- en: '**12'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: STEALING AND CRACKING PASSWORDS**
  prefs: []
  type: TYPE_NORMAL
- en: '*For the want of a nail the shoe was lost, For the want of a shoe the horse
    was lost, For the want of a horse the rider was lost, For the want of a rider
    the battle was lost, For the want of a battle the kingdom was lost, And all for
    the want of a horseshoe-nail.*'
  prefs: []
  type: TYPE_NORMAL
- en: –Benjamin Franklin
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/common.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Hackers often compromise websites and APIs by finding ways to inject their own
    code. This chapter will introduce you to one of these techniques, called SQL injection,
    and you will use it to extract a database of usernames and passwords from a web
    server. As a security measure, servers often store hashes of the passwords instead
    of plaintext passwords. We’ll explore multiple ways of cracking these hashes to
    recover the original text, and then use tools to automate the process of logging
    into a service with each stolen username-password pair.
  prefs: []
  type: TYPE_NORMAL
- en: In the process, you’ll learn a little bit about how hash functions work and
    how browsers craft HTTP requests.
  prefs: []
  type: TYPE_NORMAL
- en: '**SQL Injection**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*SQL injection* vulnerabilities occur when developers incorrectly process user
    input and use it to generate *structured query language (SQL)* queries. SQL is
    a programming language used to add, retrieve, or change information in a database.
    For example, in a database that stores users’ personal information, the following
    query might return the first and last name of the user whose social security number
    is 555-55-5555 (this number is fake):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: A complete introduction to SQL syntax is beyond the scope of this book, but
    SQL databases are essentially organized into tables, each of which consists of
    columns and rows. Each column has a name (such as `firstname`) and type (such
    as `TEXT`).
  prefs: []
  type: TYPE_NORMAL
- en: 'The query shown here, called a `SELECT` query, is designed to retrieve data
    from a table. `SELECT` queries have three parts, called *clauses*: `SELECT`, `FROM`,
    and `WHERE`. The `SELECT` clause specifies the list of columns you’d like to retrieve.
    In this example, we’re retrieving the `firstname` and `lastname` columns. The
    `FROM` clause specifies the name of the table from which we’ll retrieve the data.
    Lastly, the `WHERE` clause specifies the attributes of the rows we want to retrieve.
    For example, `WHERE SSN=''555-55-5555''` will retrieve rows that have the value
    `''555-55-5555''` in their `SSN` column.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Of course, programmers rarely write these queries manually. Instead, they write
    programs that can generate these queries whenever needed. Thus, to allow for more
    generic queries, a programmer might replace the hardcoded social security number
    with a variable such as `$id`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Replacing the fixed value with a variable allows a program to easily fill in
    missing information to generate queries. The query will now return the first and
    last names of records associated with any `$id` value the user supplies. You may
    find queries like these embedded within all sorts of apps. For example, a customer
    service agent might retrieve someone’s information by entering their social security
    number into the text box in a banking app.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, because the program inserts the social security number directly into
    the SQL query, attackers can use the text box to insert any value they’d like
    to query, including their own SQL commands, instead of the string the command
    expects. For example, imagine an attacker enters the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The web app will replace the `$id$` value with the hacker’s entry, and because
    the entry contains SQL code, the database will execute the following query.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: This query selects the `firstname` and `lastname` fields from the `Users` table
    if the user’s `SSN` field is empty. The `UNION` command then joins this value
    with the second query’s result, which the attacker supplied as user input. This
    query returns the usernames and passwords for all entries given that they all
    match the requirement (`'1' = '1'` is always true).
  prefs: []
  type: TYPE_NORMAL
- en: Notice how carefully crafted the injected SQL command is. In particular, it
    starts and ends with a single quote (`'`). This is necessary because the SQL database
    will execute only valid queries, so we must ensure that it remains valid even
    after the injection. By including `'` before the `UNION` keyword, we close the
    previous query. Later we include another `'` at the end of the injected command
    to ensure that the trailing quotation mark left over from the original query is
    closed.
  prefs: []
  type: TYPE_NORMAL
- en: SQL injection belongs to a broader class of attacks called *injection* attacks,
    in which attackers rely on user input to sneak their code into an application.
    Many web apps sanitize input to remove characters associated with injection attacks.
    For instance, they might replace quote characters ( `'` ) with `\'`, a process
    called *escaping*. This means that you often must craft your injections cleverly.
    The Open Web Application Security Project (OWASP) has a cheat sheet on ways to
    prevent injection attacks at *[https://cheatsheetseries.owasp.org/cheatsheets/Injection_Prevention_Cheat_Sheet.html](https://cheatsheetseries.owasp.org/cheatsheets/Injection_Prevention_Cheat_Sheet.html)*.
  prefs: []
  type: TYPE_NORMAL
- en: '**Stealing Passwords from a Website’s Database**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To practice performing SQL injection, activate the *Mutillidae* web app on
    your Metasploitable virtual machine. Adrian Crenshaw and Jeremy Druin designed
    Mutillidae to showcase common web vulnerabilities, and it comes preinstalled on
    your Metasploitable server. However, you must configure it first. Log in to Metasploitable
    with the username **msfadmin** and password **msfadmin**, and then edit the *config.inc*
    file, which you can access with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Change the `$dbname$` variable ➊ from `metasploitable` to `owasp10`. This directs
    Mutillidae to use the vulnerable owasp10 database instead of the Metasploitable
    database.
  prefs: []
  type: TYPE_NORMAL
- en: '***Enumerating Reachable Files on the Web Server***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Configuration files like the one you just edited often store the usernames
    and passwords that web apps need to communicate with a database or other backend
    services. If these files have incorrect access permissions, an attacker could
    read them and extract credentials. For example, WordPress websites store database
    credentials in the *wp-config.php* file. Suppose this file had incorrect access
    permissions, making it publicly available. In that case, anyone on the internet
    could read it by entering the following URL in their web browser: *http://<Word-press-url>/wp-config.php*.'
  prefs: []
  type: TYPE_NORMAL
- en: 'If you don’t already know the name of the file you’re looking for, or want
    to check for the existence of multiple possible files, you can use tools like
    `dirb` to list files in a website’s directory. This tool attempts to find the
    web directory’s files using a list of preselected words to generate possible URLs.
    It takes a list of preselected keywords like `wp-config.php`, `config.in`, and
    `config.php`, and checks if those files are readable by generating and attempting
    to access the following URLs:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: If a page doesn’t exist on the server, it will return a 404 error. However,
    if a page exists, the tool adds it to the list of reachable pages. Attacks that
    use lists of preselected words are often called *dictionary-based attacks*. This
    attack pattern is common, and we’ll see it used again later in the chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can execute this dictionary-based directory-listing attack against the
    Metasploitable server by opening a terminal on your Kali Linux virtual machine
    and running the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '***Performing SQL Injection***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Now open a web browser on your Kali Linux machine and navigate to the Mutillidae
    web app at *http://<METASPLOITABLE-IP>/mutillidae/*.
  prefs: []
  type: TYPE_NORMAL
- en: Mutillidae is intentionally vulnerable, so it includes multiple common vulnerabilities.
    Click **OWASP Top 10** ▶ **Injection** ▶ **SQLi Extract Data** ▶ **User Info**.
    You should see the login screen shown in [Figure 12-1](ch12.xhtml#ch12fig1).
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/ch12fig01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 12-1: Mutillidae login screen*'
  prefs: []
  type: TYPE_NORMAL
- en: OWASP is a web security research group that publishes an annual list of the
    year’s top 10 web vulnerabilities, nicknamed the OWASP Top 10\. (If you plan on
    auditing websites, it’s a good idea to read this list and familiarize yourself
    with these vulnerabilities.) Also check that the security level of your app is
    set to level 0, which disables Mutillidae’s defense.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now it’s time to test your SQL injection skills. Before reading ahead, try
    generating a SQL injection query of your own that extracts all the usernames and
    passwords from the site’s database. Enter your queries in the password field on
    the login page. As you test different injected queries, look at the error messages
    Mutillidae generates. Reading these error messages will help you hone your query.
    For example, you might write a query that tries to read the `users` table. However,
    if this table doesn’t exist, you’ll get the following message:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: You won’t always be this lucky; some systems only generate generic error messages.
    Injection attacks that succeed against these systems are often called *blind injection
    attacks* because attackers can’t immediately see whether they failed. To get around
    this limitation, attackers often rely on discrepancies in query execution time
    to determine if it executed correctly.
  prefs: []
  type: TYPE_NORMAL
- en: 'After you’ve practiced trying your own queries, try querying the `accounts`
    table. The following injection code should extract the usernames and passwords
    of the 16 users in the database:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, the injected query was successfully unioned with the result
    of the existing query, which allowed you to extract all the fields from the `accounts`
    table. I’ve opted to show only a portion of the data returned.
  prefs: []
  type: TYPE_NORMAL
- en: '**Writing Your Own SQL Injection Tool**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: After you’ve gotten the hang of the mechanisms of SQL injection, try writing
    a Python program to automate the injection process. Our program will simulate
    submitting the website’s login form by emulating the HTTP request sent by the
    browser; therefore, this project will require basic knowledge of how the HTTP
    protocol works. So let’s start by discussing HTTP.
  prefs: []
  type: TYPE_NORMAL
- en: '***Understanding HTTP Requests***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Whenever a user interacts with a website, their browser transforms their action
    into an *httP request* and sends it to the web server. An HTTP request contains
    the name of the resource the user is requesting and data the user is sending to
    the server. The server responds with *httP response* messages containing the HTML
    or binary data that the user requested. These responses are then parsed and displayed
    to the user.
  prefs: []
  type: TYPE_NORMAL
- en: To generate an HTTP request, you’ll first need to understand their structure.
    For accuracy, let’s use Wireshark to capture and inspect the exact HTTP request
    your browser generates when you submit the Mutillidae login form with the username
    “test” and password “abcd.” (Return to [Chapter 3](ch03.xhtml#ch3) for a refresher
    on monitoring traffic with Wireshark.)
  prefs: []
  type: TYPE_NORMAL
- en: 'Start monitoring the Ethernet (`eth0`) interface and then submit the login
    form to generate the request. Once submitted, use a filter to select packets containing
    the Metasploitable server’s IP and then select the **follow stream** option. Your
    request should look something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, the HTTP request has multiple fields. The first field ➊ represents
    the type of request being sent. Web forms commonly use either `GET` or `POST`
    requests. A `GET` request encodes the user’s input data in the URL as *query string
    parameters*, which are variables included at the end of a URL ➋. The `?` operator
    denotes the beginning of the query string parameters, and each parameter is separated
    by a `&` operator. In this request, the username and password values are included
    as query string parameters in the request sent to the server. However, if a form
    uses a `POST` request, the user’s data is placed in the request’s body, which,
    if present, would appear at ➍.
  prefs: []
  type: TYPE_NORMAL
- en: 'To determine whether a form will generate a `GET` or `POST` request without
    submitting it, you can inspect a page’s source code by right-clicking the page
    and selecting **View Page Source**. A quick search for the `method=` keyword should
    return the code for the form. For example, the Mutillidae login form’s code looks
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: This tells us the form will generate a `GET` request.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s continue looking at the HTTP request. The next header, `HOST`, identifies
    the web server to which you’re sending the request. In this case, `192.168.1.101`
    is the IP address of the server containing the page. The `User-Agent` header identifies
    the browser. Here, I have used the Mozilla Firefox browser on a `64-bit` Linux
    machine. Next, the `Accept` field specifies the format, language, and compression
    (encoding) types the browser accepts.
  prefs: []
  type: TYPE_NORMAL
- en: The `Referer` field contains the previous page you visited before navigating
    to the current page. Many websites log this value to identify the source of their
    traffic. (Although some fields, like `HOST`, are required, other fields, like
    `Referer`, are optional. Thus, you might not see them in other requests.) The
    `Connection` field specifies the connection type, and the `keep-alive` option
    instructs the server to keep the TCP connection open, allowing it to accept multiple
    requests.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `Cookie` field ➌ contains any cookies that the server has sent to the browser.
    The HTTP protocol is stateless, meaning it assumes that each request is made independently
    of all others. Therefore, the protocol doesn’t remember any previous requests
    you sent. That’s why the `Cookie` field lets programs like web servers track and
    collate a user’s interaction with the site even if the protocol doesn’t. When
    a user first visits a website, the server might assign that user a unique number
    to serve as a cookie. The server uses this unique number to authenticate the user
    and correctly process their web requests, as it will assume all HTTP requests
    that contain the same cookie belong to the same user. Each time the user sends
    a web request, the browser checks the cookie value. It’s like saying, “Hey web
    server, remember me? Here is the ID you gave me: `PHPSESSID=3e726056cf963b43bd87036e378d07be`”.
    If an attacker steals this cookie, they may be able to impersonate a victim and
    access their web sessions.'
  prefs: []
  type: TYPE_NORMAL
- en: The final `Upgrade-Insecure-Requests` field asks the web server to upgrade the
    connection to an encrypted HTTPS connection if possible. (This packet was captured
    from an unencrypted connection with the Metasploitable server.) Now that we have
    seen that Mutillidae’s credentials are sent to the server in query string parameters,
    we will inject our SQL payload in the same way.
  prefs: []
  type: TYPE_NORMAL
- en: '***Writing the Injection Program***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Our Python program will send an HTTP request similar to the one we just reviewed,
    except that it will contain our SQL injection payload as a query parameter. Create
    a new Desktop folder called *injections* on your Kali Linux machine. Create a
    new file called *sql_injection.py* in that folder and then copy the following
    into it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: We define a function called `get_request()` that returns an HTTP request containing
    the information we pass in as parameters. We replace the query parameter’s value
    with the SQL injection query ➊. We must encode the query because we’re injecting
    it directly into the URL, which can’t contain spaces or certain special characters.
    The `urllib` library URL-encodes our SQL injection query before adding it to the
    URL. This encoding process will, for example, convert all spaces to the character
    sequence `%20`.
  prefs: []
  type: TYPE_NORMAL
- en: When we’ve provided it with all the variables, the function will return the
    HTTP request, which we’ll send through a TCP socket ➌. Although not necessary,
    consider using the `argparse` library ➋ to parse the command line arguments. This
    will add a professional touch to your command line tools. The `argparse` library
    allows you to add custom flags and a help menu.
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the following command to test your new SQL injection tool:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: The script prints the request and the server’s HTML response. The preceding
    example shows a snippet of the HTML response, which contains the username and
    password pairs. A great way to debug your script is to capture requests and responses
    in Wireshark.
  prefs: []
  type: TYPE_NORMAL
- en: '**Using SQLMap**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We just built our own SQL injection tool, but existing tools can do much more
    than ours. One of the most popular SQL injections tools, called *SQLmap*, can
    automate the process of discovering and exploiting SQL injection vulnerabilities.
    Let’s perform another injection attack on the Mutillidae web app. Open a new terminal
    in Kali Linux and run the following command to start the SQLmap shell (it should
    be preinstalled on Kali Linux):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: The `-u` option specifies the URL of the web pages we’re targeting. Here we
    passed it the Mutillidae login page we attacked earlier in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'Within the shell, enter `--dbs`. This will list all databases on the system:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: '`SQLmap` first connects to the server and gets a fresh cookie ➊. Then, it uses
    the payload `'' OR NOT 6675=6675#` ➋ to test whether the query string parameter
    is vulnerable to SQL injection. Here, the `#` comments out the remainder of the
    SQL query. Lastly, `SQLmap` injects a query that returns list of databases on
    the server ➌. You can see that there are seven databases.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we know this database server is hosting several databases. Let’s focus
    on exploring the owasp10 database ➍, which is the one we’ve been attacking. Run
    the following command to list all of this database’s tables. The `-D` flag lets
    you select a particular database and `--tables` lists all of its tables:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'This command returned six tables. The table `accounts` looks particularly interesting
    as it sounds like it might contain user information. Let’s view its contents.
    Use the `-T` flag to select a specific table and the `--dump` option to dump (display)
    the table’s contents to the terminal. If you don’t include the `--dump` option,
    SQLmap will write the table’s contents to a file, instead:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'The output shows the data contained in the accounts table. There are five columns:
    `cid`, `is_admin`, `username`, `password`, and `mysignature`. There are also 16
    rows of data. I snipped the top rows to save space.'
  prefs: []
  type: TYPE_NORMAL
- en: You might think developers could have protected these passwords by encrypting
    them. The engineering team at Adobe thought they could protect passwords this
    way, too. But what happens if someone steals your encryption key, or simply guesses
    it? As part of the Adobe password breach in 2013, hackers stole and decrypted
    more than 150 million usernames and passwords.
  prefs: []
  type: TYPE_NORMAL
- en: Ideally, websites should store passwords in a form that makes it infeasible
    for either admins or attackers to recover the plaintext password. Instead of encrypting
    passwords, software developers often use a one-way function like a hash. In the
    next section, we’ll look at hash functions and discuss how hackers crack them.
    I’ll explain why you should select long passwords with uppercase and lowercase
    letters and symbols.
  prefs: []
  type: TYPE_NORMAL
- en: Keep the SQLmap terminal open; you’ll use it in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: '**Hashing Passwords**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We introduced hashes and hash functions in [Chapter 6](ch06.xhtml#ch6), and
    although we didn’t discuss them in detail, they’re very useful. Instead of storing
    plaintext passwords, database administrators often store a hash of the passwords
    to provide additional security. It’s worth taking a closer look at some fundamental
    properties of hash functions and how hackers can crack them.
  prefs: []
  type: TYPE_NORMAL
- en: The first property of a hash function is that it is a *one-way function*. This
    means that, given the output, it is infeasible to find the input. You can think
    of hash functions as being analogous to a digital blender. Once a message is blended,
    it’s impossible to recover the original message from the blended results. [Figure
    12-2](ch12.xhtml#ch12fig2) shows the results of hashing two strings.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/ch12fig02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 12-2: The hashes of two strings*'
  prefs: []
  type: TYPE_NORMAL
- en: The second important property of hashes is that it’s time consuming to find
    two inputs that hash to the same output. By time consuming, I mean that when the
    hash function is secure, it would take longer than the universe’s age to find
    two inputs that hash to the same value. If two inputs hash to the same value,
    this is called a *collision*. We estimate it will take 36 trillion years to find
    a collision for the SHA-256 hash function. To put this number in perspective,
    the universe is only 13.8 billion years old.
  prefs: []
  type: TYPE_NORMAL
- en: 'Because collisions are so rare, developers often treat a message’s hash as
    its digital fingerprint: a unique identifier of that message. This is why system
    administrators can use hashes to represent passwords without storing the original
    password. If a user logs into a system, their password is hashed and compared
    to the hash in the database. The plaintext password is never stored.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The third property of a hash function is that, regardless of the input size,
    it always produces a fixed-size output. Long and short passwords will result in
    hashes of the same length. (You might already be wondering: Why do we need long
    passwords if all hashes are the same length? It’s because longer passwords are
    still more difficult to crack. To see why, skip ahead to the “Cracking Hashes”
    section of this chapter.)'
  prefs: []
  type: TYPE_NORMAL
- en: '***The Anatomy of the MD5 Hash***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: If you’re curious about hash function design, here is a brief discussion on
    the MD5 hash function’s inner workings. Let’s look at the heart of our blender.
  prefs: []
  type: TYPE_NORMAL
- en: The MD5 hash function operates on 512-bit blocks. The first 448 bits of this
    block contain the message that is being hashed, and the last 64 bits are the message’s
    length. If the message is shorter, the bits are padded with a one followed by
    zeros. If the message is longer than 448 bits, it is split into multiple blocks.
    [Figure 12-3](ch12.xhtml#ch12fig3) shows how these 512 bits are then scrambled.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/ch12fig03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 12-3: The building blocks of the MD5 hash*'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, a 128-bit random number (a nonce) is used the create an initialization
    vector. The 128-bit initialization vector is then divided into four 32-bit blocks:
    *A*, *B*, *C*, and *D*. The mixing process begins by using a function (labeled
    *F* in [Figure 12-3](ch12.xhtml#ch12fig3)) that combines the random values of
    *B*, *C*, and *D* to produce another 32-bit value. The formula for *F* is shown
    here:'
  prefs: []
  type: TYPE_NORMAL
- en: '*F*(*B*, *C*, *D*) = (*B* **and** *C*) **or** (( **not** *B*) **and** *D*)'
  prefs: []
  type: TYPE_NORMAL
- en: 'The output of this function gets fed to a function *K*, which combines it with
    32 bits of the original message (*M[i]*), a 32-bit constant (*T[i]*), and the
    32 bits in *A*. The *i* value represents a specific iteration. Only 32 bits of
    the 512-bit message are processed at a time. Following is the formula for the
    function *K*:'
  prefs: []
  type: TYPE_NORMAL
- en: '*K*(*B*, *M*, *T*, *A*, *F*) = *B* ⊞ ((*A* ⊞ *F* ⊞ *M[i]* ⊞ *T[i]*) <<< *s[i]*)'
  prefs: []
  type: TYPE_NORMAL
- en: The ⊞ symbols represent modulo addition, which is equivalent to adding two numbers
    and then computing the result modulo of some number *n*. If *n* is 7, then 6 ⊞
    3 is 2\. The <<< symbol represents a circular left shift and *s[i]* represents
    the shift amount. The output of function *K* is used to override the value of
    the *A* block, and the blocks are rearranged by performing a circular right shift,
    as shown in [Figure 12-3](ch12.xhtml#ch12fig3). The resulting 128 bits are then
    fed back into the whole system for a total of 16 iterations, one for each 32-bit
    segment in the original 512-bit message (16 *×* 32 = 512).
  prefs: []
  type: TYPE_NORMAL
- en: The block described here is just one of the four blocks used by the MD5 hash
    function. The data pass through all four blocks in a given round. [Figure 12-4](ch12.xhtml#ch12fig4)
    shows how all four blocks are combined.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/ch12fig04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 12-4: Combining the four blocks of the MD5 algorithm*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Each block follows the same general structure. The only exception is that each
    block uses a specific function. These functions are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '*H*(*B*, *C*, *D*) = *B* **xor** *C* **xor** *D*'
  prefs: []
  type: TYPE_NORMAL
- en: '*G*(*B*, *C*, *D*) = (*B* **and** *D*) **or** (*C* **and** ( **not** *D*))'
  prefs: []
  type: TYPE_NORMAL
- en: '*I*(*B*, *C*, *D*) = *C* **xor** (*B* **or** ( **not** *D*))'
  prefs: []
  type: TYPE_NORMAL
- en: 'If the message is longer that 448 bits, the initialization vector of the next
    block is calculated by computing block *I*’s output chunks: *A*, *B*, *C*, and
    *D* addition modulo 32 the chunks of the original initialization vector. The final
    128-bit Initialization vector is the MD5 hash.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Even after all this mixing, in 1993, Antoon Bosselaers and Bert den Boer discovered
    that MD5 doesn’t meet the no-collision property of hashes, because it’s possible
    to generate two messages with the same hash. Because of this, the MD5 algorithm
    is no longer secure and shouldn’t be used when building cryptographic systems.
    Not to worry: other hash algorithms such as SHA-256, SHA-512, and SHA-3 are still
    considered secure. [Figure 12-5](ch12.xhtml#ch12fig5) shows the general architecture
    of the SHA-256 hash function. The C function represents the compression function,
    which can be described using a similar diagram and language as [Figure 12-3](ch12.xhtml#ch12fig3).'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/ch12fig05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 12-5: The SHA-256 hash function*'
  prefs: []
  type: TYPE_NORMAL
- en: '***Cracking Hashes***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: How can we crack a password hash to recover the original password? Secure hash
    functions are one-way functions, so we can’t directly reverse engineer the hash.
    But all is not lost; we just have to be clever.
  prefs: []
  type: TYPE_NORMAL
- en: Recall that each password will generate a unique hash, so two matching hashes
    must share the same plaintext password. Therefore, if we want to crack a specific
    hash, we should compute the hash of many known passwords and compare the resulting
    hashes to our original hash. If we find a match, the plaintext password we just
    hashed must be the same as the plaintext password of the hash we’re trying to
    crack. This type of attack is called a dictionary-based attack, and it’s the same
    strategy we used earlier to discover files on a server. Let’s use a dictionary-based
    attack to crack some of the password hashes in the database on the Metasploitable
    virtual machine.
  prefs: []
  type: TYPE_NORMAL
- en: 'Reopen the terminal containing the SQLmap session and use the following command
    to dump the usernames and passwords from the user table in the Damn Vulnerable
    Web App (DVWA) database. This SQLmap command will perform a dictionary-based attack
    to try to crack the password hashes in the database:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: In this case, the dictionary-based attack was able to crack all the passwords
    in the dictionary.
  prefs: []
  type: TYPE_NORMAL
- en: Of course, dictionary-based attacks will succeed only if the passwords in the
    database are also in the predefined list of passwords. A good password list is
    critical to the hash cracking process. *SecLists*, an excellent collection of
    security lists, contains several password lists that you can use for your dictionary-based
    attacks. For example, the *10-million-password-list-top-1000000.txt* contains
    a whopping one million passwords. SecLists also has password lists in other languages,
    such as French, Dutch, and German. The SecLists collection contains payloads like
    zipbombs and webshells, and entries that can be used as test data in fuzzing attacks.
    *Zipbombs* are small, compressed files that become really large when decompressed.
    You could make your own zipbomb by compressing a large file containing zeros.
    *Webshells* are shells that allow you to control a server from a web page.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can clone the SecLists Git repository to your Kali Linux desktop by running
    the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: '***Salting Hashes with a Nonce***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: If two users have the same password, both passwords will produce the same hash.
    This leaks information because it allows a hacker with access to the database
    to know that two users have the same password. Also, as you just discovered, hackers
    can figure out the value of a password if they happen to hash the same text. For
    this reason, developers often prepend a nonce to a password before hashing it.
    This nonce is commonly called a *salt*. The salt is prepended to the password
    and the resulting string is hashed and stored in the database. The original salt
    is also stored in a separate column.
  prefs: []
  type: TYPE_NORMAL
- en: '**Building a Salted Hash Cracker**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'It’s time to write our own hash cracking tool. Our hash cracker will prepend
    the salt pulled from a database to a plaintext password and compute the hash of
    the result. It will then compare the resulting hash to the hash being cracked.
    We’ll repeat this process for each password in the dictionary until a match is
    found. Create a new file called *myHashCracker.py* in the *HashCrack* folder on
    your Kali Linux desktop and copy the following into it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: This program will loop through all the passwords in the supplied dictionary
    ➊ and compute the hash of the salt and password combined. If the result matches
    the supplied hash, the program will return the plaintext password ➋. However,
    if the hash doesn’t match, it will try the next password in the dictionary. The
    process will continue until until a match is found or until every password in
    the dictionary has been checked. If no match is found, the program will return
    `None`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the Python script to crack the hash, which we hardcoded in our script ➌:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Once the script completes, it should print out the password `trustno1`.
  prefs: []
  type: TYPE_NORMAL
- en: '**Popular Hash Cracking and Brute-Forcing Tools**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Other hackers have already built some useful hash cracking tools, many of which
    come preinstalled on Kali Linux. For example, *John the Ripper* is a large community
    project that can crack multiple types of hashes.
  prefs: []
  type: TYPE_NORMAL
- en: '***John the Ripper***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Let’s use John the Ripper to crack the following hash, which you should save
    to a text file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Run the following command to start to start the cracking process.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'When the process completes, you can run the following command to view the list
    of cracked passwords:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: '***Hashcat***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Another useful hash cracking tool, *Hashcat*, includes optimizations that allow
    you to perform dictionary attacks more rapidly. For example, Hashcat parallelizes
    the process so that the software can take advantage of special hardware like *Graphics
    Processing Units (GPUs)* that can run many operations simultaneously.
  prefs: []
  type: TYPE_NORMAL
- en: However, because of these optimizations, running Hashcat in a virtual machine
    may result in an illegal instruction error. Therefore, you’ll need to install
    and run it outside of your virtual lab environment. It’s common practice among
    serious hackers to build special password-cracking machines with powerful processors
    and GPUs.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s use Hashcat to crack the *hashes.txt* file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'The `-a` flag represents the attack mode, or strategy, used to crack the hash.
    You can view possible attack modes by using the `**--help**` flag:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Option `0`, `Straight` mode (the mode we’ve used here), simply tries each word
    in the dictionary until it finds a match. Option `1`, `Combination` mode, tries
    multiple combinations of different words. For example, it might combine the password
    *fire* with the password *walker1* to produce the password *firewalker1*. Option
    `3`, `Brute-force` mode, will try every possible combination until it discovers
    the password. For example, the tool might try the values *a*, *aa*, *ab*, and
    so on.
  prefs: []
  type: TYPE_NORMAL
- en: To reduce the number of combinations Hashcat must test, you can supply a mask.
    A *mask* is a pattern that defines the password’s structure. For example, the
    pattern `?u?l?l?d?s` specifies a five-letter password. The `?u` indicates that
    the password starts with an uppercase letter. This uppercase letter is followed
    by two lowercase letters (`?l`) and the pattern ends with a digit (`?d`) followed
    by a symbol (`?s`). As a result, this mask might test the password `Bas5!`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `-m` (or mode) option represents the algorithm used to create the hash.
    You can view a complete list of available modes by running `hash -h` in the terminal.
    The following is a snippet of some of the available modes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Mode `1400` represents a hash calculated using the SHA2-256 algorithm ➊, whereas
    mode `1420` represents a hashing algorithm that first appends a salt to password
    before running it through SHA2-256 ➋. A hashing algorithm can run for multiple
    iterations, using the output of each previous run as input for the next one. For
    example, mode `2600 md5(md5($pass))` computes the MD5 hash twice. This iteration
    value is normally stored in the database. Hashcat supports a fixed number of iterations
    with its predefined modes, but tools like *MDXfind* support an arbitrary number
    of iterations. The best way to store passwords is to salt them and then hash them
    for multiple iterations with a secure hash function like SHA-3, or better yet,
    a memory-hard function like scrypt or Argon 2i.
  prefs: []
  type: TYPE_NORMAL
- en: '***Hydra***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: After you’ve recovered usernames and passwords, what can you do with them? You
    could try to use them to log in to services like FTP or SSH. Here, we look at
    *Hydra*, an invaluable tool that automates the process of attempting to log in
    to a service using username and password pairs from a list.
  prefs: []
  type: TYPE_NORMAL
- en: 'Practice using Hydra to break into your Metasploitable virtual machine through
    its FTP server. FTP allows users to upload files to a server. You can use the
    default usernames and passwords in the *ftp-betterdefaultpasslist.txt* list, which
    is a part of SecLists. The following is a copy of the complete list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Files in SecLists aren’t always this short. In fact, the FTP default password
    list is one of shortest lists in the SecLists collection, which makes it a great
    candidate for demonstrating this type of attack. The longer the list, the more
    time it will take to run.
  prefs: []
  type: TYPE_NORMAL
- en: 'Run Hydra using the following command; the IP address `192.168.1.101` represents
    the IP address of the Metasploitable server:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: The output shows three FTP accounts on the server that are using default login
    credentials. Now you could use the FTP server to, for example, upload an implant.
    Try a similar approach to access SSH accounts.
  prefs: []
  type: TYPE_NORMAL
- en: '**Exercises**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: These exercises will broaden your understanding of the ideas discussed in this
    chapter. In the first exercise, we’ll discuss NoSQL injection techniques. Then,
    we’ll examine how you can use tools like Hydra to automate the process of brute
    forcing passwords. We’ll conclude by discussing Burp Suite and its proxy, which
    allow you to intercept and modify web requests and responses.
  prefs: []
  type: TYPE_NORMAL
- en: '***NoSQL Injection***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: NoSQL databases are an alternative to databases that use SQL. Instead of storing
    data in tables, these databases store data in objects called documents, which
    are organized into collections. There is no standard query language for NoSQL
    databases, hence the name. Instead, each NoSQL platform (which includes MongoDB
    and Firebase) uses its own syntax and protocol. For this reason, programmers often
    rely on libraries to interface with these systems.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s look at an example of a Python library that interfaces with the MongoDB
    NoSQL database. The following Python program takes a social security number `POST`-ed
    by an HTTP form and uses the `pymongo` Python library to query a MongoDB database:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'We connect to the MongoDB database running on port `27017` ➊. (Default installations
    of MongoDB aren’t password protected.) Next, we select the database we want to
    query ➋. Then, we define a function called `getUserInfo` ➌. This function takes
    the social security number from the form’s `POST` request and uses it to query
    the customer collection for the users information at ➍. MongoDB queries are represented
    as key–value pairs with the following syntax: `collection.find({"key":"value"})`.
    In `{"SSN": "+post_ssn+""}`, the social security number is the value in the `SSN`
    field posted from the form (`post_ssn`).'
  prefs: []
  type: TYPE_NORMAL
- en: 'As we did with SQL databases, we can inject information into the NoSQL database
    that changes the meaning of the query. For example, imagine we provided the following
    input to the `POST` form: `{$ne: ""}`. This would result in the following query:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: The `ne` operator means *not equal to* in MongoDB, so the query now returns
    all data for users whose `SSN` field isn’t empty.
  prefs: []
  type: TYPE_NORMAL
- en: In addition to reading data, you could also inject your own data, or even code,
    into the database. Tools like to *NoSQLMap* automate the process of exploiting
    NoSQL databases. You can obtain a copy of NoSQLMap by visiting its GitHub page
    at *[https://github.com/codingo/NoSQLMap/](https://github.com/codingo/NoSQLMap/)*.
    Practice using it to see what you can uncover.
  prefs: []
  type: TYPE_NORMAL
- en: '***Brute-Forcing Web Logins***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In this chapter, we used dictionary-based attacks to crack a hash and log in
    to an FTP server. You can also use dictionary-based attacks to log in to a web
    app by trying all the usernames and passwords in some list. You might try achieving
    this by submitting multiple HTTP requests containing user login data.
  prefs: []
  type: TYPE_NORMAL
- en: 'Hydra makes it possible for you to automate this process. Run the following
    command to send HTTP requests that contain the usernames and passwords in *darkweb2017-top100.txt*
    to the login form in Mutillidae:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: First, specify the URL of the web app. Hydra uses colons to separate options.
    Next, specify the query string parameters that contain the data the user entered.
    Here, we submit multiple requests with different values for the username and password
    parameters. Use the (`^USER^`) and (`^PASS^`) placeholders to indicate where Hydra
    should insert the username and password in the URL. Lastly, you must specify the
    error message that will be contained in the HTTP response if the login attempt
    fails.
  prefs: []
  type: TYPE_NORMAL
- en: Run the command to see what usernames and passwords Hydra discovers. After you’ve
    had some practice with Hydra, see if you can gain access to the PostgreSQL server
    on the Metasploit machine.
  prefs: []
  type: TYPE_NORMAL
- en: '***Burp Suite***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Injection attacks frequently require that you modify HTTP requests. Let’s try
    using a tool that makes this process easier. The free community edition of Burp
    Suite provides a GUI that allows you to quickly modify HTTP requests and responses
    sent and received by your browser. This is possible because Burp Suite acts as
    a proxy between the browser and the server. Each HTTP message your browser sends
    or receives first passes through Burp Suite.
  prefs: []
  type: TYPE_NORMAL
- en: By default, the browser on Kali Linux isn’t configured to send web requests
    through a proxy, but you can configure Firefox to use your proxy by opening its
    preferences and searching for **Network Settings** ([Figure 12-6](ch12.xhtml#ch12fig6)).
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/ch12fig06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 12-6: Configuring the Firefox setting that will route traffic through
    Burp Suite*'
  prefs: []
  type: TYPE_NORMAL
- en: Once you’ve configured the browser, generate some web traffic by visiting *[http://cs.virginia.edu/](http://cs.virginia.edu/)*.
    Burp Suite will intercept the request and you can view it by clicking the **Proxy**
    and **Intercept** tabs, at 1 and 2, respectively, in [Figure 12-7](ch12.xhtml#ch12fig7).
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/ch12fig07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 12-7: Burp Suite’s capture of the HTTP request for* cs.virginia.edu'
  prefs: []
  type: TYPE_NORMAL
- en: After Burp Suite has captured a request, you can modify it or forward it to
    the web server unchanged. You can also send the request or response to another
    Burp Suite tab for future analysis. Explore Burp Suite to become familiar with
    using its features and then try modifying an HTTP request to execute a basic SQL
    injection attack.
  prefs: []
  type: TYPE_NORMAL
