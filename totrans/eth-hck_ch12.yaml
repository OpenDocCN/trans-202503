- en: '**12'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '**12'
- en: STEALING AND CRACKING PASSWORDS**
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '**窃取和破解密码**'
- en: '*For the want of a nail the shoe was lost, For the want of a shoe the horse
    was lost, For the want of a horse the rider was lost, For the want of a rider
    the battle was lost, For the want of a battle the kingdom was lost, And all for
    the want of a horseshoe-nail.*'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: '*缺一枚钉子，失一只鞋，缺一只鞋，失一匹马，缺一匹马，失一骑士，缺一骑士，失一场战斗，缺一场战斗，失一整个王国，所有的一切都是因为缺少一枚马蹄钉。*'
- en: –Benjamin Franklin
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: –本杰明·富兰克林
- en: '![image](../images/common.jpg)'
  id: totrans-4
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/common.jpg)'
- en: Hackers often compromise websites and APIs by finding ways to inject their own
    code. This chapter will introduce you to one of these techniques, called SQL injection,
    and you will use it to extract a database of usernames and passwords from a web
    server. As a security measure, servers often store hashes of the passwords instead
    of plaintext passwords. We’ll explore multiple ways of cracking these hashes to
    recover the original text, and then use tools to automate the process of logging
    into a service with each stolen username-password pair.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 黑客常通过找到注入自己代码的方法来攻破网站和API。本章将向你介绍其中一种技术，称为SQL注入，你将使用它从Web服务器中提取一个包含用户名和密码的数据库。作为一种安全措施，服务器通常存储密码的哈希值，而不是明文密码。我们将探索多种破解这些哈希值的方法以恢复原文，然后使用工具自动化登录服务的过程，利用每个被窃取的用户名和密码对。
- en: In the process, you’ll learn a little bit about how hash functions work and
    how browsers craft HTTP requests.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个过程中，你将学习一些哈希函数的工作原理以及浏览器如何构造HTTP请求。
- en: '**SQL Injection**'
  id: totrans-7
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**SQL注入**'
- en: '*SQL injection* vulnerabilities occur when developers incorrectly process user
    input and use it to generate *structured query language (SQL)* queries. SQL is
    a programming language used to add, retrieve, or change information in a database.
    For example, in a database that stores users’ personal information, the following
    query might return the first and last name of the user whose social security number
    is 555-55-5555 (this number is fake):'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: '*SQL注入*漏洞发生在开发人员错误地处理用户输入并使用它生成*结构化查询语言（SQL）*查询时。SQL是一种用于在数据库中添加、检索或更改信息的编程语言。例如，在一个存储用户个人信息的数据库中，以下查询可能返回社会安全号码为555-55-5555的用户的名字和姓氏（这个号码是假的）：'
- en: '[PRE0]'
  id: totrans-9
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: A complete introduction to SQL syntax is beyond the scope of this book, but
    SQL databases are essentially organized into tables, each of which consists of
    columns and rows. Each column has a name (such as `firstname`) and type (such
    as `TEXT`).
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: SQL语法的完整介绍超出了本书的范围，但SQL数据库本质上是组织成表格的，每个表由列和行组成。每列都有一个名称（如`firstname`）和类型（如`TEXT`）。
- en: 'The query shown here, called a `SELECT` query, is designed to retrieve data
    from a table. `SELECT` queries have three parts, called *clauses*: `SELECT`, `FROM`,
    and `WHERE`. The `SELECT` clause specifies the list of columns you’d like to retrieve.
    In this example, we’re retrieving the `firstname` and `lastname` columns. The
    `FROM` clause specifies the name of the table from which we’ll retrieve the data.
    Lastly, the `WHERE` clause specifies the attributes of the rows we want to retrieve.
    For example, `WHERE SSN=''555-55-5555''` will retrieve rows that have the value
    `''555-55-5555''` in their `SSN` column.'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 这里展示的查询，称为`SELECT`查询，旨在从表中检索数据。`SELECT`查询有三个部分，称为*子句*：`SELECT`、`FROM`和`WHERE`。`SELECT`子句指定你想要检索的列的列表。在这个例子中，我们正在检索`firstname`和`lastname`列。`FROM`子句指定我们将从中检索数据的表名。最后，`WHERE`子句指定我们想要检索的行的属性。例如，`WHERE
    SSN='555-55-5555'`将检索`SSN`列中值为`'555-55-5555'`的行。
- en: 'Of course, programmers rarely write these queries manually. Instead, they write
    programs that can generate these queries whenever needed. Thus, to allow for more
    generic queries, a programmer might replace the hardcoded social security number
    with a variable such as `$id`:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，程序员很少手动编写这些查询。相反，他们编写程序，以便在需要时生成这些查询。因此，为了允许更通用的查询，程序员可能会用一个变量，如`$id`，来替代硬编码的社会安全号码：
- en: '[PRE1]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Replacing the fixed value with a variable allows a program to easily fill in
    missing information to generate queries. The query will now return the first and
    last names of records associated with any `$id` value the user supplies. You may
    find queries like these embedded within all sorts of apps. For example, a customer
    service agent might retrieve someone’s information by entering their social security
    number into the text box in a banking app.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 将固定值替换为变量使程序能够轻松填补缺失的信息以生成查询。现在，查询将返回与用户提供的任何`$id`值相关的记录的名字和姓氏。你可能会在各种应用程序中发现类似的查询。例如，客户服务代理可能会通过在银行应用程序中的文本框输入某人的社会安全号码来检索该人的信息。
- en: 'However, because the program inserts the social security number directly into
    the SQL query, attackers can use the text box to insert any value they’d like
    to query, including their own SQL commands, instead of the string the command
    expects. For example, imagine an attacker enters the following:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，由于程序将社会安全号码直接插入SQL查询，攻击者可以利用文本框插入他们想要查询的任何值，包括他们自己的SQL命令，而不是命令预期的字符串。例如，想象一个攻击者输入了以下内容：
- en: '[PRE2]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The web app will replace the `$id$` value with the hacker’s entry, and because
    the entry contains SQL code, the database will execute the following query.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: Web应用程序将用黑客的输入替换`$id$`值，并且因为输入中包含SQL代码，数据库将执行以下查询。
- en: '[PRE3]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: This query selects the `firstname` and `lastname` fields from the `Users` table
    if the user’s `SSN` field is empty. The `UNION` command then joins this value
    with the second query’s result, which the attacker supplied as user input. This
    query returns the usernames and passwords for all entries given that they all
    match the requirement (`'1' = '1'` is always true).
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 这个查询从`Users`表中选择`firstname`和`lastname`字段，如果用户的`SSN`字段为空。然后，`UNION`命令将这个值与第二个查询的结果连接起来，而第二个查询是攻击者作为用户输入提供的。这个查询返回所有条目的用户名和密码，因为它们都满足条件（`'1'
    = '1'`始终为真）。
- en: Notice how carefully crafted the injected SQL command is. In particular, it
    starts and ends with a single quote (`'`). This is necessary because the SQL database
    will execute only valid queries, so we must ensure that it remains valid even
    after the injection. By including `'` before the `UNION` keyword, we close the
    previous query. Later we include another `'` at the end of the injected command
    to ensure that the trailing quotation mark left over from the original query is
    closed.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意注入的SQL命令是多么精心构造的。特别是，它以单引号（`'`）开头并以单引号（`'`）结尾。这是必要的，因为SQL数据库只会执行有效的查询，因此我们必须确保即使注入后查询仍然有效。通过在`UNION`关键字之前包含`'`，我们关闭了先前的查询。然后，我们在注入的命令末尾再次包含一个`'`，以确保关闭原查询中遗留的尾部引号。
- en: SQL injection belongs to a broader class of attacks called *injection* attacks,
    in which attackers rely on user input to sneak their code into an application.
    Many web apps sanitize input to remove characters associated with injection attacks.
    For instance, they might replace quote characters ( `'` ) with `\'`, a process
    called *escaping*. This means that you often must craft your injections cleverly.
    The Open Web Application Security Project (OWASP) has a cheat sheet on ways to
    prevent injection attacks at *[https://cheatsheetseries.owasp.org/cheatsheets/Injection_Prevention_Cheat_Sheet.html](https://cheatsheetseries.owasp.org/cheatsheets/Injection_Prevention_Cheat_Sheet.html)*.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: SQL注入属于一种更广泛的攻击类别，称为*注入*攻击，攻击者通过依赖用户输入将他们的代码偷偷注入到应用程序中。许多Web应用程序会对输入进行过滤，以去除与注入攻击相关的字符。例如，它们可能会将引号字符（`'`）替换为`\'`，这个过程叫做*转义*。这意味着你通常需要巧妙地构造你的注入代码。开放Web应用程序安全项目（OWASP）提供了一张防止注入攻击的备忘单，地址是*[https://cheatsheetseries.owasp.org/cheatsheets/Injection_Prevention_Cheat_Sheet.html](https://cheatsheetseries.owasp.org/cheatsheets/Injection_Prevention_Cheat_Sheet.html)*。
- en: '**Stealing Passwords from a Website’s Database**'
  id: totrans-22
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**从网站数据库窃取密码**'
- en: 'To practice performing SQL injection, activate the *Mutillidae* web app on
    your Metasploitable virtual machine. Adrian Crenshaw and Jeremy Druin designed
    Mutillidae to showcase common web vulnerabilities, and it comes preinstalled on
    your Metasploitable server. However, you must configure it first. Log in to Metasploitable
    with the username **msfadmin** and password **msfadmin**, and then edit the *config.inc*
    file, which you can access with the following command:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 为了练习执行SQL注入，请在你的Metasploitable虚拟机上启用*Mutillidae* Web应用程序。Adrian Crenshaw和Jeremy
    Druin设计了Mutillidae，用于展示常见的Web漏洞，它已预装在你的Metasploitable服务器上。然而，你必须先进行配置。使用用户名**msfadmin**和密码**msfadmin**登录到Metasploitable，然后编辑*config.inc*文件，你可以通过以下命令访问该文件：
- en: '[PRE4]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Change the `$dbname$` variable ➊ from `metasploitable` to `owasp10`. This directs
    Mutillidae to use the vulnerable owasp10 database instead of the Metasploitable
    database.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 将 `$dbname$` 变量 ➊ 从 `metasploitable` 修改为 `owasp10`。这会指示 Mutillidae 使用易受攻击的 owasp10
    数据库，而不是 Metasploitable 数据库。
- en: '***Enumerating Reachable Files on the Web Server***'
  id: totrans-26
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***枚举 Web 服务器上的可访问文件***'
- en: 'Configuration files like the one you just edited often store the usernames
    and passwords that web apps need to communicate with a database or other backend
    services. If these files have incorrect access permissions, an attacker could
    read them and extract credentials. For example, WordPress websites store database
    credentials in the *wp-config.php* file. Suppose this file had incorrect access
    permissions, making it publicly available. In that case, anyone on the internet
    could read it by entering the following URL in their web browser: *http://<Word-press-url>/wp-config.php*.'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 像你刚刚编辑的配置文件通常会存储网页应用需要与数据库或其他后台服务通信的用户名和密码。如果这些文件的访问权限设置不当，攻击者可能读取它们并提取凭证。例如，WordPress
    网站将数据库凭证存储在 *wp-config.php* 文件中。假设该文件的访问权限设置不正确，使得它可以公开访问，那么任何人在互联网上都可以通过在浏览器中输入以下
    URL 来读取它：*http://<Word-press-url>/wp-config.php*。
- en: 'If you don’t already know the name of the file you’re looking for, or want
    to check for the existence of multiple possible files, you can use tools like
    `dirb` to list files in a website’s directory. This tool attempts to find the
    web directory’s files using a list of preselected words to generate possible URLs.
    It takes a list of preselected keywords like `wp-config.php`, `config.in`, and
    `config.php`, and checks if those files are readable by generating and attempting
    to access the following URLs:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不知道要查找的文件名，或者想检查多个可能存在的文件，可以使用像 `dirb` 这样的工具列出网站目录中的文件。该工具通过使用一组预选单词来生成可能的
    URL，尝试查找网页目录中的文件。它会用预选的关键词列表，如 `wp-config.php`、`config.in` 和 `config.php`，并通过生成并尝试访问以下
    URL 来检查这些文件是否可以读取：
- en: '[PRE5]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: If a page doesn’t exist on the server, it will return a 404 error. However,
    if a page exists, the tool adds it to the list of reachable pages. Attacks that
    use lists of preselected words are often called *dictionary-based attacks*. This
    attack pattern is common, and we’ll see it used again later in the chapter.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 如果服务器上不存在某个页面，它会返回 404 错误。但如果页面存在，工具会将其添加到可访问页面的列表中。使用预选单词列表的攻击通常被称为 *字典攻击*。这种攻击模式非常常见，稍后我们将在本章中再次看到它的应用。
- en: 'You can execute this dictionary-based directory-listing attack against the
    Metasploitable server by opening a terminal on your Kali Linux virtual machine
    and running the following command:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过在 Kali Linux 虚拟机上打开终端并运行以下命令，对 Metasploitable 服务器执行基于字典的目录列出攻击：
- en: '[PRE6]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '***Performing SQL Injection***'
  id: totrans-33
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***执行 SQL 注入***'
- en: Now open a web browser on your Kali Linux machine and navigate to the Mutillidae
    web app at *http://<METASPLOITABLE-IP>/mutillidae/*.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 现在在 Kali Linux 机器上打开一个网页浏览器，导航到 Mutillidae 网页应用，地址为 *http://<METASPLOITABLE-IP>/mutillidae/*。
- en: Mutillidae is intentionally vulnerable, so it includes multiple common vulnerabilities.
    Click **OWASP Top 10** ▶ **Injection** ▶ **SQLi Extract Data** ▶ **User Info**.
    You should see the login screen shown in [Figure 12-1](ch12.xhtml#ch12fig1).
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: Mutillidae 是故意脆弱的，因此它包含多个常见漏洞。点击 **OWASP Top 10** ▶ **Injection** ▶ **SQLi Extract
    Data** ▶ **User Info**。你应该能看到在[图 12-1](ch12.xhtml#ch12fig1)中显示的登录界面。
- en: '![image](../images/ch12fig01.jpg)'
  id: totrans-36
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/ch12fig01.jpg)'
- en: '*Figure 12-1: Mutillidae login screen*'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 12-1：Mutillidae 登录界面*'
- en: OWASP is a web security research group that publishes an annual list of the
    year’s top 10 web vulnerabilities, nicknamed the OWASP Top 10\. (If you plan on
    auditing websites, it’s a good idea to read this list and familiarize yourself
    with these vulnerabilities.) Also check that the security level of your app is
    set to level 0, which disables Mutillidae’s defense.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: OWASP 是一个网络安全研究小组，发布年度 Web 漏洞排名，称为 OWASP Top 10（如果你计划进行网站审计，阅读这个列表并熟悉这些漏洞是一个好主意）。还要检查你的应用的安全级别是否设置为
    0，这将禁用 Mutillidae 的防御功能。
- en: 'Now it’s time to test your SQL injection skills. Before reading ahead, try
    generating a SQL injection query of your own that extracts all the usernames and
    passwords from the site’s database. Enter your queries in the password field on
    the login page. As you test different injected queries, look at the error messages
    Mutillidae generates. Reading these error messages will help you hone your query.
    For example, you might write a query that tries to read the `users` table. However,
    if this table doesn’t exist, you’ll get the following message:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是测试你 SQL 注入技巧的时候了。在继续阅读之前，尝试生成一个你自己的 SQL 注入查询，提取站点数据库中所有的用户名和密码。在登录页面的密码字段中输入你的查询。当你测试不同的注入查询时，查看
    Mutillidae 生成的错误信息。阅读这些错误信息将帮助你磨练查询。例如，你可能会写一个查询，尝试读取 `users` 表。然而，如果该表不存在，你将看到以下信息：
- en: '[PRE7]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: You won’t always be this lucky; some systems only generate generic error messages.
    Injection attacks that succeed against these systems are often called *blind injection
    attacks* because attackers can’t immediately see whether they failed. To get around
    this limitation, attackers often rely on discrepancies in query execution time
    to determine if it executed correctly.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 你不一定每次都这么幸运；有些系统只会生成通用的错误信息。成功对这些系统进行注入攻击的攻击通常被称为 *盲注攻击*，因为攻击者无法立即看到是否失败。为了绕过这个限制，攻击者通常依赖查询执行时间的差异来判断是否正确执行。
- en: 'After you’ve practiced trying your own queries, try querying the `accounts`
    table. The following injection code should extract the usernames and passwords
    of the 16 users in the database:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在你练习过自己的查询之后，尝试查询 `accounts` 表。以下注入代码应该提取数据库中 16 个用户的用户名和密码：
- en: '[PRE8]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: As you can see, the injected query was successfully unioned with the result
    of the existing query, which allowed you to extract all the fields from the `accounts`
    table. I’ve opted to show only a portion of the data returned.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，注入的查询成功地与现有查询的结果合并，这使得你能够提取 `accounts` 表中的所有字段。我选择只展示返回数据的一部分。
- en: '**Writing Your Own SQL Injection Tool**'
  id: totrans-45
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**编写你自己的 SQL 注入工具**'
- en: After you’ve gotten the hang of the mechanisms of SQL injection, try writing
    a Python program to automate the injection process. Our program will simulate
    submitting the website’s login form by emulating the HTTP request sent by the
    browser; therefore, this project will require basic knowledge of how the HTTP
    protocol works. So let’s start by discussing HTTP.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在你掌握了 SQL 注入机制后，尝试编写一个 Python 程序来自动化注入过程。我们的程序将模拟通过模仿浏览器发送的 HTTP 请求来提交网站的登录表单；因此，这个项目将需要基本的
    HTTP 协议知识。接下来，我们先来讨论一下 HTTP。
- en: '***Understanding HTTP Requests***'
  id: totrans-47
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***理解 HTTP 请求***'
- en: Whenever a user interacts with a website, their browser transforms their action
    into an *httP request* and sends it to the web server. An HTTP request contains
    the name of the resource the user is requesting and data the user is sending to
    the server. The server responds with *httP response* messages containing the HTML
    or binary data that the user requested. These responses are then parsed and displayed
    to the user.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 每当用户与网站互动时，他们的浏览器会将他们的操作转换成 *HTTP 请求* 并发送到 Web 服务器。HTTP 请求包含用户请求的资源名称以及用户发送到服务器的数据。服务器回应
    *HTTP 响应* 消息，其中包含用户请求的 HTML 或二进制数据。这些响应随后被解析并显示给用户。
- en: To generate an HTTP request, you’ll first need to understand their structure.
    For accuracy, let’s use Wireshark to capture and inspect the exact HTTP request
    your browser generates when you submit the Mutillidae login form with the username
    “test” and password “abcd.” (Return to [Chapter 3](ch03.xhtml#ch3) for a refresher
    on monitoring traffic with Wireshark.)
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 为了生成 HTTP 请求，你首先需要理解它们的结构。为了准确起见，让我们使用 Wireshark 捕获并检查浏览器提交 Mutillidae 登录表单时生成的确切
    HTTP 请求，用户名为“test”，密码为“abcd”。（返回 [第 3 章](ch03.xhtml#ch3) 查看如何使用 Wireshark 监控流量的复习内容。）
- en: 'Start monitoring the Ethernet (`eth0`) interface and then submit the login
    form to generate the request. Once submitted, use a filter to select packets containing
    the Metasploitable server’s IP and then select the **follow stream** option. Your
    request should look something like this:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 开始监控以太网（`eth0`）接口，然后提交登录表单以生成请求。提交后，使用过滤器选择包含 Metasploitable 服务器 IP 的数据包，然后选择
    **跟踪流** 选项。你的请求应该看起来像这样：
- en: '[PRE9]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: As you can see, the HTTP request has multiple fields. The first field ➊ represents
    the type of request being sent. Web forms commonly use either `GET` or `POST`
    requests. A `GET` request encodes the user’s input data in the URL as *query string
    parameters*, which are variables included at the end of a URL ➋. The `?` operator
    denotes the beginning of the query string parameters, and each parameter is separated
    by a `&` operator. In this request, the username and password values are included
    as query string parameters in the request sent to the server. However, if a form
    uses a `POST` request, the user’s data is placed in the request’s body, which,
    if present, would appear at ➍.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，HTTP 请求包含多个字段。第一个字段 ➊ 表示发送请求的类型。Web 表单通常使用 `GET` 或 `POST` 请求。`GET` 请求将用户输入的数据编码在
    URL 中，作为 *查询字符串参数*，这些变量包含在 URL 的末尾 ➋。`?` 操作符表示查询字符串参数的开始，每个参数之间通过 `&` 操作符分隔。在此请求中，用户名和密码值作为查询字符串参数包含在发送到服务器的请求中。然而，如果表单使用
    `POST` 请求，用户的数据将被放置在请求体中，如果存在的话，会出现在 ➍ 处。
- en: 'To determine whether a form will generate a `GET` or `POST` request without
    submitting it, you can inspect a page’s source code by right-clicking the page
    and selecting **View Page Source**. A quick search for the `method=` keyword should
    return the code for the form. For example, the Mutillidae login form’s code looks
    like this:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 要在不提交表单的情况下确定表单是生成 `GET` 请求还是 `POST` 请求，你可以通过右键点击页面并选择 **查看页面源代码** 来检查页面的源代码。快速搜索
    `method=` 关键字应会返回表单的代码。例如，Mutillidae 登录表单的代码如下所示：
- en: '[PRE10]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: This tells us the form will generate a `GET` request.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 这告诉我们该表单将生成一个 `GET` 请求。
- en: Let’s continue looking at the HTTP request. The next header, `HOST`, identifies
    the web server to which you’re sending the request. In this case, `192.168.1.101`
    is the IP address of the server containing the page. The `User-Agent` header identifies
    the browser. Here, I have used the Mozilla Firefox browser on a `64-bit` Linux
    machine. Next, the `Accept` field specifies the format, language, and compression
    (encoding) types the browser accepts.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续查看 HTTP 请求。下一个头字段 `HOST` 标识你正在发送请求的 web 服务器。在此例中，`192.168.1.101` 是包含该页面的服务器的
    IP 地址。`User-Agent` 头字段标识浏览器。在这里，我使用的是在 `64-bit` Linux 机器上的 Mozilla Firefox 浏览器。接下来，`Accept`
    字段指定浏览器接受的格式、语言和压缩（编码）类型。
- en: The `Referer` field contains the previous page you visited before navigating
    to the current page. Many websites log this value to identify the source of their
    traffic. (Although some fields, like `HOST`, are required, other fields, like
    `Referer`, are optional. Thus, you might not see them in other requests.) The
    `Connection` field specifies the connection type, and the `keep-alive` option
    instructs the server to keep the TCP connection open, allowing it to accept multiple
    requests.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '`Referer` 字段包含你在访问当前页面之前访问的上一页。许多网站记录此值以识别其流量来源。（尽管某些字段，如 `HOST`，是必需的，但其他字段，如
    `Referer`，是可选的。因此，在其他请求中可能看不到它们。）`Connection` 字段指定连接类型，`keep-alive` 选项指示服务器保持
    TCP 连接打开，以便接受多个请求。'
- en: 'The `Cookie` field ➌ contains any cookies that the server has sent to the browser.
    The HTTP protocol is stateless, meaning it assumes that each request is made independently
    of all others. Therefore, the protocol doesn’t remember any previous requests
    you sent. That’s why the `Cookie` field lets programs like web servers track and
    collate a user’s interaction with the site even if the protocol doesn’t. When
    a user first visits a website, the server might assign that user a unique number
    to serve as a cookie. The server uses this unique number to authenticate the user
    and correctly process their web requests, as it will assume all HTTP requests
    that contain the same cookie belong to the same user. Each time the user sends
    a web request, the browser checks the cookie value. It’s like saying, “Hey web
    server, remember me? Here is the ID you gave me: `PHPSESSID=3e726056cf963b43bd87036e378d07be`”.
    If an attacker steals this cookie, they may be able to impersonate a victim and
    access their web sessions.'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '`Cookie`字段➌包含服务器发送给浏览器的任何cookie。HTTP协议是无状态的，意味着它假设每个请求都是独立发出的。因此，协议不会记住你发送的任何先前请求。这就是为什么`Cookie`字段允许像web服务器这样的程序跟踪和整理用户与网站的交互，即使协议本身并不会记住。用户首次访问网站时，服务器可能会分配一个唯一的数字作为cookie。服务器使用这个唯一的数字来验证用户并正确处理他们的web请求，因为它会假设所有包含相同cookie的HTTP请求都属于同一个用户。每次用户发送web请求时，浏览器都会检查cookie值。这就像在说，“嘿，web服务器，记得我吗？这是你给我的ID：`PHPSESSID=3e726056cf963b43bd87036e378d07be`”。如果攻击者窃取了这个cookie，他们可能会冒充受害者并访问他们的web会话。'
- en: The final `Upgrade-Insecure-Requests` field asks the web server to upgrade the
    connection to an encrypted HTTPS connection if possible. (This packet was captured
    from an unencrypted connection with the Metasploitable server.) Now that we have
    seen that Mutillidae’s credentials are sent to the server in query string parameters,
    we will inject our SQL payload in the same way.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 最终的`Upgrade-Insecure-Requests`字段请求web服务器在可能的情况下将连接升级为加密的HTTPS连接。（此数据包是从未加密的与Metasploitable服务器的连接中捕获的。）现在我们已经看到Mutillidae的凭证以查询字符串参数的形式发送到服务器，我们将以相同的方式注入我们的SQL负载。
- en: '***Writing the Injection Program***'
  id: totrans-60
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***编写注入程序***'
- en: 'Our Python program will send an HTTP request similar to the one we just reviewed,
    except that it will contain our SQL injection payload as a query parameter. Create
    a new Desktop folder called *injections* on your Kali Linux machine. Create a
    new file called *sql_injection.py* in that folder and then copy the following
    into it:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的Python程序将发送一个类似我们刚刚回顾过的HTTP请求，只是它将包含我们的SQL注入负载作为查询参数。在你的Kali Linux机器上创建一个名为*injections*的桌面文件夹。在该文件夹中创建一个名为*sql_injection.py*的新文件，并将以下内容复制到其中：
- en: '[PRE11]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: We define a function called `get_request()` that returns an HTTP request containing
    the information we pass in as parameters. We replace the query parameter’s value
    with the SQL injection query ➊. We must encode the query because we’re injecting
    it directly into the URL, which can’t contain spaces or certain special characters.
    The `urllib` library URL-encodes our SQL injection query before adding it to the
    URL. This encoding process will, for example, convert all spaces to the character
    sequence `%20`.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 我们定义了一个名为`get_request()`的函数，它返回包含我们作为参数传入的信息的HTTP请求。我们将查询参数的值替换为SQL注入查询➊。我们必须对查询进行编码，因为我们将其直接注入到URL中，而URL不能包含空格或某些特殊字符。`urllib`库会在将SQL注入查询添加到URL之前进行URL编码。这一编码过程会将所有空格转换为字符序列`%20`。
- en: When we’ve provided it with all the variables, the function will return the
    HTTP request, which we’ll send through a TCP socket ➌. Although not necessary,
    consider using the `argparse` library ➋ to parse the command line arguments. This
    will add a professional touch to your command line tools. The `argparse` library
    allows you to add custom flags and a help menu.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们提供了所有变量后，函数将返回HTTP请求，我们将通过TCP套接字发送该请求➌。虽然不是必须的，但可以考虑使用`argparse`库➋来解析命令行参数。这将为你的命令行工具增添专业感。`argparse`库允许你添加自定义标志和帮助菜单。
- en: 'Run the following command to test your new SQL injection tool:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 运行以下命令来测试你新的SQL注入工具：
- en: '[PRE12]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The script prints the request and the server’s HTML response. The preceding
    example shows a snippet of the HTML response, which contains the username and
    password pairs. A great way to debug your script is to capture requests and responses
    in Wireshark.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 脚本打印请求和服务器的HTML响应。前面的示例显示了HTML响应的一部分，其中包含用户名和密码对。调试脚本的一个好方法是使用Wireshark捕获请求和响应。
- en: '**Using SQLMap**'
  id: totrans-68
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**使用SQLMap**'
- en: 'We just built our own SQL injection tool, but existing tools can do much more
    than ours. One of the most popular SQL injections tools, called *SQLmap*, can
    automate the process of discovering and exploiting SQL injection vulnerabilities.
    Let’s perform another injection attack on the Mutillidae web app. Open a new terminal
    in Kali Linux and run the following command to start the SQLmap shell (it should
    be preinstalled on Kali Linux):'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚构建了自己的 SQL 注入工具，但现有工具比我们的功能更强大。最流行的 SQL 注入工具之一是 *SQLmap*，它可以自动化发现和利用 SQL
    注入漏洞的过程。让我们对 Mutillidae Web 应用程序执行另一次注入攻击。打开 Kali Linux 中的新终端，并运行以下命令启动 SQLmap
    shell（它应该已经预装在 Kali Linux 中）：
- en: '[PRE13]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The `-u` option specifies the URL of the web pages we’re targeting. Here we
    passed it the Mutillidae login page we attacked earlier in this chapter.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '`-u` 选项指定了我们要攻击的网页 URL。这里我们传入了本章之前攻击过的 Mutillidae 登录页面。'
- en: 'Within the shell, enter `--dbs`. This will list all databases on the system:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在 shell 中，输入 `--dbs`。这将列出系统中的所有数据库：
- en: '[PRE14]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '`SQLmap` first connects to the server and gets a fresh cookie ➊. Then, it uses
    the payload `'' OR NOT 6675=6675#` ➋ to test whether the query string parameter
    is vulnerable to SQL injection. Here, the `#` comments out the remainder of the
    SQL query. Lastly, `SQLmap` injects a query that returns list of databases on
    the server ➌. You can see that there are seven databases.'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '`SQLmap` 首先连接到服务器并获取一个新的 cookie ➊。然后，它使用负载 `'' OR NOT 6675=6675#` ➋ 来测试查询字符串参数是否存在
    SQL 注入漏洞。这里，`#` 将 SQL 查询的其余部分注释掉。最后，`SQLmap` 注入一个查询，返回服务器上所有数据库的列表 ➌。你可以看到有七个数据库。'
- en: 'Now we know this database server is hosting several databases. Let’s focus
    on exploring the owasp10 database ➍, which is the one we’ve been attacking. Run
    the following command to list all of this database’s tables. The `-D` flag lets
    you select a particular database and `--tables` lists all of its tables:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道该数据库服务器托管着多个数据库。让我们专注于探索我们一直在攻击的 owasp10 数据库➍。运行以下命令列出该数据库的所有表格。`-D` 标志让你选择一个特定的数据库，`--tables`
    列出该数据库的所有表格：
- en: '[PRE15]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'This command returned six tables. The table `accounts` looks particularly interesting
    as it sounds like it might contain user information. Let’s view its contents.
    Use the `-T` flag to select a specific table and the `--dump` option to dump (display)
    the table’s contents to the terminal. If you don’t include the `--dump` option,
    SQLmap will write the table’s contents to a file, instead:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 该命令返回了六个表格。表格 `accounts` 看起来尤其有趣，因为它听起来可能包含用户信息。让我们查看其内容。使用 `-T` 标志来选择特定的表格，使用
    `--dump` 选项将表格内容转储（显示）到终端。如果不包括 `--dump` 选项，SQLmap 会将表格内容写入文件。
- en: '[PRE16]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The output shows the data contained in the accounts table. There are five columns:
    `cid`, `is_admin`, `username`, `password`, and `mysignature`. There are also 16
    rows of data. I snipped the top rows to save space.'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 输出显示了 `accounts` 表中的数据。共有五列：`cid`、`is_admin`、`username`、`password` 和 `mysignature`。还有16行数据。我剪辑了顶部几行以节省空间。
- en: You might think developers could have protected these passwords by encrypting
    them. The engineering team at Adobe thought they could protect passwords this
    way, too. But what happens if someone steals your encryption key, or simply guesses
    it? As part of the Adobe password breach in 2013, hackers stole and decrypted
    more than 150 million usernames and passwords.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能认为开发人员可以通过加密这些密码来保护它们。Adobe 的工程团队也曾认为他们可以通过这种方式保护密码。但是，如果有人窃取了你的加密密钥，或者仅仅猜测出了它会怎样呢？作为
    2013 年 Adobe 密码泄露事件的一部分，黑客窃取并解密了超过 1.5 亿个用户名和密码。
- en: Ideally, websites should store passwords in a form that makes it infeasible
    for either admins or attackers to recover the plaintext password. Instead of encrypting
    passwords, software developers often use a one-way function like a hash. In the
    next section, we’ll look at hash functions and discuss how hackers crack them.
    I’ll explain why you should select long passwords with uppercase and lowercase
    letters and symbols.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 理想情况下，网站应该以一种无法让管理员或攻击者恢复明文密码的形式存储密码。软件开发人员通常使用哈希等单向函数，而不是加密密码。在下一节中，我们将了解哈希函数，并讨论黑客是如何破解它们的。我将解释为什么你应该选择包含大写字母、小写字母和符号的长密码。
- en: Keep the SQLmap terminal open; you’ll use it in the next section.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 保持 SQLmap 终端打开；你将在下一节中使用它。
- en: '**Hashing Passwords**'
  id: totrans-83
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**密码哈希**'
- en: We introduced hashes and hash functions in [Chapter 6](ch06.xhtml#ch6), and
    although we didn’t discuss them in detail, they’re very useful. Instead of storing
    plaintext passwords, database administrators often store a hash of the passwords
    to provide additional security. It’s worth taking a closer look at some fundamental
    properties of hash functions and how hackers can crack them.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在[第六章](ch06.xhtml#ch6)中介绍了哈希和哈希函数，尽管我们没有详细讨论它们，但它们非常有用。数据库管理员通常不会存储明文密码，而是存储密码的哈希值，以提供额外的安全性。值得深入了解哈希函数的一些基本特性，以及黑客是如何破解它们的。
- en: The first property of a hash function is that it is a *one-way function*. This
    means that, given the output, it is infeasible to find the input. You can think
    of hash functions as being analogous to a digital blender. Once a message is blended,
    it’s impossible to recover the original message from the blended results. [Figure
    12-2](ch12.xhtml#ch12fig2) shows the results of hashing two strings.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 哈希函数的第一个特性是它是一个*单向函数*。这意味着，给定输出后，几乎不可能找到输入。你可以将哈希函数类比为一个数字搅拌机。一旦信息被搅拌，便无法从搅拌结果中恢复出原始信息。[图
    12-2](ch12.xhtml#ch12fig2)展示了对两个字符串进行哈希处理的结果。
- en: '![image](../images/ch12fig02.jpg)'
  id: totrans-86
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/ch12fig02.jpg)'
- en: '*Figure 12-2: The hashes of two strings*'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 12-2：两个字符串的哈希值*'
- en: The second important property of hashes is that it’s time consuming to find
    two inputs that hash to the same output. By time consuming, I mean that when the
    hash function is secure, it would take longer than the universe’s age to find
    two inputs that hash to the same value. If two inputs hash to the same value,
    this is called a *collision*. We estimate it will take 36 trillion years to find
    a collision for the SHA-256 hash function. To put this number in perspective,
    the universe is only 13.8 billion years old.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 哈希的第二个重要特性是，找到两个输入使得它们哈希到相同的输出是非常耗时的。这里的“耗时”是指，当哈希函数安全时，找到两个哈希结果相同的输入需要的时间将超过宇宙的年龄。如果两个输入哈希到相同的值，这叫做*碰撞*。我们估计找到一个
    SHA-256 哈希函数的碰撞需要 36 万亿年。为了让这个数字更有意义，宇宙的年龄只有 138 亿年。
- en: 'Because collisions are so rare, developers often treat a message’s hash as
    its digital fingerprint: a unique identifier of that message. This is why system
    administrators can use hashes to represent passwords without storing the original
    password. If a user logs into a system, their password is hashed and compared
    to the hash in the database. The plaintext password is never stored.'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 由于碰撞如此罕见，开发者通常将消息的哈希视为其数字指纹：该消息的唯一标识符。这就是为什么系统管理员可以使用哈希来表示密码，而不需要存储原始密码的原因。如果用户登录系统，他们的密码会被哈希并与数据库中的哈希进行比较。原始密码永远不会被存储。
- en: 'The third property of a hash function is that, regardless of the input size,
    it always produces a fixed-size output. Long and short passwords will result in
    hashes of the same length. (You might already be wondering: Why do we need long
    passwords if all hashes are the same length? It’s because longer passwords are
    still more difficult to crack. To see why, skip ahead to the “Cracking Hashes”
    section of this chapter.)'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 哈希函数的第三个特性是，无论输入大小如何，它始终产生固定大小的输出。长密码和短密码会产生相同长度的哈希值。（你可能已经在想：如果所有哈希值长度相同，那为什么还需要长密码？这是因为较长的密码仍然更难破解。想要了解原因，可以跳到本章的“破解哈希”部分。）
- en: '***The Anatomy of the MD5 Hash***'
  id: totrans-91
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***MD5 哈希的结构***'
- en: If you’re curious about hash function design, here is a brief discussion on
    the MD5 hash function’s inner workings. Let’s look at the heart of our blender.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你对哈希函数设计感兴趣，这里简要讨论一下 MD5 哈希函数的内部工作原理。让我们来看看这个“搅拌机”的核心部分。
- en: The MD5 hash function operates on 512-bit blocks. The first 448 bits of this
    block contain the message that is being hashed, and the last 64 bits are the message’s
    length. If the message is shorter, the bits are padded with a one followed by
    zeros. If the message is longer than 448 bits, it is split into multiple blocks.
    [Figure 12-3](ch12.xhtml#ch12fig3) shows how these 512 bits are then scrambled.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: MD5 哈希函数在 512 位的块上进行操作。该块的前 448 位包含被哈希的消息，最后 64 位是消息的长度。如果消息较短，则会用一个“1”位和若干个“0”位进行填充。如果消息长度超过
    448 位，则会将其分成多个块。[图 12-3](ch12.xhtml#ch12fig3)展示了这些 512 位如何被打乱。
- en: '![image](../images/ch12fig03.jpg)'
  id: totrans-94
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/ch12fig03.jpg)'
- en: '*Figure 12-3: The building blocks of the MD5 hash*'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 12-3：MD5 哈希的构建块*'
- en: 'First, a 128-bit random number (a nonce) is used the create an initialization
    vector. The 128-bit initialization vector is then divided into four 32-bit blocks:
    *A*, *B*, *C*, and *D*. The mixing process begins by using a function (labeled
    *F* in [Figure 12-3](ch12.xhtml#ch12fig3)) that combines the random values of
    *B*, *C*, and *D* to produce another 32-bit value. The formula for *F* is shown
    here:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，使用一个128位的随机数（nonce）来创建一个初始化向量。然后，将128位的初始化向量分成四个32位数据块：*A*、*B*、*C*和*D*。混合过程从使用一个函数（在[图12-3](ch12.xhtml#ch12fig3)中标记为*F*）开始，该函数将*B*、*C*和*D*的随机值结合起来，生成另一个32位的值。*F*的公式如下：
- en: '*F*(*B*, *C*, *D*) = (*B* **and** *C*) **or** (( **not** *B*) **and** *D*)'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '*F*(*B*, *C*, *D*) = (*B* **and** *C*) **or** (( **not** *B*) **and** *D*)'
- en: 'The output of this function gets fed to a function *K*, which combines it with
    32 bits of the original message (*M[i]*), a 32-bit constant (*T[i]*), and the
    32 bits in *A*. The *i* value represents a specific iteration. Only 32 bits of
    the 512-bit message are processed at a time. Following is the formula for the
    function *K*:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 该函数的输出结果被送入一个函数*K*，它将输出与原始消息的32位值（*M[i]*）、32位常数（*T[i]*）和*A*中的32位结合。*i*值表示特定的迭代步骤。每次仅处理512位消息中的32位。下面是函数*K*的公式：
- en: '*K*(*B*, *M*, *T*, *A*, *F*) = *B* ⊞ ((*A* ⊞ *F* ⊞ *M[i]* ⊞ *T[i]*) <<< *s[i]*)'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '*K*(*B*, *M*, *T*, *A*, *F*) = *B* ⊞ ((*A* ⊞ *F* ⊞ *M[i]* ⊞ *T[i]*) <<< *s[i]*)'
- en: The ⊞ symbols represent modulo addition, which is equivalent to adding two numbers
    and then computing the result modulo of some number *n*. If *n* is 7, then 6 ⊞
    3 is 2\. The <<< symbol represents a circular left shift and *s[i]* represents
    the shift amount. The output of function *K* is used to override the value of
    the *A* block, and the blocks are rearranged by performing a circular right shift,
    as shown in [Figure 12-3](ch12.xhtml#ch12fig3). The resulting 128 bits are then
    fed back into the whole system for a total of 16 iterations, one for each 32-bit
    segment in the original 512-bit message (16 *×* 32 = 512).
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: ⊞符号表示模加法，相当于将两个数字相加后对某个数*n*取模。如果*n*为7，则6 ⊞ 3的结果是2。<<<符号表示循环左移，*s[i]*表示移位的数量。函数*K*的输出结果用来覆盖*A*数据块的值，然后通过进行循环右移重新排列数据块，如[图12-3](ch12.xhtml#ch12fig3)所示。最终得到的128位被送回整个系统，经过16次迭代，每次处理原始512位消息中的一个32位段（16
    *×* 32 = 512）。
- en: The block described here is just one of the four blocks used by the MD5 hash
    function. The data pass through all four blocks in a given round. [Figure 12-4](ch12.xhtml#ch12fig4)
    shows how all four blocks are combined.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 这里描述的数据块只是MD5哈希函数所使用的四个数据块中的一个。数据会在给定的轮次中经过四个数据块。[图12-4](ch12.xhtml#ch12fig4)展示了四个数据块如何组合在一起。
- en: '![image](../images/ch12fig04.jpg)'
  id: totrans-102
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/ch12fig04.jpg)'
- en: '*Figure 12-4: Combining the four blocks of the MD5 algorithm*'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '*图12-4：组合MD5算法的四个数据块*'
- en: 'Each block follows the same general structure. The only exception is that each
    block uses a specific function. These functions are as follows:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 每个数据块都遵循相同的一般结构。唯一的例外是每个数据块使用了一个特定的函数。这些函数如下：
- en: '*H*(*B*, *C*, *D*) = *B* **xor** *C* **xor** *D*'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '*H*(*B*, *C*, *D*) = *B* **xor** *C* **xor** *D*'
- en: '*G*(*B*, *C*, *D*) = (*B* **and** *D*) **or** (*C* **and** ( **not** *D*))'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '*G*(*B*, *C*, *D*) = (*B* **and** *D*) **or** (*C* **and** ( **not** *D*))'
- en: '*I*(*B*, *C*, *D*) = *C* **xor** (*B* **or** ( **not** *D*))'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '*I*(*B*, *C*, *D*) = *C* **xor** (*B* **or** ( **not** *D*))'
- en: 'If the message is longer that 448 bits, the initialization vector of the next
    block is calculated by computing block *I*’s output chunks: *A*, *B*, *C*, and
    *D* addition modulo 32 the chunks of the original initialization vector. The final
    128-bit Initialization vector is the MD5 hash.'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 如果消息长度超过448位，则下一个数据块的初始化向量通过计算数据块*I*的输出块：*A*、*B*、*C*和*D*，并将其与原始初始化向量的块进行32位模加法运算。最终的128位初始化向量是MD5哈希值。
- en: 'Even after all this mixing, in 1993, Antoon Bosselaers and Bert den Boer discovered
    that MD5 doesn’t meet the no-collision property of hashes, because it’s possible
    to generate two messages with the same hash. Because of this, the MD5 algorithm
    is no longer secure and shouldn’t be used when building cryptographic systems.
    Not to worry: other hash algorithms such as SHA-256, SHA-512, and SHA-3 are still
    considered secure. [Figure 12-5](ch12.xhtml#ch12fig5) shows the general architecture
    of the SHA-256 hash function. The C function represents the compression function,
    which can be described using a similar diagram and language as [Figure 12-3](ch12.xhtml#ch12fig3).'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 即使经过这么多混合，1993年，Antoon Bosselaers 和 Bert den Boer 发现 MD5 并不满足哈希的无碰撞特性，因为可以生成两个具有相同哈希值的消息。因此，MD5
    算法不再安全，不应该在构建加密系统时使用。别担心：其他哈希算法如 SHA-256、SHA-512 和 SHA-3 仍然被认为是安全的。[图 12-5](ch12.xhtml#ch12fig5)展示了
    SHA-256 哈希函数的一般架构。C 函数代表压缩函数，可以使用与[图 12-3](ch12.xhtml#ch12fig3)类似的图示和语言进行描述。
- en: '![image](../images/ch12fig05.jpg)'
  id: totrans-110
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/ch12fig05.jpg)'
- en: '*Figure 12-5: The SHA-256 hash function*'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 12-5：SHA-256 哈希函数*'
- en: '***Cracking Hashes***'
  id: totrans-112
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***破解哈希***'
- en: How can we crack a password hash to recover the original password? Secure hash
    functions are one-way functions, so we can’t directly reverse engineer the hash.
    But all is not lost; we just have to be clever.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 我们如何破解一个密码哈希来恢复原始密码呢？安全哈希函数是单向函数，因此我们不能直接反向工程哈希。但并非一切都失去希望；我们只需要聪明一点。
- en: Recall that each password will generate a unique hash, so two matching hashes
    must share the same plaintext password. Therefore, if we want to crack a specific
    hash, we should compute the hash of many known passwords and compare the resulting
    hashes to our original hash. If we find a match, the plaintext password we just
    hashed must be the same as the plaintext password of the hash we’re trying to
    crack. This type of attack is called a dictionary-based attack, and it’s the same
    strategy we used earlier to discover files on a server. Let’s use a dictionary-based
    attack to crack some of the password hashes in the database on the Metasploitable
    virtual machine.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 回想一下，每个密码都会生成一个唯一的哈希，因此两个匹配的哈希必须共享相同的明文密码。因此，如果我们想破解一个特定的哈希，我们应该计算许多已知密码的哈希，并将生成的哈希与我们的原始哈希进行比较。如果找到匹配项，我们刚刚计算的明文密码必须与我们正在尝试破解的哈希的明文密码相同。这种攻击方式叫做基于字典的攻击，这也是我们之前用来发现服务器上文件的策略。让我们使用基于字典的攻击来破解
    Metasploitable 虚拟机上数据库中的一些密码哈希。
- en: 'Reopen the terminal containing the SQLmap session and use the following command
    to dump the usernames and passwords from the user table in the Damn Vulnerable
    Web App (DVWA) database. This SQLmap command will perform a dictionary-based attack
    to try to crack the password hashes in the database:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 重新打开包含 SQLmap 会话的终端，并使用以下命令从 Damn Vulnerable Web App（DVWA）数据库的用户表中转储用户名和密码。此
    SQLmap 命令将执行基于字典的攻击，尝试破解数据库中的密码哈希：
- en: '[PRE17]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: In this case, the dictionary-based attack was able to crack all the passwords
    in the dictionary.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，基于字典的攻击能够破解字典中的所有密码。
- en: Of course, dictionary-based attacks will succeed only if the passwords in the
    database are also in the predefined list of passwords. A good password list is
    critical to the hash cracking process. *SecLists*, an excellent collection of
    security lists, contains several password lists that you can use for your dictionary-based
    attacks. For example, the *10-million-password-list-top-1000000.txt* contains
    a whopping one million passwords. SecLists also has password lists in other languages,
    such as French, Dutch, and German. The SecLists collection contains payloads like
    zipbombs and webshells, and entries that can be used as test data in fuzzing attacks.
    *Zipbombs* are small, compressed files that become really large when decompressed.
    You could make your own zipbomb by compressing a large file containing zeros.
    *Webshells* are shells that allow you to control a server from a web page.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，基于字典的攻击只有在数据库中的密码也包含在预定义的密码列表中时才能成功。一份好的密码列表对于哈希破解过程至关重要。*SecLists*是一个出色的安全列表集合，包含了多个密码列表，你可以用来进行基于字典的攻击。例如，*10-million-password-list-top-1000000.txt*包含了多达一百万个密码。SecLists
    还提供了其他语言的密码列表，如法语、荷兰语和德语。SecLists 集合中还包含了像 zipbomb 和 webshells 这样的有效载荷，以及可以用作模糊测试攻击测试数据的条目。*Zipbombs*是小型的压缩文件，解压后会变得非常大。你可以通过压缩一个包含零的巨大文件来制作自己的
    zipbomb。*Webshells* 是允许你通过网页控制服务器的外壳。
- en: 'You can clone the SecLists Git repository to your Kali Linux desktop by running
    the following command:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过运行以下命令，将 SecLists Git 仓库克隆到 Kali Linux 桌面：
- en: '[PRE18]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '***Salting Hashes with a Nonce***'
  id: totrans-121
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***使用随机数（Nonce）对哈希值进行加盐***'
- en: If two users have the same password, both passwords will produce the same hash.
    This leaks information because it allows a hacker with access to the database
    to know that two users have the same password. Also, as you just discovered, hackers
    can figure out the value of a password if they happen to hash the same text. For
    this reason, developers often prepend a nonce to a password before hashing it.
    This nonce is commonly called a *salt*. The salt is prepended to the password
    and the resulting string is hashed and stored in the database. The original salt
    is also stored in a separate column.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 如果两个用户使用相同的密码，那么这两个密码将生成相同的哈希值。这会泄露信息，因为它允许一个访问数据库的黑客知道两个用户使用了相同的密码。此外，正如你刚才发现的，黑客如果恰好对相同的文本进行哈希，也能推算出密码的值。出于这个原因，开发人员通常会在对密码进行哈希之前，向密码前添加一个随机数（nonce）。这个随机数通常被称为
    *盐值*。盐值被添加到密码之前，得到的字符串会被哈希并存储在数据库中。原始的盐值也会存储在单独的列中。
- en: '**Building a Salted Hash Cracker**'
  id: totrans-123
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**构建一个盐值哈希破解器**'
- en: 'It’s time to write our own hash cracking tool. Our hash cracker will prepend
    the salt pulled from a database to a plaintext password and compute the hash of
    the result. It will then compare the resulting hash to the hash being cracked.
    We’ll repeat this process for each password in the dictionary until a match is
    found. Create a new file called *myHashCracker.py* in the *HashCrack* folder on
    your Kali Linux desktop and copy the following into it:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候编写我们自己的哈希破解工具了。我们的哈希破解器将从数据库中提取盐值并将其与明文密码连接，计算结果的哈希值。然后，它将把得到的哈希值与正在破解的哈希值进行比较。我们会对字典中的每个密码重复这个过程，直到找到匹配的密码为止。请在
    Kali Linux 桌面上的 *HashCrack* 文件夹中创建一个名为 *myHashCracker.py* 的新文件，并将以下内容复制到其中：
- en: '[PRE19]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: This program will loop through all the passwords in the supplied dictionary
    ➊ and compute the hash of the salt and password combined. If the result matches
    the supplied hash, the program will return the plaintext password ➋. However,
    if the hash doesn’t match, it will try the next password in the dictionary. The
    process will continue until until a match is found or until every password in
    the dictionary has been checked. If no match is found, the program will return
    `None`.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 该程序将遍历所提供字典中的所有密码 ➊，并计算盐值和密码组合后的哈希值。如果结果与提供的哈希匹配，程序将返回明文密码 ➋。然而，如果哈希不匹配，它将尝试字典中的下一个密码。该过程将继续，直到找到匹配的密码，或者直到检查完字典中的每个密码。如果没有找到匹配项，程序将返回
    `None`。
- en: 'Run the Python script to crack the hash, which we hardcoded in our script ➌:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 运行 Python 脚本来破解哈希值，我们在脚本中硬编码了该哈希值 ➌：
- en: '[PRE20]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Once the script completes, it should print out the password `trustno1`.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦脚本完成，它应该会打印出密码 `trustno1`。
- en: '**Popular Hash Cracking and Brute-Forcing Tools**'
  id: totrans-130
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**流行的哈希破解和暴力破解工具**'
- en: Other hackers have already built some useful hash cracking tools, many of which
    come preinstalled on Kali Linux. For example, *John the Ripper* is a large community
    project that can crack multiple types of hashes.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 其他黑客已经构建了一些有用的哈希破解工具，其中许多工具已预装在 Kali Linux 上。例如，*John the Ripper* 是一个大型社区项目，可以破解多种类型的哈希。
- en: '***John the Ripper***'
  id: totrans-132
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***John the Ripper***'
- en: 'Let’s use John the Ripper to crack the following hash, which you should save
    to a text file:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用 John the Ripper 来破解以下哈希，你应将其保存到文本文件中：
- en: '[PRE21]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Run the following command to start to start the cracking process.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 运行以下命令以开始破解过程。
- en: '[PRE22]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'When the process completes, you can run the following command to view the list
    of cracked passwords:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 过程完成后，你可以运行以下命令查看已破解的密码列表：
- en: '[PRE23]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '***Hashcat***'
  id: totrans-139
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***Hashcat***'
- en: Another useful hash cracking tool, *Hashcat*, includes optimizations that allow
    you to perform dictionary attacks more rapidly. For example, Hashcat parallelizes
    the process so that the software can take advantage of special hardware like *Graphics
    Processing Units (GPUs)* that can run many operations simultaneously.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个有用的哈希破解工具，*Hashcat*，包括一些优化，使你能够更快速地进行字典攻击。例如，Hashcat 会并行化过程，使软件能够利用像 *图形处理单元（GPU）*
    这样的特殊硬件，这些硬件可以同时运行多个操作。
- en: However, because of these optimizations, running Hashcat in a virtual machine
    may result in an illegal instruction error. Therefore, you’ll need to install
    and run it outside of your virtual lab environment. It’s common practice among
    serious hackers to build special password-cracking machines with powerful processors
    and GPUs.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，由于这些优化，运行Hashcat在虚拟机中可能会导致非法指令错误。因此，您需要在虚拟实验室环境之外安装并运行它。在严肃的黑客中，常见做法是构建专门的密码破解机器，配备强大的处理器和GPU。
- en: 'Let’s use Hashcat to crack the *hashes.txt* file:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用Hashcat破解*hashes.txt*文件：
- en: '[PRE24]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The `-a` flag represents the attack mode, or strategy, used to crack the hash.
    You can view possible attack modes by using the `**--help**` flag:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '`-a`标志表示用于破解哈希值的攻击模式或策略。您可以通过使用`**--help**`标志查看可能的攻击模式：'
- en: '[PRE25]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Option `0`, `Straight` mode (the mode we’ve used here), simply tries each word
    in the dictionary until it finds a match. Option `1`, `Combination` mode, tries
    multiple combinations of different words. For example, it might combine the password
    *fire* with the password *walker1* to produce the password *firewalker1*. Option
    `3`, `Brute-force` mode, will try every possible combination until it discovers
    the password. For example, the tool might try the values *a*, *aa*, *ab*, and
    so on.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 选项`0`，`Straight`模式（我们在这里使用的模式），会逐个尝试字典中的每个单词，直到找到匹配项。选项`1`，`Combination`模式，会尝试不同单词的多个组合。例如，它可能将密码*fire*与密码*walker1*组合，生成密码*firewalker1*。选项`3`，`Brute-force`模式，会尝试所有可能的组合，直到发现密码。例如，该工具可能会尝试值*a*、*aa*、*ab*，以此类推。
- en: To reduce the number of combinations Hashcat must test, you can supply a mask.
    A *mask* is a pattern that defines the password’s structure. For example, the
    pattern `?u?l?l?d?s` specifies a five-letter password. The `?u` indicates that
    the password starts with an uppercase letter. This uppercase letter is followed
    by two lowercase letters (`?l`) and the pattern ends with a digit (`?d`) followed
    by a symbol (`?s`). As a result, this mask might test the password `Bas5!`.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 为了减少Hashcat需要测试的组合数量，您可以提供一个掩码。*掩码*是定义密码结构的模式。例如，模式`?u?l?l?d?s`指定了一个五个字符的密码。`?u`表示密码以大写字母开头。接下来是两个小写字母（`?l`），然后模式以数字（`?d`）和符号（`?s`）结尾。因此，这个掩码可能会测试密码`Bas5!`。
- en: 'The `-m` (or mode) option represents the algorithm used to create the hash.
    You can view a complete list of available modes by running `hash -h` in the terminal.
    The following is a snippet of some of the available modes:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '`-m`（或模式）选项表示用于创建哈希值的算法。您可以通过在终端中运行`hash -h`来查看可用模式的完整列表。以下是一些可用模式的片段：'
- en: '[PRE26]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Mode `1400` represents a hash calculated using the SHA2-256 algorithm ➊, whereas
    mode `1420` represents a hashing algorithm that first appends a salt to password
    before running it through SHA2-256 ➋. A hashing algorithm can run for multiple
    iterations, using the output of each previous run as input for the next one. For
    example, mode `2600 md5(md5($pass))` computes the MD5 hash twice. This iteration
    value is normally stored in the database. Hashcat supports a fixed number of iterations
    with its predefined modes, but tools like *MDXfind* support an arbitrary number
    of iterations. The best way to store passwords is to salt them and then hash them
    for multiple iterations with a secure hash function like SHA-3, or better yet,
    a memory-hard function like scrypt or Argon 2i.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 模式`1400`表示使用SHA2-256算法计算的哈希值 ➊，而模式`1420`表示一个哈希算法，它首先将盐值附加到密码上，再通过SHA2-256计算
    ➋。哈希算法可以进行多次迭代，每次使用上一次运行的输出作为下一次运行的输入。例如，模式`2600 md5(md5($pass))`计算两次MD5哈希。这个迭代值通常存储在数据库中。Hashcat支持其预定义模式的固定迭代次数，但像*MDXfind*这样的工具支持任意次数的迭代。存储密码的最佳方法是先加盐，然后使用像SHA-3这样的安全哈希函数进行多次哈希，或者更好的是，使用像scrypt或Argon
    2i这样的内存硬算法。
- en: '***Hydra***'
  id: totrans-151
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***Hydra***'
- en: After you’ve recovered usernames and passwords, what can you do with them? You
    could try to use them to log in to services like FTP or SSH. Here, we look at
    *Hydra*, an invaluable tool that automates the process of attempting to log in
    to a service using username and password pairs from a list.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 在恢复了用户名和密码之后，您可以用它们做什么？您可以尝试用它们登录像FTP或SSH这样的服务。在这里，我们介绍了*Hydra*，一款自动化工具，可以通过使用用户名和密码对列表来尝试登录服务。
- en: 'Practice using Hydra to break into your Metasploitable virtual machine through
    its FTP server. FTP allows users to upload files to a server. You can use the
    default usernames and passwords in the *ftp-betterdefaultpasslist.txt* list, which
    is a part of SecLists. The following is a copy of the complete list:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 练习使用 Hydra 通过其 FTP 服务器突破你的 Metasploitable 虚拟机。FTP 允许用户向服务器上传文件。你可以使用 *ftp-betterdefaultpasslist.txt*
    列表中的默认用户名和密码，该列表是 SecLists 的一部分。以下是完整列表的副本：
- en: '[PRE27]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Files in SecLists aren’t always this short. In fact, the FTP default password
    list is one of shortest lists in the SecLists collection, which makes it a great
    candidate for demonstrating this type of attack. The longer the list, the more
    time it will take to run.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: SecLists 中的文件并不总是这么短。事实上，FTP 默认密码列表是 SecLists 集合中最短的列表之一，这使得它成为演示此类攻击的理想选择。列表越长，运行所需的时间就越长。
- en: 'Run Hydra using the following command; the IP address `192.168.1.101` represents
    the IP address of the Metasploitable server:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下命令运行 Hydra；IP 地址 `192.168.1.101` 代表 Metasploitable 服务器的 IP 地址：
- en: '[PRE28]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: The output shows three FTP accounts on the server that are using default login
    credentials. Now you could use the FTP server to, for example, upload an implant.
    Try a similar approach to access SSH accounts.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 输出显示服务器上有三个使用默认登录凭据的 FTP 账户。现在，你可以使用 FTP 服务器，例如，上传一个植入物。尝试使用类似的方法访问 SSH 账户。
- en: '**Exercises**'
  id: totrans-159
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**练习**'
- en: These exercises will broaden your understanding of the ideas discussed in this
    chapter. In the first exercise, we’ll discuss NoSQL injection techniques. Then,
    we’ll examine how you can use tools like Hydra to automate the process of brute
    forcing passwords. We’ll conclude by discussing Burp Suite and its proxy, which
    allow you to intercept and modify web requests and responses.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 这些练习将拓宽你对本章讨论的概念的理解。在第一个练习中，我们将讨论 NoSQL 注入技术。然后，我们将探讨如何使用像 Hydra 这样的工具自动化暴力破解密码的过程。最后，我们将讨论
    Burp Suite 及其代理，它们允许你拦截和修改 web 请求和响应。
- en: '***NoSQL Injection***'
  id: totrans-161
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***NoSQL 注入***'
- en: NoSQL databases are an alternative to databases that use SQL. Instead of storing
    data in tables, these databases store data in objects called documents, which
    are organized into collections. There is no standard query language for NoSQL
    databases, hence the name. Instead, each NoSQL platform (which includes MongoDB
    and Firebase) uses its own syntax and protocol. For this reason, programmers often
    rely on libraries to interface with these systems.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: NoSQL 数据库是相对于使用 SQL 的数据库的一种替代方案。与将数据存储在表格中的传统数据库不同，这些数据库将数据存储在称为文档的对象中，文档被组织成集合。NoSQL
    数据库没有标准查询语言，因此得名。相反，每个 NoSQL 平台（包括 MongoDB 和 Firebase）都使用其自己的语法和协议。因此，程序员通常依赖于库来与这些系统进行交互。
- en: 'Let’s look at an example of a Python library that interfaces with the MongoDB
    NoSQL database. The following Python program takes a social security number `POST`-ed
    by an HTTP form and uses the `pymongo` Python library to query a MongoDB database:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一个与 MongoDB NoSQL 数据库交互的 Python 库的示例。以下 Python 程序通过 HTTP 表单 `POST` 的社会安全号码，并使用
    `pymongo` Python 库查询 MongoDB 数据库：
- en: '[PRE29]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'We connect to the MongoDB database running on port `27017` ➊. (Default installations
    of MongoDB aren’t password protected.) Next, we select the database we want to
    query ➋. Then, we define a function called `getUserInfo` ➌. This function takes
    the social security number from the form’s `POST` request and uses it to query
    the customer collection for the users information at ➍. MongoDB queries are represented
    as key–value pairs with the following syntax: `collection.find({"key":"value"})`.
    In `{"SSN": "+post_ssn+""}`, the social security number is the value in the `SSN`
    field posted from the form (`post_ssn`).'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: '我们连接到运行在 `27017` 端口上的 MongoDB 数据库 ➊。（MongoDB 的默认安装没有密码保护。）接下来，我们选择要查询的数据库 ➋。然后，我们定义一个名为
    `getUserInfo` 的函数 ➌。该函数获取来自表单的 `POST` 请求中的社会安全号码，并用它查询客户集合中的用户信息 ➍。MongoDB 查询以键值对的形式表示，语法如下：`collection.find({"key":"value"})`。在
    `{"SSN": "+post_ssn+""}` 中，社会安全号码是来自表单的 `SSN` 字段中的值（`post_ssn`）。'
- en: 'As we did with SQL databases, we can inject information into the NoSQL database
    that changes the meaning of the query. For example, imagine we provided the following
    input to the `POST` form: `{$ne: ""}`. This would result in the following query:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: '和 SQL 数据库一样，我们可以将信息注入 NoSQL 数据库，从而改变查询的含义。例如，假设我们向 `POST` 表单提供了以下输入：`{$ne:
    ""}`。这将导致以下查询：'
- en: '[PRE30]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: The `ne` operator means *not equal to* in MongoDB, so the query now returns
    all data for users whose `SSN` field isn’t empty.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: '`ne` 操作符在 MongoDB 中表示 *不等于*，因此查询现在返回所有 `SSN` 字段不为空的用户数据。'
- en: In addition to reading data, you could also inject your own data, or even code,
    into the database. Tools like to *NoSQLMap* automate the process of exploiting
    NoSQL databases. You can obtain a copy of NoSQLMap by visiting its GitHub page
    at *[https://github.com/codingo/NoSQLMap/](https://github.com/codingo/NoSQLMap/)*.
    Practice using it to see what you can uncover.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 除了读取数据外，你还可以将自己的数据，甚至是代码，注入到数据库中。像 *NoSQLMap* 这样的工具能够自动化利用 NoSQL 数据库的过程。你可以通过访问其
    GitHub 页面 *[https://github.com/codingo/NoSQLMap/](https://github.com/codingo/NoSQLMap/)*
    来获取 NoSQLMap。练习使用它，看看你能发现什么。
- en: '***Brute-Forcing Web Logins***'
  id: totrans-170
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***暴力破解网页登录***'
- en: In this chapter, we used dictionary-based attacks to crack a hash and log in
    to an FTP server. You can also use dictionary-based attacks to log in to a web
    app by trying all the usernames and passwords in some list. You might try achieving
    this by submitting multiple HTTP requests containing user login data.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们使用基于字典的攻击破解了哈希并登录了 FTP 服务器。你也可以通过尝试一些列表中的所有用户名和密码来使用字典攻击登录 Web 应用。你可能会通过提交包含用户登录数据的多个
    HTTP 请求来实现这一点。
- en: 'Hydra makes it possible for you to automate this process. Run the following
    command to send HTTP requests that contain the usernames and passwords in *darkweb2017-top100.txt*
    to the login form in Mutillidae:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: Hydra 使你能够自动化此过程。运行以下命令，将 *darkweb2017-top100.txt* 中的用户名和密码发送到 Mutillidae 中的登录表单：
- en: '[PRE31]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: First, specify the URL of the web app. Hydra uses colons to separate options.
    Next, specify the query string parameters that contain the data the user entered.
    Here, we submit multiple requests with different values for the username and password
    parameters. Use the (`^USER^`) and (`^PASS^`) placeholders to indicate where Hydra
    should insert the username and password in the URL. Lastly, you must specify the
    error message that will be contained in the HTTP response if the login attempt
    fails.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，指定 Web 应用的 URL。Hydra 使用冒号来分隔选项。接下来，指定包含用户输入数据的查询字符串参数。这里，我们提交多个请求，使用不同的用户名和密码参数值。使用
    (`^USER^`) 和 (`^PASS^`) 占位符来指示 Hydra 在 URL 中插入用户名和密码。最后，你必须指定当登录尝试失败时，HTTP 响应中包含的错误信息。
- en: Run the command to see what usernames and passwords Hydra discovers. After you’ve
    had some practice with Hydra, see if you can gain access to the PostgreSQL server
    on the Metasploit machine.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 运行命令，查看 Hydra 发现了哪些用户名和密码。在你熟练掌握 Hydra 后，看看是否能访问 Metasploit 机器上的 PostgreSQL
    服务器。
- en: '***Burp Suite***'
  id: totrans-176
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***Burp Suite***'
- en: Injection attacks frequently require that you modify HTTP requests. Let’s try
    using a tool that makes this process easier. The free community edition of Burp
    Suite provides a GUI that allows you to quickly modify HTTP requests and responses
    sent and received by your browser. This is possible because Burp Suite acts as
    a proxy between the browser and the server. Each HTTP message your browser sends
    or receives first passes through Burp Suite.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 注入攻击通常需要修改 HTTP 请求。让我们尝试使用一款能简化此过程的工具。Burp Suite 的免费社区版提供一个 GUI，允许你快速修改浏览器发送和接收的
    HTTP 请求和响应。这是可能的，因为 Burp Suite 作为浏览器和服务器之间的代理，每条浏览器发送或接收的 HTTP 消息都会先经过 Burp Suite。
- en: By default, the browser on Kali Linux isn’t configured to send web requests
    through a proxy, but you can configure Firefox to use your proxy by opening its
    preferences and searching for **Network Settings** ([Figure 12-6](ch12.xhtml#ch12fig6)).
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，Kali Linux 上的浏览器未配置通过代理发送网页请求，但你可以通过打开 Firefox 的偏好设置，搜索 **Network Settings**
    来配置 Firefox 使用你的代理（参见图 [12-6](ch12.xhtml#ch12fig6)）。
- en: '![image](../images/ch12fig06.jpg)'
  id: totrans-179
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/ch12fig06.jpg)'
- en: '*Figure 12-6: Configuring the Firefox setting that will route traffic through
    Burp Suite*'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 12-6：配置将流量通过 Burp Suite 路由的 Firefox 设置*'
- en: Once you’ve configured the browser, generate some web traffic by visiting *[http://cs.virginia.edu/](http://cs.virginia.edu/)*.
    Burp Suite will intercept the request and you can view it by clicking the **Proxy**
    and **Intercept** tabs, at 1 and 2, respectively, in [Figure 12-7](ch12.xhtml#ch12fig7).
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 配置好浏览器后，通过访问 *[http://cs.virginia.edu/](http://cs.virginia.edu/)* 生成一些网页流量。Burp
    Suite 会拦截请求，你可以通过点击 **Proxy** 和 **Intercept** 标签，分别在图 [12-7](ch12.xhtml#ch12fig7)
    的 1 和 2 位置查看请求。
- en: '![image](../images/ch12fig07.jpg)'
  id: totrans-182
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/ch12fig07.jpg)'
- en: '*Figure 12-7: Burp Suite’s capture of the HTTP request for* cs.virginia.edu'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 12-7：Burp Suite 捕获的 cs.virginia.edu 的 HTTP 请求*'
- en: After Burp Suite has captured a request, you can modify it or forward it to
    the web server unchanged. You can also send the request or response to another
    Burp Suite tab for future analysis. Explore Burp Suite to become familiar with
    using its features and then try modifying an HTTP request to execute a basic SQL
    injection attack.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Burp Suite 捕获到请求后，你可以修改它或将其原封不动地转发给 Web 服务器。你还可以将请求或响应发送到另一个 Burp Suite 标签页，以便进行后续分析。探索
    Burp Suite，熟悉其功能后，尝试修改 HTTP 请求以执行基础的 SQL 注入攻击。
