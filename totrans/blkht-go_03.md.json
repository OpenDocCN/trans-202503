["```\nGet(url string) (resp *Response, err error)\nHead(url string) (resp *Response, err error)\nPost(url string, bodyType string, body io.Reader) (resp *Response, err error)\n```", "```\nr1, err := http.Get(\"http://www.google.com/robots.txt\")\n// Read response body. Not shown.\ndefer r1.Body.Close()\nr2, err := http.Head(\"http://www.google.com/robots.txt\")\n// Read response body. Not shown.\ndefer r2.Body.Close()\nform := url.Values{}\nform.Add(\"foo\", \"bar\")\nr3, err = http.Post❶(\n    \"https://www.google.com/robots.txt\",\n ❷ \"application/x-www-form-urlencoded\",\n    strings.NewReader(form.Encode()❸),\n)\n// Read response body. Not shown.\ndefer r3.Body.Close()\n```", "```\nfunc PostForm(url string, data url.Values) (resp *Response, err error)\n```", "```\nform := url.Values{}\nform.Add(\"foo\", \"bar\")\nr3, err := http.PostForm(\"https://www.google.com/robots.txt\", form)\n// Read response body and close.\n```", "```\nfunc NewRequest(❶method, ❷url string, ❸body io.Reader) (req *Request, err error)\n```", "```\nreq, err := http.NewRequest(\"DELETE\", \"https://www.google.com/robots.txt\", nil)\nvar client http.Client\nresp, err := client.Do(req)\n// Read response body and close.\n```", "```\nform := url.Values{}\nform.Add(\"foo\", \"bar\")\nvar client http.Client\nreq, err := http.NewRequest(\n    \"PUT\",\n    \"https://www.google.com/robots.txt\",\n    strings.NewReader(form.Encode()),\n)\nresp, err := client.Do(req)\n// Read response body and close.\n```", "```\n❶ resp, err := http.Get(\"https://www.google.com/robots.txt\")\n   if err != nil {\n       log.Panicln(err)\n   }\n   // Print HTTP Status\n   fmt.Println(resp.Status❷)\n\n   // Read and display response body\n   body, err := ioutil.ReadAll(resp.Body❸)\n   if err != nil {\n       log.Panicln(err)\n   }\n   fmt.Println(string(body))\n❹ resp.Body.Close()\n```", "```\n$ go run main.go\n200 OK\nUser-agent: *\nDisallow: /search\nAllow: /search/about\nDisallow: /sdch\nDisallow: /groups\nDisallow: /index.html?\nDisallow: /?\nAllow: /?hl=\nDisallow: /?hl=*&\nAllow: /?hl=*&gws_rd=ssl$\nDisallow: /?hl=*&*&gws_rd=ssl\n--snip--\n```", "```\n{\"Message\":\"All is good with the world\",\"Status\":\"Success\"}\n```", "```\n   package main\n\n   import {\n       encoding/json\"\n       log\n       net/http\n   }\n❶ type Status struct {\n       Message string\n       Status  string\n   }\n\n   func main() {\n    ❷ res, err := http.Post(\n           \"http://IP:PORT/ping\",\n           \"application/json\",\n           nil,\n       )\n       if err != nil {\n           log.Fatalln(err)\n       }\n\n       var status Status\n    ❸ if err := json.NewDecoder(res.Body).Decode(&status); err != nil {\n           log.Fatalln(err)\n       }\n       defer res.Body.Close()\n       log.Printf(\"%s -> %s\\n\", status.Status❹, status.Message❺)\n   }\n```", "```\n$ tree github.com/blackhat-go/bhg/ch-3/shodan\ngithub.com/blackhat-go/bhg/ch-3/shodan\n|---cmd\n|   |---shodan\n|       |---main.go\n|---shodan\n    |---api.go\n    |---host.go\n    |---shodan.go\n```", "```\nfunc APIInfo(token, url string) { --snip-- }\nfunc HostSearch(token, url string) { --snip-- }\n```", "```\n   package shodan\n\n❶ const BaseURL = \"https://api.shodan.io\"\n\n❷ type Client struct {\n       apiKey string\n   }\n\n❸ func New(apiKey string) *Client {\n       return &Client{apiKey: apiKey}\n   }\n```", "```\nfunc (s *Client) APIInfo() { --snip-- }\nfunc (s *Client) HostSearch() { --snip-- }\n```", "```\nhttps://api.shodan.io/api-info?key={YOUR_API_KEY}\n```", "```\n{\n \"query_credits\": 56,\n \"scan_credits\": 0,\n \"telnet\": true,\n \"plan\": \"edu\",\n \"https\": true,\n \"unlocked\": true,\n}\n```", "```\ntype APIInfo struct {\n    QueryCredits int    `json:\"query_credits\"`\n    ScanCredits  int    `json:\"scan_credits\"`\n    Telnet       bool   `json:\"telnet\"`\n    Plan         string `json:\"plan\"`\n    HTTPS        bool   `json:\"https\"`\n    Unlocked     bool   `json:\"unlocked\"`\n}\n```", "```\nfunc (s *Client) APIInfo() (*APIInfo, error) {\n    res, err := http.Get(fmt.Sprintf(\"%s/api-info?key=%s\", BaseURL, s.apiKey))❶\n    if err != nil {\n        return nil, err\n    }\n    defer res.Body.Close()\n\n    var ret APIInfo\n    if err := json.NewDecoder(res.Body).Decode(&ret)❷; err != nil {\n        return nil, err\n    }\n    return &ret, nil\n}\n```", "```\nhttps://api.shodan.io/shodan/host/search?key={YOUR_API_KEY}&query={query}&facets={facets}\n\n{\n    \"matches\": [\n    {\n        \"os\": null,\n        \"timestamp\": \"2014-01-15T05:49:56.283713\",\n        \"isp\": \"Vivacom\",\n        \"asn\": \"AS8866\",\n        \"hostnames\": [ ],\n        \"location\": {\n            \"city\": null,\n            \"region_code\": null,\n            \"area_code\": null,\n            \"longitude\": 25,\n            \"country_code3\": \"BGR\",\n            \"country_name\": \"Bulgaria\",\n            \"postal_code\": null,\n            \"dma_code\": null,\n            \"country_code\": \"BG\",\n            \"latitude\": 43\n        },\n        \"ip\": 3579573318,\n        \"domains\": [ ],\n \"org\": \"Vivacom\",\n        \"data\": \"@PJL INFO STATUS CODE=35078 DISPLAY=\"Power Saver\" ONLINE=TRUE\",\n        \"port\": 9100,\n        \"ip_str\": \"213.91.244.70\"\n    },\n    --snip--\n    ],\n    \"facets\": {\n        \"org\": [\n        {\n            \"count\": 286,\n            \"value\": \"Korea Telecom\"\n        },\n        --snip--\n        ]\n    },\n    \"total\": 12039\n}\n```", "```\ntype HostLocation struct {\n    City         string  `json:\"city\"`\n    RegionCode   string  `json:\"region_code\"`\n    AreaCode     int     `json:\"area_code\"`\n    Longitude    float32 `json:\"longitude\"`\n    CountryCode3 string  `json:\"country_code3\"`\n    CountryName  string  `json:\"country_name\"`\n    PostalCode   string  `json:\"postal_code\"`\n    DMACode      int     `json:\"dma_code\"`\n    CountryCode  string  `json:\"country_code\"`\n    Latitude     float32 `json:\"latitude\"`\n}\n\ntype Host struct {\n    OS        string       `json:\"os\"`\n    Timestamp string       `json:\"timestamp\"`\n    ISP       string       `json:\"isp\"`\n    ASN       string       `json:\"asn\"`\n    Hostnames []string     `json:\"hostnames\"`\n    Location  HostLocation `json:\"location\"`\n    IP        int64        `json:\"ip\"`\n    Domains   []string     `json:\"domains\"`\n    Org       string       `json:\"org\"`\n    Data      string       `json:\"data\"`\n Port      int          `json:\"port\"`\n    IPString  string       `json:\"ip_str\"`\n}\n\ntype HostSearch struct {\n    Matches []Host `json:\"matches\"`\n}\n```", "```\nfunc (s *Client) HostSearch(q string❶) (*HostSearch, error) {\n    res, err := http.Get( ❷\n        fmt.Sprintf(\"%s/shodan/host/search?key=%s&query=%s\", BaseURL, s.apiKey, q),\n    )\n    if err != nil {\n        return nil, err\n    }\n    defer res.Body.Close()\n\n    var ret HostSearch\n    if err := json.NewDecoder(res.Body).Decode(&ret)❸; err != nil {\n        return nil, err\n    }\n\n    return &ret, nil\n}\n```", "```\nfunc main() {\n    if len(os.Args) != 2 {\n        log.Fatalln(\"Usage: shodan searchterm\")\n    }\n    apiKey := os.Getenv(\"SHODAN_API_KEY\")❶\n    s := shodan.New(apiKey)❷\n    info, err := s.APIInfo()❸\n    if err != nil {\n        log.Panicln(err)\n    }\n    fmt.Printf(\n        \"Query Credits: %d\\nScan Credits:  %d\\n\\n\",\n        info.QueryCredits,\n        info.ScanCredits)\n\n    hostSearch, err := s.HostSearch(os.Args[1])❹\n    if err != nil {\n        log.Panicln(err)\n    }\n ❺ for _, host := range hostSearch.Matches {\n        fmt.Printf(\"%18s%8d\\n\", host.IPString, host.Port)\n    }\n}\n```", "```\n$ SHODAN_API_KEY=YOUR-KEY go run main.go tomcat\nQuery Credits: 100\nScan Credits:  100\n\n    185.23.138.141    8081\n   218.103.124.239    8080\n     123.59.14.169    8081\n      177.6.80.213    8181\n    142.165.84.160   10000\n--snip--\n```", "```\n$ msfconsole\nmsf > load msgrpc Pass=s3cr3t ServerHost=10.0.1.6\n[*] MSGRPC Service:  10.0.1.6:55552\n[*] MSGRPC Username: msf\n[*] MSGRPC Password: s3cr3t\n[*] Successfully loaded plugin: msgrpc\n```", "```\n$ export MSFHOST=10.0.1.6:55552\n$ export MSFPASS=s3cr3t\n```", "```\n$ go get gopkg.in/vmihailenco/msgpack.v2\n```", "```\n$ tree github.com/blackhat-go/bhg/ch-3/metasploit-minimal\ngithub.com/blackhat-go/bhg/ch-3/metasploit-minimal\n|---client\n|   |---main.go\n|---rpc\n    |---msf.go\n```", "```\n[ \"session.list\", \"token\" ]\n```", "```\n{\n\"1\" => {\n    'type' => \"shell\",\n    \"tunnel_local\" => \"192.168.35.149:44444\",\n    \"tunnel_peer\" => \"192.168.35.149:43886\",\n    \"via_exploit\" => \"exploit/multi/handler\",\n    \"via_payload\" => \"payload/windows/shell_reverse_tcp\",\n    \"desc\" => \"Command shell\",\n    \"info\" => \"\",\n    \"workspace\" => \"Project1\",\n    \"target_host\" => \"\",\n    \"username\" => \"root\",\n    \"uuid\" => \"hjahs9kw\",\n    \"exploit_uuid\" => \"gcprpj2a\",\n    \"routes\" => [ ]\n    }\n}\n```", "```\n❶ type sessionListReq struct {\n    ❷ _msgpack struct{} `msgpack:\",asArray\"`\n       Method   string\n       Token    string\n   }\n\n❸ type SessionListRes struct {\n       ID          uint32 `msgpack:\",omitempty\"`❹\n       Type        string `msgpack:\"type\"`\n       TunnelLocal string `msgpack:\"tunnel_local\"`\n       TunnelPeer  string `msgpack:\"tunnel_peer\"`\n       ViaExploit  string `msgpack:\"via_exploit\"`\n       ViaPayload  string `msgpack:\"via_payload\"`\n       Description string `msgpack:\"desc\"`\n       Info        string `msgpack:\"info\"`\n       Workspace   string `msgpack:\"workspace\"`\n       SessionHost string `msgpack\"session_host\"`\n       SessionPort int    `msgpack\"session_port\"`\n       Username    string `msgpack:\"username\"`\n       UUID        string `msgpack:\"uuid\"`\n       ExploitUUID string `msgpack:\"exploit_uuid\"`\n}\n```", "```\n[\"auth.login\", \"username\", \"password\"]\n```", "```\n{ \"result\" => \"success\", \"token\" => \"a1a1a1a1a1a1a1a1\" }\n```", "```\n{\n    \"error\" => true,\n    \"error_class\" => \"Msf::RPC::Exception\",\n    \"error_message\" => \"Invalid User ID or Password\"\n}\n```", "```\n[ \"auth.logout\", \"token\", \"logoutToken\"]\n```", "```\n{ \"result\" => \"success\" }\n```", "```\ntype loginReq struct {\n    _msgpack struct{} `msgpack:\",asArray\"`\n    Method   string\n    Username string\n    Password string\n}\n\ntype loginRes struct {\n    Result       string `msgpack:\"result\"`\n    Token        string `msgpack:\"token\"`\n    Error        bool   `msgpack:\"error\"`\n    ErrorClass   string `msgpack:\"error_class\"`\n    ErrorMessage string `msgpack:\"error_message\"`\n}\n\ntype logoutReq struct {\n    _msgpack    struct{} `msgpack:\",asArray\"`\n    Method      string\n    Token       string\n    LogoutToken string\n}\n\ntype logoutRes struct {\n    Result string `msgpack:\"result\"`\n}\n```", "```\ntype Metasploit struct {\n    host  string\n    user  string\n    pass  string\n    token string\n}\n\nfunc New(host, user, pass string) *Metasploit {\n    msf := &Metasploit{\n        host: host,\n        user: user,\n        pass: pass,\n    }\n\n    return msf\n}\n```", "```\nfunc (msf *Metasploit) send(req interface{}, res interface{})❶ error {\n    buf := new(bytes.Buffer)\n ❷ msgpack.NewEncoder(buf).Encode(req)\n ❸ dest := fmt.Sprintf(\"http://%s/api\", msf.host)\n    r, err := http.Post(dest, \"binary/message-pack\", buf)❹\n    if err != nil {\n        return err\n    }\n    defer r.Body.Close()\n\n    if err := msgpack.NewDecoder(r.Body).Decode(&res)❺; err != nil {\n        return err\n    }\n\n    return nil\n}\n```", "```\nfunc (msf *Metasploit) Login()❶ error {\n    ctx := &loginReq{\n        Method:   \"auth.login\",\n        Username: msf.user,\n        Password: msf.pass,\n    }\n    var res loginRes\n    if err := msf.send(ctx, &res)❷; err != nil {\n        return err\n    }\n    msf.token = res.Token\n    return nil\n}\n\nfunc (msf *Metasploit) Logout()❸ error {\n    ctx := &logoutReq{\n        Method:      \"auth.logout\",\n        Token:       msf.token,\n        LogoutToken: msf.token,\n    }\n    var res logoutRes\n    if err := msf.send(ctx, &res)❹; err != nil {\n        return err\n    }\n    msf.token = \"\"\n    return nil\n}\n\nfunc (msf *Metasploit) SessionList()❺ (map[uint32]SessionListRes, error) {\n    req := &SessionListReq{Method: \"session.list\", Token: msf.token}\n ❻ res := make(map[uint32]SessionListRes)\n    if err := msf.send(req, &res)❼; err != nil {\n        return nil, err\n    }\n\n ❽ for id, session := range res {\n        session.ID = id\n        res[id] = session\n    }\n    return res, nil\n}\n```", "```\nfunc New(host, user, pass string) (*Metasploit, error)❶ {\n    msf := &Metasploit{\n        host: host,\n        user: user,\n        pass: pass,\n    }\n\n    if err := msf.Login()❷; err != nil {\n        return nil, err\n    }\n\n    return msf, nil\n}\n```", "```\npackage main\n\nimport (\n    \"fmt\"\n    \"log\"\n\n    \"github.com/blackhat-go/bhg/ch-3/metasploit-minimal/rpc\"\n)\n\nfunc main() {\n    host := os.Getenv(\"MSFHOST\")\n    pass := os.Getenv(\"MSFPASS\")\n    user := \"msf\"\n\n    if host == \"\" || pass == \"\" {\n        log.Fatalln(\"Missing required environment variable MSFHOST or MSFPASS\")\n    }\n msf, err := rpc.New(host, user, pass)❶\n    if err != nil {\n        log.Panicln(err)\n    }\n ❷ defer msf.Logout()\n\n    sessions, err := msf.SessionList()❸\n    if err != nil {\n        log.Panicln(err)\n    }\n    fmt.Println(\"Sessions:\")\n ❹ for _, session := range sessions {\n        fmt.Printf(\"%5d  %s\\n\", session.ID, session.Info)\n    }\n}\n```", "```\n$ go run main.go\nSessions:\n    1 WIN-HOME\\jsmith @ WIN-HOME\n```", "```\n$ go get github.com/PuerkitoBio/goquery\n```", "```\n$ unzip test.xlsx\n$ tree\n--snip--\n|---docProps\n|   |---app.xml\n|   |---core.xml\n--snip—\n```", "```\n<?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"yes\"?>\n<cp:coreProperties xmlns:cp=\"http://schemas.openxmlformats.org/package/2006/metadata\n/core-properties\"\n\n                   >\n    <dc:creator>Dan Kottmann</dc:creator>❶\n    <cp:lastModifiedBy>Dan Kottmann</cp:lastModifiedBy>❷\n    <dcterms:created xsi:type=\"dcterms:W3CDTF\">2016-12-06T18:24:42Z</dcterms:created>\n    <dcterms:modified xsi:type=\"dcterms:W3CDTF\">2016-12-06T18:25:32Z</dcterms:modified>\n</cp:coreProperties>\n```", "```\n<?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"yes\"?>\n<Properties \n            >\n    <Application>Microsoft Excel</Application>❶\n    <DocSecurity>0</DocSecurity>\n    <ScaleCrop>false</ScaleCrop>\n    <HeadingPairs>\n        <vt:vector size=\"2\" baseType=\"variant\">\n            <vt:variant>\n                <vt:lpstr>Worksheets</vt:lpstr>\n            </vt:variant>\n            <vt:variant>\n                <vt:i4>1</vt:i4>\n            </vt:variant>\n        </vt:vector>\n    </HeadingPairs>\n    <TitlesOfParts>\n        <vt:vector size=\"1\" baseType=\"lpstr\">\n            <vt:lpstr>Sheet1</vt:lpstr>\n        </vt:vector>\n    </TitlesOfParts>\n    <Company>ACME</Company>❷\n    <LinksUpToDate>false</LinksUpToDate>\n    <SharedDoc>false</SharedDoc>\n    <HyperlinksChanged>false</HyperlinksChanged>\n    <AppVersion>15.0300</AppVersion>❸\n</Properties>\n```", "```\ntype OfficeCoreProperty struct {\n    XMLName        xml.Name `xml:\"coreProperties\"`\n    Creator        string   `xml:\"creator\"`\n    LastModifiedBy string   `xml:\"lastModifiedBy\"`\n}\n\ntype OfficeAppProperty struct {\n    XMLName     xml.Name `xml:\"Properties\"`\n    Application string   `xml:\"Application\"`\n    Company     string   `xml:\"Company\"`\n    Version     string   `xml:\"AppVersion\"`\n}\n\nvar OfficeVersions❶ = map[string]string{\n    \"16\": \"2016\",\n    \"15\": \"2013\",\n    \"14\": \"2010\",\n    \"12\": \"2007\",\n    \"11\": \"2003\",\n}\n\nfunc (a *OfficeAppProperty) GetMajorVersion()❷ string {\n    tokens := strings.Split(a.Version, \".\")❸\n\n    if len(tokens) < 2 {\n        return \"Unknown\"\n    }\n    v, ok := OfficeVersions❹ [tokens[0]]\n    if !ok {\n        return \"Unknown\"\n    }\n    return v\n}\n```", "```\nfunc NewProperties(r *zip.Reader) (*OfficeCoreProperty, *OfficeAppProperty, error) {❶\n    var coreProps OfficeCoreProperty\n    var appProps OfficeAppProperty\n\n    for _, f := range r.File {❷\n        switch f.Name {❸\n        case \"docProps/core.xml\":\n            if err := process(f, &coreProps)❹; err != nil {\n                return nil, nil, err\n            }\n        case \"docProps/app.xml\":\n            if err := process(f, &appProps)❺; err != nil {\n                return nil, nil, err\n            }\n        default:\n            continue\n        }\n    }\n    return &coreProps, &appProps, nil\n}\n\nfunc process(f *zip.File, prop interface{}) error {❻\n    rc, err := f.Open()\n    if err != nil {\n        return err\n    }\n    defer rc.Close()\n\n    if err := ❼xml.NewDecoder(rc).Decode(&prop); err != nil {\n        return err\n    }\n    return nil\n}\n```", "```\nsite:nytimes.com && filetype:docx && instreamset:(url title):docx\n```", "```\n❶ func handler(i int, s *goquery.Selection) {\n       url, ok := s.Find(\"a\").Attr(\"href\")❷\n       if !ok {\n           return\n       }\n\n       fmt.Printf(\"%d: %s\\n\", i, url)\n       res, err := http.Get(url)❸\n       if err != nil {\n           return\n       }\n       buf, err := ioutil.ReadAll(res.Body)❹\n       if err != nil {\n           return\n       }\n       defer res.Body.Close()\n\n       r, err := zip.NewReader(bytes.NewReader(buf)❺, int64(len(buf)))\n       if err != nil {\n           return\n       }\n\n       cp, ap, err := metadata.NewProperties(r)❻\n       if err != nil {\n           return\n       }\n\n       log.Printf(\n           \"%25s %25s - %s %s\\n\",\n           cp.Creator,\n           cp.LastModifiedBy,\n           ap.Application,\n           ap.GetMajorVersion())\n   }\n\n   func main() {\n       if len(os.Args) != 3 {\n           log.Fatalln(\"Missing required argument. Usage: main.go domain ext\")\n       }\n       domain := os.Args[1]\n       filetype := os.Args[2]\n\n    ❼ q := fmt.Sprintf(\n           \"site:%s && filetype:%s && instreamset:(url title):%s\",\n           domain,\n           filetype,\n           filetype)\n    ❽ search := fmt.Sprintf(\"http://www.bing.com/search?q=%s\", url.QueryEscape(q))\n       doc, err := goquery.NewDocument(search)❾\n       if err != nil {\n           log.Panicln(err)\n       }\n\n       s := \"html body div#b_content ol#b_results li.b_algo div.b_title h2\"\n    ❿ doc.Find(s).Each(handler)\n  }\n```", "```\n$ go run main.go nytimes.com docx\n0: http://graphics8.nytimes.com/packages/pdf/2012NAIHSAnnualHIVReport041713.docx\n2020/12/21 11:53:50     Jonathan V. Iralu     Dan Frosch - Microsoft Macintosh Word 2010\n1: http://www.nytimes.com/packages/pdf/business/Announcement.docx\n2020/12/21 11:53:51     agouser               agouser - Microsoft Office Outlook 2007\n2: http://www.nytimes.com/packages/pdf/business/DOCXIndictment.docx\n2020/12/21 11:53:51     AGO                   Gonder, Nanci - Microsoft Office Word 2007\n3: http://www.nytimes.com/packages/pdf/business/BrownIndictment.docx\n2020/12/21 11:53:51     AGO                   Gonder, Nanci - Microsoft Office Word 2007\n4: http://graphics8.nytimes.com/packages/pdf/health/Introduction.docx\n2020/12/21 11:53:51     Oberg, Amanda M       Karen Barrow - Microsoft Macintosh Word 2010\n```"]