["```\n\n$ lscpu\n\nArchitecture:          x86_64\n\nCPU op-mode(s):        32-bit, 64-bit\n\nByte Order:            Little Endian\n\nCPU(s):                8\n\nOn-line CPU(s) list:   0-7\n\nThread(s) per core:    2\n\nCore(s) per socket:    4\n\nSocket(s):             1\n\nModel name:            Intel(R) Core(TM) i7-3770 CPU @ 3.40GHz\n\nCPU MHz:               1607.562\n\nCPU max MHz:           3900.0000\n\nCPU min MHz:           1600.0000\n\nL1d cache:             32K\n\nL1i cache:             32K\n\nL2 cache:              256K\n\nL3 cache:              8192K\n\n...\n```", "```\n\nvoid scalar_multiply(int * array, long length, int s) {\n\n    for (i = 0; i < length; i++) {\n\n      array[i] = array[i] * s;\n\n    }\n\n}\n```", "```\n\n#include <stdio.h>\n\n#include <stdlib.h>\n\n#include <pthread.h>\n\n/* The \"thread function\" passed to pthread_create.  Each thread executes this\n\n * function and terminates when it returns from this function. */\n\nvoid *HelloWorld(void *id) {\n\n/* We know the argument is a pointer to a long, so we cast it from a\n\n     * generic (void *) to a (long *). */\n\n    long *myid = (long *) id;\n\n    printf(\"Hello world! I am thread %ld\\n\", *myid);\n\n    return NULL; // We don't need our threads to return anything.\n\n}\n\nint main(int argc, char **argv) {\n\n    int i;\n\n    int nthreads; //number of threads\n\n    pthread_t *thread_array; //pointer to future thread array\n\n    long *thread_ids;\n\n    // Read the number of threads to create from the command line.\n\n    if (argc !=2) {\n\n        fprintf(stderr, \"usage: %s <n>\\n\", argv[0]);\n\n        fprintf(stderr, \"where <n> is the number of threads\\n\");\n\n        return 1;\n\n    }\n\n    nthreads = strtol(argv[1], NULL, 10);\n\n    // Allocate space for thread structs and identifiers.\n\n    thread_array = malloc(nthreads * sizeof(pthread_t));\n\n    thread_ids = malloc(nthreads * sizeof(long));\n\n    // Assign each thread an ID and create all the threads.\n\n    for (i = 0; i < nthreads; i++) {\n\n        thread_ids[i] = i;\n\n        pthread_create(&thread_array[i], NULL, HelloWorld, &thread_ids[i]);\n\n    }\n\n    /* Join all the threads. Main will pause in this loop until all threads\n\n     * have returned from the thread function. */\n\n    for (i = 0; i < nthreads; i++) {\n\n        pthread_join(thread_array[i], NULL);\n\n    }\n\n    free(thread_array);\n\n    free(thread_ids);\n\n    return 0;\n\n} \n```", "```\n\npthread_create(pthread_t *thread, const pthread_attr_t *attr,\n\n               void *thread_function, void *thread_args)\n\n```", "```\npthread_create(&thread_array[i], NULL, HelloWorld, &thread_ids[i]);\n```", "```\n\nfor (i = 0; i < nthreads; i++) {\n\n    thread_ids[i] = i;\n\n    pthread_create(&thread_array[i], NULL, HelloWorld, &thread_ids[i]);\n\n}\n\n```", "```\npthread_join(pthread_t thread, void **return_val)\n```", "```\npthread_join(thread_array[t], NULL);\n```", "```\n for (i = 0; i < nthreads; i++) {\n\n    pthread_join(thread_array[i], NULL);\n\n} \n```", "```\n\nvoid *HelloWorld(void *id) {\n\n    long *myid = (long*)id;\n\n    printf(\"Hello world! I am thread %ld\\n\", *myid);\n\n    return NULL;\n\n}\n\n```", "```\n$ gcc -o hellothreads hellothreads.c -lpthread\n```", "```\n$ ./hellothreads\n\nusage: ./hellothreads <n>\n\nwhere <n> is the number of threads\n```", "```\n$ ./hellothreads 4\n\nHello world! I am thread 1\n\nHello world! I am thread 2\n\nHello world! I am thread 3\n\nHello world! I am thread 0\n```", "```\n$ ./hellothreads 4\n\nHello world! I am thread 0\n\nHello world! I am thread 1\n\nHello world! I am thread 2\n\nHello world! I am thread 3\n```", "```\n\nlong *array; //allocated in main\n\nlong length; //set in main (1 billion)\n\nlong nthreads; //number of threads\n\nlong s; //scalar\n\nvoid *scalar_multiply(void *id) {\n\n    long *myid = (long *) id;\n\n    int i;\n\n    //assign each thread its own chunk of elements to process\n\n    long chunk = length / nthreads;\n\n    long start = *myid * chunk;\n\n    long end  = start + chunk;\n\n    if (*myid == nthreads - 1) {\n\n        end = length;\n\n    }\n\n    //perform scalar multiplication on assigned chunk\n\n    for (i = start; i < end; i++) {\n\n        array[i] *= s;\n\n    }\n\n    return NULL;\n\n}\n\n```", "```\nlong chunk = length / nthreads;\n\nlong start = *myid * chunk;\n\nlong end  = start + chunk;\n```", "```\n\nif (*myid == nthreads - 1) {\n\n    end = length;\n\n}\n\n```", "```\n\nfor (i = start; i < end; i++) {\n\n    array[i] *= s;\n\n}\n\n```", "```\n\nstruct t_arg {\n\n    int *array; // pointer to shared array\n\n    long length; // num elements in array\n\n    long s; //scaling factor\n\n    long numthreads; // total number of threads\n\n    long id; //  logical thread id\n\n};\n\n```", "```\n\nlong nthreads = strtol(argv[1], NULL, 10); //get number of threads\n\nlong length = strtol(argv[2], NULL, 10); //get length of array\n\nlong s = strtol( argv[3], NULL, 10 ); //get scaling factor\n\nint *array = malloc(length*sizeof(int));\n\n//allocate space for thread structs and identifiers\n\npthread_t *thread_array = malloc(nthreads * sizeof(pthread_t));\n\nstruct t_arg *thread_args = malloc(nthreads * sizeof(struct t_arg));\n\n//Populate thread arguments for all the threads\n\nfor (i = 0; i < nthreads; i++){\n\n    thread_args[i].array = array;\n\n    thread_args[i].length = length;\n\n    thread_args[i].s = s;\n\n    thread_args[i].numthreads = nthreads;\n\n    thread_args[i].id = i;\n\n}\n\n```", "```\n\nfor (i = 0; i < nthreads; i++){\n\n    pthread_create(&thread_array[i], NULL, scalar_multiply, &thread_args[i]);\n\n}\n\n```", "```\n\nvoid * scalar_multiply(void* args) {\n\n    //cast to a struct t_arg from void*\n\n    struct t_arg * myargs = (struct t_arg *) args;\n\n    //extract all variables from struct\n\n    long myid =  myargs->id;\n\n    long length = myargs->length;\n\n    long s = myargs->s;\n\n    long nthreads = myargs->numthreads;\n\n    int * ap = myargs->array; //pointer to array in main\n\n    //code as before\n\n    long chunk = length/nthreads;\n\n    long start = myid * chunk;\n\n    long end  = start + chunk;\n\n    if (myid == nthreads-1) {\n\n        end = length;\n\n    }\n\n    int i;\n\n    for (i = start; i < end; i++) {\n\n        ap[i] *= s;\n\n    }\n\n    return NULL;\n\n} \n```", "```\nA = [9, 0, 2, 7, 9, 0, 1, 4, 2, 2, 4, 5, 0, 9, 1]\n```", "```\ncounts = [3, 2, 3, 0, 2, 1, 0, 1, 0, 3]\n```", "```\nA = [0, 0, 0, 1, 1, 2, 2, 2, 4, 4, 5, 7, 9, 9, 9]\n```", "```\n\n#define MAX 10 //the maximum value of an element. (10 means 0-9)\n\n/*step 1:\n\n * compute the frequency of all the elements in the input array and store\n\n * the associated counts of each element in array counts. The elements in the\n\n * counts array are initialized to zero prior to the call to this function.\n\n*/\n\nvoid countElems(int *counts, int *array_A, long length) {\n\n    int val, i;\n\n    for (i = 0; i < length; i++) {\n\n      val = array_A[i]; //read the value at index i\n\n      counts[val] = counts[val] + 1; //update corresponding location in counts\n\n    }\n\n}\n\n/* step 2:\n\n * overwrite the input array (array_A) using the frequencies stored in the\n\n *  array counts\n\n*/\n\nvoid writeArray(int *counts, int *array_A) {\n\n    int i, j = 0, amt;\n\n    for (i = 0; i < MAX; i++) { //iterate over the counts array\n\n        amt = counts[i]; //capture frequency of element i\n\n        while (amt > 0) { //while all values aren't written\n\n            array_A[j] = i; //replace value at index j of array_A with i\n\n            j++; //go to next position in array_A\n\n            amt--; //decrease the amount written by 1\n\n        }\n\n    }\n\n}\n\n/* main function:\n\n * gets array length from command line args, allocates a random array of that\n\n * size, allocates the counts array, the executes step 1 of the CountSort\n\n * algorithm (countsElem) followed by step 2 (writeArray).\n\n*/\n\nint main( int argc, char **argv ) {\n\n    //code ommitted for brevity -- download source to view full file\n\n    srand(10); //use of static seed ensures the output is the same every run\n\n    long length = strtol( argv[1], NULL, 10 );\n\n    int verbose = atoi(argv[2]);\n\n    //generate random array of elements of specified length\n\n    int *array = malloc(length * sizeof(int));\n\n    genRandomArray(array, length);\n\n    //print unsorted array (commented out)\n\n    //printArray(array, length);\n\n    //allocate counts array and initializes all elements to zero.\n\n    int counts[MAX] = {0};\n\n    countElems(counts, array, length); //calls step 1\n\n    writeArray(counts, array); //calls step2\n\n    //print sorted array (commented out)\n\n    //printArray(array, length);\n\n    free(array); //free memory\n\n    return 0;\n\n}\n```", "```\n\n$ ./countSort 15 1\n\narray before sort:\n\n5 8 8 5 8 7 5 1 7 7 3 3 8 3 4\n\nresult after sort:\n\n1 3 3 3 4 5 5 5 7 7 7 8 8 8 8\n\n```", "```\n\n/*parallel version of step 1 (first cut) of CountSort algorithm:\n\n * extracts arguments from args value\n\n * calculates the portion of the array that thread is responsible for counting\n\n * computes the frequency of all the elements in assigned component and stores\n\n * the associated counts of each element in counts array\n\n*/\n\nvoid *countElems( void *args ) {\n\n    struct t_arg * myargs = (struct t_arg *)args;\n\n    //extract arguments (omitted for brevity)\n\n    int *array = myargs->ap;\n\n    long *counts = myargs->countp;\n\n    //... (get nthreads, length, myid)\n\n    //assign work to the thread\n\n    long chunk = length / nthreads; //nominal chunk size\n\n    long start = myid * chunk;\n\n    long end = (myid + 1) * chunk;\n\n    long val;\n\n    if (myid == nthreads-1) {\n\n        end = length;\n\n    }\n\n    long i;\n\n    //heart of the program\n\n    for (i = start; i < end; i++) {\n\n        val = array[i];\n\n        counts[val] = counts[val] + 1;\n\n    }\n\n    return NULL;\n\n}\n\n```", "```\n\nint main(int argc, char **argv) {\n\n    if (argc != 4) {\n\n        //print out usage info (ommitted for brevity)\n\n        return 1;\n\n    }\n\n    srand(10); //static seed to assist in correctness check\n\n    //parse command line arguments\n\n    long t;\n\n    long length = strtol(argv[1], NULL, 10);\n\n    int verbose = atoi(argv[2]);\n\n    long nthreads = strtol(argv[3], NULL, 10);\n\n    //generate random array of elements of specified length\n\n    int *array = malloc(length * sizeof(int));\n\n    genRandomArray(array, length);\n\n    //specify counts array and initialize all elements to zero\n\n    long counts[MAX] = {0};\n\n    //allocate threads and args array\n\n    pthread_t *thread_array; //pointer to future thread array\n\n    thread_array = malloc(nthreads * sizeof(pthread_t)); //allocate the array\n\n    struct t_arg *thread_args = malloc( nthreads * sizeof(struct t_arg) );\n\n    //fill thread array with parameters\n\n    for (t = 0; t < nthreads; t++) {\n\n        //ommitted for brevity...\n\n    }\n\n    for (t = 0; t < nthreads; t++) {\n\n        pthread_create(&thread_array[t], NULL, countElems, &thread_args[t]);\n\n    }\n\n    for (t = 0; t < nthreads; t++) {\n\n        pthread_join(thread_array[t], NULL);\n\n    }\n\n    free(thread_array);\n\n    free(array);\n\nif (verbose) {\n\n        printf(\"Counts array:\\n\");\n\n        printCounts(counts);\n\n    }\n\n    return 0;\n\n} \n```", "```\n\n$ gcc -o countElems_p countElems_p.c -lpthread\n\n$ ./countElems_p 10000000 1 1\n\nCounts array:\n\n999170 1001044 999908 1000431 999998 1001479 999709 997250 1000804 1000207\n\n$ ./countElems_p 10000000 1 2\n\nCounts array:\n\n661756 661977 657828 658479 657913 659308 658561 656879 658070 657276\n\n$ ./countElems_p 10000000 1 4\n\nCounts array:\n\n579846 580814 580122 579772 582509 582713 582518 580917 581963 581094\n\n```", "```\n\nlong i;\n\nfor (i = start; i < end; i++) {\n\n    val = array[i];\n\n    counts[val] = counts[val] + 1; //this line needs to be protected\n\n}\n\n```", "```\npthread_mutex_t mutex;\n```", "```\npthread_mutex_init(&mutex, NULL);\n```", "```\npthread_mutex_destroy(&mutex);\n```", "```\n\npthread_mutex_t mutex; //global declaration of mutex, initialized in main()\n\n/*parallel version of step 1 of CountSort algorithm (attempt 1 with mutexes):\n\n * extracts arguments from args value\n\n * calculates component of the array that thread is responsible for counting\n\n * computes the frequency of all the elements in assigned component and stores\n\n * the associated counts of each element in counts array\n\n*/\n\nvoid *countElems( void *args ) {\n\n    //extract arguments\n\n    //ommitted for brevity\n\n    int *array = myargs->ap;\n\n    long *counts = myargs->countp;\n\n    //assign work to the thread\n\n    long chunk = length / nthreads; //nominal chunk size\n\n    long start = myid * chunk;\n\n    long end = (myid + 1) * chunk;\n\n    long val;\n\n    if (myid == nthreads - 1) {\n\n        end = length;\n\n    }\n\n    long i;\n\n    //heart of the program\n\n    pthread_mutex_lock(&mutex); //acquire the mutex lock\n\n    for (i = start; i < end; i++) {\n\n        val = array[i];\n\n        counts[val] = counts[val] + 1;\n\n    }\n\n    pthread_mutex_unlock(&mutex); //release the mutex lock\n\n    return NULL;\n\n}\n\n```", "```\n\n//code snippet from main():\n\npthread_mutex_init(&mutex, NULL); //initialize the mutex\n\nfor (t = 0; t < nthreads; t++) {\n\n    pthread_create( &thread_array[t], NULL, countElems, &thread_args[t] );\n\n}\n\nfor (t = 0; t < nthreads; t++) {\n\n    pthread_join(thread_array[t], NULL);\n\n}\n\npthread_mutex_destroy(&mutex); //destroy (free) the mutex \n```", "```\n\n$ ./countElems_p_v2 10000000 1 1\n\nCounts array:\n\n999170 1001044 999908 1000431 999998 1001479 999709 997250 1000804 1000207\n\n$ ./countElems_p_v2 10000000 1 2\n\nCounts array:\n\n999170 1001044 999908 1000431 999998 1001479 999709 997250 1000804 1000207\n\n$ ./countElems_p_v2 10000000 1 4\n\nCounts array:\n\n999170 1001044 999908 1000431 999998 1001479 999709 997250 1000804 1000207\n\n```", "```\n\n$ ./countElems_p_v2 100000000 0 1\n\nTime for Step 1 is 0.368126 s\n\n$ ./countElems_p_v2 100000000 0 2\n\nTime for Step 1 is 0.438357 s\n\n$ ./countElems_p_v2 100000000 0 4\n\nTime for Step 1 is 0.519913 s\n```", "```\n //code snippet from the countElems function from earlier\n\n//the heart of the program\n\npthread_mutex_lock(&mutex); //acquire the mutex lock\n\nfor (i = start; i < end; i++){\n\n    val = array[i];\n\n    counts[val] = counts[val] + 1;\n\n}\n\npthread_mutex_unlock(&mutex); //release the mutex lock \n```", "```\n\n/*modified code snippet of countElems function:\n\n *locks are now placed INSIDE the for loop!\n\n*/\n\n//the heart of the program\n\nfor (i = start; i < end; i++) {\n\n    val = array[i];\n\n    pthread_mutex_lock(&m); //acquire the mutex lock\n\n    counts[val] = counts[val] + 1;\n\n    pthread_mutex_unlock(&m); //release the mutex lock\n\n}\n\n```", "```\n\n$ ./countElems_p_v3 10000000 1 1\n\nCounts array:\n\n999170 1001044 999908 1000431 999998 1001479 999709 997250 1000804 1000207\n\n$ ./countElems_p_v3 10000000 1 2\n\nCounts array:\n\n999170 1001044 999908 1000431 999998 1001479 999709 997250 1000804 1000207\n\n$ ./countElems_p_v3 10000000 1 4\n\nCounts array:\n\n999170 1001044 999908 1000431 999998 1001479 999709 997250 1000804 1000207 \n```", "```\n\n$ ./countElems_p_v3 100000000 0 1\n\nTime for Step 1 is 1.92225 s\n\n$ ./countElems_p_v3 100000000 0 2\n\nTime for Step 1 is 10.9704 s\n\n$ ./countElems_p_v3 100000000 0 4\n\nTime for Step 1 is 9.13662 s\n\n```", "```\n\n/*parallel version of step 1 of CountSort algorithm (final attempt w/mutexes):\n\n * extracts arguments from args value\n\n * calculates component of the array that thread is responsible for counting\n\n * computes the frequency of all the elements in assigned component and stores\n\n * the associated counts of each element in counts array\n\n*/\n\nvoid *countElems( void *args ) {\n\n    //extract arguments\n\n    //ommitted for brevity\n\n    int *array = myargs->ap;\n\n    long *counts = myargs->countp;\n\n    //local declaration of counts array, initializes every element to zero.\n\n    long local_counts[MAX] = {0};\n\n    //assign work to the thread\n\n    long chunk = length / nthreads; //nominal chunk size\n\n    long start = myid * chunk;\n\n    long end = (myid + 1) * chunk;\n\n    long val;\n\n    if (myid == nthreads-1)\n\n        end = length;\n\n    long i;\n\n    //heart of the program\n\n    for (i = start; i < end; i++) {\n\n        val = array[i];\n\n        //updates local counts array\n\n        local_counts[val] = local_counts[val] + 1;\n\n    }\n\n    //update to global counts array\n\n    pthread_mutex_lock(&mutex); //acquire the mutex lock\n\n    for (i = 0; i < MAX; i++) {\n\n        counts[i] += local_counts[i];\n\n    }\n\n    pthread_mutex_unlock(&mutex); //release the mutex lock\n\nreturn NULL;\n\n} \n```", "```\n\n$ ./countElems_p_v3 100000000 0 1\n\nTime for Step 1 is 0.334574 s\n\n$ ./countElems_p_v3 100000000 0 2\n\nTime for Step 1 is 0.209347 s\n\n$ ./countElems_p_v3 100000000 0 4\n\nTime for Step 1 is 0.130745 s\n\n```", "```\n\nstruct account {\n\n    pthread_mutex_t lock;\n\n    int balance;\n\n};\n\n```", "```\n\nvoid *Transfer(void *args){\n\n    //argument passing removed to increase readability\n\n    //...\n\n    pthread_mutex_lock(&fromAcct->lock);\n\n    pthread_mutex_lock(&toAcct->lock);\n\n    fromAcct->balance -= amt;\n\n    toAcct->balance += amt;\n\n    pthread_mutex_unlock(&fromAcct->lock);\n\n    pthread_mutex_unlock(&toAcct->lock);\n\n    return NULL;\n\n}\n\n```", "```\n\nvoid *Transfer(void *args){\n\n    //argument passing removed to increase readability\n\n    //...\n\n    pthread_mutex_lock(&fromAcct->lock);\n\n    fromAcct->balance -= amt;\n\n    pthread_mutex_unlock(&fromAcct->lock);\n\n    pthread_mutex_lock(&toAcct->lock);\n\n    toAcct->balance += amt;\n\n    pthread_mutex_unlock(&toAcct->lock);\n\n    return NULL;\n\n}\n\n```", "```\n\nvoid *threadEx(void *args){\n\n    //parse args\n\n    //...\n\n    long myid = myargs->id;\n\n    int nthreads = myargs->numthreads;\n\n    int *array = myargs->array\n\n    printf(\"Thread %ld starting thread work!\\n\", myid);\n\n    pthread_barrier_wait(&barrier); //forced synchronization point\n\n    printf(\"All threads have reached the barrier!\\n\");\n\n    for (i = start; i < end; i++) {\n\n        array[i] = array[i] * 2;\n\n    }\n\n    printf(\"Thread %ld done with work!\\n\", myid);\n\n    return NULL;\n\n}\n\n```", "```\n\nint main(int argc, char **argv){\n\n    //... declarations omitted for brevity\n\n    // these will be shared by all threads via pointer fields in t_args\n\n    int num_eggs;           // number of eggs ready to collect\n\n    pthread_mutex_t mutex;  // mutex associated with cond variable\n\n    pthread_cond_t  eggs;   // used to block/wake-up farmer waiting for eggs\n\n    //... args parsing removed for brevity\n\n    num_eggs = 0; // number of eggs ready to collect\n\n    ret = pthread_mutex_init(&mutex, NULL); //initialize the mutex\n\n    pthread_cond_init(&eggs, NULL); //initialize the condition variable\n\n    //... thread_array and thread_args creation/filling omitted for brevity\n\n    // create some chicken and farmer threads\n\n    for (i = 0; i < (2 * nthreads); i++) {\n\n        if ( (i % 2) == 0 ) {\n\n            ret = pthread_create(&thread_array[i], NULL,\n\nchicken, &thread_args[i]);\n\n        }\n\n        else {\n\n            ret = pthread_create(&thread_array[i], NULL,\n\n                                 farmer, &thread_args[i] );\n\n        }\n\n    }\n\n    // wait for chicken and farmer threads to exit\n\n    for (i = 0; i < (2 * nthreads); i++)  {\n\n        ret = pthread_join(thread_array[i], NULL);\n\n    }\n\n    // clean-up program state\n\n    pthread_mutex_destroy(&mutex); //destroy the mutex\n\n    pthread_cond_destroy(&eggs);   //destroy the cond var\n\n    return 0;\n\n} \n```", "```\n\nvoid *chicken(void *args ) {\n\n    struct t_arg *myargs = (struct t_arg *)args;\n\n    int *num_eggs, i, num;\n\n    num_eggs = myargs->num_eggs;\n\n    i = 0;\n\n    // lay some eggs\n\n    for (i = 0; i < myargs->total_eggs; i++) {\n\n        usleep(EGGTIME); //chicken sleeps\n\n        pthread_mutex_lock(myargs->mutex);\n\n        *num_eggs = *num_eggs + 1;  // update number of eggs\n\n        num = *num_eggs;\n\n        pthread_cond_signal(myargs->eggs); // wake a sleeping farmer (squawk)\n\n        pthread_mutex_unlock(myargs->mutex);\n\n        printf(\"chicken %d created egg %d available %d\\n\",myargs->id,i,num);\n\n    }\n\n    return NULL;\n\n}\n\n```", "```\n\nvoid *farmer(void *args ) {\n\n    struct t_arg * myargs = (struct t_arg *)args;\n\n    int *num_eggs, i, num;\n\n    num_eggs = myargs->num_eggs;\n\n    i = 0;\n\n    for (i = 0; i < myargs->total_eggs; i++) {\n\n        pthread_mutex_lock(myargs->mutex);\n\n        while (*num_eggs == 0 ) { // no eggs to collect\n\n            // wait for a chicken to lay an egg\n\n            pthread_cond_wait(myargs->eggs, myargs->mutex);\n\n        }\n\n        // we hold mutex lock here and num_eggs > 0\n\n        num = *num_eggs;\n\n        *num_eggs = *num_eggs - 1;\n\n        pthread_mutex_unlock(myargs->mutex);\n\n        printf(\"farmer %d gathered egg %d available %d\\n\",myargs->id,i,num);\n\n    }\n\n    return NULL;\n\n}\n\n```", "```\n // mutex (initialized in main)\n\npthread_mutex_t mutex;\n\n// condition variable signifying the barrier (initialized in main)\n\npthread_cond_t barrier;\n\nvoid *threadEx_v2(void *args){\n\n    // parse args\n\n    // ...\n\n    long myid = myargs->id;\n\n    int nthreads = myargs->numthreads;\n\n    int *array = myargs->array\n\n    // counter denoting the number of threads that reached the barrier\n\n    int *n_reached = myargs->n_reached;\n\n    // start barrier code\n\n    pthread_mutex_lock(&mutex);\n\n    *n_reached++;\n\n    printf(\"Thread %ld starting work!\\n\", myid)\n\n    // if some threads have not reached the barrier\n\n    while (*n_reached < nthreads) {\n\n        pthread_cond_wait(&barrier, &mutex);\n\n    }\n\n    // all threads have reached the barrier\n\n    printf(\"all threads have reached the barrier!\\n\");\n\n    pthread_cond_broadcast(&barrier);\n\n    pthread_mutex_unlock(&mutex);\n\n    // end barrier code\n\n    // normal thread work\n\n    for (i = start; i < end; i++) {\n\n        array[i] = array[i] * 2;\n\n    }\n\n    printf(\"Thread %ld done with work!\\n\", myid);\n\n    return NULL;\n\n} \n```", "```\n $ ./countElems_p_v3 100000000 0 1\n\nTime for Step 1 is 0.331831 s\n\n$ ./countElems_p_v3 100000000 0 2\n\nTime for Step 1 is 0.197245 s\n\n$ ./countElems_p_v3 100000000 0 4\n\nTime for Step 1 is 0.140642 s\n\n$ ./countElems_p_v3 100000000 0 8\n\nTime for Step 1 is 0.107649 s \n```", "```\n\n/*parallel version of step 1 (first cut) of CountSort algorithm:\n\n * extracts arguments from args value\n\n * calculates portion of the array this thread is responsible for counting\n\n * computes the frequency of all the elements in assigned component and stores\n\n * the associated counts of each element in counts array\n\n*/\n\nvoid *countElems(void *args){\n\n    //extract arguments\n\n    //ommitted for brevity\n\n    int *array = myargs->ap;\n\n    long *counts = myargs->countp;\n\n    //assign work to the thread\n\n    //compute chunk, start, and end\n\n    //ommited for brevity\n\n    long i;\n\n    //heart of the program\n\n    for (i = start; i < end; i++){\n\n        val = array[i];\n\n        counts[val] = counts[val] + 1;\n\n    }\n\n    return NULL;\n\n}\n\n```", "```\n\n$ ./countElems_p 100000000 0 1\n\nTime for Step 1 is 0.336239 s\n\n$ ./countElems_p 100000000 0 2\n\nTime for Step 1 is 0.799464 s\n\n$ ./countElems_p 100000000 0 4\n\nTime for Step 1 is 0.767003 s\n\n```", "```\n\n$ ls /sys/devices/system/cpu/cpu0/cache/index0\n\ncoherency_line_size      power            type\n\nlevel                    shared_cpu_list  uevent\n\nnumber_of_sets           shared_cpu_map   ways_of_associativity\n\nphysical_line_partition  size\n\n```", "```\n$ cat /sys/devices/system/cpu/cpu0/cache/coherency_line_size\n\n64\n```", "```\n\n/*parallel version of CountSort algorithm step 1 (final attempt with mutexes):\n\n * extracts arguments from args value\n\n * calculates the portion of the array this thread is responsible for counting\n\n * computes the frequency of all the elements in assigned component and stores\n\n * the associated counts of each element in counts array\n\n*/\n\nvoid *countElems( void *args ){\n\n    //extract arguments\n\n    //omitted for brevity\n\n    int *array = myargs->ap;\n\n    long *counts = myargs->countp;\n\n    long local_counts[MAX] = {0}; //local declaration of counts array\n\n    //assign work to the thread\n\n    //compute chunk, start, and end values (omitted for brevity)\n\n    long i;\n\n    //heart of the program\n\n    for (i = start; i < end; i++){\n\n        val = array[i];\n\n        local_counts[val] = local_counts[val] + 1; //update local counts array\n\n    }\n\n    //update to global counts array\n\n    pthread_mutex_lock(&mutex); //acquire the mutex lock\n\n    for (i = 0; i < MAX; i++){\n\n        counts[i] += local_counts[i];\n\n    }\n\n    pthread_mutex_unlock(&mutex); //release the mutex lock\n\n    return NULL;\n\n} \n```", "```\n\nfor (i = start; i < end; i++){\n\n    val = array[i];\n\n    local_counts[val] = local_counts[val] + 1; //updates local counts array\n\n}\n\n```", "```\n\n//update to global counts array\n\npthread_mutex_lock(&mutex); //acquire the mutex lock\n\nfor (i = 0; i < MAX; i++){\n\n    counts[i] += local_counts[i];\n\n}\n\npthread_mutex_unlock(&mutex); //release the mutex lock\n\n```", "```\n\n/* computes the frequency of all the elements in the input string and stores\n\n * the associated counts of each element in the array called counts. */\n\nvoid countElemsStr(int *counts, char *input_str) {\n\n    int val, i;\n\n    char *token;\n\n    token = strtok(input_str, \" \");\n\n    while (token != NULL) {\n\n        val = atoi(token);\n\n        counts[val] = counts[val] + 1;\n\n        token = strtok(NULL, \" \");\n\n}\n\n}\n\n/* main function:\n\n * calls countElemsStr on a static string and counts up all the digits in\n\n * that string. */\n\nint main( int argc, char **argv ) {\n\n    //lines omitted for brevity, but gets user defined length of string\n\n    //fill string with n digits\n\n    char *inputString = calloc(length * 2, sizeof(char));\n\n    fillString(inputString, length * 2);\n\n    countElemsStr(counts, inputString);\n\n    return 0;\n\n} \n```", "```\n\n$ gcc -o countElemsStr countElemsStr.c\n\n$ ./countElemsStr 100000 1\n\ncontents of counts array:\n\n9963 9975 9953 10121 10058 10017 10053 9905 9915 10040\n\n```", "```\n\n/* parallel version of countElemsStr (First cut):\n\n * computes the frequency of all the elements in the input string and stores\n\n * the associated counts of each element in the array called counts\n\n*/\n\nvoid *countElemsStr(void *args) {\n\n    //parse args\n\n    struct t_arg *myargs = (struct t_arg *)args;\n\n    //omitted for brevity\n\n    //local variables\n\n    int val, i;\n\n    char *token;\n\n    int local_counts[MAX] = {0};\n\n    //compute local start and end values and chunk size:\n\n    //omitted for brevity\n\n//tokenize values\n\n    token = strtok(input_str + start, \" \");\n\n    while (token != NULL) {\n\n        val = atoi(token); //convert to an int\n\n        local_counts[val] = local_counts[val] + 1; //update associated counts\n\n        token = strtok(NULL, \" \");\n\n    }\n\n    pthread_mutex_lock(&mutex);\n\n    for (i = 0; i < MAX; i++) {\n\n        counts[i] += local_counts[i];\n\n    }\n\n    pthread_mutex_unlock(&mutex);\n\n    return NULL;\n\n} \n```", "```\n\n$ gcc -o countElemsStr_p countElemsStr_p.c -lpthread\n\n$ ./countElemsStr_p 100000 1 1\n\ncontents of counts array:\n\n9963 9975 9953 10121 10058 10017 10053 9905 9915 10040\n\n$ ./countElemsStr_p 100000 1 2\n\ncontents of counts array:\n\n498 459 456 450 456 471 446 462 450 463\n\n$ ./countElemsStr_p 100000 1 4\n\ncontents of counts array:\n\n5038 4988 4985 5042 5056 5013 5025 5035 4968 5065\n\n```", "```\n /* parallel version of countElemsStr (First cut):\n\n * computes the frequency of all the elements in the input string and stores\n\n * the associated counts of each element in the array called counts */\n\nvoid* countElemsStr(void* args) {\n\n    //parse arguments\n\n    //omitted for brevity\n\n    //local variables\n\n    int val, i;\n\n    char * token;\n\n    int local_counts[MAX] = {0};\n\n    char * saveptr; //for saving state of strtok_r\n\n    //compute local start and end values and chunk size:\n\n    //omitted for brevity\n\n    //tokenize values\n\n    token = strtok_r(input_str+start, \" \", &saveptr);\n\n    while (token != NULL) {\n\n        val = atoi(token); //convert to an int\n\n        local_counts[val] = local_counts[val]+1; //update associated counts\n\n        token = strtok_r(NULL, \" \", &saveptr);\n\n    }\n\n    pthread_mutex_lock(&mutex);\n\n    for (i = 0; i < MAX; i++) {\n\n        counts[i]+=local_counts[i];\n\n    }\n\n    pthread_mutex_unlock(&mutex);\n\n    return NULL;\n\n} \n```", "```\n\n$ gcc -o countElemsStr_p_v2 countElemsStr_p_v2.c -lpthread\n\n$ ./countElemsStr_p_v2 100000 1 1\n\ncontents of counts array:\n\n9963 9975 9953 10121 10058 10017 10053 9905 9915 10040\n\n$ ./countElemsStr_p_v2 100000 1 2\n\ncontents of counts array:\n\n9963 9975 9953 10121 10058 10017 10053 9905 9915 10040\n\n$ ./countElemsStr_p_v2 100000 1 4\n\ncontents of counts array:\n\n9963 9975 9953 10121 10058 10017 10053 9905 9915 10040 \n```", "```\n\n#include <stdio.h>\n\n#include <stdlib.h>\n\n#include <omp.h>\n\nvoid HelloWorld( void ) {\n\n    long myid = omp_get_thread_num();\n\n    printf( \"Hello world! I am thread %ld\\n\", myid );\n\n}\n\nint main( int argc, char** argv ) {\n\n    long nthreads;\n\n    if (argc !=2) {\n\n        fprintf(stderr, \"usage: %s <n>\\n\", argv[0]);\n\n        fprintf(stderr, \"where <n> is the number of threads\\n\");\n\n        return 1;\n\n    }\n\n    nthreads = strtol( argv[1], NULL, 10 );\n\n    #pragma omp parallel num_threads(nthreads)\n\n        HelloWorld();\n\n    return 0;\n\n}\n\n```", "```\n $ gcc -o hello_mp hello_mp.c -fopenmp\n\n$ ./hello_mp 4\n\nHello world! I am thread 2\n\nHello world! I am thread 3\n\nHello world! I am thread 0\n\nHello world! I am thread 1 \n```", "```\n\n$ ./hello_mp 4\n\nHello world! I am thread 3\n\nHello world! I am thread 2\n\nHello world! I am thread 1\n\nHello world! I am thread 0\n\n```", "```\n\nint main( int argc, char **argv ) {\n\n    //parse args (omitted for brevity)\n\n    srand(10); //use of static seed ensures the output is the same every run\n\n    //generate random array of elements of specified length\n\n    //(omitted for brevity)\n\n    //allocate counts array and initializes all elements to zero.\n\n    int counts[MAX] = {0};\n\n    countElems(counts, array, length); //calls step 1\n\n    writeArray(counts, array); //calls step2\n\n    free(array); //free memory\n\n    return 0;\n\n}\n\n```", "```\n\nvoid countElems(int *counts, int *array, long length) {\n\n    #pragma omp parallel default(none) shared(counts, array, length)\n\n    {\n\n        int val, i, local[MAX] = {0};\n\n        #pragma omp for\n\n        for (i = 0; i < length; i++) {\n\n            val = array[i];\n\n            local[val]++;\n\n        }\n\n       #pragma omp critical\n\n       {\n\n           for (i = 0; i < MAX; i++) {\n\n               counts[i] += local[i];\n\n           }\n\n       }\n\n   }\n\n}\n\n```", "```\n\n$ ./countElems_mp 100000000 1\n\nRun Time for Phase 1 is 0.249893\n\n$ ./countElems_mp 100000000 2\n\nRun Time for Phase 1 is 0.124462\n\n$ ./countElems_mp 100000000 4\n\nRun Time for Phase 1 is 0.068749\n\n```", "```\n\nvoid writeArray(int *counts, int *array) {\n\n    int i;\n\n    //assumed the number of threads is no more than MAX\n\n    #pragma omp parallel for schedule(dynamic)\n\n    for (i = 0; i < MAX; i++) {\n\n        int j = 0, amt, start = 0;\n\n        for (j = 0; j < i; j++) {  //calculate the \"true\" start position\n\n            start += counts[j];\n\n        }\n\n        amt = counts[i]; //the number of array positions to fill\n\n        //overwrite amt elements with value i, starting at position start\n\n        for (j = start; j < start + amt; j++) {\n\n            array[j] = i;\n\n        }\n\n    }\n\n}\n\n```"]