<html xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops" xmlns:ns="http://www.w3.org/2001/10/synthesis" lang="en-us" xml:lang="en-us">
	<head>
		<title>Ethical Hacking: A Hands-on Introduction to Breaking In</title>
		<link href="../styles/9781718501881.css" rel="stylesheet" type="text/css"/>
<meta content="urn:uuid:3776231c-affd-4772-8376-b44c973236be" name="Adept.expected.resource"/>
	</head>
	<body>
		<h2 class="h2" id="ch6"><span epub:type="pagebreak" id="page_89"/><strong><span class="big">6</span><br/>TLS AND DIFFIE-HELLMAN</strong></h2>
		<p class="verse"><em>The world is a dangerous place to live, not because of the people who are evil, but because of the people who don’t do anything about it.</em></p>
		<p class="chap-au">–Albert Einstein</p>
		<div class="imagec">
			<img alt="image" src="../images/common.jpg"/>
		</div>
		<p class="noindents">In <a href="ch04.xhtml#ch4">Chapter 4</a>, you used TCP and UDP sockets to send data between machines on the internet. But, as you observed, the data sent through these sockets wasn’t encrypted, so anybody who captured it could read it.</p>
		<p class="indent">To communicate securely, you must encrypt data before sending it. Figuring out how to do this effectively proved challenging to the security community at first because asymmetric cryptography techniques are too slow to encrypt a stream of data without causing lags. Efficient encryption requires both parties to first set up a shared symmetric key, which is used to encrypt traffic with less overhead. The <em>transport layer security (TLS)</em> protocol uses asymmetric cryptography techniques to set up this shared symmetric key. TLS is used in all sorts of applications that require secure communication, such as apps that control military drones or transmit large bank transactions. These days, most websites use HTTPS to secure their communication, and HTTPS depends on TLS.</p>
		<p class="indent">In this chapter, you’ll learn how TLS communications work and how the Diffie-Hellman key exchange algorithm generates the keys required for it. Then, you’ll write a Python program that uses TLS to establish a secure <span epub:type="pagebreak" id="page_90"/>communication channel. We’ll conclude by discussing how an attacker might decrypt an encrypted channel.</p>
		<h3 class="h3" id="ch06lev1"><strong>Transport Layer Security</strong></h3>
		<p class="noindent">Recall from <a href="ch05.xhtml#ch5">Chapter 5</a> that symmetric-key cryptography uses a single key to both encrypt and decrypt a file. This technique is fast, but it has a downside: both parties must share the key somehow. On the other hand, asymmetrickey cryptography relies on a public-private key pair to send a message, meaning that it doesn’t have this limitation.</p>
		<p class="indent">Using both techniques, TLS establishes an encrypted communication channel between two parties. To set up their encrypted channel, the two parties must exchange only two messages. <a href="ch06.xhtml#ch6fig1">Figure 6-1</a> shows a simplified overview of the process for TLS 1.3 (currently the most secure version).</p>
		<div class="image" id="ch6fig1">
			<img alt="image" src="../images/ch06fig01.jpg"/>
		</div>
		<p class="figcap"><em>Figure 6-1: The TLS message exchange</em></p>
		<p class="indent">The client starts the connection by sending a <em>Client Hello</em> message, which contains the client’s public key share and nonce. The server then combines its private key with the client’s public-key share to compute a new symmetric key. The server can now use this symmetric key to encrypt and decrypt future messages. However, the server still needs to share some information with the client so that the client can also calculate the same symmetric key. To do this, the server sends a <em>Server Hello</em> message that contains an unencrypted copy of the server’s public-key share and nonce. The client then combines its private key with the server’s public key share to calculate the same symmetric key, which it will use to encrypt and decrypt all future messages. Voilà! Now the client and server have both calculated the same symmetric key without directly sending the key. How is this possible? They both combined different pieces of information but still calculated the same key. In this chapter, I’ll talk about the algorithms that makes this possible.</p>
		<p class="indent"><span epub:type="pagebreak" id="page_91"/>Because the server knows that the client will be able to decrypt information after it receives the server’s public-key share and nonce, the server will also include some encrypted information about the server’s identity (its certificate) and proof of the message’s authenticity. Let’s delve into TLS further by exploring how the client proves the message’s authenticity.</p>
		<h4 class="h4" id="ch06lev2"><strong><em>Message Authentication</em></strong></h4>
		<p class="noindent">Encryption prevents hackers from deciphering messages, but it doesn’t prevent tampering. In a public network, a hacker can alter a decrypted message by changing bits in the encrypted message. <a href="ch06.xhtml#ch6fig2">Figure 6-2</a> shows how modifying an encrypted message can change the decrypted outcome.</p>
		<div class="image" id="ch6fig2">
			<img alt="image" src="../images/ch06fig02.jpg"/>
		</div>
		<p class="figcap"><em>Figure 6-2: How a hacker can modify an encrypted message and affect the decrypted outcome</em></p>
		<p class="indent">This isn’t an issue for TLS users, because they can detect when a message has changed and reject it. Imagine that whenever you sent a package through the mail, you wrote the package’s weight on a tag. A recipient could verify the package by comparing its weight to the one listed on the tag. If the weight matches, the recipient can be confident nothing has been added or removed.</p>
		<p class="indent">TLS uses <em>hash-based message authentication codes (HMACs)</em> to verify messages. The HMAC function uses a cryptographic hash function to generate a unique hash of each message. A <em>hash function</em> creates the same fixed-length string when given the same input. The message’s recipient reapplies HMAC and compares the two hashes. If a message is altered, its hash will be different, but if the hashes match, the message is authentic.</p>
		<p class="indent">Hash functions by themselves do not provide authenticity. Because they’re publicly commutable, a hacker could modify a message and recompute its hash. To ensure that the hash was generated by a trusted party, it must be combined with the shared symmetric key computed during the key exchange. This <em>signed</em> hash is called a <em>message authentication code</em>. Following is the equation for the HMAC function:</p>
		<p class="center">HMAC(<em>K</em>, <em>m</em>) = H((<em>K<sup>′</sup></em> <span class="ent">⊕</span> <em>opad</em>) ∥ ((<em>K<sup>′</sup></em> <span class="ent">⊕</span> <em>ipad</em>) ∥ <em>m</em>))</p>
		<p class="indent"><span epub:type="pagebreak" id="page_92"/>Here, <em>K</em> represents the shared symmetric key, and <em>m</em> represents the encrypted message. <em>H</em> represents the hash function, most commonly SHA3256. <em>K<sup>′</sup></em> is a block size version of the key. The ∥ operator represents bit-level concatenating of two pieces of information. Lastly, <em>opad</em> and <em>ipad</em> are two constants that are there for legacy reasons.</p>
		<p class="indent">Once a message is encrypted, it’s then hashed and signed by the HMAC function. The MAC is then attached to the message and sent. Only a person with the secret symmetric key can change the hash.</p>
		<h4 class="h4" id="ch06lev3"><strong><em>Certificate Authorities and Signatures</em></strong></h4>
		<p class="noindent">A hacker can pretend to be any machine on the network, so how can Bob be confident he is communicating with Alice? At the beginning of the TLS handshake, Alice provides Bob with her <em>certificate</em>, a digital document that proves Alice owns the public key she provided. Bob validates Alice’s certificate by checking its signature using the signature verification algorithm (<a href="ch06.xhtml#ch6fig3">Figure 6-3</a>).</p>
		<div class="image" id="ch6fig3">
			<img alt="image" src="../images/ch06fig03.jpg"/>
		</div>
		<p class="figcap"><em>Figure 6-3: The signature creation and verification process</em></p>
		<h5 class="h5" id="ch06lev4"><strong>Signatures</strong></h5>
		<p class="noindent">You could use the RSA algorithm discussed in <a href="ch05.xhtml#ch5">Chapter 5</a> to create a signature algorithm. To sign a certificate message <em>m</em>, first compute a hash <em>H</em>(<em>m</em>) with SHA-256 and then encrypt the result with a private key <em>sk</em> (which stands for secret key). The resulting cipher text represents your signature <em>s</em>:</p>
		<p class="center">Sign(<em>m</em>, <em>sk</em>) = <em>E</em>(<em>H</em>(<em>m</em>), <em>sk</em>) = <em>s</em></p>
		<p class="indent"><span epub:type="pagebreak" id="page_93"/>Verify the certificate or message (<em>m</em>) by using the public key (<em>pk</em>) to decrypt (<em>D</em>) the signature (<em>s</em>). The signature is valid if <em>H</em>(<em>m</em>) matches <em>s</em>:</p>
		<p class="center">Ver(<em>m</em>, <em>s</em>, <em>pk</em>) = <em>D</em>(<em>s</em>, <em>pk</em>) == <em>H</em>(<em>m</em>)</p>
		<p class="noindent"><a href="ch06.xhtml#ch6fig3">Figure 6-3</a> shows an overview of the process of signing a message that Alice sends to Bob.</p>
		<h4 class="h4" id="ch06lev5"><strong><em>Certificate Authorities</em></strong></h4>
		<p class="noindent">For a certificate to be valid, the internet’s trusted <em>public key infrastructure (PKI)</em> must have signed it. The PKI is a collection of secure servers that sign and store certified copies of certificates. Alice pays to register her certificate with an <em>intermediate certificate authority (ICA)</em>, so Bob can verify Alice’s certificate during the TLS handshake.</p>
		<p class="indent">How does Bob know that he can trust the ICA? Bob’s browser has been preprogrammed with the ICA’s public key, so it trusts messages signed with the ICA’s private key. <a href="ch06.xhtml#ch6fig4">Figure 6-4</a> shows an overview of the certificate validation process.</p>
		<div class="image" id="ch6fig4">
			<img alt="image" src="../images/ch06fig04.jpg"/>
		</div>
		<p class="figcap"><em>Figure 6-4: An overview of the certificate validation process</em></p>
		<p class="indent">Alice’s certificate contains her public key and an ICA-signed hash of the certificate. When Bob’s browser receives the certificate, it decrypts the hash and verifies the certificate by comparing the computed hash with the decrypted hash.</p>
		<p class="indent">Browsers sometimes receive a certificate from an ICA whose public key they haven’t stored. In these cases, the browser must use its other public keys to validate the ICA’s certificate. There are 14 root certificate authorities <span epub:type="pagebreak" id="page_94"/>(CAs) in the world, and all browsers must include their public keys. When a root CA trusts an ICA, it signs that ICA’s certificate. When Alice provides her certificate, she also provides a signed copy of all the CA certificates Bob needs to verify her certificate. <a href="ch06.xhtml#ch6fig5">Figure 6-5</a> shows the list of certificates used to trust the <em>virginia.edu</em> certificate. You can view the certification path in Google Chrome by clicking the lock icon on the left-hand side of the URL bar and then selecting the certificate from the drop-down menu.</p>
		<div class="image" id="ch6fig5">
			<img alt="image" src="../images/ch06fig05.jpg"/>
		</div>
		<p class="figcap"><em>Figure 6-5: The path of official certificates</em></p>
		<p class="indent">Let’s examine this certificate path. The root CA (Sectigo) validates the ICA (InCommon) by signing a hash of InCommon’s certificate. When Bob’s browser receives <em>virginia.edu</em>’s certificate, it first validates InCommon’s certificate by verifying the hash Sectigo provided. If the hashes match, Bob’s browser can trust InCommon’s certificate and will use InCommon’s public key to decrypt the hash of <em>virginia.edu</em>’s certificate.</p>
		<p class="indent">In this example, the certification path is only three levels deep. For longer paths, the browser starts at the root certificate and follows the path until it reaches the last certificate, validating each certificate along the way.</p>
		<h3 class="h3" id="ch06lev6"><strong>Using Diffie-Hellman to Compute a Shared Key</strong></h3>
		<p class="noindent">Before two parties can encrypt packets, they must compute a shared key. One way they can do that is with the <em>Diffie-Hellman</em> key exchange algorithm. In this section, we’ll look at the six steps of the Diffie-Hellman key exchange. <a href="ch06.xhtml#ch6tab1">Table 6-1</a> provides a summary of all the steps. Don’t worry if it seems complicated; I’ll explain each of these steps in the subsections that follow.</p>
		<p class="indent">Often, hackers manage to break some encryption because they discover mistakes in the design or implementation of a cryptographic algorithm. At the end of this section, we’ll examine how state actors like the NSA could break Diffie-Hellman encryption.</p>
		<p class="tabcap" id="ch6tab1"><span epub:type="pagebreak" id="page_95"/><strong>Table 6-1:</strong> The Steps Used to Establish a Shared Key in a Diffie-Hellman Key Exchange</p>
		<table class="bordertb">
			<colgroup>
				<col style="width:10%"/>
				<col style="width:45%"/>
				<col style="width:45%"/>
			</colgroup>
			<thead>
				<tr>
					<th class="borderb" style="vertical-align: top;">
						<p class="tab">Step</p>
					</th>
					<th class="borderb" style="vertical-align: top;">
						<p class="tab-c">Alice</p>
					</th>
					<th class="borderb" style="vertical-align: top;">
						<p class="tab-c">Bob</p>
					</th>
				</tr>
			</thead>
			<tbody>
				<tr>
					<td class="borderb" style="vertical-align: top;">
						<p class="tab">1</p>
					</td>
					<td class="borderb" colspan="2" style="vertical-align: top;">
						<p class="tab-c">Shared Parameter: <em>g</em></p>
					</td>
				</tr>
				<tr>
					<td style="vertical-align: top;">
						<p class="tab">2</p>
					</td>
					<td style="vertical-align: top;">
						<p class="tab-c"><em>A</em> = <em>random</em></p>
					</td>
					<td style="vertical-align: top;">
						<p class="tab-c"><em>B</em> = <em>random</em></p>
					</td>
				</tr>
				<tr>
					<td class="borderb" style="vertical-align: top;">
						<p class="tab"/>
			</td>
					<td class="borderb" style="vertical-align: top;">
						<p class="tab-c"><em>a</em> = <em>g<sup>A</sup></em></p>
					</td>
					<td class="borderb" style="vertical-align: top;">
						<p class="tab-c"><em>b</em> = <em>g<sup>B</sup></em></p>
					</td>
				</tr>
				<tr>
					<td style="vertical-align: top;">
						<p class="tab">3</p>
					</td>
					<td colspan="2" style="vertical-align: top;">
						<p class="tab-c">{<em>a</em>, <em>nonce<sub>a</sub></em>} <em>→</em></p>
					</td>
				</tr>
				<tr>
					<td class="borderb" style="vertical-align: top;">
						<p class="tab"/>
			</td>
					<td class="borderb" colspan="2" style="vertical-align: top;">
						<p class="tab-c"><em>←</em> {<em>b</em>, <em>nonce<sub>b</sub></em>}</p>
					</td>
				</tr>
				<tr>
					<td class="borderb" style="vertical-align: top;">
						<p class="tab">4</p>
					</td>
					<td class="borderb" style="vertical-align: top;">
						<p class="tab-c"><em>S</em> = <em>b<sup>A</sup></em> = (<em>g<sup>B</sup></em>)<sup><em>A</em></sup></p>
					</td>
					<td class="borderb" style="vertical-align: top;">
						<p class="tab-c"><em>S</em> = <em>a<sup>B</sup></em> = (<em>g<sup>A</sup></em>)<sup><em>B</em></sup></p>
					</td>
				</tr>
				<tr>
					<td class="borderb" style="vertical-align: top;">
						<p class="tab">5</p>
					</td>
					<td class="borderb" style="vertical-align: top;">
						<p class="tab-c"><em>K</em> = <em>HKDF</em>(<em>S</em>, <em>nonce<sub>a</sub></em>, <em>nonce<sub>b</sub></em>)</p>
					</td>
					<td class="borderb" style="vertical-align: top;">
						<p class="tab-c"><em>K</em> = <em>HKDF</em>(<em>S</em>, <em>nonce<sub>a</sub></em>, <em>nonce<sub>b</sub></em>)</p>
					</td>
				</tr>
				<tr>
					<td style="vertical-align: top;">
						<p class="tab">6</p>
					</td>
					<td colspan="2" style="vertical-align: top;">
						<p class="tab-c"><em>←</em> <em>E</em>(<em>K</em>, <em>data</em>) <em>→</em></p>
					</td>
				</tr>
			</tbody>
		</table>
		<h4 class="h4" id="ch06lev7"><strong><em>Step 1: Generating the Shared Parameters</em></strong></h4>
		<p class="noindent">The first step in the Diffie-Hellman key exchange algorithm is generating the shared parameters, <em>p</em> and <em>g</em>, which will be used to compute the public and shared secret keys. The generator, <em>g</em>, is usually set to a value of 2. This parameter is called the generator because we use it to generate the public key by computing <em>g<sup>A</sup></em>. All our public keys are generated from a base <em>g</em>, so we say they’re in the same group. You can think of a group as a series of numbers like <em>g</em><sup>1</sup>, <em>g</em><sup>2</sup>, <em>g</em><sup>3</sup>. . ., which we can also write as <em>g</em>, <em>g</em> <em>*</em> <em>g</em>, <em>g</em> <em>*</em> <em>g</em> <em>*</em> <em>g</em>. . . Notice that we could create everything in the group by multiplying <em>g</em> by itself.</p>
		<p class="indent">The parameter <em>p</em> is a large prime number that constrains the public and computed keys to values between 1 and (<em>p</em> – 1) by computing the results of modulo <em>p</em>. We have omitted the (mod <em>p</em>) operations from the table because it makes the math more straightforward without affecting the validity. A secure implementation of Diffie-Hellman uses a large prime, where (<em>p</em> – 1)/2 is also prime.</p>
		<p class="indent">You can generate these parameters by running the following command:</p>
		<p class="programs">kali@kali:~$ <span class="codestrong1">openssl genpkey -genparam -algorithm DH -out parametersPG.pem</span></p>
		<p class="indent">The <span class="literal">openssl</span> program <span class="literal">genpkey</span> generates the keys, the <span class="literal">-genparam</span> and (<span class="literal">-algorithm DH</span>) flags direct <span class="literal">openssl</span> to generate the parameters for the Diffie-Hellman key exchange algorithm, and the <span class="literal">-out</span> flag specifies the name of the output file, in this case <em>parametersPG.pem</em>.</p>
		<p class="indent">Once you’ve generated the parameters, you can view them by running the following command:</p>
		<p class="programs">kali@kali:~$ <span class="codestrong1">openssl pkeyparam -in parametersPG.pem -text</span></p>
		<p class="indent"><span epub:type="pagebreak" id="page_96"/>The <span class="literal">openssl</span> program <span class="literal">pkeyparam</span> extracts the parameters from the <em>.pem</em> file and the <span class="literal">text</span> flag outputs a human-readable version of the key. After you run the command, you should see output that looks like the following:</p>
		<p class="programs">----BEGIN DH PARAMETERS-----<br/>MIIBCAKCAQEA9vcePAZIOjEdJzd0c9cK29wGvoIA/iPnGVf/36HnxeeSt5HBZsrb<br/>iDomXlmc31ykKQuHuobNA5d/qCBhJeOINr0OLr70fBcK2HuLWGInbVDi7niTatd4<br/>l7PRZlbwau/cY17eCA9bi9H2QgPku9+FbcIRaTSwMpeQliJ7B7FqWvrTEvIpz/Kb<br/>
0d6nucUjwj4EbZrLeLAwKAw2+6g2POnYfVg5Mqoz5K9e1YOn/tLFUpiGdBbujMtJ<br/>jI0glvoCykr96wsZ/I9GHMArIjm8LQA46UyLXhjdCYs2T+Jf+8t2pXNrpigtf3n1<br/>mFkguOBaQWP2oKn+FC/EfWwKwuBqqvmd2wIBAg==<br/>
-----END DH PARAMETERS-----<br/>DH Parameters: (2048 bit)<br/>
    prime:<br/>
        00:f6:f7:1e:3c:06:48:3a:31:1d:27:37:74:73:d7:<br/>
       ....<br/>
        f6:a0:a9:fe:14:2f:c4:7d:6c:0a:c2:e0:6a:aa:f9:<br/>
        9d:db<br/>
    generator: 2 (0x2)</p>
		<p class="indent">The top section shows the Base64-encoded parameters, and the bottom section shows their human-readable representations. Both the prime (<em>p</em>) and generator (<em>g</em>) parameters are represented in hex. You’ll use these parameters to generate a public key.</p>
		<h4 class="h4" id="ch06lev8"><strong><em>Step 2: Generating the Public–Private Key Pair</em></strong></h4>
		<p class="noindent">Before Alice and Bob can generate their public keys, they must each randomly select a number to serve as their private keys. Alice and Bob then calculate their public keys by respectively computing <em>g<sup>A</sup></em> and <em>g<sup>B</sup></em>, where <em>A</em> and <em>B</em> represent their respective private keys. The NSA recommends using keys that are 3,072 bits or larger; however, selecting keys longer than 3,072 bits may be inconvenient because longer keys take more time to generate. For example, it takes a standard desktop machine more than seven hours to generate a 6,144 bit RSA key. Thus, <span class="literal">openssl</span> defaults to key sizes of 2,048 bits. <a href="ch06.xhtml#ch6tab2">Table 6-2</a> illustrates this key generation process.</p>
		<p class="tabcap" id="ch6tab2"><strong>Table 6-2:</strong> Generating the Public–Private Key Pair</p>
		<table class="box">
			<colgroup>
				<col style="width:20%"/>
				<col style="width:40%"/>
				<col style="width:40%"/>
			</colgroup>
			<thead>
				<tr>
					<th class="borderrb" style="vertical-align: top;">
						<p class="tab-c">Keys</p>
					</th>
					<th class="borderrb" style="vertical-align: top;">
						<p class="tab">Alice</p>
					</th>
					<th class="borderb" style="vertical-align: top;">
						<p class="tab">Bob</p>
					</th>
				</tr>
			</thead>
			<tbody>
				<tr>
					<td class="borderrb" style="vertical-align: top;">
						<p class="tab">Private (A and B)</p>
					</td>
					<td class="borderrb" style="vertical-align: top;">
						<p class="tab">A = random value</p>
					</td>
					<td class="borderb" style="vertical-align: top;">
						<p class="tab">B = random value</p>
					</td>
				</tr>
				<tr>
					<td class="borderr" style="vertical-align: top;">
						<p class="tab">Public (a and b)</p>
					</td>
					<td class="borderr" style="vertical-align: top;">
						<p class="tab"><em>a</em> = <em>g<sup>A</sup></em></p>
					</td>
					<td style="vertical-align: top;">
						<p class="tab"><em>b</em> = <em>g<sup>B</sup></em></p>
					</td>
				</tr>
			</tbody>
		</table>
		<p class="indent">We can generate Alice’s public–private key pair by running:</p>
		<p class="programs">kali@kali:~$ <span class="codestrong1">openssl genpkey -paramfile parametersPG.pem -out AlicePublicPrivateKeyPair.pem</span></p>
		<p class="indent"><span epub:type="pagebreak" id="page_97"/>The <span class="literal">-paramfile</span> flag instructs <span class="literal">openssl</span> to use the parameters in the file <em>parametersPG.pem</em>, and <span class="literal">genpkey</span>, to generate a new public-private key pair. When you’ve generated the key pair, you can view it by running this command:</p>
		<p class="programs">kali@kali:~$ <span class="codestrong1">openssl pkey -in AlicePublicPrivateKeyPair.pem -text -noout</span></p>
		<p class="indent">The <span class="literal">openssl</span> utility <span class="literal">pkey</span> parses private keys. The output of this command represents both keys as 2,048-bit hexadecimal numbers, as shown here:</p>
		<p class="programs">DH Private-Key: (2048 bit)<br/>
    private-key:<br/>
        53:2f:45:2d:4a:15:c3:62:4f:4c:b8:4f:43:92:8b:<br/>
        98:7c:f6:fd:1f:54:16:15:c6:28:a1:ae:8a:80:73:<br/>
       ....<br/>
    public-key:<br/>
        7f:c6:af:1e:ff:aa:ba:59:98:02:19:fb:93:6d:cc:<br/>
        57:28:00:48:20:a7:38:6a:41:43:1b:d6:00:32:8f:<br/>
       ....<br/>
    prime:<br/>
        00:f6:f7:1e:3c:06:48:3a:31:1d:27:37:74:73:d7:<br/>
        0a:db:dc:06:be:82:00:fe:23:e7:19:57:ff:df:a1:<br/>
       ....<br/>
    generator: 2 (0x2)</p>
		<p class="indent">Remember that you should never share your private key. If an attacker is able to steal or calculate your private key, they’ll be able to decrypt your communications.</p>
		<p class="indent">Next, use the same public parameters to generate Bob’s public-private key pair:</p>
		<p class="programs">kali@kali:~$ <span class="codestrong1">openssl genpkey -paramfile parametersPG.pem -out BobPublicPrivateKeyPair.pem</span></p>
		<p class="indent">It is critical that Alice and Bob use the same parameters, because they’ll calculate different secret keys if they don’t.</p>
		<h4 class="h4" id="ch06lev9"><strong><em>Why Can’t a Hacker Calculate the Private Key?</em></strong></h4>
		<p class="noindent">You might be wondering why a hacker couldn’t use the public parameter <em>g</em> and public key <em>a</em> to calculate Alice’s private key. For example, it would seem that an attacker could calculate <em>A</em> by computing the discrete log base <em>g</em> of public key <em>a</em>, like this:</p>
		<p class="center"><em>a</em> = <em>g<sup>A</sup></em> <em><span class="ent">⇒</span></em> <em>A</em> = <em>log<sub>g</sub></em>(<em>a</em>)</p>
		<p class="indent">This would be possible if a <em>a</em> were a small number; however, <em>a</em> is a very large number, 2,048 bits in our case. If you wrote out the largest possible 2,048-bit number in decimal, it would be 617 digits long and equivalent to multiplying a trillion by itself 50 times. Because calculating the discrete log is a much slower process than calculating the original exponent, it would take an attacker the remaining life of the sun to calculate the private random value <em>A</em> from the public key <em>a</em> using known classical algorithms.</p>
		<p class="indent"><span epub:type="pagebreak" id="page_98"/>However, researchers expect that quantum computers will someday be able to quickly calculate the discrete log, at which point these encryption algorithms will no longer be safe. If you’re worried about this, you can take one of two approaches to future proofing your encrypted files.</p>
		<p class="bulleta">• <strong>Choose longer keys.</strong> A key size of 3,072 bits should buy you some time; however, as quantum computers improve even those keys won’t be long enough.</p>
		<p class="bullet">• <strong>Use a quantum-safe encryption algorithm.</strong> The team at <em><a href="https://openquantumsafe.org/">https://openquantumsafe.org/</a></em> is working on open source implementations of quantum-safe algorithms. One of the most promising approaches is lattice-based cryptography. However, a discussion of these is outside the scope of this book. If you’re curious, I recommend <a href="ch16.xhtml#ch16">Chapter 16</a> of <em>A Graduate Course in Applied Cryptography</em> by Dan Boneh and Victor Shoup. You can access it by visiting: <em><a href="https://toc.cryptobook.us/">https://toc.cryptobook.us/</a></em>.</p>
		<h4 class="h4" id="ch06lev10"><strong><em>Step 3: Exchanging Key Shares and Nonces</em></strong></h4>
		<p class="noindent">Next, Alice and Bob exchange their public keys and nonces (random numbers). Recall from <a href="ch05.xhtml#ch5">Chapter 5</a> that nonces ensure that each cipher text is unique. <a href="ch06.xhtml#ch6tab3">Table 6-3</a> describes this step.</p>
		<p class="tabcap" id="ch6tab3"><strong>Table 6-3:</strong> Exchanging Public-Key Shares and Nonces</p>
		<table class="box">
			<colgroup>
				<col style="width:20%"/>
				<col style="width:40%"/>
				<col style="width:40%"/>
			</colgroup>
			<thead>
				<tr>
					<th class="borderrb" style="vertical-align: top;">
						<p class="tab-c">Step</p>
					</th>
					<th class="borderrb" style="vertical-align: top;">
						<p class="tab">Alice</p>
					</th>
					<th class="borderb" style="vertical-align: top;">
						<p class="tab">Bob</p>
					</th>
				</tr>
			</thead>
			<tbody>
				<tr>
					<td class="borderr" style="vertical-align: top;">
						<p class="tab">3</p>
					</td>
					<td colspan="2" style="vertical-align: top;">
						<p class="tab-c">{<em>a</em>, <em>nonce<sub>a</sub></em>} <em>→</em></p>
					</td>
				</tr>
				<tr>
					<td class="borderr" style="vertical-align: top;">
						<p class="tab"/>
			</td>
					<td colspan="2" style="vertical-align: top;">
						<p class="tab-c"><em>←</em> {<em>b</em>, <em>nonce<sub>b</sub></em>}</p>
					</td>
				</tr>
			</tbody>
		</table>
		<p class="indent">Use the <span class="literal">openssl pkey</span> utility to extract Alice’s public key:</p>
		<p class="programs">kali@kali:~$ <span class="codestrong1">openssl pkey -in AlicePublicPrivateKeyPair.pem -pubout -out AlicePublicKey.pem</span></p>
		<p class="indent">The <span class="literal">pubout</span> flag instructs <span class="literal">openssl</span> to output Alice’s public key only. Extract Bob’s public key using the same method:</p>
		<p class="programs">kali@kali:~$ <span class="codestrong1">openssl pkey -in BobPublicPrivateKeyPair.pem -pubout -out BobPublicKey.pem</span></p>
		<p class="indent">You can view a human-readable version of Bob’s public key by running the following command:</p>
		<p class="programs">kali@kali:~$ <span class="codestrong1">openssl pkey -pubin -in BobPublicKey.pem -text</span></p>
		<p class="indent">Notice that the generated file contains only Bob’s public key and the public parameters <em>p</em> and <em>g</em>.</p>
		<h4 class="h4" id="ch06lev11"><strong><em>Step 4: Calculating the Shared Secret Key</em></strong></h4>
		<p class="noindent">Now that Alice and Bob have each other’s public keys and public parameters, they can independently calculate the same secret symmetric key. Alice <span epub:type="pagebreak" id="page_99"/>calculates the shared key by raising Bob’s public key <em>b</em> to the value of her secret key <em>A</em>, resulting in a new shared key <em>S</em>. Bob does the same with Alice’s public key <em>a</em> and his secret key <em>B</em>, resulting in <em>the same secret key</em>.</p>
		<p class="indent">To see why the two public keys generate the same secret key, remember that we calculated Alice’s public key <em>a</em> by raising <em>g</em> to the value of her secret key (<em>a</em> = <em>g<sup>A</sup></em>). If we substitute this into Bob’s calculation of his secret key, we get: <em>S</em> = <em>a<sup>B</sup></em> = (<em>g<sup>A</sup></em>)<em><sup>B</sup></em> = <em>g<sup>AB</sup></em>. If you repeat this process for Alice, you’ll see that she calculates the same secret key: <em>S</em> = <em>b<sup>A</sup></em> = (<em>g<sup>B</sup></em>)<em><sup>A</sup></em> = <em>g<sup>BA</sup></em>. <a href="ch06.xhtml#ch6tab4">Table 6-4</a> summarizes these calculations.</p>
		<p class="tabcap" id="ch6tab4"><strong>Table 6-4:</strong> Calculating the Shared Key</p>
		<table class="box">
			<colgroup>
				<col style="width:20%"/>
				<col style="width:40%"/>
				<col style="width:40%"/>
			</colgroup>
			<thead>
				<tr>
					<th class="borderrb" style="vertical-align: top;">
						<p class="tab-c">Step</p>
					</th>
					<th class="borderrb" style="vertical-align: top;">
						<p class="tab">Alice</p>
					</th>
					<th class="borderb" style="vertical-align: top;">
						<p class="tab">Bob</p>
					</th>
				</tr>
			</thead>
			<tbody>
				<tr>
					<td class="borderr" style="vertical-align: top;">
						<p class="tab">4</p>
					</td>
					<td class="borderr" style="vertical-align: top;">
						<p class="tab"><em>S</em> = <em>b<sup>A</sup></em> = (<em>g<sup>B</sup></em>)<em>A</em></p>
					</td>
					<td style="vertical-align: top;">
						<p class="tab"><em>S</em> = <em>a<sup>B</sup></em> = (<em>g<sup>A</sup></em>)<em>B</em></p>
					</td>
				</tr>
			</tbody>
		</table>
		<p class="indent">Now, let’s use the <span class="literal">openssl</span> public-key utility, <span class="literal">pkeyutil</span>, to derive (<span class="literal">-derive</span>) Alice’s shared secret key by using Bob’s public key (<span class="literal">-peerkey</span>):</p>
		<p class="programs">kali@kali:~$ <span class="codestrong1">openssl pkeyutl -derive -inkey AlicePublicPrivateKeyPair.pem -</span><br/>
    
			<img alt="image" src="../images/arrow01.jpg"/> <span class="codestrong1">peerkey BobPublicKey.pem -out AliceSharedSecret.bin</span></p>
		<p class="indent">We can also derive Bob’s shared secret key by using the same command:</p>
		<p class="programs">kali@kali:~$ <span class="codestrong1">openssl pkeyutl -derive -inkey BobPublicPrivateKeyPair.pem -</span><br/>
    
			<img alt="image" src="../images/arrow01.jpg"/> <span class="codestrong1">peerkey AlicePublicKey.pem -out BobSharedSecret.bin</span></p>
		<p class="indent">You can view a human-readable version of Alice’s secret key by using the <span class="literal">xxd</span> command:</p>
		<p class="programs">kali@kali:~$ <span class="codestrong1">xxd AliceSharedSecret.bin</span></p>
		<p class="indent">Now, let’s use the <span class="literal">cmp</span> command to compare Alice’s and Bob’s shared secret keys. If the keys are the same, the command won’t print anything; however, if they don’t match, it will print out the differences:</p>
		<p class="programs">kali@kali:~$ <span class="codestrong1">cmp AliceSharedSecret.bin BobSharedSecret.bin</span></p>
		<p class="indent">If everything worked correctly, you should receive no output.</p>
		<h4 class="h4" id="ch06lev12"><strong><em>Step 5: Key Derivation</em></strong></h4>
		<p class="noindent">Although we now have a shared key, we can’t use it directly, because it is in the wrong form. The shared key is a number, but block ciphers require a uniform random string. Thus, we must use the <em>HKDF</em> key derivation function to derive a uniform random string from the calculated number. The HKDF function uses the shared key and both nonces to generate the final symmetric key: <em>K</em> = <em>HKDF</em>(<em>S</em>, <em>nonce<sub>a</sub></em>, <em>nonce<sub>b</sub></em>). <a href="ch06.xhtml#ch6tab5">Table 6-5</a> shows how both parties convert the shared number into a key by using the HKDF key derivation function.</p>
		<p class="tabcap" id="ch6tab5"><span epub:type="pagebreak" id="page_100"/><strong>Table 6-5:</strong> Converting <em>S</em> into a Key Using the HKDF Key Derivation Function</p>
		<table class="box">
			<colgroup>
				<col style="width:50%"/>
				<col style="width:50%"/>
			</colgroup>
			<thead>
				<tr>
					<th class="borderrb" style="vertical-align: top;">
						<p class="tab-c">Alice</p>
					</th>
					<th class="borderb" style="vertical-align: top;">
						<p class="tab-c">Bob</p>
					</th>
				</tr>
			</thead>
			<tbody>
				<tr>
					<td class="borderr" style="vertical-align: top;">
						<p class="tab"><em>K</em> = <em>HKDF</em>(<em>S</em>, <em>nonce<sub>a</sub></em>, <em>nonce<sub>b</sub></em>)</p>
					</td>
					<td style="vertical-align: top;">
						<p class="tab"><em>K</em> = <em>HKDF</em>(<em>S</em>, <em>nonce<sub>a</sub></em>, <em>nonce<sub>b</sub></em>)</p>
					</td>
				</tr>
			</tbody>
		</table>
		<p class="indent">Let’s use a key derivation function to derive a key and encrypt a file. Instead of using HKDF, we will use the PBKDF2 function supported by <span class="literal">openssl</span>.</p>
		<p class="programs">kali@kali:~$ <span class="codestrong1">openssl enc -aes-256-ctr -pbkdf2 -e -a -in plain.txt -out encrypted</span><br/>
    
			<img alt="image" src="../images/arrow01.jpg"/> <span class="codestrong1">.txt -pass file:AliceSharedSecret.bin</span></p>
		<p class="indent">Once you’ve run this command, it will derive a key from the binary value stored in <em>AliceSharedsecret.bin</em>. Next, <span class="literal">openssl</span> will use the derived key to encrypt the <em>plain.txt</em> file, and write the encrypted result to the <em>encrypted.txt</em> file.</p>
		<h4 class="h4" id="ch06lev13"><strong><em>Attacking Diffie-Hellman</em></strong></h4>
		<p class="noindent">Now that you understand the Diffie-Hellman algorithm, let’s examine how state actors could recover private keys from 1,024-bit public keys.</p>
		<p class="indent">Ideally, when choosing shared parameters, a browser would randomly select <em>p</em> from a large set of primes. (Remember: all operations are mod <em>p</em>). However, most browsers use only a small subset of prime numbers. A state actor with access to large computing resources could precompute all 1,024-bit public-private key pairs for given prime numbers. They can achieve this by using the fastest known algorithm for computing the inverse log: the <em>general number field sieve (GNFS)</em>. GNFS consists of four steps. State actors precompute the first three steps and can then easily compute the last step when needed.</p>
		<p class="indent">In a previous version of TLS (TLS 1.2), the client and server negotiated encryption type and key length using unencrypted packets. This allowed hackers to intercept packets and downgrade the key to a length of 1,024 bits. Luckily, the newest version of TLS (TLS 1.3) is not vulnerable to this type of attack.</p>
		<h3 class="h3" id="ch06lev14"><strong>Elliptic-Curve Diffie-Hellman</strong></h3>
		<p class="noindent"><em>Elliptic-curve Diffie-Hellman</em> is a faster implementation of the Diffie-Hellman key exchange algorithm that achieves similar security with shorter keys. For example, a 256-bit elliptic-curve cryptography (ECC) key is the equivalent of a 3,072-bit RSA key. (Keys are considered equivalent if it would take the same amount of computer resources to break them.)</p>
		<p class="indent">Instead of calculating exponents, elliptic-curve Diffie-Hellman performs mathematical operations on an <em>elliptic curve</em>, a type of curve that looks like the one shown in <a href="ch06.xhtml#ch6fig6">Figure 6-6</a>.</p>
		<div class="image" id="ch6fig6">
			<span epub:type="pagebreak" id="page_101"/>
			<img alt="image" src="../images/ch06fig06.jpg"/>
		</div>
		<p class="figcap"><em>Figure 6-6: Plot of the secp256k1 curve along example values for the generator, private key, and associated public key</em></p>
		<p class="indent">In elliptic-curve Diffie-Hellman, Alice’s public key <em>a<sub>xy</sub></em> is a point on the elliptic curve that is calculated by multiplying a randomly selected private integer <em>A</em> by the shared point <em>G<sub>x</sub></em><sub>,</sub><em><sub>y</sub></em>, called the <em>generator</em>. The generator is preselected to be a point on the curve that maximizes the number of possible public keys that can be calculated from it.</p>
		<p class="indent">Let’s dive into how this works.</p>
		<h4 class="h4" id="ch06lev15"><strong><em>The Math of Elliptic Curves</em></strong></h4>
		<p class="noindent">An elliptic curve is defined by</p>
		<p class="center"><em>y</em><sup>2</sup> = <em>x</em><sup>3</sup> + <em>ax</em> + <em>b</em></p>
		<p class="noindent">where <em>a</em> and <em>b</em> are the parameters of the curve.</p>
		<p class="indent"><a href="ch06.xhtml#ch6fig6">Figure 6-6</a> shows a popular elliptic curve, the secp256k1 curve, which is used in several cryptographic applications, including Bitcoin. The secp256k1 curve is defined by the following equation:</p>
		<p class="center"><em>y</em><sup>2</sup> = <em>x</em><sup>3</sup> + 7</p>
		<p class="indent">The National Institute of Standards and Technology (NIST) recommends the P-256 or Curve25519 elliptic curves, which are the most widely used curves on the web today. We’ll use the secp256k1 curve shown in <a href="ch06.xhtml#ch6fig6">Figure 6-6</a> in this discussion; however, the same concepts apply to P-256 and Curve25519.</p>
		<p class="indent"><span epub:type="pagebreak" id="page_102"/>Like the original Diffie-Hellman algorithm, the eliptic-curve Diffie-Hellman uses a shared parameter <em>G</em> and a public-private key pair. The public key is a point on the curve, and the private key is a randomly chosen integer.</p>
		<p class="indent"><a href="ch06.xhtml#ch6tab6">Table 6-6</a> summarizes the steps in the elliptic-curve Diffie-Hellman key exchange algorithm. As with the original Diffie-Hellman algorithm, all operations are mod <em>p</em>; however, I’ve omitted this from the table for clarity.</p>
		<p class="tabcap" id="ch6tab6"><strong>Table 6-6:</strong> The Steps Used to Establish a Shared Key in an Elliptic-Curve Diffie-Hellman Key Exchange</p>
		<table class="bordertb">
			<colgroup>
				<col style="width:10%"/>
				<col style="width:45%"/>
				<col style="width:45%"/>
			</colgroup>
			<thead>
				<tr>
					<th class="borderb" style="vertical-align: top;">
						<p class="tab">Step</p>
					</th>
					<th class="borderb" style="vertical-align: top;">
						<p class="tab-c">Alice</p>
					</th>
					<th class="borderb" style="vertical-align: top;">
						<p class="tab-c">Bob</p>
					</th>
				</tr>
			</thead>
			<tbody>
				<tr>
					<td class="borderb" style="vertical-align: top;">
						<p class="tab">1</p>
					</td>
					<td class="borderb" colspan="2" style="vertical-align: top;">
						<p class="tab-c">Shared point: <em>G<sub>xy</sub></em></p>
					</td>
				</tr>
				<tr>
					<td style="vertical-align: top;">
						<p class="tab">2</p>
					</td>
					<td style="vertical-align: top;">
						<p class="tab-c"><em>A</em> = <em>random</em></p>
					</td>
					<td style="vertical-align: top;">
						<p class="tab-c"><em>B</em> = <em>random</em></p>
					</td>
				</tr>
				<tr>
					<td class="borderb" style="vertical-align: top;">
						<p class="tab"/>
			</td>
					<td class="borderb" style="vertical-align: top;">
						<p class="tab-c"><em>a<sub>xy</sub></em> = <em>A</em> <em>×</em> <em>G<sub>xy</sub></em></p>
					</td>
					<td class="borderb" style="vertical-align: top;">
						<p class="tab-c"><em>b<sub>xy</sub></em> = <em>B</em> <em>×</em> <em>G<sub>xy</sub></em></p>
					</td>
				</tr>
				<tr>
					<td style="vertical-align: top;">
						<p class="tab">3</p>
					</td>
					<td colspan="2" style="vertical-align: top;">
						<p class="tab-c">{<em>a<sub>xy</sub></em>, <em>nonce<sub>a</sub></em>} <em><img alt="image" src="../images/arrow01.jpg"/></em></p>
					</td>
				</tr>
				<tr>
					<td class="borderb" style="vertical-align: top;">
						<p class="tab"/>
			</td>
					<td class="borderb" colspan="2" style="vertical-align: top;">
						<p class="tab-c"><em>←</em> {<em>b<sub>xy</sub></em>, <em>nonce<sub>b</sub></em>}</p>
					</td>
				</tr>
				<tr>
					<td class="borderb" style="vertical-align: top;">
						<p class="tab">4</p>
					</td>
					<td class="borderb" style="vertical-align: top;">
						<p class="tab"><em>K<sub>xy</sub></em> = <em>A</em> <em>×</em> <em>b<sub>xy</sub></em> = <em>A</em> <em>×</em> <em>B</em> <em>×</em> <em>G<sub>xy</sub></em></p>
					</td>
					<td class="borderb" style="vertical-align: top;">
						<p class="tab"><em>K<sub>xy</sub></em> = <em>B</em> <em>×</em> <em>a<sub>xy</sub></em> = <em>B</em> <em>×</em> <em>A</em> <em>×</em> <em>G<sub>xy</sub></em></p>
					</td>
				</tr>
				<tr>
					<td class="borderb" style="vertical-align: top;">
						<p class="tab">5</p>
					</td>
					<td class="borderb" style="vertical-align: top;">
						<p class="tab"><em>K</em> = <em>HKDF</em>(<em>K<sub>x</sub></em>, <em>nonce<sub>a</sub></em>, <em>nonce<sub>b</sub></em>)</p>
					</td>
					<td class="borderb" style="vertical-align: top;">
						<p class="tab"><em>K</em> = <em>HKDF</em>(<em>K<sub>x</sub></em>, <em>nonce<sub>a</sub></em>, <em>nonce<sub>b</sub></em>)</p>
					</td>
				</tr>
				<tr>
					<td class="borderb" style="vertical-align: top;">
						<p class="tab">6</p>
					</td>
					<td class="borderb" colspan="2" style="vertical-align: top;">
						<p class="tab-c"><em>←</em> <em>E</em>(<em>K</em>, <em>data</em>) <em><img alt="image" src="../images/arrow01.jpg"/></em></p>
					</td>
				</tr>
			</tbody>
		</table>
		<p class="indent">Notice that these steps are similar to those of the original Diffie-Hellman algorithm. For that reason, I won’t walk through them in detail. However, note that the elliptic-curve Diffie-Hellman uses the multiplication of points on the elliptic curve instead of exponentiation to generate key pairs.</p>
		<h4 class="h4" id="ch06lev16"><strong><em>The Double and Add Algorithm</em></strong></h4>
		<p class="noindent">Unless you’ve worked with elliptic curves before, you’re probably not sure what it means to perform mathematical operations on points of a curve. For example, what does it mean to multiply the point <em>G<sub>xy</sub></em> by an integer <em>A</em>?</p>
		<p class="indent">Multiplying point <em>G<sub>xy</sub></em> by an integer 4 is equivalent to adding the point to itself three times:</p>
		<p class="center">4 <em>×</em> <em>G<sub>xy</sub></em> = <em>G<sub>xy</sub></em> + <em>G<sub>xy</sub></em> + <em>G<sub>xy</sub></em> + <em>G<sub>xy</sub></em></p>
		<p class="indent">Adding a point <em>G<sub>xy</sub></em> to itself is geometrically equivalent to taking the tangent of the point and reflecting its intersection with the elliptic curve about the x-axis. <a href="ch06.xhtml#ch6fig7">Figure 6-7</a> graphically represents the process of adding a point to itself.</p>
		<div class="image" id="ch6fig7">
			<span epub:type="pagebreak" id="page_103"/>
			<img alt="image" src="../images/ch06fig07.jpg"/>
		</div>
		<p class="figcap"><em>Figure 6-7: An example of adding the point</em> <em>G<sub>xy</sub></em> <em>to itself</em></p>
		<p class="indent">A more efficient way of computing 4 <em>×</em> <em>G<sub>xy</sub></em> would be to first compute 2<em>G<sub>xy</sub></em> = <em>G<sub>xy</sub></em> + <em>G<sub>xy</sub></em> and then compute 4<em>G<sub>xy</sub></em> = 2<em>G<sub>xy</sub></em> + 2<em>G<sub>xy</sub></em>, which would reduce the number of additions needed. For that reason, the algorithm used in practice to calculate elliptic-curve Diffie-Hellman keys is called the <em>double and add algorithm</em>.</p>
		<p class="indent">When Alice computes her public key <em>a<sub>xy</sub></em> = <em>A</em> <em>×</em> <em>G<sub>xy</sub></em>, she sends it to Bob and includes a nonce. Bob does the same. Once Alice receives Bob’s public key, she calculates the point representing the shared key by multiplying Bob’s public point <em>b<sub>xy</sub></em> by her secret integer <em>A</em>, resulting in a new point: <em>K<sub>xy</sub></em> = <em>A</em> <em>×</em> <em>b<sub>xy</sub></em> = <em>A</em> <em>×</em> <em>B</em> <em>×</em> <em>G<sub>xy</sub></em>. Bob does the same and gets <em>K<sub>xy</sub></em> = <em>B</em> <em>×</em> <em>a<sub>xy</sub></em> = <em>B</em> <em>×</em> <em>A</em> <em>×</em> <em>G<sub>xy</sub></em>. By convention, the x value is extracted for key point <em>K<sub>xy</sub></em> and passed to the HKDF key derivation function to calculate the final shared key.</p>
		<h4 class="h4" id="ch06lev17"><strong><em>Why Can’t a Hacker Use G<sub>xy</sub> and a<sub>xy</sub> to Calculate the Private Key A?</em></strong></h4>
		<p class="noindent">Once again, you might be wondering: Why can’t a hacker who knows <em>G<sub>xy</sub></em> and <em>a<sub>xy</sub></em> compute <em>A</em>? Recall that we chose the generator <em>G<sub>x</sub>y</em> so that we could reach the maximum number of points on the elliptic curve. This, combined with the fact that all operations are modulo, a large prime <em>p</em> means that it is very difficult to recover <em>A</em> from <em>a<sub>xy</sub></em> and <em>G<sub>xy</sub></em>. If (<em>A</em> <em>×</em> <em>G<sub>xy</sub></em>) is smaller than <em>p</em>, you might attempt to compute <em>A</em> by the following:</p>
		<p class="center"><em>A</em> = <em>a<sub>xy</sub></em>/<em>G<sub>xy</sub></em></p>
		<p class="indent">Remember that you’re not dividing two numbers, but rather two points on an elliptic curve, which is why we can perform only addition and subtraction. To solve the preceding equation, we would need an algorithm that efficiently computes division using only addition and subtraction. However, <span epub:type="pagebreak" id="page_104"/>no currently known classical algorithms can do this. That said, it’s important to note that you want to use a good source of randomness when generating <em>A</em>. An attacker can easily determine <em>A</em> if it is generated from a predictable or pseudo-random sequence.</p>
		<h3 class="h3" id="ch06lev18"><strong>Writing TLS Sockets</strong></h3>
		<p class="noindent">Now let’s use the <em>secure sockets layer (SSL)</em> library to implement a secure socket in Python. We’ll use the Python <span class="literal">with</span> syntax, like we did in <a href="ch05.xhtml#ch5">Chapter 5</a>, to help manage our socket resources.</p>
		<p class="indent">To encrypt our sockets, we’ll use the <em>AES-GCM (Galois/counter mode) cipher</em> block cipher. AES-GCM combines the ideas of message authentication with the counter mode block ciphers introduced in <a href="ch05.xhtml#ch5">Chapter 5</a> to provide confidentiality, and message integrity. Consider an example of encrypting a TCP packet. We want to encrypt the packet’s contents, but routers need the packet’s IP addresses, so we want to ensure that this information remains unchanged. Therefore, we need integrity checks for both the encrypted and unencrypted parts of our packet. We call this approach <em>authenticated encryption with associated data</em>, and AES-GCM supports it.</p>
		<p class="indent">Let’s begin by writing a secure client socket.</p>
		<h4 class="h4" id="ch06lev19"><strong><em>The Secure Client Socket</em></strong></h4>
		<p class="noindent">Let’s implement the client socket, which will establish a secure connection to the server that we’ll implement in the next subsection. Create a new file called <em>secureSocket.py</em> and copy the following code into it:</p>
		<p class="programs"><span class="ent">➊</span> import socket<br/>
   import ssl<br/><br/>
   client_key = 'client.key'<br/>
   client_cert = 'client.crt'<br/>
   server_cert = 'server.crt'<br/>
   port = 8080<br/><br/>
   hostname = '127.0.0.1'<br/><span class="ent">➋</span> context = ssl.SSLContext(ssl.PROTOCOL_TLS, cafile=server_cert)<br/><span class="ent">➌</span> context.load_cert_chain(certfile=client_cert, keyfile=client_key)<br/>
   context.load_verify_locations(cafile=server_cert)<br/>
   context.verify_mode = ssl.CERT_REQUIRED<br/><span class="ent">➍</span> context.options |= ssl.OP_SINGLE_ECDH_USE<br/>
   context.options |= ssl.OP_NO_TLSv1 | ssl.OP_NO_TLSv1_1 | ssl.OP_NO_TLSv1_2<br/><br/><span class="ent">➎</span> with socket.create_connection((hostname, port)) as sock:<br/>
    <span class="ent">➏</span> with context.wrap_socket(sock, server_side=False,<br/>
           server_hostname=hostname) as ssock:<br/>
           print(ssock.version())<br/>
           message = input("Please enter your message: ")<br/>
           <span epub:type="pagebreak" id="page_105"/>ssock.send(message.encode())<br/>
           receives = ssock.recv(1024)<br/>
           print(receives)</p>
		<p class="indent">First, we import the Python socket and SSL libraries <span class="ent">➊</span>. Next, we create a new SSL context <span class="ent">➋</span>. The SSL context is the class that manages the certificates and other socket settings. Instead of relying on public-key infrastructure to verify certificates, the client and server each contain a copy of both certificates. Let’s generate the server’s private key and public certificate by running the following command:</p>
		<p class="programs">kali@kali:~$ <span class="codestrong1">openssl req -new -newkey rsa:3072 -days 365 -nodes -x509</span><br/><span class="codestrong1">-keyout server.key -out server.crt</span></p>
		<p class="indent">The <span class="literal">req</span> and <span class="literal">-new</span> flags specify that we’re requesting a new key. The <span class="literal">-newkey rsa:3072</span> flag generates a new RSA key that is 3,072 bits long. The <span class="literal">-days</span> flag specifies the number of days that you want the certificate to be valid, in this case 365 days. The <span class="literal">-nodes</span> flag directs <span class="literal">openssl</span> to generate an unencrypted private key and the <span class="literal">-x509</span> flag specifies the output format of the certificate. The <span class="literal">-keyout</span> flag specifies the name of the output file (<em>server.key</em>) that will contain the public-private key pair, and the <span class="literal">-out</span> flag specifies the name of the output file (<em>server.crt</em>) that will contain the certificate.</p>
		<p class="indent">When you run this command, it should ask you to enter the information you want to include in your certificate. You can leave all the fields blank or make up your information; it’s your certificate after all. Remember that any information you include in the certificate will be visible to anyone who attempts to connect to your server.</p>
		<p class="indent">After you’ve created the server’s X.509-formatted certificate, pass it to the SSL context. Repeat the above process to generate the client’s certificate and private key:</p>
		<p class="programs">kali@kali:~$ <span class="codestrong1">openssl req -new -newkey rsa:3072 -days 365 -nodes -x509</span><br/><span class="codestrong1">-keyout client.key -out client.crt</span></p>
		<p class="indent">Load the client’s private key and certificate <span class="ent">➌</span>. The server will use these to verify the client’s identity.</p>
		<p class="indent">Select a key-exchange algorithm by setting the appropriate bit in the context’s options. Here, we recommend that you use elliptic-curve Diffie-Hellman. We set the appropriate bit by OR-ing the options with the ssl constant <span class="literal">ssl.OP_SINGLE_ECDH_USE</span> <span class="ent">➍</span>. One of the great advantages of the Diffie-Hellman key exchange is that we can calculate a new shared secret for every connection. This means that if someone steals your private key, they’ll be able to decrypt only past communications and not future ones. This is commonly known as <em>forward secrecy</em>.</p>
		<p class="indent">After you’ve configured the options, create a new socket <span class="ent">➎</span> and wrap the socket in an SSL context <span class="ent">➏</span>. The socket wrapper ensures that all information is encrypted before it is sent to the socket.</p>
		<h4 class="h4" id="ch06lev20"><span epub:type="pagebreak" id="page_106"/><strong><em>The Secure Server Socket</em></strong></h4>
		<p class="noindent">Let’s implement the server socket, the program that accepts secure connections from your client. Create a new file called <em>secureServer.py</em> and copy the following code into it:</p>
		<p class="programs">   import socket<br/>
  import ssl<br/><br/>
   client_cert = 'client.crt'<br/>
   server_key = 'server.key'<br/>
   server_cert = 'server.crt'<br/>
   port = 8080<br/><span class="ent">➊</span> context = ssl.create_default_context(ssl.Purpose.CLIENT_AUTH)<br/><span class="ent">➋</span> context.verify_mode = ssl.CERT_REQUIRED<br/><span class="ent">➌</span> context.load_verify_locations(cafile=client_cert)<br/>
   context.load_cert_chain(certfile=server_cert, keyfile=server_key)<br/>
   context.options |= ssl.OP_SINGLE_ECDH_USE<br/><span class="ent">➍</span> context.options |= ssl.OP_NO_TLSv1 | ssl.OP_NO_TLSv1_1 | ssl.OP_NO_TLSv1_2<br/><br/>
   with socket.socket(socket.AF_INET, socket.SOCK_STREAM, 0) as sock:<br/>
        sock.bind(('', port))<br/>
        sock.listen(1)<br/>
        with context.wrap_socket(sock, server_side=True) as ssock:<br/>
           conn, addr = ssock.accept()<br/>
           print(addr)<br/>
           message = conn.recv(1024).decode()<br/>
           capitalizedMessage= message.upper()<br/>
           conn.send(capitalizedMessage.encode())</p>
		<p class="indent">We set up the default context to support client authentication <span class="ent">➊</span>. This means that only clients with authorized certificates can connect to the server. We then ensure that the server checks client certificates <span class="ent">➋</span>. Next, we provide the client and server certificate locations <span class="ent">➌</span>. Lastly, we ban all the previous versions of TLS, ensuring that the server uses the highest TLS version available <span class="ent">➍</span>. In this case, this is TLS 1.3.</p>
		<p class="indent">Run <em>secureServer.py</em> in your Kali Linux terminal. Then, open another terminal, run <em>secureSocket.py</em>, and add a message if you choose.</p>
		<p class="programs">TLSv1.3<br/>Please enter your message: <span class="codestrong1">test</span><br/>b'TEST'</p>
		<p class="indent">The terminal in which you ran <em>secureServer.py</em> should resemble the following:</p>
		<p class="programs">('127.0.0.1', 36000)</p>
		<div class="note">
			<p class="notet"><strong><span class="notes">NOTE</span></strong></p>
			<p class="notep"><span epub:type="pagebreak" id="page_107"/><em>If you’re having issues establishing a secure connection to the server from these scripts, your Kali Linux virtual machine may have been polluted by libraries used in prior chapters. In that case, you might need to create a new virtual machine. See <a href="ch01.xhtml#ch1">Chapter 1</a> for details on doing this.</em></p>
		</div>
		<h3 class="h3" id="ch06lev21"><strong>SSL Stripping and HSTS Bypass</strong></h3>
		<p class="noindent">How might an attacker get around TLS? If a hacker executes an ARP spoofing attack like the one we performed in <a href="ch02.xhtml#ch2">Chapter 2</a>, they’ll be able to intercept all of the user’s traffic. But if this traffic is encrypted, the attacker will be unable to read it.</p>
		<p class="indent">However, if the victim downloads an unencrypted page containing secure links, the attacker could attempt to downgrade the connection from HTTPS (indicating the use of TLS) to an unencrypted HTTP connection by replacing the secure HTTPS link</p>
		<p class="programs">&lt;a href="https://www.exampleTestDomain.com/"&gt;Login&lt;/a&gt;</p>
		<p class="noindent">with an insecure HTTP link:</p>
		<p class="programs">&lt;a href="http://www.exampleTestDomain.com/"&gt;Login&lt;/a&gt;</p>
		<p class="indent">Modern browsers defend against these attacks by implementing <em>httP Strict Transport Security (HSTS)</em> rules. Servers use HSTS rules to force browsers to use the HTTPS protocol exclusively; however, the server might not correctly enforce these rules on certain subdomains. By changing the subdomain, a hacker might be able to bypass the HSTS rules. For example, notice the extra <span class="literal">w</span> in following domain:</p>
		<p class="programs">&lt;a href="http://wwww.exampleTestDomain.com/"&gt;Login&lt;/a&gt;</p>
		<p class="indent">Though the domain <em>wwww.exampleTestDomain.com</em> might support HSTS, the system administrator might have forgotten to add HSTS for that subdomain. By accessing a new subdomain <em>wwww.exampleTestDomain.com</em> or <em>support.exampleTestDomain.com</em>, the attacker might still be able to perform an SSL stripping attack.</p>
		<p class="indent">You can use a tool like bettercap to perform this attack. The bettercap tool is a great network hacking utility that’s well worth learning. For example, it could quickly ARP spoof every machine on a network, route the traffic through an HTTP proxy with SSL stripping and HSTS bypass, and inject malicious JavaScript into web pages where HSTS is misconfigured.</p>
		<h3 class="h3" id="ch06lev22"><strong>Exercise: Add Encryption to your Ransomware Server</strong></h3>
		<p class="noindent">In <a href="ch04.xhtml#ch4">Chapter 4</a>, we explored a popular hacker tool: the botnet. However, the design of our bot was flawed because the bots used unencrypted TCP sockets to communicate with its server.</p>
		<p class="indent"><span epub:type="pagebreak" id="page_108"/>The same is true for the ransomware server we built in <a href="ch05.xhtml#ch5">Chapter 5</a>. In this exercise, you’ll implement a new version of your ransomware server that can accept secure connections. I’ve provided an example implementation of a server that supports multiple secure connections. Use this as a template to modify your own code:</p>
		<p class="programs">   import socket<br/>
   import ssl<br/>
   import threading<br/><br/><span class="ent">➊</span> client_cert = 'path/to/client.crt'<br/>
   server_key = 'path/to/server.key'<br/>
   server_cert = 'path/to/server.crt'<br/><br/>
   port = 8080<br/>
   context = ssl.create_default_context(ssl.Purpose.CLIENT_AUTH)<br/>
   context.verify_mode = ssl.CERT_REQUIRED<br/>
   context.load_verify_locations(cafile=client_cert)<br/>
   context.load_cert_chain(certfile=server_cert, keyfile=server_key)<br/>
   context.options |= ssl.OP_SINGLE_ECDH_USE<br/>
   context.options |= ssl.OP_NO_TLSv1 | ssl.OP_NO_TLSv1_1 | ssl.OP_NO_TLSv1_2<br/><br/><span class="ent">➋</span> def handler(conn):<br/>
       encrypted_key = conn.recv(4096).decode()<br/>
       #----------------------------------<br/>
       #  Add your decryption code here<br/>
       #----------------------------------<br/>
       conn.send(decrypted_key.encode())<br/>
       conn.close()<br/><br/>
   with socket.socket(socket.AF_INET, socket.SOCK_STREAM, 0) as sock:<br/>
        sock.bind(('', port))<br/>
     <span class="ent">➌</span> sock.listen(5)<br/>
        with context.wrap_socket(sock, server_side=True) as ssock:<br/>
           while True:<br/>
           <span class="ent">➍</span> conn, addr = ssock.accept()<br/>
              print(addr)<br/>
           <span class="ent">➎</span> handlerThread = threading.Thread(target=handler, args=(conn,))<br/>
              handlerThread.start()</p>
		<p class="indent">Feel free to use the certificates <em>client.crt</em> and <em>server.crt</em>, and keys <em>server.key</em> and <em>client.key</em> that you generated earlier in the chapter. You’ll need to specify their file paths <span class="ent">➊</span>. Also, if you didn’t install the <span class="literal">thread</span> library in an earlier chapter, you might need to install it here by using <span class="literal">pip</span>.</p>
		<p class="indent"><span epub:type="pagebreak" id="page_109"/>I defined the function that handles each incoming connection <span class="ent">➋</span>. You’ll add your decryption code here. Then, we set a backlog of five connections <span class="ent">➌</span>. As new connections come in, they’ll be added to the backlog, and as each connection is handled, it will be removed from the backlog. We continually accept new connections <span class="ent">➍</span>, and we create a new thread to handle each connection ”.</p>
		<p class="indent">After you’ve implemented your secure ransomware server, try encrypting your botnet’s communications, too.<span epub:type="pagebreak" id="page_110"/></p>
	</body>
</html>