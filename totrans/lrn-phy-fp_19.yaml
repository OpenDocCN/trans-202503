- en: '17'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: SATELLITE, PROJECTILE, AND PROTON MOTION
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Images/common.jpg)'
  prefs: []
  type: TYPE_IMG
- en: This chapter discusses three extended examples that use the ideas and code from
    [Chapter 16](ch16.xhtml) to express and solve Newtonian mechanics problems that
    involve one object. The examples are satellite motion, projectile motion with
    air resistance, and a proton in a uniform magnetic field. We’ll show how to make
    plots and animations for each of these examples. Note that we will not begin a
    new module in this chapter; instead, we’ll add to the `Mechanics3D` module we
    started in the last chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Satellite Motion
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'As an initial example of satellite motion, consider the following: Earth orbits
    the sun because of the attractive force of gravity between them. Strictly speaking,
    Earth and the sun each orbit a point located between the two bodies. This point,
    called the *center of mass*, is much closer to the more massive sun than it is
    to the less massive Earth, so it’s a decent approximation to say that Earth orbits
    the sun. In [Chapter 19](ch19.xhtml), we’ll treat universal gravity as a two-body
    force: both the sun and Earth will accelerate in response to it, and both bodies
    will orbit about the center of mass. In this chapter, however, we’re interested
    in the motion of a single object, say Earth, and we’ll treat the force of gravity
    on Earth by the sun as a one-body force. This means we’ll regard the sun as merely
    a piece of furniture whose role is to produce a force of gravity on Earth, but
    it will not partake in the full dance by feeling a force and exhibiting changed
    motion as a result.'
  prefs: []
  type: TYPE_NORMAL
- en: For the satellite motion in this chapter, we’ll only pay attention to the satellite.
    The larger planet or star around which the satellite orbits is imagined to be
    fixed in place; its only job is creating a force of gravity on the satellite.
  prefs: []
  type: TYPE_NORMAL
- en: Halley’s comet orbits the sun, making one orbit every 75 years or so. The orbit
    is quite elliptical, with the comet traveling quickly when it’s close to the sun
    and slowly when it’s far away. In 1986, Halley’s comet was close to the sun, and
    consequently close enough to Earth to be seen without a telescope. It is expected
    again in our neighborhood in 2061.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s animate the orbit of Halley’s comet around the sun. In [Chapter 16](ch16.xhtml),
    we described how to produce an animation. We need five pieces of information for
    the `simulateGloss` or `simulateVis` function: a time-scale factor, an animation
    rate, an initial state, a display function, and a state-update function. We’ll
    describe these now, starting with the pieces of information that have the most
    physical content.'
  prefs: []
  type: TYPE_NORMAL
- en: State-Update Function
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The state-update function `halleyUpdate` can be written using `updatePS`, shown
    in [Figure 16-3](ch16.xhtml#ch16fig3) and defined in [Chapter 16](ch16.xhtml),
    which requires a numerical method and a list of one-body forces. The function
    `halleyUpdate`, and all of the code in this chapter and the next that is not part
    of a stand-alone program, is part of the `Mechanics3D` module we began in [Chapter
    16](ch16.xhtml) and should be in the same source code file.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: For our numerical method, we’ll choose the Euler-Cromer method. Recall that
    for animation, we won’t choose the time step of the numerical method directly
    but rather through the time-scale factor and animation rate we choose later. The
    time step `dt` appears as an input to `halleyUpdate`, and we pass `dt` along to
    `eulerCromerPS` to form the numerical method. The list of one-body forces contains
    only the sun’s force of gravity.
  prefs: []
  type: TYPE_NORMAL
- en: Initial State
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The initial state `halleyInitial` determines whether we get a circular orbit,
    an elliptical orbit, or a satellite moving so fast that it escapes the gravitational
    pull of the sun. The mass of Halley’s comet is 2.2 × 10^(14) kg. The net charge
    of the comet is zero, and we start our clock at zero as well. It’s the initial
    position and velocity that will determine the subsequent orbit. I’ve chosen the
    initial position to be on the positive x-axis at the closest distance that the
    comet comes to the sun, which is 8.766 × 10^(10) m. When Halley’s comet is closest
    to the sun, it’s moving the fastest it will move in the course of its orbit, 54,569
    m/s, in a direction perpendicular to the line connecting the comet with the sun.
    We call this direction the y-direction. Placing all of this information into the
    `ParticleState` data type, we arrive at the following expression for the initial
    state `halleyInitial`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Time-Scale Factor
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '[Listing 17-1](ch17.xhtml#ch17list1) shows the time-scale factor, animation
    rate, and display function and gives a stand-alone program for a 2D animation
    of satellite motion using `gloss`.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 17-1: Stand-alone program for a 2D animation of Halley’s comet in
    orbit around the sun*'
  prefs: []
  type: TYPE_NORMAL
- en: We begin by turning on warnings. Then we import the functions we need from the
    `SimpleVec` module of [Chapter 10](ch10.xhtml), the `Mechanics3D` module we began
    in [Chapter 16](ch16.xhtml) and continue to add to in this chapter and the next,
    and the `Graphics.Gloss` module. The pictures `diskComet` and `diskSun` are markers
    for Halley’s comet and the sun, respectively. The display function `halleyPicture`
    is one of the five ingredients needed for an animation, and it uses the comet’s
    state to translate the comet marker to the appropriate position. The sun is displayed
    at the origin and does not move. In the `main` function, we choose a time-scale
    factor of `365.25 * 24 * 60 * 60` so that one year of physical time is one second
    of animation time. Since the period of Halley’s comet is about 75 years, it will
    take about a minute and 15 seconds for the animation to show a complete orbit.
  prefs: []
  type: TYPE_NORMAL
- en: Animation Rate
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: For animations in general, I recommend starting with an animation rate of about
    20 frames/second. For Halley’s comet, that gives a time step of 1/20 of a year,
    much smaller than 75 years, which appears to be the important time scale of the
    situation. If you use 20 frames/second instead of the 400 frames/second shown
    in [Listing 17-1](ch17.xhtml#ch17list1), you’ll notice that the orbit has some
    funny properties. Halley’s comet just wanders off the screen and doesn’t come
    back to go around the sun, at least not in anything close to 75 seconds. The trouble
    is that the comet moves very quickly when it is close to the sun, and relatively
    slowly when it is far away.
  prefs: []
  type: TYPE_NORMAL
- en: An accurate calculation requires a relatively small time step when the comet
    is close to the sun, moving rapidly, and changing direction quickly. The time
    step for the rest of the orbit could be substantially larger without doing any
    damage. There are some numerical methods that use a variable time step, but they
    are beyond the scope of this book. We need to increase the animation rate or decrease
    the time-scale factor in order to use a time step small enough to maintain accuracy
    during the short period of closest approach. Trying out different animation rates
    suggests that 400 frames/second is probably sufficient to give reasonably accurate
    results.
  prefs: []
  type: TYPE_NORMAL
- en: Display Function
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '[Figure 17-1](ch17.xhtml#ch17fig1) shows one frame of the animation of Halley’s
    comet around the sun. In this snapshot, the sun is shown in gray at the right
    of the figure, while Halley’s comet moves to the left, away from the sun. The
    animation we are writing produces a yellow sun and and a red comet.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Images/311fig01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 17-1: Halley’s comet moving away from the sun*'
  prefs: []
  type: TYPE_NORMAL
- en: The display function `halleyPicture` needs to describe how to produce a picture
    from a state. The main thing we want to show is the position of the comet. The
    comet moves in the *z* = 0 plane, so we just need to deal with the x- and y-components
    of position in this function. The `halleyPicture` function in [Listing 17-1](ch17.xhtml#ch17list1)
    uses pattern matching on the input to assign the local variable `r` to the position
    of the current state of the comet. Position is the only state variable that the
    display function cares about; velocity or mass play no role in determining how
    the picture looks. We use the `xComp` and `yComp` functions from the `SimpleVec`
    module of [Chapter 10](ch10.xhtml) to extract the x- and y-components of the position.
  prefs: []
  type: TYPE_NORMAL
- en: The `where` keyword is similar to the `let` keyword, allowing the code writer
    to define local variables and functions; however, `where` and its local names
    come after the body of the principal function rather than before it.
  prefs: []
  type: TYPE_NORMAL
- en: The `realToFrac` function converts real numbers with type `R` into real numbers
    with type `Float` because `gloss`’s `translate` function requires `Float`s as
    input. The final picture produced contains a yellow disk to represent the sun
    and a red disk, translated to the appropriate place, to represent the comet. The
    `pictures` function in `gloss` produces a single picture from a list of pictures.
  prefs: []
  type: TYPE_NORMAL
- en: Spatial scaling needs to take place in the display function. Physical sizes
    are expressed in meters, while `gloss` sizes are expressed in pixels. Thus, we
    need to specify how this conversion is to be done. One natural scaling strategy
    is to show everything to scale, using a single overall scaling factor to convert
    meters to pixels. The `scale` function in `gloss` is excellent for this purpose
    because it can take as input a picture with all lengths in meters and produce
    another picture scaled by the number of pixels per meter that we want. But in
    the Halley animation, if we try to show everything to scale, using accurate values
    in meters for the two radii and the position of the comet and one overall scaling
    factor from meters to pixels, we will not be able to see the comet or the sun
    because the distance over which the comet roams is so vast.
  prefs: []
  type: TYPE_NORMAL
- en: 'Since we can’t show the sizes of the sun and comet to scale, the yellow and
    red disks act only as markers for the location of the sun and comet; the sizes
    of these disks are not to scale with the orbital motion or with each other. It
    is easiest to specify the radii of the sun and comet in pixels rather than in
    meters, which would need to be scaled to pixels and scaled by a different factor
    than the comet position. The pictures `diskComet` and `diskSun` specify the radii
    for these two disks to be 10 pixels and 20 pixels, respectively. We won’t scale
    these radii any more. These two pictures make use of the `disk` function, which
    we defined in [Chapter 13](ch13.xhtml) and repeat here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Another reason I’d rather specify the radii in pixels is that spatial scaling
    is often determined by trial and error, reducing or expanding the size of an animation
    that’s working. If this trial-and-error scaling is done on the entire picture,
    involving both the orbit size and the radii, it’s easy to shrink the radii too
    much so that the disks can’t be seen, or to expand the radii too much so that
    they fill the entire screen. In either of these cases, it’s sometimes difficult
    to know what the problem is.
  prefs: []
  type: TYPE_NORMAL
- en: In the Halley animation, there is only one thing that needs to be scaled, and
    that’s the position of the comet. We use a factor of 10^(–10) pixels/meter to
    scale the x- and y-components of the position.
  prefs: []
  type: TYPE_NORMAL
- en: Projectile Motion with Air Resistance
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'For our next example, let’s look at a batted baseball. This is an example of
    projectile motion with air resistance. We’ll consider two forces that act on the
    baseball: Earth’s surface gravity and air resistance. We’ll use a 145-g baseball
    with a diameter of 74 mm and a drag coefficient of 0.3\. The list `baseballForces`
    contains the two one-body forces that act on the baseball. The list `baseballForces`,
    and all of the code in this chapter and the next that is not part of a stand-alone
    program, is part of the `Mechanics3D` module.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The first force is Earth surface gravity and the second force is air resistance.
    We define a local variable `area` to hold the cross-sectional area of the baseball.
    The number 0.074 is the diameter of the ball in meters, 0.3 is the drag coefficient,
    and 1.225 is the density of air in kg/m³.
  prefs: []
  type: TYPE_NORMAL
- en: For situations that take place on or near Earth’s surface, I like to use a coordinate
    system in which *x* and *y* are the horizontal coordinates and *z* is the vertical
    coordinate, with positive *z* pointing away from Earth’s center. Projectile motion
    with air resistance takes place in a plane. It would be reasonable to choose the
    xz-plane or the yz-plane for this motion. We’ll choose the yz-plane because the
    default coordinate system for the `simulateVis` function, should we choose to
    use it, has *y* to the right and *z* up the screen.
  prefs: []
  type: TYPE_NORMAL
- en: Calculating a Trajectory
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The function `baseballTrajectory`, defined below, produces a list of (y, z)
    pairs, where *y* and *z* are the horizontal and vertical components of position,
    respectively. We give this function a time step, an initial speed, and an angle
    in degrees. The angle is the angle above the horizontal at which the ball leaves
    the bat.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: We’ve defined several local variables to hold the angle in radians, the horizontal
    and vertical components of initial velocity, and the initial state of the ball.
    We use `statesPS` to make an infinite list of states, using the Euler-Cromer method
    with the given step size, the list of forces (`baseballForces`), and the initial
    state. The function `zGE0`, defined below, truncates the infinite list to a finite
    list consisting only of states with a vertical position greater than or equal
    to zero. The function `trajectory`, also defined below, transforms a list of states
    into a list of (y, z) pairs suitable for plotting.
  prefs: []
  type: TYPE_NORMAL
- en: The infinite list produced by `statesPS` is truncated to a finite list with
    the function `zGE0`, which takes elements of the infinite list with a vertical
    position component greater than or equal to zero. As soon as it finds a vertical
    component less than zero, it stops checking list items and returns the finite
    list.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: By returning a finite list of states, we are one step closer to plotting the
    trajectory since we can’t plot an infinite list.
  prefs: []
  type: TYPE_NORMAL
- en: The `trajectory` function returns the horizontal and vertical components of
    position for each state in the input list. This would be a natural thing to plot,
    so we are again one step closer to plotting the trajectory.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Finding the Angle for Maximum Range
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Let’s go a little further with our baseball analysis. The function `baseballRange`
    computes the horizontal range of the ball for a given initial speed and angle.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: To accomplish this, we use the `baseballTrajectory` function from earlier, take
    the last pair with a nonnegative vertical position component, and return the horizontal
    position component of that pair.
  prefs: []
  type: TYPE_NORMAL
- en: Now let’s make a graph of baseball range as a function of the angle at which
    the ball is hit. In the absence of air resistance, the maximum range is achieved
    at an angle of 45^∘. Perhaps the presence of air resistance, which we are including,
    will produce different results. The function `baseballRangeGraph` in [Listing
    17-2](ch17.xhtml#ch17list2) makes such a graph for a baseball batted at 45 m/s
    (101 mph).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 17-2: Code to produce the graph “Range for baseball hit at 45 m/s”*'
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 17-2](ch17.xhtml#ch17fig2) shows the horizontal range of a batted baseball
    as a function of the angle at which it leaves the bat. We assume an initial speed
    of 45 m/s (101 mph) at every angle. Notice that the longest range occurs at an
    angle less than 45^∘ above the horizontal.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Images/315fig01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 17-2: Range for a batted baseball. Because of air resistance, the longest
    range does not occur at an angle of 45^∘ leaving the bat.*'
  prefs: []
  type: TYPE_NORMAL
- en: We can search for the angle that produces the longest range. The value `bestAngle`
    looks through all of the angles from 30^∘ to 60^∘ in 1^∘ steps to find the angle
    that produces the longest range.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: To find the longest range, we want to compare `baseballRange 0.01 45` `thetaDeg`,
    the range for an initial speed of 45 m/s at an angle of `thetaDeg`, for different
    values of the angle. But we want the `bestAngle` function to return the angle
    at which we achieve the longest range, so we cannot merely ask for the maximum
    of `baseballRange 0.01 45 thetaDeg` because that would return only the range and
    not the angle that achieved that range.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can get what we want, the longest range and the angle at which it is achieved,
    by comparing pairs and asking for the maximum pair. The `maximum` function uses
    dictionary order when comparing pairs, so the maximum pair is the one with the
    largest first element. If there is a tie in comparing first elements, the function
    compares second elements to break the tie. By choosing the first element of the
    pair to be the range, the comparison will be done on the range, and by choosing
    the second element of the pair to be the angle, the function will return the angle
    as well. Here is the value of `bestAngle` reported by GHCi:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: We see that, to within an accuracy of 1^∘, the angle that produces the longest
    range is 41^∘ above the horizontal.
  prefs: []
  type: TYPE_NORMAL
- en: 2D Animation
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Let’s turn now to making an animation of the motion of the baseball. The motion
    takes place in a plane, so we’ll use the two-dimensional `gloss` package. We’ll
    make a stand-alone program to do the animation, and then we’ll show how the program
    can take arguments that specify the initial speed and angle.
  prefs: []
  type: TYPE_NORMAL
- en: Main Program
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[Listing 17-3](ch17.xhtml#ch17list3) gives a stand-alone program for a 2D animation
    of projectile motion using `gloss`.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 17-3: Stand-alone program for a 2D animation of projectile motion.
    Initial speed and angle can be specified on the command line when the program
    is run.*'
  prefs: []
  type: TYPE_NORMAL
- en: As usual, the first line asks for warnings and the next several lines import
    functions and types we want to use in the program.
  prefs: []
  type: TYPE_NORMAL
- en: 'A new feature of this program is that we pass information to the program using
    command line arguments. A *command line argument* is a piece of information given
    after the name of the program you execute on the command line. For example, for
    a stand-alone program called *GlossProjectile*, obtained by compiling a source
    code file called *GlossProjectile.hs*, we might run the program by entering the
    following instruction at the command line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: We give the name of the executable program we want to run (preceded by a dot-slash
    to indicate its location in the current directory) followed by some command line
    arguments that allow us to pass information to the program. We want to pass the
    initial speed and angle in degrees.
  prefs: []
  type: TYPE_NORMAL
- en: How does the program receive and use this information? The standard module `System.Environment`,
    which is included when you initially install the GHC compiler, provides a function
    `getArgs` that returns the command line arguments as a list of strings. For example,
    the `getArgs` function, if used in the program *GlossProjectile* executed with
    the command just shown, would return the list `["30","40"]`. We can then use these
    strings to determine what the program does. The function `getArgs` is simple and
    sufficient for our purposes, but if you find yourself getting more serious about
    using command line arguments in your Haskell programs, you may want to look at
    the standard module `System.Console.GetOpt`, also included with the GHC compiler,
    as it provides functions to handle command line arguments in a more sophisticated
    way.
  prefs: []
  type: TYPE_NORMAL
- en: 'Knowing that we will have access to a list of strings containing the command
    line arguments, we write a function that does the work our `main` function did
    in previous animations, namely calling `simulateGloss`, but takes a list of strings
    as input. The function `mainWithArgs` in [Listing 17-3](ch17.xhtml#ch17list3)
    does exactly that. As before, `simulateGloss` requires five pieces of information:
    a time-scale factor, an animation rate, an initial state, a display function,
    and a state-update function.'
  prefs: []
  type: TYPE_NORMAL
- en: We chose a time-scale factor of 3 (so the animation takes place more rapidly
    than the physical evolution) and an animation rate of 20 frames per second. We
    named the list of strings from the command line `args` in `mainWithArgs` and fed
    it to the function `projectileInitial`, which creates the initial state based
    on these strings. We will write the function `projectileInitial` shortly.
  prefs: []
  type: TYPE_NORMAL
- en: The display function `projectilePicture` in [Listing 17-3](ch17.xhtml#ch17list3)
    describes the picture we want to produce for a given particle state. In this display
    function, we create a picture and then scale the entire picture by a factor of
    0.2 pixels/meter. The `scale 0.2 0.2` function shrinks the picture by a factor
    of five in both the horizontal and vertical dimensions.
  prefs: []
  type: TYPE_NORMAL
- en: The `main` program uses the function `getArgs` to get any command line arguments
    specified when the program is run. The function `getArgs` is not a pure function;
    it is an *effectful* function. An effect is a computation that is not purely functional
    (that is, it depends on or changes the world in some way). Computations that depend
    on program input, randomness, or the current time are effects. Sending information
    to a display or writing to the hard drive are also effects. An effect produced
    by a function is sometimes called a side effect, presumably to distinguish it
    from the main purpose of a function, which is to produce an output. A pure function
    is one that involves no effects; its output depends only on its inputs and unchanging
    global values. An effectful function is one whose output depends on something
    other than its inputs (such as user input, command line arguments, or randomness)
    or that has a side effect in addition to its output. In Haskell, an effectful
    function must have a type that involves the `IO` type constructor.
  prefs: []
  type: TYPE_NORMAL
- en: To see this, let’s load the module `System.Environment` prefixed by a plus sign
    so that the `Mechanics3D` module will not be unloaded, which is the default behavior.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: The fact that `getArgs` is an effectful function is indicated by the `IO` type
    constructor. While a pure function’s output can depend only on its inputs and
    unchanging global values, the output of `getArgs` depends on command line arguments,
    which are not function inputs or global values. For this reason, `getArgs` must
    have type `IO [String]` rather than `[String]`. The `IO` tag on data means that
    the data may have been acquired through some effect. The absence of an `IO` tag
    on data is a promise that the data has not been acquired through any effect.
  prefs: []
  type: TYPE_NORMAL
- en: The `IO` type constructor that labels an effectful function is one example of
    a collection of type constructors known as *monads*. The idea of a monad has been
    around in the mathematics of category theory for several decades; its use in functional
    programming is more recent, where it represents a computational abstraction. Haskell
    has a type class `Monad` for type constructors, such as `IO`, that can implement
    certain functions. Since the `IO` type constructor is an instance of type class
    `Monad`, it is also referred to as the `IO` monad. It is not the intent of this
    book to say much about monads. Monads are an interesting abstraction, but I don’t
    think physics has a strong need for them. The books *Real World Haskell* [**[2](bib.xhtml#bib2)**]
    and *Learn You a Haskell for Great Good* [**[1](bib.xhtml#bib1)**] have nice discussions
    of monads. Stephen Diehl’s “What I Wish I Knew When Learning Haskell” at [http://dev.stephendiehl.com/hask](http://dev.stephendiehl.com/hask)
    also has a nice discussion of monads.
  prefs: []
  type: TYPE_NORMAL
- en: The operator `>>=`, called “bind,” is the most important of the monad functions.
    In the context of the `IO` monad we have here, it provides a way to use information
    arising from an effectful function. To understand its use, let’s take a look at
    its type.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: The type variables `a` and `b` stand for types, while the type variable `m`
    stands for a type constructor. The type class `Monad` has type constructors as
    instances. Haskell’s notion of *kind*, introduced in [Chapter 9](ch09.xhtml),
    helps to classify the possibilities of what a type variable can stand for.
  prefs: []
  type: TYPE_NORMAL
- en: 'For our purpose, the type variable `m` can be replaced with `IO`, which is
    an instance of type class `Monad`. Specializing the bind operator to the `IO`
    type constructor, bind has the following type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'We see that bind takes two things: a value with type `a` “tagged” by the `IO`
    type constructor and an effectful function whose input has type `a`, which produces
    a value of type `b` “tagged” by the `IO` type constructor. We can think of this
    `IO` type constructor as a tag on the value that indicates its origin and/or effect.
    The bind operator allows an `IO`-tagged value to be used as a regular value in
    a function that promises to return an `IO`-tagged result. Since `IO` acts as a
    tag for effects, it is important that the `IO` tag is not removable once applied.
    However, if a function returns a tagged output, the bind operator provides a way
    for a tagged input to be temporarily untagged and used, knowing that the function
    will retag the output.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We are using the bind operator (`>>=`) in a setting where type variable `a`
    is `[String]` and type variable `b` is unit, so the concrete type of bind in our
    program is the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: The bind operator is just what we need to connect the output of `getArgs` with
    the input of `mainWithArgs`. In fact, the `main` program does nothing other than
    pass the output of `getArgs` to the function `mainWithArgs`.
  prefs: []
  type: TYPE_NORMAL
- en: State-Update Function and Initial State
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: The state-update function `projectileUpdate` is written using `updatePS`, just
    as in satellite motion.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Again, for our numerical method, we chose the Euler-Cromer method. We used the
    same list of one-body forces, `baseballForces`, that we used to make the graph
    shown earlier.
  prefs: []
  type: TYPE_NORMAL
- en: 'Knowing that we want to pass the initial speed and angle to our program as
    command line arguments, and that these will be available as a list of strings,
    we’ll write the function `projectileInitial` to take a list of strings, which
    will come from the command line when we run the program, and use these strings
    to determine the initial velocity. We want the list of strings to have two elements:
    the first string gives the initial speed and the second gives the initial angle
    in degrees.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: We use pattern matching on the input to give a helpful error message if exactly
    two arguments are not provided. The first line responds to the empty list, the
    case in which no command line arguments are given. The second line responds to
    the case in which only one command line argument is given. The third line responds
    to the case in which three or more command line arguments are given. Finally,
    the fourth line treats the case of exactly two command line arguments, which is
    what we want.
  prefs: []
  type: TYPE_NORMAL
- en: 'We use the `read` function to convert the strings to real numbers. The `read`
    function takes a string as input and produces an output that is one of many types.
    We need to give a type annotation to specify what type we want the string converted
    to. Here is an example of what `read` does:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 3D Animation
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Several of the items needed to create a 3D animation are the same as those needed
    for a 2D animation, but one is different. To compare the process of making a 3D
    animation with that of making a 2D animation, let’s animate the projectile motion
    using our 3D animation tools. [Listing 17-4](ch17.xhtml#ch17list4) gives a stand-alone
    program for a 3D animation of projectile motion using `not-gloss`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 17-4: Stand-alone program for a 3D animation of projectile motion*'
  prefs: []
  type: TYPE_NORMAL
- en: The `main` function is exactly the same as in the 2D animation. The `main` `WithArgs`
    function uses `simulateVis` instead of `simulateGloss`, but it uses the same time-scale
    factor, animation rate, initial-state function, and state-update function we used
    for the 2D animation.
  prefs: []
  type: TYPE_NORMAL
- en: The only new piece we need is a display function, `projectileVisObject`. In
    this display function, the state is named `st`, and we define a local variable
    `r` for the position of the object. We use a solid red sphere with radius 0.1
    to represent the projectile. The `not-gloss` package does not measure distances
    in pixels; instead, a length of 1 is initially about 20 percent of the height
    of the screen. You can then zoom in or out by pressing E or Q, or by using the
    mouse. Before we translate the red sphere to its appropriate position, we need
    to scale the position `r` from meters to `Vis` units, and we need to convert the
    position to `Vis`’s vector type. We multiply the position by a factor of 0.01
    `Vis` units per meter so the range of the animation is not too big and not too
    small. We use the `v3FromVec` function, defined in [Chapter 16](ch16.xhtml), to
    convert to `Vis`’s vector type before using the `Trans` function.
  prefs: []
  type: TYPE_NORMAL
- en: Having seen an example of projectile motion with air resistance, the technique
    of using command line arguments to pass information into a program, and a comparison
    of 2D and 3D animation, let’s turn to an example that really requires 3D animation.
  prefs: []
  type: TYPE_NORMAL
- en: Proton in a Magnetic Field
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Magnetic fields are used in particle accelerators to get protons or electrons
    to move in a circular ring to bring them to high speed and slam them into each
    other. This lets experimentalists look at the particles created in such high-energy
    collisions and learn things about the nature of particles and their interactions.
  prefs: []
  type: TYPE_NORMAL
- en: A charged particle in a uniform magnetic field will move in a circle or a helix.
    This is not obvious, but it is a consequence of the Lorentz force law, given as
    Equation 16.8 for uniform fields. Luckily for us, a helix is a nice motion for
    showing off our 3D animation tools.
  prefs: []
  type: TYPE_NORMAL
- en: According to the Lorentz force law, the magnetic force on a particle is proportional
    to the cross product **v**(*t*) ×**B**, which means that the force is perpendicular
    to both the particle’s velocity and the magnetic field. Since the magnetic force
    is always perpendicular to the velocity of the particle, it can’t make the particle
    speed up or slow down; it can only make the particle turn (change direction).
  prefs: []
  type: TYPE_NORMAL
- en: To produce an animation of this, we’ll need a state-update function, an initial
    state, and a display function. Here is a state-update function for a particle
    in a uniform magnetic field of strength 3 × 10^(–8) Tesla.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: We’re using fourth-order Runge-Kutta as our numerical method because it produces
    good results with a fairly large step size, while Euler-Cromer requires a rather
    small step size to produce good results. There’s no way to know this in advance.
    It’s always a good idea to check that results are stable with changes in step
    size. The list of forces has only one item, the Lorentz force of a uniform magnetic
    field. The `zeroV` is for zero electric field.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the initial state of the proton on which the magnetic field acts:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: By giving the proton an initial component of velocity in both the y- and z-directions,
    we’ll get a helix for the motion. If either of these components is set to 0, a
    different kind of motion will ensue. Play around and see what happens.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the display function for the proton in the magnetic field:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: A red ball is used to mark the location of the proton.
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 17-5](ch17.xhtml#ch17list5) shows a stand-alone Haskell program to
    animate a proton in a magnetic field. The time-scale factor is set to one, so
    this is a real-time animation. Note that the magnetic field is very small in this
    example and that a larger magnetic field would cause the proton to complete a
    turn of the helix in much less time. The animation rate is set to 60 frames/second.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 17-5: Stand-alone Haskell program for 3D animation of a proton in
    a uniform magnetic field*'
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, we used the ideas and code from [Chapter 16](ch16.xhtml) to
    study three examples of the motion of a single particle in three dimensions subject
    to different forces. We gave examples of 2D or 3D animation for satellite motion,
    projectile motion with air resistance, and a particle in a magnetic field. In
    the next chapter, we’ll show how the ideas and code from [Chapter 16](ch16.xhtml)
    can be used or modified slightly to treat single-particle mechanics problems with
    the theory of relativity instead of Newton’s second law.
  prefs: []
  type: TYPE_NORMAL
- en: Exercises
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Exercise 17.1.** Modify the `halleyPicture` function in [Listing 17-1](ch17.xhtml#ch17list1)
    to include x- and y-axes in the animation. You will be able to see that the comet’s
    aphelion (point of greatest distance from the sun) is not quite aligned with the
    x-axis. This is an indication of inaccuracy in the numerical method, which can
    be reduced by decreasing the time-scale factor and reducing the time step of the
    numerical method.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Exercise 17.2.** Let’s treat Earth as being fixed at the origin of our coordinate
    system. Consider the gravitational force on a satellite of mass *m*, initial position
    **r**[0], and initial velocity **v**[0]. Since the motion of the satellite will
    take place in a plane, we can use vectors that lie in the xy-plane. Plot trajectories
    of orbits resulting from various initial conditions. Choose some values for initial
    conditions that give nearly circular orbits and some others that give elliptical
    orbits. You will find that the Euler method produces orbits that don’t close on
    themselves. Make one plot comparing the Euler and Euler-Cromer methods for one
    orbit that you like (elliptical or circular). Indicate the step size you used
    for the Euler and Euler-Cromer methods as well as your choice of initial conditions.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Exercise 17.3.** The Lorentz force law, Equation 16.8, describes the force
    exerted on a particle with charge *q* and velocity **v**(*t*) by an electric field
    **E** and a magnetic field **B**. Consider a uniform magnetic field in the z-direction.
    You may already know that a charged particle with initial velocity in the x-direction
    will go in circles in this magnetic field. Choose some values for the strength
    of the magnetic field, the charge of the particle, the mass of the particle, and
    the initial velocity. Confirm, using the Euler-Cromer method, that the particle
    does indeed go in circles. Plot *y* versus *x* for different time steps. Even
    the Euler-Cromer method will not produce circles that close on themselves if the
    time step is too big. One of your time steps should be small enough that the orbit
    appears to close.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Exercise 17.4.** Return to the satellite orbiting Earth. Write a Haskell
    program to animate your satellite’s motion around Earth. Show that by using different
    initial conditions, you can achieve circular orbits and elliptical orbits.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Exercise 17.5.** Suppose the wind is blowing horizontally at 10 m/s and you
    launch a Ping-Pong ball straight up into the air with an initial speed of 5 m/s.
    How far from the launch point will it hit the ground? You can come up with pretty
    good estimates for the density of air and the mass and cross-sectional area of
    the ball, but an estimate for the drag coefficient is more of a guess. Try the
    calculation for drag coefficients of 0.5, 1.0, and 2.0 to see how they compare.
    Repeat the calculation for a golf ball launched upward with the same speed.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Exercise 17.6.** Make the necessary modifications to the code presented in
    this chapter so that the initial position of the baseball is 1 meter above the
    ground. Make a plot of the trajectory for a line drive with a speed of 40 m/s
    at an angle 5^∘ above horizontal.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Exercise 17.7.** Investigate the effect of a 30-mph crosswind on a batted
    baseball. Assuming the wind is perpendicular to the plane in which the ball would
    otherwise travel, how far does the wind displace the ball from the place where
    it would land without the wind? Choose some reasonable values for initial speed
    and angle of the ball.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Exercise 17.8.** Given an initial speed and a drag coefficient, the optimal
    angle is the angle that produces the longest range for the baseball. Make a graph
    of the optimal angle as a function of drag coefficient for an initial speed of
    45 m/s.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Exercise 17.9.** If you can produce uniform electric and magnetic fields,
    you can make a device called a *velocity selector*. The purpose of a velocity
    selector is to allow charged particles that are traveling at a specific velocity
    to proceed in a straight line, while similar particles traveling faster or slower
    get deflected. From a beam of charged particles moving with a range of speeds,
    the velocity selector can produce a beam of particles that all have very close
    to the same speed. In this way, the experimentalist has access to a beam of charged
    particles with a known velocity that can be used for some experiment.'
  prefs: []
  type: TYPE_NORMAL
- en: Let’s model a velocity selector using a uniform electric field of 300 N/C in
    the positive z-direction and a uniform magnetic field of 0.3 T in the positive
    x-direction. We’re interested in the motion of a singly ionized particle with
    mass 1.00 × 10^(–22) kg. (Singly ionized means that one electron has been removed
    so the particle has the charge of a proton.) We’ll give this particle an initial
    velocity in the positive y-direction. If the particle is moving too fast, it will
    deflect one way; if it’s moving too slowly, it will deflect another way.
  prefs: []
  type: TYPE_NORMAL
- en: Using the `Vis` module, make a stand-alone program that takes the initial speed
    of the particle as input (similar to how our projectile motion program took initial
    speed and angle as input) and produces an animation for the particle in the velocity
    selector. To judge whether and how much the particle is deflecting, include a
    coordinate system in your picture (similar to the coordinate system we displayed
    in [Chapter 13](ch13.xhtml)), so you can tell when the particle departs from the
    y-axis. Use a time-scale factor of 5 × 10^(–4) and an animation rate of 60 frames/second.
    Run this program with different initial speeds between 0 and 5,000 m/s.
  prefs: []
  type: TYPE_NORMAL
- en: (a) Confirm that the particle deflects one way for slow speeds.
  prefs: []
  type: TYPE_NORMAL
- en: (b) Confirm that the particle deflects another way for fast speeds.
  prefs: []
  type: TYPE_NORMAL
- en: (c) Extend your program to include a circular aperture at *y* = 1 m that allows
    particles to pass through. Start with an aperture radius of 4 cm.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Particles outside this radius will be blocked by a wall and not allowed to
    pass through. Modify your state-update function to include a wall force that blocks
    particles outside the aperture radius when they get to *y* = 1 m. You can use
    the following wall force:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: This wall force applies a dissipative force that will slow the particle to a
    crawl in just a few time steps if its y-value is between 100 cm and 110 cm and
    it is outside the aperture radius. You could think of the wall as 10 cm of lead,
    but the real reason for the 10 cm is to catch particles that are moving very quickly;
    the wall thickness could be reduced if the time step was reduced. (You may notice
    that particles crawl along the wall at a slow speed or move through the 10 cm–long
    aperture “tube” because the electric field still acts on them.) Modify your display
    function to include a circle for the aperture. Find the range of velocities allowed
    through the 4-cm aperture. What range of velocities are allowed through a 1 cm–radius
    aperture? How about a 1 mm–radius aperture?
  prefs: []
  type: TYPE_NORMAL
- en: Try to guess how the target velocity (velocity of particle when undeflected)
    is related to the numeric values of electric and magnetic fields.
  prefs: []
  type: TYPE_NORMAL
- en: '**Exercise 17.10.** Use the `Vis` module to animate the motion of Halley’s
    comet. Instead of Euler-Cromer, use fourth-order Runge-Kutta because the `Vis`
    module can’t achieve an animation rate of 400 frames/second (although it won’t
    tell you this and it will do the best it can). Try animation rates of 20 frames/second
    (too small, the orbits spiral inward toward the sun), 60 frames/second (pretty
    good), and 400 frames/second (really good, even though 400 frames/second is not
    being achieved). You may want to use the following function as the last transformation
    of your picture before handing it off to `simulateVis`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: The function `zOut` orients the display so that the xy-plane is more or less
    the plane of the screen, and *z* points out from the screen. The default orientation
    has *x* pointing out of the screen, *y* to the right, and *z* up the screen.
  prefs: []
  type: TYPE_NORMAL
- en: '**Exercise 17.11.** Use `gnuplot` to make plots of the Halley’s comet orbit
    using different numerical methods. Use Euler, Euler-Cromer, and fourth-order Runge-Kutta,
    each with time steps of 1/20 year, 1/60 year, and 1/400 year. The results should
    look [Figure 17-3](ch17.xhtml#ch17fig3), where the left column is Euler, the middle
    column is Euler-Cromer, and the right column is fourth-order Runge-Kutta. The
    top row uses a time step of 1/20 year, the middle row 1/60 year, and the bottom
    row 1/400 year.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Images/326fig01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 17-3: Halley’s comet orbit using Euler, Euler-Cromer, and fourth-order
    Runge-Kutta, with time steps of 1/20 year, 1/60 year, and 1/400 year, respectively.*'
  prefs: []
  type: TYPE_NORMAL
- en: When calculating orbits, we can take advantage of energy conservation to check
    the numerical accuracy of the integration scheme. The particle state structure
    has the position of the comet, from which we can find the potential energy, and
    the velocity, from which we can compute the kinetic energy. Write a function
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: that computes the total energy of Halley’s comet in a given `ParticleState`.
    We know that the total energy of Halley’s comet is conserved, so any change in
    the energy we calculate is due to inaccuracies in the numerical method we are
    using. We can use the fractional change in energy over a period of one orbit as
    a measure of how good our numerical method is.
  prefs: []
  type: TYPE_NORMAL
- en: 'For numerical methods that are reasonably good, such as the three in the lower-right
    corner of [Figure 17-3](ch17.xhtml#ch17fig3), we can use the following predicate
    with `takeWhile` to truncate the list of states after one orbit has occurred:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: This predicate works by accepting the first 50 years of orbit data (recall the
    period is about 75 years), at which point the y-component of position is negative,
    and continuing to accept data until the y-component becomes positive, which indicates
    the beginning of the second orbit.
  prefs: []
  type: TYPE_NORMAL
- en: Calculate the fractional change in energy over a period of one orbit for (a)
    the Euler-Cromer method with step size 1/400 year (you should get about one percent),
    (b) the fourth-order Runge-Kutta method with step size 1/60 year, and (c) the
    fourth-order Runge-Kutta method with step size 1/400 year. For an extra challenge,
    label each `gnuplot` graph with the fractional change in energy over a single
    orbit.
  prefs: []
  type: TYPE_NORMAL
