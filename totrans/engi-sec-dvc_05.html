<html><head></head><body>
<div id="sbo-rt-content"><h2 class="h2" id="ch03"><span epub:type="pagebreak" id="page_51"/><strong><span class="big">3</span><br/>RANDOM NUMBER GENERATORS</strong></h2>
<div class="image1"><img alt="Image" height="252" src="../images/common.jpg" width="252"/></div>
<p class="noindent">Randomness is the natural counterpart of determinism. While we want most device functionalities to follow the latter, <em>random number generators (RNGs)</em> are meant to extract the former. But is it even possible to yield random numbers within an integrated circuit (IC)? And if so, can we even describe “good” randomness with practical requirements?</p>
<p class="indent">Some people argue that true randomness is present only in quantum-mechanical processes (and they might be right), but quantum experiments are usually hard to carry out within a standard complementary metal–oxide semiconductor (CMOS) chip. On the other hand, many security applications absolutely require a source of random numbers to reach their intended protection level.</p>
<p class="indent">This chapter starts with applications that demand randomness in order to be regarded as secure. It introduces a common way to extract randomness within a microchip and the idea behind <em>true randomness</em>. Additionally, I explain the concept of <em>pseudorandomness</em> and why it’s necessary for practical scenarios. Finally, I provide three simple tools you can use to evaluate sets of random numbers in order to find possible implementation flaws.</p>
<h3 class="h3" id="ch00lev1_27"><span epub:type="pagebreak" id="page_52"/><strong>The Need for Randomness</strong></h3>
<p class="noindent">Many security concepts rely on randomness. For example, when secrets like passwords, cryptographic keys, or unique tokens are generated, they serve as confidential data that is available only to a specific entity. Naturally, the result of this generation process has to be completely unpredictable. Otherwise, the search space for that secret would be narrowed, reducing the security level and making attacks more efficient, as discussed in <a href="ch02.xhtml#ch02">Chapter 2</a>.</p>
<p class="indent"><em>Challenge-response authentication</em>, which is part of many popular security protocols, is a second use case where randomness is essential. With this type of authentication, a verifier sends a random, unforeseeable challenge to the entity claiming a given identity to initiate the authentication process. This random value then must be processed with a unique secret to prove the claimed identity. However, if the challenge could be known in advance or possibly be recurring, the attacker would be able to prepare for this situation and acquire the expected response by other means.</p>
<p class="indent">Since secret keys and secure communication are essential for many IoT devices, the need for RNGs within these devices is pretty obvious. However, in most cases, a software solution can’t solve this need, so it has to be integrated in the hardware, usually the main processor of a device or a dedicated security chip. Therefore, an RNG requirement should be part of every processor-purchasing process when aiming for device security.</p>
<div class="note">
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>
<p class="notep"><em>In practice, some software libraries, such as Mbed TLS, explicitly require you to define a source of randomness to be used for security operations. They won’t work without it.</em></p>
</div>
<h3 class="h3" id="ch00lev1_28"><strong>The Nature of Randomness</strong></h3>
<p class="noindent">Although randomness is a natural thing, it’s quite difficult to describe. A simple explanation is that randomness is obtained from an experiment for which the outcome can’t be predicted before it’s executed, like a coin toss. Even if that experiment has been executed a million times, we wouldn’t find any pattern or characteristic repetition in the results, and couldn’t derive any certainty about the output other than by purely guessing.</p>
<p class="indent">The measure for this uncertainty and unpredictability is called <em>entropy</em>. It’s also used in other disciplines like physics or information theory to describe the amount of disorder or information contained in a system or data. In the RNG context, entropy describes the number of bits that can be regarded as <em>truly</em> random. A bad RNG might produce only 2.4 bits of entropy per byte, which means that more than 5 bits of information about a single RNG output byte could be guessed with high certainty.</p>
<p class="indent">At this point, it’s probably clear that we desire 8 bits of entropy per byte for a high-quality RNG. However, entropy itself or its absence is hard to measure, so RNG experts rely on statistical evaluations of preferably large amounts of collected random bits to identify flaws and assess their design optimizations. Two of these statistical requirements are independence and uniform distribution.</p>
<p class="indent"><span epub:type="pagebreak" id="page_53"/><em>Independence</em> means that every randomness-generating experiment should be separate from previously run experiments. Therefore, the value of output bits doesn’t have a <em>conditional</em> probability of occurrence, so it doesn’t have any relation to the output bits that have been extracted before. <a href="ch03.xhtml#ch03fig01">Figure 3-1</a> shows four binary datasets.</p>
<div class="image"><img alt="Image" height="246" id="ch03fig01" src="../images/03fig01.jpg" width="919"/></div>
<p class="figcap"><em>Figure 3-1: A 2D visualization of random bits possibly containing patterns</em></p>
<p class="indent">In <a href="ch03.xhtml#ch03fig01">Figures 3-1a</a> and <a href="ch03.xhtml#ch03fig01">3-1d</a>, our brain will immediately detect patterns, which means the binary data repeats. These are clearly less random than the others. Looking closer, <a href="ch03.xhtml#ch03fig01">Figure 3-1</a>c exhibits a subtle pattern, while <a href="ch03.xhtml#ch03fig01">Figure 3-1</a>b doesn’t show any visually detectable relation between the depicted bits.</p>
<p class="indent">We could also state that the requirement of a <em>uniform distribution</em> for random bits demands that the probability of every symbol an RNG can generate has to be equal. <a href="ch03.xhtml#ch03fig02">Figure 3-2</a> shows the random bits resulting from four symbol distributions.</p>
<div class="image"><img alt="Image" height="247" id="ch03fig02" src="../images/03fig02.jpg" width="919"/></div>
<p class="figcap"><em>Figure 3-2: A 2D visualization of random bits possibly containing a bias</em></p>
<p class="indent">With the naked eye, we can see that <a href="ch03.xhtml#ch03fig02">Figures 3-2b</a> and <a href="ch03.xhtml#ch03fig02">3-2c</a> contain more white squares than black ones. Specifically, 70 percent of the area is white in <a href="ch03.xhtml#ch03fig02">Figure 3-2</a>b, and 80 percent is white in <a href="ch03.xhtml#ch03fig02">Figure 3-2</a>c. Distinguishing between <a href="ch03.xhtml#ch03fig02">Figures 3-2a</a> and <a href="ch03.xhtml#ch03fig02">3-2d</a> is more difficult, but looking at the numbers, the situation becomes clear. <a href="ch03.xhtml#ch03fig02">Figure 3-2</a>a has a black-white relation of 45 to 55, whereas <a href="ch03.xhtml#ch03fig02">Figure 3-2</a>d is perfectly 50-50.</p>
<h3 class="h3" id="ch00lev1_29"><strong>True Random Number Generators</strong></h3>
<p class="noindent">The main task of a <em>true random number generator (TRNG)</em>, sometimes also called a <em>nondeterministic random bit generator (NRBG)</em>, is no less than the extraction of “true” randomness. We can implement an <em>entropy source</em> as <span epub:type="pagebreak" id="page_54"/>described in NIST’s <em>Special Publication 800-90B</em> that (at microscopic scale) performs experiments and outputs their results as random bits to achieve true randomness. Metaphorically, imagine a nanoscale person tossing a coin regularly and controlling transistors according to the results of heads or tails.</p>
<p class="indent">Physical sources for entropy could be a photon transmission upon a semi-transparent mirror, the observation of a radioactive atomic disintegration process, or even a wall of lava lamps (<em><a href="https://blog.cloudflare.com/randomness-101-lavarand-in-production">https://blog.cloudflare.com/randomness-101-lavarand-in-production</a></em>). However, these ideas are all hard to implement in CMOS designs, which means chip manufacturers usually rely on physical effects related to thermal and electronic noise available in ICs.</p>
<h4 class="h4" id="ch00lev2_32"><strong><em>Ring Oscillators</em></strong></h4>
<p class="noindent">A common circuit to extract and accumulate such noise is a <em>ring oscillator (RO)</em>. It consists of an odd number of inverters that are connected in a ring-like structure. On power-up, the gates drive their outputs to the inverted level of their input signals. <a href="ch03.xhtml#ch03fig03">Figure 3-3</a> shows a three-inverter RO.</p>
<div class="image"><img alt="Image" height="118" id="ch03fig03" src="../images/03fig03.jpg" width="681"/></div>
<p class="figcap"><em>Figure 3-3: A basic RO circuit</em></p>
<p class="indent">Assuming the input of the leftmost inverter is <em>high</em>, its output will be <em>low</em>, the output of the second inverter will be <em>high</em>, and the last output signal <em>low</em> again. Feeding back the final output to the first input line results in a mismatch, which causes all inverters to change their outputs accordingly. As you probably noticed, this stable circuit will never settle but will oscillate at a certain frequency.</p>
<p class="indent">In a perfect world, the RO output signal would be absolutely deterministic, as would its oscillation frequency. However, in reality, the behavior depends on the physical characteristics of the implementation and the physical state it’s in. Both lead to <em>jitter</em> in the RO signal, which, in turn, causes the frequency to vary, sometimes a bit higher, sometimes a bit lower. In short, the signal and its frequency are subject to noise. Although we are still able to partly predict the RO’s behavior, some characteristics do originate from randomness. In many cases, this is the first step toward “true” randomness in microchips.</p>
<p class="indent">Since a single oscillator provides only “a little bit” of entropy, many oscillators usually are combined to create a TRNG. <a href="ch03.xhtml#ch03fig04">Figure 3-4</a> shows a simple way these oscillator signals could be sampled by flip-flops, be combined by an XOR operation, and then be sampled again to obtain a single random bit with high entropy.</p>
<div class="image"><span epub:type="pagebreak" id="page_55"/><img alt="Image" height="356" id="ch03fig04" src="../images/03fig04.jpg" width="795"/></div>
<p class="figcap"><em>Figure 3-4: A basic TRNG architecture using multiple ROs</em></p>
<p class="indent">However, in commercial devices, we can hardly characterize any of these internal design decisions and the actual entropy of these circuits. We have to trust the chip manufacturer. The previous paragraphs are just meant to give you an idea of where that “true” randomness might come from.</p>
<h4 class="h4" id="ch00lev2_33"><strong><em>The Health Status of Entropy Sources</em></strong></h4>
<p class="noindentb">The health status of the entropy source <em>should be available</em> to TRNG users because it’s necessary to inform the system in case of a nonfunctional entropy source. Otherwise, the device might rely on random numbers that are effectively all zeros. For high-quality TRNGs, therefore, at least three test procedures monitor the correct functionality of their entropy source:</p>
<p class="hanga"><strong>Startup test</strong>    Some entropy sources have to successfully run through an initialization phase in order to generate high-quality random bits. For example, for oscillator-based circuits, the intended oscillation must get going and not be stuck in a non-oscillating state. Therefore, TRNGs must implement a startup test that carefully monitors the startup phase of its entropy source and raises an error if it fails.</p>
<p class="hanga"><strong>Total failure test</strong>    Environmental influences, such as changes in temperature, supply voltage, or intentional attacks, can lead to the sudden loss of the correct functionality of an entropy source. The total failure test watches the entropy source’s output bits for such events and issues an alarm upon occurrence.</p>
<p class="hanga"><strong>Online test</strong>    While the two previous tests monitor entropy sources for a complete outage, the online test continuously observes the distribution of the generated random bits to identify drifts and biases. If they exceed a certain limit, this might also be a reason to notify an OS or an application.</p>
<p class="indentt">Although TRNGs are the only way to extract “true” randomness and are inevitable for secure devices, they also have disadvantages. They rely on physical processes that naturally depend on environmental circumstances <span epub:type="pagebreak" id="page_56"/>that can cause changes in behavior or even errors. Also, extracting and collecting raw entropy bits takes time and usually doesn’t fulfill high-performance demands. The next section introduces primitives that lack “true” randomness but perform much better.</p>
<h3 class="h3" id="ch00lev1_30"><strong>Pseudorandom Number Generators</strong></h3>
<p class="noindent"><em>Pseudorandom number generators (PRNGs)</em> are kind of the opposite of TRNGs and are also called <em>deterministic random bit generators (DRBGs)</em> because, in contrast to TRNGs, their behavior is completely deterministic and they don’t contain an entropy source. Both characteristics are advantages of PRNGs because they make them reliable and robust against environmental impacts, while at the same time allowing for high-speed implementations.</p>
<p class="indent">Key requirements for PRNG algorithms are <em>backtracking resistance</em> and <em>prediction resistance</em>. Both assume that an attacker got access to the current state (output) of a PRNG. The former requirement then demands that the adversary is unable to derive any previous state value for this information, while the latter requires that the attacker is unable to predict future output values of the PRNG algorithm. These claims might remind you that hash functions are one-way functions or that block cipher encryptions can’t be reversed without the corresponding key—and you’d be right. These algorithms are pretty suitable for the task at hand.</p>
<p class="indent">In <em>Special Publication 800-90A</em>, experts from NIST recommend three PRNG constructions. <em>Hash_DRBG</em> uses an approved hash function that’s meant for the desired security level to process initial and intermediate state data to derive pseudorandom output bits and obtain subsequent states. <em>HMAC_DRBG</em> and <em>CTR_DRBG</em> use keyed hash functions and block ciphers in Counter mode, respectively, where the corresponding keys are not fixed but updated regularly as part of the PRNG operations.</p>
<p class="indent">Maybe you’ve heard about linear feedback shift registers (LFSRs) and Mersenne Twister PRNGs and wonder why they aren’t recommended here although they are highly efficient. They do yield random <em>looking</em> sequences, but they’re not cryptographically secure because their architecture relies only on linear combinations, which can’t provide prediction resistance. To put it simply, any attacker who is able to observe a certain number of output values can derive future values.</p>
<div class="note">
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>
<p class="notep"><em>You might stumble across</em> Dual_EC_DRBG<em>, a PRNG that was originally meant to be cryptographically secure. However, it contains a potential backdoor that might have been inserted deliberately. Choose your cryptographic primitives carefully!</em></p>
</div>
<p class="indent">In addition to making a solid choice for a PRNG algorithm, <em>seeding</em> is one of the most important parts of PRNG usage. With seeding, a PRNG is initialized with data that has enough entropy to fulfill the desired security goal. For example, if a 128-bit security level is required, the PRNG has to <span epub:type="pagebreak" id="page_57"/>be seeded with a bit string that has at least 128 bits of entropy. Also, this information has to be treated as confidential and may never be revealed to an attacker.</p>
<p class="indent">Optionally, we can implement regular <em>reseeding</em>, which means that the entropy pool of a PRNG instance is updated with “fresh” entropy. Further, we can individualize PRNG initialization by adding a unique value such as a device serial number, a nonce, or a timestamp. However, be careful, as this additional data is always considered as <em>having no entropy at all</em>, because it can be publicly available without compromising security.</p>
<h3 class="h3" id="ch00lev1_31"><strong>Practical RNG Constructions and Usage</strong></h3>
<p class="noindent">After reading the preceding chapter, you might have already guessed that you can achieve the best RNG solution for secure devices by combining TRNGs and PRNGs. The former extracts entropy continuously (and slowly), which is used for seeding and subsequently reseeding a PRNG that reliably provides almost arbitrary amounts of random bits to OSs and applications.</p>
<p class="indent">If your device runs an OS, chances are the OS developers already took care of the hard parts. But even if so, architects and developers still need to keep the following topics in mind.</p>
<h4 class="h4" id="ch00lev2_34"><strong><em>RNG Selection</em></strong></h4>
<p class="noindent">Even if an OS provides a strong RNG, not all frameworks and programming languages use it by default. Usually, it must be selected explicitly or the corresponding API has to be used in your code. Otherwise, you rely on non-cryptographic PRNGs that may break device security.</p>
<h4 class="h4" id="ch00lev2_35"><strong><em>Error Handling</em></strong></h4>
<p class="noindent">As mentioned earlier, TRNGs can fail. In addition, OS-provided RNGs might return errors, so make sure to take these return values seriously and handle them accordingly. The last thing you want is a device that works with supposedly random data that actually contains nothing but zeros without anybody noticing.</p>
<h4 class="h4" id="ch00lev2_36"><strong><em>Boot-Time Entropy</em></strong></h4>
<p class="noindent">Some procedures take place during the boot process or immediately afterward, such as Secure Shell (SSH) key generation at the initial device startup. However, at boot time, a device might not have collected a lot of entropy yet, or maybe none at all. In turn, this might lead to identical or at least similar secret keys on several devices, which is absolutely not desirable. Keep in mind that critical key-generation processes need to wait until a defined amount of entropy is available.</p>
<h3 class="h3" id="ch00lev1_32"><span epub:type="pagebreak" id="page_58"/><strong>Case Study: Random Numbers from Hardware to Python</strong></h3>
<p class="noindent">In this case study, I analyze the hardware RNG features of an STM32MP157F device, explain how the Linux RNG works, and point out why you still have to be careful to use the correct RNG in Python.</p>
<h4 class="h4" id="ch00lev2_37"><strong><em>Hardware RNG and Entropy Source</em></strong></h4>
<p class="noindent">Looking at ST’s <em>Reference Manual RM0436</em> for STM32MP157F devices, a lot of information is available about the integrated RNG. At the beginning of the corresponding section, ST writes that the implemented RNG can be used as a basis for a NIST-compliant DRBG construction and that it was successfully tested with the AIS-32 test suite of the German Federal Office for Information Security (BSI).</p>
<div class="note">
<p class="notet"><strong><span class="notes">WARNING</span></strong></p>
<p class="notep"><em>Be careful, as the implemented RNG itself is not equal to a NIST DRBG. A later part of the reference manual states that an approved PRNG must be added on top of this TRNG if a NIST-compliant DRBG with a 128-bit security level is required.</em></p>
</div>
<p class="indent">Looking closer at the manual, you’ll read that the implemented TRNG uses two analog noise sources, and that each contains three free-running ROs that are XORed to mix their outputs. The XOR result is then sampled by a dedicated clock signal and postprocessed to remove a possible bias of the raw bits. Further, a conditioning stage “increases the entropy rate,” but that process isn’t described in more detail. The final output contains 128 bits of random data that’s provided to the 32-bit Advanced High-performance Bus (AHB) by a first-in, first-out (FIFO) buffer.</p>
<p class="indent">Regarding the continuous monitoring of the noise sources, ST has implemented a repetition count test. For example, an error is raised if a noise source outputs more than 64 bits with the same value or 32 repetitions of the same 2-bit pattern. A status register available over AHB shows the errors that occurred.</p>
<p class="indent">The good news at this point is that the selected microchip provides a hardware RNG. As usual, evaluating the quality of this module for users is difficult, but if we trust a manufacturer and its security competencies, this hardware RNG can be a valuable asset.</p>
<h4 class="h4" id="ch00lev2_38"><strong><em>Hardware RNG Integration in Linux</em></strong></h4>
<p class="noindent">In Linux, a hardware RNG can be integrated by the <span class="literal">hw_random</span> framework that consists of a hardware-specific driver and a generic kernel interface creating the corresponding <em>/dev/hwrng</em> device. If <span class="literal">CONFIG_HW_RANDOM</span> is enabled in the Linux kernel configuration and the vendor-provided driver works correctly, you can check the availability and selection of your hardware RNG, as shown for my STM32MP157F device in <a href="ch03.xhtml#ch03list01">Listing 3-1</a>.</p>
<pre class="pre"><span epub:type="pagebreak" id="page_59"/><span class="codestrong1"># cat /sys/class/misc/hw_random/rng_available</span>&#13;
optee-rng&#13;
<span class="codestrong1"># cat /sys/class/misc/hw_random/rng_current</span>&#13;
optee-rng</pre>
<p class="list-title" id="ch03list01"><em>Listing 3-1: Checking hardware RNG availability</em></p>
<p class="indent">Further, if <span class="literal">rng-tools</span> is installed on your Linux system, you can run statistical tests on the integrated hardware RNG as shown in <a href="ch03.xhtml#ch03list02">Listing 3-2</a>.</p>
<pre class="pre"># <span class="codestrong1">rngtest -c 1000 &lt; /dev/hwrng</span>&#13;
rngtest 6.15&#13;
...&#13;
rngtest: starting FIPS tests...&#13;
rngtest: bits received from input: 20000032&#13;
rngtest: FIPS 140-2 successes: 999&#13;
rngtest: FIPS 140-2 failures: 1&#13;
rngtest: FIPS 140-2(2001-10-10) Monobit: 0&#13;
rngtest: FIPS 140-2(2001-10-10) Poker: 0&#13;
rngtest: FIPS 140-2(2001-10-10) Runs: 0&#13;
rngtest: FIPS 140-2(2001-10-10) Long run: 1&#13;
rngtest: FIPS 140-2(2001-10-10) Continuous run: 0&#13;
rngtest: input channel speed: (min=117.995; avg=137.966; max=149.035)Kibits/s&#13;
rngtest: FIPS tests speed: (min=14.638; avg=28.942; max=29.434)Mibits/s&#13;
rngtest: Program run time: 142228806 microseconds</pre>
<p class="list-title" id="ch03list02"><em>Listing 3-2: Running statistical tests on data from an RNG hardware device</em></p>
<p class="indent">The tests originate from NIST’s <em>FIPS 140-2</em> cryptographic requirements document. The mathematical details aren’t relevant here, and a small number of failures are nothing to worry about. Notice that this hardware RNG source supplies random numbers at a rate of around 138Kb per second.</p>
<h4 class="h4" id="ch00lev2_39"><strong><em>Linux RNG Architecture</em></strong></h4>
<p class="noindent">Like any other major OS, Linux has its own RNG concept and PRNG implementation. It was first introduced in 1994 and, back then, its architecture was based on SHA-1 operations because strong encryption algorithms were part of US export restrictions.</p>
<p class="indent">However, since version 5.17 of the Linux kernel, SHA-1 was completely removed from the code. PRNG instances now rely on the ChaCha20 cipher, while the compression function of the <em>entropy pool</em> is implemented as the hash-update operation of <em>BLAKE2s</em>, a hash function also based on ChaCha. Version 5.18 introduced various additional improvements for the Linux RNG (for example, regarding boot-time entropy).</p>
<p class="indent"><span epub:type="pagebreak" id="page_60"/>The entropy pool is an internal 256-bit memory buffer that collects data from a set of noise sources and is used to feed the base instance of a ChaCha20 PRNG. If a hardware RNG is available on the given platform, as we’ve seen for the STM32MP157F device, its provided entropy can be integrated into the entropy pool by the <span class="literal">add_hwgenerator_randomness</span> interface. Its entropy content estimation depends on the entropy quality value provided in its driver code. For my device, that value is given as 900, which means that each RNG bit delivers an entropy of around 900/1,024 = 0.879 bits.</p>
<p class="indent">Further noise sources may contribute to entropy collection. If spinning hard disks or similar block devices are available in your system, <span class="literal">add_disk _randomness</span> might positively add to your entropy pool. However, since my STM32MP157F-DK2 board runs on a microSD card, this mechanism doesn’t contribute anything. Further, key presses and mouse movements can be used to extract a certain amount of noise and enhance the internal pool by <span class="literal">add_input_randomness</span>, but user interaction is usually rare in embedded system usage. Also, device drivers can provide random data possibly available during device initialization to <span class="literal">add_device_randomness</span> in order to integrate it into the entropy pool. However, it’s treated as having zero entropy by default.</p>
<p class="indent">The <span class="literal">proc</span> filesystem provides information about the instantiated entropy pool, like its size and current entropy estimation level in bits, as shown in <a href="ch03.xhtml#ch03list03">Listing 3-3</a>.</p>
<pre class="pre"># <span class="codestrong1">cat /proc/sys/kernel/random/poolsize</span>&#13;
256&#13;
# <span class="codestrong1">cat /proc/sys/kernel/random/entropy_avail</span>&#13;
256</pre>
<p class="list-title" id="ch03list03"><em>Listing 3-3: Printing entropy pool information</em></p>
<p class="indent">Keep in mind that older Linux systems are based on another RNG architecture that would show a pool size of 4,096 bits instead of 256 at this point.</p>
<p class="indent">In the same path, the file <em>bootid</em> provides a unique, random identification number for the current runtime, as demonstrated in <a href="ch03.xhtml#ch03list04">Listing 3-4</a>. It changes for the next boot.</p>
<pre class="pre"># <span class="codestrong1">cat /proc/sys/kernel/random/boot_id</span>&#13;
e67a7d3e-3825-4019-ad86-940a7c8748df</pre>
<p class="list-title" id="ch03list04"><em>Listing 3-4: Showing the boot identification number</em></p>
<p class="indent">In contrast, <a href="ch03.xhtml#ch03list05">Listing 3-5</a> shows that reading <em>uuid</em> yields a new <em>universally unique identifier (UUID)</em> for each access.</p>
<pre class="pre"># <span class="codestrong1">cat /proc/sys/kernel/random/uuid</span>&#13;
703a31fe-fd53-44d4-8a85-075416a107ea&#13;
# <span class="codestrong1">cat /proc/sys/kernel/random/uuid</span>&#13;
10f38bb8-66a8-4951-b9b4-db89db438ba8&#13;
# <span class="codestrong1">cat /proc/sys/kernel/random/uuid</span>&#13;
6abf0dd4-2d0b-421b-b04e-8f02f994149b</pre>
<p class="list-title" id="ch03list05"><em>Listing 3-5: Reading UUIDs from the Linux RNG</em></p>
<p class="indentb"><span epub:type="pagebreak" id="page_61"/>From user space, random numbers can be retrieved in multiple ways:</p>
<p class="hanga"><strong>Reading from</strong> <em><strong>/dev/random</strong></em>    The behavior of the device file <em>/dev/ random</em> is <em>blocking</em>. That means if the ChaCha20 PRNG didn’t receive 256 bits of entropy yet, it won’t return any data.</p>
<p class="hanga"><strong>Reading from</strong> <em><strong>/dev/urandom</strong></em>    The <em>nonblocking</em> nature of <em>/dev/urandom</em> allows random numbers to be read from this device no matter the status of the initial entropy collection, making it a popular choice for developers.</p>
<p class="hanga"><strong>Using the</strong> <span class="codestrong">getrandom</span> <strong>system call</strong>    This system call can be parameterized to define its behavior. With its flag set to zero, it behaves like <em>/dev/random</em>, but if the flag is set to <span class="literal">GRND_INSECURE</span>, it returns random numbers just as <em>/dev/urandom</em> does.</p>
<p class="indentt">In kernel space, the <span class="literal">get_random_bytes</span> function can be used to access a PRNG instance and get random numbers from it. This function doesn’t depend on the status of the ChaCha20 PRNG seeding and the entropy pool.</p>
<p class="indent">A simple one-liner to write 1MB of random data into a file is shown in <a href="ch03.xhtml#ch03list06">Listing 3-6</a>.</p>
<pre class="pre"># <span class="codestrong1">dd if=/dev/urandom of=rand_file.bin bs=1M count=1 iflag=fullblock</span>&#13;
1+0 records in&#13;
1+0 records out&#13;
1048576 bytes (1.0 MB, 1.0 MiB) copied, 0.0638873 s, 16.4 MB/s&#13;
# <span class="codestrong1">ls -l rand_file.bin</span>&#13;
-rw-r--r-- 1 root root 1048576 ... rand_file.bin</pre>
<p class="list-title" id="ch03list06"><em>Listing 3-6: Generating a file that contains 1,048,576 random bytes</em></p>
<p class="indent">Calling <span class="literal">rngtest</span> with <em>/dev/urandom</em> as shown in <a href="ch03.xhtml#ch03list07">Listing 3-7</a> practically demonstrates the advantage of combining a hardware random source with a reliable software PRNG.</p>
<pre class="pre"># <span class="codestrong1">rngtest -c 1000 &lt; /dev/urandom</span>&#13;
rngtest 6.15&#13;
...&#13;
rngtest: starting FIPS tests...&#13;
rngtest: bits received from input: 20000032&#13;
rngtest: FIPS 140-2 successes: 999&#13;
rngtest: FIPS 140-2 failures: 1&#13;
rngtest: FIPS 140-2(2001-10-10) Monobit: 0&#13;
rngtest: FIPS 140-2(2001-10-10) Poker: 0&#13;
rngtest: FIPS 140-2(2001-10-10) Runs: 0&#13;
rngtest: FIPS 140-2(2001-10-10) Long run: 1&#13;
rngtest: FIPS 140-2(2001-10-10) Continuous run: 0&#13;
rngtest: input channel speed: (min=85.917; avg=185.867; max=190.735)Mibits/s&#13;
rngtest: FIPS tests speed: (min=12.203; avg=28.918; max=29.756)Mibits/s&#13;
rngtest: Program run time: 763735 microseconds</pre>
<p class="list-title" id="ch03list07"><em>Listing 3-7: Running RNG tests on</em> /dev/urandom</p>
<p class="indent"><span epub:type="pagebreak" id="page_62"/>The statistics are still fine, but the speed is increased to around 186Mbps. That’s a factor of more than 1,000 compared to the raw hardware RNG.</p>
<h4 class="h4" id="ch00lev2_40"><strong><em>Cryptographically Secure Random Numbers in Python</em></strong></h4>
<p class="noindent">Even though we have a device that comes with a hardware RNG that was properly integrated into Linux, and the Linux RNG is behaving correctly, we still can fail at cryptographically secure random number generation on the application level. In this case study, we take a look at Python, but the same is true for many other programming languages and environments.</p>
<p class="indent">Python tutorials usually name the <span class="literal">random</span> module for random number generation. However, its documentation clearly points out that this is a PRNG based on the Mersenne Twister algorithm that’s meant, for example, for modeling and simulation purposes, but isn’t suitable for cryptographic usage.</p>
<p class="indent">To use the OS-provided RNG, the <span class="literal">os</span> module provides the <span class="literal">os.urandom()</span> function. However, the recommended way in Python 3.6 or newer is to use the <span class="literal">secrets</span> module that’s meant specifically for extracting cryptographically secure random numbers and that chooses the most secure randomness source on your system.</p>
<p class="indent"><a href="ch03.xhtml#ch03list08">Listing 3-8</a> shows a script that takes a number of bytes and a filename from the command line arguments, generates the respective number of random bytes by using the <span class="literal">token_bytes()</span> function of the <span class="literal">secrets</span> module, and writes them to the given output file.</p>
<pre class="pre">import sys&#13;
import secrets&#13;
&#13;
n_bytes = int(sys.argv[1])&#13;
output_file = sys.argv[2]&#13;
&#13;
print('Generating', str(n_bytes), 'random bytes ...')&#13;
random_bytes = secrets.token_bytes(n_bytes)&#13;
&#13;
print('Writing random bytes to', output_file, '...')&#13;
with open(output_file, "wb") as f:&#13;
  f.write(random_bytes)</pre>
<p class="list-title" id="ch03list08"><em>Listing 3-8: Using Python’s</em> <span class="codeitalic1">secrets</span> <em>module to create a file with random bytes</em></p>
<p class="indent">Finally, this case study demonstrated the variety of layers in hardware and software to consider when generating random numbers for cryptographic purposes.</p>
<h3 class="h3" id="ch00lev1_33"><span epub:type="pagebreak" id="page_63"/><strong>Case Study: Practical Tools for a Randomness Quick Check</strong></h3>
<p class="noindent">If you’re in charge of developing and testing a new RNG design, you’ll want to use a variety of statistical analysis algorithms as described in NIST’s <em>Special Publication 800-22</em> or provided by the Dieharder suite, but only very few people on this planet actually design new RNGs.</p>
<p class="indent">However, many people <em>use and process</em> random numbers, which can lead to practical implementation mistakes, especially on the application level. Some of these mistakes can be found by applying relatively simple tools. This case study explains two such approaches and demonstrates how to discover common problems with them.</p>
<h4 class="h4" id="ch00lev2_41"><strong><em>Simple Tools for Distribution Analysis and Pattern Recognition</em></strong></h4>
<p class="noindent">At the beginning of this chapter, we saw that bias (or a nonuniform distribution of any kind) and recurring patterns are two indicators of low-quality random numbers. This section describes a simple means to analyze basic data features, but they are far from professional statistical analysis. They serve a sole purpose: getting hints that something is wrong in the random number generation process, most probably in the last stage (namely, in an application).</p>
<p class="indent"><a href="ch03.xhtml#ch03list09">Listing 3-9</a> shows a short script that takes a file as a command line argument, reads it, and plots a histogram showing the frequency of occurrence for all possible byte values. In the perfect case, the histogram should show a flat line, which means that all bytes are equally likely to occur within the file.</p>
<pre class="pre">import sys&#13;
import matplotlib.pyplot as plt&#13;
&#13;
file_to_analyze = sys.argv[1]&#13;
&#13;
print('Reading', file_to_analyze, '...')&#13;
with open(file_to_analyze, "rb") as f:&#13;
  data = f.read()&#13;
&#13;
hist_data = bytearray(data)&#13;
&#13;
print('Plotting distribution of bytes ...')&#13;
fig1, ax1 = plt.subplots(figsize=(15, 5))&#13;
ax1.hist(hist_data, bins=range(256+1), align='left', color = "gray")&#13;
ax1.set_title('Distribution of Bytes')&#13;
ax1.set_xlabel('byte value')&#13;
ax1.set_xticks([0, 32, 64, 96, 128, 160, 192, 224, 256])&#13;
ax1.set_ylabel('frequency of occurrence')&#13;
plt.show()</pre>
<p class="list-title" id="ch03list09"><em>Listing 3-9: A Python script to plot the distribution of bytes for a given file</em></p>
<p class="indent"><span epub:type="pagebreak" id="page_64"/>For illustration, I generated a file with 1MB of random data by using the Linux RNG and ran the script on it. <a href="ch03.xhtml#ch03fig05">Figure 3-5</a> shows the corresponding distribution. It’s not a flat line, but the frequencies are pretty close to one another.</p>
<div class="image"><img alt="Image" height="433" id="ch03fig05" src="../images/03fig05.jpg" width="832"/></div>
<p class="figcap"><em>Figure 3-5: The distribution of byte values from the Linux RNG</em></p>
<p class="indent">Pattern detection is a bit more complicated than bias analysis because patterns can be of various types. However, some applications are optimized for exactly that task: compression tools. These algorithms run through data and try to find repeating sequences, build up dictionaries, and remove redundancy. Applied to random data, every success in compression means that the dataset has entropy deficiencies. Although compression tools don’t tell us what the problem is, they can clearly state that the information content of a file is less than expected from random data.</p>
<p class="indent"><a href="ch03.xhtml#ch03list010">Listing 3-10</a> shows a simple script to invoke the common Linux compression tools <span class="literal">bzip2</span>, <span class="literal">gzip</span>, and <span class="literal">xz</span> on a file presumably containing random data.</p>
<pre class="pre">import sys&#13;
import subprocess&#13;
import os&#13;
&#13;
file_to_analyze = sys.argv[1]&#13;
&#13;
print('Compressing', file_to_analyze, '...')&#13;
run = subprocess.run('bzip2 -k ' + file_to_analyze, shell=True)&#13;
run = subprocess.run('gzip -k ' + file_to_analyze, shell=True)&#13;
run = subprocess.run('xz -k ' + file_to_analyze, shell=True)&#13;
&#13;
print('Compression test results:')&#13;
print('{:&lt;28}'.format(file_to_analyze),          '--&gt;',&#13;
      '{:&gt;9}'.format(os.path.getsize(file_to_analyze)), 'bytes')&#13;
print('{:&lt;28}'.format(file_to_analyze + '.bz2'), '--&gt;',&#13;
      '{:&gt;9}'.format(os.path.getsize(file_to_analyze + '.bz2')), 'bytes')&#13;
<span epub:type="pagebreak" id="page_65"/>&#13;
print('{:&lt;28}'.format(file_to_analyze + '.gz'),  '--&gt;',&#13;
      '{:&gt;9}'.format(os.path.getsize(file_to_analyze + '.gz')), 'bytes')&#13;
print('{:&lt;28}'.format(file_to_analyze + '.xz'),  '--&gt;',&#13;
      '{:&gt;9}'.format(os.path.getsize(file_to_analyze + '.xz')), 'bytes')&#13;
print('')</pre>
<p class="list-title" id="ch03list010"><em>Listing 3-10: A Python script to test random data with typical compression tools</em></p>
<p class="indent">Again, 1MB of data from the Linux RNG serves as a positive example here. As shown in <a href="ch03.xhtml#ch03list011">Listing 3-11</a>, all the compression tools yield larger files than the original one. This is expected because the content can’t be compressed and, at the same time, header information for the used compression format is added to the files.</p>
<pre class="pre">data_urandom.rnd             --&gt;   1048576 bytes&#13;
data_urandom.rnd.bz2         --&gt;   1053538 bytes&#13;
data_urandom.rnd.gz          --&gt;   1048771 bytes&#13;
data_urandom.rnd.xz          --&gt;   1048688 bytes</pre>
<p class="list-title" id="ch03list011"><em>Listing 3-11: The results of a compression test on the Linux RNG</em></p>
<h4 class="h4" id="ch00lev2_42"><strong><em>Problem 1: Output Space Restriction by Modulo</em></strong></h4>
<p class="noindent">In some cases, restricting the output space of a random variable is needed—for example, to the range of 0 to 99—because that range is required for a given application. A trivial approach to limit the results of an integer operation is to use the modulo operator. To obtain an integer from 0 to 99, we could just compute all random numbers modulo 100.</p>
<p class="indent">To test that case, I added that operation to the Python example from <a href="ch03.xhtml#ch03list08">Listing 3-8</a>. <a href="ch03.xhtml#ch03fig06">Figure 3-6</a> shows the resulting distribution of bytes.</p>
<div class="image"><img alt="Image" height="433" id="ch03fig06" src="../images/03fig06.jpg" width="850"/></div>
<p class="figcap"><em>Figure 3-6: The distribution of bytes when restricting with a modulo operation</em></p>
<p class="indent"><span epub:type="pagebreak" id="page_66"/>While we would expect a drop to 0 at byte values 100 or higher, a strange drop in probability occurs at value 56. However, that means the given application would generate values from 0 to 55 with <em>significantly higher probability</em>. This is unacceptable from a security point of view.</p>
<p class="indent">For Python, a robust solution would be to use the <span class="literal">randbelow()</span> function from the <span class="literal">secrets</span> module to obtain uniformly distributed and cryptographically secure random numbers within a certain integer range.</p>
<h4 class="h4" id="ch00lev2_43"><strong><em>Problem 2: Custom PRNG Designs</em></strong></h4>
<p class="noindent">Sometimes we have to rely on applications that are black boxes. We can’t assess the internals of the software, let alone the quality of random number handling. However, it might well be the case that an application instantiates its own PRNG, probably for performance reasons or for ease of use. Maybe it’s even seeded by a strong OS-provided RNG. However, if the custom PRNG exhibits a weak design, security problems might result.</p>
<p class="indent">For this test case, I implemented a weak PRNG on purpose. It’s more or less a modified 16-bit counter, seeded by the Linux RNG. It’s not very reasonable but also not completely unrealistic; developers can be creative. As in the first case, I extracted 1MB of test data from this PRNG instance and plotted its distribution of bytes as shown in <a href="ch03.xhtml#ch03fig07">Figure 3-7</a>. It shows a perfect distribution. Although that could already be suspicious, it doesn’t directly indicate a weakness.</p>
<div class="image"><img alt="Image" height="432" id="ch03fig07" src="../images/03fig07.jpg" width="832"/></div>
<p class="figcap"><em>Figure 3-7: The distribution of bytes from a custom PRNG</em></p>
<p class="indent"><span epub:type="pagebreak" id="page_67"/>However, after applying the compression tests explained previously, it becomes clear that something must be wrong. <a href="ch03.xhtml#ch03list012">Listing 3-12</a> shows the output.</p>
<pre class="pre">data_custom_prng.rnd         --&gt;   1048576 bytes&#13;
data_custom_prng.rnd.bz2     --&gt;     86756 bytes&#13;
data_custom_prng.rnd.gz      --&gt;    997143 bytes&#13;
data_custom_prng.rnd.xz      --&gt;     84648 bytes</pre>
<p class="list-title" id="ch03list012"><em>Listing 3-12: The results of a compression test on data from a custom PRNG</em></p>
<p class="indent">Two of three compression tools reduced the file size by a factor of more than 12. This change is significant. It still doesn’t tell us what exactly is wrong with the application at hand, but it calls for a discussion with its developers.</p>
<h3 class="h3" id="ch00lev1_34"><strong>Summary</strong></h3>
<p class="noindent">Randomness is a tricky beast. However, after reading this chapter, it should be clear that randomness is absolutely necessary for security and that it deserves careful consideration regarding the involved hardware and software components.</p>
<p class="indent">I explained some of the basics of entropy sources in CMOS microchips and how they create “true” randomness from noise—for example, the noise present in oscillation circuits. Further, I discussed the need for PRNGs and their beneficial properties like reliable behavior and high-speed data delivery. Both TRNGs and PRNGs are relevant and should be implemented in combination to build a secure and reliable RNG for embedded systems.</p>
<p class="indent">In the first case study, I walked through the layers of randomness in a real-world system—starting from the integrated physical noise sources in STM32MP157F devices to their integration in the Linux kernel to the complex architecture of the Linux RNG itself. Finally, I added that even on the application level, incorrect handling of RNGs and their data can lead to weaknesses. If you are interested in the details of Linux RNGs and their evolution over time, refer to the regular Linux RNG analysis documents from the German BSI.</p>
<p class="indent">Simple and pragmatic tools for identifying some problems with RNGs and their output data, especially in third-party software, concluded this chapter in a second case study.<span epub:type="pagebreak" id="page_68"/></p>
</div></body></html>