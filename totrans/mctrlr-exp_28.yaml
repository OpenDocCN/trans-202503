- en: '**C  More Privilege Escalation**'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**C.1 Game Boy Advance BIOS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Like its predecessor, Nintendo’s Game Boy Advance contains a mask ROM that executes
    at reset to boot a game cartridge after verifying that it contains a valid Nintendo
    logo for trademark protection. In the Game Boy, the ROM would unmap itself just
    before jumping into the game cartridge, but the Game Boy Advance keeps the ROM
    mapped into memory. We call this a *BIOS* because, like the BIOS ROM in an IBM
    PC, this ROM contains convenience functions that are called as interrupts.
  prefs: []
  type: TYPE_NORMAL
- en: Unlike many targets in this book, the attacker has the privilege of running
    arbitrary machine code on the device. This is possible with a simple EEPROM chip
    wired to the right pins of a game catridge, and it was very quickly available
    to hobbyists after Nintendo released the GBA.
  prefs: []
  type: TYPE_NORMAL
- en: A dump of the BIOS ROM is useful for emulating the platform, so access restrictions
    are in place. The ROM is disabled whenever an address outside of its range is
    fetched as code, then enabled when an address within its range is fetched as code.
    This happens in hardware at the instant of the access.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we’ll see three methods of tricking the Game Boy Advance into
    allowing a read of the BIOS ROM. One abuses a BIOS call that has no source address
    restrictions, one preemptively interrupts a BIOS call to change the source address
    after validation, and the third executes instructions from unmapped memory so
    that the pipeline will unlock ROM for a fetch.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/f0292-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure C.1: Nintendo GBA CPU'
  prefs: []
  type: TYPE_NORMAL
- en: '**MidiKey2Freq Method**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Fader (2001) is the classic exploit for dumping the BIOS ROM, recreated in [Figure
    C.3](app03.xhtml#chCfig3). It’s a variant on a classic technique of kernel memory
    exposure in Unix, where a system call fails to validate the source address so
    the caller can peek at memory with the kernel’s privileges.
  prefs: []
  type: TYPE_NORMAL
- en: '`MidiKey2Freq` is implemented as ROM interrupt `0x1f`. It takes a pointer to
    a MIDI sample, reads four bytes at that address, and performs an audio processing
    function on those four bytes. However this audio function has neither range nor
    alignment restrictions, and it leaves the top byte unchanged. Fader’s exploit
    loops through the ROM address space, grabbing the most significant byte in the
    return value each time.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Endrift Method**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: For a while it was thought that the `MidiKey2Freq` method was the only way to
    dump the BIOS ROM, but that didn’t seem right to Vicki Pfau. In Pfau (2017), she
    presents two different black-box techniques for dumping the BIOS ROM. Both of
    her techniques rely upon the ARM7’s interrupt priorities, triggering a hardware
    interrupt while the software interrupt of the BIOS call is in progress.
  prefs: []
  type: TYPE_NORMAL
- en: The nested interrupt can’t directly read the BIOS, but it does have full privileges
    to read and write the call stack of the software interrupt in the BIOS call.
  prefs: []
  type: TYPE_NORMAL
- en: Vicki’s black-box example registers a timer interrupt to overlap with a software
    interrupt call to `CPUFastSet`. The `CPUFastSet` handler performs fast copies
    within the BIOS address space, but it validates the source address so the caller
    cannot simply export the BIOS with it. While the BIOS software interrupt is running,
    it is itself interrupted by her `bbTest` handler, which then scans the software
    interrupt call stack for the source pointer in the `CPUFastSet` stack frame. Overwriting
    the source pointer with a ROM address before returning then causes the BIOS to
    proceed with an illegal copy, as the source address is only validated at the start
    of the interrupt handler and not repeated for each word.
  prefs: []
  type: TYPE_NORMAL
- en: '|  `0x00`  | SoftReset |'
  prefs: []
  type: TYPE_TB
- en: '| `0x01` | RegisterRamReset |'
  prefs: []
  type: TYPE_TB
- en: '| `0x02` | Halt |'
  prefs: []
  type: TYPE_TB
- en: '| `0x03` | Stop |'
  prefs: []
  type: TYPE_TB
- en: '| `0x04` | IntrWait |'
  prefs: []
  type: TYPE_TB
- en: '| `0x05` | VBlankIntrWait |'
  prefs: []
  type: TYPE_TB
- en: '| `0x06` | Div |'
  prefs: []
  type: TYPE_TB
- en: '| `0x07` | DivArm |'
  prefs: []
  type: TYPE_TB
- en: '| `0x08` | Sqrt |'
  prefs: []
  type: TYPE_TB
- en: '| `0x09` | ArcTan |'
  prefs: []
  type: TYPE_TB
- en: '| `0x0A` | ArcTan2 |'
  prefs: []
  type: TYPE_TB
- en: '| `0x0B` | CPUSet |'
  prefs: []
  type: TYPE_TB
- en: '| `0x0C` | **CPUFastSet** |'
  prefs: []
  type: TYPE_TB
- en: '| `0x0D` | BiosChecksum |'
  prefs: []
  type: TYPE_TB
- en: '| `0x0E` | BgAffineSet |'
  prefs: []
  type: TYPE_TB
- en: '| `0x0F` | ObjAffineSet |'
  prefs: []
  type: TYPE_TB
- en: '| `0x10` | BitUnpack |'
  prefs: []
  type: TYPE_TB
- en: '| `0x11` | LZ77UnCompWRAM |'
  prefs: []
  type: TYPE_TB
- en: '| `0x12` | LZ77UnCompVRAM |'
  prefs: []
  type: TYPE_TB
- en: '| `0x13` | HuffUnComp |'
  prefs: []
  type: TYPE_TB
- en: '| `0x14` | RLUnCompWRAM |'
  prefs: []
  type: TYPE_TB
- en: '| `0x15` | RLUnCompVRAM |'
  prefs: []
  type: TYPE_TB
- en: '| `0x16` | Diff8bitUnFilterWRAM |'
  prefs: []
  type: TYPE_TB
- en: '| `0x17` | Diff8bitUnFilterVRAM |'
  prefs: []
  type: TYPE_TB
- en: '| `0x18` | Diff16bitUnFilter |'
  prefs: []
  type: TYPE_TB
- en: '| `0x19` | SoundBiasChange |'
  prefs: []
  type: TYPE_TB
- en: '| `0x1A` | SoundDriverInit |'
  prefs: []
  type: TYPE_TB
- en: '| `0x1B` | SoundDriverMode |'
  prefs: []
  type: TYPE_TB
- en: '| `0x1C` | SoundDriverMain |'
  prefs: []
  type: TYPE_TB
- en: '| `0x1D` | SoundDriverVSync |'
  prefs: []
  type: TYPE_TB
- en: '| `0x1E` | SoundChannelClear |'
  prefs: []
  type: TYPE_TB
- en: '| `0x1F` | **MIDIKey2Freq** |'
  prefs: []
  type: TYPE_TB
- en: '| `0x20` | MusicPlayerOpen |'
  prefs: []
  type: TYPE_TB
- en: '| `0x21` | MusicPlayerStart |'
  prefs: []
  type: TYPE_TB
- en: '| `0x22` | MusicPlayerStop |'
  prefs: []
  type: TYPE_TB
- en: '| `0x23` | MusicPlayerContinue |'
  prefs: []
  type: TYPE_TB
- en: '| `0x24` | MusicPlayerFadeOut |'
  prefs: []
  type: TYPE_TB
- en: '| `0x25` | MultiBoot |'
  prefs: []
  type: TYPE_TB
- en: '| `0x26` | HardReset |'
  prefs: []
  type: TYPE_TB
- en: '| `0x27` | CustomHalt |'
  prefs: []
  type: TYPE_TB
- en: '| `0x28` | SoundDriverVSyncOff |'
  prefs: []
  type: TYPE_TB
- en: '| `0x29` | SoundDriverVSyncOn |'
  prefs: []
  type: TYPE_TB
- en: '| `0x2A` | SoundGetJumpList |'
  prefs: []
  type: TYPE_TB
- en: 'Table C.1: Game Boy Advance BIOS Interrupts'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/f0295-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure C.2: Game Boy Advance Memory Map'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/f0295-02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure C.3: MidiKey2Freq ROM Dumper from Fader (2001)'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/f0296-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure C.4: Optimized GBA BIOS Dumper from Pfau (2017)'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/f0296-02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure C.5: BIOS Peek Function from Hearn (2017)'
  prefs: []
  type: TYPE_NORMAL
- en: The black box method is particularly nice because it doesn’t require the author
    to already have a copy of the BIOS and the timing calibration does not need to
    be particularly accurate. Vicki also presents an optimized implementation that
    simply makes a `bx` call directly into the middle of the `CPUFastSet`, as BIOS
    entry points are unenforced and that code may always read from the BIOS. See [Figure
    C.4](app03.xhtml#chCfig4).
  prefs: []
  type: TYPE_NORMAL
- en: '**Executing Missing Memory**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: While Fader rather directly uses a BIOS call to leak memory and Pfau reuses
    pieces of BIOS code by either faking a stack or modifying the real one in a nested
    interrupt, Hearn (2017) goes to the absolute extreme of sophistication. She manages
    to execute code from unmapped memory at the far end of the address space, so a
    prefetched instruction from the beginning of memory unlocks the BIOS before being
    flushed out of the pipeline. I shit you not!
  prefs: []
  type: TYPE_NORMAL
- en: 'Thinking back to your undergrad computer science days, a Nineties RISC chip
    like the ARM7TDMI uses a pipelined architecture. This particular example has three
    pipeline stages: fetch, decode, and execute. At the same time that the CPU is
    executing an instruction, it is decoding the next instruction and fetching the
    instruction after that. When the fetched and decoded instructions aren’t worthwhile,
    they are simply flushed away.'
  prefs: []
  type: TYPE_NORMAL
- en: The CPU communicates with its peripherals, such as memories and I/O, over a
    bus. On ARM7TDMI, there is a curious effect that the data lines of this bus hold
    their last value, returning it whenever an unmapped address is fetched.^([1](footnotes.xhtml#app3fn1))
    If you read `0xdead-beef` from anywhere, or if you write it anywhere, and then
    read from an unused address like `0x10000000` or `0x4bidb10c` without any other
    bus access in between, you will read back `0xdeadbeef`. This is a quirk of the
    architecture, and many others will trigger a fault or return a different value.^([2](footnotes.xhtml#app3fn2))
  prefs: []
  type: TYPE_NORMAL
- en: Combining these observations, Hearn realized that if she could write two Thumb
    instructions as single 32-bit word to anywhere, then jump to them at `0xfffffffd`,
    the first instruction might execute just after the BIOS ROM’s first instruction
    at `0x0000-0000` is fetched, unlocking the ROM. The few lines of Thumb assembly
    in [Figure C.5](app03.xhtml#chCfig5) accomplish this, and they are an absolute
    work of art.
  prefs: []
  type: TYPE_NORMAL
- en: In reading the code, don’t forget how Thumb addressing works. `0xfffffffd` is
    odd to imply Thumb mode, but the 16-bit instruction is fetched from `0xfffffffc`.
    32 bits are fetched at a time, and there will be no separate fetch for the second
    instruction.
  prefs: []
  type: TYPE_NORMAL
- en: Line 7 writes her instruction pair to the end of memory and Line 8 jumps to
    execute it at the end of memory. The `ldr` instruction reads whatever BIOS address
    is given as a parameter right back into the return value, and the `bx lr` instruction
    returns back to the caller. “But wait,” you might ask, “how is the first instruction
    able to read from the BIOS ROM if we haven’t yet executed anything from the ROM?”
  prefs: []
  type: TYPE_NORMAL
- en: The CPU pipeline is the answer. Before the `ldr` instruction loads a word from
    the ROM, the pipeline will have already fetched a 32-bit word from `0x00000000`
    for decoding and eventually execution. This unlocks the ROM for a data fetch,
    and it doesn’t matter that these pipelined instructions will be flushed away with
    the `bx` instruction that comes next.
  prefs: []
  type: TYPE_NORMAL
- en: '**C.2 MSP432 IP Encapsulation**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: IP Encapsulation (IPE) is a feature of some MSP430 and MSP432 devices from Texas
    Instruments that serves roughly the same purpose as TrustZone-M or other trusted
    execution environments (TEE). The idea is that you might purchase a microcontroller
    with a radio library, and you would be able to *use* the library but not *read*
    the library for reverse engineering or cloning.
  prefs: []
  type: TYPE_NORMAL
- en: Like other privilege escalation exploits in this chapter, the defender is at
    a distinct disadvantage. The attacker is able to run native code, to attach a
    debugger, and to apply fault injection. The defender merely hopes that TI’s restrictions
    are sufficient to prevent extraction of protected libraries.
  prefs: []
  type: TYPE_NORMAL
- en: 'Sah and Hicks (2023) describe this feature in depth, along with some design
    mistakes that expose the encapsulated firmware. Two facts in particular are important
    for exploitation: first, the IPE feature does nothing to enforce specific entry
    points into the protected code, allowing gadgets to be reused when called from
    user program memory. Second, the IPE feature does nothing to disable the majority
    of interrupt sources, and timer interrupts are particularly useful for getting
    execution in the middle of the encapsulation library so that the attacker code
    can learn things about the library.'
  prefs: []
  type: TYPE_NORMAL
- en: Exploitation details vary between the 16-bit MSP430 architecture and the 32-bit
    ARM architecture used by the MSP432\. In either case, a timer with a very small
    count is used to trigger an exception inside the protected library, then the exception
    handler in the unprotected application observes the register states to make informed
    guesses about the state of the code.
  prefs: []
  type: TYPE_NORMAL
- en: For example, if the handler observes that some extra return pointers have been
    pushed to the stack, those pointers will reveal the locations of `call` instructions
    on MSP430 or `bl`/`blx` instructions on MSP432\. Similarly, the attacker can locate
    `ret` instructions by calling them after setting the link register on ARM or loading
    a return pointer to the stack in MSP430.
  prefs: []
  type: TYPE_NORMAL
- en: Eventually, the attacker will discover a gadget that will read an arbitrary
    address into a register. Maybe the gadget returns afterward, in which case no
    timer is necessary. Maybe it does not return, in which case the timer’s countdown
    can be used to repeatedly call into this gadget and then bounce out again. Either
    way, repeated usage of the gadget can extract all protected memory.
  prefs: []
  type: TYPE_NORMAL
- en: '**C.3 BCM11123 U-Boot and TrustZone**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Cisco’s model 8861 IP Phone uses a Broadcom BCM11123 CPU with TrustZone. A TrustZone
    chip has two modes, with *secure* code having privileges that the *non-secure*
    code lacks. It’s not that the non-secure code is exploitable, so much as that
    it is not trusted. Communication between the two modes takes the form of interrupt
    handlers, much like system calls from userland to a kernel.
  prefs: []
  type: TYPE_NORMAL
- en: In the case of this phone, U-Boot runs in non-secure memory, making API calls
    to a TrustZone monitor in order to validate and launch a Linux kernel. Cui and
    Housley (2017) is largely about EMFI attacks, but that paper’s appendix describes
    a nifty attack against this arrangement.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/f0301-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure C.6: Cui and Housely’s Exploit for the BCM11123'
  prefs: []
  type: TYPE_NORMAL
- en: The authors began by faulting the phone’s NAND flash during boot, in order to
    drop into U-Boot’s command line, much like the ROM bootloader of the Freescale
    MC13224 in [Chapter 14](ch14.xhtml#ch14). This bootloader has handy commands for
    reading, writing, and executing memory, but because it’s in the non-secure world,
    that’s not enough to dump or control the secure side of the chip in Trust-Zone.
    The game is then to find a vulnerability in the TrustZone monitor and to exploit
    it from U-Boot.
  prefs: []
  type: TYPE_NORMAL
- en: The bug in question is in the `_ssapi_public_decrypt` function, which lacks
    a necessary length check and fails to ensure that the source and destination addresses
    are on the appropriate sides of the TrustZone barrier. By carefully choosing the
    right parameters, Cui and Housley were able to copy small chunks out of the secure
    world into non-secured memory accessible by U-Boot, for reverse engineering and
    dumping.
  prefs: []
  type: TYPE_NORMAL
- en: They then used the same bug in the opposite direction, clobbering a return pointer
    in the secure world and promote U-Boot itself to run within the TrustZone.
  prefs: []
  type: TYPE_NORMAL
- en: '**C.4 LPC55S69 Hardware and Software**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The LPC55 series of microcontrollers use the ARM Cortex-M architecture, with
    TrustZone-M as a means to protect key material such as a secret key unique to
    each device from the user programmed application. Ideally, this would let a board
    designer install software on the chip that uses this key material, but even a
    serious bug in that application software would not allow an attacker to control
    the trusted zone, its software, or its keys.
  prefs: []
  type: TYPE_NORMAL
- en: Some Cortex-M devices include a Flash Patch and Breakpoint (FPB) unit, which
    allows a few words of memory to be patched, overriding their real value with a
    chosen one. In devices like the LPC55 that support TrustZone-M, that IP block
    is explicitly prohibited by ARM for fear that in remapping the address space,
    the TrustZone-M protections might be invalidated.
  prefs: []
  type: TYPE_NORMAL
- en: While reverse engineering an application for the LPC55S69, Laura Abbott discovered
    that there is a custom module much like the forbidden FPB unit, allowing for small
    patches to a few 32-bit words at any address in memory, including words of the
    ROM. She documents that module in Abbott (2021), along with a way to use it to
    fake the signature verification of ROM patches, allowing malicious ones to be
    installed that will persist to the next boot.
  prefs: []
  type: TYPE_NORMAL
- en: The module exists as an APB peripheral at `0x4003e000` in non-secure memory
    and `0x5003e000` in secure memory, a region missing from the memory map in the
    LPC55S6x user manual. Because it exists in both privileged and unprivileged modes,
    unprivileged code can use it to patch the privileged ROM code’s behavior as a
    form of privilege escalation!
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/f0303-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure C.7: LPC55S69'
  prefs: []
  type: TYPE_NORMAL
- en: This patch module’s configuration is wiped at reset, but what if an attacker
    wanted a patch to be persistent, such as to disable secure boot authentication?
    Abbot describes a table of patch entries in a protected flash memory region with
    the following structure. The three supported commands include single-word changes,
    an `svc` entry point change, and a patch to SRAM.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/f0304-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In addition to the undocumented patching module, there is a second software
    vulnerability for escalation into the secure world. A software vulnerability in
    the parsing of firmware update headers, described in Abbott (2022), allows for
    privilege escalation from the non-secure world and persistent control past the
    next reset.
  prefs: []
  type: TYPE_NORMAL
- en: The bug is in the header structure, shown in [Figure C.8](app03.xhtml#chCfig8).
    By design, `m_keyBlobBlock` ought to be the block number that is just after the
    header. Each block is 16 bytes, so block 8 would be just after the 128-byte header.
  prefs: []
  type: TYPE_NORMAL
- en: Instead of the secure boot parser copying just the header, it continues copying
    blocks until it counts up to `m_keyBlobBlock`. When the number is larger than
    8, this copying becomes a classic buffer overflow.
  prefs: []
  type: TYPE_NORMAL
- en: See also [Chapter A.3](app01.xhtml#app01_3) for a buffer over-read in the bootloader’s
    USB stack and [Chapter E.2](app05.xhtml#app05_2) for a set of glitching attacks
    against the chip.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/f0305-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure C.8: LPC55 SB2 Update Header'
  prefs: []
  type: TYPE_NORMAL
- en: '**C.5 FM3 Flash Patching**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Infineon’s FM3 series of Cortex M3 microcontrollers is used in at least some
    models of Sony’s Dualshock4 controller for the Playstation 4\. Enthusiast (2018)
    describes a flash patch and breakpoint (FPB) trick, somewhat similar to those
    in [Chapters 17](ch17.xhtml#ch17) and [C.4](app03.xhtml#app03_4), that allows
    flash memory to be extracted by persisting patches across a reset.
  prefs: []
  type: TYPE_NORMAL
- en: The chip has boot mode pins, labeled as `MD`, that are sensed at reset to execute
    either an application from flash memory or a serial bootloader from ROM. USBDirect
    is the manufacturer’s programming tool, and it operates by loading a blob of native
    code into SRAM. An open source replacement for this blob is available, and by
    patching it, you can freely play around with the programming environment.
  prefs: []
  type: TYPE_NORMAL
- en: That’s a nice and easy start, but the code runs in a restricted environment
    with access to flash memory disabled until a mass erase is performed. Any attempt
    to read from flash memory simply returns garbage data, and this also applies to
    tricky read methods like a DMA transfer.
  prefs: []
  type: TYPE_NORMAL
- en: With more experimentation, the author found that SRAM persists across resets.
    As we saw in [Chapter 2](ch02.xhtml#ch02), this is a great way to leave shellcode
    around for a subsequent attack.
  prefs: []
  type: TYPE_NORMAL
- en: Knowing that SRAM was not reset, the author looked into other peripheral devices,
    eventually finding the FPB unit. The FPB holds six pairs of addresses, remapping
    a code fetch from the first address into a fetch for the second address. This
    module’s configuration is also not cleared at reset!
  prefs: []
  type: TYPE_NORMAL
- en: The final exploit consists of an SRAM blob for the serial boot-loader that enables
    the FPB, using it to patch the user application in flash memory to re-enter the
    serial bootloader. At that point, the normal SRAM blob can be presented. Because
    the device booted from flash memory, read restrictions are not enabled and this
    blob can dump all flash memory. Mass erasing and rewriting that firmware then
    unlocks the target, much as we saw in [Chapter 17](ch17.xhtml#ch17) except with
    no requirement for a voltage glitch at reset.
  prefs: []
  type: TYPE_NORMAL
