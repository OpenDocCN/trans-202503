<html><head></head><body>
<div id="sbo-rt-content"><section>&#13;
<header>&#13;
<h1 class="chapter">&#13;
<span class="ChapterNumber"><span epub:type="pagebreak" id="Page_81" title="81"/>5</span><br/>&#13;
<span class="ChapterTitle">I<sup>2</sup>C Variants</span></h1>&#13;
</header>&#13;
<figure class="opener">&#13;
<img alt="" height="203" src="image_fi/book_art/chapterart.png" width="203"/>&#13;
</figure>&#13;
<p class="ChapterIntro">This chapter briefly describes several variants of the I<sup>2</sup>C bus, including the System Management Bus (SMBus), VESA DDC and E-DDC, ACCESS.bus, and two-wire interface. For the most part, these variants apply a protocol on top of the physical two-wire interface of the I<sup>2</sup>C bus, defining messages and other data flowing across the bus. </p>&#13;
<p>Going into detail on such protocol extensions is generally beyond the scope of this book. Nevertheless, this chapter gives an overview of those protocols (and information for other specific bus variants) and explains where you can find more information about these variants. We begin with the SMBus protocol, which deserves the most in-depth discussion, since it is widely used in computer systems.</p>&#13;
<h2 id="h1-502468c05-0001"><span epub:type="pagebreak" id="Page_82" title="82"/>	5.1	SMBus</h2>&#13;
<p class="BodyFirst">The <em>SMBus</em> was originally developed by Intel and Duracell as a means for managing battery power in computer-based systems. SMBus v1.0 and v1.1 dealt with low-power devices such as battery power management systems, while SMBus v2.0 added high-power devices to the specification.</p>&#13;
<p>It might seem unnecessary to devote a whole section to the SMBus implementation of the I<sup>2</sup>C bus, since there are few SMBus peripherals and most embedded software designers don’t spend much time on battery management, the SMBus’s main use. However, Linux I<sup>2</sup>C support, including the Raspberry Pi, provides API functions based on the SMBus protocol. For that reason alone, this slightly more-than-brief coverage of the SMBus is worthwhile. Furthermore, of all the I<sup>2</sup>C extensions and variants, the SMBus is by far the most common. </p>&#13;
<p>Most of the few peripheral ICs that support the SMBus protocol will behave like standard I<sup>2</sup>C peripherals if you ignore the information in this chapter and simply program them according to their datasheets. Many devices support some aspects of the SMBus protocol even though they do not support the full protocol. Many of the MCP23017 GPIO expander’s command sequences, for example, follow the SMBus protocol in this chapter (see Chapter 13). Therefore, having an understanding of the SMBus can help you with many peripherals out there, even if they don’t fully support the SMBus specification.</p>&#13;
<h3 id="h2-502468c05-0001">5.1.1	Differences Between SMBus and Standard I<sup>2</sup>C</h3>&#13;
<p class="BodyFirst">Though it’s based on the I<sup>2</sup>C bus, the SMBus places some additional requirements on the I<sup>2</sup>C signals:</p>&#13;
<ul>&#13;
<li>The clock—SMBCLK, the SMBus name for SCL—must be between 10 kHz and 100 kHz. In particular, note that SMBus does not support arbitrary clock stretching (below 10 kHz). Later versions of the SMBus specification also support 400-kHz and 1-MHz signals.</li>&#13;
<li>SMBus v3.0 supports signal voltages in the range of 1.8 V to 5 V. Also, SMBus explicitly states that a logic 0 is less than 0.8 V and a logic 1 is greater than 1.35 V.</li>&#13;
<li>SMBus specifies a clock low timeout of 35 msec (about 15 Hz, assuming a 50 percent duty cycle). The I<sup>2</sup>C standard specifies no such timeout.</li>&#13;
<li>SMBus specifies both rise and fall times for bus signals; the I<sup>2</sup>C standard provides no such specifications (other than bus capacitance, which affects rise and fall times).</li>&#13;
<li>NAK behavior is different between I<sup>2</sup>C and SMBus.</li>&#13;
<li>SMBus devices must always acknowledge the receipt of their address on the I<sup>2</sup>C bus; standard I<sup>2</sup>C protocol doesn’t require this (for example, if the device is busy doing something else).</li>&#13;
<li>The SMBus supports three types of devices on the bus: controllers, peripherals, and a single, special version of a controller known as the <em>host</em>.</li>&#13;
<li><span epub:type="pagebreak" id="Page_83" title="83"/>All devices on the SMBus must have a unique ID associated with them.</li>&#13;
<li>SMBus v2.0 introduced the concept of a dynamically assigned device address. </li>&#13;
<li>SMBus supports optional hardware signals, SMBAlert and SMBSuspend, that can create interrupts or suspend operations for low-power operation.</li>&#13;
</ul>&#13;
<p>The SMBus also reserves certain device addresses for purposes such as prototype devices, far beyond the number that the I<sup>2</sup>C bus reserves for special use. The SMBus also supports dynamically specified device addresses, allowing devices to choose their addresses during operation.</p>&#13;
<p>On top of the hardware differences, the SMBus specification calls out several protocol changes, including features for transferring blocks of data, bus-specific commands, and device enumeration. The SMBus specification provides more details (link provided in “For More Information” at the end of this chapter).</p>&#13;
<h3 id="h2-502468c05-0002">5.1.2	SMBus Electrical Specifications</h3>&#13;
<p class="BodyFirst">As noted previously, the SMBus SMBCLK signal must operate between 10 kHz and maximum bus speed (100 kHz, 400 kHz, or 1 MHz). In reality, most modern SMBus implementations operate at 50 kHz or faster. NXP’s documentation (see the SMBus quick start guide in “For More Information”) states that a system must not reduce the clock frequency to the minimum speed even in response to clock stretching on the part of peripheral devices. In addition, SMBus devices must be ready to operate within 500 msec after power is applied.</p>&#13;
<p>The SMBus has better electrical specifications than the standard I<sup>2</sup>C bus. It defines a logic 0 on the clock or data lines as 0.8 V or less and a logic 1 as 1.35 V or greater.</p>&#13;
<h3 id="h2-502468c05-0003">5.1.3	SMBus Reserved Addresses</h3>&#13;
<p class="BodyFirst">The SMBus reserves several addresses above and beyond the I<sup>2</sup>C reserved addresses (see section 2.5, “Special Addresses,” in Chapter 2). In addition to these addresses, the SMBus reserves 7-bit addresses 0x08 for SMBus host devices, 0x0C for SMBus alert responses, and 0x61 for the SMBus device default address. The SMBus specification also reserves certain device address for specific purposes, as described in <a href="#table5-1" id="tableanchor5-1">Table 5-1</a>.</p>&#13;
<figure>&#13;
<figcaption class="TableTitle"><p><a id="table5-1">Table 5-1</a>: Reserved SMBus Device Addresses</p></figcaption>&#13;
<table border="1" id="table-502468c05-0001">&#13;
<thead>&#13;
<tr>&#13;
<td>Address bits</td>&#13;
<td>Description</td>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr>&#13;
<td>0001-000</td>&#13;
<td>SMBus host</td>&#13;
</tr>&#13;
<tr>&#13;
<td>0001-001</td>&#13;
<td>Smart battery charger</td>&#13;
</tr>&#13;
<tr>&#13;
<td>0001-010</td>&#13;
<td>Smart battery selector or smart battery system manager</td>&#13;
</tr>&#13;
<tr>&#13;
<td><span epub:type="pagebreak" id="Page_84" title="84"/>Address bits</td>&#13;
<td>Description</td>&#13;
</tr>&#13;
<tr>&#13;
<td>0001-011</td>&#13;
<td>Smart battery</td>&#13;
</tr>&#13;
<tr>&#13;
<td>0001-100</td>&#13;
<td>SMBus alert response</td>&#13;
</tr>&#13;
<tr>&#13;
<td>0101-000</td>&#13;
<td>ACCESS.bus host</td>&#13;
</tr>&#13;
<tr>&#13;
<td>0101-100</td>&#13;
<td>Originally reserved for LCD contrast controllers (may be reassigned in future versions of the SMBus)</td>&#13;
</tr>&#13;
<tr>&#13;
<td>0101-101</td>&#13;
<td>Originally reserved for CCFL backlight controllers (may be reassigned in future versions of the SMBus)</td>&#13;
</tr>&#13;
<tr>&#13;
<td>0110-111</td>&#13;
<td>ACCESS.bus default address</td>&#13;
</tr>&#13;
<tr>&#13;
<td>1000-0xx</td>&#13;
<td>Originally reserved for PCMCIA socket controllers (may be reassigned in future versions of the SMBus)</td>&#13;
</tr>&#13;
<tr>&#13;
<td>1000-100</td>&#13;
<td>Originally reserved for VGA graphics controllers (may be reassigned in future versions of the SMBus)</td>&#13;
</tr>&#13;
<tr>&#13;
<td>1001-0xx</td>&#13;
<td>Unrestricted addresses</td>&#13;
</tr>&#13;
<tr>&#13;
<td>1100-001</td>&#13;
<td>SMBus device default address</td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
</figure>&#13;
<p>Please consult the SMBus documentation to see if there are any additions to this list. Later versions of the SMBus standard may add device addresses to this list.</p>&#13;
<h3 id="h2-502468c05-0004">5.1.4	SMBus Protocol Commands</h3>&#13;
<p class="BodyFirst">The standard I<sup>2</sup>C bus protocol specifies only the address byte, and R/W bit, format. It does not define any further data appearing on the bus. In contrast, the SMBus protocol defines several different command formats including Quick Command, Send Byte, Receive Byte, Write Byte, Write Word, Read Byte, Read Word, Process Call, Block Read, and Block Write. </p>&#13;
<aside epub:type="sidebar">&#13;
<div class="top hr"><hr/>&#13;
</div>&#13;
<section class="note">&#13;
<h2><span class="NoteHead">NOTE</span></h2>&#13;
<p>	The SMBus specification also provides for a Block Write-Block Read Process Call. This book will not cover that particular command. See the SMBus specification for more details (the link is in “For More Information”).</p>&#13;
<div class="bottom hr"><hr/>&#13;
</div>&#13;
</section>&#13;
</aside>&#13;
<p>SMBus devices do not have to implement all the SMBus protocol commands—only those that are relevant to the particular device. If a device supports the Quick Command, it likely supports only that command. Similarly, if the device supports the Read Byte command and the Send Byte command, it likely supports only those two commands. The remaining SMBus protocol commands include an extra <em>command byte</em>; this byte can specify the particular command protocol to use. The following subsections define each of these command types.</p>&#13;
<h4 id="h3-502468c05-0001"><span epub:type="pagebreak" id="Page_85" title="85"/>5.1.4.1	SMBus Quick Commands</h4>&#13;
<p class="BodyFirst">SMBus Quick Commands are simple 1-bit commands built into the R/W bit of the address byte (see <a href="#figure5-1" id="figureanchor5-1">Figure 5-1</a>). The Quick Commands transmit a single bit to the peripheral device that can be used to turn the device on or off or perform some other operation based on a single bit of binary data. </p>&#13;
<figure>&#13;
<img alt="" class="" height="95" src="image_fi/502468c05/f05002.png" width="421"/>&#13;
<figcaption><p><a id="figure5-1">Figure 5-1</a>: Quick Command format</p></figcaption>&#13;
</figure>&#13;
<p>There is no additional data beyond the address byte sent to the device with a Quick Command.</p>&#13;
<h4 id="h3-502468c05-0002">5.1.4.2	SMBus Send Byte and Read Byte Commands</h4>&#13;
<p class="BodyFirst">The SMBus Send Byte and Read Byte commands include 1 byte of data after the address byte. The R/W bit of the address byte specifies the particular command (read or write; see <a href="#figure5-2" id="figureanchor5-2">Figure 5-2</a>). </p>&#13;
<figure>&#13;
<img alt="" class="" height="97" src="image_fi/502468c05/f05001.png" width="765"/>&#13;
<figcaption><p><a id="figure5-2">Figure 5-2</a>: Send or Read Byte command format</p></figcaption>&#13;
</figure>&#13;
<p>With a Send Byte command, the host/controller device transmits the second byte to the peripheral; with the Read Byte command, the peripheral places the data on the SMBDAT (SDA) line to be read by the host/controller device.</p>&#13;
<h4 id="h3-502468c05-0003">5.1.4.3	SMBus Read Byte and Read Word Commands</h4>&#13;
<p class="BodyFirst">The SMBus Read Byte command allows you to read a single byte of data from a peripheral device with no way to specify what byte data you’re reading. That command is useful for simple devices that return a single byte value, such as reading a single set of eight digital I/O pins. The SMBus Read Byte and Word commands, on the other hand, include a special command byte that allows you to specify parameter information to select the particular byte you want to read. This could be, for example, a register or memory address or other selection or control information. The sequence for a Read Byte command appears in <a href="#figure5-3" id="figureanchor5-3">Figure 5-3</a>.</p>&#13;
<span epub:type="pagebreak" id="Page_86" title="86"/><figure>&#13;
<img alt="" class="" height="202" src="image_fi/502468c05/f05003.png" width="843"/>&#13;
<figcaption><p><a id="figure5-3">Figure 5-3</a>: Read Byte command format</p></figcaption>&#13;
</figure>&#13;
<p>The sequence for a Read Word command appears in <a href="#figure5-4" id="figureanchor5-4">Figure 5-4</a>.</p>&#13;
<figure>&#13;
<img alt="" class="" height="326" src="image_fi/502468c05/f05004.png" width="844"/>&#13;
<figcaption><p><a id="figure5-4">Figure 5-4</a>: Read Word command format</p></figcaption>&#13;
</figure>&#13;
<p>Because the controller must first write the command byte to the peripheral device, the Read Byte and Read Word commands begin with a write operation (bit 0 of the address byte contains a 0). Then the sequence must include a restart operation followed by a second address byte with bit 0 containing a 1 (for read). Then the controller reads the next byte or word (depending on the command) from the peripheral device.</p>&#13;
<p>Not all devices support both Read Byte and Read Word commands. The peripheral device’s design determines whether the controller can read a single byte, a word, or both. If the device supports reading both bytes and words using this command, then the controller must somehow specify whether it wants to read a byte or a word from the device, typically using a bit within the command byte.</p>&#13;
<h4 id="h3-502468c05-0004">5.1.4.4	SMBus Write Byte and Write Word Commands</h4>&#13;
<p class="BodyFirst">The SMBus Write Byte and Write Word commands also include a command byte that allows you to specify parameter information to select the particular byte or word you want to write to the peripheral. This could be a register or memory address or other selection or control information. The sequence for a Write Byte command appears in <a href="#figure5-5" id="figureanchor5-5">Figure 5-5</a>.</p>&#13;
<span epub:type="pagebreak" id="Page_87" title="87"/><figure>&#13;
<img alt="" class="" height="200" src="image_fi/502468c05/f05005.png" width="752"/>&#13;
<figcaption><p><a id="figure5-5">Figure 5-5</a>: Write Byte command format</p></figcaption>&#13;
</figure>&#13;
<p>The sequence for a Write Word command appears in <a href="#figure5-6" id="figureanchor5-6">Figure 5-6</a>.</p>&#13;
<figure>&#13;
<img alt="" class="" height="324" src="image_fi/502468c05/f05006.png" width="752"/>&#13;
<figcaption><p><a id="figure5-6">Figure 5-6</a>: Write Word command format</p></figcaption>&#13;
</figure>&#13;
<p>Because the controller is strictly writing to the peripheral device, there is no need for the restart command and the extra address-R/W byte in these sequences. As for the Read Byte and Read Word commands, the device’s design determines whether it supports the Write Byte, Write Word, or both commands. If the device supports both byte and word writes, then presumably the controller must somehow specify the size to write within the command byte.</p>&#13;
<h4 id="h3-502468c05-0005">5.1.4.5	SMBus Block Read Command</h4>&#13;
<p class="BodyFirst">Although most SMBus transactions involve reading or writing a single byte or word, a few devices support larger data transfers. The SMBus Block Read command handles reading blocks of data. As for the Read Byte and Read Word command, the controller transmits an address byte (with the LO bit equal to 0 to denote a write operation) followed by a command byte. Then the controller sends a repeated start operation followed by an address byte with the LO bit equal to 1 (to denote a read). The peripheral responds by sending a byte containing the byte count followed by that many data bytes, as shown in <a href="#figure5-7" id="figureanchor5-7">Figure 5-7</a>.</p>&#13;
<p>The peripheral specifies how many bytes it is returning in the byte count value. In theory, it is possible for the controller to specify how many bytes it wants to read by providing this count as part of the command byte <span epub:type="pagebreak" id="Page_88" title="88"/>field. However, the peripheral’s design determines who specifies the number of bytes returned; it could be a fixed value or a programmed value.</p>&#13;
<figure>&#13;
<img alt="" class="" height="451" src="image_fi/502468c05/f05007.png" width="831"/>&#13;
<figcaption><p><a id="figure5-7">Figure 5-7</a>: Block Read sequence</p></figcaption>&#13;
</figure>&#13;
<h4 id="h3-502468c05-0006">5.1.4.6	SMBus Block Write Command</h4>&#13;
<p class="BodyFirst">Of course, the SMBus provides a Block Write complement to the Block Read command. The command is a bit simpler than the Block Read command, as you don’t have to reverse the data direction after sending the command byte. <a href="#figure5-8" id="figureanchor5-8">Figure 5-8</a> provides the write sequence.</p>&#13;
<figure>&#13;
<img alt="" class="" height="448" src="image_fi/502468c05/f05008.png" width="843"/>&#13;
<figcaption><p><a id="figure5-8">Figure 5-8</a>: Block Write sequence</p></figcaption>&#13;
</figure>&#13;
<p><span epub:type="pagebreak" id="Page_89" title="89"/>Because there is no need to resend the device address with a new R/W bit, this sequence is shorter (and more efficient) than the Block Read command operation.</p>&#13;
<h2 id="h1-502468c05-0002">	5.2	VESA DDC and E-DDC</h2>&#13;
<p class="BodyFirst">The VESA DDC (obsolete) and E-DDC (modern) interfaces allow communication between a host (computer) system and a display monitor (the VESA device). The DDC/E-DDC (hereafter E-DDC) is a two-wire communication bus built on the I<sup>2</sup>C bus. The E-DDC protocol allows the host system to determine monitor information, set display parameters such as brightness, and perform other operations.</p>&#13;
<p>Displays that are compatible with VESA E-DDC look like I<sup>2</sup>C peripherals on the I<sup>2</sup>C bus. In particular, compatible devices can respond to the (8-bit) addresses 0xA0, 0xA1, 0xA4, or 0xA5 and a command register at address 0x60. The host (computer) exchanges information with the display through these addresses. For the most part, this is display identification and parameter information.</p>&#13;
<p>VESA specifies I<sup>2</sup>C signaling only in the VGA, HDMI, and DVI interfaces. DisplayPort interfaces use a different mechanism for transferring data between the host computer and the display device. See the VESA E-DDC specifications for more details (link in “For More Information”).</p>&#13;
<h2 id="h1-502468c05-0003">	5.3	ACCESS.bus</h2>&#13;
<p class="BodyFirst">The ACCESS.bus system was an early, pre-USB attempt to allow the attachment of low-speed peripheral devices such as keyboards and mice to a computer system. The intent was to support hot-pluggable devices that could be attached and removed without powering down the system, unlike AT and PS-2 keyboards of that era. ACCESS.bus was based on the I<sup>2</sup>C bus, supporting up to 125 devices. </p>&#13;
<p>As USB arrived about a year later, interest in ACCESS.bus quickly diminished, though it did become the basis for the VESA DDC communication system (and the obsolete Apple Desktop Bus).</p>&#13;
<h2 id="h1-502468c05-0004">	5.4	Two-Wire Interface and Two-Wire Serial Interface</h2>&#13;
<p class="BodyFirst"><em>Two-wire interface (TWI)</em> and <em>two-wire serial interface (TWSI)</em> are names that various manufacturers use to avoid trademark and compliance issues with I<sup>2</sup>C. Some manufacturers will often use TWI when their devices don’t completely support the full I<sup>2</sup>C standard—if a device doesn’t support the START byte, for example. Some people use this term if the bus doesn’t support multiple controllers, clock stretching, or other I<sup>2</sup>C features. In general, if you see this term being used, you can probably assume that the device doesn’t fully support the I<sup>2</sup>C standard, though it will likely work fine in your application if you aren’t relying on cutting-edge features.</p>&#13;
<h2 id="h1-502468c05-0005"><span epub:type="pagebreak" id="Page_90" title="90"/>	5.5	Chapter Summary</h2>&#13;
<p class="BodyFirst">This chapter briefly covered various protocol extensions to the I<sup>2</sup>C bus including the SMBus, VESA (DDC and E-DDC), ACCESS.bus, and the TWI. Of these, the SMBus and VESA bus are commonly used today. The SMBus is largely employed for system power management, and the VESA variants are used to control video displays.</p>&#13;
<p>The SMBus protocol is significant because Linux’s I<sup>2</sup>C support is based on it. Therefore, this chapter spent considerable time discussing several SMBus commands, including Quick Commands, Send and Read Byte commands, Read Byte and Read Word commands, Write Byte and Write Word commands, and Block Read and Block Write commands. </p>&#13;
<p>Unless you are dealing with the specific device categories these higher-level protocols support, it’s unlikely you’ll need more than a passing familiarity with these protocols. Nevertheless, it is important to understand that, at their core, these protocols are still based on the venerable I<sup>2</sup>C bus.</p>&#13;
<aside epub:type="sidebar">&#13;
<div class="top hr"><hr/>&#13;
</div>&#13;
<section class="box">&#13;
<h2>For More Information</h2>&#13;
<ol class="none">&#13;
<li>SMBus website: <a class="LinkURL" href="http://smbus.org">http://smbus.org</a></li>&#13;
<li>SMBus specification: <a class="LinkURL" href="http://smbus.org/specs">http://smbus.org/specs</a></li>&#13;
<li>SMBus Quick Start Guide: <a class="LinkURL" href="https://www.nxp.com/docs/en/application-note/AN4471.pdf">https://www.nxp.com/docs/en/application-note/AN4471.pdf</a></li>&#13;
<li>VESA homepage: <a class="LinkURL" href="https://vesa.org">https://vesa.org</a></li>&#13;
<li>VESA EDDC v1.2 standard: <a class="LinkURL" href="https://glenwing.github.io/docs/VESA-EDDC-1.2.pdf">https://glenwing.github.io/docs/VESA-EDDC-1.2.pdf</a></li>&#13;
<li>VESA EDID description: <a class="LinkURL" href="https://media.extron.com/public/download/files/articles/understandingedid.pdf">https://media.extron.com/public/download/files/articles/understandingedid.pdf</a></li>&#13;
<li>VESA DDC description: <a class="LinkURL" href="https://en.wikipedia.org/wiki/Display_Data_Channel">https://en.wikipedia.org/wiki/Display_Data_Channel</a></li>&#13;
<li>ACCESS.bus wiki page: <a class="LinkURL" href="https://en.wikipedia.org/wiki/ACCESS.bus">https://en.wikipedia.org/wiki/ACCESS.bus</a></li>&#13;
<li>ACCESS.bus v3.0 specification: <a class="LinkURL" href="https://www.mcc-us.com/abspec30.htm">https://www.mcc-us.com/abspec30.htm</a></li>&#13;
</ol>&#13;
<div class="bottom hr"><hr/>&#13;
</div>&#13;
</section>&#13;
</aside>&#13;
</section>&#13;
</div>&#13;
</body></html>