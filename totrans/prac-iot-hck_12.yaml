- en: '9'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '9'
- en: Firmware Hacking
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 固件黑客攻击
- en: '![](Images/chapterart.png)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/chapterart.png)'
- en: The firmware is the software piece that links the device’s hardware layer to
    its main software layer. A vulnerability in this part of the device can have a
    tremendous impact on all the device functionalities. As a result, it’s crucial
    to identify and mitigate firmware vulnerabilities to secure IoT devices.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 固件是将设备硬件层与其主要软件层连接起来的软件部分。设备中这一部分的漏洞可能会对所有设备功能产生巨大影响。因此，识别并减轻固件漏洞对保障物联网设备安全至关重要。
- en: In this chapter, we explore what firmware is and how we can retrieve it and
    then analyze it for vulnerabilities. We start by finding user credentials in the
    firmware’s filesystem. Then we emulate some of the firmware’s compiled binaries,
    along with the entire firmware, to perform dynamic analysis. We also modify a
    publicly available firmware to add a backdoor mechanism and discuss how to spot
    a vulnerable firmware update service.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将探讨什么是固件，以及如何获取它并分析其中的漏洞。我们首先通过在固件的文件系统中查找用户凭据开始。接着，我们将模拟固件的部分已编译二进制文件，以及整个固件，进行动态分析。我们还将修改一个公开可用的固件，添加一个后门机制，并讨论如何发现存在漏洞的固件更新服务。
- en: Firmware and Operating Systems
  id: totrans-5
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 固件与操作系统
- en: Firmware is a type of software that provides communication and control over
    a device’s hardware components. It’s the first piece of code that a device runs.
    Usually, it boots the operating system and provides very specific runtime services
    for programs by communicating with various hardware components. Most, if not all,
    electronic devices have firmware.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 固件是一种软件，它提供设备硬件组件的通信与控制。它是设备运行的第一段代码。通常，固件启动操作系统，并通过与各种硬件组件的通信，提供非常特定的运行时服务供程序使用。大多数电子设备都有固件，甚至可以说没有例外。
- en: Although firmware is a simpler and more reliable piece of software than operating
    systems, it’s also more restrictive and is designed to support only specific hardware.
    In contrast, many IoT devices run remarkably advanced, complex operating systems
    that support a large family of products. For example, IoT devices based on Microsoft
    Windows typically use operating systems such as Windows 10 IoT Core, Windows Embedded
    Industry (also known as POSReady or WEPOS), and Windows Embedded CE. IoT devices
    based on embedded Linux variants often use operating systems such as Android Things,
    OpenWrt, and Raspberry Pi OS. On the other hand, IoT devices designed to serve
    real-time applications that need to process data with specific time constraints
    and without buffer delays are usually based on real-time operating systems (RTOS),
    such as BlackBerry QNX, Wind River VxWorks, and NXP MQX mBed. Additionally, “bare-metal”
    IoT devices, designed to support simple microcontroller-based applications, typically
    execute assembly instructions directly on the hardware without advanced operating
    system scheduling algorithms to distribute the system resources. Nevertheless,
    each of these implementations has its own boot sequence with compatible bootloaders.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管固件是比操作系统更简单、更可靠的软件部分，但它也更具限制性，并且设计上仅支持特定硬件。相比之下，许多物联网设备运行的操作系统异常先进且复杂，支持大量产品。例如，基于微软Windows的物联网设备通常使用Windows
    10 IoT Core、Windows Embedded Industry（也称为POSReady或WEPOS）以及Windows Embedded CE等操作系统。基于嵌入式Linux变种的物联网设备通常使用如Android
    Things、OpenWrt和Raspberry Pi OS等操作系统。另一方面，旨在处理具有特定时间约束和无缓冲延迟的实时应用程序的物联网设备，通常基于实时操作系统（RTOS），如BlackBerry
    QNX、Wind River VxWorks和NXP MQX mBed。此外，设计上支持简单基于微控制器应用程序的“裸机”物联网设备，通常直接在硬件上执行汇编指令，而不使用复杂的操作系统调度算法来分配系统资源。尽管如此，这些实现每一种都有其与兼容启动程序的启动顺序。
- en: In less complicated IoT devices, the firmware might play the part of the operating
    system. Devices store firmware in nonvolatile memory, such as ROM, EPROM, or flash
    memory.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在较为简单的物联网设备中，固件可能充当操作系统的角色。设备将固件存储在非易失性存储器中，如ROM、EPROM或闪存。
- en: It’s important to examine the firmware and then attempt to modify it, because
    we can uncover many security issues during this process. Users often alter firmware
    to unlock new features or customize it. But with the same tactics, attackers can
    gain a better understanding of the system’s inner workings or even exploit a security
    vulnerability.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 检查固件并尝试修改它非常重要，因为在此过程中，我们可以发现许多安全问题。用户通常会修改固件以解锁新功能或进行个性化定制。但攻击者也可以通过相同的手段，更好地理解系统的内部工作原理，甚至利用安全漏洞。
- en: Obtaining Firmware
  id: totrans-10
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 获取固件
- en: Before you can reverse engineer a device’s firmware, you must find a way to
    gain access to it. Usually, there’s more than one method of doing so, depending
    on the device. In this section, we’ll cover the most popular firmware extraction
    methods according to the OWASP Firmware Security Testing Methodology (FSTM), which
    you can find at [https://scriptingxss.gitbook.io/firmware-security-testing-methodology/](https://scriptingxss.gitbook.io/firmware-security-testing-methodology/).
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在你进行固件逆向工程之前，你必须找到一种方法来访问固件。通常，依据设备的不同，会有多种方法。在本节中，我们将根据OWASP固件安全测试方法论(FSTM)介绍最常用的固件提取方法，你可以在[https://scriptingxss.gitbook.io/firmware-security-testing-methodology/](https://scriptingxss.gitbook.io/firmware-security-testing-methodology/)找到相关内容。
- en: Often, the easiest way to find the firmware is to explore the vendor’s support
    site. Some vendors make their firmware available to the public to simplify troubleshooting.
    For example, the networking equipment manufacturer TP-Link provides a repository
    of firmware files from routers, cameras, and other devices on its website.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，找到固件的最简单方法是浏览供应商的支持网站。一些供应商会将其固件公开，以简化故障排除。例如，网络设备制造商TP-Link在其网站上提供了来自路由器、摄像头和其他设备的固件文件库。
- en: If the firmware for the specific device isn’t published, try asking the vendor
    for it. Some vendors might simply provide you with the firmware. You could directly
    contact the development team, the manufacturer, or another of the vendor’s clients.
    Make sure you always verify that the person you contacted has the vendor’s permission
    to share the firmware with you. It’s definitely worth trying to acquire a development
    and a release build. Doing so will make your testing more effective, because you’ll
    be able to see the differences between the two builds. Also, some protection mechanisms
    might be removed in the development build. For example, Intel RealSense provides
    the production and development firmware of its cameras at [https://dev.intelrealsense.com/docs/firmware-releases/](https://dev.intelrealsense.com/docs/firmware-releases/).
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 如果特定设备的固件未公开，可以尝试向供应商索要。有些供应商可能会直接提供固件。你可以直接联系开发团队、制造商或供应商的其他客户。确保你始终验证你联系的人是否获得了供应商的许可来分享固件给你。尝试获取开发版和发布版固件是值得的。这样做将使你的测试更加有效，因为你可以看到两个版本之间的差异。此外，一些保护机制可能会在开发版中被移除。例如，Intel
    RealSense在[https://dev.intelrealsense.com/docs/firmware-releases/](https://dev.intelrealsense.com/docs/firmware-releases/)提供其摄像头的生产和开发固件。
- en: Sometimes you might have to build the firmware manually. This is a dreaded practice
    for some, but a solution is a solution. The firmware source code might be publicly
    accessible, especially in open source projects. In these situations, it might
    be possible to build the firmware by following manufacturer published walkthroughs
    and instructions. The OpenWrt operating system used in Chapter 6 is one such open
    source firmware project and is primarily found in embedded devices to route network
    traffic. For example, the firmware of the GL.iNet routers is based on OpenWrt.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候，你可能需要手动构建固件。对于某些人来说，这是一个令人畏惧的操作，但解决方案就是解决方案。固件源代码可能是公开的，尤其是在开源项目中。在这些情况下，按照制造商发布的操作步骤和说明，可能可以构建固件。第六章中使用的OpenWrt操作系统就是一个这样的开源固件项目，主要应用于嵌入式设备中进行网络流量路由。例如，GL.iNet路由器的固件基于OpenWrt。
- en: 'Another common approach is to explore the powerful search engines, like Google
    using Google Dorks*.* With the proper queries, you can find pretty much anything
    online. Search Google for binary file extensions hosted on file-sharing platforms,
    such as MediaFire, Dropbox, Microsoft OneDrive, Google Drive, or Amazon Drive.
    It’s common to come across firmware images uploaded by customers to message boards
    or customer and corporate blogs. Also look at the comment section of sites for
    communication between customers and manufacturers. You might find information
    about how to get the firmware, or you might even find that the manufacturer sent
    the customer a compressed file or link to download the firmware from a file-sharing
    platform. Here’s an example of a Google Dork for locating firmware files for Netgear
    devices:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种常见的方法是探索强大的搜索引擎，例如使用Google Dorks*.* 通过正确的查询，你几乎可以在线找到任何内容。搜索Google以查找托管在文件共享平台上的二进制文件扩展名，如MediaFire、Dropbox、Microsoft
    OneDrive、Google Drive或Amazon Drive。经常会看到客户上传到论坛或客户和公司博客上的固件镜像。还可以查看网站的评论区，看看客户和制造商之间的交流。你可能会找到如何获取固件的信息，或者甚至可能发现制造商向客户发送了压缩文件或链接，以从文件共享平台下载固件。以下是一个Google
    Dork示例，用于定位Netgear设备的固件文件：
- en: '[PRE0]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The `intitle` parameter specifies text that must exist in the title of the page,
    whereas the `intext` parameter specifies text that must exist in the page content.
    This search returned the results shown in [Figure 9-1](#figure9-1).
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '`intitle`参数指定页面标题中必须包含的文本，而`intext`参数指定页面内容中必须包含的文本。此搜索返回了[图9-1](#figure9-1)中显示的结果。'
- en: 'In addition, don’t ignore the possibility of finding exposed cloud storage
    locations. Search Amazon S3 buckets; with enough luck, you could find the firmware
    in a vendor’s unprotected bucket. (For legal reasons, make sure the buckets weren’t
    exposed unintentionally and that the vendor has granted you permission to access
    any existing files.) The S3Scanner tool can enumerate a vendor’s Amazon S3 buckets.
    The tool is written in Python 3, which is pre-installed in Kali Linux. You can
    download the application using the `git` command:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，不要忽视发现暴露的云存储位置的可能性。搜索Amazon S3桶；如果足够幸运，你可能会在厂商未保护的桶中找到固件。（出于法律原因，请确保这些桶没有被意外暴露，并且厂商已授权你访问任何现有的文件。）S3Scanner工具可以枚举厂商的Amazon
    S3桶。该工具是用Python 3编写的，Kali Linux中已预装。你可以使用`git`命令下载该应用程序：
- en: '[PRE1]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '![f09001](Images/f09001.png)'
  id: totrans-20
  prefs: []
  type: TYPE_IMG
  zh: '![f09001](Images/f09001.png)'
- en: 'Figure 9-1: Discovering firmware links for Netgear devices using a Google Dork'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 图9-1：使用Google Dork发现Netgear设备的固件链接
- en: 'Then navigate in the *application* folder and install the required dependencies
    using the `pip3` command, which is also available in Kali Linux:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 然后在*应用程序*文件夹中导航，使用`pip3`命令安装所需的依赖项，该命令在Kali Linux中也可用：
- en: '[PRE2]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Now you can search for a vendor’s Amazon S3 buckets and enumerate which of
    them provide access to firmware:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你可以搜索厂商的Amazon S3桶，并枚举哪些提供固件访问：
- en: '[PRE3]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The parameter `vendor_potential_buckets.txt` specifies a file of potential bucket
    names for the tool to try. You can create your own similar custom file and provide
    vendor names followed by popular suffixes for S3 buckets, such as `-dev`, `-development`,
    `-live`, `-staging`, and `-prod`. The tool initially outputs a warning notification
    that your AWS credentials are missing, but this is expected and you can ignore
    it. Then the tool outputs the discovered S3 buckets followed by their access status.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 参数`vendor_potential_buckets.txt`指定了一个潜在的桶名称文件供工具尝试。你可以创建自己类似的自定义文件，并提供厂商名称，后跟S3桶的常见后缀，如`-dev`、`-development`、`-live`、`-staging`和`-prod`。工具最初会输出一个警告通知，表示缺少你的AWS凭证，但这是预期的，你可以忽略它。然后，工具会输出发现的S3桶及其访问状态。
- en: If the device comes with companion software, it might be worth trying the application
    analysis approach. By analyzing the device’s mobile companion apps or *thick clients*—fully
    functional computers that don’t require a network connection to operate—you might
    pick up hardcoded endpoints that the applications communicate with. One of those
    endpoints could be the one used to download the firmware automatically during
    the update process. Regardless of whether or not this endpoint is authenticated,
    you should be able to download the firmware by analyzing the clients. You can
    find a methodology for analyzing such apps in Chapter 14.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 如果设备配有配套软件，可以尝试应用程序分析方法。通过分析设备的移动配套应用程序或 *厚客户端*——完全功能的计算机，操作时不需要网络连接——你可能会发现硬编码的端点，应用程序通过这些端点进行通信。这些端点中的一个可能是用于在更新过程中自动下载固件的端点。无论该端点是否经过身份验证，你都应该能够通过分析客户端来下载固件。你可以在第
    14 章找到分析此类应用程序的方法。
- en: For devices that still receive updates and bug fixes from the manufacturer,
    you can often perform an effective man-in-the-middle attack during the OTA updates.
    These updates are pushed over the network channel from a central server, or clusters
    of servers, to every connected device. Depending on the complexity of the application
    logic that downloads the firmware, intercepting the traffic might be the easiest
    solution. To do that, you’ll need to have a trusted certificate installed on the
    device (assuming the transfer occurs over HTTPS) and intercept the traffic using
    a network sniffer, poisoning technique (such as ARP cache poisoning), and proxy
    that can dump binary communication to a file.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 对于仍然接收制造商更新和错误修复的设备，你通常可以在 OTA 更新过程中执行有效的中间人攻击。这些更新通过网络通道从中央服务器或服务器集群推送到每个连接的设备。根据下载固件的应用逻辑复杂性，拦截流量可能是最简单的解决方案。为此，你需要在设备上安装受信任的证书（假设传输是通过
    HTTPS 进行的），并使用网络嗅探器、毒化技术（例如 ARP 缓存投毒）和代理来截取流量，并将二进制通信保存到文件中。
- en: In many devices, it might also be possible to dump the firmware using the device
    bootloader. The bootloader is usually accessible in many ways, such as through
    embedded serial RS232 ports, using special keyboard shortcuts, or over the network.
    Additionally, in most consumer devices, the bootloader is programmed to allow
    flash memory read and write operations.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在许多设备中，也可能通过设备的引导加载程序转储固件。引导加载程序通常可以通过多种方式访问，例如通过嵌入式串行 RS232 端口、使用特殊的键盘快捷键或通过网络。此外，在大多数消费类设备中，引导加载程序被编程为允许读取和写入闪存。
- en: If the hardware contains exposed programming interfaces such as UART, JTAG,
    and SPI, try connecting to these interfaces directly to read the flash memory.
    Chapters 7 and 8 include a detailed explanation of how to spot and use these interfaces.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 如果硬件包含暴露的编程接口，如 UART、JTAG 和 SPI，尝试直接连接到这些接口以读取闪存。第 7 章和第 8 章将详细解释如何识别和使用这些接口。
- en: The last and most difficult method is to extract the firmware directly from
    either the flash chip (through SPI, for example) or the *microcontroller unit
    (MCU)*. The MCU is a single chip embedded on the device board that contains the
    CPU, memory, a clock, and a control unit. You’ll need a chip programmer to do
    this.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一种也是最困难的方法是直接从闪存芯片（例如通过 SPI）或 *微控制器单元（MCU）* 提取固件。MCU 是嵌入在设备板上的单一芯片，包含 CPU、内存、时钟和控制单元。你需要一个芯片编程器来完成此操作。
- en: Hacking a Wi-Fi Modem Router
  id: totrans-32
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 破解 Wi-Fi 调制解调器路由器
- en: In this section, we’ll target the firmware of a very popular Wi-Fi modem router,
    the Netgear D6000\. We’ll first extract this firmware’s filesystem and search
    it for user credentials. Then we’ll emulate it for dynamic analysis.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将以一款非常流行的 Wi-Fi 调制解调器路由器——Netgear D6000 为目标。我们将首先提取该固件的文件系统，并在其中搜索用户凭证。然后，我们将对其进行仿真以进行动态分析。
- en: To find this firmware, navigate to the vendor’s site and find the support page
    for the device model ([https://www.netgear.com/support/product/D6000.aspx](https://www.netgear.com/support/product/D6000.aspx)).
    You should see a list of available firmware and software downloads ([Figure 9-2](#figure9-2)).
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 要找到此固件，导航到厂商网站，找到该设备型号的支持页面（[https://www.netgear.com/support/product/D6000.aspx](https://www.netgear.com/support/product/D6000.aspx)）。你应该能看到可用的固件和软件下载列表（[图
    9-2](#figure9-2)）。
- en: 'Download the files. Because the firmware is in a compressed format, use the
    `unzip` command to retrieve it. You can install `unzip` using `apt-get`:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 下载文件。由于固件是压缩格式，使用 `unzip` 命令来提取它。你可以使用 `apt-get` 安装 `unzip`：
- en: '[PRE4]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '![f09002](Images/f09002.png)'
  id: totrans-37
  prefs: []
  type: TYPE_IMG
  zh: '![f09002](Images/f09002.png)'
- en: 'Figure 9-2: Netgear D6000 support page'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9-2：Netgear D6000 支持页面
- en: 'The `wget` command is a Unix utility that downloads files from the web in a
    noninteractive way. Without any additional arguments, `wget` will save the file
    in the current working directory. The `unzip` utility then creates a folder called
    *D6000_V1.0.0.41_1.0.1_FW* that contains two files: *D6000-V1.0.0.41_1.0.1.bin*,
    which is the device firmware, and *D6000_V1.0.0.41_1.0.1_Software_Release_Notes.html*,
    which contains vendor’s notes for manually installing this firmware on the device.'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '`wget` 命令是一个 Unix 工具，用于以非交互方式从网络下载文件。在没有任何附加参数的情况下，`wget` 会将文件保存在当前工作目录中。然后，`unzip`
    工具会创建一个名为 *D6000_V1.0.0.41_1.0.1_FW* 的文件夹，里面包含两个文件：*D6000-V1.0.0.41_1.0.1.bin*，这是设备的固件文件，以及
    *D6000_V1.0.0.41_1.0.1_Software_Release_Notes.html*，它包含厂商关于如何手动安装此固件的说明。'
- en: Once you’ve acquired the firmware, you can analyze it for security issues.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你获取了固件文件，就可以分析它是否存在安全问题。
- en: Extracting the Filesystem
  id: totrans-41
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提取文件系统
- en: 'The firmware for most consumer-grade routers contains the device’s filesystem
    in a compressed format. Sometimes, the firmware is compressed several times using
    various algorithms (such as LZMA and LZMA2). Let’s extract this filesystem, mount
    it, and search its contents for security vulnerabilities. To locate the filesystem
    in the firmware file, use `binwalk`, which is pre-installed in Kali Linux:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数消费级路由器的固件包含设备的文件系统，并且是以压缩格式存储的。有时，固件会使用多种算法（如 LZMA 和 LZMA2）多次压缩。让我们提取这个文件系统，挂载它，并搜索其内容以发现安全漏洞。要定位固件文件中的文件系统，可以使用
    `binwalk` 工具，该工具在 Kali Linux 中已预安装：
- en: '[PRE5]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The `-e` parameter extracts any identified file from the firmware, such as the
    bootloader and the filesystem. The `-M` parameter recursively scans extracted
    files and performs a signature analysis to identify file types based on common
    patterns. But beware; if `binwalk` can’t correctly identify the file types, it
    can sometimes fill up your hard disk. You should now have a new folder named *_D6000-V1.0.0.41_1.0.1.bin.extracted*
    that contains the extracted contents.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '`-e` 参数提取固件中任何已识别的文件，例如引导加载程序和文件系统。`-M` 参数递归扫描提取的文件，并执行签名分析，以便根据常见模式识别文件类型。但要小心，如果
    `binwalk` 无法正确识别文件类型，它有时会填满你的硬盘。你现在应该有一个名为 *_D6000-V1.0.0.41_1.0.1.bin.extracted*
    的新文件夹，其中包含提取的内容。'
- en: Note that we used binwalk version 2.1.2-a0c5315\. Some earlier versions couldn’t
    properly extract the filesystem. We recommend that you use the latest binwalk
    version, which is available on GitHub at [https://github.com/ReFirmLabs/binwalk/](https://github.com/ReFirmLabs/binwalk/).
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们使用的是 binwalk 版本 2.1.2-a0c5315\。一些早期版本无法正确提取文件系统。我们建议你使用最新版本的 binwalk，它可以在
    GitHub 上找到，网址是 [https://github.com/ReFirmLabs/binwalk/](https://github.com/ReFirmLabs/binwalk/)。
- en: Statically Analyzing the Filesystem Contents
  id: totrans-46
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 静态分析文件系统内容
- en: 'Now that we’ve extracted the filesystem, we can navigate through the files
    and attempt to find some useful information. A good approach is to begin by searching
    for low-hanging fruit, such as credentials stored in configuration files or outdated
    and vulnerable versions of common binaries with public advisories. Look for any
    files called *passwd* or *shadow*, which often contain information for all user
    accounts on the system, including the users’ passwords. You can do this using
    common utilities like `grep` or `find` that come pre-installed in any Unix system:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经提取了文件系统，就可以浏览这些文件，尝试找到一些有用的信息。一个好的方法是首先搜索易于获取的信息，比如存储在配置文件中的凭据或具有公开漏洞通告的过时版本的常见二进制文件。寻找任何名为
    *passwd* 或 *shadow* 的文件，它们通常包含系统上所有用户帐户的信息，包括用户的密码。你可以使用如 `grep` 或 `find` 这样的常用工具来执行此操作，这些工具在任何
    Unix 系统中都会预安装：
- en: '[PRE6]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Using the `.` command, we instruct the Find tool to search the current working
    directory for the file indicated by the `-name` parameter. In this case, we’re
    looking for a file named *passwd*. As you can see, we’ve located two files with
    that name.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `.` 命令，我们指示 Find 工具在当前工作目录中搜索由 `-name` 参数指定的文件。在这种情况下，我们正在寻找一个名为 *passwd*
    的文件。正如你所看到的，我们找到了两个具有该名称的文件。
- en: 'The *bin/passwd* binary file doesn’t give us useful information in its current
    form. On the other hand, the *etc/passwd* file is in a readable format. You can
    read it using the `cat` utility:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '*bin/passwd* 二进制文件在当前形式下无法提供有用的信息。另一方面，*etc/passwd* 文件是可读的格式。你可以使用 `cat` 工具读取它：'
- en: '[PRE7]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The *etc/passwd* file contains a text-based database that lists the users who
    can authenticate to the system. Currently, there is only one entry, which is for
    the device’s administrator. The entry has the following fields, divided by colons:
    the username, the hash of the user’s password, the user identifier, the group
    identifier, extra information about the user, the path of the user’s home folder,
    and the program executed on user login. Let’s turn our attention to the password
    hash `($1$$iC.dUsGpxNNJGeOm1dFio/)`.'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '*etc/passwd*文件包含了一个文本数据库，列出了可以认证到系统的用户。目前只有一个条目，是设备管理员的条目。该条目包含以下字段，通过冒号分隔：用户名、用户密码的哈希、用户标识符、组标识符、用户的附加信息、用户的主文件夹路径，以及用户登录时执行的程序。我们来关注一下密码哈希`($1$$iC.dUsGpxNNJGeOm1dFio/)`。'
- en: Cracking the Device’s Admin Credentials
  id: totrans-53
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 破解设备的管理员凭证
- en: 'Use `hashid` to detect the admin password’s hash type. This tool is pre-installed
    in Kali Linux, and it can identify more than 220 unique types of hashes via regular
    expressions:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`hashid`检测管理员密码的哈希类型。这个工具已经预装在Kali Linux中，可以通过正则表达式识别超过220种独特的哈希类型：
- en: '[PRE8]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: According to the output, we’ve found an `MD5 Crypt` hash. Now we can try to
    crack this password using a brute-forcing tool, like john or hashcat. These tools
    cycle through a list of potential passwords, looking for one that matches the
    hash.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 根据输出，我们发现了一个`MD5 Crypt`哈希。现在我们可以尝试使用暴力破解工具来破解这个密码，比如john或hashcat。这些工具会遍历一个潜在密码的列表，寻找与哈希匹配的密码。
- en: '[PRE9]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The `-a` parameter defines the attack mode used to guess the plaintext passwords.
    We select mode `3` to perform a brute-force attack. Mode `0` would perform a wordlist
    attack, and mode `1` would perform the *combinator attack*, which appends each
    word in a dictionary to each word in another dictionary. You could also perform
    more specialized attacks using modes 6 and 7\. For example, if you knew that the
    last character in a password was a number, you could configure the tool to try
    passwords that only end in a number.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '`-a`参数定义了用于猜测明文密码的攻击模式。我们选择模式`3`来进行暴力破解攻击。模式`0`会执行字典攻击，模式`1`会执行*组合攻击*，将一个字典中的每个单词附加到另一个字典中的每个单词上。你还可以使用模式6和7进行更专业的攻击。例如，如果你知道密码的最后一个字符是数字，你可以配置工具只尝试以数字结尾的密码。'
- en: The `-m` parameter defines the type of hash we’re trying to crack, and `500[PRE10]
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '`-m`参数定义了我们要破解的哈希类型，`500[PRE10]'
- en: $ **find .** **-name *****cfg**
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: $ **find .** **-name *****cfg**
- en: ./userfs/profile.cfg
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: ./userfs/profile.cfg
- en: ./userfs/romfile.cfg
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: ./userfs/romfile.cfg
- en: ./boaroot/html/NETGEAR_D6000.cfg
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: ./boaroot/html/NETGEAR_D6000.cfg
- en: ./boaroot/html/romfile.cfg
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: ./boaroot/html/romfile.cfg
- en: ./boaroot/html/NETGEAR_D6010.cfg
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: ./boaroot/html/NETGEAR_D6010.cfg
- en: ./boaroot/html/NETGEAR_D3610.cfg
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: ./boaroot/html/NETGEAR_D3610.cfg
- en: ./boaroot/html/NETGEAR_D3600.cfg
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: ./boaroot/html/NETGEAR_D3600.cfg
- en: '[PRE11]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: $ **cat ./****squashfs****-root/****userfs****/****romfile.cfg**
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: $ **cat ./****squashfs****-root/****userfs****/****romfile.cfg**
- en: …
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: …
- en: <Account>
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: <Account>
- en: <Entry0 username="admin" web_passwd="password" console_passwd="password" display_mask="FF
    FF F7 FF FF FF FF FF FF" old_passwd="password" changed="1" temp_passwd="password"
    expire_time="5" firstuse="0" blank_password="0"/>
  id: totrans-72
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: <Entry0 username="admin" web_passwd="password" console_passwd="password" display_mask="FF
    FF F7 FF FF FF FF FF FF" old_passwd="password" changed="1" temp_passwd="password"
    expire_time="5" firstuse="0" blank_password="0"/>
- en: <Entry1 username="qwertyuiopqwertyuiopqwertyuiopqwertyuiopqwertyuiopqwertyuiopqwertyuiopqwertyuiopqwertyuiopqwertyuiopqwertyuiopqwertyuiopqwertyui"
    web_passwd="12345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678"
    display_mask="F2 8C 84 8C 8C 8C 8C 8C 8C"/>
  id: totrans-73
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: <Entry1 username="qwertyuiopqwertyuiopqwertyuiopqwertyuiopqwertyuiopqwertyuiopqwertyuiopqwertyuiopqwertyuiopqwertyuiopqwertyuiopqwertyui"
    web_passwd="12345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678"
    display_mask="F2 8C 84 8C 8C 8C 8C 8C 8C"/>
- en: <Entry2 username="anonymous" web_passwd="anon@localhost" display_mask="FF FF
    F7 FF FF FF FF FF FF"/>
  id: totrans-74
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: <Entry2 username="anonymous" web_passwd="anon@localhost" display_mask="FF FF
    F7 FF FF FF FF FF FF"/>
- en: </Account>
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: </Account>
- en: …
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: …
- en: '[PRE12]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: $ **git clone https://github.com/craigz28/firmwalker**
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: $ **git clone https://github.com/craigz28/firmwalker**
- en: $ **cd** **firmwalker**
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: $ **cd** **firmwalker**
- en: $ **./firmwalker.sh ../d6000/_D6000-V1.0.0.41_1.0.1.bin.extracted/****squashfs****-root/**
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: $ **./firmwalker.sh ../d6000/_D6000-V1.0.0.41_1.0.1.bin.extracted/****squashfs****-root/**
- en: '***Firmware Directory***'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '***固件目录***'
- en: ../d6000/_D6000-V1.0.0.41_1.0.1.bin.extracted/squashfs-root/
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: ../d6000/_D6000-V1.0.0.41_1.0.1.bin.extracted/squashfs-root/
- en: '***Search for password files***'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '***搜索密码文件***'
- en: '##################################### passwd'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '##################################### passwd'
- en: /usr/etc/passwd
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: /usr/etc/passwd
- en: /usr/bin/passwd
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: /usr/bin/passwd
- en: '##################################### shadow'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '##################################### shadow'
- en: '##################################### *.psk'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
- en: '***Search for Unix-MD5 hashes***'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
- en: '***Search for SSL related files***'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
- en: '##################################### *.crt'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
- en: /usr/etc/802_1X/Certificates/client.crt
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
- en: '##################################### *.pem'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
- en: /usr/etc/key.pem
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
- en: /usr/etc/802_1X/CA/cacert.pem
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
- en: /usr/etc/cert.pem
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
- en: …
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
- en: /usr/etc/802_1X/PKEY/client.key
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
- en: …
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
- en: '##################################### *.cfg'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
- en: …
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
- en: /userfs/romfile.cfg
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
- en: …
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: $ **ls -****l .****/****squashfs****-root/bin/**
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
- en: total 492
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
- en: lrwxrwxrwx 1 root root      7 Jan 24  2015 ash -> busybox
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
- en: -rwxr-xr-x 1 root root 502012 Jan 24  2015 busybox
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
- en: lrwxrwxrwx 1 root root      7 Jan 24  2015 cat -> busybox
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
- en: lrwxrwxrwx 1 root root      7 Jan 24  2015 chmod -> busybox
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
- en: …
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
- en: lrwxrwxrwx 1 root root      7 Jan 24  2015 zcat -> busybox
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: $ **file .****/****squashfs****-root/bin/****busybox**
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
- en: './squashfs-root/bin/busybox: ELF 32-bit MSB executable, MIPS, MIPS32 rel2 version
    1 (SYSV), dynamically linked, interpreter /lib/ld-uClibc.so.0, stripped'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: $ **sudo** **apt-get install** **qemu****qemu****-user** **qemu****-user-static**
    **qemu****-system-arm** **qemu****-system-****mips** **qemu-system-x86** **qemu****-utils**
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: $ **qemu-mips** **-****L .****/****squashfs****-root/** **./****squashfs****-root/bin/****zcat**
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
- en: 'zcat: compressed data not read from terminal.  Use -f to force it.'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: $ **sudo** **apt-get install** **busybox****-static** **fakeroot** **git** **dmsetup****kpartx****netcat-openbsd****nmap**
    **python-psycopg2 python3-psycopg2** **snmp****uml****-utilities util-****linux****vlan**
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
- en: $ **git clone --recursive https://github.com/firmadyne/firmadyne.git**
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: $ **sudo** **apt-get install** **postgresql**
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
- en: $ **sudo service postgresql start**
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
- en: $ **sudo** **-u** **postgres****createuser** **-P** **firmadyne**
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: $ **sudo** **-u** **postgres****createdb** **-O** **firmadyne** **firmware**
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
- en: $ **sudo** **-u** **postgres****psql** **-d firmware** **< .****/****firmadyne****/database/schema**
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: $ **cd .****/****firmadyne****; ./download.sh**
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21][PRE22]`` [PRE23]    A login prompt should appear. You should be able
    to authenticate using the set of credentials discovered in “Finding Credentials
    in Configuration Files” on page 215.    ### Dynamic Analysis    You can now use
    the firmware as though it were your host device. Although we won’t walk through
    a complete dynamic analysis here, we’ll give you some ideas of where to start.
    For example, you can list the firmware’s *rootfs* files using the `ls` command.
    Because you’ve emulated the firmware, you might discover files that were generated
    after the device booted and didn’t exist during the static analysis phase.    [PRE24]    Look
    through these directories. For example, in the *etc* directory, the */etc/passwd*
    file maintains the authentication details in Unix-based systems. You can use it
    to verify the existence of the accounts you identified during static analysis.    [PRE25]  uiopqwertyuiopqwertyuiopqwertyuiopqwertyuiopqwertyui:$1$$MJ7v7GdeVaM1xIZdZYKzL1:0:0:root:/:/bin/sh  [PRE26]    Next,
    it’s important to identify the network services and established connections, because
    you might identify services that you could use for further exploitation at a later
    stage. You can do this using the `netstat` command:    [PRE27]    The `-a` parameter
    requests listening and nonlistening network sockets (the combination of an IP
    address and a port). The `-n` parameter displays the IP addresses in a numeric
    format. The `-u` and `-t` parameters return both UDP and TCP sockets. The output
    indicates the existence of an HTTP server at port 80 and 443 that is waiting for
    connections.    To access network services from the host device, you might have
    to disable any existing firewall implementations in the firmware. On Linux platforms,
    these implementations are usually based on `iptables`, a command line utility
    that allows you to configure a list of IP packet-filter rules in the Linux kernel.
    Each rule lists certain network connection attributes, such as the used port,
    source IP address, and destination IP address, and states whether a network connection
    with those attributes should be allowed or blocked. If a new network connection
    doesn’t match any rules, the firewall uses a default policy. To disable any `iptables`-based
    firewall, change the default policies to accept all connections and then clear
    any existing rules using the following commands:    [PRE28]    Now try navigating
    to the device’s IP address using your browser to access the web app hosted by
    the firmware ([Figure 9-3](#figure9-3)).  ![f09003](Images/f09003.png)    Figure
    9-3: The firmware’s web app      You might not be able to access all of the firmware’s
    HTTP pages, because many of them require feedback from specialized hardware components,
    such as the Wi-Fi, Reset, and WPS buttons. It’s likely that FIRMADYNE won’t automatically
    detect and emulate all these components, and as a result, the HTTP server might
    crash. You might need to restart the firmware’s HTTP server multiple times to
    access certain pages. We leave this as an exercise for you to complete.    We
    won’t cover network attacks in this chapter, but you can use the information in
    Chapter 4 to identify vulnerabilities in the network stack and services. Begin
    by assessing the device’s HTTP service. For example, the source code of the publicly
    accessible page */cgi-bin/passrec.asp* contains the administrator’s password.
    Netgear has published this vulnerability at [https://kb.netgear.com/30490/CVE-2015-8289-Authentication-Bypass-Using-an-Alternate-Path-or-Channel/](https://kb.netgear.com/30490/CVE-2015-8289-Authentication-Bypass-Using-an-Alternate-Path-or-Channel/).    ##
    Backdooring Firmware    A *backdoor agent* is software hidden inside a computing
    device that allows an attacker to gain unauthorized access to the system. In this
    section, we’ll modify a firmware by adding a tiny backdoor that will execute when
    the firmware boots up, providing the attacker with a shell from the victim device.
    Also, the backdoor will allow us to perform dynamic analysis with root privileges
    in a real and functional device. This approach is extremely helpful in cases when
    FIRMADYNE can’t correctly emulate all firmware functionalities.    As a backdoor
    agent, we’ll use a simple bind shell written in C by Osanda Malith ([Listing 9-1](#listing9-1)).
    This script listens for new incoming connections to a predefined network port
    and allows remote code execution. We’ve added a `fork()` command to the original
    script to make it work in the background. This will create a new child process,
    which runs concurrently in background, while the parent process simply terminates
    and prevents the calling program from halting.    [PRE29]    Listing 9-1: A modified
    version of Osanda Malith’s backdooring script ([https://github.com/OsandaMalith/TP-Link/blob/master/bindshell.c](https://github.com/OsandaMalith/TP-Link/blob/master/bindshell.c))    Once
    executed, the script will start listening on port 9999 and execute any input received
    through that port as a system command.    To compile the backdoor agent, we first
    need to set up the compilation environment. The easiest way is to use the OpenWrt
    project’s frequently updated toolchain.    [PRE30]    By default, these commands
    will compile the firmware for the Atheros AR7 type of System on a Chip (SoC) routers,
    which are based on MIPS processors. To set a different value, click **Target System**
    and choose one of the available Atheros AR7 devices ([Figure 9-4](#figure9-4)).  ![f09004](Images/f09004.png)    Figure
    9-4: Reconfiguring the OpenWrt build target environment      Then save your changes
    to a new configuration file by clicking the **SAVE** option, and exit from the
    menu by clicking the **EXIT** option ([Figure 9-5](#figure9-5)).  ![f09005](Images/f09005.png)    Figure
    9-5: Selecting the Atheros target in the OpenWrt settings      Next, compile the
    toolchain using the `make` command:    [PRE31]    In OpenWrt’s *staging_dir/toolchain-mips_24kc_gcc-8.3.0_musl/bin/*
    folder, you’ll find the *mips-openwrt-linux-gcc* compiler, which you can use as
    follows:    [PRE32]    This should output a binary named *bindshell*. Transfer
    the binary to the emulated firmware using FIRMADYNE and verify that it works correctly.
    You can do this easily by using Python to create a mini web server in the folder
    that the binary is in:    [PRE33]    Then, in the emulated firmware, download
    the binary using the `wget` command:    [PRE34]    To verify that the backdoor
    agent works, attempt to connect to it from your host device using Netcat. An interactive
    shell should appear.    [PRE35]    At this stage, we need to patch the firmware
    so we can redistribute it. For this purpose, we can use the open source project
    *firmware-mod-kit*. Start by installing the necessary system packages using `apt-get`:    [PRE36]    Then
    use the `git` command to download the application from the GitHub repository.
    This repository hosts a forked version of the application, because the original
    is no longer maintained. The application folder contains a script named *./extract-firmware.sh*`that
    you can use to extract the firmware using a process similar to FIRMADYNE.`   [PRE37]
    [PRE38]`'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
