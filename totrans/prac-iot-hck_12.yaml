- en: '9'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Firmware Hacking
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/chapterart.png)'
  prefs: []
  type: TYPE_IMG
- en: The firmware is the software piece that links the device’s hardware layer to
    its main software layer. A vulnerability in this part of the device can have a
    tremendous impact on all the device functionalities. As a result, it’s crucial
    to identify and mitigate firmware vulnerabilities to secure IoT devices.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we explore what firmware is and how we can retrieve it and
    then analyze it for vulnerabilities. We start by finding user credentials in the
    firmware’s filesystem. Then we emulate some of the firmware’s compiled binaries,
    along with the entire firmware, to perform dynamic analysis. We also modify a
    publicly available firmware to add a backdoor mechanism and discuss how to spot
    a vulnerable firmware update service.
  prefs: []
  type: TYPE_NORMAL
- en: Firmware and Operating Systems
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Firmware is a type of software that provides communication and control over
    a device’s hardware components. It’s the first piece of code that a device runs.
    Usually, it boots the operating system and provides very specific runtime services
    for programs by communicating with various hardware components. Most, if not all,
    electronic devices have firmware.
  prefs: []
  type: TYPE_NORMAL
- en: Although firmware is a simpler and more reliable piece of software than operating
    systems, it’s also more restrictive and is designed to support only specific hardware.
    In contrast, many IoT devices run remarkably advanced, complex operating systems
    that support a large family of products. For example, IoT devices based on Microsoft
    Windows typically use operating systems such as Windows 10 IoT Core, Windows Embedded
    Industry (also known as POSReady or WEPOS), and Windows Embedded CE. IoT devices
    based on embedded Linux variants often use operating systems such as Android Things,
    OpenWrt, and Raspberry Pi OS. On the other hand, IoT devices designed to serve
    real-time applications that need to process data with specific time constraints
    and without buffer delays are usually based on real-time operating systems (RTOS),
    such as BlackBerry QNX, Wind River VxWorks, and NXP MQX mBed. Additionally, “bare-metal”
    IoT devices, designed to support simple microcontroller-based applications, typically
    execute assembly instructions directly on the hardware without advanced operating
    system scheduling algorithms to distribute the system resources. Nevertheless,
    each of these implementations has its own boot sequence with compatible bootloaders.
  prefs: []
  type: TYPE_NORMAL
- en: In less complicated IoT devices, the firmware might play the part of the operating
    system. Devices store firmware in nonvolatile memory, such as ROM, EPROM, or flash
    memory.
  prefs: []
  type: TYPE_NORMAL
- en: It’s important to examine the firmware and then attempt to modify it, because
    we can uncover many security issues during this process. Users often alter firmware
    to unlock new features or customize it. But with the same tactics, attackers can
    gain a better understanding of the system’s inner workings or even exploit a security
    vulnerability.
  prefs: []
  type: TYPE_NORMAL
- en: Obtaining Firmware
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Before you can reverse engineer a device’s firmware, you must find a way to
    gain access to it. Usually, there’s more than one method of doing so, depending
    on the device. In this section, we’ll cover the most popular firmware extraction
    methods according to the OWASP Firmware Security Testing Methodology (FSTM), which
    you can find at [https://scriptingxss.gitbook.io/firmware-security-testing-methodology/](https://scriptingxss.gitbook.io/firmware-security-testing-methodology/).
  prefs: []
  type: TYPE_NORMAL
- en: Often, the easiest way to find the firmware is to explore the vendor’s support
    site. Some vendors make their firmware available to the public to simplify troubleshooting.
    For example, the networking equipment manufacturer TP-Link provides a repository
    of firmware files from routers, cameras, and other devices on its website.
  prefs: []
  type: TYPE_NORMAL
- en: If the firmware for the specific device isn’t published, try asking the vendor
    for it. Some vendors might simply provide you with the firmware. You could directly
    contact the development team, the manufacturer, or another of the vendor’s clients.
    Make sure you always verify that the person you contacted has the vendor’s permission
    to share the firmware with you. It’s definitely worth trying to acquire a development
    and a release build. Doing so will make your testing more effective, because you’ll
    be able to see the differences between the two builds. Also, some protection mechanisms
    might be removed in the development build. For example, Intel RealSense provides
    the production and development firmware of its cameras at [https://dev.intelrealsense.com/docs/firmware-releases/](https://dev.intelrealsense.com/docs/firmware-releases/).
  prefs: []
  type: TYPE_NORMAL
- en: Sometimes you might have to build the firmware manually. This is a dreaded practice
    for some, but a solution is a solution. The firmware source code might be publicly
    accessible, especially in open source projects. In these situations, it might
    be possible to build the firmware by following manufacturer published walkthroughs
    and instructions. The OpenWrt operating system used in Chapter 6 is one such open
    source firmware project and is primarily found in embedded devices to route network
    traffic. For example, the firmware of the GL.iNet routers is based on OpenWrt.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another common approach is to explore the powerful search engines, like Google
    using Google Dorks*.* With the proper queries, you can find pretty much anything
    online. Search Google for binary file extensions hosted on file-sharing platforms,
    such as MediaFire, Dropbox, Microsoft OneDrive, Google Drive, or Amazon Drive.
    It’s common to come across firmware images uploaded by customers to message boards
    or customer and corporate blogs. Also look at the comment section of sites for
    communication between customers and manufacturers. You might find information
    about how to get the firmware, or you might even find that the manufacturer sent
    the customer a compressed file or link to download the firmware from a file-sharing
    platform. Here’s an example of a Google Dork for locating firmware files for Netgear
    devices:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The `intitle` parameter specifies text that must exist in the title of the page,
    whereas the `intext` parameter specifies text that must exist in the page content.
    This search returned the results shown in [Figure 9-1](#figure9-1).
  prefs: []
  type: TYPE_NORMAL
- en: 'In addition, don’t ignore the possibility of finding exposed cloud storage
    locations. Search Amazon S3 buckets; with enough luck, you could find the firmware
    in a vendor’s unprotected bucket. (For legal reasons, make sure the buckets weren’t
    exposed unintentionally and that the vendor has granted you permission to access
    any existing files.) The S3Scanner tool can enumerate a vendor’s Amazon S3 buckets.
    The tool is written in Python 3, which is pre-installed in Kali Linux. You can
    download the application using the `git` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '![f09001](Images/f09001.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 9-1: Discovering firmware links for Netgear devices using a Google Dork'
  prefs: []
  type: TYPE_NORMAL
- en: 'Then navigate in the *application* folder and install the required dependencies
    using the `pip3` command, which is also available in Kali Linux:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Now you can search for a vendor’s Amazon S3 buckets and enumerate which of
    them provide access to firmware:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The parameter `vendor_potential_buckets.txt` specifies a file of potential bucket
    names for the tool to try. You can create your own similar custom file and provide
    vendor names followed by popular suffixes for S3 buckets, such as `-dev`, `-development`,
    `-live`, `-staging`, and `-prod`. The tool initially outputs a warning notification
    that your AWS credentials are missing, but this is expected and you can ignore
    it. Then the tool outputs the discovered S3 buckets followed by their access status.
  prefs: []
  type: TYPE_NORMAL
- en: If the device comes with companion software, it might be worth trying the application
    analysis approach. By analyzing the device’s mobile companion apps or *thick clients*—fully
    functional computers that don’t require a network connection to operate—you might
    pick up hardcoded endpoints that the applications communicate with. One of those
    endpoints could be the one used to download the firmware automatically during
    the update process. Regardless of whether or not this endpoint is authenticated,
    you should be able to download the firmware by analyzing the clients. You can
    find a methodology for analyzing such apps in Chapter 14.
  prefs: []
  type: TYPE_NORMAL
- en: For devices that still receive updates and bug fixes from the manufacturer,
    you can often perform an effective man-in-the-middle attack during the OTA updates.
    These updates are pushed over the network channel from a central server, or clusters
    of servers, to every connected device. Depending on the complexity of the application
    logic that downloads the firmware, intercepting the traffic might be the easiest
    solution. To do that, you’ll need to have a trusted certificate installed on the
    device (assuming the transfer occurs over HTTPS) and intercept the traffic using
    a network sniffer, poisoning technique (such as ARP cache poisoning), and proxy
    that can dump binary communication to a file.
  prefs: []
  type: TYPE_NORMAL
- en: In many devices, it might also be possible to dump the firmware using the device
    bootloader. The bootloader is usually accessible in many ways, such as through
    embedded serial RS232 ports, using special keyboard shortcuts, or over the network.
    Additionally, in most consumer devices, the bootloader is programmed to allow
    flash memory read and write operations.
  prefs: []
  type: TYPE_NORMAL
- en: If the hardware contains exposed programming interfaces such as UART, JTAG,
    and SPI, try connecting to these interfaces directly to read the flash memory.
    Chapters 7 and 8 include a detailed explanation of how to spot and use these interfaces.
  prefs: []
  type: TYPE_NORMAL
- en: The last and most difficult method is to extract the firmware directly from
    either the flash chip (through SPI, for example) or the *microcontroller unit
    (MCU)*. The MCU is a single chip embedded on the device board that contains the
    CPU, memory, a clock, and a control unit. You’ll need a chip programmer to do
    this.
  prefs: []
  type: TYPE_NORMAL
- en: Hacking a Wi-Fi Modem Router
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this section, we’ll target the firmware of a very popular Wi-Fi modem router,
    the Netgear D6000\. We’ll first extract this firmware’s filesystem and search
    it for user credentials. Then we’ll emulate it for dynamic analysis.
  prefs: []
  type: TYPE_NORMAL
- en: To find this firmware, navigate to the vendor’s site and find the support page
    for the device model ([https://www.netgear.com/support/product/D6000.aspx](https://www.netgear.com/support/product/D6000.aspx)).
    You should see a list of available firmware and software downloads ([Figure 9-2](#figure9-2)).
  prefs: []
  type: TYPE_NORMAL
- en: 'Download the files. Because the firmware is in a compressed format, use the
    `unzip` command to retrieve it. You can install `unzip` using `apt-get`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '![f09002](Images/f09002.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 9-2: Netgear D6000 support page'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `wget` command is a Unix utility that downloads files from the web in a
    noninteractive way. Without any additional arguments, `wget` will save the file
    in the current working directory. The `unzip` utility then creates a folder called
    *D6000_V1.0.0.41_1.0.1_FW* that contains two files: *D6000-V1.0.0.41_1.0.1.bin*,
    which is the device firmware, and *D6000_V1.0.0.41_1.0.1_Software_Release_Notes.html*,
    which contains vendor’s notes for manually installing this firmware on the device.'
  prefs: []
  type: TYPE_NORMAL
- en: Once you’ve acquired the firmware, you can analyze it for security issues.
  prefs: []
  type: TYPE_NORMAL
- en: Extracting the Filesystem
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The firmware for most consumer-grade routers contains the device’s filesystem
    in a compressed format. Sometimes, the firmware is compressed several times using
    various algorithms (such as LZMA and LZMA2). Let’s extract this filesystem, mount
    it, and search its contents for security vulnerabilities. To locate the filesystem
    in the firmware file, use `binwalk`, which is pre-installed in Kali Linux:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The `-e` parameter extracts any identified file from the firmware, such as the
    bootloader and the filesystem. The `-M` parameter recursively scans extracted
    files and performs a signature analysis to identify file types based on common
    patterns. But beware; if `binwalk` can’t correctly identify the file types, it
    can sometimes fill up your hard disk. You should now have a new folder named *_D6000-V1.0.0.41_1.0.1.bin.extracted*
    that contains the extracted contents.
  prefs: []
  type: TYPE_NORMAL
- en: Note that we used binwalk version 2.1.2-a0c5315\. Some earlier versions couldn’t
    properly extract the filesystem. We recommend that you use the latest binwalk
    version, which is available on GitHub at [https://github.com/ReFirmLabs/binwalk/](https://github.com/ReFirmLabs/binwalk/).
  prefs: []
  type: TYPE_NORMAL
- en: Statically Analyzing the Filesystem Contents
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Now that we’ve extracted the filesystem, we can navigate through the files
    and attempt to find some useful information. A good approach is to begin by searching
    for low-hanging fruit, such as credentials stored in configuration files or outdated
    and vulnerable versions of common binaries with public advisories. Look for any
    files called *passwd* or *shadow*, which often contain information for all user
    accounts on the system, including the users’ passwords. You can do this using
    common utilities like `grep` or `find` that come pre-installed in any Unix system:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Using the `.` command, we instruct the Find tool to search the current working
    directory for the file indicated by the `-name` parameter. In this case, we’re
    looking for a file named *passwd*. As you can see, we’ve located two files with
    that name.
  prefs: []
  type: TYPE_NORMAL
- en: 'The *bin/passwd* binary file doesn’t give us useful information in its current
    form. On the other hand, the *etc/passwd* file is in a readable format. You can
    read it using the `cat` utility:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'The *etc/passwd* file contains a text-based database that lists the users who
    can authenticate to the system. Currently, there is only one entry, which is for
    the device’s administrator. The entry has the following fields, divided by colons:
    the username, the hash of the user’s password, the user identifier, the group
    identifier, extra information about the user, the path of the user’s home folder,
    and the program executed on user login. Let’s turn our attention to the password
    hash `($1$$iC.dUsGpxNNJGeOm1dFio/)`.'
  prefs: []
  type: TYPE_NORMAL
- en: Cracking the Device’s Admin Credentials
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Use `hashid` to detect the admin password’s hash type. This tool is pre-installed
    in Kali Linux, and it can identify more than 220 unique types of hashes via regular
    expressions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: According to the output, we’ve found an `MD5 Crypt` hash. Now we can try to
    crack this password using a brute-forcing tool, like john or hashcat. These tools
    cycle through a list of potential passwords, looking for one that matches the
    hash.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The `-a` parameter defines the attack mode used to guess the plaintext passwords.
    We select mode `3` to perform a brute-force attack. Mode `0` would perform a wordlist
    attack, and mode `1` would perform the *combinator attack*, which appends each
    word in a dictionary to each word in another dictionary. You could also perform
    more specialized attacks using modes 6 and 7\. For example, if you knew that the
    last character in a password was a number, you could configure the tool to try
    passwords that only end in a number.
  prefs: []
  type: TYPE_NORMAL
- en: The `-m` parameter defines the type of hash we’re trying to crack, and `500[PRE10]
  prefs: []
  type: TYPE_NORMAL
- en: $ **find .** **-name *****cfg**
  prefs: []
  type: TYPE_NORMAL
- en: ./userfs/profile.cfg
  prefs: []
  type: TYPE_NORMAL
- en: ./userfs/romfile.cfg
  prefs: []
  type: TYPE_NORMAL
- en: ./boaroot/html/NETGEAR_D6000.cfg
  prefs: []
  type: TYPE_NORMAL
- en: ./boaroot/html/romfile.cfg
  prefs: []
  type: TYPE_NORMAL
- en: ./boaroot/html/NETGEAR_D6010.cfg
  prefs: []
  type: TYPE_NORMAL
- en: ./boaroot/html/NETGEAR_D3610.cfg
  prefs: []
  type: TYPE_NORMAL
- en: ./boaroot/html/NETGEAR_D3600.cfg
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: $ **cat ./****squashfs****-root/****userfs****/****romfile.cfg**
  prefs: []
  type: TYPE_NORMAL
- en: …
  prefs: []
  type: TYPE_NORMAL
- en: <Account>
  prefs: []
  type: TYPE_NORMAL
- en: <Entry0 username="admin" web_passwd="password" console_passwd="password" display_mask="FF
    FF F7 FF FF FF FF FF FF" old_passwd="password" changed="1" temp_passwd="password"
    expire_time="5" firstuse="0" blank_password="0"/>
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: <Entry1 username="qwertyuiopqwertyuiopqwertyuiopqwertyuiopqwertyuiopqwertyuiopqwertyuiopqwertyuiopqwertyuiopqwertyuiopqwertyuiopqwertyuiopqwertyui"
    web_passwd="12345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678"
    display_mask="F2 8C 84 8C 8C 8C 8C 8C 8C"/>
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: <Entry2 username="anonymous" web_passwd="anon@localhost" display_mask="FF FF
    F7 FF FF FF FF FF FF"/>
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: </Account>
  prefs: []
  type: TYPE_NORMAL
- en: …
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: $ **git clone https://github.com/craigz28/firmwalker**
  prefs: []
  type: TYPE_NORMAL
- en: $ **cd** **firmwalker**
  prefs: []
  type: TYPE_NORMAL
- en: $ **./firmwalker.sh ../d6000/_D6000-V1.0.0.41_1.0.1.bin.extracted/****squashfs****-root/**
  prefs: []
  type: TYPE_NORMAL
- en: '***Firmware Directory***'
  prefs: []
  type: TYPE_NORMAL
- en: ../d6000/_D6000-V1.0.0.41_1.0.1.bin.extracted/squashfs-root/
  prefs: []
  type: TYPE_NORMAL
- en: '***Search for password files***'
  prefs: []
  type: TYPE_NORMAL
- en: '##################################### passwd'
  prefs: []
  type: TYPE_NORMAL
- en: /usr/etc/passwd
  prefs: []
  type: TYPE_NORMAL
- en: /usr/bin/passwd
  prefs: []
  type: TYPE_NORMAL
- en: '##################################### shadow'
  prefs: []
  type: TYPE_NORMAL
- en: '##################################### *.psk'
  prefs: []
  type: TYPE_NORMAL
- en: '***Search for Unix-MD5 hashes***'
  prefs: []
  type: TYPE_NORMAL
- en: '***Search for SSL related files***'
  prefs: []
  type: TYPE_NORMAL
- en: '##################################### *.crt'
  prefs: []
  type: TYPE_NORMAL
- en: /usr/etc/802_1X/Certificates/client.crt
  prefs: []
  type: TYPE_NORMAL
- en: '##################################### *.pem'
  prefs: []
  type: TYPE_NORMAL
- en: /usr/etc/key.pem
  prefs: []
  type: TYPE_NORMAL
- en: /usr/etc/802_1X/CA/cacert.pem
  prefs: []
  type: TYPE_NORMAL
- en: /usr/etc/cert.pem
  prefs: []
  type: TYPE_NORMAL
- en: …
  prefs: []
  type: TYPE_NORMAL
- en: /usr/etc/802_1X/PKEY/client.key
  prefs: []
  type: TYPE_NORMAL
- en: …
  prefs: []
  type: TYPE_NORMAL
- en: '##################################### *.cfg'
  prefs: []
  type: TYPE_NORMAL
- en: …
  prefs: []
  type: TYPE_NORMAL
- en: /userfs/romfile.cfg
  prefs: []
  type: TYPE_NORMAL
- en: …
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: $ **ls -****l .****/****squashfs****-root/bin/**
  prefs: []
  type: TYPE_NORMAL
- en: total 492
  prefs: []
  type: TYPE_NORMAL
- en: lrwxrwxrwx 1 root root      7 Jan 24  2015 ash -> busybox
  prefs: []
  type: TYPE_NORMAL
- en: -rwxr-xr-x 1 root root 502012 Jan 24  2015 busybox
  prefs: []
  type: TYPE_NORMAL
- en: lrwxrwxrwx 1 root root      7 Jan 24  2015 cat -> busybox
  prefs: []
  type: TYPE_NORMAL
- en: lrwxrwxrwx 1 root root      7 Jan 24  2015 chmod -> busybox
  prefs: []
  type: TYPE_NORMAL
- en: …
  prefs: []
  type: TYPE_NORMAL
- en: lrwxrwxrwx 1 root root      7 Jan 24  2015 zcat -> busybox
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: $ **file .****/****squashfs****-root/bin/****busybox**
  prefs: []
  type: TYPE_NORMAL
- en: './squashfs-root/bin/busybox: ELF 32-bit MSB executable, MIPS, MIPS32 rel2 version
    1 (SYSV), dynamically linked, interpreter /lib/ld-uClibc.so.0, stripped'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: $ **sudo** **apt-get install** **qemu****qemu****-user** **qemu****-user-static**
    **qemu****-system-arm** **qemu****-system-****mips** **qemu-system-x86** **qemu****-utils**
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: $ **qemu-mips** **-****L .****/****squashfs****-root/** **./****squashfs****-root/bin/****zcat**
  prefs: []
  type: TYPE_NORMAL
- en: 'zcat: compressed data not read from terminal.  Use -f to force it.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: $ **sudo** **apt-get install** **busybox****-static** **fakeroot** **git** **dmsetup****kpartx****netcat-openbsd****nmap**
    **python-psycopg2 python3-psycopg2** **snmp****uml****-utilities util-****linux****vlan**
  prefs: []
  type: TYPE_NORMAL
- en: $ **git clone --recursive https://github.com/firmadyne/firmadyne.git**
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: $ **sudo** **apt-get install** **postgresql**
  prefs: []
  type: TYPE_NORMAL
- en: $ **sudo service postgresql start**
  prefs: []
  type: TYPE_NORMAL
- en: $ **sudo** **-u** **postgres****createuser** **-P** **firmadyne**
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: $ **sudo** **-u** **postgres****createdb** **-O** **firmadyne** **firmware**
  prefs: []
  type: TYPE_NORMAL
- en: $ **sudo** **-u** **postgres****psql** **-d firmware** **< .****/****firmadyne****/database/schema**
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: $ **cd .****/****firmadyne****; ./download.sh**
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21][PRE22]`` [PRE23]    A login prompt should appear. You should be able
    to authenticate using the set of credentials discovered in “Finding Credentials
    in Configuration Files” on page 215.    ### Dynamic Analysis    You can now use
    the firmware as though it were your host device. Although we won’t walk through
    a complete dynamic analysis here, we’ll give you some ideas of where to start.
    For example, you can list the firmware’s *rootfs* files using the `ls` command.
    Because you’ve emulated the firmware, you might discover files that were generated
    after the device booted and didn’t exist during the static analysis phase.    [PRE24]    Look
    through these directories. For example, in the *etc* directory, the */etc/passwd*
    file maintains the authentication details in Unix-based systems. You can use it
    to verify the existence of the accounts you identified during static analysis.    [PRE25]  uiopqwertyuiopqwertyuiopqwertyuiopqwertyuiopqwertyui:$1$$MJ7v7GdeVaM1xIZdZYKzL1:0:0:root:/:/bin/sh  [PRE26]    Next,
    it’s important to identify the network services and established connections, because
    you might identify services that you could use for further exploitation at a later
    stage. You can do this using the `netstat` command:    [PRE27]    The `-a` parameter
    requests listening and nonlistening network sockets (the combination of an IP
    address and a port). The `-n` parameter displays the IP addresses in a numeric
    format. The `-u` and `-t` parameters return both UDP and TCP sockets. The output
    indicates the existence of an HTTP server at port 80 and 443 that is waiting for
    connections.    To access network services from the host device, you might have
    to disable any existing firewall implementations in the firmware. On Linux platforms,
    these implementations are usually based on `iptables`, a command line utility
    that allows you to configure a list of IP packet-filter rules in the Linux kernel.
    Each rule lists certain network connection attributes, such as the used port,
    source IP address, and destination IP address, and states whether a network connection
    with those attributes should be allowed or blocked. If a new network connection
    doesn’t match any rules, the firewall uses a default policy. To disable any `iptables`-based
    firewall, change the default policies to accept all connections and then clear
    any existing rules using the following commands:    [PRE28]    Now try navigating
    to the device’s IP address using your browser to access the web app hosted by
    the firmware ([Figure 9-3](#figure9-3)).  ![f09003](Images/f09003.png)    Figure
    9-3: The firmware’s web app      You might not be able to access all of the firmware’s
    HTTP pages, because many of them require feedback from specialized hardware components,
    such as the Wi-Fi, Reset, and WPS buttons. It’s likely that FIRMADYNE won’t automatically
    detect and emulate all these components, and as a result, the HTTP server might
    crash. You might need to restart the firmware’s HTTP server multiple times to
    access certain pages. We leave this as an exercise for you to complete.    We
    won’t cover network attacks in this chapter, but you can use the information in
    Chapter 4 to identify vulnerabilities in the network stack and services. Begin
    by assessing the device’s HTTP service. For example, the source code of the publicly
    accessible page */cgi-bin/passrec.asp* contains the administrator’s password.
    Netgear has published this vulnerability at [https://kb.netgear.com/30490/CVE-2015-8289-Authentication-Bypass-Using-an-Alternate-Path-or-Channel/](https://kb.netgear.com/30490/CVE-2015-8289-Authentication-Bypass-Using-an-Alternate-Path-or-Channel/).    ##
    Backdooring Firmware    A *backdoor agent* is software hidden inside a computing
    device that allows an attacker to gain unauthorized access to the system. In this
    section, we’ll modify a firmware by adding a tiny backdoor that will execute when
    the firmware boots up, providing the attacker with a shell from the victim device.
    Also, the backdoor will allow us to perform dynamic analysis with root privileges
    in a real and functional device. This approach is extremely helpful in cases when
    FIRMADYNE can’t correctly emulate all firmware functionalities.    As a backdoor
    agent, we’ll use a simple bind shell written in C by Osanda Malith ([Listing 9-1](#listing9-1)).
    This script listens for new incoming connections to a predefined network port
    and allows remote code execution. We’ve added a `fork()` command to the original
    script to make it work in the background. This will create a new child process,
    which runs concurrently in background, while the parent process simply terminates
    and prevents the calling program from halting.    [PRE29]    Listing 9-1: A modified
    version of Osanda Malith’s backdooring script ([https://github.com/OsandaMalith/TP-Link/blob/master/bindshell.c](https://github.com/OsandaMalith/TP-Link/blob/master/bindshell.c))    Once
    executed, the script will start listening on port 9999 and execute any input received
    through that port as a system command.    To compile the backdoor agent, we first
    need to set up the compilation environment. The easiest way is to use the OpenWrt
    project’s frequently updated toolchain.    [PRE30]    By default, these commands
    will compile the firmware for the Atheros AR7 type of System on a Chip (SoC) routers,
    which are based on MIPS processors. To set a different value, click **Target System**
    and choose one of the available Atheros AR7 devices ([Figure 9-4](#figure9-4)).  ![f09004](Images/f09004.png)    Figure
    9-4: Reconfiguring the OpenWrt build target environment      Then save your changes
    to a new configuration file by clicking the **SAVE** option, and exit from the
    menu by clicking the **EXIT** option ([Figure 9-5](#figure9-5)).  ![f09005](Images/f09005.png)    Figure
    9-5: Selecting the Atheros target in the OpenWrt settings      Next, compile the
    toolchain using the `make` command:    [PRE31]    In OpenWrt’s *staging_dir/toolchain-mips_24kc_gcc-8.3.0_musl/bin/*
    folder, you’ll find the *mips-openwrt-linux-gcc* compiler, which you can use as
    follows:    [PRE32]    This should output a binary named *bindshell*. Transfer
    the binary to the emulated firmware using FIRMADYNE and verify that it works correctly.
    You can do this easily by using Python to create a mini web server in the folder
    that the binary is in:    [PRE33]    Then, in the emulated firmware, download
    the binary using the `wget` command:    [PRE34]    To verify that the backdoor
    agent works, attempt to connect to it from your host device using Netcat. An interactive
    shell should appear.    [PRE35]    At this stage, we need to patch the firmware
    so we can redistribute it. For this purpose, we can use the open source project
    *firmware-mod-kit*. Start by installing the necessary system packages using `apt-get`:    [PRE36]    Then
    use the `git` command to download the application from the GitHub repository.
    This repository hosts a forked version of the application, because the original
    is no longer maintained. The application folder contains a script named *./extract-firmware.sh*`that
    you can use to extract the firmware using a process similar to FIRMADYNE.`   [PRE37]
    [PRE38]`'
  prefs: []
  type: TYPE_NORMAL
