<html><head></head><body>
<div id="book-content">
<div id="sbo-rt-content"><h2 class="h2" id="ch02"><span epub:type="pagebreak" id="page_15"/><strong>2 STM32F217 DFU Exit</strong></h2>&#13;
<p class="noindent">Reported privately in Goodspeed (2012) to ST Microelectronics, this chapter is the first public description of a remote code execution exploit for the STM32F217, STM32F407, and other chips in the family with mask ROM implementations of the USB device firmware update (DFU) protocol. This bug is nice because it’s so straightforward: the DFU implementation restricts access to reading and writing memory of a locked chip, but changing the target address and executing the application are both freely allowed.</p>&#13;
<p class="indent">To dump a locked chip’s memory, we’ll first use JTAG to place some shellcode into unused SRAM, then reset the chip and use DFU over USB to execute that shellcode, dumping all of memory out of the GPIO pins. The bootloader’s dialect of the DFU protocol is documented in STMicro (2010); be sure to keep that handy as you read this.</p>&#13;
<div class="image"><span epub:type="pagebreak" id="page_16"/><img id="ch2fig1" src="../images/f0016-01.jpg" alt="Image" width="777" height="722"/></div>&#13;
<p class="figcap">Figure 2.1: STM32F217</p>&#13;
<div class="image"><span epub:type="pagebreak" id="page_17"/><img id="ch2fig2" src="../images/f0017-01.jpg" alt="Image" width="579" height="611"/></div>&#13;
<p class="figcap">Figure 2.2: Simplified STM32F217 Memory Map</p>&#13;
<h3 class="h3" id="ch00lev1sec4"><span epub:type="pagebreak" id="page_18"/><strong>JTAG and Bootloaders</strong></h3>&#13;
<p class="noindent">Like most STM32 chips discussed in this book, the STM32F217 has three protection levels: 0, 1, and 2. Level 0 is unprotected, and if a device is in this level, you can simply read out the firmware and close this book. Level 2 allows no debugging of any kind, and devices in that level are often attacked by first downgrading protection to Level 1.</p>&#13;
<p class="indent">Level 1 is a middle ground, and the one you’ll most often find in production devices. In this mode, attaching a JTAG debugger will disable access to flash memory but preserve access to the CPU, to RAM, and to ROM. There is also the ability to downgrade from Level 1 to Level 0, at the cost of mass erasing flash memory and destroying whatever might be held there. Developers like this mode because failure analysis remains possible, but they are still told that their firmware will remain safe against extraction.<sup><a id="ch2fn_1" href="footnotes.xhtml#ch2fn1">1</a></sup></p>&#13;
<p class="indent">The STM32F217 also has three bootloaders in ROM, one each for accepting firmware updates by UART, USB DFU, and CAN bus. These three bootloaders share very little code with one another, and they implement the Level 1 protections in <em>software</em>, rather than relying on the hardware protections that exist when connecting a JTAG debugger. This is good for us, because it means that if we can trick any one of these three bootloaders into reading flash memory, we’ll be able to choose that bootloader and dump the chip’s firmware.</p>&#13;
<h3 class="h3" id="ch00lev1sec5"><span epub:type="pagebreak" id="page_19"/><strong>The USB DFU Bootloader</strong></h3>&#13;
<p class="noindent">This chapter’s bug is found in the DFU bootloader, which is accessed over USB. I began by writing a DFU client compatible with the chip, then used that to dump the ROM at <code>0x1fff0000</code> for reverse engineering in order to learn all the rules.<sup><a id="ch2fn_2" href="footnotes.xhtml#ch2fn2">2</a></sup></p>&#13;
<p class="indent">I’ll briefly cover the DFU protocol here, but the original documentation in Henry et al. (2004) is what you should read to really understand or implement the protocol.</p>&#13;
<p class="indent">The first thing to know is that DFU supports the following seven requests: <code>Detach</code>, <code>Download</code>, <code>Upload</code>, <code>Get Status</code>, <code>Clear Status</code>, <code>Get State</code>, and <code>Abort</code>. Addressing is handled by a block index, rather than an address, and this block index is relative to an address pointer.</p>&#13;
<p class="indent">Most high level commands are implemented by calling <code>Upload</code> or <code>Download</code>, followed by <code>Get Status</code> to learn the result of the transaction.</p>&#13;
<p class="indent">Block indexes begin at 2 for data transactions, rather than 0 or 1 as we might expect. If you upload 32 bytes to index 2, they will be written to the address pointer. Uploading 32 bytes to index 3 will write them 32 bytes after the address pointer, and uploading 64 bytes to the same index will write them 64 bytes after the address pointer.</p>&#13;
<p class="indent">An index of 1 is never used. Index 0 indicates a special block, where the first byte is one of a few secret commands. Downloading <code>[0x41]</code> will mass erase all flash memory. An empty string, <code>[]</code>, will detach the DFU session and execute the application at the target address. Downloading <code>[0x21, 0x1c, 0x32, 0x00, 0x08]</code> will set the target address pointer to <code>0x0800321c</code>. Downloading <code>[0x92]</code> will first mass erase all of memory, then also unlock the chip to RDP Level 0.<sup><a id="ch2fn_3" href="footnotes.xhtml#ch2fn3">3</a></sup></p>&#13;
<div class="image"><span epub:type="pagebreak" id="page_20"/><img id="ch2fig3" src="../images/f0020-01.jpg" alt="Image" width="731" height="626"/></div>&#13;
<p class="figcap">Figure 2.3: DFU Session, from Henry et al. (2004).</p>&#13;
<div class="image"><img id="ch2fig4" src="../images/f0020-02.jpg" alt="Image" width="757" height="140"/></div>&#13;
<p class="figcap">Figure 2.4: Zero Block DNLOAD Extensions from STMicro (2010)</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_21"/>You can lock the chip by downloading <code>[0xFF, 0xFF]</code> to target address <code>0x1fffc000</code>. In this case, the index is 2 and we are writing to the specified address, not to the special zero block.</p>&#13;
<p class="indent">Once the chip is locked to RDP Level 1, a connection to the DFU ROM is restricted in the following ways: You cannot <code>Upload</code> or <code>Download</code> except from certain special addresses. Special commands at index 0 are individually allowed or denied. Of particular interest is that you may still set the address pointer, and you may exit the DFU ROM.</p>&#13;
<h3 class="h3" id="ch00lev1sec6"><strong>The Bug</strong></h3>&#13;
<p class="noindent">After all that background information, the bug itself isn’t complicated. First, JTAG allows us to write an application into unused SRAM, where it will persist after a reset of the chip re-connects flash memory and begins to execute the DFU bootloader from ROM. Second, the DFU bootloader allows us to set the address pointer despite the lock, and when we exit the bootloader, execution continues to the application at the target of the pointer!</p>&#13;
<p class="indent">In practical terms, this means that if the address pointer is set to <code>0x20003000</code>, the bootloader will jump at exit to the value stored in <code>0x20003004</code>. This address was chosen because it happens to be in SRAM and unused by the DFU bootloader, so that it won’t be overwritten by the bootloader’s stack or global variables.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_22"/>The shellcode that we execute from SRAM is rather simple. It transmits all flash memory in a loop using the SPI protocol, with pin PG6 as MOSI and pin PG8 as CLK. This is nice and easy to capture with a logic analyzer, as shown in <a href="ch02.xhtml#ch2fig6">Figure 2.6</a>. If these pins also have LEDs, they will blink to indicate a successful exploit.</p>&#13;
<p class="indent">Because our output format is essentially SPI bus traffic, we can use a logic analyzer’s SPI decoder to extract the firmware image from the recording.</p>&#13;
<h3 class="h3" id="ch00lev1sec7"><strong>Exploitation</strong></h3>&#13;
<p class="noindent">ST Micro has patched the bug in recent revisions, so a little reverse engineering of your target’s ROM might be a good idea to verify that the bug is present. A better exploit should be possible by loading 2kB into the USB frame buffer, then executing the part of them that is not clobbered by shorter commands.</p>&#13;
<p class="indent">While this particular exploit only works from RDP Level 1, a glitching attack such as the one described in <a href="app05.xhtml#app05_5">Chapter E.5</a> can downgrade the protection from Level 2 to Level 1.</p>&#13;
<div class="image"><span epub:type="pagebreak" id="page_23"/><img id="ch2fig5" src="../images/f0023-01.jpg" alt="Image" width="823" height="996"/></div>&#13;
<p class="figcap">Figure 2.5: STM32 Shellcode</p>&#13;
<div class="image"><span epub:type="pagebreak" id="page_24"/><img id="ch2fig6" src="../images/f0024-01.jpg" alt="Image" width="1093" height="637"/></div>&#13;
<p class="figcap">Figure 2.6: STM32F217 Firmware Dump</p>&#13;
</div>
</div>
</body></html>