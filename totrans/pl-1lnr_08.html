<html><head></head><body><section class="appendix" title="Appendix&#xA0;A.&#xA0;Perl&#x2019;s Special Variables" epub:type="appendix" id="perls_special_variables"><div class="titlepage"><div><div><h2 class="title">Appendix A. Perl’s Special Variables</h2></div></div></div><p><a id="idx00033" class="indexterm"/><a id="idx00644" class="indexterm"/>In this appendix, I summarize Perl’s most commonly used special (predefined) variables, such as <code class="literal">$_</code>, <code class="literal">$.</code>, <code class="literal">$/</code>, <code class="literal">$\</code>, <code class="literal">$1</code>, <code class="literal">$2</code>, <code class="literal">$3</code> (and so on), <code class="literal">$</code>,, <code class="literal">@F</code>, and <code class="literal">@ARGV</code>, among others.</p><div class="sect1" title="A.1 Variable $_"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="a_1_variable_dollar">A.1 Variable $_</h2></div></div></div><p>The <code class="literal">$_</code> variable, called the <span class="emphasis"><em>default variable</em></span>, is the most commonly used variable in Perl. Often this variable is pronounced “it” (when not pronounced “dollar-underscore”); as you read on, you’ll understand why.</p><p>When using the <code class="literal">-n</code> and <code class="literal">-p</code> command-line arguments, it’s (see?) where the input is stored. Also, many operators and functions act on it implicitly. Here’s an example:</p><a id="I_programlisting_id315541"/><pre class="programlisting">perl -le '$_ = "foo"; print'</pre><p><a id="idx00140" class="indexterm"/><a id="idx00414" class="indexterm"/>Here, I place the string <code class="literal">"foo"</code> in the <code class="literal">$_</code> variable and then call <code class="literal">print</code>. When given no arguments, <code class="literal">print</code> prints the contents of the <code class="literal">$_</code> variable, which is <code class="literal">"foo"</code>.</p><p>Similarly, <code class="literal">$_</code> is used by the <code class="literal">s/regex/replace/</code> and <code class="literal">/regex/</code> operators when used without the <code class="literal">=~</code> operator. Consider this example:</p><a id="I_programlisting_id315603"/><pre class="programlisting">perl -ne '/foo/ &amp;&amp; print'</pre><p>This one-liner prints only lines that match <code class="literal">/foo/</code>. The <code class="literal">/foo/</code> operator implicitly operates on the <code class="literal">$_</code> variable that contains the current line. You could rewrite this as follows, but doing so would require too much typing:</p><a id="I_programlisting_id315623"/><pre class="programlisting">perl -ne 'if ($_ =~ /foo/) { print $_ }'</pre><p>“If it matches <code class="literal">/foo/</code>, print it”—you get the idea. You could also replace text in all the lines simply by calling <code class="literal">s/foo/bar/</code>:</p><a id="I_programlisting_id315639"/><pre class="programlisting">perl -pe 's/foo/bar/'</pre><p>Interestingly, Perl borrows the <code class="literal">$_</code> variable from sed. Remember that sed has a pattern space? The <code class="literal">$_</code> variable can also be called Perl’s pattern space. If you wrote the previous one-liner (<code class="literal">perl -pe 's/foo/bar/'</code>) in sed, it would look like <code class="literal">sed 's/foo/bar/'</code> because sed puts each line in the pattern space and the <code class="literal">s</code> command acts on it implicitly. Perl borrows many concepts and commands from sed.</p><div class="sect2" title="Using $_ with the -n argument"><div class="titlepage"><div><div><h3 class="title" id="using_dollar_with_the_-n_argument">Using $_ with the -n argument</h3></div></div></div><p>When using the <code class="literal">-n</code> argument, Perl puts the following loop around your program:</p><a id="I_programlisting_id315687"/><pre class="programlisting">while (&lt;&gt;) {
    # your program goes here (specified by -e)
}</pre><p>The <code class="literal">while (&lt;&gt;)</code> loop reads lines from standard input or files named on the command line and puts each line into the <code class="literal">$_</code> variable. You can then modify the lines and print them. For example, you can reverse the lines:</p><a id="I_programlisting_id315704"/><pre class="programlisting">perl -lne 'print scalar reverse'</pre><p><a id="idx00143" class="indexterm"/><a id="idx00478" class="indexterm"/>Because I’m using the <code class="literal">-n</code> argument here, this program becomes</p><a id="I_programlisting_id315731"/><pre class="programlisting">while (&lt;&gt;) {
    print scalar reverse
}</pre><p>which is equivalent to</p><a id="I_programlisting_id315738"/><pre class="programlisting">while (&lt;&gt;) {
    print scalar reverse $_
}</pre><p>The two programs are equivalent because many Perl functions act on <code class="literal">$_</code> implicitly, which makes writing <code class="literal">reverse</code> and <code class="literal">reverse $_</code> functionally the same thing. You need <code class="literal">scalar</code> to put the <code class="literal">reverse</code> function in the scalar context. Otherwise it’s in the list context (<code class="literal">print</code> forces the list context) and won’t reverse strings. (I explain the <code class="literal">-n</code> flag in great detail in one-liner 2.6 on page 12 and line reversing in one-liner 6.22 on page 67.)</p></div><div class="sect2" title="Using $_ with the -p argument"><div class="titlepage"><div><div><h3 class="title" id="using_dollar_with_the_-p_argument">Using $_ with the -p argument</h3></div></div></div><p>When you use the <code class="literal">-p</code> argument, Perl puts the following loop around your program:</p><a id="I_programlisting_id315790"/><pre class="programlisting">while (&lt;&gt;) {
    # your program goes here (specified by -e)
} continue {
    print or die "-p failed: $!\n";
}</pre><p>The result is almost the same as for the <code class="literal">-n</code> argument, except that after each iteration the content of <code class="literal">$_</code> is printed (through <code class="literal">print</code> in the <code class="literal">continue</code> block).</p><p>To reverse the lines as I did with <code class="literal">-n</code>, I can do this:</p><a id="I_programlisting_id315822"/><pre class="programlisting">perl -pe '$_ = reverse $_'</pre><p>The program now becomes:</p><a id="I_programlisting_id315830"/><pre class="programlisting">while (&lt;&gt;) {
    $_ = reverse $_;
} continue {
    print or die "-p failed: $!\n";
}</pre><p><a id="idx00257" class="indexterm"/><a id="idx00268" class="indexterm"/><a id="idx00300" class="indexterm"/><a id="idx00390" class="indexterm"/>I’ve modified the <code class="literal">$_</code> variable and set it to <code class="literal">reverse $_</code>, which reverses the line. The <code class="literal">continue</code> block makes sure that it’s printed. (One-liner 2.1 on page 7 explains the <code class="literal">-p</code> argument in more detail.)</p></div><div class="sect2" title="Using $_ explicitly"><div class="titlepage"><div><div><h3 class="title" id="using_dollar_explicitly">Using $_ explicitly</h3></div></div></div><p>The <code class="literal">$_</code> variable is also often used explicitly. Here are some examples of using the <code class="literal">$_</code> variable explicitly:</p><a id="I_programlisting_id315904"/><pre class="programlisting">perl -le '@vals = map { $_ * 2 } 1..10; print "@vals"'</pre><p>The output of this one-liner is <code class="literal">2 4 6 8 10 12 14 16 18 20</code>. Here, I use the <code class="literal">map</code> function to map an expression over each element in the given list and return a new list, where each element is the result of the expression. In this case, the list is <code class="literal">1..10</code> (<code class="literal">1 2 3 4 5 6 7 8 9 10</code>) and the expression is <code class="literal">$_ * 2</code>, which means multiply each element (“it”) by <code class="literal">2</code>. As you can see, I’m using <code class="literal">$_</code> explicitly. When the <code class="literal">map</code> function iterates over the list, each element is put into <code class="literal">$_</code> for my convenience.</p><p>Now let’s use <code class="literal">map</code> in a handy one-liner. How about one that multiplies each element on a line by 2?</p><a id="I_programlisting_id315955"/><pre class="programlisting">perl -alne 'print "@{[map { $_ * 2 } @F]}"'</pre><p>This one-liner maps the expression <code class="literal">$_ * 2</code> onto each element in <code class="literal">@F</code>. The crazy-looking <code class="literal">"@{[...]}"</code> is just a way to execute code inside quotes. (One-liner 4.2 on page 30 explains <code class="literal">@F</code>, and one-liner 4.4 on page 32 explains <code class="literal">"@{[...]}"</code>.)</p><p>Another function that explicitly uses <code class="literal">$_</code> is <code class="literal">grep</code>, which lets you filter the elements from a list. Here’s an example:</p><a id="I_programlisting_id315994"/><pre class="programlisting">perl -le '@vals = grep { $_ &gt; 5 } 1..10; print "@vals"'</pre><p>The output of this one-liner is <code class="literal">6 7 8 9 10</code>. As you can see, <code class="literal">grep</code> filtered elements greater than 5 from the list. The condition <code class="literal">$_ &gt; 5</code> asks, “Is the current element greater than 5?”—or, more succinctly, “Is it greater than 5?”</p><p>Let’s use <code class="literal">grep</code> in a one-liner. How about one that finds and prints all elements on the current line that are palindromes?</p><a id="I_programlisting_id316023"/><pre class="programlisting">perl -alne 'print "@{[grep { $_ eq reverse $_ } @F]}"'</pre><p><a id="idx00030" class="indexterm"/><a id="idx00069" class="indexterm"/><a id="idx00112" class="indexterm"/><a id="idx00251" class="indexterm"/><a id="idx00641" class="indexterm"/>The condition specified to the <code class="literal">grep</code> function here is <code class="literal">$_ eq reverse $_</code>, which asks, “Is the current element the same as its reverse?” This condition is true only for palindromes. For example, given the following input:</p><a id="I_programlisting_id316074"/><pre class="programlisting">civic foo mom dad
bar baz 1234321 x</pre><p>the one-liner outputs this:</p><a id="I_programlisting_id316081"/><pre class="programlisting">civic mom dad
1234321 x</pre><p>As you can see, all of these elements are palindromes.</p><p>You can learn even more about the <code class="literal">$_</code> variable by typing <code class="literal">perldoc perlvar</code> at the command line. The <span class="emphasis"><em>perlvar</em></span> documentation explains all the predefined variables in Perl.</p></div></div><div class="sect1" title="A.2 Variable $."><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="a_2_variable_dollar">A.2 Variable $.</h2></div></div></div><p>When reading a file, the <code class="literal">$.</code> variable always contains the line number of the line currently being read. For example, this one-liner numbers the lines in <code class="literal">file</code>:</p><a id="I_programlisting_id316125"/><pre class="programlisting">perl -lne 'print "$. $_"' <span class="emphasis"><em>file</em></span></pre><p>You can do the same thing with this one-liner, which replaces the current line with the line number followed by the same line:</p><a id="I_programlisting_id316136"/><pre class="programlisting">perl -pe '$_ = "$. $_"' <span class="emphasis"><em>file</em></span></pre><p>The <code class="literal">$.</code> variable isn’t reset across files, so to number multiple files simultaneously, you write</p><a id="I_programlisting_id316150"/><pre class="programlisting">perl -pe '$_ = "$. $_"' <span class="emphasis"><em>file1 file2</em></span></pre><p>This one-liner continues numbering lines in <code class="literal">file2</code> where <code class="literal">file1</code> left off. (If <code class="literal">file1</code> contains 10 lines, the first line of <code class="literal">file2</code> is numbered 11.)</p><p>To reset the <code class="literal">$.</code> variable, you use an explicit <code class="literal">close</code> on the current file handle <code class="literal">ARGV</code>:</p><a id="I_programlisting_id316190"/><pre class="programlisting">perl -pe '$_ = "$. $_"; close ARGV if eof' <span class="emphasis"><em>file1 file2</em></span></pre><p><a id="idx00002" class="indexterm"/><a id="idx00028" class="indexterm"/><a id="idx00117" class="indexterm"/><a id="idx00242" class="indexterm"/><a id="idx00551" class="indexterm"/><a id="idx00639" class="indexterm"/><code class="literal">ARGV</code> is a special file handle that contains the currently open file. By calling <code class="literal">eof</code>, I’m checking to see if it’s the end of the current file. If so, <code class="literal">close</code> closes it, which resets the <code class="literal">$.</code> variable.</p><p>You can change what Perl considers to be a line by modifying the <code class="literal">$/</code> variable. The next section discusses this variable.</p></div><div class="sect1" title="A.3 Variable $/"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="a_3_variable_dollar">A.3 Variable $/</h2></div></div></div><p>The <code class="literal">$/</code> variable is the input record separator, which is a newline by default. This variable tells Perl what to consider a line. Say you have this simple program that numbers lines:</p><a id="I_programlisting_id316284"/><pre class="programlisting">perl -lne 'print "$. $_"' <span class="emphasis"><em>file</em></span></pre><p>Because <code class="literal">$/</code> is a newline by default, Perl reads everything up to the first newline, puts it in the <code class="literal">$_</code> variable, and increments the <code class="literal">$.</code> variable. Next, it calls <code class="literal">print "$. $_"</code>, which prints the current line number and the line. But if you change the value of <code class="literal">$/</code> to two newlines, like <code class="literal">$/ = "\n\n"</code>, Perl reads everything up to the first two newlines; that is, it reads text paragraph by paragraph rather than line by line.</p><p>Here’s another example. If you have a file like the following, you can set <code class="literal">$/</code> to <code class="literal">:</code>, and Perl will read the file digit by digit.</p><a id="I_programlisting_id316330"/><pre class="programlisting">3:9:0:7:1:2:4:3:8:4:1:0:0:1:... (goes on and on)</pre><p>Or if you set <code class="literal">$/</code> to <code class="literal">undef</code>, Perl reads the entire file in a single read (called <span class="emphasis"><em>slurping</em></span>):</p><a id="I_programlisting_id316349"/><pre class="programlisting">perl -le '$/ = undef; open $f, "&lt;", "<span class="emphasis"><em>file</em></span>"; $contents = &lt;$f&gt;"</pre><p>This one-liner slurps the entire file <code class="literal">file</code> in variable <code class="literal">$contents</code>.</p><p>You can also set <code class="literal">$/</code> to reference an integer:</p><a id="I_programlisting_id316376"/><pre class="programlisting">$/ = \1024</pre><p>In this case, Perl reads the file 1024 bytes at a time. (This is also called <span class="emphasis"><em>record-by-record reading</em></span>.)</p><p>You can also use the <code class="literal">-0</code> command-line switch to provide this variable with a value, but note that you can’t do the record-by-record version like this. For example, to set <code class="literal">$/</code> to <code class="literal">:</code>, specify <code class="literal">-0072</code> because <code class="literal">072</code> is the octal value of the <code class="literal">:</code> character.</p><p>To remember what this variable does, recall that when quoting poetry, lines are separated by <code class="literal">/</code>.</p></div><div class="sect1" title="A.4 Variable $\"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="a_4_variable_dollar">A.4 Variable $\</h2></div></div></div><p><a id="idx00021" class="indexterm"/><a id="idx00023" class="indexterm"/><a id="idx00632" class="indexterm"/><a id="idx00634" class="indexterm"/>The dollar-backslash variable is appended after every <code class="literal">print</code> operation. For example, you could append a dot followed by a space <code class="literal">". "</code> after each <code class="literal">print</code>:</p><a id="I_programlisting_id316475"/><pre class="programlisting">perl -e '$\ = ". "; print "hello"; print "world"'</pre><p>This one-liner produces the following output:</p><a id="I_programlisting_id316484"/><pre class="programlisting">hello. world.</pre><p>Modifying this variable is especially helpful when you want to separate printouts by double newlines.</p><p>To remember this variable, just recall that you probably want to print <code class="literal">\n</code> after every line. Note that for Perl 5.10 and later, the function <code class="literal">say</code> is available, which is like <code class="literal">print</code>, except that it always adds a newline at the end and doesn’t use the <code class="literal">$\</code> variable.</p></div><div class="sect1" title="A.5 Variables $1, $2, $3, and so on"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="a_5_variables_dollar1_dollar2_dollar3_an">A.5 Variables $1, $2, $3, and so on</h2></div></div></div><p>Variables <code class="literal">$1</code>, <code class="literal">$2</code>, <code class="literal">$3</code>, and so on contain the matches from the corresponding set of capturing parentheses in the last pattern match. Here’s an example:</p><a id="I_programlisting_id316539"/><pre class="programlisting">perl -nle 'if (/She said: (.*)/) { print $1 }'</pre><p>This one-liner matches lines that contain the string <code class="literal">She said:</code> and then captures everything after the string in variable <code class="literal">$1</code> and prints it.</p><p>When you use another pair of parentheses, the text is captured in variable <code class="literal">$2</code>, and so on:</p><a id="I_programlisting_id316562"/><pre class="programlisting">perl -nle 'if (/(She|He) said: (.*)/) { print "$1: $2" }'</pre><p>In this one-liner, first either <code class="literal">"She"</code> or <code class="literal">"He"</code> is captured in variable <code class="literal">$1</code> and then anything she or he said is captured in variable <code class="literal">$2</code> and printed as <code class="literal">"$1: $2"</code>. You’ll get the same number of capture variables as you have pairs of parentheses.</p><p>To avoid capturing text in a variable, use the <code class="literal">?:</code> symbols inside the opening parenthesis. For example, changing <code class="literal">(She|He)</code> to <code class="literal">(?:She|He)</code>:</p><a id="I_programlisting_id316606"/><pre class="programlisting">perl -nle 'if (/(?:She|He) said: (.*)/) { print "Someone said: $1" }'</pre><p>will not capture <code class="literal">"She"</code> or <code class="literal">"He"</code> in variable <code class="literal">$1</code>. Instead, the second pair of parentheses captures what she or he said in variable <code class="literal">$1</code>.</p><p><a id="idx00025" class="indexterm"/><a id="idx00027" class="indexterm"/><a id="idx00231" class="indexterm"/><a id="idx00636" class="indexterm"/><a id="idx00638" class="indexterm"/>Beginning with Perl 5.10, you can use named capture groups as in <code class="literal">(?&lt;name&gt;...)</code>. When you do, instead of using variables <code class="literal">$1</code>, <code class="literal">$2</code>, and so on, you can use <code class="literal">$+{name}</code> to refer to the group. For example, this captures <code class="literal">"She"</code> or <code class="literal">"He"</code> in the named group <code class="literal">gender</code> and the said text in the named group <code class="literal">text</code>:</p><a id="I_programlisting_id316635"/><pre class="programlisting">perl -nle 'if (/(?&lt;gender&gt;She|He) said: (?&lt;text&gt;.*)/) {
  print "$+{gender}: $+{text}"
}'</pre></div><div class="sect1" title="A.6 Variable $,"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="a_6_variable_dollar">A.6 Variable $,</h2></div></div></div><p>The <code class="literal">$</code>, variable is the output field separator for <code class="literal">print</code> when printing multiple values. It’s undefined by default, which means that all items printed are concatenated together. Indeed, if you do this:</p><a id="I_programlisting_id316727"/><pre class="programlisting">perl -le 'print 1, 2, 3'</pre><p>you get <code class="literal">123</code> printed out. If you set <code class="literal">$</code>, to a colon, however:</p><a id="I_programlisting_id316742"/><pre class="programlisting">perl -le '$,=":"; print 1, 2, 3'</pre><p>you get <code class="literal">1:2:3</code>.</p><p>Now, suppose you want to print an array of values. If you do this:</p><a id="I_programlisting_id316757"/><pre class="programlisting">perl -le '@data=(1,2,3); print @data'</pre><p>the output is <code class="literal">123</code>. But if you quote the variable, the values are space separated:</p><a id="I_programlisting_id316768"/><pre class="programlisting">perl -le '@data=(1,2,3); print "@data"'</pre><p>So the output is <code class="literal">1 2 3</code> because the array is interpolated in a double-quoted string.</p></div><div class="sect1" title="A.7 Variable $”"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="a_7_variable_dollar">A.7 Variable $”</h2></div></div></div><p>This brings us to the <code class="literal">$"</code> variable: a single white space (by default) that’s inserted between every array value when it’s interpolated. When you write things like <code class="literal">print "@data"</code>, the <code class="literal">@data</code> array gets interpolated, and the value of <code class="literal">$"</code> is inserted between every array element. For example, this prints <code class="literal">1 2 3</code>:</p><a id="I_programlisting_id316814"/><pre class="programlisting">perl -le '@data=(1,2,3); print "@data"'</pre><p><a id="idx00014" class="indexterm"/><a id="idx00018" class="indexterm"/><a id="idx00050" class="indexterm"/><a id="idx00068" class="indexterm"/><a id="idx00074" class="indexterm"/><a id="idx00122" class="indexterm"/><a id="idx00217" class="indexterm"/><a id="idx00222" class="indexterm"/><a id="idx00557" class="indexterm"/><a id="idx00623" class="indexterm"/><a id="idx00627" class="indexterm"/><a id="idx00630" class="indexterm"/>But if you change <code class="literal">$"</code> to, say, a dash <code class="literal">-</code>, the output becomes <code class="literal">1-2-3</code>:</p><a id="I_programlisting_id316913"/><pre class="programlisting">perl -le '@data=(1,2,3); $" = "-"; print "@data"'</pre><p>Recall the <code class="literal">@{[...]}</code> trick here. If you <code class="literal">print "@{[...]}"</code>, you can execute code placed between the square brackets. For examples and more details, see section <a class="xref" href="apa.html#a_1_variable_dollar" title="A.1 Variable $_">A.1 Variable $_</a>’s discussion of the <code class="literal">$_</code> variable on page 95 and one-liner 4.4 on page 32.</p></div><div class="sect1" title="A.8 Variable @F"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="a_8_variable_commatf">A.8 Variable @F</h2></div></div></div><p>The <code class="literal">@F</code> variable is created in your Perl program when you use the <code class="literal">-a</code> argument, which stands for auto-split fields. When you use <code class="literal">-a</code>, the input is split on whitespace characters and the resulting fields are put in <code class="literal">@F</code>. For example, if the input line is <code class="literal">foo bar baz</code>, then <code class="literal">@F</code> is an array <code class="literal">("foo", "bar", "baz")</code>.</p><p>This technique allows you to operate on individual fields. For instance, you can access <code class="literal">$F[2]</code> to print the third field as follows (remembering that arrays start from index 0):</p><a id="I_programlisting_id316988"/><pre class="programlisting">perl -ane 'print $F[2]'</pre><p>You can also perform various calculations, like multiplying the fifth field by 2:</p><a id="I_programlisting_id316996"/><pre class="programlisting">perl -ane '$F[4] *= 2; print "@F"'</pre><p>Here, the fifth field <code class="literal">$F[4]</code> is multiplied by 2, and <code class="literal">print "@F"</code> prints all the fields, separated by a space.</p><p>You can also use the <code class="literal">-a</code> argument with the <code class="literal">-F</code> argument, which specifies the character to split on. For example, to process the colon-separated entries in <span class="emphasis"><em>/etc/passwd</em></span> entries, you write</p><a id="I_programlisting_id317027"/><pre class="programlisting">perl -a -F: -ne 'print $F[0]' /etc/passwd</pre><p>which prints the usernames from <span class="emphasis"><em>/etc/passwd</em></span>.</p></div><div class="sect1" title="A.9 Variable @ARGV"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="a_9_variable_commatargv">A.9 Variable @ARGV</h2></div></div></div><p>The <code class="literal">@ARGV</code> variable contains the arguments that you pass to your Perl program. For example, this prints <code class="literal">foo bar baz</code>:</p><a id="I_programlisting_id317059"/><pre class="programlisting">perl -le 'print "@ARGV"' foo bar baz</pre><p><a id="idx00045" class="indexterm"/><a id="idx00277" class="indexterm"/><a id="idx00592" class="indexterm"/><a id="idx00645" class="indexterm"/>When you use <code class="literal">-n</code> or <code class="literal">-p</code> flags, the arguments that you pass to your Perl program are opened one by one as files and removed from <code class="literal">@ARGV</code>. To access the filenames passed to your program, save them in a new variable in the <code class="literal">BEGIN</code> block:</p><a id="I_programlisting_id317110"/><pre class="programlisting">perl -nle 'BEGIN { @A = @ARGV }; ...' <span class="emphasis"><em>file1 file2</em></span></pre><p>Now you can use <code class="literal">@A</code> in your program, which contains <code class="literal">("file1", "file2")</code>. If you didn’t do this and you used <code class="literal">@ARGV</code>, it would contain <code class="literal">("file2")</code> at first, but when <code class="literal">file1</code> was processed, it would be empty <code class="literal">()</code>. Be careful here!</p><p>A similar-looking variable, <code class="literal">$ARGV</code>, contains the filename of the file currently being read, which is <code class="literal">"-"</code> if the program is currently reading from the standard input.</p></div><div class="sect1" title="A.10 Variable %ENV"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="a_10_variable_percntenv">A.10 Variable %ENV</h2></div></div></div><p>The <code class="literal">%ENV</code> hash contains environment variables from your shell. This variable comes in handy when you wish to predefine some values in your script and then use these values in your Perl program or one-liner.</p><p>Say you want to use the <code class="literal">system</code> function to execute a program that’s not in the path. You could modify the <code class="literal">$ENV{PATH}</code> variable and append the needed path:</p><a id="I_programlisting_id317186"/><pre class="programlisting">perl -nle '
  BEGIN { $ENV{PATH} .= ":/usr/local/yourprog/bin" }
  ...
  system("yourprog ...");
'</pre><p>This one-liner prints all environment variables from Perl:</p><a id="I_programlisting_id317194"/><pre class="programlisting">perl -le 'print "$_: $ENV{$_}" for keys %ENV'</pre><p>It loops over the keys (environment variable names) of the <code class="literal">%ENV</code> hash, puts each key into the <code class="literal">$_</code> variable, and then prints the name followed by <code class="literal">$ENV{$_}</code>, which is the value of the environment variable.</p></div></section></body></html>