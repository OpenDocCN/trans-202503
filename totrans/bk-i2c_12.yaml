- en: '9'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Raspberry Pi (and Linux) I²C Programming
  prefs: []
  type: TYPE_NORMAL
- en: '![](image_fi/book_art/chapterart.png)'
  prefs: []
  type: TYPE_IMG
- en: After the Arduino, the Raspberry Pi probably ranks second highest in I²C bus
    usage. In some respects, the I²C bus is probably even more important to Raspberry
    Pi hardware hackers than Arduino users because the Pi provides nothing in the
    way of analog-to-digital converters. Most often, Pi users add such capabilities
    to their systems using the I²C bus.
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter discusses the following:'
  prefs: []
  type: TYPE_NORMAL
- en: The I²C bus on the Raspberry Pi’s GPIO header
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to activate the I²C bus on the Raspberry Pi (by default, it is deactivated)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to set the I²C bus speed, which may be necessary for slow peripherals as
    the Pi does not support clock stretching
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to use the I²C utility package on the Pi
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Programming I²C devices on the Pi
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: I²C on other Linux-based systems
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A bit-banging implementation of I²C on the Raspberry Pi to overcome some of
    the Pi’s limitations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Although this chapter specifically discusses the Raspberry Pi single-board computer,
    Pi OS is really just a variant of the Linux operating system, so much of the information
    in this chapter covers generic Linux systems as well as the Raspberry Pi.
  prefs: []
  type: TYPE_NORMAL
- en: 9.1 The I²C Bus Pins on the Pi General-Purpose Input/Output Header
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Raspberry Pi has always supported at least one I²C bus on the GPIO connector.
    Pins 3 and 5 (GPIO 2 and GPIO 3) provide the SDA and SCL lines, respectively.
    These pins were available on the original 26-pin GPIO header.
  prefs: []
  type: TYPE_NORMAL
- en: After the introduction of the Raspberry Pi B+, the GPIO header was extended
    to 40 pins, and a second hardware I²C bus was added. This second I²C bus (on pins
    27 and 28 of the 40-pin header; see [Figure 9-1](#figure9-1)) was originally intended
    to connect to EEPROM devices on Pi HATs—Raspberry Pi add-on boards whose name
    stands for “hardware attached on top.” The I²C EEPROM device provided identification
    information for the board so the operating system could identify it and load an
    appropriate device driver in a “plug-and-play” fashion.
  prefs: []
  type: TYPE_NORMAL
- en: The second I²C lines were originally intended for EEPROM, camera, and DSI display
    use. Enabling these lines could cause the display, camera, and HAT units to malfunction,
    so most programmers and system designers leave these lines alone. However, if
    you are not using any of these devices, you could use the I²C bus on pins 27 and
    28 for your own purposes.
  prefs: []
  type: TYPE_NORMAL
- en: Technically, there is a third I²C bus on the HDMI connector (a 5-V variant to
    support VESA E-DDC). In theory, you could use it with a bit of work. However,
    this book will not consider the use of that bus as it’s really intended for use
    by the video display subsystem.
  prefs: []
  type: TYPE_NORMAL
- en: '![](image_fi/502468c09/f09001.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 9-1: Main and alternate (HAT EEPROM) I²C pins on Raspberry Pi bus'
  prefs: []
  type: TYPE_NORMAL
- en: With the arrival of the Raspberry Pi 4, the number of possible I²C buses increased
    yet again. [Figure 9-2](#figure9-2) shows the pinout of the 40-pin GPIO connector
    on the Raspberry Pi 4.
  prefs: []
  type: TYPE_NORMAL
- en: '![](image_fi/502468c09/f09002.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 9-2: Raspberry Pi 4 GPIO pinout'
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 9-2](#figure9-2) shows six I²C buses on the Raspberry Pi 4:'
  prefs: []
  type: TYPE_NORMAL
- en: i2c-0 SDA0 and SCL0 on pins 27 and 28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: i2c-1 SDA1 and SCL1 on pins 3 and 5
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: i2c-3 SDA3 and SCL3 on pins 7 and 29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: i2c-4 SDA4 and SCL4 on pins 31 and 26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: i2c-5 SDA5 and SCL5 on pins 32 and 33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: i2c-6 SDA6 and SCL6 on pins 15 and 16 (shares these pins with i2c-0)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note that the i2c-1 bus on the Raspberry Pi provides pullup resistors to +3.3
    V. The remaining I²C ports do not. Therefore, if you activate any I²C bus other
    than i2c-1, you will need to add pullup resistors for the bus to work properly.
  prefs: []
  type: TYPE_NORMAL
- en: 9.2 Manually Activating the I²C Buses
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: By default, the Raspberry Pi OS does not enable any of the I²C buses on the
    GPIO connector—those pins default to their GPIO pin definitions. You can use the
    raspi-config application to activate the I²C bus. This application will automatically
    edit appropriate system files to activate the I²C bus. If you would like to manually
    make these changes yourself, you must edit a couple files on the Raspberry Pi
    to enable the appropriate I²C bus(es).
  prefs: []
  type: TYPE_NORMAL
- en: 'If you want to activate i2c-1, you will need to edit the */boot/config.txt*
    text file as the superuser. In this file you will usually find the following line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The `#` at the beginning of this statement turns the whole line into a comment,
    making the statement invisible to the system and the I²C bus inactivated. To activate
    the I²C bus, simply delete the `#` character at the beginning of the line.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `i2c_arm` label tells you that this particular I²C port is part of the
    ARM processor (the CPU on the Raspberry Pi). The second I²C port (pins 27 and
    28, which is really Linux port i2c-0) is part of the video controller chip. You
    could activate that I²C bus with the following statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: However, the Raspberry Pi documentation is pretty clear that i2c-0 is reserved
    for HAT EEPROMs and you are not supposed to use it for other purposes (see [https://github.com/raspberrypi/hats/blob/master/designguide.md](https://github.com/raspberrypi/hats/blob/master/designguide.md)).
    Abuse this suggestion at your own risk.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you edit the `dtparam=i2c_arm=on` statement in */boot/config.txt* and reboot,
    you’ll discover that the I²C bus is still not available. This is because Raspberry
    Pi OS uses loadable kernel modules (LKMs) to handle I²C processing. At this point
    the system hasn’t loaded the appropriate module. To do that, execute the following
    two commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Of course, manually loading these modules every time you boot the system can
    get old fast if you’re using the I²C all the time. If you edit the */etc/modules*
    file as superuser and add the following two lines to the file, the system will
    automatically load those modules when you boot the system:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'If you have a Raspberry Pi 4 system, you can enable additional I²C buses by
    adding one or more of the following lines to the */boot/config.txt* text file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The pin numbers to which the `pins``_xx_yy` parameters refer are the GPIO pin
    numbers, not the physical pin numbers on the Pi 40-pin connector. [Table 9-1](#table9-1)
    lists the correspondence between GPIO pin numbers and physical pin numbers. See
    [https://www.raspberrypi.com/documentation/computers/os.xhtml#gpio-and-the-40-pin-header](https://www.raspberrypi.com/documentation/computers/os.xhtml#gpio-and-the-40-pin-header)
    for more information.
  prefs: []
  type: TYPE_NORMAL
- en: 'Table 9-1: GPIO Pins to Physical Pin Numbers'
  prefs: []
  type: TYPE_NORMAL
- en: '| **GPIO pin number** | **Connector pin number** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| GPIO 2 | Board pin 3 |'
  prefs: []
  type: TYPE_TB
- en: '| GPIO 3 | Board pin 5 |'
  prefs: []
  type: TYPE_TB
- en: '| GPIO 4 | Board pin 7 |'
  prefs: []
  type: TYPE_TB
- en: '| GPIO 5 | Board pin 29 |'
  prefs: []
  type: TYPE_TB
- en: '| GPIO 6 | Board pin 31 |'
  prefs: []
  type: TYPE_TB
- en: '| GPIO 7 | Board pin 26 |'
  prefs: []
  type: TYPE_TB
- en: '| GPIO 12 | Board pin 32 |'
  prefs: []
  type: TYPE_TB
- en: '| GPIO 13 | Board pin 33 |'
  prefs: []
  type: TYPE_TB
- en: '| GPIO 22 | Board pin 15 |'
  prefs: []
  type: TYPE_TB
- en: '| GPIO 23 | Board pin 16 |'
  prefs: []
  type: TYPE_TB
- en: 'Finally, make sure the following line is present in *config.txt*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: In theory, enabling the UART (serial port) shouldn’t have anything to do with
    I²C on the Pi. In practice (at least on a Pi 3), if you don’t include this line,
    the system will run the SCL line at about 65 kHz rather than the nominal 100 kHz.
  prefs: []
  type: TYPE_NORMAL
- en: 9.3 Changing the I²C Clock Frequency
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'By default, Raspberry Pi sets the I²C clock frequency to 100 kHz. To change
    the speed of the main I²C bus (i2c-1), use the following statement in */boot/config.txt*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: where `xxxxxx` stands for the clock frequency (for example, `100000`) that you
    want to use. Normally, you would place this statement immediately after `dtparam=i2c_arm=on`
    in that file.
  prefs: []
  type: TYPE_NORMAL
- en: The Raspberry Pi OS will choose an available clock frequency that is less than
    or equal to the value you specify.
  prefs: []
  type: TYPE_NORMAL
- en: 'On the Raspberry Pi 4, you can set the clock frequency of i2c-3, -4, -5, and
    -6 using the following statements:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Once again, Pi OS will choose a clock frequency that is less than or equal to
    the actual value you specify.
  prefs: []
  type: TYPE_NORMAL
- en: 9.4 I²C Clock Stretching Issues and Solutions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'At the time of writing, there has long been a known issue with the I²C protocol
    on the Raspberry Pi: the Pi does not support clock stretching. This issue seems
    to be with the hardware; it’s been around so long (and across many different Raspberry
    Pi models) that you’d expect it to have been fixed by now if it were software.
    The bottom line is that if you have an I²C device that depends on adding wait
    states via clock stretching, that device may not work very well on a standard
    Pi I²C setup.'
  prefs: []
  type: TYPE_NORMAL
- en: 'This problem has two solutions. The first is a big kludge: reduce the SCL clock
    frequency using the techniques from the previous section, hoping to slow the clock
    down enough that the clock period provides enough time for the peripheral to do
    its thing. Adafruit, for example, suggests setting the I²C clock frequency (*baudrate*
    in *config.txt* notation) to 10 kHz. Ideally, this is so slow that it gives your
    peripherals sufficient time to process the I²C data.'
  prefs: []
  type: TYPE_NORMAL
- en: Slowing down the clock frequency is unsatisfactory for two main reasons. First,
    there is no guarantee that the new, slower clock frequency provides enough time
    for an arbitrary peripheral to do its work. Second, this technique slows down
    all bit transfers, including those to and from peripherals that don’t use clock
    stretching as well as all the bits that don’t need clock stretching on the devices
    that use it. In sum, this approach doesn’t guarantee success and is very inefficient
    to boot.
  prefs: []
  type: TYPE_NORMAL
- en: The second solution is to use a *bit-banging* (software) I²C transmission. Software
    I²C processing can handle bit stretching properly. True, bit-banging is much slower
    and less efficient than a hardware implementation, but probably no more so than
    slowing down the hardware SCL frequency.
  prefs: []
  type: TYPE_NORMAL
- en: 'To set up a software-controlled I²C bus using (arbitrary) GPIO pins, add the
    following statement to your */boot/config.txt* file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: where `x` represents a bus number, and `y` and `z` represent GPIO pins on the
    Raspberry Pi GPIO connector. This creates an I²C device using the name `i2c-``x`
    that operates on the specified GPIO pins (these are the GPIO pin number designations,
    not the physical pin numbers on the Pi GPIO connector).
  prefs: []
  type: TYPE_NORMAL
- en: If the `i2c_gpio_sda` parameter is not present, the system will use GPIO 23
    as the default (physical pin 16 on the connector). If the `i2c_gpio_scl` parameter
    is not present, the system will use GPIO 24 (physical pin 18) as the default.
    If the `bus` parameter is not present, the system will dynamically assign a device
    number, so you really should explicitly provide the `bus` argument.
  prefs: []
  type: TYPE_NORMAL
- en: Note that the i2c-gpio device can use any arbitrary GPIO pins; you don’t have
    to specify pins that have I²C hardware associated with them. This means you can
    actually increase the number of supported I²C buses in the system by using software-based
    I²C devices (though, to be honest, if you need additional I²C buses, an I²C multiplexer
    is probably a better solution).
  prefs: []
  type: TYPE_NORMAL
- en: As a general rule, I would advise putting all I²C devices that depend on clock
    stretching on an i2c-gpio device and place all other I²C devices on hardware-based
    I²C buses to make your system more efficient.
  prefs: []
  type: TYPE_NORMAL
- en: 9.5 Raspberry Pi OS (Linux) I²C Utilities
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Several I²C-specific utilities are useful on the Raspberry Pi. In addition to
    these, a few normal Linux and Raspberry Pi commands are also of interest when
    working with I²C devices.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, to determine whether the I²C device drivers are even operational, enter
    the following Linux command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'This command lists all the Linux I²C devices you can currently access. For
    example, on my Raspberry Pi 4, I got the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: which tells me that I²C interface 1 (i2c-1, on pins 3 and 5) and I²C interface
    6 (i2c-6, on pins 15 and 16) are currently active. Before even attempting to run
    an application that uses the I²C signals, you should issue this command to verify
    that the I²C buses are functioning.
  prefs: []
  type: TYPE_NORMAL
- en: 'The remaining four utilities I will discuss in this section are part of the
    i2c-tools package. Originally, Raspberry Pi OS did not include these tools by
    default, though later versions of Pi OS seem to include them. If they are not
    present on your system, you must download them using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: This installs the four programs, `i2cdetect`, `i2cdump`, `i2cget`, and `i2cset`,
    on your system. The `i2cdump` utility is mainly useful for viewing the contents
    of I²C EEPROM devices. We won’t consider that application any further here; see
    the Linux man page for more information about this code.
  prefs: []
  type: TYPE_NORMAL
- en: The `i2cget` and `i2cset` programs allow you to read a byte or word from certain
    I²C devices or write a byte or word to certain I²C devices. Because of the way
    they operate, they will prove to be of marginal value to us in this chapter. Both
    applications assume that they write a register number to the I²C address followed
    by additional data to write to that register (in the case of `i2cset`) or that
    they write a register number and then read data from the specified register number
    (in the case of `i2cget`). This works well for I²C devices such as the MCP23017
    GPIO expander IC. It does not work well for devices such as the MCP4725 DAC we’re
    using as an example in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'To run the `i2cget` application, enter the following (the items in braces are
    optional):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: where `i2cbus` is the number of an active I²C bus (such as *1* for *i2c-1*),
    `device_address` is the 7-bit I²C address of the device to read from, `register`
    is an 8-bit register number (specifying a particular register on the device),
    and `mode` is one of the letters `b`, `w`, or `c` (corresponding to byte, word,
    or R/W byte, respectively). If the `register` operand is present, this command
    will place the I²C address on the bus and write the `register` value to the I²C
    address. On a device such as the MCP23017, this sets the register inside the IC
    to read. The next operation is a read operation, with the system reading the specified
    register value from the IC. In the case of the MCP4725, there are no registers
    you can select by first writing a byte to the IC, so you should never specify
    the `register` argument when using this command. Doing so will write a value to
    the MCP4725 and affect the analog output.
  prefs: []
  type: TYPE_NORMAL
- en: Unfortunately, the `i2cget` application is poorly matched to the MCP4725\. The
    MCP4725 returns 5 bytes of data when you read from the chip. The `i2cget` command
    will read a maximum of 2 bytes. There is no real way to use this command to read
    all the MCP4725 data, so we will ignore this command until Chapter 13.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `i2cset` command is the output version of the `i2cget` program. It has
    the following syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'where `i2cbus` and `device_address` have the same meanings as for the `i2cget`
    command. The `data_address` argument is effectively the same thing as the `register`
    operand in the `i2cget` command: it’s a byte value that is written to the IC immediately
    after the address byte is placed on the bus with the assumption that this is selecting
    some register on the IC.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Again, the fact that it expects to be able to write a register (`data_address`)
    makes this program somewhat incompatible with the MCP4725 DAC. However, with some
    hackery, this one can actually be made to work with the DAC. The MCP4725 expects
    a 3-byte transmission (for the Fast Mode Write command). The first byte, of course,
    is the address and R/W bit, the second byte is the HO 4 bits of the 12-bit DAC
    value, and the third byte is the LO 8 bits of the DAC value. As it turns out,
    the `i2cset` command can be coerced to output this data using the following syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: where `HOByte` is the upper 4 bits of the DAC output value and `LOByte` is the
    lower 8 bits of the DAC value.
  prefs: []
  type: TYPE_NORMAL
- en: Of the four utilities in the i2c-tools package, the `i2cdetect` program is,
    without question, the most useful of the batch. As its name suggests, this program
    detects I²C devices on the I²C bus. This program has three main forms, which the
    following paragraphs describe.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'The first form scans the system for all available I²C buses and displays them.
    Note that the command-line option is `l` (the letter L, for *list*), not `1` (one).
    This command is similar to using `ls /dev/i2c*` to identify available I²C buses.
    Executing this command on a Raspberry Pi 3 with I²C enabled, I get the following
    output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'The second form of the `i2cdetect` command outputs status and capability information
    about the I²C bus you specify as an argument:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Here’s some sample output on the Raspberry Pi for `i2c-1`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: For a description of these Linux-kernel level functionalities, visit [https://www.kernel.org/doc/html/latest/i2c/functionality.xhtml](https://www.kernel.org/doc/html/latest/i2c/functionality.xhtml).
  prefs: []
  type: TYPE_NORMAL
- en: 'The third form of the `i2cdetect` command scans the bus looking for valid I²C
    devices and (if possible) reports their presence:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: where `bus` is an I²C bus specification (either an integer such as `1` or the
    bus name such as `i2c-1`). The optional `first` and `last` parameters are device
    addresses (with `first` < `last`) that limit the range of I²C bus addresses that
    `i2cdetect` will scan.
  prefs: []
  type: TYPE_NORMAL
- en: 'Generally, use the command as follows or supply a different bus value as the
    argument:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: After entering the command, you’ll get a warning prompt that this command may
    mess with I²C devices on the bus. Knowing this, you’ll be asked to verify that
    you want the command to probe the bus.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you would prefer not to respond to this prompt when running `i2cdetect`
    (for example, from within a shell script), add the `-y` option, which tells the
    program “answer yes to the question”:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: This matrix shows the valid I²C addresses and whether `i2cdetect` has found
    a device at that address. The `--` entries indicate that `i2cdetect` doesn’t believe
    a device is at that address, and a hexadecimal number in the matrix indicates
    that a device exists at that address. In this case, `i2cdetect` found two devices
    at addresses 0x04 (probably the Broadcom I²C hardware, as that address is reserved
    for high-speed controllers) and 0x62 (the Adafruit MCP4725 I currently have wired
    to the bus).
  prefs: []
  type: TYPE_NORMAL
- en: If a `UU` appears in one of the matrix entries, a device is installed at that
    address but is currently in use by the kernel, which commonly occurs, for example,
    when you’ve hooked a real-time clock (RTC) to the system to set the date and time
    automatically when the system boots.
  prefs: []
  type: TYPE_NORMAL
- en: As noted in Chapter 2, the I²C bus does not provide a standardized mechanism
    for detecting devices. SMBus devices, in particular, can react in a bad way with
    simple attempts to read or write the device without a data payload. Therefore,
    it is possible for the `i2cdetect` program to change the state of an I²C device
    on the bus just by probing for it, which is why `i2cdetect` asks you to verify
    that you really want to scan the bus before it transmits data.
  prefs: []
  type: TYPE_NORMAL
- en: 'Because `i2cdetect` can mess with certain types of peripherals on the bus,
    it offers an option to limit the scanning to a certain range of addresses. For
    example, if you know an MCP4725 DAC is installed but don’t know what address it’s
    connected to, use the following command to search for the DAC:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: The `0x60` and `0x67` arguments limit the scanning range of the program (we
    know that the MCP4725 must have an address in the range of 0x60 to 0x67 because
    of its hardware design).
  prefs: []
  type: TYPE_NORMAL
- en: The `-q` (quick write) and `-r` (quick read) arguments are advanced options,
    and using those options can corrupt EEPROMs or hang the system. See the `i2cdetect`
    man page for details and seriously consider what you are doing before using those
    options.
  prefs: []
  type: TYPE_NORMAL
- en: 9.6 Reading and Writing I²C Data
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Once you have installed and initialized the I²C drivers, transmitting and receiving
    data on the I²C bus is relatively straightforward. Like most devices, Raspberry
    Pi OS (Linux) treats the I²C bus like a file. You open the device driver as a
    file and then read and write data using the Linux `read()` and `write()` functions.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, call the Linux `open()` function to get a file handle associated with
    the I²C bus:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: where `handle` is an integer (file descriptor) type and `busName` is a string
    containing the device name for the I²C bus you want to use. Bus names are the
    */dev/i2c** names for the buses you’ve defined in the */boot/config.txt* file.
    For example, the standard I²C bus is */dev/i2c-1*.
  prefs: []
  type: TYPE_NORMAL
- en: The `open()` function returns a negative number on an error and a non-negative
    file handle value if it is successful. Save the file handle value so you can read
    and write data later.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before accessing the I²C bus, you must set the address of the peripheral device
    you want to access using the Linux `ioctl()` (I/O control) function, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: where `result` is an integer variable that holds the error return result, `handle`
    is the handle the `open()` function call returns, and `i2cAddr` is the 7-bit address
    of the peripheral to access.
  prefs: []
  type: TYPE_NORMAL
- en: You can call `ioctl()` multiple times on the same file handle in order to access
    different peripherals on the same I²C bus. Raspberry Pi OS will continue to use
    the same peripheral address for all read and write operations until you explicitly
    change it.
  prefs: []
  type: TYPE_NORMAL
- en: 'To read data from an I²C peripheral, you use the Linux `read()` function using
    the following syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: where `result` is an integer variable that will hold the function return result
    (a negative if an error or number of bytes read if non-negative), `handle` is
    the I²C bus handle returned by `open()`, `buffer` is an array of bytes that will
    receive the data, and `bufferSize` is the number of bytes to read. If everything
    happens correctly, the function returns `bufferSize` as the result.
  prefs: []
  type: TYPE_NORMAL
- en: 'To write data to the peripheral, use the `write` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: The arguments are the same as for `read()` except the buffer holds the data
    to be written (rather than being a storage location for the data read).
  prefs: []
  type: TYPE_NORMAL
- en: The program in [Listing 9-1](#listing9-1) demonstrates reading and writing data
    on the I²C bus using the `open()`, `read()`, `write()`, and `ioctl()` functions.
    As in the previous chapter, this program emits a triangle wave on the MCP4725
    DAC outputs.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: In [Listing 9-1](#listing9-1), the Linux filename for the main Raspberry Pi
    I²C port is `"/dev/i2c-1"` ❶. To write to the Raspberry Pi I²C port, open it like
    a file ❷. To read or write a particular I²C address, you must first issue an `ioctl()`
    call with the `I2C_SLAVE` argument and the I²C address to use. From that point
    forward (until another `ioctl()` call changes the address), reads and writes to
    the I²C bus will use this address ❸. To read data from the I²C bus, just call
    the `read()` function specifying the file handle returned by the earlier `open()`
    call for the I²C port ❹. To write data to the I²C bus, call the `write()` function
    and specify the I²C file handle ❺.
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 9-3](#figure9-3) shows the DAC output on an oscilloscope.'
  prefs: []
  type: TYPE_NORMAL
- en: '![](image_fi/502468c09/f09003.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 9-3: Triangle wave output from Raspberry Pi 3'
  prefs: []
  type: TYPE_NORMAL
- en: The output is only 3.3 V (rather than 5 V) because the Pi is a 3.3-V machine
    (I’m running the MCP4725 at 3.3 V, though you could run it at 5 V as long as the
    SCL and SDA lines are 3.3 V).
  prefs: []
  type: TYPE_NORMAL
- en: 9.7 Advanced I²C Kernel Calls
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Although using `open()`, `read()`, `write()`, and `ioctl()` works reasonably
    well for simple I²C bus transactions, various forms of the `ioctl()` function
    provide more advanced operations called *kernel function calls*.
  prefs: []
  type: TYPE_NORMAL
- en: 'The kernel function calls take place through the Linux `ioctl()` API function.
    You marshal up some parameters in a data structure along with a function identifier
    and call `ioctl()`. The `ioctl()` function decodes its arguments and then passes
    the parameters along to the specified function. That function returns appropriate
    function results (via the `ioctl()` return value and the parameter list you pass
    to `ioctl()`). Consider the following `i2c_smbus_access()` function that sets
    parameters for various Linux SMBus (I²C) function calls:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'This function copies its arguments into a local data structure (`args`) and
    then passes them on to the `ioctl()` function with the `I2C_SMBUS` argument that
    tells `ioctl()` to call one of the SMBus functions; the `args.command` parameter
    specifies the particular function to call. Most of the `I2C_SMBUS` functions use
    the same parameter list: the `read_write`, `size`, and `data` fields of the `args`
    structure.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that `i2c_smbus_access()` isn’t actually a specific SMBus function. It’s
    the function that marshals the arguments and passes them on to `ioctl()`, a *dispatcher
    function*: a single entry point (into the OS in this case) that transfers (dispatches)
    control to one of several different functions. An example of a specific SMBus
    function is `i2c_smbus_read_byte()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: This function uses `i2c_smbus_access()` to marshal the parameters and make the
    actual call to `ioctl()`.
  prefs: []
  type: TYPE_NORMAL
- en: The following subsections describe the SMBus functions available via the `ioctl()`
    dispatcher. While some of these functions are very SMBus specific, many of them
    are quite useful for normal I²C operations.
  prefs: []
  type: TYPE_NORMAL
- en: 9.7.1 The i2c-dev Functions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The *linux/i2c-dev.h* header file defines the SMBus functions that follow.
    The `apt-get install libi2c-dev` command entered earlier in this chapter installs
    this header file so you can use this library in your applications. You do not
    have to link a specific library against your code to use these functions, because
    the `i2c-dev` functions are installed as part of the kernel (or a loadable module)
    and accessed via the `ioctl()` API call. To access these functions, include the
    following statements at the beginning of your C/C++ applications:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: The header file itself contains the function definitions that the following
    sections describe. They are all *static inline* functions, so the compiler expands
    them (as macros) directly in place of the calls you make.
  prefs: []
  type: TYPE_NORMAL
- en: This header file, through its own includes, defines the types shown in [Table
    9-2](#table9-2).
  prefs: []
  type: TYPE_NORMAL
- en: 'Table 9-2: Integer Types'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Type** | **Meaning** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| __u8 | Unsigned 8-bit integer |'
  prefs: []
  type: TYPE_TB
- en: '| __u16 | Unsigned 16-bit integer |'
  prefs: []
  type: TYPE_TB
- en: '| __u32 | Unsigned 32-bit integer |'
  prefs: []
  type: TYPE_TB
- en: '| __s8 | Signed 8-bit integer |'
  prefs: []
  type: TYPE_TB
- en: '| __s16 | Signed 16-bit integer |'
  prefs: []
  type: TYPE_TB
- en: '| __s32 | Signed 32-bit integer |'
  prefs: []
  type: TYPE_TB
- en: You must pass the following functions a file handle specifying the I²C bus to
    use. You obtain the file handle using the `open()` function (see section 9.6,
    “Reading and Writing I²C Data,” earlier in this chapter). You do not pass these
    functions a device address. Instead, specify the device address to use with an
    `ioctl()` call, for example, `ioctl(``handle``, I2C_SLAVE,` `i2cAddr``)`. Once
    you set the device address for a given I²C bus (specified by the `handle`), that
    address remains in effect until you explicitly change it with another `ioctl()`
    call.
  prefs: []
  type: TYPE_NORMAL
- en: The following functions all return `-1` if an error occurs. The `write()` functions
    return `0` if they are successful. The `read()` functions will either return the
    value read from the bus (when reading a single value) or return the number of
    bytes read when reading a block of bytes.
  prefs: []
  type: TYPE_NORMAL
- en: 9.7.2 The i2c_smbus_write_quick Function
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `i2c_smbus_write_quick()` function writes a single bit value to an I²C
    device:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: In this function, `file` is a file handle returned by the open function (generally
    specifying the I²C device, such as i2c-1), while `value` is the bit value (0 or
    1) to write to the I²C bus specified by `file`.
  prefs: []
  type: TYPE_NORMAL
- en: This function writes a single bit to the I²C bus. The data payload is buried
    in the R/W bit of the address byte transmitted on the bus. This function transmits
    the start condition, the address byte (with data payload in R/W), and a stop condition.
    There are no data bytes transmitted as part of this operation.
  prefs: []
  type: TYPE_NORMAL
- en: 9.7.3 The i2c_smbus_read_byte Function
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `i2c_smbus_read_byte()` function reads a single byte from the I²C bus.
    Here is the prototype:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: This function returns a single byte from the I²C device on the bus specified
    by the file handle you pass as an argument (the device address was set up earlier
    with an `ioctl()` call). The function transmits a start condition and an address
    byte to the device. It then reads the response byte from the device. Finally,
    it transmits the stop condition.
  prefs: []
  type: TYPE_NORMAL
- en: Do not use this function to read a sequence of bytes from an I²C device—for
    example, reading all the status information from an MCP4725\. Because it brackets
    the address and data values with start and stop conditions, you’ll likely wind
    up reading just the first byte of the data sequence twice in a row. The program
    in [Listing 9-2](#listing9-2) demonstrates this problem.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'When connected to a SparkFun MCP4725 at address 0x60, the program in [Listing
    9-2](#listing9-2) produced the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: The program just read the status information byte twice. When reading data from
    non-SMBus devices (such as the MCP4725), use standard I²C read operations; save
    this function for actual SMBus devices.
  prefs: []
  type: TYPE_NORMAL
- en: 9.7.4 The i2c_smbus_write_byte() Function
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `i2c_smbus_write_byte()` function writes a single byte to an I²C device:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: The `file` argument is a handle specifying the bus (device), and `value` is
    the byte to transmit on the bus. This function transmits a start condition, an
    address byte, a data byte, and, finally, a stop condition.
  prefs: []
  type: TYPE_NORMAL
- en: As with the `i2c_smbus_read_byte()` function, do not use this function to write
    a sequence of bytes to an I²C device (such as writing the DAC value to an MCP4725).
    Because it brackets the address and data values with start and stop conditions,
    you’ll likely wind up writing only the first byte of the data sequence twice in
    a row.
  prefs: []
  type: TYPE_NORMAL
- en: 9.7.5 The i2c_smbus_read_byte_data() Function
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `i2c_smbus_read_byte_data()` function writes a register number to an I²C
    device and then reads a data byte (presumably from the register specified by the
    write operation). The prototype is
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: where `file` is the file handle specifying the I²C device and `command` is a
    register number or command byte to write to the device before reading from it.
  prefs: []
  type: TYPE_NORMAL
- en: This function transmits the start condition, the address byte with the R/W set
    to 0 (write), and then the `command` byte. Then it sends a (re)start condition,
    followed by another address byte (this time with the R/W bit set to 1). The peripheral
    responds by transmitting a data byte and then the controller puts a stop condition
    on the bus. The program in [Listing 9-3](#listing9-3) demonstrates this call.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: '[Figure 9-4](#figure9-4) shows the logic analyzer output when running the program
    in [Listing 9-3](#listing9-3). As you can see from this image, the `i2c_smbus_read_byte_data()`
    function call emits two I²C operations: a write operation (writing the byte 0,
    which was the command argument in the call) and a read operation, which winds
    up reading 0xC0 from the DAC (the status byte). You can’t see it because [Figure
    9-4](#figure9-4) is not in color, but between the two transmissions is a restart
    condition: a start condition without a stop condition from the previous transmission
    (the dot between the commands).'
  prefs: []
  type: TYPE_NORMAL
- en: '![](image_fi/502468c09/f09004.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 9-4: Logic analyzer output when running the program in [Listing 9-3](#listing9-3)'
  prefs: []
  type: TYPE_NORMAL
- en: Normally, you would not use this function on an MCP4725 DAC device. Writing
    a single byte wipes out the HO 4 bits of the output value (without affecting the
    LO byte). Of course, reading a single byte does very little good as well, unless
    you’re interested only in the status byte from the MCP4725.
  prefs: []
  type: TYPE_NORMAL
- en: Generally, you would use this function to talk to a more sophisticated device
    that requires writing a command or register byte before reading a byte back from
    the device, which is a common sequence with SMBus devices. For example, the MCP23017
    GPIO expander IC works in this fashion.
  prefs: []
  type: TYPE_NORMAL
- en: The big difference between this function call and a call to write a byte followed
    by a call to read a byte is that the latter form would emit a stop condition after
    writing the first byte. This stop condition would reset the state machine logic
    of devices, such as the MCP23017, and might cause it to treat the second write
    as an independent operation, leaving the bus vulnerable to a different controller
    sending data.
  prefs: []
  type: TYPE_NORMAL
- en: 9.7.6 The i2c_smbus_write_byte_data() Function
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `i2c_smbus_write_byte_data()` function writes a byte to specify an I²C
    device register and then writes a second byte to that register. This is its prototype:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: Like the `i2c_smbus_read_byte_data()` function, this call is mainly intended
    for use when communicating with devices such as the MCP23017 GPIO expander that
    expect you to transmit a register number immediately before transmitting the data
    byte.
  prefs: []
  type: TYPE_NORMAL
- en: 9.7.7 The i2c_smbus_read_word_data() Function
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `i2c_smbus_read_word_data()` function writes a register number to an I²C
    device and then reads a pair of bytes from the device (presumably from the specified
    register). This is its prototype:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: This function is similar to `i2c_smbus_read_byte_data()` except that it reads
    2 bytes (a word) after writing the `command` byte to the I²C bus.
  prefs: []
  type: TYPE_NORMAL
- en: 'When this function executes, the following I²C bus transactions occur:'
  prefs: []
  type: TYPE_NORMAL
- en: A start condition is sent.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The address byte with an R/W bit of 0 is sent.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `command` byte is sent.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A (re)start condition is sent.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The address byte with an R/W bit of 1 is sent.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Two bytes are read from the peripheral device.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A stop condition is sent.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This function reads the bytes back in little-endian order; that is, the first
    byte it reads from the bus is the LO byte, and the second byte it reads is the
    HO byte, which is often reversed from the way data actually arrives. For example,
    when using this function to read the MCP4725 DAC, the word comes back with the
    status byte in the LO 8 bits and the next byte read (which turns out, coincidentally,
    to be the HO 8 bits of the last DAC value written) in the HO byte. Be aware of
    that issue when using this function.
  prefs: []
  type: TYPE_NORMAL
- en: 9.7.8 The i2c_smbus_write_word_data() Function
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `i2c_smbus_write_word_data()` function writes 3 bytes to an I²C device:
    the first byte specifies a register number, and the next 2 bytes are a word value
    that is written to that register. This is its prototype:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: This function is similar to `i2c_smbus_write_byte_data()`, except that it writes
    2 bytes (a word) after writing the `command` byte to the I²C bus. Note that this
    function writes the bytes in little-endian order. Be aware of this issue when
    using this function.
  prefs: []
  type: TYPE_NORMAL
- en: 'When this function executes, the following I²C bus transactions occur:'
  prefs: []
  type: TYPE_NORMAL
- en: A start condition is sent.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The address byte with an R/W bit of 0 is sent.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The command byte is sent.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The LO byte of value is sent.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The HO byte of value is sent.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A stop condition is sent.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note that, unlike the read word function, only a single address byte is sent
    with no restart conditions. This function simply writes 3 bytes (a command and
    2 data bytes) after the address byte. The first byte, presumably, is a register
    or command byte followed by 2 data bytes.
  prefs: []
  type: TYPE_NORMAL
- en: 9.7.9 The i2c_smbus_read_block_data() Function
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `i2c_smbus_read_block_data()` function reads a block of data from the specified
    device and places that data in the `values` array. This function first writes
    the register number or command byte to the device, and then the device responds
    with the data. Here is its prototype:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'This command is useful for very specific I²C devices. The bus transactions
    are the following:'
  prefs: []
  type: TYPE_NORMAL
- en: A start condition is sent.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The address byte with an R/W bit of 0 is sent.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `command` byte is sent.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A (re)start condition is sent.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The address byte with an R/W bit of 1 is sent.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The system reads a count byte (*n*) and then reads *n* bytes from the device
    (the particular device determines how many bytes are actually read).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A stop condition is sent.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To read an arbitrary block of bytes from the I²C bus, without a command or register
    byte, just use the Linux `read` function.
  prefs: []
  type: TYPE_NORMAL
- en: 9.7.10 The i2c_smbus_write_block_data() Function
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `i2c_smbus_write_block_data()` function writes a block of data to the specified
    device. This function first writes the register number or command byte to the
    device followed by the data. This is its prototype:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'This function writes a `command` byte to the device and then a write of `length`
    bytes specified by the values array. The bus transactions are the following:'
  prefs: []
  type: TYPE_NORMAL
- en: A start condition is put on the bus.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: An address byte with the R/W bit set to 0 is written to the bus.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `command` byte is written to the bus.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`length` bytes from `values` are written to the bus.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A stop condition is placed on the bus.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: No extra address byte is written after the `command` byte. Indeed, this function
    is roughly equivalent to sticking the `command` byte at the beginning of the `values`
    array and calling the Linux `write` function with `length+1` as the number of
    bytes to write.
  prefs: []
  type: TYPE_NORMAL
- en: 9.7.11 Miscellaneous Functions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There are a few other miscellaneous (SMBus-only), lesser-used functions that
    I’m not going to document here. For more information on those functions, check
    out the Linux kernel I²C documentation at [https://www.kernel.org/doc/Documentation/i2c/smbus-protocol](https://www.kernel.org/doc/Documentation/i2c/smbus-protocol).
  prefs: []
  type: TYPE_NORMAL
- en: 9.8 Reentrancy Issues with I²C Operations
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Keep in mind that Linux (Raspberry Pi OS) is a multitasking operating system.
    Therefore, it is perfectly possible for two different threads or processes to
    attempt to access the I²C bus concurrently. Linux will serialize access to the
    I²C/SMBus device driver automatically. Therefore, if some thread is currently
    executing I²C code inside the Linux kernel and another thread attempts to invoke
    some I²C kernel code, the Linux system will block the second task until the first
    thread exits the `ioctl()` call. In that sense, you don’t have to worry about
    reentrancy or anything like that.
  prefs: []
  type: TYPE_NORMAL
- en: That said, two different threads cannot talk concurrently to the same device,
    but two different threads can talk to two independent devices on the I²C bus.
    Therefore, Linux will allow two threads, or even the same thread, to open the
    same bus multiple times. This means that, for example, two different threads could
    open the i2c-1 bus and both of them could write data to the same MCP4725 DAC.
    Of course, the output of the DAC will be really messed up if both threads are
    writing to the DAC independently. Unfortunately, Linux cannot solve this problem
    for you. You must exercise care when writing multiple threads or programs that
    might access the same I²C device concurrently.
  prefs: []
  type: TYPE_NORMAL
- en: 9.9 Multicontroller Operation Under Linux
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As far as I can tell, the Raspberry Pi OS (and Linux in general) does not support
    multiple controllers on the same I²C bus. Linux is a single-controller, multiple-peripheral
    I²C interface.
  prefs: []
  type: TYPE_NORMAL
- en: I suspect the Raspberry Pi hardware will not support multiple controllers, given
    the aforementioned hardware issue with the Raspberry Pi I²C controller, which
    doesn’t handle clock stretching properly, and the fact that the same types of
    operations are necessary for clock synchronization and arbitration. Of course,
    this issue applies only to the Pi; other Linux systems will likely support multiple
    controllers on the same bus just fine.
  prefs: []
  type: TYPE_NORMAL
- en: 9.10 Other Linux Systems
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This chapter has largely focused on the Raspberry Pi, but in truth, the only
    really Pi-specific topic in this chapter is activating the I²C bus. Most of the
    functions and utilities this chapter discusses are generic to Linux. The following
    subsections describe some other common Linux-based systems that support I²C for
    general interfacing purposes.
  prefs: []
  type: TYPE_NORMAL
- en: 9.10.1 PINE A64 and ROCKPro64
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The ROCKPro64 is a 64-bit ARM SBC built to look and behave a whole lot like
    the Raspberry Pi. While it is a great little board (along with its smaller brother,
    the PINE A64), the folks at PINE64 rely on third parties to provide their Linux
    operating system ports. Multiple ports are available, which makes it a bit difficult
    to find a reasonable tutorial on getting the SBC to enable the I²C lines. Here
    are some references (both describe I²C programming on the ROCKPro64 SBC) I’ve
    found that might prove helpful if you’re using one of these machines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://forum.armbian.com/topic/8792-i2c-and-i2s-on-rock64](https://forum.armbian.com/topic/8792-i2c-and-i2s-on-rock64)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[http://synfare.com/599N105E/hwdocs/rock64/index.xhtml](http://synfare.com/599N105E/hwdocs/rock64/index.xhtml)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 9.10.2 BeagleBone Black
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The BeagleBone Black is an open source alternative to the Raspberry Pi. Because
    this device was designed with hardware hackers in mind, it’s not surprising that
    it comes with the i2c-tools set already installed and I²C buses pre-activated.
  prefs: []
  type: TYPE_NORMAL
- en: On the BeagleBone Black, bus i2c-2 (pins 19 and 20 on the P9 connector; see
    Figure 6-10 in Chapter 6) is generally available for external use. Use `"/dev/i2c-2"`
    as the filename when opening the bus to access the bus on the BeagleBone Black.
  prefs: []
  type: TYPE_NORMAL
- en: 9.10.3 Onion Omega2+
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The Onion Omega2+ is a small Linux-based module intended for IoT operation.
    This little module comes with I²C communication installed and ready to run.
  prefs: []
  type: TYPE_NORMAL
- en: Onion provides an I²C library you can link with to access I²C devices. Check
    out Onion’s I²C documentation at [https://docs.onion.io/omega2-docs](https://docs.onion.io/omega2-docs).
  prefs: []
  type: TYPE_NORMAL
- en: 9.11 Using the Raspberry Pi as an I²C Peripheral Device
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Although the standard Raspberry Pi hardware and device drivers do not support
    using the Pi as an I²C peripheral device, it is possible to do so using bit-banging
    techniques. The pigpio free software library ([https://abyz.me.uk/rpi/pigpio](https://abyz.me.uk/rpi/pigpio))
    provides an API for dealing with the GPIO pins on the Raspberry Pi. This library
    provides a software-based I²C interface supporting both controller and peripheral
    modes.
  prefs: []
  type: TYPE_NORMAL
- en: 'The pigpio library also supports bit-banging controller operations. Using a
    software-controlled I²C driver provides additional features not possible with
    the hardware I²C system, including the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Baud rates as low as 50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Repeated starts
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Clock stretching
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: I²C on any pair of spare GPIO
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: See [https://abyz.me.uk/rpi/pigpio/cif.xhtml#bbI2COpen](https://abyz.me.uk/rpi/pigpio/cif.xhtml#bbI2COpen)
    for more information on the bit-banging I²C functions in the pigio library.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, pigpio also provides a veneer (facade design pattern) over the existing
    `ioctl()` functions. See [https://abyz.me.uk/rpi/pigpio/cif.xhtml#i2cOpen](https://abyz.me.uk/rpi/pigpio/cif.xhtml#i2cOpen)
    for a list of these functions.
  prefs: []
  type: TYPE_NORMAL
- en: 9.12 Chapter Summary
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This chapter discussed I²C programming on the Raspberry Pi, beginning with a
    discussion of the I²C pins on the Pi 40-pin GPIO header. It showed how to activate
    the I²C buses on the Pi and adjust the SCL clock frequency, and then it covered
    some issues with I²C on the Pi, such as its lack of support for clock stretching.
    You also learned various generic Linux utilities you can use to probe the I²C
    bus and access certain types of I²C peripherals. However, the real meat of this
    chapter was its treatment of reading and writing data on the I²C bus via Linux,
    including various advanced kernel calls. Unlike Arduino and other simple systems,
    Linux is a full multitasking/multiprocessing operating system. To address the
    problems in such systems, this chapter briefly discussed reentrancy issues and
    how to work around the problems when multiple threads or processes are accessing
    the same I²C bus concurrently.
  prefs: []
  type: TYPE_NORMAL
- en: Although this chapter focused on the Raspberry Pi, the Pi is a generic Linux
    system, and most of the comments in this chapter that are not Pi-hardware-specific
    apply to other Linux-based systems as well. Therefore, the chapter also gave an
    overview of I²C programming on the PINE A64 or ROCKPro64, the BeagleBone Black,
    and the Onion Omega2+. Finally, you learned to use the Raspberry Pi as an I²C
    peripheral device with the pigpio library, as well as how to use the same library
    for generic bit-banging I²C support.
  prefs: []
  type: TYPE_NORMAL
