["```\n$ sudo apt install gpiod\n$ sudo apt install libgpiod-dev\n$ sudo apt install libgpiod-doc\n```", "```\n// Blink an LED.\n#include <stdio.h>\n#include <unistd.h>\n#include <gpiod.h>\n\n#define LINE 17                // GPIO line connected to LED\n#define OFF 0                  // Pin at 0.0 V\n#define ON 1                   // Pin at 3.3 V\n#define BLINKS 5               // Number of blinks\n#define SECONDS 3              // Time between blinks\n\nint main(void)\n{\n  ❶  struct gpiod_chip *chip;\n      struct gpiod_line *line;\n      int i;\n      int error; \n  ❷  chip = gpiod_chip_open(\"/dev/gpiochip0\");  // On RPi 5 use /dev/gpiochip4\n      if(!chip) {\n           puts(\"Cannot open chip\");\n           return -1;\n  }\n\n       line = gpiod_chip_get_line(chip, LINE);\n       if(line == NULL) {\n            gpiod_chip_close(chip);\n            puts(\"Cannot get GPIO line\");\n            return -1;\n       }\n       error = gpiod_line_request_output(line, \"example\", 0);\n       if(error == -1) {\n            gpiod_line_release(line);\n            gpiod_chip_close(chip);\n            puts(\"Cannot set GPIO output\");\n            return -1;\n       }\n\n       for (i = 0; i < BLINKS; i++) {\n        ❸  gpiod_line_set_value(line, ON);\n            printf(\"led on...\\n\");\n            sleep(SECONDS);\n            gpiod_line_set_value(line, OFF);\n            printf(\"...led off\\n\");\n            sleep(SECONDS);\n       }\n       gpiod_line_release(line);\n       gpiod_chip_close(chip);\n\n       return 0;\n}\n```", "```\n$ gcc -g -Wall -o blink_led blink_led.c -lgpiod\n```", "```\nstruct gpiod_chip;\nstruct gpiod_line;\n```", "```\n// Blink an LED connected to GPIO line 17 every three seconds.\n\n// Define your RPi model: 0, 1, 2, 3, 4, 5\n    ❶ .equ    RPI_MODEL, 3\n// Useful constants\n        .equ    N_BLINKS, 5               // Number of times to blink\n        .equ    DELTA_TIME, 3             // Seconds between blinks\n        .equ    GPIO_LINE, 17             // Line number\n// The following are defined in /usr/include/asm-generic/fcntl.h.\n// Note that the values are specified in octal.\n        .equ    O_RDWR, 00000002          // Open for read/write\n        .equ    O_SYNC, 04010000          // Complete writes in hardware\n// The following are defined in /usr/include/asm-generic/mman-common.h.\n        .equ    PROT_READ, 0x1            // Page can be read\n        .equ    PROT_WRITE, 0x2           // Page can be written\n        .equ    MAP_SHARED, 0x01          // Share changes\n// Beginning address of peripherals\n ❷ .if     (RPI_MODEL == 0) || (RPI_MODEL == 1)\n        .equ    PERIPHS, 0x20000000 >> 16 // RPi 0 or 1\n    .elseif (RPI_MODEL == 2) || (RPI_MODEL == 3)\n        .equ    PERIPHS, 0x3f000000 >> 16 // RPi 2 or 3\n    .elseif RPI_MODEL == 4\n        .equ    PERIPHS, 0x7e000000 >> 16 // RPi 4\n    .else\n        .equ    PERIPHS, 0x1f00000000 >> 16   // RPi 5\n    .endif\n// Offset to GPIO registers\n    .if     RPI_MODEL != 5\n        .equ    GPIO_OFFSET, 0x200000     // Other RPi models\n    .else\n        .equ    GPIO_OFFSET, 0xd0000      // RPi 5\n    .endif\n// Amount of memory to map and flags\n        .equ    MEM_SIZE, 0x400000        // Enough to include all GPIO regs\n     ❸ .equ    OPEN_FLAGS, O_RDWR | O_SYNC   // Open file flags\n        .equ    PROT_RDWR, PROT_READ | PROT_WRITE   // Allow read and write\n        .equ    NO_ADDR_PREF, 0           // Let OS choose address of mapping\n\n// Stack frame\n        .equ    save1920, 16              // Save regs\n        .equ    save21, 32\n        .equ    FRAME, 48\n// Constant data\n        .section .rodata\n        .align  2\ndev_mem:\n        .asciz  \"/dev/mem\"\nerr_msg:\n        .asciz  \"Cannot map I/O memory.\\n\"\non_msg:\n        .asciz  \"led on...\\n\"\noff_msg:\n        .asciz  \"...led off\\n\"\n\n// Code\n        .text\n        .align  2\n        .global main\n        .type   main, %function\nmain:\n        stp     fp, lr, [sp, -FRAME]!     // Create stack frame\n        mov     fp, sp                    // Set our frame pointer\n        stp     x19, x20, [sp, save1920]  // Save regs\n        str     x21, [sp, save21]\n\n// Open /dev/mem for read/write and syncing.\n        mov     w1, OPEN_FLAGS & 0xffff   // Move 32-bit flags\n        movk    w1, OPEN_FLAGS / 0xffff, lsl 16\n        adr     x0, dev_mem               // I/O device memory\n     ❹ bl      open\n        cmp     w0, -1                    // Check for error\n        b.eq    error_return              // End if error\n        mov     w19, w0                   // /dev/mem file descriptor\n\n// Map the GPIO registers to a main memory location so we can access them.\n        movz    x5, PERIPHS & 0xffff, lsl 16\n        movk    x5, PERIPHS / 0xffff, lsl 32\n        mov     w4, w19                   // File descriptor\n        mov     w3, MAP_SHARED            // Share with other processes\n        mov     w2, PROT_RDWR             // Read/write this memory\n        mov     w1, MEM_SIZE              // Amount of memory needed\n        mov     w0, NO_ADDR_PREF          // Let kernel pick memory\n     ❺ bl      mmap\n        cmp     x0, -1                    // Check for error\n        b.eq    error_return              // w0 also = -1, end function\n        mov     x20, x0                   // Save mapped address\n        mov     w0, w19                   // /dev/mem file descriptor\n        bl      close                     // Close /dev/mem file\n\n// Make the line an output.\n        mov     x0, x20                   // Get mapped memory address\n        add    x0, x0, GPIO_OFFSET        // Start of GPIO registers\n        mov     w1, GPIO_LINE\n ❻ .if     RPI_MODEL != 5\n        bl      gpio_line_to_output\n    .else\n        bl      gpio_5_line_to_output\n    .endif\n        mov     x21, x0                   // Pointer to register base\n\n// Turn the line on and off.\n        mov     x19, N_BLINKS             // Number of times to do it\nloop:\n        adr     x0, on_msg                // Tell user it's on\n        bl      write_str\n mov     w1, GPIO_LINE             // GPIO line number\n        mov     x0, x21                   // Pointer to register base\n ❼ .if     RPI_MODEL != 5\n        bl      gpio_line_set             // Turn LED on\n    .else\n        bl      gpio_5_line_set           // Turn LED on\n    .endif\n        mov     w0, DELTA_TIME            // Wait\n        bl      sleep\n\n        adr     x0, off_msg               // Tell user it's off\n        bl      write_str\n        mov     w1, GPIO_LINE             // GPIO line number\n        mov     x0, x21                   // Pointer to register base\n ❽ .if     RPI_MODEL != 5\n        bl      gpio_line_clr             // Turn LED off\n    .else\n        bl      gpio_5_line_clr           // Turn LED off\n    .endif\n        mov     w0, DELTA_TIME            // Wait\n        bl      sleep\n\n        subs    x19, x19, 1               // Decrement loop counter\n        b.gt    loop                      // Loop if > 0\n\n        mov     x0, x20                   // Our mapped memory\n        mov     w1, MEM_SIZE              // Amount we mapped for GPIO\n     ❾ bl      munmap                    // Unmap it\n        mov     w0, wzr                   // Return 0\nerror_return:\n        ldr     x21, [sp, save21]         // Restore regs\n        ldp     x19, x20, [sp, save1920]\n        ldp     fp, lr, [sp], FRAME       // Delete stack frame\n        ret\n```", "```\n$ sudo ./blink_led\n```", "```\nint open(const char *pathname, int flags);\n```", "```\nvoid *mmap(void addr[.length], size_t length, int prot,\n          int flags int fd, off_t offset);\n```", "```\n// Make a GPIO line an output. Assume that GPIO registers\n// have been mapped to application memory.\n// Calling sequence:\n//      x0 <- address of GPIO in mapped memory\n//      w1 <- GPIO line number\n//      Return address of GPIO.\n\n// Useful constants\n        .equ    FIELD_MASK, 0b111  // 3 bits\n        .equ    OUTPUT, 1          // Use line for output\n\n// Code\n        .text\n        .align  2\n        .global gpio_line_to_output\n        .type   gpio_line_to_output, %function\ngpio_line_to_output:\n// Determine register and location of line function field.\n        mov     w3, 10              // 10 fields per GPFSEL register\n     ❶ udiv    w4, w1, w3          // GPFSEL register number\n     ❷ msub    w5, w4, w3, w1      // Relative FSEL number in register\n// Compute address of GPFSEL register and line field in register.\n     ❸ lsl     w4, w4, 2           // Offset to GPFSEL register\n        add     x7, x0, x4          // GPFSELn memory address\n        ldr     w4, [x7]            // GPFSELn register contents\n\n     ❹ add     w5, w5, w5, lsl 1   // 3 X relative FSEL number\n        mov     w6, FIELD_MASK      // FSEL line field\n lsl     w6, w6, w5          // Shift to relative FSEL bit position\n     ❺ bic     w4, w4, w6          // Clear current FSEL\n\n        mov     w2, OUTPUT          // Function = output\n     ❻ lsl     w2, w2, w5          // Shift function code to FSEL position\n        orr     w4, w4, w2          // Insert function code\n        str     w4, [x7]            // Update GPFSEL register\n\n        ret\n```", "```\n// Set a GPIO line. Assume that GPIO registers\n// have been mapped to application memory.\n// Calling sequence:\n//       x0 <- address of GPIO in mapped memory\n//       w1 <- line number\n\n// Constants\n     ❶ .equ    GPSET0, 0x1c     // GPSET register offset\n\n// Code\n        .text\n        .align  2\n        .global gpio_line_set\n        .type   gpio_line_set, %function\ngpio_line_set:\n        add     x0, x0, GPSET0  // Address of GPSET0 register\n        mov     w2, 1           // Need a 1\n     ❷ lsl     w2, w2, w1      // Move to specified bit position\n        str     w2, [x0]        // Output\n\n        ret\n```", "```\n// Clear GPIO line. Assume that GPIO registers\n// have been mapped to application memory.\n// Calling sequence:\n//       x0 <- address of GPIO in mapped memory\n//       w1 <- line number\n\n// Constants\n     ❶ .equ    GPCLR0, 0x28    // GPCLR register offset\n\n// Code\n        .text\n        .align  2\n        .global gpio_line_clr\n        .type   gpio_line_clr, %function\ngpio_line_clr:\n        add     x0, x0, GPCLR0  // Address of GPCLR0 register\n        mov     w2, 1           // Need a 1\n        lsl     w2, w2, w1      // Move to specified bit position\n        str     w2, [x0]        // Output\n\n        ret\n```", "```\n// Make a GPIO line an output. Assume that GPIO registers\n// have been mapped to application memory.\n// Calling sequence:\n//      x0 <- address of GPIO in mapped memory\n//      w1 <- GPIO line number\n//      Return address of RIOBase.\n\n// Constants\n        .equ    RIOBase, 0x10000  // Offset to RIO registers\n        .equ    PADBase, 0x20000  // Offset to PAD registers\n        .equ    SYS_RIO, 5        // Use RIO to control GPIO\n        .equ    PAD_AMPS, 0x10    // 4 mA\n        .equ    RIO_SET, 0x2000   // Set reg offset\n        .equ    RIO_OE, 0x04      // Output enable\n\n// Code\n        .text\n        .align  2\n        .global gpio_5_line_to_output\n        .type   gpio_5_line_to_output, %function\ngpio_5_line_to_output:\n     ❶ lsl    x2, x1, 3         // 8 x line number\n        add    x3, x0, x2        // GPIO_line_number_STATUS\n        mov    w2, SYS_RIO       // System registered I/O\n     ❷ str    w2, [x3, 4]       // GPIO_line_number_CTRL\n\n        add    x2, x0, PADBase\n        add    x2, x2, 4         // Skip over VOLTAGE_SELECT reg\n        lsl    x3, x1, 2         // 4 x line number\n        add    x3, x3, x2        // Pad reg address of line number\n        mov    w4, PAD_AMPS      // 4 mA\n     ❸ str    w4, [x3]          // Set pad amps\n\n        add    x0, x0, RIOBase\n        mov    w2, 1             // A bit\n        lsl    w2, w2, w1        // Shift to line location\n        add    x3, x0, RIO_SET   // Use RIO set register\n     ❹ str    w2, [x3, RIO_OE]  // Make line an output\n\n        ret\n```", "```\n// Set GPIO line. Assume that GPIO registers\n// have been mapped to programming memory.\n// Calling sequence:\n//       x0 <- address of RIOBase in mapped memory\n//       w1 <- line number\n\n// Constants\n     ❶ .equ    RIO_SET, 0x2000     // Set reg\n\n// Code\n        .text\n        .align  2\n .global gpio_5_line_set\n        .type   gpio_5_line_set, %function\ngpio_5_line_set:\n        mov     w2, 1               // A bit\n     ❷ lsl     w2, w2, w1          // Shift to line location\n        add     x0, x0, RIO_SET     // Address of RIO set reg\n        str     w2, [x0]            // Line low\n        ret\n```", "```\n// Clear a GPIO line. Assume that GPIO registers\n// have been mapped to programming memory.\n// Calling sequence:\n//       x0 <- address of RIOBase in mapped memory\n//       w1 <- line number\n\n// Constants\n     ❶ .equ    RIO_CLR, 0x3000     // Clear reg\n\n// Code\n        .text\n        .align  2\n        .global gpio_5_line_clr\n        .type   gpio_5_line_clr, %function\ngpio_5_line_clr:\n        mov     w2, 1               // A bit\n        lsl     w2, w2, w1          // Shift to line location\n        add     x0, x0, RIO_CLR     // Address of RIO clear reg\n        str     w2, [x0]            // Line low\n        ret\n```", "```\n// Use a UART to echo a single character.\n// WARNING: This code does not run on any known device. It is\n// meant to sketch some general I/O concepts only.\n\n#include \"UART_functions.h\"\n#define UART0 (unsigned char *)0xfe200040   // Address of UART\n\nint UART_echo(void)\n{\n    unsigned char character;\n\n    UART_init(UART0);\n    character = UART_in(UART0);\n    UART_out(UART0, character);\n\n    return 0;\n}\n```", "```\n   // Definitions for a 16550 UART.\n   // WARNING: This code does not run on any known device. It is\n   // meant to sketch some general I/O concepts only.\n #ifndef UART_DEFS_H\n   #define UART_DEFS_H\n\n   // Register offsets\n   #define RHR 0x00    // Receive holding register\n   #define THR 0x00    // Transmit holding register\n   #define IER 0x01    // Interrupt enable register\n   #define FCR 0x02    // FIFO control register\n   #define LCR 0x03    // Line control register\n   #define LSR 0x05    // Line status register\n   #define DLL 0x00    // Divisor latch LSB\n   #define DLM 0x01    // Divisor latch MSB\n\n   // Status bits\n   #define RxRDY 0x01  // Receiver ready\n   #define TxRDY 0x20  // Transmitter ready\n\n   // Commands\n   #define NO_FIFO       0x00  // Don't use FIFO\n   #define NO_INTERRUPT  0x00  // Polling mode\n   #define MSB_38400     0x00  // 2 bytes used to\n   #define LSB_38400     0x03  //   set baud 38400\n   #define N_BITS        0x03  // 8 bits\n   #define STOP_BIT      0x00  // 1 stop bit\n   #define NO_PARITY     0x00\n❶ #define SET_COM       N_BITS | STOP_BIT | NO_PARITY\n❷ #define SET_BAUD      0x80 | SET_COM\n   #endif\n```", "```\n// Initialize, read, and write functions for an abstract UART.\n// WARNING: This code does not run on any known device. It is\n// meant to sketch some general I/O concepts only.\n\n#ifndef UART_FUNCTIONS_H\n#define UART_FUNCTIONS_H\nvoid UART_init(unsigned char* UART);                  // Initialize UART\nunsigned char UART_in(unsigned char* UART);           // Input\nvoid UART_out(unsigned char* UART, unsigned char c);  // Output\n#endif\n```", "```\n// Initialize, read, and write functions for a 16550 UART.\n// WARNING: This code does not run on any known device. It is\n// meant to sketch some general I/O concepts only.\n\n#include \"UART_defs.h\"\n#include \"UART_functions.h\"\n\n// UART_init initializes the UART and enables it.\nvoid UART_init(unsigned char* UART)\n{\n    unsigned char* port = UART;\n\n    *(port+IER) = NO_INTERRUPT;   // No interrupts\n    *(port+FCR) = NO_FIFO;        // No FIFO\n    *(port+LCR) = SET_BAUD;       // Set frequency mode\n    *(port+DLM) = MSB_38400;      // Set to 38400 baud\n    *(port+DLL) = LSB_38400;      // 2 regs to set\n    *(port+LCR) = SET_COM;        // Communications mode\n}\n\n// UART_in waits until the UART has a character and then reads it.\nunsigned char UART_in(unsigned char* UART)\n{\n    unsigned char* port = UART;\n    unsigned char character;\n ❶ while ((*(port+LSR) & RxRDY) != 0) {\n    }\n    character = *(port+RHR);\n    return character;\n}\n\n// UART_out waits until the UART is ready and then writes a character.\nvoid UART_out(unsigned char* UART, unsigned char character)\n{\n    unsigned char* port = UART;\n\n ❷ while ((*(port+LSR) & TxRDY) != 0) {\n    }\n    *(port+THR) = character;\n}\n```"]