<html xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops" lang="en" xml:lang="en">
<head>
<title>7 SYNTHESIS, PLACE AND ROUTE, AND CROSSING CLOCK DOMAINS</title>
<meta content="text/html; charset=utf-8" http-equiv="default-style"/>
<link href="../styles/stylesheet.css" rel="stylesheet" type="text/css"/>
<meta content="urn:uuid:d7b1a4c0-49cb-46f7-b6a4-8fcfa081f00a" name="Adept.expected.resource"/>
</head>
<body epub:type="bodymatter">
<section aria-labelledby="ch7" epub:type="chapter" role="doc-chapter">
<header>
<h1 class="CHAPTER" id="ch7">
<span class="CN"><span aria-label=" Page 123. " epub:type="pagebreak" id="pg_123" role="doc-pagebreak"/><samp class="SANS_Futura_Std_Bold_Condensed_B_11">7</samp></span>
<span class="CT"><samp class="SANS_Dogma_OT_Bold_B_11">SYNTHESIS, PLACE AND ROUTE, AND CROSSING CLOCK DOMAINS</samp></span>
</h1>
</header>
<figure class="opener"><img alt="" class="opener" src="../images/opener-img.png"/>
</figure>
<p class="COS">In <span class="Xref"><a href="chapter2.xhtml">Chapter 2</a></span>, I provided an overview of the FPGA build process to get you comfortable running the tools needed to work on this book’s projects. We’ll now take a closer look at the build process, to give you a deeper understanding of what exactly is going on when you click the Build FPGA button. Once you have a firm knowledge of what your FPGA tools are doing, you’ll be able to avoid many common mistakes and write highly reliable code.</p>
<p class="TX">As you learned back in <span class="Xref"><a href="chapter2.xhtml">Chapter 2</a></span>, after you’ve written your Verilog or VHDL code the FPGA design goes through three stages: synthesis, place and route, and programming. If any of these processes fails, the FPGA build won’t be successful. In this chapter, we’ll focus on the first two stages. We’ll talk in detail about synthesis, and break down the differences between synthesizable and non-synthesizable code. After that, we’ll revisit the place and route process and explore one common issue that arises during this <span aria-label=" Page 124. " epub:type="pagebreak" id="pg_124" role="doc-pagebreak"/>stage: timing errors. You’ll learn what causes these errors and how to fix them. Finally, we’ll look in detail at a situation where you’re particularly likely to encounter timing issues: when signals cross between parts of your FPGA design running at different clock frequencies. You’ll learn how to safely cross clock domains in your FPGA.</p>
<section aria-labelledby="sec1" epub:type="division">
<h2 class="H1" id="sec1"><span id="h-86"/><samp class="SANS_Futura_Std_Bold_B_11">Synthesis</samp></h2>
<p class="TNI1"><i>Synthesis</i> is the process of breaking down your Verilog or VHDL code and converting it to simple components (LUTs, flip-flops, block RAMs, and so on) that exist on your specific FPGA. In this sense, an FPGA synthesis tool is similar to a compiler, which takes code in a language like C and breaks it down into very simple instructions that your CPU can understand.</p>
<p class="TX">For the process to work correctly, the synthesis tool needs to know exactly what type of FPGA you’re using so it knows what resources are available. Then, since these resources are finite, it becomes the synthesis tool’s job to figure out how to use them as efficiently as possible. This is called <i>logic optimization</i> (or <i>logic minimization</i>), and it’s a major part of the synthesis process. As I mentioned in <span class="Xref"><a href="chapter3.xhtml">Chapter 3</a></span>, there’s no reason for you to ever perform logic optimization manually; you can simply leave it to the synthesis tool. That’s not to say, however, that writing code that uses your available resources intelligently isn’t important. Having a good understanding of what your code will synthesize into is critical to becoming a strong FPGA designer.</p>
<p class="TX">A key output of the synthesis process is your <i>utilization report</i>, which tells you how many LUTs, flip-flops, block RAMs, and other resources you’re using in your design. We’ve examined excerpts from utilization reports in past chapters; I recommend always reading through this report to make sure that your expectations match reality with regard to the resources being used.</p>
<section aria-labelledby="sec2" epub:type="division">
<h3 class="H2" id="sec2"><span id="h-87"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Notes, Warnings, and Errors</samp></h3>
<p class="TNI1">The synthesis process often generates a very large number of notes and warnings, even when it runs successfully. When unsuccessful, the process generates errors as well. The notes are mostly informational, telling you how the tool is interpreting your code. Warnings are worth looking at to make sure that you’re not making mistakes. However, in large designs there might be hundreds of warnings, so they can become overwhelming. Some tools allow you to hide warnings once you’re comfortable with them. This is a useful feature that allows you to focus on the real problems.</p>
<p class="TX">One particular warning worth noting is the <i>inferred latch</i> warning. As you learned back in <span class="Xref"><a href="chapter4.xhtml">Chapter 4</a></span>, latches are bad. They’re often created accidentally, and the tools can have trouble analyzing them in the context of timing in your FPGA design. If you create a latch, you’ll be notified of it during the synthesis process. You’ll get a warning like this:</p>
<pre><code><span aria-label=" Page 125. " epub:type="pagebreak" id="pg_125" role="doc-pagebreak"/>[Synth 8-327] inferring latch for variable 'o_test' [test_program.vhd:19]</code></pre>
<p class="TX">Don’t ignore this warning. Unless you’re sure that you really want that latch in your design, you should try to remove it. I’ve been doing FPGA design for many years and I’ve never needed to use a latch, so you should have a very good reason if you’re planning to keep it.</p>
<p class="TX">If something goes wrong during synthesis, you’ll get an error rather than a warning. The two most common errors you’ll encounter are syntax errors and utilization errors; we’ll look at those next.</p>
<section aria-labelledby="sec3" epub:type="division">
<h4 class="H3" id="sec3"><samp class="SANS_Futura_Std_Bold_Condensed_B_11">Syntax Errors</samp></h4>
<p class="TNI1">When you start the synthesis process, the first thing the tool will do is check your Verilog or VHDL code for syntax errors. These are by far the most common errors you’ll encounter. There are literally hundreds of kinds of syntax errors that might be lurking in your code; perhaps you forgot to define a signal, mistyped a keyword, or left out a semicolon, for example. In the last case, you might see an error message like this one in Verilog:</p>
<pre><code>** Error: (vlog-13069) design.v(5): near "endmodule": syntax error,
unexpected endmodule, expecting ';' or ','.</code></pre>
<p class="BodyContinued">or this one in VHDL:</p>
<pre><code>** Error: design.vhd(5): near "end": (vcom-1576) expecting ';'.</code></pre>
<p class="TX">The synthesis tool will tell you on which line of which file it encountered the error. In the preceding error messages, for example, <samp class="SANS_TheSansMonoCd_W5Regular_11">design.v(5)</samp> in Verilog or <samp class="SANS_TheSansMonoCd_W5Regular_11">design.vhd(5)</samp> in VHDL is telling you to check line 5 of the file called <i>design</i>. You can use this information to edit your code to pass the syntax check.</p>
<p class="TX">Occasionally, you’ll get an overwhelming number of syntax errors. The best thing you can do in this case is find the first error and fix that one. Often, a cascade of errors can stem from the first one. This is a good rule for engineering in general: fix the first problem first. Once you’ve resolved that first syntax error, rerun the synthesis process. If you’re still getting errors, again find the first one, fix it, and rerun synthesis. This process is iterative, and it often takes a few cycles for all the syntax errors to be resolved and the synthesis process to complete successfully.</p>
</section>
<section aria-labelledby="sec4" epub:type="division">
<h4 class="H3" id="sec4"><samp class="SANS_Futura_Std_Bold_Condensed_B_11">Utilization Errors</samp></h4>
<p class="TNI1">Once your code passes the syntax check, the next most common error you’ll encounter during synthesis is a <i>utilization error</i>, where your design requires more components than the FPGA has available. For example, if your FPGA has 1,000 flip-flops but your code is requesting 2,000, you’ll get a utilization error. The design simply won’t fit on your FPGA, so you’ll need to think of ways to shrink your code to instantiate fewer flip-flops. A good rule of thumb is to aim to utilize no more than 80 percent of the available <span aria-label=" Page 126. " epub:type="pagebreak" id="pg_126" role="doc-pagebreak"/>LUTs or flip-flops. This will make it easier for the place and route process to get your design to meet timing (more on this later in the chapter), as well as giving you more flexibility to modify your design or add new features in the future.</p>
<p class="TX">If you can’t get your code to fit in your chosen FPGA, you have a few options:</p>
<p class="NLF2">1.  Switch to a larger FPGA.</p>
<p class="NLM2">2.  Identify the most resource-intensive modules and rewrite them.</p>
<p class="NLL2">3.  Remove functionality.</p>
<p class="TX">Switching to a larger FPGA might be a big deal, but it isn’t always. Many FPGA vendors offer higher-resource FPGAs in the same physical package as lower-resource parts. The higher-resource ones often cost a bit more, so you’ll pay a few extra dollars for those additional resources, but the new FPGA won’t take up any extra space on your circuit board. When you’re selecting an FPGA for a project, it’s a good idea to pick an FPGA family and package where you have the option to move up in resources, just in case you end up needing more resources than you expect.</p>
<p class="TX">If you can’t switch to a different FPGA, the next step is to analyze your code to see if it uses more resources than necessary. This isn’t a matter of low-level logic minimization to shave off a LUT here and a flip-flop there—the tools do that for you. Rather, there are ways in which you might inadvertently write code that uses dramatically more resources than you expect. As an example, I once traced a high utilization error to one single line of code that was dividing two numbers. As you’ll learn in <span class="Xref"><a href="chapter10.xhtml">Chapter 10</a></span>, division is often a very resource-intensive operation in an FPGA. I was able to change the division operation into a memory operation by creating a table of possible inputs and mapping each input to an output. This used a block RAM, but it freed up the LUTs and flip-flops used for the division and allowed the FPGA to pass the synthesis process. Rewriting code with a focus on lower resource utilization is a skill you’ll sharpen as you gain more FPGA experience. You can dig into the utilization reports of each module to figure out which are using the most resources, and then examine those individually.</p>
<p class="TX">Another approach for reducing resource utilization is to have different inputs share the same FPGA resource. FPGAs often perform the same operation on multiple input channels. Instead of having dedicated FPGA resources for each channel, you can use a single implementation, with each channel taking a turn sharing the hardware. For example, say you have 100 channels that all need a cosine operation performed on them once a second. You could have channel 1 perform the cosine operation in the first 10 ms, then allow channel 2 to perform that same cosine operation in the next 10 ms, then channel 3, and so on. This way, the hardware used to perform the cosine operation can be shared between all the channels and only needs to be instantiated once, rather than being instantiated 100 times, once for each channel.</p>
<p class="TX">This keeps the overall resource utilization much lower, but it only works if you have the time available to share a resource. If your timelines <span aria-label=" Page 127. " epub:type="pagebreak" id="pg_127" role="doc-pagebreak"/>are too tight this approach might not work. Additionally, it does add some complexity, because now you need to build a component that will negotiate the sharing. We refer to the process of sharing a resource as <i>arbitration</i>, and the component that performs sharing this is often referred to as an <i>arbiter</i>. Arbiters can be built to share off-FPGA resources as well. For example, we might have several modules that write data to a MicroSD card. An arbiter could be designed to allow those modules to share the single MicroSD card and prevent two modules from trying to write data at the same time, which would cause data loss or corruption.</p>
<p class="TX">If you’ve written very efficient code and you still can’t make it fit on your FPGA, the only option left is to remove functionality. Maybe there’s a microcontroller on the same board that can do some of the things that the FPGA was supposed to do. Or maybe you just need to tell your team that it won’t work. FPGAs simply have a limit to the amount of stuff they can fit.</p>
</section>
</section>
<section aria-labelledby="sec5" epub:type="division">
<h3 class="H2" id="sec5"><span id="h-88"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Non-synthesizable Code</samp></h3>
<p class="TNI1">Many keywords in the Verilog and VHDL languages can’t be translated into FPGA components by a synthesis tool; they aren’t synthesizable. If you include any of these keywords in your project code, the synthesis tool will simply ignore them. It might generate a warning or a note, but not an error. The tool will move forward with the synthesis process, omitting the non-synthesizable parts from the final design—and potentially leading to problems if you were counting on the functionality of the non-synthesizable code.</p>
<p class="TX">It might seem strange that non-synthesizable keywords exist in Verilog and VHDL, but they’re useful for simulation and testbenches. As we discussed in <span class="Xref"><a href="chapter5.xhtml">Chapter 5</a></span>, testing your code is critical, and the languages provide keywords to assist you with this. In fact, you can include non-synthesizable elements in your project code for simulation purposes and leave them in when you run the code through synthesis, since the tool will just ignore them. To be safe, you can explicitly tell the tool not to bother trying to synthesize these parts of your code by preceding them with <samp class="SANS_TheSansMonoCd_W5Regular_11">synthesis translate_off</samp> and succeeding them with <samp class="SANS_TheSansMonoCd_W5Regular_11">synthesis translate_on</samp>. This technique works for both Verilog and VHDL. For example, if you’re designing a FIFO, you might want to assert that you’re never writing to a full FIFO or reading from an empty FIFO when running simulations of the code. The <samp class="SANS_TheSansMonoCd_W5Regular_11">synthesis translate_off</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">synthesis translate_on</samp> directives let you bake those assertions into the actual design code, without having to worry about maintaining separate code for simulation and synthesis.</p>
<p class="TX">Some of the most common areas where non-synthesizable code arises include keeping track of time, printing text, working with files, and looping. We’ll consider those now.</p>
<section aria-labelledby="sec6" epub:type="division">
<h4 class="H3" id="sec6"><samp class="SANS_Futura_Std_Bold_Condensed_B_11">Keeping Track of Time</samp></h4>
<p class="TNI1">As you know, there’s no inherent way to measure the passage of time in an FPGA. Instead, we rely on counting clock cycles. Still, there are parts of <span aria-label=" Page 128. " epub:type="pagebreak" id="pg_128" role="doc-pagebreak"/>both VHDL and Verilog that refer to time: for example, <samp class="SANS_TheSansMonoCd_W5Regular_11">$time</samp> in Verilog or <samp class="SANS_TheSansMonoCd_W5Regular_11">now</samp> in VHDL will provide a current timestamp, while a statement like <samp class="SANS_TheSansMonoCd_W5Regular_11">#100</samp> in Verilog or <samp class="SANS_TheSansMonoCd_W5Regular_11">wait</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">for 100 ns;</samp> in VHDL will create a short delay. These features can be useful for running simulations—for example, to trigger input signals at precise time intervals—but they aren’t synthesizable.</p>
</section>
<section aria-labelledby="sec7" epub:type="division">
<h4 class="H3" id="sec7"><samp class="SANS_Futura_Std_Bold_Condensed_B_11">Printing</samp></h4>
<p class="TNI1">One common way to get feedback during the testing process is to send text to the terminal. In C and Python, for example, you have functions like <samp class="SANS_TheSansMonoCd_W5Regular_11">printf()</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">print()</samp> that will send text to a console to allow you to see what’s going on. Similar functions exist in Verilog and VHDL. In Verilog, you can use <samp class="SANS_TheSansMonoCd_W5Regular_11">$display()</samp> to send text to the terminal. In VHDL, it’s a bit more complicated, and there are a few options. For example, you can use <samp class="SANS_TheSansMonoCd_W5Regular_11">assert</samp> followed by <samp class="SANS_TheSansMonoCd_W5Regular_11">report</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">severity note</samp> to send text to the screen, as shown here:</p>
<pre><code>assert false report "Hello World" severity note;</code></pre>
<p class="TX">These text outputs only work in simulation. They can’t be synthesized, as the concept of a console or terminal doesn’t exist on a physical FPGA.</p>
</section>
<section aria-labelledby="sec8" epub:type="division">
<h4 class="H3" id="sec8"><samp class="SANS_Futura_Std_Bold_Condensed_B_11">Working with Files</samp></h4>
<p class="TNI1">In most cases, you can’t synthesize Verilog or VHDL code that involves reading from or writing to a file. The FPGA has no concept of “files” or any operating system; you have to build all that stuff yourself if you really need it. Consider something like storing data from a temperature sensor. You might want to read data from the sensor every second and write those values to a file. This is possible to do in simulation with functions like <samp class="SANS_TheSansMonoCd_W5Regular_11">$fopen()</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">$fwrite()</samp> in Verilog or <samp class="SANS_TheSansMonoCd_W5Regular_11">file_open()</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">write()</samp> in VHDL, but in synthesis, forget about it.</p>
<p class="TX">One exception here is that some FPGAs allow you to use a text file to preload (initialize) a block RAM. The specifics of how different vendors accomplish this vary, so refer to the memory usage guide for your FPGA if this is something you ever need to do.</p>
</section>
<section aria-labelledby="sec9" epub:type="division">
<h4 class="H3" id="sec9"><samp class="SANS_Futura_Std_Bold_Condensed_B_11">Looping</samp></h4>
<p class="TNI1">Loop statements <i>can</i> be synthesized, but they probably won’t work the way you expect. You might be familiar with <samp class="SANS_TheSansMonoCd_W5Regular_11">for</samp> loops from a software language like C or Python: they allow you to write concise code that repeats an operation a specific number of times one after another. In simulation, Verilog or VHDL <samp class="SANS_TheSansMonoCd_W5Regular_11">for</samp> loops work this way. In synthesizable FPGA code, however, <samp class="SANS_TheSansMonoCd_W5Regular_11">for</samp> loops work differently; they’re used to condense replicated logic, providing a shorthand for writing several similar statements that are meant to be executed <i>at the same time, rather than one after another</i>. To demonstrate, consider this example code for a 4-bit shift register:</p>
<p class="Label"><span aria-label=" Page 129. " epub:type="pagebreak" id="pg_129" role="doc-pagebreak"/><samp class="SANS_Futura_Std_Bold_Oblique_BI_11">Verilog</samp></p>
<pre><code>always @(posedge i_Clk)
  begin
    r_Shift[1] &lt;= r_Shift[0];
    r_Shift[2] &lt;= r_Shift[1];
    r_Shift[3] &lt;= r_Shift[2];
  end</code></pre>
<p class="Label"><samp class="SANS_Futura_Std_Bold_Oblique_BI_11">VHDL</samp></p>
<pre><code>process (i_Clk)
begin
  if rising_edge(i_Clk) then
    r_Shift(1) &lt;= r_Shift(0);
    r_Shift(2) &lt;= r_Shift(1);
    r_Shift(3) &lt;= r_Shift(2);
  end if;
end process;</code></pre>
<p class="TX">Each clock cycle, this code shifts data through the <samp class="SANS_TheSansMonoCd_W5Regular_11">r_Shift</samp> register. The value from bit 0 is shifted to bit 1, the value from bit 1 is shifted to bit 2, and so on. The assignment statements that accomplish this follow a completely predictable pattern: the value of <samp class="SANS_TheSansMonoCd_W5Regular_11">r_Shift[i]</samp> is assigned to <samp class="SANS_TheSansMonoCd_W5Regular_11">r_Shift[i</samp><samp class="SANS_TheSansMonoCd_W5Regular_11">+</samp><samp class="SANS_TheSansMonoCd_W5Regular_11">1]</samp>. Synthesizable Verilog and VHDL <samp class="SANS_TheSansMonoCd_W5Regular_11">for</samp> loops provide a more compact way of writing predictable code like this. Using a <samp class="SANS_TheSansMonoCd_W5Regular_11">for</samp> loop, we can rewrite the shift register code as follows:</p>
<p class="Label"><samp class="SANS_Futura_Std_Bold_Oblique_BI_11">Verilog</samp></p>
<pre><code>always @(posedge i_Clk)
  begin
  <span aria-label="annotation1" class="CodeAnnotationCode">❶</span> for(i=0; i&lt;3; i=i+1)
     <span aria-label="annotation2" class="CodeAnnotationCode">❷</span> r_Shift[i+1] &lt;= r_Shift[i];
  end</code></pre>
<p class="Label"><samp class="SANS_Futura_Std_Bold_Oblique_BI_11">VHDL</samp></p>
<pre><code>process (i_Clk)
begin
  if rising_edge(i_Clk) then
  <span aria-label="annotation1" class="CodeAnnotationCode">❶</span> for i in 0 to 2 loop
     <span aria-label="annotation2" class="CodeAnnotationCode">❷</span> r_Shift(i+1) &lt;= r_Shift(i);
     end loop;
  end if;
end process;</code></pre>
<p class="TX">Here, we declare a <samp class="SANS_TheSansMonoCd_W5Regular_11">for</samp> loop with incrementing variable <samp class="SANS_TheSansMonoCd_W5Regular_11">i</samp> <span aria-label="annotation1" class="CodeAnnotation">❶</span>. With each iteration, the statement assigning the value from bit <samp class="SANS_TheSansMonoCd_W5Regular_11">i</samp> to bit <samp class="SANS_TheSansMonoCd_W5Regular_11">i + 1</samp> <span aria-label="annotation2" class="CodeAnnotation">❷</span> is executed. For example, on the first iteration of the loop <samp class="SANS_TheSansMonoCd_W5Regular_11">i</samp> is <samp class="SANS_TheSansMonoCd_W5Regular_11">0</samp>, so the line that gets executed is <samp class="SANS_TheSansMonoCd_W5Regular_11">r_Shift[0</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">+ 1]</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">&lt;=</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">r_Shift[0]</samp>. The second time through <samp class="SANS_TheSansMonoCd_W5Regular_11">i</samp> is <samp class="SANS_TheSansMonoCd_W5Regular_11">1</samp>, so we get <samp class="SANS_TheSansMonoCd_W5Regular_11">r_Shift[1</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">+ 1]</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">&lt;=</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">r_Shift[1]</samp>. On the third and final iteration, we get <samp class="SANS_TheSansMonoCd_W5Regular_11">r_Shift[2</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">+ 1]</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">&lt;=</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">r_Shift[2]</samp>.</p>
<p class="TX">The important thing to realize here is that <i>this all happens in one clock cycle</i>. In effect, all iterations of the loop execute simultaneously, just as the three separate assignment statements in the version without the <samp class="SANS_TheSansMonoCd_W5Regular_11">for</samp> loop will execute simultaneously. The two versions do exactly the same thing <span aria-label=" Page 130. " epub:type="pagebreak" id="pg_130" role="doc-pagebreak"/>(and will synthesize to the exact same FPGA resources), except the <samp class="SANS_TheSansMonoCd_W5Regular_11">for</samp> loop version is written in a more compact way.</p>
<p class="TX">A common mistake that beginners make is putting a <samp class="SANS_TheSansMonoCd_W5Regular_11">for</samp> loop inside a clocked <samp class="SANS_TheSansMonoCd_W5Regular_11">always</samp> or <samp class="SANS_TheSansMonoCd_W5Regular_11">process</samp> block and expecting each iteration of the loop to take one clock cycle. Take the following snippet of C code, for example:</p>
<pre><code>for (i=0; i&lt;10; i++)
  data[i] = data[i] + 1;</code></pre>
<p class="TX">Here we have an array, <samp class="SANS_TheSansMonoCd_W5Regular_11">data</samp>, and we’re incrementing every value inside the array by 1 using a <samp class="SANS_TheSansMonoCd_W5Regular_11">for</samp> loop. (We’re assuming here that <samp class="SANS_TheSansMonoCd_W5Regular_11">data</samp> has 10 items.) If you try to do the same thing using a Verilog or VHDL <samp class="SANS_TheSansMonoCd_W5Regular_11">for</samp> loop, expecting that it will take 10 clock cycles to run, you’ll be very confused, since the loop will actually be executed in a single clock cycle. If you <i>do</i> want to run a sequence like this over a number of clock cycles, you can update the values inside an <samp class="SANS_TheSansMonoCd_W5Regular_11">if</samp> statement that checks for an index value to exceed a certain threshold, like this:</p>
<p class="Label"><samp class="SANS_Futura_Std_Bold_Oblique_BI_11">Verilog</samp></p>
<pre><code>always @(posedge i_Clk)
  begin
  <span aria-label="annotation1" class="CodeAnnotationCode">❶</span> if (r_Index &lt; 10)
      begin
      <span aria-label="annotation2" class="CodeAnnotationCode">❷</span> r_Data[r_Index] &lt;= r_Data[r_Index] + 1;
      <span aria-label="annotation3" class="CodeAnnotationCode">❸</span> r_Index         &lt;= r_Index + 1;
      end
  end</code></pre>
<p class="Label"><samp class="SANS_Futura_Std_Bold_Oblique_BI_11">VHDL</samp></p>
<pre><code>process (i_Clk)
begin
  if rising_edge(i_Clk) then
  <span aria-label="annotation1" class="CodeAnnotationCode">❶</span> if r_Index &lt; 10 then
     <span aria-label="annotation2" class="CodeAnnotationCode">❷</span> r_Data(r_Index) &lt;= r_Data(r_Index) + 1;
     <span aria-label="annotation3" class="CodeAnnotationCode">❸</span> r_Index         &lt;= r_Index + 1;
     end if;
  end if;
end process;</code></pre>
<p class="TX">Here, we use an <samp class="SANS_TheSansMonoCd_W5Regular_11">if</samp> statement to replicate the check that stops the <samp class="SANS_TheSansMonoCd_W5Regular_11">for</samp> loop <span aria-label="annotation1" class="CodeAnnotation">❶</span>. In this case, we want the operation to run 10 times, or until <samp class="SANS_TheSansMonoCd_W5Regular_11">r_Index</samp> is no longer less than 10. (We’re assuming that the index value starts at 0, although this isn’t shown in the code.) Next, we increment a value in <samp class="SANS_TheSansMonoCd_W5Regular_11">r_Data</samp>, using <samp class="SANS_TheSansMonoCd_W5Regular_11">r_Index</samp> to access the correct item in the array <span aria-label="annotation2" class="CodeAnnotation">❷</span>. Finally, we increment <samp class="SANS_TheSansMonoCd_W5Regular_11">r_Index</samp> <span aria-label="annotation3" class="CodeAnnotation">❸</span>, which will then be used on the next clock cycle to update the next value in the array. In total, this will take 10 clock cycles to execute. In general, when trying to write code that iterates like a conventional <samp class="SANS_TheSansMonoCd_W5Regular_11">for</samp> loop, usually all you need to do is add a counter signal (like <samp class="SANS_TheSansMonoCd_W5Regular_11">r_Index</samp>) and monitor it with an <samp class="SANS_TheSansMonoCd_W5Regular_11">if</samp> statement, as you’ve seen here.</p>
<p class="TX">Until you’re very confident in how FPGA <samp class="SANS_TheSansMonoCd_W5Regular_11">for</samp> loops work, I recommend avoiding them in any synthesizable code.</p>
</section>
</section>
</section>
<section aria-labelledby="sec10" epub:type="division">
<h2 class="H1" id="sec10"><span id="h-89"/><span aria-label=" Page 131. " epub:type="pagebreak" id="pg_131" role="doc-pagebreak"/><samp class="SANS_Futura_Std_Bold_B_11">Place and Route</samp></h2>
<p class="TNI1"><i>Place and route</i> is the process of taking your synthesized design and mapping it to physical locations on your specific FPGA. The place and route tool decides exactly which LUTs, flip-flops, and block RAMs (and other components we haven’t talked about yet) in your FPGA will be used, and wires them all together. At the end of the process, you get a file that can be loaded onto the FPGA. As you’ve seen, actually programming the FPGA using this file is usually a separate step.</p>
<p class="TX">Place and route, as the name implies, is in fact two processes: the placement of the synthesized design into your FPGA, and then the routing of that design using physical wires to connect everything together. The routing process is often the most time-consuming step in the build process, especially for large designs. On a single computer, it can take several hours to route a complicated FPGA. This is one of the main reasons why simulations are critical. You may only get a few chances a day to test your design on an actual FPGA because the build process takes so long, so it’s best to iron out as many problems as you can through simulation <i>before</i> starting this process.</p>
<section aria-labelledby="sec11" epub:type="division">
<h3 class="H2" id="sec11"><span id="h-90"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Constraints</samp></h3>
<p class="TNI1">To run the place and route process, you need to constrain at least two aspects of your design: the pins and the clock(s). There are other elements that can be constrained as well—input/output delays, specific routing, and more—but these two are the most fundamental.</p>
<p class="TX">The pin constraints tell the place and route tool which signals in the Verilog or VHDL code are mapped to which physical pins on the FPGA. When you’re working with your circuit board, you’ll need to look at the PCB schematic to know which FPGA pins connect to switches, which pins connect to LEDs, and so on. This is an example of a situation in which having some knowledge of how to read schematics is helpful for an FPGA designer.</p>
<p class="TX">The clock constraints tell the tool about the clock frequency used to drive your FPGA (or frequencies, if you have multiple clock domains, as we’ll discuss later in the chapter). Clock constraints are fundamental to the routing process, in particular, since there are physical limitations on how far a signal can travel and how much can be done to it within a single clock period. When the place and route process finishes, it will generate a timing report that takes the clock constraints into account. If everything is sure to work under the specified clock constraints, the design is said to meet timing, and the report will show this. If, however, the tool determines that the clock constraints may be too tight for what you’ve designed, the tool will display timing errors in your timing report. As you’ll see next, timing errors are really bad!</p>
</section>
<section aria-labelledby="sec12" epub:type="division">
<h3 class="H2" id="sec12"><span id="h-91"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Timing Errors</samp></h3>
<p class="TNI1">Timing errors occur when your design and clock constraints are asking for the FPGA components and wires to work at a faster pace than the place <span aria-label=" Page 132. " epub:type="pagebreak" id="pg_132" role="doc-pagebreak"/>and route tool can guarantee they can handle. This means your FPGA might not work as desired. I say <i>might</i> because it’s possible that it will work perfectly, despite the timing errors—there’s no way to know for sure ahead of time. This is in part because an FPGA’s performance is affected by its operating conditions; it can vary, for example, based on changes in voltage and temperature. It might sound odd that your FPGA will perform slightly differently at cold temperatures versus hot temperatures, but that’s the reality.</p>
<p class="TX">It’s the job of the place and route tool to stress your design and analyze how it will perform in all possible operating conditions, including worst-case scenarios. If the design can run at your specified clock frequency across all those conditions, the tool can guarantee that the FPGA will meet timing; otherwise, it will report timing errors. The tools won’t stop you from programming your FPGA with a design that contains timing errors. Maybe they should, but they don’t. Again, this is because it’s uncertain whether or how the timing errors will manifest. The tools don’t know if you’ll be running your design on your desk at room temperature, or on a satellite in the vacuum of space. In either case, the design might work, or it might fail, or it might appear to work perfectly for five minutes before manifesting a small error. Timing errors can produce strange behavior.</p>
<p class="TX">I once was brought onto an FPGA design for a camera product that was riddled with timing errors that the previous designer hadn’t bothered to fix. Instead, they had built the design, looked at the report and seen that it contained dozens of timing errors, and programmed the FPGA anyway. They then tested it at their desk to see if it worked. They ran it for a few minutes and didn’t run into any problems, so they decided it was fine and integrated it into the product. Then the product started to fail in odd ways. Pixels would blink, or the scene would flicker, but only occasionally, so the user might ignore it. Even stranger, only some products would have issues, and the severity of the problem varied from unit to unit.</p>
<p class="TX">Once someone realized how bad the issue was, a serious effort was made to fix the timing errors and produce an FPGA design that would work 100 percent of the time. The FPGA tools had been trying to tell the original designer that there might be a problem. Not a <i>functional</i> problem—the code was theoretically OK as written—but there was a chance that it wouldn’t work correctly with the given clock constraints under all operating conditions. The moral of this story is that when an FPGA acts in weird ways, it’s very possible that you haven’t looked closely at your timing report (or, as was the case with my prior coworker, ignored it completely!).</p>
<p class="TX">At their root, timing errors arise because FPGAs are subject to physical limitations. Up to this point, we’ve been working in an ideal world. We’ve imaged that all signals can travel instantly from their source to their destination, and that all flip-flops can change their output instantly when they see a rising clock edge. We’ve been assuming that if the code is correct, then everything will just work.</p>
<p class="TX">Welcome to reality! In the real world, nothing is truly instantaneous, and components behave in unpredictable ways if they’re asked to work too quickly. Three physical limitations that contribute to FPGA timing errors <span aria-label=" Page 133. " epub:type="pagebreak" id="pg_133" role="doc-pagebreak"/>are setup time, hold time, and propagation delay. Let’s take a quick look at these, and then we’ll explore how to fix timing errors.</p>
<section aria-labelledby="sec13" epub:type="division">
<h4 class="H3" id="sec13"><samp class="SANS_Futura_Std_Bold_Condensed_B_11">Setup and Hold Time</samp></h4>
<p class="TNI1"><i>Setup time</i> is the amount of time for which the input to a flip-flop is required to be stable <i>before</i> a clock edge in order for the flip-flop to accurately register the input data to its output on that clock edge. <i>Hold time</i> is the amount of time for which the input must be stable <i>after</i> a clock edge in order for the flip-flop to reliably hold its current output value until the next clock edge. This is illustrated in <a href="#fig7-1">Figure 7-1</a>.</p>
<figure class="IMG"><img alt="" class="img30" id="fig7-1" src="../images/Figure7-1.png"/>
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 7-1: Setup (t</samp><samp class="SANS_Futura_Std_Book_Oblique_I-SUB_11">su</samp><samp class="SANS_Futura_Std_Book_Oblique_I_11">) and hold (t</samp><samp class="SANS_Futura_Std_Book_Oblique_I-SUB_11">h</samp><samp class="SANS_Futura_Std_Book_Oblique_I_11">) time</samp></p></figcaption>
</figure>
<p class="TX">We expect the flip-flop to register some data at the rising clock edge shown in the middle of the figure. The time immediately before the rising edge is the setup time, labeled <i>t</i><span class="ePub-I-SUB">su</span>. The time immediately after the rising edge is the hold time, labeled <i>t</i><span class="ePub-I-SUB">h</span>. If the data input to the flip-flop changes outside the setup and hold window, then everything works fine. However, bad things can happen if your data input changes during the setup and hold window. Specifically, the flip-flop can become <i>metastable</i>, entering a state where its output is unstable: it could be a 1, it could be a 0, or it could even be somewhere in between. <a href="#fig7-2">Figure 7-2</a> shows an example of a metastable event.</p>
<figure class="IMG"><img alt="" class="img40" id="fig7-2" src="../images/Figure7-2.png"/>
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 7-2: A metastable condition</samp></p></figcaption>
</figure>
<p class="TX"><span aria-label=" Page 134. " epub:type="pagebreak" id="pg_134" role="doc-pagebreak"/>Here we see a clock signal and the input and output signals of a flip-flop. The shaded area of the input signal labeled <i>t</i><span class="ePub-I-SUB">su</span> represents the flip-flop’s setup time, immediately before the rising clock edge. As you can see, the data input to the flip-flop transitions from low to high during the setup window. This causes the output to be metastable for some amount of time, after which it settles out to either a 0 or a 1.</p>
<p class="TX">To understand metastability, people often use the analogy of a ball balanced on top of a hill, as shown in <a href="#fig7-3">Figure 7-3</a>. The ball could roll down the hill either to the left or to the right, and there’s no predicting which way it’ll go. A random gust of wind could blow it one way or the other. If it rolls down to the left, that’s state 0, and if it rolls to the right, that’s state 1. When the output of a flip-flop is in a metastable state, it’s a ball teetering on a hill, trying to find a more stable state to rest into.</p>
<figure class="IMG"><img alt="" class="img50" id="fig7-3" src="../images/Figure7-3.png"/>
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 7-3: A metastable state</samp></p></figcaption>
</figure>
<p class="TX">In addition to not knowing which way the ball will roll, there’s also no way to tell how long it will take for the ball to roll down the hill. It might fall quickly, or it might take a while. This is known as the <i>metastable resolution time</i>, or the time it takes for a metastable situation to become stable.</p>
<p class="TX">There’s no way to know ahead of time which state the output will settle on. Sometimes it might be a 0, while other times when this situation occurs it might be a 1. Assuming the data input doesn’t change again, the output will definitely be a 1 at the next rising clock edge, when the flip-flop again registers its input to its output. In the meantime, however, for the duration of this one clock cycle, there’s no telling what the output will be, and this is not desired behavior for an FPGA.</p>
<p class="TX">If your design has timing errors, your FPGA tools are telling you that one or more flip-flops could have their setup and hold windows violated, which could put them in a metastable state. Metastability is probabilistic, however, so there’s no guarantee that it will actually occur. There’s a chance that your design will be completely fine despite the reported timing errors, but there’s also a chance that the FPGA will exhibit strange and unpredictable behavior. In FPGA design we like things to be predictable, so even the remote possibility of metastability occurring is a problem.</p>
<p class="TX">Metastable conditions can occur when either the setup or the hold time is violated, but setup and hold time are physical properties of your FPGA and are beyond your control. You can’t modify your design in a way that will <span aria-label=" Page 135. " epub:type="pagebreak" id="pg_135" role="doc-pagebreak"/>change the setup or hold time. In order to resolve a timing error, you must focus your efforts on the other main physical limitation of FPGAs: propagation delay.</p>
</section>
<section aria-labelledby="sec14" epub:type="division">
<h4 class="H3" id="sec14"><samp class="SANS_Futura_Std_Bold_Condensed_B_11">Propagation Delay</samp></h4>
<p class="TNI1"><i>Propagation delay</i> is the amount of time it takes for a signal to travel from a source to a destination. As mentioned previously, in the real world this is not instantaneous: it takes some time, albeit a very small amount, for voltage changes to propagate down a wire. A decent rule of thumb is that signals can travel along a wire at a rate of 1 foot per nanosecond. That may not sound like much of a delay, but consider that there are thousands of tiny wires running everywhere inside your FPGA. When you add up the physical length of the wires the total can be amazingly long, considering how small the chips are. This can lead to a significant propagation delay as signals travel from one flip-flop to another.</p>
<p class="TX">Additionally, every piece of logic that a signal goes through—for example, a LUT representing an AND gate—adds some extra time to the propagation delay, since these logic operations aren’t perfectly instantaneous either. This concept is illustrated in <a href="#fig7-4">Figure 7-4</a>.</p>
<figure class="IMG"><img alt="" class="img50" id="fig7-4" src="../images/Figure7-4.png"/>
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 7-4: Propagation delay between two flip-flops</samp></p></figcaption>
</figure>
<p class="TX">Here we have two flip-flops, with data traveling from the output of one flip-flop to the input of the other. The logic and routing in between might consist of wires and/or LUTs. This is where the propagation delay happens, and the more stuff there is in that cloud—for example, longer wires or more LUTs—the longer it will take for the output of flip-flop 1 to reach the input of flip-flop 2. If the propagation delay is too long, the design won’t be able to meet timing at the requested clock constraint.</p>
<p class="TX">The issue here is that both flip-flops are driven by the same clock. If flip-flop 1 sees a change on its input and registers that change to its output at one rising clock edge, we’d expect flip-flop 2 to see that change and register it at the next rising clock edge. The signal only has a single clock period to propagate from flip-flop 1 to flip-flop 2. If the signal can safely arrive within that time, the design will work. But if the logic and routing in between the flip-flops create too long of a propagation delay, we’ll get a timing error. There might be many thousands of flip-flops in <span aria-label=" Page 136. " epub:type="pagebreak" id="pg_136" role="doc-pagebreak"/>the FPGA design, and it’s the responsibility of the place and route tool to analyze every single path and show us the worst offenders from a timing perspective.</p>
<p class="TX">In fact, the signal has <i>less</i> than the length of a single clock period to propagate from flip-flop 1 to flip-flop 2, since we also need to take the setup time into account. The propagation delay may be less than the clock period, but as we’ve just seen, if the signal arrives at flip-flop 2 within its setup window, the output of flip-flop 2 will be uncertain. This leads to the following formula for calculating the clock period needed for a design to function properly:</p>
<p class="EQ"><i>t</i><span class="ePub-I-SUB">clk(min)</span> = <i>t</i><span class="ePub-I-SUB">su</span> + <i>t</i><span class="ePub-I-SUB">p</span></p>
<p class="TX">Here, <i>t</i><span class="ePub-I-SUB">clk(min)</span> is the minimum clock period required for the design to work without timing errors, <i>t</i><span class="ePub-I-SUB">su</span> is the setup time, and <i>t</i><span class="ePub-I-SUB">p</span> is the worst propagation delay the design will experience between two flip-flops. As an example, say all of the flip-flops on the FPGA have a fixed setup time of 2 ns and our design will create a propagation delay of up to 10 ns (in the worst case) between two particular flip-flops. Our formula tells us that our clock needs to have a period of at least 2 + 10 = 12 ns, which works out to a frequency of 83.3 MHz. We could easily run the design with a slower clock than that if we wanted, in which case the period would be even longer, but if we wanted to run the FPGA faster, say at 100 MHz, then the clock period would be too short and we would get timing errors.</p>
</section>
<section aria-labelledby="sec15" epub:type="division">
<h4 class="H3" id="sec15"><samp class="SANS_Futura_Std_Bold_Condensed_B_11">How to Fix Timing Errors</samp></h4>
<p class="TNI1">As you’ve just seen, the clock period, setup time, and propagation delay are the main factors contributing to timing errors. Since the setup time is fixed, there are two basic ways to solve timing errors:</p>
<ul class="BL">
<li class="BL">Slow down the clock frequency.</li>
<li class="BL">Reduce the propagation delay by breaking up the logic into stages.</li>
</ul>
<p class="TX">Slowing down your clock frequency might seem like the most obvious choice. If you’re able to run your FPGA slower, your timing will improve. However, it’s unlikely that you’ll be able to change your clock frequency freely; it’s usually set in stone for some particular reason, such as if you’re interfacing to a peripheral that needs to run at a specific frequency. Chances are you won’t be able to slow the clock down just to relax timing.</p>
<p class="TX">Breaking up your logic into stages, also known as <i>pipelining</i>, is the more robust (and often the only) option. If you do less “stuff” between any two flip-flops, the propagation delay will decrease, and it will be easier for your design to meet timing. <a href="#fig7-5">Figure 7-5</a> illustrates how this works.</p>
<span aria-label=" Page 137. " epub:type="pagebreak" id="pg_137" role="doc-pagebreak"/>
<figure class="IMG"><img alt="" class="img50" id="fig7-5" src="../images/Figure7-5.png"/>
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 7-5: Reducing the propagation delay through pipelining</samp></p></figcaption>
</figure>
<p class="TX">In the top half of the figure, we have a large amount of logic between two flip-flops—so much that the design has too long of a propagation delay and fails timing. The solution, shown in the bottom half of the figure, is to break up the logic into two stages, with another flip-flop added in between. This way, half of the logic can be done between flip-flops 1 and 2, and the other half between flip-flops 2 and 3. The propagation delay for each of these stages should be short enough that the stages can be accomplished in a single clock cycle, and overall the tools will have two clock cycles to do what we were originally trying to do in one clock cycle.</p>
<p class="TX">When you break up a single stage in your design into multiple stages like this, you’re creating a <i>pipeline</i> of operations, with a flip-flop between each stage to synchronize the operations with the clock. A well-pipelined design will have a much better chance at meeting timing at high clock frequencies. To demonstrate, let’s consider an example of some code that has poor timing, and then look at how to pipeline the logic to avoid timing errors. First, here’s the problematic code:</p>
<p class="Label"><samp class="SANS_Futura_Std_Bold_Oblique_BI_11">Verilog</samp></p>
<pre><code>module timing_error
  (input            i_Clk,
  input [7:0]       i_Data,
  output reg [15:0] o_Data);
  reg [7:0] r0_Data = 0;
  always @(posedge i_Clk)
  begin
     r0_Data &lt;= i_Data;
  <span aria-label="annotation1" class="CodeAnnotationCode">❶</span> o_Data  &lt;= ((r0_Data / 3) + 1) * 5;
  end
endmodule</code></pre>
<p class="Label"><span aria-label=" Page 138. " epub:type="pagebreak" id="pg_138" role="doc-pagebreak"/><samp class="SANS_Futura_Std_Bold_Oblique_BI_11">VHDL</samp></p>
<pre><code>library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
entity timing_error is
  port (
    i_Clk  : in std_logic;
    i_Data : in unsigned(7 downto 0);
    o_Data : out unsigned(15 downto 0));
end entity timing_error;
architecture RTL of timing_error is
  signal r0_Data : unsigned(7 downto 0);
begin
  process (i_Clk) is
  begin
    if rising_edge(i_Clk) then
       r0_Data &lt;= i_Data;
    <span aria-label="annotation1" class="CodeAnnotationCode">❶</span> o_Data &lt;= ((r0_Data / 3) + 1) * 5;
    end if;
  end process;
end RTL;</code></pre>
<p class="TX">I can’t imagine why anyone would write code like this, but it will do for demonstration purposes. The problem arises when we perform some mathematical operations—division, addition, and multiplication—on the value of <samp class="SANS_TheSansMonoCd_W5Regular_11">r0_Data</samp> <span aria-label="annotation1" class="CodeAnnotation">❶</span>. All three of these operations are performed on the same line, inside a synchronous <samp class="SANS_TheSansMonoCd_W5Regular_11">always</samp> or <samp class="SANS_TheSansMonoCd_W5Regular_11">process</samp> block, which means they must occur within one clock cycle. To do all that math, the output of the 8-bit-wide register <samp class="SANS_TheSansMonoCd_W5Regular_11">r0_Data</samp> will pass through a bunch of LUTs, then into the inputs of the flip-flops for <samp class="SANS_TheSansMonoCd_W5Regular_11">o_Data</samp>, all within one clock cycle. This puts us firmly in the upper half of <a href="#fig7-5">Figure 7-5</a>: the mathematical operations require a lot of logic and will create a considerable propagation delay.</p>
<p class="TX">Let’s see what happens when we run this code through place and route with a 100 MHz clock constraint. Here’s the resulting timing report:</p>
<pre><code><var>--snip--</var>
4.1::Critical Path Report for i_Clk
***********************************
Clock: i_Clk
<span aria-label="annotation1" class="CodeAnnotationHang">❶</span> Frequency: 89.17 MHz | Target: 100.00 MHz
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
<span aria-label="annotation2" class="CodeAnnotationHang">❷</span> Path Begin : r0_Data_fast_5_LC_1_9_5/lcout
<span aria-label="annotation3" class="CodeAnnotationHang">❸</span> Path End : o_DataZ0Z_7_LC_5_12_5/in3
Capture Clock : o_DataZ0Z_7_LC_5_12_5/clk
Setup Constraint : 10000p
<span aria-label="annotation4" class="CodeAnnotationHang">❹</span> Path slack : -1215p
<var>--snip--</var></code></pre>
<p class="TX"><span aria-label=" Page 139. " epub:type="pagebreak" id="pg_139" role="doc-pagebreak"/>We can see that we tried to drive the clock to 100 MHz, but the place and route tool can only guarantee timing up to 89.17 MHz <span aria-label="annotation1" class="CodeAnnotation">❶</span>. When the target frequency is higher than the maximum achievable frequency, we’ll have timing errors. The timing report then tells us about the worst-offending paths in the design, albeit a little cryptically. First, the report identifies the beginning <span aria-label="annotation2" class="CodeAnnotation">❷</span> and end <span aria-label="annotation3" class="CodeAnnotation">❸</span> of each problematic path. Notice that <samp class="SANS_TheSansMonoCd_W5Regular_11">r0_Data</samp> is in the signal name of <samp class="SANS_TheSansMonoCd_W5Regular_11">Path Begin</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">o_Data</samp> is in the signal name of <samp class="SANS_TheSansMonoCd_W5Regular_11">Path End</samp>, but there’s a bunch of extra stuff there too. The tools add this additional information to identify the exact locations of the components in question within the FPGA. The downside is that the information isn’t very human-readable, but since the core signal names have persisted, we can see that the path from <samp class="SANS_TheSansMonoCd_W5Regular_11">r0_Data</samp> to <samp class="SANS_TheSansMonoCd_W5Regular_11">o_Data</samp> is the failing path. Further, the report tells us exactly how much the path is failing by <span aria-label="annotation4" class="CodeAnnotationCode">❹</span>. The <i>path slack</i> is the amount of wiggle room the path has available to meet timing, and the fact that it’s negative is telling us we’re too slow; we need an additional 1,215 picoseconds (ps), or 1.215 ns, to remove this timing error. That makes sense, since the difference in clock period between 89.17 MHz and 100 MHz is 1,215 ps.</p>
<p class="TX">Now that we’ve identified the failing path, we can pipeline the path’s logic by breaking up the math operations with some flip-flops. Here’s what that might look like:</p>
<p class="Label"><samp class="SANS_Futura_Std_Bold_Oblique_BI_11">Verilog</samp></p>
<pre><code>module timing_error
  (input            i_Clk,
  input [7:0]       i_Data,
  output reg [15:0] o_Data);
  reg [7:0] r0_Data, r1_Data, r2_Data = 0;
  always @(posedge i_Clk)
  begin
     r0_Data &lt;= i_Data;
  <span aria-label="annotation1" class="CodeAnnotationCode">❶</span> r1_Data &lt;= r0_Data / 3;
  <span aria-label="annotation2" class="CodeAnnotationCode">❷</span> r2_Data &lt;= r1_Data + 1;
  <span aria-label="annotation3" class="CodeAnnotationCode">❸</span> o_Data  &lt;= r2_Data * 5;
  end
endmodule</code></pre>
<p class="Label"><samp class="SANS_Futura_Std_Bold_Oblique_BI_11">VHDL</samp></p>
<pre><code>library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
entity timing_error is
  port (
    i_Clk  : in  std_logic;
    i_Data : in  unsigned(7 downto 0);
    o_Data : out unsigned(15 downto 0));
end entity timing_error;
architecture RTL of timing_error is
  signal r0_Data, r1_Data, r2_Data : unsigned(7 downto 0);
<span aria-label=" Page 140. " epub:type="pagebreak" id="pg_140" role="doc-pagebreak"/>begin
  process (i_Clk) is
  begin
    if rising_edge(i_Clk) then
       r0_Data &lt;= i_Data;
    <span aria-label="annotation1" class="CodeAnnotationCode">❶</span> r1_Data &lt;= r0_Data / 3;
    <span aria-label="annotation2" class="CodeAnnotationCode">❷</span> r2_Data &lt;= r1_Data + 1;
    <span aria-label="annotation3" class="CodeAnnotationCode">❸</span> o_Data  &lt;= r2_Data * 5;
    end if;
  end process;
end RTL;</code></pre>
<p class="TX">We’ve taken what used to be a single line of code and broken it up into three lines. First, we perform just the division operation and write the result to an intermediary signal, <samp class="SANS_TheSansMonoCd_W5Regular_11">r1_Data</samp> <span aria-label="annotation1" class="CodeAnnotation">❶</span>. Then we perform the addition operation on <samp class="SANS_TheSansMonoCd_W5Regular_11">r1_Data</samp> and assign the result to <samp class="SANS_TheSansMonoCd_W5Regular_11">r2_Data</samp> <span aria-label="annotation2" class="CodeAnnotation">❷</span>, and finally we perform the multiplication operation on <samp class="SANS_TheSansMonoCd_W5Regular_11">r2_Data</samp> and assign the result to our original output, <samp class="SANS_TheSansMonoCd_W5Regular_11">o_Data</samp> <span aria-label="annotation3" class="CodeAnnotation">❸</span>. We’ve introduced new signals to distribute the large math operation that was occurring in a single clock cycle across multiple clock cycles. This should reduce the propagation delay. Indeed, if we run the new, pipelined design through place and route, we’ll get the following timing report:</p>
<pre><code><var>--snip--</var>
4.1::Critical Path Report for i_Clk
***********************************
Clock: i_Clk
Frequency: 110.87 MHz | Target: 100.00 MHz
<var>--snip--</var></code></pre>
<p class="TX">Now we’re meeting timing: the place and route tool can guarantee performance up to a clock frequency of 110.87 MHz, when the target frequency was 100 MHz. As you’ve seen, fixing the timing errors involved a bit of trade-off. We had to add flip-flops into our design to break up the logic into stages, so our design now uses more FPGA resources than before. Additionally, the math operation that was meant to take a single clock cycle now takes three clock cycles. However, keep in mind that our module can still take in new input values at a rate of 100 MHz and spit out calculated output values at a rate of 100 MHz, as we intended with the original design; it’s only the <i>first</i> result to come out of the pipeline that will take two additional clock cycles, due to the added flip-flops.</p>
</section>
<section aria-labelledby="sec16" epub:type="division">
<h4 class="H3" id="sec16"><samp class="SANS_Futura_Std_Bold_Condensed_B_11">Unexpected Timing Errors</samp></h4>
<p class="TNI1">You can fix most timing errors by pipelining your design to cut down on propagation delay and avoid metastable conditions. However, place and route tools can’t anticipate every timing error. These tools aren’t perfect; they can only analyze your design based on the information they have. Even if you don’t see any errors in your timing report, there are two situations <span aria-label=" Page 141. " epub:type="pagebreak" id="pg_141" role="doc-pagebreak"/>where metastable conditions may still occur that the place and route tool can’t reliably predict:</p>
<ul class="BL">
<li class="BL">When sampling a signal asynchronous to the FPGA clock</li>
<li class="BL">When crossing clock domains</li>
</ul>
<p class="TX">Sampling a signal asynchronous to the FPGA clock is very common when you have an external signal that serves as input to your FPGA. The input signal will go directly to the input of a flip-flop in your design, but it will be asynchronous, meaning it isn’t coordinated by your main FPGA clock. For example, think about someone pushing a button. That button press could come at any time, so if it happens to occur during the setup time of the flip-flop the button is wired to, then that flip-flop will be in a metastable state. The place and route tool doesn’t know anything about this potential issue, so it won’t flag it as a timing error. But you, dear FPGA designer, can anticipate and fix the problem. The solution is to <i>double-flop</i> the input data by passing it through an extra flip-flop, as shown in <a href="#fig7-6">Figure 7-6</a>.</p>
<figure class="IMG"><img alt="" class="img50" id="fig7-6" src="../images/Figure7-6.png"/>
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 7-6: Double-flopping to fix metastability</samp></p></figcaption>
</figure>
<p class="TX">In this figure, a signal that’s asynchronous to the clock is being sampled by the first flip-flop. Since we can’t guarantee the timing of this input relative to the clock, it might violate setup or hold times and create a metastable condition at the output of the first flip-flop. As discussed previously, though, the occurrence of a metastable condition is probabilistic. It’s also quite rare. Even if the first flip-flop enters a metastable state, it’s highly unlikely that the second flip-flop will enter one too. In fact, adding a second flip-flop in series with the first one reduces the likelihood of a metastable condition at the output to effectively zero. (Adding a third flip-flop in series would decrease the likelihood even more, but FPGA experts have concluded that two flip-flops in series is enough.) We can now use the stable signal internal to our design and be confident that we won’t see strange behavior.</p>
<p class="TX">The other situation where you still may encounter a metastable state is when you cross clock domains in your FPGA. This is a big topic that warrants its own section.</p>
</section>
</section>
</section>
<section aria-labelledby="sec17" epub:type="division">
<h2 class="H1" id="sec17"><span id="h-92"/><samp class="SANS_Futura_Std_Bold_B_11">Crossing Clock Domains</samp></h2>
<p class="TNI1">As I’ve mentioned, it’s possible to have multiple clock domains inside a single FPGA, with different clocks driving different parts of the design. You might <span aria-label=" Page 142. " epub:type="pagebreak" id="pg_142" role="doc-pagebreak"/>need a camera interface running at 25.725 MHz and an HDMI interface running at 148.5 MHz, for example. If you wanted to send the data from the camera out to the HDMI for visualization on a monitor, that data would have to cross clock domains, moving from the part of the design controlled by a 25.725 MHz clock to the part of the design controlled by a 148.5 MHz clock. However, there’s no way to guarantee the alignment between these clock domains; they can drift apart and back together. Even if the clocks have a seemingly predictable relationship, like a 50 MHz clock and a 100 MHz clock, you can’t be sure that the clocks started at the same time.</p>
<p class="NOTE"><span class="NoteHead"><samp class="SANS_Dogma_OT_Bold_B_21">NOTE</samp></span></p>
<p class="NOTE-TXT"><i>The exception is if you’re using an FPGA component called a</i> <span class="Roman">phase-locked loop (PLL)</span><i>, which can generate unique clock frequencies and establish relationships between them. The PLL is discussed in detail in <a href="chapter9.xhtml">Chapter 9</a>.</i></p>
<p class="TX">The bottom line is that when you have clock domains that are asynchronous to each other, signals crossing between domains might produce metastable states within some flip-flops. In this section, we’ll look at how to cross clock domains safely, from slower to faster and vice versa, and avoid metastability. We’ll also discuss how to use a FIFO to send large amounts of data across clock domains.</p>
<section aria-labelledby="sec18" epub:type="division">
<h3 class="H2" id="sec18"><span id="h-93"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Crossing from Slower to Faster</samp></h3>
<p class="TNI1">The simplest situation to handle is going from a slower clock domain to a faster clock domain. To avoid problems, all you need to do is double-flop the data when it enters the faster domain, as shown in <a href="#fig7-7">Figure 7-7</a>. This is the same approach we took to fix the external asynchronous signal, since it’s fundamentally the same issue: the signal from the slower clock domain is asynchronous to the faster clock domain that it’s entering.</p>
<figure class="IMG"><img alt="" class="img100" id="fig7-7" src="../images/Figure7-7.png"/>
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 7-7: Crossing from a slower to a faster clock domain</samp></p></figcaption>
</figure>
<p class="TX">In <a href="#fig7-7">Figure 7-7</a>, we have three flip-flops in series. The first is driven by a slower clock, while the others are driven by a faster clock. The slower clock is your <i>source clock domain</i>, and the faster clock is your <i>destination clock domain</i>. Since the clocks are asynchronous to each other, we can’t guarantee that data coming from the slower clock domain won’t violate the setup or hold times of the middle flip-flop (the first one in the faster clock domain) and trigger a metastable state. However, we know that the output of the second of these flip-flops will be stable, allowing the data to be used in the faster clock domain. Let’s look at how this design could be implemented in code:</p>
<p class="Label"><span aria-label=" Page 143. " epub:type="pagebreak" id="pg_143" role="doc-pagebreak"/><samp class="SANS_Futura_Std_Bold_Oblique_BI_11">Verilog</samp></p>
<pre><code>always @(posedge i_Fast_Clk)
  begin
  <span aria-label="annotation1" class="CodeAnnotationCode">❶</span> r1_Data &lt;= i_Slow_Data;
  <span aria-label="annotation2" class="CodeAnnotationCode">❷</span> r2_Data &lt;= r1_Data;
  end</code></pre>
<p class="Label"><samp class="SANS_Futura_Std_Bold_Oblique_BI_11">VHDL</samp></p>
<pre><code>process (i_Fast_Clk) is
begin
  if rising_edge(i_Fast_Clk) then
  <span aria-label="annotation1" class="CodeAnnotationCode">❶</span> r1_Data &lt;= i_Slow_Data;
  <span aria-label="annotation2" class="CodeAnnotationCode">❷</span> r2_Data &lt;= r1_Data;
  end if;
end process;</code></pre>
<p class="TX">The code consists of an <samp class="SANS_TheSansMonoCd_W5Regular_11">always</samp> or <samp class="SANS_TheSansMonoCd_W5Regular_11">process</samp> block running off the positive edges of the faster clock. First, the signal <samp class="SANS_TheSansMonoCd_W5Regular_11">i_Slow_Data</samp> (coming from the slower domain) enters flip-flop <samp class="SANS_TheSansMonoCd_W5Regular_11">r1_Data</samp> <span aria-label="annotation1" class="CodeAnnotation">❶</span>. The output of this flip-flop could be metastable if a change in <samp class="SANS_TheSansMonoCd_W5Regular_11">i_Slow_Data</samp> violates its setup or hold time, but we resolve this metastable condition by double-flopping the data, passing it through a second flip-flop, <samp class="SANS_TheSansMonoCd_W5Regular_11">r2_Data</samp> <span aria-label="annotation2" class="CodeAnnotation">❷</span>. At this point, we have stable data that we can use in the faster clock domain without having to worry about metastable conditions.</p>
<p class="TX">One word of caution about writing code for an FPGA that uses two clock domains: be very careful to keep the code for the two domains separate. Keep all of your slower signals in one <samp class="SANS_TheSansMonoCd_W5Regular_11">always</samp> or <samp class="SANS_TheSansMonoCd_W5Regular_11">process</samp> block, clearly separated from the faster signals in a different <samp class="SANS_TheSansMonoCd_W5Regular_11">always</samp> or <samp class="SANS_TheSansMonoCd_W5Regular_11">process</samp> block (the exception is signals crossing between domains). In fact, I find it helpful to put code that runs in different clock domains in completely different files, just to be sure I’m not mixing and matching signals.</p>
</section>
<section aria-labelledby="sec19" epub:type="division">
<h3 class="H2" id="sec19"><span id="h-94"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Crossing from Faster to Slower</samp></h3>
<p class="TNI1">Going from a faster clock domain to a slower one is more complicated than the other way around, since the data inside the faster clock domain could easily change before the slower clock domain even sees it. For example, consider a pulse that occurs for one clock cycle in a 100 MHz clock domain, that you’re trying to detect in a 25 MHz clock domain. There’s a good chance that you’ll never see this pulse, as illustrated in <a href="#fig7-8">Figure 7-8</a>.</p>
<figure class="IMG"><img alt="" class="img100" id="fig7-8" src="../images/Figure7-8.png"/>
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 7-8: A failed crossing from a faster to a slower clock domain</samp></p></figcaption>
</figure>
<p class="TX"><span aria-label=" Page 144. " epub:type="pagebreak" id="pg_144" role="doc-pagebreak"/>This figure shows two cycles of the 25 MHz clock. After the clock’s first rising edge but before its second rising edge, the 100 MHz pulse comes and goes, so fast that the 25 MHz clock never “sees” and registers it. This is because the pulse doesn’t occur during the rising edge of the 25 MHz clock. Therefore, the pulse will go completely unnoticed in the 25 MHz clock domain. The solution to this problem is to <i>stretch out</i> any signals from the faster clock domain that are meant to enter the slower clock domain, until they’re long enough to guarantee that they’ll be noticed. <a href="#fig7-9">Figure 7-9</a> shows how this works.</p>
<figure class="IMG"><img alt="" class="img100" id="fig7-9" src="../images/Figure7-9.png"/>
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 7-9: A successful crossing from a faster to a slower clock domain</samp></p></figcaption>
</figure>
<p class="TX">Looking at the new waveform of the 100 MHz pulse, we can see that it’s been stretched from a single cycle of the 100 MHz clock to multiple clock cycles, ensuring that a rising edge in the 25 MHz clock domain will see the pulse. As a general rule, pulses passing from a faster clock domain to a slower clock domain should be stretched to last at least two clock cycles in the slower domain. This way, even if the pulse violates the setup and hold time of the first clock cycle in the slower domain and triggers a metastable state, it will be stable at the second clock cycle. In our example, we should stretch out the 100 MHz pulse to at least eight 100 MHz clock cycles, the equivalent of two 25 MHz clock cycles. You can stretch the signals even longer if you like.</p>
</section>
<section aria-labelledby="sec20" epub:type="division">
<h3 class="H2" id="sec20"><span id="h-95"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Using a FIFO</samp></h3>
<p class="TNI1">In the previous examples we looked at how to transmit a simple pulse across clock domains. But what if you want to send a lot of data between two clock domains, such as when sending camera data to an HDMI interface? In this case, the most common method is to use a FIFO. You write data to the FIFO according to one clock and read it out according to the other. Of course, the key requirement here is that the FIFO must support two different clock frequencies, whereas the FIFO we looked at in <span class="Xref"><a href="chapter6.xhtml">Chapter 6</a></span> only supported one clock.</p>
<p class="TX">To cross clock domains with a FIFO, you’ll likely need to use a <i>primitive</i>, a dedicated FPGA component designed by the manufacturer specifically for your exact FPGA. For example, Intel will have prewritten FIFO primitives that run in different clock domains, but the Verilog or VHDL code to create them will differ from that of AMD’s FIFO primitives. (We’ll explore more examples of primitives in <a href="chapter9.xhtml">Chapter 9</a>.)</p>
<p class="TX">When using FIFOs, always remember not to violate the two cardinal rules: don’t read from an empty FIFO, and don’t write to a full FIFO. Many <span aria-label=" Page 145. " epub:type="pagebreak" id="pg_145" role="doc-pagebreak"/>FIFO primitives provide a count of the number of words (elements) in the FIFO as an output, but I don’t recommend relying on it. Instead, I suggest making heavy use of the <i>AF</i> and <i>AE</i> (almost full and almost empty) flags, introduced in <span class="Xref">“Input and Output Signals” on page 117</span>. It’s best to read from and write to the FIFO in bursts of a fixed size, especially when crossing clock domains, and to use that burst size to determine your AF and AE threshold levels. Set your AE level equal to your fixed burst size, and set your AF level equal to the FIFO depth minus your burst size. With this setup, you can guarantee that you’ll never break the two key rules. The AF flag can throttle the write clock interface by ensuring that if the FIFO doesn’t have enough room for another burst, writes will be disabled. Likewise, the AE flag can throttle the read clock interface by ensuring that if the FIFO doesn’t have a complete burst in it, the read side will not try to pull data out of the FIFO.</p>
<p class="TX">Let’s explore an example. Consider a case where we have some module writing data to a FIFO at 33 MHz. On the read side, we’re dumping the data as quickly as possible to external memory. Let’s say the read clock frequency is 110 MHz. In this situation, because the read clock is much faster than the write clock, the read side will be idle much of the time, even if the writes are happening at every clock cycle. To avoid reading from an empty FIFO, you can set the AE flag to some number that indicates to your read code that there’s a burst of data ready to be read. If you set it to 50 words, for example, once the FIFO has 50 words inside it the AE flag will change from a 1 to a 0, which will trigger some logic on the read side to drain exactly 50 words from the FIFO.</p>
<p class="TX">This is often how crossing clock domains gets implemented. If you’re using your AE/AF flags, you’re doing it correctly. Try not to rely on the flags that tell you when the FIFO is completely full or empty, and definitely don’t use the counter that some FIFOs support.</p>
</section>
<section aria-labelledby="sec21" epub:type="division">
<h3 class="H2" id="sec21"><span id="h-96"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Addressing Timing Errors</samp></h3>
<p class="TNI1">When running a design with multiple clock domains through the place and route process, you’ll need to include the frequencies of each clock in your clock constraints. The place and route tool will analyze data sent and received between these clock interfaces and report on any timing errors it observes. As you’ve seen, this is the tool telling you that you’re likely to encounter situations where setup and hold times will be violated, which could trigger metastable conditions.</p>
<p class="TX">Let’s assume you’ve handled the clock domain crossings well, using the double-flopping, data stretching, and FIFO methods discussed in the previous sections. You’re aware of the possibility of the metastable states, and you’ve prepared for them. The tool doesn’t know about the steps you’ve taken, though. It’s unable to see that you’re a smart FPGA designer and that you’ve got it all under control. To suppress the errors in your timing report, you’ll need to create some unique <i>timing constraints</i> that relax the tools and tell them that you’re a competent designer and that you understand that your design may be metastable. Exactly how to create these timing <span aria-label=" Page 146. " epub:type="pagebreak" id="pg_146" role="doc-pagebreak"/>constraints is beyond the scope of this book, as each FPGA vendor has its own unique style.</p>
<p class="TX">You should always aim to have no timing errors in your design. However, as an FPGA designer, you’ll inevitably experience situations where you cross clock domains. You need to clearly understand the common pitfalls that can occur in these situations. If the crossing is simple enough, you can just double-flop the data or perform data stretching. For many situations, you’ll likely need to use a FIFO that supports two clocks, one for reading and one for writing. When structuring your code that handles crossing clock domains, be very careful not to mix and match signals from both clock domains.</p>
</section>
</section>
<section aria-labelledby="sec22" epub:type="division">
<h2 class="H1" id="sec22"><span id="h-97"/><samp class="SANS_Futura_Std_Bold_B_11">Summary</samp></h2>
<p class="TNI1">In this chapter we’ve explored the FPGA build process in detail, looking closely at what happens to your FPGA code when it is synthesized and run through place and route. You’ve learned about different categories of non-synthesizable code, and in particular seen how <samp class="SANS_TheSansMonoCd_W5Regular_11">for</samp> loops synthesize differently than you may expect. While examining the place and route process, you learned about some of the physical limitations of FPGAs and saw how they can lead to timing errors. Finally, you learned some strategies for fixing timing errors, including errors that can arise when crossing clock domains. With this knowledge, you’ll be able to write your Verilog or VHDL code more confidently, and you’ll be able to address common issues that arise during the build process.</p>
</section>
</section>
</body>
</html>