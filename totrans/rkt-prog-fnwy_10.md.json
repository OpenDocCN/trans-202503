["```\n> let x = 0.8\n> let y = 7\n> (x + 1.2)*(7.7 / y)\n2.2\n```", "```\n\"(x + 1.2)*(7.7 / y)\"\n```", "```\n(\"(\" \"x\" \"+\" 1.2 \")\" \"*\" \"(\" 7.7 \"/\" \"Y\" \")\" )\n```", "```\n> (define unsigned-integer (regexp \"[0-9]+\"))\n```", "```\n> (regexp-match #rx\"[0-9]+\" \"Is the number 1234 an integer?\")\n'(\"1234\")\n```", "```\n> (regexp-match-positions #rx\"[0-9]+\" \"Is the number 1234 an integer?\")\n'((14 . 18))\n\n> (substring \"Is the number 1234 an integer?\" 14 18)\n\"1234\"\n```", "```\n> (regexp-match #rx\"[0-9]+\" \"Is the number 1234 an integer?\" 14 18)\n'(\"1234\")\n\n> (regexp-match-positions #rx\"[0-9]+\" \"Is the number 1234 an integer?\" 14 18)\n'((14 . 18))\n\n> (regexp-match #rx\"[0-9]+\" \"Is the number 1234 an integer?\" 16)\n'(\"34\")\n```", "```\n> (regexp-match #rx\"gizmo\" \"Is gizmo here?\")\n'(\"gizmo\")\n\n> (regexp-match #rx\"gizmo\" \"Is gixmo here?\")\n#f\n```", "```\n> (regexp-match #rx\"cats.*dogs\" \"It's raining cats and dogs!\")\n'(\"cats and dogs\")\n```", "```\n> (regexp-match #rx\"cats|dogs\" \"Do you like cats?\")\n'(\"cats\")\n> (regexp-match #rx\"cats|dogs\" \"Or do you like dogs?\")\n'(\"dogs\")\n```", "```\n> (regexp-match #rx\"^[0-9]+\" \"Is the number 1234 an integer?\" 16)\n'(\"34\")\n\n> (regexp-match #rx\"^[0-9]+\" \"Is the number 1234 an integer?\")\n#f\n\n> (regexp-match #rx\"^[0-9]+\" \"987 is an integer!\")\n'(\"987\")\n\n> (regexp-match #rx\"[0-9]+$\" \"987 is a number?\")\n#f\n\n> (regexp-match #rx\"[0-9]+$\" \"The number is at the end: 987\")\n'(\"987\")\n```", "```\n> (regexp-match #rx\"abc|def\" \"abcdef\")\n'(\"abc\")\n\n> (regexp-match #rx\"abc|def\" \"defabc\")\n'(\"def\")\n\n> (regexp-match #rx\"(abc)|(def)\" \"abcdef\")\n'(\"abc\" \"abc\" #f)\n\n> (regexp-match #rx\"ab(c|d)ef\" \"abcdef\")\n#f\n\n> (regexp-match #rx\"ab(c|d)ef\" \"abcef\")\n'(\"abcef\" \"c\")\n```", "```\n> (regexp-match #rx\"(?>abc)|(?>def)\" \"abcdef\")\n'(\"abc\")\n```", "```\n> (regexp-match* #rx\"(abc)|(def)\" \"abcdef\")\n'(\"abc\" \"def\")\n```", "```\n(define regex-ident #rx\"^[A-Za-z](?>[A-Za-z]|[0-9])*\")\n```", "```\n(define regex-number #rx\"^[0-9]+(?>\\\\.[0-9]+)?(?>e[+-]?[0-9]+)?\")\n```", "```\n> (regexp-match regex-number \"123\")\n'(\"123\")\n\n> (regexp-match regex-number \"a123\")\n#f\n(@\\pagebreak@)\n> (regexp-match regex-number \"123.\")\n'(\"123\")\n```", "```\n> (regexp-match regex-number \"123.0\")\n'(\"123.0\")\n```", "```\n> (regexp-match regex-number \"123.456\")\n'(\"123.456\")\n\n> (regexp-match regex-number \"123.456e\")\n'(\"123.456\")\n```", "```\n> (regexp-match regex-number \"123.456e23\")\n'(\"123.456e23\")\n\n> (regexp-match regex-number \"123.456e+23\")\n'(\"123.456e+23\")\n\n> (regexp-match regex-number \"123e+23\")\n'(\"123e+23\")\n\n> (regexp-match regex-number \"123e23\")\n'(\"123e23\")\n\n> (regexp-match regex-number \"e23\")\n#f\n```", "```\n(define regex-op #rx\"^[-+*/^=]\")\n```", "```\n(define regex-ws #rx\"^ *\")\n```", "```\n(define regex-fname #rx\"^(sin|cos|tan|asin|acos|atan|log|ln|sqrt)\")\n```", "```\n(define regex-keyword #rx\"^let\")\n```", "```\n(define (tokenize instr)\n  (let loop ([i 0])\n    (let* ([str-len (string-length instr)]\n           [next-pos 0]\n        ➊ [start (cdar (regexp-match-positions regex-ws instr i))])\n\n      (define (match-reg regex)\n        (let ([v (regexp-match-positions regex instr start)])\n          (if (equal? v #f)\n              (set! next-pos #f)\n              (set! next-pos (cdar v)))\n          next-pos))\n\n   ➋ (define (classify type)\n        (let ([val (substring instr start next-pos)])\n          (if (equal? type 'number)\n              (cons type (string->number val))\n              (cons type val))))\n\n      (define (at-end)\n        (or (= str-len next-pos)\n            (let ([c (string-ref instr next-pos)])\n              (not (or (char-numeric? c) (char-alphabetic? c))))))\n\n      (let ([token\n          ➌ (cond [(= start str-len)'()]\n                ➍ [(and (match-reg regex-keyword) (at-end))\n                      (classify 'keyword)]\n                   [(and (match-reg regex-fname) (at-end))\n                      (classify 'fname)]\n                   [(match-reg regex-ident) (classify 'ident)]\n                   [(match-reg regex-number) (classify 'number)]\n                   [(match-reg regex-op) (classify 'op)]\n                ➎ [(equal? #\\( (string-ref instr start))\n                      (set! next-pos (add1 start))\n                      (cons 'lpar \"(\")]\n                ➏ [(equal? #\\) (string-ref instr start))\n                      (set! next-pos (add1 start))\n                      (cons 'rpar \")\")]\n                   [else #f])])\n        (cond [(equal? token '()) '()]\n           ➐ [token (cons token (loop next-pos))]\n           ➑ [else (error (format \"Invalid token at ~a.\" start))])))))\n```", "```\n> (tokenize \"(x1*cos(45) + 25 *(4e-12 / alpha)^2\")\n'((lpar . \"(\")\n  (ident . \"x1\")\n  (op . \"*\")\n  (fname . \"cos\")\n  (lpar . \"(\")\n  (number . 45)\n  (rpar . \")\")\n  (op . \"+\")\n  (number . 25)\n  (op . \"*\")\n  (lpar . \"(\")\n  (number . 4e-012)\n  (op . \"/\")\n  (ident . \"alpha\")\n  (rpar . \")\")\n  (op . \"^\")\n  (number . 2))\n```", "```\n(define token-symbol #f)\n(define token-value null)\n(define token-list '())\n```", "```\n(define (assign?) (equal? token-value \"=\"))\n\n(define (pow?) (equal? token-value \"^\"))\n\n(define (neg?) (equal? token-value \"-\"))\n\n(define (term?) (or\n                  (equal? token-value \"*\")\n                  (equal? token-value \"/\")))\n\n(define (expr?) (or\n                  (equal? token-value \"+\")\n                  (equal? token-value \"-\")))\n```", "```\n(define (next-symbol)\n  (unless (null? token-list)\n    (let ([token (car token-list)])\n      (set! token-symbol (car token))\n      (set! token-value (cdr token))\n      (set! token-list (cdr token-list)))))\n```", "```\n(define (accept sym)\n  (if (equal? token-symbol sym)\n      (begin\n        (next-symbol)\n        #t)\n      #f))\n```", "```\n(define (expect sym)\n  (if (accept sym)\n      #t\n      (if (null? token-list)\n          (error \"Unexpected end of input.\") \n          (error (format \"Unexpected symbol '~a' in input.\" token-value)))))\n```", "```\n(define (factor)\n  (let ([val token-value])\n    (cond [(accept 'number) (cons 'number val)]\n          [(accept 'ident) (cons 'ident val)]\n       ➊ [(accept 'lpar)\n           (let ([v (expr)])\n             (expect 'rpar)\n             v)]\n          [(accept 'fname)\n           (let ([fname val])\n             (expect 'lpar)\n             (let ([v (expr)])\n               (expect 'rpar)\n               (cons 'func-call (cons fname v))))]\n          [else (error (format \"Invalid token: ~a.\" token-value))])))\n```", "```\n(define (pow)\n  (let ([e1 (factor)])\n    (if (pow?)\n        (begin\n          (next-symbol)\n       ➊ (let ([e2 (pow)])\n            (cons '^ (cons e1 e2))))\n        e1)))\n```", "```\n(define (neg)\n  (if (neg?)\n      (begin\n        (next-symbol)\n        (cons 'neg (neg)))\n      (pow)))\n```", "```\n(define (term)\n  (let ([e1 (neg)])\n    (let loop ()\n      (when (term?)\n        (let ([op (if (equal? token-value \"*\") '* '/)])\n          (next-symbol) \n          (let ([e2 (neg)])\n            (set! e1 (cons op (cons e1 e2)))))\n        (loop)))\n    e1))\n```", "```\n(define (expr)\n  (let ([e1 (term)])\n    (let loop ()\n      (when (expr?)\n        (let ([op (if (equal? token-value \"+\") '+ '-)])\n          (next-symbol) \n          (let ([e2 (term)])\n            (set! e1 (cons op (cons e1 e2)))))\n        (loop)))\n    e1))\n```", "```\n(define (statement)\n  (if (equal? token-value \"let\")\n      (begin\n        (next-symbol)\n        (let ([id token-value])\n          (accept 'ident)\n          (if (assign?)\n              (begin\n                (next-symbol)\n                (cons 'assign (cons id (expr))))\n              (error \"Invalid let statement\"))))\n      (expr)))\n```", "```\n(define (parse instr)\n  (set! token-list (tokenize (string-trim instr)))\n  (next-symbol)\n  (let ([val (statement)])\n    (if (equal? token-list '())\n        val\n        (error \"Syntax error in input.\"))))\n```", "```\n> (parse \"x y\")\n```", "```\n> (parse \"(x1*cos(45) + 25 *(4e-12 / alpha))^2\")\n'(pow (+ (* (ident . \"x1\") func-call \"cos\" number . 45) * (number . 25) / (\n     number . 4e-012) ident . \"alpha\") number . 2)\n```", "```\n(define (print-tree ast)\n  (let loop ([level 0][node ast])\n    (let ([indent (make-string (* 4 level) #\\ )]\n           [sym (car node)]\n           [val (cdr node)])\n      (printf indent)\n      (define (print-op)\n        (printf \"Operator: ~a\\n\"  sym)\n        (loop (add1 level) (car val))\n        (loop (add1 level) (cdr val)))\n      (match sym\n        ['number (printf \"Number: ~a\\n\" val)]\n        ['ident  (printf \"Identifier: ~a\\n\" val)]\n        ['func-call \n           (printf \"Function: ~a\\n\" (car val))\n           (loop (add1 level) (cdr val))]\n        ['+ (print-op)]\n        ['- (print-op)]\n        ['* (print-op)]\n        ['/ (print-op)]\n        ['^ (print-op)]\n        ['neg \n           (printf \"Neg:\\n\")\n           (loop (add1 level) val)]\n        ['assign\n           (printf \"Assign: ~a\\n\" (car val))\n           (loop (add1 level) (cdr val))]\n        [_ (printf \"Node: ~a?\\n\" node)]))))\n```", "```\n> (define ast (parse \"(x1*cos(45) + 25 *(4e-12 / alpha))^2\"))\n> (print-tree ast)\nOperator: ^\n    Operator: +\n        Operator: *\n            Identifier: x1\n            Function: cos\n                Number: 45\n        Operator: *\n            Number: 25\n            Operator: /\n                Number: 4e-012\n                Identifier: alpha\n    Number: 2\n```", "```\n(struct op (prec assoc))\n\n(define get-prop\n  (let ([op-prop\n         (hash\n          'assign (cons 0 'r)\n          '+   (op 10 'l) \n          '-   (op 10 'l) \n          '*   (op 20 'l) \n          '/   (op 20 'l)\n          'neg (op 30 'n)\n          '^   (op 40 'r)\n          'expt   (op 40 'r)\n          'number (op 90 'n)\n          'ident  (op 90 'n)\n          'func-call (op 90 'n))])\n    (λ (sym)\n      (hash-ref op-prop sym (λ () (op 90 'n))))))\n```", "```\n(define (ast->string ast)\n  (let ([expr-port (open-output-string)])\n    (define (push str)\n      (display str expr-port))\n    (let loop ([node ast])\n      (let* ([sym (car node)]\n             [val (cdr node)]\n             [prop (get-prop sym)]\n             [prec (op-prec prop)]\n             [assoc (op-assoc prop)])\n\n        (define (need-paren arg side)\n          (let ([arg-prec (op-prec (get-prop (car arg)))])\n            (cond [(< arg-prec prec) #t]\n                  [(> arg-prec prec) #f]\n                  [else (not (equal? assoc side))])))\n\n        (define (push-op) \n          (let* ([e1 (car val)]\n                 [par1 (need-paren e1 'l)]\n                 [e2 (cdr val)]\n                 [par2 (need-paren e2 'r)])\n            (when par1 (push \"(\"))\n            (loop e1)\n            (when par1 (push \")\"))\n            (push (format \" ~a \"  sym))\n            (when par2 (push \"(\"))\n            (loop e2)\n            (when par2 (push \")\"))))\n\n        (match sym\n          ['number (push (number->string val))]\n          ['ident (push val)]\n          ['func-call \n           (push (car val))\n           (push \"(\")\n           (loop (cdr val))\n           (push \")\")]\n          ['+ (push-op)]\n          ['- (push-op)]\n          ['* (push-op)]\n          ['/ (push-op)]\n          ['^ (push-op)]\n          ['neg \n           (push \"-\")\n           (let ([paren (need-paren val 'n)])\n             (when paren (push \"(\"))\n             (loop val)\n             (when paren (push \")\")))]\n          ['assign\n           (push (format \"let ~a = \" (car val)))\n           (loop (cdr val))]\n          [_ (push (format \"Node: ~a\" sym))])))\n    (get-output-string expr-port)))\n```", "```\n> (ast->string (parse \"(x1*cos(45) - 4 + -25 *(4e-12 / alpha))^2\"))\n\"(x1 * cos(45) - 4 + -25 * (4e-012 / alpha)) ^ 2\"\n```", "```\n(define var\n  (let ([vars (make-hash)])\n    (λ args\n      (match args\n        [(list 'set v n) (hash-set! vars v n)]\n        [(list 'get v)\n         (if (hash-has-key? vars v)\n             (hash-ref vars v)\n             (error (format \"Undefined variable: ~a\" v)))]))))\n```", "```\n(define (eval-ast ast)\n  (let loop ([node ast])\n  ➊ (let ([sym (car node)]\n           [val (cdr node)])\n\n   ➋ (define (eval-op)\n        (let ([n1 (loop (car val))]\n              [n2 (loop (cdr val))])\n          (match sym\n            ['+ (+ n1 n2)]\n            ['- (- n1 n2)]\n            ['* (* n1 n2)]\n            ['/ (/ n1 n2)]\n            ['^ (expt n1 n2)])))\n\n   ➌ (define (eval-func fname val)\n        (match fname\n          [\"sin\" (sin val)]\n          [\"cos\" (cos val)]\n          [\"tan\" (tan val)]\n          [\"asin\" (asin val)]\n          [\"acos\" (acos val)]\n          [\"atan\" (atan val)]\n          [\"ln\" (log val)]\n          [\"log\" (log val 10)]\n          [\"sqrt\" (sqrt val)] ))\n\n   ➍ (match sym\n        ['number val]\n        ['ident (var 'get val)]\n        ['+ (eval-op)]\n        ['- (eval-op)]\n        ['* (eval-op)]\n        ['/ (eval-op)]\n        ['^ (eval-op)]\n        ['neg (- (loop val))]\n        ['assign (var 'set (car val)\n                      (loop (cdr val)))]\n     ➎ ['func-call \n         (eval-func (car val)\n                    (loop (cdr val)))]\n        [_ (error \"Unknown symbol\")]))))\n```", "```\n> (eval-ast (parse \"let x = 3\"))\n> (eval-ast (parse \"let y = 4\"))\n> (eval-ast (parse \"sqrt(x^2 + y^2)\"))\n5\n\n> (eval-ast (parse \"x + tan(45 * 3.14159 / 180)\"))\n3.9999986732059836\n```", "```\n(define (start)\n  (var 'set \"pi\" pi)\n  (var 'set \"e\" (exp 1))\n  (display \"Welcome to TRAC!\\n\\n\")\n  (let loop ()\n    (display \"> \")\n      (let ([v (eval-ast (parse (read-line)))])\n        (when (number? v) (displayln  v)))\n    (loop)))\n```", "```\n> (start)\nWelcome to TRAC!\n\n> let x = 3\n> let y = 2+2\n> sqrt(x^2+y^2)\n5\n\n> tan(45 * pi / 180)\n0.9999999999999999\n```", "```\n> let x=3\n> let y=4\n> sqrt(x^2 + y^2\n. . Unexpected end of input\n```", "```\n(define (start)\n  (var 'set \"pi\" pi)\n  (var 'set \"e\" (exp 1))\n  (display \"Welcome to TRAC!\\n\\n\")\n  (let loop ()\n    (display \"> \")\n    (with-handlers ([exn:fail? (λ (e) (displayln \"An error occured\"))])\n      (let ([v (eval-ast (parse (read-line)))])\n        (when (number? v) (displayln v))))\n    (loop)))\n```", "```\n> sqrt(x^2 + y^2\nAn error occurred!\n>\n```", "```\n(λ (e) (displayln (exn-message e)))\n```", "```\n> (start)\nWelcome to TRAC!\n\n> let x=3\n> let y=4\n> sqrt(x^2 + y^2\nUnexpected end of input.\n> sqrt(x^2 + y^2)\n5\n>\n```", "```\n(define (start)\n  (reset)\n  (let loop ()\n    (display \"> \")\n    (with-handlers ([exn:fail? (λ (e) (displayln (exn-message e)))])\n      (let ([v (eval-ast (parse (read-line)))])\n        (when (number? v)\n          (if (not (real? v))\n              (error \"Result undefined.\")\n              (displayln v)))))\n    (loop)))\n```", "```\n> sqrt(-2)\nResult undefined.\n```", "```\n(define regex-number #rx\"^[0-9]+(?>\\\\.[0-9]+)?(?>e[+-]?[0-9]+)?i?\")\n```", "```\n(define (tokenize instr)\n         ⋮\n      (define (classify type)\n        (let ([val (substring instr start next-pos)])\n          (if (equal? type 'number) \n              (cons type\n                    (if (equal? #\\i (string-ref val (sub1 (string-length val))))\n                        (string->number (string-append \"0+\" val))\n                        (string->number val)))\n              (cons type val))))\n         ⋮\n```", "```\n> 1i\n0+1i\n\n> 1i^2\n-1\n\n> 2*1+2i\n2+2i\n\n> 2*(1+2i)\n2+4i\n```", "```\n(define RADIANS 1)\n(define DEGREES (/ pi 180))\n(define trig-mode RADIANS)\n```", "```\n(define FRAC 1)\n(define FLOAT 2)\n(define num-mode FLOAT)\n```", "```\n(define regex-keyword #rx\"^(let|reset|\\\\?)\")\n```", "```\n(define (reset)\n  (var 'set \"pi\" pi)\n  (var 'set \"e\" (exp 1))\n\n  (var 'set \"Rad\" RADIANS)\n  (var 'set \"Deg\" DEGREES)\n  (set! trig-mode RADIANS)\n\n  (var 'set \"Frac\" FRAC)\n  (var 'set \"Float\" FLOAT)\n  (set! num-mode FLOAT)\n\n  (displayln \"** Welcome to TRAC! **\\n\")\n  (displayln \"  Modes: Rad, Float\")\n  (displayln \"  Enter ? for help.\\n\")\n  )\n```", "```\n(define (start)\n  (reset)\n  (let loop ()\n    (display \"> \")\n    (with-handlers ([exn:fail? (λ (e) (displayln (exn-message e)))])\n      (let ([v (eval-ast (parse (read-line)))])\n        (when (number? v) (displayln v))))\n    (loop)))\n```", "```\n(define (statement)\n  (cond [(equal? token-value \"let\")\n         (next-symbol)\n         (let ([id token-value])\n           (accept 'ident)\n           (if (assign?)\n               (begin\n                 (next-symbol)\n                 (cons 'assign (cons id (expr))))\n               (error \"Invalid let statement\")))]\n        [(equal? token-value \"reset\") (cons 'reset null)]\n        [(equal? token-value \"?\") (cons 'help null)]\n        [else (expr)]))\n```", "```\n(define (eval-ast ast)\n  (let loop ([node ast])\n    (let ([sym (car node)]\n          [val (cdr node)])\n\n      (define (eval-op)\n        (let ([n1 (loop (car val))]\n              [n2 (loop (cdr val))])\n          (match sym\n            ['+ (+ n1 n2)]\n            ['- (- n1 n2)]\n            ['* (* n1 n2)]\n            ['/ (/ n1 n2)]\n            ['^ (expt n1 n2)])))\n\n      (define (eval-func fname val)\n        (match fname\n       ➊ [\"sin\" (sin (* val trig-mode))]\n          [\"cos\" (cos (* val trig-mode))]\n          [\"tan\" (tan (* val trig-mode))]\n          [\"asin\" (/ (asin val) trig-mode)]\n          [\"acos\" (/ (acos val) trig-mode)]\n          [\"atan\" (/ (atan val) trig-mode)]\n          [\"ln\" (log val)]\n          [\"log\" (log val 10)]\n          [\"sqrt\" (sqrt val)] ))\n\n      (match sym\n        ['number\n      ➋ (if (and (= num-mode FLOAT) (exact? val))\n             (exact->inexact val)\n             val)]\n        ['ident (var 'get val)]\n        ['+ (eval-op)]\n        ['- (eval-op)]\n        ['* (eval-op)]\n        ['/ (eval-op)]\n        ['^ (eval-op)]\n        ['neg (- (loop val))]\n     ➌ ['reset (reset)]\n     ➍ ['help (print-help)]\n        ['assign\n         (var 'set (car val)                    \n              (let ([n (loop (cdr val))])\n             ➎ (cond [(equal? (car val) \"TrigMode\")\n                       (if (or (= n RADIANS) (= n DEGREES))\n                           (begin\n                             (set! trig-mode n)\n                             (printf \"TrigMode set to ~a.\\n\\n\" (if (= n\n     RADIANS) \"Rad\" \"Deg\")))\n                           (error \"Invalid TrigMode.\"))]\n                   ➏ [(equal? (car val) \"NumMode\")\n                       (if (or (= n FRAC) (= n FLOAT))\n                           (begin\n                             (set! num-mode n)\n                             (printf \"NumMode set to ~a.\\n\\n\" (if (= n FRAC) \"\n     Frac\" \"Float\")))\n                           (error \"Invalid NumMode.\"))]\n                      [else n])))]\n        ['func-call \n         (eval-func (car val)\n                    (loop  (cdr val)))]\n        [_ (error \"Unknown symbol\")]))))\n```", "```\n(define (print-help)\n  (let ([help (list\n               (format \"Current TrigMode: ~a\"\n                       (if (= trig-mode RADIANS) \"Rad\" \"Deg\"))              \n               \"To change TrigMode: to radians type:\"\n               \"   let TrigMode = Rad\"\n               \"To change TrigMode to degrees type:\"\n               \"   let TrigMode = Deg\"\n               \"\"   \n               (format \"Current NumMode: ~a\"\n                       (if (= num-mode FLOAT) \"Float\" \"Frac\"))\n               \"To change NumMode to float type:\"\n               \"   let NumMode: = Float\"\n               \"To change NumMode: to fraction type:\"\n               \"   let NumMode: = Frac\"\n               \"\"\n               \"To reset TRAC to defaults type:\"\n               \"   reset\")])\n    (let loop([h help])\n      (unless (equal? h '())\n        (printf \"~a\\n\" (car h))\n        (loop (cdr h)))))\n  (newline))\n```", "```\n> (start)\n** Welcome to TRAC! **\n\n  Modes: Rad, Float\n  Enter ? for help.\n\n> tan(45)\n1.6197751905438615\n> let TrigMode=Deg\nTrigMode set to Deg.\n\n> tan(45)\n0.9999999999999999\n> atan(1)\n45.0\n> let TrigMode=45\nInvalid TrigMode.\n> let TrigMode=Rad\nTrigMode set to Rad.\n\n> cos(pi)\n-1.0\n> 2/4\n0.5\n> let NumMode=Frac\nNumMode set to Frac.\n\n> 2/4\n1/2\n> reset\n** Welcome to TRAC! **\n\n  Modes: Rad, Float\n  Enter ? for help.\n\n> ?\nCurrent TrigMode: Rad\nTo change TrigMode: to radians type:\n   let TrigMode = Rad\nTo change TrigMode to degrees type:\n   let TrigMode = Deg\n\nCurrent NumMode: Float\nTo change NumMode to float type:\n   let NumMode: = Float\nTo change NumMode: to fraction type:\n   let NumMode: = Frac\n\nTo reset TRAC to defaults type:\n   reset\n\n>\n```", "```\n(define ops\n  (vector\n   (cons '+ 2) \n   (cons '- 1) ; unary minus\n   (cons '- 2) ; subtraction\n   (cons '* 2) \n   (cons '/ 2) \n   (cons 'expt 2) \n   (cons 'sin 1) \n   (cons 'cos 1) \n   (cons 'tan 1) \n   (cons 'asin 1) \n   (cons 'acos 1) \n   (cons 'atan 1) \n   (cons 'sqrt 1) \n   (cons 'log 1) ; natural log\n   (cons 'log 2) ; base n log\n   ))\n\n(define (gen-racket)\n  (let ([num-ops (vector-length ops)])\n    (let loop ([d (random 1 5)])\n      (if (= d 0)\n          (exact->inexact (* (random) 1000000000))\n          (let* ([op (vector-ref ops (random num-ops))]\n                 [sym (car op)]\n                 [args (cdr op)]\n                 [next-d (sub1 d)])\n            (if (= args 1)\n                (list sym (loop next-d))\n                (if (equal? sym 'log)\n                    (list sym (loop next-d) 10)\n                    (list sym (loop next-d) (loop next-d)))))))))\n```", "```\n> (gen-racket)\n'(* (cos 25563340.24229431) (cos 112137357.31425005))\n\n> (gen-racket)\n'(log 502944961.7985059 10)\n\n> (gen-racket)\n'(sqrt (tan (expt (sqrt 721196577.8863264) (+ 739078577.777451 744205482.2563056))))\n```", "```\n(define (racket->trac expr)\n  (let ([out-port (open-output-string)])\n    (define (push str)\n      (display str out-port))\n    (let loop ([node expr])\n      (if (number? node)\n          (push (number->string node))\n          (let* ([sym (car node)]\n                 [sym (cond [(equal? sym 'expt) '^]\n                            [(equal? sym 'log)\n                             (if (= (length node) 2) 'ln 'log)]\n                            [(equal? sym '-)\n                             (if (= (length node) 2) 'neg '-)]\n                            [else sym])]\n                 [prop (get-prop sym)]\n                 [prec (op-prec prop)]\n                 [assoc (op-assoc prop)])\n\n            (define (need-paren arg side)\n              (if (not (list? arg))\n                  #f\n                  (let ([arg-prec (op-prec (get-prop (car arg)))])\n                    (cond [(< arg-prec prec) #t]\n                          [(> arg-prec prec) #f]\n                          [else (not (equal? assoc side))]))))\n\n            (define (push-op)\n              (let* ([e1 (second node)]\n                     [e2 (third node)]\n                     [par1 (need-paren e1 'l)]\n                     [par2 (need-paren e2 'r)])\n                (when par1 (push \"(\"))\n                (loop e1)\n                (when par1 (push \")\"))\n                (push (format \" ~a \"  sym))\n                (when par2 (push \"(\"))\n                (loop e2)\n                (when par2 (push \")\"))))\n\n            (define (push-neg)\n              (let* ([e (second node)]\n                     [paren (need-paren e 'n)])\n                (push \"-\")\n                (when paren (push \"(\"))\n                (loop e)\n                (when paren (push \")\"))))\n\n            (define (push-func)\n              (push (format \"~a\"  sym))\n              (push \"(\")\n              (loop (second node))\n              (push \")\"))\n\n            (match sym\n              ['+ (push-op)]\n              ['- (push-op)]\n              ['* (push-op)]\n              ['/ (push-op)]\n              ['^ (push-op)]\n              ['neg  (push-neg)]\n              ['sin  (push-func)]\n              ['cos  (push-func)]\n              ['tan  (push-func)]\n              ['asin (push-func)]\n              ['acos (push-func)]\n              ['atan (push-func)]\n              ['ln   (push-func)]\n              ['log  (push-func)]\n              ['sqrt (push-func)])))\n      (get-output-string out-port))))\n```", "```\n> (racket->trac (gen-racket))\n\n\"asin(tan(944670433.0 - 858658023.0 + (918652763.0 + 285573780.0)))\"\n> (racket->trac (gen-racket))\n\"sin(atan(364076270.0)) / sqrt(ln(536830818.0))\"\n\n> (racket->trac (gen-racket))\n\"atan(978003385.0)\"\n```", "```\n> (define r (gen-racket))\n> r\n'(+ (cos (atan 142163217.6660815)) (log (cos 528420918.36769867)))\n\n> (define v1 (eval r))\n> v1\n-1.021485300993499\n\n> (define v2 (eval-ast (parse (racket->trac r))))\n> v2\n-1.021485300993499\n\n> (= v1 v2)\n#t\n```", "```\n(define (test n)\n  (for ([in-range n])\n    (let* ([expr (gen-racket)]\n           [v1 (eval expr)]\n           [v2 (eval-ast (parse (racket->trac expr)))]\n           [delta (magnitude (- v1 v2))])\n      (when (> delta 0)\n        (displayln \"Mismatch:\")\n        (printf \"Racket: ~a\\n\" expr)\n        (printf \"TRAC: ~a\\n\" (racket->trac expr))\n        (printf \"v1: ~a, v2: ~a, delta: ~a\\n\\n\" v1 v2 delta)))))\n```", "```\n> (test 10)\nMismatch:\nRacket: (atan (atan (expt 137194961.20152807 513552901.52574974)))\nTRAC: atan(atan(137194961.20152807 ^ 513552901.52574974))\nv1: 1.0038848218538872, v2: 0.2553534898896325, delta: 0.7485313319642546\n\nMismatch:\nRacket: (- (log (expt (+ 67463417.07939068 342883686.1438599) (sin\n     521439863.24302197))) (sqrt (+ (atan 402359159.5913063) (acos\n     213010305.84288383))))\nTRAC: ln((67463417.07939068 + 342883686.1438599) ^ sin(521439863.24302197)) -\n     sqrt(atan(402359159.5913063) + acos(213010305.84288383))\nv1: -23.07001808516913-3.029949988703483i, v2:\n     16.55567328478171+0.11164266488631025i, delta: 39.75003171002113\n```", "```\n> (test 100000)\n>\n```", "```\n(start)\n```"]