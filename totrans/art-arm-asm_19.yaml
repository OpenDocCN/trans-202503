- en: <hgroup>
  prefs: []
  type: TYPE_NORMAL
- en: 16 STAND-ALONE ASSEMBLY LANGUAGE PROGRAMS
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: </hgroup>
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/opener.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Until now, this book has relied upon a C/C++ main program to call the example
    code written in assembly language. While this is probably the biggest use of assembly
    language in the real world, it is also possible to write stand-alone code (no
    C/C++ main program) in assembly language. In this chapter, you’ll learn how to
    write such stand-alone programs.
  prefs: []
  type: TYPE_NORMAL
- en: For the purposes of this book, *stand-alone assembly language program* means
    that the assembly language code contains an actual *main* program (not asmMain,
    which is just a function that a C++ program calls). Such a program does not make
    any C/C++ stdlib calls; the only external calls to code outside the application
    itself are OS API function calls.
  prefs: []
  type: TYPE_NORMAL
- en: NOTE
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*Some readers might take the term* stand-alone *to mean that an assembly language
    program makes no external function calls, not even to an OS, and handles all I/O
    at the hardware level within the application itself. That’s an appropriate definition
    for embedded systems, but not the definition I use in this book.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Technically, your assembly code will always be called by a C/C++ program. That’s
    because the OS itself is written in C/C++, with a tiny bit of assembly code. When
    the OS transfers control to your assembly code, this is not much different from
    a C/C++ main program calling your assembly code. Nevertheless, “pure” assembly
    applications have some clear advantages: you’re not dragging along the C/C++ library
    code and application runtime system, so your programs can be smaller and you won’t
    have external naming conflicts with C/C++ public names.'
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter covers OS system calls for macOS and Linux (including Pi OS).
    It begins by explaining how to maintain portability in your code, given that system
    calls are not portable between OSes. It then introduces the concept of system
    calls for these two OSes. After discussing the svc (supervisor call) instruction
    used to make calls to OS API functions, it provides two examples: a stand-alone
    “Hello, world!” application and a file I/O application. Finally, it points out
    that macOS frowns on direct system calls and expects you to interface to the OS
    via C library function calls.'
  prefs: []
  type: TYPE_NORMAL
- en: 16.1 Portability Issues with System Calls
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'While most of the example programs appearing in this book so far are portable
    between macOS and Linux, system API calls vary by OS. Code in the previous chapters
    ignored this issue by calling C/C++ stdlib functions that handled the low-level
    OS details, but the example code in this chapter makes OS-specific calls. Therefore,
    portability won’t happen automatically. You have four options for handling this
    issue:'
  prefs: []
  type: TYPE_NORMAL
- en: Ignore portability and write a given example program only for macOS or only
    for Linux. In general, I take this approach when writing code specific to an OS.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Write two (nonportable) versions of the same program: one for Linux and one
    for macOS.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Write a single program that uses conditional assembly to include OS-specific
    code, as necessary.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Create two wrapper files, one that has macOS versions of OS calls and another
    that has Linux version, and include the appropriate wrapper with your main (portable)
    code.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The appropriate mechanism to use depends on your application. If you are not
    interested in writing portable assembly code that will work across OSes (the most
    common case when writing assembly applications), you’ll use the first approach
    and write code just for the OS you are targeting.
  prefs: []
  type: TYPE_NORMAL
- en: If you do want your assembly application to run on macOS and Linux, your approach
    will depend on the size of the application. If the application is relatively small,
    writing two OS-specific variants is not that difficult (though maintenance may
    be an issue, as you’ll have to maintain two separate versions of the application).
    If the application is large, or you expect to upgrade and maintain it frequently,
    the third or fourth approach is probably better. A single application that uses
    conditional assembly to deal with OS-specific issues is usually much easier to
    maintain and expand than two separate applications, and using wrapper code makes
    it easier to maintain the code for each specific OS.
  prefs: []
  type: TYPE_NORMAL
- en: 'There is a fifth approach: write all your OS-dependent code in C/C++ and call
    assembly functions that deal with the non-OS-specific functionality. That’s how
    all the example programs in this book have been written.'
  prefs: []
  type: TYPE_NORMAL
- en: It should go without saying that the code in this chapter does not use the *build*
    script to compile/assemble the example applications. The *build* script assumes
    the use of the *c.cpp* main program (and the whole point of this chapter is to
    stop using that code). Therefore, each example program in this chapter includes
    a makefile that builds the code.
  prefs: []
  type: TYPE_NORMAL
- en: 16.2 Stand-Alone Code and System Calls
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The first example program in this book, Listing 1-1 on [page 5](chapter1.xhtml#pg_5),
    is a stand-alone program. Here it is as Listing 16-1, with a couple of changes,
    for the sake of discussion.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: I’ve made two changes to this code compared with that in Listing 1-1\. At both
    instances of ❶ and ❷, I’ve introduced a new symbol, main (and _main). This is
    because Linux requires the main program to be named main, whereas macOS requires
    the name _main. Were you to attempt to compile Listing 1-1 under Linux, you would
    get something like an undefined reference to `main` message. Rather than mess
    around with conditional assembly (or write two separate versions of Listing 16-1),
    I simply include both symbols in the source file. Linux largely ignores the _main
    symbol, and macOS ignores the main symbol; the program happily compiles under
    either OS.
  prefs: []
  type: TYPE_NORMAL
- en: 'Listing 16-1 consists of a single instruction: ret ❸. On entry, the LR register
    contains a return address that transfers control back to the OS. Therefore, this
    program (should you actually execute it) returns immediately to the OS.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Although returning to the OS via a ret instruction works (particularly if building
    this code with GCC), this isn’t the standard way to return to Linux or macOS.
    Instead, an application should make a call to the exit() API function. To call
    a system API function, a program must load a function number into a register,
    load appropriate parameters into the parameter registers (X0 through X7), and
    then execute the supervisor (OS) call instruction svc #OSint, where OSint is 0
    for Linux and 0x80 for macOS.'
  prefs: []
  type: TYPE_NORMAL
- en: NOTE
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*In reality, macOS seems to ignore the immediate constant following the* svc
    *instruction. Many online examples use the value 0 as the* svc *operand (and personal
    experiments show that it works). However, the macOS source code seems to use 0x80
    as the constant, so I recommend using this value under macOS.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Under Linux, you load the system call number into the X8 register, while under
    macOS you load this into X16\. I’ve added the following statements in *aoaa.inc*
    to handle this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Under both Linux and macOS, the exit function expects a single integer parameter
    in the X0 register holding the program’s return code (generally this is 0 if no
    errors occurred while running the program). The only question remaining is, “What
    is the system call number for exit()?” Under Linux, the code is 93, while under
    macOS it’s 1 (I’ll discuss how I determined these magic numbers in section 16.3,
    “The svc Interface and OS Portability,” on the next page). Listing 16-2 provides
    a very simple assembly application that immediately returns to the OS and that
    you can compile for macOS or Linux.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Listing 16-2 includes *aoaa.inc* ❶ in order to generate an error if the OS symbol
    (Linux or Darwin) is not defined on the command line (which *aoaa.inc* translates
    to isLinux or isMacOS), as well as to obtain the OSint and svcReg constants.
  prefs: []
  type: TYPE_NORMAL
- en: The program uses conditional assembly to generate the different code needed
    for macOS or Linux, setting the constant exitCode equal to the OS’s exit function
    number ❷. This function loads X0 with 0 ❸ to indicate success when it returns.
    It then loads the exitCode function number into the OS’s function number parameter
    register ❹ (svcReg is X8 under Linux and X16 under macOS, as defined in *aoaa.inc*,
    as per the previous example). Finally, the code issues the supervisor call instruction
    to call the OS ❺. Because of the nature of this call, the svc instruction never
    returns control back to the program, so there is no need for a ret instruction.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s the makefile to build the program in Listing 16-2:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'To build and run this program, enter the following commands into the shell
    program:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The program returns without producing any output, as expected.
  prefs: []
  type: TYPE_NORMAL
- en: 16.3 The svc Interface and OS Portability
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Both macOS and Linux use the supervisor call instruction (svc) to make API calls
    to the OS. However, the exact calling sequence varies considerably between the
    two OSes. This section clarifies the differences between them with respect to
    the functions (the API) that they support—in particular, regarding call numbers,
    parameters, and error handling.
  prefs: []
  type: TYPE_NORMAL
- en: Although both OSes are Unix based (and share many POSIX-compliant functions),
    each has its own set of OS-specific functions that may have no equivalence on
    the other system. Even the common (for example, POSIX) functions may expect different
    arguments and produce different return results, meaning you must be especially
    careful when attempting to write assembly code that is portable between these
    two OSes. This is a good example of how using wrappers to localize OS system calls
    can help improve the portability and maintainability of your code.
  prefs: []
  type: TYPE_NORMAL
- en: 16.3.1 Call Numbers
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'As noted earlier, the function call number values differ between OSes, as does
    the location where you pass the call numbers (X8 for Linux, X16 for macOS). It’s
    easy enough to overcome the register location issue by using a #define (or .req
    directive). However, the function call number values are completely OS dependent.'
  prefs: []
  type: TYPE_NORMAL
- en: The *sys*/*syscall.h* file is a header file that contains definitions for all
    the system API call numbers. (You can include it in an assembly language source
    file even though it’s a C header file.) This file is generally installed on your
    system when you install your C compiler (GCC or Clang) and is typically found
    in the default include path used by the compiler. See the GCC or Xcode documentation
    for more details.
  prefs: []
  type: TYPE_NORMAL
- en: 'Although #include <sys/syscall.h> will work on both Linux and macOS, the actual
    definitions may appear in a different file elsewhere in the compiler’s directory
    tree, with an appropriate #include inside *sys*/*syscall.h* leading to the actual
    file.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are a few lines from *sys/syscall.h* on a macOS machine:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'The #ifdef statement in this code is a warning that Apple considers the svc
    API interface to be undocumented and private, as discussed in the “Using svc Under
    macOS” box on the next page.'
  prefs: []
  type: TYPE_NORMAL
- en: On my macOS system, I used the Unix find command to locate *sys*/*syscall.h*
    buried deep in the Xcode directory path */Library/Developer/CommandLineTools/SDK/
    ...* , but your mileage may vary.
  prefs: []
  type: TYPE_NORMAL
- en: 'Under Debian Linux, #include <sys/syscall.h> includes */usr/include/asm -generic/unistd.h*
    (again, use the Unix find command if this file isn’t present at this location).
    Here are a few lines from that file, sorted to match the order of the statements
    in the macOS *syscall.h* file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, the function names, the constant names, and the function call
    numbers in the two files don’t agree. For example, Linux generally prefers openat()
    over the open() function. Fortunately, macOS also provides openat(), so it’s possible
    to use the same function on both OSes. However, the symbolic names macOS and Linux
    use for the same functions are quite different, which means including *sys/syscall.h*
    isn’t a portable solution. You’ll still have to provide your own local names that
    map to the corresponding Linux and macOS names (suggestion: use two syscall wrapper
    *.S* files, one for Mac and one for Linux, to resolve these problems).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Unfortunately, the *sys/syscall.h* header files don’t provide the parameter
    lists for the various functions. You can find the parameter information for Linux
    at *[https://<wbr>arm<wbr>.syscall<wbr>.sh](https://arm.syscall.sh)*. For example,
    consider the entry for the exit() function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: This line tells you that X8 must contain 0x5D (93) and X0 must contain the exit
    code (error_code). Linux system calls have a maximum of six parameters (X0 through
    X5), but exit() uses only one of them (in addition to the function call number
    in X8).
  prefs: []
  type: TYPE_NORMAL
- en: On macOS, you must use the macOS call number (1 for exit) and load that call
    number into X16\. The parameters are generally the same for equivalent macOS functions,
    subject (of course) to the differences in the Linux versus macOS ABI (see section
    16.8, “For More Information,” on [page 930](chapter16.xhtml#pg_930) for the set
    of system calls).
  prefs: []
  type: TYPE_NORMAL
- en: 16.3.2 API Parameters
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'As a general rule, all the system calls have well-defined names and parameter
    lists, which you can find online by searching for the function’s name or by using
    the man command at the command line. For example, the openat() call has the following
    parameters (from the Linux man page):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: The openat code (57 in Linux, 463 under macOS) goes in X8 (Linux) or X16 (macOS),
    a directory descriptor goes in X0, a pointer to the filename (pathname) goes in
    X1, and the flags get passed in X2 (an optional mode parameter can be passed in
    X3). You choose the parameter registers according to the ARM ABI.
  prefs: []
  type: TYPE_NORMAL
- en: 'To create code that’s portable between macOS and Linux, you can use the following
    conditional assembly at the beginning of your source file to select the constants
    based on the OS:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: From this point forward, you can use the symbols sys_* on either OS. Of course,
    if you don’t require portability between the two OSes, you can simply include
    *sys/syscall.h* and use the SYS_* or _NR_* symbols as appropriate for your OS
    choice.
  prefs: []
  type: TYPE_NORMAL
- en: 16.3.3 API Error Handling
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: One other big difference between macOS and Linux API calls is in the way they
    return an indication of an error. For macOS API calls, the error status is returned
    in the carry flag (C = 1 for error, C = 0 for no error). If the carry flag is
    set, macOS returns an error code in the X0 register. Linux, on the other hand,
    returns –1 in X0 if there is an error; you must then fetch the actual error code
    from the errno variable (as shown in Listing 7-2 on [page 358](chapter7.xhtml#pg_358),
    for example).
  prefs: []
  type: TYPE_NORMAL
- en: 'Dealing with error return values in portable code could be problematic. One
    solution is to use a set of wrapper functions to handle errors in an OS-specific
    fashion for each OS. I’ve chosen to create a small macro to translate the error
    return status to a common value on both macOS and Linux:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Under macOS, if the carry is clear ❶, then this macro does nothing (no error).
    If there is an error (carry set), the macro negates the value in X0 ❷ (which is
    currently a positive error code).
  prefs: []
  type: TYPE_NORMAL
- en: Under Linux, an error is indicated by returning –1 in X0, in which case the
    code has to retrieve the actual error code from the errno variable. If the API
    function returns –1 ❸, the code fetches errno’s value ❹ (which is a positive number)
    and negates it.
  prefs: []
  type: TYPE_NORMAL
- en: This macro assumes that the API function will return a nonnegative result in
    X0 if there is no error, so it returns a negation of the actual error code if
    there was an error. This will provide a sign-consistent set of values you can
    test for under either OS.
  prefs: []
  type: TYPE_NORMAL
- en: Although the checkError macro produces a portable set of error codes, do not
    assume that the two OSes will produce exactly the same error codes for any given
    situation. They are more likely to produce slightly different error codes under
    the same circumstances. At the very least, you should be able to handle any error
    return code that either the macOS or Linux man pages list for a given API function
    (yet another argument for using a wrapper function to handle error codes in portable
    code).
  prefs: []
  type: TYPE_NORMAL
- en: You can lift the appropriate defines from the *errno.h* file (or other files
    it may include); this will allow you to refer to Unix-compatible constant names
    like EPERM or EACCES in your assembly source code. Don’t forget that the checkError
    macro negates the error code, so you have to compare against negated *errno.h*
    constants (for example, -EPERM or -EACCES).
  prefs: []
  type: TYPE_NORMAL
- en: 16.4 A Stand-Alone “Hello, World!” Program
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: By convention, the first “real” program to try when writing a stand-alone assembly
    program is “Hello, world!” Under Linux and macOS, you can use the system write()
    function to write a string to the standard output device, as shown in Listing
    16-3.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'In Listing 16-3, the #include statement loads in the operating-specific constant
    names for the API function call values ❶. The code defines the system call constants
    for macOS ❷. As the write symbol was already defined in the *aoaa.inc* header
    file (the name of the C stdlib write() function), I’ve used sys_write to overcome
    namespace pollution. Likewise, the code defines the Linux system call constants
    ❸.'
  prefs: []
  type: TYPE_NORMAL
- en: Calling the system API write() function prints Hello, world! ❹. This call expects
    a pointer to the string in X1, the string length in X2, and a file descriptor
    value in X0\. For the stdout device, the file descriptor is 1\. Finally, I include
    the usual program termination code ❺.
  prefs: []
  type: TYPE_NORMAL
- en: Note that the C stdlib write() function is nothing more than facade code that
    directly calls the Linux write() API function. If we were willing to link with
    C code, we could have accomplished the same thing by calling write(), but doing
    so would defeat the purpose of this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s the makefile that will build the program in Listing 16-3:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Here are the commands to build and run the program, along with the sample output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Note that the program did not print Calling Listing16-3 nor Listing16-3 terminated.
    That output is produced by the *c.cpp* main() function, which this code is not
    using.
  prefs: []
  type: TYPE_NORMAL
- en: 16.5 A Sample File I/O Program
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'File I/O has been conspicuously absent from the book thus far. While reading
    and writing file data is easily achieved using the C stdlib functions such as
    fopen, fclose, and fprintf, the Linux and macOS APIs provide many useful functions
    (on which the C stdlib is built) for this purpose. This section describes a few
    of these functions:'
  prefs: []
  type: TYPE_NORMAL
- en: open    Open (or create) a file for reading, writing, or appending.
  prefs: []
  type: TYPE_NORMAL
- en: read    Read data from an open file.
  prefs: []
  type: TYPE_NORMAL
- en: write    Write data to an open file.
  prefs: []
  type: TYPE_NORMAL
- en: close    Close an open file.
  prefs: []
  type: TYPE_NORMAL
- en: 'For the purposes of this example, I’ll implement these calls as a *files* library
    consisting of three source modules:'
  prefs: []
  type: TYPE_NORMAL
- en: '***volatile.S***    A pair of utility functions that save and restore all the
    volatile registers'
  prefs: []
  type: TYPE_NORMAL
- en: '***stdio.S***    A set of I/O routines that write data to the stdout device
    and read data from the stdin device (console I/O)'
  prefs: []
  type: TYPE_NORMAL
- en: '***files.S***    A set of routines for opening, reading, writing, and closing
    files'
  prefs: []
  type: TYPE_NORMAL
- en: 'I’ve put these files in a *files* subdirectory, along with a *files.mak* makefile
    that will assemble these files and put them in a *file.a* archive file. Here’s
    the makefile:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: After this makefile successfully builds the source files (and combines them
    into the *file.a* archive file) ❶, it copies *file.a* into the parent directory,
    where the application that uses *files.a* appears.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before discussing the file library’s source files, I’ll present the *files.inc*
    header file, since it contains definitions that both the library and application
    source code will use:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'As mentioned earlier, the macOS SYS_* symbols appear inside an #ifdef block
    that hides the definitions if the symbol __APPLE_API_PRIVATE is not defined. Therefore,
    when including the sys/syscall.h header file under macOS, *files.inc* needs to
    define the symbol __APPLE_API_PRIVATE so that all the SYS_* labels will be processed
    by the CPP ❶.'
  prefs: []
  type: TYPE_NORMAL
- en: The *files.inc* header then defines various symbols whose values differ by OS
    (in particular, the API function call numbers) ❷ ❸. This conditional assembly
    block also defines the O_CREAT symbol, which is different for the two OSes.
  prefs: []
  type: TYPE_NORMAL
- en: Next, the header defines various constants that will be useful in both the library
    source code and in applications that link against the library ❹. The stdin, stdout,
    and stderr constants are the Unix file descriptor values for the standard input
    device, the standard output device, and the standard error (output) device, respectively.
    The library uses cr, lf, and bs as ASCII character code constants.
  prefs: []
  type: TYPE_NORMAL
- en: 'I’ve then inserted several #define statements lifted from *fcntl.h* ❺ (yet
    another C/C++ header file containing useful API constant definitions; you’ll usually
    find it in the same directory as *syscall.h*). These constants are used with the
    openat() function when creating a new file (you supply these constants for the
    mode parameter). As with *errno.h*, you cannot simply include *fcntl.h* because
    Gas will not be able to process the C/C++ statements that appear in it.'
  prefs: []
  type: TYPE_NORMAL
- en: As previously discussed, the library uses the file.checkError macro ❻ after
    svc instructions to check error return results. Finally, the code includes external
    definitions for all the functions that appear in the *files.a* library ❼.
  prefs: []
  type: TYPE_NORMAL
- en: 16.5.1 volatiles.S Functions
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The *volatiles.S* source file contains two functions that save and restore
    all the volatile registers, saveVolatile and restoreVolatile:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: These functions simply store the registers into successive locations at the
    address held in the FP register. It is the caller’s responsibility to preserve
    FP and load it with the address of the volatile_save structure before calling
    saveVolatile or restoreVolatile. As you can see in *volatiles.S*, this code does
    not preserve the value in the FP register.
  prefs: []
  type: TYPE_NORMAL
- en: The purpose behind saveVolatile and restoreVolatile is to overcome the fact
    that the OS API calls can modify the volatile register set. It’s good assembly
    language programming style to always preserve register values unless you are explicitly
    returning a result in a register. The *volatiles.S* functions allow you to conform
    to this style even when calling low-level API functions that trash the volatile
    registers.
  prefs: []
  type: TYPE_NORMAL
- en: The one downside of these functions is that you never know which volatile registers
    a given API function might modify, so you have to preserve them all, even if the
    API function changes only a few. This, sadly, introduces inefficiency into the
    code; reading and writing memory is not especially fast. However, not having to
    worry about volatile registers in your assembly language code is worth the slight
    efficiency loss. (Moreover, file I/O is usually a relatively slow process to begin
    with, so if you’re frequently calling file I/O functions, saving and restoring
    the registers is probably a very small percentage of the running time.)
  prefs: []
  type: TYPE_NORMAL
- en: 'The *aoaa.inc* header file contains the following structure to define the layout
    of the registers saved by saveVolatile and loaded by restoreVolatile:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Because this structure is rather large, saveVolatile and restoreVolatile do
    not refer to the individual fields. The offsets to certain members of this structure
    are too large to encode in the addressing mode offset field of a 32-bit load instruction.
    Nevertheless, these structures do document where saveVolatile and restoreVolatile
    place the data.
  prefs: []
  type: TYPE_NORMAL
- en: 16.5.2 files.S File I/O Functions
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The *files.S* source file contains the file I/O functions in the library. Because
    this file is rather long, I’ll break it into pieces and discuss each section in
    turn. (I won’t include the parameter values you pass to these functions; these
    are well documented online, or you can use the Unix man command for the read(),
    write(), open(), openat(), and close() functions.)
  prefs: []
  type: TYPE_NORMAL
- en: 'Most of the *files.S* functions are facade code—that is, they exist to change
    the environment or parameters of another function (in this case, the OS API functions).
    These functions preserve volatile registers so that the caller doesn’t have to
    worry about their preservation; in a few cases (open calls), they automatically
    set up certain default parameters for the caller; or, in the event of an error,
    they modify the return codes to produce a consistent result across OSes. The file.write
    function demonstrates providing a uniform interface (across OSes), preserving
    the volatile registers, and returning a consistent error code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: In the activation record, file.write reserves space for the volatile register
    save area ❶ and the special variable fw_locals.fpSave ❷. The code will use this
    variable to preserve the FP register across calls to saveVolatile and restoreVolatile.
    Note that fw_locals.fpSave appears last in the activation record, so it will be
    located on the top of the stack when file.write builds the activation record.
    This is a temporary variable that will not be used when system calls use the space
    on the top of the stack (assuming they do).
  prefs: []
  type: TYPE_NORMAL
- en: Next, file.write saves all the volatile registers to the volatile save area
    (fw_locals.volSave) ❸. Because saveVolatile expects FP pointing at the save area,
    this code saves FP to the top of the stack (which just happens to be the location
    of the fw_locals.fpSave variable), loads FP with the address of the fw_locals.volSave
    structure, calls saveVolatile, and then restores FP upon return.
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that the code could not reference the fw_locals.fpSave variable by using
    the [FP, #fw_locals.fpSave] addressing mode. First, the size of the activation
    record is too large, and the offset of fw_locals.fpSave cannot be encoded into
    a 32-bit instruction. Second, FP is not pointing at the activation record upon
    return from saveVolatile, so the [FP, #fw_locals.fpSave] addressing mode would
    reference the wrong location (even if the offset weren’t too large).'
  prefs: []
  type: TYPE_NORMAL
- en: The code then actually calls the API function ❹. This code is almost trivial,
    because all the parameters the write() function requires are already in the appropriate
    registers, as they were passed into file.write in those registers.
  prefs: []
  type: TYPE_NORMAL
- en: 'The code checks for an error and massages the value in X0 if an error occurred
    during the write operation ❺. The file.write function restores the registers previously
    saved to fw_locals.volSave ❻. The code and explanation are almost identical to
    that at ❸, with one exception: the value in X0\. Because this code returns a function
    result in X0 and restoreVolatile will restore X0 to its original value, this code
    has to save and restore X0 across the call to restoreVolatile. Because the variable
    fw_locals.saveX0 appears in the activation record before fw_locals.volSave, there
    is no problem with the offset when using the [FP, #fw_locals.saveX0] addressing
    mode; only the variables appearing after fw_locals.volSave will have offsets too
    large to use in the addressing mode.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The file.read function is almost identical to the file.write function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: The only real difference between file.read and file.write is the function number
    loaded into the svcReg register.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, *files.S* provides the code for the file.open function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'The file.open function is identical to file.write and file.read, except for
    the call to the OS API function ❶. Instead of calling the API open() function,
    file.open calls the API openat() function, a more modern version of open(). Here
    are the C/C++ prototypes for these two functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: The openat() function has one extra parameter, int dirfd. This complicates matters
    because file.open expects the same parameters as the open() function; therefore,
    upon entry to file.open, the parameters are sitting in the wrong registers for
    a call to openat().
  prefs: []
  type: TYPE_NORMAL
- en: This is easily fixed by moving X1 to X2 and X0 to X1, then loading X0 with the
    value AT_FDCWD to make the openat() function behave like open() ❶. The open()
    and openat() functions have an optional third or fourth parameter (respectively)
    that lets you set the permissions when creating a new file. The file.open function
    is intended for opening existing files, so you don’t normally specify that extra
    parameter when calling it. However, just in case the caller specifies O_CREAT
    in X1, this code sets X3 to a reasonable value (read and write permissions for
    everyone).
  prefs: []
  type: TYPE_NORMAL
- en: 'The file.openNew function is a variant of file.open used to create new files:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: The only difference between file.openNew and file.open is that file .openNew
    expects just a single parameter (the pathname in X0) and automatically supplies
    the flag values (O_CREAT+O_WRONLY+O_EXCL) for the call to openat().
  prefs: []
  type: TYPE_NORMAL
- en: 'The file.close function is the final file I/O function in the *files.S* source
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: The file.close function expects a file descriptor in X0 (returned by a successful
    call to file.open or file.openNew) and passes that descriptor along to the API
    close() function. Otherwise, it’s similar in form to the file.read and file.write
    functions.
  prefs: []
  type: TYPE_NORMAL
- en: 16.5.3 stdio.S Functions
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The last source file in the files library is the *stdio.S* file. This module
    contains functions you can use to read and write strings on the console (standard
    I/O) device. Again, because of its size, I’ve broken this source file into more
    easily digestible pieces.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, the stdout.puts function writes a (zero-terminated) string to the standard
    output device (usually the display console):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Note that this code does not preserve all the volatile registers ❶, because
    the stdout.puts function does not directly call an OS API function that might
    modify the registers. Therefore, this function preserves only the actual registers
    it uses.
  prefs: []
  type: TYPE_NORMAL
- en: 'This function will call file.write to write the string to the standard output
    device. The file.write function requires three parameters: a file descriptor (the
    stdout constant works fine for the descriptor value), the address of the data
    (string) to write, and a length value. Although stdout.put has the address of
    the string in X0, there is no length parameter. Therefore this code computes the
    length of the zero-terminated string whose address appears in X0 ❷.'
  prefs: []
  type: TYPE_NORMAL
- en: NOTE
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*Scanning the string a byte at a time is a lame way to compute string length,
    but I’ve done so here because it is simpler than the alternative. If this really
    bothers you, you can link in the C stdlib* strlen() *function. However, keep in
    mind that making the system call and drawing all those pixels on the screen to
    print the string is many orders of magnitude slower than this string-length calculation,
    so you won’t save much time by using faster string-length computation code.*'
  prefs: []
  type: TYPE_NORMAL
- en: Once the length is computed, the stdout.put function calls file.write to actually
    print the string to the standard output device ❸. After restoring the few registers
    this code changed, the function returns.
  prefs: []
  type: TYPE_NORMAL
- en: Technically, file.write could return an error code (which stdout.puts ignores
    and doesn’t return to its caller). However, the likelihood of such an error is
    low, so this code ignores errors. One likely problem could be if standard output
    were redirected to a disk file and there was an issue writing to the disk, so
    this bug is worth addressing if this routine finds its way into production code;
    I chose not to address this here to keep the code cleaner (and because of the
    extremely low probability of occurrence).
  prefs: []
  type: TYPE_NORMAL
- en: 'The stdout.newLn function is identical to stdout.puts, except that it writes
    a fixed string (a newline character) to the standard output device:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'The stdin.read function is the input complement to stdout.write:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: When you pass stdin.read a buffer’s address and size, it will read up to that
    number of characters from the standard input device (usually the keyboard) and
    place those characters into the buffer. This function will stop reading characters
    when it either reads the specified number of characters or encounters a newline
    character (line feed) in the input.
  prefs: []
  type: TYPE_NORMAL
- en: The twist to this otherwise straightforward code is that it has to move the
    address and byte count around ❶ prior to calling the OS read() function. This
    is because the buffer address needs to go in X1 and X2 when calling read(), and
    the function has to load the standard input file descriptor into X0.
  prefs: []
  type: TYPE_NORMAL
- en: 'The stdin.getc function is a one-character version of stdin.read:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: The stdin.getc function returns the character it reads in X0 rather than placing
    it in a buffer. This function has to reserve storage for a buffer ❶ because the
    call to the API read() function requires a buffer. Technically, the buffer needs
    to be only eight characters long, but this function reserves 16 bytes just to
    help keep the stack 16-byte aligned. This code initializes the first 8 bytes of
    the buffer to 0 ❷. The function will actually return all 8 bytes (even though
    the read operation stores only a single byte into the buffer). This function computes
    the address of the buffer to pass to the API read() function ❸.
  prefs: []
  type: TYPE_NORMAL
- en: If, somehow, the call to the API read() function returns an error, the code
    will store the negative error return code into the first 8 bytes of the buffer
    ❹. Before returning, stdin.getc loads the 8 bytes at the beginning of the buffer
    into X0 and returns that value (this is either the single character plus seven
    0s, a UTF-8 value, or the 8-byte negative error code) ❺.
  prefs: []
  type: TYPE_NORMAL
- en: NOTE
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*The* stdin.get *function does not read a single character from the keyboard
    and then immediately return to the caller. Instead, the OS will read a whole line
    of text from the* *keyboard and return the first character of that line. Successive
    calls to* stdin.get *will read the remaining characters from that internal OS
    buffer. This is standard Unix behavior, not a specific feature of this function.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'The last function in the *stdio.S* file is stdin.readln:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: This function, intended mainly for interactive use, reads a line of text from
    the keyboard with a modicum of editing (handling backspace characters), placing
    those characters into a buffer. In many respects, it works just like stdin.read,
    except that pressing BACKSPACE deletes a character from the input buffer rather
    than returning the backspace ASCII code as a character of the buffer.
  prefs: []
  type: TYPE_NORMAL
- en: This function repeatedly calls stdin.getc ❶, reading one character at a time.
    If stdin.getc returns an error (a negative return value), this function immediately
    returns, passing the error code on to its caller.
  prefs: []
  type: TYPE_NORMAL
- en: The code checks whether the input line is complete by comparing the character
    against the ASCII codes for a carriage return or newline (line feed) ❷. If the
    character matches one of these two, the code exits the loop.
  prefs: []
  type: TYPE_NORMAL
- en: The stdin.readln function then checks for a backspace character ❸. If it is
    a backspace, this function will delete the previous character from the input buffer
    (if there was one). If the character is not a backspace, the code branches down
    to ❹, where it appends the character to the end of the buffer.
  prefs: []
  type: TYPE_NORMAL
- en: When the function finds a carriage return or line feed in the input stream,
    it transfers control to ❺, where it zero-terminates the string and returns the
    number of characters actually read in the X0 register.
  prefs: []
  type: TYPE_NORMAL
- en: Beyond processing backspace characters, there are two additional differences
    between reading a line of text with stdin.readln and simply calling stdin.read.
    First, stdin.readln will zero-terminate the string read into the buffer. Second,
    stdin.readln does not place the newline character (or carriage return) in the
    buffer.
  prefs: []
  type: TYPE_NORMAL
- en: 16.5.4 File I/O Demo Application
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The simple application in Listing 16-4 demonstrates the use of the *file.a*
    library.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: This program begins by prompting the user to enter a filename ❶. It reads this
    filename from the user and then echoes the filename to the display. The program
    opens the file and saves away the file handle that file .open returns ❷. If an
    error occurred opening the file, the program drops down to the badOpen label,
    prints an error message, and quits.
  prefs: []
  type: TYPE_NORMAL
- en: Next, the program continuously reads a block of (up to) 4,096 bytes until the
    end of the file is reached (or another error occurs) ❸. When reading from a file,
    the file.read function will read the full 4,096 bytes, ignoring any newline characters
    (it stops on newlines only when reading from the standard input). If this function
    reads 0 bytes from the input, it has reached the end of the file, and the loop
    exits.
  prefs: []
  type: TYPE_NORMAL
- en: The code then writes the bytes read to the standard output device ❹, using the
    return value from file.read as the byte count on the call to file .write. This
    is because the last block of bytes read from the file might not be 4,096 bytes
    in length; if it read fewer than 4,096 bytes, the next read will return 0 bytes
    and the operation will be complete. Once the program completes, it closes the
    file and quits ❺>.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s the makefile that will build the program in Listing 16-4:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Here’s a sample build operation and execution of the program:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: I’ve used the *Listing16-4.mak* text file as the input for this run of the program.
  prefs: []
  type: TYPE_NORMAL
- en: '### 16.6 Calling System Library Functions Under macOS'
  prefs: []
  type: TYPE_NORMAL
- en: As I mentioned earlier, Apple frowns on applications that make direct calls
    to the macOS kernel via the svc instruction. The company claims the proper way
    to make those calls is via the C library code Apple has provided. This chapter
    has shown you the low-level calls because, well, that was the purpose of this
    chapter; if you’re the one writing the C library code (or similar library code
    that interfaces to the OS), you need to know this information. However, I would
    be remiss if I didn’t show you how Apple recommends interfacing applications with
    macOS.
  prefs: []
  type: TYPE_NORMAL
- en: 'I’ve created a variant of the *files.a* library, stored in the *files-macOS*
    directory in the online source code set, that links in the kernel read(), write(),
    open(), and close() functions. To avoid redundancy, I don’t print all that code
    in this chapter, but I’ll list the file.write function here to give you an idea
    of the simplicity of the change:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: The only difference between this version of file.write and the version in the
    original *files.a* library is that I’ve replaced the svc instruction sequence
    with a call to the _write() function ❶.
  prefs: []
  type: TYPE_NORMAL
- en: 'The new *files.a* library also includes a couple of changes to the *files.inc*
    header file. The most important change is to the file.checkError macro:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: The macOS _write() function returns –1 when an error occurs, since C code can’t
    test the carry flag. Therefore, I modified file.checkError to handle errors the
    same way Linux does.
  prefs: []
  type: TYPE_NORMAL
- en: I had to build the *files-macOS* library first (to create a new version of *file.a*,
    replacing the version that made direct OS calls), then made *Listing16-4.S* by
    using the *file.a* library from *files-macOS*. The program ran the same as the
    original file I/O example from the previous section.
  prefs: []
  type: TYPE_NORMAL
- en: 'In theory, you could use this same approach with Linux, creating slightly more
    portable code between the two OSes. However, the svc API interface under Linux
    is well defined and documented, so there is no reason not to call the API functions
    directly.  ### 16.7 Creating Assembly Applications Without GCC'
  prefs: []
  type: TYPE_NORMAL
- en: 'Throughout this chapter, I’ve continued to use GCC to assemble and link the
    assembly language files. That’s because most of the example code in this chapter
    includes *aoaa.inc*, and that file depends on the CPP. You might view this approach
    with suspicion, thinking GCC might be sneaking some C code into your program.
    And you would be right: even when you build a “pure” assembly language program
    with GCC, it links in some code to set up the environment prior to the execution
    of your program (so that if you do call any C library code, the environment has
    been set up for it).'
  prefs: []
  type: TYPE_NORMAL
- en: Generally, such extra code is of little consequence—it executes once, is fairly
    fast, and doesn’t take up that much space. However, if you are an absolute purist
    and you want to execute only the code you’ve written, you can do so with a little
    extra work. You just won’t be able to use *aoaa.inc*, and you’ll have to write
    non-portable code specifically for macOS or Linux.
  prefs: []
  type: TYPE_NORMAL
- en: Listing 16-5 is a “pure” assembly language program written for Linux.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Please note that this filename must have a lowercase *.s* suffix ❶; you will
    not be compiling this using GCC, so you won’t be using CPP with this code. Under
    Linux, the default program entry point is named _start. Therefore, this code declares
    _start as a global symbol ❷ and uses _start as the entry point for the program
    ❸. I got away with using main (or _main) in earlier examples in this chapter because
    the C code that GCC links in supplies the _start label and transfers control to
    main (or _main); however, as we’re giving up the GCC-generated code, we have to
    explicitly supply the _start label.
  prefs: []
  type: TYPE_NORMAL
- en: 'To assemble, link, and run this program, use the following Linux commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: To make this program run under macOS, you must first modify the source code
    to use the appropriate macOS API constants, as shown in Listing 16-6.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Assembling the code is similar to Linux (note that the program name suffix
    is also a lowercase *.s*):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Linking the program, however, is a bit more complex:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: It’s best to use a makefile when building pure assembly files under macOS; manually
    typing these commands every time you want to build the application can be quite
    tedious!
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, the linker (ld) command still links in a bunch of C code (libSystem).
    There’s no other way (that I know of) to avoid this, which is why I’m perfectly
    happy letting GCC do all this work for me.
  prefs: []
  type: TYPE_NORMAL
- en: NOTE
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*Apple isn’t kidding when it warns you against writing code like this. Between
    the time I first wrote this “Hello, World!” and the time this chapter was reviewed,
    Apple made changes to its system that broke the program. In particular, the linker
    now expects the program to be named* _main *rather than* _start*, and the command
    line for* ld *has some subtle changes. Moral of the story: stick with GCC (Clang)
    to do all this work for you.*'
  prefs: []
  type: TYPE_NORMAL
- en: 16.8 For More Information
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You can find the system call numbers for Linux at *[https://<wbr>github<wbr>.com<wbr>/torvalds<wbr>/linux<wbr>/blob<wbr>/v4<wbr>.17<wbr>/include<wbr>/uapi<wbr>/asm<wbr>-generic<wbr>/unistd<wbr>.h](https://github.com/torvalds/linux/blob/v4.17/include/uapi/asm-generic/unistd.h)*.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Find the system call numbers for macOS at *[https://<wbr>github<wbr>.com<wbr>/opensource<wbr>-apple<wbr>/xnu<wbr>/blob<wbr>/master<wbr>/bsd<wbr>/kern<wbr>/syscalls<wbr>.master](https://github.com/opensource-apple/xnu/blob/master/bsd/kern/syscalls.master)*
    or *[https://<wbr>opensource<wbr>.apple<wbr>.com<wbr>/source<wbr>/xnu<wbr>/xnu<wbr>-1504<wbr>.3<wbr>.12<wbr>/bsd<wbr>/kern<wbr>/syscalls<wbr>.master](https://opensource.apple.com/source/xnu/xnu-1504.3.12/bsd/kern/syscalls.master)*.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
