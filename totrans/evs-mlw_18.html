<html><head></head><body>
<section epub:type="chapter" role="doc-chapter" aria-labelledby="ch14">&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_265" aria-label="265"/>&#13;
<hgroup>&#13;
&#13;
<h2 class="CHAPTER" id="ch14">&#13;
<span class="CN"><samp class="SANS_Futura_Std_Bold_Condensed_B_11">14</samp></span>&#13;
<span class="CT"><samp class="SANS_Dogma_OT_Bold_B_11">INTRODUCTION TO ROOTKITS</samp></span>&#13;
</h2>&#13;
</hgroup>&#13;
<figure class="opener"><img class="opener" src="../images/opener.jpg" alt=""/></figure>&#13;
<p class="TNI2"><i>Rootkits</i> are malware variants that specialize in hiding their presence on a host by first obtaining low-level access to the victim system. The name <i>rootkit</i> originates from Unix, where the <i>root</i> user has the highest level of privileges the system allows. Rootkits use several evasion methods, such as intercepting and modifying communication between kernel and user space and directly tampering with data structures in kernel memory, to hide from endpoint defenses and investigation tools.</p>&#13;
<p class="TX">This chapter provides an introductory overview of kernel-based rootkits and some of the techniques they use to evade defenses and manipulate a system. While not an exhaustive resource on rootkits or rootkit analysis, this chapter covers some of the tactics to be on the lookout for when you’re investigating low-level malware.</p>&#13;
<section epub:type="division" aria-labelledby="sec1">&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_266" aria-label="266"/>&#13;
<h3 class="H1" id="sec1"><span id="h-230"/><samp class="SANS_Futura_Std_Bold_B_11">Rootkit Fundamentals</samp></h3>&#13;
<p class="TNI1">There are many reasons why a malware author might use rootkit components:</p>&#13;
<p class="ListHead"><b>Persistence and survivability</b></p>&#13;
<p class="ListPlainFirst">Since rootkits exist in kernel space and have low-level system access, they can persist after reboots and in strong, well-defended environments. Bootkits, an advanced form of rootkit we’ll discuss later in the chapter, reside at the firmware layer and therefore have even greater persistence.</p>&#13;
<p class="ListHead"><b>Defense circumvention</b></p>&#13;
<p class="ListPlainFirst">Some rootkits actively tamper with and blind endpoint defenses such as EDR and anti-malware. Such rootkits can also hide and protect their files and processes from investigators by redirecting function calls, for example.</p>&#13;
<p class="ListHead"><b>Low-level access to devices and drivers</b></p>&#13;
<p class="ListPlainFirst">Some rootkits intercept requests and commands to and from kernel drivers and hardware. One example is Moriya (see the May 2021 article “Operation TunnelSnake” at <a href="https://securelist.com/operation-tunnelsnake-and-moriya-rootkit/101831/"><i>https://<wbr/>securelist<wbr/>.com<wbr/>/operation<wbr/>-tunnelsnake<wbr/>-and<wbr/>-moriya<wbr/>-rootkit<wbr/>/101831<wbr/>/</i></a>), which intercepts, manipulates, and hides network traffic to and from the infected host.</p>&#13;
<div class="spc"/>&#13;
<p class="TX">Because rootkits reside in kernel space and work by manipulating kernel elements, let’s take a closer look at what these components are before discussing how rootkits take advantage of them.</p>&#13;
<section epub:type="division" aria-labelledby="sec2">&#13;
&#13;
<h4 class="H2" id="sec2"><span id="h-231"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_I_11">Kernel Modules and Drivers</samp></h4>&#13;
<p class="TNI1"><i>Kernel modules</i> are binary files containing code and data that extend the kernel’s functionalities. They can be loaded at system boot-up or on demand. <i>Kernel drivers</i> are a specific type of kernel module that interact with system hardware. There are different types of kernel drivers:</p>&#13;
<p class="ListHead"><b>Device drivers</b></p>&#13;
<p class="ListPlainFirst">Perhaps the most common type of kernel driver, device drivers provide an interface between Windows and the underlying hardware devices of the system, such as keyboards, mice, and printers. They interact with system hardware either directly or indirectly.</p>&#13;
<p class="ListHead"><b>Filter drivers</b></p>&#13;
<p class="ListPlainFirst">As their name suggests, filter drivers “filter” IO communication destined for other drivers, intercepting and potentially modifying it. These drivers add functionality to other drivers or to the system at large, and they also enable capabilities such as logging and monitoring. Some malicious actors load filter drivers in the kernel to take advantage of these benefits, as you’ll see later.</p>&#13;
<p class="ListHead"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_267" aria-label="267"/><b>Minifilter drivers</b></p>&#13;
<p class="ListPlainFirst">Similar to filter drivers, minifilter drivers filter IO operations and were introduced in more modern versions of Windows to improve performance and simplify development and compatibility. These drivers can also be abused by malicious actors.</p>&#13;
<blockquote>&#13;
<p class="Note"><span class="NoteHead"><samp class="SANS_Dogma_OT_Bold_B_15">NOTE</samp></span></p>&#13;
</blockquote>&#13;
<p class="NOTE-TXT"><i>Even though all kernel drivers are modules, not all kernel modules are drivers. However, for simplicity’s sake, I’ll use the terms</i> <span class="note_Italic">module</span> <i>and</i> <span class="note_Italic">driver</span> <i>interchangeably in this chapter.</i></p>&#13;
<p class="TX">You can view loaded kernel modules in Windows using a Process Manager–like tool such as Process Hacker, as shown in <a href="chapter14.xhtml#fig14-1">Figure 14-1</a>.</p>&#13;
<figure class="IMG"><img class="img100" id="fig14-1" src="../images/fig14-1.jpg" alt=""/>&#13;
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 14-1: Viewing loaded kernel modules in Process Hacker</samp></p></figcaption>&#13;
</figure>&#13;
<p class="TX">To view loaded kernel modules in Process Hacker, right-click the system process, select <b>Properties</b>, and then select the <b>Modules</b> tab. In <a href="chapter14.xhtml#fig14-1">Figure 14-1</a>, you can see some of the kernel drivers installed on my system, such as Advanced Configuration and Power Interface (ACPI) drivers and display drivers such as the VGA boot driver.</p>&#13;
<p class="TX">Now that you have a basic understanding of kernel drivers, let’s dive into the structure of malicious kernel drivers, which are more commonly known as rootkits.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec3">&#13;
&#13;
<h4 class="H2" id="sec3"><span id="h-232"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_I_11">Rootkit Components</samp></h4>&#13;
<p class="TNI1">Rootkits commonly have two components: a process running in user space and a kernel driver that receives instructions from that process. Rootkits nearly always start with a user-space executable that must be deployed and executed on the victim host. Once this is accomplished, the malicious process loads a driver into kernel space. <a href="chapter14.xhtml#fig14-2">Figure 14-2</a> shows a simple, high-level view of how rootkits are installed.</p>&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_268" aria-label="268"/>&#13;
<figure class="IMG"><img class="img60" id="fig14-2" src="../images/fig14-2.jpg" alt=""/>&#13;
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 14-2: The rootkit installation process</samp></p></figcaption>&#13;
</figure>&#13;
<p class="TX">First, the victim is delivered a dropper executable (<i>malware.exe</i>) that, once executed, decrypts an embedded malicious kernel driver (<i>rootkit.sys</i>). The dropper configures and executes this driver as a service, completing the rootkit’s installation into kernel space. (We’ll discuss this more in a moment.) The user-space process code contains the majority of the malware’s primary functionalities, while the kernel component works to mask and protect the user-space process on the system, establish low-level hooks to hide its artifacts in memory and on disk, and blind endpoint defenses and investigators to its presence.</p>&#13;
<p class="TX"><a href="chapter14.xhtml#fig14-3">Figure 14-3</a> illustrates some of the newly installed rootkit’s functionalities.</p>&#13;
<figure class="IMG"><img class="img100" id="fig14-3" src="../images/fig14-3.jpg" alt=""/>&#13;
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 14-3: The basic functionalities of a rootkit</samp></p></figcaption>&#13;
</figure>&#13;
<p class="TX">This rootkit can conceal its user-space executable (<i>malware.exe</i>) as well as issue commands to its kernel driver (<i>rootkit.sys</i>) <span class="CodeAnnotation" aria-label="annotation1">❶</span>. Rootkit user-space components often communicate to their kernel-space counterparts <span role="doc-pagebreak" epub:type="pagebreak" id="pg_269" aria-label="269"/>by sending requests via a WinAPI function such as <samp class="SANS_TheSansMonoCd_W5Regular_11">DeviceIOControl</samp>, which allows a user-space process to send a control code (instruction) to a kernel-space driver. In addition, this rootkit is able to hook and intercept API calls from user space <span class="CodeAnnotation" aria-label="annotation2">❷</span>, intercept communication between other kernel components and device drivers <span class="CodeAnnotation" aria-label="annotation3">❸</span>, and even tamper with kernel memory directly <span class="CodeAnnotation" aria-label="annotation4">❹</span>. All of these techniques will become clearer as we progress through this chapter. But first, let’s take a step back and talk about how rootkits are installed in the first place.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec4">&#13;
&#13;
<h4 class="H2" id="sec4"><span id="h-233"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_I_11">Rootkit Installation</samp></h4>&#13;
<p class="TNI1">In the past, rootkits were more prevalent, but Microsoft has implemented protective measures in later versions of Windows that make it more difficult to implement the changes necessary to install malicious kernel components on a system. Even so, there are ways to bypass these protections, so these kinds of attacks do still happen sometimes. Let’s take a look at a recent real-world example: HermeticWiper.</p>&#13;
<p class="TX">HermeticWiper targeted victims in Ukraine in 2022. It’s not a rootkit per se; rather, it is destructive malware that requires low-level access to overwrite data on the disk, rendering a system unbootable. However, because HermeticWiper uses a common method of loading a kernel driver and is well documented, it’s a good example of how rootkits can also be installed in a victim environment.</p>&#13;
<p class="TX">One particular HermeticWiper sample was signed by a certificate stolen from a valid company, Hermetica Digital Ltd., potentially allowing HermeticWiper to bypass certain endpoint defenses. (This technique was discussed in <span class="Xref"><a href="chapter13.xhtml">Chapter 13</a>.</span>) When HermeticWiper first executes, the sample writes a new <i>.sys</i> file with a file name consisting of four characters (such as <i>bpdr.sys</i>) to disk. This file is a legitimate driver from the company EaseUS that is normally used to resize and partition disks; however, it can be misused, as we’ll see in a moment. Since at the time of the attack, this file is signed by a valid certificate, it’s able to bypass Windows protections like driver-signing enforcement.</p>&#13;
<p class="TX">Next, to obtain the special privileges required for loading drivers, HermeticWiper attempts to obtain <samp class="SANS_TheSansMonoCd_W5Regular_11">SeLoadDriverPrivilege</samp>. This privilege can be obtained only by a process already running at a high privilege level, so most malware will need to use a privilege elevation technique (such as a UAC bypass) to get administrator or system-level privileges and then call a function such as <samp class="SANS_TheSansMonoCd_W5Regular_11">AdjustTokenPrivileges</samp> (as discussed in <span class="Xref"><a href="chapter13.xhtml">Chapter 13</a></span>). Once it has the required privileges, HermeticWiper creates a new service by calling <samp class="SANS_TheSansMonoCd_W5Regular_11">CreateServiceW</samp> and starts it by calling <samp class="SANS_TheSansMonoCd_W5Regular_11">StartServiceW</samp>. Creating and executing a service is one of the most common methods of loading a new kernel driver, for both legitimate and malicious purposes. It can also be accomplished via the Windows command line, like so:</p>&#13;
<pre class="pre-120"><code>C:\&gt; sc create "evil" binPath="C:\Users\Public\evil.sys" type=kernel</code></pre>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_270" aria-label="270"/>This command creates a new service (<samp class="SANS_TheSansMonoCd_W5Regular_11">evil</samp>), specifying an input parameter of <samp class="SANS_TheSansMonoCd_W5Regular_11">C:\Users\Public\evil.sys</samp> (the path of the malicious driver to be loaded) and a type of <samp class="SANS_TheSansMonoCd_W5Regular_11">kernel</samp>, denoting this service as a kernel driver installation. The following command can then be used to start the service:</p>&#13;
<pre class="pre-121"><code>C:\&gt; sc start "evil"</code></pre>&#13;
<p class="TX">Here’s the output of executing these commands in Windows:</p>&#13;
<pre class="pre-122"><code>C:\Windows\system32&gt; sc create "evil" binPath="C:\Users\Public\evil.sys" type=kernel&#13;
&#13;
[SC] CreateService SUCCESS&#13;
&#13;
C:\Windows\system32&gt; sc start "evil"&#13;
&#13;
SERVICE_NAME: evil&#13;
TYPE             : 1 KERNEL_DRIVER&#13;
STATE            : 4 RUNNING&#13;
<var>--snip--</var>&#13;
WIN32_EXIT_CODE  : 0 (0x0)&#13;
<var>--snip--</var></code></pre>&#13;
<p class="TX">In the case of HermeticWiper, since the driver (at the time of attack, at least) is legitimate and signed by a valid authority, it likely won’t have any issues installing in kernel space and can circumvent built-in Windows controls. If the driver wasn’t signed by a valid signing authority, we’d receive the following error upon starting the service:</p>&#13;
<pre class="pre-123"><code>C:\Windows\system32&gt; sc start "evil"&#13;
&#13;
[SC] StartService FAILED 1275:&#13;
This driver has been blocked from loading</code></pre>&#13;
<p class="TX">Once the malicious service is successfully installed, the Windows Service Controller takes over and loads the driver into kernel address space. The malware’s user-space component can now interact with the malicious driver in kernel space by invoking <samp class="SANS_TheSansMonoCd_W5Regular_11">DeviceIOControl</samp> and issuing commands to it. In doing so, HermeticWiper is using an otherwise legitimate driver (the EaseUS driver) to write data to the disk, destroying this data and making infected systems inoperable.</p>&#13;
<blockquote>&#13;
<p class="Note"><span class="NoteHead"><samp class="SANS_Dogma_OT_Bold_B_15">NOTE</samp></span></p>&#13;
</blockquote>&#13;
<p class="NOTE-TXT"><i>Kernel drivers aren’t always loaded using services. There are other techniques for loading them, including invoking the NT API function <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">NtLoadDriver</samp>.</i></p>&#13;
<p class="TX">This abuse of legitimate drivers is a form of the Bring Your Own Vulnerable Driver technique, which we’ll discuss next.</p>&#13;
<aside class="box" aria-label="box-10">&#13;
<p class="BoxTitle" id="box-10"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_271" aria-label="271"/><samp class="SANS_Dogma_OT_Bold_B_11">EXPLORING H</samp><samp class="SANS_Dogma_OT_Bold_B_11">ERMETIC</samp><samp class="SANS_Dogma_OT_Bold_B_11">WIPER</samp></p>&#13;
<p class="BoxBodyFirst"><samp class="SANS_Futura_Std_Book_11">I would encourage you to explore HermeticWiper in your analysis VM. You can find a sample on VirusTotal or Malshare (</samp><samp class="SANS_TheSansMonoCd_W5Regular_11">SHA256: 1bc44eef75779e3ca1eefb8ff5a64807dbc942b1e4a2672d77b9f6928d292591</samp><samp class="SANS_Futura_Std_Book_11">).</samp></p>&#13;
<p class="BoxBodyFirst1"><samp class="SANS_Futura_Std_Book_11">Detonate the sample with Administrator privileges, and make sure to capture its behaviors in Procmon. See if you can locate where HermeticWiper is writing the driver file to disk, how it loads the driver, and how it interacts with the driver (via</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">DeviceIOControl</samp> <samp class="SANS_Futura_Std_Book_11">codes).</samp></p>&#13;
<p class="BoxBodyFirst1"><samp class="SANS_Futura_Std_Book_11">If you’d like to read more on HermeticWiper, see the following articles:</samp></p>&#13;
<ul class="ul0">&#13;
<li class="BoxListBullet"><samp class="SANS_Futura_Std_Book_11">Desai, Deepen, and Brett Stone-Gloss. “HermeticWiper &amp; Resurgence of</samp> <samp class="SANS_Futura_Std_Book_11">Targeted Attacks on Ukraine,”</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">Zscaler</samp><samp class="SANS_Futura_Std_Book_11">, February 24, 2022.</samp> <a href="https://www.zscaler.com/blogs/security-research/hermeticwiper-resurgence-targeted-attacks-ukraine"><samp class="SANS_Futura_Std_Book_Oblique_I_11">https://www.z</samp><samp class="SANS_Futura_Std_Book_Oblique_I_11">scaler.com/blogs/security-research/hermeticwiper-resurgence-targeted-attacks-ukraine</samp></a>.</li>&#13;
<li class="BoxListBullet"><samp class="SANS_Futura_Std_Book_11">Editor. “ESET Research: Ukraine Hit by Destructive Attacks Before and During the Russian Invasion with HermeticWiper and IsaacWiper,”</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">ESET</samp><samp class="SANS_Futura_Std_Book_11">, March 1, 2022.</samp> <a href="https://www.eset.com/int/about/newsroom/press-releases/research/eset-research-ukraine-hit-by-destructive-attacks-before-and-during-the-russian-invasion-with-hermet/"><samp class="SANS_Futura_Std_Book_Oblique_I_11">https://www.eset.com/int/about/newsroom/press-releases/research/eset-research-ukraine-hit-by-destructive-attacks-before-and-during-the-russian-invasion-with-hermet/</samp></a>.</li>&#13;
<li class="BoxListBullet"><samp class="SANS_Futura_Std_Book_11">Hasherezade, Ankur Saini, and Roberto Santos. “HermeticWiper: A Detailed Analysis of the Destructive Malware That Targeted Ukraine.”</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">Malwarebytes</samp><samp class="SANS_Futura_Std_Book_11">, March 4, 2022.</samp> <a href="https://www.malwarebytes.com/blog/threat-intelligence/2022/03/hermeticwiper-a-detailed-analysis-of-the-destructive-malware-that-targeted-ukraine"><samp class="SANS_Futura_Std_Book_Oblique_I_11">https://www.malwarebytes.com/blog/threat-intelligence/2022/03/hermeticwiper-a-detailed-analysis-of-the-destructive-malware-that-targeted-ukraine</samp></a>.</li>&#13;
<li class="BoxListBullet"><samp class="SANS_Futura_Std_Book_11">Roccia, Thomas. “Security Infographics: Overview of HermeticWiper,”</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">SecurityBreak</samp><samp class="SANS_Futura_Std_Book_11">, August 29, 2020.</samp> <a href="https://blog.securitybreak.io"><samp class="SANS_Futura_Std_Book_Oblique_I_11">https://blog.securitybreak.io</samp></a>.</li>&#13;
</ul>&#13;
</aside>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec5">&#13;
&#13;
<h4 class="H2" id="sec5"><span id="h-234"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_I_11">BYOVD Attacks</samp></h4>&#13;
<p class="TNI1"><i>Bring Your Own Vulnerable Driver</i> (<i>BYOVD</i>, or simply <i>BYOD</i>) attacks take advantage of legitimate, signed drivers as a sort of proxy to interact with the kernel; disable security controls; or load a separate, unsigned, malicious kernel driver. A malware author searches for a legitimate driver that is already signed by a valid signing authority (and therefore vetted by the Windows operating system) that can be dropped to the victim system during the attack. This driver must also have some sort of vulnerability that allows the threat actor to perform low-level malicious actions on the victim system. To exploit these vulnerabilities, rootkits often send commands to the vulnerable driver (by invoking <samp class="SANS_TheSansMonoCd_W5Regular_11">DeviceIOControl</samp>, for example) from their user-space process.</p>&#13;
<p class="TX">One notable example of this type of attack is the FudModule rootkit, purportedly used by North Korean cybercriminals known as the Lazarus Group. As reported by researchers at ESET, FudModule takes advantage of a vulnerable, signed Dell driver containing a vulnerability <span role="doc-pagebreak" epub:type="pagebreak" id="pg_272" aria-label="272"/>(CVE-2021-21551) that allowed Lazarus to write data into kernel memory. More specifically, the vulnerability was triggered by a specially crafted instruction to the driver via <samp class="SANS_TheSansMonoCd_W5Regular_11">DeviceIOControl</samp>. Ultimately, the threat actors successfully disabled multiple defensive mechanisms in Windows, effectively blinding endpoint defenses to later stages of the attack. For more information, see Peter K<span class="accent">á</span>lnai’s article “Amazon-Themed Campaigns of Lazarus in the Netherlands and Belgium” at <a href="https://www.welivesecurity.com/2022/09/30/amazon-themed-campaigns-lazarus-netherlands-belgium/"><i>https://<wbr/>www<wbr/>.welivesecurity<wbr/>.com<wbr/>/2022<wbr/>/09<wbr/>/30<wbr/>/amazon<wbr/>-themed<wbr/>-campaigns<wbr/>-lazarus<wbr/>-netherlands<wbr/>-belgium<wbr/>/</i></a>.</p>&#13;
<p class="TX">Another example of malware that uses the BYOVD technique is the BlackByte ransomware family. As Sophos reported, BlackByte abuses a vulnerable driver in the legitimate product MSI AfterBurner, a tool for tuning graphics cards. The driver vulnerability (CVE-2019-16098) allowed the BlackByte operators to interact with the kernel and disable EDR products on the host by terminating EDR-related processes. To learn more about this malware, check out Andreas Klopsch’s article “Remove All the Callbacks—BlackByte Ransomware Disables EDR Via RTCore64.sys Abuse” at <a href="https://news.sophos.com/en-us/2022/10/04/blackbyte-ransomware-returns/"><i>https://<wbr/>news<wbr/>.sophos<wbr/>.com<wbr/>/en<wbr/>-us<wbr/>/2022<wbr/>/10<wbr/>/04<wbr/>/blackbyte<wbr/>-ransomware<wbr/>-returns<wbr/>/</i></a>.</p>&#13;
<p class="TX">A third example is the malware family ZeroCleare, found by researchers at IBM X-Force IRIS to be abusing a vulnerable VirtualBox driver (<i>vboxdrv.sys</i>), which allowed the attacker to execute shellcode in kernel memory and install a malicious kernel driver. You can read more about this attack in the IBM report “New Destructive Wiper ZeroCleare Targets Energy Sector in the Middle East” at <a href="https://securityintelligence.com/posts/new-destructive-wiper-zerocleare-targets-energy-sector-in-the-middle-east/"><i>https://<wbr/>securityintelligence<wbr/>.com<wbr/>/posts<wbr/>/new<wbr/>-destructive<wbr/>-wiper<wbr/>-zerocleare<wbr/>-targets<wbr/>-energy<wbr/>-sector<wbr/>-in<wbr/>-the<wbr/>-middle<wbr/>-east<wbr/>/</i></a>.</p>&#13;
<p class="TX">Unfortunately, there are other recent examples of malware abusing vulnerable drivers to disable and blind endpoint defenses, load additional malicious kernel drivers, or otherwise execute malicious code in privileged areas of the operating system. Furthermore, since these drivers are legitimate and signed, there’s currently not much that can be done to completely prevent this type of attack. There’s a dedicated project for tracking these vulnerable drivers; it’s called Living Off The Land Drivers (LOLDrivers, for short). It’s worth exploring if you’re interested in learning more about BYOVD attacks, so visit the project website at <a href="https://www.loldrivers.io"><i>https://<wbr/>www<wbr/>.loldrivers<wbr/>.io</i></a>.</p>&#13;
<blockquote>&#13;
<p class="Note"><span class="NoteHead"><samp class="SANS_Dogma_OT_Bold_B_15">NOTE</samp></span></p>&#13;
</blockquote>&#13;
<p class="NOTE-TXT"><i>Not all BYOVD usage is rootkit related. For example, some malware simply leverages a vulnerable driver to execute kernel functions or perform low-level actions that would otherwise be prohibited.</i></p>&#13;
<p class="TX">Now that you’ve gotten an overview of how threat actors can bypass Windows protections to install rootkits, let’s start looking into how rootkits behave on a victim host and manipulate the system to stay hidden. We’ll start with an old technique: DKOM.</p>&#13;
</section>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec6">&#13;
&#13;
<h3 class="H1" id="sec6"><span id="h-235"/><samp class="SANS_Futura_Std_Bold_B_11">Direct Kernel Object Manipulation</samp></h3>&#13;
<p class="TNI1"><i>Direct kernel object manipulation</i> (<i>DKOM)</i> involves directly modifying data in kernel memory. This is a delicate task because, when done incorrectly, <span role="doc-pagebreak" epub:type="pagebreak" id="pg_273" aria-label="273"/>it can crash the operating system. Done correctly, however, it can give the malware immense power. One example of DKOM is hiding processes.</p>&#13;
<p class="TX">Using DKOM, a rootkit can hide its user-space processes and kernel modules from endpoint defenses and forensics analysts by modifying its processes’ EPROCESS data structures in kernel memory. You might remember from <span class="Xref"><a href="chapter1.xhtml">Chapter 1</a></span> that EPROCESS structures form a doubly linked list of processes running on the host. Some defense and analysis tools rely on these structures to monitor and inspect anomalous running processes.</p>&#13;
<p class="TX">To perform this type of DKOM technique, a malicious kernel-space module invokes a function such as <samp class="SANS_TheSansMonoCd_W5Regular_11">PsLookupProcessByProcessID</samp> to get a pointer to its own user-space component’s EPROCESS structure. Then, the malware can modify the <i>forward link (flink)</i> and <i>backward link (blink)</i> members of the EPROCESS structure, unlinking the structure from the EPROCESS chain. <a href="chapter14.xhtml#fig14-4">Figure 14-4</a> illustrates normal, unmodified EPROCESS structures before unlinking.</p>&#13;
<figure class="IMG"><img class="img70" id="fig14-4" src="../images/fig14-4.jpg" alt=""/>&#13;
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 14-4: Doubly linked EPROCESS structures before unlinking</samp></p></figcaption>&#13;
</figure>&#13;
<p class="TX">Notice how the EPROCESS structures are linked by their flink and blink members.</p>&#13;
<p class="TX"><a href="chapter14.xhtml#fig14-5">Figure 14-5</a> shows what happens when a rootkit tampers with the EPROCESS structures to unlink its malicious process (center).</p>&#13;
<figure class="IMG"><img class="img70" id="fig14-5" src="../images/fig14-5.jpg" alt=""/>&#13;
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 14-5: EPROCESS structures after unlinking</samp></p></figcaption>&#13;
</figure>&#13;
<p class="TX">Notice how both the flink and blink for the malicious process’s EPROCESS structure point back to it, effectively disconnecting this process from the normal EPROCESS chain.</p>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_274" aria-label="274"/>The following code is an abridged version of the HideProcess project (see <a href="https://github.com/landhb/HideProcess"><i>https://<wbr/>github<wbr/>.com<wbr/>/landhb<wbr/>/HideProcess</i></a>), and it demonstrates how the malware accomplishes the tasks outlined previously:</p>&#13;
<pre class="pre-124"><code>void remove_links(PLIST_ENTRY Current) {&#13;
&#13;
    PLIST_ENTRY Previous, Next;&#13;
  <span class="Code_CodeAnnotation" aria-label="annotation1">❶</span> Previous = (Current-&gt;Blink);&#13;
  <span class="Code_CodeAnnotation" aria-label="annotation2">❷</span> Next = (Current-&gt;Flink);&#13;
&#13;
    // Loop over self (connect previous with next).&#13;
    Previous-&gt;Flink = Next;&#13;
    Next-&gt;Blink = Previous;&#13;
&#13;
    // Rewrite the current LIST_ENTRY to point to itself.&#13;
  <span class="Code_CodeAnnotation" aria-label="annotation3">❸</span> Current-&gt;Blink = (PLIST_ENTRY)&amp;Current-&gt;Flink;&#13;
  <span class="Code_CodeAnnotation" aria-label="annotation4">❹</span> Current-&gt;Flink = (PLIST_ENTRY)&amp;Current-&gt;Flink;&#13;
<var>--snip--</var></code></pre>&#13;
<p class="TX">First, the code defines the variables <samp class="SANS_TheSansMonoCd_W5Regular_11">Previous</samp> (which stores the current process’s blink pointer) <span class="CodeAnnotation" aria-label="annotation1">❶</span> and <samp class="SANS_TheSansMonoCd_W5Regular_11">Next</samp> (which stores the current process’s flink pointer) <span class="CodeAnnotation" aria-label="annotation2">❷</span>. Later, the code rewrites these <samp class="SANS_TheSansMonoCd_W5Regular_11">LIST_ENTRY</samp> values to point to itself. The <samp class="SANS_TheSansMonoCd_W5Regular_11">Current-&gt;Blink</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">=</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">(PLIST_ENTRY)&amp;Current-&gt;Flink</samp> line sets the process’s current blink pointer to its flink pointer value <span class="CodeAnnotation" aria-label="annotation3">❸</span>. The <samp class="SANS_TheSansMonoCd_W5Regular_11">Current-&gt;Flink</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">=</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">(PLIST _ENTRY)&amp;Current-&gt;Flink</samp> line ensures that the process’s flink points to itself <span class="CodeAnnotation" aria-label="annotation4">❹</span>. In essence, this breaks the EPROCESS chain, hiding the process from process management tools (like Task Manager) and some forensics investigation toolsets, perhaps helping it better evade endpoint defenses.</p>&#13;
<p class="TX">DKOM isn’t limited to hiding processes, however. Using DKOM techniques, malware can theoretically alter any object in kernel memory. Malware has been known to use DKOM techniques to hide malicious network traffic or alter files in order to interfere with forensics investigations. DKOM can also be used to inject kernel hooks, as you’ll see in the next section.</p>&#13;
<p class="TX">While DKOM is one of the most basic and straightforward methods rootkits can use to hide or to alter the system, it’s not a golden ticket. DKOM and other kernel manipulation techniques can easily crash the operating system, potentially alerting the victim to the malware’s presence. Not only that, but security measures like PatchGuard also can create challenges for malware authors, as we’ll discuss later in the chapter.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec7">&#13;
&#13;
<h3 class="H1" id="sec7"><span id="h-236"/><samp class="SANS_Futura_Std_Bold_B_11">“Legacy” Kernel Hooking</samp></h3>&#13;
<p class="TNI1">Just like malware running in user space can use inline and IAT hooking to monitor, intercept, and manipulate function calls, kernel-space malware can use several types of hooks to launch its attacks. We’ll discuss some of the most prevalent, starting with the decades-old technique of SSDT hooking.</p>&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_275" aria-label="275"/>&#13;
<blockquote>&#13;
<p class="Note"><span class="NoteHead"><samp class="SANS_Dogma_OT_Bold_B_15">NOTE</samp></span></p>&#13;
</blockquote>&#13;
<p class="NOTE-TXT"><i>The techniques discussed in this section were at one time some of the most common ones used by both rootkits and endpoint defense products alike. Much like DKOM, however, they’re no longer popular thanks to the protections that Microsoft has implemented in modern versions of Windows. Still, it’s important to gain a basic understanding of them since you may occasionally witness malware using these or similar tactics, and it’ll also give you a better grasp of more modern rootkit techniques.</i></p>&#13;
<section epub:type="division" aria-labelledby="sec8">&#13;
&#13;
<h4 class="H2" id="sec8"><span id="h-237"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_I_11">SSDT Hooks</samp></h4>&#13;
<p class="TNI1">The <i>System Service Descriptor Table (SSDT)</i> or <i>Dispatch Table</i> contains an array of syscall IDs and their corresponding pointers to kernel functions. (These differ between 32- and 64-bit operating systems, but we won’t go into those specifics here.) As discussed in <span class="Xref"><a href="chapter1.xhtml">Chapters 1</a></span> and <span class="Xref"><a href="chapter13.xhtml">13</a></span>, when a user-space process invokes Windows API and NT API functions, the function eventually makes a syscall into the kernel to fulfill the request. Let’s look at an example using <samp class="SANS_TheSansMonoCd_W5Regular_11">NtReadFile</samp> to read a file on disk. Here’s the basic sequence of steps that must occur:</p>&#13;
<p class="ListNumber1">  1.  A program in user space invokes <samp class="SANS_TheSansMonoCd_W5Regular_11">NtReadFile</samp>. The program initiates a syscall, referencing the syscall ID that corresponds to the <samp class="SANS_TheSansMonoCd_W5Regular_11">NtReadFile</samp> function.</p>&#13;
<p class="ListNumber">  2.  The syscall triggers the processor to switch from user mode to kernel mode and passes the request and syscall ID to the syscall handler.</p>&#13;
<p class="ListNumber">  3.  The syscall handler consults the SSDT to obtain the address of the kernel <samp class="SANS_TheSansMonoCd_W5Regular_11">NtReadFile</samp> function (which is exported from <i>ntoskrnl.exe</i>) and then proceeds to execute the function.</p>&#13;
<p class="ListNumber">  4.  Since the <samp class="SANS_TheSansMonoCd_W5Regular_11">NtReadFile</samp> function is being invoked to read a file on disk, it must communicate with kernel drivers such as the disk driver stack. This is where the IO manager is engaged.</p>&#13;
<p class="ListNumber">  5.  The IO manager sends instructions in the form of <i>IO request packets (IRPs)</i> to the appropriate drivers, which will carry out <samp class="SANS_TheSansMonoCd_W5Regular_11">NtReadFile</samp>’s requested actions (such as reading the specific file on disk). I’ll discuss the IO manager and IRPs later in this chapter.</p>&#13;
<p class="ListNumber2">  6.  Once the drivers process the request, the result is sent back to the original calling program in user space.</p>&#13;
<p class="TX">Now that you have a basic understanding of how the SSDT is used, you can see how malware could insert a hook into it to redirect requests to malicious code. <a href="chapter14.xhtml#fig14-6">Figure 14-6</a> shows an example of this approach with the <samp class="SANS_TheSansMonoCd_W5Regular_11">NtReadFile</samp> function.</p>&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_276" aria-label="276"/>&#13;
<figure class="IMG"><img class="img70" id="fig14-6" src="../images/fig14-6.jpg" alt=""/>&#13;
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 14-6: An SSDT hook for NtReadFile</samp></p></figcaption>&#13;
</figure>&#13;
<p class="TX">The rootkit modifies the function pointer to <samp class="SANS_TheSansMonoCd_W5Regular_11">NtReadFile</samp> inside the SSDT, which redirects the request for <samp class="SANS_TheSansMonoCd_W5Regular_11">NtReadFile</samp> to the rootkit’s malicious kernel module. The rootkit then intercepts and modifies the call to <samp class="SANS_TheSansMonoCd_W5Regular_11">NtReadFile</samp>. Later, it can redirect the call to the original <samp class="SANS_TheSansMonoCd_W5Regular_11">NtReadFile</samp> function code inside <i>ntoskrnl.exe</i>.</p>&#13;
<p class="TX">There are many reasons why a malware author would use SSDT hooking. For example, they might implement an SSDT hook for <samp class="SANS_TheSansMonoCd_W5Regular_11">NtReadFile</samp> to prevent the malware’s own malicious files and code from being read by endpoint defenses and investigators. Another kernel-hooking technique, inline kernel hooks, is used for a similar reason.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec9">&#13;
&#13;
<h4 class="H2" id="sec9"><span id="h-238"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_I_11">Inline Kernel Hooks</samp></h4>&#13;
<p class="TNI1">Inline hooking is a malware technique employed not just in user space (as discussed in <span class="Xref"><a href="chapter12.xhtml">Chapter 12</a></span>) but in kernel functions as well. To install the hooks, a rootkit attempts to modify function code inside <i>ntoskrnl.exe</i>. Similar to the example just discussed with SSDT hooking, a rootkit could hook <samp class="SANS_TheSansMonoCd_W5Regular_11">NtReadFile</samp> by tampering with the function’s code to insert a jump instruction and redirect control flow to the malicious kernel module’s code, as illustrated in <a href="chapter14.xhtml#fig14-7">Figure 14-7</a>.</p>&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_277" aria-label="277"/>&#13;
<figure class="IMG"><img class="img70" id="fig14-7" src="../images/fig14-7.jpg" alt=""/>&#13;
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 14-7: An inline kernel hook for NtReadFile</samp></p></figcaption>&#13;
</figure>&#13;
<p class="TX">There are a number of ways a rootkit can write a hook into a target function. Similar to inline hooking in user space, the malware first must alter the memory protections of the target function’s code and then write a hook into it. The following pseudocode demonstrates how this might look:</p>&#13;
<pre class="pre-125"><code>// Set target memory to PAGE_READWRITE protection.&#13;
MmProtectMdlSystemAddress(mdl, "PAGE_READWRITE");&#13;
&#13;
// Write a hook (a jump instruction) into the target function.&#13;
RtlCopyMemory(targetAddress, sourceAddress, size);&#13;
&#13;
// Set the target memory back to original protections.&#13;
MmProtectMdlSystemAddress(mdl, "PAGE_READONLY");</code></pre>&#13;
<p class="TX"><samp class="SANS_TheSansMonoCd_W5Regular_11">MmProtectMdlSystemAddress</samp> is a kernel function that’s used to set the memory protection type for a <i>memory descriptor list (MDL)</i>, which is a structure containing a memory address range. This function has two parameters: a <samp class="SANS_TheSansMonoCd_W5Regular_11">MemoryDescriptorList</samp> (the memory address range that will be altered) and a protection constant (such as <samp class="SANS_TheSansMonoCd_W5Regular_11">PAGE_READWRITE</samp>, which would change the MDL’s protections to be writable).</p>&#13;
<p class="TX">Following this, the malware invokes a kernel function such as <samp class="SANS_TheSansMonoCd_W5Regular_11">RtlCopyMemory</samp> to overwrite the target code with a jump instruction, for instance. The primary parameters of <samp class="SANS_TheSansMonoCd_W5Regular_11">RtlCopyMemory</samp> are the destination address of the target memory region, the source address (which contains the jump instruction to be copied), and the size of the data being copied. Malware must be careful to set the target memory region back to its original protection setting because incorrect and anomalous protections (such <span role="doc-pagebreak" epub:type="pagebreak" id="pg_278" aria-label="278"/>as “writable”) may raise the suspicions of endpoint defenses or cause system instability.</p>&#13;
<p class="TX">Next, we’ll turn to IRP hooking, another type of kernel hook rootkits have been known to use.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec10">&#13;
&#13;
<h4 class="H2" id="sec10"><span id="h-239"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_I_11">IRP Hooks</samp></h4>&#13;
<p class="TNI1">When user-space programs need to communicate with kernel drivers, they do so via the IO manager. This communication is primarily accomplished with IO request packets (IRPs), which are objects comprising data structures that contain information about the request and actions to be performed. IRPs are passed between the calling program and kernel drivers, but they can also be used for communication between drivers. For example, a USB keyboard driver will need to communicate with the USB host controller driver, and the IO manager helps facilitate this. This relationship is illustrated in <a href="chapter14.xhtml#fig14-8">Figure 14-8</a>.</p>&#13;
<figure class="IMG"><img class="img70" id="fig14-8" src="../images/fig14-8.jpg" alt=""/>&#13;
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 14-8: How an IRP works</samp></p></figcaption>&#13;
</figure>&#13;
<p class="TX">This program invokes the <samp class="SANS_TheSansMonoCd_W5Regular_11">CreateFile</samp> function to open a handle to a file on disk. Eventually, the program makes a syscall into the kernel (<i>ntoskrnl.exe</i>). This is where the IO manager gets involved, sending an IRP to the filesystem driver that will handle this operation. In the final step (not pictured here), the driver sends the status of the operation back to the IO manager, which will return the status to the calling program.</p>&#13;
<p class="TX">Every IRP includes an <i>IRP code</i>, which tells the recipient driver what IRP handler should be used to handle the respective request. <a href="chapter14.xhtml#tab14-1">Table 14-1</a> lists some of the more interesting IRP function codes for our purposes.</p>&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_279" aria-label="279"/>&#13;
<p class="TT" id="tab14-1"><span class="Heavy"><samp class="SANS_Futura_Std_Heavy_B_11">Table 14-1:</samp></span> <samp class="SANS_Futura_Std_Book_11">IRP Codes</samp></p>&#13;
<table class="Basic-Table">&#13;
<thead>&#13;
<tr>&#13;
<th class="TCH" scope="col"><p class="TCH1"><samp class="SANS_Futura_Std_Heavy_B_11">IRP code</samp></p></th>&#13;
<th class="TCH" scope="col"><p class="TCH1"><samp class="SANS_Futura_Std_Heavy_B_11">Request description</samp></p></th>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr>&#13;
<td class="TBF"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">IRP_MJ_CREATE</samp></p></td>&#13;
<td class="TBF"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">Sent to a driver when the requesting thread opens a handle to a device or file object, such as when making a call to</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">NtCreateFile</samp></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TB"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">IRP_MJ_WRITE</samp></p></td>&#13;
<td class="TB"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">Sent to a driver when the requester wishes to transfer data, such as when writing data to a file</samp></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TB"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">IRP_MJ_READ</samp></p></td>&#13;
<td class="TB"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">Sent to a driver when the requester wishes to read data, such as from a file</samp></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TB"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">IRP_MJ_DEVICE_CONTROL</samp></p></td>&#13;
<td class="TB"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">Sent when a</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">DeviceIoControl</samp> <samp class="SANS_Futura_Std_Book_11">function is called (meaning a user-space process is sending a direct control code, or instruction, to a driver)</samp></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TB"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">IRP_MJ_SHUTDOWN</samp></p></td>&#13;
<td class="TB"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">Sent when a system shutdown has been initiated</samp></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TBL"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">IRP_MJ_SYSTEM_CONTROL</samp></p></td>&#13;
<td class="TBL"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">Sent when a user-space process requests system information via Windows Management Instrumentation (WMI)</samp></p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<p class="TX">Each driver installed in the kernel includes a table of IRP handlers called the <i>major function table</i> (or the <i>IRP function table</i>). Major function tables contain pointers to the handler code that will handle a particular IRP; this code might be located in the driver itself or inside another driver or module. The following output shows an IRP function table for the FLTMGR driver:</p>&#13;
<pre class="pre-126"><code>IRP_MJ_CREATE              0xfffff8023674ca20   FLTMGR.SYS&#13;
IRP_MJ_CREATE_NAMED_PIPE   0xfffff8023674ca20   FLTMGR.SYS&#13;
IRP_MJ_CLOSE               0xfffff80236713e60   FLTMGR.SYS&#13;
IRP_MJ_READ                0xfffff80236713e60   FLTMGR.SYS&#13;
IRP_MJ_WRITE               0xfffff80236713e60   FLTMGR.SYS&#13;
IRP_MJ_QUERY_INFORMATION   0xfffff80236713e60   FLTMGR.SYS&#13;
IRP_MJ_SET_INFORMATION     0xfffff80236713e60   FLTMGR.SYS&#13;
IRP_MJ_QUERY_EA            0xfffff80236713e60   FLTMGR.SYS&#13;
<var>--snip--</var></code></pre>&#13;
<p class="TX">This output was created with the help of Volatility, a memory forensics and analysis tool. Although not covered in this book, memory forensics techniques can be great additions to the malware analysis process, especially in the case of rootkits. For this specific example, I used the <samp class="SANS_TheSansMonoCd_W5Regular_11">driverirp</samp> module in Volatility.</p>&#13;
<p class="TX">The first column in this output contains the IRP code. The second and third columns contain the pointer to the associated IRP handler function and the module containing the handler code, respectively. In this case, the driver points to handlers it contains.</p>&#13;
<p class="TX">To intercept, modify, and gain control of IO communication, malicious kernel drivers might attempt to hook IRPs. One reason for doing so is to hide and protect the malware’s artifacts on the endpoint by intercepting IRP function calls that reference those artifacts on disk. The Autochk rootkit (<samp class="SANS_TheSansMonoCd_W5Regular_11">SHA256: 28924b6329f5410a5cca30f3530a3fb8a97c23c9509a192f2092cbdf139a91d8</samp>) does exactly this: it hooks <samp class="SANS_TheSansMonoCd_W5Regular_11">IRP_MJ_CREATE</samp> inside the FLTMGR driver to intercept IRPs referencing its malicious files on disk (as illustrated in <a href="chapter14.xhtml#fig14-9">Figure 14-9</a>).</p>&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_280" aria-label="280"/>&#13;
<figure class="IMG"><img class="img80" id="fig14-9" src="../images/fig14-9.jpg" alt=""/>&#13;
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 14-9: An IRP hook for NtReadFile</samp></p></figcaption>&#13;
</figure>&#13;
<p class="TX">If an application in user space, such as a forensics tool, attempts to access this rootkit’s files, the IRP will be handled by the rootkit’s handler code rather than by the legitimate handler that would otherwise deal with this request. The following Volatility output shows the hooked FLTMGR driver’s IRP function table:</p>&#13;
<pre class="pre-127"><code>0 IRP_MJ_CREATE             0xfffff80230bf1bc4   autochk.sys&#13;
1 IRP_MJ_CREATE_NAMED_PIPE  0xfffff8023674ca20   FLTMGR.SYS&#13;
2 IRP_MJ_CLOSE              0xfffff80236713e60   FLTMGR.SYS&#13;
3 IRP_MJ_READ               0xfffff80236713e60   FLTMGR.SYS&#13;
4 IRP_MJ_WRITE        	    0xfffff80236713e60   FLTMGR.SYS&#13;
5 IRP_MJ_QUERY_INFORMATION  0xfffff80236713e60   FLTMGR.SYS&#13;
6 IRP_MJ_SET_INFORMATION    0xfffff80236713e60   FLTMGR.SYS&#13;
7 IRP_MJ_QUERY_EA           0xfffff80236713e60   FLTMGR.SYS&#13;
<var>--snip--</var></code></pre>&#13;
<p class="TX">Notice anything shady? In the first row of the code, <samp class="SANS_TheSansMonoCd_W5Regular_11">FLTMGR.SYS</samp> has been replaced with <samp class="SANS_TheSansMonoCd_W5Regular_11">autochk.sys</samp>. All <samp class="SANS_TheSansMonoCd_W5Regular_11">MJ_CREATE</samp> IRPs destined for the FLTMGR driver will instead be forwarded to the malicious handler code inside the rootkit’s driver, <samp class="SANS_TheSansMonoCd_W5Regular_11">autochk.sys!</samp> You can read more about some of the techniques of this rootkit at <a href="https://repnz.github.io/posts/autochk-rootkit-analysis/"><i>https://<wbr/>repnz<wbr/>.github<wbr/>.io<wbr/>/posts<wbr/>/autochk<wbr/>-rootkit<wbr/>-analysis<wbr/>/</i></a>.</p>&#13;
<p class="TX">To install an IRP hook, malware authors have a few options. One approach is to replace the original handler code pointer value in a victim driver with a pointer to malicious handler code. Alternatively, malware could use the inline hooking method described previously to overwrite the first few bytes in the legitimate handler function with a jump instruction to malicious code.</p>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_281" aria-label="281"/>Both of these techniques, as well as the other hooking techniques mentioned, rely on the delicate task of manipulating kernel objects in memory. As noted earlier, however, the techniques discussed in this section aren’t often used in malware anymore due to the protections now built into Windows. With this in mind, let’s shift to some relatively modern techniques that rootkits might use to circumvent these Windows protections, starting with IRP filtering and interception.</p>&#13;
</section>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec11">&#13;
&#13;
<h3 class="H1" id="sec11"><span id="h-240"/><samp class="SANS_Futura_Std_Bold_B_11">IRP Interception by Filtering</samp></h3>&#13;
<p class="TNI1">Rather than crudely hooking kernel drivers to intercept and manipulate IRPs, rootkits can register a filter or minifilter driver to do so. Introduced at the beginning of this chapter, filter drivers and minifilter drivers can be “attached” to a device and added to its driver stack, intercepting IRPs as they are filtered down the stack. Let’s go over this process in more detail.</p>&#13;
<blockquote>&#13;
<p class="Note"><span class="NoteHead"><samp class="SANS_Dogma_OT_Bold_B_15">NOTE</samp></span></p>&#13;
</blockquote>&#13;
<p class="NOTE-TXT"><i>Filter drivers (sometimes called</i> <span class="note_Italic">legacy filter drivers</span><i>) and minifilter drivers are both types of filters, but they operate quite differently. I won’t go into the specifics of these two drivers in this book.</i></p>&#13;
<p class="TX">Each hardware device attached to the system has an associated hierarchical stack of drivers that enables communication between the device and the operating system (see <a href="chapter14.xhtml#fig14-10">Figure 14-10</a>).</p>&#13;
<figure class="IMG"><img class="img100" id="fig14-10" src="../images/fig14-10.jpg" alt=""/>&#13;
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 14-10: How the IO manager communicates with driver stacks</samp></p></figcaption>&#13;
</figure>&#13;
<p class="TX">Each driver in the stack performs a specific role and serves as an interface between the drivers before and after it in the stack. Additionally, when the IO manager sends an IRP to a specific device, the IRP is routed through the device’s hierarchical driver stack, passing through each driver in the <span role="doc-pagebreak" epub:type="pagebreak" id="pg_282" aria-label="282"/>stack one by one. If one of the drivers has a handler for the specific IRP, it takes some sort of action on that IRP. The arrows shown in <a href="chapter14.xhtml#fig14-10">Figure 14-10</a> represent communication between drivers in the form of IRPs.</p>&#13;
<p class="TX">Filter drivers are designed to be inserted into a driver stack to add functionality. They can be inserted in various locations (called <i>altitudes</i>) in the stack or even added all the way to the top of the stack, where they can intercept any and all IRPs destined for the driver stack (see <a href="chapter14.xhtml#fig14-11">Figure 14-11</a>).</p>&#13;
<figure class="IMG"><img class="img70" id="fig14-11" src="../images/fig14-11.jpg" alt=""/>&#13;
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 14-11: A filter driver added to the top of the driver stack</samp></p></figcaption>&#13;
</figure>&#13;
<p class="TX">Rootkits can register a new filter driver and “insert” it at the top of a driver stack, allowing them to see and intercept all inbound IRPs. After intercepting, the malware can choose to drop the IRP or modify it. A rootkit might use a filter driver this way to protect its own files. For example, it could register a filter driver to watch for and intercept IO requests to its own files, either modifying the requests or dropping them completely to effectively hide them from investigators and analysis tools. EDR and other endpoint defenses sometimes use filter drivers for the same reason: to protect their files from malware.</p>&#13;
<p class="TX">To implement a filter driver, a rootkit must first load the driver into kernel memory (potentially using the techniques from “<span class="Xref">Rootkit Installation</span>” on <span class="Xref"><a href="chapter14.xhtml#pg_269">page 269</a></span>). The filter driver must specify which IRP communication it cares about by setting up a handler for those IRPs. For instance, if the malware is trying to intercept <samp class="SANS_TheSansMonoCd_W5Regular_11">MJ_CREATE</samp> IRPs, it must implement this in the filter driver’s IRP function table.</p>&#13;
<p class="TX">Malware can abuse minifilter drivers by registering one of its own (by calling <samp class="SANS_TheSansMonoCd_W5Regular_11">FltRegisterFilter</samp>) or by hooking an existing minifilter. Some modern malware has been known to do this. When analyzing rootkit <span role="doc-pagebreak" epub:type="pagebreak" id="pg_283" aria-label="283"/>driver code, take note of whether the malware is calling <samp class="SANS_TheSansMonoCd_W5Regular_11">FltRegisterFilter</samp> to register its own minifilter driver. Also notice whether the malware is calling functions such as <samp class="SANS_TheSansMonoCd_W5Regular_11">FltGetFilterFromName</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">FltEnumerateFilters</samp>, or <samp class="SANS_TheSansMonoCd_W5Regular_11">FltEnumerateInstances</samp>; it may be attempting to enumerate other minifilters on the host, preparing for hooking. For more information on how minifilter drivers are implemented in practice, see Rahul Dev Tripathi’s article “Storage Device Restriction Using a Minifilter Driver Approach” at <a href="https://www.codeproject.com/Articles/5341729/Storage-Device-Restriction-Using-a-Minifilter-Driv"><i>https://<wbr/>www<wbr/>.codeproject<wbr/>.com<wbr/>/Articles<wbr/>/5341729<wbr/>/Storage<wbr/>-Device<wbr/>-Restriction<wbr/>-Using<wbr/>-a<wbr/>-Minifilter<wbr/>-Driv<wbr/></i></a>.</p>&#13;
<p class="TX">Legacy filter drivers are installed differently. The specifics are outside the scope of this book, but you can learn more from the filesystem driver tutorial at <a href="https://www.codeproject.com/Articles/43586/File-System-Filter-Driver-Tutorial"><i>https://<wbr/>www<wbr/>.codeproject<wbr/>.com<wbr/>/Articles<wbr/>/43586<wbr/>/File<wbr/>-System<wbr/>-Filter<wbr/>-Driver<wbr/>-Tutorial</i></a> and from Rotem Salinas’s great write-up “Fantastic Rootkits and Where to Find Them” at <a href="https://www.cyberark.com/resources/threat-research-blog/fantastic-rootkits-and-where-to-find-them-part-1"><i>https://<wbr/>www<wbr/>.cyberark<wbr/>.com<wbr/>/resources<wbr/>/threat<wbr/>-research<wbr/>-blog<wbr/>/fantastic<wbr/>-rootkits<wbr/>-and<wbr/>-where<wbr/>-to<wbr/>-find<wbr/>-them<wbr/>-part<wbr/>-1</i></a>.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec12">&#13;
&#13;
<h3 class="H1" id="sec12"><span id="h-241"/><samp class="SANS_Futura_Std_Bold_B_11">Abusing Kernel Callbacks</samp></h3>&#13;
<p class="TNI1">Abusing kernel callbacks is another more modern approach used by some rootkits. To recap the discussion in <span class="Xref"><a href="chapter13.xhtml">Chapter 13</a></span>, a callback allows a kernel module to be notified of system events so that it can take some sort of action when they happen. For example, a driver may need to know when a process executed in user space, so it would implement the <samp class="SANS_TheSansMonoCd_W5Regular_11">PsSetCreateProcessNotifyRoutine</samp> callback (as in the case of some EDR products). Once this callback is registered with the driver, the driver will receive a notification in the form of an IRP when a process is created on the system, giving the driver the chance to execute its callback code for that event.</p>&#13;
<p class="TX">The creator of the process is responsible for sending out a notification to all registered drivers. So, when a process spawns a child process, for example, the calling process sends out the <samp class="SANS_TheSansMonoCd_W5Regular_11">CreateProcessNotifyRoutine</samp> notification to all registered drivers. When a driver receives the notification, the driver’s callback code will be executed.</p>&#13;
<p class="TX">A rootkit can also use callbacks if it wants to be notified of specific system events. Once an event occurs, such as a registry modification or filesystem operation, the rootkit’s malicious driver(s) will be notified, and the callback code will be executed. The following output shows a listing of registered callback routines on an infected system:</p>&#13;
<pre class="pre-128"><code>Type                               Callback            Module&#13;
--------------------------------------------------------------------&#13;
IoRegisterShutdownNotification     0xfffff8033891e830  ntoskrnl.exe&#13;
IoRegisterShutdownNotification     0xfffff8033b6b10c0  SgrmAgent.sys&#13;
IoRegisterShutdownNotification     0xfffff803390cf320  ntoskrnl.exe&#13;
<var>--snip--</var>&#13;
PsRemoveLoadImageNotifyRoutine     0xfffff80af3afb210  ahcache.sys&#13;
PsRemoveCreateThreadNotifyRoutine  0xfffff80336bd1060  mmcss.sys&#13;
<b>PsSetCreateThreadNotifyRoutine     0xfffff6050d26ccc0  comp.sys</b>&#13;
KeBugCheckCallbackListHead         0xfffff8033c13cb90  ndis.sys&#13;
KeBugCheckCallbackListHead         0xfffff8033c59b4e0  fvevol.sys&#13;
<var>--snip--</var></code></pre>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_284" aria-label="284"/>In this output, the <samp class="SANS_TheSansMonoCd_W5Regular_11">Type</samp> column shows the callback type, the <samp class="SANS_TheSansMonoCd_W5Regular_11">Callback</samp> column shows the address of the callback handler, and the <samp class="SANS_TheSansMonoCd_W5Regular_11">Module</samp> column shows the kernel module that registered the callback. Most of these are normal, legitimate callbacks. However, there’s a suspicious module name (<samp class="SANS_TheSansMonoCd_W5Regular_11">comp.sys</samp>) that appears to have registered an interesting callback (<samp class="SANS_TheSansMonoCd_W5Regular_11">PsSetCreateThreadNotifyRoutine</samp>). As mentioned previously, this callback will trigger when a new thread is created by a process in user space. Also note that the address of the callback code is much different from those of the legitimate callbacks (<samp class="SANS_TheSansMonoCd_W5Regular_11">0xfffff6050d26ccc0</samp> versus <samp class="SANS_TheSansMonoCd_W5Regular_11">0xfffff80af3afb210</samp>, for example).</p>&#13;
<p class="TX">A similar approach was taken by the DirtyMoe rootkit. DirtyMoe used kernel callbacks to silently inject malicious code into newly created threads in user space. You can read more about it in Martin Chlumeck<span class="accent">ý</span>’s article “DirtyMoe: Rootkit Driver” at <a href="https://decoded.avast.io/martinchlumecky/dirtymoe-rootkit-driver/"><i>https://<wbr/>decoded<wbr/>.avast<wbr/>.io<wbr/>/martinchlumecky<wbr/>/dirtymoe<wbr/>-rootkit<wbr/>-driver<wbr/>/</i></a>.</p>&#13;
<p class="TX">The infamous Necurs rootkit, which originated in 2014, sets up a registry callback (<samp class="SANS_TheSansMonoCd_W5Regular_11">CmRegisterCallback</samp>), a type of filter driver callback that will notify it of any access to its registry service key. If an investigator or program attempts to access this registry key, the attempt fails. This simplified pseudocode example shows how a malicious driver could register and abuse a registry callback:</p>&#13;
<pre class="pre-129"><code><span class="CodeAnnotationHang">1</span> void RegistryCallback(..., ..., context)&#13;
{&#13;
  if (context)&#13;
  {&#13;
   <span class="Code_CodeAnnotation" aria-label="annotation2">❷</span> if (event == CM_EVENT_REGISTRY_KEY_OPEN)&#13;
    {&#13;
     <span class="Code_CodeAnnotation" aria-label="annotation3">❸</span> if (context-&gt;registryKey == "HKEY_CURRENT_USER\Software\Microsoft\&#13;
Windows\CurrentVersion\evil")&#13;
      {&#13;
     <span class="Code_CodeAnnotation" aria-label="annotation4">❹</span> // Block the action.&#13;
      }&#13;
    }&#13;
  }&#13;
}&#13;
&#13;
<span class="CodeAnnotationHang">5</span> CmRegisterCallback(RegistryCallback, &amp;context);</code></pre>&#13;
<p class="TX">This malware code first defines the callback function code (<samp class="SANS_TheSansMonoCd_W5Regular_11">RegistryCallback</samp>) that will be executed once the callback occurs <span class="CodeAnnotation" aria-label="annotation1">❶</span>. Later in the code, the rootkit defines the registry callback, passing the callback name (<samp class="SANS_TheSansMonoCd_W5Regular_11">RegistryCallback</samp>) and also the context, which is a pointer to a structure containing information about the function call <span class="CodeAnnotation" aria-label="annotation5">❺</span>. Since this callback will be triggered by programs interacting with the Windows registry, this context structure contains important information like the particular registry action (open key, write data, and so on) and the target of the action (or the specific registry key or value affected).</p>&#13;
<p class="TX">When a program performs a registry action, such as invoking <samp class="SANS_TheSansMonoCd_W5Regular_11">RegOpenKeyExA</samp>, the rootkit’s malicious callback code will be executed. The rootkit <span role="doc-pagebreak" epub:type="pagebreak" id="pg_285" aria-label="285"/>checks to see if the registry event is equal to <samp class="SANS_TheSansMonoCd_W5Regular_11">CM_EVENT_REGISTRY_KEY_OPEN</samp> (indicating that a registry key is being opened) <span class="CodeAnnotation" aria-label="annotation2">❷</span> and then checks to see whether the registry key being acted upon is <samp class="SANS_TheSansMonoCd_W5Regular_11">HKEY_CURRENT_USER\Software\Microsoft\Windows\CurrentVersion\evil</samp> (the key used by the malware to establish persistence on the host) <span class="CodeAnnotation" aria-label="annotation3">❸</span>. If the key name matches, the rootkit attempts to prevent the program or investigator from inspecting that registry key <span class="CodeAnnotation" aria-label="annotation4">❹</span>. It can do so by temporarily deleting its own registry key and re-creating it later, or by injecting malicious code into the calling process and hooking into the function call to prevent the call from succeeding, among other methods.</p>&#13;
<blockquote>&#13;
<p class="Note"><span class="NoteHead"><samp class="SANS_Dogma_OT_Bold_B_15">NOTE</samp></span></p>&#13;
</blockquote>&#13;
<p class="NOTE-TXT"><i><samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">CmRegisterCallback</samp> is now obsolete; the modern version of this function is <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">CmRegisterCallbackEx</samp>. The principles of the function remain the same, however.</i></p>&#13;
<p class="TX">You’ve seen quite a bit about how rootkits operate at a very low level in the operating system to manipulate kernel memory, install hooks, and configure callbacks, allowing them to remain hidden and evade defenses. Now we’ll look briefly at a variant of malware that delves even deeper: bootkits.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec13">&#13;
&#13;
<h3 class="H1" id="sec13"><span id="h-242"/><samp class="SANS_Futura_Std_Bold_B_11">Bootkits</samp></h3>&#13;
<p class="TNI1">A <i>bootkit</i> is a piece of malware designed to hide inside the system firmware, compromising the entire boot process. If a bootkit is able to tamper with the operating system boot-up, injecting itself into this process chain, it can effectively achieve all the benefits of a rootkit while also surviving system rebuilds.</p>&#13;
<p class="TX">One specific type of bootkit is a UEFI bootkit (sometimes called a UEFI rootkit), which operates within the <i>Unified Extensible Firmware Interface (UEFI)</i>, a specialized storage chip attached to a system’s motherboard. The UEFI contains low-level software that executes before the operating system boots up, providing an interface between the operating system kernel and the various firmware devices installed in the system. Given that the UEFI boots before the operating system, malware that can embed itself within the UEFI chip will remain undetected for longer periods of time and can even survive operating system reinstallations and rebuilds.</p>&#13;
<p class="TX">One notable example of a UEFI bootkit is CosmicStrand. In July 2022, researchers from Kaspersky reported that this UEFI bootkit dug itself into systems, with the entry vector possibly being a hardware vulnerability. The bootkit affected various systems with certain models of Asus and Gigabyte motherboards and took control of the Windows operating system kernel loader, injecting malicious code into kernel memory. For more about this threat, see the article “CosmicStrand: The Discovery of a Sophisticated UEFI Firmware Rootkit,” from Kaspersky’s Global Research &amp; Analysis Team (GreAT) at <a href="https://securelist.com/cosmicstrand-uefi-firmware-rootkit/106973/"><i>https://<wbr/>securelist<wbr/>.com<wbr/>/cosmicstrand<wbr/>-uefi<wbr/>-firmware<wbr/>-rootkit<wbr/>/106973<wbr/>/</i></a>.</p>&#13;
<p class="TX">Another example is the MosaicRegressor framework, which was also discovered by Kaspersky. It included a UEFI rootkit component that <span role="doc-pagebreak" epub:type="pagebreak" id="pg_286" aria-label="286"/>hijacked the Windows boot process to drop an executable to disk that silently executes when Windows boots up. If this executable is removed from the disk, it will be rewritten to disk upon reboot of the system, providing a high degree of persistence. You can read the article from Kaspersky about MosaicRegressor, “Lurking in the Shadows of UEFI,” by Mark Lechtik, Igor Kuznetsov, and Yury Parshin, at <a href="https://securelist.com/mosaicregressor/98849/"><i>https://<wbr/>securelist<wbr/>.com<wbr/>/mosaicregressor<wbr/>/98849<wbr/>/</i></a>.</p>&#13;
<p class="TX">Compared with traditional user-space malware, bootkits are relatively rare. However, they might not be as rare as they’re perceived to be. Because of their low-level access to the host, they can survive and persist undetected even in well-defended environments. If we can’t detect this type of malware, we don’t know it exists, which leads us to the unsettling conclusion that this type of malware could be embedded in more systems than we know. However, all is not lost. Let’s wrap up this chapter by discussing some of the built-in Windows defenses against rootkits and bootkits.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec14">&#13;
&#13;
<h3 class="H1" id="sec14"><span id="h-243"/><samp class="SANS_Futura_Std_Bold_B_11">Defenses Against Rootkits</samp></h3>&#13;
<p class="TNI1">Microsoft has implemented several defenses against rootkits, two of the most important being <i>PatchGuard</i> and <i>Driver Signature Enforcement (DSE)</i>. Introduced in 2005 for x64 versions of Windows XP, PatchGuard, which is also known as <i>Kernel Patch Protection (KPP)</i>, mitigates many of the rootkit techniques described earlier, such as SSDT and IDT hooking and many forms of DKOM. PatchGuard works by periodically verifying the integrity of kernel memory structures to test whether they’ve been modified. If PatchGuard detects that one of these structures has been modified, it forces a crash of the kernel, which has the result shown in <a href="chapter14.xhtml#fig14-12">Figure 14-12</a>.</p>&#13;
<figure class="IMG"><img class="img70" id="fig14-12" src="../images/fig14-12.jpg" alt=""/>&#13;
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 14-12: A kernel security check crash caused by PatchGuard</samp></p></figcaption>&#13;
</figure>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_287" aria-label="287"/>PatchGuard isn’t impervious to circumvention, however. Since it scans kernel memory periodically, if these checks are timed properly, malware could very quickly tamper with kernel memory and then revert to a “clean” state before PatchGuard executes its integrity check. To initiate this check, the operating system calls the <samp class="SANS_TheSansMonoCd_W5Regular_11">KeBugCheckEx</samp> kernel API function, which certain malware has been known to hook to prevent the kernel integrity check from successfully executing. There have also been several issues with malware exploiting PatchGuard and other related components. One example of such malware is GhostHook, which exploited a vulnerability in the way Windows implements a certain low-level Intel API called Intel Processor Trace, potentially allowing malware to fly under PatchGuard’s radar. This attack technique is quite complex, so we won’t go into the details here, but you can read more about it in Kasif Dekel’s post, “GhostHook—Bypassing PatchGuard with Processor Trace Based Hooking,” at <a href="https://www.cyberark.com/resources/threat-research-blog/ghosthook-bypassing-patchguard-with-processor-trace-based-hooking"><i>https://<wbr/>www<wbr/>.cyberark<wbr/>.com<wbr/>/resources<wbr/>/threat<wbr/>-research<wbr/>-blog<wbr/>/ghosthook<wbr/>-bypassing<wbr/>-patchguard<wbr/>-with<wbr/>-processor<wbr/>-trace<wbr/>-based<wbr/>-hooking</i></a>.</p>&#13;
<p class="TX">Two other relatively recent examples of malware that evade PatchGuard are InfinityHook (<a href="https://github.com/everdox/InfinityHook"><i>https://<wbr/>github<wbr/>.com<wbr/>/everdox<wbr/>/InfinityHook</i></a>), which abuses a kernel API called <samp class="SANS_TheSansMonoCd_W5Regular_11">NtTraceEvent</samp>, and ByePg (<a href="https://github.com/can1357/ByePg"><i>https://<wbr/>github<wbr/>.com<wbr/>/can1357<wbr/>/ByePg</i></a>), which hijacks a kernel structure called the <samp class="SANS_TheSansMonoCd_W5Regular_11">HalPrivateDispatchTable</samp>. Both of these circumvent PatchGuard in different ways. Note, however, that Microsoft has been quick to patch some of these known vulnerabilities in PatchGuard, forcing malware authors to adapt.</p>&#13;
<p class="TX">As mentioned at the beginning of this section, another security control Microsoft has implemented is Driver Signature Enforcement (DSE), sometimes called <i>digital signature enforcement</i>, which has been released for Windows Vista (x64) and more recent versions. DSE ensures that only pre-verified (signed) drivers are allowed to be loaded into kernel memory. In theory, legitimate drivers will be permitted, while suspicious, unsigned drivers will be prevented from loading. You read earlier in the chapter how malware can circumvent this control by using a malicious kernel driver signed with a legitimate certificate or by using BYOVD techniques. Microsoft recommends dealing with this problem by using <i>blocklists</i> of known vulnerable drivers. If a driver is reported to be vulnerable or is actively being misused, Microsoft adds it to the blocklist, which prevents it from being installed later. You can enforce this feature by enabling the “Microsoft Vulnerable Driver Blocklist” security option in later versions of Windows. The primary concerns with this control are that some legitimate drivers may be prevented from loading and that it protects only against known malicious drivers.</p>&#13;
<p class="TX">Finally, <i>early launch anti-malware (ELAM)</i> is a feature of some endpoint defense software that protects the Windows boot process. ELAM is responsible for loading anti-malware kernel components prior to other third-party components. This ensures that the anti-malware is properly loaded and running before rootkits or any other persistent malware have the opportunity to load and execute. ELAM can be a good defense against rootkits. However, as ELAM drivers aren’t loaded until later stages in the boot process, ELAM alone might not prevent loading of bootkits.</p>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_288" aria-label="288"/>For defense against bootkits and UEFI rootkits, you can enable <i>Secure Boot</i>. Available on most modern hardware, Secure Boot prevents malicious code from hijacking the Windows boot process. Upon boot-up, Secure Boot verifies the integrity of UEFI firmware drivers and the operating system itself before allowing the system to fully boot. This provides a layer of protection in the event malware has embedded itself in a UEFI chip. Secure Boot is optional in most versions of Windows, but it’s required in Windows 11. As with all security controls, however, various implementations of Secure Boot have vulnerabilities that could be exploited by malware. Researchers from Eclypsium (<a href="https://eclypsium.com"><i>https://<wbr/>eclypsium<wbr/>.com</i></a>) reported on some of these vulnerabilities in 2020 and 2022, for example.</p>&#13;
<p class="TX">As a final note, many Windows rootkit protections, such as PatchGuard and DSE, are for x64 (64-bit) versions of Windows only. This leaves x86 (32-bit) versions of Windows potentially exposed to a host of dangerous low-level malware. Fortunately, precisely because these security features aren’t enabled in x86 mode, EDR and anti-malware can use these same techniques for good, to monitor and protect the endpoint.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec15">&#13;
&#13;
<h3 class="H1" id="sec15"><span id="h-244"/><samp class="SANS_Futura_Std_Bold_B_11">Summary</samp></h3>&#13;
<p class="TNI1">This chapter covered the fundamentals of rootkits: how kernel modules work, how malware installs malicious modules, and how threat actors bypass protections such as signed driver enforcement. We discussed some common rootkit techniques such as DKOM, kernel hooking, IRP interception, and kernel callback abuse. You were introduced to bootkits and also saw how kernel-space malware can bypass built-in Windows protection mechanisms like PatchGuard. This chapter has only scratched the surface of rootkits and kernel manipulation techniques, however, so if you’re interested in learning more, I encourage you to review <span class="Xref"><a href="appendix-C.xhtml">Appendix C</a></span> for more resources. In the next chapter, we’ll discuss how modern malware evades endpoint defenses and investigators by leveraging “fileless” and anti- forensics techniques.</p>&#13;
</section>&#13;
</section>&#13;
</body></html>