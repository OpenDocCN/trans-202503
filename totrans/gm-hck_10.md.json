["```\nDWORD __cdecl someFunction(int times, const char* string);\n```", "```\nPUSH DWORD PTR:[ESP+0x4] // get second arg from stack\nPUSH times \nCALL someFunction \nADD ESP, 0x8 \nRETN\n```", "```\nPUSH DWORD PTR:[ESP+0x4] // get second arg from stack\nPUSH times \nMOV EAX, someFunction\nCALL EAX \nADD ESP, 0x8 \nRETN\n```", "```\n BYTE codeCave[20] = {\n    0xFF, 0x74, 0x24, 0x04,       // PUSH DWORD PTR:[ESP+0x4]\n    0x68, 0x00, 0x00, 0x00, 0x00, // PUSH 0\n    0xB8, 0x00, 0x00, 0x00, 0x00, // MOV EAX, 0x0\n    0xFF, 0xD0,                   // CALL EAX\n    0x83, 0xC4, 0x08,             // ADD ESP, 0x08\n    0xC3                          // RETN\n};\n```", "```\nmemcpy(&codeCave[5], &times, 4);\nmemcpy(&codeCave[10], &addressOfSomeFunc, 4);\n```", "```\n   int stringlen = strlen(string) + 1; // +1 to include null terminator\n   int cavelen = sizeof(codeCave);\n➊ int fulllen = stringlen + cavelen;\n   auto remoteString = // allocate the memory with EXECUTE rights\n➋      VirtualAllocEx(process, 0, fulllen, MEM_COMMIT, PAGE_EXECUTE);\n\n   auto remoteCave = // keep a note of where the code cave will go\n➌      (LPVOID)((DWORD)remoteString + stringlen);\n\n   // write the string first\n➍ WriteProcessMemory(process, remoteString, string, stringlen, NULL);\n\n   // write the code cave next\n➎ WriteProcessMemory(process, remoteCave, codeCave, cavelen, NULL);\n```", "```\nHANDLE thread = CreateRemoteThread(process, NULL, NULL,\n                    (LPTHREAD_START_ROUTINE)remoteCave,\n                    remoteString, NULL, NULL);\n WaitForSingleObject(thread, INFINITE);\nCloseHandle(thread);\nVirtualFreeEx(process, remoteString, fulllen, MEM_RELEASE)\n```", "```\nPUSHAD // push general registers to the stack\nPUSHFD // push EFLAGS to the stack\n // shellcode should be here\n\nPOPFD // pop EFLAGS from the stack\nPOPAD // pop general registers to the stack\n\n// resume the thread without using registers here\n```", "```\nPUSH string\nPUSH times \nMOV EAX, someFunction\nCALL EAX \nADD ESP, 0x8\n```", "```\nPUSH originalEIP\nRETN\n```", "```\n//save state\nPUSHAD           // push general registers to the stack\nPUSHFD           // push EFLAGS to the stack\n // do work with shellcode\nPUSH string \nPUSH times \nMOV EAX, someFunction\nCALL EAX \nADD ESP, 0x8\n\n// restore state\nPOPFD            // pop EFLAGS from the stack\nPOPAD            // pop general registers to the stack\n\n// un-hijack: resume the thread without using registers\nPUSH originalEIP \nRETN\n```", "```\nBYTE codeCave[31] = {\n    0x60,                         // PUSHAD\n    0x9C,                         // PUSHFD\n    0x68, 0x00, 0x00, 0x00, 0x00, // PUSH 0\n    0x68, 0x00, 0x00, 0x00, 0x00, // PUSH 0\n    0xB8, 0x00, 0x00, 0x00, 0x00, // MOV EAX, 0x0\n    0xFF, 0xD0,                   // CALL EAX\n    0x83, 0xC4, 0x08,             // ADD ESP, 0x08\n    0x9D,                         // POPFD\n    0x61,                         // POPAD\n    0x68, 0x00, 0x00, 0x00, 0x00, // PUSH 0\n    0xC3                          // RETN\n};\n\n// we'll need to add some code here to place\n// the thread's EIP into threadContext.Eip\n\nmemcpy(&codeCave[3], &remoteString, 4);\nmemcpy(&codeCave[8], &times, 4);\nmemcpy(&codeCave[13], &func, 4);\nmemcpy(&codeCave[25], &threadContext.Eip, 4);\n```", "```\nint stringlen = strlen(string) + 1;\nint cavelen = sizeof(codeCave);\nint fulllen = stringlen + cavelen;\n\nauto remoteString =\n    VirtualAllocEx(process, 0, fulllen, MEM_COMMIT, PAGE_EXECUTE);\nauto remoteCave =\n    (LPVOID)((DWORD)remoteString + stringlen);\n```", "```\nDWORD GetProcessThreadID(HANDLE Process) {\n    THREADENTRY32 entry;\n    entry.dwSize = sizeof(THREADENTRY32);\n    HANDLE snapshot = CreateToolhelp32Snapshot(TH32CS_SNAPTHREAD, 0);\n\n    if (Thread32First(snapshot, &entry) == TRUE) {\n        DWORD PID = GetProcessId(Process);\n        while (Thread32Next(snapshot, &entry) == TRUE) {\n            if (entry.th32OwnerProcessID == PID) {\n                CloseHandle(snapshot);\n                return entry.th32ThreadID;\n            }\n        }\n    }\n    CloseHandle(snapshot);\n    return NULL;\n}\n```", "```\nHANDLE thread = OpenThread(\n    (THREAD_GET_CONTEXT | THREAD_SUSPEND_RESUME | THREAD_SET_CONTEXT),\n    false, threadID);\nSuspendThread(thread);\n CONTEXT threadContext;\nthreadContext.ContextFlags = CONTEXT_CONTROL;\nGetThreadContext(thread, &threadContext);\n```", "```\nWriteProcessMemory(process, remoteString, string, stringlen, NULL);\nWriteProcessMemory(process, remoteCave, codeCave, cavelen, NULL);\n```", "```\nthreadContext.Eip = (DWORD)remoteCave;\nthreadContext.ContextFlags = CONTEXT_CONTROL;\nSetThreadContext(thread, &threadContext);\nResumeThread(thread);\n```", "```\n// write the dll name to memory\nwchar_t* dllName = \"c:\\\\something.dll\";\nint namelen = wcslen(dllName) + 1;\nLPVOID remoteString =\n    VirtualAllocEx(process, NULL, namelen * 2, MEM_COMMIT, PAGE_EXECUTE);\nWriteProcessMemory(process, remoteString, dllName, namelen * 2, NULL);\n\n// get the address of LoadLibraryW()\nHMODULE k32 = GetModuleHandleA(\"kernel32.dll\");\nLPVOID funcAdr = GetProcAddress(k32, \"LoadLibraryW\");\n\n// create a thread to call LoadLibraryW(dllName)\nHANDLE thread =\n    CreateRemoteThread(process, NULL, NULL,\n        (LPTHREAD_START_ROUTINE)funcAdr,\n        remoteString, NULL, NULL);\n\n// let the thread finish and clean up\nWaitForSingleObject(thread, INFINITE);\nCloseHandle(thread);\n```", "```\nBOOL APIENTRY DllMain(HMODULE hModule,\n                      DWORD ul_reason_for_call,\n                      LPVOID lpReserved) {\n    switch (ul_reason_for_call) {\n        case DLL_PROCESS_ATTACH:\n            printf(\"DLL attached!\\n\");\n            break;\n        case DLL_PROCESS_DETACH:\n            printf(\"DLL detached!\\n\");\n            break;\n    }\n    return TRUE;\n}\n```", "```\nDWORD WINAPI runBot(LPVOID lpParam) {\n    // run your bot\n    return 1;\n}\n\n// do this from DllMain() for case DLL_PROCESS_ATTACH\nauto thread = CreateThread(NULL, 0, &runBot, NULL, 0, NULL);\nCloseHandle(thread);\n```", "```\nDWORD value = *((DWORD*)adr); // read a DWORD from adr\n*((DWORD*)adr) = 1234;        // write 1234 to DWORD adr\n```", "```\ntemplate<typename T>\nT readMemory(LPVOID adr) {\n    return *((T*)adr);\n}\n\ntemplate<typename T>\nvoid writeMemory(LPVOID adr, T val) {\n    *((T*)adr) = val;\n}\n```", "```\nDWORD value = readMemory<DWORD>(adr); // read\nwriteMemory<DWORD>(adr, value++);     // increment and write\n```", "```\ntemplate<typename T>\nT* pointMemory(LPVOID adr) {\n    return ((T*)adr);\n}\n```", "```\nDWORD* pValue = pointMemory<DWORD>(adr); // point\nDWORD value = *pValue;                   // 'read'\n(*pValue)++;                             // increment and 'write'\n```", "```\nDWORD newBase = (DWORD)GetModuleHandle(NULL);\n```", "```\nDWORD newBase;\n__asm {\n    MOV EAX, DWORD PTR FS:[0x30]\n    MOV EAX, DWORD PTR DS:[EAX+0x8]\n    MOV newBase, EAX\n}\n```"]