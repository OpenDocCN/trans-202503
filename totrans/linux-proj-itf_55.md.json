["```\n#include <sys/file.h>\n\nint `flock`(int *fd*, int *operation*);\n```", "```\n`filelock/t_flock.c`\n#include <sys/file.h>\n#include <fcntl.h>\n#include \"curr_time.h\"                  /* Declaration of currTime() */\n#include \"tlpi_hdr.h\"\n\nint\nmain(int argc, char *argv[])\n{\n    int fd, lock;\n    const char *lname;\n\n    if (argc < 3 || strcmp(argv[1], \"--help\") == 0 ||\n            strchr(\"sx\", argv[2][0]) == NULL)\n        usageErr(\"%s file lock [sleep-time]\\n\"\n                 \"    'lock' is 's' (shared) or 'x' (exclusive)\\n\"\n                 \"        optionally followed by 'n' (nonblocking)\\n\"\n                 \"    'secs' specifies time to hold lock\\n\", argv[0]);\n\n    lock = (argv[2][0] == 's') ? LOCK_SH : LOCK_EX;\n    if (argv[2][1] == 'n')\n        lock |= LOCK_NB;\n\n    fd = open(argv[1], O_RDONLY);               /* Open file to be locked */\n    if (fd == -1)\n        errExit(\"open\");\n\n    lname = (lock & LOCK_SH) ? \"LOCK_SH\" : \"LOCK_EX\";\n\n    printf(\"PID %ld: requesting %s at %s\\n\", (long) getpid(), lname,\n            currTime(\"%T\"));\n\n    if (flock(fd, lock) == -1) {\n        if (errno == EWOULDBLOCK)\n            fatal(\"PID %ld: already locked - bye!\", (long) getpid());\n        else\n            errExit(\"flock (PID=%ld)\", (long) getpid());\n    }\n\n    printf(\"PID %ld: granted    %s at %s\\n\", (long) getpid(), lname,\n            currTime(\"%T\"));\n\n    sleep((argc > 3) ? getInt(argv[3], GN_NONNEG, \"sleep-time\") : 10);\n\n    printf(\"PID %ld: releasing  %s at %s\\n\", (long) getpid(), lname,\n            currTime(\"%T\"));\n    if (flock(fd, LOCK_UN) == -1)\n        errExit(\"flock\");\n\n    exit(EXIT_SUCCESS);\n}\n    `filelock/t_flock.c`\n```", "```\n$ `touch tfile`\n$ `./t_flock tfile s 60 &`\n[1] 9777\nPID 9777: requesting LOCK_SH at 21:19:37\nPID 9777: granted    LOCK_SH at 21:19:37\n```", "```\n$ `./t_flock tfile s 2`\nPID 9778: requesting LOCK_SH at 21:19:49\nPID 9778: granted    LOCK_SH at 21:19:49\nPID 9778: releasing  LOCK_SH at 21:19:51\n```", "```\n$ `./t_flock tfile xn`\nPID 9779: requesting LOCK_EX at 21:20:03\nPID 9779: already locked - bye!\n```", "```\n$ `./t_flock tfile x`\nPID 9780: requesting LOCK_EX at 21:20:21\nPID 9777: releasing  LOCK_SH at 21:20:37\nPID 9780: granted    LOCK_EX at 21:20:37\nPID 9780: releasing  LOCK_EX at 21:20:47\n```", "```\nflock(fd, LOCK_EX);               /* Gain lock via 'fd' */\nnewfd = dup(fd);                  /* 'newfd' refers to same lock as 'fd' */\nflock(newfd, LOCK_UN);            /* Frees lock acquired via 'fd' */\n```", "```\nfd1 = open(\"a.txt\", O_RDWR);\nfd2 = open(\"a.txt\", O_RDWR);\nflock(fd1, LOCK_EX);\nflock(fd2, LOCK_EX);              /* Locked out by lock on 'fd1' */\n```", "```\nflock(fd, LOCK_EX);               /* Parent obtains lock */\nif (fork() == 0)                  /* If child... */\n    flock(fd, LOCK_UN);           /* Release lock shared with parent */\n```", "```\nstruct flock flockstr;\n\n/* Set fields of 'flockstr' to describe lock to be placed or removed */\n\nfcntl(fd, cmd, &flockstr);          /* Place lock defined by 'fl' */\n```", "```\nstruct flock {\n    short l_type;       /* Lock type: F_RDLCK, F_WRLCK, F_UNLCK */\n    short l_whence;     /* How to interpret 'l_start': SEEK_SET,\n                           SEEK_CUR, SEEK_END */\n    off_t l_start;      /* Offset where the lock begins */\n    off_t l_len;        /* Number of bytes to lock; 0 means \"until EOF\" */\n    pid_t l_pid;        /* Process preventing our lock (F_GETLK only) */\n};\n```", "```\n*cmd lock start length*[*whence*]\n```", "```\n`filelock/i_fcntl_locking.c`\n#include <sys/stat.h>\n#include <fcntl.h>\n#include \"tlpi_hdr.h\"\n\n#define MAX_LINE 100\n\nstatic void\ndisplayCmdFmt(void)\n{\n    printf(\"\\n    Format: cmd lock start length [whence]\\n\\n\");\n    printf(\"    'cmd' is 'g' (GETLK), 's' (SETLK), or 'w' (SETLKW)\\n\");\n    printf(\"    'lock' is 'r' (READ), 'w' (WRITE), or 'u' (UNLOCK)\\n\");\n    printf(\"    'start' and 'length' specify byte range to lock\\n\");\n    printf(\"    'whence' is 's' (SEEK_SET, default), 'c' (SEEK_CUR), \"\n           \"or 'e' (SEEK_END)\\n\\n\");\n}\n\nint\nmain(int argc, char *argv[])\n{\n    int fd, numRead, cmd, status;\n    char lock, cmdCh, whence, line[MAX_LINE];\n    struct flock fl;\n    long long len, st;\n\n    if (argc != 2 || strcmp(argv[1], \"--help\") == 0)\n        usageErr(\"%s file\\n\", argv[0]);\n\n    fd = open(argv[1], O_RDWR);\n    if (fd == -1)\n        errExit(\"open (%s)\", argv[1]);\n\n    printf(\"Enter ? for help\\n\");\n\n    for (;;) {          /* Prompt for locking command and carry it out */\n        printf(\"PID=%ld> \", (long) getpid());\n        fflush(stdout);\n\n        if (fgets(line, MAX_LINE, stdin) == NULL)       /* EOF */\n            exit(EXIT_SUCCESS);\n        line[strlen(line) - 1] = '\\0';          /* Remove trailing '\\n' */\n\n        if (*line == '\\0')\n            continue;                           /* Skip blank lines */\n\n        if (line[0] == '?') {\n            displayCmdFmt();\n            continue;\n        }\n\n        whence = 's';                   /* In case not otherwise filled in */\n\n        numRead = sscanf(line, \"%c %c %lld %lld %c\", &cmdCh, &lock,\n                        &st, &len, &whence);\n        fl.l_start = st;\n        fl.l_len = len;\n\n        if (numRead < 4 || strchr(\"gsw\", cmdCh) == NULL ||\n                strchr(\"rwu\", lock) == NULL || strchr(\"sce\", whence) == NULL) {\n            printf(\"Invalid command!\\n\");\n            continue;\n        }\n\n        cmd = (cmdCh == 'g') ? F_GETLK : (cmdCh == 's') ? F_SETLK : F_SETLKW;\n        fl.l_type = (lock == 'r') ? F_RDLCK : (lock == 'w') ? F_WRLCK : F_UNLCK;\n        fl.l_whence = (whence == 'c') ? SEEK_CUR :\n                      (whence == 'e') ? SEEK_END : SEEK_SET;\n\n        status = fcntl(fd, cmd, &fl);           /* Perform request... */\n\n        if (cmd == F_GETLK) {                   /* ... and see what happened */\n            if (status == -1) {\n                errMsg(\"fcntl - F_GETLK\");\n            } else {\n                if (fl.l_type == F_UNLCK)\n                    printf(\"[PID=%ld] Lock can be placed\\n\", (long) getpid());\n                else                            /* Locked out by someone else */\n                    printf(\"[PID=%ld] Denied by %s lock on %lld:%lld \"\n                            \"(held by PID %ld)\\n\", (long) getpid(),\n                            (fl.l_type == F_RDLCK) ? \"READ\" : \"WRITE\",\n                            (long long) fl.l_start,\n                            (long long) fl.l_len, (long) fl.l_pid);\n            }\n        } else {                /* F_SETLK, F_SETLKW */\n            if (status == 0)\n                printf(\"[PID=%ld] %s\\n\", (long) getpid(),\n                        (lock == 'u') ? \"unlocked\" : \"got lock\");\n            else if (errno == EAGAIN || errno == EACCES)        /* F_SETLK */\n                printf(\"[PID=%ld] failed (incompatible lock)\\n\",\n                        (long) getpid());\n            else if (errno == EDEADLK)                          /* F_SETLKW */\n                printf(\"[PID=%ld] failed (deadlock)\\n\", (long) getpid());\n            else\n                errMsg(\"fcntl - F_SETLK(W)\");\n        }\n    }\n}\n    `filelock/i_fcntl_locking.c`\n```", "```\n`Terminal window 1`\n$ `ls -l tfile`\n-rw-r--r--    1 mtk      users         100 Apr 18 12:19 tfile\n$ `./i_fcntl_locking tfile`\nEnter ? for help\nPID=790> `s r 0 40`\n[PID=790] got lock\n```", "```\n`Terminal window 2`\n                                    $ `./i_fcntl_locking tfile`\n                                    Enter ? for help\n                                    PID=800> `s r -30 0 e`\n                                    [PID=800] got lock\n```", "```\nPID=790> `g w 0 0`\n[PID=790] Denied by READ lock on 70:0 (held by PID 800)\nPID=790> `s w 0 0`\n[PID=790] failed (incompatible lock)\nPID=790> `w w 0 0`\n```", "```\nPID=800> `g w 0 0`\n                                    [PID=800] Denied by READ lock on 0:40\n                                    (held by PID 790)\n                                    PID=800> `w w 0 0`\n                                    [PID=800] failed (deadlock)\n```", "```\nPID=800> `s u 0 0`\n                                    [PID=800] unlocked\n[PID=790] got lock\n```", "```\n`filelock/region_locking.c`\n#include <fcntl.h>\n#include \"region_locking.h\"             /* Declares functions defined here */\n\n/* Lock a file region (private; public interfaces below) */\n\nstatic int\nlockReg(int fd, int cmd, int type, int whence, int start, off_t len)\n{\n    struct flock fl;\n\n    fl.l_type = type;\n    fl.l_whence = whence;\n    fl.l_start = start;\n    fl.l_len = len;\n\n    return fcntl(fd, cmd, &fl);\n}\n\nint                     /* Lock a file region using nonblocking F_SETLK */\nlockRegion(int fd, int type, int whence, int start, int len)\n{\n    return lockReg(fd, F_SETLK, type, whence, start, len);\n}\n\nint                     /* Lock a file region using blocking F_SETLKW */\nlockRegionWait(int fd, int type, int whence, int start, int len)\n{\n    return lockReg(fd, F_SETLKW, type, whence, start, len);\n}\n\n/* Test if a file region is lockable. Return 0 if lockable, or\n   PID of process holding incompatible lock, or -1 on error. */\n\npid_t\nregionIsLocked(int fd, int type, int whence, int start, int len)\n{\n    struct flock fl;\n\n    fl.l_type = type;\n    fl.l_whence = whence;\n    fl.l_start = start;\n    fl.l_len = len;\n\n    if (fcntl(fd, F_GETLK, &fl) == -1)\n        return -1;\n\n    return (fl.l_type == F_UNLCK) ? 0 : fl.l_pid;\n}\n    `filelock/region_locking.c`\n```", "```\nstruct flock fl;\n\nfl.l_type = F_WRLCK;\nfl.l_whence = SEEK_SET;\nfl.l_start = 0;\nfl.l_len = 0;\n\nfd1 = open(\"testfile\", O_RDWR);\nfd2 = open(\"testfile\", O_RDWR);\n\nif (fcntl(fd1, cmd, &fl) == -1)\n    errExit(\"fcntl\");\n\nclose(fd2);\n```", "```\n# `mount -o mand /dev/sda10 /testfs`\n```", "```\n# `mount | grep sda10`\n/dev/sda10 on /testfs type ext3 (rw,mand)\n```", "```\n$ `chmod g+s,g-x /testfs/file`\n```", "```\n$ `ls -l /testfs/file`\n-rw-r-Sr--    1 mtk      users       0 Apr 22 14:11 /testfs/file\n```", "```\n$ `cat /proc/locks`\n1: POSIX  ADVISORY  WRITE 458 03:07:133880 0 EOF\n2: FLOCK  ADVISORY  WRITE 404 03:07:133875 0 EOF\n3: POSIX  ADVISORY  WRITE 312 03:07:133853 0 EOF\n4: FLOCK  ADVISORY  WRITE 274 03:07:81908 0 EOF\n```", "```\n$ `ps -p 312`\n  PID TTY          TIME CMD\n  312 ?        00:00:00 atd\n```", "```\n$ `ls -li /dev/sda7 | awk '$6 == \"3,\" && $7 == 10'`\n  1311 brw-rw----    1 root   disk    3,  7 May 12  2006 /dev/`sda`7\n```", "```\n$ `mount | grep sda7`\n/dev/sda7 on / type reiserfs (rw)             *Device is mounted on* /\n$ `su`                                          *So we can search all directories*\nPassword:\n# `find / -mount -inum 133853`                  *Search for i-node 133853*\n/var/run/atd.pid\n```", "```\n# `cat /var/run/atd.pid`\n312\n```", "```\n$ `cat /proc/locks`\n1: POSIX  ADVISORY  WRITE 11073 03:07:436283 100 109\n1: -> POSIX  ADVISORY  WRITE 11152 03:07:436283 100 109\n2: POSIX  MANDATORY WRITE 11014 03:07:436283 0 9\n2: -> POSIX  MANDATORY WRITE 11024 03:07:436283 0 9\n2: -> POSIX  MANDATORY READ  11122 03:07:436283 0 19\n3: FLOCK  ADVISORY  WRITE 10802 03:07:134447 0 EOF\n3: -> FLOCK  ADVISORY  WRITE 10840 03:07:134447 0 EOF\n```", "```\nif (createPidFile(\"mydaemon\", \"/var/run/mydaemon.pid\", 0) == -1)\n    errExit(\"createPidFile\");\n```", "```\n`filelock/create_pid_file.c`\n#include <sys/stat.h>\n#include <fcntl.h>\n#include \"region_locking.h\"             /* For lockRegion() */\n#include \"create_pid_file.h\"            /* Declares createPidFile() and\n                                           defines CPF_CLOEXEC */\n#include \"tlpi_hdr.h\"\n\n#define BUF_SIZE 100            /* Large enough to hold maximum PID as string */\n\n/* Open/create the file named in 'pidFile', lock it, optionally set the\n   close-on-exec flag for the file descriptor, write our PID into the file,\n   and (in case the caller is interested) return the file descriptor\n   referring to the locked file. The caller is responsible for deleting\n   'pidFile' file (just) before process termination. 'progName' should be the\n   name of the calling program (i.e., argv[0] or similar), and is used only for\n   diagnostic messages. If we can't open 'pidFile', or we encounter some other\n   error, then we print an appropriate diagnostic and terminate. */\n\nint\ncreatePidFile(const char *progName, const char *pidFile, int flags)\n{\n    int fd;\n    char buf[BUF_SIZE];\n\n    fd = open(pidFile, O_RDWR | O_CREAT, S_IRUSR | S_IWUSR);\n    if (fd == -1)\n        errExit(\"Could not open PID file %s\", pidFile);\n\n    if (flags & CPF_CLOEXEC) {\n\n        /* Set the close-on-exec file descriptor flag */\n\n        flags = fcntl(fd, F_GETFD);                     /* Fetch flags */\n        if (flags == -1)\n            errExit(\"Could not get flags for PID file %s\", pidFile);\n\n        flags |= FD_CLOEXEC;                            /* Turn on FD_CLOEXEC */\n\n        if (fcntl(fd, F_SETFD, flags) == -1)            /* Update flags */\n            errExit(\"Could not set flags for PID file %s\", pidFile);\n    }\n\n    if (lockRegion(fd, F_WRLCK, SEEK_SET, 0, 0) == -1) {\n        if (errno  == EAGAIN || errno == EACCES)\n            fatal(\"PID file '%s' is locked; probably \"\n                     \"'%s' is already running\", pidFile, progName);\n        else\n            errExit(\"Unable to lock PID file '%s'\", pidFile);\n    }\n\n    if (ftruncate(fd, 0) == -1)\n        errExit(\"Could not truncate PID file '%s'\", pidFile);\n\n    snprintf(buf, BUF_SIZE, \"%ld\\n\", (long) getpid());\n    if (write(fd, buf, strlen(buf)) != strlen(buf))\n        fatal(\"Writing to PID file '%s'\", pidFile);\n\n    return fd;\n}\n    `filelock/create_pid_file.c`\n```", "```\nfd = open(file, O_CREAT | O_TRUNC | O_WRONLY, (mode_t) 0);\nclose(fd);\n```"]