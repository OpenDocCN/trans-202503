- en: '**3**'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**RECONNAISSANCE WITH PROCESS MONITOR AND PROCESS EXPLORER**'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/common.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Cheat Engine and OllyDbg can help you tear apart a game’s memory and code,
    but you also need to understand how the game interacts with files, registry values,
    network connections, and other processes. To learn how those interactions work,
    you must use two tools that excel at monitoring the external actions of processes:
    Process Monitor and Process Explorer. With these tools, you can track down the
    complete game map, locate save files, identify registry keys used to store settings,
    and enumerate the Internet Protocol (IP) addresses of remote game servers.'
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, I’ll teach you how to use both Process Monitor and Process
    Explorer to log system events and inspect them to see how a game was involved.
    Useful mainly for initial reconnaissance, these tools are amazing at giving a
    clear, verbose picture of exactly how a game interacts with your system. You can
    download both programs from the Windows Sysinternals website (*[https://technet.microsoft.com/en-us/sysinternals/](https://technet.microsoft.com/en-us/sysinternals/)*).
  prefs: []
  type: TYPE_NORMAL
- en: '**Process Monitor**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You can learn a lot about a game simply by exploring how it interacts with the
    registry, filesystem, and network. Process Monitor is a powerful system-monitoring
    tool that logs such events in real time and lets you seamlessly integrate the
    data into a debugging session. This tool provides extensive amounts of useful
    data regarding a game’s interaction with the external environment. With calculated
    review (and sometimes, spontaneous intuition) on your part, this data can reveal
    details about data files, network connections, and registry events that are helpful
    to your ability to see and manipulate how the game functions.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, I’ll show you how to use Process Monitor to log data, navigate
    it, and make educated guesses about the files a game interacts with. After this
    interface tour, you’ll have a chance to try out Process Monitor for yourself in
    “[Finding a High Score File](ch03.xhtml#ch03sb01)” on [page 55](ch03.xhtml#page_55).
  prefs: []
  type: TYPE_NORMAL
- en: '***Logging In-Game Events***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Process Monitor’s logs can hold all sorts of potentially useful information,
    but their most practical use is to help you figure out where data files, such
    as in-game item definitions, might be stored. When you start Process Monitor,
    the first dialog you see is the Process Monitor Filter, shown in [Figure 3-1](ch03.xhtml#ch3fig1).
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f03-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 3-1: Process Monitor Filter dialog*'
  prefs: []
  type: TYPE_NORMAL
- en: This dialog allows you to show or suppress events based on a number of dynamic
    properties they possess. To start monitoring processes, select **Process Name**
    ▸ **Is** ▸ ***YourGameFilename.exe*** ▸ **Include** and then press **Add**, **Apply**,
    and **OK**. This tells Process Monitor to show events invoked by *YourGameFilename.exe*.
    With the proper filters set, you will be taken to the main window shown in [Figure
    3-2](ch03.xhtml#ch3fig2).
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f03-02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 3-2: Process Monitor main window*'
  prefs: []
  type: TYPE_NORMAL
- en: To configure the columns displayed in Process Monitor’s log area, right-click
    on the header and choose **Select Columns**. There’s an impressive number of options,
    but I recommend seven.
  prefs: []
  type: TYPE_NORMAL
- en: '**Time of Day** Lets you see when actions are happening.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Process Name** Is useful if you’re monitoring multiple processes, but with
    the single-process filter that is typically used for games; disabling this option
    can save precious space.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Process ID** Is like Process Name, but it shows the ID rather than the name.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Operation** Shows what action was performed; thus, this option is compulsory.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Path** Shows the path of the action’s target; also compulsory.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Detail** Is useful only in some cases, but enabling it won’t hurt.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Result** Shows when actions, such as loading files, fail.'
  prefs: []
  type: TYPE_NORMAL
- en: As you show more columns, the log can get very crowded, but sticking with these
    options should help keep the output succinct.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once the monitor is running and you’ve defined the columns you wish to see,
    there are five event class filters, outlined in black in [Figure 3-2](ch03.xhtml#ch3fig2),
    that you can toggle to clean up your logs even further. Event class filters let
    you choose which events to show in the log, based on type. From left to right,
    these filters are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Registry** Shows all registry activity. There will be a lot of white noise
    in the registry upon process creation, as games rarely use the registry and Windows
    libraries always use it. Leaving this filter disabled can save a lot of space
    in the log.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Filesystem** Shows all filesystem activity. This is the most important event
    class filter, since knowing where data files are stored and how they are accessed
    is integral to writing an effective bot.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Network** Shows all network activity. The call stack on network events can
    be useful in finding network-related code within a game.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Process and thread activity** Shows all process and thread actions. The call
    stack on these events can give you insight into how a game’s code handles threads.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Process profiling** Periodically shows information about the memory and CPU
    usage of each running process; a game hacker will rarely use it.'
  prefs: []
  type: TYPE_NORMAL
- en: If class-level event filtering is still not precise enough to filter out unwanted
    pollution in your logs, right-click on specific events for event-level filtering
    options. Once you have your event filtering configured to log only what you need,
    you can begin navigating the log. [Table 3-1](ch03.xhtml#ch3tab1) lists some useful
    hotkeys for controlling the log’s behavior.
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 3-1:** Process Monitor Hotkeys'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Hotkey** | **Action** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| CTRL-E | Toggles logging. |'
  prefs: []
  type: TYPE_TB
- en: '| CTRL-A | Toggles automatic scrolling of the log. |'
  prefs: []
  type: TYPE_TB
- en: '| CTRL-X | Clears the log. |'
  prefs: []
  type: TYPE_TB
- en: '| CTRL-L | Displays the Filter dialog. |'
  prefs: []
  type: TYPE_TB
- en: '| CTRL-H | Displays the Highlight dialog. This dialog looks very similar to
    the Filter dialog, but it is used to indicate which events should be highlighted.
    |'
  prefs: []
  type: TYPE_TB
- en: '| CTRL-F | Displays the Search dialog. |'
  prefs: []
  type: TYPE_TB
- en: '| CTRL-P | Displays the Event Properties dialog for the selected event. |'
  prefs: []
  type: TYPE_TB
- en: As you navigate the log, you can examine the operations recorded to see the
    fine-grained details of an event.
  prefs: []
  type: TYPE_NORMAL
- en: '***Inspecting Events in the Process Monitor Log***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Process Monitor logs every data point it possibly can about an event, enabling
    you to learn more about these events than just the files they act upon. Carefully
    inspecting data-rich columns, such as Result and Detail, can yield some very interesting
    information.
  prefs: []
  type: TYPE_NORMAL
- en: For example, I’ve found that games sometimes read data structures, element by
    element, directly from files. This behavior is apparent when a log contains a
    large number of reads to the same file, where each read has sequential offsets
    but differing lengths. Consider the hypothetical event log shown in [Table 3-2](ch03.xhtml#ch3tab2).
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 3-2:** Example Event Log'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Operation** | **Path** | **Detail** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| Create File | *C:\file.dat* | Desired Access: Read |'
  prefs: []
  type: TYPE_TB
- en: '| Read File | *C:\file.dat* | Offset: 0 Size: 4 |'
  prefs: []
  type: TYPE_TB
- en: '| Read File | *C:\file.dat* | Offset: 4 Size: 2 |'
  prefs: []
  type: TYPE_TB
- en: '| Read File | *C:\file.dat* | Offset: 6 Size: 2 |'
  prefs: []
  type: TYPE_TB
- en: '| Read File | *C:\file.dat* | Offset: 8 Size: 4 |'
  prefs: []
  type: TYPE_TB
- en: '| Read File | *C:\file.dat* | Offset: 12 Size: 4 |'
  prefs: []
  type: TYPE_TB
- en: '| ... | *...* | ...Continues to read chunks of 4 bytes for a while |'
  prefs: []
  type: TYPE_TB
- en: 'This log reveals that the game is reading a structure from the file piece by
    piece, disclosing some hints about what the structure looks like. For example,
    let’s say that these reads reflect the following data file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Compare the log in [Table 3-2](ch03.xhtml#ch3tab2) with this structure. First,
    the game reads the 4 `header` bytes. Then, it reads two 2-byte values: `effectCount`
    and `itemCount`. It then creates two integer arrays, `effects` and `items`, of
    respective lengths `effectCount` and `itemCount`. The game then fills these arrays
    with data from the file, reading 4 bytes `effectCount + itemCount` times.'
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Developers definitely shouldn’t use a process like this to read data from
    a file, but you’d be amazed at how often it happens. Fortunately for you, naïveté
    like this just makes your analysis easier.*'
  prefs: []
  type: TYPE_NORMAL
- en: In this case, the event log can identify small pieces of information within
    a file. But keep in mind that, while correlating the reads with the known structure
    is easy, it’s much harder to reverse engineer an unknown structure from nothing
    but an event log. Typically, game hackers will use a debugger to get more context
    about each interesting event, and the data from Process Monitor can be seamlessly
    integrated into a debugging session, effectively tying together the two powerful
    reverse engineering paradigms.
  prefs: []
  type: TYPE_NORMAL
- en: '***Debugging a Game to Collect More Data***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Let’s step away from this hypothetical file read and look at how Process Monitor
    lets you transition from event logging to debugging. Process Monitor stores a
    complete stack trace for each event, showing the full execution chain that led
    to the event being triggered. You can view these stack traces in the Stack tab
    of the Event Properties window (double-click the event or press CTRL-P), as shown
    in [Figure 3-3](ch03.xhtml#ch3fig3).
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f03-03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 3-3: Process Monitor event call stack*'
  prefs: []
  type: TYPE_NORMAL
- en: The stack trace is displayed in a table starting with a Frame column ➊, which
    shows the execution mode and stack frame index. A pink *K* in this column means
    the call happened in kernel mode, while a blue *U* means it happened in user mode.
    Since game hackers typically work in user mode, kernel mode operations are usually
    meaningless.
  prefs: []
  type: TYPE_NORMAL
- en: The Module column ➋ shows the executable module where the calling code was located.
    Each module is just the name of the binary that made the call; this makes it easy
    to identify which calls were actually made from within a game binary.
  prefs: []
  type: TYPE_NORMAL
- en: The Location column ➌ shows the name of the function that made each call, as
    well as the call offset. These function names are deduced from the export table
    of the module and will generally not be present for the functions within a game
    binary. When no function names are present, the Location column instead shows
    the module name and the call’s *offset* (how many bytes past the origin address
    the call is in memory) from the module’s base address.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*In the context of code, the offset is how many bytes of assembly code are
    between an item and its origin.*'
  prefs: []
  type: TYPE_NORMAL
- en: The Address column ➍ shows the code address of the call, which is very useful
    because you can jump to the address in the OllyDbg disassembler. Finally, the
    Path column ➎ shows the path to the module that made the call.
  prefs: []
  type: TYPE_NORMAL
- en: In my opinion, the stack trace is, by far, the most powerful feature in Process
    Monitor. It reveals the entire context that led to an event, which can be immensely
    useful when you are debugging a game. You can use it to find the exact code that
    triggered an event, crawl up the call chain to see how it got there, and even
    determine exactly what libraries were used to complete each action.
  prefs: []
  type: TYPE_NORMAL
- en: Process Monitor’s sister application, Process Explorer, doesn’t have many capabilities
    beyond those in Process Monitor or OllyDbg. But it does expose some of those capabilities
    much more effectively, making it an ideal pick in certain situations.
  prefs: []
  type: TYPE_NORMAL
- en: '**FINDING A HIGH SCORE FILE**'
  prefs: []
  type: TYPE_NORMAL
- en: If you’re ready to test your Process Monitor skills, you’ve come to the right
    place. Open the *GameHackingExamples/Chapter3_FindingFiles* directory and execute
    *FindingFiles.exe*. You’ll see that it is a game of Pong, like the one in “[Patching
    an `if()` Statement](ch02.xhtml#ch02sb01)” on [page 46](ch02.xhtml#page_46). Unlike
    in [Chapter 2](ch02.xhtml#ch02), though, now the game is actually playable. It
    also displays your current score and your all-time-high score.
  prefs: []
  type: TYPE_NORMAL
- en: Now restart the game, firing up Process Monitor before executing it for the
    second time. Filtering for filesystem activity and creating any other filters
    you see fit, try to locate where the game stores the high-score file. For bonus
    points, try to modify this file to make the game show the highest possible score.
  prefs: []
  type: TYPE_NORMAL
- en: '**Process Explorer**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Process Explorer is an advanced task manager (it even has a button you can press
    to make it your default task manager), and it’s very handy when you’re starting
    to understand how a game operates. It provides complex data about running processes,
    such as parent and child processes, CPU usage, memory usage, loaded modules, open
    handles, and command line arguments, and it can manipulate those processes. It
    exceeds at showing you high-level information, such as process trees, memory consumption,
    file access, and process IDs, all of which can be very useful.
  prefs: []
  type: TYPE_NORMAL
- en: Of course, none of this data is specifically useful in isolation. But with a
    keen eye, you can make correlations and draw some useful conclusions about what
    global objects—including files, mutexes, and shared memory segments—a game has
    access to. Additionally, the data shown in Process Explorer can be even more valuable
    when cross-referenced with data gathered in a debugging session.
  prefs: []
  type: TYPE_NORMAL
- en: This section introduces the Process Explorer interface, discusses the properties
    it shows, and describes how you can use this tool to manipulate *handles* (references
    to system resources). After this introduction, use “[Finding and Closing a Mutex](ch03.xhtml#ch03sb02)”
    on [page 60](ch03.xhtml#page_60) to hone your skills.
  prefs: []
  type: TYPE_NORMAL
- en: '***Process Explorer’s User Interface and Controls***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: When you open Process Explorer, you see a window that is split into three distinct
    sections, as in [Figure 3-4](ch03.xhtml#ch3fig4).
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f03-04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 3-4: Process Explorer main window*'
  prefs: []
  type: TYPE_NORMAL
- en: Those three sections are the toolbar ➊, an upper pane ➋, and a lower pane ➌.
    The upper pane shows a list of processes, utilizing a tree structure to display
    their parent/child relationships. Different processes are highlighted with different
    colors; if you don’t like the current colors, click **Options** ▸ **Configure
    Colors** to display a dialog that allows you to view and change them.
  prefs: []
  type: TYPE_NORMAL
- en: Just as in Process Monitor, the display for this table is highly versatile,
    and you can customize it by right-clicking on the table header and choosing Select
    Columns. There are probably more than 100 customization options, but I find that
    the defaults with the addition of the ASLR Enabled column work just fine.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: Address Space Layout Randomization (ASLR) *is a Windows security feature that
    allocates executable images at unpredictable locations, and knowing whether it’s
    on is invaluable when you’re trying to alter game state values in memory.*
  prefs: []
  type: TYPE_NORMAL
- en: 'The lower pane has three possible states: Hidden, DLLs, and Handles. The Hidden
    option hides the pane from view, DLLs displays a list of Dynamic Link Libraries
    loaded within the current process, and Handles shows a list of handles held by
    the process (visible in [Figure 3-4](ch03.xhtml#ch3fig4)). You can hide or unhide
    the entire lower pane by toggling View ▸ Show Lower Pane. When it is visible,
    you can change the information display by selecting either View ▸ Lower Pane View
    ▸ DLLs or View ▸ Lower Pane View ▸ Handles.'
  prefs: []
  type: TYPE_NORMAL
- en: You can also use hotkeys to quickly change between lower pane modes without
    affecting processes in the upper pane. These hotkeys are listed in [Table 3-3](ch03.xhtml#ch3tab3).
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 3-3:** Process Explorer Hotkeys'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Hotkey** | **Action** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| CTRL-F | Search through lower pane data sets for a value. |'
  prefs: []
  type: TYPE_TB
- en: '| CTRL-L | Toggle the lower pane between hidden and visible. |'
  prefs: []
  type: TYPE_TB
- en: '| CTRL-D | Toggle the lower pane to display DLLs. |'
  prefs: []
  type: TYPE_TB
- en: '| CTRL-H | Toggle the lower pane to display handles. |'
  prefs: []
  type: TYPE_TB
- en: '| spacebar | Toggle process list autorefresh. |'
  prefs: []
  type: TYPE_TB
- en: '| ENTER | Display the Properties dialog for the selected process. |'
  prefs: []
  type: TYPE_TB
- en: '| DEL | Kill the selected process. |'
  prefs: []
  type: TYPE_TB
- en: '| SHIFT-DEL | Kill the selected process and all child processes. |'
  prefs: []
  type: TYPE_TB
- en: Use the GUI or hotkeys to practice changing modes. When you’re acquainted with
    the main window, we’ll look at another important Process Explorer dialog, called
    Properties.
  prefs: []
  type: TYPE_NORMAL
- en: '***Examining Process Properties***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Much like Process Monitor, Process Explorer has a very kinetic approach to data
    gathering; the end result is a broad and verbose spectrum of information. In fact,
    if you open the Properties dialog (shown in [Figure 3-5](ch03.xhtml#ch3fig5))
    for a process, you’ll see a massive tab bar containing 10 tabs.
  prefs: []
  type: TYPE_NORMAL
- en: The Image tab, selected by default and shown in [Figure 3-5](ch03.xhtml#ch3fig5),
    displays the executable name, version, build date, and complete path. It also
    displays the current working directory and the Address Space Layout Randomization
    status of the executable. ASLR status is the most important piece of information
    here, because it has a direct effect on how a bot can read the memory from a game.
    I’ll talk about this more in [Chapter 6](ch06.xhtml#ch06).
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f03-05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 3-5: Process Explorer Properties dialog*'
  prefs: []
  type: TYPE_NORMAL
- en: The Performance, Performance Graph, Disk and Network, and GPU Graph tabs display
    a myriad of metrics about the CPU, memory, disk, network, and GPU usage of the
    process. If you create a bot that injects into a game, this information can be
    very useful to determine how much of a performance impact your bot has on the
    game.
  prefs: []
  type: TYPE_NORMAL
- en: The TCP/IP tab displays a list of active TCP connections, which you can use
    to find any game server IP addresses that a game connects to. If you’re trying
    to test connection speed, terminate connections, or research a game’s network
    protocol, this information is critical.
  prefs: []
  type: TYPE_NORMAL
- en: The Strings tab displays a list of strings found in either the binary or the
    memory of the process. Unlike the string list in OllyDbg, which shows only strings
    referenced by assembly code, the list includes any occurrences of three or more
    consecutive readable characters, followed by a null terminator. When a game binary
    is updated, you can use a diffing tool on this list from each game version to
    determine whether there are any new strings that you want to investigate.
  prefs: []
  type: TYPE_NORMAL
- en: The Threads tab shows you a list of threads running within the process and allows
    you to pause, resume, or kill each thread; the Security tab displays the security
    privileges of the process; and the Environment tab displays any environment variables
    known to or set by the process.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*If you open the Properties dialog for a .NET process, you’ll notice two additional
    tabs: .NET Assemblies and .NET Performance. The data in these tabs is pretty self-explanatory.
    Please keep in mind that a majority of the techniques in this book won’t work
    with games written in .NET.*'
  prefs: []
  type: TYPE_NORMAL
- en: '***Handle Manipulation Options***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'As you’ve seen, Process Explorer can provide you with a wealth of information
    about a process. That’s not all it’s good for, though: it can also manipulate
    certain parts of a process. For example, you can view and manipulate open handles
    from the comfort of Process Explorer’s lower pane (see [Figure 3-4](ch03.xhtml#ch3fig4)).
    This alone makes a strong argument for adding Process Explorer to your toolbox.
    Closing a handle is as simple as right-clicking on it and selecting Close Handle.
    This can come in handy when you want, for instance, to close mutexes, which is
    essential to certain types of hacks.'
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*You can right-click on the lower pane header and click Select Columns to customize
    the display. One column you might find particularly useful is Handle Value, which
    can help when you see a handle being passed around in OllyDbg and want to know
    what it does.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**Closing Mutexes**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Games often allow only one client to run at a time; this is called *single-instance
    limitation*. You can implement single-instance limitation in a number of ways,
    but using a system mutex is common because mutexes are sessionwide and can be
    accessed by a simple name. It’s trivial to limit instances with mutexes, and thanks
    to Process Explorer, it’s just as trivial to remove that limit, allowing you to
    run multiple instances of a game at the same time.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, here’s how a game might tackle single-instance limitation with a mutex:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: This example code creates a mutex named `onlyoneplease`. Next, the function
    checks `GetLastError()` to see whether the mutex was already created, and if so,
    it closes the game. If the mutex doesn’t already exist, the game creates the first
    instance, thereby blocking any future game clients from running. In this example,
    the game runs normally, and once it finishes, `CloseHandle()` is called to close
    the mutex and allow future game instances to run.
  prefs: []
  type: TYPE_NORMAL
- en: You can use Process Explorer to close instance-limiting mutexes and run many
    game instances simultaneously. To do so, choose the Handles view of the lower
    pane, look for all handles with a type of `Mutant`, determine which one is limiting
    instances of the game, and close that mutex.
  prefs: []
  type: TYPE_NORMAL
- en: '**WARNING**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Mutexes are also used to synchronize data across threads and processes. Close
    one only if you’re sure that its sole purpose is the one you’re trying to subvert!*'
  prefs: []
  type: TYPE_NORMAL
- en: Multiclient hacks are generally in high demand, so being able to quickly develop
    them for emerging games is crucial to your overall success as a bot developer
    within that market. Since mutexes are one of the most common ways to achieve single-instance
    limitation, Process Explorer is an integral tool for prototyping these kinds of
    hacks.
  prefs: []
  type: TYPE_NORMAL
- en: '**Inspecting File Accesses**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Unlike Process Monitor, Process Explorer can’t show a list of filesystem calls.
    On the other hand, the Handles view of Process Explorer’s lower pane can show
    all file handles that a game currently has open, revealing exactly what files
    are in continuous use without the need to set up advanced filtering criteria in
    Process Monitor. Just look for handles with a type of `File` to see all files
    the game is currently using.
  prefs: []
  type: TYPE_NORMAL
- en: This functionality can come in handy if you’re trying to locate logfiles or
    save files. Moreover, you can locate named pipes that are used for interprocess
    communication (IPC); these are files prefixed with *\Device\NamedPipe\*. Seeing
    one of these pipes is often a hint that the game is talking to another process.
  prefs: []
  type: TYPE_NORMAL
- en: '**FINDING AND CLOSING A MUTEX**'
  prefs: []
  type: TYPE_NORMAL
- en: To put your Process Explorer skills to use, go to the *GameHackingExamples/Chapter3_CloseMutex*
    directory and execute *CloseMutex.exe*. This game plays exactly like the one in
    “[Finding a High Score File](ch03.xhtml#ch03sb01)” on [page 55](ch03.xhtml#page_55),
    but it prevents you from simultaneously running multiple instances. As you might
    have guessed, it does this using a single-instance-limitation mutex. Using Process
    Explorer’s Handles view in the lower pane, find the mutex responsible for this
    limitation and close it. If you succeed, you’ll be able to open a second instance
    of the game.
  prefs: []
  type: TYPE_NORMAL
- en: '**Closing Thoughts**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To be effective when using Process Monitor and Process Explorer, you need, above
    all else, a deep familiarity with the data that these applications display as
    well as the interfaces they use to display it. While this chapter’s overview is
    a good baseline, the intricacies of these applications can be learned only through
    experience, so I encourage you to play around with them on your system.
  prefs: []
  type: TYPE_NORMAL
- en: 'You won’t use these tools on a regular basis, but at some point, they’ll save
    the day: as you struggle to figure out how some code works, you’ll recall an obscure
    piece of information that caught your eye during a previous Process Explorer or
    Process Monitor session. That’s why I consider them useful reconnaissance tools.'
  prefs: []
  type: TYPE_NORMAL
