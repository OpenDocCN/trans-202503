- en: '**8**'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Three Helpings of Pi**'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '![Image](../images/common.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The number *π* (pi) represents the ratio of a circle’s circumference (the distance
    all the way around the circle’s “rim”) to its diameter (the straight line distance
    from one side of the circle through its center to the other side). Remarkably,
    the value of this ratio is the same no matter what size the circle is. Other properties
    of a circle, like its area, depend on its size, but not *π*; as the size of the
    circle increases, the ratio of the increasing circumference to the increasing
    diameter remains constant.
  prefs: []
  type: TYPE_NORMAL
- en: You can think of measurements of circumference and diameter as being given in
    a common length unit, like centimeters or inches. In the ratio, the units of these
    measurements cancel out, leaving *π* as a pure number, dimensionless. It’s often
    approximated as 3.14, but the digits beyond the decimal point actually continue
    on forever, without repeating. Over the years, mathematicians have devised lots
    of different ways to calculate *π*, with varying degrees of accuracy. In this
    chapter, we’ll consider a few such techniques, using algebra, geometry, and even
    number theory.
  prefs: []
  type: TYPE_NORMAL
- en: How Archimedes Calculated Pi
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Let’s first explore an approach to calculating *π* used by the ancient Greek
    mathematician Archimedes. Start by drawing a circle, then draw an *inscribed*
    polygon, a shape that fits completely inside the circle with its corners just
    touching the circle’s rim. Next, draw a *circumscribed* polygon, a shape that
    completely surrounds the circle such that the midpoint of each side touches the
    rim of the circle. The two polygons should have the same number of sides, and
    they should be *regular* polygons, meaning all their sides are of equal length.
    [Figure 8-1](ch08.xhtml#ch8fig1) shows what this drawing might look like.
  prefs: []
  type: TYPE_NORMAL
- en: Notice that the perimeter of the inscribed (purple) hexagon is smaller than
    the circumference of the circle, and the perimeter of the circumscribed (black)
    hexagon is larger than the circumference of the circle. This means we can use
    the perimeters of these two hexagons to find lower and upper bounds for the value
    of *π*.
  prefs: []
  type: TYPE_NORMAL
- en: The figure doesn’t specify length units, so let’s say the circle has a radius
    of *r* = 1\. A circle with a radius of 1 is called a *unit circle*. This unit
    circle has a circumference of *C* = 2*πr* = 2*π*. The inscribed hexagon is made
    up of six equilateral triangles with side length 1, so by summing the lengths
    of the outer edges of the triangles we can determine that the size of the perimeter
    of the inscribed hexagon is 6\. This in turn tells us that 2*π* > 6, so *π* >
    3.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg172_Image_208.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 8-1: Inscribed and circumscribed hexagons*'
  prefs: []
  type: TYPE_NORMAL
- en: With a little bit of trigonometry, we can calculate that the circumscribed hexagon
    has sides of length (2![Image](../images/pg172_Image_209.jpg)) / 3, so the size
    of its perimeter is (6 ⋅ 2![Image](../images/pg172_Image_209.jpg)) / 3\. This
    equals 4![Image](../images/pg172_Image_209.jpg), and if 2*π* < 4![Image](../images/pg172_Image_209.jpg),
    then *π* < 2![Image](../images/pg172_Image_209.jpg), or approximately 3.4642.
  prefs: []
  type: TYPE_NORMAL
- en: We now know that *π* is between 3 and 3.4642\. To get a little more precision,
    let’s try doubling the number of sides of the inscribed and circumscribed polygons.
    As the number of sides increases, the inner and outer polygons nestle closer to
    the circle. [Figure 8-2](ch08.xhtml#ch8fig2) shows what happens when we go from
    6 sides to 12, for example.
  prefs: []
  type: TYPE_NORMAL
- en: 'As the polygons get closer and closer to the circle, their perimeters *converge*
    on the value of 2*π*. Archimedes went from 6- to 12- to 24- to 48- to 96-sided
    polygons and reached an approximation for *π* that was the best known for centuries:
    223 / 71 < *π* < 22 / 7.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg172_Image_210.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 8-2: Inscribed and circumscribed 12-sided polygons*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Archimedes arrived at his approximation by developing a recurrence rule for
    tracking how the perimeters change when you double the number of sides of the
    two polygons. The recurrence takes *a*[*n*] and *b*[*n*], the old upper and lower
    bounds of *π*, and calculates the new upper and lower bounds after the doubling,
    *a*[*n* + 1] and *b*[*n* + 1], as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg172_Image_211.jpg)'
  prefs: []
  type: TYPE_IMG
- en: For example, to go from our initial hexagons, where *a*[1] = 2![Image](../images/pg172_Image_209.jpg)
    and *b*[1] = 3, to the 12-sided polygons, we calculate
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg173_Image_212.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'and:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg173_Image_213.jpg)'
  prefs: []
  type: TYPE_IMG
- en: This tells us that *π* must be between 3.10583 and 3.21539.
  prefs: []
  type: TYPE_NORMAL
- en: The calculation for *a*[*n* + 1] is called the *harmonic mean* of *a*[*n*] and
    *b*[*n*]. The calculation for *b*[*n* + 1] is the *geometric mean* of *a*[*n*
    + 1] and *b*[*n*]. You can find more details about what these terms mean and how
    Archimedes used trigonometry to derive his recurrence at *[https://mathworld.wolfram.com/ArchimedesRecurrenceFormula.html](https://mathworld.wolfram.com/ArchimedesRecurrenceFormula.html)*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Project 30: Archimedes’s Recurrence'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In this project, we’ll program Archimedes’s recurrence in Scratch in order to
    calculate an approximation of *π*. We’ll start with hexagons, which, as we’ve
    established, give an upper bound *a*[1] of 2![Image](../images/pg172_Image_209.jpg)
    and a lower bound *b*[1] of 3\. Then, we’ll have the number of sides double from
    there. [Figure 8-3](ch08.xhtml#ch8fig3) shows the code.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg173_Image_214.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 8-3: Calculating *π* starting from inscribed and circumscribed hexagons*'
  prefs: []
  type: TYPE_NORMAL
- en: After setting the starting values for the upper and lower bounds ❶, we use a
    loop to calculate new values until the results are equal ➋, meaning we’ve reached
    the highest level of accuracy that Scratch can support. We store the upper bounds
    in list `A` and the lower bounds in list `B`. In the loop, notice how we calculate
    the new value of `a` first so we can use it in our calculation of `b`.
  prefs: []
  type: TYPE_NORMAL
- en: The Results
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[Figure 8-4](ch08.xhtml#ch8fig4) shows the contents of the `A` and `B` lists
    after running the program.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg174_Image_215.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 8-4: Starting with hexagons and converging to π*'
  prefs: []
  type: TYPE_NORMAL
- en: 'It takes just 27 cycles of the loop for us to hit the accuracy limits of Scratch’s
    floating-point representation. At this point, the values of the bounds converge
    on 3.141592653589792\. You can check that the first several digits are right if
    you remember the mnemonic “How I need a shake, chocolate of course, after the
    heavy lectures involving quantum mechanics.” Count the letters in each word to
    get the first 15 digits of *π*: “How I need” is 3, 1, 4, and so on.'
  prefs: []
  type: TYPE_NORMAL
- en: Hacking the Code
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: The side-doubling recurrence works even if we don’t start with hexagons. Suppose
    we approximate the circumference of a circle with inscribed and circumscribed
    squares, as in [Figure 8-5](ch08.xhtml#ch8fig5).
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg175_Image_216.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 8-5: Using squares to approximate circumference*'
  prefs: []
  type: TYPE_NORMAL
- en: If the circle still has a radius of 1, the outer square has a perimeter of 8\.
    By the Pythagorean theorem, the inner square has sides of length ![Image](../images/pg175_Image_217.jpg).
    Since the circle has a circumference of 2*π*, the first estimate is therefore
    2![Image](../images/pg175_Image_217.jpg) < *π* < 4\. To run the recurrence from
    there, just replace the two blocks setting the initial values of `a` and `b` (see
    [Figure 8-3](ch08.xhtml#ch8fig3) ❶ on [page 153](ch08.xhtml#page_153)) with the
    blocks in [Figure 8-6](ch08.xhtml#ch8fig6).
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg175_Image_218.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 8-6: New initial values for the recurrence*'
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 8-7](ch08.xhtml#ch8fig7) shows the result of running the program with
    these new starting values.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg175_Image_219.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 8-7: Starting with squares and converging to π*'
  prefs: []
  type: TYPE_NORMAL
- en: Even though the recurrence starts with wider bounds, it quickly converges, once
    again taking 27 cycles to hit Scratch’s accuracy limit.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg26_Image_12.jpg) Programming Challenge'
  prefs: []
  type: TYPE_NORMAL
- en: '**8.1**Figure out the initial values for the recurrence if you start with inscribed
    and circumscribed triangles. Since the first doubling of sides goes from triangles
    to hexagons, the output from the second line on should be the same as in [Figure
    8-4](ch08.xhtml#ch8fig4).'
  prefs: []
  type: TYPE_NORMAL
- en: Estimating Pi from the Area of a Circle
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Another way to calculate *π* is to use *A* = *πr*², the formula for the area
    of a circle. Imagine you’ve drawn a circle with a radius of *r* on top of a grid,
    with its center at point (0, 0). Any point (*x*, *y*) inside the circle will satisfy
    the inequality *x*² + *y*² < *r*². Say we focus only on points whose coordinates
    are integers. These are known as *lattice points*. We can think of each lattice
    point as the lower-left corner of a *unit square*, a square with a side length
    *s* = 1 and area *s*² = 1\. Counting the number of lattice points inside the circle
    (the ones that satisfy the *x*² + *y*² < *r*² inequality) gives us an approximation
    of the area of the circle. [Figure 8-8](ch08.xhtml#ch8fig8) shows an example of
    how this works, for a circle with a radius of 4.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg176_Image_220.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 8-8: Lattice points in a circle with a radius of 4*'
  prefs: []
  type: TYPE_NORMAL
- en: 'The lattice points inside the circle are shown as purple dots. There are 45
    in all. Each lattice point marks the lower-left corner of a yellow unit square.
    A few of these squares extend beyond the circle, but this is offset by the parts
    of the circle that the squares don’t cover. On balance, we can say that the circle
    has an approximate area of 45, the same as the area covered by the yellow squares.
    We know the area of a circle is *πr*², so dividing 45 by *r*² gives us an estimated
    value for *π*: 45 / 16 = 2.8125.'
  prefs: []
  type: TYPE_NORMAL
- en: 'If we also count the four lattice points that fall directly on the perimeter
    of the circle—points (4, 0), (0, 4), (–4, 0), and (–4, 0)—we can get a better
    approximation: 49 / 16 = 3.0625\. We could get even closer by using a bigger circle.
    This is because the area of the circle grows in proportion to the square of the
    radius, but the error comes only from the squares around the circumference, the
    number of which grows only in proportion to the first power of the radius. So
    the bigger the circle is, the less the error is relative to the overall area.
    In our next project, we’ll see how much we can improve our estimate by increasing
    the size of the radius, with Scratch handling the calculations for us.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Project 31: Using the Lattice Point Tally'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '[Figure 8-9](ch08.xhtml#ch8fig9) shows some Scratch code that prompts for a
    radius and counts lattice points in the resulting circle to approximate *π*. The
    output keeps track of both the number of lattice points that satisfy the condition
    *x*² + *y*² < *r*² and the resulting estimated value of *π*.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg177_Image_221.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 8-9: Counting lattice points to determine π*'
  prefs: []
  type: TYPE_NORMAL
- en: We first ask for a value for the circle’s radius. Then, we use two nested loops
    ❶ to step through the rows and columns of lattice points in a square circumscribed
    around the circle. We start in the top-right corner of the square, where `x` and
    `y` both equal the radius *r*, and work toward the bottom-left corner, where they
    equal –*r*. For each pair of coordinates, we check if the point is in the circle
    ➋ and increment the lattice count if it is. At the end, we divide the lattice
    count by the square of the radius to get the approximation of *π*.
  prefs: []
  type: TYPE_NORMAL
- en: The Results
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[Figure 8-10](ch08.xhtml#ch8fig10) shows the result of running the program
    for a circle with a radius of 1,000.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg178_Image_222.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 8-10: Counting lattice points in a circle with* r *= 1,000*'
  prefs: []
  type: TYPE_NORMAL
- en: This approximation of *π* is accurate up to the first four decimal places. Much
    better!
  prefs: []
  type: TYPE_NORMAL
- en: Hacking the Code
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: For a circle with a radius of *r*, the program in [Figure 8-9](ch08.xhtml#ch8fig9)
    has to check (2*r*)² lattice points. When *r* = 1,000, that’s 4 million points
    to check, which takes a little while. The delay gets worse as the circle gets
    bigger. If *r* = 10,000, for example, there will be 400 million points to check,
    and you’ll be waiting a very long time for your results.
  prefs: []
  type: TYPE_NORMAL
- en: But why check *all* the points? We can sample a smaller number of randomly selected
    lattice points and use those to make a guess about the overall area of the circle.
    [Figure 8-11](ch08.xhtml#ch8fig11) shows how.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg179_Image_223.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 8-11: Sampling random lattice points to determine π*'
  prefs: []
  type: TYPE_NORMAL
- en: 'The variable `tries` controls the `repeat` loop ❶ and determines how many random
    points to check. I recommend setting it to about 10 times the radius of the circle.
    We can confine ourselves to looking only at points in the first quadrant of the
    grid, where the coordinates are positive integers, by picking random `x` and `y`
    values between `0` and `radius` ➋. If the point falls within the circle, we update
    the lattice count as before. With enough tries, we should see the following equivalence:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg179_Image_224.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The left side of this equivalence is the ratio of “hits” (lattice points in
    the circle) to the total number of points sampled. The right side is the ratio
    of one-fourth of the circle’s area (the part of the circle in the first quadrant
    of the grid) to the square of its radius. Think of *r*² here as the area of the
    first-quadrant square containing all the points we can possibly sample. Substituting
    *A* for *πr*² and solving for *π*, we get:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg179_Image_225.jpg)'
  prefs: []
  type: TYPE_IMG
- en: We use this equation at the end of the program to estimate *π*. [Figure 8-12](ch08.xhtml#ch8fig12)
    shows an example result, with a radius of 10,000 and 100,000 randomly sampled
    points.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg180_Image_226.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 8-12: Estimating π through random trials*'
  prefs: []
  type: TYPE_NORMAL
- en: Your output from this program will probably be different every time you run
    it, since the random number generator determines the choice of points to test.
    Still, the result we got here is pretty close, and it’s calculated much more quickly
    than it would have been if the program had checked every single lattice point
    in the circle.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg26_Image_12.jpg) Programming Challenge'
  prefs: []
  type: TYPE_NORMAL
- en: '**8.2**There’s a subtle difference between these two versions of the `pick
    random` block:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg180_Image_227.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Embed each block in a little bit of code that reports the result to see how
    they behave. The version with `1` returns integer values, so asking for values
    between 0 and 1 gives 0 about half the time and 1 about half the time. The version
    with `1.0` returns values between 0 and 1, which aren’t necessarily integers.
    If we don’t have integer (*x, y*) coordinates, then we don’t have true lattice
    points, but does that matter? See if the code in [Figure 8-11](ch08.xhtml#ch8fig11)
    still works if the randomly chosen points don’t have integer coordinates.
  prefs: []
  type: TYPE_NORMAL
- en: Approximating Pi with Relative Primes
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The number *π* shows up in many places in mathematics that seem to be far removed
    from circles and geometry. One interesting formula involving *π* relates back
    to the idea of common divisors from [Chapters 2](ch02.xhtml#ch02) and [3](ch03.xhtml#ch03).
    Remember that a *common divisor* of two integers is a number that’s a divisor
    of each one. If the only common divisor that two integers have is 1, then the
    two integers are said to be *relatively prime*.
  prefs: []
  type: TYPE_NORMAL
- en: Here’s a geometric way to interpret relative primes. Suppose you’re standing
    at the origin of a coordinate plane, at the point (0, 0), looking out at the lattice
    points. You can see most of them, but some are blocked because there’s another
    lattice point in the way. For example, [Figure 8-13](ch08.xhtml#ch8fig13) marks
    the *visible lattice points* in the first quadrant as purple dots. The straight
    black lines show that the point (1, 1) blocks the points (2, 2), (3, 3), and so
    on; the point (2, 1) blocks (4, 2) and (6, 3); and the point (3, 2) blocks (6,
    4).
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg181_Image_228.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 8-13: Visible and hidden lattice points*'
  prefs: []
  type: TYPE_NORMAL
- en: The coordinates of the visible points, such as (1, 1), (7, 2), and (3, 8), are
    relatively prime. The coordinates of blocked points, such as (6, 8) and (2, 4),
    are not. The 8×8 square shown in [Figure 8-13](ch08.xhtml#ch8fig13) has 44 visible
    lattice points in it out of 64 points total, so the proportion that are visible
    is 44 / 64 ≈ 0.6875\. This tells us the proportion of pairs of numbers between
    1 and 8 that are relatively prime.
  prefs: []
  type: TYPE_NORMAL
- en: Now suppose we expand the size of the square. What happens to the number of
    visible lattice points and to the number of relatively prime pairs? Both numbers
    grow, of course, but in a very specific way. As the size of the square grows,
    the proportion of the square’s lattice points that are visible approaches a limiting
    value of about 0.608\. The amazing thing is that this number has a value related
    to *π*. It’s 6/*π*². The reason for this is a little too advanced for this book
    (if you’re interested, it has to do with the Riemann zeta function), but we can
    still explore how the ratio behaves and use it to estimate the value of *π*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Project 32: Using Only Visible Lattice Points'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Let’s write a program that counts the number of visible lattice points within
    a first-quadrant square of a given size and uses that count to calculate an approximation
    of *π*. (We’re using a square here rather than a circle because it’s easier to
    generate the points in a square with nested loops.) Since each visible point’s
    coordinates will be relatively prime, we can use the custom `gcd` (greatest common
    divisor) block we created for [Project 9](ch02.xhtml#ch02lev14) back in [Chapter
    2](ch02.xhtml#ch02) to help (see [Figure 2-17](ch02.xhtml#ch2fig17) on [page 38](ch02.xhtml#page_38)
    for the block definition). If the GCD of a set of coordinates is 1, we’ve found
    a visible lattice point. [Figure 8-14](ch08.xhtml#ch8fig14) shows the code.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg182_Image_229.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 8-14: Approximating π by counting visible lattice points*'
  prefs: []
  type: TYPE_NORMAL
- en: We prompt for a quadrant size, then test all lattice points within the square
    with lower-left corner (`1`, `1`) and upper-right corner (`size`, `size`) using
    nested loops ❶. We start at (1,1) so we’re always calculating GCDs of pairs of
    positive integers. For every visible lattice point whose coordinates yield a GCD
    of `1`, we increment the `count` variable.
  prefs: []
  type: TYPE_NORMAL
- en: 'After the loops are completed, we use the value of `count` to approximate *π*.
    We already know the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg182_Image_230.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Solving for *π*, we get:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg183_Image_231.jpg)'
  prefs: []
  type: TYPE_IMG
- en: We make this calculation at the end of the program ➋.
  prefs: []
  type: TYPE_NORMAL
- en: The Results
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: It’s fun to run this program for a fairly large square, say `size = 1000`, and
    watch Scratch Cat take a few seconds to tally the points as they’re counted. [Figure
    8-15](ch08.xhtml#ch8fig15) shows the results. As before, the larger the sample
    size, the more accurate the approximation is likely to be.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg183_Image_232.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 8-15: Visible lattice points in a square of size 1,000*'
  prefs: []
  type: TYPE_NORMAL
- en: Once again, the value of *π* is accurate for at least the first few decimal
    places.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg26_Image_12.jpg) Programming Challenges'
  prefs: []
  type: TYPE_NORMAL
- en: '**8.3**The series behind the visible lattice point enumeration is:'
  prefs: []
  type: TYPE_NORMAL
- en: '*π*²/6 = 1 + 1/4 + 1/9 + 1/16 + . . . + 1/*n*² + . . .'
  prefs: []
  type: TYPE_NORMAL
- en: 'Use Scratch to check this out by working out the first several partial sums:'
  prefs: []
  type: TYPE_NORMAL
- en: 1, 1 + 1/4, 1 + 1/4 + 1/9, . . .
  prefs: []
  type: TYPE_NORMAL
- en: '**8.4**A formula for *π* involving an infinite series is *π*/4 = 1 – 1/3 +
    1/5 – 1/7 + . . . . This is sometimes called the *Gregory series*. Program Scratch
    to use this formula to get the first few digits of *π*.'
  prefs: []
  type: TYPE_NORMAL
- en: '**8.5**The series in Challenge 8.3 consists of all positive terms, while the
    Gregory series has terms that alternate between positive and negative. Compare
    how many terms of each series it takes to get a value of *π* that’s accurate to
    three decimal places. In general, alternating series converge much more slowly
    than series of positive terms.'
  prefs: []
  type: TYPE_NORMAL
- en: '**8.6**In [Project 31](ch08.xhtml#ch08lev6), we used two versions of the area
    calculation to approximate *π*: one using every point in the square and one sampling
    points at random. Try applying a similar random approach to [Project 32](ch08.xhtml#ch08lev10).
    Examine a random sampling of lattice points, count how many have relatively prime
    coordinates, and use that count to approximate *π*.'
  prefs: []
  type: TYPE_NORMAL
- en: Conclusion
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The number *π* comes up in lots of places in math, which leads to many different
    techniques for calculating its approximate value. Because of the limits of the
    IEEE 754 floating-point representation, Scratch can’t express *π* exactly. But
    then again, neither can we, since the digits of *π* go on forever! With Scratch
    Cat’s help, though, we can easily approximate its value in various ways, with
    up to 15 or 16 digits of accuracy.
  prefs: []
  type: TYPE_NORMAL
