- en: '**9**'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '**9**'
- en: PAINT COLORFUL BUBBLES WITH YOUR MOUSE!
  id: totrans-1
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 用鼠标绘制五颜六色的泡泡！
- en: '![Image](../images/circle.jpg)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/circle.jpg)'
- en: In the next three chapters, we’ll build BubbleDraw, an interactive, animated
    drawing app that lets the user draw floating, bouncy, colorful bubbles with their
    mouse in the desktop version and with their fingers in the mobile version!
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的三章中，我们将构建BubbleDraw，一个交互式的动画绘图应用程序，用户可以在桌面版本中用鼠标绘制漂浮、弹跳的五彩泡泡，在移动版本中用手指绘制！
- en: The first version of the BubbleDraw app will look like [Figure 9-1](ch9.xhtml#ch9fig1),
    with each bubble in a different random color. It will let the user draw bubbles
    of random colors whenever they click and drag the mouse on the app window. The
    user will also be able to change the size of the bubbles by scrolling the mouse
    wheel up and down or by using a scroll gesture on a trackpad or touchscreen.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: BubbleDraw应用程序的第一个版本将如[图 9-1](ch9.xhtml#ch9fig1)所示，每个泡泡都有不同的随机颜色。它将允许用户每次在应用程序窗口中点击并拖动鼠标时绘制随机颜色的泡泡。用户还可以通过上下滚动鼠标滚轮或在触摸板或触摸屏上使用滚动手势来改变泡泡的大小。
- en: '![Image](../images/f0198-01.jpg)'
  id: totrans-5
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/f0198-01.jpg)'
- en: '*Figure 9-1: The BubbleDraw app lets the user draw randomly colored bubbles
    using the mouse.*'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 9-1：BubbleDraw应用程序允许用户使用鼠标绘制随机颜色的泡泡。*'
- en: We’re going to use an object-oriented programming approach to build the BubbleDraw
    app. The variables, functions, loops, and conditional statements you’ve learned
    so far are known as *procedural programming*. Procedural programming involves
    writing programs step-by-step in a linear fashion, sort of like following a recipe.
    Object-oriented programming uses all of these concepts, but it allows us to program
    much larger and more complicated applications by breaking a big software project
    into smaller pieces called *objects*.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用面向对象编程方法来构建BubbleDraw应用程序。到目前为止，你学到的变量、函数、循环和条件语句都属于*过程式编程*。过程式编程是按步骤线性地编写程序，类似于按照食谱做菜。面向对象编程使用了所有这些概念，但它允许我们通过将一个大型软件项目分解成更小的部分（称为*对象*）来编写更大、更复杂的应用程序。
- en: As an example, a bubble is an important entity in the BubbleDraw app, so bubbles
    might become objects as we begin to code this app. First, we’ll tackle the problem
    of defining what a bubble is. Second, we’ll figure out a way to store information
    on lots of bubbles and how to draw the bubbles on the screen. Finally, we’ll add
    the ability to click and drag the mouse to create bubbles. Instead of writing
    separate pieces of code to control each bubble individually, we’ll write one piece
    of code that applies to all bubble objects.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一个示例，泡泡在BubbleDraw应用程序中是一个重要的实体，因此在我们开始编写代码时，泡泡可能会变成对象。首先，我们将解决如何定义泡泡的问题。其次，我们将找出存储大量泡泡信息并在屏幕上绘制泡泡的方法。最后，我们将添加通过点击和拖动鼠标来创建泡泡的功能。我们不会为每个泡泡编写单独的控制代码，而是编写一段适用于所有泡泡对象的代码。
- en: 'We’ll begin with two source code files: one for the app window called *BubbleDraw*
    and one for the drawing canvas called *BubblePanel*. The app window will extend
    a familiar class, `JFrame`, and the drawing canvas inside the window frame will
    use a new kind of GUI container called a `JPanel`. By building two separate files,
    we’ll be able to reuse the drawing canvas in a GUI app in [Chapter 10](ch10.xhtml#ch10).
    Let’s start coding!'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从两个源代码文件开始：一个是用于应用程序窗口的*BubbleDraw*，另一个是用于绘图画布的*BubblePanel*。应用程序窗口将扩展一个熟悉的类`JFrame`，而窗口框架内的绘图画布将使用一种新的GUI容器类型`JPanel`。通过构建两个独立的文件，我们将能够在[第10章](ch10.xhtml#ch10)的GUI应用程序中重用绘图画布。让我们开始编码吧！
- en: Creating the BubbleDraw Project Files
  id: totrans-10
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建BubbleDraw项目文件
- en: In Eclipse, go to **File** ▸ **New** ▸ **Java Project** and create a new project
    folder for the BubbleDraw app. Name the project `BubbleDraw` and click **Finish**.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在Eclipse中，转到**文件** ▸ **新建** ▸ **Java项目**，为BubbleDraw应用程序创建一个新的项目文件夹。将项目命名为`BubbleDraw`并点击**完成**。
- en: Expand the *BubbleDraw* project folder in the Project Explorer pane, right-click
    the *src* folder, and select **New** ▸ **Class**. Create a class called `BubbleDraw`
    for the app window, with `javax.swing.JFrame` as the superclass, and under **Which
    method stubs . . .** select the **public static void main(String[] args)** checkbox.
    Then click **Finish**.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在项目资源管理器面板中展开*BubbleDraw*项目文件夹，右键点击*src*文件夹，选择**新建** ▸ **类**。为应用程序窗口创建一个名为`BubbleDraw`的类，并将`javax.swing.JFrame`作为父类，在**选择方法存根
    . . .**下勾选**public static void main(String[] args)**复选框。然后点击**完成**。
- en: Next, we’ll create the BubblePanel drawing canvas. Right-click the *src* folder
    and select **New** ▸ **Class**. Name this class `BubblePanel`, with a superclass
    of `javax.swing.JPanel`. Click **Finish**.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将创建 `BubblePanel` 绘图画布。右键点击 *src* 文件夹并选择 **新建** ▸ **类**。将该类命名为 `BubblePanel`，并将其父类设置为
    `javax.swing.JPanel`。点击 **完成**。
- en: Using these classes, we’ll create a reusable `BubblePanel` canvas that we can
    expand and put into other apps. The `BubbleDraw` frame will be a container that
    displays the `BubblePanel`.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这些类，我们将创建一个可重用的 `BubblePanel` 画布，可以将其扩展并嵌入到其他应用程序中。`BubbleDraw` 窗体将是一个容器，用于显示
    `BubblePanel`。
- en: Building the BubbleDraw Frame
  id: totrans-15
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 构建 BubbleDraw 窗体
- en: 'Let’s begin by setting up the main app window in the *BubbleDraw.java* source
    code file. Click the *BubbleDraw.java* tab at the top of the content pane in Eclipse,
    and you’ll see the following code has already been filled in:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从设置 *BubbleDraw.java* 源代码文件中的主应用程序窗口开始。点击 Eclipse 内容窗格顶部的 *BubbleDraw.java*
    标签，你将看到以下代码已经填写：
- en: import javax.swing.JFrame;
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: import javax.swing.JFrame;
- en: public class BubbleDraw extends JFrame {
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: public class BubbleDraw extends JFrame {
- en: public static void main(String[] args) {
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: public static void main(String[] args) {
- en: '}'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '}'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: The app window runs in a `JFrame`, like our previous GUI apps did. In this app,
    we need the window to display the drawing canvas, our `BubblePanel`. We won’t
    add any other GUI components to this first version of the app.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序窗口在 `JFrame` 中运行，就像我们之前的 GUI 应用程序一样。在这个应用程序中，我们需要让窗口显示绘图画布，也就是我们的 `BubblePanel`。我们不会在这个应用程序的第一个版本中添加其他
    GUI 组件。
- en: 'We want to create a `JFrame` window and add setup code for the frame as we
    have in previous chapters, but we’ll also add a `BubblePanel` to the frame for
    our drawing canvas. The complete `BubbleDraw` class will look like [Listing 9-1](ch9.xhtml#ch9list1):'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 我们想要创建一个 `JFrame` 窗口，并像前几章一样为窗体添加设置代码，但我们还将向窗体中添加一个 `BubblePanel` 作为我们的绘图画布。完整的
    `BubbleDraw` 类将如下所示 [Listing 9-1](ch9.xhtml#ch9list1)：
- en: import javax.swing.JFrame;
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: import javax.swing.JFrame;
- en: public class BubbleDraw extends JFrame {
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: public class BubbleDraw extends JFrame {
- en: public static void main(String[] args) {
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: public static void main(String[] args) {
- en: ➊ JFrame frame = new JFrame("*Your Name*'s BubbleDraw App");
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: ➊ JFrame frame = new JFrame("*你的名字* 的 BubbleDraw 应用程序");
- en: ➋ frame.setDefaultCloseOperation(JFrame.*EXIT_ON_CLOSE*);
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: ➋ frame.setDefaultCloseOperation(JFrame.*EXIT_ON_CLOSE*);
- en: ➌ frame.getContentPane().add(new BubblePanel());
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: ➌ frame.getContentPane().add(new BubblePanel());
- en: ➍ frame.setSize(new java.awt.Dimension(600,400));
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: ➍ frame.setSize(new java.awt.Dimension(600,400));
- en: ➎ frame.setVisible(true);
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: ➎ frame.setVisible(true);
- en: '}'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '}'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '*Listing 9-1: The BubbleDraw*  *class*'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '*Listing 9-1: The BubbleDraw*  *class*'
- en: Start by creating a new `JFrame` with a title bar at the top ➊. Put your own
    name in the title string. Next, set the default close operation so that the app
    exits when the user closes the window ➋. Then add the code to open a new `BubblePanel`
    drawing canvas as the content inside this frame ➌. The last two lines set the
    size of the window ➍ and make it visible ➎.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 从创建一个带有标题栏的新的 `JFrame` 开始 ➊。在标题字符串中放入你的名字。接下来，设置默认的关闭操作，以便用户关闭窗口时应用程序退出 ➋。然后，添加代码以打开一个新的
    `BubblePanel` 绘图画布，作为此窗体中的内容 ➌。最后两行代码设置窗口的大小 ➍ 并使其可见 ➎。
- en: Save the *BubbleDraw.java* file and run it once. You’ll see a gray Java frame
    with `"`*Your Name*`'s BubbleDraw App"` in the title bar. We’ll build the logic
    for the `BubblePanel` drawing canvas next.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 保存 *BubbleDraw.java* 文件并运行一次。你将看到一个灰色的 Java 窗体，标题栏中显示 `"`*你的名字*` 的 BubbleDraw
    应用程序"`。接下来，我们将构建 `BubblePanel` 绘图画布的逻辑。
- en: Creating a Class for Bubbles
  id: totrans-37
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建一个气泡类
- en: Switch to the tab for the *BubblePanel.java* file. This file will contain all
    the logic for drawing bubbles on the screen. Our first task will be creating a
    `Bubble` class to store each bubble’s color, size, and location on the screen.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 切换到 *BubblePanel.java* 文件的标签页。该文件将包含所有绘制气泡的逻辑。我们的第一个任务是创建一个 `Bubble` 类，用来存储每个气泡的颜色、大小和在屏幕上的位置。
- en: '*Defining a Bubble*'
  id: totrans-39
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*定义一个气泡*'
- en: 'The reason for building a class is quite practical: in the older, procedural
    approach to programming, we would need a separate variable for each bubble’s x-
    and y-coordinates, size, and so on. For example, we’d need a `bubble1x` variable
    for the first bubble’s x-location, as well as `bubble1y`, `bubble1size`, and `bubble1color`
    variables for that bubble. That wouldn’t be so bad, but what if we drag the mouse
    for a few seconds and wind up with a thousand bubbles? We would need 4,000 variables
    just to keep track! Instead, we can use properties inside a class to store those
    values for each bubble.'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 构建类的原因非常实际：在早期的过程式编程方法中，我们需要为每个气泡的 x 和 y 坐标、大小等创建单独的变量。例如，我们需要一个 `bubble1x`
    变量来存储第一个气泡的 x 坐标，还需要 `bubble1y`、`bubble1size` 和 `bubble1color` 变量来存储该气泡的其他信息。这还不算太糟糕，但如果我们拖动鼠标几秒钟后出现了一千个气泡呢？我们就需要
    4000 个变量来追踪它们！而是，我们可以在类中使用属性来存储每个气泡的这些值。
- en: Before we start writing code, let’s define what a bubble is. As shown earlier
    in [Figure 9-1](ch9.xhtml#ch9fig1), a bubble is a colorful, filled circle, and
    bubbles can be different sizes and in different locations.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始编写代码之前，让我们定义一下什么是气泡。如前所示，在[图9-1](ch9.xhtml#ch9fig1)中，气泡是一个五彩斑斓、填充的圆形，气泡可以有不同的大小和位置。
- en: All of those features are attributes of bubbles in this app. In object-oriented
    programming, we use the nouns and adjectives that describe an object to build
    a list of attributes when we create a new class. Attributes are stored as class
    variables.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些特性都是这个应用中气泡的属性。在面向对象编程中，我们使用描述对象的名词和形容词来创建新类时的属性列表。属性存储为类变量。
- en: Besides attributes, a class can also contain methods. A method is a type of
    function associated with a specific class. Methods enable a class to do something.
    Think about what we want the bubbles in the drawing app to do. We need to create
    a bubble whenever the user clicks or drags the mouse. We’ll also draw a bubble
    every time the screen refreshes. The verbs—like *create* and *draw*—will help
    us identify the methods we need in our bubble class.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 除了属性外，类还可以包含方法。方法是与特定类相关的函数类型。方法使类能够执行某些操作。想想我们希望绘图应用中的气泡做什么。每当用户点击或拖动鼠标时，我们需要创建一个气泡。每次屏幕刷新时，我们也需要绘制一个气泡。像*创建*和*绘制*这样的动词将帮助我们确定在气泡类中需要哪些方法。
- en: 'When we capture all of those attributes and methods into a single class, we
    can describe any bubble we might want to show on the screen. This is how a coder
    solves problems with object-oriented programming: by breaking big applications
    into smaller pieces, creating classes by asking questions about what the program
    contains, and then identifying methods and attributes by asking what each object
    of a new class should do and what kind of information it needs.'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们将所有这些属性和方法封装到一个类中时，就可以描述我们想要在屏幕上显示的任何气泡。这就是程序员通过面向对象编程解决问题的方式：通过将大型应用程序拆分为更小的部分，通过提问程序包含了什么来创建类，然后通过询问每个新类的对象应该做什么以及需要什么信息来确定方法和属性。
- en: 'Let’s begin writing the `Bubble` class. We’ll do this inside the `BubblePanel`
    class, as `BubblePanel` is the only place we need to draw bubbles. Start coding
    your `Bubble` class before the closing brace at the end of `BubblePanel`, as follows:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们开始编写 `Bubble` 类。我们将在 `BubblePanel` 类内部进行此操作，因为 `BubblePanel` 是我们唯一需要绘制气泡的地方。在
    `BubblePanel` 结束的右大括号前开始编写 `Bubble` 类，如下所示：
- en: import javax.swing.JPanel;
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: import javax.swing.JPanel;
- en: public class BubblePanel extends JPanel {
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: public class BubblePanel extends JPanel {
- en: private class Bubble {
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: private class Bubble {
- en: '}'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '}'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: We usually make internal and helper classes private to keep other programs from
    accessing them directly. So, to make `Bubble` an internal class accessible only
    from a `BubblePanel`, we declare it as `private`. This technique, called *encapsulation*,
    means that the `BubblePanel` class hides its inner workings from other classes.
    Encapsulation is one of the core principles of object-oriented programming, and
    it’s a best practice worth following because it means we can change the way the
    `Bubble` class works internally and know for certain that we won’t break other
    parts of the code. Since `Bubble` is declared as `private`, we know that there
    isn’t any code outside of the `BubblePanel` class that depends on it. This is
    especially important for bigger applications that contain a large number of classes
    and are worked on by many programmers.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通常将内部类和辅助类设为私有，以防止其他程序直接访问它们。因此，为了使`Bubble`成为只能从`BubblePanel`访问的内部类，我们将其声明为`private`。这种称为*封装*的技术意味着`BubblePanel`类对其内部工作原理对其他类隐藏。封装是面向对象编程的核心原则之一，并且是一种值得遵循的最佳实践，因为它意味着我们可以更改`Bubble`类在内部的工作方式，并且可以确定我们不会破坏代码的其他部分。由于`Bubble`被声明为`private`，因此我们知道`BubblePanel`类之外没有任何代码依赖于它。这对于包含大量类并由许多程序员处理的较大型应用程序尤其重要。
- en: '`BubblePanel` will rely on the `Bubble` class to store information on individual
    bubbles as the user draws on the screen. A bubble has an (x, y) location on the
    screen, a size, and a color, so we can make these attributes as variables inside
    `Bubble`. The x- and y-coordinates of the bubble’s location and the size of the
    bubble can all be stored as integer values:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '`BubblePanel`将依赖`Bubble`类来存储用户在屏幕上绘制的各个气泡的信息。一个气泡在屏幕上有一个 (x, y) 位置、一个大小和一个颜色，因此我们可以将这些属性作为`Bubble`内部的变量。气泡位置的
    x 和 y 坐标以及气泡的大小都可以存储为整数值：'
- en: import javax.swing.JPanel;
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: import javax.swing.JPanel;
- en: public class BubblePanel extends JPanel {
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: public class BubblePanel extends JPanel {
- en: private class Bubble {
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: private class Bubble {
- en: private int x;
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: private int x;
- en: private int y;
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: private int y;
- en: private int size;
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: private int size;
- en: '}'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '}'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: Here we make two separate variables called `x` and `y` to store the bubble’s
    coordinates, as well as a `size` variable. These attributes are `private`, so
    only the `Bubble` class itself can change those values directly. We encapsulate
    all the data a bubble should have inside the `Bubble` class, and we interact with
    bubbles using the methods in that class only.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们创建了两个单独的变量，分别称为`x`和`y`，用于存储气泡的坐标，以及一个`size`变量。这些属性是`private`，因此只有`Bubble`类本身才能直接更改这些值。我们将气泡应具有的所有数据封装在`Bubble`类中，并且仅使用该类中的方法与气泡进行交互。
- en: 'As mentioned earlier, each bubble in our app can have its own color. The `java.awt`
    library has a `Color` class that handles *RGB* (*red-green-blue*) color values
    to reproduce any color that we can display on our monitor. We’ll talk a bit more
    about RGB when we actually write the code to control bubble colors later in the
    chapter, so for now just import the `java.awt.Color` class at the top of the file
    and add an attribute called `color` to the `Bubble` class, like so:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，我们的应用程序中的每个气泡都可以有自己的颜色。`java.awt`库有一个`Color`类，用于处理 *RGB* (*红-绿-蓝*) 颜色值，以重现我们可以在显示器上显示的任何颜色。当我们实际编写代码来控制气泡颜色时，我们将在本章后面详细讨论
    RGB，因此现在只需在文件顶部导入`java.awt.Color`类，并将一个名为`color`的属性添加到`Bubble`类，如下所示：
- en: import java.awt.Color;
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: import java.awt.Color;
- en: import javax.swing.JPanel;
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: import javax.swing.JPanel;
- en: public class BubblePanel extends JPanel {
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: public class BubblePanel extends JPanel {
- en: private class Bubble {
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: private class Bubble {
- en: private int x;
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: private int x;
- en: private int y;
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: private int y;
- en: private int size;
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: private int size;
- en: private Color color;
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: private Color color;
- en: '}'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '}'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: Now that we’ve added the four attributes we want each bubble to have (`x`, `y`,
    `size`, and `color`), we can start building the behaviors, or functions, of a
    bubble to give values to these attributes. We’ll do that by adding methods inside
    the `Bubble` class.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经添加了我们希望每个气泡都具有的四个属性（`x`、`y`、`size`和`color`），我们可以开始构建气泡的行为或函数，以赋予这些属性值。我们将通过在`Bubble`类中添加方法来实现这一点。
- en: '*Designing a Bubble’s Methods*'
  id: totrans-74
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*设计气泡的方法*'
- en: 'The `Bubble` class will have two actions, which we’ll turn into methods: creating
    a bubble and drawing a bubble on the desktop screen.'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '`Bubble`类将具有两个动作，我们将把它们变成方法：创建一个气泡并在桌面屏幕上绘制一个气泡。'
- en: 'Methods that create objects have a special name: *constructors*. A constructor
    sets up an object by assigning values to the object’s attributes. When we assign
    values to the attributes inside a constructor, we’re *initializing* them. For
    the `Bubble` class, we want to initialize the `x`, `y`, `size`, and `color` attributes
    of an individual bubble.'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 创建对象的方法有一个特殊的名称：*构造方法*。构造方法通过为对象的属性赋值来设置对象。当我们在构造方法内为属性赋值时，我们是在*初始化*它们。对于`Bubble`类，我们希望初始化每个气泡的`x`、`y`、`size`和`color`属性。
- en: Building the Constructor
  id: totrans-77
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 构造方法的构建
- en: A constructor method begins with the keyword `public`, followed by the name
    of the class and a pair of parentheses. If there are any parameters you want to
    pass in as you set up an object, you place those inside the parentheses. We want
    to assign each bubble its `x`, `y`, and `size` values when it is created, so the
    constructor for the `Bubble` class looks like [Listing 9-2](ch9.xhtml#ch9list2).
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 构造方法以关键字`public`开头，后跟类名和一对圆括号。如果你想在创建对象时传递任何参数，可以将它们放在圆括号内。我们希望在创建每个气泡时为其分配`x`、`y`和`size`值，因此`Bubble`类的构造方法如下所示：[Listing
    9-2](ch9.xhtml#ch9list2)。
- en: private class Bubble {
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: private class Bubble {
- en: private int x;
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: private int x;
- en: private int y;
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: private int y;
- en: private int size;
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: private int size;
- en: private Color color;
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: private Color color;
- en: ➊ public Bubble(int newX, int newY, int newSize) {
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: ➊ public Bubble(int newX, int newY, int newSize) {
- en: ➋ x = newX;
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: ➋ x = newX;
- en: ➌ y = newY;
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: ➌ y = newY;
- en: ➍ size = newSize;
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: ➍ size = newSize;
- en: '}'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '}'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '*Listing 9-2: The Bubble class constructor*'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '*Listing 9-2: 气泡类的构造方法*'
- en: Each bubble’s coordinates and size will be determined by the user, so we want
    to pass the x- and y-coordinates and a size as integer values to the `Bubble()`
    constructor as each new bubble is created. These values are the three parameters
    we pass to the `Bubble()` method and are called `newX`, `newY`, and `newSize`
    ➊. Later in the code, when we handle the user creating bubbles, we’ll be outside
    the private `Bubble` class. That means we won’t have direct access to the bubble’s
    attributes, so we can’t just assign values to the `x`, `y`, and `size` attributes
    of each bubble. In order to get around that, we assign the attributes values through
    the `Bubble()` constructor, which takes the input from the user; assigns the input
    values to `newX`, `newY`, and `newSize`; and then assigns the user input values
    to the bubble’s attributes at ➋, ➌, and ➍.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 每个气泡的坐标和大小将由用户确定，因此我们希望将x和y坐标以及大小作为整数值传递给`Bubble()`构造方法，在创建每个新的气泡时。这些值是我们传递给`Bubble()`方法的三个参数，分别称为`newX`、`newY`和`newSize`
    ➊。稍后在代码中，当我们处理用户创建气泡时，我们将处于`Bubble`类外部。那意味着我们无法直接访问气泡的属性，因此不能直接为每个气泡的`x`、`y`和`size`属性赋值。为了解决这个问题，我们通过`Bubble()`构造方法为属性赋值，该构造方法接收来自用户的输入，将输入值赋给`newX`、`newY`和`newSize`，然后在➋、➌和➍处将用户输入的值赋给气泡的属性。
- en: We also want each bubble to have a random color. Because the color will be random,
    we don’t need to pass it to the constructor using a parameter. Instead, we can
    create the color inside the constructor.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还希望每个气泡都有一个随机的颜色。由于颜色是随机的，我们不需要通过参数将其传递给构造方法。相反，我们可以在构造方法内部创建颜色。
- en: We’ll need to generate random RGB color values to create a color for each bubble.
    RGB works by combining different amounts of red, green, and blue light on your
    computer monitor to produce different colors. In programming, each of these three
    colors is represented by an integer between 0 (none of the color) and 255 (the
    maximum amount of the color possible). To make a color, we need to get three integers
    between 0 and 255, separate them with commas, and group them together between
    parentheses. For example, pure red has an RGB value of (255, 0, 0), meaning full
    red, no green, and no blue. Yellow is (255, 255, 0) in RGB, meaning full amounts
    of red and green, but no blue. In total, there are over 16 million RGB color values
    that can be created this way.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要生成随机的RGB颜色值，为每个气泡创建颜色。RGB的工作原理是通过在计算机显示器上混合不同量的红、绿和蓝光来生成不同的颜色。在编程中，这三种颜色的每一种都由一个介于0（无颜色）和255（最大颜色量）之间的整数表示。为了创建颜色，我们需要得到三个介于0到255之间的整数，用逗号分隔，并将它们放在圆括号内。例如，纯红色的RGB值是(255,
    0, 0)，意味着红色满量，没有绿色和蓝色。黄色的RGB值是(255, 255, 0)，意味着红色和绿色满量，没有蓝色。总共有超过1600万种RGB颜色值可以通过这种方式创建。
- en: We’ve generated random numbers with the `Math` class’s `Math.random()` method
    before when we needed a single number, but in the BubbleDraw app, we’ll need three
    random numbers (one for each part of RGB), so let’s look at a new way to generate
    random values.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前在需要生成一个单一数值时，使用过`Math`类的`Math.random()`方法来生成随机数，但在BubbleDraw应用中，我们需要生成三个随机数（分别对应RGB的每个部分），所以我们来看一种新的生成随机值的方式。
- en: 'The `java.util.Random` class contains several useful methods, including `nextInt()`,
    which will let us instantly generate a random integer up to a certain size without
    having to do additional math or rounding. To use the `Random` class, we’ll have
    to import it first, at the top of the *BubblePanel.java* file:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '`java.util.Random`类包含几个有用的方法，包括`nextInt()`，它可以让我们瞬间生成一个随机整数，且大小不超过指定的上限，无需做额外的数学运算或四舍五入。要使用`Random`类，我们首先需要在*BubblePanel.java*文件的顶部导入它：'
- en: import java.util.Random;
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: import java.util.Random;
- en: import java.awt.Color;
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: import java.awt.Color;
- en: import javax.swing.JPanel;
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: import javax.swing.JPanel;
- en: 'Because `Random` is a class, we need to create a new object or variable of
    the `Random` type to access its functions. Add the following line inside the top
    of the `BubblePanel` class:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 因为`Random`是一个类，我们需要创建一个新的`Random`类型的对象或变量来访问它的功能。请在`BubblePanel`类的顶部添加以下行：
- en: import java.util.Random;
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: import java.util.Random;
- en: import java.awt.Color;
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: import java.awt.Color;
- en: import javax.swing.JPanel;
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: import javax.swing.JPanel;
- en: public class BubblePanel extends JPanel {
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: public class BubblePanel extends JPanel {
- en: Random rand = new Random();
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: Random rand = new Random();
- en: private class Bubble {
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: private class Bubble {
- en: This line creates a random number generator called `rand` that will allow us
    to generate random integer or floating-point values quickly. We’re encapsulating
    `rand` by putting it at the top of the `BubblePanel` class so that we can generate
    random numbers both in the drawing window and in the inner `Bubble` class, but
    not outside a `BubblePanel`.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 这一行创建了一个名为`rand`的随机数生成器，它将允许我们快速生成随机的整数或浮动值。我们将`rand`封装在`BubblePanel`类的顶部，这样我们就可以在绘图窗口和内部的`Bubble`类中生成随机数，但不能在`BubblePanel`外部使用它。
- en: To create a random color in Java, we can use the constructor for the `java.awt.Color`
    class that we imported earlier. The constructor will accept three integer arguments
    between `0` and `255` for the red, green, and blue values to create a color.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 要在Java中创建一个随机颜色，我们可以使用之前导入的`java.awt.Color`类的构造函数。该构造函数接受三个整数参数，范围是`0`到`255`，分别表示红、绿、蓝三个值，以创建一个颜色。
- en: 'Add the following code to the `Bubble()` constructor method:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 在`Bubble()`构造方法中添加以下代码：
- en: public Bubble(int newX, int newY, int newSize) {
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: public Bubble(int newX, int newY, int newSize) {
- en: x = newX;
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: x = newX;
- en: y = newY;
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: y = newY;
- en: size = newSize;
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: size = newSize;
- en: color = new Color( rand.nextInt(256),
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: color = new Color( rand.nextInt(256),
- en: rand.nextInt(256),
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: rand.nextInt(256),
- en: rand.nextInt(256) );
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: rand.nextInt(256) );
- en: '}'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: We use the `new` keyword with the constructor for the `Color` class to create
    a new color, and each of the RGB color values will be a randomly generated integer
    between `0` and `255`. Every time you call the `nextInt()` method, it generates
    a new random integer between 0 and the maximum integer you pass it. Here, we want
    random color values from `0` to `255`, so we pass it `256` because `nextInt()`
    generates an integer up to, but not including, the upper bound passed to it.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`new`关键字和`Color`类的构造函数来创建一个新的颜色，每个RGB颜色值将是一个在`0`和`255`之间随机生成的整数。每次调用`nextInt()`方法时，它会生成一个介于`0`和你传入的最大整数之间的新随机整数。在这里，我们希望获得从`0`到`255`的随机颜色值，因此我们传入`256`，因为`nextInt()`生成的整数小于但不包括传入的上限。
- en: Coding the Method to Draw a Bubble
  id: totrans-118
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 编写绘制气泡的方法
- en: 'Now that each bubble has an (x, y) location, a size, and a random color, let’s
    add the ability to draw bubbles on the screen. To draw colorful graphics on the
    screen, we’ll import the `java.awt.Graphics` class. This `Graphics` class contains
    methods such as `setColor()` to choose a paint color, `drawRect()` to draw a rectangle,
    and `fillOval()` to paint a filled-in oval on the screen, just to name a few.
    We’ll use `fillOval()` to draw our circles, so add the following `import` statement
    to the top of the *BubblePanel.java* file:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 现在每个气泡都有了一个(x, y)位置、大小和随机颜色，让我们添加在屏幕上绘制气泡的功能。为了在屏幕上绘制彩色图形，我们将导入`java.awt.Graphics`类。该`Graphics`类包含像`setColor()`（选择绘画颜色）、`drawRect()`（绘制矩形）和`fillOval()`（在屏幕上绘制填充椭圆）等方法。我们将使用`fillOval()`来绘制圆形，因此请在*BubblePanel.java*文件的顶部添加以下`import`语句：
- en: import java.awt.Graphics;
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: import java.awt.Graphics;
- en: import java.util.Random;
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: import java.util.Random;
- en: import java.awt.Color;
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: import java.awt.Color;
- en: import javax.swing.JPanel;
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: import javax.swing.JPanel;
- en: 'Next, let’s add a `draw()` method to the `Bubble` inner class, below the `Bubble()`
    constructor:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们在`Bubble`内部类中添加一个`draw()`方法，位于`Bubble()`构造函数下方：
- en: private class Bubble {
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: private class Bubble {
- en: private int x;
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: private int x;
- en: private int y;
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: private int y;
- en: private int size;
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: private int size;
- en: private Color color;
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: private Color color;
- en: public Bubble(int newX, int newY, int newSize) {
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: public Bubble(int newX, int newY, int newSize) {
- en: --snip--
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: --省略--
- en: '}'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: public void draw(Graphics canvas) {
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: public void draw(Graphics canvas) {
- en: ➊ canvas.setColor(color);
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: ➊ canvas.setColor(color);
- en: ➋ canvas.fillOval(x - size/2, y - size/2, size, size);
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: ➋ canvas.fillOval(x - size/2, y - size/2, size, size);
- en: '}'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '}'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: The `draw()` method accepts one parameter, a `Graphics` canvas called `canvas`.
    Inside the `draw()` method, we call the `setColor()` method on `canvas` ➊ to set
    the drawing color to the color stored in the `color` variable of the bubble we’ll
    draw. At ➋, we call `fillOval()` to paint a filled-in circle on the screen. The
    `fillOval()` method takes four parameters, the x- and y-coordinate of the upper-left
    corner of a bounding box in which we’ll draw the oval, followed by the width and
    height of the box. Think of the bounding box as an invisible rectangle at that
    (x, y) location with the given width and height and the oval as a balloon that
    will be blown up until it touches all four sides of the box (see [Figure 9-2](ch9.xhtml#ch9fig2)).
    By setting the same width and height for the box to make it square, we’ll end
    up with a circle instead of an oval.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '`draw()`方法接受一个参数，即一个名为`canvas`的`Graphics`画布。在`draw()`方法内部，我们首先调用`canvas`上的`setColor()`方法➊，将绘图颜色设置为我们将要绘制的气泡的`color`变量中的颜色。在➋处，我们调用`fillOval()`方法，将一个填充的圆形绘制到屏幕上。`fillOval()`方法接受四个参数，第一个和第二个参数是我们将在其中绘制椭圆的边界框的左上角的x和y坐标，接着是该框的宽度和高度。可以将边界框看作是一个在(x,
    y)位置的不可见矩形，给定宽度和高度，而椭圆则像一个气球，会膨胀直到触及框的四个边（见[图 9-2](ch9.xhtml#ch9fig2)）。通过设置相同的宽度和高度，使得框成为正方形，我们最终得到的是一个圆形，而不是椭圆。'
- en: Because our ovals are actually circles, the width and height are the same value—the
    size of the bubble in pixels we stored in the `size` attribute. At ➋, we want
    the bubble to be centered on the (x, y) location the user clicked, so we adjust
    the upper-left corner of each bubble by subtracting half the size (`size/2`) from
    each of the `x` and `y` values.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们的椭圆实际上是圆形的，宽度和高度是相同的数值——我们在`size`属性中存储的气泡的像素大小。在➋，我们希望气泡位于用户点击的(x, y)位置的中心，因此我们通过从`x`和`y`的值中减去一半的大小(`size/2`)来调整每个气泡的左上角位置。
- en: '![Image](../images/f0205-01.jpg)'
  id: totrans-140
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/f0205-01.jpg)'
- en: '*Figure 9-2: The fillOval() method takes four parameters, the upper-left corner’s
    xand y-coordinates, followed by the oval’s width and height.*'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 9-2：`fillOval()`方法接受四个参数，第一个是左上角的x和y坐标，接下来是椭圆的宽度和高度。*'
- en: With the addition of the `draw()` method, we now have a complete `Bubble` class
    that can remember the location, size, and color of a bubble. The class methods
    we made can be used to create new bubbles and draw them on the screen. It’s time
    to add logic to the `BubblePanel` class to use those methods to create and draw
    bubbles whenever the user clicks and drags on the screen.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 随着`draw()`方法的添加，我们现在有了一个完整的`Bubble`类，它可以记住气泡的位置、大小和颜色。我们所做的类方法可以用来创建新的气泡并将它们绘制到屏幕上。接下来，我们需要在`BubblePanel`类中添加逻辑，利用这些方法在用户点击和拖动屏幕时创建和绘制气泡。
- en: Storing Bubbles in an ArrayList
  id: totrans-143
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在`ArrayList`中存储气泡
- en: We need a way to store all the bubbles the user creates when they click and
    drag around the screen. Java’s libraries contain several useful *data structures*,
    which are classes for storing groups of objects.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要一种方式来存储用户在屏幕上点击和拖动时创建的所有气泡。Java的库中包含了几种有用的*数据结构*，它们是用于存储对象集合的类。
- en: The `java.util.ArrayList` is a *dynamic* data structure. That means it not only
    stores a collection of objects but can also grow or shrink depending on the needs
    of the program. For the BubbleDraw app, we can’t predict how many bubbles the
    user will draw, so a dynamic data structure like an `ArrayList` is the perfect
    option for storing all the bubbles a user could create. An `ArrayList` is a flexible
    way to store things when you don’t know how many items you’ll need in advance.
    A regular array in Java has a fixed size, but an `ArrayList` can keep adding new
    bubbles every time the user clicks.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '`java.util.ArrayList`是一个*动态*数据结构。这意味着它不仅存储对象集合，还可以根据程序的需要动态地增长或缩小。对于BubbleDraw应用程序，我们无法预测用户会绘制多少个气泡，因此像`ArrayList`这样的动态数据结构是存储用户可能创建的所有气泡的完美选择。当你不知道会需要多少个项目时，`ArrayList`是一种灵活的存储方式。Java中的常规数组具有固定的大小，但`ArrayList`可以在每次用户点击时不断添加新的气泡。'
- en: 'First, let’s import `java.util.ArrayList` at the top of the *BubblePanel.java*
    file so we can access `ArrayList` data types:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，在*BubblePanel.java*文件顶部导入`java.util.ArrayList`，以便我们可以访问`ArrayList`数据类型：
- en: import java.util.ArrayList;
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: import java.util.ArrayList;
- en: import java.awt.Graphics;
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: import java.awt.Graphics;
- en: import java.util.Random;
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: import java.util.Random;
- en: import java.awt.Color;
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: import java.awt.Color;
- en: import javax.swing.JPanel;
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: import javax.swing.JPanel;
- en: 'Next, we need to declare an `ArrayList` that will hold objects of the `Bubble`
    class. Inside the `BubblePanel` class, add the following declaration:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要声明一个`ArrayList`，用于存储`Bubble`类的对象。在`BubblePanel`类中，添加以下声明：
- en: public class BubblePanel extends JPanel {
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: public class BubblePanel extends JPanel {
- en: Random rand = new Random();
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: Random rand = new Random();
- en: ArrayList<Bubble> bubbleList;
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: ArrayList<Bubble> bubbleList;
- en: The `ArrayList` data structure can accept a type specifier inside the angle
    brackets, `<` and `>`, to tell Java what type of objects the `ArrayList` will
    hold. An `ArrayList` can hold any type of object, but the `ArrayList` we’re declaring,
    `bubbleList`, will contain only objects of the `Bubble` class.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: '`ArrayList`数据结构可以接受一个类型说明符，放在尖括号`<`和`>`之间，告诉Java该`ArrayList`将包含哪种类型的对象。`ArrayList`可以容纳任何类型的对象，但我们声明的`bubbleList`将只包含`Bubble`类的对象。'
- en: 'Next, let’s take care of one additional variable, `size`, for the default bubble
    size:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们处理一个额外的变量`size`，用于设置默认的气泡大小：
- en: public class BubblePanel extends JPanel {
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: public class BubblePanel extends JPanel {
- en: Random rand = new Random();
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: Random rand = new Random();
- en: ArrayList<Bubble> bubbleList;
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: ArrayList<Bubble> bubbleList;
- en: int size = 25;
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: int size = 25;
- en: This `size` variable sets a starting size for bubble diameters in pixels. I
    picked `25` pixels, but you can choose a larger or smaller starting size if you’d
    like.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 这个`size`变量设置了气泡直径的初始大小，单位是像素。我选择了`25`像素，但如果你愿意，也可以选择更大或更小的初始大小。
- en: '*Adding a Constructor to the BubblePanel Class*'
  id: totrans-163
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*为BubblePanel类添加构造函数*'
- en: We’ve declared `bubbleList` to be a dynamic `ArrayList` of `Bubble` objects,
    so let’s add a constructor to the `BubblePanel` class to initialize `bubbleList`
    and set the background color of the drawing window.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已将`bubbleList`声明为一个动态的`ArrayList`，它存储`Bubble`对象。因此，让我们为`BubblePanel`类添加一个构造函数，来初始化`bubbleList`并设置绘图窗口的背景颜色。
- en: 'Just as we saw in the `Bubble` inner class, the constructor for the `BubblePanel`
    class uses the format `public` plus the name of the class, followed by a pair
    of parentheses:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 就像我们在`Bubble`内部类中看到的那样，`BubblePanel`类的构造函数采用`public`加上类名，然后是一对圆括号的格式：
- en: public class BubblePanel extends JPanel {
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: public class BubblePanel extends JPanel {
- en: Random rand = new Random();
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: Random rand = new Random();
- en: ArrayList<Bubble> bubbleList;
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: ArrayList<Bubble> bubbleList;
- en: int size = 25;
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: int size = 25;
- en: public BubblePanel() {
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: public BubblePanel() {
- en: '}'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: 'Notice that we end the constructor with open and close parentheses, because
    the constructor is a method. Inside the constructor, we initialize `bubbleList`
    to get it ready to store a flexible `ArrayList` of `Bubble` objects. We also set
    the background color of the drawing window to black:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们以开括号和闭括号结束构造函数，因为构造函数是一个方法。在构造函数内部，我们初始化`bubbleList`，以便它准备好存储一个灵活的`ArrayList`类型的`Bubble`对象。我们还将绘图窗口的背景颜色设置为黑色：
- en: public BubblePanel() {
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: public BubblePanel() {
- en: ➊ bubbleList = new ArrayList<Bubble>();
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: ➊ bubbleList = new ArrayList<Bubble>();
- en: ➋ setBackground(Color.BLACK);
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: ➋ setBackground(Color.BLACK);
- en: '}'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '**NOTE**'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*Although I recommend a black background for the app, the images in this book
    show a white background for readability.*'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: '*尽管我推荐为应用程序设置黑色背景，但本书中的图片为了可读性显示了白色背景。*'
- en: 'Just as in the declaration of `bubbleList`, when we construct a new `ArrayList`
    at ➊, we can specify the type of object we want to store in angle brackets: `<Bubble>`.'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 就像在声明`bubbleList`时一样，当我们在➊创建一个新的`ArrayList`时，我们可以通过尖括号`<Bubble>`来指定我们希望存储的对象类型。
- en: At ➋, we can use the `setBackground()` method directly because `BubblePanel`
    is extending `JPanel`, and we’ve seen that `JPanel` objects have a background
    color. We’re setting the background to the color constant `Color.BLACK` from the
    `Color` class we imported earlier. This constant has an RGB value of (0, 0, 0).
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 在➋处，我们可以直接使用`setBackground()`方法，因为`BubblePanel`类继承自`JPanel`，而我们已经看到`JPanel`对象具有背景颜色。我们将背景设置为先前导入的`Color`类中的常量`Color.BLACK`。此常量的RGB值为(0,
    0, 0)。
- en: Now, when we start the BubbleDraw app and create a `BubblePanel` drawing canvas,
    we’ll begin with an empty list of bubbles and a black screen background.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当我们启动BubbleDraw应用程序并创建一个`BubblePanel`绘图画布时，我们将从一个空的气泡列表和一个黑色背景的屏幕开始。
- en: Save your changes so far. In the next section, we’ll fill that window with colorful
    bubbles!
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 保存到目前为止的更改。在下一节中，我们将用五颜六色的气泡填充窗口！
- en: '*Adding a Method to Draw on the Screen*'
  id: totrans-183
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*在屏幕上绘制的方法*'
- en: Next, we need to add a method to paint all the bubbles in `bubbleList` to the
    drawing screen.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要添加一个方法来将`bubbleList`中的所有气泡绘制到画布上。
- en: All of the GUI components in the `javax.swing` toolkit, including the `JPanel`
    we extended for the `BubblePanel` drawing screen, have a `paintComponent()` method
    that draws that component on the screen. We’re going to modify, or *override*,
    the default `paintComponent()` method to make the `BubblePanel` draw all the bubbles
    in `bubbleList`.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: '`javax.swing`工具包中的所有GUI组件，包括我们为`BubblePanel`绘图屏幕扩展的`JPanel`，都有一个`paintComponent()`方法，用来将该组件绘制到屏幕上。我们将修改，或称为*重写*，默认的`paintComponent()`方法，以使`BubblePanel`绘制`bubbleList`中的所有气泡。'
- en: 'First, we need to declare the `paintComponent()` method. Because we’re overriding
    the `paintComponent()` method that already exists in `JPanel`, the parent class
    of `BubblePanel`, we have to use the same *method signature*, or first line of
    code. That means we have to match the way `paintComponent()` is declared exactly,
    as a `public void` method, with one parameter, of type `Graphics`:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要声明`paintComponent()`方法。因为我们正在重写`JPanel`中已经存在的`paintComponent()`方法，而`JPanel`是`BubblePanel`的父类，所以我们必须使用相同的*方法签名*，即第一行代码。这意味着我们必须完全匹配`paintComponent()`的声明方式，它是一个`public
    void`方法，带有一个`Graphics`类型的参数：
- en: public class BubblePanel extends JPanel {
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: public class BubblePanel extends JPanel {
- en: --snip--
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: --snip--
- en: '}'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: public void paintComponent(Graphics canvas) {
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: public void paintComponent(Graphics canvas) {
- en: '}'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: We place the `paintComponent()` method just below the `BubblePanel()` constructor.
    Notice that `paintComponent()` requires a `Graphics` object, which we call `canvas`
    just as in the `draw()` method we designed for the `Bubble` class. Any object
    that draws on the screen can use a `Graphics` object to color the individual pixels
    on the computer screen.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将`paintComponent()`方法放在`BubblePanel()`构造函数的下方。请注意，`paintComponent()`需要一个`Graphics`对象，我们称之为`canvas`，就像我们为`Bubble`类设计的`draw()`方法一样。任何在屏幕上绘制的对象都可以使用`Graphics`对象来为计算机屏幕上的每个像素上色。
- en: 'Inside this method, we first want to allow the `JPanel` parent class to clear
    the drawing screen and do any other setup it normally would before drawing anything
    else. We do this by calling `paintComponent()` from the parent class:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个方法内部，我们首先希望允许`JPanel`父类清除绘图屏幕并执行它通常会做的其他设置，之后再绘制任何内容。我们通过调用父类的`paintComponent()`方法来实现：
- en: public void paintComponent(Graphics canvas) {
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: public void paintComponent(Graphics canvas) {
- en: super.paintComponent(canvas);
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: super.paintComponent(canvas);
- en: '}'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: 'The keyword `super` tells Java to call the original `paintComponent()` method
    from `JPanel`. This means that all the code in the original `paintComponent()`
    method will be pulled into our new one. This is a useful object-oriented programming
    feature: because we extended the `JPanel` class to create the new `BubblePanel`
    class, we can take advantage of all the functionality already built into `JPanel`,
    such as clearing the pixels inside the window when the app opens and preparing
    the `Graphics` canvas for drawing colorful graphics. We say that `BubblePanel`
    *inherits* these functions from `JPanel`.'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 关键词`super`告诉Java调用`JPanel`中的原始`paintComponent()`方法。这意味着原始`paintComponent()`方法中的所有代码都会被引入到我们的新方法中。这是一个有用的面向对象编程特性：因为我们扩展了`JPanel`类来创建新的`BubblePanel`类，所以我们可以利用已经内置在`JPanel`中的所有功能，例如在应用程序启动时清除窗口内的像素，以及为绘制彩色图形准备`Graphics`画布。我们说`BubblePanel`
    *继承*了这些功能来自`JPanel`。
- en: Once we’ve prepared the canvas, it’s time to loop through the list of bubbles
    and draw each one on `canvas`. To accomplish this, we’ll use a `for` loop in a
    new way.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们准备好画布，就该循环遍历气泡列表，并在`canvas`上绘制每一个气泡。为此，我们将以一种新的方式使用`for`循环。
- en: You first saw a `for` loop in [Chapter 6](ch6.xhtml#ch6), when we wanted to
    loop through each character in a string to encode secret messages. This time,
    we’re using a shorter version of a `for` loop, called a `for each` statement,
    that’s specially designed to loop through a list or collection of objects.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 你第一次看到`for`循环是在[第6章](ch6.xhtml#ch6)，当时我们想要循环遍历字符串中的每个字符来编码秘密消息。这次，我们使用的是`for`循环的简短版本，叫做`for
    each`语句，它特别设计用于循环遍历列表或对象集合。
- en: 'Let’s see the working code first, and then I’ll break down the `for each` statement
    piece by piece:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先看看完整的代码，然后我将逐步讲解`for each`语句：
- en: public void paintComponent(Graphics canvas) {
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: public void paintComponent(Graphics canvas) {
- en: super.paintComponent(canvas);
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: super.paintComponent(canvas);
- en: '➊ for(Bubble b : bubbleList) {'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: '➊ for(Bubble b : bubbleList) {'
- en: ➋ b.draw(canvas);
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: ➋ b.draw(canvas);
- en: '}'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '}'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: 'You can read the `for each` statement at ➊ as “For each `Bubble` `b` in `bubbleList`.”
    You can tell this is a `for each` statement instead of a regular `for` loop, first
    because of the colon in the middle and, second, because it doesn’t have the three
    parts we saw in `for` loops back in [Chapter 6](ch6.xhtml#ch6): *initialization,
    condition*, and *update*. Java uses the same keyword `for` and parentheses for
    both loops, but the `for each` statement is designed just for collections of objects,
    such as arrays, `ArrayList`s, and so on.'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以将➊处的`for each`语句理解为“对于`bubbleList`中的每个`Bubble` `b`。”你可以通过两点判断这是一个`for each`语句，而不是普通的`for`循环，首先是因为中间有冒号，其次是因为它没有我们在[第6章](ch6.xhtml#ch6)看到的`for`循环的三个部分：*初始化，条件*，和*更新*。Java对这两种循环使用相同的关键字`for`和括号，但`for
    each`语句专门为对象集合（如数组、`ArrayList`等）设计。
- en: For each `Bubble` `b` in the `ArrayList` `bubbleList`, the loop will call `b.draw(canvas)`
    ➋ to draw that individual bubble on the drawing screen. The first time the loop
    executes, `b` will point to the first `Bubble` object in `bubbleList`, and each
    time the loop repeats, `b` will point to the next bubble in the list. Calling
    `b.draw(canvas)` tells that bubble to draw itself on the `canvas`.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 对于`ArrayList` `bubbleList`中的每个`Bubble` `b`，循环将调用`b.draw(canvas)` ➋，在绘图屏幕上绘制该单个气泡。第一次执行循环时，`b`将指向`bubbleList`中的第一个`Bubble`对象，每次循环重复时，`b`将指向列表中的下一个气泡。调用`b.draw(canvas)`会告诉该气泡在`canvas`上绘制自己。
- en: This single, short `for each` loop will draw every bubble in the `bubbleList`
    to the screen. The only problem is that we don’t have any bubbles to test. Let’s
    generate some random bubbles to see the app in action before we move on to creating
    bubbles with the mouse.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 这个单一的短`for each`循环将把`bubbleList`中的每个气泡绘制到屏幕上。唯一的问题是我们没有任何气泡可以测试。让我们生成一些随机气泡，在继续创建鼠标交互之前先查看应用程序的实际效果。
- en: '*Testing the BubblePanel Class*'
  id: totrans-210
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*测试BubblePanel类*'
- en: To test what we’ve done so far, before we add the mouse interaction, we’ll write
    a test method that draws 100 bubbles of random sizes all over the app window.
    This will allow us to make sure the app works without writing the final code.
    This way we can debug any errors in our code early and see a preview of how cool
    the app will look when it’s finished.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 为了测试到目前为止我们所做的工作，在添加鼠标交互之前，我们将编写一个测试方法，在应用程序窗口中绘制100个随机大小的气泡。这将使我们能够确保应用程序正常工作，而无需编写最终的代码。这样，我们可以及早调试代码中的任何错误，并预览应用程序完成后的酷炫效果。
- en: Call the new method `testBubbles()`. Place it after the `paintComponent()` method
    and before the `private class Bubble`, as shown in [Listing 9-3](ch9.xhtml#ch9list3).
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 调用新方法`testBubbles()`。将其放置在`paintComponent()`方法之后，`private class Bubble`之前，如[列表
    9-3](ch9.xhtml#ch9list3)所示。
- en: public void paintComponent(Graphics canvas) {
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: public void paintComponent(Graphics canvas) {
- en: --snip--
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: --省略--
- en: '}'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '}'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: ➊ public void testBubbles() {
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: ➊ public void testBubbles() {
- en: ➋ for(int n = 0; n < 100; n++) {
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: ➋ for(int n = 0; n < 100; n++) {
- en: ➌ int x = rand.nextInt(600);
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: ➌ int x = rand.nextInt(600);
- en: ➍ int y = rand.nextInt(400);
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: ➍ int y = rand.nextInt(400);
- en: ➎ int size = rand.nextInt(50);
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: ➎ int size = rand.nextInt(50);
- en: ➏ bubbleList.add( new Bubble(x, y, size) );
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: ➏ bubbleList.add( new Bubble(x, y, size) );
- en: '}'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: ➐ repaint();
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: ➐ repaint();
- en: '}'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: private class Bubble {
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: private class Bubble {
- en: '*Listing 9-3: Creating the testBubbles() method*'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 9-3：创建testBubbles()方法*'
- en: At ➊, we declare `testBubbles()` as `public` with `void` as the return type,
    meaning it doesn’t pass any information back to the program. Then, we use a regular
    `for` loop ➋ to go from `n = 0` to `99`, a total of 100 iterations. That means
    we’ll create 100 bubbles, and for each bubble, we need an (x, y) location and
    a size for its width and height in pixels.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 在➊处，我们将`testBubbles()`声明为`public`，返回类型为`void`，这意味着它不会向程序返回任何信息。然后，我们使用一个常规的`for`循环➋，从`n
    = 0`循环到`99`，总共100次迭代。这意味着我们将创建100个气泡，并且对于每个气泡，我们需要一个(x, y)位置和一个用于宽度和高度的大小。
- en: We set the pixel dimensions of the BubbleDraw app frame to `600` wide by `400`
    tall at the beginning of this chapter, so for the bubble’s location, we need an
    `x` value between `0` and `600` and a `y` value between `0` and `400`. Inside
    the `for` loop, we use the random number generator `rand` to get a random integer
    between `0` and `600` and store it in the variable `x` ➌ for the x-coordinate
    of the center of the bubble on the screen. Then, we generate a y-coordinate value
    between `0` and `400` and store it in `y` ➍. Next, for the size of the bubble
    in pixels, we generate a random number between `0` and `50` ➎. The last step inside
    the loop creates a new `Bubble` object using the random `x`, `y`, and `size` that
    we just generated, and we add that new `Bubble` to the `ArrayList` `bubbleList`
    ➏.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在本章开始时将BubbleDraw应用程序框架的像素尺寸设置为宽`600`，高`400`，因此对于气泡的位置，我们需要一个`x`值在`0`和`600`之间，`y`值在`0`和`400`之间。在`for`循环中，我们使用随机数生成器`rand`获取一个在`0`和`600`之间的随机整数，并将其存储在变量`x`中➌，作为气泡中心的x坐标。接着，我们生成一个在`0`和`400`之间的y坐标值，并将其存储在`y`中➍。然后，为了确定气泡的大小（像素），我们生成一个在`0`和`50`之间的随机数➎。循环中的最后一步是使用我们刚生成的随机`x`、`y`和`size`创建一个新的`Bubble`对象，并将这个新创建的`Bubble`添加到`ArrayList`
    `bubbleList`中➏。
- en: Finally, we call the `repaint()` method ➐. Normally before we draw new computer
    graphics, we have to clear the screen by drawing an empty, black background, but
    here `repaint()` does this for us. Notice that we didn’t have to clear the background
    of the screen inside the `paintComponent()` method either; all we had to do was
    draw the bubbles from `bubbleList`. The `repaint()` method takes care of redrawing
    the background as well as calling `paintComponent()`, so we’ll call it anytime
    we want to refresh or repaint the screen.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们调用`repaint()`方法➐。通常，在绘制新的计算机图形之前，我们需要通过绘制一个空的黑色背景来清除屏幕，但这里`repaint()`方法会为我们完成这项工作。注意，我们在`paintComponent()`方法中也没有清除屏幕的背景；我们所需要做的只是从`bubbleList`中绘制气泡。`repaint()`方法负责重新绘制背景，并调用`paintComponent()`，因此每当我们想要刷新或重新绘制屏幕时，我们都会调用它。
- en: 'There’s just one more step to complete before we can test the app—we need to
    call the `testBubbles()` method from the `BubblePanel()` constructor. Add the
    following line of code to your constructor for the `BubblePanel`:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们可以测试应用程序之前，还有一步需要完成——我们需要在`BubblePanel()`构造函数中调用`testBubbles()`方法。将以下代码行添加到`BubblePanel`的构造函数中：
- en: public BubblePanel() {
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: public BubblePanel() {
- en: bubbleList = new ArrayList<Bubble>();
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: bubbleList = new ArrayList<Bubble>();
- en: setBackground(Color.BLACK);
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: setBackground(Color.BLACK);
- en: testBubbles();
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: testBubbles();
- en: '}'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: Save *BubblePanel.java* and then switch to the *BubbleDraw.java* tab. Save that
    file and press the run button in Eclipse. You’ll need to run the file from the
    *BubbleDraw.java* tab the first time you compile and run, because `BubbleDraw`
    contains the `main()` method that runs the program. You should see a window full
    of colorful, randomly placed bubbles, similar to [Figure 9-3](ch9.xhtml#ch9fig3).
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 保存*BubblePanel.java*文件，然后切换到*BubbleDraw.java*标签页。保存该文件，并在Eclipse中按下运行按钮。第一次编译和运行时，你需要从*BubbleDraw.java*标签页运行该文件，因为`BubbleDraw`包含了运行程序的`main()`方法。你应该看到一个充满五颜六色、随机排列的气泡的窗口，类似于[图9-3](ch9.xhtml#ch9fig3)。
- en: '![Image](../images/f0210-01.jpg)'
  id: totrans-238
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/f0210-01.jpg)'
- en: '*Figure 9-3: Each time you run this version of the BubbleDraw app, the testBubbles()
    method will draw 100 bubbles on the screen.*'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: '*图9-3：每次运行这个版本的BubbleDraw应用程序时，`testBubbles()`方法都会在屏幕上绘制100个气泡。*'
- en: If you like the look of the random bubbles, take a little time to play with
    the numbers in the `testBubbles()` method. See if you can draw 200, 500, or even
    1,000 bubbles instead of 100\. Make the bubbles larger, either by generating a
    larger random number for `size` or by adding a value to `size` after the random
    number is generated. Play with the `x` and `y` values to see if you can fit every
    bubble on the screen instead of having some bubbles cut off at the edges.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你喜欢这些随机气泡的外观，可以花点时间调整`testBubbles()`方法中的数字。试试看能否绘制200、500甚至1000个气泡，而不是100个。通过为`size`生成一个更大的随机数，或者在生成随机数后给`size`加上一个值，来使气泡变大。调整`x`和`y`值，看看是否能让每个气泡都显示在屏幕上，而不是让一些气泡被边缘切掉。
- en: Modify the `testBubbles()` method as much as you’d like; this is a great opportunity
    to try new things and immediately see the visual effect of each change. We’ll
    comment out the `testBubbles()` method in the next section as we add mouse interaction,
    so you can feel free to experiment with `testBubbles()` without fear of messing
    up the rest of the program.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 随意修改 `testBubbles()` 方法；这是一个尝试新事物并立即看到每次更改的视觉效果的绝佳机会。在下一节中，当我们添加鼠标交互时，我们会将 `testBubbles()`
    方法注释掉，所以你可以尽情尝试 `testBubbles()`，无需担心破坏程序的其他部分。
- en: Handling Mouse Events from the User
  id: totrans-242
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 处理用户的鼠标事件
- en: The goal of the BubbleDraw app is to allow the user to draw bubbles using their
    mouse. We saw in the last section that the bubble-drawing part is working. Now
    all we have to do is add the mouse interaction.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: BubbleDraw 应用的目标是让用户能够使用鼠标绘制气泡。我们在上一节中看到，绘制气泡的部分已经能够正常工作。现在我们要做的就是添加鼠标交互功能。
- en: 'We’ll use event listeners to give the app the ability to handle mouse clicks,
    mouse movement, and even mouse wheel scrolling. We added event listeners to our
    GUI apps in [Chapters 3](ch3.xhtml#ch3) and [7](ch7.xhtml#ch7) using anonymous
    inner classes to handle button clicks, sliders, and text field changes; but if
    we used anonymous inner classes in this app, we would need to make three separate
    listeners for each type of event, and that would be hard to keep track of. Plus,
    in two of those events, clicking and dragging the mouse, we want the result to
    be the same: the app should add bubbles each time the user clicks the mouse on
    the screen *and* whenever the user drags the mouse across the screen. It would
    be much easier to just have one block of code we could attach to both events than
    to write a listener for one event and copy and paste the code to another. So,
    to make the app more manageable, we’re going to create a single, named event listener
    that can respond to all three types of events.'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用事件监听器来让应用程序处理鼠标点击、鼠标移动甚至鼠标滚轮滚动。在[第 3 章](ch3.xhtml#ch3) 和 [第 7 章](ch7.xhtml#ch7)
    中，我们使用匿名内部类为我们的 GUI 应用添加了事件监听器，处理按钮点击、滑块和文本框更改；但是如果我们在这个应用中使用匿名内部类，我们将需要为每种事件类型分别创建三个监听器，而这将很难管理。而且，在其中的两种事件（点击和拖动鼠标）中，我们希望结果是相同的：每次用户点击屏幕时，*并且*每次用户拖动鼠标时，应用都应添加气泡。将同一段代码附加到这两种事件比为每个事件编写一个监听器并复制粘贴代码要简单得多。因此，为了使应用程序更易于管理，我们将创建一个单一的命名事件监听器，来响应所有三种类型的事件。
- en: '*Creating a Reusable Event Listener*'
  id: totrans-245
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*创建可重用的事件监听器*'
- en: 'Before we can create our event listener, we need to import one additional library,
    `java.awt.event.*`, at the top of the *BubblePanel.java* file:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建事件监听器之前，我们需要在 *BubblePanel.java* 文件的顶部引入另一个库，`java.awt.event.*`：
- en: import java.awt.event.*;
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: import java.awt.event.*;
- en: import java.util.ArrayList;
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: import java.util.ArrayList;
- en: import java.awt.Graphics;
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: import java.awt.Graphics;
- en: import java.util.Random;
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: import java.util.Random;
- en: import java.awt.Color;
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: import java.awt.Color;
- en: import javax.swing.JPanel;
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: import javax.swing.JPanel;
- en: Our previous `import` statements have brought in only one class at a time, but
    this statement brings in every class in the `java.awt.event` library. The wildcard
    character, the asterisk (`*`), means that we want to bring in all the classes
    at the top level of `java.awt.event`, including all the mouse events and listeners,
    and much more. We could import each class individually as we use it, but importing
    `java.awt.event.*` will make the program much easier to write, allowing us to
    focus on coding instead of switching back and forth to the top of the file every
    time we need to use another event class.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前的`import`语句每次只引入一个类，但这条语句将引入 `java.awt.event` 库中的所有类。通配符字符星号（`*`）意味着我们要引入
    `java.awt.event` 顶层的所有类，包括所有的鼠标事件和监听器，以及更多内容。我们可以在需要时单独引入每个类，但使用 `java.awt.event.*`
    可以使程序更易于编写，让我们能集中精力编码，而不是每次需要使用其他事件类时都去文件顶部切换。
- en: Next, let’s start coding the private, named inner class to listen for mouse
    events. We’ll name it `BubbleListener`, as it will handle all the events related
    to bubbles in the `BubblePanel` class. Add this class below your `testBubbles()`
    method but above the private class `Bubble`. Java programmers usually include
    listener classes near the bottom of the class file, along with any other helper
    classes—this convention just helps us quickly find the listener code for debugging
    or modifying the file.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们开始编写私有的、命名的内部类来监听鼠标事件。我们将它命名为`BubbleListener`，因为它将处理`BubblePanel`类中与气泡相关的所有事件。将这个类添加到`testBubbles()`方法下方，但位于私有类`Bubble`上方。Java程序员通常将监听器类放在类文件的底部，以及其他任何辅助类——这个约定有助于我们快速找到监听器代码，便于调试或修改文件。
- en: repaint();
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: repaint();
- en: '}'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: private class BubbleListener extends  MouseAdapter {
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: private class BubbleListener extends MouseAdapter {
- en: '}'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: private class Bubble {
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: private class Bubble {
- en: The `BubbleListener` class extends `MouseAdapter`, which processes mouse events.
    Just as when we used the `extends` keyword to build a new type of `JFrame` that
    inherited all the features and functions of its parent class, the `BubbleListener`
    will inherit all the mouse event listener features of the `MouseAdapter` class.
    This adapter class includes the ability to handle `MouseListener` events for clicks,
    `MouseMotionListener` events for mouse movement, and `MouseWheelListener` events
    for scrolling with the mouse wheel or trackpad.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: '`BubbleListener`类继承了`MouseAdapter`，该类处理鼠标事件。就像我们使用`extends`关键字来构建一个新的`JFrame`类型，继承了父类的所有特性和功能一样，`BubbleListener`将继承`MouseAdapter`类的所有鼠标事件监听器功能。这个适配器类包括了处理`MouseListener`点击事件、`MouseMotionListener`鼠标移动事件以及`MouseWheelListener`鼠标滚轮或触控板滚动事件的能力。'
- en: We’ll add these event handlers to the code step-by-step, and we’ll test the
    app after each addition to see the BubbleDraw app emerge one feature at a time.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将一步步地将这些事件处理程序添加到代码中，并在每次添加后测试应用程序，逐渐看到BubbleDraw应用程序的各个功能。
- en: '*Handling Clicks and Drags*'
  id: totrans-262
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*处理点击和拖动*'
- en: When we handle mouse events, we need to complete two steps. First, we have to
    add code to the `BubbleListener` to handle the individual event we’re after, like
    `mousePressed()`. Then, we have to add the listener to the `BubblePanel()` constructor
    so the drawing screen knows to listen for that type of event and call `BubbleListener`
    to handle the event when it happens. Let’s do this for the first case, when the
    user presses the mouse button to draw a bubble.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们处理鼠标事件时，需要完成两个步骤。首先，我们必须在`BubbleListener`中添加代码来处理我们关注的具体事件，比如`mousePressed()`。然后，我们必须将监听器添加到`BubblePanel()`构造函数中，这样绘图界面就会知道去监听这种类型的事件，并在事件发生时调用`BubbleListener`来处理它。让我们以用户按下鼠标按钮绘制气泡的情况为例，来实现这两个步骤。
- en: Listening for Mouse Button Events
  id: totrans-264
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 监听鼠标按钮事件
- en: 'There are three events that we can listen for from the mouse buttons:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以监听三种鼠标按钮事件：
- en: '`mousePressed()` Occurs when the user presses any mouse button'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: '`mousePressed()` 当用户按下任何鼠标按钮时触发'
- en: '`mouseReleased()` Occurs when the user releases the button'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: '`mouseReleased()` 当用户释放按钮时触发'
- en: '`mouseClicked()` Occurs when the user presses and releases in quick succession'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: '`mouseClicked()` 当用户快速按下并释放鼠标按钮时触发'
- en: 'For the BubbleDraw app, we’ll use the `mousePressed()` handler so that the
    app will draw a bubble as soon as the user presses the mouse button. The signature
    for a `mousePressed()` event handler looks like the following:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 对于BubbleDraw应用程序，我们将使用`mousePressed()`处理程序，这样当用户按下鼠标按钮时，应用程序就会立即绘制一个气泡。`mousePressed()`事件处理程序的声明如下：
- en: private class BubbleListener extends MouseAdapter {
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: private class BubbleListener extends MouseAdapter {
- en: public void mousePressed(MouseEvent e) {
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: public void mousePressed(MouseEvent e) {
- en: '}'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '}'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '**NOTE**'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*Spelling and capitalization are especially important when you’re writing event
    handlers because they already have built-in names with specific capitalization.
    Make sure your mousePressed() method matches this one exactly.*'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: '*拼写和大小写在编写事件处理程序时尤其重要，因为它们已经有了内建的名称和特定的大小写。确保你的mousePressed()方法与此完全一致。*'
- en: The `mousePressed()` event handler goes inside the `BubbleListener` class, and
    it must be declared as `public` with a `void` return type to match the `mousePressed()`
    method in the `MouseAdapter` class. Notice it also takes a parameter of type `MouseEvent`.
    All of the mouse events get information about the mouse pointer’s location on
    the screen when the event happened. The x- and y-coordinates of the mouse event
    are stored in a `MouseEvent` object, and we can get those coordinates with the
    `getX()` and `getY()` methods.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: '`mousePressed()`事件处理程序位于`BubbleListener`类中，它必须声明为`public`并且返回类型为`void`，以匹配`MouseAdapter`类中的`mousePressed()`方法。注意，它还接受一个`MouseEvent`类型的参数。所有鼠标事件都会获取事件发生时鼠标指针在屏幕上的位置。鼠标事件的x坐标和y坐标保存在`MouseEvent`对象中，我们可以通过`getX()`和`getY()`方法获取这些坐标。'
- en: The following code adds a bubble to the `bubbleList` at the location where the
    user clicked the mouse, and then repaints the drawing screen to make the bubble
    appear.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码将一个气泡添加到`bubbleList`中，位置是用户点击鼠标的位置，然后重新绘制画面，使气泡出现。
- en: private class BubbleListener extends MouseAdapter {
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: private class BubbleListener extends MouseAdapter {
- en: public void mousePressed(MouseEvent e) {
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: public void mousePressed(MouseEvent e) {
- en: ➊ bubbleList.add(new Bubble(e.getX(), e.getY(), size));
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: ➊ bubbleList.add(new Bubble(e.getX(), e.getY(), size));
- en: ➋ repaint();
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: ➋ repaint();
- en: '}'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '}'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: 'At ➊, we create a new `Bubble` object at the (x, y) location where the user
    clicked the mouse, `e.getX()` and `e.getY()`. The `MouseEvent` class has several
    properties and methods for working with mouse events, like finding out which button
    was pressed and where the mouse is on the screen. As I just mentioned, the `getX()`
    and `getY()` methods tell us the x- and y-coordinates of the mouse event, such
    as a click or drag. Look back down in the `Bubble` class, and you’ll see that
    the constructor method we wrote there required three parameters: `int newX`, `int
    newY`, and `int newSize`. So, we must pass `e.getX()`, `e.getY()`, and `size`
    to the constructor to create a new `Bubble` object. Once the bubble is created,
    we add it to the `ArrayList` of bubbles with `bubbleList.add()`.'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 在➊处，我们在用户点击鼠标的位置（`e.getX()`和`e.getY()`）创建一个新的`Bubble`对象。`MouseEvent`类具有多个属性和方法用于处理鼠标事件，例如获取按下了哪个按钮以及鼠标在屏幕上的位置。正如我刚才提到的，`getX()`和`getY()`方法告诉我们鼠标事件的x和y坐标，例如点击或拖动。回到`Bubble`类，你会看到我们在那里编写的构造方法需要三个参数：`int
    newX`、`int newY`和`int newSize`。因此，我们必须将`e.getX()`、`e.getY()`和`size`传递给构造函数来创建一个新的`Bubble`对象。创建气泡后，我们通过`bubbleList.add()`将其添加到气泡的`ArrayList`中。
- en: At ➋, we call the `repaint()` method to refresh the screen and draw the updated
    `bubbleList` to the canvas.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 在➋处，我们调用`repaint()`方法刷新屏幕，并将更新后的`bubbleList`绘制到画布上。
- en: This completes the `mousePressed()` event handler, but we still need to do one
    more thing to make the app listen for `mousePressed()` events and send them to
    the `BubbleListener` class. We have to tell the `BubblePanel` class to add `BubbleListener`
    as the listener for mouse events.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 这完成了`mousePressed()`事件处理程序，但我们仍然需要做一件事，让应用程序监听`mousePressed()`事件并将其发送到`BubbleListener`类。我们必须告诉`BubblePanel`类将`BubbleListener`添加为鼠标事件的监听器。
- en: 'In the `BubblePanel()` constructor, make two changes. First, comment out the
    `testBubbles()` line by placing two forward slashes at the front of the line.
    Second, call the `addMouseListener()` command to use `BubbleListener` to process
    mouse events. The updated constructor is shown here:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 在`BubblePanel()`构造函数中，做两处修改。首先，将`testBubbles()`行注释掉，在行前加上两个斜杠。其次，调用`addMouseListener()`命令，使用`BubbleListener`来处理鼠标事件。更新后的构造函数如下所示：
- en: public BubblePanel() {
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: public BubblePanel() {
- en: bubbleList = new ArrayList<Bubble>();
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: bubbleList = new ArrayList<Bubble>();
- en: setBackground(Color.*BLACK*);
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: setBackground(Color.*BLACK*);
- en: ➊ // testBubbles();
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: ➊ // testBubbles();
- en: ➋ addMouseListener( new BubbleListener() );
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: ➋ addMouseListener( new BubbleListener() );
- en: '}'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: By commenting out the call to `testBubbles()`➊, we’ve left it in place in case
    we want to draw random test bubbles again, but we’ve stopped it from running so
    that we can test the interactive BubbleDraw app using the mouse. The new line
    at ➋ tells the `BubblePanel` to listen for mouse events and to send them to the
    `BubbleListener` class when they happen.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 通过注释掉对`testBubbles()`的调用➊，我们将其保留以备以后可能再次绘制随机测试气泡，但已经阻止其运行，这样我们可以测试使用鼠标的交互式BubbleDraw应用。➋处的新行告诉`BubblePanel`监听鼠标事件，并在事件发生时将其发送到`BubbleListener`类。
- en: With those changes in place, you should be able to run the BubbleDraw app and
    use the mouse button to place bubbles anywhere you click, as shown in [Figure
    9-4](ch9.xhtml#ch9fig4).
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 完成这些更改后，你应该能够运行BubbleDraw应用程序，并使用鼠标按钮在你点击的任意位置放置气泡，如[图 9-4](ch9.xhtml#ch9fig4)所示。
- en: '![Image](../images/f0214-01.jpg)'
  id: totrans-296
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/f0214-01.jpg)'
- en: '*Figure 9-4: After adding the mousePressed() handler and setting BubbleListener
    as the listener for mouse events in the app, you should be able to draw by clicking
    anywhere on the screen.*'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 9-4：在添加mousePressed()处理器并将BubbleListener设置为应用程序中的鼠标事件监听器后，你应该能够通过点击屏幕上的任何位置来绘制气泡。*'
- en: Very cool! You can click repeatedly to draw shapes and patterns on the screen,
    but it would be easier to drag the mouse to draw bubbles. Let’s address that next.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 非常酷！你可以反复点击在屏幕上绘制形状和图案，但用鼠标拖动来绘制气泡会更容易一些。接下来我们来解决这个问题。
- en: Listening for Mouse Motion Events
  id: totrans-299
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 监听鼠标运动事件
- en: Mouse motion events are a separate type of event from mouse button presses,
    but they can still be processed in a class that extends `MouseAdapter`, like `BubbleListener`.
    The two types of mouse motion events are `mouseMoved()` and `mouseDragged()`.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 鼠标运动事件与鼠标按钮按下事件是两种不同类型的事件，但它们仍然可以在扩展`MouseAdapter`的类中处理，比如`BubbleListener`。两种鼠标运动事件分别是`mouseMoved()`和`mouseDragged()`。
- en: A `mouseMoved()` event happens anytime the mouse is moved over the drawing window.
    A `mouseDragged()` event occurs whenever the mouse is moved while a button is
    pressed. Since we want to draw bubbles only when the user clicks and drags the
    mouse, we’ll implement the `mouseDragged()` event handler in the `BubbleListener`
    class first, and then we’ll add a mouse motion listener to the `BubblePanel` constructor
    to activate the listener.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 每当鼠标在绘图窗口上移动时，都会发生一个`mouseMoved()`事件。当鼠标在按下按钮的同时被移动时，就会发生`mouseDragged()`事件。由于我们希望只有在用户点击并拖动鼠标时才绘制气泡，我们首先会在`BubbleListener`类中实现`mouseDragged()`事件处理器，然后我们会在`BubblePanel`构造函数中添加鼠标动作监听器来激活监听器。
- en: 'Add the `mouseDragged()` event handler to the `BubbleListener` class, as shown
    here:'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 如下所示，向`BubbleListener`类中添加`mouseDragged()`事件处理器：
- en: private class BubbleListener extends MouseAdapter {
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: private class BubbleListener extends MouseAdapter {
- en: public void mousePressed(MouseEvent e) {
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: public void mousePressed(MouseEvent e) {
- en: --snip--
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: --snip--
- en: '}'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: public void mouseDragged(MouseEvent e) {
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: public void mouseDragged(MouseEvent e) {
- en: bubbleList.add(new Bubble(e.getX(), e.getY(), size));
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: bubbleList.add(new Bubble(e.getX(), e.getY(), size));
- en: repaint();
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: repaint();
- en: '}'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '}'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: You’ll notice that the code looks almost exactly like the `mousePressed()` event
    handler, except for the name `mouseDragged()`. That’s because they both handle
    `MouseEvent`s. The `mousePressed()` method handles events when the user presses
    a mouse button, and `mouseDragged()` is called whenever the user drags the mouse.
    In this app, both events should behave the same way, adding bubbles to `bubbleList`
    and calling the `repaint()` function.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 你会注意到，代码看起来几乎和`mousePressed()`事件处理器一模一样，除了名称是`mouseDragged()`。这是因为它们都处理`MouseEvent`事件。`mousePressed()`方法处理用户按下鼠标按钮时的事件，而`mouseDragged()`在用户拖动鼠标时被调用。在这个应用程序中，这两个事件应该表现得一样，都会将气泡添加到`bubbleList`中，并调用`repaint()`函数。
- en: 'Next, add `BubbleListener` as the mouse motion listener to the `BubblePanel()`
    constructor with the following statement:'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，使用以下语句将`BubbleListener`作为鼠标动作监听器添加到`BubblePanel()`构造函数中：
- en: public BubblePanel() {
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: public BubblePanel() {
- en: bubbleList = new ArrayList<Bubble>();
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: bubbleList = new ArrayList<Bubble>();
- en: setBackground(Color.*BLACK*);
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: setBackground(Color.*BLACK*);
- en: // testBubbles();
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: // testBubbles();
- en: addMouseListener( new BubbleListener() );
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: addMouseListener( new BubbleListener() );
- en: addMouseMotionListener( new BubbleListener() );
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: addMouseMotionListener( new BubbleListener() );
- en: '}'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: Once again, let’s run the app to test this new event listener. Save your code,
    press the run button, and click and drag around the app window that appears, as
    shown in [Figure 9-5](ch9.xhtml#ch9fig5).
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 再次运行应用程序来测试这个新的事件监听器。保存代码，点击运行按钮，然后在出现的应用程序窗口中点击并拖动，如[图 9-5](ch9.xhtml#ch9fig5)所示。
- en: '![Image](../images/f0215-01.jpg)'
  id: totrans-322
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/f0215-01.jpg)'
- en: '*Figure 9-5: Now you can click and drag to draw continuous streams of bubbles!*'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 9-5：现在你可以点击并拖动来绘制连续的气泡流！*'
- en: Impressive, huh? Just by adding two event handlers for mouse button and mouse
    motion events to the `BubblePanel` graphics app, we’ve built an interactive, multicolored
    drawing app in Java.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 印象深刻吧？仅仅通过为鼠标按钮事件和鼠标运动事件添加两个事件处理器到`BubblePanel`图形应用程序中，我们就用Java构建了一个交互式、多彩的绘图应用程序。
- en: '*Bonus: Handling MouseWheel Events*'
  id: totrans-325
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*附加内容：处理鼠标滚轮事件*'
- en: 'We’ve seen two small but powerful event handlers for mouse button presses and
    mouse click-and-drag events at work in the app so far, but there’s another event
    class in `MouseAdapter`: `MouseWheelEvent`. Depending on your system, you might
    have a physical wheel on your mouse or trackpad that you can use to scroll up
    and down in documents and web pages. Or, you might have a laptop with a trackpad
    that allows you to scroll using a gesture, such as the two-finger swipe gesture
    on a MacBook or the vertical swipe along the far-right edge of the trackpad on
    most Windows laptops.'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经看到了两个小而强大的事件处理程序，用于处理鼠标按钮按下和鼠标点击拖动事件，但`MouseAdapter`中还有一个事件类：`MouseWheelEvent`。根据你的系统，你可能在鼠标或触摸板上有一个物理滚轮，可以用来在文档和网页中上下滚动。或者，你可能有一台带触摸板的笔记本，允许你通过手势滚动，比如MacBook上的双指滑动手势或大多数Windows笔记本触摸板的右边缘垂直滑动手势。
- en: 'Java interprets either kind of scroll event as a `MouseWheelEvent`. We can
    add a `mouseWheelMoved()` listener to the `BubbleListener` to handle mouse wheel
    events or trackpad scroll gesture events on systems that provide them, as follows:'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: Java将任何类型的滚动事件都解释为`MouseWheelEvent`。我们可以为`BubbleListener`添加一个`mouseWheelMoved()`监听器，以处理提供滚动功能的系统上的鼠标滚轮事件或触摸板手势事件，代码如下：
- en: private class BubbleListener extends MouseAdapter {
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: private class BubbleListener extends MouseAdapter {
- en: public void mousePressed(MouseEvent e) {
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: public void mousePressed(MouseEvent e) {
- en: --snip--
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: --snip--
- en: '}'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: public void mouseDragged(MouseEvent e) {
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: public void mouseDragged(MouseEvent e) {
- en: --snip--
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: --snip--
- en: '}'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: ➊ public void mouseWheelMoved(MouseWheelEvent e) {
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: ➊ public void mouseWheelMoved(MouseWheelEvent e) {
- en: ➋ size += e.getUnitsToScroll();
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: ➋ size += e.getUnitsToScroll();
- en: '}'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '}'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: At ➊, the `mouseWheelMoved()` method accepts a `MouseWheelEvent`. At ➋, we get
    the number of units the mouse wheel scrolled from the `MouseWheelEvent` `e` with
    `e.getUnitsToScroll()`, and we add this amount to `size`. The number returned
    by `getUnitsToScroll()` can be positive or negative, depending on your operating
    system and whether the wheel was scrolled up or down.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 在➊处，`mouseWheelMoved()`方法接受一个`MouseWheelEvent`。在➋处，我们通过`e.getUnitsToScroll()`从`MouseWheelEvent`
    `e`中获取鼠标滚轮滚动的单位数，并将其加到`size`中。`getUnitsToScroll()`返回的数字可以是正数或负数，具体取决于你的操作系统以及滚轮是向上还是向下滚动。
- en: '**DIFFERENCES IN SCROLLING BETWEEN OPERATING SYSTEMS**'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: '**操作系统之间滚动的差异**'
- en: Windows, macOS, and Linux differ when it comes to scrolling. On macOS, scrolling
    or gesturing up returns a positive value, so the code we just wrote will increase
    the bubble size when the user scrolls or gestures up and shrink the size when
    the user scrolls down. On Windows and most Linux flavors, scrolling up with the
    mouse wheel moves a web page or document *down* instead, returning a negative
    number from `getUnitsToScroll()`. This means that scrolling up will cause the
    bubbles to get smaller, while scrolling down will add to the size and make them
    larger.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: Windows、macOS和Linux在滚动方面有所不同。在macOS上，向上滚动或手势上滑会返回一个正值，因此我们刚才写的代码会在用户向上滚动或上滑时增大气泡的大小，在用户向下滚动时减小大小。而在Windows和大多数Linux版本中，使用鼠标滚轮向上滚动会将网页或文档*向下*移动，返回`getUnitsToScroll()`的负数。这意味着向上滚动会导致气泡变小，而向下滚动则会使气泡增大。
- en: 'If you want to make your app work the same way on all three operating systems,
    change the code to the following:'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想让你的应用程序在所有三种操作系统上表现一致，可以将代码更改为以下内容：
- en: public void mouseWheelMoved(MouseWheelEvent e) {
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: public void mouseWheelMoved(MouseWheelEvent e) {
- en: if(System.*getProperty*("os.name").startsWith("Mac"))
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: if(System.*getProperty*("os.name").startsWith("Mac"))
- en: size += e.getUnitsToScroll();
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: size += e.getUnitsToScroll();
- en: else
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: else
- en: size -= e.getUnitsToScroll();
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: size -= e.getUnitsToScroll();
- en: '}'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: The `if` statement gets the operating system name with `System.getProperty ("os.name")`
    and checks whether the name starts with the string `"Mac"`. If so, we add the
    units scrolled to `size`. Otherwise, we subtract the units scrolled from `size`
    to reverse Windows and Linux scrolling to positive for up, negative for down.
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: '`if`语句通过`System.getProperty("os.name")`获取操作系统名称，并检查名称是否以字符串`"Mac"`开头。如果是这样，我们将滚动的单位数加到`size`中。否则，我们从`size`中减去滚动的单位数，以便将Windows和Linux的滚动行为反向，向上滚动为正，向下滚动为负。'
- en: 'Lastly, add the mouse wheel listener to the `BubblePanel()` constructor, just
    below the previous two listeners:'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，将鼠标滚轮监听器添加到`BubblePanel()`构造函数中，就在前两个监听器下面：
- en: public BubblePanel() {
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: public BubblePanel() {
- en: bubbleList = new ArrayList<Bubble>();
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: bubbleList = new ArrayList<Bubble>();
- en: setBackground(Color.*BLACK*);
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: setBackground(Color.*BLACK*);
- en: // testBubbles();
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: // testBubbles();
- en: addMouseListener( new BubbleListener() );
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: addMouseListener( new BubbleListener() );
- en: addMouseMotionListener( new BubbleListener() );
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: addMouseMotionListener( new BubbleListener() );
- en: addMouseWheelListener( new BubbleListener() );
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: addMouseWheelListener( new BubbleListener() );
- en: '}'
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: Save and run the app now, and you should be able to change the bubble size by
    scrolling your mouse wheel or gesturing up or down on your trackpad, as shown
    in [Figure 9-6](ch9.xhtml#ch9fig6).
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 现在保存并运行应用程序，你应该能够通过滚动鼠标滚轮或在触控板上上下滑动来更改气泡的大小，如 [图 9-6](ch9.xhtml#ch9fig6) 所示。
- en: '![Image](../images/f0217-01.jpg)'
  id: totrans-360
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/f0217-01.jpg)'
- en: '*Figure 9-6: Use your mouse wheel or trackpad to change the size of the bubbles.*'
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 9-6：使用鼠标滚轮或触控板更改气泡的大小。*'
- en: The first version of the BubbleDraw app is complete! You can click and drag
    to draw with multicolored bubbles on the screen, scroll up and down to change
    the bubble size, maximize the window to draw fullscreen, and more.
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: BubbleDraw 应用的第一个版本已完成！你可以点击并拖动屏幕上的多彩气泡进行绘制，向上和向下滚动以改变气泡的大小，最大化窗口以全屏绘制等。
- en: What You Learned
  id: totrans-363
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 你学到了什么
- en: You’ve designed a colorful, interactive drawing app though an object-oriented
    programming approach by creating a `Bubble` class to capture the features and
    behaviors of bubbles.
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 你通过面向对象的编程方法设计了一个多彩的互动绘图应用，通过创建一个 `Bubble` 类来捕捉气泡的特性和行为。
- en: 'Here are some of the new things you’ve learned in this chapter:'
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是你在本章中学到的一些新知识：
- en: • Building a single app with multiple classes and multiple Java source code
    files
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: • 使用多个类和多个 Java 源代码文件构建一个单一的应用程序
- en: • Using an object-oriented programming approach to break a problem down into
    smaller pieces
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: • 使用面向对象的编程方法将问题拆分成更小的部分
- en: • Building the `Bubble` class from scratch, including attributes, methods, and
    a constructor
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: • 从头开始构建 `Bubble` 类，包括属性、方法和构造函数
- en: • Creating random colors using the `java.util.Random` and `java.awt.Color` classes
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: • 使用 `java.util.Random` 和 `java.awt.Color` 类创建随机颜色
- en: • Generating random numbers in a given range with `Random.nextInt(range)`
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: • 使用 `Random.nextInt(range)` 生成给定范围内的随机数
- en: • Drawing graphics with the `java.awt.Graphics` class
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: • 使用 `java.awt.Graphics` 类绘制图形
- en: • Using the `paintComponent()` method to describe what your app should draw
    and using `repaint()` to clear the screen and redraw
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: • 使用 `paintComponent()` 方法描述应用程序应绘制的内容，并使用 `repaint()` 清空屏幕并重新绘制
- en: • Writing event handlers for mouse events, including clicks, movement, and mouse
    wheel events
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: • 为鼠标事件编写事件处理程序，包括点击、移动和鼠标滚轮事件
- en: • Using the `java.util.ArrayList` class to store a dynamic list of objects,
    such as the bubbles in BubbleDraw
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: • 使用 `java.util.ArrayList` 类来存储动态对象列表，如 BubbleDraw 中的气泡
- en: • Adding multiple event listeners to an app using a custom listener class, `BubbleListener`
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: • 使用自定义监听器类 `BubbleListener` 向应用程序添加多个事件监听器
- en: Programming Challenges
  id: totrans-376
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 编程挑战
- en: Try these programming challenge exercises to review and practice what you’ve
    learned, as well as to expand your programming skills. Visit the book’s website
    at *[https://www.nostarch.com/learnjava/](https://www.nostarch.com/learnjava/)*
    for sample solutions.
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试这些编程挑战练习来复习和实践你所学的知识，并扩展你的编程技能。访问本书的官方网站 *[https://www.nostarch.com/learnjava/](https://www.nostarch.com/learnjava/)*
    获取示例解答。
- en: '*#1: No Bubble Too Small*'
  id: totrans-378
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*#1: 气泡不应太小*'
- en: If you scroll the mouse down enough, the bubbles will simply disappear because
    the `size` value drops below `0`, resulting in a circle that Java can’t draw on
    the screen. In fact, a `size` of `2` or smaller will produce bubbles just a single
    pixel tall, so let’s make sure the value of `size` stays at least 3 pixels by
    3 pixels to keep the bubbles circular.
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你将鼠标滚动得足够远，气泡将会消失，因为 `size` 值下降到 `0` 以下，导致 Java 无法在屏幕上绘制圆形。实际上，`size` 值为 `2`
    或更小时，气泡将仅为一个像素高，因此让我们确保 `size` 的值至少保持为 3 像素，以保持气泡的圆形。
- en: Add a little logic to the `mouseWheelMoved()` method in the `BubbleListener`
    class in *BubblePanel.java* to check whether the `size` variable goes below a
    value of `3`. If so, set `size` equal to `3` to keep the bubble visible on the
    screen. Add this new `if` statement to the end of the `mouseWheelMoved()` method
    so that you check the size after it’s changed, not before.
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *BubblePanel.java* 中的 `BubbleListener` 类的 `mouseWheelMoved()` 方法中添加一些逻辑，检查
    `size` 变量是否降到 `3` 以下。如果是，设置 `size` 为 `3` 以保持气泡在屏幕上可见。将这个新的 `if` 语句添加到 `mouseWheelMoved()`
    方法的末尾，以便在大小变化后检查，而不是在变化之前。
- en: Run the app with the change, and you should be able to scroll the mouse wheel
    until the bubbles are just a couple of pixels wide, but they’ll no longer disappear.
    Great work!
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 运行带有更改的应用程序，你应该能够滚动鼠标滚轮直到气泡变得仅有几个像素宽，但它们将不再消失。做得很好！
- en: '*#2: PixelDraw!*'
  id: totrans-382
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*#2: 像素绘图！*'
- en: Add just a little bit of math to the constructor for new `Bubble()` objects,
    and you can create a cool, pixelated effect, as shown in [Figure 9-7](ch9.xhtml#ch9fig7).
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/f0219-01.jpg)'
  id: totrans-384
  prefs: []
  type: TYPE_IMG
- en: '*Figure 9-7: Changing the location of new Bubbles slightly can create a cool
    pixel-drawing effect.*'
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
- en: Let’s copy the *BubbleDraw* project folder to make the changes in a new project
    without messing up the original app. Double-click your *BubblePanel .java* tab
    to restore the default view and then, in the Package Explorer, press CTRL-C or
    ![Image](../images/symbol.jpg)-C to copy the *BubbleDraw* project folder. Press
    CTRL-V or ![Image](../images/symbol.jpg)-V to paste a new copy of the folder into
    your workspace. Change the name of the folder to **PixelDraw**, as shown in [Figure
    9-8](ch9.xhtml#ch9fig8).
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/f0219-02.jpg)'
  id: totrans-387
  prefs: []
  type: TYPE_IMG
- en: '*Figure 9-8: You can copy a project folder in the Package Explorer and paste
    it to create a new copy.*'
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
- en: Change the code for the `Bubble()` constructor inside the private class `Bubble`
    as follows.
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
- en: public Bubble(int newX, int newY, int newSize) {
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
- en: x = (newX / newSize) * newSize + newSize/2;
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
- en: y = (newY / newSize) * newSize + newSize/2;
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
- en: size = newSize;
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
- en: color = new Color( rand.nextInt(256),
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
- en: rand.nextInt(256),
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
- en: rand.nextInt(256) );
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
- en: This new math only alters the (x, y) location of each new bubble because of
    the way Java handles division of two integer values. Java keeps only the integer,
    or whole number, result when you divide two integers, so dividing by `newSize`
    and multiplying by `newSize` will make your bubbles appear to be on a grid, as
    you saw back in [Figure 9-7](ch9.xhtml#ch9fig7). For example, if `newSize` is
    `10` and `x` is `25`, then `x` divided by `newSize` would be `25 / 10`, which
    evaluates to `2` in Java. Multiplying by `10` then gives us `20`, the location
    of the bubble on a 10×10 pixel grid. We add `newSize/2` to each coordinate to
    center the dots within the imaginary grid. Remember, scrolling the mouse wheel
    still changes the size of the bubbles, so you can draw thick, blocky images or
    fine, pixel-perfect drawings.
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
- en: 'If you’d like to make the pixel effect more *Minecraft*-y, you can make the
    bubbles into squares. To do so, change the `draw()` method to fill rectangles
    instead of ovals by commenting out the `fillOval()` command and using the `fillRect()`
    command instead:'
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
- en: public void draw(Graphics canvas) {
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
- en: canvas.setColor(color);
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
- en: // canvas.fillOval(x - size/2, y - size/2, size, size);
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
- en: canvas.fillRect(x - size/2, y - size/2, size, size);
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
- en: Now you can draw in a pixelated style, as shown in [Figure 9-9](ch9.xhtml#ch9fig9).
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/f0220-01.jpg)'
  id: totrans-406
  prefs: []
  type: TYPE_IMG
- en: '*Figure 9-9: Drawing with rectangles instead of ovals creates a pixelated drawing
    effect.*'
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
