<html><head></head><body><div id="sbo-rt-content"><section>
<header>
<h1 class="chapter">
<span class="ChapterNumber"><span epub:type="pagebreak" title="135" id="Page_135"/>8</span><br/>
<span class="ChapterTitle">Advanced Graphics and Animation</span></h1>
</header><figure class="opener">
<img src="Images/chapterart.png" alt="" width="206" height="206"/>
</figure>
<h2 id="h1-501645c08-0001" class="HeadProject"><span><span epub:type="pagebreak" title="136" id="Page_136"/>Sketch 61: Layering</span></h2>
<p class="BodyFirst">One of the key features of modern graphics programs like Photoshop is the idea of <span class="KeyTerm">layers</span>. That’s the creation of a set of graphical objects (images) that are placed on top of each other to achieve a complex effect. Transparency makes it possible to see objects on lower layers. This sketch uses three layers: an image of the moon, a circle around a crater, and a targeting display (<span class="KeyTerm">reticle</span>). Using the keyboard, the user can reposition the moon image. The goal of the interface is to allow the user to align the reticle with the target circle.</p>
<p>Drawing inside the sketch window involves using a graphics object class called <code>PGraphics</code>. The <code>background()</code>, <code>line()</code>, and <code>ellipse()</code> functions, and many others, are part of the <code>PGraphics</code> class, though we can use them without a <code>PGraphics</code> object. Alternatively, our drawing can take place in one of these objects and then be displayed on the screen later by calling <code>image()</code>. This sketch will draw the moon image with an ellipse highlighting a crater inside of a <code>PGraphics</code> instance, and we’ll then display it in the sketch window.</p>
<p>The variable used for the <code>PGraphics</code> object is named <code>pg</code>, and the function that creates one is called (reasonably enough) <code>createGraphics()</code> <span class="CodeAnnotation" aria-label="annotation1">1</span>:</p>
<pre><code>PGraphics pg;
pg = createGraphics(moon.width, moon.height);</code></pre>
<p class="BodyContinued">Here, <code>moon</code> is the <code>PImage</code> variable that holds the background image of the moon. </p>
<p>To draw in a <code>PGraphics</code> object, we use the graphics functions that we have used before, but specify the <code>pg</code> variable as the target <span class="CodeAnnotation" aria-label="annotation2">2</span>:</p>
<pre><code>pg.beginDraw(); 
pg.image(moon, 0, 0);
pg.stroke (0, 200, 0); 
pg.noFill(); 
pg.ellipse (393, 233, 12, 12);
pg.endDraw();</code></pre>
<p>Drawing is preceded by a call to <code>beginDraw()</code>, a function that is similar to a bracket; the corresponding end bracket is a call to <code>endDraw()</code>. If you don’t use these calls, Processing doesn’t initialize the object, and drawing will not work (even though Processing may not generate an error). The preceding code draws the moon image in the <code>PGraphics</code> objects and draws a circle around a target.</p>
<p>The <code>draw()</code> function displays the <code>PGraphics</code> object using the call <code>image(pg, xoff, yoff)</code>, where <code>xoff</code> and <code>yoff</code> are positional offsets that are controlled using key presses of <span class="KeyCaps">W</span>, <span class="KeyCaps">A</span>, <span class="KeyCaps">S</span>, and <span class="KeyCaps">D</span> in the traditional way <span class="CodeAnnotation" aria-label="annotation3">3</span>. (A <code>PGraphics</code> object has many of the properties of a <code>PImage</code>, since <code>image()</code> can display both.) The values of <code>xoff</code> and <code>yoff</code> are generally negative so that the underlying graphic gets shifted left and up under the window, which remains stable, from its starting point in the upper-left corner. The <code>draw()</code> function also draws the reticle as a small set of lines that point to the center of the window <span class="CodeAnnotation" aria-label="annotation4">4</span>. </p>
<aside epub:type="sidebar">
<div class="top hr"><hr/></div>
<section class="boxcustom1">

<pre><code><span epub:type="pagebreak" title="137" id="Page_137"/>PImage moon;
int xoff=0, yoff=0;
PGraphics pg;

void setup () 
{
  moon = loadImage ("moon.jpg");
  size (300, 300);
  pg =   <span class="CodeAnnotationHang" aria-label="annotation1">1</span>createGraphics(moon.width, moon.height);
  <span class="CodeAnnotationHang" aria-label="annotation2">2</span> pg.beginDraw(); 
  pg.image(moon, 0, 0); 
  pg.stroke (0, 200, 0); 
  pg.noFill(); 
  pg.ellipse (393, 233, 12, 12);
  pg.endDraw();
  stroke (200); 
  noFill();
}

void draw () 
{
  background (200);
  <span class="CodeAnnotationHang" aria-label="annotation3">3</span> image(pg, xoff, yoff);
  <span class="CodeAnnotationHang" aria-label="annotation4">4</span> line (0, height/2, width/2-10, height/2);
  line (width/2+10, height/2, width, height/2);
  line (width/2, 0, width/2, height/2-10);
  line (width/2, height/2+10, width/2, height);
  ellipse (width/2, height/2, 10, 10);
}

void keyPressed ()
{
  if (key == 'w') yoff = yoff + 1;       // Move up
  else if (key == 's') yoff = yoff -1;   // Move down
  else if (key == 'a') xoff = xoff +1;   // Move left
  else if (key == 'd') xoff = xoff -1;   // Move right 
  if (xoff &gt; 0) xoff=0;  
  if (xoff &lt; -(moon.width-width)) xoff = -(moon.width-width);
  if (yoff &gt; 0) yoff = 0; 
  if (yoff &lt; -(moon.height-height)) yoff = -(moon.height-height);
}</code></pre>
<figure class="graphic"><img src="Images/g061001.png" alt="g061001" width="375" height="376"/></figure>
<div class="bottom hr"><hr/></div>
</section>
</aside>
<h2 id="h1-501645c08-0002" class="HeadProject"><span><span epub:type="pagebreak" title="138" id="Page_138"/>Sketch 62: Seeing the World Through a Window</span></h2>
<p class="BodyFirst">Many games, animations, and simulations (driving or space travel, for example) use a view through a window as a part of the interface. This sketch implements a window that looks out on a 3D scene and allows the user to move about that scene while looking through the window.</p>
<p>This is a more advanced application of <code>PGraphics</code>. We’ll render a simple 3D scene to a <code>PGraphics</code> instance named <code>pg</code>, read a 2D image with transparent sections (the window) into a <code>PGraphics</code> instance named <code>g2</code>, and draw the two graphics objects to the screen using calls to <code>image()</code>.</p>
<p>The 3D primitives we’ll use to draw the 3D scene are all part of <code>PGraphics</code>. We’ll enable the 3D rendering engine with a parameter to <code>createGraphics()</code> <span class="CodeAnnotation" aria-label="annotation1">1</span>, instead of to <code>size()</code> as in Sketch 51, and then we’ll set up the 3D parameters with calls to <code>camera()</code> <span class="CodeAnnotation" aria-label="annotation2">2</span> and <code>ambientLight()</code>. The basic call to <code>size()</code> sets up the graphics window; each <code>PGraphics</code> instance is like having a distinct window to draw in, and all of the usual graphics methods can be used via the dot notation: <code>pg.line()</code>, <code>pg.ellipse()</code>, and so on. No <code>PGraphics</code> object is visible until drawn in the graphics window. Thus we can create a simulated 3D space inside the <code>pg</code> object, drawing four cubes there that provide targets to be viewed through the window.</p>
<p>The 2D portion involves displaying a 2D image (a <code>PImage</code> variable named <code>back</code>) that represents the window (<a href="#figure62-1" id="figureanchor62-1">Figure 62-1</a>). The GIF image has transparent sections, created by defining a color (in this case green) as transparent using an image editor like Photoshop. We call this kind of image a <span class="KeyTerm">stencil</span>.</p>
<figure>
<img src="Images/f062001.png" alt="f062001" class="" width="694" height="308"/>
<figcaption><p><a id="figure62-1">Figure 62-1</a>: The stencil for the window</p></figcaption>
</figure>
<p>The sketch draws the two images on the window, <code>pg</code> first (the 3D rendering) <span class="CodeAnnotation" aria-label="annotation3">3</span> followed by <code>g2</code> (the stencil) <span class="CodeAnnotation" aria-label="annotation4">4</span>. The transparent parts of <code>g2</code> allow the 3D scene to be seen through the window portions.</p>
<p>The user can control the viewpoint for the 3D scene using the keyboard in the usual way <span class="CodeAnnotation" aria-label="annotation5">5</span>. The 3D scene changes as a consequence of the change in the viewpoint, but the 2D scene does not. The result is that the window stays in the same place but the view seen through it (the transparent portions) changes as a function of that viewpoint, as if the user were inside a moving vehicle looking at a scene outside.</p>
<aside epub:type="sidebar">
<div class="top hr"><hr/></div>
<section class="boxcustom1">
<pre><code>int ex=-70, ey=0, ez=-225, cx=0, cy=0, cz=0;
float dx, dz, angle=74;
PGraphics pg, g2;
PImage back;

void setup ()
{
  size(200, 200, P2D);
  surface.setResizable(true);
  back = loadImage ("window.gif");
  surface.setSize(back.width, back.height);
  pg = createGraphics(back.width, back.height,   <span class="CodeAnnotationHang" aria-label="annotation1">1</span>P3D);
  g2 = createGraphics (back.width, back.height);
  g2.beginDraw(); g2.image(back, 0, 0); g2.endDraw();
}
void draw () 
{
  background (200);
  pg.beginDraw();
  pg.background(0,0,200); 
  <span class="CodeAnnotationHang" aria-label="annotation2">2</span> pg.camera (ex, ey, ez, cx, cy, cz, 0.0, -1.0, 0.0);
  pg.ambientLight (0, 200, 0);
  pg.translate (100, 0, 100); pg.box(20); pg.translate (-100, 0, -100);
  pg.translate (-100, 0, 100); pg.box(20); pg.translate (100, 0, -100);
  pg.translate (100, 0, -100); pg.box(20); pg.translate (-100, 0, 100);
  pg.translate (-100, 0, -100); pg.box(20); pg.translate (100, 0, 100); 
  pg.endDraw();
  <span class="CodeAnnotationHang" aria-label="annotation3">3</span> image(pg, 0, 0);   <span class="CodeAnnotationHang" aria-label="annotation4">4</span>image (g2, 0, 0);
}

void keyPressed ()
{
  <span class="CodeAnnotationHang" aria-label="annotation5">5</span> if (key == 'w')   // Move 'forward'
  {   ex += 5*dx;   ez += 5*dz;  
  }
  else if (key == 's')  // Move 'backward'
  {   ex -= 5*dx;    ez -= 5*dz;   
  }
  else if (key == 'a')     // Turn left a unit (CCW)
    angle = angle + 1.0;
  else if (key == 'd')     // Turn right a unit (CW)
    angle = angle - 1.0;
  dx = cos(radians(angle)); dz = sin(radians(angle));
  cx = (int)(dx*20000.0);  // cx = x coordinate of center point = cos(angle)*20000
  cz = (int)(dz*20000.0);  // cz = z coordinate of center point = sin(angle)*20000
}</code></pre>
<span epub:type="pagebreak" title="139" id="Page_139"/><figure class="graphic"><img src="Images/g062001.png" alt="g062001" width="448" height="198"/></figure>
<figure class="graphic"><img src="Images/g062002.png" alt="g062002" width="447" height="197"/></figure>
<div class="bottom hr"><hr/></div>
</section>
</aside>
<h2 id="h1-501645c08-0003" class="HeadProject"><span><span epub:type="pagebreak" title="140" id="Page_140"/>Sketch 63: The PShape Object—A Rotating Planet</span></h2>
<p class="BodyFirst">This sketch will display a rotating planet (a sphere) and allow the user to move around it in 3D. The new part in this sketch is texture-mapping the planet’s surface onto the sphere, which is really a collection of polygons. One way to do this would be to build a model of a sphere out of polygons and do the texture-mapping within a <code>beginShape()</code> and <code>endShape()</code> block. An easier way is to use a <code>PShape</code> object, which is a data type for storing arbitrary shapes.</p>
<p>To implement the rotating planet, we’ll create a <code>PShape</code> object through a call to <code>createShape()</code>, which allows us to build arbitrarily complex shapes using the large set of drawing operations provided by the <code>PShape</code> class. It is possible to create almost anything using a <code>PShape</code>, and the documentation available online is necessary for complex creations. Our case is simple, because a sphere is one of the shapes provided. This is the call that makes the planet, where <code>globe</code> is a <code>PShape</code> object <span class="CodeAnnotation" aria-label="annotation1">1</span>:</p>
<pre><code>globe = createShape(SPHERE, 100);  // 100 is the size of the sphere</code></pre>
<p>The texture, a map of Mars as a <code>PImage</code> variable named <code>timg</code>, is applied using <code>globe.setTexture(timg)</code> <span class="CodeAnnotation" aria-label="annotation2">2</span>.</p>
<p>Then we display the planet in <code>draw()</code> using a call to the <code>shape()</code> function <span class="CodeAnnotation" aria-label="annotation3">3</span>:</p>
<pre><code>translate (x, y, z);
globe.rotateY(radians(0.5));  // rotateY function is a part of PShape
shape(globe);                 // This displays the shape in the window</code></pre>
<p>This code positions the sphere in the center of the field of view and rotates it about its own axis before displaying it. The usual keys allow the user to change the viewing position.</p>
<aside epub:type="sidebar">
<div class="top hr"><hr/></div>
<section class="note">
<h2><span class="NoteHead">NOTE</span></h2>
<p>	A 3D modeling package such as 3D Studio Max or Maya creates shapes such as cars and chairs out of polygons and saves them to a file with the suffix <em>.obj</em>. Animations and games use polygon files to create objects within their imaginary worlds by rendering and texture-mapping the polygons. Processing programs use the <code>loadShape(</code><code>)</code> function to read an <em>.obj</em> file and return a Processing <code>PShape</code> object. Here is an example code sequence:</p>
<pre><code>PShape s;
s = loadShape ("chair.obj");
shape (s);</code></pre>
<div class="bottom hr"><hr/></div>
</section>
</aside>
<aside epub:type="sidebar">
<div class="top hr"><hr/></div>
<section class="boxcustom1">
<pre><code>int x=100, y=100, z=100;            // Sphere position
int eyex=100, eyey=100, eyez=400;   // Viewpoint
int cx=100, cy=100, cz=100;         // Point we are looking at
PShape globe;
PImage timg;
float theta=270, dx=0, dz=0;

void setup ()
{
  size (400, 400, P3D);
  frameRate(10);
  timg = loadImage("globe03.jpg");
  <span class="CodeAnnotationHang" aria-label="annotation1">1</span> globe = createShape(SPHERE, 100);    
  globe.setStroke(255);
  <span class="CodeAnnotationHang" aria-label="annotation2">2</span> globe.setTexture(timg);  
}

void draw ()
{
  background (45, 45, 120);
  camera(eyex, eyey, eyez, 
        cx, cy, cz, 0, 1, 0);
  translate (x, y, z);
  globe.rotateY(radians(0.5));
  <span class="CodeAnnotationHang" aria-label="annotation3">3</span> shape(globe);
}

void keyPressed ()
{
  if (key == 'w')           // Move 'forward'
  {  eyex += 5*dx;   eyez += 5*dz;  }
  else if (key == 's')      // Move 'backward'
  {  eyex -= 5*dx;    eyez -= 5*dz;   } 
  else if (key == 'a')      // Turn left a unit (CCW)
    theta = theta + 1.0;
  else if (key == 'd')      // Turn right a unit (CW)
    theta = theta - 1.0;
  dx = cos(radians(theta)); dz = sin(radians(theta));
  cx = (int)(dx*20000.0);  
  cz = (int)(dz*20000.0);  
}</code></pre>
<span epub:type="pagebreak" title="141" id="Page_141"/><figure class="graphic"><img src="Images/g063001.png" alt="g063001" width="515" height="515"/></figure>
<div class="bottom hr"><hr/></div>
</section>
</aside>
<h2 id="h1-501645c08-0004" class="HeadProject"><span><span epub:type="pagebreak" title="142" id="Page_142"/>Sketch 64: Splines—Drawing Curves</span></h2>
<p class="BodyFirst">So far, we’ve rendered simple geometric objects like lines, ellipses, rectangles, and spheres using predefined Processing functions. But many real-world objects are not linear or elliptical; they have complex shapes. Examples are legion, including cars, fan blades, jewelry, clothing, and living things—even graphs of data. In Processing, complex shapes are rendered using curves. To demonstrate, this sketch allows the user to draw curves using a series of mouse clicks and to see how the selected “control points” affect the curves.</p>
<p>Processing uses <em>splines</em> to render curves. In the earlier days of drafting, when people used pencils and T-squares, people used something called a <span class="KeyTerm">spline</span> to draw smooth, oddly shaped curves. It was a long, flexible metal strip that could hold a shape, align with points on paper, and allow the drafter to connect them using a pencil. Mathematically, a spline is a polynomial function that approximates a curve by using a set of points. The details can be complex, but the idea is to use many polynomials connected end to end to build the curve. Processing hides the complexity.</p>
<p>Processing provides a function named <code>curve()</code> that implements a type of polynomial named the <span class="KeyTerm">Catmull-Rom spline</span>. This function uses four points to define each section of the curve. The first two define the direction the curve will have at the beginning, and the second two define the direction it will have at the end. The curve itself consists of a set of points (pixels) between the middle two points. As seen in <a href="#figure64-1" id="figureanchor64-1">Figure 64-1</a>, the angle defined by the first two points establishes the direction of the curve at point P<sub>1</sub>, which defines the shape of the polygon between P<sub>1</sub> and P<sub>2</sub>; we establish the direction of the curve at P<sub>2</sub> by the direction between P<sub>2</sub> and P<sub>3</sub>. In the figure, the points P<sub>1</sub> and P<sub>2</sub> in the two examples are the same, but the curves have a different shape due to the different positions of P<sub>0</sub> and P<sub>3</sub>.</p>
<figure>
<img src="Images/f064001.png" alt="f064001" class="" width="293" height="250"/>
<figcaption><p><a id="figure64-1">Figure 64-1</a>: Control points of a spline curve</p></figcaption>
</figure>
<p>This is the function call used in Processing to draw a curve section between P<sub>1</sub>=(x1,y1) and P<sub>2</sub>=(x2,y2):</p>
<pre><code>curve (x0,y0,  x1,y1,  x2,y2,  x3,y3);</code></pre>
<p>The start and end points, (<code>x0</code>, <code>y0</code>) and (<code>x3</code>, <code>y3</code>), control the shape <span class="CodeAnnotation" aria-label="annotation1">1</span>. To draw a longer curve, we need multiple calls to <code>curve()</code>, with the endpoints of one being the beginning of the next. </p>
<p>This sketch allows the user to select points, drawn as small red circles using mouse clicks <span class="CodeAnnotation" aria-label="annotation2">2</span>, and to observe the shape change caused by the position of the next point as the mouse moves. Four points define a curve, so when the user selects the fourth point, a red curve is drawn using the points specified, and then a blue curve that changes as the mouse moves is drawn from the final point to the mouse position, (<code>mouseX</code>, <code>mouseY</code>). Clicking again will add a new point to the curve, extending the red portion to include the new point and <span epub:type="pagebreak" title="143" id="Page_143"/>showing a new blue section. Pressing the BACKSPACE key deletes the last point in the curve <span class="CodeAnnotation" aria-label="annotation3">3</span>, and the spacebar turns the drawing of the final (blue) section on and off <span class="CodeAnnotation" aria-label="annotation4">4</span>. </p>
<p>This sketch keeps the point coordinates in arrays <code>x</code> and <code>y</code> and passes successive groups of four coordinates to <code>curve()</code>.</p>
<aside epub:type="sidebar">
<div class="top hr"><hr/></div>
<section class="boxcustom1">
<pre><code>final int SIZE = 200;
float x[] = new float[SIZE];
float y[] = new float[SIZE];
int N = 0;
boolean drawLast = true;

void setup ()
{
  size(400,400);
  noFill();
}

void draw ()
{
  background(200);
  stroke(255, 102, 0);
  if(drawLast)
    for (int i=0; i&lt;N; i++) ellipse (x[i], y[i], 2, 2);
  if (N&gt;=4)
  {
    for (int i=0; i&lt;=N-4; i++)
    <span class="CodeAnnotationHang" aria-label="annotation1">1</span> curve (x[i],y[i], x[i+1],y[i+1], 
           x[i+2],y[i+2], x[i+3],y[i+3]);
    stroke(0,0,200);
    if (drawLast)
      curve (x[N-3],y[N-3], x[N-2],y[N-2], 
             x[N-1],y[N-1], mouseX, mouseY);
  }
}

void mousePressed ()
{
  <span class="CodeAnnotationHang" aria-label="annotation2">2</span> x[N] = mouseX; y[N] = mouseY;
}

void mouseReleased () 
{  if (N &lt; SIZE-1) N = N + 1;  }

void keyPressed ()
{
  <span class="CodeAnnotationHang" aria-label="annotation3">3</span> if (key == BACKSPACE &amp;&amp; N&gt;0) N=N-1;
  <span class="CodeAnnotationHang" aria-label="annotation4">4</span> if (key == ' ') drawLast = !drawLast;  // ! means 'not'
}</code></pre>
<figure class="graphic"><img src="Images/g064001.png" alt="g064001" width="309" height="309"/></figure>
<figure class="graphic"><img src="Images/g064002.png" alt="g064002" width="309" height="309"/></figure>
<figure class="graphic"><img src="Images/g064003.png" alt="g064003" width="308" height="309"/></figure>
<div class="bottom hr"><hr/></div>
</section>
</aside>
<h2 id="h1-501645c08-0005" class="HeadProject"><span><span epub:type="pagebreak" title="144" id="Page_144"/>Sketch 65: A Driving Simulation with Waypoints</span></h2>
<p class="BodyFirst">Sketch 60 allowed a user to drive around a track in 3D, and Sketch 64 illustrated how to create curves, like a track that a simulated car could drive on. Computer driving games often have automated vehicles that compete with the player, giving the impression of being a real opponent. This sketch will implement a system for computer-controlled cars that is similar to the methods used in those computer games. </p>
<p>It’s important to realize that games and simulations do not necessarily do things the way people do. A human driver would orient the car based on the next turn they could see and would steer continually to remain on the track. We could build a computer program to do this too, but it would be pretty complicated. Another option is to use predetermined knowledge about the track to steer the vehicle. In this case, the programmer has to provide more information to the program at the outset, but the resulting simplicity in the code is worth the effort.</p>
<p>To be specific, the programmer breaks up the track into linear pieces. The linear pieces should be as long as possible and join to each other at vertices called <span class="KeyTerm">waypoints</span>, places where the direction of the line, and hence the car, changes. (We can dissect any curve this way.) Each waypoint has a number or a label assigned by the programmer. When the car is at waypoint 1, the program will change its direction of motion to move toward waypoint 2. When it arrives at waypoint 2, it will steer to waypoint 3. Because the segments are lines, we don’t need to steer between waypoints.</p>
<p>This sketch implements waypoints as a collection of arrays, each array containing one dimension of the waypoints. The location of waypoint <code>i</code> is in the array locations <code>wpx[i]</code> and <code>wpy[i]</code> <span class="CodeAnnotation" aria-label="annotation1">1</span>. In a more accurate simulation, a waypoint would have much more information associated with it: changes in speed and acceleration, rate of change of the turn, and perhaps graphical information like brake lights turning on. In the current sketch, the only other thing needed is the angle between the current and the next waypoint so that we can rotate the car to face the new direction. We could calculate this, but it would take more code, and the positions of the waypoints and the angles between them can be determined in advance. We declare arrays <code>wpx</code>, <code>wpy</code>, and <code>wpa</code> <span class="CodeAnnotation" aria-label="annotation2">2</span> and initialize them with the position and angle data, which implicitly defines the size of the arrays. (It is not possible to both specify the size of an array using a number and initialize it using data.)</p>
<p>Using the vehicle’s assigned <code>speed</code> (changed using <span class="KeyCaps">W</span> and <span class="KeyCaps">S</span>), we compute its position change during each frame as <code>dx = speed * ( wpx(i+1) - wpx(i) )/d(i,i+1)</code><sub> </sub>where <code>d(i,i+1)</code> is the distance between waypoints <code>i</code> and <code>i+1</code> <span class="CodeAnnotation" aria-label="annotation4">4</span>. We say that the vehicle has arrived at waypoint <code>i</code> when it is within <code>speed</code> pixels of it, at which point it changes direction and aims for the next waypoint, <code>i+1</code> <span class="CodeAnnotation" aria-label="annotation3">3</span>. The <code>wayPoint</code> variable indicates the last waypoint encountered, meaning that the vehicle is aiming for <code>wayPoint+1</code>. The waypoint count wraps around at the end, so we increment modulo-<em>N</em> where <em>N</em> is the number of waypoints: the waypoint following <em>N</em> is 0.</p>
<p>Pressing the spacebar allows the user to see where the waypoints and paths are.</p>
<aside epub:type="sidebar">
<div class="top hr"><hr/></div>
<section class="boxcustom1">
<pre><code><span class="CodeAnnotationHang" aria-label="annotation1">1</span> float wpx[] = { 172, 221, 354, 787, 848, 846, 747, 645, 198};
float wpy[] = { 217, 166, 129, 100, 165, 536, 869, 884, 734};
<span class="CodeAnnotationHang" aria-label="annotation2">2</span> float wpa[] = { 39, 70, 80, 135, 175, 195, 260, 290, 354}; // Degrees
PImage track;
float x=wpx[8], y=wpy[8], dx, dy;
int wayPoint = 8, speed=2, N= wpx.length;
boolean lines = true;
void setup ()
{
  size(100,100);
  surface.setResizable(true);
  track = loadImage("road.png");
  surface.setSize(track.width, track.height);
}

void draw ()
{
  fill (255, 0, 0);
  image(track, 0, 0);
  if (lines) for (int i=0; i&lt;N; i++)   // Draw lines?
    line(wpx[i], wpy[i], wpx[(i+1)%N], wpy[(i+1)%N]);
  translate (x, y);                    // Rotate car to face motion
  rotate (radians(wpa[wayPoint]));
  rect (0, 0, 5, 10);                  // Arrived at waypoint?
  <span class="CodeAnnotationHang" aria-label="annotation3">3</span> if (distance (x, y, wpx[(wayPoint+1)%N], wpy[(wayPoint+1)%N]) &lt; speed)
  {
    wayPoint = (wayPoint+1)%N;         // Yes. Aim at next one
    x = wpx[wayPoint];
    y = wpy[wayPoint];
  }                     // Change x and y car position
  <span class="CodeAnnotationHang" aria-label="annotation4">4</span> dx = speed * (wpx[(wayPoint+1)%N]-wpx[wayPoint])/
        distance (wpx[wayPoint],wpy[wayPoint], wpx[(wayPoint+1)%N],
        wpy[(wayPoint+1)%N]);
  dy = speed* (wpy[(wayPoint+1)%N]-wpy[wayPoint])/
        distance (wpx[wayPoint],wpy[wayPoint], wpx[(wayPoint+1)%N],
        wpy[(wayPoint+1)%N]);
  x = x + dx; y = y + dy;
}

float distance (float x0, float y0, float x1, float y1)
{ return sqrt ( (x0-x1)*(x0-x1) + (y0-y1)*(y0-y1) ); }

void keyPressed ()
{
  if (key == ' ') lines = !lines;                // Toggle waypoint display.
  if (key == 'w') speed = speed+1;               // Faster
  if (key == 's') if (speed&gt;0) speed = speed-1;  // Slower, but not backwards
}</code></pre>
<span epub:type="pagebreak" title="145" id="Page_145"/><figure class="graphic"><img src="Images/g065001.png" alt="g065001" width="354" height="336"/></figure>
<div class="bottom hr"><hr/></div>
</section>
</aside>
<h2 id="h1-501645c08-0006" class="HeadProject"><span><span epub:type="pagebreak" title="146" id="Page_146"/>Sketch 66: Many Small Objects—A Snowstorm</span></h2>
<p class="BodyFirst">A Processing program redraws the screen many times each second. Visible objects must be redrawn in each frame, and to do so the program must save the graphical parameters (size, location, shape, and color) of all of them. Drawing each object takes time, so if there are many, is it still possible to redraw them all quickly enough? In many cases it is, if the objects themselves are not complex. This sketch will draw snow falling, with each snowflake being an object that moves realistically between frames. </p>
<p>Snowflakes are, in fact, very complex shapes, but from a distance they are just white blobs. We’ll draw them as small rectangles whose width and height vary by a small random value each frame to simulate the effect of the snowflake fluttering as it falls <span class="CodeAnnotation" aria-label="annotation1">1</span>. We set the dimensions with the formula <code>width = size + random(3)-1.5</code>.</p>
<p><code>size</code> is a constant set to <code>3</code>, and the value of <code>random(3)</code> is a number between 0 and 3, so <code>random(3)-1.5</code> will have a value between −1.5 and +1.5, creating a change in the size between 1.5 and 4.5. Each snowflake also has a slightly different falling speed <span class="CodeAnnotation" aria-label="annotation5">5</span>. This gives the illusion of depth because flakes that fall faster appear nearer to the viewer than ones that fall slower. The speed is selected at random, but it yields the desired effect.</p>
<p>The program creates snowflakes at the top of the screen and gives them a downward (+y) speed, which will make them appear to fall. To track the position, size, and speed in both the x- and y-directions, we use arrays: for example, the array <code>x</code> stores the x position, and <code>x[i]</code> is the x location of the <code>i</code><sup>th</sup> snowflake. The array size, given by the constant <code>SIZE</code>, is the maximum number of snowflakes. (The value here is 5,000, found by trial and error based on the observed number needed given the background and the maximum rate of snowfall.)</p>
<p>Snow does not normally fall straight down; we observe it drifting and floating with air currents. The speed at which the snowflakes fall remains constant, but the x position of each flake changes a bit at random as it falls to try to give the illusion of real snow <span class="CodeAnnotation" aria-label="annotation2">2</span>. If we set <code>dx</code> to a nonzero value, it simulates a wind, and snow will blow in the specified direction.</p>
<p>Each frame, we generate up to 30 new snowflakes with random horizontal positions and y-coordinates of 0 <span class="CodeAnnotation" aria-label="annotation4">4</span> (at the top of the window, to maintain the illusion). The number of snowflakes created during each frame is random but is a function of the y position of the mouse <span class="CodeAnnotation" aria-label="annotation3">3</span>. The nearer the mouse is to the top of the screen, the less snow will appear to fall. This is the number of flakes created:</p>
<pre><code>N = (int)random (((float)mouseY/height)*30);</code></pre>
<p class="BodyContinued">This means that almost no flakes will fall for small values of <code>mouseY</code>, while the maximum of up to 30 new snowflakes during each frame occurs when <code>mouseY/height</code> is at its maximum of 1.0.</p>
<p>The global variable <code>SIZE</code> has a value of 5,000, which is the number of snowflakes that can be on the screen at any time. Initially there are only a few, but the array will fill up quickly. When all 5,000 array elements are occupied, we start over again at 0, assuming that the snowflakes at the beginning of the array have fallen past the bottom of the screen and are not visible. This technique is referred to as a <span class="KeyTerm">circular array</span>.</p>
<aside epub:type="sidebar">
<div class="top hr"><hr/></div>
<section class="boxcustom1">
<pre><code>final int SIZE = 5000;
float x[] = new float[SIZE];
float y[] = new float[SIZE];
float dx[] = new float[SIZE];
float dy[] = new float[SIZE];
float size[] = new float[SIZE];
int last = 0, N=0;
PImage background;

void setup ()
{
  size(100,100);
  surface.setResizable(true);
  background = loadImage("background.png");
  surface.setSize (background.width, background.height);
  for (int i=0; i&lt;SIZE; i++) x[i] = -1;
}

void draw ()
{
  fill (210);
  noStroke();
  image (background, 0, 0);
  for (int i=0; i&lt;SIZE; i++)  // Draw existing
  {
    if (x[i] &gt;= 0)
    {
      rect(x[i], y[i],   <span class="CodeAnnotationHang" aria-label="annotation1">1</span> size[i]+random(3)-1.5, size[i]+random(3)-1.5);
      <span class="CodeAnnotationHang" aria-label="annotation2">2</span> x[i] = x[i] + dx[i] + random (3)-1.5;
      y[i] = y[i] + dy[i];
    } }

  <span class="CodeAnnotationHang" aria-label="annotation3">3</span> N = (int)random (((float)mouseY/height)*30);  // Create new
  for (int i=0; i&lt;N; i++)
  {
    <span class="CodeAnnotationHang" aria-label="annotation4">4</span> x[last] = random(width); y[last] = 0;
    <span class="CodeAnnotationHang" aria-label="annotation5">5</span> dx[last] = 0; dy[last] = random(2)+1;
    size[last] = 3;
    last = last + 1;
    if (last &gt;=SIZE) last = 0;
  }
}</code></pre>
<span epub:type="pagebreak" title="147" id="Page_147"/><figure class="graphic"><img src="Images/g066001.png" alt="g066001" width="375" height="300"/></figure>
<figure class="graphic"><img src="Images/g066002.png" alt="g066002" width="375" height="300"/></figure>
<div class="bottom hr"><hr/></div>
</section>
</aside>
<h2 id="h1-501645c08-0007" class="HeadProject"><span><span epub:type="pagebreak" title="148" id="Page_148"/>Sketch 67: Particle Graphics—Smoke</span></h2>
<p class="BodyFirst">Some things are difficult to model using polygons: soft and amorphous shapes like water, fire, clouds, and smoke, for example. Such things can move in unpredictable ways and expand to fill arbitrary shapes. This sketch will draw smoke emitting from a smokestack and illustrate a key method in modern computer graphics: a <span class="KeyTerm">particle system</span>.</p>
<p>A particle system combines a large number of small objects to form a complex shape. The objects are usually simple, like spheres or circles, and have a set of parameters that control their display. The basic parameters of a circle are position, velocity, color, and size. Initial parameters usually have a random element: speed plus or minus a random number, for example. An <span class="KeyTerm">emitter</span> is the location where the system creates new particles (circles), usually with a small, random displacement, so the particles aren’t exactly at the emitter. </p>
<p>The particle system in this sketch produces a large number of overlapping circles, possibly somewhat transparent, moving with slightly different speeds (not unlike the previous sketch except for density). The previous sketch drew a large number of small objects that could still be seen as individual snowflakes. In this sketch, if enough of these particles exist, we can’t distinguish them individually, and they form an object in combination. As the number increases and the objects overlap, the result looks like fog or smoke.</p>
<p>The sketch defines a large number of circles to be created (<code>SIZE</code>) and declares arrays to hold the position, speed, and size of each one: the value of <code>x[121]</code> is the x position of the 121st circle, for example. Initially there are none, and the variable <code>last</code> holds the index of the last one defined. We increment <code>last</code> each frame as we create new circles, and we reset it to zero when the number exceeds <code>SIZE</code>. </p>
<p>The <code>draw()</code> function first runs through the arrays and draws each circle that exists (meaning <code>x[i] &gt; 0</code>) <span class="CodeAnnotation" aria-label="annotation1">1</span>. It changes the circle’s position by a small random amount, may change the size slightly, and gives it a color that varies around RGB = (205, 205, 150). It then creates a random number of new circles, giving them positions near the emitter, a vertical speed, and a small size <span class="CodeAnnotation" aria-label="annotation2">2</span>.</p>
<p>The effect is striking. With up to 800 circles, the system yields a remarkably good impression of smoke moving upward. The sketch reads and displays a background image of a smokestack for a better visual effect.</p>
<p>The outline around the circles has been turned off with <code>noStroke()</code>, but it is educational to delete that statement and run the program so that the particles can be seen. The way the particles move and overlap is clearer, as in <a href="#figure67-1" id="figureanchor67-1">Figure 67-1</a>.</p>
<figure>
<img src="Images/f067001.png" alt="f067001" class="" width="531" height="398"/>
<figcaption><p><a id="figure67-1">Figure 67-1</a>: Particles showing the outline of the circles</p></figcaption>
</figure>
<aside epub:type="sidebar">
<div class="top hr"><hr/></div>
<section class="boxcustom1">
<pre><code>final int SIZE = 800;
float x[] = new float[SIZE];
float y[] = new float[SIZE];
float dx[] = new float[SIZE];
float dy[] = new float[SIZE];
float size[] = new float[SIZE];
int last = 0;
PImage background;
int emitterx=252, emittery=200;

void setup ()
{
  size(100,100);
  surface.setResizable(true);
  background = loadImage ("background.png");
  surface.setSize(background.width, background.height);
  for (int i=0; i&lt;SIZE; i++) x[i] = -1;
}

void draw ()
{
  int N=0;

  noStroke();
  
  image (background, 0, 0);
  for (int i=0; i&lt;SIZE; i++)  // Draw existing particles
    <span class="CodeAnnotationHang" aria-label="annotation1">1</span> if (x[i] &gt; 0)
    {        // Vary the color slightly
      fill (200+random(10), 200+random(10), 150, 64);
      ellipse (x[i], y[i], size[i], size[i]);  // Draw circle
      x[i] = x[i] + random(3)-1.5;             // Jiggle X
      y[i] = y[i] + dy[i] + random(3)-1.5;     // Move up
      size[i] = size[i] + random(3)-1.5;       // Change size
    }

    N = (int)random(15);    // Create N new particles
    <span class="CodeAnnotationHang" aria-label="annotation2">2</span> for (int i=0; i&lt;N; i++)
    {
      last = (last+1);
      if (last &gt;= SIZE) last = 0;
      x[last] = emitterx+random(2)-1;   // X position (emitter)
      y[last] = emittery;               // Y position (emitter)
      dx[last] = 0; dy[last] = -2;      // Initial speed (up)
      size[last] = 4;                   // Initial size
    }
}</code></pre>
<span epub:type="pagebreak" title="149" id="Page_149"/><figure class="graphic"><img src="Images/g067001.png" alt="g067001" width="332" height="249"/></figure>
<figure class="graphic"><img src="Images/g067002.png" alt="g067002" width="332" height="250"/></figure>
<div class="bottom hr"><hr/></div>
</section>
</aside>
<h2 id="h1-501645c08-0008" class="HeadProject"><span><span epub:type="pagebreak" title="150" id="Page_150"/>Sketch 68: Saving a State—A Spinning Propeller</span></h2>
<p class="BodyFirst">This sketch will draw a spinning propeller. We can code this in many ways, some of them simpler than the method in this sketch, but the purpose here is to use a simple example to explain how and why to save (and restore) the <span class="KeyTerm">geometric state</span> of a sketch.</p>
<p>The geometric state is the resultant combination of all the translation, rotation, and scaling that accumulate during the display of an object up to a specific point in the drawing process. Rotating an object about its center means first translating the origin to the center of the object, doing the rotation, and then translating the origin back to the original location. If the state is not restored by undoing the translation, then all objects drawn from that time on will translate to the location of the object.</p>
<p>The current state, whatever it is, including all rotation, translation, and scaling, is saved using a call to the function <code>pushMatrix()</code> and is restored by a call to <code>popMatrix()</code>. These calls must always occur in pairs, like brackets; a call to <code>pushMatrix()</code> always has a corresponding call to <code>popMatrix()</code>. For example, you could save and restore state while rotating a triangle about its center at (100, 100), shown in <a href="#figure68-1" id="figureanchor68-1">Figure 68-1</a>, as follows:</p>
<pre><code>pushMatrix();
translate (100, 100);
rotate(angle);
triangle (0.-20, 20, -20, -20, 20);
popMatrix();</code></pre>
<p>At this point, the origin and rotation angle are back to their original values, and the next object can be drawn from a clean state.</p>
<p>This sketch draws a propeller with four sections, each being one blade, which is an image. We draw this blade four times: once in the original orientation, and then three times each rotated about the propeller center point by 90 degrees <span class="CodeAnnotation" aria-label="annotation1">1</span>. Each section drawn uses a save and restore:</p>
<pre><code>pushMatrix();            // Save 
rotate(PI);              // Rotate 
image (prop, 0, 0);      // Draw 
popMatrix();             // Restore</code></pre>
<p>The four-section propeller is drawn inside a <code>drawProp(x,y)</code> function that saves the state on entering the function, then translates to (<code>x</code>, <code>y</code>), scales the image, rotates it, updates the angle so the next call to <code>drawProp()</code> draws the propeller at a different angle <span class="CodeAnnotation" aria-label="annotation2">2</span>, and draws the four sections. We use multiple calls to the <code>drawProp()</code> function to draw a rotating propeller at multiple locations. </p>
<figure>
<img src="Images/f068001.png" alt="f068001" class="" width="411" height="291"/>
<figcaption><p><a id="figure68-1">Figure 68-1</a>: The transformations needed to rotate an object about its center</p></figcaption>
</figure>
<aside epub:type="sidebar">
<div class="top hr"><hr/></div>
<section class="boxcustom1">

<pre><code>PImage prop;
float angle = 0.0;
void setup ()
{
  prop = loadImage("props.gif");
  size(400, 200);
}

void draw ()
{
  background(255); 
  fill (128); noStroke();
  ellipse (175, 100, 30, 40);  // Draw simple aircraft
  rect (50, 95, 250, 10);
  stroke (128);
  line (175, 100, 175, 75);
  drawProp (100, 100);         // Left propeller
  drawProp (250, 100);         // Right propeller
}

void drawProp(int x, int y)
{
  <span class="CodeAnnotationHang" aria-label="annotation1">1</span> pushMatrix();    // Save state on entry to the function
  translate(x, y); // Translate to the specified propeller position
  scale (0.2);     // Make it smaller
  rotate(angle);   // rotate the propeller as a whole
  <span class="CodeAnnotationHang" aria-label="annotation2">2</span> angle = angle + 0.1;     
  image (prop, 0, 0);      // Draw the first prop section
  pushMatrix();            // save state
    rotate(PI/2);          // Rotate 90 degrees
    image (prop, 0, 0);    // draw second prop section
  popMatrix();             // restore
  pushMatrix();            // Save again
    rotate(PI);            // Rotate by 180 degrees
    image (prop, 0, 0);    // draw third prop section
  popMatrix();             // Restore
  pushMatrix();            // save one more time
    rotate(-PI/2);         // Rotate 270 degrees (-90)
    image (prop, 0, 0);    // Draw final section
  popMatrix();             // restore
  ellipse (0, 0, 30, 30);  // draw the center part of the propeller
  popMatrix();             // Restore state to what it was when function was called
}</code></pre>
<span epub:type="pagebreak" title="151" id="Page_151"/><figure class="graphic"><img src="Images/g068001.png" alt="g068001" width="379" height="189"/></figure>
<figure class="graphic"><img src="Images/g068002.png" alt="g068002" width="379" height="188"/></figure>
<div class="bottom hr"><hr/></div>
</section>
</aside>
<h2 id="h1-501645c08-0009" class="HeadProject"><span><span epub:type="pagebreak" title="152" id="Page_152"/>Sketch 69: L-Systems—Drawing Plants</span></h2>
<p class="BodyFirst">Drawing realistic-looking plants is difficult. Living things do not usually contain straight lines, which is what computers draw best. In addition, there is a random nature to life forms that humans recognize, so we are critical of renderings. In 1968 a botanist named Aristid Lindenmayer developed a scheme for describing the growth of fungi and algae, and then later expanded it to deal with more advanced plant life. This was in turn adapted by computer graphics practitioners into a scheme for drawing plants. We call this scheme an <span class="KeyTerm">L-system</span>.</p>
<p>An L-system is technically a <span class="KeyTerm">grammar</span>, which is a set of rules for making strings. If a grammar has two rules, X -&gt; Xf and X -&gt; z, then it is showing how to take a symbol, X, and transform it into a sequence of characters. For each X, we choose which replacement rule to follow, and we continue replacing capital Xs (referred to as <span class="KeyTerm">non-terminal symbols</span>) until there are no more left to replace. Here’s an example expansion for this grammar: X -&gt; Xf -&gt; Xff -&gt; Xfff -&gt; zfff. </p>
<p>In an L-system, a grammar that can define a plant, the final string represents a recipe for drawing something. It uses the following symbols:</p>
<ol class="none">
<li><span class="RunInHead">f</span>  Draw a straight line segment. </li>
<li><span class="RunInHead">[</span>  Save the current state (<code>pushMatrix()</code>).</li>
<li><span class="RunInHead">]</span>  Go back to the previous state (<code>popMatrix()</code>).</li>
<li><span class="RunInHead">+</span>  Rotate by a fixed positive angle.</li>
<li><span class="RunInHead">-</span>  Rotate by a fixed negative angle.</li>
</ol>
<p>The grammar uses two rules to produce a string of these symbols:</p>
<ol class="none">
<li>X -&gt; ff</li>
<li>X -&gt; f–[[X]+X]+f[+fX]–X</li>
</ol>
<p>Unless the plant consists of only two straight lines (ff), the first step would be X –&gt; f–[[X]+X]+f[+fX]–X. Then each X would be replaced by the right side of a production, so the second step might be f–[[X]+X]+f[+fX]–X –&gt; f–[[ f–[[X]+X]+f[+fX]–X]+ff]+f[+ff]–ff, followed perhaps by f–[[ f–[[ff]+ff]+f[+fff]–ff]+ff]+f[+ff]–ff, which can now be drawn.</p>
<p>The <code>makeString()</code> function <span class="CodeAnnotation" aria-label="annotation1">1</span> calls itself to expand the non-terminal X symbols into strings and append these to the string being constructed. It will only call itself to a depth specified by the first parameter, <code>levels</code>, and will then return, thus guaranteeing that the program will eventually end. The string generated by the grammar is passed to the <code>drawPlant()</code> function <span class="CodeAnnotation" aria-label="annotation2">2</span>, which executes each character as a graphical operation, thus drawing the plant. In the function <code>void</code> <code>drawPlant(float length, float angle, String s, int drawLevel)</code>, the first parameter, <code>length</code>, is the length of the line to draw (for the symbol f); the <code>angle</code> is the rotation angle for the + and - characters; <code>s</code> is the string generated by <code>makeString()</code>; and <code>drawLevel</code> indicates a depth level for drawing lines. Essentially, <code>makeString()</code> creates a string that is a program for how to draw the plant, and <code>drawPlant()</code> executes that program.</p>
<aside epub:type="sidebar">
<div class="top hr"><hr/></div>
<section class="boxcustom1">
<pre><code>public void setup () 
{  
    String rules;
    size(800, 800, P2D); stroke(0);    
    translate(width/2,height); 
    rules = makeString(6, "X");  
    drawPlant (4, 22, rules,rules.length()-1);    
}

<span class="CodeAnnotationHang" aria-label="annotation1">1</span> String makeString(int levels, String s)
{
  String next = "";
  char c;
  if (levels &gt; 0) 
  { // Check if there are any levels left to render
    for (int i=0; i&lt;s.length(); i++)
    {
      c = s.charAt(i);
      if (c == 'X')
        next+=makeString(levels-1, "F-[[X]+X]+F[+FX]-X");
      else if (c == 'F') next += makeString(levels-1, "FF");
      else next = next + c;                    
    }
  } else next = s;
  return next;
} 

<span class="CodeAnnotationHang" aria-label="annotation2">2</span> void drawPlant(float length, float angle, String s, int drawLevel)
{ 
  char c;
  int i=0;
  for (int j=0; j&lt;s.length(); j++)
  {
    c = s.charAt(j);
    if (c == '-') rotate(radians(angle));
    else if (c == '+') rotate(-radians(angle));
    else if (c == '[') pushMatrix();
    else if (c == ']') popMatrix();
    else if (c == 'F')
    {
      if (i &lt;= drawLevel) line(0, 0, 0, -length); 
      translate(0,-length); 
    }
    i++;
  }
}
// (This sketch is a reworking of the one found at 
https://www.openprocessing.org/sketch/103747/)</code></pre>
<span epub:type="pagebreak" title="153" id="Page_153"/><figure class="graphic"><img src="Images/g069001.png" alt="g069001" width="385" height="385"/></figure>
<figure class="graphic"><img src="Images/g069002.png" alt="g069002" width="385" height="385"/></figure>
<div class="bottom hr"><hr/></div>
</section>
</aside>
<h2 id="h1-501645c08-0010" class="HeadProject"><span><span epub:type="pagebreak" title="154" id="Page_154"/>Sketch 70: Warping an Image</span></h2>
<p class="BodyFirst">In 1991 the general public saw <span class="KeyTerm">morphing</span> for the first time, an effect that uses a computer to smoothly convert one image into another. The computer produces a small sequence of images so that, when played back as a video sequence, an object appears to continuously change shape to become the other. The film <em>Terminator 2</em> used it and, probably most strikingly, the Michael Jackson music video for the song “Black or White” used it in a sequence where faces morphed into one another. This sketch performs a warp or bending of an image, but does not do a complete morph.</p>
<p>The principle underlying the morphing method is something called a <span class="KeyTerm">polynomial warp</span>. Imagine we place an image over a regular grid and then bend the grid using a mathematical function and take the image with it. The result is an image that changes in a particular way—a <span class="KeyTerm">warp</span>. Morphing between two images requires that we establish a correspondence between the image, usually by a human. A function bends (maps) one image into another (a warp) while the pixel color values change systematically from the source to the destination values.</p>
<p>If the image is a face and the warp is based on a sine curve, we get an effect that looks like a funhouse mirror, as shown in <a href="#figure70-1" id="figureanchor70-1">Figure 70-1</a>. The geometry of the original face bends (<span class="KeyTerm">maps</span>) into that of the new one according to the function.</p>
<figure>
<img src="Images/f070001.png" alt="f070001" class="" width="694" height="261"/>
<figcaption><p><a id="figure70-1">Figure 70-1</a>: Warping a face</p></figcaption>
</figure>
<p>This sketch implements an image warp. We read an image and display the pixels according to a sine function transformation of coordinates. The original image is <code>source</code>, and this is the mapping between original and new pixel coordinates:</p>
<pre><code>newX = (int)(x + size*sin(radians(3*y)));
newY = (int)(y + size*cos(radians(4*x)));</code></pre>
<p>This mapping is arbitrary, chosen for an amusing effect. The loop that does the mapping <span class="CodeAnnotation" aria-label="annotation2">2</span> has to map pixel values from the destination back to the source, not the other way around. Each pixel in the source does correspond to a pixel in the destination, but there may be unmapped pixels in the result if we do the mapping the other way. So for each pixel <code>(x,y)</code> in the destination image, we transform it to <code>(newX, newY)</code> values using the desired function and then find the corresponding pixel in the source image. We then set the destination <code>(x,y)</code> to the source <code>(newX, newY)</code>.</p>
<p>In the sketch, the values of <code>ds</code> and <code>size</code> are parameters to the transformation function, and they change slightly each frame <span class="CodeAnnotation" aria-label="annotation1">1</span>, creating a cyclical change in the image that a person will perceive as an animation of the bending or warping motion. </p>
<aside epub:type="sidebar">
<div class="top hr"><hr/></div>
<section class="boxcustom1">
<pre><code>float size = 0;
float ds = .3;
PImage source, destination;

void setup ()
{
  size(100,100);
  surface.setResizable(true);
  source = loadImage("image.jpg");  // Fill in your own image here
  surface.setSize(source.width, source.height);
  destination = new PImage(source.width, source.height);
}

void draw ()
{
  background (200);
  warp(source);
  image(destination, 0, 0);
  size -= random(ds);
  if (abs(size) &gt; 12)
  {
    <span class="CodeAnnotationHang" aria-label="annotation1">1</span> ds = -ds;
    size = size - ds;
  }
}

void warp(PImage source)
{
  int w = source.width, h = source.height;
  int newX, newY;
  color c;

  for(int x = 12; x &lt; w-12; x++)
    for(int y = 12; y &lt; h-12; y++)
    {
      <span class="CodeAnnotationHang" aria-label="annotation2">2</span> newX = (int)(x + size*sin(radians(3*y)));
      newY = (int)(y + size*cos(radians(4*x)));

      if(newX &gt;= w || newX &lt; 0 || newY &gt;= h || newY &lt; 0)
        c = color(200);
      else
        c = source.get (newX, newY);
      destination.set (x, y, c);
    }
}</code></pre>

<span epub:type="pagebreak" title="155" id="Page_155"/><figure class="graphic"><img src="Images/g070001.png" alt="g070001" width="342" height="256"/></figure>
<figure class="graphic"><img src="Images/g070002.png" alt="g070002" width="342" height="256"/></figure>
<div class="bottom hr"><hr/></div>
</section>
</aside>
</section>
</div></body></html>