<html><head></head><body><div id="sbo-rt-content"><h2 class="h2" id="ch04"><span epub:type="pagebreak" id="page_67"/><span class="big">4</span><br/>BUILDING A BINARY LOADER USING LIBBFD</h2>&#13;
<p class="noindent">Now that you have a solid understanding of how binaries work from the previous chapters, you’re ready to start building your own analysis tools. Throughout this book, you’ll frequently build your own tools that manipulate binaries. Because nearly all of these tools will need to parse and (statically) load binary files, it makes sense to have a common framework that provides this ability. In this chapter, let’s use <code>libbfd</code> to design and implement such a framework to reinforce what you’ve learned so far about binary formats.</p>&#13;
<p class="indent">You’ll see the binary loading framework again in <a href="part3.xhtml">Part III</a> of this book, which covers advanced techniques for building your own binary analysis tools. Before designing the framework, I’ll briefly introduce <code>libbfd</code>.</p>&#13;
<h3 class="h3" id="ch04_1">4.1 <span epub:type="pagebreak" id="page_68"/>What Is libbfd?</h3>&#13;
<p class="noindent">The Binary File Descriptor library<sup><a id="ch04fn_1a" href="footnote.xhtml#ch04fn_1">1</a></sup> (<code>libbfd</code>) provides a common interface for reading and parsing all popular binary formats, compiled for a wide variety of architectures. This includes ELF and PE files for x86 and x86-64 machines. By basing your binary loader on <code>libbfd</code>, you can automatically support all these formats without having to implement any format-specific support.</p>&#13;
<p class="indent">The BFD library is part of the GNU project and is used by many applications in the <code>binutils</code> suite, including <code>objdump</code>, <code>readelf</code>, and <code>gdb</code>. It provides generic abstractions for all common components used in binary formats, such as headers describing the binary’s target and properties, lists of sections, sets of relocations, symbol tables, and so on. On Ubuntu, <code>libbfd</code> is part of the <code>binutils-dev</code> package.</p>&#13;
<p class="indent">You can find the core <code>libbfd</code> API in <em>/usr/include/bfd.h</em>.<sup><a id="ch04fn_2a" href="footnote.xhtml#ch04fn_2">2</a></sup> Unfortunately, <code>libbfd</code> can be a bit unwieldy to use, so instead of trying to explain the API here, let’s dive straight in and explore the API while implementing the binary-loading framework.</p>&#13;
<h3 class="h3" id="ch04_2">4.2 A Simple Binary-Loading Interface</h3>&#13;
<p class="noindent">Before implementing the binary loader, let’s design an easy-to-use interface. After all, the whole point of the binary loader is to make the process of loading binaries as easy as possible for all the binary analysis tools that you’ll implement later in this book. It’s intended for use in static analysis tools. Note that this is completely different from the dynamic loader provided by the OS, whose job it is to load binaries into memory to execute them, as discussed in <a href="ch01.xhtml#ch01">Chapter 1</a>.</p>&#13;
<p class="indent">Let’s make the binary-loading interface agnostic of the underlying implementation, which means it won’t expose any <code>libbfd</code> functions or data structures. For simplicity, let’s also keep the interface as basic as possible, exposing only those parts of the binary that you’ll use frequently in later chapters. For example, the interface will omit components such as relocations, which aren’t usually relevant for your binary analysis tools.</p>&#13;
<p class="indent"><a href="ch04.xhtml#ch04list1">Listing 4-1</a> shows the C++ header file describing the basic API that the binary loader will expose. Note that it is located in the <em>inc</em> directory on the VM, rather than in the <em>chapter4</em> directory that contains the other code for this chapter. That’s because the loader is shared among all chapters in this book.</p>&#13;
<p class="listing1" id="ch04list1"><span epub:type="pagebreak" id="page_69"/><em>Listing 4-1:</em> inc/loader.h</p>&#13;
<pre>   #ifndef LOADER_H<br/>   #define LOADER_H<br/><br/>   #include &lt;stdint.h&gt;<br/>   #include &lt;string&gt;<br/>   #include &lt;vector&gt;<br/><br/>   class Binary;<br/>   class Section;<br/>   class Symbol;<br/><br/><span class="ent">➊</span> class Symbol {<br/>   public:<br/>     enum SymbolType {<br/>       SYM_TYPE_UKN = 0,<br/>       SYM_TYPE_FUNC = 1<br/>     };<br/><br/>     Symbol() : type(SYM_TYPE_UKN), name(), addr(0) {}<br/><br/>     SymbolType type;<br/>     std::string name;<br/>     uint64_t    addr;<br/>   };<br/><br/><span class="ent">➋</span> class Section {<br/>   public:<br/>     enum SectionType {<br/>       SEC_TYPE_NONE = 0,<br/>       SEC_TYPE_CODE = 1,<br/>       SEC_TYPE_DATA = 2<br/>     };<br/><br/>     Section() : binary(NULL), type(SEC_TYPE_NONE),<br/>                 vma(0), size(0), bytes(NULL) {}<br/><br/>     bool contains(uint64_t addr) { return (addr &gt;= vma) &amp;&amp; (addr-vma &lt; size); }<br/><br/>     Binary         *binary;<br/>     std::string     name;<br/>     SectionType     type;<br/>     uint64_t        vma;<br/>     uint64_t        size;<br/>     uint8_t         *bytes;<br/>   };<br/><br/><span class="ent">➌</span> class Binary {<br/>   public:<br/>     enum BinaryType {<br/>       BIN_TYPE_AUTO = 0,<br/>       BIN_TYPE_ELF  = 1,<br/>       BIN_TYPE_PE   = 2<br/>     };<br/>     enum BinaryArch {<br/>       ARCH_NONE = 0,<br/>       ARCH_X86 = 1<br/>     };<br/><br/>     Binary() : type(BIN_TYPE_AUTO), arch(ARCH_NONE), bits(0), entry(0) {}<br/><br/>     Section *get_text_section()<br/>       { for(auto &amp;s : sections) if(s.name == ".text") return &amp;s; return NULL; }<br/><br/>     std::string            filename;<br/>     BinaryType             type;<br/>     std::string            type_str;<br/>     BinaryArch             arch;<br/>     std::string            arch_str;<br/>     unsigned               bits;<br/>     uint64_t               entry;<br/>     std::vector&lt;Section&gt;   sections;<br/>     std::vector&lt;Symbol&gt;    symbols;<br/>   };<br/><br/><span class="ent">➍</span> int load_binary(std::string &amp;fname, Binary *bin, Binary::BinaryType type);<br/><span class="ent">➎</span> void unload_binary(Binary *bin);<br/><br/> #endif /* LOADER_H */</pre>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_70"/>As you can see, the API exposes a number of classes representing different components of a binary. The <code>Binary</code> class is the “root” class, representing an abstraction of the entire binary <span class="ent">➌</span>. Among other things, it contains a <code>vector</code> of <code>Section</code> objects and a <code>vector</code> of <code>Symbol</code> objects. The <code>Section</code> class <span class="ent">➋</span> and <code>Symbol</code> class <span class="ent">➊</span> represent the sections and symbols contained in the binary, respectively.</p>&#13;
<p class="indent">At its core, the whole API centers around only two functions. The first of these is the <code>load_binary</code> function <span class="ent">➍</span>, which takes the name of a binary file to load (<code>fname</code>), a pointer to a <code>Binary</code> object to contain the loaded binary (<code>bin</code>), and a descriptor of the binary type (<code>type</code>). It loads the requested binary into the <code>bin</code> parameter and returns an integer value of 0 if the loading process was successful or a value less than 0 if it was not successful. The second <span epub:type="pagebreak" id="page_71"/>function is <code>unload_binary</code> <span class="ent">➎</span>, which simply takes a pointer to a previously loaded <code>Binary</code> object and unloads it.</p>&#13;
<p class="indent">Now that you’re familiar with the binary loader API, let’s take a look at how it’s implemented. I’ll start by discussing the implementation of the <code>Binary</code> class.</p>&#13;
<h4 class="h4" id="ch04_2_1"><em>4.2.1 The Binary Class</em></h4>&#13;
<p class="noindent">As the name implies, the <code>Binary</code> class is an abstraction of a complete binary. It contains the binary’s filename, type, architecture, bit width, entry point address, and sections and symbols. The binary type has a dual representation: the <code>type</code> member contains a numeric type identifier, while <code>type_str</code> contains a string representation of the binary type. The same kind of dual representation is used for the architecture.</p>&#13;
<p class="indent">Valid binary types are enumerated in <code>enum BinaryType</code> and include ELF (<code>BIN_TYPE_ELF</code>) and PE (<code>BIN_TYPE_PE</code>). There’s also a <code>BIN_TYPE_AUTO</code>, which you can pass to the <code>load_binary</code> function to ask it to automatically determine whether the binary is an ELF or PE file. Similarly, valid architectures are enumerated in <code>enum BinaryArch</code>. For these purposes, the only valid architecture is <code>ARCH_X86</code>. This includes both x86 and x86-64; the distinction between the two is made by the <code>bits</code> member of the <code>Binary</code> class, which is set to 32 bits for x86 and to 64 bits for x86-64.</p>&#13;
<p class="indent">Normally, you access sections and symbols in the <code>Binary</code> class by iterating over the <code>sections</code> and <code>symbols</code> vectors, respectively. Because binary analysis often focuses on the code in the <code>.text</code> section, there is also a convenience function called <code>get_text_section</code> that, as the name implies, automatically looks up and returns this section for you.</p>&#13;
<h4 class="h4" id="ch04_2_2"><em>4.2.2 The Section Class</em></h4>&#13;
<p class="noindent">Sections are represented by objects of type <code>Section</code>. The <code>Section</code> class is a simple wrapper around the main properties of a section, including the section’s name, type, starting address (the <code>vma</code> member), size (in bytes), and raw bytes contained in the section. For convenience, there is also a pointer back to the <code>Binary</code> that contains the <code>Section</code> object. The section type is denoted by an <code>enum SectionType</code> value, which tells you whether the section contains code (<code>SEC_TYPE_CODE</code>) or data (<code>SEC_TYPE_DATA</code>).</p>&#13;
<p class="indent">During your analyses, you’ll often want to check to which section a particular instruction or piece of data belongs. For this reason, the <code>Section</code> class has a function called <code>contains</code>, which takes a code or data address and returns a <code>bool</code> indicating whether the address is part of the section.</p>&#13;
<h4 class="h4" id="ch04_2_3"><em>4.2.3 The Symbol Class</em></h4>&#13;
<p class="noindent">As you now know, binaries contain symbols for many types of components, including local and global variables, functions, relocation expressions, objects, and more. To keep things simple, the loader interface exposes only one kind of symbol: function symbols. These are especially useful <span epub:type="pagebreak" id="page_72"/>because they enable you to easily implement function-level binary analysis tools when function symbols are available.</p>&#13;
<p class="indent">The loader represents symbols using the <code>Symbol</code> class. It contains a symbol type, represented as an <code>enum SymbolType</code>, for which the only valid value is <code>SYM_TYPE_FUNC</code>. In addition, the class contains the symbolic name and the start address of the function described by the symbol.</p>&#13;
<h3 class="h3" id="ch04_3">4.3 Implementing the Binary Loader</h3>&#13;
<p class="noindent">Now that the binary loader has a well-defined interface, let’s implement it! This is where <code>libbfd</code> gets involved. Because the code for the complete loader is a bit lengthy, I’ll split it up into chunks, which I’ll discuss one by one. In the following code, you can recognize the <code>libbfd</code> API functions because they all start with <code>bfd_</code> (there are also some functions that end with <code>_bfd</code>, but they are functions defined by the loader).</p>&#13;
<p class="indent">First, you must of course include all the header files you need. I won’t mention all of the standard C/C++ headers that the loader uses since they’re not of interest here (if you really want, you can look them up in the loader’s source on the VM). What is important to mention is that all programs that use <code>libbfd</code> must include <em>bfd.h</em>, as shown in <a href="ch04.xhtml#ch04list2">Listing 4-2</a>, and link against <code>libbfd</code> by specifying the linker flag <code>-lbfd</code>. In addition to <em>bfd.h</em>, the loader includes the header file that contains the interface created in the previous section.</p>&#13;
<p class="listing1" id="ch04list2"><em>Listing 4-2:</em> inc/loader.cc</p>&#13;
<pre>#include &lt;bfd.h&gt;<br/>#include "loader.h"</pre>&#13;
<p class="indent">With that out of the way, the next logical parts of the code to look at are <code>load_binary</code> and <code>unload_binary</code>, the two entry point functions exposed by the loader interface. <a href="ch04.xhtml#ch04list3">Listing 4-3</a> shows how these functions are implemented.</p>&#13;
<p class="listing1" id="ch04list3"><em>Listing 4-3:</em> inc/loader.cc <em>(continued)</em></p>&#13;
<pre>  int<br/><span class="ent">➊</span> load_binary(std::string &amp;fname, Binary *bin, Binary::BinaryType type)<br/>  {<br/>    return <span class="ent">➋</span>load_binary_bfd(fname, bin, type);<br/>  }<br/>  <br/>  void<br/><span class="ent">➌</span> unload_binary(Binary *bin)<br/>  {<br/>    size_t i;<br/>    Section *sec;<br/><br/><span class="ent">➍</span> for(i = 0; i &lt; bin-&gt;sections.size(); i++) {<br/>     sec = &amp;bin-&gt;sections[i];<br/>     if(sec-&gt;bytes) {<br/><span class="ent">➎</span>      free(sec-&gt;bytes);<br/>     }<br/>    }<br/>   }</pre>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_73"/>The job of <code>load_binary</code> <span class="ent">➊</span> is to parse a binary file specified by filename and load it into the <code>Binary</code> object given to it. This is a bit of a tedious process, so <code>load_binary</code> wisely defers the work to another function, called <code>load_binary_bfd</code> <span class="ent">➋</span>. I’ll discuss this function shortly.</p>&#13;
<p class="indent">First, let’s look at <code>unload_binary</code> <span class="ent">➌</span>. As with so many things, destroying a <code>Binary</code> object is a lot easier than creating one. To unload a <code>Binary</code> object, the loader must release (with <code>free</code>) all of the <code>Binary</code>’s dynamically allocated components. Luckily, there aren’t many of those: only the <code>bytes</code> member of each <code>Section</code> is allocated dynamically (using <code>malloc</code>). Thus, <code>unload_binary</code> simply iterates over all <code>Section</code> objects <span class="ent">➍</span> and deallocates the <code>bytes</code> array for each of them <span class="ent">➎</span>. Now that you’ve seen how unloading a binary works, let’s take a more detailed look at how the loading process is implemented using <code>libbfd</code>.</p>&#13;
<h4 class="h4" id="ch04_3_1"><em>4.3.1 Initializing libbfd and Opening a Binary</em></h4>&#13;
<p class="noindent">In the previous section, I promised to show you <code>load_binary_bfd</code>, the function that uses <code>libbfd</code> to take care of all the work involved in loading the binary. Before I do that, I have to get one more prerequisite out of the way. That is, to parse and load a binary, you must first open it. The code to open a binary is implemented in a function called <code>open_bfd</code>, shown in <a href="ch04.xhtml#ch04list4">Listing 4-4</a>.</p>&#13;
<p class="listing1" id="ch04list4"><em>Listing 4-4:</em> inc/loader.cc <em>(continued)</em></p>&#13;
<pre>   static bfd*<br/>   open_bfd(std::string &amp;fname)<br/>   {<br/>     static int bfd_inited = 0;<br/>     bfd *bfd_h;<br/><br/>     if(!bfd_inited) {<br/><span class="ent">➊</span>      bfd_init();<br/>        bfd_inited = 1;<br/>     }<br/><br/><span class="ent">➋</span>   bfd_h = bfd_openr(fname.c_str(), NULL);<br/>     if(!bfd_h) {<br/>       fprintf(stderr, "failed to open binary '%s' (%s)\n",<br/>               fname.c_str(), <span class="ent">➌</span>bfd_errmsg(bfd_get_error()));<br/>       return NULL;<br/>     }<br/><span class="ent">➍</span>   if(!bfd_check_format(bfd_h, bfd_object)) {<br/>       fprintf(stderr, "file '%s' does not look like an executable (%s)\n",<br/>               fname.c_str(), bfd_errmsg(bfd_get_error()));<br/>       return NULL;<br/>     }<br/><br/>     /* Some versions of bfd_check_format pessimistically set a wrong_format<br/>     * error before detecting the format and then neglect to unset it once<br/>     * the format has been detected. We unset it manually to prevent problems.<br/>     */<br/><span class="ent">➎</span>  bfd_set_error(bfd_error_no_error);<br/><br/><span class="ent">➏</span>  if(bfd_get_flavour(bfd_h) == bfd_target_unknown_flavour) {<br/>      fprintf(stderr, "unrecognized format for binary '%s' (%s)\n",<br/>             fname.c_str(), bfd_errmsg(bfd_get_error()));<br/>      return NULL;<br/>    }<br/>   <br/>    return bfd_h;<br/>  }</pre>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_74"/>The <code>open_bfd</code> function uses <code>libbfd</code> to determine the properties of the binary specified by the filename (the <code>fname</code> parameter), open it, and then return a handle to the binary. Before you can use <code>libbfd</code>, you must call <code>bfd_init</code> <span class="ent">➊</span> to initialize <code>libbfd</code>’s internal state (or, as the documentation puts it, to “initialize magical internal data structures”). Since this needs to be done only once, <code>open_bfd</code> uses a static variable to keep track of whether the initialization has been done already.</p>&#13;
<p class="indent">After initializing <code>libbfd</code>, you call the <code>bfd_openr</code> function to open the binary by filename <span class="ent">➋</span>. The second parameter of <code>bfd_openr</code> allows you to specify a target (the type of the binary), but in this case, I’ve left it to <code>NULL</code> so that <code>libbfd</code> will automatically determine the binary type. The return value of <code>bfd_openr</code> is a pointer to a file handle of type <code>bfd</code>; this is <code>libbfd</code>’s root data structure, which you can pass to all other functions in <code>libbfd</code> to perform operations on the binary. In case of error, <code>bfd_openr</code> returns <code>NULL</code>.</p>&#13;
<p class="indent">In general, whenever an error occurs, you can find the type of the most recent error by calling <code>bfd_get_error</code>. This returns an object of the type <code>bfd_error_type</code>, which you can compare against predefined error identifiers such as <code>bfd_error_no_memory</code> or <code>bfd_error_invalid_target</code> to figure out how to handle the error. Often, you’ll just want to exit with an error message. To accommodate this, the <code>bfd_errmsg</code> function can translate a <code>bfd_error_type</code> into a string describing the error, which you can print to the screen <span class="ent">➌</span>.</p>&#13;
<p class="indent">After getting a handle to the binary, you should check the format of the binary using the <code>bfd_check_format</code> function <span class="ent">➍</span>. This function takes a <code>bfd</code> handle and a <code>bfd_format</code> value, which can be set to <code>bfd_object</code>, <code>bfd_archive</code>, or <code>bfd_core</code>. In this case, the loader sets it to <code>bfd_object</code> to verify whether the opened file is indeed an object, which in <code>libbfd</code> terminology means an executable, a relocatable object, or a shared library.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_75"/>After confirming that it’s dealing with a <code>bfd_object</code>, the loader manually sets <code>libbfd</code>’s error state to <code>bfd_error_no_error</code> <span class="ent">➎</span>. This is a work-around for an issue in some versions of <code>libbfd</code>, which set a <code>bfd_error_wrong_format</code> error before detecting the format and leave the error state set even if the format detection shows no problems.</p>&#13;
<p class="indent">Finally, the loader checks that the binary has a known “flavor” by using the <code>bfd_get_flavour</code> function <span class="ent">➏</span>. This function returns a <code>bfd_flavour</code> object, which simply indicates the kind of binary (ELF, PE, and so on). Valid <code>bfd_flavour</code> values include <code>bfd_target_msdos_flavour</code>, <code>bfd_target_coff_flavour</code>, and <code>bfd_target_elf_flavour</code>. If the binary format is unknown or there was an error, then <code>get_bfd_flavour</code> returns <code>bfd_target_unknown_flavour</code>, in which case <code>open_bfd</code> prints an error and returns <code>NULL</code>.</p>&#13;
<p class="indent">If all checks pass, it means that you have successfully opened a valid binary and are ready to start loading its contents! The <code>open_bfd</code> function returns the <code>bfd</code> handle it opened so you can use it later in other <code>libbfd</code> API calls, as shown in the next few listings.</p>&#13;
<h4 class="h4" id="ch04_3_2"><em>4.3.2 Parsing Basic Binary Properties</em></h4>&#13;
<p class="noindent">Now that you’ve seen the necessary code to open a binary, it’s time to take a look at the <code>load_binary_bfd</code> function, shown in <a href="ch04.xhtml#ch04list5">Listing 4-5</a>. Recall that this is the function that handles all the actual parsing and loading work on behalf of the <code>load_binary</code> function. In this section, the aim is to load all of the interesting details about the binary into the <code>Binary</code> object pointed to by the <code>bin</code> parameter.</p>&#13;
<p class="listing1" id="ch04list5"><em>Listing 4-5:</em> inc/loader.cc <em>(continued)</em></p>&#13;
<pre>   static int<br/>   load_binary_bfd(std::string &amp;fname, Binary *bin, Binary::BinaryType type)<br/>   {<br/>     int ret;<br/>     bfd *bfd_h;<br/>     const bfd_arch_info_type *bfd_info;<br/><br/>     bfd_h = NULL;<br/><span class="ent">➊</span>   bfd_h = open_bfd(fname);<br/>     if(!bfd_h) {<br/>       goto fail;<br/>     }<br/><br/>     bin-&gt;filename = std::string(fname);<br/><span class="ent">➋</span>   bin-&gt;entry    = bfd_get_start_address(bfd_h);<br/><br/><span class="ent">➌</span>   bin-&gt;type_str = std::string(bfd_h-&gt;xvec-&gt;name);<br/><span class="ent">➍</span>   switch(bfd_h-&gt;xvec-&gt;flavour) {<br/>     case bfd_target_elf_flavour:<br/>       bin-&gt;type = Binary::BIN_TYPE_ELF;<br/>       break;<br/>    case bfd_target_coff_flavour:<br/>      bin-&gt;type = Binary::BIN_TYPE_PE;<br/>      break;<br/>    case bfd_target_unknown_flavour:<br/>    default:<br/>      fprintf(stderr, "unsupported binary type (%s)\n", bfd_h-&gt;xvec-&gt;name);<br/>      goto fail;<br/>    }<br/><br/><span class="ent">➎</span>     bfd_info = bfd_get_arch_info(bfd_h);<br/><span class="ent">➏</span>     bin-&gt;arch_str = std::string(bfd_info-&gt;printable_name);<br/><span class="ent">➐</span>     switch(bfd_info-&gt;mach) {<br/>      case bfd_mach_i386_i386:<br/>        bin-&gt;arch = Binary::ARCH_X86;<br/>        bin-&gt;bits = 32;<br/>        break;<br/>      case bfd_mach_x86_64:<br/>        bin-&gt;arch = Binary::ARCH_X86;<br/>        bin-&gt;bits = 64;<br/>        break;<br/>      default:<br/>        fprintf(stderr, "unsupported architecture (%s)\n",<br/>                bfd_info-&gt;printable_name);<br/>        goto fail;<br/>      }<br/><br/>      /* Symbol handling is best-effort only (they may not even be present) */<br/><span class="ent">➑</span>    load_symbols_bfd(bfd_h, bin);<br/><span class="ent">➒</span>    load_dynsym_bfd(bfd_h, bin);<br/><br/>      if(load_sections_bfd(bfd_h, bin) &lt; 0) goto fail;<br/><br/>      ret = 0;<br/>      goto cleanup;<br/><br/>    fail:<br/>      ret = -1;<br/><br/>    cleanup:<br/><span class="ent">➓</span>    if(bfd_h) bfd_close(bfd_h);<br/><br/>      return ret;<br/>   }</pre>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_76"/>The <code>load_binary_bfd</code> function begins by using the just implemented <code>open_bfd</code> function to open the binary specified in the <code>fname</code> parameter and <span epub:type="pagebreak" id="page_77"/>get a <code>bfd</code> handle to this binary <span class="ent">➊</span>. Then, <code>load_binary_bfd</code> sets some of <code>bin</code>’s basic properties. It starts by copying the name of the binary file and using <code>libbfd</code> to find and copy the entry point address <span class="ent">➋</span>.</p>&#13;
<p class="indent">To get the entry point address of a binary, you use <code>bfd_get_start_address</code>, which simply returns the value of the <code>start_address</code> field of the <code>bfd</code> object. The start address is a <code>bfd_vma</code>, which is really nothing more than a 64-bit unsigned integer.</p>&#13;
<p class="indent">Next, the loader collects information about the binary type: is it an ELF, a PE, or some other, unsupported type of binary? You can find this information in the <code>bfd_target</code> structure maintained by <code>libbfd</code>. To get a pointer to this data structure, you just need to access the <code>xvec</code> field in the <code>bfd</code> handle. In other words, <code>bfd_h-&gt;xvec</code> gives you a pointer to a <code>bfd_target</code> structure.</p>&#13;
<p class="indent">Among other things, this structure provides a string containing the name of the target type. The loader copies this string into the <code>Binary</code> object <span class="ent">➌</span>. Next, it inspects the <code>bfd_h-&gt;xvec-&gt;flavour</code> field using a switch and sets the type of the <code>Binary</code> accordingly <span class="ent">➍</span>. The loader supports only ELF and PE, so it emits an error if <code>bfd_h-&gt;xvec-&gt;flavour</code> indicates any other type of binary.</p>&#13;
<p class="indent">Now you know whether the binary is an ELF or PE, but you don’t yet know the architecture. To find this out, you use <code>libbfd</code>’s <code>bfd_get_arch_info</code> function <span class="ent">➎</span>. As the name implies, this function returns a pointer to a data structure that provides information about the binary architecture. This data structure is called <code>bfd_arch_info_type</code>. It provides a convenient printable string describing the architecture, which the loader copies into the <code>Binary</code> object <span class="ent">➏</span>.</p>&#13;
<p class="indent">The <code>bfd_arch_info_type</code> data structure also contains a field called <code>mach</code> <span class="ent">➐</span>, which is just an integer identifier for the architecture (called the <em>machine</em> in <code>libbfd</code> terminology). This integer representation of the architecture allows for a convenient <code>switch</code> to implement architecture-specific handling. If <code>mach</code> is equal to <code>bfd_mach_i386_i386</code>, then it’s a 32-bit x86 binary, and the loader sets the fields in the <code>Binary</code> accordingly. If <code>mach</code> is <code>bfd_mach_x86_64</code>, then it’s an x86-64 binary, and the loader again sets the appropriate fields. Any other type is unsupported and results in an error.</p>&#13;
<p class="indent">Now that you’ve seen how to parse basic information about the binary type and architecture, it’s time to get to the real work: loading the symbols and sections contained in the binary. As you might imagine, this is not as simple as what you’ve seen so far, so the loader defers the necessary work to specialized functions, described in the next sections. The two functions the loader uses to load symbols are called <code>load_symbols_bfd</code> and <code>load_dynsym_bfd</code> <span class="ent">➑</span>. As described in the next section, they load symbols from the static and dynamic symbol tables, respectively. The loader also implements <code>load_sections_bfd</code>, a specialized function to load the binary’s sections <span class="ent">➒</span>. I’ll discuss it shortly, in <a href="ch04.xhtml#ch04_3_4">Section 4.3.4</a>.</p>&#13;
<p class="indent">After loading the symbols and sections, you’ll have copied all the information that you’re interested in to your own <code>Binary</code> object, which means you’re done using <code>libbfd</code>. Because the <code>bfd</code> handle is no longer needed, <span epub:type="pagebreak" id="page_78"/>the loader closes it using <code>bfd_close</code> <span class="ent">➓</span>. It also closes the handle if any error happens before it’s fully done loading the binary.</p>&#13;
<h4 class="h4" id="ch04_3_3"><em>4.3.3 Loading Symbols</em></h4>&#13;
<p class="noindent"><a href="ch04.xhtml#ch04list6">Listing 4-6</a> shows the code for <code>load_symbols_bfd</code>, the function to load the static symbol table.</p>&#13;
<p class="listing1" id="ch04list6"><em>Listing 4-6:</em> inc/loader.cc <em>(continued)</em></p>&#13;
<pre>   static int<br/>   load_symbols_bfd(bfd *bfd_h, Binary *bin)<br/>   {<br/>     int ret;<br/>     long n, nsyms, i;<br/><span class="ent">➊</span>   asymbol **bfd_symtab;<br/>     Symbol *sym;<br/>   <br/>     bfd_symtab = NULL;<br/>   <br/><span class="ent">➋</span>    n = bfd_get_symtab_upper_bound(bfd_h);<br/>     if(n &lt; 0) {<br/>       fprintf(stderr, "failed to read symtab (%s)\n",<br/>               bfd_errmsg(bfd_get_error()));<br/>       goto fail;<br/>     } else if(n) {<br/><span class="ent">➌</span>      bfd_symtab = (asymbol**)malloc(n);<br/>       if(!bfd_symtab) {<br/>         fprintf(stderr, "out of memory\n");<br/>        goto fail;<br/>       }<br/><span class="ent">➍</span>     nsyms = bfd_canonicalize_symtab(bfd_h, bfd_symtab);<br/>       if(nsyms &lt; 0) {<br/>         fprintf(stderr, "failed to read symtab (%s)\n",<br/>                bfd_errmsg(bfd_get_error()));<br/>         goto fail;<br/>       }<br/><span class="ent">➎</span>     for(i = 0; i &lt; nsyms; i++) {<br/><span class="ent">➏</span>       if(bfd_symtab[i]-&gt;flags &amp; BSF_FUNCTION) {<br/>           bin-&gt;symbols.push_back(Symbol());<br/>           sym = &amp;bin-&gt;symbols.back();<br/><span class="ent">➐</span>         sym-&gt;type = Symbol::SYM_TYPE_FUNC;<br/><span class="ent">➑</span>         sym-&gt;name = std::string(bfd_symtab[i]-&gt;name);<br/><span class="ent">➒</span>         sym-&gt;addr = bfd_asymbol_value(bfd_symtab[i]);<br/>         }<br/>       }<br/>     }<br/>     ret = 0;<br/>     goto cleanup;<br/><br/>   fail:<br/>     ret = -1;<br/><br/>   cleanup:<br/><span class="ent">➓</span>   if(bfd_symtab) free(bfd_symtab);<br/><br/>     return ret;<br/><br/>  }</pre>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_79"/>In <code>libbfd</code>, symbols are represented by the <code>asymbol</code> structure, which is just a short name for <code>struct bfd_symbol</code>. In turn, a symbol table is just an <code>asymbol**</code>, meaning an array of pointers to symbols. Thus, the job of <code>load_symbols_bfd</code> is to populate the array of <code>asymbol</code> pointers declared at <span class="ent">➊</span> and then to copy the interesting information to the <code>Binary</code> object.</p>&#13;
<p class="indent">The input parameters to <code>load_symbols_bfd</code> are a <code>bfd</code> handle and the <code>Binary</code> object in which to store the symbolic information. Before you can load any symbol pointers, you need to allocate enough space to store all of them in. The <code>bfd_get_symtab_upper_bound</code> function <span class="ent">➋</span> tells you how many bytes to allocate for this purpose. The number of bytes is negative in case of an error, and it can also be zero, meaning that there is no symbol table. If there’s no symbol table, <code>load_symbols_bfd</code> is done and simply returns.</p>&#13;
<p class="indent">If all is well and the symbol table contains a positive number of bytes, you allocate enough space to keep all the <code>asymbol</code> pointers in <span class="ent">➌</span>. If the <code>malloc</code> succeeds, you’re finally ready to ask <code>libbfd</code> to populate your symbol table! You do this using the <code>bfd_canonicalize_symtab</code> function <span class="ent">➍</span>, which takes as input your <code>bfd</code> handle and the symbol table that you want to populate (your <code>asymbol**</code>). As requested, <code>libbfd</code> duly populates your symbol table and returns the number of symbols it placed in the table (again, if that number is negative, you know something went wrong).</p>&#13;
<p class="indent">Now that you have a populated symbol table, you can loop over all the symbols it contains <span class="ent">➎</span>. Recall that for the binary loader, you are interested only in function symbols. Thus, for each symbol, you check whether the <code>BSF_FUNCTION</code> flag is set, which indicates that it is a function symbol <span class="ent">➏</span>. If this is the case, you reserve room for a <code>Symbol</code> (recall that this is the loader’s own class to store symbols in) in the <code>Binary</code> object by adding an entry to the <code>vector</code> that contains all the loaded symbols. You mark the newly created <code>Symbol</code> as a function symbol <span class="ent">➐</span>, copy the symbolic name <span class="ent">➑</span>, and set the <code>Symbol</code>’s address <span class="ent">➒</span>. To get a function symbol’s value, which is the function’s start address, you use the <code>bfd_asymbol_value</code> function provided by <code>libbfd</code>.</p>&#13;
<p class="indent">Now that all of the interesting symbols have been copied into <code>Symbol</code> objects, the loader no longer needs <code>libbfd</code>’s representation. Therefore, when <code>load_symbols_bfd</code> finishes, it deallocates any space reserved to store <code>libbfd</code> symbols <span class="ent">➓</span>. After that, it returns, and the symbol-loading process is complete.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_80"/>So, that’s how you load symbols from the static symbol table with <code>libbfd</code>. But how is it done for the dynamic symbol table? Luckily, the process is almost completely identical, as you can see in <a href="ch04.xhtml#ch04list7">Listing 4-7</a>.</p>&#13;
<p class="listing1" id="ch04list7"><em>Listing 4-7:</em> inc/loader.cc <em>(continued)</em></p>&#13;
<pre>   static int<br/>   load_dynsym_bfd(bfd *bfd_h, Binary *bin)<br/>   {<br/>     int ret;<br/>     long n, nsyms, i;<br/><span class="ent">➊</span>   asymbol **bfd_dynsym;<br/>     Symbol *sym;<br/>   <br/>     bfd_dynsym = NULL;<br/>   <br/><span class="ent">➋</span>   n = bfd_get_dynamic_symtab_upper_bound(bfd_h);<br/>     if(n &lt; 0) {<br/>       fprintf(stderr, "failed to read dynamic symtab (%s)\n",<br/>               bfd_errmsg(bfd_get_error()));<br/>       goto fail;<br/>     } else if(n) {<br/>       bfd_dynsym = (asymbol**)malloc(n);<br/>       if(!bfd_dynsym) {<br/>         fprintf(stderr, "out of memory\n");<br/>         goto fail;<br/>      }<br/><span class="ent">➌</span>    nsyms = bfd_canonicalize_dynamic_symtab(bfd_h, bfd_dynsym);<br/>      if(nsyms &lt; 0) {<br/>        fprintf(stderr, "failed to read dynamic symtab (%s)\n",<br/>                bfd_errmsg(bfd_get_error()));<br/>       goto fail;<br/>     }<br/>     for(i = 0; i &lt; nsyms; i++) {<br/>       if(bfd_dynsym[i]-&gt;flags &amp; BSF_FUNCTION) {<br/>         bin-&gt;symbols.push_back(Symbol());<br/>         sym = &amp;bin-&gt;symbols.back();<br/>         sym-&gt;type = Symbol::SYM_TYPE_FUNC;<br/>         sym-&gt;name = std::string(bfd_dynsym[i]-&gt;name);<br/>         sym-&gt;addr = bfd_asymbol_value(bfd_dynsym[i]);<br/>       }<br/>      }<br/>     }<br/>    <br/>     ret = 0;<br/>     goto cleanup;<br/>   <br/>   fail:<br/>     ret = -1;<br/>     <br/>   cleanup:<br/>     if(bfd_dynsym) free(bfd_dynsym);<br/>    <br/>     return ret;<br/>   }</pre>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_81"/>The function shown in <a href="ch04.xhtml#ch04list7">Listing 4-7</a> to load symbols from the dynamic symbol table is aptly called <code>load_dynsym_bfd</code>. As you can see, <code>libbfd</code> uses the same data structure (<code>asymbol</code>) to represent both static and dynamic symbols <span class="ent">➊</span>. The only differences with the previously shown <code>load_symbols_bfd</code> function are the following. First, to find the number of bytes you need to reserve for symbol pointers, you call <code>bfd_get_dynamic_symtab_upper_bound</code> <span class="ent">➋</span> instead of <code>bfd_get_symtab_upper_bound</code>. Second, to populate the symbol table, you use <code>bfd_canonicalize_dynamic_symtab</code> <span class="ent">➌</span> instead of <code>bfd_canonicalize_symtab</code>. That’s it! The rest of the dynamic symbol-loading process is the same as for static symbols.</p>&#13;
<h4 class="h4" id="ch04_3_4"><em>4.3.4 Loading Sections</em></h4>&#13;
<p class="noindent">After loading the symbols, only one thing remains to be done, though it’s arguably the most important step: loading the binary’s sections. <a href="ch04.xhtml#ch04list8">Listing 4-8</a> shows how <code>load_sections_bfd</code> implements the functionality to do this.</p>&#13;
<p class="listing1" id="ch04list8"><em>Listing 4-8:</em> inc/loader.cc <em>(continued)</em></p>&#13;
<pre>  static int<br/>  load_sections_bfd(bfd *bfd_h, Binary *bin)<br/>  {<br/>    int bfd_flags;<br/>    uint64_t vma, size;<br/>    const char *secname;<br/><span class="ent">➊</span>  asection* bfd_sec;<br/>    Section *sec;<br/>    Section::SectionType sectype;<br/>  <br/><span class="ent">➋</span>  for(bfd_sec = bfd_h-&gt;sections; bfd_sec; bfd_sec = bfd_sec-&gt;next) {<br/><span class="ent">➌</span>    bfd_flags = bfd_get_section_flags(bfd_h, bfd_sec);<br/><br/>      sectype = Section::SEC_TYPE_NONE;<br/><span class="ent">➍</span>    if(bfd_flags &amp; SEC_CODE) {<br/>        sectype = Section::SEC_TYPE_CODE;<br/>      } else if(bfd_flags &amp; SEC_DATA) {<br/>        sectype = Section::SEC_TYPE_DATA;<br/>      } else {<br/>        continue;<br/>      }<br/><span class="ent">➎</span>    vma     = bfd_section_vma(bfd_h, bfd_sec);<br/><span class="ent">➏</span>    size    = bfd_section_size(bfd_h, bfd_sec);<br/><span class="ent">➐</span>    secname = bfd_section_name(bfd_h, bfd_sec);<br/>     if(!secname) secname = "&lt;unnamed&gt;";<br/>  <br/><span class="ent">➑</span>    bin-&gt;sections.push_back(Section());<br/>      sec = &amp;bin-&gt;sections.back();<br/>  <br/>      sec-&gt;binary = bin;<br/>      sec-&gt;name   = std::string(secname);<br/>      sec-&gt;type   = sectype;<br/>      sec-&gt;vma    = vma;<br/>      sec-&gt;size   = size;<br/><span class="ent">➒</span>    sec-&gt;bytes  = (uint8_t*)malloc(size);<br/>      if(!sec-&gt;bytes) {<br/>        fprintf(stderr, "out of memory\n");<br/>        return -1;<br/>     }<br/>    <br/><span class="ent">➓</span>   if(!bfd_get_section_contents(bfd_h, bfd_sec, sec-&gt;bytes, 0, size)) {<br/>       fprintf(stderr, "failed to read section '%s' (%s)\n",<br/>              secname, bfd_errmsg(bfd_get_error()));<br/>       return -1;<br/>     }<br/>   }<br/><br/>   return 0;<br/> }</pre>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_82"/>To store sections, <code>libbfd</code> uses a data structure called <code>asection</code>, also known as <code>struct bfd_section</code>. Internally, <code>libbfd</code> keeps a linked list of <code>asection</code> structures to represent all sections. The loader reserves an <code>asection*</code> to iterate over this list <span class="ent">➊</span>.</p>&#13;
<p class="indent">To iterate over all the sections, you start at the first one (pointed to by <code>bfd_h-&gt;sections</code>, the head of <code>libbfd</code>’s section list) and then follow the <code>next</code> pointer contained in each <code>asection</code> object <span class="ent">➋</span>. When the <code>next</code> pointer is <code>NULL</code>, you’ve reached the end of the list.</p>&#13;
<p class="indent">For each section, the loader first checks whether it should be loaded at all. Since the loader only loads code and data sections, it starts by getting the section flags to check what the type of the section is. To get the flags, it uses <code>bfd_get_section_flags</code> <span class="ent">➌</span>. Then, it checks whether either the <code>SEC_CODE</code> or <code>SEC_DATA</code> flag is set <span class="ent">➍</span>. If not, then it skips this section and moves on to the next. If either of the flags <em>is</em> set, then the loader sets the section type for the corresponding <code>Section</code> object and continues loading the section.</p>&#13;
<p class="indent">In addition to the section type, the loader copies the virtual address, size (in bytes), name, and raw bytes of each code or data section. To find the virtual base address of a <code>libbfd</code> section, you use <code>bfd_section_vma</code> <span class="ent">➎</span>. Similarly, <span epub:type="pagebreak" id="page_83"/>you use <code>bfd_section_size</code><span class="ent">➏</span> and <code>bfd_section_name</code> <span class="ent">➐</span> to get the size and name of the section, respectively. It’s possible that the section has no name, in which case <code>bfd_section_name</code> will return <code>NULL</code>.</p>&#13;
<p class="indent">The loader now copies the actual contents of the section into a <code>Section</code> object. To accomplish that, it reserves a <code>Section</code> in the <code>Binary</code> <span class="ent">➑</span> and copies all the fields it just read. Then, it allocates enough space in the <code>bytes</code> member of the <code>Section</code> to contain all of the bytes in the section <span class="ent">➒</span>. If the <code>malloc</code> succeeds, it copies all the section bytes from the <code>libbfd</code> section object into the <code>Section</code>, using the <code>bfd_get_section_contents</code> function <span class="ent">➓</span>. The arguments it takes are a <code>bfd</code> handle, a pointer to the <code>asection</code> object of interest, a destination array to contain the section contents, the offset at which to start copying, and the number of bytes to copy into the destination array. To copy all the bytes, the start offset is 0 and the number of bytes to copy is equal to the section size. If the copy succeeds, <code>bfd_get_section_contents</code> returns <code>true</code>; otherwise, it returns <code>false</code>. If all went well, the loading process is now complete!</p>&#13;
<h3 class="h3" id="ch04_4">4.4 Testing the Binary Loader</h3>&#13;
<p class="noindent">Let’s create a simple program to test the new binary loader. The program will take the name of a binary as input, use the loader to load that binary, and then display some diagnostics about what it loaded. <a href="ch04.xhtml#ch04list9">Listing 4-9</a> shows the code for the test program.</p>&#13;
<p class="listing1" id="ch04list9"><em>Listing 4-9:</em> loader_demo.cc</p>&#13;
<pre>     #include &lt;stdio.h&gt;<br/>     #include &lt;stdint.h&gt;<br/>     #include &lt;string&gt;<br/>     #include "../inc/loader.h"<br/><br/>     int<br/>     main(int argc, char *argv[])<br/>     {<br/>       size_t i;<br/>       Binary bin;<br/>       Section *sec;<br/>       Symbol *sym;<br/>       std::string fname;<br/><br/>       if(argc &lt; 2) {<br/>         printf("Usage: %s &lt;binary&gt;\n", argv[0]);<br/>         return 1;<br/>     }<br/><br/>     fname.assign(argv[1]);<br/><span class="ent">➊</span>   if(load_binary(fname, &amp;bin, Binary::BIN_TYPE_AUTO) &lt; 0) {<br/>       return 1;<br/>     }<br/><br/><span class="ent">➋</span>   printf("loaded binary '%s' %s/%s (%u bits) entry@0x%016jx\n",<br/>           bin.filename.c_str(),<br/>           bin.type_str.c_str(), bin.arch_str.c_str(),<br/>           bin.bits, bin.entry);<br/><br/><span class="ent">➌</span>   for(i = 0; i &lt; bin.sections.size(); i++) {<br/>       sec = &amp;bin.sections[i];<br/>       printf(" 0x%016jx %-8ju %-20s %s\n",<br/>              sec-&gt;vma, sec-&gt;size, sec-&gt;name.c_str(),<br/>              sec-&gt;type == Section::SEC_TYPE_CODE ? "CODE" : "DATA");<br/>     }<br/><br/><span class="ent">➍</span>   if(bin.symbols.size() &gt; 0) {<br/>       printf("scanned symbol tables\n");<br/>       for(i = 0; i &lt; bin.symbols.size(); i++) {<br/>         sym = &amp;bin.symbols[i];<br/>         printf(" %-40s 0x%016jx %s\n",<br/>                sym-&gt;name.c_str(), sym-&gt;addr,<br/>                (sym-&gt;type &amp; Symbol::SYM_TYPE_FUNC) ? "FUNC" : "");<br/>       }<br/>     }<br/><br/><span class="ent">➎</span>   unload_binary(&amp;bin);<br/><br/>     return 0;<br/>    }</pre>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_84"/>This test program loads the binary given to it as its first argument <span class="ent">➊</span> and then displays some basic information about the binary such as the filename, type, architecture, and entry point <span class="ent">➋</span>. It then prints the base address, size, name, and type of every section <span class="ent">➌</span> and finally displays all of the symbols that were found <span class="ent">➍</span>. It then unloads the binary and returns <span class="ent">➎</span>. Try running the <code>loader_demo</code> program in the VM! You should see output similar to <a href="ch04.xhtml#ch04list10">Listing 4-10</a>.</p>&#13;
<p class="listing1" id="ch04list10"><em>Listing 4-10: Example output of the loader test program</em></p>&#13;
<pre>$ <span class="codestrong1">loader_demo /bin/ls</span><br/><br/>loaded binary '/bin/ls' elf64-x86-64/i386:x86-64 (64 bits) entry@0x4049a0<br/>  0x0000000000400238 28     .interp                DATA<br/>  0x0000000000400254 32     .note.ABI-tag          DATA<br/>  0x0000000000400274 36     .note.gnu.build-id     DATA<br/>  0x0000000000400298 192    .gnu.hash              DATA<br/>  0x0000000000400358 3288   .dynsym                DATA<br/>  0x0000000000401030 1500   .dynstr                DATA<br/>  0x000000000040160c 274    .gnu.version           DATA<br/>  0x0000000000401720 112    .gnu.version_r         DATA<br/>  0x0000000000401790 168    .rela.dyn              DATA<br/>  0x0000000000401838 2688   .rela.plt              DATA<br/>  0x00000000004022b8 26     .init                  CODE<br/>  0x00000000004022e0 1808   .plt                   CODE<br/>  0x00000000004029f0 8      .plt.got               CODE<br/>  0x0000000000402a00 70281  .text                  CODE<br/>  0x0000000000413c8c 9      .fini                  CODE<br/>  0x0000000000413ca0 27060  .rodata                DATA<br/>  0x000000000041a654 2060   .eh_frame_hdr          DATA<br/>  0x000000000041ae60 11396  .eh_frame              DATA<br/>  0x000000000061de00 8      .init_array            DATA<br/>  0x000000000061de08 8      .fini_array            DATA<br/>  0x000000000061de10 8      .jcr                   DATA<br/>  0x000000000061de18 480    .dynamic               DATA<br/>  0x000000000061dff8 8      .got                   DATA<br/>  0x000000000061e000 920    .got.plt               DATA<br/>  0x000000000061e3a0 608    .data                  DATA<br/>scanned symbol tables<br/>...<br/>  _fini                     0x0000000000413c8c     FUNC<br/>  _init                     0x00000000004022b8     FUNC<br/>  free                      0x0000000000402340     FUNC<br/>  _obstack_memory_used      0x0000000000412960     FUNC<br/>  _obstack_begin            0x0000000000412780     FUNC<br/>  _obstack_free             0x00000000004128f0     FUNC<br/>  localtime_r               0x00000000004023a0     FUNC<br/>  _obstack_allocated_p      0x00000000004128c0     FUNC<br/>  _obstack_begin_1          0x00000000004127a0     FUNC<br/>  _obstack_newchunk         0x00000000004127c0     FUNC<br/>  malloc                    0x0000000000402790     FUNC</pre>&#13;
<h3 class="h3" id="ch04_5">4.5 Summary</h3>&#13;
<p class="noindent"><span epub:type="pagebreak" id="page_85"/>In <a href="ch01.xhtml#ch01">Chapters 1</a> through <a href="ch03.xhtml#ch03">3</a>, you learned all about binary formats. In this chapter, you learned how to load these binaries to prepare them for subsequent binary analysis. In the process, you also learned about <code>libbfd</code>, a commonly used library for loading binaries. Now that you have a functioning binary loader, you’re ready to move on to techniques for analyzing binaries. After an introduction to fundamental binary analysis techniques in <a href="part2.xhtml">Part II</a> of this book, you’ll use the loader in <a href="part3.xhtml">Part III</a> to implement your own binary analysis tools.</p>&#13;
<div class="box">&#13;
<p class="headbox" id="ch04_6"><span epub:type="pagebreak" id="page_86"/>Exercises</p>&#13;
<p class="boxhead1">1. Dumping Section Contents</p>&#13;
<p class="noindent">For brevity, the current version of the <code>loader_demo</code> program doesn’t display section contents. Expand it with the ability to take a binary and the name of a section as input. Then dump the contents of that section to the screen in hexadecimal format.</p>&#13;
<p class="boxhead1">2. Overriding Weak Symbols</p>&#13;
<p class="noindent">Some symbols are <em>weak</em>, which means that their value may be overridden by another symbol that isn’t weak. Currently, the binary loader doesn’t take this into account and simply stores all symbols. Expand the binary loader so that if a weak symbol is later overridden by another symbol, only the latest version is kept. Take a look at <em>/usr/include/bfd.h</em> to figure out the flags to check for.</p>&#13;
<p class="boxhead1">3. Printing Data Symbols</p>&#13;
<p class="noindent">Expand the binary loader and the <code>loader_demo</code> program so that they can handle local and global data symbols as well as function symbols. You’ll need to add handling for data symbols in the loader, add a new <code>SymbolType</code> in the <code>Symbol</code> class, and add code to the <code>loader_demo</code> program to print the data symbols to screen. Be sure to test your modifications on a nonstripped binary to ensure the presence of some data symbols. Note that data items are called <em>objects</em> in symbol terminology. If you’re unsure about the correctness of your output, use <code>readelf</code> to verify it.</p>&#13;
</div>&#13;
</div></body></html>