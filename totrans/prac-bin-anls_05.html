<html><head></head><body><div id="sbo-rt-content"><h2 class="h2" id="ch04"><span epub:type="pagebreak" id="page_67"/><span class="big">4</span><br/>BUILDING A BINARY LOADER USING LIBBFD</h2>&#13;
<p class="noindent">Now that you have a solid understanding of how binaries work from the previous chapters, you’re ready to start building your own analysis tools. Throughout this book, you’ll frequently build your own tools that manipulate binaries. Because nearly all of these tools will need to parse and (statically) load binary files, it makes sense to have a common framework that provides this ability. In this chapter, let’s use <span class="literal">libbfd</span> to design and implement such a framework to reinforce what you’ve learned so far about binary formats.</p>&#13;
<p class="indent">You’ll see the binary loading framework again in <a href="part3.xhtml">Part III</a> of this book, which covers advanced techniques for building your own binary analysis tools. Before designing the framework, I’ll briefly introduce <span class="literal">libbfd</span>.</p>&#13;
<h3 class="h3" id="ch04_1">4.1 <span epub:type="pagebreak" id="page_68"/>What Is libbfd?</h3>&#13;
<p class="noindent">The Binary File Descriptor library<sup><a id="ch04fn_1a" href="footnote.xhtml#ch04fn_1">1</a></sup> (<span class="literal">libbfd</span>) provides a common interface for reading and parsing all popular binary formats, compiled for a wide variety of architectures. This includes ELF and PE files for x86 and x86-64 machines. By basing your binary loader on <span class="literal">libbfd</span>, you can automatically support all these formats without having to implement any format-specific support.</p>&#13;
<p class="indent">The BFD library is part of the GNU project and is used by many applications in the <span class="literal">binutils</span> suite, including <span class="literal">objdump</span>, <span class="literal">readelf</span>, and <span class="literal">gdb</span>. It provides generic abstractions for all common components used in binary formats, such as headers describing the binary’s target and properties, lists of sections, sets of relocations, symbol tables, and so on. On Ubuntu, <span class="literal">libbfd</span> is part of the <span class="literal">binutils-dev</span> package.</p>&#13;
<p class="indent">You can find the core <span class="literal">libbfd</span> API in <em>/usr/include/bfd.h</em>.<sup><a id="ch04fn_2a" href="footnote.xhtml#ch04fn_2">2</a></sup> Unfortunately, <span class="literal">libbfd</span> can be a bit unwieldy to use, so instead of trying to explain the API here, let’s dive straight in and explore the API while implementing the binary-loading framework.</p>&#13;
<h3 class="h3" id="ch04_2">4.2 A Simple Binary-Loading Interface</h3>&#13;
<p class="noindent">Before implementing the binary loader, let’s design an easy-to-use interface. After all, the whole point of the binary loader is to make the process of loading binaries as easy as possible for all the binary analysis tools that you’ll implement later in this book. It’s intended for use in static analysis tools. Note that this is completely different from the dynamic loader provided by the OS, whose job it is to load binaries into memory to execute them, as discussed in <a href="ch01.xhtml#ch01">Chapter 1</a>.</p>&#13;
<p class="indent">Let’s make the binary-loading interface agnostic of the underlying implementation, which means it won’t expose any <span class="literal">libbfd</span> functions or data structures. For simplicity, let’s also keep the interface as basic as possible, exposing only those parts of the binary that you’ll use frequently in later chapters. For example, the interface will omit components such as relocations, which aren’t usually relevant for your binary analysis tools.</p>&#13;
<p class="indent"><a href="ch04.xhtml#ch04list1">Listing 4-1</a> shows the C++ header file describing the basic API that the binary loader will expose. Note that it is located in the <em>inc</em> directory on the VM, rather than in the <em>chapter4</em> directory that contains the other code for this chapter. That’s because the loader is shared among all chapters in this book.</p>&#13;
<p class="listing1" id="ch04list1"><span epub:type="pagebreak" id="page_69"/><em>Listing 4-1:</em> inc/loader.h</p>&#13;
<p class="programs">   #ifndef LOADER_H<br/>   #define LOADER_H<br/><br/>   #include &lt;stdint.h&gt;<br/>   #include &lt;string&gt;<br/>   #include &lt;vector&gt;<br/><br/>   class Binary;<br/>   class Section;<br/>   class Symbol;<br/><br/><span class="ent">➊</span> class Symbol {<br/>   public:<br/>     enum SymbolType {<br/>       SYM_TYPE_UKN = 0,<br/>       SYM_TYPE_FUNC = 1<br/>     };<br/><br/>     Symbol() : type(SYM_TYPE_UKN), name(), addr(0) {}<br/><br/>     SymbolType type;<br/>     std::string name;<br/>     uint64_t    addr;<br/>   };<br/><br/><span class="ent">➋</span> class Section {<br/>   public:<br/>     enum SectionType {<br/>       SEC_TYPE_NONE = 0,<br/>       SEC_TYPE_CODE = 1,<br/>       SEC_TYPE_DATA = 2<br/>     };<br/><br/>     Section() : binary(NULL), type(SEC_TYPE_NONE),<br/>                 vma(0), size(0), bytes(NULL) {}<br/><br/>     bool contains(uint64_t addr) { return (addr &gt;= vma) &amp;&amp; (addr-vma &lt; size); }<br/><br/>     Binary         *binary;<br/>     std::string     name;<br/>     SectionType     type;<br/>     uint64_t        vma;<br/>     uint64_t        size;<br/>     uint8_t         *bytes;<br/>   };<br/><br/><span class="ent">➌</span> class Binary {<br/>   public:<br/>     enum BinaryType {<br/>       BIN_TYPE_AUTO = 0,<br/>       BIN_TYPE_ELF  = 1,<br/>       BIN_TYPE_PE   = 2<br/>     };<br/>     enum BinaryArch {<br/>       ARCH_NONE = 0,<br/>       ARCH_X86 = 1<br/>     };<br/><br/>     Binary() : type(BIN_TYPE_AUTO), arch(ARCH_NONE), bits(0), entry(0) {}<br/><br/>     Section *get_text_section()<br/>       { for(auto &amp;s : sections) if(s.name == ".text") return &amp;s; return NULL; }<br/><br/>     std::string            filename;<br/>     BinaryType             type;<br/>     std::string            type_str;<br/>     BinaryArch             arch;<br/>     std::string            arch_str;<br/>     unsigned               bits;<br/>     uint64_t               entry;<br/>     std::vector&lt;Section&gt;   sections;<br/>     std::vector&lt;Symbol&gt;    symbols;<br/>   };<br/><br/><span class="ent">➍</span> int load_binary(std::string &amp;fname, Binary *bin, Binary::BinaryType type);<br/><span class="ent">➎</span> void unload_binary(Binary *bin);<br/><br/> #endif /* LOADER_H */</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_70"/>As you can see, the API exposes a number of classes representing different components of a binary. The <span class="literal">Binary</span> class is the “root” class, representing an abstraction of the entire binary <span class="ent">➌</span>. Among other things, it contains a <span class="literal">vector</span> of <span class="literal">Section</span> objects and a <span class="literal">vector</span> of <span class="literal">Symbol</span> objects. The <span class="literal">Section</span> class <span class="ent">➋</span> and <span class="literal">Symbol</span> class <span class="ent">➊</span> represent the sections and symbols contained in the binary, respectively.</p>&#13;
<p class="indent">At its core, the whole API centers around only two functions. The first of these is the <span class="literal">load_binary</span> function <span class="ent">➍</span>, which takes the name of a binary file to load (<span class="literal">fname</span>), a pointer to a <span class="literal">Binary</span> object to contain the loaded binary (<span class="literal">bin</span>), and a descriptor of the binary type (<span class="literal">type</span>). It loads the requested binary into the <span class="literal">bin</span> parameter and returns an integer value of 0 if the loading process was successful or a value less than 0 if it was not successful. The second <span epub:type="pagebreak" id="page_71"/>function is <span class="literal">unload_binary</span> <span class="ent">➎</span>, which simply takes a pointer to a previously loaded <span class="literal">Binary</span> object and unloads it.</p>&#13;
<p class="indent">Now that you’re familiar with the binary loader API, let’s take a look at how it’s implemented. I’ll start by discussing the implementation of the <span class="literal">Binary</span> class.</p>&#13;
<h4 class="h4" id="ch04_2_1"><em>4.2.1 The Binary Class</em></h4>&#13;
<p class="noindent">As the name implies, the <span class="literal">Binary</span> class is an abstraction of a complete binary. It contains the binary’s filename, type, architecture, bit width, entry point address, and sections and symbols. The binary type has a dual representation: the <span class="literal">type</span> member contains a numeric type identifier, while <span class="literal">type_str</span> contains a string representation of the binary type. The same kind of dual representation is used for the architecture.</p>&#13;
<p class="indent">Valid binary types are enumerated in <span class="literal">enum BinaryType</span> and include ELF (<span class="literal">BIN_TYPE_ELF</span>) and PE (<span class="literal">BIN_TYPE_PE</span>). There’s also a <span class="literal">BIN_TYPE_AUTO</span>, which you can pass to the <span class="literal">load_binary</span> function to ask it to automatically determine whether the binary is an ELF or PE file. Similarly, valid architectures are enumerated in <span class="literal">enum BinaryArch</span>. For these purposes, the only valid architecture is <span class="literal">ARCH_X86</span>. This includes both x86 and x86-64; the distinction between the two is made by the <span class="literal">bits</span> member of the <span class="literal">Binary</span> class, which is set to 32 bits for x86 and to 64 bits for x86-64.</p>&#13;
<p class="indent">Normally, you access sections and symbols in the <span class="literal">Binary</span> class by iterating over the <span class="literal">sections</span> and <span class="literal">symbols</span> vectors, respectively. Because binary analysis often focuses on the code in the <span class="literal">.text</span> section, there is also a convenience function called <span class="literal">get_text_section</span> that, as the name implies, automatically looks up and returns this section for you.</p>&#13;
<h4 class="h4" id="ch04_2_2"><em>4.2.2 The Section Class</em></h4>&#13;
<p class="noindent">Sections are represented by objects of type <span class="literal">Section</span>. The <span class="literal">Section</span> class is a simple wrapper around the main properties of a section, including the section’s name, type, starting address (the <span class="literal">vma</span> member), size (in bytes), and raw bytes contained in the section. For convenience, there is also a pointer back to the <span class="literal">Binary</span> that contains the <span class="literal">Section</span> object. The section type is denoted by an <span class="literal">enum SectionType</span> value, which tells you whether the section contains code (<span class="literal">SEC_TYPE_CODE</span>) or data (<span class="literal">SEC_TYPE_DATA</span>).</p>&#13;
<p class="indent">During your analyses, you’ll often want to check to which section a particular instruction or piece of data belongs. For this reason, the <span class="literal">Section</span> class has a function called <span class="literal">contains</span>, which takes a code or data address and returns a <span class="literal">bool</span> indicating whether the address is part of the section.</p>&#13;
<h4 class="h4" id="ch04_2_3"><em>4.2.3 The Symbol Class</em></h4>&#13;
<p class="noindent">As you now know, binaries contain symbols for many types of components, including local and global variables, functions, relocation expressions, objects, and more. To keep things simple, the loader interface exposes only one kind of symbol: function symbols. These are especially useful <span epub:type="pagebreak" id="page_72"/>because they enable you to easily implement function-level binary analysis tools when function symbols are available.</p>&#13;
<p class="indent">The loader represents symbols using the <span class="literal">Symbol</span> class. It contains a symbol type, represented as an <span class="literal">enum SymbolType</span>, for which the only valid value is <span class="literal">SYM_TYPE_FUNC</span>. In addition, the class contains the symbolic name and the start address of the function described by the symbol.</p>&#13;
<h3 class="h3" id="ch04_3">4.3 Implementing the Binary Loader</h3>&#13;
<p class="noindent">Now that the binary loader has a well-defined interface, let’s implement it! This is where <span class="literal">libbfd</span> gets involved. Because the code for the complete loader is a bit lengthy, I’ll split it up into chunks, which I’ll discuss one by one. In the following code, you can recognize the <span class="literal">libbfd</span> API functions because they all start with <span class="literal">bfd_</span> (there are also some functions that end with <span class="literal">_bfd</span>, but they are functions defined by the loader).</p>&#13;
<p class="indent">First, you must of course include all the header files you need. I won’t mention all of the standard C/C++ headers that the loader uses since they’re not of interest here (if you really want, you can look them up in the loader’s source on the VM). What is important to mention is that all programs that use <span class="literal">libbfd</span> must include <em>bfd.h</em>, as shown in <a href="ch04.xhtml#ch04list2">Listing 4-2</a>, and link against <span class="literal">libbfd</span> by specifying the linker flag <span class="literal">-lbfd</span>. In addition to <em>bfd.h</em>, the loader includes the header file that contains the interface created in the previous section.</p>&#13;
<p class="listing1" id="ch04list2"><em>Listing 4-2:</em> inc/loader.cc</p>&#13;
<p class="programs">#include &lt;bfd.h&gt;<br/>#include "loader.h"</p>&#13;
<p class="indent">With that out of the way, the next logical parts of the code to look at are <span class="literal">load_binary</span> and <span class="literal">unload_binary</span>, the two entry point functions exposed by the loader interface. <a href="ch04.xhtml#ch04list3">Listing 4-3</a> shows how these functions are implemented.</p>&#13;
<p class="listing1" id="ch04list3"><em>Listing 4-3:</em> inc/loader.cc <em>(continued)</em></p>&#13;
<p class="programs">  int<br/><span class="ent">➊</span> load_binary(std::string &amp;fname, Binary *bin, Binary::BinaryType type)<br/>  {<br/>    return <span class="ent">➋</span>load_binary_bfd(fname, bin, type);<br/>  }<br/>  <br/>  void<br/><span class="ent">➌</span> unload_binary(Binary *bin)<br/>  {<br/>    size_t i;<br/>    Section *sec;<br/><br/><span class="ent">➍</span> for(i = 0; i &lt; bin-&gt;sections.size(); i++) {<br/>     sec = &amp;bin-&gt;sections[i];<br/>     if(sec-&gt;bytes) {<br/><span class="ent">➎</span>      free(sec-&gt;bytes);<br/>     }<br/>    }<br/>   }</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_73"/>The job of <span class="literal">load_binary</span> <span class="ent">➊</span> is to parse a binary file specified by filename and load it into the <span class="literal">Binary</span> object given to it. This is a bit of a tedious process, so <span class="literal">load_binary</span> wisely defers the work to another function, called <span class="literal">load_binary_bfd</span> <span class="ent">➋</span>. I’ll discuss this function shortly.</p>&#13;
<p class="indent">First, let’s look at <span class="literal">unload_binary</span> <span class="ent">➌</span>. As with so many things, destroying a <span class="literal">Binary</span> object is a lot easier than creating one. To unload a <span class="literal">Binary</span> object, the loader must release (with <span class="literal">free</span>) all of the <span class="literal">Binary</span>’s dynamically allocated components. Luckily, there aren’t many of those: only the <span class="literal">bytes</span> member of each <span class="literal">Section</span> is allocated dynamically (using <span class="literal">malloc</span>). Thus, <span class="literal">unload_binary</span> simply iterates over all <span class="literal">Section</span> objects <span class="ent">➍</span> and deallocates the <span class="literal">bytes</span> array for each of them <span class="ent">➎</span>. Now that you’ve seen how unloading a binary works, let’s take a more detailed look at how the loading process is implemented using <span class="literal">libbfd</span>.</p>&#13;
<h4 class="h4" id="ch04_3_1"><em>4.3.1 Initializing libbfd and Opening a Binary</em></h4>&#13;
<p class="noindent">In the previous section, I promised to show you <span class="literal">load_binary_bfd</span>, the function that uses <span class="literal">libbfd</span> to take care of all the work involved in loading the binary. Before I do that, I have to get one more prerequisite out of the way. That is, to parse and load a binary, you must first open it. The code to open a binary is implemented in a function called <span class="literal">open_bfd</span>, shown in <a href="ch04.xhtml#ch04list4">Listing 4-4</a>.</p>&#13;
<p class="listing1" id="ch04list4"><em>Listing 4-4:</em> inc/loader.cc <em>(continued)</em></p>&#13;
<p class="programs">   static bfd*<br/>   open_bfd(std::string &amp;fname)<br/>   {<br/>     static int bfd_inited = 0;<br/>     bfd *bfd_h;<br/><br/>     if(!bfd_inited) {<br/><span class="ent">➊</span>      bfd_init();<br/>        bfd_inited = 1;<br/>     }<br/><br/><span class="ent">➋</span>   bfd_h = bfd_openr(fname.c_str(), NULL);<br/>     if(!bfd_h) {<br/>       fprintf(stderr, "failed to open binary '%s' (%s)\n",<br/>               fname.c_str(), <span class="ent">➌</span>bfd_errmsg(bfd_get_error()));<br/>       return NULL;<br/>     }<br/><span class="ent">➍</span>   if(!bfd_check_format(bfd_h, bfd_object)) {<br/>       fprintf(stderr, "file '%s' does not look like an executable (%s)\n",<br/>               fname.c_str(), bfd_errmsg(bfd_get_error()));<br/>       return NULL;<br/>     }<br/><br/>     /* Some versions of bfd_check_format pessimistically set a wrong_format<br/>     * error before detecting the format and then neglect to unset it once<br/>     * the format has been detected. We unset it manually to prevent problems.<br/>     */<br/><span class="ent">➎</span>  bfd_set_error(bfd_error_no_error);<br/><br/><span class="ent">➏</span>  if(bfd_get_flavour(bfd_h) == bfd_target_unknown_flavour) {<br/>      fprintf(stderr, "unrecognized format for binary '%s' (%s)\n",<br/>             fname.c_str(), bfd_errmsg(bfd_get_error()));<br/>      return NULL;<br/>    }<br/>   <br/>    return bfd_h;<br/>  }</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_74"/>The <span class="literal">open_bfd</span> function uses <span class="literal">libbfd</span> to determine the properties of the binary specified by the filename (the <span class="literal">fname</span> parameter), open it, and then return a handle to the binary. Before you can use <span class="literal">libbfd</span>, you must call <span class="literal">bfd_init</span> <span class="ent">➊</span> to initialize <span class="literal">libbfd</span>’s internal state (or, as the documentation puts it, to “initialize magical internal data structures”). Since this needs to be done only once, <span class="literal">open_bfd</span> uses a static variable to keep track of whether the initialization has been done already.</p>&#13;
<p class="indent">After initializing <span class="literal">libbfd</span>, you call the <span class="literal">bfd_openr</span> function to open the binary by filename <span class="ent">➋</span>. The second parameter of <span class="literal">bfd_openr</span> allows you to specify a target (the type of the binary), but in this case, I’ve left it to <span class="literal">NULL</span> so that <span class="literal">libbfd</span> will automatically determine the binary type. The return value of <span class="literal">bfd_openr</span> is a pointer to a file handle of type <span class="literal">bfd</span>; this is <span class="literal">libbfd</span>’s root data structure, which you can pass to all other functions in <span class="literal">libbfd</span> to perform operations on the binary. In case of error, <span class="literal">bfd_openr</span> returns <span class="literal">NULL</span>.</p>&#13;
<p class="indent">In general, whenever an error occurs, you can find the type of the most recent error by calling <span class="literal">bfd_get_error</span>. This returns an object of the type <span class="literal">bfd_error_type</span>, which you can compare against predefined error identifiers such as <span class="literal">bfd_error_no_memory</span> or <span class="literal">bfd_error_invalid_target</span> to figure out how to handle the error. Often, you’ll just want to exit with an error message. To accommodate this, the <span class="literal">bfd_errmsg</span> function can translate a <span class="literal">bfd_error_type</span> into a string describing the error, which you can print to the screen <span class="ent">➌</span>.</p>&#13;
<p class="indent">After getting a handle to the binary, you should check the format of the binary using the <span class="literal">bfd_check_format</span> function <span class="ent">➍</span>. This function takes a <span class="literal">bfd</span> handle and a <span class="literal">bfd_format</span> value, which can be set to <span class="literal">bfd_object</span>, <span class="literal">bfd_archive</span>, or <span class="literal">bfd_core</span>. In this case, the loader sets it to <span class="literal">bfd_object</span> to verify whether the opened file is indeed an object, which in <span class="literal">libbfd</span> terminology means an executable, a relocatable object, or a shared library.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_75"/>After confirming that it’s dealing with a <span class="literal">bfd_object</span>, the loader manually sets <span class="literal">libbfd</span>’s error state to <span class="literal">bfd_error_no_error</span> <span class="ent">➎</span>. This is a work-around for an issue in some versions of <span class="literal">libbfd</span>, which set a <span class="literal">bfd_error_wrong_format</span> error before detecting the format and leave the error state set even if the format detection shows no problems.</p>&#13;
<p class="indent">Finally, the loader checks that the binary has a known “flavor” by using the <span class="literal">bfd_get_flavour</span> function <span class="ent">➏</span>. This function returns a <span class="literal">bfd_flavour</span> object, which simply indicates the kind of binary (ELF, PE, and so on). Valid <span class="literal">bfd_flavour</span> values include <span class="literal">bfd_target_msdos_flavour</span>, <span class="literal">bfd_target_coff_flavour</span>, and <span class="literal">bfd_target_elf_flavour</span>. If the binary format is unknown or there was an error, then <span class="literal">get_bfd_flavour</span> returns <span class="literal">bfd_target_unknown_flavour</span>, in which case <span class="literal">open_bfd</span> prints an error and returns <span class="literal">NULL</span>.</p>&#13;
<p class="indent">If all checks pass, it means that you have successfully opened a valid binary and are ready to start loading its contents! The <span class="literal">open_bfd</span> function returns the <span class="literal">bfd</span> handle it opened so you can use it later in other <span class="literal">libbfd</span> API calls, as shown in the next few listings.</p>&#13;
<h4 class="h4" id="ch04_3_2"><em>4.3.2 Parsing Basic Binary Properties</em></h4>&#13;
<p class="noindent">Now that you’ve seen the necessary code to open a binary, it’s time to take a look at the <span class="literal">load_binary_bfd</span> function, shown in <a href="ch04.xhtml#ch04list5">Listing 4-5</a>. Recall that this is the function that handles all the actual parsing and loading work on behalf of the <span class="literal">load_binary</span> function. In this section, the aim is to load all of the interesting details about the binary into the <span class="literal">Binary</span> object pointed to by the <span class="literal">bin</span> parameter.</p>&#13;
<p class="listing1" id="ch04list5"><em>Listing 4-5:</em> inc/loader.cc <em>(continued)</em></p>&#13;
<p class="programs">   static int<br/>   load_binary_bfd(std::string &amp;fname, Binary *bin, Binary::BinaryType type)<br/>   {<br/>     int ret;<br/>     bfd *bfd_h;<br/>     const bfd_arch_info_type *bfd_info;<br/><br/>     bfd_h = NULL;<br/><span class="ent">➊</span>   bfd_h = open_bfd(fname);<br/>     if(!bfd_h) {<br/>       goto fail;<br/>     }<br/><br/>     bin-&gt;filename = std::string(fname);<br/><span class="ent">➋</span>   bin-&gt;entry    = bfd_get_start_address(bfd_h);<br/><br/><span class="ent">➌</span>   bin-&gt;type_str = std::string(bfd_h-&gt;xvec-&gt;name);<br/><span class="ent">➍</span>   switch(bfd_h-&gt;xvec-&gt;flavour) {<br/>     case bfd_target_elf_flavour:<br/>       bin-&gt;type = Binary::BIN_TYPE_ELF;<br/>       break;<br/>    case bfd_target_coff_flavour:<br/>      bin-&gt;type = Binary::BIN_TYPE_PE;<br/>      break;<br/>    case bfd_target_unknown_flavour:<br/>    default:<br/>      fprintf(stderr, "unsupported binary type (%s)\n", bfd_h-&gt;xvec-&gt;name);<br/>      goto fail;<br/>    }<br/><br/><span class="ent">➎</span>     bfd_info = bfd_get_arch_info(bfd_h);<br/><span class="ent">➏</span>     bin-&gt;arch_str = std::string(bfd_info-&gt;printable_name);<br/><span class="ent">➐</span>     switch(bfd_info-&gt;mach) {<br/>      case bfd_mach_i386_i386:<br/>        bin-&gt;arch = Binary::ARCH_X86;<br/>        bin-&gt;bits = 32;<br/>        break;<br/>      case bfd_mach_x86_64:<br/>        bin-&gt;arch = Binary::ARCH_X86;<br/>        bin-&gt;bits = 64;<br/>        break;<br/>      default:<br/>        fprintf(stderr, "unsupported architecture (%s)\n",<br/>                bfd_info-&gt;printable_name);<br/>        goto fail;<br/>      }<br/><br/>      /* Symbol handling is best-effort only (they may not even be present) */<br/><span class="ent">➑</span>    load_symbols_bfd(bfd_h, bin);<br/><span class="ent">➒</span>    load_dynsym_bfd(bfd_h, bin);<br/><br/>      if(load_sections_bfd(bfd_h, bin) &lt; 0) goto fail;<br/><br/>      ret = 0;<br/>      goto cleanup;<br/><br/>    fail:<br/>      ret = -1;<br/><br/>    cleanup:<br/><span class="ent">➓</span>    if(bfd_h) bfd_close(bfd_h);<br/><br/>      return ret;<br/>   }</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_76"/>The <span class="literal">load_binary_bfd</span> function begins by using the just implemented <span class="literal">open_bfd</span> function to open the binary specified in the <span class="literal">fname</span> parameter and <span epub:type="pagebreak" id="page_77"/>get a <span class="literal">bfd</span> handle to this binary <span class="ent">➊</span>. Then, <span class="literal">load_binary_bfd</span> sets some of <span class="literal">bin</span>’s basic properties. It starts by copying the name of the binary file and using <span class="literal">libbfd</span> to find and copy the entry point address <span class="ent">➋</span>.</p>&#13;
<p class="indent">To get the entry point address of a binary, you use <span class="literal">bfd_get_start_address</span>, which simply returns the value of the <span class="literal">start_address</span> field of the <span class="literal">bfd</span> object. The start address is a <span class="literal">bfd_vma</span>, which is really nothing more than a 64-bit unsigned integer.</p>&#13;
<p class="indent">Next, the loader collects information about the binary type: is it an ELF, a PE, or some other, unsupported type of binary? You can find this information in the <span class="literal">bfd_target</span> structure maintained by <span class="literal">libbfd</span>. To get a pointer to this data structure, you just need to access the <span class="literal">xvec</span> field in the <span class="literal">bfd</span> handle. In other words, <span class="literal">bfd_h-&gt;xvec</span> gives you a pointer to a <span class="literal">bfd_target</span> structure.</p>&#13;
<p class="indent">Among other things, this structure provides a string containing the name of the target type. The loader copies this string into the <span class="literal">Binary</span> object <span class="ent">➌</span>. Next, it inspects the <span class="literal">bfd_h-&gt;xvec-&gt;flavour</span> field using a switch and sets the type of the <span class="literal">Binary</span> accordingly <span class="ent">➍</span>. The loader supports only ELF and PE, so it emits an error if <span class="literal">bfd_h-&gt;xvec-&gt;flavour</span> indicates any other type of binary.</p>&#13;
<p class="indent">Now you know whether the binary is an ELF or PE, but you don’t yet know the architecture. To find this out, you use <span class="literal">libbfd</span>’s <span class="literal">bfd_get_arch_info</span> function <span class="ent">➎</span>. As the name implies, this function returns a pointer to a data structure that provides information about the binary architecture. This data structure is called <span class="literal">bfd_arch_info_type</span>. It provides a convenient printable string describing the architecture, which the loader copies into the <span class="literal">Binary</span> object <span class="ent">➏</span>.</p>&#13;
<p class="indent">The <span class="literal">bfd_arch_info_type</span> data structure also contains a field called <span class="literal">mach</span> <span class="ent">➐</span>, which is just an integer identifier for the architecture (called the <em>machine</em> in <span class="literal">libbfd</span> terminology). This integer representation of the architecture allows for a convenient <span class="literal">switch</span> to implement architecture-specific handling. If <span class="literal">mach</span> is equal to <span class="literal">bfd_mach_i386_i386</span>, then it’s a 32-bit x86 binary, and the loader sets the fields in the <span class="literal">Binary</span> accordingly. If <span class="literal">mach</span> is <span class="literal">bfd_mach_x86_64</span>, then it’s an x86-64 binary, and the loader again sets the appropriate fields. Any other type is unsupported and results in an error.</p>&#13;
<p class="indent">Now that you’ve seen how to parse basic information about the binary type and architecture, it’s time to get to the real work: loading the symbols and sections contained in the binary. As you might imagine, this is not as simple as what you’ve seen so far, so the loader defers the necessary work to specialized functions, described in the next sections. The two functions the loader uses to load symbols are called <span class="literal">load_symbols_bfd</span> and <span class="literal">load_dynsym_bfd</span> <span class="ent">➑</span>. As described in the next section, they load symbols from the static and dynamic symbol tables, respectively. The loader also implements <span class="literal">load_sections_bfd</span>, a specialized function to load the binary’s sections <span class="ent">➒</span>. I’ll discuss it shortly, in <a href="ch04.xhtml#ch04_3_4">Section 4.3.4</a>.</p>&#13;
<p class="indent">After loading the symbols and sections, you’ll have copied all the information that you’re interested in to your own <span class="literal">Binary</span> object, which means you’re done using <span class="literal">libbfd</span>. Because the <span class="literal">bfd</span> handle is no longer needed, <span epub:type="pagebreak" id="page_78"/>the loader closes it using <span class="literal">bfd_close</span> <span class="ent">➓</span>. It also closes the handle if any error happens before it’s fully done loading the binary.</p>&#13;
<h4 class="h4" id="ch04_3_3"><em>4.3.3 Loading Symbols</em></h4>&#13;
<p class="noindent"><a href="ch04.xhtml#ch04list6">Listing 4-6</a> shows the code for <span class="literal">load_symbols_bfd</span>, the function to load the static symbol table.</p>&#13;
<p class="listing1" id="ch04list6"><em>Listing 4-6:</em> inc/loader.cc <em>(continued)</em></p>&#13;
<p class="programs">   static int<br/>   load_symbols_bfd(bfd *bfd_h, Binary *bin)<br/>   {<br/>     int ret;<br/>     long n, nsyms, i;<br/><span class="ent">➊</span>   asymbol **bfd_symtab;<br/>     Symbol *sym;<br/>   <br/>     bfd_symtab = NULL;<br/>   <br/><span class="ent">➋</span>    n = bfd_get_symtab_upper_bound(bfd_h);<br/>     if(n &lt; 0) {<br/>       fprintf(stderr, "failed to read symtab (%s)\n",<br/>               bfd_errmsg(bfd_get_error()));<br/>       goto fail;<br/>     } else if(n) {<br/><span class="ent">➌</span>      bfd_symtab = (asymbol**)malloc(n);<br/>       if(!bfd_symtab) {<br/>         fprintf(stderr, "out of memory\n");<br/>        goto fail;<br/>       }<br/><span class="ent">➍</span>     nsyms = bfd_canonicalize_symtab(bfd_h, bfd_symtab);<br/>       if(nsyms &lt; 0) {<br/>         fprintf(stderr, "failed to read symtab (%s)\n",<br/>                bfd_errmsg(bfd_get_error()));<br/>         goto fail;<br/>       }<br/><span class="ent">➎</span>     for(i = 0; i &lt; nsyms; i++) {<br/><span class="ent">➏</span>       if(bfd_symtab[i]-&gt;flags &amp; BSF_FUNCTION) {<br/>           bin-&gt;symbols.push_back(Symbol());<br/>           sym = &amp;bin-&gt;symbols.back();<br/><span class="ent">➐</span>         sym-&gt;type = Symbol::SYM_TYPE_FUNC;<br/><span class="ent">➑</span>         sym-&gt;name = std::string(bfd_symtab[i]-&gt;name);<br/><span class="ent">➒</span>         sym-&gt;addr = bfd_asymbol_value(bfd_symtab[i]);<br/>         }<br/>       }<br/>     }<br/>     ret = 0;<br/>     goto cleanup;<br/><br/>   fail:<br/>     ret = -1;<br/><br/>   cleanup:<br/><span class="ent">➓</span>   if(bfd_symtab) free(bfd_symtab);<br/><br/>     return ret;<br/><br/>  }</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_79"/>In <span class="literal">libbfd</span>, symbols are represented by the <span class="literal">asymbol</span> structure, which is just a short name for <span class="literal">struct bfd_symbol</span>. In turn, a symbol table is just an <span class="literal">asymbol**</span>, meaning an array of pointers to symbols. Thus, the job of <span class="literal">load_symbols_bfd</span> is to populate the array of <span class="literal">asymbol</span> pointers declared at <span class="ent">➊</span> and then to copy the interesting information to the <span class="literal">Binary</span> object.</p>&#13;
<p class="indent">The input parameters to <span class="literal">load_symbols_bfd</span> are a <span class="literal">bfd</span> handle and the <span class="literal">Binary</span> object in which to store the symbolic information. Before you can load any symbol pointers, you need to allocate enough space to store all of them in. The <span class="literal">bfd_get_symtab_upper_bound</span> function <span class="ent">➋</span> tells you how many bytes to allocate for this purpose. The number of bytes is negative in case of an error, and it can also be zero, meaning that there is no symbol table. If there’s no symbol table, <span class="literal">load_symbols_bfd</span> is done and simply returns.</p>&#13;
<p class="indent">If all is well and the symbol table contains a positive number of bytes, you allocate enough space to keep all the <span class="literal">asymbol</span> pointers in <span class="ent">➌</span>. If the <span class="literal">malloc</span> succeeds, you’re finally ready to ask <span class="literal">libbfd</span> to populate your symbol table! You do this using the <span class="literal">bfd_canonicalize_symtab</span> function <span class="ent">➍</span>, which takes as input your <span class="literal">bfd</span> handle and the symbol table that you want to populate (your <span class="literal">asymbol**</span>). As requested, <span class="literal">libbfd</span> duly populates your symbol table and returns the number of symbols it placed in the table (again, if that number is negative, you know something went wrong).</p>&#13;
<p class="indent">Now that you have a populated symbol table, you can loop over all the symbols it contains <span class="ent">➎</span>. Recall that for the binary loader, you are interested only in function symbols. Thus, for each symbol, you check whether the <span class="literal">BSF_FUNCTION</span> flag is set, which indicates that it is a function symbol <span class="ent">➏</span>. If this is the case, you reserve room for a <span class="literal">Symbol</span> (recall that this is the loader’s own class to store symbols in) in the <span class="literal">Binary</span> object by adding an entry to the <span class="literal">vector</span> that contains all the loaded symbols. You mark the newly created <span class="literal">Symbol</span> as a function symbol <span class="ent">➐</span>, copy the symbolic name <span class="ent">➑</span>, and set the <span class="literal">Symbol</span>’s address <span class="ent">➒</span>. To get a function symbol’s value, which is the function’s start address, you use the <span class="literal">bfd_asymbol_value</span> function provided by <span class="literal">libbfd</span>.</p>&#13;
<p class="indent">Now that all of the interesting symbols have been copied into <span class="literal">Symbol</span> objects, the loader no longer needs <span class="literal">libbfd</span>’s representation. Therefore, when <span class="literal">load_symbols_bfd</span> finishes, it deallocates any space reserved to store <span class="literal">libbfd</span> symbols <span class="ent">➓</span>. After that, it returns, and the symbol-loading process is complete.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_80"/>So, that’s how you load symbols from the static symbol table with <span class="literal">libbfd</span>. But how is it done for the dynamic symbol table? Luckily, the process is almost completely identical, as you can see in <a href="ch04.xhtml#ch04list7">Listing 4-7</a>.</p>&#13;
<p class="listing1" id="ch04list7"><em>Listing 4-7:</em> inc/loader.cc <em>(continued)</em></p>&#13;
<p class="programs">   static int<br/>   load_dynsym_bfd(bfd *bfd_h, Binary *bin)<br/>   {<br/>     int ret;<br/>     long n, nsyms, i;<br/><span class="ent">➊</span>   asymbol **bfd_dynsym;<br/>     Symbol *sym;<br/>   <br/>     bfd_dynsym = NULL;<br/>   <br/><span class="ent">➋</span>   n = bfd_get_dynamic_symtab_upper_bound(bfd_h);<br/>     if(n &lt; 0) {<br/>       fprintf(stderr, "failed to read dynamic symtab (%s)\n",<br/>               bfd_errmsg(bfd_get_error()));<br/>       goto fail;<br/>     } else if(n) {<br/>       bfd_dynsym = (asymbol**)malloc(n);<br/>       if(!bfd_dynsym) {<br/>         fprintf(stderr, "out of memory\n");<br/>         goto fail;<br/>      }<br/><span class="ent">➌</span>    nsyms = bfd_canonicalize_dynamic_symtab(bfd_h, bfd_dynsym);<br/>      if(nsyms &lt; 0) {<br/>        fprintf(stderr, "failed to read dynamic symtab (%s)\n",<br/>                bfd_errmsg(bfd_get_error()));<br/>       goto fail;<br/>     }<br/>     for(i = 0; i &lt; nsyms; i++) {<br/>       if(bfd_dynsym[i]-&gt;flags &amp; BSF_FUNCTION) {<br/>         bin-&gt;symbols.push_back(Symbol());<br/>         sym = &amp;bin-&gt;symbols.back();<br/>         sym-&gt;type = Symbol::SYM_TYPE_FUNC;<br/>         sym-&gt;name = std::string(bfd_dynsym[i]-&gt;name);<br/>         sym-&gt;addr = bfd_asymbol_value(bfd_dynsym[i]);<br/>       }<br/>      }<br/>     }<br/>    <br/>     ret = 0;<br/>     goto cleanup;<br/>   <br/>   fail:<br/>     ret = -1;<br/>     <br/>   cleanup:<br/>     if(bfd_dynsym) free(bfd_dynsym);<br/>    <br/>     return ret;<br/>   }</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_81"/>The function shown in <a href="ch04.xhtml#ch04list7">Listing 4-7</a> to load symbols from the dynamic symbol table is aptly called <span class="literal">load_dynsym_bfd</span>. As you can see, <span class="literal">libbfd</span> uses the same data structure (<span class="literal">asymbol</span>) to represent both static and dynamic symbols <span class="ent">➊</span>. The only differences with the previously shown <span class="literal">load_symbols_bfd</span> function are the following. First, to find the number of bytes you need to reserve for symbol pointers, you call <span class="literal">bfd_get_dynamic_symtab_upper_bound</span> <span class="ent">➋</span> instead of <span class="literal">bfd_get_symtab_upper_bound</span>. Second, to populate the symbol table, you use <span class="literal">bfd_canonicalize_dynamic_symtab</span> <span class="ent">➌</span> instead of <span class="literal">bfd_canonicalize_symtab</span>. That’s it! The rest of the dynamic symbol-loading process is the same as for static symbols.</p>&#13;
<h4 class="h4" id="ch04_3_4"><em>4.3.4 Loading Sections</em></h4>&#13;
<p class="noindent">After loading the symbols, only one thing remains to be done, though it’s arguably the most important step: loading the binary’s sections. <a href="ch04.xhtml#ch04list8">Listing 4-8</a> shows how <span class="literal">load_sections_bfd</span> implements the functionality to do this.</p>&#13;
<p class="listing1" id="ch04list8"><em>Listing 4-8:</em> inc/loader.cc <em>(continued)</em></p>&#13;
<p class="programs">  static int<br/>  load_sections_bfd(bfd *bfd_h, Binary *bin)<br/>  {<br/>    int bfd_flags;<br/>    uint64_t vma, size;<br/>    const char *secname;<br/><span class="ent">➊</span>  asection* bfd_sec;<br/>    Section *sec;<br/>    Section::SectionType sectype;<br/>  <br/><span class="ent">➋</span>  for(bfd_sec = bfd_h-&gt;sections; bfd_sec; bfd_sec = bfd_sec-&gt;next) {<br/><span class="ent">➌</span>    bfd_flags = bfd_get_section_flags(bfd_h, bfd_sec);<br/><br/>      sectype = Section::SEC_TYPE_NONE;<br/><span class="ent">➍</span>    if(bfd_flags &amp; SEC_CODE) {<br/>        sectype = Section::SEC_TYPE_CODE;<br/>      } else if(bfd_flags &amp; SEC_DATA) {<br/>        sectype = Section::SEC_TYPE_DATA;<br/>      } else {<br/>        continue;<br/>      }<br/><span class="ent">➎</span>    vma     = bfd_section_vma(bfd_h, bfd_sec);<br/><span class="ent">➏</span>    size    = bfd_section_size(bfd_h, bfd_sec);<br/><span class="ent">➐</span>    secname = bfd_section_name(bfd_h, bfd_sec);<br/>     if(!secname) secname = "&lt;unnamed&gt;";<br/>  <br/><span class="ent">➑</span>    bin-&gt;sections.push_back(Section());<br/>      sec = &amp;bin-&gt;sections.back();<br/>  <br/>      sec-&gt;binary = bin;<br/>      sec-&gt;name   = std::string(secname);<br/>      sec-&gt;type   = sectype;<br/>      sec-&gt;vma    = vma;<br/>      sec-&gt;size   = size;<br/><span class="ent">➒</span>    sec-&gt;bytes  = (uint8_t*)malloc(size);<br/>      if(!sec-&gt;bytes) {<br/>        fprintf(stderr, "out of memory\n");<br/>        return -1;<br/>     }<br/>    <br/><span class="ent">➓</span>   if(!bfd_get_section_contents(bfd_h, bfd_sec, sec-&gt;bytes, 0, size)) {<br/>       fprintf(stderr, "failed to read section '%s' (%s)\n",<br/>              secname, bfd_errmsg(bfd_get_error()));<br/>       return -1;<br/>     }<br/>   }<br/><br/>   return 0;<br/> }</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_82"/>To store sections, <span class="literal">libbfd</span> uses a data structure called <span class="literal">asection</span>, also known as <span class="literal">struct bfd_section</span>. Internally, <span class="literal">libbfd</span> keeps a linked list of <span class="literal">asection</span> structures to represent all sections. The loader reserves an <span class="literal">asection*</span> to iterate over this list <span class="ent">➊</span>.</p>&#13;
<p class="indent">To iterate over all the sections, you start at the first one (pointed to by <span class="literal">bfd_h-&gt;sections</span>, the head of <span class="literal">libbfd</span>’s section list) and then follow the <span class="literal">next</span> pointer contained in each <span class="literal">asection</span> object <span class="ent">➋</span>. When the <span class="literal">next</span> pointer is <span class="literal">NULL</span>, you’ve reached the end of the list.</p>&#13;
<p class="indent">For each section, the loader first checks whether it should be loaded at all. Since the loader only loads code and data sections, it starts by getting the section flags to check what the type of the section is. To get the flags, it uses <span class="literal">bfd_get_section_flags</span> <span class="ent">➌</span>. Then, it checks whether either the <span class="literal">SEC_CODE</span> or <span class="literal">SEC_DATA</span> flag is set <span class="ent">➍</span>. If not, then it skips this section and moves on to the next. If either of the flags <em>is</em> set, then the loader sets the section type for the corresponding <span class="literal">Section</span> object and continues loading the section.</p>&#13;
<p class="indent">In addition to the section type, the loader copies the virtual address, size (in bytes), name, and raw bytes of each code or data section. To find the virtual base address of a <span class="literal">libbfd</span> section, you use <span class="literal">bfd_section_vma</span> <span class="ent">➎</span>. Similarly, <span epub:type="pagebreak" id="page_83"/>you use <span class="literal">bfd_section_size</span><span class="ent">➏</span> and <span class="literal">bfd_section_name</span> <span class="ent">➐</span> to get the size and name of the section, respectively. It’s possible that the section has no name, in which case <span class="literal">bfd_section_name</span> will return <span class="literal">NULL</span>.</p>&#13;
<p class="indent">The loader now copies the actual contents of the section into a <span class="literal">Section</span> object. To accomplish that, it reserves a <span class="literal">Section</span> in the <span class="literal">Binary</span> <span class="ent">➑</span> and copies all the fields it just read. Then, it allocates enough space in the <span class="literal">bytes</span> member of the <span class="literal">Section</span> to contain all of the bytes in the section <span class="ent">➒</span>. If the <span class="literal">malloc</span> succeeds, it copies all the section bytes from the <span class="literal">libbfd</span> section object into the <span class="literal">Section</span>, using the <span class="literal">bfd_get_section_contents</span> function <span class="ent">➓</span>. The arguments it takes are a <span class="literal">bfd</span> handle, a pointer to the <span class="literal">asection</span> object of interest, a destination array to contain the section contents, the offset at which to start copying, and the number of bytes to copy into the destination array. To copy all the bytes, the start offset is 0 and the number of bytes to copy is equal to the section size. If the copy succeeds, <span class="literal">bfd_get_section_contents</span> returns <span class="literal">true</span>; otherwise, it returns <span class="literal">false</span>. If all went well, the loading process is now complete!</p>&#13;
<h3 class="h3" id="ch04_4">4.4 Testing the Binary Loader</h3>&#13;
<p class="noindent">Let’s create a simple program to test the new binary loader. The program will take the name of a binary as input, use the loader to load that binary, and then display some diagnostics about what it loaded. <a href="ch04.xhtml#ch04list9">Listing 4-9</a> shows the code for the test program.</p>&#13;
<p class="listing1" id="ch04list9"><em>Listing 4-9:</em> loader_demo.cc</p>&#13;
<p class="programs">     #include &lt;stdio.h&gt;<br/>     #include &lt;stdint.h&gt;<br/>     #include &lt;string&gt;<br/>     #include "../inc/loader.h"<br/><br/>     int<br/>     main(int argc, char *argv[])<br/>     {<br/>       size_t i;<br/>       Binary bin;<br/>       Section *sec;<br/>       Symbol *sym;<br/>       std::string fname;<br/><br/>       if(argc &lt; 2) {<br/>         printf("Usage: %s &lt;binary&gt;\n", argv[0]);<br/>         return 1;<br/>     }<br/><br/>     fname.assign(argv[1]);<br/><span class="ent">➊</span>   if(load_binary(fname, &amp;bin, Binary::BIN_TYPE_AUTO) &lt; 0) {<br/>       return 1;<br/>     }<br/><br/><span class="ent">➋</span>   printf("loaded binary '%s' %s/%s (%u bits) entry@0x%016jx\n",<br/>           bin.filename.c_str(),<br/>           bin.type_str.c_str(), bin.arch_str.c_str(),<br/>           bin.bits, bin.entry);<br/><br/><span class="ent">➌</span>   for(i = 0; i &lt; bin.sections.size(); i++) {<br/>       sec = &amp;bin.sections[i];<br/>       printf(" 0x%016jx %-8ju %-20s %s\n",<br/>              sec-&gt;vma, sec-&gt;size, sec-&gt;name.c_str(),<br/>              sec-&gt;type == Section::SEC_TYPE_CODE ? "CODE" : "DATA");<br/>     }<br/><br/><span class="ent">➍</span>   if(bin.symbols.size() &gt; 0) {<br/>       printf("scanned symbol tables\n");<br/>       for(i = 0; i &lt; bin.symbols.size(); i++) {<br/>         sym = &amp;bin.symbols[i];<br/>         printf(" %-40s 0x%016jx %s\n",<br/>                sym-&gt;name.c_str(), sym-&gt;addr,<br/>                (sym-&gt;type &amp; Symbol::SYM_TYPE_FUNC) ? "FUNC" : "");<br/>       }<br/>     }<br/><br/><span class="ent">➎</span>   unload_binary(&amp;bin);<br/><br/>     return 0;<br/>    }</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_84"/>This test program loads the binary given to it as its first argument <span class="ent">➊</span> and then displays some basic information about the binary such as the filename, type, architecture, and entry point <span class="ent">➋</span>. It then prints the base address, size, name, and type of every section <span class="ent">➌</span> and finally displays all of the symbols that were found <span class="ent">➍</span>. It then unloads the binary and returns <span class="ent">➎</span>. Try running the <span class="literal">loader_demo</span> program in the VM! You should see output similar to <a href="ch04.xhtml#ch04list10">Listing 4-10</a>.</p>&#13;
<p class="listing1" id="ch04list10"><em>Listing 4-10: Example output of the loader test program</em></p>&#13;
<p class="programs">$ <span class="codestrong1">loader_demo /bin/ls</span><br/><br/>loaded binary '/bin/ls' elf64-x86-64/i386:x86-64 (64 bits) entry@0x4049a0<br/>  0x0000000000400238 28     .interp                DATA<br/>  0x0000000000400254 32     .note.ABI-tag          DATA<br/>  0x0000000000400274 36     .note.gnu.build-id     DATA<br/>  0x0000000000400298 192    .gnu.hash              DATA<br/>  0x0000000000400358 3288   .dynsym                DATA<br/>  0x0000000000401030 1500   .dynstr                DATA<br/>  0x000000000040160c 274    .gnu.version           DATA<br/>  0x0000000000401720 112    .gnu.version_r         DATA<br/>  0x0000000000401790 168    .rela.dyn              DATA<br/>  0x0000000000401838 2688   .rela.plt              DATA<br/>  0x00000000004022b8 26     .init                  CODE<br/>  0x00000000004022e0 1808   .plt                   CODE<br/>  0x00000000004029f0 8      .plt.got               CODE<br/>  0x0000000000402a00 70281  .text                  CODE<br/>  0x0000000000413c8c 9      .fini                  CODE<br/>  0x0000000000413ca0 27060  .rodata                DATA<br/>  0x000000000041a654 2060   .eh_frame_hdr          DATA<br/>  0x000000000041ae60 11396  .eh_frame              DATA<br/>  0x000000000061de00 8      .init_array            DATA<br/>  0x000000000061de08 8      .fini_array            DATA<br/>  0x000000000061de10 8      .jcr                   DATA<br/>  0x000000000061de18 480    .dynamic               DATA<br/>  0x000000000061dff8 8      .got                   DATA<br/>  0x000000000061e000 920    .got.plt               DATA<br/>  0x000000000061e3a0 608    .data                  DATA<br/>scanned symbol tables<br/>...<br/>  _fini                     0x0000000000413c8c     FUNC<br/>  _init                     0x00000000004022b8     FUNC<br/>  free                      0x0000000000402340     FUNC<br/>  _obstack_memory_used      0x0000000000412960     FUNC<br/>  _obstack_begin            0x0000000000412780     FUNC<br/>  _obstack_free             0x00000000004128f0     FUNC<br/>  localtime_r               0x00000000004023a0     FUNC<br/>  _obstack_allocated_p      0x00000000004128c0     FUNC<br/>  _obstack_begin_1          0x00000000004127a0     FUNC<br/>  _obstack_newchunk         0x00000000004127c0     FUNC<br/>  malloc                    0x0000000000402790     FUNC</p>&#13;
<h3 class="h3" id="ch04_5">4.5 Summary</h3>&#13;
<p class="noindent"><span epub:type="pagebreak" id="page_85"/>In <a href="ch01.xhtml#ch01">Chapters 1</a> through <a href="ch03.xhtml#ch03">3</a>, you learned all about binary formats. In this chapter, you learned how to load these binaries to prepare them for subsequent binary analysis. In the process, you also learned about <span class="literal">libbfd</span>, a commonly used library for loading binaries. Now that you have a functioning binary loader, you’re ready to move on to techniques for analyzing binaries. After an introduction to fundamental binary analysis techniques in <a href="part2.xhtml">Part II</a> of this book, you’ll use the loader in <a href="part3.xhtml">Part III</a> to implement your own binary analysis tools.</p>&#13;
<div class="box">&#13;
<p class="headbox" id="ch04_6"><span epub:type="pagebreak" id="page_86"/>Exercises</p>&#13;
<p class="boxhead1">1. Dumping Section Contents</p>&#13;
<p class="noindent">For brevity, the current version of the <span class="literal">loader_demo</span> program doesn’t display section contents. Expand it with the ability to take a binary and the name of a section as input. Then dump the contents of that section to the screen in hexadecimal format.</p>&#13;
<p class="boxhead1">2. Overriding Weak Symbols</p>&#13;
<p class="noindent">Some symbols are <em>weak</em>, which means that their value may be overridden by another symbol that isn’t weak. Currently, the binary loader doesn’t take this into account and simply stores all symbols. Expand the binary loader so that if a weak symbol is later overridden by another symbol, only the latest version is kept. Take a look at <em>/usr/include/bfd.h</em> to figure out the flags to check for.</p>&#13;
<p class="boxhead1">3. Printing Data Symbols</p>&#13;
<p class="noindent">Expand the binary loader and the <span class="literal">loader_demo</span> program so that they can handle local and global data symbols as well as function symbols. You’ll need to add handling for data symbols in the loader, add a new <span class="literal">SymbolType</span> in the <span class="literal">Symbol</span> class, and add code to the <span class="literal">loader_demo</span> program to print the data symbols to screen. Be sure to test your modifications on a nonstripped binary to ensure the presence of some data symbols. Note that data items are called <em>objects</em> in symbol terminology. If you’re unsure about the correctness of your output, use <span class="literal">readelf</span> to verify it.</p>&#13;
</div>&#13;
</div></body></html>