<html><head></head><body>
<h2 class="h2" id="ch04"><span epub:type="pagebreak" id="page_51"/><strong><span class="big">4</span></strong><br/><strong>DIAGNOSTICS AND LOGGING</strong></h2>&#13;
<div class="image1"><img src="graphics/common-01.jpg" alt="image"/></div>&#13;
<p class="noindent">The OBD-II connector is primarily used by mechanics to quickly analyze and troubleshoot problems with a vehicle. (See “<a href="ch02.html#ch02lev2sec1">The OBD-II Connector</a>” on <a href="ch02.html#page_17">page 17</a> for help locating the OBD connector.) When a vehicle experiences a fault, it saves information related to that fault and triggers the engine warning light, also known as the <em>malfunction indicator lamp (MIL).</em> These routine diagnostic checks are handled by the vehicle’s primary ECU, the powertrain control module (PCM), which can be made up of several ECUs (but to keep the discussion simple, we’ll refer to it only as the PCM).</p>&#13;
<p class="indent">If you trigger faults while experimenting with the bus on a vehicle, you’ll need to able to read and write to the PCM in order to clear them. In this chapter, we’ll learn how to fetch and clear diagnostic codes as well as query the diagnostic services of the ECU. We’ll also learn how to access a vehicle’s crash data recordings and how to brute-force hidden diagnostic codes.</p>&#13;
<h3 class="h3" id="ch04lev1sec1"><span epub:type="pagebreak" id="page_52"/><strong>Diagnostic Trouble Codes</strong></h3>&#13;
<p class="noindent">The PCM stores fault codes as diagnostic trouble codes (DTCs). DTCs are stored in different places. For instance, memory-based DTCs are stored in the PCM’s RAM, which means they’re erased when power from the battery is lost (as is true for all DTCs stored in RAM). More serious DTCs are stored in areas that will survive a power failure.</p>&#13;
<p class="indent">Faults are usually classified as either hard or soft. Soft faults map to intermittent issues, whereas hard faults are ones that won’t go away without some sort of intervention. Often to determine whether a fault is hard or soft, a mechanic clears the DTCs and drives the vehicle to see whether the fault reappears. If it reappears, the fault is a hard fault. A soft fault could be due to a problem such as a loose gas cap.</p>&#13;
<p class="indent">Not all faults trigger the MIL light right away. Specifically, class A faults, which signal a gross emissions failure, light the MIL right away, while class B faults, which don’t affect the vehicle’s emissions system, are stored the first time they’re triggered as a <em>pending</em> fault. The PCM waits to record several of the same faults before triggering the MIL. Class C faults often won’t turn on the MIL light but instead trigger a “service engine soon” type of message. Class D faults don’t trigger the MIL light at all.</p>&#13;
<p class="indentb">When storing the DTCs, the PCM snapshots all the relevant engine components in what is known as <em>freeze frame data,</em> which typically includes information such as the following:</p>&#13;
<p class="bull">• DTC involved</p>&#13;
<p class="bull">• Engine load</p>&#13;
<p class="bull">• Engine revolutions per minute (RPM)</p>&#13;
<p class="bull">• Engine temperature</p>&#13;
<p class="bull">• Fuel trim</p>&#13;
<p class="bull">• Manifold air pressure/mass air flow (MAP/MAF) values</p>&#13;
<p class="bull">• Operating mode (open/close loop)</p>&#13;
<p class="bull">• Throttle position</p>&#13;
<p class="bull">• Vehicle speed</p>&#13;
<p class="indentt">Some systems store only one freeze frame, usually for the first DTC triggered or the highest-priority DTC, while others record multiple ones.</p>&#13;
<p class="indent">In an ideal world, these snapshots would happen as soon the DTC occurs, but the freeze frames are typically recorded about five seconds after a DTC is triggered.</p>&#13;
<h4 class="h4" id="ch04lev2sec1"><strong><em>DTC Format</em></strong></h4>&#13;
<p class="noindent">A DTC is a five-character alphanumeric code. For example, you’ll see codes like P0477 (exhaust pressure control valve low) and U0151 (lost communication with restraint control module). The code in the first byte position represents the basic function of the component that set the code, as shown in <a href="ch04.html#ch4tab1">Table 4-1</a>.</p>&#13;
<p class="tabcaption"><span epub:type="pagebreak" id="page_53"/><a id="ch4tab1"/><strong>Table 4-1:</strong> Diagnostic Code Layouts</p>&#13;
<table class="topbot">&#13;
<thead>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table_th"><p class="table"><strong>Byte position</strong></p></td>&#13;
<td style="vertical-align: top;" class="table_th"><p class="table"><strong>Description</strong></p></td>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table"><p class="table">1</p></td>&#13;
<td style="vertical-align: top;" class="table"><p class="table">P (0x0) = powertrain, B (0x1) = body,<br/>C (0x2) = chassis, U (0x3) = network</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table"><p class="table">2</p></td>&#13;
<td style="vertical-align: top;" class="table"><p class="table">0,2,3 (SAE standard) 1,3 (manufacturer specific)</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table"><p class="table">3</p></td>&#13;
<td style="vertical-align: top;" class="table"><p class="table">Subgroup of position 1</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table"><p class="table">4</p></td>&#13;
<td style="vertical-align: top;" class="table"><p class="table">Specific fault area</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table"><p class="table">5</p></td>&#13;
<td style="vertical-align: top;" class="table"><p class="table">Specific fault area</p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<div class="note">&#13;
<p class="notet"><strong><span class="bgblack">NOTE</span></strong></p>&#13;
<p class="notep"><em>When set to 3, byte 2 is both an SAE-defined standard and a manufacturer-specific code. Originally, 3 was used exclusively for manufacturers, but pressure is mounting to standardize 3 to mean a standard code instead. In modern cars, if you see a 3 in the second position, it’s probably an SAE standard code.</em></p>&#13;
</div>&#13;
<p class="indent">The five characters in a DTC are represented by just two raw bytes on the network. <a href="ch04.html#ch4tab2">Table 4-2</a> shows how to break down the 2 DTC bytes into a full DTC code.</p>&#13;
<p class="tabcaption"><a id="ch4tab2"/><strong>Table 4-2:</strong> Diagnostic Code Binary Breakdown</p>&#13;
<div class="image1"><img src="graphics/f0053-01.jpg" alt="image"/></div>&#13;
<p class="indent">Except for the first two, the characters have a one-to-one relationship. Refer to <a href="ch04.html#ch4tab1">Table 4-1</a> to see how the first two bits are assigned.</p>&#13;
<p class="indentb">You should be able to look up the meaning of any codes that follow the SAE standard online. Here are some example ranges for common powertrain DTCs:</p>&#13;
<p class="bull">• P0001–P0099: Fuel and air metering, auxiliary emissions controls</p>&#13;
<p class="bull">• P0100–P0199: Fuel and air metering</p>&#13;
<p class="bull">• P0200–P0299: Fuel and air metering (injector circuit)</p>&#13;
<p class="bull">• P0300–P0399: Ignition system or misfire</p>&#13;
<p class="bull">• P0400–P0499: Auxiliary emissions controls</p>&#13;
<p class="bull">• P0500–P0599: Vehicle speed controls, and idle control systems</p>&#13;
<p class="bull">• P0600–P0699: Computer output circuit</p>&#13;
<p class="bull">• P0700–P0799: Transmission</p>&#13;
<p class="indentt">To learn the meaning of a particular code, pick up a repair book in the Chilton series at your local auto shop. There, you’ll find a list of all OBD-II diagnostic codes for your vehicle.</p>&#13;
<h4 class="h4" id="ch04lev2sec2"><span epub:type="pagebreak" id="page_54"/><strong><em>Reading DTCs with Scan Tools</em></strong></h4>&#13;
<p class="noindent">Mechanics check fault codes with scan tools. Scan tools are nice to have but not necessary for vehicle hacking. You should be able to pick one up at any vehicle supply store or on the Internet for anywhere between $100 and $3,000.</p>&#13;
<p class="indent">For the cheapest possible solution, you can get an ELM327 device on eBay for around $10. These are typically dongles that need additional software, such as a mobile app, in order for them to function fully as scan tools. The software is usually free or under $5. A basic scan tool should be able to probe the vehicle’s fault system and report on the common, nonmanufacturer-specific DTC codes. Higher-end ones should have manufacturer-specific databases that allow you to perform much more detailed testing.</p>&#13;
<h4 class="h4" id="ch04lev2sec3"><strong><em>Erasing DTCs</em></strong></h4>&#13;
<p class="noindentb">DTCs usually erase themselves once the fault no longer appears during conditions similar to when the fault was first found. For this purpose, <em>similar</em> is defined as the following:</p>&#13;
<p class="bull">• Engine speed within 375 RPM of the flagged condition</p>&#13;
<p class="bull">• Engine load within 10 percent of the flagged condition</p>&#13;
<p class="bull">• Engine temp is similar</p>&#13;
<p class="indentt">Under normal conditions, once the PCM no longer sees a fault after three checks, the MIL light turns off and the DTCs get erased. There are other ways to clear these codes: you can clear soft DTCs with a scan tool (discussed in the previous section) or by disconnecting the vehicle’s battery. Permanent or hard DTCs, however, are stored in NVRAM and are cleared only when the PCM no longer sees the fault condition. The reason for this is simple enough: to prevent mechanics from manually turning off the MIL and clearing the DTCs when the problem still exists. Permanent DTCs give mechanics a history of faults so that they’re in a better position to repair them.</p>&#13;
<h3 class="h3" id="ch04lev1sec2"><strong>Unified Diagnostic Services</strong></h3>&#13;
<p class="noindent">The <em>Unified Diagnostic Services (UDS)</em> is designed to provide a uniform way to show mechanics what’s going on with a vehicle without their having to pay huge license fees for the auto manufacturer’s proprietary CAN bus packet layouts.</p>&#13;
<p class="indent">Unfortunately, although UDS was designed to make vehicle information accessible to even the mom-and-pop mechanic, the reality is a bit different: CAN packets are sent the same way but the contents vary for each make, model, and even year.</p>&#13;
<p class="indent">Auto manufacturers sell dealers licenses to the details of the packet contents. In practice, UDS just works as a gateway to make some but not all <span epub:type="pagebreak" id="page_55"/>of this vehicle information available. The UDS system does <em>not</em> affect how a vehicle operates; it’s basically just a read-only view into what’s going on. However, it’s possible to use UDS to perform more advanced operations, such as diagnostic tests or firmware modifications (tests that are only a feature of higher-end scan tools). Diagnostic tests like these send the system a request to perform an action, and that request generates signals, such as other CAN packets, that are used to perform the work. For instance, a diagnostic tool may make a request to unlock the car doors, which results in the component sending a separate CAN signal that actually does the work of unlocking the doors.</p>&#13;
<h4 class="h4" id="ch04lev2sec4"><strong><em>Sending Data with ISO-TP and CAN</em></strong></h4>&#13;
<p class="noindent">Because CAN frames are limited to 8 bytes of data, UDS uses the ISO-TP protocol to send larger outputs over the CAN bus. You can still use regular CAN to read or send data, but the response won’t be complete because ISO-TP allows chaining of multiple CAN packets.</p>&#13;
<p class="indent">To test ISO-TP, connect to a CAN network that has diagnostic-capable modules such as an ECU. Then send a packet designed for ISO-TP over normal CAN using SocketCAN’s <span class="literal">cansend</span> application:</p>&#13;
<p class="programs">$ <span class="codestrong">cansend can0 7df#02010d</span><br/>Replies similar to 7e8 03 41 0d 00</p>&#13;
<p class="indent">In this listing, <span class="literal">7df</span> is the OBD diagnostic code, <span class="literal">02</span> is the size of the packet, <span class="literal">01</span> is the mode (show current data; see <a href="app02.html#app02">Appendix B</a> for a list of common modes and PIDs), and <span class="literal">0d</span> is the service (a vehicle speed of 0 because the vehicle was stationary). The response adds 0x8 to the ID (<span class="literal">7e8</span>); the next byte is the size of the response. Responses then add 0x40 to the type of request, which is 0x41 in this case. Then, the service is repeated and followed by the data for the service. ISO-TP dictates how to respond to a CAN packet.</p>&#13;
<p class="indent">Normal CAN packets use a “fire-and-forget” structure, meaning they simply send data and don’t wait for a return packet. ISO-TP specifies a method to receive response data. Because this response data can’t be sent back using the same arbitration ID, the receiver returns the response by adding 0x8 to the ID and noting that the response is a positive one by adding 0x40 to the request. (If the response fails, you should see a 0x7F instead of the positive + 0x40 response.)</p>&#13;
<p class="indent"><a href="ch04.html#ch4tab3">Table 4-3</a> lists the most common error responses.</p>&#13;
<p class="tabcaption"><a id="ch4tab3"/><strong>Table 4-3:</strong> Common UDS Error Responses</p>&#13;
<table class="topbot">&#13;
<thead>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table_th"><p class="table"><strong>Hex (4th byte)</strong></p></td>&#13;
<td style="vertical-align: top;" class="table_th"><p class="table"><strong>Abbreviation</strong></p></td>&#13;
<td style="vertical-align: top;" class="table_th"><p class="table"><strong>Description</strong></p></td>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table"><p class="table">10</p></td>&#13;
<td style="vertical-align: top;" class="table"><p class="table">GR</p></td>&#13;
<td style="vertical-align: top;" class="table"><p class="table">General reject</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table"><p class="table">11</p></td>&#13;
<td style="vertical-align: top;" class="table"><p class="table">SNS</p></td>&#13;
<td style="vertical-align: top;" class="table"><p class="table">Service not supported</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table"><p class="table">12</p></td>&#13;
<td style="vertical-align: top;" class="table"><p class="table">SFNS</p></td>&#13;
<td style="vertical-align: top;" class="table"><p class="table">Subfunction not supported</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table"><p class="table">13</p></td>&#13;
<td style="vertical-align: top;" class="table"><p class="table">IMLOIF</p></td>&#13;
<td style="vertical-align: top;" class="table"><p class="table">Incorrect message length or invalid format</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table"><span epub:type="pagebreak" id="page_56"/><p class="table">14</p></td>&#13;
<td style="vertical-align: top;" class="table"><p class="table">RTL</p></td>&#13;
<td style="vertical-align: top;" class="table"><p class="table">Response too long</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table"><p class="table">21</p></td>&#13;
<td style="vertical-align: top;" class="table"><p class="table">BRR</p></td>&#13;
<td style="vertical-align: top;" class="table"><p class="table">Busy repeat request</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table"><p class="table">22</p></td>&#13;
<td style="vertical-align: top;" class="table"><p class="table">CNC</p></td>&#13;
<td style="vertical-align: top;" class="table"><p class="table">Condition not correct</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table"><p class="table">24</p></td>&#13;
<td style="vertical-align: top;" class="table"><p class="table">RSE</p></td>&#13;
<td style="vertical-align: top;" class="table"><p class="table">Request sequence error</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table"><p class="table">25</p></td>&#13;
<td style="vertical-align: top;" class="table"><p class="table">NRFSC</p></td>&#13;
<td style="vertical-align: top;" class="table"><p class="table">No response from subnet component</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table"><p class="table">26</p></td>&#13;
<td style="vertical-align: top;" class="table"><p class="table">FPEORA</p></td>&#13;
<td style="vertical-align: top;" class="table"><p class="table">Failure prevents execution of requested action</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table"><p class="table">31</p></td>&#13;
<td style="vertical-align: top;" class="table"><p class="table">ROOR</p></td>&#13;
<td style="vertical-align: top;" class="table"><p class="table">Request out of range</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table"><p class="table">33</p></td>&#13;
<td style="vertical-align: top;" class="table"><p class="table">SAD</p></td>&#13;
<td style="vertical-align: top;" class="table"><p class="table">Security access denied</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table"><p class="table">35</p></td>&#13;
<td style="vertical-align: top;" class="table"><p class="table">IK</p></td>&#13;
<td style="vertical-align: top;" class="table"><p class="table">Invalid key</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table"><p class="table">36</p></td>&#13;
<td style="vertical-align: top;" class="table"><p class="table">ENOA</p></td>&#13;
<td style="vertical-align: top;" class="table"><p class="table">Exceeded number of attempts</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table"><p class="table">37</p></td>&#13;
<td style="vertical-align: top;" class="table"><p class="table">RTDNE</p></td>&#13;
<td style="vertical-align: top;" class="table"><p class="table">Required time delay not expired</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table"><p class="table">38-4F</p></td>&#13;
<td style="vertical-align: top;" class="table"><p class="table">RBEDLSD</p></td>&#13;
<td style="vertical-align: top;" class="table"><p class="table">Reserved by extended data link security document</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table"><p class="table">70</p></td>&#13;
<td style="vertical-align: top;" class="table"><p class="table">UDNA</p></td>&#13;
<td style="vertical-align: top;" class="table"><p class="table">Upload/download not accepted</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table"><p class="table">71</p></td>&#13;
<td style="vertical-align: top;" class="table"><p class="table">TDS</p></td>&#13;
<td style="vertical-align: top;" class="table"><p class="table">Transfer data suspended</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table"><p class="table">72</p></td>&#13;
<td style="vertical-align: top;" class="table"><p class="table">GPF</p></td>&#13;
<td style="vertical-align: top;" class="table"><p class="table">General programming failure</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table"><p class="table">73</p></td>&#13;
<td style="vertical-align: top;" class="table"><p class="table">WBSC</p></td>&#13;
<td style="vertical-align: top;" class="table"><p class="table">Wrong block sequence counter</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table"><p class="table">78</p></td>&#13;
<td style="vertical-align: top;" class="table"><p class="table">RCRRP</p></td>&#13;
<td style="vertical-align: top;" class="table"><p class="table">Request correctly received but response is pending</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table"><p class="table">7E</p></td>&#13;
<td style="vertical-align: top;" class="table"><p class="table">SFNSIAS</p></td>&#13;
<td style="vertical-align: top;" class="table"><p class="table">Subfunction not supported in active session</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table"><p class="table">7F</p></td>&#13;
<td style="vertical-align: top;" class="table"><p class="table">SNSIAS</p></td>&#13;
<td style="vertical-align: top;" class="table"><p class="table">Service not supported in active session</p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<p class="indent">For example, if you use service 0x11 to reset the ECU and the ECU doesn’t support remote resets, you may see traffic like this:</p>&#13;
<p class="programs">$ <span class="codestrong">cansend can0 7df#021101</span><br/>Replies similar to 7e8 03 7F 11 11</p>&#13;
<p class="indent">In this response, we can see that after 0x7e8, the next byte is 0x03, which represents the size of the response. The next byte, 0x7F, represents an error for service 0x11, the third byte. The final byte, 0x11, represents the error returned—in this case, service not supported (SNS).</p>&#13;
<p class="indent">To send or receive something with more than the 8 bytes of data in a standard CAN packet, use SocketCAN’s ISO-TP tools. Run <span class="literal">istotpsend</span> in one terminal, and then run <span class="literal">isotpsniffer</span> (or <span class="literal">isotprecv</span>) in another terminal to see the response to your <span class="literal">istotpsend</span> commands. (Don’t forget to <span class="literal">insmod</span> your <span class="literal">can-isotp.ko</span> module, as described in <a href="ch03.html#ch03">Chapter 3</a>.)</p>&#13;
<p class="indent">For example, in one terminal, set up a sniffer like this:</p>&#13;
<p class="programs">$ <span class="codestrong">isotpsniffer -s 7df -d 7e8 can0</span></p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_57"/>Then, in another terminal, send the request packet via the command line:</p>&#13;
<p class="programs">$ <span class="codestrong">echo "09 02" | isotpsend -s 7DF -d 7E8 can0</span></p>&#13;
<p class="indent">When using ISO-TP, you need to specify a source and destination address (ID). In the case of UDS, the source is 0x7df, and the destination (response) is 0x7e8. (When using ISO-TP tools, the starting 0x in the addresses isn’t specified.)</p>&#13;
<p class="indent">In this example, we’re sending a packet containing PID 0x02 with mode 0x09 in order to request the vehicle’s VIN. The response in the sniffer should display the vehicle’s VIN, as shown here in the last line of output:</p>&#13;
<p class="programs">$ <span class="codestrong">isotpsniffer -s 7df -d 7e8 can0</span><br/> can0  7DF  [2]  09 02  - '..'<br/> can0  7E8  [20]  49<span class="ent">➊</span> 02<span class="ent">➋</span> 01<span class="ent">➌</span> 31 47 31 5A 54 35 33 38 32 36 46 31 30 39 31 34 39<br/>     - 'I..1G1ZT53826F109149'</p>&#13;
<p class="indent">The first 3 bytes make up the UDS response. 0x49 <span class="ent">➊</span> is service 0x09 + 0x40, which signifies a positive response for PID 0x02 <span class="ent">➋</span>, the next byte. The third byte, 0x01 <span class="ent">➌</span>, indicates the number of data items that are being returned (one VIN in this case). The VIN returned is 1G1ZT53826F109149. Enter this VIN into Google, and you should see detailed information about this vehicle, which was taken from an ECU pulled from a wrecked car found in a junkyard. <a href="ch04.html#ch4tab4">Table 4-4</a> shows the information you should see.</p>&#13;
<p class="tabcaption"><a id="ch4tab4"/><strong>Table 4-4:</strong> VIN Information</p>&#13;
<table class="topbot">&#13;
<thead>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table_th"><p class="table"><strong>Model</strong></p></td>&#13;
<td style="vertical-align: top;" class="table_th"><p class="table"><strong>Year</strong></p></td>&#13;
<td style="vertical-align: top;" class="table_th"><p class="table"><strong>Make</strong></p></td>&#13;
<td style="vertical-align: top;" class="table_th"><p class="table"><strong>Body</strong></p></td>&#13;
<td style="vertical-align: top;" class="table_th"><p class="table"><strong>Engine</strong></p></td>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table"><p class="table">Malibu</p></td>&#13;
<td style="vertical-align: top;" class="table"><p class="table">2006</p></td>&#13;
<td style="vertical-align: top;" class="table"><p class="table">Chevrolet</p></td>&#13;
<td style="vertical-align: top;" class="table"><p class="table">Sedan 4 Door</p></td>&#13;
<td style="vertical-align: top;" class="table"><p class="table">3.5L V6 OHV 12V</p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<p class="indent">If you were watching this UDS query via a normal CAN sniffer, you’d have seen several response packets on 0x7e8. You could re-assemble an ISO-TP packet by hand or with a simple script, but the ISO-TP tools make things much easier.</p>&#13;
<div class="note">&#13;
<p class="notet"><strong><span class="bgblack">NOTE</span></strong></p>&#13;
<p class="notep"><em>If you have difficulty running the ISO-TP tools, make sure you have the proper kernel module compiled and installed (see “<a href="ch03.html#ch03lev2sec5">Installing Additional Kernel Modules</a>” on <a href="ch03.html#page_42">page 42</a>).</em></p>&#13;
</div>&#13;
<h4 class="h4" id="ch04lev2sec5"><strong><em>Understanding Modes and PIDs</em></strong></h4>&#13;
<p class="noindent">The first byte of the data section in a diagnostic code is the mode. In automotive manuals, modes start with a $, as in $1. The $ is used to state that the number is in hex. The mode $1 is the same as 0x01, $0A is the same as 0x0A, and so on. I’ve listed a few examples here, and there are more in <a href="app02.html#app02">Appendix B</a> for reference.</p>&#13;
<p class="term"><span epub:type="pagebreak" id="page_58"/><strong>0x01: Shows current data</strong></p>&#13;
<p class="termlist">Shows data streams of a given PID. Sending a PID of 0x00 returns 4 bytes of bit-encoded available PIDs (0x01 through 0x20).</p>&#13;
<p class="term"><strong>0x02: Shows freeze frame data</strong></p>&#13;
<p class="termlist">Has the same PID values as 0x01, except that the data returned is from the freeze frame state.</p>&#13;
<p class="term"><strong>0x03: Shows stored “confirmed” diagnostic trouble codes</strong></p>&#13;
<p class="termlist">Matches the DTCs mentioned in “<a href="ch04.html#ch04lev2sec1">DTC Format</a>” on <a href="ch04.html#page_52">page 52</a>.</p>&#13;
<p class="term"><strong>0x04: Erases DTCs and clears diagnostic history</strong></p>&#13;
<p class="termlist">Clears the DTC and freeze frame data.</p>&#13;
<p class="term"><strong>0x07: Shows “pending” diagnostic codes</strong></p>&#13;
<p class="termlist">Displays codes that have shown up once but that haven’t been confirmed; status pending.</p>&#13;
<p class="term"><strong>0x08: Controls operations of onboard component/system</strong></p>&#13;
<p class="termlist">Allows a technician to activate and deactivate the system actuators manually. System actuators allow drive-by-wire operations and physically control different devices. These codes aren’t standard, so a common scan tool won’t be able to do much with this mode. Dealership scan tools have a lot more access to vehicle internals and are an interesting target for hackers to reverse engineer.</p>&#13;
<p class="term"><strong>0x09: Requests vehicle information</strong></p>&#13;
<p class="termlist">Several pieces of data can be pulled with mode 0x09.</p>&#13;
<p class="term"><strong>0x0a: Permanent diagnostic codes</strong></p>&#13;
<p class="termlist">This mode pulls DTCs that have been erased via mode 0x04. These DTCs are cleared only once the PCM has verified the fault condition is no longer present (see “<a href="ch04.html#ch04lev2sec3">Erasing DTCs</a>” on <a href="ch04.html#page_54">page 54</a>).</p>&#13;
<h4 class="h4" id="ch04lev2sec6"><strong><em>Brute-Forcing Diagnostic Modes</em></strong></h4>&#13;
<p class="noindent">Each manufacturer has its own proprietary modes and PIDs, which you can usually get by digging through “acquired” dealer software or by using tools or brute force. The easiest way to do brute force is to use an open source tool called the <em>CaringCaribou (CC)</em>, available at <em><a href="https://github.com/CaringCaribou/caringcaribou">https://github.com/CaringCaribou/caringcaribou</a>.</em></p>&#13;
<p class="indent">CaringCaribou consists of a collection of Python modules designed to work with SocketCAN. One such module is a DCM module that deals specifically with discovering diagnostic services.</p>&#13;
<p class="indent">To get started with CaringCaribou, create an RC file in your home directory, <em>~/.canrc.</em></p>&#13;
<p class="programs"><span epub:type="pagebreak" id="page_59"/><br/>[default]<br/>interface = socketcan_ctypes<br/>channel = can0</p>&#13;
<p class="indent">Set your channel to that of your SocketCAN device. Now, to discover what diagnostics your vehicle supports, run the following:</p>&#13;
<p class="programs">$ <span class="codestrong">./cc.py dcm discovery</span></p>&#13;
<p class="indent">This will send the tester-present code to every arbitration ID. Once the tool sees a valid response (0x40+service) or an error (0x7f), it’ll print the arbitration ID and the reply ID. Here is an example discovery session using CaringCaribou:</p>&#13;
<p class="programs">-------------------<br/>CARING CARIBOU v0.1<br/>-------------------<br/><br/>Loaded module 'dcm'<br/><br/>Starting diagnostics service discovery<br/>Sending diagnostics Tester Present to 0x0244<br/>Found diagnostics at arbitration ID 0x0244, reply at 0x0644</p>&#13;
<p class="indent">We see that there’s a diagnostic service responding to 0x0244. Great! Next, we probe the different services on 0x0244:</p>&#13;
<p class="programs">$ <span class="codestrong">./cc.py dcm services 0x0244 0x0644</span><br/><br/>-------------------<br/>CARING CARIBOU v0.1<br/>-------------------<br/><br/>Loaded module 'dcm'<br/><br/>Starting DCM service discovery<br/>Probing service 0xff (16 found)<br/>Done!<br/><br/>Supported service 0x00: Unknown service<br/>Supported service 0x10: DIAGNOSTIC_SESSION_CONTROL<br/>Supported service 0x1a: Unknown service<br/>Supported service 0x00: Unknown service<br/>Supported service 0x23: READ_MEMORY_BY_ADDRESS<br/>Supported service 0x27: SECURITY_ACCESS<br/>Supported service 0x00: Unknown service<br/>Supported service 0x34: REQUEST_DOWNLOAD<br/>Supported service 0x3b: Unknown service<br/>Supported service 0x00: Unknown service<br/>Supported service 0x00: Unknown service<br/>Supported service 0x00: Unknown service<br/>Supported service 0xa5: Unknown service<br/>Supported service 0xa9: Unknown service<br/>Supported service 0xaa: Unknown service<br/>Supported service 0xae: Unknown service</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_60"/>Notice that the output lists several duplicate services for service 0x00. This is often caused by an error response for something that’s not a UDS service. For instance, the requests below 0x0A are legacy modes that don’t respond to the official UDS protocol.</p>&#13;
<div class="note">&#13;
<p class="notet"><strong><span class="bgblack">NOTE</span></strong></p>&#13;
<p class="notep"><em>As of this writing, CaringCaribou is in its early stages of development, and your results may vary. The current version available doesn’t account for older modes and parses the response incorrectly, which is why you see several services with ID 0x00. For now, just ignore those services; they’re false positives. CaringCaribou’s discovery option stops at the first arbitration ID that responds to a diagnostic session control (DSC) request. Restart the scan from where it left off using the</em> <span class="literal"><span class="codeitalic">-min</span></span> <em>option, as follows:</em></p>&#13;
</div>&#13;
<p class="programs">$ <span class="codestrong">./cc.py dcm discovery -min 0x245</span></p>&#13;
<p class="indent">In our example, the scan will also stop scanning a bit later at this more common diagnostic ID:</p>&#13;
<p class="programs">Found diagnostics at arbitration ID 0x07df, reply at 0x07e8</p>&#13;
<h4 class="h4" id="ch04lev2sec7"><strong><em>Keeping a Vehicle in a Diagnostic State</em></strong></h4>&#13;
<p class="noindent">When doing certain types of diagnostic operations, it’s important to keep the vehicle in a diagnostic state because it’ll be less likely to be interrupted, thereby allowing you to perform actions that can take several minutes. In order to keep the vehicle in this state, you need to continuously send a packet to let the vehicle know that a diagnostic technician is present.</p>&#13;
<p class="indent">These simple scripts will keep the car in a diagnostic state that’ll prove useful for flashing ROMs or brute-forcing. The tester present packet keeps the car in a diagnostic state. It works as a heartbeat, so you’ll need to transmit it every one to two seconds, as shown here:</p>&#13;
<p class="programs">#!/bin/sh<br/>while :<br/>do<br/>    cansend can0 7df#013e<br/>    sleep 1<br/>done</p>&#13;
<p class="indent">You can do the same things with <span class="literal">cangen</span>:</p>&#13;
<p class="programs">$ <span class="codestrong">cangen -g 1000 -I 7DF -D 013E -L 2 can0</span></p>&#13;
<div class="note"><span epub:type="pagebreak" id="page_61"/>&#13;
<p class="notet"><strong><span class="bgblack">NOTE</span></strong></p>&#13;
<p class="notep"><em>As of this writing,</em> <span class="literal"><span class="codeitalic">cangen</span></span> <em>doesn’t always work on serial-line CAN devices. One possible workaround is to tell</em> <span class="literal"><span class="codeitalic">slcand</span></span> <em>to use canX style names instead of slcanX.</em></p>&#13;
</div>&#13;
<p class="indent">Use the <span class="literal">ReadDataByID</span> command to read data by ID and to query devices for information. 0x01 is the standard query. The enhanced version, 0x22, can return information not available with standard OBD tools.</p>&#13;
<p class="indent">Use the <span class="literal">SecurityAccess</span> command (0x27) to access protected information. This can be a rolling key, meaning that the password or key changes each time, but the important thing is that the controller responds if successful. For example, if you send the key 0x1, and it’s the correct access code, then you should receive an 0x2 in return. Some actions, such as flashing ROMs, will require you to send a <span class="literal">SecurityAccess</span> request. If you don’t have the algorithm to generate the necessary challenge response, then you’ll need to brute-force the key.</p>&#13;
<h3 class="h3" id="ch04lev1sec3"><strong>Event Data Recorder Logging</strong></h3>&#13;
<p class="noindentb">You likely know that airplanes have black boxes that record information about flights as well as conversations in the cockpit and over radio transmissions. All 2015 and newer vehicles are also required to have a type of black box, known as an <em>event data recorder (EDR)</em>, but EDRs record only a portion of the information that a black box on an airplane would. The information stored on the EDR includes the following (you’ll find a more complete list in SAE J1698-2):</p>&#13;
<p class="bull">• Airbag deployment</p>&#13;
<p class="bull">• Brake status</p>&#13;
<p class="bull">• Delta-v (longitudinal change in velocity)</p>&#13;
<p class="bull">• Ignition cycles</p>&#13;
<p class="bull">• Seat belt status</p>&#13;
<p class="bull">• Steering angles</p>&#13;
<p class="bull">• Throttle position</p>&#13;
<p class="bull">• Vehicle speed</p>&#13;
<p class="indentt">While this data is very similar to freeze frame data, its purpose is to collect and store information during a crash. The EDR constantly stores information, typically only about 20 seconds worth at any one time. This information was originally stored in a vehicle’s airbag control module (ACM), but today’s vehicles distribute this data among the vehicle’s ECUs. These boxes collect data from other ECUs and sensors and store them for recovery after a crash. <a href="ch04.html#ch4fig1">Figure 4-1</a> shows a typical EDR.</p>&#13;
<div class="image"><span epub:type="pagebreak" id="page_62"/><img src="graphics/f04-01.jpg" alt="image"/></div>&#13;
<p class="figcap"><a id="ch4fig1"/><em>Figure 4-1: A typical event data recorder</em></p>&#13;
<h4 class="h4" id="ch04lev2sec8"><strong><em>Reading Data from the EDR</em></strong></h4>&#13;
<p class="noindent">The official way to read data from an EDR is with a crash data retrieval (CDR) tool kit. A basic CDR tool will connect to the OBD connector and pull data (or image the vehicle) from the main ECU. CDR tools can also access data in other modules, such as the ACM or the rollover sensor (ROS) module, but they’ll normally need to be plugged in directly to those devices instead of using the OBD port. (You’ll find a comprehensive list of which vehicles have black box data that can be retrieved here: <em><a href="http://www.crashdatagroup.com/research/vehiclecoverage.html">http://www.crashdatagroup.com/research/vehiclecoverage.html</a></em>.)</p>&#13;
<p class="indent">CDR kits include both proprietary hardware and software. The hardware usually costs about $2,000, and the cost of the software will vary depending on how many vehicle types you want to support. The format of vehicle crash data is often considered proprietary as well, and many manufacturers license the communication protocol to tool providers that make CDRs. Obviously, this is not in the best interest of the consumer. The National Highway Traffic Safety Administration (NHTSA) has proposed the adoption of a standard OBD communication method to access this data.</p>&#13;
<h4 class="h4" id="ch04lev2sec9"><span epub:type="pagebreak" id="page_63"/><strong><em>The SAE J1698 Standard</em></strong></h4>&#13;
<p class="noindent">The SAE J1698 standard lists recommended practices for event data collection and defines event records by sample rate: high, low, and static. High samples are data recorded at the crash event, low samples are pre-crash data, and static samples are data that doesn’t change. Many vehicles are influenced by the SAE J1698 but don’t necessarily conform to its rules for all data retrieved from a vehicle.</p>&#13;
<p class="indentb">Some recorded elements are:</p>&#13;
<p class="bull">• Cruise control status</p>&#13;
<p class="bull">• Driver controls: parking brake, headlight, front wiper, gear selection, passenger airbag disabled switch</p>&#13;
<p class="bull">• Foremost seat track position</p>&#13;
<p class="bull">• Hours in operation</p>&#13;
<p class="bull">• Indicator status lights: VEDI, SRS, PAD, TPMS, ENG, DOOR, IOD</p>&#13;
<p class="bull">• Latitude and longitude</p>&#13;
<p class="bull">• Seating position</p>&#13;
<p class="bull">• SRS deployment status/time</p>&#13;
<p class="bull">• Temperature air/cabin</p>&#13;
<p class="bull">• Vehicle mileage</p>&#13;
<p class="bull">• VIN</p>&#13;
<p class="indentt">While the SAE J1698 states latitude and longitude recordings, many manufacturers claim not to record this information for privacy reasons. Your research may vary.</p>&#13;
<h4 class="h4" id="ch04lev2sec10"><strong><em>Other Data Retrieval Practices</em></strong></h4>&#13;
<p class="noindent">Not all manufacturers conform the to SAE J1698 standard. For example, since the 1990s, General Motors has collected a small amount of EDR data in the sensing and diagnostic module (SDM) of its vehicles. The SDM stores the vehicle’s Delta-v, which is the longitudinal change in the vehicle’s velocity. The SDM does not record any post-crash information.</p>&#13;
<p class="indent">Another example is Ford’s EDR, known as the <em>restraint control module (RCM)</em>. Ford stores a vehicle’s longitudinal and lateral acceleration data rather than Delta-v. If the vehicle has electronic throttle control, the PCM stores additional EDR data, including whether the passenger was an adult or not, the percent the accelerator/brake pedal was depressed, and whether a diagnostic code was active when the crash occurred.</p>&#13;
<h3 class="h3" id="ch04lev1sec4"><span epub:type="pagebreak" id="page_64"/><strong>Automated Crash Notification Systems</strong></h3>&#13;
<p class="noindentb"><em>Automated crash notification (ACN) systems</em> are the phone-home systems that contact a vehicle’s manufacturer or a third party with event information. These coincide with other crash recovery systems and extend the functionality by contacting the manufacturer or third party. One major difference is that there aren’t rules or standards that determine what data is collected and sent to an ACN. ACNs are specific to each manufacturer, and each system will send different information. For example, the Veridian automated collision notification system (released in 2001) reports this information:</p>&#13;
<p class="bull">• Crash type (frontal, side, rear)</p>&#13;
<p class="bull">• Date and time</p>&#13;
<p class="bull">• Delta-v</p>&#13;
<p class="bull">• Longitude and latitude</p>&#13;
<p class="bull">• Make, model, and year of vehicle</p>&#13;
<p class="bull">• Principal direction of force</p>&#13;
<p class="bull">• Probable number of occupants</p>&#13;
<p class="bull">• Rollover (yes or no)</p>&#13;
<p class="bull">• Seat belt use</p>&#13;
<p class="bull">• Vehicle’s final resting position (normal, left side, right side, roof)</p>&#13;
<h3 class="h3" id="ch04lev1sec5"><strong>Malicious Intent</strong></h3>&#13;
<p class="noindent">Attackers may target a vehicle’s DTCs and freeze frame data to hide malicious activity. For example, if an exploit needs to take advantage of only a brief, temporary condition in order to succeed, a vehicle’s freeze frame data will most likely miss the event due to delays in recording. Captured freeze frame snapshots rarely contain information that would help determine whether the DTC was triggered by malicious intent. (Because black box EDR systems typically trigger only during a crash, it’s unlikely that an attacker would target them because they’re not likely to contain useful data.)</p>&#13;
<p class="indent">An attacker fuzzing a vehicle’s system might check for fired DTCs and use the information contained in a DTC to determine which component was affected. This type of attack would most likely occur during the research phase of an attack (when an attacker is trying to determine what components the randomly generated packets were affecting), not during an active exploit.</p>&#13;
<p class="indent">Accessing and fuzzing manufacturer-specific PIDs—by flashing firmware or using mode 0x08—can lead to interesting results. Because each manufacturer interface is kept secret, it’s difficult to assess the actual risk of the network. Unfortunately, security professionals will need to reverse or fuzz these proprietary interfaces to determine what is exposed before work can be done to determine whether there are vulnerabilities. Malicious actors will need to do the same thing, although they won’t be motivated to share their findings. If they can keep undocumented entry points <span epub:type="pagebreak" id="page_65"/>and weaknesses a secret, then their exploit will last longer without being detected. Having secret interfaces into the vehicle doesn’t increase security; the vulnerabilities are there regardless of whether people are allowed to discuss them. Because there’s money in selling these codes (sometimes upward of $50,000), the industry has little incentive to embrace the community.</p>&#13;
<h3 class="h3" id="ch04lev1sec6"><strong>Summary</strong></h3>&#13;
<p class="noindent">In this chapter, you have gone beyond traditional CAN packets to understand more complex protocols such as ISO-TP. You have learned how CAN packets can be linked together to write larger messages or to create two-directional communications over CAN. You also learned how to read and clear any DTCs. You looked at how to find undocumented diagnostic services and saw what types of data are recorded about you and your driving habits. You also explored some ways in which diagnostic services can be used by malicious parties.<span epub:type="pagebreak" id="page_66"/></p>&#13;
</body></html>