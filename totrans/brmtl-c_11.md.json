["```\n// Block until the transmit empty (TXE) flag is set.\nwhile ((uartHandle.Instance->ISR & UART_FLAG_TXE) == 0)\n    continue;\n```", "```\nif (diskInterrupt)      { handleDiskInterrupt(); return;}\nif (serialInterrupt)    { handleSerialInterrupt(); return;}\nif (keyboardInterrupt)  { handleKeyboardInterrupt(); return;}\nif (mouseInterrupt)     { handleMouseInterrupt(); return;}\nlogUnknownInterrupt();\n```", "```\ng_pfnVectors:\n  .word  _estack\n  .word  Reset_Handler\n  .word  NMI_Handler\n  .word  HardFault_Handler\n# Many more handlers\n  .word  USART1_IRQHandler              /* USART1 */\n  .word  USART2_IRQHandler              /* USART2 */\n```", "```\n .weak      USART2_IRQHandler\n  .thumb_set USART2_IRQHandler,Default_Handler\n```", "```\n .section .text.Default_Handler,\"ax\",%progbits\nDefault_Handler:\nInfinite_Loop:\n  b Infinite_Loop\n```", "```\nconst char* volatile usart2String = NULL;     // The string we are sending\n```", "```\n/**\n  * @brief   Write Hello World to the serial I/O.\n  * Use interrupts instead of polling.\n*/\n\n#include <stdbool.h>\n#include \"stm32f0xx_nucleo.h\"\n#include \"stm32f0xx.h\"\n\nconst char hello[] = \"Hello World!\\r\\n\";   // The message to send\nint current; // The character in the message we are sending\n\nUART_HandleTypeDef uartHandle;      // UART initialization\n\n`... Error_Handler same as Listing 9-3 ...`\n\nconst char* volatile usart2String = NULL;       // The string we are sending\n/**\n * Handle the USART2 interrupt.\n *\n * Magically called by the chip's interrupt system.\n * Name is fixed because of the startup code that\n * populates the interrupt vector.\n */\nvoid USART2_IRQHandler(void)\n{\n    if ((uartHandle.Instance->ISR & USART_ISR_TXE) != 0) {\n        // This should never happen, but we don't want to crash if it does.\n        if (usart2String == NULL) {\n            // Turn off interrupt.\n            uartHandle.Instance->CR1 &= ~(USART_CR1_TXEIE);\n            return;\n        }\n        if (*usart2String == '\\0') {\n            usart2String = NULL;        // We're done with the string.\n            // Turn off interrupt.\n            uartHandle.Instance->CR1 &= ~(USART_CR1_TXEIE);\n            return;\n        }\n        uartHandle.Instance->TDR = *usart2String; // Send character to the UART.\n        ++usart2String;              // Point to next character.\n        return;\n    }\n    // Since the only interrupt we enabled was TXE, we should never\n    // get here. When we do enable other interrupts, we need to put\n    // code to handle them here.\n}\n/**\n * Our version of puts\n *\n * Outputs the exact string given to the output\n *\n * @param str String to send\n *\n * @note Assumes that str is not null and not\n * pointing to the empty string\n */\nvoid myPuts(const char* str)\n{\n    // If someone is sending a string, wait for it.\n    while (usart2String != NULL)\n        continue;\n\n    // Tell the interrupt route what string to use.\n    usart2String = str;\n\n    uartHandle.Instance->TDR = *usart2String;  // Send character to the UART.\n    ++usart2String;             // Point to next character.\n    // Enable the interrupt.\n    uartHandle.Instance->CR1 |= USART_CR1_TXEIE;\n}\n\n`... led2_Init and uart2_Init, same as Listing 9-3 ...`\n\nint main(void)\n{\n    HAL_Init(); // Initialize hardware.\n    led2_Init();\n    uart2_Init();\n    // Tell the chip that we want the interrupt vector\n    // for USART2 to be enabled.\n    NVIC_EnableIRQ(USART2_IRQn);\n\n    // Keep sending the message for a long time.\n    for (;;) {\n        myPuts(hello);\n        HAL_Delay(500);\n    }\n}\n\n`... HAL_UART_MspInit and HAL_UART_MspDeInit, same as Listing 9-3 ...`\n```", "```\nint main(void)\n{\n    HAL_Init(); // Initialize hardware\n    led2_Init();\n    uart2_Init();\n    // Tell the chip that we want the interrupt vector\n    // for USART2 to be enabled.\n    NVIC_EnableIRQ(USART2_IRQn);\n```", "```\nvoid myPuts(const char* str)\n{\n    // If someone is sending a string, wait for it.\n  1 while (usart2String != NULL)\n        continue;\n\n    // Tell the interrupt route what string to use.\n  2 usart2String = str;\n\n  3 uartHandle.Instance->TDR = *usart2String;  // Send character to the UART.\n    ++usart2String;             // Point to next character.\n    // Enable the interrupt.\n  4 uartHandle.Instance->CR1 |= USART_CR1_TXEIE;\n}\n```", "```\n1 void USART2_IRQHandler(void)\n{\n  2 if ((uartHandle.Instance->ISR & USART_ISR_TXE) != 0) {\n        // This should never happen, but we don't want to crash if it does.\n      3 if (usart2String == NULL) {\n // Turn off interrupt.\n            uartHandle.Instance->CR1 &= ~(USART_CR1_TXEIE);\n            return;\n        }\n      4 if (*usart2String == '\\0') {\n            usart2String = NULL;        // We're done with the string.\n            // Turn off interrupt.\n            uartHandle.Instance->CR1 &= ~(USART_CR1_TXEIE);\n            return;\n        }\n      5 uartHandle.Instance->TDR = *usart2String; // Send character to the UART.\n      6 ++usart2String;         // Point to next character.\n        return;\n    }\n    // Since the only interrupt we enabled was TXE, we should never\n    // get here. When we do enable other interrupts, we need to put\n    // code to handle them here.\n}\n```", "```\ni = 5;\nif (i == 5) {\n```", "```\ni = 5;\n←----- interrupt triggers, i set to 6.\nif (i == 5) { // No longer true\n```", "```\nmyPuts(\"There are \");\nif (messageCount == 0)\n   myPuts(\" no \");              // Blocks waiting on previous message\nelse\n   myPuts(\" some \");            // Blocks waiting on previous message\nmyPuts(\"messages waiting\\r\\n\"); // Blocks waiting on previous message\n```", "```\nstruct circularBuffer {\n    uint32_t putIndex;      // Where we will put the next character\n    uint32_t getIndex;      // Where to get the next character\n    uint32_t nCharacters;   // Number of characters in the buffer\n    char data[BUFFER_SIZE]; // The data in the buffer\n}\n```", "```\nIf the buffer is full, wait.\nPut a character in the buffer at putIndex.\nMove putIndex up one, wrapping if needed.\nIncrement the number of characters in the buffer.\n```", "```\nGet a character from the buffer at getIndex.\nIncrement getIndex, wrapping as needed.\nDecrement the number of characters in the buffer.\n```", "```\nvoid myPutchar(const char ch)\n{\n    // Wait until there is room.\n  1 while (buffer.nCharacters == BUFFER_SIZE)\n        continue;\n  2 buffer.data[buffer.putIndex] = ch;\n  3 ++buffer.putIndex;\n    if (buffer.putIndex == BUFFER_SIZE)\n        buffer.putIndex = 0;\n\n    // We've added another character.\n  4 ++buffer.nCharacters;\n    // Now we're done.\n\n    // Enable the interrupt (or reenable it).\n  5 uartHandle.Instance->CR1 |= USART_CR1_TXEIE;\n}\n```", "```\nvoid USART2_IRQHandler(void)\n{\n  1 if ((uartHandle.Instance->ISR & USART_ISR_TXE) != 0) {\n        if (buffer.nCharacters == 0) {\n            // Turn off interrupt.\n            uartHandle.Instance->CR1 &= ~(USART_CR1_TXEIE);\n            return;\n        }\n      2 // Send to UART.\n        uartHandle.Instance->TDR = buffer.data[buffer.getIndex];\n      3 ++buffer.getIndex;\n        if (buffer.getIndex == BUFFER_SIZE)\n            buffer.getIndex = 0;\n\n      4 --buffer.nCharacters;\n\n      5 if (buffer.nCharacters == 0)\n            uartHandle.Instance->CR1 &= ~(USART_CR1_TXEIE);\n        return;\n    }\n    // Since the only interrupt we enabled was TXE, we should\n    // never get here. When we do enable other interrupts,\n    // we need to put the code to handle them here.\n}\n```", "```\n/**\n  * @brief   Write Hello World to the serial I/O\n  * using a circular buffer.\n  *\n  * @note Contains a race condition to demonstrate\n  * how not do do this program\n  */\n\n#include <stdbool.h>\n#include \"stm32f0xx_nucleo.h\"\n#include \"stm32f0xx.h\"\n\nconst char hello[] = \"Hello World!\\r\\n\";   // The message to send\nint current; // The character in the message we are sending\n\nUART_HandleTypeDef uartHandle;      // UART initialization\n\n#define BUFFER_SIZE 8   // The data buffer size\n\nstruct circularBuffer {\n    uint32_t putIndex;      // Where we will put the next character\n    uint32_t getIndex;      // Where to get the next character\n    uint32_t nCharacters;   // Number of characters in the buffer\n    char data[BUFFER_SIZE]; // The data in the buffer\n};\n\n// A simple, classic circular buffer for USART2\nvolatile struct circularBuffer buffer = {0,0,0, {'\\0'}};\n\n`... Error_Handler from Listing 9-3` `...`\n\n/**\n * Handle the USART2 interrupt.\n *\n * Magically called by the chip's interrupt system.\n * Name is fixed because of the startup code that\n * populates the interrupt vector.\n */\nvoid USART2_IRQHandler(void)\n{\n    if ((uartHandle.Instance->ISR & USART_ISR_TXE) != 0) {\n        if (buffer.nCharacters == 0) {\n            // Turn off interrupt.\n            uartHandle.Instance->CR1 &= ~(USART_CR1_TXEIE);\n            return;\n        }\n        // Send to UART.\n        uartHandle.Instance->TDR = buffer.data[buffer.getIndex];\n        ++buffer.getIndex;\n        if (buffer.getIndex == BUFFER_SIZE)\n            buffer.getIndex = 0;\n\n        --buffer.nCharacters;\n\n        if (buffer.nCharacters == 0)\n            uartHandle.Instance->CR1 &= ~(USART_CR1_TXEIE);\n        return;\n    }\n    // Since the only interrupt we enabled was TXE, we should never\n    // get here. When we do enable other interrupts, we need to put\n    // code to handle them here.\n}\n\n/**\n * Put a character in the serial buffer.\n *\n * @param ch The character to send\n */\nvoid myPutchar(const char ch)\n{\n    // Wait until there is room.\n    while (buffer.nCharacters == BUFFER_SIZE)\n        continue;\n    buffer.data[buffer.putIndex] = ch;\n    ++buffer.putIndex;\n    if (buffer.putIndex == BUFFER_SIZE)\n        buffer.putIndex = 0;\n\n    // We've added another character.\n    ++buffer.nCharacters;\n    // Now we're done.\n\n    // Enable the interrupt (or reenable it).\n    uartHandle.Instance->CR1 |= USART_CR1_TXEIE;\n}\n\n/**\n * Our version of puts\n *\n * Outputs the exact string given to the output\n *\n * @param str String to send\n *\n * @note Assumes that str is not null\n */\nvoid myPuts(const char* str)\n{\n    for (/* str set */; *str != '\\0'; ++str)\n        myPutchar(*str);\n}\n\n`... led2_init and uart2_init same as Listing 9-3 ...`\n\nint main(void)\n{\n    HAL_Init(); // Initialize hardware.\n    led2_Init();\n    uart2_Init();\n    // Tell the chip that we want the interrupt vector\n    // for USART2 to be enabled.\n    NVIC_EnableIRQ(USART2_IRQn);\n\n    // Keep sending the message for a long time.\n    for (;;) {\n        myPuts(hello);\n        HAL_Delay(500);\n    }\n}\n\n`... HAL_UART_MspInit and HAL_UART_MspDeInit same as Listing 9-3 ...`\n```", "```\nHello World!\nHello World!\nHello World!\n```", "```\nHello World!\nello World!\nHello Wold!\nHello World!\n```", "```\nnCharacters == 0\ngetIndex != putIndex\n```", "```\n#define N_EVENTS 100                   // Store 100 events.\nuint32_t nextEvent = 0;                // Where to put the next event\nstruct logEvent debugEvents[N_EVENTS]; // The log data\n\nvoid debugEvent(const uint32_t line)\n{\n    debugEvents[nextEvent].line = line;\n    debugEvents[nextEvent].putIndex = buffer.putIndex;\n    debugEvents[nextEvent].getIndex = buffer.getIndex;\n    debugEvents[nextEvent].nCharacters = buffer.nCharacters;\n    ++nextEvent;\n    if (nextEvent == N_NEVETS)\n        nextEvent = 0;\n}\n```", "```\nvoid USART2_IRQHandler(void)\n*--snip--*\n      debugEvent(__LINE__);\n      --buffer.nCharacters;\n      debugEvent(__LINE__);\n\nvoid myPutchar(const char ch)\n*--snip--*\n      debugEvent(__LINE__);\n      ++buffer.nCharacters;\n      debugEvent(__LINE__);\n```", "```\nvoid myPutchar(const char ch)\n{\n    if ((buffer.nCharacters == 0) && (buffer.getIndex != buffer.putIndex))\n        Error_Handler();\n```", "```\n77 void USART2_IRQHandler(void)\n*--snip--*\n89      debugEvent(__LINE__);\n90      --buffer.nCharacters;\n91      debugEvent(__LINE__);\n```", "```\n106 void myPutchar(const char ch)\n*--snip--*\n119     debugEvent(__LINE__);\n120     ++buffer.nCharacters;\n121     debugEvent(__LINE__);\n```", "```\nstruct circularBuffer {\n    uint32_t putIndex;      // Where we will put the next character\n    uint32_t getIndex;      // Where to get the next character\n    uint32_t nCharacters;   // Number of characters in the buffer\n    char data[BUFFER_SIZE]; // The data in the buffer\n};\n```", "```\n--buffer.nCharacters;\n```", "```\n++buffer.nCharacters;\n```", "```\n++buffer.nCharacters;\n```", "```\n120:../src/main.c ***  ++buffer.nCharacters;\n404               loc 2 118 0\n405 005c 094B     ldr  r3, .L22     ; Load r3 with the address in .L22,\n                                    ; which happens to be \"buffer\".\n406 005e 9B68     ldr  r3, [r3, #8] ; Get the value of  \n                                    ; buffer.nCharacters.\n407 0060 5A1C   1 adds r2, r3, #1   ; Add 1 to r3 and store the result in r2.\n408 0062 084B     ldr  r3, .L22     ; Get the address again.\n409 0064 9A60     str  r2, [r3, #8] ; Store buffer.nCharacters.\n```", "```\n119      __disable_irq();\n120      ++buffer.nCharacters;\n121      __enable_irq();\n```"]