- en: '11'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Graphics
  prefs: []
  type: TYPE_NORMAL
- en: '![g11001](image_fi/502680c11/g11001.png)'
  prefs: []
  type: TYPE_IMG
- en: When people on the Android team say “graphics,” they may mean vastly different
    things, because there are many layers of graphics functionality that are implemented
    by very distinct teams for very different reasons. For example, there are 3D graphics
    systems using OpenGL ES,^([1](#c11-footnote-1)) and more recently, Vulkan, for
    supporting anything from games to mapping applications to Virtual Reality to Augmented
    Reality. There are graphics capabilities in the UI toolkit, which is responsible
    for drawing things like text, shapes, lines, and images, so that application developers
    can populate their user interfaces with, well, graphics. And then there is the
    lowest level of graphics on the system which provides the fundamental capability
    for pixels and windows to appear on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: We’ll start with this lowest level of graphics, which came about through the
    work of Mathias Agopian, another hire from Be and PalmSource, who started on the
    Android team in late 2006.
  prefs: []
  type: TYPE_NORMAL
- en: '![](image_fi/502680c11/f11001.png)'
  prefs: []
  type: TYPE_IMG
- en: 'A vastly simplified view of Android’s graphics system. Applications call into
    the Canvas API to draw things. The Canvas API is implemented underneath by the
    Skia rendering engine, which turns things like shapes and text into pixels. SurfaceFlinger
    provides a buffer, or surface, into which these pixels are drawn. SurfaceFlinger
    calls into OpenGL ES, a low-level graphics API that renders triangles. OpenGL
    ES uses PixelFlinger to draw the buffer: Note that PixelFlinger was eventually
    replaced by a GPU (Graphics Processing Unit) when GPUs became standard in smartphones.
    Finally, all of the surfaces that need to be drawn onto the screen (including
    the foreground application as well as the status and navigation bars) are composed
    together in the Hardware Composer and then displayed on the screen for the user
    to see.'
  prefs: []
  type: TYPE_NORMAL
- en: Mathias Agopian and Android Graphics
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Software rendering, in my opinion, was going to die.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: —Mathias Agopian
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Mathias is a calm and quiet person who arrives at the office late, stays very
    late, and focuses almost exclusively on coding (avoiding email and meetings as
    much as possible).
  prefs: []
  type: TYPE_NORMAL
- en: In the early days, Mathias had a temper^([2](#c11-footnote-2)) that would occasionally
    surface. Something would upset him and he would storm out, sometimes staying away
    for several days or even weeks. In one episode, Mathias was upset at Brian Swetland.
    He threw his phone and marched out of the office, only to return a few minutes
    later to ask for his phone back, since he needed its memory card.^([3](#c11-footnote-3))
  prefs: []
  type: TYPE_NORMAL
- en: Mathias spent his childhood learning how to program various computers, from
    the Armstrad CPC to several Atari computers, to the BeBox. He wrote graphics and
    audio applications for his Atari Falcon (including a sound tracker app for the
    Falcon which he sold under the name Crazy Music Machine^([4](#c11-footnote-4)))
    and he became known^([5](#c11-footnote-5)) for programming articles that he wrote
    for French computer magazines. He also, as a hobby, wrote Epson printer drivers
    for the Atari and the BeBox, which those companies shipped with their systems.
    His work on the Be printer drivers resulted in a job; he left France to join Be
    in 1999.
  prefs: []
  type: TYPE_NORMAL
- en: Mathias stayed at Be until they were acquired by Palm and continued on with
    the rest of the team at PalmSource, working mostly on graphics software, until
    he decided he’d had enough of wherever PalmSource was going. He left around the
    same time as Joe Onorato and joined Google to work on Android in late 2005.
  prefs: []
  type: TYPE_NORMAL
- en: The Basics
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When Mathias joined Android, he started on system fundamentals. The operating
    system essentially didn’t exist yet, so everyone who joined at that time helped
    out with building basic necessities.
  prefs: []
  type: TYPE_NORMAL
- en: For example, the platform didn’t yet have core data structures for C++ (Vector
    and HashMap). In a desktop or server world, these pieces wouldn’t have been needed,
    because they come with standard libraries that developers typically use. But on
    Android, especially at that time, the platform only included code and libraries
    that were absolutely necessary. Adding standard libraries would have pulled in
    too many unnecessary pieces, taking up storage space that simply wasn’t available.
    So Mathias wrote versions of these data structures that everyone could use for
    Android development.
  prefs: []
  type: TYPE_NORMAL
- en: Mathias also worked on optimizing memcpy^([6](#c11-footnote-6)) and memset,
    low-level utilities for manipulating chunks of memory. Memcpy is a critical piece
    of software used by the entire system,^([7](#c11-footnote-7)) and is often a performance
    bottleneck in memory-intensive situations. Bob Lee commented on this work, “He
    hand-wrote this assembly language for memcpy, made it insanely fast and had a
    huge performance improvement. It was brilliant.”
  prefs: []
  type: TYPE_NORMAL
- en: PixelFlinger^([8](#c11-footnote-8))
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Mathias’s main goal for the graphics system was to implement something he called
    SurfaceFlinger, which was needed to display the buffers (*surfaces*) full of graphics
    that were produced by all of the applications on the system. But this system depended
    on lower-level functionality that did not yet exist, so he started there instead.
  prefs: []
  type: TYPE_NORMAL
- en: One of Mathias’s assumptions was that SurfaceFlinger would need a GPU^([9](#c11-footnote-9))
    to do its work; it would use OpenGL ES to perform the low-level operations required
    to get the graphics data from the application into buffers, and then to display
    those buffers onto the screen. The problem was, Android wasn’t running on a device
    with a GPU. The device that Android was targeting at that time, and all the way
    through the launch of the SDK, was Sooner, which had no GPU and therefore no OpenGL
    ES.
  prefs: []
  type: TYPE_NORMAL
- en: But Mathias saw a future in which GPUs would be standard on smartphones. “Before
    joining Android, I had a little bit of experience with mobile platforms. And it
    was really, really obvious to me that in the future we would be rendering using
    hardware.^([10](#c11-footnote-10)) Software rendering, in my opinion, was going
    to die.
  prefs: []
  type: TYPE_NORMAL
- en: '“My idea was: I want everything to be ready for when we get hardware. The problem
    is, we don’t have hardware. We don’t really know when it’s going to happen. So
    I thought, I’m in charge of graphics, I’m going to pretend I have a GPU. So I
    wrote a GPU, essentially. This way, I was able to write SurfaceFlinger using ‘GL.’
    It was using real OpenGL ES, but it defaulted to software. And then, little by
    little, real hardware started to show up.”'
  prefs: []
  type: TYPE_NORMAL
- en: When Mathias said that he wrote a GPU, he meant that he wrote a *virtual* GPU;
    software that performed the same work as a GPU would, but in software instead
    of dedicated hardware. A GPU is not magical; the dedicated hardware in a GPU is
    not doing anything that cannot be done by software running on the CPU instead.
    It just does that job much faster, since it has hardware that is optimized for
    graphics operations.^([11](#c11-footnote-11)) In writing his fake GPU, Mathias
    provided a software layer to handle graphics operations normally handled by a
    GPU, translating those commands to low-level information that the existing Android
    display system could understand.
  prefs: []
  type: TYPE_NORMAL
- en: The OpenGL ES layer that he wrote issued commands to a lower layer that handled
    drawing textured triangles,^([12](#c11-footnote-12)) called PixelFlinger. This
    extra layer of abstraction of using OpenGL ES on top of PixelFlinger added work
    and overhead and wouldn’t have made sense if it were the only device Android was
    targeting. But in a world where Android was aiming at the future, and the future
    almost certainly included GPU hardware, this meant that SurfaceFlinger had to
    be written only once, to target OpenGL ES. As soon as the future matched Mathias’s
    vision and GPUs were available, it would continue working as-is, but faster (using
    hardware, instead of the software-based PixelFlinger).
  prefs: []
  type: TYPE_NORMAL
- en: Mathias’s approach of writing PixelFlinger’s virtual GPU was an example of the
    *product versus platform* approach that Android took in the early days.^([13](#c11-footnote-13))
    A *product* approach, where the team simply got the initial phone to work as quickly
    as possible, wouldn’t have taken as long. But the *platform* approach that Mathias
    took, building up layers of software that scaled way beyond that initial release,
    proved useful to Android in the long run. “It was necessary to go through that
    step to be ready for when the hardware was there. But also to convince people
    that that’s what needed to happen.”
  prefs: []
  type: TYPE_NORMAL
- en: This long-term approach to the graphics system, and other parts of the platform,
    was an element of the team’s approach in those early days. Overall, the team was
    very scrappy, preferring small, hard-working teams, and making quick, pragmatic
    decisions as they drove toward 1.0\. But several of the decisions that the team
    made early on, and the extra work those required, happened because they were the
    right thing for the future of the platform, even though that future wasn’t assured.
    So although the team was focused on the goal of shipping 1.0, they were trying
    to do so with a platform that would live beyond that single ship date, into the
    future that Android eventually achieved.
  prefs: []
  type: TYPE_NORMAL
- en: PixelFlinger had a limited shelf life in terms of Android phones. It was critical
    for the Sooner device that the team used during early development, but the G1
    that shipped with 1.0 already had the GPU capabilities^([14](#c11-footnote-14))
    that Mathias had wanted and predicted. The importance of PixelFlinger wasn’t in
    the capabilities that it provided for specific products, but in what it meant
    for the platform, to build in forward-looking capabilities that drove an architecture
    and ecosystem into a hardware-accelerated future.^([15](#c11-footnote-15))
  prefs: []
  type: TYPE_NORMAL
- en: SurfaceFlinger
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Once PixelFlinger and OpenGL ES were working, Mathias could implement SurfaceFlinger.
    Applications draw their graphics objects (buttons, text, images—whatever) into
    a buffer in memory and SurfaceFlinger posts that buffer to the screen, visible
    to the user. SurfaceFlinger was essentially the glue between the higher-level
    graphics operations happening in applications and the OpenGL ES layer that he
    had written previously, responsible for copying buffers around and displaying
    them to the user. The separation of app rendering from displaying the pixels on
    the screen was intentional; one of Mathias’s design goals was to enable smooth
    graphics by ensuring that no app could cause rendering performance problems for
    any other app (this was related to Android’s overall approach to security on the
    platform, where there was always a clear separation of applications from each
    other). So applications would draw into buffers, and SurfaceFlinger would take
    it from there.
  prefs: []
  type: TYPE_NORMAL
- en: Hardware Composer
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The other part of the graphics system that Mathias wrote was the Hardware Composer
    (HWC). SurfaceFlinger handles drawing UI graphics into a window on the screen.
    But there are several windows that need to be combined together to make up the
    final pixels on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: '![](image_fi/502680c11/f11002.png)'
  prefs: []
  type: TYPE_IMG
- en: A sample Android screen, showing the typical status bar, navigation bar, and
    home screen
  prefs: []
  type: TYPE_NORMAL
- en: Think about a typical Android screen that the user sees. There is a status bar
    (where the current time and various status and notification icons show up), a
    navigation bar (where the back and home buttons reside), and finally the actual
    foreground application (or the home screen). There may be other windows as well,
    like popup menus on top of the foreground application.
  prefs: []
  type: TYPE_NORMAL
- en: All of these are separate windows, often running in separate processes. For
    example, the navigation and status bars are managed by the system process, whereas
    the application window is owned by the application process. All of these windows
    need to be displayed together in some sensible way, which is the job of the Hardware
    Composer.
  prefs: []
  type: TYPE_NORMAL
- en: Mathias’s idea for HWC was to use specialized graphics hardware called hardware
    overlays,^([16](#c11-footnote-16)) which provide display memory dedicated to each
    application, avoiding the overhead of all applications sharing the same video
    memory. Using overlay hardware also saved power and provided higher performance
    for applications. By using dedicated overlay hardware, the system avoided using
    the power-hungry GPU for these simple and frequent windowing operations. Also,
    using overlays left the GPU available for use by applications,^([17](#c11-footnote-17))
    for accelerating games or other graphics-intensive operations.
  prefs: []
  type: TYPE_NORMAL
- en: Rather than drawing each of these windows manually on the screen, or telling
    the GPU to draw them through OpenGL ES, the HWC would send each of the windows
    to a different overlay. The display hardware would then compose these overlays
    together onto the screen to make it all look like one seamless screen of information,
    rather than the several completely different processes that they actually are.
  prefs: []
  type: TYPE_NORMAL
- en: The problem was that overlays were difficult to use in practice, since every
    device tended to have different numbers and capabilities of overlays. But given
    the GPU limitations of the G1, plus relatively good overlay support on that device,
    Mathias and Jason Sams came up with a novel approach. Instead of trying to handle
    the infinite variations of overlays directly in HWC, their software would tell
    the underlying hardware what HWC needed and either the hardware could support
    their requirements or HWC would back off to using OpenGL ES. Over time, hardware
    vendors saw the benefit of handling these overlay operations directly and it became
    an area for vendors to offer extra performance on their devices for this critical
    area of the platform.
  prefs: []
  type: TYPE_NORMAL
- en: Mike Reed and Skia
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'All of Mathias’s work was predicated on having something to display on the
    screen: graphics content from the applications. The system for applications to
    draw graphics content for their UIs also needed to be created. For that, Android
    used a rendering system called Skia that was acquired early on from Mike Reed.'
  prefs: []
  type: TYPE_NORMAL
- en: If “serial graphics entrepreneur” is a real thing, that’s what Mike Reed is.
  prefs: []
  type: TYPE_NORMAL
- en: Mike started programming late in life, at least compared to many of the early
    Android engineers. Mike got college degrees in science and math. But in 1984,
    the original Macintosh was released and showed up on his campus. “That changed
    everything. I wanted to do graphics, because that’s what the Mac was really showing
    off. So I got a math degree, but taught myself programming.”
  prefs: []
  type: TYPE_NORMAL
- en: Mike managed to get hired at Apple after grad school (“I just squeaked into
    that job”), where he met Cary Clark, future co-founder of Skia.^([18](#c11-footnote-18))
    After several years at Apple, Mike left and started HeadSpin, creating a game
    engine used by CD-ROM games. HeadSpin was acquired by Cyan, makers of the game
    *Myst*, and Mike left to start a new graphics technology company called AlphaMask.
    AlphaMask was acquired by Openwave, a company providing browser software for mobile
    devices.
  prefs: []
  type: TYPE_NORMAL
- en: 'Mike left Openwave in 2004 and started Skia with Cary, his former Apple colleague,
    where they created a graphics rendering engine. Skia licensed its engine to various
    clients, including several in California. For one of Mike’s trips to California,
    Cary suggested that Mike should meet with a startup called Android, which had
    been founded by a couple of Cary’s former colleagues at WebTV: Andy Rubin and
    Chris White.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In late 2004, Android was quite small, with only the two co-founders plus new
    employees Brian Swetland and Tracey Cole. Android was in the midst of a pivot
    from building a camera OS to a phone OS. Nevertheless, Andy knew that they would
    need a rendering engine to display the UI, so he paid Mike for an evaluation license
    of Skia and agreed to get back in touch. But Mike didn’t hear back from him: “Andy
    just fell off the map and he didn’t respond to emails.”'
  prefs: []
  type: TYPE_NORMAL
- en: Months later, in the Summer of 2005, Andy finally contacted Mike. “He says,
    ‘Sorry I dropped out, but I’m emailing you from a new email address.’ And sure
    enough, it’s something@google.com. He says, ‘Hey I got acquired. We should probably
    finish that license.’”
  prefs: []
  type: TYPE_NORMAL
- en: But instead of just being another licensee of Skia’s rendering engine, Google
    acquired Mike’s company. Android was, after all, in hiring mode, and acquisitions
    can be an effective way (if you have the money) to hire multiple people quickly.
  prefs: []
  type: TYPE_NORMAL
- en: The acquisition was announced on November 9, 2005, and the four engineers from
    Skia (Mike, Cary, Leon Scroggins, and Patrick Scott) started in December.
  prefs: []
  type: TYPE_NORMAL
- en: One of the points of negotiation was location. Mike and Cary had, years earlier,
    made the decision to leave California and settle in North Carolina, and they weren’t
    wild about returning to the Bay Area. Google agreed to leave the team in North
    Carolina, where they established the new Chapel Hill office.^([19](#c11-footnote-19))
  prefs: []
  type: TYPE_NORMAL
- en: After the team started at Google, they got to work making Skia the graphics
    engine for Android. The underlying rendering software itself was fairly complete;
    they had full support in C++ for the kinds of 2D drawing operations that Android
    needed (lines, shapes, text, and images). In fact, the raw graphics functionality
    of Skia in Android has changed very little since those early years (though major
    improvements have happened along the way, like hardware acceleration). But given
    Android’s choice of Java as the main programming language for applications, they
    needed Skia to be callable from Java, not C++, so the team wrote the Java bindings.^([20](#c11-footnote-20))
  prefs: []
  type: TYPE_NORMAL
- en: Writing bindings for Skia and integrating the engine into the rest of the Android
    platform wasn’t too difficult, so the Skia team soon picked up a couple other
    projects. One of the projects, the new UI system, was short-lived. Mike’s team
    proposed that Android use Skia’s existing system for displaying UI. They had a
    system working already that developers programmed using a combination of JavaScript
    and XML. But the move to Java, plus some late-night work from Joe Onorato,^([21](#c11-footnote-21))
    sent the team down a different path.
  prefs: []
  type: TYPE_NORMAL
