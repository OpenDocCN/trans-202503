<html><head></head><body>
<p id="filepos871667" class="calibre_"><span class="calibre6"><span class="bold">
</span></span><span class="calibre1"><span class="bold">13</span></span><br class="calibre5"/><span class="calibre6"><span class="bold">DECOMPILING AND REVERSING MANAGED ASSEMBLIES</span></span></p><p class="calibre_12"><img src="images/00010.jpg" class="calibre_13"/></p><p class="calibre_6">Mono and .NET use a VM much as Java does to run compiled executables. The executable format for .NET and Mono is written using a higher-level bytecode than native x86 or x86_64 assembly, called managed assembly. This is in contrast to the native, unmanaged executables from languages like C and C++. Because managed assemblies are written in a higher-level bytecode, decompiling them is fairly straightforward if you use a few libraries that are not a part of the standard library.</p><p class="calibre_6">In this chapter, we will write a short decompiler that accepts a managed assembly and writes the source code back to a specified folder. This is a very useful tool for malware researchers, reverse engineers, or anyone needing to perform <span class="italic">binary diffing</span> (comparing two compiled binaries or libraries for differences at the byte level) between two .NET libraries or applications. We will then briefly cover a program shipped with Mono called <span class="calibre4">monodis</span> that is very useful for analyzing assemblies outside of source code analysis for potential backdoors and other nefarious code.</p><p id="filepos873153" class="calibre_10"><span class="calibre3"><span class="bold"> Decompiling Managed Assemblies</span></span></p><p class="calibre_11">A number of easy-to-use .NET decompilers exist. However, their UIs tend to use toolkits like WPF (Windows Presentation Foundation) that keep them from being cross-platform (and mainly only running on Windows). Many security engineers, analysts, and pentesters run Linux or OS X, so this isn’t super useful. ILSpy is one example of a good Windows decompiler; it uses the cross-platform <span class="calibre4">ICSharpCode.Decompiler</span> and <span class="calibre4">Mono.Cecil</span> libraries for decompilation, but its UI is Windows specific, so it isn’t usable on Linux or OS X. Luckily, we can build a simple tool that takes an assembly as an argument and uses these two previously mentioned open source libraries to decompile a given assembly and write the resulting source code back to disk for later analysis.</p><p class="calibre_6">Both of these libraries are available in NuGet. Installation will depend on your IDE; if you are using Xamarin Studio or Visual Studio, you can manage NuGet packages in the Solution Explorer for each project in the solution. <a href="#filepos877724">Listing 13-1</a> details the whole class, with the methods required to decompile a given assembly.</p><blockquote class="calibre_14"><span class="calibre4">class MainClass</span><br class="calibre5"/><span class="calibre4">{</span><br class="calibre5"/><span class="calibre4"> public static void ➊Main(string[] args)</span><br class="calibre5"/><span class="calibre4"> {</span><br class="calibre5"/><span class="calibre4"> if (args.Length != 2)</span><br class="calibre5"/><span class="calibre4"> {</span><br class="calibre5"/><span class="calibre4"> Console.Error.WriteLine("Dirty C# decompiler requires two arguments.");</span><br class="calibre5"/><span class="calibre4"> Console.Error.WriteLine("decompiler.exe &lt;assembly&gt; &lt;path to directory&gt;");</span><br class="calibre5"/><span class="calibre4"> return;</span><br class="calibre5"/><span class="calibre4"> }</span><br class="calibre5"/><br class="calibre5"/><span class="calibre4"> IEnumerable&lt;AssemblyClass&gt; klasses = ➋GenerateAssemblyMethodSource(args[0]);</span><br class="calibre5"/><span class="calibre4"> ➌foreach (AssemblyClass klass in klasses)</span><br class="calibre5"/><span class="calibre4"> {</span><br class="calibre5"/><span class="calibre4"> string outdir = Path.Combine(args[1], klass.namespase);</span><br class="calibre5"/><span class="calibre4"> if (!Directory.Exists(outdir))</span><br class="calibre5"/><span class="calibre4"> Directory.CreateDirectory(outdir);</span><br class="calibre5"/><br class="calibre5"/><span class="calibre4"> string path = Path.Combine(outdir, klass.name + ".cs");</span><br class="calibre5"/><span class="calibre4"> File.WriteAllText(path, klass.source);</span><br class="calibre5"/><span class="calibre4"> }</span><br class="calibre5"/><span class="calibre4"> }</span><br class="calibre5"/><br class="calibre5"/><span class="calibre4"> private static IEnumerable&lt;AssemblyClass&gt; ➍GenerateAssemblyMethodSource(string assemblyPath)</span><br class="calibre5"/><span class="calibre4"> {</span><br class="calibre5"/><span class="calibre4"> AssemblyDefinition assemblyDefinition = AssemblyDefinition.➎ReadAssembly(assemblyPath,</span><br class="calibre5"/><span class="calibre4"> new ReaderParameters(ReadingMode.Deferred) { ReadSymbols = true });</span><br class="calibre5"/><span class="calibre4"> AstBuilder astBuilder = null;</span><br class="calibre5"/><span class="calibre4"> foreach (var defmod in assemblyDefinition.Modules)</span><br class="calibre5"/><span class="calibre4"> {</span><br class="calibre5"/><span class="calibre4"> ➏foreach (var typeInAssembly in defmod.Types)</span><br class="calibre5"/><span class="calibre4"> {</span><br class="calibre5"/><span class="calibre4"> AssemblyClass klass = new AssemblyClass();</span><br class="calibre5"/><span class="calibre4"> klass.name = typeInAssembly.Name;</span><br class="calibre5"/><span class="calibre4"> klass.namespase = typeInAssembly.Namespace;</span><br class="calibre5"/><span class="calibre4"> astBuilder = new AstBuilder(new DecompilerContext(assemblyDefinition.MainModule)</span><br class="calibre5"/><span class="calibre4"> { CurrentType = typeInAssembly });</span><br class="calibre5"/><span class="calibre4"> astBuilder.AddType(typeInAssembly);</span><br class="calibre5"/><br class="calibre5"/><span class="calibre4"> using (StringWriter output = new StringWriter())</span><br class="calibre5"/><span class="calibre4"> {</span><br class="calibre5"/><span class="calibre4"> astBuilder.➐GenerateCode(new PlainTextOutput(output));</span><br class="calibre5"/><span class="calibre4"> klass.➑source = output.ToString();</span><br class="calibre5"/><span class="calibre4"> }</span><br class="calibre5"/><span class="calibre4"> ➒yield return klass;</span><br class="calibre5"/><span class="calibre4"> }</span><br class="calibre5"/><span class="calibre4"> }</span><br class="calibre5"/><span class="calibre4"> }</span><br class="calibre5"/><span class="calibre4">}</span><br class="calibre5"/><br class="calibre5"/><span class="calibre4">public class AssemblyClass</span><br class="calibre5"/><span class="calibre4">{</span><br class="calibre5"/><span class="calibre4"> public string namespase;</span><br class="calibre5"/><span class="calibre4"> public string name;</span><br class="calibre5"/><span class="calibre4"> public string source;</span><br class="calibre5"/><span class="calibre4">}</span></blockquote><p id="filepos877724" class="calibre_15"><span class="calibre4"><span class="italic">Listing 13-1: The dirty C# decompiler</span></span></p><p class="calibre_6"><a href="#filepos877724">Listing 13-1</a> is pretty dense, so let’s go through the big points. In the <span class="calibre4">MainClass</span>, we first create a <span class="calibre4">Main()</span> method ➊ that will be run when we run the program. It begins by checking how many arguments are specified. If only one argument is specified, it prints the usage and exits. If two arguments are specified in the application, we assume that the first is the path to the assembly we want to decompile and that the second is the folder where the resulting source code should be written. Finally, we pass the first argument to the application using the <span class="calibre4">GenerateAssemblyMethodSource()</span> method ➋, which is implemented just below the <span class="calibre4">Main()</span> method.</p><p class="calibre_6">In the <span class="calibre4">GenerateAssemblyMethodSource()</span> method ➍, we use the <span class="calibre4">Mono.Cecil</span> method <span class="calibre4">ReadAssembly()</span> ➎ to return an <span class="calibre4">AssemblyDefinition</span>. Basically, this is a class from <span class="calibre4">Mono.Cecil</span> that fully represents an assembly and allows you to programmatically probe it. Once we have the <span class="calibre4">AssemblyDefinition</span> for the assembly we want to decompile, we have what we need to generate C# source code that is functionally equivalent to the raw bytecode instructions in the assembly. We use <span class="calibre4">Mono.Cecil</span> to generate our C# code from the <span class="calibre4">AssemblyDefinition</span> by creating an <span class="italic">abstract syntax tree (AST)</span>. I won’t go into ASTs (there are college courses dedicated to this subject), but you should know that an AST can express every potential code path within a program and that <span class="calibre4">Mono.Cecil</span> can be used to generate the AST of a .NET program.</p><p class="calibre_6">This process must be repeated for every class in the assembly. Basic assemblies like this one have only one or two classes, but complex applications can have many dozen or more. That would be a pain to code individually, so we create a <span class="calibre4">foreach</span> loop ➏ to do the work for us. It iterates these steps over each class in the assembly and creates a new <span class="calibre4">AssemblyClass</span> (which is defined below the <span class="calibre4">GenerateAssemblyMethodSource()</span> method) based on the current class information.</p><p class="calibre_6">The part to note here is that the <span class="calibre4">GenerateCode()</span> method ➐ actually does the heavy lifting of the whole program by taking the AST we create to give us a C# source code representation of the class in the assembly. Then, we assign the <span class="calibre4">source</span> field ➑ on the <span class="calibre4">AssemblyClass</span> with the generated C# source code, as well as the name of the class and the namespace. When all this is done, we return a list of classes and their source code to the caller of the <span class="calibre4">GenerateAssemblyMethodSource()</span> method—in this case, our <span class="calibre4">Main()</span> method. As we iterate over each class returned ➌ by <span class="calibre4">GenerateAssemblyMethodSource()</span>, we create a new file per class and write the source code for the class into the file. We use the <span class="calibre4">yield</span> keyword ➒ in <span class="calibre4">GenerateAssemblyMethodSource()</span> to return each class, one at a time, as we iterate in the <span class="calibre4">foreach</span> loop ➌ rather than returning a full list of all the classes and then processing them. This is a good performance boost for binaries with a lot of classes to process.</p><p id="filepos881526" class="calibre_10"><span class="calibre3"><span class="bold">Testing the Decompiler</span></span></p><p class="calibre_11">Let’s take a time-out to test this by writing a Hello World–esque application. Make a new project with the simple class in <a href="#filepos882442">Listing 13-2</a> and then compile it.</p><blockquote class="calibre_14"><span class="calibre4">using System;</span><br class="calibre5"/><span class="calibre4">namespace hello_world</span><br class="calibre5"/><span class="calibre4">{</span><br class="calibre5"/><span class="calibre4"> class MainClass</span><br class="calibre5"/><span class="calibre4"> {</span><br class="calibre5"/><span class="calibre4"> public static void Main(string[] args)</span><br class="calibre5"/><span class="calibre4"> {</span><br class="calibre5"/><span class="calibre4"> Console.WriteLine("Hello World!");</span><br class="calibre5"/><span class="calibre4"> Console.WriteLine(2 + 2);</span><br class="calibre5"/><span class="calibre4"> }</span><br class="calibre5"/><span class="calibre4"> }</span><br class="calibre5"/><span class="calibre4">}</span></blockquote><p id="filepos882442" class="calibre_15"><span class="calibre4"><span class="italic">Listing 13-2: A simple Hello World application before decompilation</span></span></p><p class="calibre_6">After compiling the project, we point our new decompiler at it to see what it comes out with, as shown in <a href="#filepos883620">Listing 13-3</a>.</p><blockquote class="calibre_14"><span class="calibre4">$ </span><span class="calibre4"><span class="bold">./decompiler.exe ~/projects/hello_world/bin/Debug/hello_world.exe hello_world</span></span><br class="calibre5"/><span class="calibre4">$ </span><span class="calibre4"><span class="bold">cat hello_world/hello_world/MainClass.cs</span></span><br class="calibre5"/><span class="calibre4">using System;</span><br class="calibre5"/><br class="calibre5"/><span class="calibre4">namespace hello_world</span><br class="calibre5"/><span class="calibre4">{</span><br class="calibre5"/><span class="calibre4"> internal class MainClass</span><br class="calibre5"/><span class="calibre4"> {</span><br class="calibre5"/><span class="calibre4"> public static void Main(string[] args)</span><br class="calibre5"/><span class="calibre4"> {</span><br class="calibre5"/><span class="calibre4"> Console.WriteLine("Hello World!");</span><br class="calibre5"/><span class="calibre4"> Console.WriteLine(➊4);</span><br class="calibre5"/><span class="calibre4"> }</span><br class="calibre5"/><span class="calibre4"> }</span><br class="calibre5"/><span class="calibre4">}</span></blockquote><p id="filepos883620" class="calibre_15"><span class="calibre4"><span class="italic">Listing 13-3: The decompiled Hello World source code</span></span></p><p class="calibre_6">Pretty close! The only real difference is the second <span class="calibre4">WriteLine()</span> method call. In the original code, we had <span class="calibre4">2 + 2</span>, but the decompiled version outputs <span class="calibre4">4</span> ➊. This is not a problem. During compile time, anything that evaluates to a constant value is replaced with that in the binary, so <span class="calibre4">2 + 2</span> gets written as <span class="calibre4">4</span> in the assembly—something to keep in mind when dealing with assemblies that perform a lot of math to achieve a given result.</p><p id="filepos884338" class="calibre_10"><span class="calibre3"><span class="bold">Using monodis to Analyze an Assembly</span></span></p><p class="calibre_11">Say we want to do some cursory investigation into a malicious binary before decompiling it. The <span class="calibre4">monodis</span> tool that ships with Mono gives us a lot of power for doing this. It has specific <span class="calibre4">strings</span>-type options (<span class="calibre4">strings</span> is a common Unix utility that prints any human-readable string of characters found in a given file) and can list and export resources compiled into the assembly such as config files or private keys. The <span class="calibre4">monodis</span> usage output can be cryptic and hard to read, as shown in <a href="#filepos886321">Listing 13-4</a> (though the man page is a little better).</p><blockquote class="calibre_14"><span class="calibre4">$ </span><span class="calibre4"><span class="bold">monodis</span></span><br class="calibre5"/><span class="calibre4">monodis -- Mono Common Intermediate Language Disassembler</span><br class="calibre5"/><span class="calibre4">Usage is: monodis [--output=filename] [--filter=filename] [--help] [--mscorlib]</span><br class="calibre5"/><span class="calibre4">[--assembly] [--assemblyref] [--classlayout]</span><br class="calibre5"/><span class="calibre4">[--constant] [--customattr] [--declsec] [--event] [--exported]</span><br class="calibre5"/><span class="calibre4">[--fields] [--file] [--genericpar] [--interface] [--manifest]</span><br class="calibre5"/><span class="calibre4">[--marshal] [--memberref] [--method] [--methodimpl] [--methodsem]</span><br class="calibre5"/><span class="calibre4">[--methodspec] [--moduleref] [--module] [--mresources] [--presources]</span><br class="calibre5"/><span class="calibre4">[--nested] [--param] [--parconst] [--property] [--propertymap]</span><br class="calibre5"/><span class="calibre4">[--typedef] [--typeref] [--typespec] [--implmap] [--fieldrva]</span><br class="calibre5"/><span class="calibre4">[--standalonesig] [--methodptr] [--fieldptr] [--paramptr] [--eventptr]</span><br class="calibre5"/><span class="calibre4">[--propertyptr] [--blob] [--strings] [--userstrings] [--forward-decls] file ..</span></blockquote><p id="filepos886321" class="calibre_15"><span class="calibre4"><span class="italic">Listing 13-4: The</span></span><span class="calibre4">
</span><span class="calibre4"><span class="italic">monodis</span></span><span class="calibre4">
</span><span class="calibre4"><span class="italic">usage output</span></span></p><p class="calibre_6">Running <span class="calibre4">monodis</span> with no arguments prints a full disassembly of the assembly in the Common Intermediate Language (CIL) bytecode, or you can output the disassembly straight into a file. <a href="#filepos888130">Listing 13-5</a> shows some of the disassembly output of the <span class="calibre4">ICSharpCode.Decompiler.dll</span> assembly, which is effectively analogous to the x86 assembly language you may see for a natively compiled application.</p><blockquote class="calibre_14"><span class="calibre4">$ </span><span class="calibre4"><span class="bold">monodis ICSharpCode.Decompiler.dll | tail -n30 | head -n10</span></span><br class="calibre5"/><span class="calibre4"> IL_000c: mul</span><br class="calibre5"/><span class="calibre4"> IL_000d: call class [mscorlib]System.Collections.Generic.EqualityComparer`1&lt;!0&gt; class</span><br class="calibre5"/><span class="calibre4">[mscorlib]System.Collections.Generic.EqualityComparer`1&lt;!'&lt;expr&gt;j__TPar'&gt;::get_Default()</span><br class="calibre5"/><span class="calibre4"> IL_0012: ldarg.0</span><br class="calibre5"/><span class="calibre4"> IL_0013: ldfld !0 class '&lt;&gt;f__AnonymousType5`2'&lt;!0,!1&gt;::'&lt;expr&gt;i__Field'</span><br class="calibre5"/><span class="calibre4"> IL_0018: callvirt instance int32 class [mscorlib]System.Collections.Generic.Equality</span><br class="calibre5"/><span class="calibre4">Comparer`1&lt;!'&lt;expr&gt;j__TPar'&gt;::GetHashCode(!0)</span><br class="calibre5"/><span class="calibre4"> IL_001d: add</span><br class="calibre5"/><span class="calibre4"> IL_001e: stloc.0</span><br class="calibre5"/><span class="calibre4"> IL_001f: ldc.i4 -1521134295</span><br class="calibre5"/><span class="calibre4"> IL_0024: ldloc.0</span><br class="calibre5"/><span class="calibre4"> IL_0025: mul $</span></blockquote><p id="filepos888130" class="calibre_15"><span class="calibre4"><span class="italic">Listing 13-5: Some CIL disassembly from</span></span><span class="calibre4">
</span><span class="calibre4"><span class="italic">ICSharpCode.Decompiler.dll</span></span></p><p class="calibre_6">That’s nice, but not very useful if you don’t know what you’re looking at. Notice that the output code looks similar to x86 assembly. This is actually raw intermediate language (IL), which is kind of like Java bytecode in JAR files, and it can seem a bit arcane. You’ll likely find this most useful when diffing two versions of a library to see what was changed.</p><p class="calibre_6">It has other great features that aid in reverse engineering. For instance, you can run the GNU <span class="calibre4">strings</span> utility on an assembly to see which strings are stored inside, but you always get cruft you don’t want, such as random byte sequences that just happen to be ASCII printable. If, on the other hand, you pass the <span class="calibre4">--userstrings</span> argument to <span class="calibre4">monodis</span>, it will print any strings that are stored for use in the code, such as variable assignments or constants, as <a href="#filepos889947">Listing 13-6</a> shows. Since <span class="calibre4">monodis</span> actually parses the assembly to determine what strings have been programmatically defined, it can produce much cleaner results with higher signal to noise.</p><blockquote class="calibre_14"><span class="calibre4">$ </span><span class="calibre4"><span class="bold">monodis --userstrings ~/projects/hello_world/bin/Debug/hello_world.exe</span></span><br class="calibre5"/><span class="calibre4">User Strings heap contents</span><br class="calibre5"/><span class="calibre4">00: ""</span><br class="calibre5"/><span class="calibre4">01: "Hello World!"</span><br class="calibre5"/><span class="calibre4">1b: ""</span><br class="calibre5"/><span class="calibre4">$</span></blockquote><p id="filepos889947" class="calibre_15"><span class="calibre4"><span class="italic">Listing 13-6: Using the</span></span><span class="calibre4">
</span><span class="calibre4"><span class="italic">--userstrings</span></span><span class="calibre4">
</span><span class="calibre4"><span class="italic">argument for</span></span><span class="calibre4">
</span><span class="calibre4"><span class="italic">monodis</span></span></p><p class="calibre_6">You can also combine <span class="calibre4">--userstrings</span> with <span class="calibre4">--strings</span> (used for metadata and other things), which will output all strings stored in the assembly that aren’t the random garbage that GNU <span class="calibre4">strings</span> picks up. This is very useful when you look for encryption keys or credentials hardcoded into assemblies.</p><p class="calibre_6">However, my favorite <span class="calibre4">monodis</span> flags are <span class="calibre4">--manifest</span> and <span class="calibre4">--mresources</span>. The first, <span class="calibre4">--manifest</span>, lists all the embedded resources in the assembly. These are usually images or configuration files, but sometimes you’ll find private keys and other sensitive material. The second argument, <span class="calibre4">--mresources</span>, saves each embedded resource to the current working directory. <a href="#filepos891930">Listing 13-7</a> shows this in practice.</p><blockquote class="calibre_14"><span class="calibre4">$ </span><span class="calibre4"><span class="bold">monodis --manifest ~/projects/hello_world/bin/Debug/hello_world.exe</span></span><br class="calibre5"/><span class="calibre4">Manifestresource Table (1..1)</span><br class="calibre5"/><span class="calibre4">1: public 'hello_world.til_neo.png' at offset 0 in current module</span><br class="calibre5"/><span class="calibre4">$ </span><span class="calibre4"><span class="bold">monodis --mresources ~/projects/hello_world/bin/Debug/hello_world.exe</span></span><br class="calibre5"/><span class="calibre4">$ </span><span class="calibre4"><span class="bold">file hello_world.til_neo.png</span></span><br class="calibre5"/><span class="calibre4"> hello_world.til_neo.png: PNG image data, 1440 x 948, 8-bit/color RGBA, non-interlaced</span><br class="calibre5"/><span class="calibre4">$</span></blockquote><p id="filepos891930" class="calibre_15"><span class="calibre4"><span class="italic">Listing 13-7: Saving an embedded resource to the filesystem with</span></span><span class="calibre4">
</span><span class="calibre4"><span class="italic">monodis</span></span></p><p class="calibre_6">Apparently, someone hid a picture of Neo in my Hello World application! To be sure, <span class="calibre4">monodis</span> is a favorite tool when I’m messing with an unknown assembly and I want to gain a little bit more information about it, such as methods or specific strings in the binary.</p><p class="calibre_6">Finally, we have one of the most useful arguments to <span class="calibre4">monodis</span>, <span class="calibre4">--method</span>, which lists all the methods and arguments available in a library or binary (see <a href="#filepos893213">Listing 13-8</a>).</p><blockquote class="calibre_14"><span class="calibre4">$ </span><span class="calibre4"><span class="bold">monodis --method ch1_hello_world.exe</span></span><br class="calibre5"/><span class="calibre4">Method Table (1..2)</span><br class="calibre5"/><span class="calibre4">########## ch1_hello_world.MainClass</span><br class="calibre5"/><span class="calibre4">1: ➊instance default void '.ctor' () (param: 1 impl_flags: cil managed )</span><br class="calibre5"/><span class="calibre4">2: ➋default void Main (string[] args) (param: 1 impl_flags: cil managed ) </span><a id="filepos893213"/><span class="calibre4"><span class="italic">Listing 13-8: Demonstrating the</span></span><span class="calibre4">
</span><span class="calibre7"><span class="italic">--method</span></span><span class="calibre4">
</span><span class="calibre4"><span class="italic">argument for</span></span><span class="calibre4">
</span><span class="calibre7"><span class="italic">monodis</span></span></blockquote><p class="calibre_6">When you run <span class="calibre4">monodis --method</span> on the Hello World program from <a href="index_split_006.html#filepos69411">Chapter 1</a>, you will notice that <span class="calibre4">monodis</span> prints two method lines. The first line ➊ is the constructor for the <span class="calibre4">MainClass</span> class that contains the <span class="calibre4">Main()</span> method, on line 2 ➋. So, not only does this argument list all the methods (and which class those methods are in), but it also prints the class constructors! This can offer great insight into how a program may work: method names are often good descriptions of what is going on internally.</p><p id="filepos894141" class="calibre_10"><span class="calibre3"><span class="bold">Conclusion</span></span></p><p class="calibre_11">In the first part of this chapter, we discussed how to utilize the open source <span class="calibre4">ICSharpCode.Decompiler</span> and <span class="calibre4">Mono.Cecil</span> libraries to decompile an arbitrary assembly back into C# code. By compiling a small Hello World application, we saw one difference between the code that results from a decompiled assembly and that of the original source. Other differences may occur, such as the keyword <span class="calibre4">var</span> being replaced with the actual type of the object being created. However, the generated code should still be functionally equivalent, even if it isn’t completely the same source code as before.</p><p class="calibre_6">Then, we used the <span class="calibre4">monodis</span> tool to see how to dissect and analyze assemblies to glean more information from a rogue application than we would easily have been able to do otherwise. Hopefully, these tools can decrease the time between going from “What happened?” to “How do we fix it?” when something goes wrong or a new piece of malware is found. </p><div class="mbp_pagebreak" id="calibre_pb_18"/>
</body></html>