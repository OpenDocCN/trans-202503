<html><head></head><body>
<section epub:type="chapter" role="doc-chapter" aria-labelledby="ch16">&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_387" aria-label="387"/>&#13;
<hgroup>&#13;
&#13;
<h2 class="CHAPTER" id="ch16">&#13;
<span class="CN"><span class="SANS_Futura_Std_Bold_Condensed_B_11">16</span></span>&#13;
<span class="CT"><span class="SANS_Dogma_OT_Bold_B_11">DIGITAL SEARCH TREES</span></span>&#13;
</h2>&#13;
</hgroup>&#13;
<figure class="opener"><img class="opener" src="../images/opener.jpg" alt=""/>&#13;
</figure>&#13;
<p class="INTRO">In the previous four chapters, we explored different types of trees, including binary trees, general trees, heaps, and more. All of those trees are based on storing and comparing keys. With the digital search trees we’ll consider in this chapter, we won’t associate keys with nodes. Instead, the node’s position in the tree will define the key with which it is associated. In other words, you won’t store keys in a single place in the tree; they’ll be distributed across the whole structure, starting at the tree’s root. The leaves will mark where the keys end.</p>&#13;
<p class="TX">This might look like merely changing the way we work, in the same way that the radix sort changed the way we sorted (<span class="Xref"><a href="chapter6.xhtml">Chapter 6</a></span>). With radix sort, instead of sorting by comparing keys, we worked with the keys character by <span role="doc-pagebreak" epub:type="pagebreak" id="pg_388" aria-label="388"/>character (or digit by digit, for numbers). With digital search trees, instead of storing and comparing keys, we’ll work with paths in trees.</p>&#13;
<p class="TX">We’ll focus on three different data structures: <i>tries</i>, which can do searches in time proportional to a key’s length; <i>radix trees</i>, which are optimized versions of tries; and <i>ternary search tries</i>, an extension of binary search trees. These structures are particularly effective when we’re searching for strings, just as we search in a dictionary for words.</p>&#13;
<section epub:type="division" aria-labelledby="sec1">&#13;
&#13;
<h3 class="H1" id="sec1"><span id="h1-83"/><span class="SANS_Futura_Std_Bold_B_11">The Classic Version of Tries</span></h3>&#13;
<p class="TNI1">Tries often are used simply to store words, allowing for easy, fast searches where users can enter a few letters, and words starting with those letters appear. Tries also are used as generic search trees where keys and data are stored and then a search is conducted for a key to provide the associated data.</p>&#13;
<blockquote>&#13;
<p class="Note"><span class="SANS_Dogma_OT_Bold_B_15">NOTE</span></p>&#13;
</blockquote>&#13;
<p class="NOTE-TXT"><i>Trie originally was pronounced like the word tree, but it’s also pronounced like the word try to distinguish it from tree. You can pronounce it either way.</i></p>&#13;
<p class="TX">Think of tries as a bit like old telephone indexes that had a set of buttons, one for each letter. If you wanted to find a name starting with <i>F</i>, you’d press that key, and the index would open on the F page. The analogy doesn’t stop there. Assume the index had another set of buttons for the name’s second letter, and pressing that button led you to yet another page with a new set of buttons. If you clicked all the buttons in order, you’d arrive at the name you were looking for or an empty page, meaning the name wasn’t in the index. This analogy may be hard to understand (I wonder how many readers have ever seen such a phone index! Maybe think of how autocomplete works instead?), so let’s consider the actual definition of a trie.</p>&#13;
<p class="TX">A trie has a link for each possible character (the same way the previous phone index example has a button for each letter in a name), but for simplicity, we’ll work with only the letters from A to E, plus an end of word (EOW) character to indicate where each word ends. We’ll use <span class="SANS_TheSansMonoCd_W5Regular_11">■</span> for this. (Other languages, such as C, use the NULL <span class="SANS_TheSansMonoCd_W5Regular_11">\0</span> character for EOW, but the square symbol is more visible.) Suppose the words are ACE, AD, BADE, BE, BED, and BEE. In the trie, you’ll actually see ACE<span class="SANS_TheSansMonoCd_W5Regular_11">■</span>, AD<span class="SANS_TheSansMonoCd_W5Regular_11">■</span>, and so on. This trie looks like the diagram in <a href="chapter16.xhtml#fig16-1">Figure 16-1</a>, and for clarity, I’ve placed the root on the left instead of at the top, so you can read the words horizontally.</p>&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_389" aria-label="389"/>&#13;
<figure class="IMG"><img class="img1" id="fig16-1" src="../images/Figure16-1.jpg" alt=""/>&#13;
<figcaption><p class="CAP"><span class="SANS_Futura_Std_Book_Oblique_11">Figure 16-1: A sample trie for words using only letters from A to E</span></p></figcaption>&#13;
</figure>&#13;
<p class="TX">Each node in the trie consists of an array of links, one for each possible letter (A–E) plus the EOW character. (You could say it’s a six-ary tree; see <span class="Xref"><a href="chapter13.xhtml">Chapter 13</a></span>.) The empty links have a white background in the diagram, and actual links have a gray background. Each word in a little box represents some extra data or value associated with the corresponding key (we’ll get to that in the next section).</p>&#13;
<p class="TX">You can define the basic functions to create a trie as follows:</p>&#13;
<pre id="pre-317"><code>const EOW = "■";&#13;
const ALPHABET = `${EOW}ABCDE`;&#13;
const newTrie = () =&gt; null;&#13;
const newNode = () =&gt; ({links: new Array(ALPHABET.length).fill(null)});&#13;
const isEmpty = (trie) =&gt; !trie; // null or undefined</code></pre>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_390" aria-label="390"/>First, define the <span class="SANS_TheSansMonoCd_W5Regular_11">EOW</span> character; you’ll use the same definition throughout this chapter. The <span class="SANS_TheSansMonoCd_W5Regular_11">ALPHABET</span> constant includes all the characters we’ll accept; for this example, you’re using only five letters, but for a real application, you’d most likely include at least the whole alphabet, A to Z. A new trie is just a <span class="SANS_TheSansMonoCd_W5Regular_11">null</span> value, and a new node is an object with a <span class="SANS_TheSansMonoCd_W5Regular_11">links</span> property, which is an array with one null link for each character in <span class="SANS_TheSansMonoCd_W5Regular_11">ALPHABET</span>. Finally, to recognize an empty trie, simply check for “falsey” values on the last line.</p>&#13;
<p class="TX">You can also associate some value with every key, as shown next.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec2">&#13;
&#13;
<h3 class="H1" id="sec2"><span id="h1-84"/><span class="SANS_Futura_Std_Bold_B_11">Storing Extra Data in a Trie</span></h3>&#13;
<p class="TNI1">When we studied trees in previous chapters, we were concerned only with storing keys and searching for keys, because adding extra data was simple. Instead of a single key field, we could have a record with a key field and an extra data field. If we wanted to modify the algorithms to include extra fields, the changes were minor: searches would return the extra data instead of just a boolean value, and adding a key would also add the extra fields in the same object.</p>&#13;
<p class="TX">But in a trie, keys aren’t stored in a single place and instead are distributed throughout the trie’s branches. There is a solution to this, but because the changes needed in the algorithms aren’t so minor, we’ll work with keys plus data.</p>&#13;
<p class="TX">The dictionary abstract data type (ADT) will change slightly, specifically the add and find operations, as shown in <a href="chapter16.xhtml#tab16-1">Table 16-1</a>.</p>&#13;
&#13;
<table class="table">&#13;
<caption><p class="TT" id="tab16-1"><span class="Heavy"><span class="SANS_Futura_Std_Heavy_11">Table 16-1:</span></span> <span class="SANS_Futura_Std_Book_11">Operations on Tries</span></p></caption>&#13;
<thead>&#13;
<tr>&#13;
<th class="TCH" scope="col"><p class="TCH1"><span class="SANS_Futura_Std_Heavy_11">Operation</span></p></th>&#13;
<th class="TCH" scope="col"><p class="TCH1"><span class="SANS_Futura_Std_Heavy_11">Signature</span></p></th>&#13;
<th class="TCH" scope="col"><p class="TCH1"><span class="SANS_Futura_Std_Heavy_11">Description</span></p></th>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr>&#13;
<td class="TBF"><p class="TBGREY"><span class="SANS_Futura_Std_Book_11">Create</span></p></td>&#13;
<td class="TBF"><p class="TBGREY"><span class="symbol">→</span> <span class="SANS_Futura_Std_Book_11">D</span></p></td>&#13;
<td class="TBF"><p class="TBGREY"><span class="SANS_Futura_Std_Book_11">Create a new dictionary.</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">Empty?</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">D</span> <span class="symbol">→</span> <span class="SANS_Futura_Std_Book_11">boolean</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">Determine whether the dictionary is empty.</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TB"><p class="TBGREY"><span class="SANS_Futura_Std_Book_11">Add</span></p></td>&#13;
<td class="TB"><p class="TBGREY"><span class="SANS_Futura_Std_Book_11">D × key × data</span> <span class="symbol">→</span> <span class="SANS_Futura_Std_Book_11">D</span></p></td>&#13;
<td class="TB"><p class="TBGREY"><span class="SANS_Futura_Std_Book_11">Given a new key and data, add them to the dictionary.</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">Remove</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">D × key</span> <span class="symbol">→</span> <span class="SANS_Futura_Std_Book_11">D</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">Given a key, remove it from the dictionary.</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TBL"><p class="TBGREY"><span class="SANS_Futura_Std_Book_11">Find</span></p></td>&#13;
<td class="TBL"><p class="TBGREY"><span class="SANS_Futura_Std_Book_11">D × key</span> <span class="symbol">→</span> <span class="SANS_Futura_Std_Book_11">data | null</span></p></td>&#13;
<td class="TBL"><p class="TBGREY"><span class="SANS_Futura_Std_Book_11">Given a key, return its data or return null if not found.</span></p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<p class="TX">As in other chapters, we’ll study the performance of the structures for this ADT. Now that we’ve defined the full structure for a trie and looked at how to create one, let’s consider the rest of the needed functions.</p>&#13;
<section epub:type="division" aria-labelledby="sec3">&#13;
&#13;
<h4 class="H2" id="sec3"><span id="h2-155"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_11">Searching a Trie</span></h4>&#13;
<p class="TNI1">How do you look for a word? For example, if you want to know whether BED is a valid word, <a href="chapter16.xhtml#fig16-2">Figure 16-2</a> shows the path you’d take.</p>&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_391" aria-label="391"/>&#13;
<figure class="IMG"><img class="img1" id="fig16-2" src="../images/Figure16-2.jpg" alt=""/>&#13;
<figcaption><p class="CAP"><span class="SANS_Futura_Std_Book_Oblique_11">Figure 16-2: Searching successfully for BED in a trie</span></p></figcaption>&#13;
</figure>&#13;
<p class="TX">The search for BED starts at the root. You look at the B link and find it’s not null, so you follow it to the next level. There, you look at the E link and again follow it. The next step is similar: look at the D link and follow it. Finally, you arrive at the EOW, and finding a link to some data in the corresponding link, call it a successful search and return the found data.</p>&#13;
<p class="TX">A failed search looks different. For example, if you want to find the word DAB, the search would fail at the beginning, since no word starts with D. What about ACED? This time, you’d start the search at the A link, then the C link, and finally the E link, but you’d arrive at a node with no D link, meaning ACED isn’t in the trie. <a href="chapter16.xhtml#fig16-3">Figure 16-3</a> shows this failed search.</p>&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_392" aria-label="392"/>&#13;
<figure class="IMG"><img class="img1" id="fig16-3" src="../images/Figure16-3.jpg" alt=""/>&#13;
<figcaption><p class="CAP"><span class="SANS_Futura_Std_Book_Oblique_11">Figure 16-3: Searching (unsuccessfully) for ACED in a trie</span></p></figcaption>&#13;
</figure>&#13;
<p class="TX">Consider one last case and search for BAD. Remember, you’re adding an EOW character, so in reality, you’re trying to find BAD<span class="SANS_TheSansMonoCd_W5Regular_11">■</span>. <a href="chapter16.xhtml#fig16-4">Figure 16-4</a> shows what happens.</p>&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_393" aria-label="393"/>&#13;
<figure class="IMG"><img class="img1" id="fig16-4" src="../images/Figure16-4.jpg" alt=""/>&#13;
<figcaption><p class="CAP"><span class="SANS_Futura_Std_Book_Oblique_11">Figure 16-4: Searching unsuccessfully for BAD: BADE is in the trie, but BAD isn’t.</span></p></figcaption>&#13;
</figure>&#13;
<p class="TX">This search starts at the root and follows the B link first, then the A link, and then the D link. BAD is a prefix of at least one word, but the EOW link is missing, so BAD isn’t considered to be in the trie.</p>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_394" aria-label="394"/>To implement this logic, first create an auxiliary <span class="SANS_TheSansMonoCd_W5Regular_11">_find()</span> function that actually does the searches:</p>&#13;
<pre id="pre-318"><code>const _find = (trie, [first, . . .rest]) =&gt; {&#13;
<span class="Code_CodeAnnotation" aria-label="annotation1">❶</span> const i = ALPHABET.indexOf(first);&#13;
<span class="Code_CodeAnnotation" aria-label="annotation2">❷</span> if (isEmpty(trie)) {&#13;
   return null;&#13;
<span class="Code_CodeAnnotation" aria-label="annotation3">❸</span>} else if (first === EOW) {&#13;
   return isEmpty(trie.links[i]) ? null : trie.links[i].data;&#13;
<span class="Code_CodeAnnotation" aria-label="annotation4">❹</span>} else {&#13;
   return _find(trie.links[i], rest);&#13;
 }&#13;
};</code></pre>&#13;
<p class="TX">The <span class="SANS_TheSansMonoCd_W5Regular_11">i</span> variable <span class="CodeAnnotation" aria-label="annotation1">❶</span> selects the proper value from the <span class="SANS_TheSansMonoCd_W5Regular_11">links</span> property, and now you’re ready to start searching. If the trie is empty (maybe it was empty from the beginning, or maybe you traveled down a <span class="SANS_TheSansMonoCd_W5Regular_11">null</span> link), the search has obviously failed <span class="CodeAnnotation" aria-label="annotation2">❷</span>. If you arrive at the end of the word (marked by the EOW character), do a simple test: if the corresponding link is null, the search fails as before; if not, the link points to an object with a data property, which you return <span class="CodeAnnotation" aria-label="annotation3">❸</span>. Otherwise, if you haven’t yet reached a null link or the EOW character <span class="CodeAnnotation" aria-label="annotation4">❹</span>, go down the right link and keep searching recursively.</p>&#13;
<p class="TX">The <span class="SANS_TheSansMonoCd_W5Regular_11">find()</span> function just calls the earlier <span class="SANS_TheSansMonoCd_W5Regular_11">_find()</span>, but it adds the needed EOW character at the end of the string you’re trying to find:</p>&#13;
<pre id="pre-319"><code>const find = (trie, wordToFind) =&gt;&#13;
<span class="Code_CodeAnnotation" aria-label="annotation1">❶</span> !!wordToFind ? _find(trie, wordToFind + EOW) : null;</code></pre>&#13;
<p class="TX">Test for an empty word to find <span class="CodeAnnotation" aria-label="annotation1">❶</span>, and if it’s empty, return null without any further ado.</p>&#13;
<p class="TX">Searching tries isn’t complex, and it’s similar to searches in other types of trees we looked at in previous chapters.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec4">&#13;
&#13;
<h4 class="H2" id="sec4"><span id="h2-156"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_11">Adding a Key to a Trie</span></h4>&#13;
<p class="TNI1">Adding a new key (plus data) to an existing trie follows the same strategy used for searches. Go down the links, letter by letter, and if the link exists, follow it, and if it doesn’t, add a new empty node. For instance, in the trie diagram shown in <a href="chapter16.xhtml#fig16-5">Figure 16-5</a>, if you want to add a BAD key, you just need to add a link at the last node with the data.</p>&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_395" aria-label="395"/>&#13;
<figure class="IMG"><img class="img1" id="fig16-5" src="../images/Figure16-5.jpg" alt=""/>&#13;
<figcaption><p class="CAP"><span class="SANS_Futura_Std_Book_Oblique_11">Figure 16-5: Adding BAD to a trie</span></p></figcaption>&#13;
</figure>&#13;
<p class="TX">The only change in the trie is that the (so far) empty EOW link now points to the data associated with the BAD key.</p>&#13;
<p class="TX">As another example, to add ABE, you would start by following the A link at the root, but then you’d need to add two new nodes, as shown in <a href="chapter16.xhtml#fig16-6">Figure 16-6</a>.</p>&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_396" aria-label="396"/>&#13;
<figure class="IMG"><img class="img1" id="fig16-6" src="../images/Figure16-7.jpg" alt=""/>&#13;
<figcaption><p class="CAP"><span class="SANS_Futura_Std_Book_Oblique_11">Figure 16-6: Adding ABE to the trie requires new nodes.</span></p></figcaption>&#13;
</figure>&#13;
<p class="TX">The code for this addition is similar to other insertion functions we’ve discussed in previous chapters:</p>&#13;
<pre id="pre-320"><code><span class="codeannotated_CodeAnnotation" aria-label="annotation1">❶</span> const _add = (trie, [first, . . .rest], data) =&gt; {&#13;
<span class="Code_CodeAnnotation" aria-label="annotation2">❷</span> if (first) {&#13;
  <span class="Code_CodeAnnotation" aria-label="annotation3">❸</span> if (isEmpty(trie)) {&#13;
      trie = newNode();&#13;
    }&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_397" aria-label="397"/>  <span class="Code_CodeAnnotation" aria-label="annotation4">❹</span> const i = ALPHABET.indexOf(first);&#13;
    if (first === EOW) {&#13;
    <span class="Code_CodeAnnotation" aria-label="annotation5">❺</span> trie.links[i] = {data};&#13;
    } else {&#13;
    <span class="Code_CodeAnnotation" aria-label="annotation6">❻</span> trie.links[i] = _add(trie.links[i], rest, data);&#13;
    }&#13;
  }&#13;
  return trie;&#13;
};</code></pre>&#13;
<p class="TX">An <span class="SANS_TheSansMonoCd_W5Regular_11">_add()</span> auxiliary function <span class="CodeAnnotation" aria-label="annotation1">❶</span> actually does the insertion. While you haven’t reached the end of the string (including the added EOW) <span class="CodeAnnotation" aria-label="annotation2">❷</span>, advance, following the links corresponding to successive letters. If you find an empty link <span class="CodeAnnotation" aria-label="annotation3">❸</span>, create a new node and keep advancing until you reach the EOW character. At each step, decide what link to follow <span class="CodeAnnotation" aria-label="annotation4">❹</span>, and when you reach the EOW, add a link to the extra data <span class="CodeAnnotation" aria-label="annotation5">❺</span>; otherwise, recursively keep adding the rest of the string <span class="CodeAnnotation" aria-label="annotation6">❻</span>.</p>&#13;
<p class="TX">Finally, the <span class="SANS_TheSansMonoCd_W5Regular_11">add()</span> function just invokes <span class="SANS_TheSansMonoCd_W5Regular_11">_add()</span>:</p>&#13;
<pre id="pre-321"><code>const add = (trie, wordToAdd, dataToAdd = wordToAdd) =&gt;&#13;
  _add(trie, wordToAdd + EOW, dataToAdd);</code></pre>&#13;
<p class="TX">This function also ensures that the EOW character is added.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec5">&#13;
&#13;
<h4 class="H2" id="sec5"><span id="h2-157"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_11">Removing a Key from a Trie</span></h4>&#13;
<p class="TNI1">Now we’ll look at deleting a key, which is a bit more complex than adding keys to a trie. First, try to find the key; if you can’t find it, you’re finished, since there’s nothing else to do. If you find the key (and arrived at an EOW character), just delete the associated data, making the pointer null. If doing that left the current node empty of pointers, then delete the node and fix the parent’s pointer, which may again leave an all-empty node, so keep going up, back to the root, possibly deleting more nodes on the way.</p>&#13;
<p class="TX">Let’s consider a few cases. Returning to the example trie, if you want to delete BE, you’d clear its EOW link as shown in <a href="chapter16.xhtml#fig16-7">Figure 16-7</a>, and you’d be done.</p>&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_398" aria-label="398"/>&#13;
<figure class="IMG"><img class="img1" id="fig16-7" src="../images/Figure16-8.jpg" alt=""/>&#13;
<figcaption><p class="CAP"><span class="SANS_Futura_Std_Book_Oblique_11">Figure 16-7: Deleting BE from the trie</span></p></figcaption>&#13;
</figure>&#13;
<p class="TX">To make it more difficult, after deleting BE, what if you want to delete BADE? First you clear the EOW link, but then the whole node has only null links, as shown in <a href="chapter16.xhtml#fig16-8">Figure 16-8</a>.</p>&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_399" aria-label="399"/>&#13;
<figure class="IMG"><img class="img1" id="fig16-8" src="../images/Figure16-6.jpg" alt=""/>&#13;
<figcaption><p class="CAP"><span class="SANS_Futura_Std_Book_Oblique_11">Figure 16-8: Deleting BADE implies removing several (now empty) nodes from the trie.</span></p></figcaption>&#13;
</figure>&#13;
<p class="TX">However, removing that node (and clearing the E link at its parent) repeats the situation, so you also delete the parent, and then the parent’s parent, until you arrive at a not all-empty node. The final situation looks like <a href="chapter16.xhtml#fig16-9">Figure 16-9</a>.</p>&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_400" aria-label="400"/>&#13;
<figure class="IMG"><img class="img1" id="fig16-9" src="../images/Figure16-9.jpg" alt=""/>&#13;
<figcaption><p class="CAP"><span class="SANS_Futura_Std_Book_Oblique_11">Figure 16-9: The final trie after removing BADE</span></p></figcaption>&#13;
</figure>&#13;
<p class="TX">As with searching and adding, you need an auxiliary function to implement this:</p>&#13;
<pre id="pre-322"><code><span class="codeannotated_CodeAnnotation" aria-label="annotation1">❶</span> const _remove = (trie, [first, . . .rest]) =&gt; {&#13;
<span class="Code_CodeAnnotation" aria-label="annotation2">❷</span> if (isEmpty(trie)) {&#13;
    // nothing to do&#13;
  } else if (!first) {&#13;
  <span class="Code_CodeAnnotation" aria-label="annotation3">❸</span> trie = null;&#13;
  } else {&#13;
  <span class="Code_CodeAnnotation" aria-label="annotation4">❹</span> const i = ALPHABET.indexOf(first);&#13;
  <span class="Code_CodeAnnotation" aria-label="annotation5">❺</span> trie.links[i] = _remove(trie.links[i], rest);&#13;
  <span class="Code_CodeAnnotation" aria-label="annotation6">❻</span> if (trie.links.every((t) =&gt; isEmpty(t))) {&#13;
      trie = null;&#13;
    }&#13;
  }&#13;
<span class="Code_CodeAnnotation" aria-label="annotation7">❼</span> return trie;&#13;
};</code></pre>&#13;
<p class="TX">The <span class="SANS_TheSansMonoCd_W5Regular_11">_remove()</span> function does the actual removal <span class="CodeAnnotation" aria-label="annotation1">❶</span>. You search, link by link, and when you reach a null link, you know you’re done <span class="CodeAnnotation" aria-label="annotation2">❷</span>. If you reach the end of the word (past the EOW character), set the current link to <span class="SANS_TheSansMonoCd_W5Regular_11">null</span> <span class="CodeAnnotation" aria-label="annotation3">❸</span>. <span role="doc-pagebreak" epub:type="pagebreak" id="pg_401" aria-label="401"/>If you’re still in the middle of the word, decide what link to follow <span class="CodeAnnotation" aria-label="annotation4">❹</span>. Then recursively remove the rest of the word <span class="CodeAnnotation" aria-label="annotation5">❺</span> and do a final check to see whether the node is totally empty (all null), in which case, you also set the node to <span class="SANS_TheSansMonoCd_W5Regular_11">null</span> <span class="CodeAnnotation" aria-label="annotation6">❻</span>. At the end, just return the modified trie <span class="CodeAnnotation" aria-label="annotation7">❼</span>.</p>&#13;
<p class="TX">The final code you need is the following:</p>&#13;
<pre id="pre-323"><code>const remove = (trie, wordToRemove) =&gt; _remove(trie, wordToRemove + EOW);</code></pre>&#13;
<p class="TX">The <span class="SANS_TheSansMonoCd_W5Regular_11">remove()</span> function just calls <span class="SANS_TheSansMonoCd_W5Regular_11">_remove()</span>, and it adds the needed EOW character to the string you want to remove.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec6">&#13;
&#13;
<h4 class="H2" id="sec6"><span id="h2-158"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_11">Considering Performance for Tries</span></h4>&#13;
<p class="TNI1">How do the different operations perform? <a href="chapter16.xhtml#tab16-2">Table 16-2</a> is almost the simplest table in this book; can you see why?</p>&#13;
&#13;
<table class="table">&#13;
<caption><p class="TT" id="tab16-2"><span class="Heavy"><span class="SANS_Futura_Std_Heavy_11">Table 16-2:</span></span> <span class="SANS_Futura_Std_Book_11">Performance of Operations for Tries</span></p></caption>&#13;
<thead>&#13;
<tr>&#13;
<th class="TCH" scope="col"><p class="TCH1"><span class="SANS_Futura_Std_Heavy_11">Operation</span></p></th>&#13;
<th class="TCH" scope="col"><p class="TCH1"><span class="SANS_Futura_Std_Heavy_11">Performance</span></p></th>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr>&#13;
<td class="TBF"><p class="TBGREY"><span class="SANS_Futura_Std_Book_11">Create</span></p></td>&#13;
<td class="TBF"><p class="TBGREY"><span class="SANS_Futura_Std_Book_Oblique_11">O</span><span class="SANS_Futura_Std_Book_11">(1)</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">Empty?</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_Oblique_11">O</span><span class="SANS_Futura_Std_Book_11">(1)</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TB"><p class="TBGREY"><span class="SANS_Futura_Std_Book_11">Add</span></p></td>&#13;
<td class="TB"><p class="TBGREY"><span class="SANS_Futura_Std_Book_Oblique_11">O</span><span class="SANS_Futura_Std_Book_11">(</span><span class="SANS_Futura_Std_Book_Oblique_11">k</span><span class="SANS_Futura_Std_Book_11">)</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">Remove</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_Oblique_11">O</span><span class="SANS_Futura_Std_Book_11">(</span><span class="SANS_Futura_Std_Book_Oblique_11">k</span><span class="SANS_Futura_Std_Book_11">)</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TBL"><p class="TBGREY"><span class="SANS_Futura_Std_Book_11">Find</span></p></td>&#13;
<td class="TBL"><p class="TBGREY"><span class="SANS_Futura_Std_Book_Oblique_11">O</span><span class="SANS_Futura_Std_Book_11">(</span><span class="SANS_Futura_Std_Book_Oblique_11">k</span><span class="SANS_Futura_Std_Book_11">)</span></p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<p class="TX">Creating a trie and checking whether it’s empty are <i>O</i>(1) constant operations. And, given the structure, if keys are <i>k</i> characters long, all the other operations take (at most) <i>k</i> steps, which is the maximum height of a trie with such keys—excellent constant results! Note that the <i>O</i>(<i>k</i>) performance, with constant <i>k</i>, should be written as <i>O</i>(1). I wrote it as <i>O</i>(<i>k</i>) here just as a reminder that <i>k</i> steps will be taken, but in performance terms, any constant implies <i>O</i>(1).</p>&#13;
<p class="TX">However, despite having a very good performance, notice that this structure is quite wasteful. All the nodes have many links (as many characters as possible in the keys), making for a lot of unused space. Even worse with this structure, if you want to distinguish between uppercase and lowercase characters, or deal with the entire alphabet, or store words in foreign languages, the space requirements for nodes will grow wildly, because of the many links that each node will require.</p>&#13;
<p class="TX">This situation isn’t quite favorable, so let’s consider another approach to tries and aim for a more modern (and less wasteful) implementation, which JavaScript fortunately lets you do easily.</p>&#13;
</section>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec7">&#13;
&#13;
<h3 class="H1" id="sec7"><span id="h1-85"/><span class="SANS_Futura_Std_Bold_B_11">An Enhanced Version of Tries</span></h3>&#13;
<p class="TNI1">Consider again how to represent a trie. At each node, you need a link for each character in a string, but if only a few of those characters are actually <span role="doc-pagebreak" epub:type="pagebreak" id="pg_402" aria-label="402"/>necessary, you don’t need to waste space for the rest. In fact, it sounds like you need some kind of set here, and that’s indeed the solution.</p>&#13;
<p class="TX">If you have a large varying number of possible links, you should use some of the structures discussed in <span class="Xref"><a href="chapter13.xhtml">Chapter 13</a></span>. However, because alphabets are limited, you can use an object with characters for keys and links for values. (For yet another solution, see question 16.1.)</p>&#13;
<p class="TX">With the same six strings as in the previous trie (ACE, AD, BADE, BE, BED, and BEE), the structure looks like <a href="chapter16.xhtml#fig16-10">Figure 16-10</a>.</p>&#13;
<figure class="IMG"><img class="img1" id="fig16-10" src="../images/Figure16-10.jpg" alt=""/>&#13;
<figcaption><p class="CAP"><span class="SANS_Futura_Std_Book_Oblique_11">Figure 16-10: An enhanced object-based version of a trie with fewer links</span></p></figcaption>&#13;
</figure>&#13;
<p class="TX">The main difference is now the nodes can be much smaller, including only the strictly necessary links and nothing more.</p>&#13;
<section epub:type="division" aria-labelledby="sec8">&#13;
&#13;
<h4 class="H2" id="sec8"><span id="h2-159"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_11">Defining an Object-Based Trie</span></h4>&#13;
<p class="TNI1">Instead of having an array of links, you can define this new style of space-saving tries using an object:</p>&#13;
<pre id="pre-324"><code>const EOW = "■";&#13;
const newTrie = () =&gt; null;&#13;
<b>const newNode = () =&gt; ({links: {}});</b>&#13;
const isEmpty = (trie) =&gt; !trie; // null or undefined</code></pre>&#13;
<p class="TX">You need to make only one simple change from the previous trie (shown in bold): a new node now has an object named <span class="SANS_TheSansMonoCd_W5Regular_11">links</span> instead of an array with that name.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec9">&#13;
&#13;
<h4 class="H2" id="sec9"><span id="h2-160"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_11">Searching an Object-Based Trie</span></h4>&#13;
<p class="TNI1">The process for searching an object-based trie for a key is similar to searching a classic trie: start at the root and follow the links that correspond to each character in the string, one by one. Instead of an array with links to all possible characters, you have an object with only the links actually required. For instance, revisit the BED search in <a href="chapter16.xhtml#fig16-11">Figure 16-11</a>.</p>&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_403" aria-label="403"/>&#13;
<figure class="IMG"><img class="img1" id="fig16-11" src="../images/Figure16-11.jpg" alt=""/>&#13;
<figcaption><p class="CAP"><span class="SANS_Futura_Std_Book_Oblique_11">Figure 16-11: Searching successfully for BED in an object-based trie</span></p></figcaption>&#13;
</figure>&#13;
<p class="TX">Starting at the root in the links object, follow the B link. At the next node, follow the E link, and so on, until reaching the EOW link. Then you know the key was found and can return the associated data, whatever it is.</p>&#13;
<p class="TX">Try redoing a failed search as well, as shown in <a href="chapter16.xhtml#fig16-12">Figure 16-12</a>.</p>&#13;
<figure class="IMG"><img class="img1" id="fig16-12" src="../images/Figure16-12.jpg" alt=""/>&#13;
<figcaption><p class="CAP"><span class="SANS_Futura_Std_Book_Oblique_11">Figure 16-12: Searching unsuccessfully for ACED in an object-based trie</span></p></figcaption>&#13;
</figure>&#13;
<p class="TX">If you search for ACED, the process stops after following the last E link. The node you arrive at doesn’t have a D link, so you can’t proceed, as the key you want isn’t in the trie.</p>&#13;
<p class="TX">Searching object-based tries isn’t really different from searching the original tries; the only change is how you choose the link to follow. The following logic shows the needed changes:</p>&#13;
<pre id="pre-325"><code>const _find = (trie, [first, . . .rest]) =&gt; {&#13;
  if (isEmpty(trie)) {&#13;
    return null;&#13;
  } else if (first === EOW) {&#13;
<b>    return isEmpty(trie.links[first]) ? null : trie.links[first].data;</b>&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_404" aria-label="404"/><b>  } else {</b>&#13;
<b>    return _find(trie.links[first], rest);</b>&#13;
  }&#13;
};&#13;
&#13;
const find = (trie, wordToFind) =&gt;&#13;
  !!wordToFind &amp;&amp; _find(trie, wordToFind + EOW);</code></pre>&#13;
<p class="TX">In comparison with the original trie search code, you have only two changes (shown in bold): you can access the needed link directly without having to check the alphabet first—for example, the link for the letter A is at <span class="SANS_TheSansMonoCd_W5Regular_11">links.A</span>, (or, equivalently, <span class="SANS_TheSansMonoCd_W5Regular_11">links["A"]</span>) with no further ado. The <span class="SANS_TheSansMonoCd_W5Regular_11">find()</span> function itself is exactly the same as with the original tries.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec10">&#13;
&#13;
<h4 class="H2" id="sec10"><span id="h2-161"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_11">Adding a Key to an Object-Based Trie</span></h4>&#13;
<p class="TNI1">Adding a key is also similar to the algorithm for the original tries. The changes you need to make work like those you made for searching. For instance, consider adding ABE, as shown in <a href="chapter16.xhtml#fig16-13">Figure 16-13</a>.</p>&#13;
<figure class="IMG"><img class="img1" id="fig16-13" src="../images/Figure16-13.jpg" alt=""/>&#13;
<figcaption><p class="CAP"><span class="SANS_Futura_Std_Book_Oblique_11">Figure 16-13: Adding ABE to an object-based trie</span></p></figcaption>&#13;
</figure>&#13;
<p class="TX">Start following links as you did with the search, and when links don’t appear, add them. In this case, the root already has an A link, so you follow it. The next node has no B link, so add it to the existing (C and D) links. From that point onward, start adding new nodes to the trie.</p>&#13;
<p class="TX">It’s the same process as for the original tries; here’s the new logic:</p>&#13;
<pre id="pre-326"><code>const _add = (trie, [first, . . .rest], data) =&gt; {&#13;
  if (first) {&#13;
    if (isEmpty(trie)) {&#13;
      trie = newNode();&#13;
    }&#13;
    if (first === EOW) {&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_405" aria-label="405"/><b>      trie.links[first] = {data};</b>&#13;
    } else {&#13;
<b>      trie.links[first] = _add(trie.links[first], rest, data);</b>&#13;
    }&#13;
  }&#13;
  return trie;&#13;
};&#13;
&#13;
const add = (trie, wordToAdd, dataToAdd = wordToAdd) =&gt;&#13;
  _add(trie, wordToAdd + EOW, dataToAdd);</code></pre>&#13;
<p class="TX">Again, the only difference in the logic from the original tries is that you always know what link to use for a given character, so you don’t need to search the <span class="SANS_TheSansMonoCd_W5Regular_11">ALPHABET</span> array (shown in bold).</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec11">&#13;
&#13;
<h4 class="H2" id="sec11"><span id="h2-162"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_11">Removing a Key from an Object-Based Trie</span></h4>&#13;
<p class="TNI1">Finally, removing a key is also similar to the previous code for original tries, but deciding whether the node is empty requires a different approach. For example, if you want to remove BADE from the original trie, you’ll get the result shown in <a href="chapter16.xhtml#fig16-14">Figure 16-14</a>.</p>&#13;
<figure class="IMG"><img class="img1" id="fig16-14" src="../images/Figure16-14.jpg" alt=""/>&#13;
<figcaption><p class="CAP"><span class="SANS_Futura_Std_Book_Oblique_11">Figure 16-14: Removing BADE from an object-based trie</span></p></figcaption>&#13;
</figure>&#13;
<p class="TX">As with the previous array-based trie implementation, when nodes become empty, you delete them. The updated logic is as follows:</p>&#13;
<pre id="pre-327"><code>const _remove = (trie, [first, . . .rest]) =&gt; {&#13;
  if (isEmpty(trie)) {&#13;
    // nothing to do&#13;
  } else if (!first) {&#13;
    trie = null;&#13;
  } else {&#13;
  <span class="Code_CodeAnnotation" aria-label="annotation1">❶</span> trie.links[first] = _remove(trie.links[first], rest);&#13;
    if (isEmpty(trie.links[first])) {&#13;
    <span class="Code_CodeAnnotation" aria-label="annotation2">❷</span> delete trie.links[first];&#13;
    <span class="Code_CodeAnnotation" aria-label="annotation3">❸</span> if (Object.keys(trie.links).length === 0) {&#13;
        trie = null;&#13;
      }&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_406" aria-label="406"/>    }&#13;
  }&#13;
  return trie;&#13;
};&#13;
&#13;
const remove = (trie, wordToRemove) =&gt; _remove(trie, wordToRemove + EOW);</code></pre>&#13;
<p class="TX">Most of the differences with the logic for original tries <span class="CodeAnnotation" aria-label="annotation1">❶</span> <span class="CodeAnnotation" aria-label="annotation2">❷</span> are directly related to knowing what link to use, but in order to decide whether a node became empty, you need to see how many keys the <span class="SANS_TheSansMonoCd_W5Regular_11">links</span> object has <span class="CodeAnnotation" aria-label="annotation3">❸</span>.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec12">&#13;
&#13;
<h4 class="H2" id="sec12"><span id="h2-163"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_11">Considering Performance for Object-Based Tries</span></h4>&#13;
<p class="TNI1">What changes with this new version of a trie? Performance is exactly the same as for the array-based tries; the only difference is the amount of memory needed. Think of it this way: if you were using a trie for a dictionary of European languages (with all the tildes, accents, and special characters, like the Danish <span class="accent">å</span>, or the Czech <span class="kerning_ewithcaron">e</span><span class="kerning_caronwithe">ˇ</span>, or the German <span class="accent">ß</span>), you would need an array with more than 200 links in each node, although most of them would be empty. Using an object saves a lot of space, which could be important in some cases.</p>&#13;
<p class="TX">However, using objects instead of arrays isn’t as efficient as it could be. After all, if the keys are long, you still need a very tall trie. As a border case, imagine having a trie with a single key that’s 20 characters long. You’d have a 20-level-high tree for one single key. Radix trees provide an enhanced solution.</p>&#13;
</section>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec13">&#13;
&#13;
<h3 class="H1" id="sec13"><span id="h1-86"/><span class="SANS_Futura_Std_Bold_B_11">Radix Trees</span></h3>&#13;
<p class="TNI1">Both the tries so far work well, but they have many levels. For instance, when looking for BADE in the example trie, you have to go down one level for each letter, while there are no other words that start with A; see <a href="chapter16.xhtml#fig16-15">Figure 16-15</a>.</p>&#13;
<figure class="IMG"><img class="img1" id="fig16-15" src="../images/Figure16-15.jpg" alt=""/>&#13;
<figcaption><p class="CAP"><span class="SANS_Futura_Std_Book_Oblique_11">Figure 16-15: Searching successfully for BADE in a trie requires many steps.</span></p></figcaption>&#13;
</figure>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_407" aria-label="407"/>The idea for radix trees is that if any level has a single link, we “push it up” and join it with its parent link to shorten future searches. <a href="chapter16.xhtml#fig16-16">Figure 16-16</a> shows what a radix tree for the ACE, AD, BADE, BE, BED, and BEE sets of words looks like.</p>&#13;
<figure class="IMG"><img class="img7" id="fig16-16" src="../images/Figure16-16.jpg" alt=""/>&#13;
<figcaption><p class="CAP"><span class="SANS_Futura_Std_Book_Oblique_11">Figure 16-16: A radix tree shortens searches by joining links.</span></p></figcaption>&#13;
</figure>&#13;
<p class="TX">Now, you would have found BADE in just two steps. This tree is shorter than all previous tries. Some paths (for example, B to E to BE) are still the same length, but most others are shorter, because some levels have multicharacter links. Let’s explore how these trees would be defined and used, because they’ll represent a more performant kind of digital tree.</p>&#13;
<section epub:type="division" aria-labelledby="sec14">&#13;
&#13;
<h4 class="H2" id="sec14"><span id="h2-164"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_11">Defining a Radix Tree</span></h4>&#13;
<p class="TNI1">If you use an object to store links, like you did with the object-based tries, you find that the logic for radix trees is exactly the same. The difference is in <i>how</i> you use the links (they won’t always be single-character links), but otherwise the structure is the same:</p>&#13;
<pre id="pre-328"><code>const EOW = "■";&#13;
const newRadixTree = () =&gt; null;&#13;
const newNode = () =&gt; ({links: {}});&#13;
const isEmpty = (rt) =&gt; !rt;</code></pre>&#13;
<p class="TX">Since there are no changes here with regard to the previous object-based tries code, let’s move on to working with these new trees.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec15">&#13;
&#13;
<h4 class="H2" id="sec15"><span id="h2-165"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_11">Searching a Radix Tree</span></h4>&#13;
<p class="TNI1">Doing searches is similar to what you did for object-based tries, but now that the links may correspond to many characters, you need to work a bit differently. Start with a simple case: searching for BED—or, more precisely, BED<span class="SANS_TheSansMonoCd_W5Regular_11">■</span>. <a href="chapter16.xhtml#fig16-17">Figure 16-17</a> shows the path to follow.</p>&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_408" aria-label="408"/>&#13;
<figure class="IMG"><img class="img7" id="fig16-17" src="../images/Figure16-17.jpg" alt=""/>&#13;
<figcaption><p class="CAP"><span class="SANS_Futura_Std_Book_Oblique_11">Figure 16-17: Searching successfully for BED in a radix tree</span></p></figcaption>&#13;
</figure>&#13;
<p class="TX">At the root, you need to find a link that is a prefix of BED<span class="SANS_TheSansMonoCd_W5Regular_11">■</span>. In this case, follow a B link to the next level. (If you don’t find such a link, declare the search unsuccessful right then.) Since you followed a B link, next search for ED<span class="SANS_TheSansMonoCd_W5Regular_11">■</span>. Again, you find a link that matches the search and follow that E link to the third level, where you look for D<span class="SANS_TheSansMonoCd_W5Regular_11">■</span>. At this point, you find a complete match, so you found the key and can return its data. You’re done!</p>&#13;
<p class="TX">As another example, look for ACED<span class="SANS_TheSansMonoCd_W5Regular_11">■</span>, which will be a failed search (see <a href="chapter16.xhtml#fig16-18">Figure 16-18</a>).</p>&#13;
<figure class="IMG"><img class="img7" id="fig16-18" src="../images/Figure16-18.jpg" alt=""/>&#13;
<figcaption><p class="CAP"><span class="SANS_Futura_Std_Book_Oblique_11">Figure 16-18: Searching unsuccessfully for ACED in a radix tree</span></p></figcaption>&#13;
</figure>&#13;
<p class="TX">What happens here? At the first level, you find an A link to follow, so you then look for CED<span class="SANS_TheSansMonoCd_W5Regular_11">■</span> at the second level. However, you don’t find any link that has the search string’s prefix, you fail. If you were searching for CAB<span class="SANS_TheSansMonoCd_W5Regular_11">■</span>, you’d have the same problem, but at the root, because no link has a prefix with that string.</p>&#13;
<p class="TX">The idea is that you move down the tree, level by level, matching prefixes to links. Given two strings, you first need an auxiliary function to find how many characters they have in common from the start. For example, if you have BEE and BADE, you’d have only one character in common (B). If you have ACED and ACAD, you’d have two characters in common (the initial AC characters).</p>&#13;
<p class="TX">The auxiliary function looks like this:</p>&#13;
<pre id="pre-329"><code>const _commonLength = (str1, str2) =&gt; {&#13;
  let i = 0;&#13;
<span class="Code_CodeAnnotation" aria-label="annotation1">❶</span> while (str1[i] &amp;&amp; str1[i] === str2[i]) {&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_409" aria-label="409"/>  <span class="Code_CodeAnnotation" aria-label="annotation2">❷</span> i++;&#13;
  }&#13;
  return i;&#13;
};</code></pre>&#13;
<p class="Continued">Start by comparing characters from the beginning <span class="CodeAnnotation" aria-label="annotation1">❶</span> and count <span class="CodeAnnotation" aria-label="annotation2">❷</span> until the strings end or stop matching.</p>&#13;
<p class="TX">With this function, you can start searching:</p>&#13;
<pre id="pre-330"><code>const _find = (trie, wordToFind) =&gt; {&#13;
<span class="Code_CodeAnnotation" aria-label="annotation1">❶</span> if (isEmpty(trie)) {&#13;
    return false;&#13;
  } else {&#13;
  <span class="Code_CodeAnnotation" aria-label="annotation2">❷</span> const linkWord = Object.keys(trie.links).find(&#13;
      (v) =&gt; v[0] === wordToFind[0]&#13;
    );&#13;
&#13;
  <span class="Code_CodeAnnotation" aria-label="annotation3">❸</span> if (linkWord) {&#13;
    <span class="Code_CodeAnnotation" aria-label="annotation4">❹</span> if (wordToFind === linkWord) {&#13;
        return trie.links[linkWord].data;&#13;
      } else {&#13;
      <span class="Code_CodeAnnotation" aria-label="annotation5">❺</span> const common = _commonLength(linkWord, wordToFind);&#13;
      <span class="Code_CodeAnnotation" aria-label="annotation6">❻</span> return _find(&#13;
          trie.links[linkWord.substring(0, common)],&#13;
          wordToFind.substring(common)&#13;
        );&#13;
      }&#13;
  <span class="Code_CodeAnnotation" aria-label="annotation7">❼</span>} else {&#13;
      return false;&#13;
    }&#13;
  }&#13;
};</code></pre>&#13;
<p class="TX">If the tree is empty, the key obviously can’t be there <span class="CodeAnnotation" aria-label="annotation1">❶</span>. To see whether a link is a prefix of the search key, first find the (only) object key that matches the first character <span class="CodeAnnotation" aria-label="annotation2">❷</span>, because you can’t have two or more keys with the same initial character in a node (it would break the structure). If you find such a link <span class="CodeAnnotation" aria-label="annotation3">❸</span>, check whether it actually has the complete string you need <span class="CodeAnnotation" aria-label="annotation4">❹</span>; if so, you’re done. If the link doesn’t match the whole string, find the common prefix <span class="CodeAnnotation" aria-label="annotation5">❺</span> and recursively search for the rest of the string <span class="CodeAnnotation" aria-label="annotation6">❻</span>. On the other hand, if you don’t find a link matching the initial character of the string, the search fails <span class="CodeAnnotation" aria-label="annotation7">❼</span>.</p>&#13;
<p class="TX">The main <span class="SANS_TheSansMonoCd_W5Regular_11">find()</span> function is the same as with object-based tries:</p>&#13;
<pre id="pre-331"><code>const find = (trie, wordToFind) =&gt;&#13;
  !!wordToFind &amp;&amp; _find(trie, wordToFind + EOW);</code></pre>&#13;
<p class="TX">The logic for searching radix tries is similar to the logic used for tries, except matching links is a bit more complex.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec16">&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_410" aria-label="410"/>&#13;
<h4 class="H2" id="sec16"><span id="h2-166"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_11">Adding a Key to a Radix Tree</span></h4>&#13;
<p class="TNI1">The problem with adding new keys to radix trees is if there’s some previously added key that matches part of the key you want to add. Start with a simple case: adding ABE<span class="SANS_TheSansMonoCd_W5Regular_11">■</span> as with the original radix tree (see <a href="chapter16.xhtml#fig16-19">Figure 16-19</a>).</p>&#13;
<figure class="IMG"><img class="img7" id="fig16-19" src="../images/Figure16-19.jpg" alt=""/>&#13;
<figcaption><p class="CAP"><span class="SANS_Futura_Std_Book_Oblique_11">Figure 16-19: Adding ABE to a radix tree: initial structure</span></p></figcaption>&#13;
</figure>&#13;
<p class="TX">First, search for the string as shown in the previous section, and after following the A link, you arrive at a node with no links matching the BE<span class="SANS_TheSansMonoCd_W5Regular_11">■</span> prefix. This means you simply can stop searching right here and add the new link in that place.</p>&#13;
<p class="TX"><a href="chapter16.xhtml#fig16-20">Figure 16-20</a> shows the more complex case of adding BAD to the tree updated in <a href="chapter16.xhtml#fig16-19">Figure 16-19</a>.</p>&#13;
<figure class="IMG"><img class="img7" id="fig16-20" src="../images/Figure16-20.jpg" alt=""/>&#13;
<figcaption><p class="CAP"><span class="SANS_Futura_Std_Book_Oblique_11">Figure 16-20: Adding BAD to a radix tree requires splitting some links.</span></p></figcaption>&#13;
</figure>&#13;
<p class="TX">The difference here is that after following the B link, you find there already was a partial match (ADE<span class="SANS_TheSansMonoCd_W5Regular_11">■</span>), so now you need to do a split: the common prefix (AD) remains in the node, and you create a new node with the rest of the keys.</p>&#13;
<p class="TX">The logic thus needs to deal with two cases: not finding a prefix (as with ABE) or finding a partial match (as with BADE). Here’s the code:</p>&#13;
<pre id="pre-332"><code><span role="doc-pagebreak" epub:type="pagebreak" id="pg_411" aria-label="411"/>const _add = (trie, wordToAdd, data) =&gt; {&#13;
<span class="Code_CodeAnnotation" aria-label="annotation1">❶</span> if (wordToAdd) {&#13;
  <span class="Code_CodeAnnotation" aria-label="annotation2">❷</span> if (isEmpty(trie)) {&#13;
      trie = newNode();&#13;
      trie.links[wordToAdd] = {data};&#13;
    } else {&#13;
    <span class="Code_CodeAnnotation" aria-label="annotation3">❸</span> const linkWord = Object.keys(trie.links).find(&#13;
        (v) =&gt; v[0] === wordToAdd[0]&#13;
      );&#13;
    <span class="Code_CodeAnnotation" aria-label="annotation4">❹</span> if (linkWord) {&#13;
        const common = _commonLength(linkWord, wordToAdd);&#13;
        const prefix = linkWord.substring(0, common);&#13;
        const oldSuffix = linkWord.substring(common);&#13;
        const newSuffix = wordToAdd.substring(common);&#13;
&#13;
      <span class="Code_CodeAnnotation" aria-label="annotation5">❺</span> if (linkWord === prefix) {&#13;
          trie.links[linkWord] = _add(trie.links[linkWord], newSuffix, data);&#13;
        } else {&#13;
        <span class="Code_CodeAnnotation" aria-label="annotation6">❻</span> trie.links[prefix] = {&#13;
            links: {&#13;
              [oldSuffix]: trie.links[linkWord],&#13;
              [newSuffix]: {data}&#13;
            }&#13;
          };&#13;
        <span class="Code_CodeAnnotation" aria-label="annotation7">❼</span> delete trie.links[linkWord];&#13;
        }&#13;
      } else {&#13;
      <span class="Code_CodeAnnotation" aria-label="annotation8">❽</span> trie.links[wordToAdd] = {data};&#13;
      }&#13;
    }&#13;
  }&#13;
<span class="Code_CodeAnnotation" aria-label="annotation9">❾</span> return trie;&#13;
};</code></pre>&#13;
<p class="TX">First check whether you are adding a nonempty string <span class="CodeAnnotation" aria-label="annotation1">❶</span>; if not, return the trie unchanged <span class="CodeAnnotation" aria-label="annotation9">❾</span>. If you have a string to insert, check whether the tree is empty <span class="CodeAnnotation" aria-label="annotation2">❷</span>, because if it’s empty, create a new node with the single key, and you are done. If the tree isn’t empty, search for an existing key that matches at least the first character <span class="CodeAnnotation" aria-label="annotation3">❸</span> (as shown previously). If you don’t find one, create a new node <span class="CodeAnnotation" aria-label="annotation8">❽</span>; otherwise, check whether the found key matches what you’re inserting in full or in part <span class="CodeAnnotation" aria-label="annotation4">❹</span> by splitting the key according to the common length you found. If the match is in full <span class="CodeAnnotation" aria-label="annotation5">❺</span>, follow the link to insert the rest of the string; otherwise <span class="CodeAnnotation" aria-label="annotation6">❻</span>, do a split, leaving the common prefix in the node by adding a new node and deleting the old key <span class="CodeAnnotation" aria-label="annotation7">❼</span>.</p>&#13;
<p class="TX">The rest of the logic is the same as for the other tries:</p>&#13;
<pre id="pre-333"><code>const add = (trie, wordToAdd, dataToAdd = wordToAdd) =&gt;&#13;
  _add(trie, wordToAdd + EOW, dataToAdd);</code></pre>&#13;
<p class="TX">You have now seen how to add a new key, which had two distinct cases; now see what happens with the reverse algorithm to remove a key from a radix tree.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec17">&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_412" aria-label="412"/>&#13;
<h4 class="H2" id="sec17"><span id="h2-167"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_11">Removing a Key from a Radix Tree</span></h4>&#13;
<p class="TNI1">Continuing with the same radix tree that was updated in <a href="chapter16.xhtml#fig16-20">Figure 16-20</a>, consider two cases for removing keys: removing a link from a node, leaving it with two or more links, and removing a link from a node, leaving it with a single link. Take a look at the simpler former case first (<a href="chapter16.xhtml#fig16-21">Figure 16-21</a>).</p>&#13;
<figure class="IMG"><img class="img7" id="fig16-21" src="../images/Figure16-21.jpg" alt=""/>&#13;
<figcaption><p class="CAP"><span class="SANS_Futura_Std_Book_Oblique_11">Figure 16-21: The radix tree from which you’ll remove ACE</span></p></figcaption>&#13;
</figure>&#13;
<p class="TX">To remove ACE from the radix tree, search for it, and when you arrive at the final link, simply remove it. The tree would look like <a href="chapter16.xhtml#fig16-22">Figure 16-22</a>.</p>&#13;
<figure class="IMG"><img class="img7" id="fig16-22" src="../images/Figure16-22.jpg" alt=""/>&#13;
<figcaption><p class="CAP"><span class="SANS_Futura_Std_Book_Oblique_11">Figure 16-22: Removing ACE requires removing only a link.</span></p></figcaption>&#13;
</figure>&#13;
<p class="TX">However, what if you want to remove BADE? Remember, if you have a single link, you need to join it with the parent link, as shown in <a href="chapter16.xhtml#fig16-23">Figure 16-23</a>.</p>&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_413" aria-label="413"/>&#13;
<figure class="IMG"><img class="img7" id="fig16-23" src="../images/Figure16-23.jpg" alt=""/>&#13;
<figcaption><p class="CAP"><span class="SANS_Futura_Std_Book_Oblique_11">Figure 16-23: Removing BADE requires more work.</span></p></figcaption>&#13;
</figure>&#13;
<p class="TX">After searching for BADE and removing the last link (E<span class="SANS_TheSansMonoCd_W5Regular_11">■</span>), the final node ended up with only an EOW link. You then push it up so that it joins with its parent, which is an AD link. Doing this reverses the kind of split you did when adding new keys.</p>&#13;
<p class="TX">Consider the actual logic. You need an auxiliary <span class="SANS_TheSansMonoCd_W5Regular_11">_remove()</span> function, as in the other cases, to remove the desired key:</p>&#13;
<pre id="pre-334"><code>const _remove = (trie, wordToRemove) =&gt; {&#13;
<span class="Code_CodeAnnotation" aria-label="annotation1">❶</span> if (!isEmpty(trie) &amp;&amp; wordToRemove &gt; "") {&#13;
  <span class="Code_CodeAnnotation" aria-label="annotation2">❷</span> const linkWord = Object.keys(trie.links).find(&#13;
      (v) =&gt; v[0] === wordToRemove[0]&#13;
    );&#13;
  <span class="Code_CodeAnnotation" aria-label="annotation3">❸</span> if (linkWord &amp;&amp; wordToRemove.startsWith(linkWord)) {&#13;
      const common = _commonLength(linkWord, wordToRemove);&#13;
      const prefix = linkWord.substring(0, common);&#13;
&#13;
    <span class="Code_CodeAnnotation" aria-label="annotation4">❹</span> if (wordToRemove === prefix) {&#13;
        delete trie.links[prefix];&#13;
    <span class="Code_CodeAnnotation" aria-label="annotation5">❺</span>} else {&#13;
        trie.links[prefix] = _remove(&#13;
          trie.links[prefix],&#13;
          wordToRemove.substring(common)&#13;
        );&#13;
      <span class="Code_CodeAnnotation" aria-label="annotation6">❻</span> if (Object.keys(trie.links[prefix].links).length === 1) {&#13;
          const single = Object.keys(trie.links[prefix].links)[0];&#13;
          trie.links[prefix + single] = trie.links[prefix].links[single];&#13;
          delete trie.links[prefix];&#13;
        }&#13;
      }&#13;
    }&#13;
  }&#13;
<span class="Code_CodeAnnotation" aria-label="annotation7">❼</span> return trie;&#13;
};</code></pre>&#13;
<p class="TX">Start by checking whether you’re done, which means reaching an empty link or the end of the word you’re removing <span class="CodeAnnotation" aria-label="annotation1">❶</span>. If you aren’t finished, search for a link that has a common prefix with the word you’re removing <span class="CodeAnnotation" aria-label="annotation2">❷</span> as described earlier. If you don’t find one, you’re also done, because the <span role="doc-pagebreak" epub:type="pagebreak" id="pg_414" aria-label="414"/>word you’re removing isn’t in the trie. If you find a suitable prefix <span class="CodeAnnotation" aria-label="annotation3">❸</span>, you have two possibilities: you’ve found the whole word or part of the word. In the former case <span class="CodeAnnotation" aria-label="annotation4">❹</span>, delete the link; no more work is needed. In the latter case <span class="CodeAnnotation" aria-label="annotation5">❺</span>, search for and remove the rest of the word, discounting the prefix already found (you’ll do this recursively). After that, check whether the trie ended with a single key <span class="CodeAnnotation" aria-label="annotation6">❻</span>, in which case, join its only key with the prefix you found. Finally, return the updated trie <span class="CodeAnnotation" aria-label="annotation7">❼</span>.</p>&#13;
<p class="TX">With this function out of the way, you can code the <span class="SANS_TheSansMonoCd_W5Regular_11">remove()</span> function:</p>&#13;
<pre id="pre-335"><code>const remove = (trie, wordToRemove) =&gt; {&#13;
<span class="Code_CodeAnnotation" aria-label="annotation1">❶</span> if (!isEmpty(trie)) {&#13;
  <span class="Code_CodeAnnotation" aria-label="annotation2">❷</span> _remove(trie, wordToRemove + EOW);&#13;
  <span class="Code_CodeAnnotation" aria-label="annotation3">❸</span> if (Object.keys(trie.links).length === 0) {&#13;
      trie = null;&#13;
    }&#13;
  }&#13;
  return trie;&#13;
};</code></pre>&#13;
<p class="TX">If the trie isn’t empty <span class="CodeAnnotation" aria-label="annotation1">❶</span>, use the auxiliary function to remove the key from the tree <span class="CodeAnnotation" aria-label="annotation2">❷</span> and then a final check remains: if the root became empty <span class="CodeAnnotation" aria-label="annotation3">❸</span>, the trie is null.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec18">&#13;
&#13;
<h4 class="H2" id="sec18"><span id="h2-168"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_11">Considering Performance for Radix Trees</span></h4>&#13;
<p class="TNI1">Radix trees are like “compressed” versions of tries. They’re faster when nodes include longer strings, and at worst, they behave the same way as tries if all links are “single-character” links. This means you don’t need to do much analysis. <a href="chapter16.xhtml#tab16-3">Table 16-3</a> shows the performance.</p>&#13;
&#13;
<table class="table">&#13;
<caption><p class="TT" id="tab16-3"><span class="Heavy"><span class="SANS_Futura_Std_Heavy_11">Table 16-3:</span></span> <span class="SANS_Futura_Std_Book_11">Performance of Operations for Radix Trees</span></p></caption>&#13;
<thead>&#13;
<tr>&#13;
<th class="TCH" scope="col"><p class="TCH1"><span class="SANS_Futura_Std_Heavy_11">Operation</span></p></th>&#13;
<th class="TCH" scope="col"><p class="TCH1"><span class="SANS_Futura_Std_Heavy_11">Performance</span></p></th>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr>&#13;
<td class="TBF"><p class="TBGREY"><span class="SANS_Futura_Std_Book_11">Create</span></p></td>&#13;
<td class="TBF"><p class="TBGREY"><span class="SANS_Futura_Std_Book_Oblique_11">O</span><span class="SANS_Futura_Std_Book_11">(1)</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">Empty?</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_Oblique_11">O</span><span class="SANS_Futura_Std_Book_11">(1)</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TB"><p class="TBGREY"><span class="SANS_Futura_Std_Book_11">Add</span></p></td>&#13;
<td class="TB"><p class="TBGREY"><span class="SANS_Futura_Std_Book_Oblique_11">O</span><span class="SANS_Futura_Std_Book_11">(1)</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">Remove</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_Oblique_11">O</span><span class="SANS_Futura_Std_Book_11">(1)</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TBL"><p class="TB1"><span class="SANS_Futura_Std_Book_11">Find</span></p></td>&#13;
<td class="TBL"><p class="TB1"><span class="SANS_Futura_Std_Book_Oblique_11">O</span><span class="SANS_Futura_Std_Book_11">(1)</span></p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<p class="TX">The results for radix trees are the same as for tries: all operations are <i>O</i>(1).</p>&#13;
</section>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec19">&#13;
&#13;
<h3 class="H1" id="sec19"><span id="h1-87"/><span class="SANS_Futura_Std_Bold_B_11">Ternary Search Tries</span></h3>&#13;
<p class="TNI1">Tries and radix trees are based on the idea of storing keys “down the links.” You can also apply this idea to <i>ternary trees</i>, a new structure that saves space and provides good performance. We mentioned ternary trees in <span class="Xref"><a href="chapter13.xhtml">Chapter 13</a></span>, as a generalization of binary trees having three links at each node instead <span role="doc-pagebreak" epub:type="pagebreak" id="pg_415" aria-label="415"/>of two, but we didn’t actually work with them. The idea is that with a ternary search tree, each node has a key (a single character) and three links:</p>&#13;
<ul class="ul">&#13;
<li class="ListBullet">The left link is for strings whose current character is less than the node key.</li>&#13;
<li class="ListBullet">The middle link is for strings whose current character is equal to the node key.</li>&#13;
<li class="ListBullet">The right link is for strings whose current character is greater than the node key.</li>&#13;
</ul>&#13;
<p class="TX"><a href="chapter16.xhtml#fig16-24">Figure 16-24</a> shows a ternary search tree.</p>&#13;
<figure class="IMG"><img class="img7" id="fig16-24" src="../images/Figure16-24.jpg" alt=""/>&#13;
<figcaption><p class="CAP"><span class="SANS_Futura_Std_Book_Oblique_11">Figure 16-24: A ternary search tree with seven words</span></p></figcaption>&#13;
</figure>&#13;
<p class="TX">Try to follow the path to every word; you’ll then understand the difference between the middle links and the right and left links. The following sections explain this in detail.</p>&#13;
<section epub:type="division" aria-labelledby="sec20">&#13;
&#13;
<h4 class="H2" id="sec20"><span id="h2-169"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_11">Defining Ternary Tries</span></h4>&#13;
<p class="TNI1">We’ve already considered binary search trees, and defining a ternary tree is similar. All you need to do is add a middle link:</p>&#13;
<pre id="pre-336"><code>const EOW = "■";&#13;
&#13;
const newTernary = () =&gt; null;&#13;
&#13;
const newNode = (key) =&gt; ({&#13;
  key,&#13;
  left: null,&#13;
  right: null,&#13;
  middle: null&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_416" aria-label="416"/>});&#13;
&#13;
const isEmpty = (tree) =&gt; tree === null;</code></pre>&#13;
<p class="TX">Creating ternary trees is quite simple, but storing extra data and doing searches require some changes.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec21">&#13;
&#13;
<h4 class="H2" id="sec21"><span id="h2-170"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_11">Storing Extra Data in a Ternary Trie</span></h4>&#13;
<p class="TNI1">With ternary tries, you have the same issue as with other common trees. You could store extra data next to the key, but again you have the problem that keys aren’t stored in any single place, as they are with search trees; the keys are spread all over the trie.</p>&#13;
<p class="TX">To alleviate this complication, reapply the solution used for tries. When you reach the EOW character, use its middle pointer to store extra data:</p>&#13;
<pre id="pre-337"><code>tree.middle = {data};</code></pre>&#13;
<p class="TX">Of course, if you’re using the ternary trie just to store the keys and don’t care about extra data (for example, if you were using a ternary trie to look up words to see whether they exist in a Scrabble application to check a weird-looking word your opponent entered), you can omit that line and modify the search function (which you’ll look at next) to return only true or false.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec22">&#13;
&#13;
<h4 class="H2" id="sec22"><span id="h2-171"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_11">Searching a Ternary Trie</span></h4>&#13;
<p class="TNI1">Given how we designed ternary tries, it should be no surprise that searching for a key in a ternary trie is similar to the logic for binary search trees (see <span class="Xref"><a href="chapter12.xhtml">Chapter 12</a></span>). As an example, <a href="chapter16.xhtml#fig16-25">Figure 16-25</a> shows how to look for the word AD (you’ll actually search for AD<span class="SANS_TheSansMonoCd_W5Regular_11">■</span>, with the appended EOW character).</p>&#13;
<figure class="IMG"><img class="img7" id="fig16-25" src="../images/Figure16-25.jpg" alt=""/>&#13;
<figcaption><p class="CAP"><span class="SANS_Futura_Std_Book_Oblique_11">Figure 16-25: Searching successfully for AD in a ternary trie</span></p></figcaption>&#13;
</figure>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_417" aria-label="417"/>The search starts at the root, which has a B. Since A (the first letter in AD<span class="SANS_TheSansMonoCd_W5Regular_11">■</span>) is less than B, follow the left link. Then you find an A, so go down the middle link, looking for the rest of the string, which is D<span class="SANS_TheSansMonoCd_W5Regular_11">■</span>. You find a C, so go down the right link. Then you find a D, so now go down the middle, looking for the EOW character. After finding it, successfully return the associated data.</p>&#13;
<p class="TX">If you had been looking for ADD instead, you’d have found an empty link after the first D, so the search would have been a failure.</p>&#13;
<p class="TX">As mentioned previously, the ternary trie search process is similar to that of binary search trees. The logic is as follows, and as with other cases, an auxiliary function comes in handy:</p>&#13;
<pre id="pre-338"><code>const _find = (tree, wordToFind) =&gt; {&#13;
<span class="Code_CodeAnnotation" aria-label="annotation1">❶</span> if (isEmpty(tree)) {&#13;
   return false;&#13;
<span class="Code_CodeAnnotation" aria-label="annotation2">❷</span>} else if (wordToFind.length === 0) {&#13;
   return tree.data;&#13;
<span class="Code_CodeAnnotation" aria-label="annotation3">❸</span>} else if (tree.key === wordToFind[0]) {&#13;
   return _find(tree.middle, wordToFind.substring(1));&#13;
<span class="Code_CodeAnnotation" aria-label="annotation4">❹</span>} else {&#13;
   return _find(wordToFind &lt; tree.key ? tree.left : tree.right, wordToFind);&#13;
 }&#13;
};</code></pre>&#13;
<p class="TX">If the tree is empty or you reach an empty subtree in the search, the search has failed <span class="CodeAnnotation" aria-label="annotation1">❶</span>. Otherwise, search recursively character by character. After passing the EOW character, you’ve found the key and can return its data <span class="CodeAnnotation" aria-label="annotation2">❷</span>; if you aren’t storing any data, just return <span class="SANS_TheSansMonoCd_W5Regular_11">true</span>. If the current tree key matches the first character of the word you’re searching <span class="CodeAnnotation" aria-label="annotation3">❸</span>, go down the middle link to match the rest of the word. If it isn’t a match <span class="CodeAnnotation" aria-label="annotation4">❹</span>, go down the left or right link as in a binary search tree.</p>&#13;
<p class="TX">To do a search, you need the same <span class="SANS_TheSansMonoCd_W5Regular_11">find()</span> function as with other tries:</p>&#13;
<pre id="pre-339"><code>const find = (trie, wordToFind) =&gt;&#13;
  !!wordToFind &amp;&amp; _find(trie, wordToFind + EOW);</code></pre>&#13;
<p class="TX">As you can see, working with the ternary trie isn’t that different from working with regular tries, but things will change a bit more when adding or deleting keys from the structure.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec23">&#13;
&#13;
<h4 class="H2" id="sec23"><span id="h2-172"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_11">Adding a Key to a Ternary Trie</span></h4>&#13;
<p class="TNI1">The logic for adding a key to a ternary trie is also similar to adding a key to binary search trees. Start at the root and compare the first character of the string to be added with the character at the root and decide whether to go left or right (if there’s no match) or down the middle (if the characters match). This process continues until you either find the key (and don’t need to do anything) or decide you need to add it.</p>&#13;
<p class="TX">Try to add ABE to the ternary trie from the previous section; <a href="chapter16.xhtml#fig16-26">Figure 16-26</a> highlights the steps.</p>&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_418" aria-label="418"/>&#13;
<figure class="IMG"><img class="img7" id="fig16-26" src="../images/Figure16-26.jpg" alt=""/>&#13;
<figcaption><p class="CAP"><span class="SANS_Futura_Std_Book_Oblique_11">Figure 16-26: Adding ABE to a ternary trie</span></p></figcaption>&#13;
</figure>&#13;
<p class="TX">You want to add ABE<span class="SANS_TheSansMonoCd_W5Regular_11">■</span> (remember the EOW), so a comparison with the root’s B makes you go down the left link. You find an A there, so you go down the middle link. Then, you find a C, and as you want to add BE<span class="SANS_TheSansMonoCd_W5Regular_11">■</span>, again you go down the left link, but because it’s null, you add a new subtree with B at its root in that location, an E down the middle link, and finally an EOW pointing to the extra data for the key.</p>&#13;
<p class="TX">Here’s the actual logic:</p>&#13;
<pre id="pre-340"><code>const _add = (tree, wordToAdd, data) =&gt; {&#13;
<span class="Code_CodeAnnotation" aria-label="annotation1">❶</span> if (wordToAdd.length &gt; 0) {&#13;
  <span class="Code_CodeAnnotation" aria-label="annotation2">❷</span> if (isEmpty(tree)) {&#13;
      tree = newNode(wordToAdd[0]);&#13;
    }&#13;
  <span class="Code_CodeAnnotation" aria-label="annotation3">❸</span> if (tree.key === wordToAdd[0]) {&#13;
    <span class="Code_CodeAnnotation" aria-label="annotation4">❹</span> tree.middle =  &#13;
        wordToAdd[0] === EOW&#13;
          ? {data}&#13;
          : _add(tree.middle, wordToAdd.substring(1), data);&#13;
  <span class="Code_CodeAnnotation" aria-label="annotation5">❺</span>} else {&#13;
    <span class="Code_CodeAnnotation" aria-label="annotation6">❻</span> const side = wordToAdd &lt; tree.key ? "left" : "right";&#13;
    <span class="Code_CodeAnnotation" aria-label="annotation7">❼</span> tree[side] = _add(tree[side], wordToAdd, data);&#13;
    }&#13;
  }&#13;
<span class="Code_CodeAnnotation" aria-label="annotation8">❽</span> return tree;&#13;
};</code></pre>&#13;
<p class="TX">First, process the string you want to add character by character until the end <span class="CodeAnnotation" aria-label="annotation1">❶</span>. If you reach an empty link, create a new tree <span class="CodeAnnotation" aria-label="annotation2">❷</span> and add the rest of the pending characters in the new key. If the current node’s key matches the first character of the string you are adding <span class="CodeAnnotation" aria-label="annotation3">❸</span>, either add the data (if you’re already at the EOW character) or recursively add the rest of the string <span role="doc-pagebreak" epub:type="pagebreak" id="pg_419" aria-label="419"/>to the middle-link subtree <span class="CodeAnnotation" aria-label="annotation4">❹</span>, which moves you down the tree. If there isn’t a match <span class="CodeAnnotation" aria-label="annotation5">❺</span>, decide whether to go down the left or right link <span class="CodeAnnotation" aria-label="annotation6">❻</span> and use recursion to add the string there <span class="CodeAnnotation" aria-label="annotation7">❼</span>. At the end, return the updated trie <span class="CodeAnnotation" aria-label="annotation8">❽</span>.</p>&#13;
<p class="TX">As before, the actual <span class="SANS_TheSansMonoCd_W5Regular_11">add()</span> function makes use of the auxiliary <span class="SANS_TheSansMonoCd_W5Regular_11">_add()</span> function:</p>&#13;
<pre id="pre-341"><code>const add = (tree, wordToAdd, data = wordToAdd) =&gt;&#13;
  _add(tree, wordToAdd + EOW, data);</code></pre>&#13;
<p class="TX">Addition didn’t end up being that different from binary tries, if you dismiss the logic dealing with the middle links. Deletion will be similar, but with some complications.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec24">&#13;
&#13;
<h4 class="H2" id="sec24"><span id="h2-173"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_11">Removing a Key from a Ternary Trie</span></h4>&#13;
<p class="TNI1">Removing a key is harder than the other functions, but with the lessons from <span class="Xref"><a href="chapter12.xhtml">Chapter 12</a></span> on how to deal with maintaining the proper data structure after removing any given node, you’ll get it done. (A spoiler: as with binary search trees, you’ll have to deal with deleting a node differently depending on how many children a node has.) Start with a more complex ternary trie, which will provide some unique cases, as shown in <a href="chapter16.xhtml#fig16-27">Figure 16-27</a> (I replaced some subtrees with triangles for clarity).</p>&#13;
<figure class="IMG"><img class="img7" id="fig16-27" src="../images/Figure16-27.jpg" alt=""/>&#13;
<figcaption><p class="CAP"><span class="SANS_Futura_Std_Book_Oblique_11">Figure 16-27: A ternary trie from which you’ll delete some words</span></p></figcaption>&#13;
</figure>&#13;
<p class="TX">Notice that when deleting a word, you need to delete several nodes along the path from the root to the final EOW, because now the keys aren’t stored in a single node. However, you can’t delete the <i>entire</i> path; you stop wherever the path joins another different path.</p>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_420" aria-label="420"/>Let’s start with a simple example: What if you want to delete BEAD, BEVY, or BELL? In each of those cases, just remove all nodes from the EOW backward until you get to a node that is part of a different path, and that’s it. Removing those three words results in the trie shown in <a href="chapter16.xhtml#fig16-28">Figure 16-28</a>.</p>&#13;
<figure class="IMG"><img class="img7" id="fig16-28" src="../images/Figure16-28.jpg" alt=""/>&#13;
<figcaption><p class="CAP"><span class="SANS_Futura_Std_Book_Oblique_11">Figure 16-28: Deleting words may require removing nodes upward.</span></p></figcaption>&#13;
</figure>&#13;
<p class="TX">The “cut” is at the marked nodes, which still keep their middle link and (in the case of BEST) another side link. Now consider what happens if you want to remove BETS. You shouldn’t leave the T node, because that’s wasteful. Since that node has a single child, you can work as you did with binary search trees and just link the node’s parent to the non-null child (see <a href="chapter16.xhtml#fig16-29">Figure 16-29</a>).</p>&#13;
<figure class="IMG"><img class="img7" id="fig16-29" src="../images/Figure16-29.jpg" alt=""/>&#13;
<figcaption><p class="CAP"><span class="SANS_Futura_Std_Book_Oblique_11">Figure 16-29: Removing BETS from the ternary trie requires changing a link from the parent.</span></p></figcaption>&#13;
</figure>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_421" aria-label="421"/>The key problem happens when you need to delete a node that has both left and right links. Go back to the original trie and consider removing BED. To recap, <a href="chapter16.xhtml#fig16-30">Figure 16-30</a> shows the original trie.</p>&#13;
<figure class="IMG"><img class="img7" id="fig16-30" src="../images/Figure16-30.jpg" alt=""/>&#13;
<figcaption><p class="CAP"><span class="SANS_Futura_Std_Book_Oblique_11">Figure 16-30: A ternary trie from which you’ll remove BED</span></p></figcaption>&#13;
</figure>&#13;
<p class="TX">When removing BED, you can’t just remove the D node, because that would break the trie, losing many other words; however, you don’t want to leave it either, because it isn’t a part of any word. The solution is similar to what you did with binary search trees: you can find the next word in its right subtree and use it to replace the word you’re deleting. In this case, the next word is BEER, as shown in <a href="chapter16.xhtml#fig16-31">Figure 16-31</a>.</p>&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_422" aria-label="422"/>&#13;
<figure class="IMG"><img class="img7" id="fig16-31" src="../images/Figure16-31.jpg" alt=""/>&#13;
<figcaption><p class="CAP"><span class="SANS_Futura_Std_Book_Oblique_11">Figure 16-31: Put BEER in the place of BED to maintain the structure of the ternary trie.</span></p></figcaption>&#13;
</figure>&#13;
<p class="TX">After finding the word that’s going to replace the deleted one (BEER replaces BED), you need to adjust several links to maintain the proper trie shape. If the right child has no left child, the changes are easier. See if you can figure out how to remove BEST and replace it with BEVY.</p>&#13;
<p class="TX">The logic is as follows:</p>&#13;
<pre id="pre-342"><code>const _remove = (tree, wordToRemove) =&gt; {&#13;
<span class="Code_CodeAnnotation1" aria-label="annotation1">❶</span> if (isEmpty(tree)) {&#13;
    // nothing to do&#13;
<span class="Code_CodeAnnotation1" aria-label="annotation2">❷</span>} else if (wordToRemove.length === 0) {&#13;
    tree = null;&#13;
  } else {&#13;
  <span class="Code_CodeAnnotation1" aria-label="annotation3">❸</span> if (wordToRemove[0] === tree.key) {&#13;
      tree.middle =&#13;
        tree.key === EOW&#13;
          ? null&#13;
          : _remove(tree.middle, wordToRemove.substring(1));&#13;
&#13;
    <span class="Code_CodeAnnotation1" aria-label="annotation4">❹</span> if (isEmpty(tree.middle)) {&#13;
      <span class="Code_CodeAnnotation1" aria-label="annotation5">❺</span> if (isEmpty(tree.left)) {&#13;
          tree = tree.right;&#13;
        } else if (isEmpty(tree.right)) {&#13;
          tree = tree.left;&#13;
      <span class="Code_CodeAnnotation1" aria-label="annotation6">❻</span>} else {&#13;
          let treeR = tree.right;&#13;
          let prev = null;&#13;
        <span class="Code_CodeAnnotation1" aria-label="annotation7">❼</span> while (!isEmpty(treeR.left)) {&#13;
            prev = treeR;&#13;
            treeR = treeR.left;&#13;
          }&#13;
        <span class="Code_CodeAnnotation1" aria-label="annotation8">❽</span> if (prev) {&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_423" aria-label="423"/>            prev.left = treeR.right;&#13;
            treeR.right = tree.right;&#13;
          }&#13;
&#13;
       <span class="Code_CodeAnnotation1" aria-label="annotation9">❾</span> treeR.left = tree.left;&#13;
          tree = treeR;&#13;
        }&#13;
      }&#13;
  <span class="Code_CodeAnnotation1" aria-label="annotation10">❿</span>} else {&#13;
      const side = wordToRemove &lt; tree.key ? "left" : "right";&#13;
      tree[side] = _remove(tree[side], wordToRemove);&#13;
    }&#13;
  }&#13;
&#13;
  return tree;&#13;
};</code></pre>&#13;
<p class="TX">If the tree is empty, do nothing else <span class="CodeAnnotation" aria-label="annotation1">❶</span>. If you reach the end of the word (past the EOW character, as in the search), set the tree to null, and you are done <span class="CodeAnnotation" aria-label="annotation2">❷</span>. While the character you are looking for matches the current node’s key, follow its middle link recursively <span class="CodeAnnotation" aria-label="annotation3">❸</span>, but if you reach the EOW, set that link to null. After doing the removal, see if you’re at a node with an empty middle link <span class="CodeAnnotation" aria-label="annotation4">❹</span>, which is a situation you don’t want. If one of the two (left or right) links <span class="CodeAnnotation" aria-label="annotation5">❺</span> is empty, choose the other link, but if both are non-null <span class="CodeAnnotation" aria-label="annotation6">❻</span>, you need to find the leftmost node at the right <span class="CodeAnnotation" aria-label="annotation7">❼</span> and fix the links as described earlier <span class="CodeAnnotation" aria-label="annotation8">❽</span> <span class="CodeAnnotation" aria-label="annotation9">❾</span>. (If <span class="SANS_TheSansMonoCd_W5Regular_11">prev</span> <span class="SANS_TheSansMonoCd_W5Regular_11">===</span> <span class="SANS_TheSansMonoCd_W5Regular_11">null</span>, there was just one single node to the right; otherwise, you need to go down the left links.) If you don’t find the right character earlier, you need to go left or right <span class="CodeAnnotation" aria-label="annotation10">❿</span>.</p>&#13;
<p class="TX">With this function out of the way, removing a key is the same function as with other tries:</p>&#13;
<pre id="pre-343"><code>const remove = (tree, wordToRemove) =&gt; _remove(tree, wordToRemove + EOW);</code></pre>&#13;
<p class="TX">You have now seen all the functions that work with ternary tries, so now let’s consider their performance.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec25">&#13;
&#13;
<h4 class="H2" id="sec25"><span id="h2-174"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_11">Considering Performance for Ternary Tries</span></h4>&#13;
<p class="TNI1">Ternary tries are different from the other tries we saw in this chapter in one way: the shape of the tree depends on the order of additions and removals, and that means you can have a worst case that behaves differently from the normal, average case. You may remember that this also happened with plain binary search trees. The worst-case performance differed from the average performance, and that depended on how the tree had been created.</p>&#13;
<p class="TX">If you insert all keys in ascending order, adding, searching, and removing will all be <i>O</i>(<i>sk</i>) if you store keys that are <i>k</i> characters long, with an alphabet of <i>s</i> symbols, which is a far better result than <i>O</i>(<i>n</i>)! To be proper, <i>O</i>(<i>sk</i>) is actually <i>O</i>(1) because <i>sk</i> is constant, so the ternary tries have the same performance as other tries.</p>&#13;
</section>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec26">&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_424" aria-label="424"/>&#13;
<h3 class="H1" id="sec26"><span id="h1-88"/><span class="SANS_Futura_Std_Bold_B_11">Summary</span></h3>&#13;
<p class="TNI1">In this chapter, we looked at several variants of search trees called tries that apply a different concept: instead of directly storing and comparing keys, tries work on a character-per-character basis, providing an enhanced performance in comparison to the search trees we looked at previously, without the need for complex operations, such as rotating or balancing nodes.</p>&#13;
<p class="TX">The structures we studied here are frequently used for dictionaries (enabling quick look-up of words) or straightforward searches: given a key, find its related data. The assured performance of tries makes them a useful data structure, particularly if you are doing some kind of work where you need to be as fast as possible and don’t want to deal with unexpected worst cases that may take too long to process.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec27">&#13;
&#13;
<h3 class="H1" id="sec27"><span id="h1-89"/><span class="SANS_Futura_Std_Bold_B_11">Questions</span></h3>&#13;
<p class="ListHead"><b>16.1  Maps for Tries</b></p>&#13;
<p class="ListPlainFirst">Can you implement a trie using a map instead of an array or an object?</p>&#13;
<p class="ListHead"><b>16.2  Ever Empty?</b></p>&#13;
<p class="ListPlainFirst">From the section “<span class="listplain_Xref">Adding a Key to a Radix Tree</span>” on page <span class="listplain_Xref">410</span>, in the <span class="SANS_TheSansMonoCd_W5Regular_11">_add()</span> function, can <span class="SANS_TheSansMonoCd_W5Regular_11">wordToAdd</span> ever be empty, and if so, when?</p>&#13;
<p class="ListHead"><b>16.3  Rotate Your Tries</b></p>&#13;
<p class="ListPlainFirst">Can you apply rotations to a ternary trie?</p>&#13;
<p class="ListHead"><b>16.4  Empty Middle?</b></p>&#13;
<p class="ListPlainFirst">True or false: middle links can never be empty in a ternary trie.</p>&#13;
<p class="ListHead"><b>16.5  Four-Letter Ternary Trie?</b></p>&#13;
<p class="ListPlainFirst">Suppose you start with an empty ternary trie and add in order keys AAAA, AAAB, . . . AAAZ, BAAA, . . . BAAZ ... all the way to ZZZZ—with all possible combinations of four letters. How tall would that trie be?</p>&#13;
<p class="ListHead"><b>16.6  How Do They Look?</b></p>&#13;
<p class="ListPlainFirst">As a recap, how would all the structures in this chapter look (array-based tries, object-based tries, radix trees, and ternary tries) if you just added a single word, ALGORITHM, to them?</p>&#13;
</section>&#13;
</section>&#13;
</body></html>