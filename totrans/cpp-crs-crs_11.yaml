- en: '**9'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: FUNCTIONS**
  prefs: []
  type: TYPE_NORMAL
- en: '*Functions should do one thing. They should do it well. They should do it only.'
  prefs: []
  type: TYPE_NORMAL
- en: —Robert C. Martin,* Clean Code
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/common.jpg)'
  prefs: []
  type: TYPE_IMG
- en: This chapter rounds out the ongoing discussion of functions, which encapsulate
    code into reusable components. Now that you’re armed with a strong background
    in C++ fundamentals, this chapter first revisits functions with a far more in-depth
    treatment of modifiers, specifiers, and return types, which appear in function
    declarations and specialize the behavior of your functions.
  prefs: []
  type: TYPE_NORMAL
- en: Then you’ll learn about overload resolution and accepting variable numbers of
    arguments before exploring function pointers, type aliases, function objects,
    and the venerable lambda expression. The chapter closes with an introduction to
    the `std::function` before revisiting the `main` function and accepting command
    line arguments.
  prefs: []
  type: TYPE_NORMAL
- en: '**Function Declarations**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Function declarations have the following familiar form:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: You can provide a number of optional *modifiers* (or *specifiers*) to functions.
    Modifiers alter a function’s behavior in some way. Some modifiers appear at the
    beginning in the function’s declaration or definition (*prefix modifiers*), whereas
    others appear at the end (*suffix modifiers*). The prefix modifiers appear before
    the return type. The suffix modifiers appear after the argument list.
  prefs: []
  type: TYPE_NORMAL
- en: 'There isn’t a clear language reason why certain modifiers appear as prefixes
    or suffixes: because C++ has a long history, these features evolved incrementally.'
  prefs: []
  type: TYPE_NORMAL
- en: '***Prefix Modifiers***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'At this point, you already know several prefix modifiers:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The prefix `static` indicates that a function that isn’t a member of a class
    has internal linkage, meaning the function won’t be used outside of this translation
    unit. Unfortunately, this keyword does double duty: if it modifies a method (that
    is, a function inside a class), it indicates that the function isn’t associated
    with an instantiation of the class but rather with the class itself (see [Chapter
    4](ch04.xhtml#ch04)).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The modifier `virtual` indicates that a method can be overridden by a child
    class. The `override` modifier indicates to the compiler that a child class intends
    to override a parent’s virtual function (see [Chapter 5](ch05.xhtml#ch05)).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The modifier `constexpr` indicates that the function should be evaluated at
    compile time if possible (see [Chapter 7](ch07.xhtml#ch07)).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The modifier `[[noreturn]]` indicates that this function won’t return (see [Chapter
    8](ch08.xhtml#ch08)). Recall that this attribute helps the compiler to optimize
    your code.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Another prefix modifier is `inline`, which plays a role in guiding the compiler
    when optimizing code.
  prefs: []
  type: TYPE_NORMAL
- en: 'On most platforms, a function call compiles into a series of instructions,
    such as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Place arguments into registers and on the call stack.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Push a return address onto the call stack.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Jump to the called function.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: After the function completes, jump to the return address.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Clean up the call stack.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: These steps typically execute very quickly, and the payoff in reduced binary
    size can be substantial if you use a function in many places.
  prefs: []
  type: TYPE_NORMAL
- en: '*Inlining a function* means copying and pasting the contents of the function
    directly into the execution path, eliminating the need for the five steps outlined.
    This means that as the processor executes your code, it will immediately execute
    your function’s code rather than executing the (modest) ceremony required for
    function invocation. If you prefer this marginal increase in speed over the commensurate
    cost in increased binary size, you can use the `inline` keyword to indicate this
    to the compiler. The `inline` keyword hints to the compiler’s optimizer to put
    a function directly inline rather than perform a function call.'
  prefs: []
  type: TYPE_NORMAL
- en: Adding `inline` to a function doesn’t change its behavior; it’s purely an expression
    of preference to the compiler. You must ensure that if you define a function `inline`,
    you do so in all translation units. Also note that modern compilers will typically
    inline functions where it makes sense—especially if a function isn’t used outside
    of a single translation unit.
  prefs: []
  type: TYPE_NORMAL
- en: '***Suffix Modifiers***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'At this point in the book, you already know two suffix modifiers:'
  prefs: []
  type: TYPE_NORMAL
- en: The modifier `noexcept` indicates that the function will *never* throw an exception.
    It enables certain optimizations (see [Chapter 4](ch04.xhtml#ch04)).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The modifier `const` indicates that the method won’t modify an instance of its
    class, allowing `const` references types to invoke the method (see [Chapter 4](ch04.xhtml#ch04)).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'This section explores three more suffix modifiers: `final`, `override`, and
    `volatile`.'
  prefs: []
  type: TYPE_NORMAL
- en: '**final and override**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: The `final` modifier indicates that a method cannot be overridden by a child
    class. It’s effectively the opposite of `virtual`. [Listing 9-1](ch09.xhtml#ch09ex01)
    attempts to override a `final` method and yields a compiler error.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 9-1: A class attempting to override a final method (This code doesn’t
    compile.)*'
  prefs: []
  type: TYPE_NORMAL
- en: This listing marks the `shoot` method `final` ➊. Within `BostonCorbettJunior`,
    which inherits from `BostonCorbett`, you attempt to `override` the `shoot` method
    ➋. This causes a compiler error.
  prefs: []
  type: TYPE_NORMAL
- en: You can also apply the `final` keyword to an entire class, disallowing that
    class from becoming a parent entirely, as demonstrated in [Listing 9-2](ch09.xhtml#ch09ex02).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 9-2: A program with a class attempting to inherit from a final class.
    (This code doesn’t compile.)*'
  prefs: []
  type: TYPE_NORMAL
- en: The `BostonCorbett` class is marked as `final` ➊, and this causes a compiler
    error when you attempt to inherit from it in `BostonCorbettJunior` ➋.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Neither `final` nor `override` is technically a language keyword; they are
    *identifiers*. Unlike keywords, identifiers gain special meaning only when used
    in a specific context. This means you can use `final` and `override` as symbol
    names elsewhere in your program, thereby leading to the insanity of constructions
    like `virtual void final() override`. Try not to do this.*'
  prefs: []
  type: TYPE_NORMAL
- en: Whenever you’re using interface inheritance, you should mark implementing classes
    `final` because the modifier can encourage the compiler to perform an optimization
    called *devirtualization*. When virtual calls are devirtualized, the compiler
    eliminates the runtime overhead associated with a virtual call.
  prefs: []
  type: TYPE_NORMAL
- en: '**volatile**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Recall from [Chapter 7](ch07.xhtml#ch07) that a volatile object’s value can
    change at any time, so the compiler must treat all accesses to volatile objects
    as visible side effects for optimization purposes. The `volatile` keyword indicates
    that a method can be invoked on volatile objects. This is analogous to how `const`
    methods can be applied to `const` objects. Together, these two keywords define
    a method’s *const/volatile qualification* (or sometimes *cv qualification*), as
    demonstrated in [Listing 9-3](ch09.xhtml#ch09ex03).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 9-3: Illustrating the use of a `volatile` method*'
  prefs: []
  type: TYPE_NORMAL
- en: In this listing, you declare the `apply` method on the `Distillate` class `vola``tile`
    ➊. You also create a `volatile Distillate` called `ethanol` within `main` ➋. Because
    the `apply` method is `volatile`, you can still invoke it ➌ (even though `ethanol`
    is `volatile`).
  prefs: []
  type: TYPE_NORMAL
- en: 'Had you not marked `apply volatile` ➊, the compiler would emit an error when
    you attempted to invoke it ➌. Just like you cannot invoke a non-`const` method
    on a `const` object, you cannot invoke a non-`volatile` method on a `volatile`
    object. Consider what would happen if you could perform such an operation: a non-`volatile`
    method is a candidate for all kinds of compiler optimizations for the reasons
    outlined in [Chapter 7](ch07.xhtml#ch07): many kinds of memory accesses can be
    optimized away without changing the observable side effects of your program.'
  prefs: []
  type: TYPE_NORMAL
- en: How should the compiler treat a contradiction arising from you using a `volatile`
    object—which requires that all its memory accesses are treated as observable side
    effects—to invoke a non-`volatile` method? The compiler’s answer is that it calls
    this contradiction an error.
  prefs: []
  type: TYPE_NORMAL
- en: '**auto Return Types**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'There are two ways to declare the return value of a function:'
  prefs: []
  type: TYPE_NORMAL
- en: (Primary) Lead a function declaration with its return type, as you’ve been doing
    all along.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: (Secondary) Have the compiler deduce the correct return type by using `auto`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As with `auto` type deduction, the compiler deduces the return type, fixing
    the runtime type.
  prefs: []
  type: TYPE_NORMAL
- en: This feature should be used judiciously. Because function definitions are documentation,
    it’s best to provide concrete return types when available.
  prefs: []
  type: TYPE_NORMAL
- en: '**auto and Function Templates**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The primary use case for `auto` type deduction is with function templates,
    where a return type can depend (in potentially complicated ways) on the template
    parameters. Its usage is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'It’s possible to extend the `auto`-return-type deduction syntax to provide
    the return type as a suffix with the arrow operator `->`. This way, you can append
    an expression that evaluates to the function’s return type. Its usage is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Usually, you wouldn’t use this pedantic form, but in certain situations it’s
    helpful. For example, this form of `auto` type deduction is commonly paired with
    a `decltype` type expression. A `decltype` type expression yields another expression’s
    resultant type. Its usage is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'This expression resolves to the resulting type of the expression. For example,
    the following `decltype` expression yields `int`, because the integer literal
    100 has that type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Outside of generic programming with templates, `decltype` is rare.
  prefs: []
  type: TYPE_NORMAL
- en: You can combine `auto`-return-type deduction and `decltype` to document the
    return types of function templates. Consider the `add` function in [Listing 9-4](ch09.xhtml#ch09ex04),
    which defines a function template `add` that adds two arguments together.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 9-4: Using `decltype` and `auto`-return-type deduction*'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `add` function employs `auto` type deduction with the `decltype` type expression
    ➊. Each time you instantiate a template with two types `X` and `Y`, the compiler
    evaluates `decltype(X + Y)` and fixes the return type of `add`. Within `main`,
    you provide three instantiations. First, you add a `double` and an `int` ➋. The
    compiler determines that `decltype(double{ 100\. } + int{ -10 })` is a `double`,
    which fixes the return type of this `add` instantiation. This, in turn, sets the
    type of `my_double` to `double` ➋. You have two other instantiations: one for
    an `unsigned int` and `int` (which results in an `unsigned int` ➌) and another
    for a `char` and an `unsigned long long` (which results in an `unsigned long long`
    ➍).'
  prefs: []
  type: TYPE_NORMAL
- en: '**Overload Resolution**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*Overload resolution* is the process that the compiler executes when matching
    a function invocation with its proper implementation.'
  prefs: []
  type: TYPE_NORMAL
- en: Recall from [Chapter 4](ch04.xhtml#ch04) that function overloads allow you to
    specify functions with the same name but different types and possibly different
    arguments. The compiler selects among these function overloads by comparing the
    argument types within the function invocation with the types within each overload
    declaration. The compiler will choose the best among the possible options, and
    if it cannot select a best option, it will generate a compiler error.
  prefs: []
  type: TYPE_NORMAL
- en: 'Roughly, the matching process proceeds as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: The compiler will look for an exact type match.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The compiler will try using integral and floating-point promotions to get a
    suitable overload (for example, `int` to `long` or `float` to `double`).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The compiler will try to match using standard conversions like integral type
    to floating-point or casting a pointer-to-child into a pointer-to-parent.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The compiler will look for a user-defined conversion.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The compiler will look for a variadic function.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Variadic Functions**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*Variadic functions* take a variable number of arguments. Typically, you specify
    the exact number of arguments a function takes by enumerating all of its parameters
    explicitly. With a variadic function, you can take any number of arguments. The
    variadic function `printf` is a canonical example: you provide a format specifier
    and an arbitrary number of parameters. Because `printf` is a variadic function,
    it accepts any number of parameters.'
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*The astute Pythonista will note an immediate conceptual relationship between
    variadic functions and `*args`/`**kwargs`.*'
  prefs: []
  type: TYPE_NORMAL
- en: You declare variadic functions by placing `...` as the final parameter in the
    function’s argument list. When a variadic function is invoked, the compiler matches
    arguments against declared arguments. Any leftovers pack into the variadic arguments
    represented by the `...` argument.
  prefs: []
  type: TYPE_NORMAL
- en: You cannot extract elements from the variadic arguments directly. Instead, you
    access individual arguments using the utility functions in the `<cstdarg>` header.
  prefs: []
  type: TYPE_NORMAL
- en: '[Table 9-1](ch09.xhtml#ch09tab01) lists these utility functions.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 9-1:** Utility Functions in the `<cstdarg>` Header'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Function** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| `va_list` | Used to declare a local variable representing the variadic arguments
    |'
  prefs: []
  type: TYPE_TB
- en: '| `va_start` | Enables access to the variadic arguments |'
  prefs: []
  type: TYPE_TB
- en: '| `va_end` | Used to end iteration over the variadic arguments |'
  prefs: []
  type: TYPE_TB
- en: '| `va_arg` | Used to iterate over each element in the variadic arguments |'
  prefs: []
  type: TYPE_TB
- en: '| `va_copy` | Makes a copy of the variadic arguments |'
  prefs: []
  type: TYPE_TB
- en: The utility functions’ usage is a little convoluted and best presented in a
    cohesive example. Consider the variadic `sum` function in [Listing 9-5](ch09.xhtml#ch09ex05),
    which contains a variadic argument.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 9-5: A `sum` function with a variadic argument list*'
  prefs: []
  type: TYPE_NORMAL
- en: You declare `sum` as a variadic function ➊. All variadic functions must declare
    a `va_list`. You’ve named it `args` ➋. A `va_list` requires initialization with
    `va_start` ➌, which takes two arguments. The first argument is a `va_list`, and
    the second is the size of the variadic arguments. You iterate over each element
    in the variadic arguments using the `va_args` function. The first argument is
    the `va_list` argument, and the second is the argument type ➍. Once you’ve completed
    iterating, you call `va_end` with the `va_list` structure ➎.
  prefs: []
  type: TYPE_NORMAL
- en: 'You invoke `sum` with seven arguments: the first is the number of variadic
    arguments (six) followed by six numbers (2, 4, 6, 8, 10, 12) ➏.'
  prefs: []
  type: TYPE_NORMAL
- en: Variadic functions are a holdover from C. Generally, variadic functions are
    unsafe and a common source of security vulnerabilities.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are at least two major problems with variadic functions:'
  prefs: []
  type: TYPE_NORMAL
- en: Variadic arguments are not type-safe. (Notice that the second argument of `va_arg`
    is a type.)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The number of elements in the variadic arguments must be tracked separately.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The compiler cannot help you with either of these issues.
  prefs: []
  type: TYPE_NORMAL
- en: Fortunately, variadic templates provide a safer and more performant way to implement
    variadic functions.
  prefs: []
  type: TYPE_NORMAL
- en: '**Variadic Templates**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The variadic template enables you to create function templates that accept variadic,
    same-typed arguments. They enable you to employ the considerable power of the
    template engine. To declare a variadic template, you add a special template parameter
    called a *template parameter pack*. [Listing 9-6](ch09.xhtml#ch09ex06) demonstrates
    its usage.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 9-6: A template function with a parameter pack*'
  prefs: []
  type: TYPE_NORMAL
- en: 'The template parameter pack is part of the template parameter list ➊. When
    you use `Args` within the function template ➋, it’s called a *function parameter
    pack*. Some special operators are available for use with parameter packs:'
  prefs: []
  type: TYPE_NORMAL
- en: You can use `sizeof...(args)` to obtain the parameter pack’s size.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can invoke a function (for example, `other_function`) with the special syntax
    `other_function(args...)`. This expands the parameter pack `args` and allows you
    to perform further processing on the arguments contained in the parameter pack.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '***Programming with Parameter Packs***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Unfortunately, it’s not possible to index into a parameter pack directly. You
    must invoke the function template from within itself—a process called *compile-time
    recursion*—to recursively iterate over the elements in a parameter pack.
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 9-7](ch09.xhtml#ch09ex07) demonstrates the pattern.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 9-7: A template function illustrating compile-time recursion with
    parameter packs. Unlike other usage listings, the ellipses contained in this listing
    are literal.*'
  prefs: []
  type: TYPE_NORMAL
- en: The key is to add a regular template parameter before the parameter pack ➊.
    Each time you invoke `my_func`, `x` absorbs the first argument. The remainder
    packs into `args`. To invoke, you use the `args...` construct to expand the parameter
    pack ➋.
  prefs: []
  type: TYPE_NORMAL
- en: 'The recursion needs a stopping criteria, so you add a function template specialization
    without the parameter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: '***Revisiting the sum Function***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Consider the (much improved) `sum` function implemented as a variadic template
    in [Listing 9-8](ch09.xhtml#ch09ex08).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 9-8: A refactor of [Listing 9-5](ch09.xhtml#ch09ex05) using a template
    parameter pack instead of `va_args`*'
  prefs: []
  type: TYPE_NORMAL
- en: The first function ➋ is the overload that handles the stopping condition; if
    the function has only a single argument, you simply return the argument `x,` because
    the sum of a single element is just the element. The variadic template ➍ follows
    the recursion pattern outlined in [Listing 9-7](ch09.xhtml#ch09ex07). It peels
    a single argument `x` off the parameter pack `args` and then returns `x` plus
    the result of the recursive call to `sum` with the expanded parameter pack ➎.
    Because all of this generic programming can be computed at compile time, you mark
    these functions `constexpr` ➊➌. This compile-time computation is a *major* advantage
    over [Listing 9-5](ch09.xhtml#ch09ex05), which has identical output but computes
    the result at runtime ➏. (Why pay runtime costs when you don’t have to?)
  prefs: []
  type: TYPE_NORMAL
- en: When you just want to apply a single binary operator (like plus or minus) over
    a range of values (like [Listing 9-5](ch09.xhtml#ch09ex05)), you can use a fold
    expression instead of recursion.
  prefs: []
  type: TYPE_NORMAL
- en: '***Fold Expressions***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'A *fold expression* computes the result of using a binary operator over all
    the arguments of a parameter pack. Fold expressions are distinct from but related
    to variadic templates. Their usage is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'For example, you could employ the following fold expression to sum over all
    elements in a parameter pack called `args`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: '[Listing 9-9](ch09.xhtml#ch09ex09) refactors 9-8 to use a fold expression instead
    of recursion.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 9-9: A refactor of [Listing 9-8](ch09.xhtml#ch09ex08) using a fold
    expression*'
  prefs: []
  type: TYPE_NORMAL
- en: You simplify the `sum` function by using a fold expression instead of the recursion
    approach ➊. The end result is identical ➋.
  prefs: []
  type: TYPE_NORMAL
- en: '**Function Pointers**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*Functional programming* is a programming paradigm that emphasizes function
    evaluation and immutable data. One of the major concepts in functional programming
    is to pass a function as a parameter to another function.'
  prefs: []
  type: TYPE_NORMAL
- en: One way you can achieve this is to pass a function pointer. Functions occupy
    memory, just like objects. You can refer to this memory address via usual pointer
    mechanisms. However, unlike objects, you cannot modify the pointed-to function.
    In this respect, functions are conceptually similar to `const` objects. You can
    take the address of functions and invoke them, and that’s about it.
  prefs: []
  type: TYPE_NORMAL
- en: '***Declaring a Function Pointer***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'To declare a function pointer, use the following ugly syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: This has the same appearance as a function declaration where the function name
    is replaced (`*pointer-name`).
  prefs: []
  type: TYPE_NORMAL
- en: As usual, you can employ the address-of operator `&` to take the address of
    a function. This is optional, however; you can simply use the function name as
    a pointer.
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 9-10](ch09.xhtml#ch09ex10) illustrates how you can obtain and use
    function pointers.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 9-10: A program illustrating function pointers. (Due to address space
    layout randomization, the addresses ➍➐ will vary at runtime.)*'
  prefs: []
  type: TYPE_NORMAL
- en: This listing shows two functions with identical function signatures, `add` and
    `subtract`. Because the function signatures match, pointer types to these functions
    will also match. You initialize a function pointer `operation` accepting a `float`
    and an `int` as arguments and returning a `float` ➊. Next, you print the value
    of `operation`, which is `nullptr`, after initialization ➋.
  prefs: []
  type: TYPE_NORMAL
- en: You then assign the address of `add` to `operation` ➌ using the address-of operator
    and print its new address ➍. You invoke `operation` and print the result ➎.
  prefs: []
  type: TYPE_NORMAL
- en: To illustrate that you can reassign function pointers, you assign `operation`
    to `subtract` without using the address of operator ➏, print the new value of
    `operation` ➐, and finally print the result ➑.
  prefs: []
  type: TYPE_NORMAL
- en: '***Type Aliases and Function Pointers***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Type aliases provide a neat way to program with function pointers. The usage
    is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'You could have defined an `operation_func` type alias in [Listing 9-10](ch09.xhtml#ch09ex10),
    for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: This is especially useful if you’ll be using function pointers of the same type;
    it can really clean up the code.
  prefs: []
  type: TYPE_NORMAL
- en: '**The Function-Call Operator**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You can make user-defined types callable or invocable by overloading the function-call
    operator `operator()()`. Such a type is called a *function type*, and instances
    of a function type are called *function objects*. The function-call operator permits
    any combination of argument types, return types, and modifiers (except `static`).
  prefs: []
  type: TYPE_NORMAL
- en: The primary reason you might want to make a user-defined type callable is to
    interoperate with code that expects function objects to use the function-call
    operator. You’ll find that many libraries, such as the stdlib, use the function-call
    operator as the interface for function-like objects. For example, in [Chapter
    19](ch19.xhtml#ch19), you’ll learn how to create an asynchronous task with the
    `std::async` function, which accepts an arbitrary function object that can execute
    on a separate thread. It uses the function-call operator as the interface. The
    committee that invented `std::async` could have required you to expose, say, a
    `run` method, but they chose the function-call operator because it allows generic
    code to use identical notation to invoke a function or a function object.
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 9-11](ch09.xhtml#ch09ex11) illustrates the function-call operator’s
    usage.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 9-11: The function-call operator’s usage*'
  prefs: []
  type: TYPE_NORMAL
- en: The function-call operator has the special `operator()` method name ➋. You declare
    an arbitrary number of arguments ➌, and you also decide the appropriate return
    type ➊.
  prefs: []
  type: TYPE_NORMAL
- en: When the compiler evaluates a function-call expression, it will invoke the function-call
    operator on the first operand, passing the remaining operands as arguments. The
    result of the function-call expression is the result of invoking the corresponding
    function-call operator.
  prefs: []
  type: TYPE_NORMAL
- en: '**A Counting Example**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Consider the function type `CountIf` in [Listing 9-12](ch09.xhtml#ch09ex12),
    which computes the frequency of a particular `char` in a null-terminated string.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 9-12: A function type that counts the number of characters appearing
    in a null-terminated string*'
  prefs: []
  type: TYPE_NORMAL
- en: You initialize `CountIf` objects using a constructor taking a `char` ➊. You
    can call the resulting function object as if it were a function taking a null-terminated
    string argument ➋, because you’ve implemented the function call operator. The
    function call operator iterates through each character in the argument `str` using
    an `index` variable ➌, incrementing the `result` variable whenever the character
    matches the `x` field ➍. Because calling the function doesn’t modify the state
    of a `CountIf` object, you’ve marked it `const`.
  prefs: []
  type: TYPE_NORMAL
- en: Within `main`, you’ve initialized the `CountIf` function object `s_counter`,
    which will count the frequency of the letter `s` ➎. You can use `s_counter` as
    if it were a function ➏. You can even initialize a `CountIf` object and use the
    function operator directly as an rvalue object ➐. You might find this convenient
    to do in some settings where, for example, you might only need to invoke the object
    a single time.
  prefs: []
  type: TYPE_NORMAL
- en: You can employ function objects as partial applications. [Listing 9-12](ch09.xhtml#ch09ex12)
    is conceptually similar to the `count_if` function in [Listing 9-13](ch09.xhtml#ch09ex13).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 9-13: A free function emulating [Listing 9-12](ch09.xhtml#ch09ex12)*'
  prefs: []
  type: TYPE_NORMAL
- en: The `count_if` function has an extra argument `x` ➊, but otherwise it’s almost
    identical to the function operator of `CountIf`.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*In functional programming parlance, the `CountIf` is the `partial application`
    of `x` to `count_if`. When you partially apply an argument to a function, you
    fix that argument’s value. The product of such a partial application is another
    function taking one less argument.*'
  prefs: []
  type: TYPE_NORMAL
- en: Declaring function types is verbose. You can often reduce the boilerplate substantially
    with lambda expressions.
  prefs: []
  type: TYPE_NORMAL
- en: '**Lambda Expressions**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*Lambda expressions* construct unnamed function objects succinctly. The function
    object implies the function type, resulting in a quick way to declare a function
    object on the fly. Lambdas don’t provide any additional functionality other than
    declaring function types the old-fashioned way. But they’re extremely convenient
    when you need to initialize a function object in only a single context.'
  prefs: []
  type: TYPE_NORMAL
- en: '***Usage***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'There are five components to a lambda expression:'
  prefs: []
  type: TYPE_NORMAL
- en: '`*captures*`: The member variables of the function object (that is, the partially
    applied parameters)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`*parameters*`: The arguments required to invoke the function object'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`*body*`: The function object’s code'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`*specifiers*`: Elements like `constexpr, mutable`, `noexcept`, and `[[noreturn]]`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`*return type*`: The type returned by the function object'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Lambda expression usage is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Only the captures and the body are required; everything else is optional. You’ll
    learn about each of these components in depth in the next few sections.
  prefs: []
  type: TYPE_NORMAL
- en: Each lambda component has a direct analogue in a function object. To form a
    bridge between the function objects like `CountIf` and lambda expressions, look
    at [Listing 9-14](ch09.xhtml#ch09ex14), which lists the `CountIf` function type
    from [Listing 9-12](ch09.xhtml#ch09ex12) with annotations that correspond to the
    analogous portions of the lambda expression in the usage listing.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 9-14: Comparing the `CountIf` type declaration with a lambda expression*'
  prefs: []
  type: TYPE_NORMAL
- en: The member variables you set in the constructor of `CountIf` are analogous to
    a lambda’s capture ➊. The function-call operator’s arguments ➋, body ➌, and return
    type ➍ are analogous to the lambda’s parameters, body, and return type. Finally,
    modifiers can apply to the function-call operator ➎ and the lambda. (The numbers
    in the Lambda expession usage example and [Listing 9-14](ch09.xhtml#ch09ex14)
    correspond.)
  prefs: []
  type: TYPE_NORMAL
- en: '***Lambda Parameters and Bodies***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Lambda expressions produce function objects. As function objects, lambdas are
    callable. Most of the time, you’ll want your function object to accept parameters
    upon invocation.
  prefs: []
  type: TYPE_NORMAL
- en: 'The lambda’s body is just like a function body: all of the parameters have
    function scope.'
  prefs: []
  type: TYPE_NORMAL
- en: You declare lambda parameters and bodies using essentially the same syntax that
    you use for functions.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, the following lambda expression yields a function object that
    will square its `int` argument:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: The lambda takes a single `int x` and uses it within the lambda’s body to perform
    the squaring.
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 9-15](ch09.xhtml#ch09ex15) employs three different lambdas to transform
    the array `1, 2, 3`.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 9-15: Three lambdas and a transform function*'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `transform` template function ➊ accepts four arguments: a function object
    `fn`, an `in` array and an `out` array, and the corresponding `length` of those
    arrays. Within transform, you invoke `fn` on each element of `in` and assign the
    result to the corresponding element of `out` ➋.'
  prefs: []
  type: TYPE_NORMAL
- en: Within `main`, you declare a `base` array `1, 2, 3` that will be used as the
    `in` array. In the same line you also declare three uninitialized arrays `a, b`,
    and `c`, which will be used as the `out` arrays. The first call to `transform`
    passes a lambda `([](int x) { return 1; })` that always returns 1 ➌, and the result
    is stored into `a`. (Notice that the lambda didn’t need a name!) The second call
    to `transform ([](int x) { return x; })` simply returns its argument ➍, and the
    result is stored into `b`. The third call to `transform` multiplies the argument
    by 10 and adds 5 ➎. The result is stored in `c`. You then print the output into
    a matrix where each column illustrates the transform that was applied to the different
    lambdas in each case.
  prefs: []
  type: TYPE_NORMAL
- en: Notice that you declared `transform` as a template function, allowing you to
    reuse it with any function object.
  prefs: []
  type: TYPE_NORMAL
- en: '***Default Arguments***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: You can provide default arguments to a lambda. Default lambda parameters behave
    just like default function parameters. The caller can specify values for default
    parameters, in which case the lambda uses the caller-provided values. If the caller
    doesn’t specify a value, the lambda uses the default.
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 9-16](ch09.xhtml#ch09ex16) illustrates the default argument behavior.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 9-16: Using default lambda parameters*'
  prefs: []
  type: TYPE_NORMAL
- en: The increment lambda has two parameters, `x` and `y`. But the `y` parameter
    is optional because it has the default argument 1 ➊. If you don’t specify an argument
    for `y` when you call the function ➋, increment returns `1 + x`. If you do call
    the function with an argument for `y` ➌, that value is used instead.
  prefs: []
  type: TYPE_NORMAL
- en: '***Generic Lambdas***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Generic lambdas are lambda expression templates. For one or more parameters,
    you specify `auto` rather than a concrete type. These `auto` types become template
    parameters, meaning the compiler will stamp out a custom instantiation of the
    lambda.
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 9-17](ch09.xhtml#ch09ex17) illustrates how to assign a generic lambda
    into a variable and then use the lambda in two different template instantiations.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 9-17: Using a generic lambda*'
  prefs: []
  type: TYPE_NORMAL
- en: 'You add a second template parameter to `transform` ➊, which you use as the
    pointed-to type of `in` and `out`. This allows you to apply transform to arrays
    of any type, not just of `int` types. To test out the upgraded transform template,
    you declare two arrays with different pointed-to types: `int` ➋ and `float` ➌.
    (Recall from [Chapter 3](ch03.xhtml#ch03) that the `f` in `10.f` specifies a `float`
    literal.) Next, you assign a generic lambda expression to `translate` ➍. This
    allows you to use the same lambda for each instantiation of transform: when you
    instantiate with `base_int` ➎ and with `base_float` ➏.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Without a generic lambda, you’d have to declare the parameter types explicitly,
    like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: So far, you’ve been leaning on the compiler to deduce the return types of your
    lambdas. This is especially useful for generic lambdas, because often the lambda’s
    return type will depend on its parameter types. But you can explicitly state the
    return type if you want.
  prefs: []
  type: TYPE_NORMAL
- en: '***Lambda Return Types***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The compiler deduces a lambda’s return type for you. To take over from the
    compiler, you use the arrow `->` syntax, as in the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: This lambda expression accepts an `int` and a `double` and returns a `double`.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also use `decltype` expressions, which can be useful with generic lambdas.
    For example, consider the following lambda:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Here you’ve explicitly declared that the return type of the lambda is whatever
    type results from adding an `x` to a `y`.
  prefs: []
  type: TYPE_NORMAL
- en: You’ll rarely need to specify a lambda’s return type explicitly.
  prefs: []
  type: TYPE_NORMAL
- en: A far more common requirement is that you must inject an object into a lambda
    before invocation. This is the role of lambda captures.
  prefs: []
  type: TYPE_NORMAL
- en: '***Lambda Captures***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '*Lambda captures* inject objects into the lambda. The injected objects help
    to modify the behavior of the lambda.'
  prefs: []
  type: TYPE_NORMAL
- en: Declare a lambda’s capture by specifying a capture list within brackets `[]`.
    The capture list goes before the parameter list, and it can contain any number
    of comma-separated arguments. You then use these arguments within the lambda’s
    body.
  prefs: []
  type: TYPE_NORMAL
- en: A lambda can capture by reference or by value. By default, lambdas capture by
    value.
  prefs: []
  type: TYPE_NORMAL
- en: A lambda’s capture list is analogous to a function type’s constructor. [Listing
    9-18](ch09.xhtml#ch09ex18) reformulates `CountIf` from [Listing 9-12](ch09.xhtml#ch09ex12)
    as the lambda `s_counter`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 9-18: Reformulating `CountIf` from [Listing 9-12](ch09.xhtml#ch09ex12)
    as a lambda*'
  prefs: []
  type: TYPE_NORMAL
- en: You initialize a `char` called `to_count` to the letter `s` ➊. Next, you capture
    `to_count` within the lambda expression assigned to `s_counter` ➋. This makes
    `to_count` available within the body of the lambda expression ➌.
  prefs: []
  type: TYPE_NORMAL
- en: To capture an element by reference rather than by value, prefix the captured
    object’s name with an ampersand `&`. [Listing 9-19](ch09.xhtml#ch09ex19) adds
    a capture reference to `s_counter` that keeps a running tally across lambda invocations.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 9-19: Using a capture reference in a lambda*'
  prefs: []
  type: TYPE_NORMAL
- en: You initialize the counter variable `tally` to zero ➊, and then the `s_counter`
    lambda captures `tally` by reference (note the ampersand `&`) ➋. Within the lambda’s
    body, you add a statement to increment `tally` by an invocation’s `result` before
    returning ➌. The result is that `tally` will track the total count no matter how
    many times you invoke the lambda. Before the first `s_counter` invocation, you
    print the value of `tally` ➍ (which is still zero). After you invoke `s_counter`
    with `Sally sells seashells by the seashore.`, you have a `tally` of 7 ➎. The
    last invocation of `s_counter` with `Sailor went to sea to see what he could see.`
    returns 3, so the value of `tally` is 7 + 3 = 10 ➏.
  prefs: []
  type: TYPE_NORMAL
- en: '**Default Capture**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: So far, you’ve had to capture each element by name. Sometimes this style of
    capturing is called *named capture*. If you’re lazy, you can capture all automatic
    variables used within a lambda using *default capture*. To specify a default capture
    by value within a capture list, use a lone equal sign `=`. To specify a default
    capture by reference, use a lone ampersand `&`.
  prefs: []
  type: TYPE_NORMAL
- en: For example, you could “simplify” the lambda expression in [Listing 9-19](ch09.xhtml#ch09ex19)
    to perform a default capture by reference, as demonstrated in [Listing 9-20](ch09.xhtml#ch09ex20).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 9-20: Simplifying a lambda expression with a default capture by reference*'
  prefs: []
  type: TYPE_NORMAL
- en: 'You specify a default capture by reference ➊, which means any automatic variables
    in the body of the lambda expression get captured by reference. There are two:
    `to_count` ➋ and `tally` ➌.'
  prefs: []
  type: TYPE_NORMAL
- en: If you compile and run the refactored listing, you’ll obtain identical output.
    However, notice that `to_count` is now captured by reference. If you accidentally
    modify it within the lambda expression’s body, the change will occur across lambda
    invocations as well as within `main` (where `to_count` is an automatic variable).
  prefs: []
  type: TYPE_NORMAL
- en: What would happen if you performed a default capture by value instead? You would
    only need to change the `=` to an `&` in the capture list, as demonstrated in
    [Listing 9-21](ch09.xhtml#ch09ex21).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 9-21: Modifying [Listing 9-20](ch09.xhtml#ch09ex20) to capture by
    value instead of by reference (This code doesn''t compile.)*'
  prefs: []
  type: TYPE_NORMAL
- en: You change the default capture to be by value ➊. The `to_count` capture is unaffected
    ➋, but attempting to modify `tally` results in a compiler error ➌. You’re not
    allowed to modify variables captured by value unless you add the `mutable` keyword
    to the lambda expression. The `mutable` keyword allows you to modify value-captured
    variables. This includes calling non-`const` methods on that object.
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 9-22](ch09.xhtml#ch09ex22) adds the `mutable` modifier and has a default
    capture by value.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 9-22: A `mutable` lambda expression with a default capture by value*'
  prefs: []
  type: TYPE_NORMAL
- en: You declare a default capture by value ➊, and you make the lambda `s_counter
    mutable` ➋. Each of the three times you print `tally` ➌➍➎, you get a zero value.
    Why?
  prefs: []
  type: TYPE_NORMAL
- en: Because `tally` gets copied by value (via the default capture), the version
    in the lambda is, in essence, an entirely different variable that just happens
    to have the same name. Modifications to the lambda’s copy of `tally` don’t affect
    the automatic `tally` variable of `main`. The `tally` in `main()` is initialized
    to zero and never gets modified.
  prefs: []
  type: TYPE_NORMAL
- en: 'It’s also possible to mix a default capture with a named capture. You could,
    for example, default capture by reference and copy `to_count` by value using the
    following formulation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: This specifies a default capture by reference ➊ and `to_count` ➋ capture by
    value.
  prefs: []
  type: TYPE_NORMAL
- en: Although performing a default capture might seem like an easy shortcut, refrain
    from using it. It’s far better to declare captures explicitly. If you catch yourself
    saying “I’ll just use a default capture because there are too many variables to
    list out,” you probably need to refactor your code.
  prefs: []
  type: TYPE_NORMAL
- en: '**Initializer Expressions in Capture Lists**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Sometimes you want to initialize a whole new variable within a capture list.
    Maybe renaming a captured variable would make a lambda expression’s intent clearer.
    Or perhaps you want to move an object into a lambda and therefore need to initialize
    a variable.
  prefs: []
  type: TYPE_NORMAL
- en: To use an initializer expression, just declare the new variable’s name followed
    by an equal sign and the value you want to initialize your variable with, as [Listing
    9-23](ch09.xhtml#ch09ex23) demonstrates.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 9-23: Using an initializer expression within a lambda capture*'
  prefs: []
  type: TYPE_NORMAL
- en: The capture list contains a simple named capture where you have `tally` by reference
    ➊. The lambda also captures `to_count` by value, but you’ve elected to use the
    variable name `my_char` instead ➋. Of course, you’ll need to use the name `my_char`
    instead of `to_count` inside the lambda ➌.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*An initializer expression in a capture list is also called an init capture.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**Capturing this**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Sometimes lambda expressions have an enclosing class. You can capture an enclosing
    object (pointed-to by `this`) by value or by reference using either `[*this]`
    or `[this]`, respectively.
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 9-24](ch09.xhtml#ch09ex24) implements a `LambdaFactory` that generates
    counting lambdas and keeps track of a `tally`.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 9-24: A `LambdaFactory` illustrating the use of `this` capture*'
  prefs: []
  type: TYPE_NORMAL
- en: The `LambdaFactory` constructor takes a single character and initializes the
    `to_count` field with it. The `make_lambda` ➊ method illustrates how you can capture
    `this` by reference ➋ and use the `to_count` ➌ and `tally` ➍ member variables
    within the lambda expression.
  prefs: []
  type: TYPE_NORMAL
- en: Within `main`, you initialize a `factory` ➎ and make a `lambda` using the `make_``lambda`
    method ➏. The output is identical to [Listing 9-19](ch09.xhtml#ch09ex19), because
    you capture `this` by reference and state of `tally` persists across invocations
    of `lambda`.
  prefs: []
  type: TYPE_NORMAL
- en: '**Clarifying Examples**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: There are a lot of possibilities with capture lists, but once you have a command
    of the basics–capturing by value and by reference–there aren’t many surprises.
    [Table 9-2](ch09.xhtml#ch09tab02) provides short, clarifying examples that you
    can use for future reference.
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 9-2:** Clarifying Examples of Lambda Capture Lists'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Capture list** | **Meaning** |'
  prefs: []
  type: TYPE_TB
- en: '| `[&]` | Default capture by reference |'
  prefs: []
  type: TYPE_TB
- en: '| `[&,i]` | Default capture by reference; capture `i` by value |'
  prefs: []
  type: TYPE_TB
- en: '| `[=]` | Default capture by value |'
  prefs: []
  type: TYPE_TB
- en: '| `[=,&i]` | Default capture by value; capture `i` by reference |'
  prefs: []
  type: TYPE_TB
- en: '| `[i]` | Capture `i` by value |'
  prefs: []
  type: TYPE_TB
- en: '| `[&i]` | Capture `i` by reference |'
  prefs: []
  type: TYPE_TB
- en: '| `[i,&j]` | Capture `i` by value; capture `j` by reference |'
  prefs: []
  type: TYPE_TB
- en: '| `[i=j,&k]` | Capture `j` by value as `i`; capture `k` by reference |'
  prefs: []
  type: TYPE_TB
- en: '| `[this]` | Capture `enclosing object` by reference |'
  prefs: []
  type: TYPE_TB
- en: '| `[*this]` | Capture `enclosing object` by value |'
  prefs: []
  type: TYPE_TB
- en: '| `[=,*this,i,&j]` | Default capture by value; capture `this` and `i` by value;
    capture `j` by reference |'
  prefs: []
  type: TYPE_TB
- en: '***constexpr Lambda Expressions***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'All lambda expressions are `constexpr` as long as the lambda can be invoked
    at compile time. You can optionally make the `constexpr` declaration explicit,
    as in the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: You should mark a lambda `constexpr` if you want to make sure that it meets
    all `constexpr` requirements. As of C++17, this means no dynamic memory allocations
    and no calling non-`constexpr` functions, among other restrictions. The standards
    committee plans to loosen these restrictions with each release, so if you write
    a lot of code using `constexpr`, be sure to brush up on the latest `constexpr`
    constraints.
  prefs: []
  type: TYPE_NORMAL
- en: '**std::function**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Sometimes you just want a uniform container for storing callable objects. The
    `std::function` class template from the `<functional>` header is a polymorphic
    wrapper around a callable object. In other words, it’s a generic function pointer.
    You can store a static function, a function object, or a lambda into a `std::function`.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*The `*function*` class is in the stdlib. We’re presenting it a little ahead
    of schedule because it fits naturally.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'With `functions`, you can:'
  prefs: []
  type: TYPE_NORMAL
- en: Invoke without the caller knowing the function’s implementation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Assign, move, and copy
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Have an empty state, similar to a `nullptr`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '***Declaring a Function***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'To declare a `function`, you must provide a single template parameter containing
    the function prototype of the callable object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: The `std::function` class template has a number of constructors. The default
    constructor constructs a `std::function` in empty mode, meaning it contains no
    callable object.
  prefs: []
  type: TYPE_NORMAL
- en: '**Empty Functions**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: If you invoke a `std::function` with no contained object, `std::function` will
    throw a `std::bad_function_call` exception. Consider [Listing 9-25](ch09.xhtml#ch09ex25).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 9-25: The default `std::function` constructor and the `std::bad_function_call`
    exception*'
  prefs: []
  type: TYPE_NORMAL
- en: You default-construct a `std::function` ➊. The template parameter `void()` denotes
    a function taking no arguments and returning `void`. Because you didn’t fill `func`
    with a callable object, it’s in an empty state. When you invoke `func` ➋, it throws
    a `std::bad_function_call`, which you catch and print ➌.
  prefs: []
  type: TYPE_NORMAL
- en: '**Assigning a Callable Object to a Function**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: To assign a callable object to a `function`, you can either use the constructor
    or assignment operator of `function`, as in [Listing 9-26](ch09.xhtml#ch09ex26).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 9-26: Using the constructor and assignment operator of `function`*'
  prefs: []
  type: TYPE_NORMAL
- en: You declare the static function `static_func` that takes no arguments and returns
    `void` ➊. In `main`, you create a function called `func` ➋. The template parameter
    indicates that a callable object contained by `func` takes no arguments and returns
    `void`. You initialize `func` with a lambda that prints the message `A lambda`.
    You invoke `func` immediately afterward ➌, invoking the contained lambda and printing
    the expected message. Next, you assign `static_func` to `func`, which replaces
    the lambda you assigned upon construction ➍. You then invoke `func`, which invokes
    `static_func` rather than the lambda, so you see `A static function.` printed
    ➎.
  prefs: []
  type: TYPE_NORMAL
- en: '***An Extended Example***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: You can construct a `function` with callable objects, as long as that object
    supports the function semantics implied by the template parameter of `function`.
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 9-27](ch09.xhtml#ch09ex27) uses an array of `std::function` instances
    and fills it with a static function that counts spaces, a `CountIf` function object
    from [Listing 9-12](ch09.xhtml#ch09ex12), and a lambda that computes string length.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 9-27: Using a `std::function` array to iterate over a uniform collection
    of callable objects with varying underlying types*'
  prefs: []
  type: TYPE_NORMAL
- en: You declare a `std::function` array ➊ with static storage duration called `funcs`.
    The template argument is the function prototype for a function taking a `const
    char*` and returning a `size_t` ➋. In the `funcs` array, you pass in a static
    function pointer ➌, a function object ➍, and a lambda ➎. In `main`, you use a
    range-based `for` loop to iterate through each function in `funcs` ➏. You invoke
    each function `func` with the text `Sailor went to sea to see what he could see.`
    and print the result.
  prefs: []
  type: TYPE_NORMAL
- en: 'Notice that, from the perspective of `main`, all the elements in `funcs` are
    the same: you just invoke them with a null-terminated string and get back a `size_t`
    ➐.'
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Using a `function` can incur runtime overhead. For technical reasons, `function`
    might need to make a dynamic allocation to store the callable object. The compiler
    also has difficulty optimizing away `function` invocations, so you’ll often incur
    an indirect function call. Indirect function calls require additional pointer
    dereferences*.'
  prefs: []
  type: TYPE_NORMAL
- en: '**The main Function and the Command Line**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: All C++ programs must contain a global function with the name `main`. This function
    is defined as the program’s entry point, the function invoked at program startup.
    Programs can accept any number of environment-provided arguments called *command
    line parameters* upon startup.
  prefs: []
  type: TYPE_NORMAL
- en: 'Users pass command line parameters to programs to customize their behavior.
    You’ve probably used this feature when executing command line programs, as in
    the `copy` (on Linux: `cp`) command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: When invoking this command, you instruct the program to copy `file_a.txt` into
    `file_b.txt` by passing these values as command line parameters. As with command
    line programs you might be used to, it’s possible to pass values as command line
    parameters to your C++ programs.
  prefs: []
  type: TYPE_NORMAL
- en: You can choose whether your program handles command line parameters by how you
    declare `main`.
  prefs: []
  type: TYPE_NORMAL
- en: '***The Three main Overloads***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: You can access command line parameters within `main` by adding arguments to
    your `main` declaration.
  prefs: []
  type: TYPE_NORMAL
- en: There are three valid varieties of overload for `main`, as shown in [Listing
    9-28](ch09.xhtml#ch09ex28).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 9-28: The valid overloads for `main`*'
  prefs: []
  type: TYPE_NORMAL
- en: The first overload ➊ takes no parameters, which is the way you’ve been using
    `main()` in this book so far. Use this form if you want to ignore any arguments
    provided to your program.
  prefs: []
  type: TYPE_NORMAL
- en: 'The second overload ➋ accepts two parameters, `argc` and `argv`. The first
    argument, `argc`, is a non-negative number corresponding to the number of elements
    in `argv`. The environment calculates this automatically: you don’t have to provide
    the number of elements in `argc`. The second argument, `argv`, is an array of
    pointers to null-terminated strings that corresponds to an argument passed in
    from the execution environment.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The third overload ➌: is an extension of the second overload ➋: it accepts
    an arbitrary number of additional implementation parameters. This way, the target
    platform can offer some additional arguments to the program. Implementation parameters
    aren’t common in modern desktop environments.'
  prefs: []
  type: TYPE_NORMAL
- en: Usually, an operating system passes the full path to the program’s executable
    as the first command line argument. This behavior depends on your operating environment.
    On macOS, Linux, and Windows, the executable’s path is the first argument. The
    format of this path depends on the operating system. ([Chapter 17](ch17.xhtml)
    discusses filesystems in depth.)
  prefs: []
  type: TYPE_NORMAL
- en: '***Exploring Program Parameters***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Let’s build a program to explore how the operating system passes parameters
    to your program. [Listing 9-29](ch09.xhtml#ch09ex29) prints the number of command
    line arguments and then prints the index and value of the arguments on each line.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 9-29: A program that prints the command line arguments. Compile this
    program as `list_929`.*'
  prefs: []
  type: TYPE_NORMAL
- en: You declare main with the `argc`/`argv` overload, which makes command line parameters
    available to your program ➊. First, you print the number of command line arguments
    via `argc` ➋. Then you loop through each argument, printing its index and its
    value ➌.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s look at some sample output (on Windows 10 x64). Here is one program invocation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: Here, you provide no additional command line arguments aside from the name of
    the program, `list_929` ➊. (Depending on how you compiled the listing, you should
    replace this with the name of your executable.) On a Windows 10 x64 machine, the
    result is that your program receives a single argument ➋, the name of the executable
    ➌.
  prefs: []
  type: TYPE_NORMAL
- en: 'And here is another invocation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, you provide additional program arguments: `Violence is the last refuge
    of the incompetent.` ➊. You can see from the output that Windows has split the
    command line by spaces, resulting in a total of nine arguments.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In major desktop operating systems, you can force the operating system to treat
    such a phrase as a single argument by enclosing it within quotes, as in the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: '***A More Involved Example***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Now that you know how to process command line input, let’s consider a more involved
    example. A *histogram* is an illustration that shows a distribution’s relative
    frequency. Let’s build a program that computes a histogram of the letter distribution
    of the command line arguments.
  prefs: []
  type: TYPE_NORMAL
- en: 'Start with two helper functions that determine whether a given `char` is an
    uppercase letter or a lowercase letter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: The `pos_A, pos_Z, pos_a`, and `pos_z` constants contain the ASCII values of
    the letters A, Z, a, and z respectively (refer to the ASCII chart in [Table 2-4](ch02.xhtml#ch02tab04)).
    The `within_AZ` function determines whether some `char x` is an uppercase letter
    by determining whether its value is between `pos_A` and `pos_Z` inclusive ➊. The
    `within_az` function does the same for lowercase letters ➋.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you have some elements for processing ASCII data from the command line,
    let’s build an `AlphaHistogram` class that can ingest command line elements and
    store character frequencies, as shown in [Listing 9-30](ch09.xhtml#ch09ex30).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 9-30: An `AlphaHistogram` that ingests command line elements*'
  prefs: []
  type: TYPE_NORMAL
- en: An `AlphaHistogram` will store the frequency of each letter in the `counts`
    array ➌. This array initializes to zero whenever an `AlphaHistogram` is constructed.
    The `ingest` method will take a null-terminated string and update `counts` appropriately
    ➊. Then the `print` method will display the histogram information stored in `counts`
    ➋.
  prefs: []
  type: TYPE_NORMAL
- en: First, consider the implementation of `ingest` in [Listing 9-31](ch09.xhtml#ch09ex31).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 9-31: An implementation of the `ingest` method*'
  prefs: []
  type: TYPE_NORMAL
- en: Because `x` is a null-terminated string, you don’t know its length ahead of
    time. So, you initialize an `index` variable ➊ and use a `while` loop to extract
    a single `char c` at a time ➋. This loop will terminate if `c` is null, which
    is the end of the string. Within the loop, you use the `within_AZ` helper function
    to determine whether `c` is an uppercase letter ➌. If it is, you subtract `pos_A`
    from `c`. This normalizes an uppercase letter to the interval 0 to 25 to correspond
    with `counts`. You do the same check for lowercase letters using the `within_az`
    helper function ➍, and you update `counts` in case `c` is lowercase. If `c` is
    neither lowercase nor uppercase, `counts` is unaffected. Finally, you increment
    `index` before continuing to loop ➎.
  prefs: []
  type: TYPE_NORMAL
- en: Now, consider how to `print` `counts`, as shown in [Listing 9-32](ch09.xhtml#ch09ex32).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 9-32: An implementation of the `print` method*'
  prefs: []
  type: TYPE_NORMAL
- en: To print the histogram, you loop over each letter from A to Z ➊. Within the
    loop, you first print the `index` letter ➋, and then determine how many asterisks
    to print by extracting the correct letter out of `counts` ➌. You print the correct
    number of asterisks using a `while` loop ➍, and then you print a terminating newline
    ➎.
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 9-33](ch09.xhtml#ch09ex33) shows `AlphaHistogram` in action.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 9-33: A program illustrating `AlphaHistogram`*'
  prefs: []
  type: TYPE_NORMAL
- en: You iterate over each command line argument after the program name ➊, passing
    each into the `ingest` method of your `AlphaHistogram` object ➋. Once you’ve ingested
    them all, you print the `histogram` ➌. Each line corresponds to a letter, and
    the asterisks show the absolute frequency of the corresponding letter. As you
    can see, the phrase `The quick brown fox jumps over the lazy dog` contains each
    letter in the English alphabet.
  prefs: []
  type: TYPE_NORMAL
- en: '***Exit Status***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The `main` function can return an `int` corresponding to the exit status of
    the program. What the values represent is environment defined. On modern desktop
    systems, for example, a zero return value corresponds with a successful program
    execution. If no `return` statement is explicitly given, an implicit `return 0`
    is added by the compiler.
  prefs: []
  type: TYPE_NORMAL
- en: '**Summary**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This chapter took a deeper look at functions, including how to declare and define
    them, how to use the myriad keywords available to you to modify function behavior,
    how to specify return types, how overload resolution works, and how to take a
    variable number of arguments. After a discussion of how you take pointers to functions,
    you explored lambda expressions and their relationship to function objects. Then
    you learned about the entry point for your programs, the `main` function, and
    how to take command line arguments.
  prefs: []
  type: TYPE_NORMAL
- en: '**EXERCISES**'
  prefs: []
  type: TYPE_NORMAL
- en: '**9-1.** Implement a `fold` function template with the following prototype:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'For example, your implementation must support the following usage:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'The value of `sum` should be 1,500\. Use `fold` to calculate the following
    quantities: the `maximum`, the `minimum`, and the number of elements greater than
    200.'
  prefs: []
  type: TYPE_NORMAL
- en: '**9-2.** Implement a program that accepts an arbitrary number of command line
    arguments, counts the length in characters of each argument, and prints a histogram
    of the argument length distribution.'
  prefs: []
  type: TYPE_NORMAL
- en: '**9-3.** Implement an `all` function with the following prototype:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: The `Fn` function type is a `predicate` that supports `bool operator()(In)`.
    Your `all` function must test whether `function` returns `true` for every element
    of `input`. If it does, return `true`. Otherwise, return `false`.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, your implementation must support the following usage:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: '**FURTHER READING**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Functional Programming in C++: How to Improve Your C++ Programs Using Functional
    Techniques* by Ivan Čukić (Manning, 2019)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Clean Code: A Handbook of Agile Software Craftsmanship* by Robert C. Martin
    (Pearson Education, 2009'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
