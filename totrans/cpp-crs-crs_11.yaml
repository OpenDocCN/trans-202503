- en: '**9'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '**9'
- en: FUNCTIONS**
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '**函数**'
- en: '*Functions should do one thing. They should do it well. They should do it only.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: '*函数应该只做一件事，做好这件事，且只做这件事。*'
- en: —Robert C. Martin,* Clean Code
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: —罗伯特·C·马丁，*《代码整洁之道》*
- en: '![Image](../images/common.jpg)'
  id: totrans-4
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/common.jpg)'
- en: This chapter rounds out the ongoing discussion of functions, which encapsulate
    code into reusable components. Now that you’re armed with a strong background
    in C++ fundamentals, this chapter first revisits functions with a far more in-depth
    treatment of modifiers, specifiers, and return types, which appear in function
    declarations and specialize the behavior of your functions.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将继续讨论函数，这些函数将代码封装成可重用的组件。现在你已经掌握了C++基础知识，本章首先通过更加深入地讲解修饰符、说明符和返回类型来回顾函数，这些内容出现在函数声明中并专门化函数的行为。
- en: Then you’ll learn about overload resolution and accepting variable numbers of
    arguments before exploring function pointers, type aliases, function objects,
    and the venerable lambda expression. The chapter closes with an introduction to
    the `std::function` before revisiting the `main` function and accepting command
    line arguments.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 然后你将学习重载解析以及接受可变数量的参数，接着探索函数指针、类型别名、函数对象和久负盛名的lambda表达式。本章的最后将介绍`std::function`，然后再次回顾`main`函数并接受命令行参数。
- en: '**Function Declarations**'
  id: totrans-7
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**函数声明**'
- en: 'Function declarations have the following familiar form:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 函数声明具有以下熟悉的形式：
- en: '[PRE0]'
  id: totrans-9
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: You can provide a number of optional *modifiers* (or *specifiers*) to functions.
    Modifiers alter a function’s behavior in some way. Some modifiers appear at the
    beginning in the function’s declaration or definition (*prefix modifiers*), whereas
    others appear at the end (*suffix modifiers*). The prefix modifiers appear before
    the return type. The suffix modifiers appear after the argument list.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以为函数提供多个可选的*修饰符*（或*说明符*）。修饰符会以某种方式改变函数的行为。一些修饰符出现在函数声明或定义的开头（*前缀修饰符*），而其他修饰符出现在结尾（*后缀修饰符*）。前缀修饰符出现在返回类型之前，后缀修饰符出现在参数列表之后。
- en: 'There isn’t a clear language reason why certain modifiers appear as prefixes
    or suffixes: because C++ has a long history, these features evolved incrementally.'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 没有明确的语言原因说明为什么某些修饰符作为前缀或后缀出现：因为C++有着悠久的历史，这些特性是逐步演变而来的。
- en: '***Prefix Modifiers***'
  id: totrans-12
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***前缀修饰符***'
- en: 'At this point, you already know several prefix modifiers:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 到此为止，你已经了解了几个前缀修饰符：
- en: 'The prefix `static` indicates that a function that isn’t a member of a class
    has internal linkage, meaning the function won’t be used outside of this translation
    unit. Unfortunately, this keyword does double duty: if it modifies a method (that
    is, a function inside a class), it indicates that the function isn’t associated
    with an instantiation of the class but rather with the class itself (see [Chapter
    4](ch04.xhtml#ch04)).'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 前缀`static`表示一个非类成员的函数具有内部链接，意味着该函数在此翻译单元外部不会被使用。不幸的是，这个关键字具有双重作用：如果它修饰的是一个方法（即类中的函数），它表示该函数不与类的实例化关联，而是与类本身关联（见[第4章](ch04.xhtml#ch04)）。
- en: The modifier `virtual` indicates that a method can be overridden by a child
    class. The `override` modifier indicates to the compiler that a child class intends
    to override a parent’s virtual function (see [Chapter 5](ch05.xhtml#ch05)).
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 修饰符`virtual`表示方法可以被子类重写。修饰符`override`则向编译器表明子类打算重写父类的虚函数（见[第5章](ch05.xhtml#ch05)）。
- en: The modifier `constexpr` indicates that the function should be evaluated at
    compile time if possible (see [Chapter 7](ch07.xhtml#ch07)).
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 修饰符`constexpr`表示函数应在编译时进行求值（见[第7章](ch07.xhtml#ch07)）。
- en: The modifier `[[noreturn]]` indicates that this function won’t return (see [Chapter
    8](ch08.xhtml#ch08)). Recall that this attribute helps the compiler to optimize
    your code.
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 修饰符`[[noreturn]]`表示该函数不会返回（见[第8章](ch08.xhtml#ch08)）。回想一下，这个属性有助于编译器优化你的代码。
- en: Another prefix modifier is `inline`, which plays a role in guiding the compiler
    when optimizing code.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个前缀修饰符是`inline`，它在优化代码时指导编译器的作用。
- en: 'On most platforms, a function call compiles into a series of instructions,
    such as the following:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数平台上，函数调用会编译成一系列指令，如下所示：
- en: Place arguments into registers and on the call stack.
  id: totrans-20
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将参数放入寄存器和调用栈中。
- en: Push a return address onto the call stack.
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将返回地址压入调用栈。
- en: Jump to the called function.
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 跳转到被调用的函数。
- en: After the function completes, jump to the return address.
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 函数完成后，跳转到返回地址。
- en: Clean up the call stack.
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 清理调用栈。
- en: These steps typically execute very quickly, and the payoff in reduced binary
    size can be substantial if you use a function in many places.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 这些步骤通常执行得非常迅速，并且如果你在多个地方使用一个函数，减少的二进制文件大小可能会带来显著的收益。
- en: '*Inlining a function* means copying and pasting the contents of the function
    directly into the execution path, eliminating the need for the five steps outlined.
    This means that as the processor executes your code, it will immediately execute
    your function’s code rather than executing the (modest) ceremony required for
    function invocation. If you prefer this marginal increase in speed over the commensurate
    cost in increased binary size, you can use the `inline` keyword to indicate this
    to the compiler. The `inline` keyword hints to the compiler’s optimizer to put
    a function directly inline rather than perform a function call.'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '*内联函数*意味着将函数的内容直接复制并粘贴到执行路径中，省去了五个步骤的必要。这意味着当处理器执行你的代码时，它将立即执行函数的代码，而不是执行调用函数时所需的（适度的）程序。如果你更倾向于这种对速度的轻微提升，而不介意增加的二进制文件大小，可以使用`inline`关键字来向编译器表明这一点。`inline`关键字提示编译器的优化器将函数直接内联，而不是执行函数调用。'
- en: Adding `inline` to a function doesn’t change its behavior; it’s purely an expression
    of preference to the compiler. You must ensure that if you define a function `inline`,
    you do so in all translation units. Also note that modern compilers will typically
    inline functions where it makes sense—especially if a function isn’t used outside
    of a single translation unit.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 向函数添加`inline`不会改变其行为；它只是编译器偏好的表达方式。你必须确保如果你定义了`inline`函数，必须在所有翻译单元中都这么做。另外请注意，现代编译器通常会在适当的地方内联函数，尤其是当一个函数仅在一个翻译单元内使用时。
- en: '***Suffix Modifiers***'
  id: totrans-28
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***后缀修饰符***'
- en: 'At this point in the book, you already know two suffix modifiers:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书的这一部分，你已经了解了两个后缀修饰符：
- en: The modifier `noexcept` indicates that the function will *never* throw an exception.
    It enables certain optimizations (see [Chapter 4](ch04.xhtml#ch04)).
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 修饰符`noexcept`表示该函数*永远*不会抛出异常。它使得某些优化成为可能（见[第4章](ch04.xhtml#ch04)）。
- en: The modifier `const` indicates that the method won’t modify an instance of its
    class, allowing `const` references types to invoke the method (see [Chapter 4](ch04.xhtml#ch04)).
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 修饰符`const`表示该方法不会修改其类的实例，从而允许`const`引用类型调用该方法（见[第4章](ch04.xhtml#ch04)）。
- en: 'This section explores three more suffix modifiers: `final`, `override`, and
    `volatile`.'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 本节将探讨另外三个后缀修饰符：`final`、`override`和`volatile`。
- en: '**final and override**'
  id: totrans-33
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**final 和 override**'
- en: The `final` modifier indicates that a method cannot be overridden by a child
    class. It’s effectively the opposite of `virtual`. [Listing 9-1](ch09.xhtml#ch09ex01)
    attempts to override a `final` method and yields a compiler error.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '`final`修饰符表示一个方法不能被子类重写。它实际上是`virtual`的反义词。[列表 9-1](ch09.xhtml#ch09ex01)尝试重写一个`final`方法并导致编译错误。'
- en: '[PRE1]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '*Listing 9-1: A class attempting to override a final method (This code doesn’t
    compile.)*'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 9-1：一个类尝试重写一个final方法（这段代码无法编译）。*'
- en: This listing marks the `shoot` method `final` ➊. Within `BostonCorbettJunior`,
    which inherits from `BostonCorbett`, you attempt to `override` the `shoot` method
    ➋. This causes a compiler error.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 这个列表将`shoot`方法标记为`final` ➊。在继承自`BostonCorbett`的`BostonCorbettJunior`中，你尝试`override`（重写）`shoot`方法
    ➋。这将导致编译错误。
- en: You can also apply the `final` keyword to an entire class, disallowing that
    class from becoming a parent entirely, as demonstrated in [Listing 9-2](ch09.xhtml#ch09ex02).
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以将`final`关键字应用于整个类，禁止该类成为父类，正如[列表 9-2](ch09.xhtml#ch09ex02)中所示。
- en: '[PRE2]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '*Listing 9-2: A program with a class attempting to inherit from a final class.
    (This code doesn’t compile.)*'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 9-2：一个类尝试从一个 final 类继承（这段代码无法编译）。*'
- en: The `BostonCorbett` class is marked as `final` ➊, and this causes a compiler
    error when you attempt to inherit from it in `BostonCorbettJunior` ➋.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '`BostonCorbett`类被标记为`final` ➊，当你尝试在`BostonCorbettJunior`中继承它时会导致编译错误 ➋。'
- en: '**NOTE**'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*Neither `final` nor `override` is technically a language keyword; they are
    *identifiers*. Unlike keywords, identifiers gain special meaning only when used
    in a specific context. This means you can use `final` and `override` as symbol
    names elsewhere in your program, thereby leading to the insanity of constructions
    like `virtual void final() override`. Try not to do this.*'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '*`final`和`override`在技术上不是语言关键字；它们是*标识符*。与关键字不同，标识符只有在特定上下文中使用时才会获得特殊含义。这意味着你可以在程序的其他地方使用`final`和`override`作为符号名，从而导致像`virtual
    void final() override`这样的疯狂构造。尽量避免这么做。*'
- en: Whenever you’re using interface inheritance, you should mark implementing classes
    `final` because the modifier can encourage the compiler to perform an optimization
    called *devirtualization*. When virtual calls are devirtualized, the compiler
    eliminates the runtime overhead associated with a virtual call.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 每当使用接口继承时，应该将实现类标记为 `final`，因为这个修饰符可以促使编译器执行一种叫做 *去虚拟化*（devirtualization）的优化。当虚拟调用被去虚拟化时，编译器会消除与虚拟调用相关的运行时开销。
- en: '**volatile**'
  id: totrans-45
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**volatile**'
- en: Recall from [Chapter 7](ch07.xhtml#ch07) that a volatile object’s value can
    change at any time, so the compiler must treat all accesses to volatile objects
    as visible side effects for optimization purposes. The `volatile` keyword indicates
    that a method can be invoked on volatile objects. This is analogous to how `const`
    methods can be applied to `const` objects. Together, these two keywords define
    a method’s *const/volatile qualification* (or sometimes *cv qualification*), as
    demonstrated in [Listing 9-3](ch09.xhtml#ch09ex03).
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 回想一下 [第7章](ch07.xhtml#ch07)，`volatile` 对象的值可以随时变化，因此编译器必须将对 `volatile` 对象的所有访问视为可见副作用，以便进行优化。`volatile`
    关键字表示可以对 `volatile` 对象调用方法。这类似于 `const` 方法可以应用于 `const` 对象。结合这两个关键字，它们定义了一个方法的
    *const/volatile 资格*（有时称为 *cv 资格*），如 [列表 9-3](ch09.xhtml#ch09ex03) 所示。
- en: '[PRE3]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '*Listing 9-3: Illustrating the use of a `volatile` method*'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 9-3：展示如何使用 `volatile` 方法*'
- en: In this listing, you declare the `apply` method on the `Distillate` class `vola``tile`
    ➊. You also create a `volatile Distillate` called `ethanol` within `main` ➋. Because
    the `apply` method is `volatile`, you can still invoke it ➌ (even though `ethanol`
    is `volatile`).
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，你在 `Distillate` 类上声明了 `apply` 方法 `vola``tile` ➊。你还在 `main` 中创建了一个名为 `ethanol`
    的 `volatile Distillate` ➋。由于 `apply` 方法是 `volatile` 的，你仍然可以调用它 ➌（即使 `ethanol`
    是 `volatile`）。
- en: 'Had you not marked `apply volatile` ➊, the compiler would emit an error when
    you attempted to invoke it ➌. Just like you cannot invoke a non-`const` method
    on a `const` object, you cannot invoke a non-`volatile` method on a `volatile`
    object. Consider what would happen if you could perform such an operation: a non-`volatile`
    method is a candidate for all kinds of compiler optimizations for the reasons
    outlined in [Chapter 7](ch07.xhtml#ch07): many kinds of memory accesses can be
    optimized away without changing the observable side effects of your program.'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你没有标记 `apply volatile` ➊，当你尝试调用它时，编译器会抛出错误 ➌。就像你不能对 `const` 对象调用非 `const`
    方法一样，你不能对 `volatile` 对象调用非 `volatile` 方法。想象一下如果可以执行这样的操作会发生什么：非 `volatile` 方法是编译器优化的候选，因为如
    [第7章](ch07.xhtml#ch07) 中所述，许多种内存访问可以在不改变程序可观察副作用的情况下被优化掉。
- en: How should the compiler treat a contradiction arising from you using a `volatile`
    object—which requires that all its memory accesses are treated as observable side
    effects—to invoke a non-`volatile` method? The compiler’s answer is that it calls
    this contradiction an error.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 编译器应该如何处理因使用 `volatile` 对象——它要求所有内存访问被视为可观察的副作用——来调用一个非 `volatile` 方法时产生的矛盾？编译器的回答是，将这种矛盾视为错误。
- en: '**auto Return Types**'
  id: totrans-52
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**auto 返回类型**'
- en: 'There are two ways to declare the return value of a function:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 有两种方式声明函数的返回值：
- en: (Primary) Lead a function declaration with its return type, as you’ve been doing
    all along.
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: （主要）像之前一样，使用返回类型来引导函数声明。
- en: (Secondary) Have the compiler deduce the correct return type by using `auto`.
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: （次要）通过使用 `auto`，让编译器推导出正确的返回类型。
- en: As with `auto` type deduction, the compiler deduces the return type, fixing
    the runtime type.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 和 `auto` 类型推导一样，编译器会推导出返回类型，固定运行时类型。
- en: This feature should be used judiciously. Because function definitions are documentation,
    it’s best to provide concrete return types when available.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 这个特性应该谨慎使用。因为函数定义本身就是文档，因此在可能的情况下，最好提供具体的返回类型。
- en: '**auto and Function Templates**'
  id: totrans-58
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**auto 和函数模板**'
- en: 'The primary use case for `auto` type deduction is with function templates,
    where a return type can depend (in potentially complicated ways) on the template
    parameters. Its usage is as follows:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '`auto` 类型推导的主要用例是在函数模板中，其中返回类型可能依赖（以潜在复杂的方式）于模板参数。其用法如下：'
- en: '[PRE4]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'It’s possible to extend the `auto`-return-type deduction syntax to provide
    the return type as a suffix with the arrow operator `->`. This way, you can append
    an expression that evaluates to the function’s return type. Its usage is as follows:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 可以将 `auto` 返回类型推导语法扩展为通过箭头操作符 `->` 提供返回类型作为后缀。这样，你可以附加一个表达式，该表达式计算出函数的返回类型。其用法如下：
- en: '[PRE5]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Usually, you wouldn’t use this pedantic form, but in certain situations it’s
    helpful. For example, this form of `auto` type deduction is commonly paired with
    a `decltype` type expression. A `decltype` type expression yields another expression’s
    resultant type. Its usage is as follows:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，你不会使用这种冗长的形式，但在某些情况下它非常有用。例如，这种形式的 `auto` 类型推导通常与 `decltype` 类型表达式搭配使用。`decltype`
    类型表达式返回另一个表达式的结果类型。它的用法如下：
- en: '[PRE6]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'This expression resolves to the resulting type of the expression. For example,
    the following `decltype` expression yields `int`, because the integer literal
    100 has that type:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 这个表达式会解析为表达式的结果类型。例如，以下 `decltype` 表达式返回 `int`，因为整数字面量 100 的类型是 `int`：
- en: '[PRE7]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Outside of generic programming with templates, `decltype` is rare.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在模板的泛型编程之外，`decltype` 是一种罕见的用法。
- en: You can combine `auto`-return-type deduction and `decltype` to document the
    return types of function templates. Consider the `add` function in [Listing 9-4](ch09.xhtml#ch09ex04),
    which defines a function template `add` that adds two arguments together.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以结合 `auto` 返回类型推导和 `decltype` 来记录函数模板的返回类型。考虑 [示例 9-4](ch09.xhtml#ch09ex04)
    中的 `add` 函数，它定义了一个 `add` 函数模板，用来将两个参数相加。
- en: '[PRE8]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '*Listing 9-4: Using `decltype` and `auto`-return-type deduction*'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '*示例 9-4：使用 `decltype` 和 `auto` 返回类型推导*'
- en: 'The `add` function employs `auto` type deduction with the `decltype` type expression
    ➊. Each time you instantiate a template with two types `X` and `Y`, the compiler
    evaluates `decltype(X + Y)` and fixes the return type of `add`. Within `main`,
    you provide three instantiations. First, you add a `double` and an `int` ➋. The
    compiler determines that `decltype(double{ 100\. } + int{ -10 })` is a `double`,
    which fixes the return type of this `add` instantiation. This, in turn, sets the
    type of `my_double` to `double` ➋. You have two other instantiations: one for
    an `unsigned int` and `int` (which results in an `unsigned int` ➌) and another
    for a `char` and an `unsigned long long` (which results in an `unsigned long long`
    ➍).'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '`add` 函数使用 `auto` 类型推导结合 `decltype` 类型表达式 ➊。每次你用两个类型 `X` 和 `Y` 实例化模板时，编译器会评估
    `decltype(X + Y)`，并确定 `add` 的返回类型。在 `main` 中，你提供了三种实例化。首先，你将一个 `double` 和一个 `int`
    相加 ➋。编译器确定 `decltype(double{ 100\. } + int{ -10 })` 是一个 `double`，这就确定了该 `add`
    实例化的返回类型。反过来，这也将 `my_double` 的类型设定为 `double` ➋。你还有两个其他的实例化：一个是 `unsigned int`
    和 `int`（结果是 `unsigned int` ➌），另一个是 `char` 和 `unsigned long long`（结果是 `unsigned
    long long` ➍）。'
- en: '**Overload Resolution**'
  id: totrans-72
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**重载解析**'
- en: '*Overload resolution* is the process that the compiler executes when matching
    a function invocation with its proper implementation.'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '*重载解析* 是编译器在将函数调用与其正确实现匹配时执行的过程。'
- en: Recall from [Chapter 4](ch04.xhtml#ch04) that function overloads allow you to
    specify functions with the same name but different types and possibly different
    arguments. The compiler selects among these function overloads by comparing the
    argument types within the function invocation with the types within each overload
    declaration. The compiler will choose the best among the possible options, and
    if it cannot select a best option, it will generate a compiler error.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 回顾 [第 4 章](ch04.xhtml#ch04)，函数重载允许你指定具有相同名称但不同类型和可能不同参数的函数。编译器通过将函数调用中的参数类型与每个重载声明中的类型进行比较，从而选择其中的一个重载。编译器会在可能的选项中选择最佳的，如果无法选择最佳选项，它将生成编译错误。
- en: 'Roughly, the matching process proceeds as follows:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 大致而言，匹配过程如下：
- en: The compiler will look for an exact type match.
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编译器会寻找一个精确的类型匹配。
- en: The compiler will try using integral and floating-point promotions to get a
    suitable overload (for example, `int` to `long` or `float` to `double`).
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编译器会尝试使用整数和浮点数的转换来获得合适的重载（例如，从 `int` 到 `long` 或从 `float` 到 `double`）。
- en: The compiler will try to match using standard conversions like integral type
    to floating-point or casting a pointer-to-child into a pointer-to-parent.
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编译器会尝试使用标准转换来进行匹配，比如将整数类型转换为浮点数，或者将指向子类的指针转换为指向父类的指针。
- en: The compiler will look for a user-defined conversion.
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编译器会寻找用户定义的转换。
- en: The compiler will look for a variadic function.
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编译器会寻找一个变参函数。
- en: '**Variadic Functions**'
  id: totrans-81
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**变参函数**'
- en: '*Variadic functions* take a variable number of arguments. Typically, you specify
    the exact number of arguments a function takes by enumerating all of its parameters
    explicitly. With a variadic function, you can take any number of arguments. The
    variadic function `printf` is a canonical example: you provide a format specifier
    and an arbitrary number of parameters. Because `printf` is a variadic function,
    it accepts any number of parameters.'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '*变参函数*接受可变数量的参数。通常，你通过明确列出所有参数来指定函数所接受的参数数量。使用变参函数时，你可以接受任意数量的参数。变参函数 `printf`
    就是一个典型的例子：你提供一个格式说明符和任意数量的参数。因为 `printf` 是变参函数，所以它接受任何数量的参数。'
- en: '**NOTE**'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*The astute Pythonista will note an immediate conceptual relationship between
    variadic functions and `*args`/`**kwargs`.*'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '*机智的 Pythonista 会立刻注意到变参函数与 `*args`/`**kwargs` 之间的概念关系。*'
- en: You declare variadic functions by placing `...` as the final parameter in the
    function’s argument list. When a variadic function is invoked, the compiler matches
    arguments against declared arguments. Any leftovers pack into the variadic arguments
    represented by the `...` argument.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 你通过将 `...` 放置为函数参数列表的最后一个参数来声明变参函数。当调用变参函数时，编译器会将传入的参数与声明的参数进行匹配。多余的参数将打包成 `...`
    表示的变参。
- en: You cannot extract elements from the variadic arguments directly. Instead, you
    access individual arguments using the utility functions in the `<cstdarg>` header.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 你不能直接从变参中提取元素。相反，你需要使用 `<cstdarg>` 头文件中的工具函数来访问每个单独的参数。
- en: '[Table 9-1](ch09.xhtml#ch09tab01) lists these utility functions.'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '[表 9-1](ch09.xhtml#ch09tab01)列出了这些工具函数。'
- en: '**Table 9-1:** Utility Functions in the `<cstdarg>` Header'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '**表 9-1：** `<cstdarg>` 头文件中的工具函数'
- en: '| **Function** | **Description** |'
  id: totrans-89
  prefs: []
  type: TYPE_TB
  zh: '| **函数** | **描述** |'
- en: '| `va_list` | Used to declare a local variable representing the variadic arguments
    |'
  id: totrans-90
  prefs: []
  type: TYPE_TB
  zh: '| `va_list` | 用于声明表示变参参数的局部变量 |'
- en: '| `va_start` | Enables access to the variadic arguments |'
  id: totrans-91
  prefs: []
  type: TYPE_TB
  zh: '| `va_start` | 启用访问变参参数 |'
- en: '| `va_end` | Used to end iteration over the variadic arguments |'
  id: totrans-92
  prefs: []
  type: TYPE_TB
  zh: '| `va_end` | 用于结束对变参参数的遍历 |'
- en: '| `va_arg` | Used to iterate over each element in the variadic arguments |'
  id: totrans-93
  prefs: []
  type: TYPE_TB
  zh: '| `va_arg` | 用于遍历变参参数中的每个元素 |'
- en: '| `va_copy` | Makes a copy of the variadic arguments |'
  id: totrans-94
  prefs: []
  type: TYPE_TB
  zh: '| `va_copy` | 创建变参参数的副本 |'
- en: The utility functions’ usage is a little convoluted and best presented in a
    cohesive example. Consider the variadic `sum` function in [Listing 9-5](ch09.xhtml#ch09ex05),
    which contains a variadic argument.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 工具函数的使用有些复杂，最好通过一个连贯的示例来展示。考虑 [示例 9-5](ch09.xhtml#ch09ex05) 中的变参 `sum` 函数，它包含一个变参参数。
- en: '[PRE9]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '*Listing 9-5: A `sum` function with a variadic argument list*'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '*示例 9-5：一个具有变参列表的 `sum` 函数*'
- en: You declare `sum` as a variadic function ➊. All variadic functions must declare
    a `va_list`. You’ve named it `args` ➋. A `va_list` requires initialization with
    `va_start` ➌, which takes two arguments. The first argument is a `va_list`, and
    the second is the size of the variadic arguments. You iterate over each element
    in the variadic arguments using the `va_args` function. The first argument is
    the `va_list` argument, and the second is the argument type ➍. Once you’ve completed
    iterating, you call `va_end` with the `va_list` structure ➎.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 你将 `sum` 声明为变参函数 ➊。所有变参函数必须声明一个 `va_list`。你将其命名为 `args` ➋。`va_list` 需要通过 `va_start`
    初始化 ➌，后者接受两个参数。第一个参数是 `va_list`，第二个是变参参数的大小。你通过 `va_args` 函数遍历变参中的每个元素。第一个参数是
    `va_list`，第二个是参数类型 ➍。遍历完成后，你通过 `va_end` 来结束遍历，传入 `va_list` 结构体 ➎。
- en: 'You invoke `sum` with seven arguments: the first is the number of variadic
    arguments (six) followed by six numbers (2, 4, 6, 8, 10, 12) ➏.'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 你调用 `sum` 函数时传入七个参数：第一个是变参参数的数量（六个），后面是六个数字（2, 4, 6, 8, 10, 12）➏。
- en: Variadic functions are a holdover from C. Generally, variadic functions are
    unsafe and a common source of security vulnerabilities.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 变参函数是从C语言继承下来的。通常，变参函数不安全，是常见的安全漏洞源。
- en: 'There are at least two major problems with variadic functions:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 变参函数至少存在两个主要问题：
- en: Variadic arguments are not type-safe. (Notice that the second argument of `va_arg`
    is a type.)
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 变参参数不是类型安全的。（注意 `va_arg` 的第二个参数是类型。）
- en: The number of elements in the variadic arguments must be tracked separately.
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 变参参数的元素数量必须单独跟踪。
- en: The compiler cannot help you with either of these issues.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 编译器无法帮助你解决这些问题。
- en: Fortunately, variadic templates provide a safer and more performant way to implement
    variadic functions.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，变参模板提供了一种更安全且性能更高的实现变参函数的方式。
- en: '**Variadic Templates**'
  id: totrans-106
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**变参模板**'
- en: The variadic template enables you to create function templates that accept variadic,
    same-typed arguments. They enable you to employ the considerable power of the
    template engine. To declare a variadic template, you add a special template parameter
    called a *template parameter pack*. [Listing 9-6](ch09.xhtml#ch09ex06) demonstrates
    its usage.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 变参模板使你能够创建接受变参且类型相同的函数模板。它们使你能够利用模板引擎的强大功能。要声明变参模板，你需要添加一个特殊的模板参数，叫做*模板参数包*。[清单
    9-6](ch09.xhtml#ch09ex06)展示了它的用法。
- en: '[PRE10]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '*Listing 9-6: A template function with a parameter pack*'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 9-6：一个带有参数包的模板函数*'
- en: 'The template parameter pack is part of the template parameter list ➊. When
    you use `Args` within the function template ➋, it’s called a *function parameter
    pack*. Some special operators are available for use with parameter packs:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 模板参数包是模板参数列表的一部分 ➊。当你在函数模板 ➋ 中使用`Args`时，它被称为*函数参数包*。有一些特殊的操作符可以与参数包一起使用：
- en: You can use `sizeof...(args)` to obtain the parameter pack’s size.
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以使用`sizeof...(args)`来获取参数包的大小。
- en: You can invoke a function (for example, `other_function`) with the special syntax
    `other_function(args...)`. This expands the parameter pack `args` and allows you
    to perform further processing on the arguments contained in the parameter pack.
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以使用特殊语法`other_function(args...)`调用一个函数（例如`other_function`）。这会展开参数包`args`，并允许你对参数包中的参数进行进一步处理。
- en: '***Programming with Parameter Packs***'
  id: totrans-113
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***使用参数包编程***'
- en: Unfortunately, it’s not possible to index into a parameter pack directly. You
    must invoke the function template from within itself—a process called *compile-time
    recursion*—to recursively iterate over the elements in a parameter pack.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，无法直接对参数包进行索引。你必须从函数模板内部调用自己——这个过程叫做*编译时递归*——以递归地遍历参数包中的元素。
- en: '[Listing 9-7](ch09.xhtml#ch09ex07) demonstrates the pattern.'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '[清单 9-7](ch09.xhtml#ch09ex07)展示了这一模式。'
- en: '[PRE11]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '*Listing 9-7: A template function illustrating compile-time recursion with
    parameter packs. Unlike other usage listings, the ellipses contained in this listing
    are literal.*'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 9-7：一个示范编译时递归与参数包的模板函数。与其他用法清单不同，清单中包含的省略号是字面上的。*'
- en: The key is to add a regular template parameter before the parameter pack ➊.
    Each time you invoke `my_func`, `x` absorbs the first argument. The remainder
    packs into `args`. To invoke, you use the `args...` construct to expand the parameter
    pack ➋.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 关键是要在参数包之前添加一个常规模板参数 ➊。每次调用`my_func`时，`x`会吸收第一个参数，其余的会打包到`args`中。要调用时，你使用`args...`构造来展开参数包
    ➋。
- en: 'The recursion needs a stopping criteria, so you add a function template specialization
    without the parameter:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 递归需要一个停止条件，因此你添加一个没有参数的函数模板特化：
- en: '[PRE12]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '***Revisiting the sum Function***'
  id: totrans-121
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***重新审视求和函数***'
- en: Consider the (much improved) `sum` function implemented as a variadic template
    in [Listing 9-8](ch09.xhtml#ch09ex08).
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑在[清单 9-8](ch09.xhtml#ch09ex08)中作为变参模板实现的（经过大幅改进的）`sum`函数。
- en: '[PRE13]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '*Listing 9-8: A refactor of [Listing 9-5](ch09.xhtml#ch09ex05) using a template
    parameter pack instead of `va_args`*'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 9-8：使用模板参数包替代`va_args`的[清单 9-5](ch09.xhtml#ch09ex05)的重构版*'
- en: The first function ➋ is the overload that handles the stopping condition; if
    the function has only a single argument, you simply return the argument `x,` because
    the sum of a single element is just the element. The variadic template ➍ follows
    the recursion pattern outlined in [Listing 9-7](ch09.xhtml#ch09ex07). It peels
    a single argument `x` off the parameter pack `args` and then returns `x` plus
    the result of the recursive call to `sum` with the expanded parameter pack ➎.
    Because all of this generic programming can be computed at compile time, you mark
    these functions `constexpr` ➊➌. This compile-time computation is a *major* advantage
    over [Listing 9-5](ch09.xhtml#ch09ex05), which has identical output but computes
    the result at runtime ➏. (Why pay runtime costs when you don’t have to?)
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个函数 ➋ 是处理停止条件的重载；如果函数只有一个参数，你只需返回参数`x,`，因为单个元素的和就是该元素。变参模板 ➍ 遵循[清单 9-7](ch09.xhtml#ch09ex07)中概述的递归模式。它从参数包`args`中去除一个参数`x`，然后返回`x`加上递归调用`sum`时展开的参数包
    ➎ 的结果。由于所有这些通用编程都可以在编译时计算，所以你将这些函数标记为`constexpr` ➊➌。这种编译时计算是*主要*的优势，相较于[清单 9-5](ch09.xhtml#ch09ex05)，虽然它们的输出相同，但会在运行时计算结果
    ➏。（既然不需要，为什么要支付运行时的代价呢？）
- en: When you just want to apply a single binary operator (like plus or minus) over
    a range of values (like [Listing 9-5](ch09.xhtml#ch09ex05)), you can use a fold
    expression instead of recursion.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 当你只想对一系列值（如[列表 9-5](ch09.xhtml#ch09ex05)中的值）应用单一的二元运算符（如加法或减法）时，你可以使用折叠表达式而非递归。
- en: '***Fold Expressions***'
  id: totrans-127
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***折叠表达式***'
- en: 'A *fold expression* computes the result of using a binary operator over all
    the arguments of a parameter pack. Fold expressions are distinct from but related
    to variadic templates. Their usage is as follows:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '*折叠表达式*计算在参数包的所有参数上使用二元运算符的结果。折叠表达式与可变参数模板不同，但相关。它们的使用方法如下：'
- en: '[PRE14]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'For example, you could employ the following fold expression to sum over all
    elements in a parameter pack called `args`:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，你可以使用以下折叠表达式来对名为`args`的参数包中的所有元素进行求和：
- en: '[PRE15]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '[Listing 9-9](ch09.xhtml#ch09ex09) refactors 9-8 to use a fold expression instead
    of recursion.'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 9-9](ch09.xhtml#ch09ex09)将 9-8 重构为使用折叠表达式而非递归。'
- en: '[PRE16]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '*Listing 9-9: A refactor of [Listing 9-8](ch09.xhtml#ch09ex08) using a fold
    expression*'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 9-9：将 [列表 9-8](ch09.xhtml#ch09ex08) 使用折叠表达式进行重构*'
- en: You simplify the `sum` function by using a fold expression instead of the recursion
    approach ➊. The end result is identical ➋.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 你通过使用折叠表达式来简化`sum`函数，而不是使用递归方法 ➊。最终结果是相同的 ➋。
- en: '**Function Pointers**'
  id: totrans-136
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**函数指针**'
- en: '*Functional programming* is a programming paradigm that emphasizes function
    evaluation and immutable data. One of the major concepts in functional programming
    is to pass a function as a parameter to another function.'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '*函数式编程*是一种编程范式，强调函数求值和不可变数据。函数式编程中的一个主要概念是将函数作为参数传递给另一个函数。'
- en: One way you can achieve this is to pass a function pointer. Functions occupy
    memory, just like objects. You can refer to this memory address via usual pointer
    mechanisms. However, unlike objects, you cannot modify the pointed-to function.
    In this respect, functions are conceptually similar to `const` objects. You can
    take the address of functions and invoke them, and that’s about it.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过传递函数指针来实现这一点。函数占用内存，就像对象一样。你可以通过常规的指针机制引用这个内存地址。然而，与对象不同的是，你不能修改指向的函数。从这个角度看，函数在概念上类似于`const`对象。你可以获取函数的地址并调用它们，仅此而已。
- en: '***Declaring a Function Pointer***'
  id: totrans-139
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***声明函数指针***'
- en: 'To declare a function pointer, use the following ugly syntax:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 要声明一个函数指针，请使用以下丑陋的语法：
- en: '[PRE17]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: This has the same appearance as a function declaration where the function name
    is replaced (`*pointer-name`).
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 这与函数声明的外观相同，只是函数名被替换为（`*pointer-name`）。
- en: As usual, you can employ the address-of operator `&` to take the address of
    a function. This is optional, however; you can simply use the function name as
    a pointer.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 像往常一样，你可以使用取地址符号`&`来获取函数的地址。然而，这不是必须的；你也可以直接使用函数名作为指针。
- en: '[Listing 9-10](ch09.xhtml#ch09ex10) illustrates how you can obtain and use
    function pointers.'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 9-10](ch09.xhtml#ch09ex10)展示了如何获取并使用函数指针。'
- en: '[PRE18]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '*Listing 9-10: A program illustrating function pointers. (Due to address space
    layout randomization, the addresses ➍➐ will vary at runtime.)*'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 9-10：一个展示函数指针的程序。（由于地址空间布局随机化，地址 ➍➐ 在运行时会有所不同。）*'
- en: This listing shows two functions with identical function signatures, `add` and
    `subtract`. Because the function signatures match, pointer types to these functions
    will also match. You initialize a function pointer `operation` accepting a `float`
    and an `int` as arguments and returning a `float` ➊. Next, you print the value
    of `operation`, which is `nullptr`, after initialization ➋.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 这个列表展示了两个具有相同函数签名的函数，`add`和`subtract`。由于函数签名匹配，这些函数的指针类型也会匹配。你初始化一个接受`float`和`int`作为参数并返回`float`的函数指针`operation`
    ➊。接下来，你打印初始化后`operation`的值，它是`nullptr` ➋。
- en: You then assign the address of `add` to `operation` ➌ using the address-of operator
    and print its new address ➍. You invoke `operation` and print the result ➎.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，你使用取地址符号将`add`的地址赋值给`operation` ➌，并打印其新地址 ➍。你调用`operation`并打印结果 ➎。
- en: To illustrate that you can reassign function pointers, you assign `operation`
    to `subtract` without using the address of operator ➏, print the new value of
    `operation` ➐, and finally print the result ➑.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 为了说明你可以重新赋值函数指针，你将`operation`赋值为`subtract`，而不使用取地址符号 ➏，打印`operation`的新值 ➐，最后打印结果
    ➑。
- en: '***Type Aliases and Function Pointers***'
  id: totrans-150
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***类型别名和函数指针***'
- en: 'Type aliases provide a neat way to program with function pointers. The usage
    is as follows:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 类型别名为编程提供了一种简洁的方式来使用函数指针。其使用方法如下：
- en: '[PRE19]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'You could have defined an `operation_func` type alias in [Listing 9-10](ch09.xhtml#ch09ex10),
    for example:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，你可以在[清单 9-10](ch09.xhtml#ch09ex10)中定义一个`operation_func`类型别名：
- en: '[PRE20]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: This is especially useful if you’ll be using function pointers of the same type;
    it can really clean up the code.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你将使用相同类型的函数指针，这非常有用；它确实可以清理代码。
- en: '**The Function-Call Operator**'
  id: totrans-156
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**函数调用操作符**'
- en: You can make user-defined types callable or invocable by overloading the function-call
    operator `operator()()`. Such a type is called a *function type*, and instances
    of a function type are called *function objects*. The function-call operator permits
    any combination of argument types, return types, and modifiers (except `static`).
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过重载函数调用操作符`operator()()`使用户定义类型可调用或可执行。这样的类型被称为*函数类型*，函数类型的实例被称为*函数对象*。函数调用操作符允许任意组合的参数类型、返回类型和修饰符（除了`static`）。
- en: The primary reason you might want to make a user-defined type callable is to
    interoperate with code that expects function objects to use the function-call
    operator. You’ll find that many libraries, such as the stdlib, use the function-call
    operator as the interface for function-like objects. For example, in [Chapter
    19](ch19.xhtml#ch19), you’ll learn how to create an asynchronous task with the
    `std::async` function, which accepts an arbitrary function object that can execute
    on a separate thread. It uses the function-call operator as the interface. The
    committee that invented `std::async` could have required you to expose, say, a
    `run` method, but they chose the function-call operator because it allows generic
    code to use identical notation to invoke a function or a function object.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能希望使用户定义类型可调用的主要原因是与期望使用函数调用操作符的代码进行互操作。你会发现许多库（如stdlib）使用函数调用操作符作为函数对象的接口。例如，在[第
    19 章](ch19.xhtml#ch19)中，你将学习如何使用`std::async`函数创建一个异步任务，它接受一个可以在单独线程上执行的任意函数对象。它使用函数调用操作符作为接口。发明`std::async`的委员会本可以要求你暴露一个比如`run`的方法，但他们选择了函数调用操作符，因为它允许通用代码使用相同的符号来调用函数或函数对象。
- en: '[Listing 9-11](ch09.xhtml#ch09ex11) illustrates the function-call operator’s
    usage.'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: '[清单 9-11](ch09.xhtml#ch09ex11)展示了函数调用操作符的使用。'
- en: '[PRE21]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '*Listing 9-11: The function-call operator’s usage*'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 9-11：函数调用操作符的使用*'
- en: The function-call operator has the special `operator()` method name ➋. You declare
    an arbitrary number of arguments ➌, and you also decide the appropriate return
    type ➊.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 函数调用操作符具有特殊的`operator()`方法名称 ➋。你声明任意数量的参数 ➌，并且你还决定适当的返回类型 ➊。
- en: When the compiler evaluates a function-call expression, it will invoke the function-call
    operator on the first operand, passing the remaining operands as arguments. The
    result of the function-call expression is the result of invoking the corresponding
    function-call operator.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 当编译器评估函数调用表达式时，它将对第一个操作数调用函数调用操作符，并将其余操作数作为参数传递。函数调用表达式的结果是调用相应的函数调用操作符的结果。
- en: '**A Counting Example**'
  id: totrans-164
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**一个计数示例**'
- en: Consider the function type `CountIf` in [Listing 9-12](ch09.xhtml#ch09ex12),
    which computes the frequency of a particular `char` in a null-terminated string.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 请参阅[清单 9-12](ch09.xhtml#ch09ex12)中的`CountIf`函数类型，该类型计算特定`char`在空终止字符串中的出现频率。
- en: '[PRE22]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '*Listing 9-12: A function type that counts the number of characters appearing
    in a null-terminated string*'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 9-12：一个计算空终止字符串中字符出现次数的函数类型*'
- en: You initialize `CountIf` objects using a constructor taking a `char` ➊. You
    can call the resulting function object as if it were a function taking a null-terminated
    string argument ➋, because you’ve implemented the function call operator. The
    function call operator iterates through each character in the argument `str` using
    an `index` variable ➌, incrementing the `result` variable whenever the character
    matches the `x` field ➍. Because calling the function doesn’t modify the state
    of a `CountIf` object, you’ve marked it `const`.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 你通过使用构造函数来初始化`CountIf`对象，该构造函数接受一个`char` ➊。你可以像调用函数一样调用这个结果函数对象，传递一个空终止字符串作为参数
    ➋，因为你已经实现了函数调用操作符。函数调用操作符通过`index`变量 ➌ 遍历参数`str`中的每个字符，每当字符与`x`字段匹配时，`result`变量就会递增
    ➍。由于调用该函数不会修改`CountIf`对象的状态，因此你已将其标记为`const`。
- en: Within `main`, you’ve initialized the `CountIf` function object `s_counter`,
    which will count the frequency of the letter `s` ➎. You can use `s_counter` as
    if it were a function ➏. You can even initialize a `CountIf` object and use the
    function operator directly as an rvalue object ➐. You might find this convenient
    to do in some settings where, for example, you might only need to invoke the object
    a single time.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `main` 中，你已经初始化了 `CountIf` 函数对象 `s_counter`，它将计算字母 `s` 的频率 ➎。你可以像使用函数一样使用
    `s_counter` ➏。你甚至可以初始化一个 `CountIf` 对象，并直接将函数运算符作为右值对象使用 ➐。在某些场景中，这样做可能会很方便，比如你可能只需要调用该对象一次。
- en: You can employ function objects as partial applications. [Listing 9-12](ch09.xhtml#ch09ex12)
    is conceptually similar to the `count_if` function in [Listing 9-13](ch09.xhtml#ch09ex13).
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以将函数对象用作部分应用。[列表 9-12](ch09.xhtml#ch09ex12) 在概念上与 [列表 9-13](ch09.xhtml#ch09ex13)
    中的 `count_if` 函数类似。
- en: '[PRE23]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '*Listing 9-13: A free function emulating [Listing 9-12](ch09.xhtml#ch09ex12)*'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 9-13：模拟 [列表 9-12](ch09.xhtml#ch09ex12) 的自由函数*'
- en: The `count_if` function has an extra argument `x` ➊, but otherwise it’s almost
    identical to the function operator of `CountIf`.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: '`count_if` 函数有一个额外的参数 `x` ➊，但除此之外，它几乎与 `CountIf` 的函数运算符相同。'
- en: '**NOTE**'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*In functional programming parlance, the `CountIf` is the `partial application`
    of `x` to `count_if`. When you partially apply an argument to a function, you
    fix that argument’s value. The product of such a partial application is another
    function taking one less argument.*'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: '*在函数式编程术语中，`CountIf` 是将 `x` 部分应用到 `count_if` 的 `partial application`。当你将一个参数部分应用到函数时，你固定了该参数的值。这样的部分应用的产物是另一个接受少一个参数的函数。*'
- en: Declaring function types is verbose. You can often reduce the boilerplate substantially
    with lambda expressions.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 声明函数类型通常比较冗长。你可以通过 Lambda 表达式显著减少样板代码。
- en: '**Lambda Expressions**'
  id: totrans-177
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**Lambda 表达式**'
- en: '*Lambda expressions* construct unnamed function objects succinctly. The function
    object implies the function type, resulting in a quick way to declare a function
    object on the fly. Lambdas don’t provide any additional functionality other than
    declaring function types the old-fashioned way. But they’re extremely convenient
    when you need to initialize a function object in only a single context.'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: '*Lambda 表达式* 简洁地构造了无名的函数对象。函数对象隐含了函数类型，从而提供了一种快速声明函数对象的方法。Lambda 不提供任何额外的功能，只是以传统的方式声明函数类型。但当你只需要在一个特定的上下文中初始化函数对象时，它们非常方便。'
- en: '***Usage***'
  id: totrans-179
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***用法***'
- en: 'There are five components to a lambda expression:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: Lambda 表达式有五个组成部分：
- en: '`*captures*`: The member variables of the function object (that is, the partially
    applied parameters)'
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`*captures*`：函数对象的成员变量（即部分应用的参数）'
- en: '`*parameters*`: The arguments required to invoke the function object'
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`*参数*`：调用函数对象所需的参数'
- en: '`*body*`: The function object’s code'
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`*body*`：函数对象的代码'
- en: '`*specifiers*`: Elements like `constexpr, mutable`, `noexcept`, and `[[noreturn]]`'
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`*specifiers*`：如 `constexpr`、`mutable`、`noexcept` 和 `[[noreturn]]` 等元素'
- en: '`*return type*`: The type returned by the function object'
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`*返回类型*`：函数对象返回的类型'
- en: 'Lambda expression usage is as follows:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: Lambda 表达式的用法如下：
- en: '[PRE24]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Only the captures and the body are required; everything else is optional. You’ll
    learn about each of these components in depth in the next few sections.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 仅捕获和函数体是必需的，其他部分都是可选的。你将在接下来的几节中深入了解这些组件。
- en: Each lambda component has a direct analogue in a function object. To form a
    bridge between the function objects like `CountIf` and lambda expressions, look
    at [Listing 9-14](ch09.xhtml#ch09ex14), which lists the `CountIf` function type
    from [Listing 9-12](ch09.xhtml#ch09ex12) with annotations that correspond to the
    analogous portions of the lambda expression in the usage listing.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 每个 Lambda 组件都有一个与之直接对应的函数对象。为了在函数对象（如 `CountIf`）与 Lambda 表达式之间架起桥梁，查看 [列表 9-14](ch09.xhtml#ch09ex14)，其中列出了来自
    [列表 9-12](ch09.xhtml#ch09ex12) 的 `CountIf` 函数类型，并附有注释，表示 Lambda 表达式在使用时的类似部分。
- en: '[PRE25]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '*Listing 9-14: Comparing the `CountIf` type declaration with a lambda expression*'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 9-14：比较 `CountIf` 类型声明与 Lambda 表达式*'
- en: The member variables you set in the constructor of `CountIf` are analogous to
    a lambda’s capture ➊. The function-call operator’s arguments ➋, body ➌, and return
    type ➍ are analogous to the lambda’s parameters, body, and return type. Finally,
    modifiers can apply to the function-call operator ➎ and the lambda. (The numbers
    in the Lambda expession usage example and [Listing 9-14](ch09.xhtml#ch09ex14)
    correspond.)
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 您在 `CountIf` 构造函数中设置的成员变量类似于 lambda 的捕获 ➊。函数调用运算符的参数 ➋、主体 ➌ 和返回类型 ➍ 类似于 lambda
    的参数、主体和返回类型。最后，修饰符可以应用于函数调用运算符 ➎ 和 lambda。（Lambda 表达式使用示例中的数字与 [列表 9-14](ch09.xhtml#ch09ex14)
    相对应。）
- en: '***Lambda Parameters and Bodies***'
  id: totrans-193
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***Lambda 参数与主体***'
- en: Lambda expressions produce function objects. As function objects, lambdas are
    callable. Most of the time, you’ll want your function object to accept parameters
    upon invocation.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: Lambda 表达式生成函数对象。作为函数对象，lambda 是可调用的。大多数时候，您希望在调用时让函数对象接受参数。
- en: 'The lambda’s body is just like a function body: all of the parameters have
    function scope.'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: lambda 的主体就像一个函数的主体：所有的参数都具有函数作用域。
- en: You declare lambda parameters and bodies using essentially the same syntax that
    you use for functions.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 您使用与函数相同的语法来声明 lambda 的参数和主体。
- en: 'For example, the following lambda expression yields a function object that
    will square its `int` argument:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，以下 lambda 表达式生成一个函数对象，该对象将对其 `int` 参数进行平方操作：
- en: '[PRE26]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: The lambda takes a single `int x` and uses it within the lambda’s body to perform
    the squaring.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 该 lambda 接受一个 `int x`，并在 lambda 的主体内使用它进行平方操作。
- en: '[Listing 9-15](ch09.xhtml#ch09ex15) employs three different lambdas to transform
    the array `1, 2, 3`.'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 9-15](ch09.xhtml#ch09ex15) 使用了三个不同的 lambda 表达式来转换数组 `1, 2, 3`。'
- en: '[PRE27]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '*Listing 9-15: Three lambdas and a transform function*'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 9-15：三个 lambda 表达式和一个 transform 函数*'
- en: 'The `transform` template function ➊ accepts four arguments: a function object
    `fn`, an `in` array and an `out` array, and the corresponding `length` of those
    arrays. Within transform, you invoke `fn` on each element of `in` and assign the
    result to the corresponding element of `out` ➋.'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: '`transform` 模板函数 ➊ 接受四个参数：一个函数对象 `fn`，一个 `in` 数组和一个 `out` 数组，以及这些数组的相应 `length`。在
    `transform` 中，您会对 `in` 的每个元素调用 `fn`，并将结果赋值给 `out` 的相应元素 ➋。'
- en: Within `main`, you declare a `base` array `1, 2, 3` that will be used as the
    `in` array. In the same line you also declare three uninitialized arrays `a, b`,
    and `c`, which will be used as the `out` arrays. The first call to `transform`
    passes a lambda `([](int x) { return 1; })` that always returns 1 ➌, and the result
    is stored into `a`. (Notice that the lambda didn’t need a name!) The second call
    to `transform ([](int x) { return x; })` simply returns its argument ➍, and the
    result is stored into `b`. The third call to `transform` multiplies the argument
    by 10 and adds 5 ➎. The result is stored in `c`. You then print the output into
    a matrix where each column illustrates the transform that was applied to the different
    lambdas in each case.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `main` 中，您声明了一个 `base` 数组 `1, 2, 3`，它将作为 `in` 数组使用。在同一行中，您还声明了三个未初始化的数组 `a,
    b` 和 `c`，它们将作为 `out` 数组使用。第一次调用 `transform` 时传递了一个始终返回 1 的 lambda `([](int x)
    { return 1; })` ➌，结果被存储在 `a` 中。（注意，lambda 不需要名字！）第二次调用 `transform ([](int x) {
    return x; })` 简单地返回其参数 ➍，结果被存储在 `b` 中。第三次调用 `transform` 时，lambda 将参数乘以 10 并加上
    5 ➎。结果被存储在 `c` 中。然后，您将输出打印到一个矩阵中，其中每一列展示了在每种情况下应用于不同 lambda 的转换。
- en: Notice that you declared `transform` as a template function, allowing you to
    reuse it with any function object.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，您将 `transform` 声明为模板函数，这使得您可以使用任何函数对象重复使用它。
- en: '***Default Arguments***'
  id: totrans-206
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***默认参数***'
- en: You can provide default arguments to a lambda. Default lambda parameters behave
    just like default function parameters. The caller can specify values for default
    parameters, in which case the lambda uses the caller-provided values. If the caller
    doesn’t specify a value, the lambda uses the default.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以为 lambda 提供默认参数。默认的 lambda 参数行为与默认的函数参数相同。调用者可以为默认参数指定值，在这种情况下，lambda 使用调用者提供的值。如果调用者没有指定值，lambda
    则使用默认值。
- en: '[Listing 9-16](ch09.xhtml#ch09ex16) illustrates the default argument behavior.'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 9-16](ch09.xhtml#ch09ex16) 展示了默认参数的行为。'
- en: '[PRE28]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '*Listing 9-16: Using default lambda parameters*'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 9-16：使用默认的 lambda 参数*'
- en: The increment lambda has two parameters, `x` and `y`. But the `y` parameter
    is optional because it has the default argument 1 ➊. If you don’t specify an argument
    for `y` when you call the function ➋, increment returns `1 + x`. If you do call
    the function with an argument for `y` ➌, that value is used instead.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 增量 lambda 有两个参数，`x` 和 `y`。但 `y` 参数是可选的，因为它具有默认参数 1 ➊。如果你在调用函数时没有为 `y` 指定参数 ➋，则增量返回
    `1 + x`。如果你确实为 `y` 提供了一个参数 ➌，则使用该值。
- en: '***Generic Lambdas***'
  id: totrans-212
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***通用 Lambda***'
- en: Generic lambdas are lambda expression templates. For one or more parameters,
    you specify `auto` rather than a concrete type. These `auto` types become template
    parameters, meaning the compiler will stamp out a custom instantiation of the
    lambda.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 通用 lambda 是 lambda 表达式模板。对于一个或多个参数，你可以指定 `auto` 而不是具体类型。这些 `auto` 类型将成为模板参数，意味着编译器会为该
    lambda 创建一个自定义实例化。
- en: '[Listing 9-17](ch09.xhtml#ch09ex17) illustrates how to assign a generic lambda
    into a variable and then use the lambda in two different template instantiations.'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 9-17](ch09.xhtml#ch09ex17) 演示了如何将通用 lambda 分配给一个变量，然后在两个不同的模板实例化中使用该 lambda。'
- en: '[PRE29]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '*Listing 9-17: Using a generic lambda*'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 9-17：使用通用 lambda*'
- en: 'You add a second template parameter to `transform` ➊, which you use as the
    pointed-to type of `in` and `out`. This allows you to apply transform to arrays
    of any type, not just of `int` types. To test out the upgraded transform template,
    you declare two arrays with different pointed-to types: `int` ➋ and `float` ➌.
    (Recall from [Chapter 3](ch03.xhtml#ch03) that the `f` in `10.f` specifies a `float`
    literal.) Next, you assign a generic lambda expression to `translate` ➍. This
    allows you to use the same lambda for each instantiation of transform: when you
    instantiate with `base_int` ➎ and with `base_float` ➏.'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 你向 `transform` 添加了第二个模板参数 ➊，你用它作为 `in` 和 `out` 的指向类型。这使你可以将 transform 应用于任何类型的数组，而不仅仅是
    `int` 类型的数组。为了测试升级后的 transform 模板，你声明了两个具有不同指向类型的数组：`int` ➋ 和 `float` ➌。（回想一下[第
    3 章](ch03.xhtml#ch03)，`10.f` 中的 `f` 表示一个 `float` 字面量。）接下来，你将一个通用的 lambda 表达式赋值给
    `translate` ➍。这使你可以在每次实例化 transform 时使用相同的 lambda：当你用 `base_int` ➎ 和 `base_float`
    ➏ 进行实例化时。
- en: 'Without a generic lambda, you’d have to declare the parameter types explicitly,
    like the following:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有通用 lambda，你将需要像下面这样显式声明参数类型：
- en: '[PRE30]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: So far, you’ve been leaning on the compiler to deduce the return types of your
    lambdas. This is especially useful for generic lambdas, because often the lambda’s
    return type will depend on its parameter types. But you can explicitly state the
    return type if you want.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，你一直依赖编译器推断 lambda 的返回类型。这对于通用 lambda 尤其有用，因为通常 lambda 的返回类型会依赖于其参数类型。但是，如果你愿意，你也可以显式声明返回类型。
- en: '***Lambda Return Types***'
  id: totrans-221
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***Lambda 返回类型***'
- en: 'The compiler deduces a lambda’s return type for you. To take over from the
    compiler, you use the arrow `->` syntax, as in the following:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 编译器会为你推断 lambda 的返回类型。要接管编译器的推断，你可以使用箭头 `->` 语法，如下所示：
- en: '[PRE31]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: This lambda expression accepts an `int` and a `double` and returns a `double`.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 这个 lambda 表达式接受一个 `int` 和一个 `double`，并返回一个 `double`。
- en: 'You can also use `decltype` expressions, which can be useful with generic lambdas.
    For example, consider the following lambda:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以使用 `decltype` 表达式，这在使用通用 lambda 时非常有用。例如，考虑以下 lambda：
- en: '[PRE32]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Here you’ve explicitly declared that the return type of the lambda is whatever
    type results from adding an `x` to a `y`.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，你显式声明 lambda 的返回类型为将 `x` 加到 `y` 后得到的类型。
- en: You’ll rarely need to specify a lambda’s return type explicitly.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 你很少需要显式指定 lambda 的返回类型。
- en: A far more common requirement is that you must inject an object into a lambda
    before invocation. This is the role of lambda captures.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 一个更常见的需求是你必须在调用之前将一个对象注入到 lambda 中。这就是 lambda 捕获的作用。
- en: '***Lambda Captures***'
  id: totrans-230
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***Lambda 捕获***'
- en: '*Lambda captures* inject objects into the lambda. The injected objects help
    to modify the behavior of the lambda.'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: '*Lambda 捕获*将对象注入到 lambda 中。注入的对象有助于修改 lambda 的行为。'
- en: Declare a lambda’s capture by specifying a capture list within brackets `[]`.
    The capture list goes before the parameter list, and it can contain any number
    of comma-separated arguments. You then use these arguments within the lambda’s
    body.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 通过在括号`[]`内指定捕获列表来声明 lambda 的捕获。捕获列表位于参数列表之前，可以包含任意数量的逗号分隔的参数。然后，在 lambda 的主体内使用这些参数。
- en: A lambda can capture by reference or by value. By default, lambdas capture by
    value.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 一个 lambda 可以按引用捕获或按值捕获。默认情况下，lambda 按值捕获。
- en: A lambda’s capture list is analogous to a function type’s constructor. [Listing
    9-18](ch09.xhtml#ch09ex18) reformulates `CountIf` from [Listing 9-12](ch09.xhtml#ch09ex12)
    as the lambda `s_counter`.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: lambda 的捕获列表类似于函数类型的构造函数。[清单 9-18](ch09.xhtml#ch09ex18) 将[清单 9-12](ch09.xhtml#ch09ex12)中的
    `CountIf` 改写为 lambda `s_counter`。
- en: '[PRE33]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: '*Listing 9-18: Reformulating `CountIf` from [Listing 9-12](ch09.xhtml#ch09ex12)
    as a lambda*'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 9-18：将[清单 9-12](ch09.xhtml#ch09ex12)中的 `CountIf` 改写为 lambda*'
- en: You initialize a `char` called `to_count` to the letter `s` ➊. Next, you capture
    `to_count` within the lambda expression assigned to `s_counter` ➋. This makes
    `to_count` available within the body of the lambda expression ➌.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 你初始化一个名为 `to_count` 的 `char` 类型变量，赋值为字母 `s` ➊。接下来，你在分配给 `s_counter` 的 lambda
    表达式中捕获 `to_count` ➋。这样，`to_count` 就可以在 lambda 表达式的主体内使用 ➌。
- en: To capture an element by reference rather than by value, prefix the captured
    object’s name with an ampersand `&`. [Listing 9-19](ch09.xhtml#ch09ex19) adds
    a capture reference to `s_counter` that keeps a running tally across lambda invocations.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 要通过引用捕获一个元素，而不是通过值捕获，可以在捕获对象的名称前加上与号 `&`。[清单 9-19](ch09.xhtml#ch09ex19) 在 `s_counter`
    中添加了一个引用捕获，使其在 lambda 调用中保持累积计数。
- en: '[PRE34]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: '*Listing 9-19: Using a capture reference in a lambda*'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 9-19：在 lambda 中使用引用捕获*'
- en: You initialize the counter variable `tally` to zero ➊, and then the `s_counter`
    lambda captures `tally` by reference (note the ampersand `&`) ➋. Within the lambda’s
    body, you add a statement to increment `tally` by an invocation’s `result` before
    returning ➌. The result is that `tally` will track the total count no matter how
    many times you invoke the lambda. Before the first `s_counter` invocation, you
    print the value of `tally` ➍ (which is still zero). After you invoke `s_counter`
    with `Sally sells seashells by the seashore.`, you have a `tally` of 7 ➎. The
    last invocation of `s_counter` with `Sailor went to sea to see what he could see.`
    returns 3, so the value of `tally` is 7 + 3 = 10 ➏.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 你将计数器变量 `tally` 初始化为零 ➊，然后 `s_counter` lambda 通过引用捕获 `tally`（注意与号 `&`） ➋。在 lambda
    的主体中，你添加一条语句，在每次调用时通过 `result` 增加 `tally`，然后返回 ➌。结果是，无论你调用多少次 lambda，`tally` 都会跟踪总计数。在第一次调用
    `s_counter` 之前，你打印 `tally` 的值 ➍（此时为零）。当你用 `Sally sells seashells by the seashore.`
    调用 `s_counter` 后，`tally` 的值为 7 ➎。最后一次调用 `s_counter`，传入 `Sailor went to sea to
    see what he could see.` 时返回 3，因此 `tally` 的值为 7 + 3 = 10 ➏。
- en: '**Default Capture**'
  id: totrans-242
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**默认捕获**'
- en: So far, you’ve had to capture each element by name. Sometimes this style of
    capturing is called *named capture*. If you’re lazy, you can capture all automatic
    variables used within a lambda using *default capture*. To specify a default capture
    by value within a capture list, use a lone equal sign `=`. To specify a default
    capture by reference, use a lone ampersand `&`.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，你需要通过名称捕获每个元素。有时，这种捕获方式被称为*命名捕获*。如果你懒得一个个捕获，可以通过*默认捕获*来捕获 lambda 中所有使用的自动变量。要在捕获列表中指定值捕获，使用单一的等号
    `=`。要指定引用捕获，使用单一的与号 `&`。
- en: For example, you could “simplify” the lambda expression in [Listing 9-19](ch09.xhtml#ch09ex19)
    to perform a default capture by reference, as demonstrated in [Listing 9-20](ch09.xhtml#ch09ex20).
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，你可以将[清单 9-19](ch09.xhtml#ch09ex19)中的 lambda 表达式“简化”，通过引用执行默认捕获，如[清单 9-20](ch09.xhtml#ch09ex20)中所示。
- en: '[PRE35]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: '*Listing 9-20: Simplifying a lambda expression with a default capture by reference*'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 9-20：通过引用的默认捕获简化 lambda 表达式*'
- en: 'You specify a default capture by reference ➊, which means any automatic variables
    in the body of the lambda expression get captured by reference. There are two:
    `to_count` ➋ and `tally` ➌.'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 你通过➊指定默认引用捕获，这意味着 lambda 表达式体内的任何自动变量都会通过引用捕获。这里有两个变量：`to_count` ➋ 和 `tally`
    ➌。
- en: If you compile and run the refactored listing, you’ll obtain identical output.
    However, notice that `to_count` is now captured by reference. If you accidentally
    modify it within the lambda expression’s body, the change will occur across lambda
    invocations as well as within `main` (where `to_count` is an automatic variable).
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你编译并运行重构后的清单，你将获得相同的输出。然而，请注意，`to_count` 现在是通过引用捕获的。如果你在 lambda 表达式体内不小心修改了它，变化会影响到所有
    lambda 调用以及 `main` 中的 `to_count`（它是一个自动变量）。
- en: What would happen if you performed a default capture by value instead? You would
    only need to change the `=` to an `&` in the capture list, as demonstrated in
    [Listing 9-21](ch09.xhtml#ch09ex21).
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你改为使用值捕获，会发生什么呢？你只需要将捕获列表中的 `=` 改为 `&`，如[清单 9-21](ch09.xhtml#ch09ex21)中所示。
- en: '[PRE36]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: '*Listing 9-21: Modifying [Listing 9-20](ch09.xhtml#ch09ex20) to capture by
    value instead of by reference (This code doesn''t compile.)*'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
- en: You change the default capture to be by value ➊. The `to_count` capture is unaffected
    ➋, but attempting to modify `tally` results in a compiler error ➌. You’re not
    allowed to modify variables captured by value unless you add the `mutable` keyword
    to the lambda expression. The `mutable` keyword allows you to modify value-captured
    variables. This includes calling non-`const` methods on that object.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 9-22](ch09.xhtml#ch09ex22) adds the `mutable` modifier and has a default
    capture by value.'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: '*Listing 9-22: A `mutable` lambda expression with a default capture by value*'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
- en: You declare a default capture by value ➊, and you make the lambda `s_counter
    mutable` ➋. Each of the three times you print `tally` ➌➍➎, you get a zero value.
    Why?
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
- en: Because `tally` gets copied by value (via the default capture), the version
    in the lambda is, in essence, an entirely different variable that just happens
    to have the same name. Modifications to the lambda’s copy of `tally` don’t affect
    the automatic `tally` variable of `main`. The `tally` in `main()` is initialized
    to zero and never gets modified.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
- en: 'It’s also possible to mix a default capture with a named capture. You could,
    for example, default capture by reference and copy `to_count` by value using the
    following formulation:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: This specifies a default capture by reference ➊ and `to_count` ➋ capture by
    value.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
- en: Although performing a default capture might seem like an easy shortcut, refrain
    from using it. It’s far better to declare captures explicitly. If you catch yourself
    saying “I’ll just use a default capture because there are too many variables to
    list out,” you probably need to refactor your code.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
- en: '**Initializer Expressions in Capture Lists**'
  id: totrans-262
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Sometimes you want to initialize a whole new variable within a capture list.
    Maybe renaming a captured variable would make a lambda expression’s intent clearer.
    Or perhaps you want to move an object into a lambda and therefore need to initialize
    a variable.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
- en: To use an initializer expression, just declare the new variable’s name followed
    by an equal sign and the value you want to initialize your variable with, as [Listing
    9-23](ch09.xhtml#ch09ex23) demonstrates.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: '*Listing 9-23: Using an initializer expression within a lambda capture*'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
- en: The capture list contains a simple named capture where you have `tally` by reference
    ➊. The lambda also captures `to_count` by value, but you’ve elected to use the
    variable name `my_char` instead ➋. Of course, you’ll need to use the name `my_char`
    instead of `to_count` inside the lambda ➌.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
- en: '*An initializer expression in a capture list is also called an init capture.*'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
- en: '**Capturing this**'
  id: totrans-270
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Sometimes lambda expressions have an enclosing class. You can capture an enclosing
    object (pointed-to by `this`) by value or by reference using either `[*this]`
    or `[this]`, respectively.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 9-24](ch09.xhtml#ch09ex24) implements a `LambdaFactory` that generates
    counting lambdas and keeps track of a `tally`.'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: '*Listing 9-24: A `LambdaFactory` illustrating the use of `this` capture*'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
- en: The `LambdaFactory` constructor takes a single character and initializes the
    `to_count` field with it. The `make_lambda` ➊ method illustrates how you can capture
    `this` by reference ➋ and use the `to_count` ➌ and `tally` ➍ member variables
    within the lambda expression.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
- en: Within `main`, you initialize a `factory` ➎ and make a `lambda` using the `make_``lambda`
    method ➏. The output is identical to [Listing 9-19](ch09.xhtml#ch09ex19), because
    you capture `this` by reference and state of `tally` persists across invocations
    of `lambda`.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
- en: '**Clarifying Examples**'
  id: totrans-277
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: There are a lot of possibilities with capture lists, but once you have a command
    of the basics–capturing by value and by reference–there aren’t many surprises.
    [Table 9-2](ch09.xhtml#ch09tab02) provides short, clarifying examples that you
    can use for future reference.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 9-2:** Clarifying Examples of Lambda Capture Lists'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
- en: '| **Capture list** | **Meaning** |'
  id: totrans-280
  prefs: []
  type: TYPE_TB
- en: '| `[&]` | Default capture by reference |'
  id: totrans-281
  prefs: []
  type: TYPE_TB
- en: '| `[&,i]` | Default capture by reference; capture `i` by value |'
  id: totrans-282
  prefs: []
  type: TYPE_TB
- en: '| `[=]` | Default capture by value |'
  id: totrans-283
  prefs: []
  type: TYPE_TB
- en: '| `[=,&i]` | Default capture by value; capture `i` by reference |'
  id: totrans-284
  prefs: []
  type: TYPE_TB
- en: '| `[i]` | Capture `i` by value |'
  id: totrans-285
  prefs: []
  type: TYPE_TB
- en: '| `[&i]` | Capture `i` by reference |'
  id: totrans-286
  prefs: []
  type: TYPE_TB
- en: '| `[i,&j]` | Capture `i` by value; capture `j` by reference |'
  id: totrans-287
  prefs: []
  type: TYPE_TB
- en: '| `[i=j,&k]` | Capture `j` by value as `i`; capture `k` by reference |'
  id: totrans-288
  prefs: []
  type: TYPE_TB
- en: '| `[this]` | Capture `enclosing object` by reference |'
  id: totrans-289
  prefs: []
  type: TYPE_TB
- en: '| `[*this]` | Capture `enclosing object` by value |'
  id: totrans-290
  prefs: []
  type: TYPE_TB
- en: '| `[=,*this,i,&j]` | Default capture by value; capture `this` and `i` by value;
    capture `j` by reference |'
  id: totrans-291
  prefs: []
  type: TYPE_TB
- en: '***constexpr Lambda Expressions***'
  id: totrans-292
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'All lambda expressions are `constexpr` as long as the lambda can be invoked
    at compile time. You can optionally make the `constexpr` declaration explicit,
    as in the following:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: You should mark a lambda `constexpr` if you want to make sure that it meets
    all `constexpr` requirements. As of C++17, this means no dynamic memory allocations
    and no calling non-`constexpr` functions, among other restrictions. The standards
    committee plans to loosen these restrictions with each release, so if you write
    a lot of code using `constexpr`, be sure to brush up on the latest `constexpr`
    constraints.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
- en: '**std::function**'
  id: totrans-296
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Sometimes you just want a uniform container for storing callable objects. The
    `std::function` class template from the `<functional>` header is a polymorphic
    wrapper around a callable object. In other words, it’s a generic function pointer.
    You can store a static function, a function object, or a lambda into a `std::function`.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
- en: '*The `*function*` class is in the stdlib. We’re presenting it a little ahead
    of schedule because it fits naturally.*'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
- en: 'With `functions`, you can:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
- en: Invoke without the caller knowing the function’s implementation
  id: totrans-301
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Assign, move, and copy
  id: totrans-302
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Have an empty state, similar to a `nullptr`
  id: totrans-303
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '***Declaring a Function***'
  id: totrans-304
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'To declare a `function`, you must provide a single template parameter containing
    the function prototype of the callable object:'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  id: totrans-306
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: The `std::function` class template has a number of constructors. The default
    constructor constructs a `std::function` in empty mode, meaning it contains no
    callable object.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
- en: '**Empty Functions**'
  id: totrans-308
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: If you invoke a `std::function` with no contained object, `std::function` will
    throw a `std::bad_function_call` exception. Consider [Listing 9-25](ch09.xhtml#ch09ex25).
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  id: totrans-310
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: '*Listing 9-25: The default `std::function` constructor and the `std::bad_function_call`
    exception*'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
- en: You default-construct a `std::function` ➊. The template parameter `void()` denotes
    a function taking no arguments and returning `void`. Because you didn’t fill `func`
    with a callable object, it’s in an empty state. When you invoke `func` ➋, it throws
    a `std::bad_function_call`, which you catch and print ➌.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
- en: '**Assigning a Callable Object to a Function**'
  id: totrans-313
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: To assign a callable object to a `function`, you can either use the constructor
    or assignment operator of `function`, as in [Listing 9-26](ch09.xhtml#ch09ex26).
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  id: totrans-315
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: '*Listing 9-26: Using the constructor and assignment operator of `function`*'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
- en: You declare the static function `static_func` that takes no arguments and returns
    `void` ➊. In `main`, you create a function called `func` ➋. The template parameter
    indicates that a callable object contained by `func` takes no arguments and returns
    `void`. You initialize `func` with a lambda that prints the message `A lambda`.
    You invoke `func` immediately afterward ➌, invoking the contained lambda and printing
    the expected message. Next, you assign `static_func` to `func`, which replaces
    the lambda you assigned upon construction ➍. You then invoke `func`, which invokes
    `static_func` rather than the lambda, so you see `A static function.` printed
    ➎.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
- en: '***An Extended Example***'
  id: totrans-318
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: You can construct a `function` with callable objects, as long as that object
    supports the function semantics implied by the template parameter of `function`.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 9-27](ch09.xhtml#ch09ex27) uses an array of `std::function` instances
    and fills it with a static function that counts spaces, a `CountIf` function object
    from [Listing 9-12](ch09.xhtml#ch09ex12), and a lambda that computes string length.'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  id: totrans-321
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: '*Listing 9-27: Using a `std::function` array to iterate over a uniform collection
    of callable objects with varying underlying types*'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
- en: You declare a `std::function` array ➊ with static storage duration called `funcs`.
    The template argument is the function prototype for a function taking a `const
    char*` and returning a `size_t` ➋. In the `funcs` array, you pass in a static
    function pointer ➌, a function object ➍, and a lambda ➎. In `main`, you use a
    range-based `for` loop to iterate through each function in `funcs` ➏. You invoke
    each function `func` with the text `Sailor went to sea to see what he could see.`
    and print the result.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
- en: 'Notice that, from the perspective of `main`, all the elements in `funcs` are
    the same: you just invoke them with a null-terminated string and get back a `size_t`
    ➐.'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
- en: '*Using a `function` can incur runtime overhead. For technical reasons, `function`
    might need to make a dynamic allocation to store the callable object. The compiler
    also has difficulty optimizing away `function` invocations, so you’ll often incur
    an indirect function call. Indirect function calls require additional pointer
    dereferences*.'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
- en: '**The main Function and the Command Line**'
  id: totrans-327
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: All C++ programs must contain a global function with the name `main`. This function
    is defined as the program’s entry point, the function invoked at program startup.
    Programs can accept any number of environment-provided arguments called *command
    line parameters* upon startup.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
- en: 'Users pass command line parameters to programs to customize their behavior.
    You’ve probably used this feature when executing command line programs, as in
    the `copy` (on Linux: `cp`) command:'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  id: totrans-330
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: When invoking this command, you instruct the program to copy `file_a.txt` into
    `file_b.txt` by passing these values as command line parameters. As with command
    line programs you might be used to, it’s possible to pass values as command line
    parameters to your C++ programs.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
- en: You can choose whether your program handles command line parameters by how you
    declare `main`.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
- en: '***The Three main Overloads***'
  id: totrans-333
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: You can access command line parameters within `main` by adding arguments to
    your `main` declaration.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
- en: There are three valid varieties of overload for `main`, as shown in [Listing
    9-28](ch09.xhtml#ch09ex28).
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  id: totrans-336
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: '*Listing 9-28: The valid overloads for `main`*'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
- en: The first overload ➊ takes no parameters, which is the way you’ve been using
    `main()` in this book so far. Use this form if you want to ignore any arguments
    provided to your program.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
- en: 'The second overload ➋ accepts two parameters, `argc` and `argv`. The first
    argument, `argc`, is a non-negative number corresponding to the number of elements
    in `argv`. The environment calculates this automatically: you don’t have to provide
    the number of elements in `argc`. The second argument, `argv`, is an array of
    pointers to null-terminated strings that corresponds to an argument passed in
    from the execution environment.'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
- en: 'The third overload ➌: is an extension of the second overload ➋: it accepts
    an arbitrary number of additional implementation parameters. This way, the target
    platform can offer some additional arguments to the program. Implementation parameters
    aren’t common in modern desktop environments.'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
- en: Usually, an operating system passes the full path to the program’s executable
    as the first command line argument. This behavior depends on your operating environment.
    On macOS, Linux, and Windows, the executable’s path is the first argument. The
    format of this path depends on the operating system. ([Chapter 17](ch17.xhtml)
    discusses filesystems in depth.)
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
- en: '***Exploring Program Parameters***'
  id: totrans-342
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Let’s build a program to explore how the operating system passes parameters
    to your program. [Listing 9-29](ch09.xhtml#ch09ex29) prints the number of command
    line arguments and then prints the index and value of the arguments on each line.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  id: totrans-344
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: '*Listing 9-29: A program that prints the command line arguments. Compile this
    program as `list_929`.*'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
- en: You declare main with the `argc`/`argv` overload, which makes command line parameters
    available to your program ➊. First, you print the number of command line arguments
    via `argc` ➋. Then you loop through each argument, printing its index and its
    value ➌.
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s look at some sample output (on Windows 10 x64). Here is one program invocation:'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  id: totrans-348
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: Here, you provide no additional command line arguments aside from the name of
    the program, `list_929` ➊. (Depending on how you compiled the listing, you should
    replace this with the name of your executable.) On a Windows 10 x64 machine, the
    result is that your program receives a single argument ➋, the name of the executable
    ➌.
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
- en: 'And here is another invocation:'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  id: totrans-351
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Here, you provide additional program arguments: `Violence is the last refuge
    of the incompetent.` ➊. You can see from the output that Windows has split the
    command line by spaces, resulting in a total of nine arguments.'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
- en: 'In major desktop operating systems, you can force the operating system to treat
    such a phrase as a single argument by enclosing it within quotes, as in the following:'
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  id: totrans-354
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: '***A More Involved Example***'
  id: totrans-355
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Now that you know how to process command line input, let’s consider a more involved
    example. A *histogram* is an illustration that shows a distribution’s relative
    frequency. Let’s build a program that computes a histogram of the letter distribution
    of the command line arguments.
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
- en: 'Start with two helper functions that determine whether a given `char` is an
    uppercase letter or a lowercase letter:'
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  id: totrans-358
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: The `pos_A, pos_Z, pos_a`, and `pos_z` constants contain the ASCII values of
    the letters A, Z, a, and z respectively (refer to the ASCII chart in [Table 2-4](ch02.xhtml#ch02tab04)).
    The `within_AZ` function determines whether some `char x` is an uppercase letter
    by determining whether its value is between `pos_A` and `pos_Z` inclusive ➊. The
    `within_az` function does the same for lowercase letters ➋.
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
- en: Now that you have some elements for processing ASCII data from the command line,
    let’s build an `AlphaHistogram` class that can ingest command line elements and
    store character frequencies, as shown in [Listing 9-30](ch09.xhtml#ch09ex30).
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  id: totrans-361
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: '*Listing 9-30: An `AlphaHistogram` that ingests command line elements*'
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
- en: An `AlphaHistogram` will store the frequency of each letter in the `counts`
    array ➌. This array initializes to zero whenever an `AlphaHistogram` is constructed.
    The `ingest` method will take a null-terminated string and update `counts` appropriately
    ➊. Then the `print` method will display the histogram information stored in `counts`
    ➋.
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
- en: First, consider the implementation of `ingest` in [Listing 9-31](ch09.xhtml#ch09ex31).
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  id: totrans-365
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: '*Listing 9-31: An implementation of the `ingest` method*'
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
- en: Because `x` is a null-terminated string, you don’t know its length ahead of
    time. So, you initialize an `index` variable ➊ and use a `while` loop to extract
    a single `char c` at a time ➋. This loop will terminate if `c` is null, which
    is the end of the string. Within the loop, you use the `within_AZ` helper function
    to determine whether `c` is an uppercase letter ➌. If it is, you subtract `pos_A`
    from `c`. This normalizes an uppercase letter to the interval 0 to 25 to correspond
    with `counts`. You do the same check for lowercase letters using the `within_az`
    helper function ➍, and you update `counts` in case `c` is lowercase. If `c` is
    neither lowercase nor uppercase, `counts` is unaffected. Finally, you increment
    `index` before continuing to loop ➎.
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
- en: Now, consider how to `print` `counts`, as shown in [Listing 9-32](ch09.xhtml#ch09ex32).
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  id: totrans-369
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: '*Listing 9-32: An implementation of the `print` method*'
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
- en: To print the histogram, you loop over each letter from A to Z ➊. Within the
    loop, you first print the `index` letter ➋, and then determine how many asterisks
    to print by extracting the correct letter out of `counts` ➌. You print the correct
    number of asterisks using a `while` loop ➍, and then you print a terminating newline
    ➎.
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 9-33](ch09.xhtml#ch09ex33) shows `AlphaHistogram` in action.'
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  id: totrans-373
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: '*Listing 9-33: A program illustrating `AlphaHistogram`*'
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
- en: You iterate over each command line argument after the program name ➊, passing
    each into the `ingest` method of your `AlphaHistogram` object ➋. Once you’ve ingested
    them all, you print the `histogram` ➌. Each line corresponds to a letter, and
    the asterisks show the absolute frequency of the corresponding letter. As you
    can see, the phrase `The quick brown fox jumps over the lazy dog` contains each
    letter in the English alphabet.
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
- en: '***Exit Status***'
  id: totrans-376
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The `main` function can return an `int` corresponding to the exit status of
    the program. What the values represent is environment defined. On modern desktop
    systems, for example, a zero return value corresponds with a successful program
    execution. If no `return` statement is explicitly given, an implicit `return 0`
    is added by the compiler.
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
- en: '**Summary**'
  id: totrans-378
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This chapter took a deeper look at functions, including how to declare and define
    them, how to use the myriad keywords available to you to modify function behavior,
    how to specify return types, how overload resolution works, and how to take a
    variable number of arguments. After a discussion of how you take pointers to functions,
    you explored lambda expressions and their relationship to function objects. Then
    you learned about the entry point for your programs, the `main` function, and
    how to take command line arguments.
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
- en: '**EXERCISES**'
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
- en: '**9-1.** Implement a `fold` function template with the following prototype:'
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  id: totrans-382
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'For example, your implementation must support the following usage:'
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  id: totrans-384
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'The value of `sum` should be 1,500\. Use `fold` to calculate the following
    quantities: the `maximum`, the `minimum`, and the number of elements greater than
    200.'
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
- en: '**9-2.** Implement a program that accepts an arbitrary number of command line
    arguments, counts the length in characters of each argument, and prints a histogram
    of the argument length distribution.'
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
- en: '**9-3.** Implement an `all` function with the following prototype:'
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  id: totrans-388
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: The `Fn` function type is a `predicate` that supports `bool operator()(In)`.
    Your `all` function must test whether `function` returns `true` for every element
    of `input`. If it does, return `true`. Otherwise, return `false`.
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, your implementation must support the following usage:'
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  id: totrans-391
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: '**FURTHER READING**'
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
- en: '*Functional Programming in C++: How to Improve Your C++ Programs Using Functional
    Techniques* by Ivan Čukić (Manning, 2019)'
  id: totrans-393
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Clean Code: A Handbook of Agile Software Craftsmanship* by Robert C. Martin
    (Pearson Education, 2009'
  id: totrans-394
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
