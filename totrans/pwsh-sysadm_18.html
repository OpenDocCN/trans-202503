<html><head></head><body>
<h2 class="h2" id="ch15"><span epub:type="pagebreak" id="page_217"/><span class="big">15</span><br/>PROVISIONING A VIRTUAL ENVIRONMENT</h2>&#13;
<div class="image1"><img class="inline" src="../images/common.jpg" alt="Images"/></div>&#13;
<p class="noindent"><span class="bign"><em>PowerLab</em> is a final, massive project using all the concepts you’ve learned and more. It’s a project that automates the provisioning of Hyper-V virtual machines (VMs) all the way up to installing and configuring services including SQL and IIS. Imagine being able to run a single</span> command such as <code>New-PowerLabSqlServer</code>, <code>New-PowerLabIISServer</code>, or even <code>New-PowerLab</code>, wait a few minutes, and have a fully configured machine (or machines) pop out. That’s what you’re going to get if you stick with me throughout the rest of the book.</p>&#13;
<p class="indent">The purpose of the PowerLab project is to remove all the repetitive, time-consuming tasks required to bring up a test environment or a lab. When you’re done, you should have just a handful of commands to build an entire Active Directory forest from nothing but a Hyper-V host and a few ISO files.</p>&#13;
<p class="indent">I’ve purposefully not covered <em>everything</em> that’s going into PowerLab in Parts I and II. Instead, I challenge you to notice these areas and come up with unique solutions on your own. After all, in programming there are <span epub:type="pagebreak" id="page_218"/>always lots of ways to accomplish the same task. If you get stuck, please feel free to reach out to me on Twitter at @adbertram.</p>&#13;
<p class="indent">By building a project of this scale, you will not only cover hundreds of PowerShell topics, but also see just how powerful a scripting language can be and come away with a substantial time-saving utility.</p>&#13;
<p class="indent">In this chapter, you’ll get PowerLab started by creating the bare-bones <code>PowerLab</code> module. Then you’ll add the ability to automate the creation of a virtual switch, VM, and virtual hard disk (VHD).</p>&#13;
<h3 class="h3" id="ch15lev1">PowerLab Module Prerequisites</h3>&#13;
<p class="noindent">To follow along with all the code examples you’ll work with in <a href="part3.xhtml#part3">Part III</a>, you need to meet a few prerequisites. Each chapter in this part has a “Prerequisites” section. This is to ensure that you always know what to expect.</p>&#13;
<p class="indent">For the project in this chapter, you need a Hyper-V host with the following configuration:</p>&#13;
<ul>&#13;
<li><p class="noindent">A network adapter</p></li>&#13;
<li><p class="noindent">IP: 10.0.0.5 (optional, but to follow along exactly, you need this IP)</p></li>&#13;
<li><p class="noindent">Subnet mask: 255.255.255.0</p></li>&#13;
<li><p class="noindent">A workgroup</p></li>&#13;
<li><p class="noindent">At least 100GB of available storage</p></li>&#13;
<li><p class="noindent">Windows Server 2016 with a full GUI</p></li>&#13;
</ul>&#13;
<p class="indent">To create a Hyper-V server, you need to install the Hyper-V role on the Windows server you intend to use. You can expedite the setup process by downloading and running the Hyper-V <em>Setup.ps1</em> script in the book’s resources at <em><a href="https://github.com/adbertram/PowerShellForSysadmins/">https://github.com/adbertram/PowerShellForSysadmins/</a></em>. This will set up Hyper-V and create a few necessary folders.</p>&#13;
<div class="note">&#13;
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>&#13;
<p class="notep"><em>If you’re planning on following along word for word, please run the associated chapter’s Pester prerequisite script</em> (Prerequisites.Tests.ps1) <em>to confirm that your Hyper-V server is set up as expected. These tests will confirm that your lab environment is set up exactly as mine is. Run</em> <span class="codeitalic">Invoke-Pester</span><em>, passing it the prerequisite script, as in <a href="ch15.xhtml#ch15list1">Listing 15-1</a>. For the rest of the book, all code will be executed on the Hyper-V host itself.</em></p>&#13;
</div>&#13;
<pre>PS&gt; <span class="codestrong1">Invoke-Pester -Path 'C:\PowerShellForSysadmins\Part III\Automating Hyper-V\Prerequisites&#13;
.Tests.ps1'</span>&#13;
&#13;
Describing Automating Hyper-V Chapter Prerequisites&#13;
 [+] Hyper-V host server should have the Hyper-V Windows feature installed 2.23s&#13;
 [+] Hyper-V host server is Windows Server 2016 147ms&#13;
 [+] Hyper-V host server should have at least 100GB of available storage 96ms&#13;
 [+] has a PowerLab folder at the root of C 130ms&#13;
 [+] has a PowerLab\VMs folder at the root of C 41ms&#13;
<span epub:type="pagebreak" id="page_219"/> [+] has a PowerLab\VHDs folder at the root of C 47ms&#13;
Tests completed in 2.69s&#13;
Passed: 5 Failed: 0 Skipped: 0 Pending: 0 Inconclusive: 0</pre>&#13;
<p class="caption" id="ch15list1"><em>Listing 15-1: Running Pester prerequisite checks for Hyper-V work</em></p>&#13;
<p class="indent">If you have successfully set up your environment, the output should confirm five passes. Once you’ve confirmed that your environment is all set up and ready go, you can get started on the project!</p>&#13;
<h3 class="h3" id="ch15lev2">Creating the Module</h3>&#13;
<p class="noindent">Because you know that you’ll need to automate a potentially large number of tasks that all relate to one another, you should create a PowerShell module. As you learned in <a href="ch07.xhtml#ch7">Chapter 7</a>, a PowerShell module is a great way to combine lots of like-functions into one unit; that way, you can easily manage all the code necessary to perform the tasks surrounding a specific purpose. PowerLab is no different. There’s no reason to think about everything at once, so start small—add functionality, test, and repeat.</p>&#13;
<h4 class="h4" id="ch15lev2sec1">Creating a Blank Module</h4>&#13;
<p class="noindent">First, you need to create a blank module. To do that, remote-desktop to your soon-to-be Hyper-V host and log in as the local administrator—or any account in the local administrators group. You’ll build this module directly on the Hyper-V host to ease VM creation and administration. This means you’ll use an RDP session to connect to your Hyper-V host’s console session. Then you’ll create the module folder, the module itself (the <em>.psm1</em> file), and the optional manifest (the <em>.psd1</em> file).</p>&#13;
<p class="indent">Since you’re logged in via the local administrator account and may one day allow others to use your PowerLab module, create the module in <em>C:\ProgramFiles\WindowsPowerShell\Modules</em>. This will allow you to access the module when logged in as any administrative user on the host.</p>&#13;
<p class="indent">Next, open a PowerShell console and choose <strong>Run as Administrator</strong>. Then, create a PowerLab module folder by using the following:</p>&#13;
<pre>PS&gt; <span class="codestrong1">New-Item -Path C:\Program Files\WindowsPowerShell\Modules\PowerLab -ItemType Directory</span></pre>&#13;
<p class="indent">Next, create a blank text file called <em>PowerLab.psm1</em>. Use the <code>New-Item</code> command:</p>&#13;
<pre>PS&gt; <span class="codestrong1">New-Item -Path 'C:\Program Files\WindowsPowerShell\Modules\PowerLab\PowerLab.psm1'</span></pre>&#13;
<h4 class="h4" id="ch15lev2sec2">Creating a Module Manifest</h4>&#13;
<p class="noindent">Now, create a module manifest. To create a module manifest, use the handy <code>New-ModuleManifest</code> command. This command creates a template manifest, which you can then open in a text editor and tweak after the <span epub:type="pagebreak" id="page_220"/>initial file is built, if necessary. Here are the parameters I used to build the template manifest:</p>&#13;
<pre>PS&gt; <span class="codestrong1">New-ModuleManifest -Path 'C:\Program Files\WindowsPowerShell\Modules\PowerLab\PowerLab.psd1'</span> &#13;
<span class="codestrong1">-Author 'Adam Bertram'</span> &#13;
<span class="codestrong1">-CompanyName 'Adam the Automator, LLC'</span> &#13;
<span class="codestrong1">-RootModule 'PowerLab.psm1'</span> &#13;
<span class="codestrong1">-Description 'This module automates all tasks to provision entire environments of a domain&#13;
controller, SQL server and IIS web server from scratch.'</span></pre>&#13;
<p class="indent">Feel free to modify the parameter values to suit your needs.</p>&#13;
<h4 class="h4" id="ch15lev2sec3">Using Built-In Prefixes for Function Names</h4>&#13;
<p class="noindent">A function doesn’t necessarily need a specific name. However, when you’re building a module that is typically a group of related functions, it’s always a good idea to preface the noun part of the function with the same label. For example, your project is called <em>PowerLab</em>. In this project, you’ll build functions that all relate to that common theme. To differentiate the functions in PowerLab from the functions in other modules you may have loaded, you can add the name of the module before the actual noun portion of the name. This means that most functions’ nouns will start with the term <em>PowerLab</em>.</p>&#13;
<p class="indent">However, not all functions will start with the name of the module. Examples include helper functions that only assist other functions and will never be called by a user.</p>&#13;
<p class="indent">When you’re sure you want all function nouns to use the same prefix without having to explicitly define it in the function name, the module manifest has an option called <code>DefaultCommandPrefix</code>. This option will force PowerShell to preface the noun with a particular string. For example, if you define the <code>DefaultCommandPrefix</code> key in a manifest and create a function inside the module called <code>New-Switch</code>, when the module is imported, the function won’t be available for use as <code>New-Switch</code> but as <code>New-PowerLabSwitch</code>:</p>&#13;
<pre># Default prefix for commands exported from this modul...&#13;
# DefaultCommandPrefix = ''</pre>&#13;
<p class="indent">I prefer <em>not</em> to go with this approach because it forcefully prefaces <em>all</em> function name nouns inside the module with that string.</p>&#13;
<h4 class="h4" id="ch15lev2sec4">Importing the New Module</h4>&#13;
<p class="noindent">Now that you’ve built the manifest, you’re ready to see whether it imports successfully. Since you haven’t written any functions yet, the module won’t be able to do anything, but it’s important to see whether PowerShell can see the module. If you see the following result, you’re good to go.</p>&#13;
<pre><span epub:type="pagebreak" id="page_221"/>PS&gt; <span class="codestrong1">Get-Module -Name PowerLab –ListAvailable</span>&#13;
&#13;
    Directory: C:\Program Files\WindowsPowerShell\Modules&#13;
&#13;
ModuleType Version    Name                                ExportedCommands&#13;
---------- -------    ----                                ----------------&#13;
Script     1.0        PowerLab</pre>&#13;
<p class="indent">If the PowerLab module doesn’t appear at the bottom of the output, return to the previous steps. In addition, check to ensure that you have the PowerLab folder created under <em>C:\Program Files\WindowsPowerShell\Modules</em> with <em>PowerLab.psm1</em> and <em>PowerLab.psd1</em> files inside.</p>&#13;
<h3 class="h3" id="ch15lev3">Automating Virtual Environment Provisioning</h3>&#13;
<p class="noindent">Now that you have built the module’s structure, you can begin to add functionality to it. Since the task of creating a server, such as SQL or IIS, has various steps that depend on one another, you’ll first work on automating the creation of a virtual switch, virtual machine, and virtual disk. Then you’ll automate deploying the operating system to these VMs, and finally, you’ll install SQL Server and IIS on these VMs.</p>&#13;
<h4 class="h4" id="ch15lev3sec5">Virtual Switches</h4>&#13;
<p class="noindent">Before you can begin automating the creation of VMs, you need to ensure that a virtual switch is set up on the Hyper-V host. <em>Virtual switches</em> allow VMs to communicate with client machines and other VMs built on a host.</p>&#13;
<h5 class="h5">Creating a Virtual Switch Manually</h5>&#13;
<p class="noindent">Your virtual switch will be an <em>external</em> switch, called <code>PowerLab</code>. Chances are, a switch with this name isn’t already on the Hyper-V host, but just to be sure, list all the virtual switches on the host. You’ll never regret checking first.</p>&#13;
<p class="indent">To see all of the switches set up on your Hyper-V host, use the <span class="codestrong">Get-VmSwitch</span> command. Once you confirm that the PowerLab switch doesn’t exist, create a new virtual switch with the <code>New-VmSwitch</code> command, specifying the name (<code>PowerLab</code>) and the type of switch:</p>&#13;
<pre>PS&gt; <span class="codestrong1">New-VMSwitch -Name PowerLab -SwitchType External</span></pre>&#13;
<p class="indent">Since you need your VMs to be able to communicate with hosts outside Hyper-V, you pass the value <code>External</code> to the <code>SwitchType</code> parameter. Whoever you share this project with will also need to create an external switch.</p>&#13;
<p class="indent">With your switch created, it’s now time to create the PowerLab module’s first function.</p>&#13;
<h5 class="h5"><span epub:type="pagebreak" id="page_222"/>Automating VM Switch Creation</h5>&#13;
<p class="noindent">The first PowerLab function, called <code>New-PowerLabSwitch</code>, creates the Hyper-V switch. This function isn’t too complicated. In fact, without it, you would simply need to execute a single command at the prompt—that is, <code>New-VmSwitch</code>. But if you wrap that Hyper-V command inside a custom function, you will have the ability to perform other work: adding any kind of default configuration to the switch, for example.</p>&#13;
<p class="indent">I am a big fan of <em>idempotency</em>, which is a fancy word that means “regardless of the state in which the command executes, it performs the same task every time.” In this example, if the task of creating the switch were not idempotent, then running <code>New-VmSwitch</code> would result in an error if the switch already existed.</p>&#13;
<p class="indent">To remove the requirement to manually check whether the switch is created before attempting to create a switch, you can use the <code>Get-VmSwitch</code> command. This command checks whether the switch has been created. Then, if—and only if—the switch doesn’t exist will you attempt to create a new switch. This allows you to run <code>New-PowerLabSwitch</code> in any environment and know that it will always create the virtual switch without returning an error—regardless of the state of the Hyper-V host.</p>&#13;
<p class="indent">Open the <em>C:\Program Files\WindowsPowerShell\Modules\PowerLab\PowerLab.psm1</em> file and create the <code>New-PowerLabSwitch</code> function, as shown in <a href="ch15.xhtml#ch15list2">Listing 15-2</a>.</p>&#13;
<pre>function New-PowerLabSwitch {&#13;
    param(&#13;
        [Parameter()]&#13;
        [string]$SwitchName = 'PowerLab',&#13;
&#13;
        [Parameter()]&#13;
        [string]$SwitchType = 'External'&#13;
    )&#13;
&#13;
    if (-not (Get-VmSwitch -Name $SwitchName -SwitchType $SwitchType -ErrorAction&#13;
    SilentlyContinue)) { <span class="ent">❶</span>&#13;
        $null = New-VMSwitch -Name $SwitchName -SwitchType $SwitchType <span class="ent">❷</span>&#13;
    } else {&#13;
        Write-Verbose -Message "The switch [$($SwitchName)] has already been created." <span class="ent">❸</span>&#13;
    }&#13;
}</pre>&#13;
<p class="caption" id="ch15list2"><em>Listing 15-2: <code>New-PowerLabSwitch</code> function in the <code>PowerLab</code> module</em></p>&#13;
<p class="indent">This function first checks to see whether the switch is already created <span class="ent">❶</span>. If it isn’t, the function creates it <span class="ent">❷</span>. If the switch is already created, the function will simply return a verbose message to the console <span class="ent">❸</span>.</p>&#13;
<p class="indent">Save the module and then force it to import again by using <span class="codestrong">Import-Module -Name PowerLab -Force</span>.</p>&#13;
<p class="indent">When you add new functions to the module, you must import the module again. If a module is already imported, you must use the <code>Force</code> parameter with <code>Import-Module</code> to force <span epub:type="pagebreak" id="page_223"/>PowerShell to import it again. Otherwise, PowerShell will see that the module has already been imported and skip it.</p>&#13;
<p class="indent">Once you’ve imported the module again, the <code>New-PowerLabSwitch</code> function should be available to you. Run this command:</p>&#13;
<pre>PS&gt; <span class="codestrong1">New-PowerLabSwitch –Verbose</span>&#13;
VERBOSE: The switch [PowerLab] has already been created.</pre>&#13;
<p class="indent">Notice that you don’t receive an error, but instead, a useful verbose message saying the switch has already been created. This is because you passed the optional <code>Verbose</code> parameter to the function. Defaults were chosen for the <code>SwitchName</code> and <code>SwitchType</code> parameters, since these will usually be the same.</p>&#13;
<h4 class="h4" id="ch15lev3sec6">Creating Virtual Machines</h4>&#13;
<p class="noindent">Now that you’ve set up a virtual switch, it’s time to create a VM. For this demo, you’ll create a generation 2 VM, called LABDC, with 2GB attached to the virtual switch you just built in the <em>C:\PowerLab\VMs</em> folder on the Hyper-V host. I’ve chosen <em>LABDC</em> as the name because this will eventually be our Active Directory domain controller. This VM will eventually be the domain controller you’ll use for your fully built lab.</p>&#13;
<p class="indent">First, take a look at all the existing VMs and ensure that one doesn’t already exist with the same name. Since you already know the name of the VM you want to create, pass that value to the <code>Name</code> parameter of <code>Get-Vm</code>:</p>&#13;
<pre>PS&gt; <span class="codestrong1">Get-Vm -Name LABDC</span>&#13;
Get-Vm : A parameter is invalid. Hyper-V was unable to find a virtual machine with name LABDC.&#13;
At line:1 char:1&#13;
+ Get-Vm -Name LABDC&#13;
+ ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~&#13;
    + CategoryInfo          : InvalidArgument: (LABDC:String) [Get-VM],&#13;
                              VirtualizationInvalidArgumentException&#13;
    + FullyQualifiedErrorId : InvalidParameter,Microsoft.HyperV.PowerShell.Commands.GetVMCommand</pre>&#13;
<p class="indent">The <code>Get-Vm</code> command returns an error when it can’t find the VM with the specified name. Because you’re just checking whether it exists, and it doesn’t necessarily matter to us whether it does or doesn’t at this point, use the <code>ErrorAction</code> parameter with the <code>SilentlyContinue</code> value to ensure that the command returns nothing if the VM doesn’t exist in your automation script later. You’re not using a <code>try/catch</code> here for simplicity’s sake.</p>&#13;
<p class="indent">This technique works only if the command returns a nonterminating error. If the command returns a terminating error, you’ll have to either look into returning all the objects and filtering them with <code>Where-Object</code> or enclosing the command in a <code>try/catch</code> block.</p>&#13;
<h5 class="h5">Creating a VM Manually</h5>&#13;
<p class="noindent">The VM doesn’t exist, which means you need to create it. To create a VM, you need to run the <code>Get-Vm</code> command and pass it the values that you defined at the start of this section.</p>&#13;
<pre><span epub:type="pagebreak" id="page_224"/>PS&gt; <span class="codestrong1">New-VM -Name 'LABDC' -Path 'C:\PowerLab\VMs'</span> &#13;
<span class="codestrong1">-MemoryStartupBytes 2GB -Switch 'PowerLab' -Generation 2</span>&#13;
&#13;
Name   State CPUUsage(%) MemoryAssigned(M) Uptime   Status             Version&#13;
----   ----- ----------- ----------------- ------   ------             -------&#13;
LABDC  Off   0           0                 00:00:00 Operating normally 8.0</pre>&#13;
<p class="indent">You should now have a VM, but confirm this by running <span class="codestrong">Get-Vm</span> again.</p>&#13;
<h5 class="h5">Automating VM Creation</h5>&#13;
<p class="noindent">To automate creating a simple VM, you again need to add another function. This function will follow the same pattern as that used to create a new virtual switch: make an idempotent function that performs a task regardless of the state of the Hyper-V host.</p>&#13;
<p class="indent">Enter the <code>New-PowerLabVm</code> function, as shown in <a href="ch15.xhtml#ch15list3">Listing 15-3</a>, into your <em>PowerLab.psm1</em> module.</p>&#13;
<pre>function New-PowerLabVm {&#13;
    param(&#13;
        [Parameter(Mandatory)]&#13;
        [string]$Name,&#13;
&#13;
        [Parameter()]&#13;
        [string]$Path = 'C:\PowerLab\VMs',&#13;
&#13;
        [Parameter()]&#13;
        [string]$Memory = 4GB,&#13;
&#13;
        [Parameter()]&#13;
        [string]$Switch = 'PowerLab',&#13;
&#13;
        [Parameter()]&#13;
        [ValidateRange(1, 2)]&#13;
        [int]$Generation = 2&#13;
    )&#13;
&#13;
 <span class="ent">❶</span> if (-not (Get-Vm -Name $Name -ErrorAction SilentlyContinue)) {&#13;
     <span class="ent">❷</span> $null = New-VM -Name $Name -Path $Path -MemoryStartupBytes $Memory&#13;
        -Switch $Switch -Generation $Generation&#13;
    } else {&#13;
     <span class="ent">❸</span> Write-Verbose -Message "The VM [$($Name)] has already been created."&#13;
    }&#13;
}</pre>&#13;
<p class="caption" id="ch15list3"><em>Listing 15-3: <code>New-PowerLabVm</code> function in the <code>PowerLab</code> module</em></p>&#13;
<p class="indent">This function checks whether the VM already exists <span class="ent">❶</span>. If it doesn’t, the function will create one <span class="ent">❷</span>. If it does, the function will display a verbose message to the console <span class="ent">❸</span>.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_225"/>Save <em>PowerLab.psm1</em> and execute your new function at the prompt:</p>&#13;
<pre>PS&gt; <span class="codestrong1">New-PowerLabVm -Name 'LABDC' –Verbose</span>&#13;
VERBOSE: The VM [LABDC] has already been created.</pre>&#13;
<p class="indent">Again, when you run this command, you can create a VM with the specified parameter values—whether that VM already exists (after you force the module to be imported again) or not.</p>&#13;
<h4 class="h4" id="ch15lev3sec7">Virtual Hard Disks</h4>&#13;
<p class="noindent">You now have a VM attached to a switch, but a VM isn’t any good without storage attached to it. To take care of that, you need to create a local virtual hard disk (VHD) and connect it to a VM.</p>&#13;
<div class="note">&#13;
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>&#13;
<p class="notep"><em>In <a href="ch16.xhtml#ch16">Chapter 16</a>, you’ll use a community script that converts an ISO file into a VHD. Therefore, you don’t need to create a VHD. But if you aren’t planning on automating the operating system deployment, or if you need to automate the VHD creation as part of another script, I still recommend that you complete this section.</em></p>&#13;
</div>&#13;
<h5 class="h5">Creating a VHD Manually</h5>&#13;
<p class="noindent">To create a VHD file, you need only a single command: <code>New-Vhd</code>. In this section, you’ll create a VHD that’s capable of growing to 50GB in size; and to save space, you’ll set the VHD to dynamically size.</p>&#13;
<p class="indent">You first need to create a folder on the Hyper-V host at <em>C:\PowerLab\VHDs</em> to place the VHD. Be sure to name your VHD with the same name as the VM you intend to attach it to in order to keep things simple.</p>&#13;
<p class="indent">Create the VHD with <code>New-Vhd</code>:</p>&#13;
<pre>PS&gt; <span class="codestrong1">New-Vhd</span> <span class="ent">❶</span><span class="codestrong1">-Path 'C:\PowerLab\VHDs\MYVM.vhdx'</span> <span class="ent">❷</span><span class="codestrong1">-SizeBytes 50GB</span> <span class="ent">❸</span><span class="codestrong1">–Dynamic</span>&#13;
&#13;
ComputerName            : HYPERVSRV&#13;
Path                    : C:\PowerLab\VHDs\MYVM.vhdx&#13;
VhdFormat               : VHDX&#13;
VhdType                 : Dynamic&#13;
FileSize                : 4194304&#13;
Size                    : 53687091200&#13;
MinimumSize             :&#13;
LogicalSectorSize       : 512&#13;
PhysicalSectorSize      : 4096&#13;
BlockSize               : 33554432&#13;
ParentPath              :&#13;
DiskIdentifier          : 3FB5153D-055D-463D-89F3-BB733B9E69BC&#13;
FragmentationPercentage : 0&#13;
Alignment               : 1&#13;
Attached                : False&#13;
DiskNumber              :&#13;
Number                  :</pre>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_226"/>You pass <code>New-Vhd</code> the path <span class="ent">❶</span> and the VHD size <span class="ent">❷</span>, and, finally, indicate that you want it to dynamically size <span class="ent">❸</span>.</p>&#13;
<p class="indent">Confirm that you successfully created the VHD on your Hyper-V host with the <code>Test-Path</code> command. If <code>Test-Path</code> returns <code>True</code>, you were successful:</p>&#13;
<pre>PS&gt; <span class="codestrong1">Test-Path -Path 'C:\PowerLab\VHDs\MYVM.vhdx'</span>&#13;
True</pre>&#13;
<p class="indent">Now you need to attach the VHD to the VM you created earlier. To do this, you use the <code>Add-VMHardDiskDrive</code> command. But because you’re <em>not</em> going to be attaching a VHD to LABDC—the OS deployment automation, in <a href="ch16.xhtml#ch16">Chapter 16</a>, will do that—create another VM, called MYVM, to attach to the VHD:</p>&#13;
<pre>PS&gt; <span class="codestrong1">New-PowerLabVm -Name 'MYVM'</span>&#13;
PS&gt; <span class="ent">❶</span><span class="codestrong1">Get-VM -Name MYVM | Add-VMHardDiskDrive -Path 'C:\PowerLab\VHDs\MYVM.vhdx'</span>&#13;
PS&gt; <span class="ent">❷</span><span class="codestrong1">Get-VM -Name MYVM | Get-VMHardDiskDrive</span>&#13;
&#13;
VMName ControllerType ControllerNumber ControllerLocation DiskNumber Path&#13;
------ -------------- ---------------- ------------------ ---------- ----&#13;
MYVM   SCSI           0                0                             C:\PowerLab\VHDs\MYVM.vhdx</pre>&#13;
<p class="indent">The <code>Add-VMHardDiskDrive</code> command accepts the object type that the <code>Get-VM</code> command returns for its pipeline input so you can pass the VM directly from <code>Get-VM</code> to <code>Add-VMHardDiskDrive</code>—specifying the path to the VHD on the Hyper-V host <span class="ent">❶</span>.</p>&#13;
<p class="indent">Immediately after, use <code>Get-VMHardDiskDrive</code> to confirm that the VHDX was added successfully <span class="ent">❷</span>.</p>&#13;
<h5 class="h5">Automating VHD Creation</h5>&#13;
<p class="noindent">You can add another function to your module to automate the process of creating a VHD and attaching it to a VM. When you create scripts or functions, accounting for various configurations is important.</p>&#13;
<p class="indent"><a href="ch15.xhtml#ch15list4">Listing 15-4</a> defines the <code>New-PowerLabVhd</code> function, which creates a VHD and attaches a VM to it.</p>&#13;
<pre>function New-PowerLabVhd {&#13;
    param&#13;
    (&#13;
        [Parameter(Mandatory)]&#13;
        [string]$Name,&#13;
&#13;
        [Parameter()]&#13;
        [string]$AttachToVm,&#13;
&#13;
        [Parameter()]&#13;
        [ValidateRange(512MB, 1TB)]&#13;
        [int64]$Size = 50GB,&#13;
&#13;
<span epub:type="pagebreak" id="page_227"/>        [Parameter()]&#13;
        [ValidateSet('Dynamic', 'Fixed')]&#13;
        [string]$Sizing = 'Dynamic',&#13;
&#13;
        [Parameter()]&#13;
        [string]$Path = 'C:\PowerLab\VHDs'&#13;
    )&#13;
&#13;
    $vhdxFileName = "$Name.vhdx"&#13;
    $vhdxFilePath = Join-Path -Path $Path -ChildPath "$Name.vhdx"&#13;
&#13;
    ### Ensure we don't try to create a VHD when there's already one there&#13;
    if (-not (Test-Path -Path $vhdxFilePath -PathType Leaf)) { <span class="ent">❶</span>&#13;
        $params = @{&#13;
            SizeBytes = $Size&#13;
            Path      = $vhdxFilePath&#13;
        }&#13;
        if ($Sizing -eq 'Dynamic') { <span class="ent">❷</span>&#13;
            $params.Dynamic = $true&#13;
        } elseif ($Sizing -eq 'Fixed') {&#13;
            $params.Fixed = $true&#13;
        }&#13;
&#13;
        New-VHD @params&#13;
        Write-Verbose -Message "Created new VHD at path [$($vhdxFilePath)]"&#13;
    }&#13;
&#13;
    if ($PSBoundParameters.ContainsKey('AttachToVm')) {&#13;
        if (-not ($vm = Get-VM -Name $AttachToVm -ErrorAction SilentlyContinue)) { <span class="ent">❸</span>&#13;
            Write-Warning -Message "The VM [$($AttachToVm)] does not exist. Unable to attach VHD."&#13;
        } elseif (-not ($vm | Get-VMHardDiskDrive | Where-Object { $_.Path -eq $vhdxFilePath })) { <span class="ent">❹</span>&#13;
            $vm | Add-VMHardDiskDrive -Path $vhdxFilePath&#13;
            Write-Verbose -Message "Attached VHDX [$($vhdxFilePath)] to VM [$($AttachToVM)]."&#13;
        } else { <span class="ent">❺</span>&#13;
            Write-Verbose -Message "VHDX [$($vhdxFilePath)] already attached to VM [$($AttachToVM)]."&#13;
        }&#13;
    }&#13;
}</pre>&#13;
<p class="caption" id="ch15list4"><em>Listing 15-4: <code>New-PowerLabVhd</code> function in the <code>PowerLab</code> module</em></p>&#13;
<p class="indent">This function supports both dynamic and fixed sizing <span class="ent">❷</span>, and it accounts for four individual states:</p>&#13;
<ul>&#13;
<li><p class="noindent">The VHD already exists <span class="ent">❶</span>.</p></li>&#13;
<li><p class="noindent">The VM to attach the VHD to doesn’t exist <span class="ent">❸</span>.</p></li>&#13;
<li><p class="noindent">The VM to attach the VHD to exists, but the VHD hasn’t been connected yet <span class="ent">❹</span>.</p></li>&#13;
<li><p class="noindent">The VM to attach the VHD to exists, and the VHD has already been attached <span class="ent">❺</span>.</p></li>&#13;
</ul>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_228"/>Function design is a whole other matter entirely. It takes years of coding and practice to be able to create a script or function that’s resilient across many scenarios. It’s an art that has never truly been perfected, but if you’re able to think through as many different ways a problem may occur and account for those up front, your function will be that much better off. However, don’t go <em>too</em> overboard and spend hours on a function or script making sure <em>every</em> detail is covered! This is just code. You can change it later.</p>&#13;
<h5 class="h5">Executing the New-PowerLabVhd Function</h5>&#13;
<p class="noindent">You can execute this code in various states and account for each state. Let’s test multiple states to ensure that this automation script works in each situation:</p>&#13;
<pre>PS&gt; <span class="codestrong1">New-PowerLabVhd -Name MYVM -Verbose -AttachToVm MYVM</span>&#13;
&#13;
VERBOSE: VHDX [C:\PowerLab\VHDs\MYVM.vhdx] already attached to VM [MYVM].&#13;
&#13;
PS&gt; <span class="codestrong1">Get-VM -Name MYVM | Get-VMHardDiskDrive | Remove-VMHardDiskDrive</span>&#13;
PS&gt; <span class="codestrong1">New-PowerLabVhd -Name MYVM -Verbose -AttachToVm MYVM</span>&#13;
&#13;
VERBOSE: Attached VHDX [C:\PowerLab\VHDs\MYVM.vhdx] to VM [MYVM].&#13;
PS&gt; <span class="codestrong1">New-PowerLabVhd -Name MYVM -Verbose -AttachToVm NOEXIST</span>&#13;
&#13;
WARNING: The VM [NOEXIST] does not exist. Unable to attach VHD.</pre>&#13;
<p class="indent">Here, you’re not quite testing in the formal sense. Instead, you’re putting your new function through its paces by forcing it to run through each of the code paths you defined.</p>&#13;
<h3 class="h3" id="ch15lev4">Testing the New Functions with Pester</h3>&#13;
<p class="noindent">You should now be able to automate the creation of a Hyper-V VM, but you should always build Pester tests for everything you create in order to make sure everything works as you expect, as well as monitor your automation over time. You’ll build Pester tests for all the work you do in the rest of the book. You can find the Pester tests in this book’s resources at <a href="https://github.com/adbertram/PowerShellForSysadmins/"><em>https://github.com/adbertram/PowerShellForSysadmins/</em></a>.</p>&#13;
<p class="indent">In this chapter, you accomplished four things:</p>&#13;
<ul>&#13;
<li><p class="noindent">Created a virtual switch</p></li>&#13;
<li><p class="noindent">Created a VM</p></li>&#13;
<li><p class="noindent">Created a VHDX</p></li>&#13;
<li><p class="noindent">Attached the VHDX to the VM</p></li>&#13;
</ul>&#13;
<p class="indent">I broke the Pester tests for this chapter into sections that correspond to the four accomplishments. Breaking tests into stages like this helps keep your tests organized.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_229"/>Let’s run the test against the code you wrote in this chapter. To run the test script, make sure you downloaded the <em>Automating-Hyper-V.Tests.ps1</em> script from the book’s resources. In the following code, the test script is located in the root of <em>C:\</em>, but your path may be different depending on where you downloaded the resource files.</p>&#13;
<pre>PS&gt; <span class="codestrong1">Invoke-Pester 'C:\Automating-Hyper-V.Tests.ps1'</span>&#13;
Describing Automating Hyper-V Chapter Demo Work&#13;
   Context Virtual Switch&#13;
    [+] created a virtual switch called PowerLab 195ms&#13;
   Context Virtual Machine&#13;
    [+] created a virtual machine called MYVM 62ms&#13;
   Context Virtual Hard Disk&#13;
    [+] created a VHDX called MYVM at C:\PowerLab\VHDs 231ms&#13;
    [+] attached the MYVM VHDX to the MYVM VM 194ms&#13;
Tests completed in 683ms&#13;
Passed: 4 Failed: 0 Skipped: 0 Pending: 0 Inconclusive: 0</pre>&#13;
<p class="indent">All four tests pass, so you’re good to move on to the next chapter.</p>&#13;
<h3 class="h3" id="ch15lev5">Summary</h3>&#13;
<p class="noindent">You created the foundation for your first real-world PowerShell automation project! I hope you’re already seeing just how much time you can save by automating with PowerShell! By using a freely available PowerShell module from Microsoft, you were able to run just a few commands to quickly create a virtual switch, VM, and disk drive. Microsoft gave you the commands, but it was up to you to build the logic around them to make everything flow seamlessly.</p>&#13;
<p class="indent">You might now see that it’s possible to build scripts on the fly that work, but by thinking ahead and adding conditional logic, your scripts can account for more situations.</p>&#13;
<p class="indent">In the next chapter, you’ll take the VM you just created and automate deploying an operating system to it with little more than an ISO file.<span epub:type="pagebreak" id="page_230"/></p>&#13;
</body></html>