- en: '19'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Data Buses
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter you will
  prefs: []
  type: TYPE_NORMAL
- en: Learn about the I²C bus
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: See how to use an EEPROM and a port expander on the I²C bus
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Learn about the SPI bus
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Find out how to use a digital rheostat on the SPI bus
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An Arduino communicates with other devices via a *data bus*, a system of connections
    that allows two or more devices to exchange data in an orderly manner. A data
    bus can provide a connection between the Arduino and various sensors, I/O expansion
    devices, and other components.
  prefs: []
  type: TYPE_NORMAL
- en: The two major buses of most importance to the Arduino are the *Serial Peripheral
    Interface (SPI)* bus and the *Inter-Integrated Circuit (I*^(*2*)*C)* bus. Many
    useful sensors and external devices communicate using these buses.
  prefs: []
  type: TYPE_NORMAL
- en: The I²C Bus
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The I²C bus, also known as the *Two-Wire Interface (TWI)* bus, is a simple and
    easy-to-use data bus. Data is transferred between devices and the Arduino through
    two wires, known as *SDA* and *SCL* (the data line and clock line, respectively).
    In the case of the Arduino Uno, the SDA pin is A4 and the SCL pin is A5, as shown
    in [Figure 19-1](#figure19-1).
  prefs: []
  type: TYPE_NORMAL
- en: Some newer R3 boards also have dedicated I²C pins at the upper-left corner for
    convenient access, as shown in [Figure 19-2](#figure19-2). If you use these two
    pins, you cannot use the A4 and A5 pins for other purposes.
  prefs: []
  type: TYPE_NORMAL
- en: '![f19001](image_fi/500587c19/f19001.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 19-1: The I ²C bus connectors on the Arduino Uno'
  prefs: []
  type: TYPE_NORMAL
- en: '![f19002](image_fi/500587c19/f19002.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 19-2: Additional dedicated I ²C pins'
  prefs: []
  type: TYPE_NORMAL
- en: As the six pins used for reprogramming the USB interface microcontroller take
    up the space normally used for pin labeling, you can see the labels on the rear
    of the Arduino, as shown in [Figure 19-3](#figure19-3).
  prefs: []
  type: TYPE_NORMAL
- en: '![f19003](image_fi/500587c19/f19003.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 19-3: Labels for additional dedicated I ²C pins'
  prefs: []
  type: TYPE_NORMAL
- en: On the I²C bus, the Arduino is the *main device*, and each IC out on the bus
    is a *secondary*. Each secondary has its own address, a hexadecimal number that
    allows the Arduino to address and communicate with each device. Each device usually
    has a range of 7-bit I²C bus addresses to choose from, which is detailed in the
    manufacturer’s data sheet. The particular addresses available are determined by
    wiring the IC pins a certain way.
  prefs: []
  type: TYPE_NORMAL
- en: 'To use the I²C bus, you’ll need to use the Wire library (included with the
    Arduino IDE):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, in `void setup()`, activate the bus with this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Data is transmitted along the bus 1 byte at a time. To send a byte of data
    from the Arduino to a device on the bus, three functions are required:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The first function initiates communication with the following line of code
    (where `address` is the secondary device’s bus address in hexadecimal—for example
    `0x50`):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The second function sends 1 byte of data from the Arduino to the device addressed
    by the previous function (where `data` is a variable containing 1 byte of data;
    you can send more than 1 byte, but you’ll need to use one `Wire.write()` call
    for each byte):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, once you have finished sending data to a particular device, use this
    to end the transmission:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To request that data from an I²C device be sent to the Arduino, start with
    `Wire.beginTransmission(``address``)`, followed by the this code (where `x` is
    the number of bytes of data to request):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, use the following function to store each incoming byte into a variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Then finalize the transaction with `Wire.endTransmission()`. We’ll put these
    functions to use in the next project.
  prefs: []
  type: TYPE_NORMAL
- en: 'Project #54: Using an External EEPROM'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In Chapter 18, we used the Arduino’s internal EEPROM to prevent the erasure
    of variable data caused by a board reset or power failure. The Arduino’s internal
    EEPROM stores only 1,024 bytes of data. To store more data, you can use external
    EEPROMs, as you’ll see in this project.
  prefs: []
  type: TYPE_NORMAL
- en: '![f19004](image_fi/500587c19/f19004.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 19-4: Microchip Technology’s 24LC512 EEPROM'
  prefs: []
  type: TYPE_NORMAL
- en: For our external EEPROM, we’ll use the Microchip Technology 24LC512 EEPROM,
    which can store 64KB (65,536 bytes) of data ([Figure 19-4](#figure19-4)). It’s
    available from retailers such as Digi-Key (part number 24LC512-I/P-ND) and PMD
    Way (part number 24LC512A).
  prefs: []
  type: TYPE_NORMAL
- en: The Hardware
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Here’s what you’ll need to create this project:'
  prefs: []
  type: TYPE_NORMAL
- en: Arduino and USB cable
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: One Microchip Technology 24LC512 EEPROM
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: One breadboard
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Two 4.7 kΩ resistors
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: One 100 nF ceramic capacitor
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Various connecting wires
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Schematic
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: For the circuit, connect one 4.7 kΩ resistor between 5 V and SCL and the other
    between 5 V and SDA, as shown in [Figure 19-5](#figure19-5).
  prefs: []
  type: TYPE_NORMAL
- en: '![f19005](image_fi/500587c19/f19005.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 19-5: Schematic for Project 54'
  prefs: []
  type: TYPE_NORMAL
- en: The bus address for the 24LC512 EEPROM IC is partially determined by the way
    it is wired into the circuit. The last 3 bits of the bus address are determined
    by the status of pins A2, A1, and A0\. When these pins are connected to GND, their
    values are `0`; when they are connected to 5 V, their values are `1`.
  prefs: []
  type: TYPE_NORMAL
- en: The first 4 bits are preset as `1010`. Therefore, in our circuit, since A0,
    A1, and A2 are connected directly to GND, the bus address is represented as `1010000`
    in binary, which is `0x50` in hexadecimal. This means that we can use `0x50` as
    the bus address in the sketch.
  prefs: []
  type: TYPE_NORMAL
- en: The Sketch
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Although our external EEPROM can store up to 64KB of data, our sketch is intended
    to demonstrate just a bit of its use, so we’ll store and retrieve bytes only in
    the EEPROM’s first 20 memory positions.
  prefs: []
  type: TYPE_NORMAL
- en: 'Enter and upload the following sketch:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Let’s walk through the sketch. At 1, we activate the library and define the
    I²C bus address for the EEPROM as `chip1`. At 2, we start the Serial Monitor and
    then the I²C bus. The two custom functions `writeData()` and `readData()` are
    included to save you time and give you some reusable code for future work with
    this EEPROM IC. We’ll use them to write and read data, respectively, from the
    EEPROM.
  prefs: []
  type: TYPE_NORMAL
- en: The function `writeData()` at 3 initiates transmission with the EEPROM, sends
    the address of where to store the byte of data in the EEPROM using the next two
    `Wire.write()` function calls, sends a byte of data to be written, and then ends
    transmission.
  prefs: []
  type: TYPE_NORMAL
- en: The function `readData()` at 4 operates the I²C bus in the same manner as `writeData()`.
    First, however, it sets the address to read from, and then instead of sending
    a byte of data to the EEPROM, it uses `Wire.requestFrom()` to read the data at
    5. Finally, the byte of data sent from the EEPROM is received into the variable
    `result` and becomes the return value for the function.
  prefs: []
  type: TYPE_NORMAL
- en: Running the Sketch
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In `void loop()`, the sketch loops 20 times and writes a value to the EEPROM
    each time. Then it loops again, retrieving the values and displaying them in the
    Serial Monitor, as shown in [Figure 19-6](#figure19-6).
  prefs: []
  type: TYPE_NORMAL
- en: '![f19006](image_fi/500587c19/f19006.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 19-6: Results of Project 54'
  prefs: []
  type: TYPE_NORMAL
- en: 'Project #55: Using a Port Expander IC'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A *port expander* is another useful IC that is controlled via I²C. It’s designed
    to offer more digital output pins. In this project, we’ll use the Microchip Technology
    MCP23017 16-bit port expander IC ([Figure 19-7](#figure19-7)), which has 16 digital
    outputs to add to your Arduino. It is available from retailers such as Digi-Key
    (part number MCP23017-E/SP-ND) and PMD Way (part number MCP23017A).
  prefs: []
  type: TYPE_NORMAL
- en: '![f19007](image_fi/500587c19/f19007.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 19-7: Microchip Technology’s MCP23017 port expander IC'
  prefs: []
  type: TYPE_NORMAL
- en: In this project, we’ll connect the MCP23017 to an Arduino and demonstrate how
    to control the 16 port expander outputs with the Arduino. Each of the port expander’s
    outputs can be treated like a regular Arduino digital output.
  prefs: []
  type: TYPE_NORMAL
- en: The Hardware
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Here’s what you’ll need to create this project:'
  prefs: []
  type: TYPE_NORMAL
- en: Arduino and USB cable
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: One breadboard
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Various connecting wires
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: One Microchip Technology MCP20317 port expander IC
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Two 4.7 kΩ resistors
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: (Optional) An equal number of 560 Ω resistors and LEDs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Schematic
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[Figure 19-8](#figure19-8) shows the basic schematic for an MCP23017\. As with
    the EEPROM from Project 54, we can set the I²C bus address by using a specific
    wiring order. With the MCP23017, we connected pins 15 through 17 to GND to set
    the address to `0x20`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'When you’re working with the MCP23017, it helps to have the pinout diagram
    from the IC’s data sheet, as shown in [Figure 19-9](#figure19-9). Note that the
    16 outputs are divided into two banks: GPA7 through GPA0 on the right and GPB0
    through GPB7 on the left. We’ll connect LEDs via 560 Ω resistors from some or
    all of the outputs to demonstrate when the outputs are being activated.'
  prefs: []
  type: TYPE_NORMAL
- en: '![f19008](image_fi/500587c19/f19008.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 19-8: Schematic for Project 55'
  prefs: []
  type: TYPE_NORMAL
- en: '![f19009](image_fi/500587c19/f19009.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 19-9: Pinout diagram for MCP23017'
  prefs: []
  type: TYPE_NORMAL
- en: The Sketch
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Enter and upload the following sketch:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: To use the MCP23017, we need the lines listed in `void setup()` from 1 through
    2. To turn on and off the outputs on each bank, we send 1 byte representing each
    bank in order; that is, we send a value for bank GPA0 through GPA7 and then a
    value for GPB0 through GPB7.
  prefs: []
  type: TYPE_NORMAL
- en: When setting individual pins, you can think of each bank as a binary number
    (as explained in “A Quick Course in Binary” in Chapter 6 on page 104). Thus, to
    turn on pins 1 through 4, you would send the number `11110000` in binary (`240`
    in decimal), inserted into the `Wire.write()` function shown at 3 for bank GPA0
    through GPA7 or 4 for bank GPB0 through GPB7.
  prefs: []
  type: TYPE_NORMAL
- en: Hundreds of devices use the I²C bus for communication. Now that you know the
    basics of how to use this bus, you can use any of these devices with an Arduino
    board.
  prefs: []
  type: TYPE_NORMAL
- en: The SPI Bus
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The SPI bus differs from the I²C bus in that it can be used to send data to
    and receive data from a device simultaneously and at different speeds, depending
    on the microcontroller used. Communication, however, is also main/secondary: the
    Arduino acts as the main and determines which secondary device it will communicate
    with at any one time.'
  prefs: []
  type: TYPE_NORMAL
- en: Pin Connections
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Each SPI device uses four pins to communicate with a main: *MOSI* (main out,
    secondary in), *MISO* (main in, secondary out), *SCK* (serial clock), and *SS*
    or *CS* (secondary select or chip select). These SPI pins are connected to the
    Arduino as shown in [Figure 19-10](#figure19-10).'
  prefs: []
  type: TYPE_NORMAL
- en: '![f19010](image_fi/500587c19/f19010.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 19-10: SPI pins on an Arduino Uno'
  prefs: []
  type: TYPE_NORMAL
- en: A typical single Arduino-to-SPI device connection is shown in [Figure 19-11](#figure19-11).
    Arduino pins D11 through D13 are reserved for SPI, but the SS pin can use any
    other digital pin (often D10 is used because it’s next to the SPI pins).
  prefs: []
  type: TYPE_NORMAL
- en: '![f19011](image_fi/500587c19/f19011.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 19-11: Typical Arduino-to-SPI device connection'
  prefs: []
  type: TYPE_NORMAL
- en: Implementing the SPI
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Now let’s examine how to implement the SPI bus in a sketch. Before doing this,
    however, we’ll run through the functions used. First, include the SPI library
    (included with the Arduino IDE software):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, you need to choose a pin to be used for SS and set it as a digital output
    in `void setup()`. Because we’re using only one SPI device in our example, we’ll
    use D10 and set it to `HIGH` first, because most SPI devices have an “active low”
    SS pin (this means the pin is connected to GND to be set to `HIGH`, and vice versa):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is the function to activate the SPI bus:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we need to tell the sketch which way to send and receive data. Some
    SPI devices require that their data be sent with the most significant bit first,
    and some want the MSB last. (Again, see “A Quick Course in Binary” in Chapter
    6 for more on MSB.) Therefore, in `void setup()`, we use the following function
    after `SPI.begin()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Here, `order` is either `MSBFIRST` or `MSBLAST`.
  prefs: []
  type: TYPE_NORMAL
- en: Sending Data to an SPI Device
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To send data to an SPI device, we first set the SS pin to `LOW`, which tells
    the SPI device that the main (the Arduino) wants to communicate with it. Next,
    we send bytes of data to the device with the following line, as often as necessary—that
    is, you use this once for each byte you are sending:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: After you’ve finished communicating with the device, set the SS pin to `HIGH`
    to tell the device that the Arduino has finished communicating with it.
  prefs: []
  type: TYPE_NORMAL
- en: Each SPI device requires a separate SS pin. For example, if you had two SPI
    devices, the second SPI device’s SS pin could be D9 and connected to the Arduino
    as shown in [Figure 19-12](#figure19-12).
  prefs: []
  type: TYPE_NORMAL
- en: '![f19012](image_fi/500587c19/f19012.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 19-12: Two SPI devices connected to one Arduino'
  prefs: []
  type: TYPE_NORMAL
- en: 'When communicating with secondary device #2, you would use the D9 (instead
    of the D10) SS pin before and after communication.'
  prefs: []
  type: TYPE_NORMAL
- en: Project 56 demonstrates using the SPI bus with a digital rheostat.
  prefs: []
  type: TYPE_NORMAL
- en: 'Project #56: Using a Digital Rheostat'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In simple terms, a *rheostat* device is similar to the potentiometers we examined
    in Chapter 4, except the rheostat has two pins: one for the wiper and one for
    the return current. In this project, you’ll use a digital rheostat to set the
    resistance in the sketch instead of physically turning a potentiometer knob or
    shaft yourself. Rheostats are often the basis of volume controls in audio equipment
    that use buttons rather than dials, such as a car stereo. The tolerance of a rheostat
    is much larger than that of a normal fixed-value resistor—in some cases, around
    20 percent larger.'
  prefs: []
  type: TYPE_NORMAL
- en: '![f19013](image_fi/500587c19/f19013.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 19-13: Microchip Technology’s MCP4162 digital rheostat'
  prefs: []
  type: TYPE_NORMAL
- en: For Project 56, we will use the Microchip Technology MCP4162 shown in [Figure
    19-13](#figure19-13). The MCP4162 is available in various resistance values; this
    example uses the 10 kΩ version. It is available from retailers such as Digi-Key
    (part number MCP4162-103E/P-ND) and element14 (part number 1840698). The resistance
    can be adjusted in 257 steps; each step has a resistance of around 40 Ω. To select
    a particular step, we send 2 bytes of data to a command byte (which is 0) and
    the value byte (which is between 0 and 256). The MCP4162 uses nonvolatile memory,
    so when the power is disconnected and then reconnected, the last value selected
    is still in effect.
  prefs: []
  type: TYPE_NORMAL
- en: We’ll control the brightness of an LED using the rheostat.
  prefs: []
  type: TYPE_NORMAL
- en: The Hardware
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Here’s what you’ll need to create this project:'
  prefs: []
  type: TYPE_NORMAL
- en: Arduino and USB cable
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: One breadboard
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Various connecting wires
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: One Microchip Technology MCP4162 digital rheostat
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: One 560 Ω resistor
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: One LED
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Schematic
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[Figure 19-14](#figure19-14) shows the schematic. The pin numbering on the
    MCP4162 starts at the top left of the package. Pin 1 is indicated by the indented
    dot to the left of the Microchip logo on the IC (see [Figure 19-13](#figure19-13)).'
  prefs: []
  type: TYPE_NORMAL
- en: '![f19014](image_fi/500587c19/f19014.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 19-14: Schematic for Project 56'
  prefs: []
  type: TYPE_NORMAL
- en: The Sketch
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Enter and upload the following sketch:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Let’s walk through the code. First, we set up the SPI bus at 1 and 2. At 3,
    we set the byte direction to suit the MPC4162\. To make setting the resistance
    easier, we use the custom function at 4, which accepts the resistance step (0
    through 255) and passes it to the MCP4162\. Finally, the sketch uses two loops
    to move the rheostat through all the stages, from 0 to the maximum at 5 and then
    back to 0 at 6. This last piece should make the LED increase and decrease in brightness,
    fading up and down for as long as the sketch is running.
  prefs: []
  type: TYPE_NORMAL
- en: Looking Ahead
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this chapter, you learned about and experimented with two important Arduino
    communication methods. Now you’re ready to interface your Arduino with a huge
    variety of sensors, more advanced components, and other items as they become available
    on the market. One of the most popular components today is a real-time clock IC
    that allows your projects to keep and work with time—and that’s the topic of Chapter
    20. So let’s go!
  prefs: []
  type: TYPE_NORMAL
