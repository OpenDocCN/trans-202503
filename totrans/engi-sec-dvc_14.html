<html><head></head><body>
<div id="sbo-rt-content"><h2 class="h2" id="ch11"><span epub:type="pagebreak" id="page_199"/><strong><span class="big">11</span><br/>ACCESS CONTROL AND MANAGEMENT</strong></h2>
<div class="image1"><img alt="Image" height="252" src="../images/common.jpg" width="252"/></div>
<p class="noindent">In IT systems, the management of users and permissions has a long tradition because humans have played a central role from the beginning. By contrast, embedded systems were not meant for interaction in the past and often come with only a few users or even just a single system user.</p>
<p class="indent">Today, with the increasing complexity of IoT business models and application scenarios, many players are involved in the life-cycle processes of IoT devices—from developers to maintenance personnel to third-party service providers to the end users themselves. Devices must be able to <em>handle</em> all these roles and to <em>separate</em> them from one another. Further, internal processes and applications running on your device will also require various permissions to fulfill their purposes. Restricting them according to the principle of least privilege can save your device from severe damage.</p>
<p class="indent">This chapter starts with a look at a variety of situations where access control can make an important contribution to device security. Afterward, I explain common concepts you can use to implement access restrictions on devices running Linux. The case study at the end of the chapter teases the practical possibilities of process restrictions with the AppArmor tool.</p>
<h3 class="h3" id="ch00lev1_89"><span epub:type="pagebreak" id="page_200"/><strong>Everyday Threats</strong></h3>
<p class="noindent">Database leaks and breaches happen nearly every day. Often, the data published or sold by criminals contains long lists of usernames and passwords. Credentials for your IoT devices could be among those secrets, enabling adversaries to log into your products. You might jump to the conclusion that these are your customers’ risks and that you don’t have any responsibility in case of credential theft, but that’s not completely true.</p>
<p class="indent">You have to ask yourself at least two questions: “Did we separate end-user accounts from manufacturer accounts?” and “Did we restrict those end-user accounts as far as possible in order to contain the damage in case of leaked credentials?” If you don’t consider these topics, they might boomerang and negatively affect your product’s reputation, at the very least.</p>
<p class="indent">On a regular basis, penetration testers, security researchers, or even customers identify unknown vulnerabilities in products. And the probability of security issues increases with device and software complexity and the number of services exposed on network interfaces. Even though you might have established a solid vulnerability-management process, as described in <a href="ch01.xhtml#ch01">Chapter 1</a>, and are even prepared to roll out updates securely, as explained in <a href="ch09.xhtml#ch09">Chapter 9</a>, your product could still be vulnerable during a certain time frame. If such a case leads to attacks in the field that significantly affect your devices, the obvious question experts will pose is, “Why was the vulnerable application able to cause impacts on all of the system’s parts when it has a rather constrained purpose?”</p>
<p class="indent">Currently, a common topic among manufacturers in multiple industries is the transformation of their devices into <em>platforms</em> that can install and run apps from a corresponding marketplace that is, in turn, fed by app developers all around the world. Again, it might seem obvious that those developers are in charge of their apps’ security. However, if an actual vulnerability is exploited in an app, it’s the responsibility of the platform’s designers to protect system processes and configurations as well as other apps from the one causing trouble.</p>
<p class="indent">Sometimes access control is considered only on a software or OS level. However, an additional threat has significant relevance for embedded systems: physical access. Attackers as well as penetration testers and researchers can analyze a device physically by interacting with local (debug) interfaces like JTAG, Universal Asynchronous Receiver-Transmitter (UART), or the Inter-Integrated Circuit (I<sup>2</sup>C) bus.</p>
<p class="indent">Mitigating this threat by stating that “no one will open up our device” and, even if so, “the internals are so complex that even our engineers don’t know all the details” is common, but it’s rarely reasonable. Interested attackers will definitely remove the product housing and look for local interfaces, and if they have a certain motivation, they’ll also be willing to spend time on manually reverse engineering the device until they reach their goal.</p>
<h3 class="h3" id="ch00lev1_90"><span epub:type="pagebreak" id="page_201"/><strong>Access Control and Damage Containment</strong></h3>
<p class="noindent">In many cases, solid access-control management can reduce or even prevent an attack’s impact. It’s a perfect example of how engineers and developers can take seriously the principle of defense in depth. If one security layer, like the confidentiality of user credentials, fails or an unknown software vulnerability is discovered, the access-control layer steps in and prevents the worst consequences.</p>
<p class="indent">However, this works only if you have a sound basis for deciding whether access should be granted and, if so, how much access is actually necessary. You should take several properties into account when granting a user access to an object like a file or hardware resource.</p>
<p class="indent">Permissions can be granted and denied on the basis of the user’s identity, sometimes known as <em>identity-based access control (IBAC)</em>. However, managing every single user or human independently might be too complicated. Therefore, <em>role-based access control (RBAC)</em>, which sets permissions according to the user’s role, has gained popularity. This not only eases permission management but also requires you to explicitly assign roles to every user, which increases transparency.</p>
<p class="indent">Yet another access-control approach relies on the attributes of subjects, objects, and maybe even their environments. Known as <em>attribute-based access control (ABAC)</em>, it allows for more dynamic access decisions than IBAC or RBAC.</p>
<p class="indent">A common strategy for optimizing access control in terms of security is to reduce permissions to the minimum required by a given user or application. However, that’s the crux of the matter, because those minimum requirements are often not explicitly known.</p>
<p class="indent">Thus, developers often tend to set permissions generously, leaving space for malicious activities or compromise. Their reasoning is understandable because restricting users and applications too much might render the device inoperable. And, to make the situation worse, the duties of a user and the access privileges of an application might change over time. Therefore, it’s important to consider access-control management early and comprehensively over the whole device life cycle.</p>
<h4 class="h4" id="ch00lev2_134"><strong><em>Design and Development Phase</em></strong></h4>
<p class="noindent">During hardware design, discussions about physical access to IC pins, pads, and traces on a PCB should already be on the agenda. Obfuscation of debug ports or the application of epoxy resin on critical parts might be solutions to think about. The impact of physical access also might be reduced by contact switches or springs that indicate to the main processor that the product casing was opened.</p>
<p class="indent">For higher security, there’s even the possibility of integrating a conducting mesh structure into a plastic case, which continuously runs signals on its lines to detect any tampering with the housing. Such mechanisms are already used in payment terminals.</p>
<p class="indent"><span epub:type="pagebreak" id="page_202"/>An important part of firmware development is the specification of system users, their roles, directories, initial files, and corresponding permissions. Even if this sounds trivial at first, make sure to take the whole range of your device’s intended use cases into account. The results have to be implemented in the build system of your choice (for example, Yocto or Buildroot) and should be monitored for correctness throughout the whole development process.</p>
<p class="indent">Next, you must analyze all the device’s software applications and services. On the one hand, you must specify in which user context each application should be run. This defines the rights a process has at runtime, which becomes especially important when it’s taken over by a malicious actor. Consider carefully whether root is always your best choice.</p>
<p class="indent">On the other hand, applications can also play an active role in access-control management. Let’s take a web server as an example. This common type of application has control over the web pages it serves to connected clients. Some parts of the web interface, like the page for device administration, might be more critical than others. Based on OS users or the web server’s own user management, the server has to be configured appropriately to grant admin access only to legitimate users.</p>
<p class="indent">Of course, the application might have several “admin” users: a <span class="literal">webadmin</span> for administration tasks carried out by the web application, a <span class="literal">sysadmin</span> for Linux system administration, and maybe a <span class="literal">superadmin</span> used for manufacturer access. And all of them have different permissions.</p>
<h4 class="h4" id="ch00lev2_135"><strong><em>Production Considerations</em></strong></h4>
<p class="noindent">Device production is usually not considered an important step in access-control management, but more and more standards—for example, the European ETSI EN 303 645 for consumer electronics—require devices to refrain from implementing global default passwords. Since a device’s firmware is usually a static global artifact, a device-individual password has to be generated and set during production.</p>
<p class="indent">And it’s not only the firmware that has to be individualized. A piece of paper, a sticker, or a part of the product packaging also has to be labeled with the individual password. This process depends heavily on your device’s firmware structure and your production processes.</p>
<p class="indent">An alternative to in-production password generation is to force end users to set a new, custom password at first login. The advantage of this approach is that you can use a single, global firmware image, which is much easier to handle during production. However, your product is also left with a universal default password that can be used at least once during initialization—by users and adversaries.</p>
<h4 class="h4" id="ch00lev2_136"><span epub:type="pagebreak" id="page_203"/><strong><em>Customer Activities and Decommissioning</em></strong></h4>
<p class="noindent">In the field, customers might want to create additional users themselves or change the permission of given accounts. You have to decide whether that should be possible and, if so, within what limits. Allowing a customer to choose freely which permissions to grant could lead to an <em>elevation of privilege</em>, resulting in the end user receiving more rights than implicitly intended.</p>
<p class="indent">Manually changing passwords on hundreds of devices is absolutely tedious and also error-prone. Therefore, modern IoT infrastructures require a central management of assets and configurations—including users, roles, and permissions—in order to stay manageable at all. For device manufacturers, preparing devices to support Lightweight Directory Access Protocol (LDAP) integration or something similar might be reasonable to ease central management. However, make sure to consider the potential threats when you trust a remote server to handle users, credentials, and permissions for your device.</p>
<p class="indent">As mentioned before, applications should be restricted to the minimum permissions necessary to function correctly. However, with every firmware update, the features and behavior of a device’s software components might change. New functionality might require further permissions, and strict security could be a showstopper. Also, security updates might remove software routines that required specific permissions, and those permissions wouldn’t be needed anymore afterward. In general, if you work with tools that restrict software applications and you update that software, you always have to double-check that the related permissions match the new version.</p>
<p class="indent">Last but not least, you have to consider that your device might be resold and used by another customer. That customer should still be able to initialize the device and to reset users and permissions, but shouldn’t have access to data created by the previous owner. The same applies for final decommissioning when curious dumpster divers or scrap dealers might want to get hold of access-restricted data. The original customer should be provided with a “clear all private data” button that actually does what it says, and newly added users shouldn’t be able to access others’ data even if it isn’t cleared.</p>
<h3 class="h3" id="ch00lev1_91"><strong>Discretionary Access Control</strong></h3>
<p class="noindent"><em>Discretionary access control (DAC)</em> is a fundamental approach to managing access rights of subjects and groups to objects within a system. The subjects in our case are users in a Linux OS, while objects might be files, directories, memory locations, interprocess communication, and all sorts of system devices and interfaces. This methodology is <em>discretionary</em> because permissions for a certain object are granted <em>at the discretion</em> of a user owning this specific object; <em>owners</em> can pass on permissions to other users and groups.</p>
<div class="note">
<p class="notet"><span epub:type="pagebreak" id="page_204"/><strong><span class="notes">NOTE</span></strong></p>
<p class="notep"><em>In Linux systems, the root user is omnipotent. It’s able to override permissions set by owners. Therefore, “becoming root” is one of the most attractive goals for attackers. For developers, this means processes that could potentially be compromised, such as all applications listening on network ports, should never run as root!</em></p>
</div>
<h4 class="h4" id="ch00lev2_137"><strong><em>Linux Filesystem Permissions</em></strong></h4>
<p class="noindent">Every single file in a Linux filesystem has a permission string associated with it. As shown in <a href="ch11.xhtml#ch11list01">Listing 11-1</a>, the <span class="literal">ls</span> tool can print the string always at the beginning of each line.</p>
<pre class="pre"># <span class="codestrong1">ls -l</span>&#13;
-rw-r--r-- 1 root root    23 Apr 30 13:13 README&#13;
lrwxrwxrwx 1 root root    17 Apr 30 14:15 current_logfile -&gt; logs/73944561.log&#13;
drwxr-xr-x 2 root root  1024 Apr 30 14:14 logs&#13;
-rw-r--r-- 1 bob  guest   12 Apr 30 17:15 my_notes.md&#13;
# <span class="codestrong1">ls -l logs/73944561.log</span>&#13;
-rw-r--r-- 1 root root     9 Apr 30 12:20 73944561.log</pre>
<p class="list-title" id="ch11list01"><em>Listing 11-1: A file permission listing on Linux</em></p>
<p class="indent">The prominent strings <span class="literal">root root</span> show that all files are owned by the root user from the root group, except for the <em>my_notes.md</em> file, which is owned by <em>bob</em> of the <em>guest</em> group. Further, the very first character of each line specifies whether it’s a regular file (<span class="literal">-</span>), a directory (<span class="literal">d</span>), or a symbolic link (<span class="literal">l</span>). Block devices (<span class="literal">b</span>) and character devices (<span class="literal">c</span>) would also be indicated there. The following nine characters represent the permissions granted for each file. They’re separated in three groups of three characters each, concerning read (<span class="literal">r</span>), write (<span class="literal">w</span>), and execute (<span class="literal">x</span>) permissions of the owner, a corresponding group, and anybody else, respectively.</p>
<p class="indent">For example, the <em>README</em> file in <a href="ch11.xhtml#ch11list01">Listing 11-1</a> can be read and written by the root user, but other users in the root group may only read. Read permission is also granted to any other user, no matter in which group, as indicated by the trailing <span class="literal">r--</span>.</p>
<p class="indent">Whenever you read tutorials or third-party source code for Linux access-control management, you’ll likely stumble over an efficient, three-digit notation of access permissions. The 9-bit permission strings can be written efficiently as three octal numbers: one for owner permissions, one for group member permissions, and the last one stands for all others.</p>
<p class="indent">For example, <span class="literal">777</span> means that everybody may read, write, and execute a given object. In contrast, <span class="literal">740</span> says that the owner may read, write, and execute; group members are allowed only to read; and anybody else has no access rights at all. <a href="ch11.xhtml#ch11tab01">Table 11-1</a> details the conversion of permissions to octal numbers, and vice versa.</p>
<p class="tabcap" id="ch11tab01"><span epub:type="pagebreak" id="page_205"/><strong>Table 11-1:</strong> Octal Representation of Linux File Permissions</p>
<table class="table-h">
<colgroup>
<col style="width:33%"/>
<col style="width:34%"/>
<col style="width:33%"/>
</colgroup>
<thead>
<tr>
<th class="tab_th"><strong>Octal</strong></th>
<th class="tab_th"><strong>Binary</strong></th>
<th class="tab_th"><strong>Permissions</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td class="bg1">0</td>
<td class="bg1">000</td>
<td class="bg1"><span class="literal">---</span></td>
</tr>
<tr>
<td class="bg">1</td>
<td class="bg">001</td>
<td class="bg"><span class="literal">--x</span></td>
</tr>
<tr>
<td class="bg1">2</td>
<td class="bg1">010</td>
<td class="bg1"><span class="literal">-w-</span></td>
</tr>
<tr>
<td class="bg">3</td>
<td class="bg">011</td>
<td class="bg"><span class="literal">-wx</span></td>
</tr>
<tr>
<td class="bg1">4</td>
<td class="bg1">100</td>
<td class="bg1"><span class="literal">r--</span></td>
</tr>
<tr>
<td class="bg">5</td>
<td class="bg">101</td>
<td class="bg"><span class="literal">r-x</span></td>
</tr>
<tr>
<td class="bg1">6</td>
<td class="bg1">110</td>
<td class="bg1"><span class="literal">rw-</span></td>
</tr>
<tr>
<td class="bg">7</td>
<td class="bg">111</td>
<td class="bg"><span class="literal">rwx</span></td>
</tr>
</tbody>
</table>
<p class="indent">Understanding file permissions is straightforward, but directories behave a little bit differently. There, read permission enables the enumeration of items within a directory. Write permission grants the right to add, delete, or rename directory items. Execute permission allows users to navigate to the directory, such as with the <span class="literal">cd</span> command, and access files or subdirectories.</p>
<h4 class="h4" id="ch00lev2_138"><strong><em>Linux User and Group Management</em></strong></h4>
<p class="noindent">In Linux, several tools exist for managing users and groups. The most basic commands, available in all distributions, even on embedded systems, are the following:</p>
<table class="table-h1">
<colgroup>
<col style="width:20%"/>
<col style="width:80%"/>
</colgroup>
<tbody>
<tr>
<td><span class="codestrong">useradd</span></td>
<td>Create a new user</td>
</tr>
<tr>
<td><span class="codestrong">usermod</span></td>
<td>Modify properties of an existing user</td>
</tr>
<tr>
<td><span class="codestrong">userdel</span></td>
<td>Delete a user</td>
</tr>
<tr>
<td><span class="codestrong">groupadd</span></td>
<td>Create a new group</td>
</tr>
<tr>
<td><span class="codestrong">groupmod</span></td>
<td>Modify properties of an existing group</td>
</tr>
<tr>
<td><span class="codestrong">groupdel</span></td>
<td>Delete a group</td>
</tr>
</tbody>
</table>
<p class="indent">When engineering secure devices, the most important commands are <span class="literal">useradd</span> and <span class="literal">groupadd</span>, because they can be used at image-creation time to implement users and roles defined in an associated access-control concept.</p>
<p class="indent">For user creation, of course, the new user’s name has to be provided. Further options you might want to specify are its <em>user identifier</em>—or <em>UID</em> (<span class="literal">--uid</span>)—its home directory (<span class="literal">--home</span>), and whether this directory should be created automatically (<span class="literal">--create-home</span>). In addition, you can define whether a user group with the same name should be created (<span class="literal">--user-group</span>) and which groups the user should belong to (<span class="literal">--groups</span>). The <span class="literal">--shell</span> option allows for specifying the shell used after login, but it can also be used with <span class="literal">false</span> and <span class="literal">nologin</span> to disable user login. Finally, you can set the user’s password (in hashed form) with the <span class="literal">--password</span> option.</p>
<p class="indent"><span epub:type="pagebreak" id="page_206"/>The main parameters to specify for creating a group with <span class="literal">groupadd</span> are the group’s name and, if desired, a corresponding <em>group identifier (GID)</em> (<span class="literal">--gid</span>) that you can use to refer to the specific group at a later time.</p>
<p class="indent">Users as well as groups might be flagged as belonging to the system (<span class="literal">--system</span>), in contrast to being external, probably human users. Such system accounts receive a UID/GID from a reserved system range. In addition, system users don’t expire and don’t get a home directory created.</p>
<div class="note">
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>
<p class="notep"><em>The tools</em> <span class="codeitalic">useradd</span> <em>and</em> <span class="codeitalic">adduser</span> <em>as well as</em> <span class="codeitalic">groupadd</span> <em>and</em> <span class="codeitalic">addgroup</span> <em>get mixed up easily. The ones presented in this section are the basic, portable versions, while the others might be more user-friendly in an interactive session.</em></p>
</div>
<h4 class="h4" id="ch00lev2_139"><strong><em>Linux Permission Management</em></strong></h4>
<p class="noindentb">To configure owners, groups, and permissions of files and directories, we need three common tools on Linux systems:</p>
<p class="hanga"><span class="codestrong">chown</span>    Allows you to change the owner of a file or directory to another owner. For example, the owner of the <em>web.conf</em> file can be set to <em>bob</em> with <span class="literal">chown bob web.conf</span>.</p>
<p class="hanga"><span class="codestrong">chgrp</span>    Specifies a new group for a given file or directory. The group of the <em>manuals</em> directory might be changed to <em>guest</em> with <span class="literal">chgrp guest manuals</span>, for example.</p>
<p class="hanga"><span class="codestrong">chmod</span>    Manipulates permissions for files and directories. The call <span class="literal">chmod +x script.sh</span> adds execution permission to the <em>script.sh</em> file, while <span class="literal">chmod -wx script.sh</span> removes permissions for writing and execution. Both affect only the owner’s permissions. By prepending <span class="literal">g</span> for group, <span class="literal">o</span> for others, <span class="literal">u</span> for users/owners, and <span class="literal">a</span> for all, you can also specify which part of the permission string should be affected. For example, <span class="literal">chmod go-rwx private.key</span> removes all access rights of the <em>private.key</em> file for all group members and anybody else except the owner.</p>
<h4 class="h4" id="ch00lev2_140"><strong><em>Access-Control Lists</em></strong></h4>
<p class="noindent">In principle, users and groups enable us to represent any desired access-control settings. However, in some cases, the limitation that a file or directory can have only a single owner and a single associated group makes efficient access-control management difficult.</p>
<p class="indent">Let me provide an example because the usefulness might not be obvious. Imagine you have a directory called <em>internal_logs</em> for storing logs and runtime data. Files in this directory are created by five users, all belonging to the <em>service</em> group. Two years after market release, you introduce a new predictive maintenance feature and an associated <span class="literal">predmain</span> user who needs read access only to the <em>internal_logs/freqtrack.dat</em> file, and the user shouldn’t be able to write anything—to contain damage in case of compromise. You can’t add <em>predmain</em> to the <em>service</em> group because then it would have too many permissions, and you can’t make <em>predmain</em> the owner of <em>freqtrack.dat</em> because, again, compromise would leave an attacker with too much control.</p>
<p class="indent"><span epub:type="pagebreak" id="page_207"/>One solution is to use access-control lists (ACLs) that are implemented based on the extended file attributes (xattr) of a Linux filesystem. Depending on your system, ACL support has to be installed, and the filesystem has to be mounted with the <span class="literal">acl</span> option before you can use the <span class="literal">getfacl</span> and <span class="literal">setfacl</span> command line tools to view and change permissions on a fine-grained level, respectively.</p>
<h3 class="h3" id="ch00lev1_92"><strong>Case Study: Access Control for STM32MP157F-DK2 Firmware</strong></h3>
<p class="noindent">In this case study, I first demonstrate a user- and file-initialization process with Yocto. Next, I explore the default permissions set by Linux for certain system files and the reasoning behind them. Finally, as an example of application-level access control, I take a look at the configuration of the SSH daemon Dropbear.</p>
<h4 class="h4" id="ch00lev2_141"><strong><em>User Creation and File Provisioning in Yocto</em></strong></h4>
<p class="noindent">The first question regarding access control you have to clarify on any Linux platform is the way you want to handle the root user. Especially during development, the root user might be used regularly and often, even without a password. Make sure to remove debug settings for production images. In my case, I removed the <span class="literal">debug-tweaks</span> feature from ST’s <span class="literal">st-image-core</span> image, as shown in <a href="ch11.xhtml#ch11list02">Listing 11-2</a>.</p>
<pre class="pre">EXTRA_IMAGE_FEATURES:remove = "debug-tweaks"&#13;
inherit extrausers&#13;
ROOT_PASSWORD_HASH = "\$6\$ZsFPzdUpnha4s1lG\$8Zxzo4UhZBomryn/SJSlVq97TLy..."&#13;
EXTRA_USERS_PARAMS:append = "usermod --password '${ROOT_PASSWORD_HASH}' root;"</pre>
<p class="list-title" id="ch11list02"><em>Listing 11-2: Preparing the root user for production</em></p>
<p class="indent">I inherited the <span class="literal">extrausers</span> class, which allows the modification of the existing root user (for example, to protect it with a strong password). The cryptic-looking string behind <span class="literal">ROOT_PASSWORD_HASH</span> is the user password hash format expected by Linux. It was obtained by calling <span class="literal">openssl passwd -6</span> <span class="codeitalic">password</span>, where the <span class="literal">-6</span> parameter indicates that a salted hash based on SHA-512 is used. Also note that the <span class="literal">$</span> symbols act as separators in this format and that they need to be escaped within Yocto recipes.</p>
<div class="note">
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>
<p class="notep"><em>In many cases, completely disabling root login makes sense, unless you have convincing reasons not to, in order to rule out misuse of this powerful user.</em></p>
</div>
<p class="indent">Yocto additionally provides the <span class="literal">useradd</span> class to further provision users and groups from within a custom recipe. <a href="ch11.xhtml#ch11list03">Listing 11-3</a> shows the creation of two system users, <em>rservice</em> and <em>lservice</em>, as well as the end users <em>admin</em> and <em>guest</em>. Also, two corresponding groups are created, and the users are added to these groups.</p>
<pre class="pre"><span epub:type="pagebreak" id="page_208"/>inherit useradd&#13;
USERADD_PACKAGES = "${PN}"&#13;
&#13;
USERADD_PARAM:${PN} = "--password '\$6\$fu47IexZgSH/T6d0\$9a.LjAl0sL0K...' \&#13;
                       --home /home/rservice --system rservice; \&#13;
                       --password '\$6\$tSsINjOvlFOaVrky\$9VIgdb7.LIVG...' \&#13;
                       --home /home/lservice --system lservice; \&#13;
                       --password '\$6\$VOPFagOJM.H.ZWIh\$8lELUZpkIogC...' \&#13;
                       --uid 1300 --home /home/admin admin; \&#13;
                       --password '\$6\$CPaAzKAYqkSKW42x\$KgivNUKDqsJT...' \&#13;
                       --uid 1301 --home /home/guest guest"&#13;
&#13;
GROUPADD_PARAM:${PN} = "--system service; \&#13;
                        --gid 890 endusers"&#13;
&#13;
GROUPMEMS_PARAM:${PN} = "--add rservice --group service; \&#13;
                         --add lservice --group service; \&#13;
                         --add admin --group endusers; \&#13;
                         --add guest --group endusers"</pre>
<p class="list-title" id="ch11list03"><em>Listing 11-3: Creating users and groups for the image</em></p>
<p class="indent">All users are initialized with a password in the <span class="literal">USERADD_PARAM</span> variable. Specific UIDs are used only for end-user accounts. The <span class="literal">GROUPADD_PARAM</span> variable allows you to create new groups, while <span class="literal">GROUPMEMS_PARAM</span> enrolls the created users in those groups.</p>
<p class="indent">In some cases, you also might want to create directories for users and place initial files in them. In <a href="ch11.xhtml#ch11list04">Listing 11-4</a>, a snippet from a custom recipe is shown that may serve as a simple example of file provisioning for created users, including necessary commands to set owners and groups accordingly.</p>
<pre class="pre">do_install () {&#13;
        install -d -m 770 ${D}/home/rservice&#13;
        install -d -m 740 ${D}/home/lservice&#13;
        install -d -m 500 ${D}/home/admin&#13;
        install -d -m 550 ${D}/home/guest&#13;
&#13;
        install -p -m 400 administration.md ${D}/home/admin/&#13;
        install -p -m 440 README ${D}/home/guest/&#13;
&#13;
        chown -R rservice ${D}/home/rservice&#13;
        chown -R lservice ${D}/home/lservice&#13;
        chown -R admin ${D}/home/admin&#13;
        chown -R guest ${D}/home/guest&#13;
&#13;
        chgrp -R service ${D}/home/rservice&#13;
        chgrp -R service ${D}/home/lservice&#13;
<span epub:type="pagebreak" id="page_209"/>        chgrp -R endusers ${D}/home/admin&#13;
        chgrp -R endusers ${D}/home/guest&#13;
}</pre>
<p class="list-title" id="ch11list04"><em>Listing 11-4: The basic file provisioning for created users</em></p>
<p class="indent">First, home directories for all users are created with corresponding permissions. For example, end users should be able to read only provided data, but not to store their own code to the device or even execute it. Further, administration information should not be accessible for the <span class="literal">guest</span> user.</p>
<p class="indent">Service users, on the other hand, have higher permissions. They may load custom data to their directories, while the <span class="literal">lservice</span> local service user has the highest rights because it might even read and write to the remote service user’s directory.</p>
<p class="indent">With these basic steps, you can lay the foundation for your device’s access-control management.</p>
<h4 class="h4" id="ch00lev2_142"><strong><em>Exploration of System Files and Predefined Users</em></strong></h4>
<p class="noindent">Luckily, Linux and its distributions already take care of permission settings for a variety of system files. Let’s look at some specific examples within the firmware of my STM32MP157F device.</p>
<p class="indent">The user and password management on Linux is implemented by the <em>/etc/passwd</em> and <em>/etc/shadow</em> files. As shown in <a href="ch11.xhtml#ch11list05">Listing 11-5</a>, the first file is marked readable for everybody because there might be various good reasons to read the list of users on a system. However, the actual password hash of each user is not included in the <em>passwd</em> file. It resides in the <em>shadow</em> file, which is readable only by root for login verification purposes.</p>
<pre class="pre"># <span class="codestrong1">ls -l /etc/passwd /etc/shadow</span>&#13;
-rw-r--r-- 1 root root 1404 ... /etc/passwd&#13;
-r-------- 1 root root  884 ... /etc/shadow</pre>
<p class="list-title" id="ch11list05"><em>Listing 11-5: The access rights to password files on Linux</em></p>
<p class="indent"><em>Shadowing</em> password storage has been done for decades. The main idea is to restrict the access of unprivileged users to password hashes, because if a user uses a weak password, an adversary with access to the corresponding password hash would be able to launch a brute-force attack against it.</p>
<div class="note">
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>
<p class="notep"><em>If you wonder how passwords could be changed if</em> /etc/shadow <em>is only readable, even for root: the superuser root has similar powers to Chuck Norris; it can even write to read-only files.</em></p>
</div>
<p class="indent"><a href="ch11.xhtml#ch11list06">Listing 11-6</a> shows the permission strings for my device’s microSD card (<em>/dev/mmcblk0</em>), the Linux RNG device (<em>/dev/urandom</em>), and the hardware RNG device of the STM32MP157F (<em>/dev/hwrng</em>).</p>
<pre class="pre"># <span class="codestrong1">ls -l /dev/mmcblk0</span>&#13;
brw-rw---- 1 root disk 179, 0 Apr 28 17:42 /dev/mmcblk0<span epub:type="pagebreak" id="page_210"/>&#13;
# <span class="codestrong1">ls -l /dev/urandom /dev/hwrng</span>&#13;
crw------- 1 root root 10, 183 Apr 28 17:42 /dev/hwrng&#13;
crw-rw-rw- 1 root root  1,   9 Apr 28 17:42 /dev/urandom</pre>
<p class="list-title" id="ch11list06"><em>Listing 11-6: The permissions for a microSD card and RNG devices</em></p>
<p class="indent">You can see that, for device files, the permission string indicates whether it’s a block device (<span class="literal">b</span>) or a character device (<span class="literal">c</span>). The results also show that the microSD card can be read only by root or members of the <em>disk</em> group. For RNGs, the system differentiates between the OS-provided RNG <span class="literal">urandom</span>, which can be read and written be everyone, and the hardware RNG device <span class="literal">hwrng</span>, which only root may access.</p>
<p class="indent">Let’s shift the focus from files to processes. <a href="ch11.xhtml#ch11list07">Listing 11-7</a> shows typical applications like the web server <span class="literal">httpd</span> or the MQTT broker <span class="literal">mosquitto</span> and the corresponding users executing these processes.</p>
<pre class="pre"># <span class="codestrong1">ps | grep -E 'PID|httpd|mosquitto'</span>&#13;
  PID USER       VSZ STAT COMMAND&#13;
 1138 root      5680 S    /usr/sbin/httpd -DFOREGROUND -D SSL -D PHP5 -k start&#13;
 1148 daemon    224m S    /usr/sbin/httpd -DFOREGROUND -D SSL -D PHP5 -k start&#13;
 1149 daemon    224m S    /usr/sbin/httpd -DFOREGROUND -D SSL -D PHP5 -k start&#13;
 1150 daemon    224m S    /usr/sbin/httpd -DFOREGROUND -D SSL -D PHP5 -k start&#13;
 1235 mosquitt  6792 S    /usr/sbin/mosquitto -c /etc/mosquitto/mosquitto.conf&#13;
 2507 daemon    224m S    /usr/sbin/httpd -DFOREGROUND -D SSL -D PHP5 -k start&#13;
 2610 root      2320 S    grep -E PID|httpd|mosquitto</pre>
<p class="list-title" id="ch11list07"><em>Listing 11-7: The user context of typical network daemons</em></p>
<p class="indent">The web server <span class="literal">httpd</span> exhibits a common strategy to limit the attack surface in case a vulnerability could be exploited remotely. It starts under the root user, binds to its designated port (for example, 80), and then deliberately drops its high privileges by altering its GID and UID by calls to <span class="literal">setgid()</span> and <span class="literal">setuid()</span>, respectively. Therefore, in my case, the four “worker threads” of <span class="literal">httpd</span> run under the low-privilege user <em>daemon</em>.</p>
<p class="indent">The same is true for the Mosquitto broker. You can infer from its documentation that, even if started as the root user, Mosquitto immediately drops privileges after reading its configuration file and continues running in the context of a more limited user, called <span class="literal">mosquitto</span> in my case.</p>
<p class="indent">The output of usernames by <span class="literal">ps</span> is limited to eight characters. Therefore, <span class="literal">mosquitto</span> becomes <span class="literal">mosquitt</span>.</p>
<h4 class="h4" id="ch00lev2_143"><strong><em>SSH Daemon Access-Control Configuration</em></strong></h4>
<p class="noindent"><em>Dropbear</em> is a lightweight SSH daemon that’s especially popular on embedded systems. It enables secure remote access to a device, which makes it perfectly useful but also absolutely critical. Applications like that deserve dedicated consideration regarding access-control settings, because if they implement an “open door policy,” it’s literally an invitation for attackers.</p>
<p class="indent"><a href="ch11.xhtml#ch11list08">Listing 11-8</a> shows a part of the command line arguments for the <span class="literal">dropbear</span> daemon that are interesting from an access-control point of view.</p>
<pre class="pre"><span epub:type="pagebreak" id="page_211"/># <span class="codestrong1">dropbear --help</span>&#13;
...&#13;
-w  Disallow root logins&#13;
-G  Restrict logins to members of specified group&#13;
-s  Disable password logins&#13;
-g  Disable password logins for root&#13;
-B  Allow blank password logins&#13;
-T  Maximum authentication tries (default 10)&#13;
...</pre>
<p class="list-title" id="ch11list08"><em>Listing 11-8: Some access-control options for</em> <span class="codeitalic1">dropbear</span></p>
<p class="indent">Disabling root access over SSH (<span class="literal">-w</span>) is a good idea in most instances. For this case study, it might also be reasonable to restrict SSH access to users from the <em>service</em> group (<span class="literal">-G</span>), because it shouldn’t be a feature for end users. Disabling password logins completely and allowing only public-key authentication would be perfect, but if your PKI is not yet prepared for this step, the <span class="literal">-s</span> option isn’t possible. Since we completely disabled root access, using <span class="literal">-g</span> would be redundant. The <span class="literal">-B</span> argument should be used only during development; you probably don’t want to find this in a production firmware image. Lastly, you can restrict the maximum number of login tries—for example, to three (<span class="literal">-T 3</span>).</p>
<div class="note">
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>
<p class="notep"><em>You can also change the port of the</em> <span class="codeitalic">dropbear</span> <em>SSH daemon from 22 to a custom one with the</em> <span class="codeitalic">-p</span> <em>option. That’s just obscurity, but it might save your internet-connected device from being discovered by automated SSH scans.</em></p>
</div>
<p class="indent">To store your <span class="literal">dropbear</span> settings persistently, you have to change the <em>/etc/dropbear/default</em> file in your firmware image. The important line that it should contain to implement the discussed access-control restrictions is <span class="literal">DROPBEAR_EXTRA_ARGS="-w -T 3 -G service"</span>.</p>
<h3 class="h3" id="ch00lev1_93"><strong>Mandatory Access Control</strong></h3>
<p class="noindent">While DAC concepts are usually known among embedded system developers, <em>mandatory access control (MAC)</em> is often uncharted territory. However, MAC implementations can contribute significantly to a device’s security and to the containment of damage in case of compromise.</p>
<p class="indent">The basic idea of MAC systems for embedded devices is that permissions and policies regarding the way users and processes may interact with files and other resources are managed by the manufacturer and enforced by the OS. In contrast to the user-centric approach of DAC, users can’t override the rules defined by MAC.</p>
<p class="indent">MAC implementations are powerful tools, but with power comes responsibility. <em>Whitelisting</em> is a popular access-control strategy in which access is denied by default and granted only if explicitly allowed. This approach can also be used for MAC systems to permit only defined access of subjects to objects. However, if you omit specifying a legitimate access as “allowed,” <span epub:type="pagebreak" id="page_212"/>maybe because it’s used infrequently, an application that requires it might crash during runtime whenever the access occurs.</p>
<p class="indent">If you choose a <em>blacklisting</em> approach—defining only dangerous cases for which access should be denied, like malware detected by virus scanners—the probability of breaking functionality is reduced. However, you have to ensure that corresponding rules for newly discovered malicious behavior find their way into your devices in a timely manner.</p>
<h4 class="h4" id="ch00lev2_144"><strong><em>Linux Security Modules</em></strong></h4>
<p class="noindent">Since the Linux community was not able to agree on one specific security module, Linux introduced the <em>Linux Security Module (LSM)</em> framework. It enables the implementation of various MAC systems for Linux.</p>
<p class="indent">These LSMs are compiled into the Linux kernel and take action if specific hook functions are called within the kernel code. These hooks are integrated in all procedures relevant for access control within the OS, from file access to task spawning to interprocess communication. If reached, the kernel hands over control to the LSM, which is able to at least log the performed action or directly decide whether access should be granted or denied based on its specific rule set.</p>
<p class="indent">LSM implementations differ significantly in terms of their concepts, their way of configuring rule sets, and their supporting community. However, they also share a common property: all have a negative impact on system performance. The following sections introduce popular LSM implementations.</p>
<h4 class="h4" id="ch00lev2_145"><strong><em>SELinux</em></strong></h4>
<p class="noindent">In 2000, the NSA published its idea of a MAC system for Linux to the open source community: <em>Security-Enhanced Linux (SELinux)</em>. Supported by other stakeholders in this field, the project flourished and was finally integrated into version 2.6 of the mainline Linux kernel in 2003. Since version 4.3, it’s the default LSM in Android, and many Linux distributions for desktop and server applications support it.</p>
<p class="indent">SELinux relies on security policies that define which objects might be accessed by which subjects. For this purpose, objects and subjects must be registered in SELinux with corresponding <em>labels</em> containing a user, a role, and an associated type. These labels define a kind of context or domain for subjects and objects. The actual access control is implemented by <em>type enforcement</em>, which defines whether a subject with a specific type can access an object with a specific type.</p>
<p class="indent">Many Linux distributions provide their own set of predefined SELinux policies to restrict a variety of common applications and services. Further, there is a database of reference policies that you can use for your purposes. However, creating custom policies for your applications requires deep know-how about their functionalities and a detailed understanding of the SELinux concepts and structures. You should not underestimate the necessary characterization efforts, even if tools are available to support you.</p>
<p class="indent"><span epub:type="pagebreak" id="page_213"/>At runtime, SELinux can be operated in three ways. The <em>enforcing</em> mode is meant for productive use, because it strictly applies all given policies and logs corresponding activities. However, during development or in a test phase, the <em>permissive</em> mode is more suitable. It processes all policies, but only generates warnings and log data without enforcing the defined rules. This can be enormously helpful for fine-tuning custom policies and troubleshooting. If <em>disabled</em>, SELinux is turned off completely and doesn’t protect or restrict anything.</p>
<p class="indent">Although (or perhaps precisely because) SELinux provides a vast number of capabilities, it’s a pretty complex tool that many embedded system engineers refrain from using. This is probably the main reason other LSM implementations emerged and became popular alternatives, as described in the following sections.</p>
<h4 class="h4" id="ch00lev2_146"><strong><em>AppArmor</em></strong></h4>
<p class="noindent"><em>AppArmor</em> is the second LSM implementation to gain significant popularity among Linux distributions. It became part of the Linux kernel 2.6.36 in 2010 and is currently the default MAC system for Ubuntu and SUSE Linux. Its development has been funded by Canonical since 2009.</p>
<p class="indent">Access control is managed on the basis of individual profiles per application. In contrast to SELinux, AppArmor uses filesystem paths to identify subjects and file objects, so the syntax offers better readability. Further, it allows a hybrid approach of whitelisting and blacklisting rules that control the resource access of a process. The created profiles can restrict network access and various sorts of Linux capabilities, but also permissions to read, write, and execute files.</p>
<p class="indent">AppArmor comes with a list of predefined profiles, and additional profiles for common applications are maintained by the Ubuntu community. Additionally, AppArmor provides several tools that support developers in profiling custom applications and generating corresponding profiles.</p>
<p class="indent">Generally speaking, there are two ways of characterizing access requirements. First, targeted profiling allows you to capture access events of a single application and to automatically generate a profile from it. Second, AppArmor can apply a systemic monitoring approach that logs access operations of a defined set of applications for days or even weeks and spanning multiple reboots. The collected log information can then be turned into a series of profiles restricting the analyzed applications in a preferably optimal way.</p>
<p class="indent">Each AppArmor profile available on a device can be put into one of three modes at runtime: enforce, complain, or audit. In <em>enforcement mode</em>, the rules set by the profile are enforced, and violation attempts are logged. The <em>complain mode</em> allows for monitoring an application’s behavior under a defined profile, and operations that violate the policy are logged. This mode is also used in the automated profile creation mentioned previously and is therefore sometimes called AppArmor’s <em>learning mode</em>. To log all access, whether successful or not, while enforcing a given policy, the <em>audit mode</em> has to be selected.</p>
<p class="indent"><span epub:type="pagebreak" id="page_214"/>AppArmor is a worthy alternative to SELinux that succeeds in reducing configuration and profiling complexity. From a security point of view, it’s sometimes more lax than its competitor and leaves space to circumvent access control in specific cases. For embedded systems, however, it might be a perfect compromise to introduce MAC mechanisms.</p>
<h4 class="h4" id="ch00lev2_147"><strong><em>Other LSMs and Non-LSM MACs</em></strong></h4>
<p class="noindent">Besides the two popular LSM implementations, SELinux and AppArmor, you might want to consider further options.</p>
<p class="indent">As the name suggests, the <em>Simplified Mandatory Access Control Kernel (SMACK)</em> system was developed with a focus on simplicity, in contrast to the complexity of SELinux. It has been part of the Linux mainline kernel since 2008 and was always meant for use in embedded systems. Two larger OS projects rely on its protection mechanisms: the mobile OS Tizen used in Samsung’s smart TVs, and the automotive-grade Linux distribution meant as an open source platform for connected cars. However, looking at SMACK’s website and its Git repositories, it seems that it’s no longer actively maintained.</p>
<p class="indent">A further MAC system based on the LSM framework is called <em>TOMOYO</em>. The project was started in 2003 and merged into the Linux kernel 2.6.30 in 2009. Again, the motivation was simpler usage and higher usability—for example, as implemented by an automatic policy generation, which is also necessary because this MAC system doesn’t come with a comprehensive set of rules for common services. In addition, TOMOYO not only serves as a MAC implementation but also facilitates system behavior analysis. It comes in three versions: 1.<em>x</em>, 2.<em>x</em>, and AKARI. The first one requires specific kernel patching and is, therefore, usually not your first choice. AKARI and TOMOYO 2.<em>x</em> use the LSM framework. At the time of writing, AKARI provides a few more features, but TOMOYO 2.<em>x</em> is catching up.</p>
<p class="indent">Although the LSM framework provides a multitude of possibilities for integrating custom security modules, not everybody in the community is satisfied with its implementation, especially considering the performance overhead it generates. Therefore, non-LSM MAC systems also exist that aim for higher performance or enhanced security module features. However, since those implementations are not part of the mainline kernel and have to be integrated by applying a custom set of patches, they might be an option only if you really can’t reach your requirements with the popular LSM implementations.</p>
<h3 class="h3" id="ch00lev1_94"><strong>Case Study: Application Confinement with AppArmor</strong></h3>
<p class="noindent">In this case study, I shed light on the installation of AppArmor with the Yocto toolchain of my STM32MP157F-DK2 device and walk through its basic usage to restrict an application.</p>
<h4 class="h4" id="ch00lev2_148"><span epub:type="pagebreak" id="page_215"/><strong><em>Installation</em></strong></h4>
<p class="noindent">AppArmor is not included in the default installation of ST’s OpenSTLinux distribution. Luckily, the Yocto <span class="literal">meta-security</span> layer maintained by Armin Kuster provides an AppArmor recipe under <em>meta-security/recipes-mac/AppArmor</em>.</p>
<p class="indent">After cloning the corresponding Git repository, the Linux kernel can be configured for AppArmor usage with the settings shown in <a href="ch11.xhtml#ch11list09">Listing 11-9</a>.</p>
<pre class="pre">CONFIG_SECURITY=y&#13;
CONFIG_SECURITY_APPARMOR=y&#13;
CONFIG_DEFAULT_SECURITY="apparmor"&#13;
CONFIG_SECURITY_APPARMOR_BOOTPARAM_VALUE=1</pre>
<p class="list-title" id="ch11list09"><em>Listing 11-9: The Linux kernel configuration to enable AppArmor</em></p>
<p class="indent">The first two lines enable AppArmor, and the last two lines set it as the default LSM to be used. However, I also had to add <span class="literal">security=apparmor</span> to the kernel’s boot arguments in U-Boot’s <em>extlinux.conf</em> files to select AppArmor at boot time.</p>
<p class="indent">To compile and install the AppArmor user-space tools, add the line <span class="literal">IMAGE_INSTALL += "apparmor"</span> to the image’s recipe. I also had to add several distro features to the provided OpenSTLinux, as shown in <a href="ch11.xhtml#ch11list010">Listing 11-10</a>, in order to make Yocto successfully complete the building process.</p>
<pre class="pre">DISTRO_FEATURES += "security"&#13;
DISTRO_FEATURES += "apparmor"&#13;
DISTRO_FEATURES += "tpm"</pre>
<p class="list-title" id="ch11list010"><em>Listing 11-10: The distro features for AppArmor from</em> <span class="codeitalic1">meta-security</span></p>
<p class="indent">After booting the device, you can check whether AppArmor is actually enabled with the command shown in <a href="ch11.xhtml#ch11list011">Listing 11-11</a>. If it returns a <span class="literal">Y</span>, it was activated properly.</p>
<pre class="pre"># <span class="codestrong1">cat /sys/module/apparmor/parameters/enabled</span>&#13;
Y</pre>
<p class="list-title" id="ch11list011"><em>Listing 11-11: Checking whether AppArmor was enabled correctly</em></p>
<p class="indent">AppArmor comes with the <span class="literal">aa-status</span> tool, which lists a variety of details regarding AppArmor’s current status, as shown in <a href="ch11.xhtml#ch11list012">Listing 11-12</a>.</p>
<pre class="pre"># <span class="codestrong1">aa-status</span>&#13;
apparmor module is loaded.&#13;
50 profiles are loaded.&#13;
50 profiles are in enforce mode.&#13;
   ...&#13;
   apache2&#13;
   ...&#13;
   avahi-daemon&#13;
   ...&#13;
<span epub:type="pagebreak" id="page_216"/>   ping&#13;
   ...&#13;
   syslogd&#13;
   traceroute&#13;
   ...&#13;
0 profiles are in complain mode.&#13;
...&#13;
2 processes are in enforce mode.&#13;
   /usr/sbin/avahi-daemon (665) avahi-daemon&#13;
   /usr/sbin/avahi-daemon (667) avahi-daemon&#13;
0 processes are in complain mode.&#13;
...</pre>
<p class="list-title" id="ch11list012"><em>Listing 11-12: The initial output of</em> <span class="codeitalic1">aa-status</span></p>
<p class="indent">You can see that the AppArmor recipe from the <span class="literal">meta-security</span> layer also installs a set of 50 standard profiles that are loaded in enforce mode on my device. However, the first thing I noticed is that although there are profiles loaded for <span class="literal">apache2</span> and <span class="literal">syslogd</span>, the corresponding, currently running processes are not confined. Only the <span class="literal">avahi-daemon</span> processes are restricted according to their profile.</p>
<p class="indent">To investigate this issue, we have to take a look at the default AppArmor profiles stored in <em>/etc/apparmor.d/</em>. For <span class="literal">apache2</span>, the file containing the provided profile is called <em>usr.sbin.apache2</em>. The filename is already a hint for the path of the executable it confines: <em>/usr/sbin/apache2</em>, in this case. Looking at the content of the file, you can see a line stating <span class="literal">profile apache2 /usr/\{bin, sbin\}/apache2</span>, which means that the profile at hand is named <span class="literal">apache2</span> and targets the executable <em>apache2</em> located at <em>/usr/bin/</em> or <em>/usr/sbin/</em>.</p>
<p class="indent">Unfortunately, this file doesn’t exist in my installation. Instead, it’s called <em>httpd</em>. Therefore, I created a copy of the initial file named <em>usr.sbin.httpd</em>. I also changed the profile name to <span class="literal">httpd</span> and the path for the executable to <span class="literal">/usr/\{bin,sbin\}/httpd</span>. Afterward, I loaded the profile in enforce mode as shown in <a href="ch11.xhtml#ch11list013">Listing 11-13</a> and restarted the web server.</p>
<pre class="pre"># <span class="codestrong1">aa-enforce /etc/apparmor.d/usr.sbin.httpd</span>&#13;
Setting /etc/apparmor.d/usr.sbin.httpd to enforce mode.&#13;
# <span class="codestrong1">systemctl restart apache2</span>&#13;
# <span class="codestrong1">aa-disable /etc/apparmor.d/usr.sbin.apache2</span>&#13;
Disabling /etc/apparmor.d/usr.sbin.apache2.</pre>
<p class="list-title" id="ch11list013"><em>Listing 11-13: Loading and disabling profiles</em></p>
<p class="indent">I also disabled the original profile with the help of <span class="literal">aa-disable</span> in order to clean up.</p>
<p class="indent"><a href="ch11.xhtml#ch11list014">Listing 11-14</a> presents the output of another call to <span class="literal">aa-status</span>, showing that the <span class="literal">httpd</span> profile was loaded correctly and that all four corresponding process instances are running in enforce mode as desired.</p>
<pre class="pre"><span epub:type="pagebreak" id="page_217"/># <span class="codestrong1">aa-status</span>&#13;
...&#13;
50 profiles are loaded.&#13;
50 profiles are in enforce mode.&#13;
...&#13;
   httpd&#13;
   httpd//DEFAULT_URI&#13;
   httpd//HANDLING_UNTRUSTED_INPUT&#13;
   httpd//phpsysinfo&#13;
...&#13;
6 processes are in enforce mode.&#13;
   /usr/sbin/avahi-daemon (669) avahi-daemon&#13;
   /usr/sbin/avahi-daemon (672) avahi-daemon&#13;
   /usr/sbin/httpd (668) httpd&#13;
   /usr/sbin/httpd (678) httpd&#13;
   /usr/sbin/httpd (679) httpd&#13;
   /usr/sbin/httpd (681) httpd&#13;
...</pre>
<p class="list-title" id="ch11list014"><em>Listing 11-14: The output of</em> <span class="codeitalic1">aa-status</span> <em>after profile changes</em></p>
<p class="indent">Although we succeeded in activating the predefined profile, we have no idea whether the profile actually restricts the web server application in a secure way. A comment in the given profile says that “this profile is completely permissive,” which means that you still have to customize it according to your application and requirements.</p>
<p class="indent">A quick look at the profile <em>sbin.syslogd</em> associated with the <span class="literal">syslogd</span> tool, the second example binary identified at the beginning of this subsection, reveals that the configured path, <em>/sbin/syslogd</em>, matches the path of the corresponding executable, but the process is still not running in enforce mode. The properties of the binary, as shown in <a href="ch11.xhtml#ch11list015">Listing 11-15</a>, reveal that the executable is actually a symbolic link to another executable—namely, <em>/bin/busybox.nosuid</em>.</p>
<pre class="pre"># <span class="codestrong1">ls -l /sbin/syslogd</span>&#13;
lrwxrwxrwx 1 root root 19 ... /sbin/syslogd -&gt; /bin/busybox.nosuid</pre>
<p class="list-title" id="ch11list015"><em>Listing 11-15: A symbolic link to another executable</em></p>
<p class="indent">This makes the situation somewhat complicated because BusyBox unites a variety of tools in one binary. Simply changing the <span class="literal">syslogd</span> profile’s path doesn’t solve this issue but rather causes further problems with other Busy-Box functionalities. In such cases, you have several options. You could just spare the <span class="literal">syslogd</span> profile, you could search for or create a comprehensive <span class="literal">busybox</span> profile, or you could install and use the original <span class="literal">syslogd</span> application after all.</p>
<h4 class="h4" id="ch00lev2_149"><span epub:type="pagebreak" id="page_218"/><strong><em>Application Profiling</em></strong></h4>
<p class="noindent">For your own applications or third-party tools that don’t come with a predefined AppArmor profile, you have to create one yourself if you want to confine them with MAC mechanisms at runtime.</p>
<p class="indent">Let’s look at a very simple Python application that was reduced to the minimum. <a href="ch11.xhtml#ch11list016">Listing 11-16</a> shows the code.</p>
<pre class="pre">#!/usr/bin/python3&#13;
&#13;
import sys&#13;
&#13;
if len(sys.argv) == 2:&#13;
    file_path = sys.argv[1]&#13;
    with open(file_path, 'r') as f:&#13;
        print(f.read())&#13;
else:&#13;
    print('Usage:', sys.argv[0], '&lt;filename&gt;')</pre>
<p class="list-title" id="ch11list016"><em>Listing 11-16: A simple file-printing application in Python</em></p>
<p class="indent">This application’s sole purpose is to print the content of a text file given as a command line argument. The application’s filename is <em>printfile.py</em>, it’s located in <em>/home/root/</em>, and it’s marked as executable.</p>
<p class="indent">Let’s assume that this tool is an essential part of your web interface and needs to run with superuser privileges because it has to print the content of the <em>testfile</em> and <em>logfile</em> files, which are accessible only by root. However, during your threat and risk analysis, you discover that adversaries might be able to inject other filepaths than the two intended ones, which could lead to the exposure of sensitive information and should be prevented—for example, by using a custom-tailored AppArmor profile.</p>
<p class="indent"><a href="ch11.xhtml#ch11list017">Listing 11-17</a> shows the basic initial profile I created at <em>/etc/apparmor.d/ home.root.printfile.py</em> as a starting point for profiling this application. It includes read access (<span class="literal">r</span>) for the two previously mentioned files and denies any other file access.</p>
<pre class="pre">/home/root/printfile.py {&#13;
   /home/root/testfile     r,&#13;
   /home/root/logfile      r,&#13;
}</pre>
<p class="list-title" id="ch11list017"><em>Listing 11-17: The initial AppArmor profile for</em> printfile.py</p>
<p class="indent">In the second step, I loaded the newly created profile in complain mode, as shown in <a href="ch11.xhtml#ch11list018">Listing 11-18</a>.</p>
<pre class="pre"># <span class="codestrong1">aa-complain /etc/apparmor.d/home.root.printfile.py</span>&#13;
Setting /etc/apparmor.d/home.root.printfile.py to complain mode.</pre>
<p class="list-title" id="ch11list018"><em>Listing 11-18: Loading a profile in complain mode</em></p>
<p class="indent"><span epub:type="pagebreak" id="page_219"/>If you now execute <span class="literal">./printfile.py testfile</span> in <em>home/root/</em>, the application will work without issues but will create log entries for all profile violations.</p>
<p class="indent"><a href="ch11.xhtml#ch11list019">Listing 11-19</a> shows a pruned set of AppArmor kernel messages corresponding to <em>printfile.py</em>.</p>
<pre class="pre"># <span class="codestrong1">dmesg | grep printfile.py</span>&#13;
... audit: type=1400 audit(1652997509.490:132): apparmor="STATUS"&#13;
             operation="profile_load" profile="unconfined"&#13;
             name="/home/root/printfile.py" pid=1557 comm="apparmor_parser"&#13;
... audit: type=1400 audit(1652997771.210:133): apparmor="ALLOWED"&#13;
             operation="open" profile="/home/root/printfile.py"&#13;
             name="/etc/ld.so.cache" pid=1560 comm="printfile.py"&#13;
             requested_mask="r" denied_mask="r" fsuid=0 ouid=0&#13;
... audit: type=1300 audit(1652997771.210:133): arch=40000028 ...&#13;
             comm="printfile.py" exe="/usr/bin/python3.10"&#13;
             subj=/home/root/printfile.py (complain) key=(null)&#13;
... audit: type=1400 audit(1652997771.210:134): apparmor="ALLOWED"&#13;
             operation="open" profile="/home/root/printfile.py"&#13;
             name="/usr/lib/libpython3.10.so.1.0" pid=1560 comm="printfile.py"&#13;
             requested_mask="r" denied_mask="r" fsuid=0 ouid=0&#13;
... audit: type=1300 audit(1652997771.210:134): arch=40000028 ...&#13;
             comm="printfile.py" exe="/usr/bin/python3.10"&#13;
             subj=/home/root/printfile.py (complain) key=(null)&#13;
... audit: type=1400 audit(1652997771.210:135): apparmor="ALLOWED"&#13;
             operation="file_mmap" profile="/home/root/printfile.py"&#13;
             name="/usr/lib/libpython3.10.so.1.0" pid=1560 comm="printfile.py"&#13;
             requested_mask="rm" denied_mask="rm" fsuid=0 ouid=0&#13;
... audit: type=1300 audit(1652997771.210:135): arch=40000028 ...&#13;
             comm="printfile.py" exe="/usr/bin/python3.10"&#13;
             subj=/home/root/printfile.py (complain) key=(null)&#13;
... audit: type=1400 audit(1652997771.210:136): apparmor="ALLOWED"&#13;
             operation="open" profile="/home/root/printfile.py"&#13;
             name="/lib/libc.so.6" pid=1560 comm="printfile.py"&#13;
             requested_mask="r" denied_mask="r" fsuid=0 ouid=0</pre>
<p class="list-title" id="ch11list019"><em>Listing 11-19: The AppArmor complain messages for</em> printfile.py</p>
<p class="indent">You can see that multiple access violations occurred while just calling <em>printfile.py</em> in its intended way. If you put the initial profile in enforce mode, the application won’t work anymore. Therefore, you have to use the depicted output to extend the AppArmor profile for <em>printfile.py</em>. For example, you have to grant read access (<span class="literal">r</span>) to <em>/etc/ld.so.cache</em>, execution rights (<span class="literal">ux</span>) for <em>/usr/bin/python3.10</em>, and permissions for reading (<span class="literal">r</span>) and mapping (<span class="literal">m</span>) <em>/usr/lib/libpython3.10.so.1.0</em>.</p>
<p class="indent"><a href="ch11.xhtml#ch11list020">Listing 11-20</a> shows the final profile after four iterations of execution in complain mode, profile refinement, and reloading.</p>
<pre class="pre"><span epub:type="pagebreak" id="page_220"/>/home/root/printfile.py flags=(complain) {&#13;
   /home/root/testfile             r,&#13;
   /home/root/logfile              r,&#13;
   /etc/ld.so.cache                r,&#13;
   /usr/bin/python3.10             ux,&#13;
   /usr/lib/libpython3.10.so.1.0   rm,&#13;
   /lib/libc.so.6                  rm,&#13;
   /lib/libm.so.6                  rm,&#13;
   /usr/lib/locale/locale-archive  r,&#13;
   /usr/lib/python3.10/            r,&#13;
   /usr/lib/python3.10/**          r,&#13;
   /home/root/printfile.py         r,&#13;
}</pre>
<p class="list-title" id="ch11list020"><em>Listing 11-20: The AppArmor profile for</em> printfile.py <em>after refinement</em></p>
<p class="indent">After this manual characterization phase, the created profile can be loaded in enforce mode and tested for its behavior (<a href="ch11.xhtml#ch11list021">Listing 11-21</a>).</p>
<pre class="pre"># <span class="codestrong1">aa-enforce /etc/apparmor.d/home.root.printfile.py</span>&#13;
Setting /etc/apparmor.d/home.root.printfile.py to enforce mode.&#13;
# <span class="codestrong1">./printfile.py testfile</span>&#13;
--- --- ---&#13;
This is a test file!&#13;
--- --- ---&#13;
# <span class="codestrong1">./printfile.py logfile</span>&#13;
--- --- ---&#13;
All the logs...&#13;
--- --- ---&#13;
# <span class="codestrong1">./printfile.py secrets</span>&#13;
Traceback (most recent call last):&#13;
  File "/home/root/./printfile.py", line 7, in &lt;module&gt;&#13;
    with open(file_path, 'r') as f:&#13;
PermissionError: [Errno 13] Permission denied: 'secrets'&#13;
# <span class="codestrong1">./printfile.py /etc/passwd</span>&#13;
Traceback (most recent call last):&#13;
  File "/home/root/./printfile.py", line 7, in &lt;module&gt;&#13;
    with open(file_path, 'r') as f:&#13;
PermissionError: [Errno 13] Permission denied: '/etc/passwd'</pre>
<p class="list-title" id="ch11list021"><em>Listing 11-21: Testing</em> printfile.py <em>in enforce mode</em></p>
<p class="indent">Printing the <em>testfile</em> and <em>logfile</em> files works as intended. However, if attackers try to read the <em>secrets</em> file in the same folder or even the <em>/etc/passwd</em> file, AppArmor successfully protects from severe damage.</p>
<p class="indent">This simple case study showed the basic feasibility of application characterization and corresponding AppArmor profile creation. However, even this trivial example took several profiling iterations, and the resulting profile will need to be maintained continuously—for example, if you switch to <span epub:type="pagebreak" id="page_221"/>another distribution or even a newer version of Python. Further, as you can imagine, more complex applications require significantly more characterization and testing efforts.</p>
<h3 class="h3" id="ch00lev1_95"><strong>Summary</strong></h3>
<p class="noindent">Access control is an enormously broad topic that could fill a whole book on its own. It encompasses the basic configurations of users, groups, directory structures, and access permissions (as discussed in this chapter for the Linux DAC system), the deactivation of hardware debugging features and tools not meant for end users, and the complex field of OS-enforced MAC policies that have to be fine-tuned to the individual behavior and resource-access demands of a specific application. And while I don’t expect you to invest all your time designing perfect access-control settings, there’s no way around this matter in secure device engineering.</p>
<p class="indent">In practice, we have to find practically feasible compromises. A complete whitelisting approach might be hard to implement and can lead to broken applications if misconfigured, for which security will be blamed. Blacklisting, on the other hand, won’t be able to immediately catch new threats that appear in the field. A fine granularity of permissions can be managed over time only if you are willing to expend significant effort, but if your access-control concept is too simplistic, your adversaries will thank you for removing that annoying obstacle in the way.</p>
<p class="indent">Finally, I’d like to point out that access-control mechanisms always have a strong relation to system-integrity protection, as described in <a href="ch08.xhtml#ch08">Chapter 8</a>. Just imagine if you painstakingly defined a perfect set of access rules only to find out that an attacker can reset them all to 777 within minutes. That would hurt.<span epub:type="pagebreak" id="page_222"/></p>
</div></body></html>