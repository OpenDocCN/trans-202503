- en: '**14'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '**14**'
- en: UEFI BOOT VS. THE MBR/VBR BOOT PROCESS**
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '**UEFI 引导与 MBR/VBR 引导过程**'
- en: '![Image](../images/common.jpg)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/common.jpg)'
- en: As we’ve seen, bootkit development follows the evolution of the boot process.
    With Windows 7’s introduction of the Kernel-Mode Code Signing Policy, which made
    it hard to load arbitrary code into the kernel, came the resurgence of bootkits
    that targeted the boot process logic before any signing checks applied (for example,
    by targeting the VBR, which could not be protected at the time). Likewise, because
    the UEFI standard supported in Windows 8 is replacing legacy boot processes like
    the MBR/VBR boot flow, it is also becoming the next boot infection target.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，bootkit 的开发遵循了引导过程的演变。随着 Windows 7 引入内核模式代码签名策略，这使得将任意代码加载到内核中变得困难，bootkit
    也因此迎来了复兴，它们通过攻击在任何签名检查应用之前的引导过程逻辑（例如，通过攻击当时无法保护的 VBR）来进行感染。同样，由于 Windows 8 中支持的
    UEFI 标准正在取代像 MBR/VBR 这样的传统引导流程，它也正在成为下一个引导感染的目标。
- en: The modern UEFI is very different from legacy approaches. The legacy BIOS developed
    alongside the first PC-compatible computer firmware and, in its early days, was
    a simple piece of code that configured the PC hardware during initial setup to
    boot all other software. But as PC hardware grew in complexity, more complex firmware
    code was needed to configure it, so the UEFI standard was developed to control
    the sprawling complexity in a uniform structure. Nowadays, almost all modern computer
    systems are expected to employ UEFI firmware for their configuration; the legacy
    BIOS process is increasingly relegated to simpler embedded systems.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 现代 UEFI 与传统方法非常不同。传统 BIOS 与第一台兼容 PC 的计算机固件一同发展，在早期，它只是一个简单的代码片段，在初次设置时配置 PC
    硬件，以便启动其他所有软件。但随着 PC 硬件复杂性的增加，需要更复杂的固件代码来进行配置，因此开发了 UEFI 标准，以统一的结构来控制不断扩展的复杂性。如今，几乎所有现代计算机系统都预计会使用
    UEFI 固件进行配置；而传统的 BIOS 引导过程则越来越被简单的嵌入式系统所取代。
- en: Prior to the introduction of the UEFI standard, BIOS implementations by different
    vendors shared no common structure. This lack of consistency created obstacles
    for attackers, who were forced to target every BIOS implementation separately,
    but it was also a challenge for defenders, who had no unified mechanism for protecting
    the integrity of the boot process and control flow. The UEFI standard enabled
    defenders to create such a mechanism, which became known as the UEFI Secure Boot.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在引入 UEFI 标准之前，不同厂商的 BIOS 实现并没有共同的结构。这种不一致性为攻击者创造了障碍，他们被迫分别攻击每一个 BIOS 实现，但这对防御者来说也是一种挑战，因为他们没有统一的机制来保护引导过程和控制流的完整性。UEFI
    标准使防御者能够创建这样的机制，它被称为 UEFI 安全引导（UEFI Secure Boot）。
- en: Partial support for UEFI started with Windows 7, but support for UEFI Secure
    Boot was not introduced until Windows 8\. Alongside Secure Boot, Microsoft continues
    supporting the MBR-based legacy boot process via UEFI’s Compatibility Support
    Module (CSM), which is not compatible with Secure Boot and does not offer its
    integrity guarantees, as discussed shortly. Whether or not this legacy support
    via CSM is disabled in the future, UEFI is clearly the next step in the evolution
    of the boot process and, thus, the arena where the bootkit’s and the boot defense’s
    codevelopment will occur.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 部分支持 UEFI 从 Windows 7 开始，但直到 Windows 8 才引入了 UEFI 安全引导。与安全引导一同，微软继续通过 UEFI 的兼容性支持模块（CSM）支持基于
    MBR 的传统引导过程，而 CSM 与安全引导不兼容，并且无法提供其完整性保证，正如稍后所讨论的那样。无论未来是否禁用通过 CSM 提供的传统支持，UEFI
    显然是引导过程演变的下一步，因此，它将成为 bootkit 和引导防御共同发展的领域。
- en: In this chapter, we’ll focus on the specifics of the UEFI boot process, specifically
    on its differences from the legacy boot MBR/VBR infection approaches.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将重点关注 UEFI 引导过程的细节，特别是它与传统的 MBR/VBR 引导感染方法的区别。
- en: '**The Unified Extensible Firmware Interface**'
  id: totrans-8
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**统一可扩展固件接口**'
- en: UEFI is a specification (*[https://www.uefi.org](https://www.uefi.org)*) that
    defines a software interface between an operating system and the firmware. It
    was originally developed by Intel to replace the widely divergent legacy BIOS
    boot software, which was also limited to 16-bit mode and thus unsuitable for new
    hardware. These days, UEFI firmware dominates in the PC market with Intel CPUs,
    and ARM vendors are also moving toward it. As mentioned, for compatibility reasons,
    some UEFI-based firmware contains a Compatibility Support Module to support the
    legacy BIOS boot process for previous generations of operating systems; however,
    Secure Boot cannot be supported under CSM.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: UEFI 是一个规范（*[https://www.uefi.org](https://www.uefi.org)*），定义了操作系统与固件之间的软件接口。最初由英特尔开发，用来取代广泛存在差异的传统
    BIOS 启动软件，后者仅限于 16 位模式，因此不适用于新硬件。如今，UEFI 固件在配备英特尔 CPU 的 PC 市场中占主导地位，ARM 供应商也在朝这个方向发展。如前所述，出于兼容性考虑，一些基于
    UEFI 的固件包含兼容性支持模块（CSM），以支持旧版操作系统的传统 BIOS 启动过程；然而，CSM 下无法支持安全启动（Secure Boot）。
- en: The UEFI firmware resembles a miniature operating system that even has its own
    network stack. It contains a few million lines of code, mostly in C, with some
    assembly language mixed in for platform-specific parts. The UEFI firmware is thus
    much more complex and provides more functionality than its legacy BIOS precursors.
    And, unlike the legacy BIOS, its core parts are open source, a characteristic
    that, along with code leaks (for example, the AMI source code leak of 2013), has
    opened up possibilities for external vulnerability researchers. Indeed, a wealth
    of information about UEFI vulnerabilities and attack vectors has been released
    over the years, some of which will be covered in [Chapter 16](ch16.xhtml#ch16).
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: UEFI 固件类似于一个迷你操作系统，甚至拥有自己的网络栈。它包含几百万行代码，主要是 C 语言，也混合了一些汇编语言，用于平台特定的部分。因此，UEFI
    固件比其传统 BIOS 前身更加复杂，提供了更多的功能。而且，与传统 BIOS 不同，它的核心部分是开源的，这一特点以及代码泄漏（例如，2013 年的 AMI
    源代码泄漏）为外部漏洞研究人员提供了更多的可能性。事实上，关于 UEFI 漏洞和攻击路径的大量信息已经被公开，其中一些将在[第16章](ch16.xhtml#ch16)中介绍。
- en: '**NOTE**'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*The inherent complexity of UEFI firmware is one of the main causes of a number
    of UEFI vulnerabilities and attack vectors reported over the years. The availability
    of the source code and greater openness of UEFI firmware implementation details,
    however, is not. Source code availability shouldn’t have a negative impact on
    security and, in fact, has the opposite effect.*'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: '*UEFI 固件的固有复杂性是多年来报告的许多 UEFI 漏洞和攻击路径的主要原因之一。然而，源代码的可用性和 UEFI 固件实现细节的更大开放性并不是原因。源代码的可用性不应对安全性产生负面影响，事实上，它产生了相反的效果。*'
- en: '**Differences Between the Legacy BIOS and UEFI Boot Processes**'
  id: totrans-13
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**传统 BIOS 和 UEFI 启动过程的区别**'
- en: 'From a security standpoint, the main differences in UEFI’s boot process derive
    from the aim of supporting Secure Boot: the flow logic of the MBR/VBR is eliminated
    and completely replaced by UEFI components. We’ve mentioned Secure Boot a few
    times already, and now we’ll look at it more closely as we examine the UEFI process.'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 从安全角度来看，UEFI 启动过程的主要区别在于其支持安全启动（Secure Boot）的目标：MBR/VBR 的流程逻辑被完全消除，并由 UEFI 组件完全取代。我们已经提到过安全启动，现在我们将更详细地了解它，并深入分析
    UEFI 过程。
- en: 'Let’s first review the examples of malicious OS boot modifications we’ve seen
    so far and the bootkits that inflict them:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们首先回顾一下我们到目前为止看到的恶意操作系统启动修改示例，以及施加这些修改的启动工具包（bootkits）：
- en: MBR boot code modification (TDL4)
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: MBR 启动代码修改（TDL4）
- en: MBR partition table modification (Olmasco)
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: MBR 分区表修改（Olmasco）
- en: VBR BIOS parameter block (Gapz)
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: VBR BIOS 参数块（Gapz）
- en: IPL bootstrap code modification (Rovnix)
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: IPL 启动代码修改（Rovnix）
- en: From this list, we can see that the techniques for infecting the boot process
    all depend on violating the integrity of the next stage that’s loaded. UEFI Secure
    Boot is meant to change that pattern by establishing a chain of trust through
    which the integrity of each stage in the flow is verified before that stage is
    loaded and given control.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 从这份列表中，我们可以看到，感染启动过程的技术都依赖于违反加载的下一个阶段的完整性。UEFI 安全启动旨在通过建立一个信任链来改变这一模式，通过该链，流中每个阶段的完整性在该阶段被加载并控制之前都会得到验证。
- en: '***The Boot Process Flow***'
  id: totrans-21
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***启动过程流***'
- en: The task of the MBR-based legacy BIOS was merely to apply the necessary hardware
    configurations and then transfer control to each succeeding stage of the boot
    code—from boot code to MBR to VBR and finally to an OS bootloader (for instance,
    to *bootmgr* and *winload.exe* in the case of Windows); the rest of the flow logic
    was beyond its responsibility.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 基于MBR的传统BIOS的任务仅仅是应用必要的硬件配置，然后将控制权传递给启动代码的每个后续阶段——从启动代码到MBR，再到VBR，最后到操作系统引导加载程序（例如，在Windows系统中为*bootmgr*和*winload.exe*）；其余的流程逻辑超出了它的职责范围。
- en: The boot process in UEFI is substantially different. The MBR and VBR no longer
    exist; instead, UEFI’s own single piece of boot code is responsible for loading
    the *bootmgr*.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在UEFI中的启动过程有显著不同。MBR和VBR不再存在；取而代之的是UEFI自身的一段启动代码，负责加载*bootmgr*。
- en: '***Disk Partitioning: MBR vs. GPT***'
  id: totrans-24
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***磁盘分区：MBR与GPT***'
- en: UEFI also differs from the legacy BIOS in the kind of partition table it uses.
    Unlike the legacy BIOS, which uses an MBR-style partition table, UEFI supports
    the *GUID Partition Table (GPT)*. The GPT is rather different from the MBR. MBR
    tables support only four primary or extended partition slots (with multiple logical
    partitions in an extended partition, if needed), whereas a GPT supports a much
    larger number of partitions, each of which is identified by a unique 16-byte identification
    Globally Unique Identifier, or GUID. Overall, MBR partitioning rules are more
    complex than those of the GPT; the GPT style allows larger partition sizes and
    has a flat table structure, at the cost of using GUID labels rather than small
    integers to identify partitions. This flat table structure simplifies certain
    aspects of partition management under UEFI.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: UEFI还与传统BIOS在使用的分区表类型上有所不同。与使用MBR式分区表的传统BIOS不同，UEFI支持*GUID分区表（GPT）*。GPT与MBR有很大不同。MBR表仅支持四个主分区或扩展分区插槽（如果需要，可以在扩展分区中有多个逻辑分区），而GPT支持更多的分区，每个分区都有一个唯一的16字节标识符——全球唯一标识符（GUID）。总体而言，MBR的分区规则比GPT更复杂；GPT方式允许更大的分区大小，并且具有扁平化的表结构，代价是使用GUID标签而不是小整数来标识分区。此扁平结构简化了UEFI下的某些分区管理。
- en: To support the UEFI boot process, the new GPT partitioning scheme specifies
    a dedicated partition from which the UEFI OS bootloader is loaded (in the legacy
    MBR table, this role was played by an “active” bit flag set on a primary partition).
    This special partition is referred to as the *EFI system partition*, and it is
    formatted with the FAT32 filesystem (although FAT12 and FAT16 are also possible).
    The path to this bootloader within the partition’s filesystem is specified in
    a dedicated *nonvolatile random access memory (NVRAM)* variable, also known as
    a UEFI variable. NVRAM is a small memory storage module, located on PC motherboards,
    that is used to store the BIOS and operating system configuration settings.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 为了支持UEFI启动过程，新的GPT分区方案指定了一个专用分区，用于加载UEFI操作系统引导加载程序（在传统的MBR表中，这个角色是由设置在主分区上的“活动”位标志来承担的）。这个特殊分区被称为*EFI系统分区*，并且采用FAT32文件系统格式（尽管FAT12和FAT16也是可能的）。该分区内文件系统中引导加载程序的路径在一个专用的*非易失性随机存取存储器（NVRAM）*变量中指定，也称为UEFI变量。NVRAM是一个小型内存存储模块，位于PC主板上，用于存储BIOS和操作系统配置设置。
- en: 'For Microsoft Windows, the path to the bootloader on a UEFI system looks like
    *\EFI\Microsoft\Boot\bootmgfw.efi*. The purpose of this module is to locate the
    operating system kernel loader—*winload.efi* for modern Windows versions with
    UEFI support—and transfer control to it. The functionality of *winload.efi* is
    essentially the same as that of *winload.exe*: to load and initialize the operating
    system kernel image.'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 对于微软Windows，UEFI系统中的引导加载程序路径看起来像是*\EFI\Microsoft\Boot\bootmgfw.efi*。这个模块的目的是定位操作系统内核加载程序——对于支持UEFI的现代Windows版本为*winload.efi*——并将控制权传递给它。*winload.efi*的功能与*winload.exe*本质相同：加载并初始化操作系统内核镜像。
- en: '[Figure 14-1](ch14.xhtml#ch14fig01) shows the boot process flow for legacy
    BIOS versus UEFI, skipping those MBR and VBR steps.'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '[图14-1](ch14.xhtml#ch14fig01)展示了传统BIOS与UEFI之间的启动过程流图，跳过了MBR和VBR步骤。'
- en: '![image](../images/14fig01.jpg)'
  id: totrans-29
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/14fig01.jpg)'
- en: '*Figure 14-1: The difference in boot flow between legacy BIOS and UEFI systems*'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '*图14-1：传统BIOS与UEFI系统启动流程的差异*'
- en: As you can see, UEFI-based systems do much more in firmware before transferring
    control to the operating system bootloader than does a legacy BIOS. There are
    no intermediate stages like the MBR/VBR bootstrap code; the boot process is fully
    controlled by the UEFI firmware alone, whereas the BIOS firmware only took care
    of platform initialization, letting the operating system loaders (*bootmgr* and
    *winload.exe*) do the rest.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，基于 UEFI 的系统在将控制权转交给操作系统启动加载程序之前，固件中执行的工作比遗留 BIOS 要多得多。没有像 MBR/VBR 启动代码这样的中间阶段；启动过程完全由
    UEFI 固件控制，而 BIOS 固件只负责平台初始化，将其余部分交给操作系统加载程序（*bootmgr* 和 *winload.exe*）处理。
- en: '***Other Differences***'
  id: totrans-32
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***其他差异***'
- en: Another huge change introduced by UEFI is that almost all of its code runs in
    protected mode, except for the small initial stub that is given control by the
    CPU when it is powered up or reset. Protected mode provides support for executing
    32- or 64-bit code (although it also allows for emulating other legacy modes that
    are not used by modern boot logic). By contrast, legacy boot logic executed most
    of its code in 16-bit mode until it transferred control to the OS loaders.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: UEFI 引入的另一个巨大变化是几乎所有的代码都在保护模式下运行，只有在 CPU 启动或重置时，给定的少量初始代码才会由 CPU 控制。保护模式提供了执行
    32 位或 64 位代码的支持（尽管它也允许模拟其他不被现代启动逻辑使用的遗留模式）。相比之下，遗留启动逻辑大部分代码都在 16 位模式下执行，直到它将控制权转交给操作系统加载程序。
- en: Another difference between UEFI firmware and legacy BIOS is that most UEFI firmware
    is written in C (and could even be compiled with a C++ compiler, as certain vendors
    do), with only a small part written in assembly language. This makes for better
    code quality compared to the all-assembly implementations of legacy BIOS firmware.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个 UEFI 固件与遗留 BIOS 之间的区别是，大多数 UEFI 固件都是用 C 语言编写的（甚至可以用 C++ 编译器编译，正如某些厂商所做的那样），只有一小部分是用汇编语言编写的。这与遗留
    BIOS 固件完全采用汇编语言实现相比，提供了更好的代码质量。
- en: Further differences between legacy BIOS and UEFI firmware are presented in [Table
    14-1](ch14.xhtml#ch14tab01).
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 遗留 BIOS 和 UEFI 固件之间的更多差异见 [表 14-1](ch14.xhtml#ch14tab01)。
- en: '**Table 14-1:** Comparison of Legacy BIOS and UEFI Firmware'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '**表 14-1：** 遗留 BIOS 和 UEFI 固件比较'
- en: '|  | **Legacy BIOS** | **UEFI firmware** |'
  id: totrans-37
  prefs: []
  type: TYPE_TB
  zh: '|  | **遗留 BIOS** | **UEFI 固件** |'
- en: '| --- | --- | --- |'
  id: totrans-38
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| **Architecture** | Unspecified firmware development process; all BIOS vendors
    independently support their own codebase | Unified specification for firmware
    development and Intel reference code (EDKI/EDKII) |'
  id: totrans-39
  prefs: []
  type: TYPE_TB
  zh: '| **架构** | 未指定固件开发过程；所有 BIOS 厂商独立支持各自的代码库 | 统一的固件开发规范和英特尔参考代码 (EDKI/EDKII)
    |'
- en: '| **Implementation** | Mostly assembly language | C/C++ |'
  id: totrans-40
  prefs: []
  type: TYPE_TB
  zh: '| **实现方式** | 主要是汇编语言 | C/C++ |'
- en: '| **Memory model** | 16-bit real mode | 32-/64-bit protected mode |'
  id: totrans-41
  prefs: []
  type: TYPE_TB
  zh: '| **内存模型** | 16 位实模式 | 32 位/64 位保护模式 |'
- en: '| **Bootstrap code** | MBR and VBR | None (firmware controls the boot process)
    |'
  id: totrans-42
  prefs: []
  type: TYPE_TB
  zh: '| **启动代码** | MBR 和 VBR | 无 (固件控制启动过程) |'
- en: '| **Partition scheme** | MBR partition table | GUID Partition Table (GPT) |'
  id: totrans-43
  prefs: []
  type: TYPE_TB
  zh: '| **分区方案** | MBR 分区表 | GUID 分区表 (GPT) |'
- en: '| **Disk I/O** | System interrupts | UEFI services |'
  id: totrans-44
  prefs: []
  type: TYPE_TB
  zh: '| **磁盘 I/O** | 系统中断 | UEFI 服务 |'
- en: '| **Bootloaders** | *bootmgr* and *winload.exe* | *bootmgfw.efi* and *winload.efi*
    |'
  id: totrans-45
  prefs: []
  type: TYPE_TB
  zh: '| **启动加载器** | *bootmgr* 和 *winload.exe* | *bootmgfw.efi* 和 *winload.efi* |'
- en: '| **OS interaction** | BIOS interrupts | UEFI services |'
  id: totrans-46
  prefs: []
  type: TYPE_TB
  zh: '| **操作系统交互** | BIOS 中断 | UEFI 服务 |'
- en: '| **Boot configuration information** | CMOS memory, no notion of NVRAM variables
    | UEFI NVRAM variable store |'
  id: totrans-47
  prefs: []
  type: TYPE_TB
  zh: '| **启动配置** | CMOS 内存，无 NVRAM 变量的概念 | UEFI NVRAM 变量存储 |'
- en: Before we go into the details of the UEFI boot process and its operating system
    bootloader, we’ll take a close look at the GPT specifics. Understanding the differences
    between the MBR and GPT partitioning schemes is essential for learning the UEFI
    boot process.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在深入了解 UEFI 启动过程及其操作系统启动加载程序之前，我们将仔细查看 GPT 相关细节。理解 MBR 和 GPT 分区方案之间的差异对于学习 UEFI
    启动过程至关重要。
- en: '**GUID Partition Table Specifics**'
  id: totrans-49
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**GUID 分区表详情**'
- en: If you look at a primary Windows hard drive formatted with a GPT in a hex editor,
    you’ll find no MBR or VBR boot code in the first two sectors (1 sector = 512 bytes).
    The space that in a legacy BIOS would contain MBR code is almost entirely zeroed
    out. Instead, at the beginning of the second sector, you can see an `EFI PART`
    signature at offset 0x200 ([Figure 14-2](ch14.xhtml#ch14fig02)), just after the
    familiar `55 AA` end-of-MBR tag. This is the EFI partition table signature of
    the GPT header, which identifies it as such.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你用十六进制编辑器查看一个格式化为GPT的Windows主硬盘，你会发现在前两个扇区中（1个扇区 = 512字节）没有MBR或VBR启动代码。传统BIOS中本应包含MBR代码的空间几乎完全为零化。相反，在第二个扇区的开始，你可以看到偏移量0x200处有一个`EFI
    PART`签名（见[图14-2](ch14.xhtml#ch14fig02)），紧跟着熟悉的`55 AA` MBR结束标志。这是GPT头部的EFI分区表签名，标识其为GPT。
- en: '![image](../images/14fig02.jpg)'
  id: totrans-51
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/14fig02.jpg)'
- en: '*Figure 14-2: GUID Partition Table signature dumped from* \\.\PhysicalDrive0'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '*图14-2：从* \\.\PhysicalDrive0 导出的GUID分区表签名*'
- en: The MBR partition table structure is not all gone, however. In order to be compatible
    with legacy boot processes and tools such as pre-GPT low-level disk editors, the
    GPT emulates the old MBR table as it starts. This emulated MBR partition table
    now contains just one entry for the entire GPT disk, shown in [Figure 14-3](ch14.xhtml#ch14fig03).
    This form of MBR scheme is known as *Protective MBR*.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，MBR分区表结构并没有完全消失。为了与传统的启动过程和工具（如GPT之前的低级磁盘编辑器）兼容，GPT在启动时会模拟旧的MBR表。这个模拟的MBR分区表现在只包含一个条目，表示整个GPT磁盘，见[图14-3](ch14.xhtml#ch14fig03)。这种MBR方案形式被称为*保护性MBR*。
- en: '![image](../images/14fig03.jpg)'
  id: totrans-54
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/14fig03.jpg)'
- en: '*Figure 14-3: Legacy MBR header parsed in 010 Editor by the `Drive.bt` template*'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '*图14-3：010编辑器中通过`Drive.bt`模板解析的传统MBR头部*'
- en: This Protective MBR prevents legacy software such as disk utilities from accidentally
    destroying GUID partitions by marking the entire disk space as claimed by a single
    partition; legacy tools unaware of GPT do not mistake its GPT-partitioned parts
    for free space. The Protective MBR has the same format as a normal MBR, despite
    being only a stub. The UEFI firmware will recognize this Protective MBR for what
    it is and will not attempt to execute any code from it.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 这个保护性MBR通过将整个磁盘空间标记为由单一分区占用，防止了传统软件（如磁盘工具）意外破坏GUID分区；不支持GPT的传统工具不会误将其GPT分区的部分当作空闲空间。尽管它只是一个存根，保护性MBR的格式与普通MBR相同。UEFI固件会识别这个保护性MBR，并不会尝试从中执行任何代码。
- en: The main departure from the legacy BIOS boot process is that all of the code
    responsible for the early boot stages of the system is now encapsulated in the
    UEFI firmware itself, residing in the flash chip rather than on the disk. This
    means that MBR infection methods that infected or modified the MBR or VBR on the
    disk (used by the likes of TDL4 and Olmasco, as discussed in [Chapters 7](ch07.xhtml#ch07)
    and [10](ch10.xhtml#ch10), respectively) will have no effect on GPT-based systems’
    boot flow, even without Secure Boot being enabled.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 与传统BIOS启动过程的主要区别在于，负责系统早期启动阶段的所有代码现在都被封装在UEFI固件中，存储在闪存芯片中，而不是磁盘上。这意味着感染或修改磁盘上的MBR或VBR的MBR感染方法（例如TDL4和Olmasco病毒，分别在[第7章](ch07.xhtml#ch07)和[第10章](ch10.xhtml#ch10)中讨论）将不会对基于GPT的系统启动流程产生影响，即使没有启用安全启动。
- en: '**CHECKING FOR GPT SUPPORT**'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '**检查GPT支持**'
- en: You can check whether your Windows system includes GPT support by using Microsoft’s
    PowerShell commands. Specifically, the `Get-Disk` command ([Listing 14-1](ch14.xhtml#ch14list01))
    will return a table, the last column of which, named Partition Style, shows the
    supported partition table type. If it is GPT compatible, you’ll see GPT listed
    as the Partition Style; otherwise, you’ll see MBR in that column.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过使用微软的PowerShell命令来检查你的Windows系统是否支持GPT。具体来说，`Get-Disk`命令（见[清单14-1](ch14.xhtml#ch14list01)）将返回一个表格，最后一列名为“Partition
    Style”，显示支持的分区表类型。如果是GPT兼容的，你将看到GPT列在Partition Style这一列中；否则，看到MBR。
- en: '[PRE0]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '*Listing 14-1: The output from `Get-Disk`*'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单14-1：`Get-Disk`的输出*'
- en: '[Table 14-2](ch14.xhtml#ch14tab02) lists descriptions of the values found in
    the GPT header.'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '[表14-2](ch14.xhtml#ch14tab02)列出了GPT头部中各个值的描述。'
- en: '**Table 14-2:** GPT Header'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '**表14-2：** GPT头部'
- en: '| **Name** | **Offset** | **Length** |'
  id: totrans-64
  prefs: []
  type: TYPE_TB
  zh: '| **名称** | **偏移量** | **长度** |'
- en: '| --- | --- | --- |'
  id: totrans-65
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| Signature “EFI PART” | 0x00 | 8 bytes |'
  id: totrans-66
  prefs: []
  type: TYPE_TB
  zh: '| 签名“EFI PART” | 0x00 | 8字节 |'
- en: '| Revision for GPT version | 0x08 | 4 bytes |'
  id: totrans-67
  prefs: []
  type: TYPE_TB
  zh: '| GPT版本的修订号 | 0x08 | 4字节 |'
- en: '| Header size | 0x0C | 4 bytes |'
  id: totrans-68
  prefs: []
  type: TYPE_TB
  zh: '| 头部大小 | 0x0C | 4字节 |'
- en: '| CRC32 of header | 0x10 | 4 bytes |'
  id: totrans-69
  prefs: []
  type: TYPE_TB
  zh: '| 头部的CRC32 | 0x10 | 4字节 |'
- en: '| Reserved | 0x14 | 4 bytes |'
  id: totrans-70
  prefs: []
  type: TYPE_TB
- en: '| Current LBA (logical block addressing) | 0x18 | 8 bytes |'
  id: totrans-71
  prefs: []
  type: TYPE_TB
- en: '| Backup LBA | 0x20 | 8 bytes |'
  id: totrans-72
  prefs: []
  type: TYPE_TB
- en: '| First usable LBA for partitions | 0x28 | 8 bytes |'
  id: totrans-73
  prefs: []
  type: TYPE_TB
- en: '| Last usable LBA | 0x30 | 8 bytes |'
  id: totrans-74
  prefs: []
  type: TYPE_TB
- en: '| Disk GUID | 0x38 | 16 bytes |'
  id: totrans-75
  prefs: []
  type: TYPE_TB
- en: '| Starting LBA of array of partition entries | 0x48 | 8 bytes |'
  id: totrans-76
  prefs: []
  type: TYPE_TB
- en: '| Number of partition entries in array | 0x50 | 4 bytes |'
  id: totrans-77
  prefs: []
  type: TYPE_TB
- en: '| Size of a single partition entry | 0x54 | 4 bytes |'
  id: totrans-78
  prefs: []
  type: TYPE_TB
- en: '| CRC32 of partition array | 0x58 | 4 bytes |'
  id: totrans-79
  prefs: []
  type: TYPE_TB
- en: '| Reserved | 0x5C | * |'
  id: totrans-80
  prefs: []
  type: TYPE_TB
- en: As you can see, the GPT header contains only constant fields rather than code.
    From a forensic perspective, the most important of these fields are *Starting
    LBA of array of partition entries* and the *Number of partition entries in array*.
    These entries define the location and size of the partition table on the hard
    drive, respectively.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
- en: Another interesting field in the GPT header is *Backup LBA*, which provides
    the location of a backup copy of the GPT header. This allows you to recover the
    primary GPT header in case it becomes corrupted. We touched upon the backup GPT
    header in [Chapter 13](ch13.xhtml#ch13) when we discussed the Petya ransomware,
    which encrypted both the primary and backup GPT headers to make system recovery
    more difficult.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
- en: As shown in [Figure 14-4](ch14.xhtml#ch14fig04), each entry in the partition
    table provides information on the properties and location of a partition on the
    hard drive.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/14fig04.jpg)'
  id: totrans-84
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-4: GUID Partition Table*'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
- en: 'The two 64-bit fields *First LBA* and *Last LBA* define the address of the
    very first and last sectors of a partition, respectively. The *Partition type
    GUID* field contains a GUID value that identifies the type of the partition. For
    instance, for the EFI system partition mentioned earlier in “[Disk Partitioning:
    MBR vs. GPT](ch14.xhtml#ch14lev2sec2)” on [page 235](ch14.xhtml#page_235), the
    type is *C12A7328-F81F-11D2-BA4B-00A0C93EC93B.*'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
- en: 'The absence of any executable code from the GPT scheme presents a problem for
    bootkit infections: how can malware developers transfer control of the boot process
    to their malicious code in the GPT scheme? One idea is to modify EFI bootloaders
    before they transfer control to the OS kernel. Before we explore this, though,
    we’ll look at the basics of the UEFI firmware architecture and boot process.'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
- en: '**PARSING A GPT DRIVE WITH SWEETSCAPE**'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
- en: To parse the fields of a GPT drive on a live machine or in a dumped partition,
    you can use the shareware SweetScape 010 Editor (*[https://www.sweetscape.com](https://www.sweetscape.com)*)
    with the `Drive.bt` template by Benjamin Vernoux, found on the SweetScape site
    in the *Templates* repository in the Downloads section. The 010 Editor has a really
    powerful template-based parsing engine based on C-like structures (see [Figure
    14-3](ch14.xhtml#ch14fig03)).
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
- en: '**How UEFI Firmware Works**'
  id: totrans-90
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Having explored the GPT partitioning scheme, we now understand where the OS
    bootloader is located and how the UEFI firmware finds it on the hard drive. Next,
    let’s look at how the UEFI firmware loads and executes the OS loader. We’ll provide
    background information on the stages the UEFI boot process goes through in order
    to prepare the environment for executing the loader.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在探讨了 GPT 分区方案之后，我们现在了解了操作系统引导加载程序的位置以及 UEFI 固件如何在硬盘上找到它。接下来，让我们看看 UEFI 固件是如何加载和执行操作系统加载器的。我们将提供有关
    UEFI 引导过程各个阶段的背景信息，以便为执行加载器做好环境准备。
- en: 'The UEFI firmware, which interprets the aforementioned data structures in the
    GPT table to locate OS loader, is stored on a motherboard’s flash chip (also known
    as the *SPI flash*, where “SPI” refers to the bus interface that connects the
    chip to the rest of the chipset). When the system starts up, the chipset logic
    maps the contents of the flash chip’s memory onto a specific RAM region, whose
    start and end addresses are configured in the hardware chipset itself and depend
    on CPU-specific configuration. Once the mapped SPI flash chip code receives control
    upon power-on, it initializes the hardware and loads various drivers, the OS boot
    manager, the OS loader, and then finally the OS kernel itself. The steps of this
    sequence can be summarized as follows:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: UEFI 固件通过解释 GPT 表中的上述数据结构来定位操作系统加载器，存储在主板的闪存芯片中（也称为 *SPI flash*，其中“SPI”指的是将芯片与其他芯片组连接的总线接口）。当系统启动时，芯片组逻辑将闪存芯片的内存映射到特定的
    RAM 区域，该区域的起始和结束地址在硬件芯片组中进行配置，并依赖于特定 CPU 的配置。一旦映射的 SPI 闪存芯片代码在开机时获得控制，它会初始化硬件并加载各种驱动程序、操作系统引导管理器、操作系统加载器，最后是操作系统内核。此过程的步骤可以总结如下：
- en: The UEFI firmware performs UEFI platform initialization, performs CPU and chipset
    initialization, and loads UEFI platform modules (aka UEFI drivers; these are distinct
    from the device-specific code loaded in the next step).
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: UEFI 固件执行 UEFI 平台初始化，执行 CPU 和芯片组初始化，并加载 UEFI 平台模块（也称为 UEFI 驱动程序；这些与下一步加载的设备特定代码不同）。
- en: The UEFI boot manager enumerates devices on the external buses (such as the
    PCI bus), loads UEFI device drivers, and then loads the boot application.
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: UEFI 引导管理器列举外部总线（如 PCI 总线）上的设备，加载 UEFI 设备驱动程序，然后加载引导应用程序。
- en: The Windows Boot Manager (*bootmgfw.efi*) loads the Windows Boot Loader.
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Windows 引导管理器（*bootmgfw.efi*）加载 Windows 引导加载程序。
- en: The Windows Boot Loader (*winload.efi*) loads the Windows OS.
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Windows 引导加载程序（*winload.efi*）加载 Windows 操作系统。
- en: The code responsible for steps 1 and 2 resides on the SPI flash; the code for
    steps 3 and 4 is extracted from the filesystem in the special UEFI partition of
    the hard drive, once 1 and 2 have made it possible to read the hard drive. The
    UEFI specification further divides the firmware into components responsible for
    the different parts of hardware initialization or boot process activity, as illustrated
    in [Figure 14-5](ch14.xhtml#ch14fig05).
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 步骤 1 和 2 所需的代码驻留在 SPI 闪存中；步骤 3 和 4 的代码从硬盘上的特殊 UEFI 分区的文件系统中提取，一旦步骤 1 和 2 使得硬盘可读。UEFI
    规范进一步将固件划分为不同部分，负责硬件初始化或引导过程中的活动，如 [图 14-5](ch14.xhtml#ch14fig05) 所示。
- en: The OS loader essentially relies on the EFI boot services and EFI runtime services
    provided by the UEFI firmware to boot and manage the system. As we’ll explain
    in “[Inside the Operating System Loader](ch14.xhtml#ch14lev2sec5)” on [page 245](ch14.xhtml#page_245),
    the OS loader relies on these services to establish an environment in which it
    can load the OS kernel. Once the OS loader takes control of the boot flow from
    the UEFI firmware, the boot services are removed and no longer available to the
    operating system. Runtime services, however, do remain available to the operating
    system at runtime and provide an interface for reading and writing NVRAM UEFI
    variables, performing firmware updates (via *Capsule Update*), and rebooting or
    shutting down the system.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 操作系统加载器本质上依赖于 UEFI 固件提供的 EFI 引导服务和 EFI 运行时服务来引导和管理系统。正如我们将在 “[操作系统加载器内部](ch14.xhtml#ch14lev2sec5)”
    的 [第 245 页](ch14.xhtml#page_245) 中解释的那样，操作系统加载器依赖这些服务来建立一个能够加载操作系统内核的环境。一旦操作系统加载器从
    UEFI 固件接管了引导流程，引导服务就被移除，并且操作系统将无法再访问它们。然而，运行时服务在操作系统运行时仍然可用，并提供一个接口，用于读取和写入 NVRAM
    UEFI 变量、执行固件更新（通过 *Capsule Update*）以及重新启动或关闭系统。
- en: '![image](../images/14fig05.jpg)'
  id: totrans-99
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/14fig05.jpg)'
- en: '*Figure 14-5: The UEFI framework overview*'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 14-5：UEFI 框架概览*'
- en: '**FIRMWARE CAPSULE UPDATE**'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '**固件 Capsule 更新**'
- en: Capsule Update is a technology for securely updating UEFI firmware. The operating
    system loads the capsule firmware update image into memory and signals to the
    UEFI firmware, via a runtime service, that the capsule is present. As a result,
    the UEFI firmware reboots the system and processes the update capsule upon the
    next boot. Capsule Update attempts to standardize and improve the security of
    the UEFI firmware update process. We’ll discuss it in more depth in [Chapter 15](ch15.xhtml#ch15).
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: Capsule Update 是一种用于安全更新 UEFI 固件的技术。操作系统将 Capsule 固件更新镜像加载到内存中，并通过运行时服务向 UEFI
    固件发出信号，表示 Capsule 已经存在。结果，UEFI 固件在下次启动时重启系统并处理更新 Capsule。Capsule Update 力求标准化并提高
    UEFI 固件更新过程的安全性。我们将在[第15章](ch15.xhtml#ch15)中深入讨论。
- en: '***The UEFI Specification***'
  id: totrans-103
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***UEFI 规范***'
- en: 'In contrast to the legacy BIOS boot, the UEFI specification covers every step
    from the beginning of hardware initialization onward. Before this specification,
    hardware vendors had more freedom in the firmware development process, but this
    freedom also allowed for confusion and, hence, vulnerabilities. The specification
    outlines four main consecutive stages of the boot process, each with its own responsibilities:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 与传统的 BIOS 启动方式相比，UEFI 规范涵盖了从硬件初始化开始的每个步骤。在此规范之前，硬件厂商在固件开发过程中有更多自由，但这种自由也带来了混乱，因此也存在漏洞。该规范概述了启动过程的四个主要连续阶段，每个阶段都有自己的职责：
- en: '**Security (SEC)** Initializes temporary memory using CPU caches and locates
    the loader for the PEI phase. Code executed at the SEC phase runs from SPI flash
    memory.'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '**安全 (SEC)** 使用 CPU 缓存初始化临时内存，并为 PEI 阶段定位加载程序。在 SEC 阶段执行的代码来自 SPI 闪存内存。'
- en: '**Pre-EFI Initialization (PEI)** Configures the memory controller, initializes
    the chipset, and handles the S3 resume process. Code executed at this phase runs
    in temporary memory until the memory controller is initialized. Once this is done,
    the PEI code is executed from the permanent memory.'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '**预 EFI 初始化 (PEI)** 配置内存控制器，初始化芯片组，并处理 S3 恢复过程。在此阶段执行的代码在临时内存中运行，直到内存控制器初始化完成。一旦完成，PEI
    代码将从永久内存中执行。'
- en: '**Driver Execution Environment (DXE)** Initializes System Management Mode (SMM)
    and DXE services (the core, dispatcher, drivers, and so forth), as well as the
    boot and runtime services.'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '**驱动执行环境 (DXE)** 初始化系统管理模式 (SMM) 和 DXE 服务（核心、调度器、驱动程序等），以及启动和运行时服务。'
- en: '**Boot Device Selection (BDS)** Discovers the hardware device from which the
    OS can be booted, for example, by enumerating peripheral devices on the PCI bus
    that may contain a UEFI-compatible bootloader (such as an OS loader).'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '**启动设备选择 (BDS)** 发现操作系统可以从中启动的硬件设备，例如，通过枚举可能包含 UEFI 兼容启动加载程序（如操作系统加载程序）的 PCI
    总线上的外部设备。'
- en: All of the components used in the boot process reside on the SPI flash, except
    for the OS loader, which resides in the disk’s filesystem and is found by the
    SPI flash–based DXE/BDS-phase code via a filesystem path stored in an NVRAM UEFI
    variable (as discussed earlier).
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 除了操作系统加载程序（位于磁盘文件系统中，并通过基于 SPI 闪存的 DXE/BDS 阶段代码通过存储在 NVRAM UEFI 变量中的文件系统路径找到）外，启动过程中使用的所有组件都位于
    SPI 闪存中。
- en: The SMM and DXE initialization stages are some of the most interesting areas
    for implanting rootkits. The SMM, at ring –2, is the most privileged system mode—more
    privileged than hypervisors at ring –1\. (See the “[System Management Mode](ch14.xhtml#ch14sb01)”
    box for more on SMM and the ring privilege levels.) From this mode, malicious
    code can exercise full control of the system.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: SMM 和 DXE 初始化阶段是植入 rootkit 的最有趣的领域之一。SMM 处于环 –2，是最特权的系统模式——比环 –1 的虚拟机监控器更具特权。（有关
    SMM 和环特权级别的更多信息，请参见 “[系统管理模式](ch14.xhtml#ch14sb01)”框。）从这个模式下，恶意代码可以完全控制系统。
- en: Similarly, DXE drivers offer another powerful point for implementing bootkit
    functionality. A good example of DXE-based malware is Hacking Team’s firmware
    rootkit implementation, discussed in [Chapter 15](ch15.xhtml#ch15).
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，DXE 驱动程序为实现启动病毒功能提供了另一个强大的手段。一个典型的 DXE 基础恶意软件例子是 Hacking Team 的固件 rootkit
    实现，详见[第15章](ch15.xhtml#ch15)。
- en: '**SYSTEM MANAGEMENT MODE**'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '**系统管理模式**'
- en: System Management Mode is a special mode of the x86 CPUs, executed with special
    higher “ring –2” privileges (that’s “minus two,” which is lower and more powerful
    than “ring –1,” which in turn is more powerful than “ring 0,” historically the
    most trusted privilege—isn’t it lucky that we have an infinite supply of integers
    less than zero?). SMM was introduced in Intel 386 processors primarily as a means
    of aiding power management, but it has grown in both complexity and importance
    in modern CPUs. SMM is now an integral part of the firmware, responsible for all
    initialization and memory separation setup in the boot process. SMM’s code executes
    in a separate address space meant to be isolated from the normal operating system
    address space layout (including the OS kernel space). In [Chapters 15](ch15.xhtml#ch15)
    and [16](ch16.xhtml#ch16), we’ll focus more on how UEFI rootkits leverage SMM.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 系统管理模式（SMM）是x86 CPU的一种特殊模式，以特殊的更高“环 –2”权限执行（即“负二”，比“环 –1”更低且更强大，而“环 0”则是历史上最可信的权限——幸运的是，我们有无限多小于零的整数可用！）。SMM最初在Intel
    386处理器中作为一种帮助电源管理的手段引入，但在现代CPU中，SMM的复杂性和重要性大大增加。现在，SMM已经成为固件的一个组成部分，负责启动过程中的所有初始化和内存分离设置。SMM的代码在一个独立的地址空间中执行，该地址空间应与正常操作系统地址空间布局（包括操作系统内核空间）隔离。在[第15章](ch15.xhtml#ch15)和[第16章](ch16.xhtml#ch16)中，我们将更多地探讨UEFI根套件如何利用SMM。
- en: We’ll now explore this last stage and the process through which the operating
    system kernel receives control. We’ll go into more detail about DXE and SMM in
    the next chapter.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将探讨最后阶段以及操作系统内核如何获得控制权的过程。在下一章中，我们将更详细地讨论DXE和SMM。
- en: '***Inside the Operating System Loader***'
  id: totrans-115
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***操作系统加载程序内部***'
- en: Now that the SPI-stored UEFI firmware code has done its work, it passes control
    to the OS loader stored on disk. The loader code is also 64-bit or 32-bit (depending
    on the operating system version); there’s no place for the MBR’s or VBR’s 16-bit
    loader code in the boot process.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，存储在SPI中的UEFI固件代码已经完成它的工作，它将控制权交给存储在磁盘上的操作系统加载程序。加载程序代码也是64位或32位（取决于操作系统版本）；MBR或VBR的16位加载程序代码在启动过程中没有位置。
- en: The OS loader consists of several files stored in the EFI system partition,
    including the modules *bootmgfw.efi* and *winload.efi*. The first is referred
    to as the *Windows Boot Manager* and the second as the *Windows Boot Loader*.
    The location of these modules is also specified by NVRAM variables. In particular,
    the UEFI path of the drive (defined by how the UEFI standard enumerates the ports
    and buses of a motherboard) containing the ESP is stored in the boot order NVRAM
    variable `BOOT_ORDER` (which the user usually can change via BIOS configuration);
    the path within the ESP’s filesystem is stored in another variable, `BOOT` (which
    is typically in *\EFI\Microsoft\Boot\*).
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 操作系统加载程序由存储在EFI系统分区中的多个文件组成，包括模块*bootmgfw.efi*和*winload.efi*。第一个被称为*Windows启动管理器*，第二个被称为*Windows启动加载程序*。这些模块的位置也由NVRAM变量指定。特别地，包含ESP的驱动器的UEFI路径（由UEFI标准如何枚举主板的端口和总线定义）存储在启动顺序NVRAM变量`BOOT_ORDER`中（用户通常可以通过BIOS配置更改）；ESP文件系统中的路径存储在另一个变量`BOOT`中（通常位于*\\EFI\\Microsoft\\Boot\\*）。
- en: '**Accessing the Windows Boot Manager**'
  id: totrans-118
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**访问Windows启动管理器**'
- en: The UEFI firmware boot manager consults the NVRAM UEFI variables to find the
    ESP and then, in the case of Windows, the OS-specific boot manager *bootmgfw.efi*
    inside it. The boot manager then creates a runtime image of this file in memory.
    To do so, it relies on the UEFI firmware to read the startup hard drive and parse
    its filesystem. Under a different OS, the NVRAM variable would contain a path
    to that OS’s loader; for example, for Linux it points to the GRUB bootloader (*grub.efi*).
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: UEFI固件启动管理器会查阅NVRAM UEFI变量以查找ESP，然后在Windows的情况下，查找其中的操作系统特定启动管理器*bootmgfw.efi*。启动管理器随后在内存中创建此文件的运行时镜像。为此，它依赖UEFI固件读取启动硬盘并解析其文件系统。在其他操作系统下，NVRAM变量会包含指向该操作系统加载程序的路径；例如，对于Linux，它指向GRUB启动加载程序（*grub.efi*）。
- en: Once *bootmgfw.efi* is loaded, the UEFI firmware boot manager jumps to the entry
    point of *bootmgfw.efi*, `EfiEntry`. This is the start of the OS boot process,
    at which point the SPI flash–stored firmware gives control to code stored on the
    hard disk.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦*bootmgfw.efi*被加载，UEFI固件启动管理器会跳转到*bootmgfw.efi*的入口点`EfiEntry`。这是操作系统启动过程的开始，此时存储在SPI闪存中的固件将控制权交给硬盘上的代码。
- en: '**Establishing an Execution Environment**'
  id: totrans-121
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**建立执行环境**'
- en: The `EfiEntry` entry, the prototype of which is shown in [Listing 14-2](ch14.xhtml#ch14list02),
    calls the Windows Boot Manager, *bootmgfw.efi*, and is used to configure the UEFI
    firmware callbacks for the Windows Boot Loader, *winload.efi*, which is called
    right after it. These callbacks connect *winload.efi* code with the UEFI firmware
    runtime services, which it needs for operations on peripherals, like reading the
    hard drive. These services will continue to be used by Windows even when it’s
    fully loaded, via hardware abstraction layer (HAL) wrappers, which we’ll see being
    set up shortly.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '*Listing 14-2: Prototype of the `EfiEntry` routine (`EFI_IMAGE_ENTRY_POINT`)*'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
- en: The first parameter of `EfiEntry` ➊ points to the *bootmgfw.efi* module that
    is responsible for continuing the boot process and calling *winload.efi*. The
    second parameter ➋ contains the pointer to the UEFI configuration table (`EFI_SYSTEM_TABLE`),
    which is the key to accessing most of an EFI environment service’s configuration
    data ([Figure 14-6](ch14.xhtml#ch14fig06)).
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/14fig06.jpg)'
  id: totrans-126
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-6: `EFI_SYSTEM_TABLE` high-level structure*'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
- en: The *winload.efi* loader uses UEFI services to load the operating system kernel
    with the boot device driver stack and to initialize `EFI_RUNTIME_TABLE` in the
    kernel space for future access by the kernel through the HAL library code module
    (*hal.dll*). HAL consumes the `EFI_SYSTEM_TABLE` and exports the functions that
    wrap the UEFI runtime functions to the rest of the kernel. The kernel calls these
    functions to perform tasks like reading the NVRAM variables and handling BIOS
    updates via the so-called Capsule Update handed to the UEFI firmware.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
- en: Note the pattern of multiple wrappings created over the UEFI hardware-specific
    code configured at the earliest stages of boot by each subsequent layer. You never
    know how deep into the UEFI rabbit hole an OS system call might go!
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
- en: The structure of the `EFI_RUNTIME_SERVICES` used by the HAL module *hal.dll*
    is shown in [Figure 14-7](ch14.xhtml#ch14fig07).
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/14fig07.jpg)'
  id: totrans-131
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-7: `EFI_RUNTIME_SERVICES` in* hal.dll*’s representation*'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
- en: '`HalEfiRuntimeServiceTable` holds a pointer to `EFI_RUNTIME_SERVICES`, which
    in turn contains the addresses of entry points of service routines that will do
    things like get or set the NVRAM variable, perform a Capsule Update, and so on.'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapters, we’ll analyze these structures in the context of firmware
    vulnerabilities, exploitation, and rootkits. For now, we simply want to stress
    that `EFI_SYSTEM_TABLE` and (especially) `EFI_RUNTIME_SERVICES` within it are
    the keys to finding the structures responsible for accessing UEFI configuration
    information and that some of this information is accessible from the kernel mode
    of the operating system.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 14-8](ch14.xhtml#ch14fig08) shows the disassembled `EfiEntry` routine.
    One of its first instructions triggers a call to the function `EfiInitCreateInputParametersEx()`,
    which converts the `EfiEntry` parameters to the format expected by *bootmgfw.efi*.
    Inside `EfiInitCreateInputParametersEx()`, a routine called `EfiInitpCreateApplicationEntry()`
    creates an entry for the *bootmgfw.efi* in the Boot Configuration Data (BCD),
    a binary storage of configuration parameters for a Windows bootloader. After `EfiInitCreateInputParametersEx()`
    returns, the `BmMain` routine (highlighted in [Figure 14-8](ch14.xhtml#ch14fig08))
    receives control. Note that at this point, to properly access hardware device
    operations, including any hard drive input and output, and to initialize memory,
    the Windows Boot Manager must use only EFI services, as the main Windows driver
    stacks are not yet loaded and thus are unavailable.'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/14fig08.jpg)'
  id: totrans-136
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-8: Disassembled `EfiEntry` routine*'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
- en: '**Reading the Boot Configuration Data**'
  id: totrans-138
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'As the next step, `BmMain` calls the following routines:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
- en: BmFwInitializeBootDirectoryPath Routine used to initialize the boot application’s
    path (*\EFI\Microsoft\Boot*)
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
- en: BmOpenDataStore Routine used to mount and read the BCD database file (*\EFI\Microsoft\Boot\BCD*)
    via UEFI services (disk I/O)
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
- en: BmpLaunchBootEntry **and** ImgArchEfiStartBootApplication Routines used to execute
    boot application (*winload.efi*)
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 14-3](ch14.xhtml#ch14list03) shows Boot Configuration Data as output
    by the standard command line tool *bcdedit.exe*, which is included in all recent
    versions of Microsoft Windows. The paths to the Windows Boot Manager and Windows
    Boot Loader modules are marked with ➊ and ➋ respectively.'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '*Listing 14-3: Output from the `bcdedit` console command*'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
- en: The Windows Boot Manager (*bootmgfw.efi*) is also responsible for the boot policy
    verification and for the initialization of the Code Integrity and Secure Boot
    components, covered in the following chapters.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
- en: At the next stage of the boot process, *bootmgfw.efi* loads and verifies the
    Windows Boot Loader (*winload.efi*). Before starting to load *winload.efi*, the
    Windows Boot Manager initializes the memory map for transition to the protected
    memory mode, which provides both virtual memory and paging. Importantly, it performs
    this setup via UEFI runtime services rather than directly. This creates a strong
    layer of abstraction for the OS virtual memory data structures, such as the GDT,
    which were previously handled by a legacy BIOS in 16-bit assembly code.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
- en: '**Transferring Control to Winload**'
  id: totrans-148
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: In the final stage of the Windows Boot Manager, the `BmpLaunchBootEntry()` routine
    loads and executes *winload.efi*, the Windows Boot Loader. [Figure 14-9](ch14.xhtml#ch14fig09)
    presents the complete call graph from `EfiEntry()` to `BmpLaunchBootEntry()`,
    as generated by the Hex-Rays IDA Pro disassembler with the IDAPathFinder script
    (*[http://www.devttys0.com/tools/](http://www.devttys0.com/tools/)*).
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/14fig09.jpg)'
  id: totrans-150
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-9: Call graph flow from `EfiEntry()` to `BmpLaunchBootEntry()`*'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
- en: The control flow preceding the `BmpLaunchBootEntry()` function chooses the right
    boot entry, based on the values from the BCD store. If Full Volume Encryption
    (BitLocker) is enabled, the Boot Manager decrypts the system partition before
    it can transfer control to the Boot Loader. The `BmpLaunchBootEntry()` function
    followed by `BmpTransferExecution()` checks the boot options and passes execution
    to `BlImgLoadBootApplication()`, which then calls `ImgArchEfiStartBootApplication()`.
    The `ImgArchEfiStartBootApplication()` routine is responsible for initializing
    the protected memory mode for *winload.efi*. After that, control is passed to
    the function `Archpx64TransferTo64BitApplicationAsm()`, which finalizes the preparation
    for starting *winload.efi* ([Figure 14-10](ch14.xhtml#ch14fig10)).
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/14fig10.jpg)'
  id: totrans-153
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-10: Call graph flow from `BmpLaunchBootEntry()` to `Archpx64TransferTo64BitApplicationAsm()`*'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
- en: After this crucial point, all execution flow is transferred to *winload.efi*,
    which is responsible for loading and initializing the Windows kernel. Prior to
    this moment, execution happens in the UEFI environment over boot services and
    operates under the flat physical memory model.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
- en: '*If Secure Boot is disabled, malicious code can make any memory modifications
    at this stage of the boot process, because kernel-mode modules are not yet protected
    by the Windows Kernel Patch Protection (KPP) technology (also known as PatchGuard).
    PatchGuard will initialize only in the later steps of the boot process. Once PatchGuard
    is activated, though, it will make malicious modifications of kernel modules much
    harder.*'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
- en: '***The Windows Boot Loader***'
  id: totrans-158
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The Windows Boot Loader performs the following configuration actions:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
- en: Initializes the kernel debugger if the OS boots in debug mode (including the
    hypervisor debug mode).
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Wraps UEFI Boot Services into HAL abstractions for later use by the Windows
    kernel-mode code and calls Exit Boot Services.
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Checks the CPU for the Hyper-V hypervisor support features and sets them up
    if supported.
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Checks for Virtual Secure Mode (VSM) and DeviceGuard policies (Windows 10 only).
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Runs integrity checks on the kernel itself and on the Windows components, then
    transfers control to the kernel.
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Windows Boot Loader starts execution from the `OslMain()` routine, as shown
    in [Listing 14-4](ch14.xhtml#ch14list04), which performs all the previously described
    actions.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '*Listing 14-4: The decompiled `OslMain()` function (Windows 10)*'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
- en: The Windows Boot Loader starts with configuring the kernel memory address space
    by calling the `OslBuildKernelMemoryMap()` function ([Figure 14-11](ch14.xhtml#ch14fig11)).
    Next, it prepares for loading the kernel with the call to the `OslFwpKernelSetupPhase1()`
    function ➊. The `OslFwpKernelSetupPhase1()` function calls `EfiGetMemoryMap()`
    to get the pointer to the `EFI_BOOT_SERVICE` structure configured earlier, and
    then stores it in a global variable for future operations from kernel mode, via
    the HAL services.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/14fig11.jpg)'
  id: totrans-169
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-11: Call graph flow from `OslMain()` to `OslBuildKernelMemoryMap()`*'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
- en: After that, the `OslFwpKernelSetupPhase1()` routine calls the EFI function `ExitBootServices()`.
    This function notifies the operating system that it is about to receive full control;
    this callback allows for making any last-minute configurations before jumping
    into the kernel.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
- en: The VSM boot policy checks are implemented in the routine `BlVsmCheckSystemPolicy`
    ➋ ➌, which checks the environment against the Secure Boot policy and reads the
    UEFI variable `VbsPolicy` into memory, filling the `BlVsmpSystemPolicy` structure
    in memory.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
- en: Finally, execution flow reaches the operating system kernel (which in our case
    is the *ntoskrnl.exe* image) ➍ via `OslArchTransferToKernel()` ([Listing 14-5](ch14.xhtml#ch14list05)).
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '*Listing 14-5: Disassembled `OslArchTransferToKernel()` function*'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
- en: This function has been mentioned in previous chapters, because some bootkits
    (such as Gapz) hook it to insert their own hooks into the kernel image.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
- en: '***Security Benefits of UEFI Firmware***'
  id: totrans-177
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: As we’ve seen, legacy MBR- and VBR-based bootkits are unable to get control
    of the UEFI booting scheme, since the bootstrap code they infect is no longer
    executed in the UFEI boot process flow. Yet the biggest security impact of UEFI
    is due to its support for Secure Boot technology. Secure Boot changes the rootkit
    and bootkit infection game, because it prevents attackers from modifying any pre-OS
    boot components—that is, unless they find a way to bypass Secure Boot.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
- en: Moreover, the recent Boot Guard technology released by Intel marks another step
    in the evolution of Secure Boot. Boot Guard is a hardware-based integrity protection
    technology that attempts to protect the system even before Secure Boot starts.
    In a nutshell, Boot Guard allows a platform vendor to install cryptographic keys
    that maintain the integrity of Secure Boot.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
- en: Another recent technology delivered since Intel’s Skylake CPU (a generation
    of the Intel CPU) release is BIOS Guard, which armors platforms against firmware
    flash storage modifications. Even if an attacker gains access to flash memory,
    BIOS Guard can protect it from the installation of a malicious implant, thereby
    also preventing execution of malicious code at boot time.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
- en: These security technologies directly influenced the direction of modern bootkits,
    forcing malware developers to evolve their approaches in order to contend with
    these defenses.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
- en: '**Conclusion**'
  id: totrans-182
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The switch of modern PCs to UEFI firmware since Microsoft Windows 7 was a first
    step to changing the boot process flow and reshaping the bootkit ecology. The
    methods that relied on legacy BIOS interrupts for transferring control to malicious
    code became obsolete, as such structures disappeared from systems booting through
    UEFI.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
- en: Secure Boot technology completely changed the game, because it was no longer
    possible to directly modify the bootloader components such as *bootmgfw.efi* and
    *winload.efi*.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
- en: Now all boot process flow is trusted and verified from firmware with hardware
    support. Attackers need to go deeper into firmware to search out and exploit BIOS
    vulnerabilities to bypass these UEFI security features. [Chapter 16](ch16.xhtml#ch16)
    will provide an overview of the modern BIOS vulnerabilities landscape, but first,
    [Chapter 15](ch15.xhtml#ch15) will touch upon the evolution of rootkit and bootkit
    threats in light of firmware attacks.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
