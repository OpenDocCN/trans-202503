- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">1</samp> <samp class="SANS_Dogma_OT_Bold_B_11">MEET
    THE FPGA</samp>
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">1</samp> <samp class="SANS_Dogma_OT_Bold_B_11">认识FPGA</samp>
- en: '![](../images/opener-img.png)'
  id: totrans-1
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/opener-img.png)'
- en: An *FPGA*, short for *field programmable gate array*, is a highly capable type
    of *integrated circuit*, an electronic circuit in a single package. The *field
    programmable* part of the name indicates that FPGAs can be reprogrammed when in
    the field (that is, without having to return them to the manufacturer). The *gate
    array* part indicates that an FPGA is made up of a two-dimensional grid featuring
    a large number of gates, fundamental units of digital logic that we’ll discuss
    in depth in [Chapter 3](chapter3.xhtml).
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: '*FPGA*，全称*现场可编程门阵列*，是一种高度强大的*集成电路*，是一种将电子电路集成在一个封装中的技术。名称中的*现场可编程*部分意味着FPGA可以在现场重新编程（即无需返回给制造商）。*门阵列*部分表明FPGA是由一个二维网格组成，网格内包含大量的门，这些门是数字逻辑的基本单元，我们将在[第3章](chapter3.xhtml)中深入讨论。'
- en: 'The name is actually a bit of an anachronism. The reality is that some FPGAs
    aren’t field programmable, and most are no longer just an array of simple gates.
    In fact, they’re much more sophisticated than that. Despite these exceptions,
    the name has stuck over the years, and it highlights a unique characteristic of
    FPGAs: their incredible flexibility. An FPGA’s uses are limited only by the designer’s
    imagination. Other digital programmable devices, such as microcontrollers, are
    designed with a specific set of capabilities; you can only do something if that
    feature is built in. By contrast, an FPGA’s array of gates (or the more modern
    equivalent) is like a blank slate that you can program, and reprogram, and reprogram
    to do almost anything you want, with fewer restrictions. This freedom doesn’t
    come without trade-offs, however, and FPGA development demands a unique set of
    skills.'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 这个名称实际上有些过时。事实上，有些FPGA并不是现场可编程的，而且大多数FPGA也不再仅仅是简单的门阵列。实际上，它们比这复杂得多。尽管有这些例外，FPGA的名称还是沿用了多年，而且它突出了FPGA的一个独特特性：它们的惊人灵活性。FPGA的用途仅受设计师想象力的限制。其他数字可编程设备，如微控制器，通常是根据特定功能设计的；你只能做那些已经内建的功能。相比之下，FPGA的门阵列（或更现代的等效物）就像一块白纸，你可以编程、重新编程、再编程，使其做几乎任何你想做的事情，且限制较少。然而，这种自由也不是没有代价的，FPGA开发需要一套独特的技能。
- en: 'Learning how to work with FPGAs requires a different style of thinking from
    traditional computer programming. Traditional software engineering, like programming
    in C, for example, is serial: first this happens, then this happens, and finally
    this happens. This is because C is compiled to run on a single processor, or CPU,
    and that CPU is a serial machine. It processes one instruction at a time.'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 学习如何使用FPGA需要一种与传统计算机编程不同的思维方式。例如，传统的软件工程（如C语言编程）是串行的：先发生这个，然后发生那个，最后发生那个。这是因为C语言是编译后在单一处理器或CPU上运行的，而该CPU是一个串行机器，它一次处理一条指令。
- en: 'FPGAs, on the other hand, work in parallel: everything is happening at the
    same time. Understanding the difference between serial and parallel programming
    is fundamental to working with FPGAs. When you can think about solving a problem
    using parallel methods, your overall problem-solving skills will increase. These
    skills will also translate to other, non-FPGA applications; you’ll begin to see
    problems differently than if you were only thinking about them serially. Learning
    how to think in parallel rather than serially is a critical skill for becoming
    an FPGA engineer, and it’s one you’ll develop throughout this book.'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: FPGA与传统的计算机处理器不同，它们是并行工作的：所有的操作同时进行。理解串行编程与并行编程的区别，对于使用FPGA至关重要。当你能够用并行方法来解决问题时，你的整体问题解决能力将得到提升。这些技能也会应用到其他非FPGA的场景中；你会开始以不同的方式看待问题，而不仅仅是以串行的思维去思考。学习如何用并行思维而非串行思维来解决问题，是成为一名FPGA工程师的关键技能，而且你将在本书中不断地培养这一技能。
- en: 'FPGAs are a lot of fun to work with. When you create an FPGA design using Verilog
    or VHDL (more on these languages later in this chapter), you’re writing code at
    the lowest possible level. You’re literally creating the physical connections,
    the actual wires, between electrical components and input/output pins on your
    device. This allows you to solve almost any digital problem: you have complete
    control. It’s a much lower level of programming than working with a microcontroller
    that has a processor, for example. For this reason, learning about FPGAs is an
    excellent way to become familiar with hardware programming techniques and better
    understand how exactly digital logic works in other applications. You’ll gain
    a newfound respect for the complexities of even the simplest integrated circuits
    once you start working with FPGAs.'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: FPGA 设计非常有趣。当你使用 Verilog 或 VHDL 创建 FPGA 设计时（关于这些语言将在本章后续部分介绍），你是在最低层次编写代码。你实际上是在创建电气组件之间、设备的输入/输出引脚之间的物理连接，真正的电线。这使你能够解决几乎所有数字问题：你拥有完全的控制权。这种编程方式远比使用具有处理器的微控制器要低级。例如，学习
    FPGA 是熟悉硬件编程技术的一个极好方法，同时也有助于更好地理解数字逻辑在其他应用中的工作原理。一旦你开始使用 FPGA，你会对即使是最简单的集成电路的复杂性产生新的敬意。
- en: This first chapter sets you up for diving deeper into FPGAs by providing some
    background information. We’ll briefly cover the history of FPGAs, from their initial
    creation in the 1980s through today, and explore some of their common uses. We’ll
    also consider how FPGAs compare to other common digital components, such as microcontrollers
    and application-specific integrated circuits (ASICs). Finally, we’ll discuss the
    differences between Verilog and VHDL, the two most popular languages for working
    with FPGAs.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 本章通过提供一些背景信息，为你深入了解 FPGA 打下基础。我们将简要回顾 FPGA 的历史，从1980年代的初次诞生到今天，并探讨一些常见的应用。我们还将比较
    FPGA 与其他常见数字组件的异同，例如微控制器和应用特定集成电路（ASIC）。最后，我们将讨论 Verilog 和 VHDL 这两种用于 FPGA 编程的主流语言之间的差异。
- en: <samp class="SANS_Futura_Std_Bold_B_11">A Brief History of FPGAs</samp>
  id: totrans-8
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">FPGA 的简短历史</samp>
- en: The very first FPGA was the XC2064, created by Xilinx in 1985\. It was very
    primitive, with a measly 800 gates, a fraction compared to the millions of gate
    operations that can be performed on today’s FPGAs. It was also relatively expensive,
    costing $55, which adjusted for inflation would be around $145 today. Still, the
    XC2064 kicked off an entire industry, and (alongside Altera) Xilinx has remained
    one of the dominant companies in the FPGA market for more than 30 years.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个 FPGA 是由 Xilinx 在1985年创建的 XC2064。它非常原始，只有 800 个逻辑门，与今天 FPGA 所能执行的数百万个逻辑门操作相比微不足道。它的价格也相对较贵，售价为55美元，按通货膨胀调整后今天大约为145美元。尽管如此，XC2064
    启动了整个行业，并且（与 Altera 一起）Xilinx 在过去 30 多年里一直是 FPGA 市场的主导公司之一。
- en: 'Early FPGAs like the XC2064 were only able to perform very simple tasks: Boolean
    operations such as taking the logical OR of two input pins and putting the result
    onto an output pin (you’ll learn much more about Boolean operations and logic
    gates in [Chapter 3](chapter3.xhtml)). In the 1980s, this type of problem required
    a dedicated circuit built of OR gates. If you also needed to perform a Boolean
    AND on two different pins, you might have to add another circuit, filling up your
    circuit board with these dedicated components. When FPGAs came along, a single
    device could replace many discrete gate components, lowering costs, saving component
    space on the circuit board, and allowing the design to be reprogrammed as the
    requirements of the project changed.'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 像 XC2064 这样的早期 FPGA 只能执行非常简单的任务：布尔运算，例如对两个输入引脚进行逻辑“或”运算并将结果输出到一个输出引脚（你将在[第3章](chapter3.xhtml)中学习到更多关于布尔运算和逻辑门的知识）。在1980年代，这类问题需要专门的电路，由“或”门组成。如果你还需要对两个不同的引脚执行布尔“与”运算，你可能还需要增加另一个电路，将这些专用组件填充到电路板上。随着
    FPGA 的出现，一个设备就可以替代许多离散的逻辑门组件，降低成本、节省电路板上的空间，并且随着项目需求的变化，设计可以重新编程。
- en: From these humble beginnings, the capabilities of FPGAs have increased dramatically.
    Over the years, the devices have been designed with more *hard intellectual property
    (IP)*, or specialized components within the FPGA that are dedicated to performing
    a specific task (as opposed to *soft* components that can be used to perform many
    tasks). For example, hard IP blocks in modern FPGAs let them interface directly
    with USB devices, DDR memory, and other off-chip components. Some of these capabilities
    (like a USB-C interface) would simply not be possible without some dedicated hard
    IP to do the job. Companies have even placed dedicated processors (called *hard
    processors*) inside FPGAs so that you can run normal C code within the FPGA itself.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 从这些简单的起步开始，FPGA的能力有了显著提升。多年来，这些设备已设计成拥有更多的*硬知识产权（IP）*，即FPGA内部专门用于执行特定任务的组件（与可执行多任务的*软*组件不同）。例如，现代FPGA中的硬IP模块使得它们能够直接与USB设备、DDR内存及其他外部组件进行接口连接。其中一些功能（如USB-C接口）没有某些专用硬IP是无法实现的。公司甚至将专用处理器（称为*硬处理器*）放入FPGA中，以便在FPGA内部运行普通的C代码。
- en: As the devices have evolved, the FPGA market has undergone many mergers and
    acquisitions. In 2020, the chip-making company AMD purchased Xilinx for $35 billion.
    It’s plausible that this purchase was a response to its main competitor Intel’s
    2015 acquisition of Altera for $16.7 billion. It’s interesting that two companies
    focused predominantly on CPUs decided to purchase FPGA companies, and there’s
    much speculation as to why. In general, it’s thought that as CPUs mature, dedicating
    some part of the chip to FPGA-like reprogrammable hardware seems to be an idea
    worth pursuing.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 随着设备的不断发展，FPGA市场经历了许多并购。2020年，芯片制造公司AMD以350亿美元收购了Xilinx。这次收购可能是对其主要竞争对手Intel在2015年以167亿美元收购Altera的回应。有趣的是，两个主要以CPU为核心的公司决定收购FPGA公司，这也引发了很多关于其原因的猜测。一般认为，随着CPU的成熟，将部分芯片用于类似FPGA的可重编程硬件似乎是一个值得追求的想法。
- en: Apart from Xilinx and Altera (which from here on I’ll be calling by their parent
    company names, AMD and Intel, respectively), other companies have carved out their
    own niches within the FPGA market. For example, Lattice Semiconductor has done
    well for itself making mostly smaller, less expensive FPGAs. Lattice has been
    happy to play on its own in this lower end of the market, while letting AMD and
    Intel slug it out at the higher end. Today, the open source community has embraced
    Lattice FPGAs, which have been reverse-engineered to allow for low-level hacking.
    Another medium-sized player in the FPGA space, Actel, was acquired by Microsemi
    in 2010 for $430 million. Microsemi itself was acquired by Microchip Technology
    in 2018.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 除了Xilinx和Altera（从现在开始我会分别使用它们的母公司名称，AMD和Intel），其他公司在FPGA市场中也找到了自己的定位。例如，Lattice
    Semiconductor凭借主要生产较小且价格较低的FPGA取得了不错的成绩。Lattice乐于在这个市场的低端独立发展，同时让AMD和Intel在高端市场中竞争。如今，开源社区已经接纳了Lattice
    FPGA，并通过逆向工程使其能够进行低级别的黑客攻击。FPGA领域的另一家中型公司Actel，于2010年被Microsemi以4.3亿美元收购，而Microsemi本身在2018年被Microchip
    Technology收购。
- en: <samp class="SANS_Futura_Std_Bold_B_11">Popular FPGA Applications</samp>
  id: totrans-14
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">流行的FPGA应用</samp>
- en: In their modern, highly capable and flexible form, FPGAs are used in many interesting
    areas. For example, they’re a critical component in the telecommunications industry,
    where they’re often found in cell phone towers. They route internet traffic to
    bring the internet to your smartphone, allowing you to stream YouTube videos on
    your bus ride to work.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在现代、高性能且灵活的形式下，FPGA被广泛应用于许多有趣的领域。例如，它们是电信行业的关键组件，常常出现在手机信号塔中。它们负责路由互联网流量，将互联网带入你的智能手机，让你在通勤的公交车上观看YouTube视频。
- en: FPGAs are also widely used in the finance industry for high-frequency trading,
    where companies use algorithms to automatically buy and sell stocks incredibly
    quickly. Traders have found that if you can execute a stock purchase or sale slightly
    quicker than the competition, you can gain a financial edge. The speed of execution
    is paramount; a tiny bit of latency can cost a company millions of dollars. FPGAs
    are well suited to this task because they’re very fast and can be reprogrammed
    as new trading algorithms are discovered. This is an industry where milliseconds
    matter, and FPGAs can provide an advantage.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: FPGA在金融行业中也被广泛应用于高频交易，公司利用算法自动进行快速的股票买卖。交易员发现，如果你能够比竞争对手稍微快一点地执行股票购买或销售，就能获得财务上的优势。执行速度至关重要；哪怕是微小的延迟，都可能让公司损失数百万美元。FPGA非常适合这项任务，因为它们的速度非常快，并且能够根据新的交易算法进行重新编程。这是一个毫秒决定胜负的行业，而FPGA能够提供优势。
- en: FPGAs are used in the defense industry as well, for applications like radar
    digital signal processing. FPGAs can process received radar reflections using
    mathematical filters to see small objects hundreds of miles away. They’re also
    used to process and manipulate images from infrared (IR) cameras, which can see
    heat rather than visible light, allowing military operatives to see people even
    in complete darkness. These operations are often highly math-intensive, requiring
    many multiplication and addition operations to happen at parallel—something that
    FPGAs excel at.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: FPGA在国防工业中也有应用，比如雷达数字信号处理。FPGA可以使用数学滤波器处理接收到的雷达反射信号，从而发现几百英里外的小物体。它们还被用于处理和操控红外（IR）摄像头的图像，这些摄像头能够看到热量而非可见光，使得军事人员即使在完全黑暗的环境中也能看到人类。这些操作通常需要大量的数学运算，需要并行进行许多乘法和加法运算，而FPGA在这方面表现得尤为出色。
- en: 'Another area where FPGAs have found a niche is in the space industry: they
    can be programmed with redundancies to hedge against the effects of radiation
    bombardment, which can cause digital circuits to fail. On Earth, the atmosphere
    protects electronics (and people) from lots of solar radiation, but outer space
    doesn’t have that lovely blanket, so the electronics on satellites are subjected
    to a much harsher environment.'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: FPGA在航天工业中也找到了自己的市场：它们可以通过编程冗余措施来应对辐射轰击的影响，因为辐射可能导致数字电路故障。在地球上，大气层保护电子设备（以及人类）免受大量的太阳辐射，但外太空没有这层“温暖的被子”，因此卫星上的电子设备面临着更为严苛的环境。
- en: 'Finally, FPGAs are also getting interest from the artificial intelligence (AI)
    community. They can be used to accelerate neural nets, another massively parallel
    computational problem, and thus are helping humans attack issues that weren’t
    solvable using traditional programming techniques: image classification, speech
    recognition and translation, robotics control, game strategy, and more.'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，FPGA也受到了人工智能（AI）社区的关注。它们可以用于加速神经网络，这是一个大规模并行计算问题，因此它们正在帮助人类解决一些传统编程方法无法解决的问题：图像分类、语音识别与翻译、机器人控制、游戏策略等。
- en: This look at popular FPGA applications is far from exhaustive. Overall, FPGAs
    are a good candidate for any digital electronics problem where high bandwidth,
    low latency, or high processing capability is needed.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 这篇关于FPGA应用的概览远远不够全面。总体而言，FPGA是解决任何需要高带宽、低延迟或高处理能力的数字电子问题的良好选择。
- en: <samp class="SANS_Futura_Std_Bold_B_11">Comparing Common Digital Logic Components</samp>
  id: totrans-21
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">常见数字逻辑组件的比较</samp>
- en: Despite how far they’ve come since their early days and the wide range of applications
    they’re used for, FPGAs are still a relatively niche technology compared to other
    digital logic components like microcontrollers and ASICs. In this section, we’ll
    compare these three technologies. You’ll see why FPGAs are a good solution for
    some problems but not others, and how they have tough competition from other devices,
    especially microcontrollers.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管FPGA自早期发展以来已经取得了很大的进展，并且广泛应用于多个领域，但与微控制器和ASIC等其他数字逻辑组件相比，FPGA仍然是一项相对小众的技术。在本节中，我们将对这三种技术进行比较。你将看到为什么FPGA对于某些问题是一个好的解决方案，但对于其他问题则不适用，并且它们面临来自其他设备，尤其是微控制器的激烈竞争。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">FPGAs vs. Microcontrollers</samp>
  id: totrans-23
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">FPGA与微控制器</samp>
- en: 'Microcontrollers are everywhere. If you aren’t an embedded software engineer,
    you may not realize how many toys, tools, gadgets, and devices are controlled
    with small and inexpensive microcontrollers: everything from TV remote controls
    to coffee makers to talking toys. If you’re an electronics hobbyist, you might
    be familiar with the *Arduino*, which is powered by a small microcontroller from
    Atmel (now Microchip Technology, the same company that owns what used to be Actel).
    Millions of Arduinos have been sold to hobbyists around the world. They’re cheap,
    fun, and relatively easy to work with.'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 微控制器无处不在。如果你不是嵌入式软件工程师，你可能没有意识到有多少玩具、工具、小设备和仪器都由小型且廉价的微控制器控制：从电视遥控器到咖啡机，再到会说话的玩具。如果你是电子爱好者，你可能熟悉*Arduino*，它由Atmel（现在的Microchip
    Technology）出品的小型微控制器驱动（Microchip也是以前的Actel公司）。全球已有数百万个Arduino售出给爱好者。它们便宜、有趣，并且相对容易操作。
- en: So why are microcontrollers everywhere, but not FPGAs? Why isn’t there an FPGA
    controlling your coffee maker or making your Elmo doll come to life? The main
    reason is cost. The consumer electronics industry, which uses the largest number
    of microcontrollers overall, is incredibly sensitive to cost. Consumers like you
    and I want the least expensive products we can possibly buy, and the companies
    that make those products will shave off every penny possible to make that happen.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，为什么微控制器到处可见，而FPGA却没有呢？为什么你的咖啡机或艾尔摩娃娃没有FPGA控制呢？主要原因是成本。消费电子行业是使用最多微控制器的行业，对成本的敏感度非常高。像你我这样的消费者希望购买尽可能便宜的产品，而制造这些产品的公司会尽可能压缩每一分钱，以达成这一目标。
- en: Microcontrollers come in seemingly endless varieties, with each one designed
    for a very specific purpose. This helps companies drive costs down. For example,
    if your product needs one analog-to-digital converter (ADC), two USB interfaces,
    and at least 30 general purpose input/output (GPIO) pins, there’s a microcontroller
    with exactly those specifications. What if you realize you only need one USB interface?
    There’s probably a different microcontroller with those specifications, too. With
    such variety, there’s no need to pay for extra features. Companies can find a
    microcontroller with the bare minimum of what they need, and save money in the
    process.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 微控制器种类繁多，每种微控制器都针对特定用途设计。这有助于公司降低成本。例如，如果你的产品需要一个模拟到数字转换器（ADC）、两个USB接口以及至少30个通用输入输出（GPIO）引脚，就有一款微控制器恰好满足这些规格。如果你意识到只需要一个USB接口呢？也许会有另一款微控制器符合这些规格。正因为种类繁多，企业不需要为多余的功能付费。公司可以找到一款满足最低需求的微控制器，并在这个过程中节省资金。
- en: FPGAs, on the other hand, are much more general. With a single FPGA, you might
    create five ADC interfaces and no USB interface, or three USB and no ADC interfaces.
    You pretty much have a blank slate at your disposal. As you’ll learn, however,
    FPGAs need to have many internal wires (called *routing*) to support all these
    different possibilities, and all that routing adds cost and complexity. In many
    cases, you’ll end up paying more for extra features and flexibility that you don’t
    need.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: FPGA则更加通用。通过单一的FPGA，你可能会创建五个ADC接口而没有USB接口，或者三个USB接口而没有ADC接口。你几乎拥有一张空白的画布。可是，正如你将学到的，FPGA需要许多内部线路（称为*路由*）来支持所有这些不同的可能性，这些路由增加了成本和复杂性。在许多情况下，你最终会为不需要的额外功能和灵活性付出更多的费用。
- en: Another contributing factor to cost is quantity. If you buy 10 million microcontrollers,
    which is not unrealistic in the field of consumer electronics, you’ll pay less
    per chip than you would if you only bought 100,000\. FPGAs, meanwhile, are typically
    produced and sold in relatively low quantities, so they cost more per unit. It’s
    a bit of a chicken-and-egg situation, where FPGAs could be less expensive if there
    were more of them, but for there to be more of them, they would have to be less
    expensive. If the costs were the same as with microcontrollers, would there be
    more FPGAs in use? I think it’s likely that there would be, but FPGAs are also
    more complicated to use, so that works against them as well.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 成本的另一个因素是数量。如果你购买1000万个微控制器，这在消费电子领域并不算不现实，那么每颗芯片的价格就会比购买10万个便宜。与此同时，FPGA通常是以较小的数量生产和销售的，因此每个单元的价格较高。这有点像“先有鸡还是先有蛋”的问题，FPGA本可以因为数量增多而便宜，但要想数量增多，价格必须降低。如果成本和微控制器相同，FPGA的使用量会更多吗？我认为可能会更多，但FPGA的使用也更复杂，这也对它们造成了一定的制约。
- en: 'Since microcontrollers are designed for specific purposes, they can be very
    easy to set up. You can get a basic design up and running on a microcontroller
    in a few hours. By contrast, you need to program *everything* inside the FPGA,
    and this is very time-consuming. Although there are some hard IP blocks to get
    you started, the majority of the device is programmable logic—that blank slate
    we talked about—that you need to design yourself. Writing all the code to do what
    you need also takes longer in a language like Verilog or VHDL than C, which is
    commonly used to program microcontrollers. With C, you’re writing code at a higher
    level, so you can do more with a single line. With Verilog and VHDL you’re writing
    at a much lower level: individual gates and wires are literally being created
    with your code. You can think of low-level programming like working with individual
    LEGO bricks and high-level programming like working with preconstructed LEGO sets.
    This adds complexity, which adds time, which also increases costs. Engineers want
    the simplest solution, and most often a microcontroller is simpler than an FPGA.'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 由于微控制器是为特定目的设计的，因此它们非常容易设置。你可以在几个小时内就让微控制器运行基本的设计。相比之下，你需要在 FPGA 内编程*所有内容*，这非常耗时。虽然有一些硬件
    IP 块可以帮助你入门，但设备的大部分是可编程逻辑——我们之前提到的那块空白画布——你需要自己设计。用像 Verilog 或 VHDL 这样的语言编写代码也比用
    C 语言要花费更多时间，而 C 语言通常用于编程微控制器。使用 C 语言时，你在更高的层次上编写代码，因此可以用一行代码完成更多操作。而在 Verilog
    和 VHDL 中，你则是在更低的层次上编写代码：你的代码实际上是在创建单个逻辑门和导线。你可以把低级编程想象成用单个 LEGO 积木来拼装，而高级编程则像是在使用已经构建好的
    LEGO 套件。这增加了复杂性，从而增加了时间，也提高了成本。工程师们通常都希望找到最简单的解决方案，而大多数情况下，微控制器比 FPGA 更简单。
- en: Another factor to consider is how much power the device consumes. Many electronic
    devices run off batteries, and it’s critical to maximize their lifetime by making
    the devices as low-power as possible. The more power they use, the more often
    you’ll have to change the batteries, which is something nobody wants to do. Again,
    since a microcontroller is designed for a specific use, it can be optimized to
    draw incredibly little power, enabling a single AAA battery to power a Bluetooth
    mouse for months, for example. FPGAs, with all their routing resources, are simply
    unable to compete with microcontrollers in terms of power consumption. That’s
    not to say you can’t use an FPGA in a battery-powered application, but head-to-head
    the microcontroller will win that battle every time.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个需要考虑的因素是设备的功耗。许多电子设备依赖电池运行，因此至关重要的是通过尽可能降低设备的功耗来最大化电池寿命。例如，一节 AAA 电池就能为蓝牙鼠标提供数月的使用时间，因为微控制器是为特定用途设计的，可以优化为消耗极少的功率。相比之下，FPGA
    拥有大量的布线资源，在功耗方面无法与微控制器竞争。这并不是说不能在电池供电的应用中使用 FPGA，但在同等条件下，微控制器每次都会在这一方面胜出。
- en: Summarizing, microcontrollers almost always dominate in terms of cost, ease
    of use, and power consumption. So why would anyone use an FPGA over a microcontroller?
    There are other factors to consider, such as speed and flexibility, and here the
    tables turn in favor of the FPGA.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，微控制器在成本、易用性和功耗方面几乎总是占据优势。那么，为什么还有人会选择 FPGA 而不是微控制器呢？还有其他因素需要考虑，比如速度和灵活性，在这些方面，FPGA
    却能扭转局面。
- en: 'When I say speed, I mean two things: bandwidth and computations. *Bandwidth*
    is the rate of data transfer across a path. FPGAs can have incredibly large bandwidth,
    much more than any microcontroller could ever attain. They can process hundreds
    of gigabits per second with no trouble at all. This might be useful, for example,
    when driving multiple 4K displays. FPGAs are often used in video editing hardware
    that requires enormous amounts of bandwidth to keep up with the data streams.
    Their high bandwidth allows them to move tremendous amounts of data from various
    external interfaces (USB-C, Ethernet, ADCs, memories, and more) at very fast rates.'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 当我说速度时，我指的是两件事：带宽和计算能力。*带宽*是数据通过路径传输的速率。FPGA 的带宽可以非常大，远超过任何微控制器能够达到的水平。它们可以毫不费力地处理每秒数百吉比特的数据。例如，在驱动多个
    4K 显示器时，FPGA 的高带宽可以发挥巨大作用。FPGA 经常用于需要大量带宽以跟上数据流的视频编辑硬件。它们的高带宽使得它们能够以非常快的速度从各种外部接口（USB-C、以太网、模拟到数字转换器、内存等）传输大量数据。
- en: As for computational speed, the number of mathematical computations an FPGA
    can perform in a second dwarfs anything a microcontroller can do. A microcontroller
    usually has just one processor, and with all computations going through the same
    processor, the number of computations that can be performed each second is limited.
    An FPGA, on the other hand, can run many computations in parallel. For example,
    you can run hundreds of multiplication operations at the same time, something
    that simply isn’t possible with a microcontroller. This might be useful when running
    large mathematical filters on data, which often involve many multiplication and
    addition operations occurring at very fast rates.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 至于计算速度，FPGA每秒能够进行的数学计算远超任何微控制器的能力。微控制器通常只有一个处理器，所有计算都通过同一个处理器进行，因此每秒能够执行的计算数量有限。而FPGA则能够并行运行多个计算。例如，你可以同时运行数百次乘法运算，这在微控制器中是根本不可能实现的。这在处理大规模数学滤波数据时尤其有用，因为这些滤波过程通常涉及许多乘法和加法运算，且速度非常快。
- en: The other major benefit of an FPGA is its flexibility. I said microcontrollers
    come in endless varieties, but of course, this is a slight exaggeration. If your
    design has some particularly exotic requirement—say, if it needs 16 ADC interfaces—there
    might not be any microcontroller in the world that will meet your needs. FPGAs
    are much less limited. As I’ve mentioned, an FPGA is like a blank slate that can
    be programmed to do almost anything, providing you with tremendous flexibility
    to tackle a wide range of digital logic problems.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: FPGA的另一个主要优点是其灵活性。我之前说过，微控制器有各种各样的类型，但当然，这只是一个小小的夸张。如果你的设计有一些特别的需求——比如需要16个ADC接口——那么世界上可能没有任何微控制器能够满足这些需求。FPGA的限制要小得多。正如我提到的，FPGA就像一块空白的画布，可以编程来做几乎任何事情，这为你提供了极大的灵活性来解决各种数字逻辑问题。
- en: 'When you have an engineering problem, you need to choose the best tool possible
    to solve it. Often a microcontroller works very well, but occasionally it simply
    won’t work due to speed or flexibility issues. In those situations, an FPGA is
    a good candidate. However, there’s also another kind of device worth considering:
    an ASIC.'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 当你面临一个工程问题时，你需要选择最合适的工具来解决它。通常情况下，微控制器非常适用，但有时由于速度或灵活性问题，它可能无法胜任。在这种情况下，FPGA是一个很好的选择。然而，还有一种值得考虑的设备：ASIC。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">FPGAs vs. ASICs</samp>
  id: totrans-36
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">FPGAs与ASICs的对比</samp>
- en: An ASIC is a type of integrated circuit designed for a particular use. Unlike
    an FPGA, which can suit any number of uses, an ASIC is designed to be really good
    at one thing. You might think that it would always be better to have the flexibility
    of an FPGA, but there are trade-offs to consider. We’ve already compared FPGAs
    to microcontrollers in terms of cost, ease of use, power, speed, and flexibility.
    Let’s now compare FPGAs and ASICs along those same lines.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: ASIC是一种为特定用途设计的集成电路。与可以适应多种用途的FPGA不同，ASIC是专门为某一项任务而设计的，能够在这项任务上做到极致。你可能会认为拥有FPGA的灵活性总是更好，但实际上还是有一些权衡需要考虑。我们已经从成本、易用性、功耗、速度和灵活性等方面对比了FPGA和微控制器，现在让我们也从这些方面来比较FPGA和ASIC。
- en: 'ASICs are incredibly expensive to make in low quantities because they have
    a large *nonrecurring engineering (NRE)* cost: you need to pay a lot of money
    up front to a semiconductor foundry (or *fab*) to get that first ASIC chip. Often
    the NRE on an ASIC design can run into the millions of dollars. Whether or not
    you choose to design an ASIC highly depends on how many chips you’ll need. If
    you’re making low quantities of something, even into the tens of thousands, it’s
    unlikely you’ll ever be able to recover the up-front cost of an ASIC. If you need
    millions of chips, however, then an ASIC starts to become an attractive option,
    since each chip after the first one is very cheap (often under $1). Compare that
    to an FPGA, where a single chip often costs more than $10, and you start to see
    that FPGAs just don’t make financial sense in large volumes. Generalizing, in
    smaller quantities FPGAs usually win against ASICs, but in larger quantities they
    can’t compete as well.'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 由于ASIC在少量生产时的*非经常性工程（NRE）*成本非常高，因此其制造成本非常昂贵：你需要向半导体代工厂（或称*fab*）支付大量的前期费用，才能获得第一颗ASIC芯片。通常，ASIC设计的NRE成本可能高达数百万美元。是否选择设计ASIC很大程度上取决于你需要多少芯片。如果你只生产少量的产品，即使是几万个，也很难收回ASIC的前期成本。然而，如果你需要数百万颗芯片，那么ASIC就会变得具有吸引力，因为第一颗芯片之外的每颗芯片非常便宜（通常不到1美元）。与此相比，FPGA的单颗芯片往往超过10美元，你就会发现FPGA在大批量生产中经济上并不划算。总的来说，在较小数量的情况下，FPGA通常优于ASIC，但在较大数量时，FPGA无法与ASIC竞争。
- en: An area where FPGAs always win out over ASICs is in terms of ease of use. The
    process of designing an ASIC is very complicated. Plus, you need to make sure
    your design is free of bugs *before* you go to the fab to make the chip, or you’ll
    have wasted your NRE. Most FPGAs, on the other hand, can be fixed in the field
    (hence *field programmable*), so even if you find a bug after shipping your product
    to customers, you can update the code and remedy the issue. That’s simply not
    possible with an ASIC. Therefore, you must spend significant engineering time
    and effort verifying that your ASIC design is as bug-free as possible before getting
    it fabricated. There’s actually an entire discipline called *verification engineering*
    that does just this, something we’ll explore in more detail in [Chapter 5](chapter5.xhtml).
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: FPGA在一个领域总是优于ASIC，那就是易用性。设计一个ASIC的过程非常复杂。而且，在你去芯片制造厂（fab）制造芯片之前，必须确保你的设计没有错误，否则你就浪费了NRE成本。另一方面，大多数FPGA可以在现场修复（因此称为*现场可编程*），所以即使在将产品交付给客户后发现了错误，你仍然可以更新代码并解决问题。这对于ASIC来说则根本不可能做到。因此，在制造ASIC之前，你必须花费大量的工程时间和精力，验证你的ASIC设计尽可能没有漏洞。实际上，*验证工程*就是做这项工作的一个学科，我们将在[第5章](chapter5.xhtml)中更详细地探讨这一点。
- en: One large benefit to an ASIC is that it can be optimized for low power. ASICs
    are finely tuned for their specific application; they have what they need and
    no more. Meanwhile, recall that an FPGA has a significant number of wires and
    interconnections, which give it its flexibility but mean it uses more power. A
    further advantage ASICs have over FPGAs is that they can use fabrication techniques
    that optimize them for low power at the transistor level. For a real-life example,
    when Bitcoin was new, people were using their home computers (CPUs) to mine it.
    This draws a lot of power per Bitcoin mined. Eventually, people realized that
    FPGAs could be programmed to mine Bitcoins, using less power than CPUs. Electrical
    power is expensive, so mining Bitcoins with FPGAs was more profitable. Further
    down the line, people realized that ASICs could mine Bitcoins even faster and
    using even less power than FPGAs. It became worth the up-front cost to create
    an ASIC dedicated to Bitcoin mining, because the cost savings from the lower power
    consumption were so significant. Today, Bitcoins are mined almost exclusively
    with ASICs.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: ASIC的一个主要优势是它可以针对低功耗进行优化。ASIC被精细调校以适应特定的应用需求；它们只包含所需的部分，没有多余的功能。与此同时，回想一下，FPGA具有大量的线路和互联，这为其提供了灵活性，但也意味着它使用更多的电力。ASIC相对于FPGA的另一个优势是，它们可以使用优化低功耗的制造技术，甚至在晶体管级别上进行优化。举个现实中的例子，当比特币刚出现时，人们使用家用电脑（CPU）进行挖矿。这种方式每挖出一个比特币就会消耗大量电力。最终，人们意识到FPGA可以被编程用来挖掘比特币，比CPU消耗的电力更少。由于电力昂贵，使用FPGA挖掘比特币变得更具利润。再往后发展，人们意识到ASIC可以比FPGA更快速、更节能地挖掘比特币。制造一款专用于比特币挖矿的ASIC变得物有所值，因为它在降低功耗上的节省非常显著。如今，比特币几乎完全依赖ASIC进行挖矿。
- en: 'When it comes to speed, FPGAs and ASICs both have large bandwidth and can move
    lots of data around. They’re also both very capable at math operations, particularly
    multiplication and addition, and both can do those operations in parallel. ASICs
    have a small edge in this category: because they’re built specifically for one
    purpose, they can often run a bit faster than FPGAs.'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在速度方面，FPGAs 和 ASICs 都具有大带宽，能够传输大量数据。它们在数学运算方面也非常强大，尤其是在乘法和加法运算上，且都可以并行执行这些操作。ASICs
    在这一方面稍占优势：因为它们是专门为某一特定用途设计的，因此通常比 FPGAs 更快。
- en: FPGAs, on the other hand, offer significantly more flexibility than ASICs. Having
    flexibility in what your design can do is very valuable, especially if you’re
    working on a project that isn’t clearly defined. Unlike ASICs, which are fixed,
    FPGAs can be reprogrammed over and over again, with features and functionality
    added or removed. Additionally, ASICs take a long time to design, make, and verify,
    but you can get started with an FPGA right away, so the speed of progress can
    be faster.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，FPGAs 提供了比 ASICs 更大的灵活性。设计中所具备的灵活性非常宝贵，特别是当你在做一个不完全明确的项目时。与固定的 ASICs 不同，FPGAs
    可以反复重新编程，添加或移除功能和特性。此外，ASICs 的设计、制造和验证过程需要很长时间，而 FPGA 则可以立刻开始使用，因此进展速度通常更快。
- en: In general, ASICs win against FPGAs on cost when the volumes are very high,
    but not when they’re low. They beat FPGAs on power consumption and have a slight
    edge on speed, but they lose to FPGAs on flexibility and ease of use. In reality,
    though, ASICs and FPGAs often go hand in hand. When a company wants to design
    an ASIC, it will typically start by designing a prototype with an FPGA, and then
    produce the ASIC. This method allows engineers to work with the hardware sooner
    and gain confidence in the product, prior to spending millions of dollars on a
    custom chip. The engineers can work through the bugs in the Verilog or VHDL code
    using the FPGA prototype, and fix issues when it’s inexpensive and simpler to
    do so. This code isn’t throwaway code either, since the same Verilog or VHDL used
    on an FPGA can be used to create an ASIC.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 一般来说，当生产量非常高时，ASICs 在成本上优于 FPGAs，但当生产量较低时则不然。ASICs 在功耗上优于 FPGAs，并且在速度上稍有优势，但在灵活性和易用性上则不如
    FPGAs。然而，实际上，ASICs 和 FPGAs 经常是一起使用的。当一家公司想设计一个 ASIC 时，通常会先用 FPGA 设计一个原型，然后再生产
    ASIC。这种方法使工程师可以更早地接触硬件，并在花费数百万美元定制芯片之前对产品充满信心。工程师可以通过 FPGA 原型在 Verilog 或 VHDL
    代码中解决问题，并在成本较低、实现更简单时进行修正。此代码并非是一次性丢弃的代码，因为同样的 Verilog 或 VHDL 可以用来创建 ASIC。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">FPGAs vs. Microcontrollers
    vs. ASICs</samp>
  id: totrans-44
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">FPGAs 与微控制器与 ASICs
    的比较</samp>
- en: That was a lot to take in, so let’s briefly summarize what we’ve just discussed
    about FPGAs, microcontrollers, and ASICs. [Table 1-1](#tab1-1) provides an overview
    of where each type of device sits on the scale across different parameters. There
    are always exceptions, but the table provides a good generalization.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 这一部分信息有点多，所以下面我们简要总结一下关于 FPGAs、微控制器和 ASICs 的讨论。[表 1-1](#tab1-1)提供了每种设备在不同参数上的对比概况。虽然总有例外情况，但这张表格提供了一个很好的概括。
- en: <samp class="SANS_Futura_Std_Heavy_B_11">Table 1-1:</samp> <samp class="SANS_Futura_Std_Book_11">Comparing
    an FPGA vs. a Microcontroller vs. an ASIC</samp>
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Heavy_B_11">表 1-1：</samp> <samp class="SANS_Futura_Std_Book_11">比较
    FPGA 与微控制器与 ASIC 的优劣</samp>
- en: '|  | <samp class="SANS_Futura_Std_Heavy_B_11">FPGA</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">Microcontroller</samp>
    | <samp class="SANS_Futura_Std_Heavy_B_11">ASIC</samp> |'
  id: totrans-47
  prefs: []
  type: TYPE_TB
  zh: '|  | <samp class="SANS_Futura_Std_Heavy_B_11">FPGA</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">微控制器</samp>
    | <samp class="SANS_Futura_Std_Heavy_B_11">ASIC</samp> |'
- en: '| --- | --- | --- | --- |'
  id: totrans-48
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- |'
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">Cost (low quantities)</samp> | <samp
    class="SANS_Futura_Std_Book_11">Moderate</samp> | <samp class="SANS_Futura_Std_Book_11">Cheap</samp>
    | <samp class="SANS_Futura_Std_Book_11">Expensive</samp> |'
  id: totrans-49
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_Futura_Std_Heavy_B_11">成本（小批量生产）</samp> | <samp class="SANS_Futura_Std_Book_11">适中</samp>
    | <samp class="SANS_Futura_Std_Book_11">便宜</samp> | <samp class="SANS_Futura_Std_Book_11">昂贵</samp>
    |'
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">Cost (high quantities)</samp> |
    <samp class="SANS_Futura_Std_Book_11">Moderate</samp> | <samp class="SANS_Futura_Std_Book_11">Cheap</samp>
    | <samp class="SANS_Futura_Std_Book_11">Cheap</samp> |'
  id: totrans-50
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_Futura_Std_Heavy_B_11">成本（大批量生产）</samp> | <samp class="SANS_Futura_Std_Book_11">适中</samp>
    | <samp class="SANS_Futura_Std_Book_11">便宜</samp> | <samp class="SANS_Futura_Std_Book_11">便宜</samp>
    |'
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">Speed</samp> | <samp class="SANS_Futura_Std_Book_11">Fast</samp>
    | <samp class="SANS_Futura_Std_Book_11">Moderate</samp> | <samp class="SANS_Futura_Std_Book_11">Fast</samp>+
    |'
  id: totrans-51
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_Futura_Std_Heavy_B_11">速度</samp> | <samp class="SANS_Futura_Std_Book_11">快速</samp>
    | <samp class="SANS_Futura_Std_Book_11">适中</samp> | <samp class="SANS_Futura_Std_Book_11">快速</samp>+
    |'
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">Power</samp> | <samp class="SANS_Futura_Std_Book_11">Moderate</samp>
    | <samp class="SANS_Futura_Std_Book_11">Low</samp> | <samp class="SANS_Futura_Std_Book_11">Low</samp>
    |'
  id: totrans-52
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_Futura_Std_Heavy_B_11">功耗</samp> | <samp class="SANS_Futura_Std_Book_11">适中</samp>
    | <samp class="SANS_Futura_Std_Book_11">低</samp> | <samp class="SANS_Futura_Std_Book_11">低</samp>
    |'
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">Flexibility</samp> | <samp class="SANS_Futura_Std_Book_11">High</samp>
    | <samp class="SANS_Futura_Std_Book_11">Low</samp> | <samp class="SANS_Futura_Std_Book_11">None</samp>
    |'
  id: totrans-53
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_Futura_Std_Heavy_B_11">灵活性</samp> | <samp class="SANS_Futura_Std_Book_11">高</samp>
    | <samp class="SANS_Futura_Std_Book_11">低</samp> | <samp class="SANS_Futura_Std_Book_11">无</samp>
    |'
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">Ease of use</samp> | <samp class="SANS_Futura_Std_Book_11">Medium</samp>
    | <samp class="SANS_Futura_Std_Book_11">Easy</samp> | <samp class="SANS_Futura_Std_Book_11">Difficult</samp>
    |'
  id: totrans-54
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_Futura_Std_Heavy_B_11">易用性</samp> | <samp class="SANS_Futura_Std_Book_11">中等</samp>
    | <samp class="SANS_Futura_Std_Book_11">容易</samp> | <samp class="SANS_Futura_Std_Book_11">困难</samp>
    |'
- en: Cost is often the dominant factor in why a microcontroller or an ASIC is chosen
    over an FPGA for large-volume applications. They’re simply cheaper, and that counts
    in industries that are highly sensitive to cost. When performance is the most
    important consideration and the high initial cost and level of complexity are
    acceptable, ASICs are often preferred. The sweet spot for FPGAs is applications
    that are low volume but require high speed in terms of either bandwidth or computations,
    or require a very flexible and unique design (like having 16 ADCs to interface
    to).
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 成本通常是为什么微控制器或ASIC在大批量应用中被选择而不是FPGA的主要因素。它们更便宜，这在对成本高度敏感的行业中至关重要。当性能是最重要的考虑因素，并且高昂的初期成本和复杂性是可以接受的时，ASIC通常是首选。FPGA的最佳应用领域是那些低量但在带宽或计算上需要高速的应用，或者需要非常灵活和独特的设计（例如需要16个ADC接口的设计）。
- en: Ultimately, FPGAs, microcontrollers, and ASICs are three tools in the engineer’s
    toolbox. When looking at the requirements of your particular problem, you’ll need
    to decide which of these tools provides the best solution. You wouldn’t use a
    hammer to turn a screw; knowing which tool to use for which application is critical
    to becoming a strong engineer. The act of examining multiple possibilities and
    selecting a technical solution is often referred to in engineering as a *trade
    study*.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 最终，FPGA、微控制器和ASIC是工程师工具箱中的三种工具。在审视你特定问题的需求时，你需要决定这些工具中哪个提供了最佳的解决方案。你不会用锤子来拧螺丝；了解在何时使用哪种工具对于成为一名优秀工程师至关重要。审视多种可能性并选择技术解决方案的过程在工程学中通常被称为*技术研究*。
- en: 'I love FPGAs, but when I look at a technical problem, often the right solution
    is a microcontroller: they’re easy to use and inexpensive. A microcontroller isn’t
    *always* the right solution, though. Sometimes you need more speed, or the problem
    is one that microcontrollers just aren’t designed for. Selecting the right tool
    for your problem will make solving the problem much more enjoyable. And as you’ll
    hopefully see, working with FPGAs is certainly enjoyable! It’s like working with
    LEGO or building a house in Minecraft. Using simple, low-level building blocks,
    you can create something wonderfully complex.'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 我喜欢FPGA，但当我面对技术问题时，通常正确的解决方案是微控制器：它们易于使用且价格低廉。然而，微控制器并不*总是*正确的解决方案。有时候你需要更多的速度，或者问题是微控制器本身设计不适用的。选择合适的工具来解决你的问题将使解决问题的过程更加愉快。正如你希望看到的，使用FPGA确实是非常愉快的！这就像玩乐高或者在Minecraft中建造房子。使用简单的、低级的构建模块，你可以创造出令人惊叹的复杂作品。
- en: <samp class="SANS_Futura_Std_Bold_B_11">Verilog and VHDL</samp>
  id: totrans-58
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">Verilog和VHDL</samp>
- en: 'As I’ve mentioned, there are two main languages for working with FPGAs (and
    ASICs): Verilog and VHDL. These languages are known as *hardware description languages
    (HDLs)* because they’re used to define the behavior of digital logic circuits.
    Though syntactically Verilog and VHDL may look similar to traditional programming
    languages, it’s important to realize that HDLs are a different beast entirely.
    When you write your FPGA code with an HDL, you’re working directly with wires,
    logic gates, and other discrete resources on the FPGA, whereas when you code with
    a traditional programming language you don’t have that same low level of control
    over your device. Understanding the logic behind your Verilog or VHDL code and
    knowing what FPGA components you’re instantiating with that code is a critical
    skill for a digital designer, and something we’ll return to throughout the book.'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我之前提到的，FPGA（和 ASIC）有两种主要的编程语言：Verilog 和 VHDL。这些语言被称为*硬件描述语言（HDL）*，因为它们用于定义数字逻辑电路的行为。尽管在语法上，Verilog
    和 VHDL 可能看起来与传统编程语言相似，但必须意识到，HDL 完全是另一种类型的语言。当你用 HDL 编写 FPGA 代码时，你直接操作的是 FPGA
    上的电线、逻辑门和其他离散资源，而使用传统编程语言编程时，你并不直接控制设备的低级部分。理解你写的 Verilog 或 VHDL 代码背后的逻辑，并知道用这些代码实例化了哪些
    FPGA 组件，是数字设计师的关键技能，也是我们在本书中会不断提到的内容。
- en: FPGA beginners often wonder if it’s better to learn Verilog or VHDL. There’s
    no right answer; it really depends on your situation. To help you make that decision,
    let’s compare and contrast the two languages to identify some reasons why you
    might select one over the other.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: FPGA 初学者经常会困惑是学习 Verilog 还是 VHDL 更好。没有正确的答案；这实际上取决于你的具体情况。为了帮助你做出决定，我们将对比这两种语言，找出你可能选择其中一种的原因。
- en: <samp class="SANS_Dogma_OT_Bold_B_21">NOTE</samp>
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Dogma_OT_Bold_B_21">注意</samp>
- en: '*All the code examples in this book will be shown in both Verilog and VHDL,
    back-to-back, so whichever language you choose, you’ll be able to follow along.*'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '*本书中的所有代码示例将同时展示 Verilog 和 VHDL 两种语言，因此无论你选择哪种语言，都能跟得上进度。*'
- en: VHDL stands for VHSIC Hardware Description Language, and VHSIC, the acronym
    within an acronym, stands for Very High-Speed Integrated Circuit. In full, VHDL
    is the *Very High-Speed Integrated Circuit Hardware Description Language*—quite
    a mouthful! It was developed by the United States Department of Defense (DoD)
    in 1983 and borrows many features and syntax from another DoD-developed language
    called Ada. VHDL, like Ada, is strongly typed.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: VHDL 代表 VHSIC 硬件描述语言，而 VHSIC 这个缩写中的缩写代表的是 Very High-Speed Integrated Circuit（超高速集成电路）。全称是*超高速集成电路硬件描述语言*——真是个绕口令！它是由美国国防部（DoD）于
    1983 年开发的，并且借鉴了另一个由 DoD 开发的语言 Ada 的许多特性和语法。VHDL 和 Ada 一样，是强类型语言。
- en: If you’ve never worked with a strongly typed language, it can be a bit challenging
    at first. Strong typing forces the designer to be very explicit with their code.
    For example, in a weakly typed language like Python or C, you can add a variable
    defined as an integer to a variable defined as a float without any problem. A
    strongly typed language like VHDL, however, would never allow something like this.
    When adding two numbers in VHDL, their widths (number of bits) and types need
    to match exactly, or the syntax checker will throw some cryptic error. Until you
    understand the strong type checking that the language is performing, it can be
    cumbersome to get what you need done as a beginner. When sorting out these issues
    in VHDL, you often need to create intermediary signals of the correct type, or
    use lots of type conversions throughout your code. This is one of several reasons
    VHDL often requires much more typing (on your keyboard, that is) than Verilog
    to perform the same functionality. If you want to use VHDL, it helps to be a fast
    typist.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你从未接触过强类型语言，刚开始可能会有些挑战。强类型要求设计师在代码中非常明确。例如，在像 Python 或 C 这样的弱类型语言中，你可以将一个定义为整数的变量与一个定义为浮点数的变量相加，完全没有问题。然而，像
    VHDL 这样的强类型语言是绝对不允许这样做的。在 VHDL 中相加两个数字时，它们的位宽（位数）和类型必须完全匹配，否则语法检查器会抛出一些难以理解的错误。在你理解语言执行的强类型检查之前，作为初学者，解决这些问题可能会变得非常麻烦。在
    VHDL 中处理这些问题时，你通常需要创建正确类型的中介信号，或者在代码中使用大量的类型转换。这也是为什么 VHDL 通常比 Verilog 需要更多敲键盘输入（也就是更多代码）来实现相同功能的原因之一。如果你想使用
    VHDL，成为一个快速打字员会对你有帮助。
- en: Compared to VHDL, Verilog looks more similar to a software language like C,
    which makes it easier for some people to read Verilog code and understand what
    it’s doing. Also, Verilog is weakly typed. It allows you to write code that’s
    wrong, but more concise. It would have no problem adding a float to an integer,
    even if the result of that addition might be incorrect.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 与VHDL相比，Verilog看起来更像C等软件语言，这使得一些人更容易阅读Verilog代码并理解其功能。此外，Verilog是弱类型的。它允许你编写错误的代码，但更简洁。它在将浮点数与整数相加时不会出错，即使这个加法结果可能不正确。
- en: Another interesting point of comparison is that Verilog is case sensitive but
    VHDL is not. This means that a variable called <samp class="SANS_TheSansMonoCd_W5Regular_11">RxDone</samp>
    isn’t the same as a variable called <samp class="SANS_TheSansMonoCd_W5Regular_11">rxDone</samp>
    in Verilog, but VHDL treats them as the same. It might seem odd that strongly
    typed VHDL isn’t case sensitive while weakly typed Verilog is, but that’s just
    the way history turned out. In my experience, Verilog’s case sensitivity can create
    issues that are hard to diagnose. You might think two signals are the same, but
    the code sees them as different due to a capitalization discrepancy.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个有趣的对比点是，Verilog是区分大小写的，而VHDL则不是。这意味着在Verilog中，一个名为<samp class="SANS_TheSansMonoCd_W5Regular_11">RxDone</samp>的变量与一个名为<samp
    class="SANS_TheSansMonoCd_W5Regular_11">rxDone</samp>的变量不同，而在VHDL中，它们被视为相同。虽然强类型的VHDL不区分大小写，而弱类型的Verilog却区分大小写，这可能看起来有些奇怪，但这就是历史的安排。根据我的经验，Verilog的大小写敏感性可能会造成一些难以诊断的问题。你可能认为两个信号是相同的，但由于大小写的差异，代码将它们视为不同的信号。
- en: Ultimately, none of these points is the most important factor, though. You should
    choose between Verilog and VHDL based on which language you’re more likely to
    use in school or at work. If your university uses Verilog, learn Verilog! If companies
    where you might want to work use VHDL, learn VHDL! The breakdown of who uses VHDL
    versus Verilog is highly dependent on where in the world you’re living. If you
    compare VHDL and Verilog using Google Trends, you can start to get a pretty good
    idea of which language you should be learning first.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，最终这些点都不是最重要的因素。你应该根据你在学校或工作中更可能使用哪种语言来选择Verilog或VHDL。如果你的大学使用Verilog，那就学习Verilog！如果你想要工作的公司使用VHDL，那就学习VHDL！谁使用VHDL而不是Verilog的分布高度依赖于你所在的地区。如果你通过Google趋势比较VHDL和Verilog，你会更清楚应该首先学习哪种语言。
- en: When you look at the overall search volumes for the two terms throughout the
    world, you’ll find that “Verilog” tends to have more searches than “VHDL.” Maybe
    that’s because it’s used more often, or maybe people have more trouble with Verilog
    and need to look up solutions online more than they do with VHDL. In any case,
    it’s more revealing to break down the trends on a country-by-country basis. [Figure
    1-1](#fig1-1) shows some examples.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 当你查看全球范围内这两个术语的整体搜索量时，你会发现“Verilog”的搜索量通常多于“VHDL”。也许是因为Verilog使用得更频繁，或者人们在使用Verilog时遇到更多问题，需要比VHDL更频繁地在线查找解决方案。不管怎样，按国家细分这些趋势更有启发性。[图
    1-1](#fig1-1)展示了一些例子。
- en: '![](../images/Figure1-1.png)'
  id: totrans-69
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure1-1.png)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 1-1: Verilog vs. VHDL
    search volumes in selected countries</samp>'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图 1-1：Verilog与VHDL在选定国家的搜索量对比</samp>
- en: India and the United States have the largest volumes of Google searches for
    the two terms, but while VHDL and Verilog appear to be roughly equal in popularity
    in India, Verilog is slightly more popular in the United States than VHDL. In
    fact, I know from personal experience that in the United States the defense industry
    favors VHDL, while the commercial industry favors Verilog. Notice that in Germany
    and France, VHDL is significantly more popular than Verilog. If you are from either
    of these two countries, I would highly recommend learning VHDL first! Conversely,
    in China and South Korea Verilog is much more popular than VHDL, so adjust your
    priorities accordingly.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 印度和美国是两个在这两个术语的谷歌搜索量最大国家，但尽管在印度VHDL和Verilog的受欢迎程度大致相当，Verilog在美国的受欢迎程度略高于VHDL。事实上，根据我个人经验，在美国，国防行业偏好VHDL，而商业行业偏好Verilog。注意，在德国和法国，VHDL明显比Verilog更受欢迎。如果你来自这两个国家，我强烈建议你首先学习VHDL！相反，在中国和韩国，Verilog远比VHDL更受欢迎，因此请根据情况调整优先顺序。
- en: In general, VHDL and Verilog are equally capable languages. You should choose
    which language to learn based on what suits your location and circumstances.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 总的来说，VHDL和Verilog是同样强大的语言。你应该根据你所在的地区和情况选择学习哪种语言。
- en: <samp class="SANS_Futura_Std_Bold_B_11">Summary</samp>
  id: totrans-73
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">总结</samp>
- en: This chapter introduced you to FPGAs and provided you with an overview of their
    history and common applications. We compared FPGAs with microcontrollers and ASICs
    and saw where each type of integrated circuit really shines. You learned that
    FPGAs excel at applications that aren’t cost sensitive, but where high speed,
    maximum flexibility, or unique interfaces are required. Finally, we looked at
    the two most popular hardware description languages used to work with FPGAs, Verilog
    and VHDL, and discussed how to choose the right language for you and your situation.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 本章介绍了FPGA，并提供了关于其历史和常见应用的概述。我们将FPGA与微控制器和ASIC进行了比较，并看到了每种集成电路类型的优势所在。你了解到，FPGA在不太敏感于成本，但需要高速、最大灵活性或独特接口的应用中表现出色。最后，我们探讨了用于与FPGA配合工作的两种最流行的硬件描述语言：Verilog和VHDL，并讨论了如何根据你的需求和情况选择合适的语言。
