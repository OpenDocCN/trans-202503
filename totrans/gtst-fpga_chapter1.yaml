- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">1</samp> <samp class="SANS_Dogma_OT_Bold_B_11">MEET
    THE FPGA</samp>
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '![](../images/opener-img.png)'
  prefs: []
  type: TYPE_IMG
- en: An *FPGA*, short for *field programmable gate array*, is a highly capable type
    of *integrated circuit*, an electronic circuit in a single package. The *field
    programmable* part of the name indicates that FPGAs can be reprogrammed when in
    the field (that is, without having to return them to the manufacturer). The *gate
    array* part indicates that an FPGA is made up of a two-dimensional grid featuring
    a large number of gates, fundamental units of digital logic that we’ll discuss
    in depth in [Chapter 3](chapter3.xhtml).
  prefs: []
  type: TYPE_NORMAL
- en: 'The name is actually a bit of an anachronism. The reality is that some FPGAs
    aren’t field programmable, and most are no longer just an array of simple gates.
    In fact, they’re much more sophisticated than that. Despite these exceptions,
    the name has stuck over the years, and it highlights a unique characteristic of
    FPGAs: their incredible flexibility. An FPGA’s uses are limited only by the designer’s
    imagination. Other digital programmable devices, such as microcontrollers, are
    designed with a specific set of capabilities; you can only do something if that
    feature is built in. By contrast, an FPGA’s array of gates (or the more modern
    equivalent) is like a blank slate that you can program, and reprogram, and reprogram
    to do almost anything you want, with fewer restrictions. This freedom doesn’t
    come without trade-offs, however, and FPGA development demands a unique set of
    skills.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Learning how to work with FPGAs requires a different style of thinking from
    traditional computer programming. Traditional software engineering, like programming
    in C, for example, is serial: first this happens, then this happens, and finally
    this happens. This is because C is compiled to run on a single processor, or CPU,
    and that CPU is a serial machine. It processes one instruction at a time.'
  prefs: []
  type: TYPE_NORMAL
- en: 'FPGAs, on the other hand, work in parallel: everything is happening at the
    same time. Understanding the difference between serial and parallel programming
    is fundamental to working with FPGAs. When you can think about solving a problem
    using parallel methods, your overall problem-solving skills will increase. These
    skills will also translate to other, non-FPGA applications; you’ll begin to see
    problems differently than if you were only thinking about them serially. Learning
    how to think in parallel rather than serially is a critical skill for becoming
    an FPGA engineer, and it’s one you’ll develop throughout this book.'
  prefs: []
  type: TYPE_NORMAL
- en: 'FPGAs are a lot of fun to work with. When you create an FPGA design using Verilog
    or VHDL (more on these languages later in this chapter), you’re writing code at
    the lowest possible level. You’re literally creating the physical connections,
    the actual wires, between electrical components and input/output pins on your
    device. This allows you to solve almost any digital problem: you have complete
    control. It’s a much lower level of programming than working with a microcontroller
    that has a processor, for example. For this reason, learning about FPGAs is an
    excellent way to become familiar with hardware programming techniques and better
    understand how exactly digital logic works in other applications. You’ll gain
    a newfound respect for the complexities of even the simplest integrated circuits
    once you start working with FPGAs.'
  prefs: []
  type: TYPE_NORMAL
- en: This first chapter sets you up for diving deeper into FPGAs by providing some
    background information. We’ll briefly cover the history of FPGAs, from their initial
    creation in the 1980s through today, and explore some of their common uses. We’ll
    also consider how FPGAs compare to other common digital components, such as microcontrollers
    and application-specific integrated circuits (ASICs). Finally, we’ll discuss the
    differences between Verilog and VHDL, the two most popular languages for working
    with FPGAs.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">A Brief History of FPGAs</samp>
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The very first FPGA was the XC2064, created by Xilinx in 1985\. It was very
    primitive, with a measly 800 gates, a fraction compared to the millions of gate
    operations that can be performed on today’s FPGAs. It was also relatively expensive,
    costing $55, which adjusted for inflation would be around $145 today. Still, the
    XC2064 kicked off an entire industry, and (alongside Altera) Xilinx has remained
    one of the dominant companies in the FPGA market for more than 30 years.
  prefs: []
  type: TYPE_NORMAL
- en: 'Early FPGAs like the XC2064 were only able to perform very simple tasks: Boolean
    operations such as taking the logical OR of two input pins and putting the result
    onto an output pin (you’ll learn much more about Boolean operations and logic
    gates in [Chapter 3](chapter3.xhtml)). In the 1980s, this type of problem required
    a dedicated circuit built of OR gates. If you also needed to perform a Boolean
    AND on two different pins, you might have to add another circuit, filling up your
    circuit board with these dedicated components. When FPGAs came along, a single
    device could replace many discrete gate components, lowering costs, saving component
    space on the circuit board, and allowing the design to be reprogrammed as the
    requirements of the project changed.'
  prefs: []
  type: TYPE_NORMAL
- en: From these humble beginnings, the capabilities of FPGAs have increased dramatically.
    Over the years, the devices have been designed with more *hard intellectual property
    (IP)*, or specialized components within the FPGA that are dedicated to performing
    a specific task (as opposed to *soft* components that can be used to perform many
    tasks). For example, hard IP blocks in modern FPGAs let them interface directly
    with USB devices, DDR memory, and other off-chip components. Some of these capabilities
    (like a USB-C interface) would simply not be possible without some dedicated hard
    IP to do the job. Companies have even placed dedicated processors (called *hard
    processors*) inside FPGAs so that you can run normal C code within the FPGA itself.
  prefs: []
  type: TYPE_NORMAL
- en: As the devices have evolved, the FPGA market has undergone many mergers and
    acquisitions. In 2020, the chip-making company AMD purchased Xilinx for $35 billion.
    It’s plausible that this purchase was a response to its main competitor Intel’s
    2015 acquisition of Altera for $16.7 billion. It’s interesting that two companies
    focused predominantly on CPUs decided to purchase FPGA companies, and there’s
    much speculation as to why. In general, it’s thought that as CPUs mature, dedicating
    some part of the chip to FPGA-like reprogrammable hardware seems to be an idea
    worth pursuing.
  prefs: []
  type: TYPE_NORMAL
- en: Apart from Xilinx and Altera (which from here on I’ll be calling by their parent
    company names, AMD and Intel, respectively), other companies have carved out their
    own niches within the FPGA market. For example, Lattice Semiconductor has done
    well for itself making mostly smaller, less expensive FPGAs. Lattice has been
    happy to play on its own in this lower end of the market, while letting AMD and
    Intel slug it out at the higher end. Today, the open source community has embraced
    Lattice FPGAs, which have been reverse-engineered to allow for low-level hacking.
    Another medium-sized player in the FPGA space, Actel, was acquired by Microsemi
    in 2010 for $430 million. Microsemi itself was acquired by Microchip Technology
    in 2018.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Popular FPGA Applications</samp>
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In their modern, highly capable and flexible form, FPGAs are used in many interesting
    areas. For example, they’re a critical component in the telecommunications industry,
    where they’re often found in cell phone towers. They route internet traffic to
    bring the internet to your smartphone, allowing you to stream YouTube videos on
    your bus ride to work.
  prefs: []
  type: TYPE_NORMAL
- en: FPGAs are also widely used in the finance industry for high-frequency trading,
    where companies use algorithms to automatically buy and sell stocks incredibly
    quickly. Traders have found that if you can execute a stock purchase or sale slightly
    quicker than the competition, you can gain a financial edge. The speed of execution
    is paramount; a tiny bit of latency can cost a company millions of dollars. FPGAs
    are well suited to this task because they’re very fast and can be reprogrammed
    as new trading algorithms are discovered. This is an industry where milliseconds
    matter, and FPGAs can provide an advantage.
  prefs: []
  type: TYPE_NORMAL
- en: FPGAs are used in the defense industry as well, for applications like radar
    digital signal processing. FPGAs can process received radar reflections using
    mathematical filters to see small objects hundreds of miles away. They’re also
    used to process and manipulate images from infrared (IR) cameras, which can see
    heat rather than visible light, allowing military operatives to see people even
    in complete darkness. These operations are often highly math-intensive, requiring
    many multiplication and addition operations to happen at parallel—something that
    FPGAs excel at.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another area where FPGAs have found a niche is in the space industry: they
    can be programmed with redundancies to hedge against the effects of radiation
    bombardment, which can cause digital circuits to fail. On Earth, the atmosphere
    protects electronics (and people) from lots of solar radiation, but outer space
    doesn’t have that lovely blanket, so the electronics on satellites are subjected
    to a much harsher environment.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, FPGAs are also getting interest from the artificial intelligence (AI)
    community. They can be used to accelerate neural nets, another massively parallel
    computational problem, and thus are helping humans attack issues that weren’t
    solvable using traditional programming techniques: image classification, speech
    recognition and translation, robotics control, game strategy, and more.'
  prefs: []
  type: TYPE_NORMAL
- en: This look at popular FPGA applications is far from exhaustive. Overall, FPGAs
    are a good candidate for any digital electronics problem where high bandwidth,
    low latency, or high processing capability is needed.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Comparing Common Digital Logic Components</samp>
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Despite how far they’ve come since their early days and the wide range of applications
    they’re used for, FPGAs are still a relatively niche technology compared to other
    digital logic components like microcontrollers and ASICs. In this section, we’ll
    compare these three technologies. You’ll see why FPGAs are a good solution for
    some problems but not others, and how they have tough competition from other devices,
    especially microcontrollers.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">FPGAs vs. Microcontrollers</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Microcontrollers are everywhere. If you aren’t an embedded software engineer,
    you may not realize how many toys, tools, gadgets, and devices are controlled
    with small and inexpensive microcontrollers: everything from TV remote controls
    to coffee makers to talking toys. If you’re an electronics hobbyist, you might
    be familiar with the *Arduino*, which is powered by a small microcontroller from
    Atmel (now Microchip Technology, the same company that owns what used to be Actel).
    Millions of Arduinos have been sold to hobbyists around the world. They’re cheap,
    fun, and relatively easy to work with.'
  prefs: []
  type: TYPE_NORMAL
- en: So why are microcontrollers everywhere, but not FPGAs? Why isn’t there an FPGA
    controlling your coffee maker or making your Elmo doll come to life? The main
    reason is cost. The consumer electronics industry, which uses the largest number
    of microcontrollers overall, is incredibly sensitive to cost. Consumers like you
    and I want the least expensive products we can possibly buy, and the companies
    that make those products will shave off every penny possible to make that happen.
  prefs: []
  type: TYPE_NORMAL
- en: Microcontrollers come in seemingly endless varieties, with each one designed
    for a very specific purpose. This helps companies drive costs down. For example,
    if your product needs one analog-to-digital converter (ADC), two USB interfaces,
    and at least 30 general purpose input/output (GPIO) pins, there’s a microcontroller
    with exactly those specifications. What if you realize you only need one USB interface?
    There’s probably a different microcontroller with those specifications, too. With
    such variety, there’s no need to pay for extra features. Companies can find a
    microcontroller with the bare minimum of what they need, and save money in the
    process.
  prefs: []
  type: TYPE_NORMAL
- en: FPGAs, on the other hand, are much more general. With a single FPGA, you might
    create five ADC interfaces and no USB interface, or three USB and no ADC interfaces.
    You pretty much have a blank slate at your disposal. As you’ll learn, however,
    FPGAs need to have many internal wires (called *routing*) to support all these
    different possibilities, and all that routing adds cost and complexity. In many
    cases, you’ll end up paying more for extra features and flexibility that you don’t
    need.
  prefs: []
  type: TYPE_NORMAL
- en: Another contributing factor to cost is quantity. If you buy 10 million microcontrollers,
    which is not unrealistic in the field of consumer electronics, you’ll pay less
    per chip than you would if you only bought 100,000\. FPGAs, meanwhile, are typically
    produced and sold in relatively low quantities, so they cost more per unit. It’s
    a bit of a chicken-and-egg situation, where FPGAs could be less expensive if there
    were more of them, but for there to be more of them, they would have to be less
    expensive. If the costs were the same as with microcontrollers, would there be
    more FPGAs in use? I think it’s likely that there would be, but FPGAs are also
    more complicated to use, so that works against them as well.
  prefs: []
  type: TYPE_NORMAL
- en: 'Since microcontrollers are designed for specific purposes, they can be very
    easy to set up. You can get a basic design up and running on a microcontroller
    in a few hours. By contrast, you need to program *everything* inside the FPGA,
    and this is very time-consuming. Although there are some hard IP blocks to get
    you started, the majority of the device is programmable logic—that blank slate
    we talked about—that you need to design yourself. Writing all the code to do what
    you need also takes longer in a language like Verilog or VHDL than C, which is
    commonly used to program microcontrollers. With C, you’re writing code at a higher
    level, so you can do more with a single line. With Verilog and VHDL you’re writing
    at a much lower level: individual gates and wires are literally being created
    with your code. You can think of low-level programming like working with individual
    LEGO bricks and high-level programming like working with preconstructed LEGO sets.
    This adds complexity, which adds time, which also increases costs. Engineers want
    the simplest solution, and most often a microcontroller is simpler than an FPGA.'
  prefs: []
  type: TYPE_NORMAL
- en: Another factor to consider is how much power the device consumes. Many electronic
    devices run off batteries, and it’s critical to maximize their lifetime by making
    the devices as low-power as possible. The more power they use, the more often
    you’ll have to change the batteries, which is something nobody wants to do. Again,
    since a microcontroller is designed for a specific use, it can be optimized to
    draw incredibly little power, enabling a single AAA battery to power a Bluetooth
    mouse for months, for example. FPGAs, with all their routing resources, are simply
    unable to compete with microcontrollers in terms of power consumption. That’s
    not to say you can’t use an FPGA in a battery-powered application, but head-to-head
    the microcontroller will win that battle every time.
  prefs: []
  type: TYPE_NORMAL
- en: Summarizing, microcontrollers almost always dominate in terms of cost, ease
    of use, and power consumption. So why would anyone use an FPGA over a microcontroller?
    There are other factors to consider, such as speed and flexibility, and here the
    tables turn in favor of the FPGA.
  prefs: []
  type: TYPE_NORMAL
- en: 'When I say speed, I mean two things: bandwidth and computations. *Bandwidth*
    is the rate of data transfer across a path. FPGAs can have incredibly large bandwidth,
    much more than any microcontroller could ever attain. They can process hundreds
    of gigabits per second with no trouble at all. This might be useful, for example,
    when driving multiple 4K displays. FPGAs are often used in video editing hardware
    that requires enormous amounts of bandwidth to keep up with the data streams.
    Their high bandwidth allows them to move tremendous amounts of data from various
    external interfaces (USB-C, Ethernet, ADCs, memories, and more) at very fast rates.'
  prefs: []
  type: TYPE_NORMAL
- en: As for computational speed, the number of mathematical computations an FPGA
    can perform in a second dwarfs anything a microcontroller can do. A microcontroller
    usually has just one processor, and with all computations going through the same
    processor, the number of computations that can be performed each second is limited.
    An FPGA, on the other hand, can run many computations in parallel. For example,
    you can run hundreds of multiplication operations at the same time, something
    that simply isn’t possible with a microcontroller. This might be useful when running
    large mathematical filters on data, which often involve many multiplication and
    addition operations occurring at very fast rates.
  prefs: []
  type: TYPE_NORMAL
- en: The other major benefit of an FPGA is its flexibility. I said microcontrollers
    come in endless varieties, but of course, this is a slight exaggeration. If your
    design has some particularly exotic requirement—say, if it needs 16 ADC interfaces—there
    might not be any microcontroller in the world that will meet your needs. FPGAs
    are much less limited. As I’ve mentioned, an FPGA is like a blank slate that can
    be programmed to do almost anything, providing you with tremendous flexibility
    to tackle a wide range of digital logic problems.
  prefs: []
  type: TYPE_NORMAL
- en: 'When you have an engineering problem, you need to choose the best tool possible
    to solve it. Often a microcontroller works very well, but occasionally it simply
    won’t work due to speed or flexibility issues. In those situations, an FPGA is
    a good candidate. However, there’s also another kind of device worth considering:
    an ASIC.'
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">FPGAs vs. ASICs</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: An ASIC is a type of integrated circuit designed for a particular use. Unlike
    an FPGA, which can suit any number of uses, an ASIC is designed to be really good
    at one thing. You might think that it would always be better to have the flexibility
    of an FPGA, but there are trade-offs to consider. We’ve already compared FPGAs
    to microcontrollers in terms of cost, ease of use, power, speed, and flexibility.
    Let’s now compare FPGAs and ASICs along those same lines.
  prefs: []
  type: TYPE_NORMAL
- en: 'ASICs are incredibly expensive to make in low quantities because they have
    a large *nonrecurring engineering (NRE)* cost: you need to pay a lot of money
    up front to a semiconductor foundry (or *fab*) to get that first ASIC chip. Often
    the NRE on an ASIC design can run into the millions of dollars. Whether or not
    you choose to design an ASIC highly depends on how many chips you’ll need. If
    you’re making low quantities of something, even into the tens of thousands, it’s
    unlikely you’ll ever be able to recover the up-front cost of an ASIC. If you need
    millions of chips, however, then an ASIC starts to become an attractive option,
    since each chip after the first one is very cheap (often under $1). Compare that
    to an FPGA, where a single chip often costs more than $10, and you start to see
    that FPGAs just don’t make financial sense in large volumes. Generalizing, in
    smaller quantities FPGAs usually win against ASICs, but in larger quantities they
    can’t compete as well.'
  prefs: []
  type: TYPE_NORMAL
- en: An area where FPGAs always win out over ASICs is in terms of ease of use. The
    process of designing an ASIC is very complicated. Plus, you need to make sure
    your design is free of bugs *before* you go to the fab to make the chip, or you’ll
    have wasted your NRE. Most FPGAs, on the other hand, can be fixed in the field
    (hence *field programmable*), so even if you find a bug after shipping your product
    to customers, you can update the code and remedy the issue. That’s simply not
    possible with an ASIC. Therefore, you must spend significant engineering time
    and effort verifying that your ASIC design is as bug-free as possible before getting
    it fabricated. There’s actually an entire discipline called *verification engineering*
    that does just this, something we’ll explore in more detail in [Chapter 5](chapter5.xhtml).
  prefs: []
  type: TYPE_NORMAL
- en: One large benefit to an ASIC is that it can be optimized for low power. ASICs
    are finely tuned for their specific application; they have what they need and
    no more. Meanwhile, recall that an FPGA has a significant number of wires and
    interconnections, which give it its flexibility but mean it uses more power. A
    further advantage ASICs have over FPGAs is that they can use fabrication techniques
    that optimize them for low power at the transistor level. For a real-life example,
    when Bitcoin was new, people were using their home computers (CPUs) to mine it.
    This draws a lot of power per Bitcoin mined. Eventually, people realized that
    FPGAs could be programmed to mine Bitcoins, using less power than CPUs. Electrical
    power is expensive, so mining Bitcoins with FPGAs was more profitable. Further
    down the line, people realized that ASICs could mine Bitcoins even faster and
    using even less power than FPGAs. It became worth the up-front cost to create
    an ASIC dedicated to Bitcoin mining, because the cost savings from the lower power
    consumption were so significant. Today, Bitcoins are mined almost exclusively
    with ASICs.
  prefs: []
  type: TYPE_NORMAL
- en: 'When it comes to speed, FPGAs and ASICs both have large bandwidth and can move
    lots of data around. They’re also both very capable at math operations, particularly
    multiplication and addition, and both can do those operations in parallel. ASICs
    have a small edge in this category: because they’re built specifically for one
    purpose, they can often run a bit faster than FPGAs.'
  prefs: []
  type: TYPE_NORMAL
- en: FPGAs, on the other hand, offer significantly more flexibility than ASICs. Having
    flexibility in what your design can do is very valuable, especially if you’re
    working on a project that isn’t clearly defined. Unlike ASICs, which are fixed,
    FPGAs can be reprogrammed over and over again, with features and functionality
    added or removed. Additionally, ASICs take a long time to design, make, and verify,
    but you can get started with an FPGA right away, so the speed of progress can
    be faster.
  prefs: []
  type: TYPE_NORMAL
- en: In general, ASICs win against FPGAs on cost when the volumes are very high,
    but not when they’re low. They beat FPGAs on power consumption and have a slight
    edge on speed, but they lose to FPGAs on flexibility and ease of use. In reality,
    though, ASICs and FPGAs often go hand in hand. When a company wants to design
    an ASIC, it will typically start by designing a prototype with an FPGA, and then
    produce the ASIC. This method allows engineers to work with the hardware sooner
    and gain confidence in the product, prior to spending millions of dollars on a
    custom chip. The engineers can work through the bugs in the Verilog or VHDL code
    using the FPGA prototype, and fix issues when it’s inexpensive and simpler to
    do so. This code isn’t throwaway code either, since the same Verilog or VHDL used
    on an FPGA can be used to create an ASIC.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">FPGAs vs. Microcontrollers
    vs. ASICs</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: That was a lot to take in, so let’s briefly summarize what we’ve just discussed
    about FPGAs, microcontrollers, and ASICs. [Table 1-1](#tab1-1) provides an overview
    of where each type of device sits on the scale across different parameters. There
    are always exceptions, but the table provides a good generalization.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Heavy_B_11">Table 1-1:</samp> <samp class="SANS_Futura_Std_Book_11">Comparing
    an FPGA vs. a Microcontroller vs. an ASIC</samp>
  prefs: []
  type: TYPE_NORMAL
- en: '|  | <samp class="SANS_Futura_Std_Heavy_B_11">FPGA</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">Microcontroller</samp>
    | <samp class="SANS_Futura_Std_Heavy_B_11">ASIC</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">Cost (low quantities)</samp> | <samp
    class="SANS_Futura_Std_Book_11">Moderate</samp> | <samp class="SANS_Futura_Std_Book_11">Cheap</samp>
    | <samp class="SANS_Futura_Std_Book_11">Expensive</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">Cost (high quantities)</samp> |
    <samp class="SANS_Futura_Std_Book_11">Moderate</samp> | <samp class="SANS_Futura_Std_Book_11">Cheap</samp>
    | <samp class="SANS_Futura_Std_Book_11">Cheap</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">Speed</samp> | <samp class="SANS_Futura_Std_Book_11">Fast</samp>
    | <samp class="SANS_Futura_Std_Book_11">Moderate</samp> | <samp class="SANS_Futura_Std_Book_11">Fast</samp>+
    |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">Power</samp> | <samp class="SANS_Futura_Std_Book_11">Moderate</samp>
    | <samp class="SANS_Futura_Std_Book_11">Low</samp> | <samp class="SANS_Futura_Std_Book_11">Low</samp>
    |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">Flexibility</samp> | <samp class="SANS_Futura_Std_Book_11">High</samp>
    | <samp class="SANS_Futura_Std_Book_11">Low</samp> | <samp class="SANS_Futura_Std_Book_11">None</samp>
    |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">Ease of use</samp> | <samp class="SANS_Futura_Std_Book_11">Medium</samp>
    | <samp class="SANS_Futura_Std_Book_11">Easy</samp> | <samp class="SANS_Futura_Std_Book_11">Difficult</samp>
    |'
  prefs: []
  type: TYPE_TB
- en: Cost is often the dominant factor in why a microcontroller or an ASIC is chosen
    over an FPGA for large-volume applications. They’re simply cheaper, and that counts
    in industries that are highly sensitive to cost. When performance is the most
    important consideration and the high initial cost and level of complexity are
    acceptable, ASICs are often preferred. The sweet spot for FPGAs is applications
    that are low volume but require high speed in terms of either bandwidth or computations,
    or require a very flexible and unique design (like having 16 ADCs to interface
    to).
  prefs: []
  type: TYPE_NORMAL
- en: Ultimately, FPGAs, microcontrollers, and ASICs are three tools in the engineer’s
    toolbox. When looking at the requirements of your particular problem, you’ll need
    to decide which of these tools provides the best solution. You wouldn’t use a
    hammer to turn a screw; knowing which tool to use for which application is critical
    to becoming a strong engineer. The act of examining multiple possibilities and
    selecting a technical solution is often referred to in engineering as a *trade
    study*.
  prefs: []
  type: TYPE_NORMAL
- en: 'I love FPGAs, but when I look at a technical problem, often the right solution
    is a microcontroller: they’re easy to use and inexpensive. A microcontroller isn’t
    *always* the right solution, though. Sometimes you need more speed, or the problem
    is one that microcontrollers just aren’t designed for. Selecting the right tool
    for your problem will make solving the problem much more enjoyable. And as you’ll
    hopefully see, working with FPGAs is certainly enjoyable! It’s like working with
    LEGO or building a house in Minecraft. Using simple, low-level building blocks,
    you can create something wonderfully complex.'
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Verilog and VHDL</samp>
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As I’ve mentioned, there are two main languages for working with FPGAs (and
    ASICs): Verilog and VHDL. These languages are known as *hardware description languages
    (HDLs)* because they’re used to define the behavior of digital logic circuits.
    Though syntactically Verilog and VHDL may look similar to traditional programming
    languages, it’s important to realize that HDLs are a different beast entirely.
    When you write your FPGA code with an HDL, you’re working directly with wires,
    logic gates, and other discrete resources on the FPGA, whereas when you code with
    a traditional programming language you don’t have that same low level of control
    over your device. Understanding the logic behind your Verilog or VHDL code and
    knowing what FPGA components you’re instantiating with that code is a critical
    skill for a digital designer, and something we’ll return to throughout the book.'
  prefs: []
  type: TYPE_NORMAL
- en: FPGA beginners often wonder if it’s better to learn Verilog or VHDL. There’s
    no right answer; it really depends on your situation. To help you make that decision,
    let’s compare and contrast the two languages to identify some reasons why you
    might select one over the other.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Dogma_OT_Bold_B_21">NOTE</samp>
  prefs: []
  type: TYPE_NORMAL
- en: '*All the code examples in this book will be shown in both Verilog and VHDL,
    back-to-back, so whichever language you choose, you’ll be able to follow along.*'
  prefs: []
  type: TYPE_NORMAL
- en: VHDL stands for VHSIC Hardware Description Language, and VHSIC, the acronym
    within an acronym, stands for Very High-Speed Integrated Circuit. In full, VHDL
    is the *Very High-Speed Integrated Circuit Hardware Description Language*—quite
    a mouthful! It was developed by the United States Department of Defense (DoD)
    in 1983 and borrows many features and syntax from another DoD-developed language
    called Ada. VHDL, like Ada, is strongly typed.
  prefs: []
  type: TYPE_NORMAL
- en: If you’ve never worked with a strongly typed language, it can be a bit challenging
    at first. Strong typing forces the designer to be very explicit with their code.
    For example, in a weakly typed language like Python or C, you can add a variable
    defined as an integer to a variable defined as a float without any problem. A
    strongly typed language like VHDL, however, would never allow something like this.
    When adding two numbers in VHDL, their widths (number of bits) and types need
    to match exactly, or the syntax checker will throw some cryptic error. Until you
    understand the strong type checking that the language is performing, it can be
    cumbersome to get what you need done as a beginner. When sorting out these issues
    in VHDL, you often need to create intermediary signals of the correct type, or
    use lots of type conversions throughout your code. This is one of several reasons
    VHDL often requires much more typing (on your keyboard, that is) than Verilog
    to perform the same functionality. If you want to use VHDL, it helps to be a fast
    typist.
  prefs: []
  type: TYPE_NORMAL
- en: Compared to VHDL, Verilog looks more similar to a software language like C,
    which makes it easier for some people to read Verilog code and understand what
    it’s doing. Also, Verilog is weakly typed. It allows you to write code that’s
    wrong, but more concise. It would have no problem adding a float to an integer,
    even if the result of that addition might be incorrect.
  prefs: []
  type: TYPE_NORMAL
- en: Another interesting point of comparison is that Verilog is case sensitive but
    VHDL is not. This means that a variable called <samp class="SANS_TheSansMonoCd_W5Regular_11">RxDone</samp>
    isn’t the same as a variable called <samp class="SANS_TheSansMonoCd_W5Regular_11">rxDone</samp>
    in Verilog, but VHDL treats them as the same. It might seem odd that strongly
    typed VHDL isn’t case sensitive while weakly typed Verilog is, but that’s just
    the way history turned out. In my experience, Verilog’s case sensitivity can create
    issues that are hard to diagnose. You might think two signals are the same, but
    the code sees them as different due to a capitalization discrepancy.
  prefs: []
  type: TYPE_NORMAL
- en: Ultimately, none of these points is the most important factor, though. You should
    choose between Verilog and VHDL based on which language you’re more likely to
    use in school or at work. If your university uses Verilog, learn Verilog! If companies
    where you might want to work use VHDL, learn VHDL! The breakdown of who uses VHDL
    versus Verilog is highly dependent on where in the world you’re living. If you
    compare VHDL and Verilog using Google Trends, you can start to get a pretty good
    idea of which language you should be learning first.
  prefs: []
  type: TYPE_NORMAL
- en: When you look at the overall search volumes for the two terms throughout the
    world, you’ll find that “Verilog” tends to have more searches than “VHDL.” Maybe
    that’s because it’s used more often, or maybe people have more trouble with Verilog
    and need to look up solutions online more than they do with VHDL. In any case,
    it’s more revealing to break down the trends on a country-by-country basis. [Figure
    1-1](#fig1-1) shows some examples.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Figure1-1.png)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 1-1: Verilog vs. VHDL
    search volumes in selected countries</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: India and the United States have the largest volumes of Google searches for
    the two terms, but while VHDL and Verilog appear to be roughly equal in popularity
    in India, Verilog is slightly more popular in the United States than VHDL. In
    fact, I know from personal experience that in the United States the defense industry
    favors VHDL, while the commercial industry favors Verilog. Notice that in Germany
    and France, VHDL is significantly more popular than Verilog. If you are from either
    of these two countries, I would highly recommend learning VHDL first! Conversely,
    in China and South Korea Verilog is much more popular than VHDL, so adjust your
    priorities accordingly.
  prefs: []
  type: TYPE_NORMAL
- en: In general, VHDL and Verilog are equally capable languages. You should choose
    which language to learn based on what suits your location and circumstances.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Summary</samp>
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This chapter introduced you to FPGAs and provided you with an overview of their
    history and common applications. We compared FPGAs with microcontrollers and ASICs
    and saw where each type of integrated circuit really shines. You learned that
    FPGAs excel at applications that aren’t cost sensitive, but where high speed,
    maximum flexibility, or unique interfaces are required. Finally, we looked at
    the two most popular hardware description languages used to work with FPGAs, Verilog
    and VHDL, and discussed how to choose the right language for you and your situation.
  prefs: []
  type: TYPE_NORMAL
