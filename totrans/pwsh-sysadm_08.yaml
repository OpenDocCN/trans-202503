- en: '7'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: EXPLORING MODULES
  prefs: []
  type: TYPE_NORMAL
- en: '![Images](../images/common.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In the preceding chapter, you learned about functions. Functions break a script
    into manageable units, giving you more efficient, more readable code. But there’s
    no reason a good function should exist in only a script or single session. In
    this chapter, you’ll learn about *modules*, groups of similar functions that are
    packaged together and distributed for others to use across many scripts.
  prefs: []
  type: TYPE_NORMAL
- en: In its purest form, a PowerShell module is just a text file with a *.psm1* file
    extension and some optional, extra metadata. Other types of modules that don’t
    fit this description are known as *binary modules* and *dynamic modules*, but
    they are outside the scope of this book.
  prefs: []
  type: TYPE_NORMAL
- en: Any command that hasn’t been explicitly placed in your session almost certainly
    comes from a module. Many of the commands you’ve been using throughout this book
    are part of Microsoft’s internal modules that come with PowerShell, but there
    are also third-party modules and the ones you create yourself. To use a module,
    you first have to install it. Then, when a command inside a module needs to be
    used, that module has to be imported into your session; as of PowerShell v3, PowerShell
    auto-imports modules when a command is referenced.
  prefs: []
  type: TYPE_NORMAL
- en: You’ll begin this chapter by looking at the models that are already installed
    in your system. Then, you’ll take apart a model to see its different parts before
    finally looking at how to download and install PowerShell modules from the PowerShell
    Gallery.
  prefs: []
  type: TYPE_NORMAL
- en: Exploring Default Modules
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: PowerShell comes with numerous modules installed by default. In this section,
    you’ll see how to discover and import modules from your session.
  prefs: []
  type: TYPE_NORMAL
- en: Finding Modules in Your Session
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: You can see the modules imported into your current session by using the `Get-Module`
    cmdlet (which is itself part of a module). The `Get-Module` cmdlet is a command
    that allows you to see all the modules on your system available to you in your
    current session.
  prefs: []
  type: TYPE_NORMAL
- en: Start a fresh PowerShell session and run `Get-Module`, as in [Listing 7-1](ch07.xhtml#ch7list1).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 7-1: Viewing imported modules with the `Get-Module` command*'
  prefs: []
  type: TYPE_NORMAL
- en: Each line you see from this `Get-Module` output is a module that has been imported
    into the current session, which means all the commands inside that module are
    immediately available to you. The `Microsoft.PowerShell.Management` and `Microsoft.PowerShell.Utility`
    modules are imported in any PowerShell session by default.
  prefs: []
  type: TYPE_NORMAL
- en: Notice the `ExportedCommands` column in [Listing 7-1](ch07.xhtml#ch7list1).
    These are the commands you can use from the module. You can easily find all of
    these commands by using `Get-Command` and specifying the module name. Let’s check
    out all the exported commands inside the `Microsoft.PowerShell.Management` module
    in [Listing 7-2](ch07.xhtml#ch7list2).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 7-2: Viewing commands inside a PowerShell module*'
  prefs: []
  type: TYPE_NORMAL
- en: These are all the commands that are exported from that module; these are the
    ones that can be explicitly called from outside the module. Some module authors
    choose to include functions inside their modules that a user cannot use. Any function
    that is not exported to a user, and only does work inside a script or module,
    is called a *private function*, or what some developers refer to as a *helper
    function*.
  prefs: []
  type: TYPE_NORMAL
- en: Using `Get-Module` without any parameters will return all modules that are imported,
    but what about the modules that have been installed but not imported?
  prefs: []
  type: TYPE_NORMAL
- en: Finding Modules on Your Computer
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: To get a list of all modules that are installed and can be imported into your
    session, you can use `Get-Module` with the `ListAvailable` parameter, as in [Listing
    7-3](ch07.xhtml#ch7list3).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 7-3: Using `Get-Module` to view all available modules*'
  prefs: []
  type: TYPE_NORMAL
- en: The `ListAvailable` parameter tells PowerShell to check a few folders for any
    subfolders with *.psm1* files in them. PowerShell will then read each of those
    modules from the filesystem and return a list of each module’s name, some metadata,
    and all the functions that can be used from that module.
  prefs: []
  type: TYPE_NORMAL
- en: 'PowerShell looks for modules on disk in a few default locations, depending
    on the type of module:'
  prefs: []
  type: TYPE_NORMAL
- en: '**System modules** Nearly all modules that come installed by default with PowerShell
    will be located in *C:\Windows\System32\WindowsPowerShell\1.0\Modules*. This module
    path is typically dedicated for internal PowerShell modules only. Technically,
    you could place modules in this folder, but it’s not recommended you do so.'
  prefs: []
  type: TYPE_NORMAL
- en: '**All Users modules** Modules are also stored in *C:\Program Files\WindowsPowerShell\Modules*.
    This path is loosely called the *All Users* module path, and it’s where you put
    any modules you’d like available to all users who log into the computer.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Current User modules** Lastly, you can store modules in *C:\Users\<LoggedInUser>\Documents\WindowsPowerShell\Modules*.
    Inside this folder, you’ll find all modules that you’ve created or downloaded
    that are available to only the current user. Placing modules in this path allows
    for some separation if multiple users with different requirements will be logging
    into the computer.'
  prefs: []
  type: TYPE_NORMAL
- en: When `Get-Module -ListAvailable` is called, PowerShell will read all these folder
    paths and return all the modules in each. However, these aren’t the only possible
    module paths, just the defaults.
  prefs: []
  type: TYPE_NORMAL
- en: You can tell PowerShell to add a new module path by using the `$PSModulePath`
    environment variable, which defines each module folder separated by a semicolon,
    as shown in [Listing 7-4](ch07.xhtml#ch7list4).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 7-4: The `PSModulePath` environment variable*'
  prefs: []
  type: TYPE_NORMAL
- en: 'You can add folders to the `PSModulePath` environment variable by doing a little
    string parsing, although this technique may be a little advanced. Here’s a quick
    one-liner:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'However, be aware that this adds the new folder in only the current session.
    To make this change persistent, you need to use the `SetEnvironmentVariable()`
    method on the `Environment` .NET class, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Let’s now see how to use the modules you have by importing them.
  prefs: []
  type: TYPE_NORMAL
- en: Importing Modules
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Once a module folder path is in the `PSModulePath` environment variable, you
    have to import the module into the current session. Nowadays, because of PowerShell’s
    auto-importing feature, if you have a module installed, you can usually call the
    function you want first, and PowerShell will auto-import the module it belongs
    to. Still, it’s important to understand how importing works.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s use a default PowerShell module called `Microsoft.PowerShell.Management`.
    In [Listing 7-5](ch07.xhtml#ch7list5), you’ll run `Get-Module` twice: once in
    a fresh PowerShell session, and once after using the `cd` command, an alias for
    `Set-Location`, a command found in the `Microsoft.PowerShell.Management` module.
    Look what happens:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 7-5: PowerShell auto-imports `Microsoft.PowerShell.Management` after
    using `cd`.*'
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, `Microsoft.PowerShell.Management` is auto-imported after you
    use `cd`. The auto-import feature usually works. But if you’re expecting a command
    inside a module to be available and it’s not, a problem with the module might
    be preventing the command’s import.
  prefs: []
  type: TYPE_NORMAL
- en: To manually import a module, use the `Import-Module` command, as in [Listing
    7-6](ch07.xhtml#ch7list6).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 7-6: Importing a module manually, reimporting it, and removing it*'
  prefs: []
  type: TYPE_NORMAL
- en: You’ll notice this listing also uses the `Force` parameter and the `Remove``-Module`
    command. If the module has been changed (say you’ve made changes to a custom module),
    you can use the `Import-Module` command with the `Force` parameter to unload and
    reimport the module. The `Remove-Module` unloads a module from a session, although
    this command is not used often.
  prefs: []
  type: TYPE_NORMAL
- en: The Components of a PowerShell Module
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Now that you’ve learned how to use a PowerShell module, let’s see what they
    look like.
  prefs: []
  type: TYPE_NORMAL
- en: The .psm1 File
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Any text file with a .*psm1* file extension can be a PowerShell module. For
    this file to be useful, it must have functions inside it. While not strictly required,
    all functions inside a module should be built around the same concept. For example,
    [Listing 7-7](ch07.xhtml#ch7list7) shows some functions dealing with software
    installation.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 7-7: Functions dealing with software installation*'
  prefs: []
  type: TYPE_NORMAL
- en: Notice that the noun in each command’s name stays the same, and only the verb
    changes. This is best practice when building modules. If you find yourself needing
    to change the noun, then you should start thinking about breaking one module into
    multiple modules.
  prefs: []
  type: TYPE_NORMAL
- en: The Module Manifest
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Besides a *.psm1* file full of functions, you’ll also have a module manifest,
    or a *.psd1* file. A *module manifest* is an optional but recommended text file
    written in the form of a PowerShell hashtable. This hashtable contains elements
    that describe metadata about the module.
  prefs: []
  type: TYPE_NORMAL
- en: It’s possible to create a module manifest from scratch, but PowerShell has a
    `New-ModuleManifest` command that can generate a template for you. Let’s use `New-ModuleManifest`
    to build a module manifest for our software package, as in [Listing 7-8](ch07.xhtml#ch7list8).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 7-8: Using the `New-ModuleManifest` to build a module manifest*'
  prefs: []
  type: TYPE_NORMAL
- en: 'This command creates a *.psd1* file that looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: As you can see when running the command, there are plenty of fields for which
    I didn’t provide parameters. We’re not going to go in depth on module manifests.
    For now, just know that, at a minimum, always define the `RootModule`, `Author`,
    `Description`, and perhaps the `version`. All of these attributes are optional,
    but it’s always good practice to get in the habit of adding as much information
    to the module manifest as possible.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you’ve seen the anatomy of a module, let’s see how to download and
    install one.
  prefs: []
  type: TYPE_NORMAL
- en: Working with Custom Modules
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Thus far, you’ve been working with only the modules installed in PowerShell
    by default. In this section, you’ll see how to find, install, and uninstall custom
    modules.
  prefs: []
  type: TYPE_NORMAL
- en: Finding Modules
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'One of the best parts of modules is sharing them: why waste your time solving
    a problem that’s already been solved? Chances are, if you’re running into a problem,
    the PowerShell Gallery has a solution. The *PowerShell Gallery* (*[https://www.powershellgallery.com/](https://www.powershellgallery.com/)*)
    is a repository of thousands of PowerShell modules and scripts that anyone with
    an account can freely upload to or download from. It has modules written by single
    individuals, and modules written by gigantic corporations like Microsoft.'
  prefs: []
  type: TYPE_NORMAL
- en: Lucky for us, you can also use the Gallery from PowerShell itself. PowerShell
    has a built-in module called `PowerShellGet` that provides simple-to-use commands
    to interact with the PowerShell Gallery. [Listing 7-9](ch07.xhtml#ch7list9) uses
    `Get-Command` to pull up the `PowerShellGet` commands.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 7-9: The `PowerShellGet` commands*'
  prefs: []
  type: TYPE_NORMAL
- en: The `PowerShellGet` module includes commands for finding, saving, and installing
    modules, as well as publishing your own. You’re not quite ready to publish modules
    yet (you haven’t even created your own!), so we’ll focus on how to find and install
    modules from the PowerShell Gallery.
  prefs: []
  type: TYPE_NORMAL
- en: To find a module, you use the `Find-Module` command, which allows you to search
    the PowerShell Gallery for modules matching a specific name. If you’re looking
    for modules to manage a VMware infrastructure, for example, you can use wildcards
    with the `Name` parameter to find all modules in the PowerShell Gallery that have
    the word *VMware* in them, as in [Listing 7-10](ch07.xhtml#ch7list10).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 7-10: Using `Find-Module` to locate modules related to VMware*'
  prefs: []
  type: TYPE_NORMAL
- en: The `Find-Module` command doesn’t download anything; it just shows you what’s
    in the PowerShell Gallery. In the next section, you’ll see how to install the
    modules.
  prefs: []
  type: TYPE_NORMAL
- en: Installing Modules
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Once you have a module you want to install, you can use the `Install-Module`
    command to install it. The `Install-Module` command can take a `Name` parameter,
    but let’s use the pipeline and simply send the objects that `Find-Module` returns
    directly to the `Install-Module` command ([Listing 7-11](ch07.xhtml#ch7list11)).
  prefs: []
  type: TYPE_NORMAL
- en: Note that you may receive a warning about an untrusted repository. You will
    receive this untrusted warning because, by default, the `Find-Module` command
    uses a PowerShell repository that is untrusted, meaning you must explicitly tell
    PowerShell to trust all packages inside that repository. Otherwise, it will prompt
    you to run `Set-PSRepository`, as shown in [Listing 7-11](ch07.xhtml#ch7list11),
    to change the installation policy for that repository.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 7-11: Installing a module by using the `Install-Module` command*'
  prefs: []
  type: TYPE_NORMAL
- en: 'By default, the command in [Listing 7-11](ch07.xhtml#ch7list11) will download
    the module and place it into the All Users module path in *C:\Program Files*.
    To check that the module is in this path, you can use the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Uninstalling Modules
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Newcomers to PowerShell often get confused by the difference between removing
    and uninstalling a module. As you saw in “Importing Modules” on [page 82](ch07.xhtml#page_82),
    you can use `Remove-Module` to *remove* a module from the PowerShell session.
    But this only unloads the module from the session; it doesn’t remove the module
    from your disk.
  prefs: []
  type: TYPE_NORMAL
- en: To take a module off the disk—or *uninstall* it—you have to use the `Uninstall-Module`
    cmdlet. [Listing 7-12](ch07.xhtml#ch7list12) uninstalls the module you just installed.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 7-12: Uninstalling a module*'
  prefs: []
  type: TYPE_NORMAL
- en: Only modules downloaded from the PowerShell Gallery will be uninstalled via
    `Uninstall-Module`—the default modules are there to stay!
  prefs: []
  type: TYPE_NORMAL
- en: Creating Your Own Module
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: So far, you’ve been working with other people’s modules. Of course, one of the
    amazing things about PowerShell modules is you can create your own and share it
    with the rest of the world. You’ll spend [Part III](part3.xhtml#part3) of this
    book building a real-world module, but for now, let’s see how to turn your Software
    module into a real module.
  prefs: []
  type: TYPE_NORMAL
- en: As you saw earlier, a typical PowerShell module consists of a folder (the *module
    container*), *.psm1* file (the module), and a *.psd1* file (the module manifest).
    If the module folder is in one of the three locations (System, All Users, or Current
    User), PowerShell will automatically see this and import it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s first create the module folder. The module folder must be the same name
    as the module itself. Since I tend to make modules available for all users on
    a system, you’ll add it to the All Users module path, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Once you create the folder, make a blank *.psm1* file that will eventually
    hold your functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, create the module manifest just as you did in [Listing 7-8](ch07.xhtml#ch7list8):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'At this point, PowerShell should be able to see your module, but notice it
    does not see any exported commands yet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s add the three functions you used earlier into the *.psm1* file and see
    if PowerShell recognizes them now:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: PowerShell has exported all the commands inside your module and made them available
    for use. If you want to go the extra mile and choose which commands get exported,
    you can also open your module manifest and find the `FunctionsToExport` key. In
    there, you can define each command, separated by a comma, which will then dictate
    which commands get exported. Although not mandatory, it provides a more granular
    approach to exporting module functions.
  prefs: []
  type: TYPE_NORMAL
- en: Congrats! You’ve just created your first module! It won’t do much unless you
    fill the functions in with real functionality, a fun challenge for you to do on
    your own.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned about modules, groups of like-minded code that
    prevent you from wasting time on problems that have already been solved. You saw
    the basic anatomy of a module, as well as how to install, import, remove, and
    uninstall them. You even made your own basic module!
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 8](ch08.xhtml#ch8), you’ll learn how to access remote computers
    by using PowerShell remoting.
  prefs: []
  type: TYPE_NORMAL
