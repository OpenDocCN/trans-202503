<html><head></head><body>
<div id="sbo-rt-content"><section aria-labelledby="ch8" epub:type="chapter" role="doc-chapter">
<header>
<h1 class="CHAPTER" id="ch8">
<span class="CN"><span aria-label=" Page 249. " epub:type="pagebreak" id="pg_249" role="doc-pagebreak"/><samp class="SANS_Futura_Std_Bold_Condensed_B_11">8</samp></span>
<span class="CT"><samp class="SANS_Dogma_OT_Bold_B_11">PERFORMANCE AND EFFICIENCY</samp></span>
</h1>
</header>
<figure class="opener"><img alt="" class="opener" height="191" src="../images/opener-img.png" width="191"/>
</figure>
<p class="COS">Few programmers set out to write inefficient code, but we don’t always have time to fine-tune an algorithm to extract the maximum possible performance. Nevertheless, it’s important to understand how some coding practices can hurt performance and how we can employ alternative approaches to make our code more efficient. In this chapter, we’ll put some common techniques and practices under the microscope to examine their performance and compare their characteristics with potential alternatives.</p>
<p class="TX">We’ll explore the following:</p>
<ul class="BL">
<li class="BL">Where default code behavior may not be optimally efficient</li>
<li class="BL">Why some common performance concerns are misconceptions</li>
<li class="BL"><span aria-label=" Page 250. " epub:type="pagebreak" id="pg_250" role="doc-pagebreak"/>How to evaluate code performance and target its bottlenecks</li>
<li class="BL">When making small optimizations may be worth the trouble</li>
</ul>
<section aria-labelledby="sec1" epub:type="division">
<h2 class="H1" id="sec1"><span id="h-179"/><samp class="SANS_Futura_Std_Bold_B_11">Measuring and Optimizing Performance</samp></h2>
<p class="TNI">The term <i>optimization</i> is often used to mean altering code to make a program run more quickly, but we might want to optimize for many other outcomes: lower memory use, higher numeric calculation precision, increased data throughput, and ease of deployment, to name just a few. Sometimes we trade raw performance for code readability or even convenience. We may decide that making our code easy to test is more important than making the program run at maximum speed. However, optimizing for one area can often adversely affect one or more other areas of an application, so we must make sure that the potential benefits are worth the cost and that our efforts aren’t actually leading to <i>pessimization</i>: writing or using code that prevents a program from running efficiently.</p>
<p class="TX">The easiest and most direct method for optimizing a program’s performance is to enable optimizations in the build configuration. A release build configuration has optimizations enabled by default. When building the debug configuration, the compiler generates code that closely matches the source code’s structure and logic, which allows for setting diagnostic features like breakpoints, step-by-step debugging, and inspecting variables. The optimizations enabled in a release build may change the code’s logical structure in subtle ways, making debugging much more difficult but potentially improving the code’s efficiency or reducing the program’s size.</p>
<p class="TX">The C# compiler itself performs very little in the way of optimizing the code, leaving the majority of that work to the JIT compiler.</p>
<section aria-labelledby="sec2" epub:type="division">
<h3 class="H2" id="sec2"><span id="h-180"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">The JIT Compiler</samp></h3>
<p class="TNI">The C# compiler translates our C# code into CIL format, which in turn is translated to native machine code either ahead of time (AOT) by a tool such as the CrossGen utility or at run time by the JIT compiler, the latter being the default. In normal operation, the JIT compiler translates the program piecemeal; rather than producing the machine code for the entire program all at once before running it (as AOT tools do), the JIT compiler translates portions of the CIL to native format <i>just in time</i>. A portion would generally be a method, but in principle it could be part of a method, such as a loop or <samp class="SANS_TheSansMonoCd_W5Regular_11">if</samp> block.</p>
<p class="TX">Because JIT compiler optimizations occur during a program’s execution, they’ll vary among platforms and run-time environments. While AOT compilation may improve a program’s startup time, the JIT compiler can take advantage of optimizations specific to a particular CPU, register set, operating system, and program state to produce efficient code on the fly.</p>
<p class="TX">One common optimization is to inline the code within a method, avoiding the overhead of a method call. The JIT compiler may also be able to replace some method calls with native intrinsic CPU instructions, further <span aria-label=" Page 251. " epub:type="pagebreak" id="pg_251" role="doc-pagebreak"/>improving performance. Once a block has been translated by the JIT compiler, its native code remains in memory, so it usually doesn’t need to be recompiled if the program runs it more than once.</p>
<p class="TX">In a debug build, the JIT compiler is much less aggressive in the optimizations it applies so that normal debugging operations are supported. When we’re trying to assess our code’s performance, it usually makes the most sense to base that assessment on a release build so it will account for all of the optimizations performed by the JIT compiler.</p>
</section>
<section aria-labelledby="sec3" epub:type="division">
<h3 class="H2" id="sec3"><span id="h-181"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Performance Benchmarks</samp></h3>
<p class="TNI">When our code runs more slowly than we expect, simply observing the running application may give us some insights, but measuring performance precisely will allow us to target our optimization efforts more effectively.</p>
<p class="TX">Recording the time it takes for code to run—whether it’s a complete end-to-end run or just a portion of a program—is known as <i>benchmarking</i>. More generally, a <i>benchmark</i> is a standard against which something is measured. By timing our code, we establish a benchmark with which to compare a new version, to determine whether our changes have made the code faster or slower, or have had no discernible effect.</p>
<p class="TX">Many unit-testing frameworks report how long it takes for the tests to run, and even the elapsed time taken for individual tests. Keeping an eye on these numbers is certainly worthwhile because a sudden increase can indicate that an efficiency problem has been introduced somewhere. This approach can be particularly valuable in an automated <i>continuous integration (CI)</i> service, in which changes from multiple contributors are automatically integrated into a program; we can set up a CI service to alert us if the timing of the unit tests begins to change. If a particular test that usually runs in a few hundred milliseconds starts taking considerably longer, we can focus on the piece of code being tested to see if further investigation is warranted.</p>
<p class="TX">A more fine-grained and precise approach to measuring how fast a section of code runs is to instrument the code itself. The basic technique is simple in principle: just before running the code to be measured, we create a timer to record the elapsed time, and when the code has finished running, we record the timer’s measurement. <a href="#list8-1">Listing 8-1</a> shows a simple but na<span class="accent">ï</span>ve benchmark using the <samp class="SANS_TheSansMonoCd_W5Regular_11">Stopwatch</samp> class from the <samp class="SANS_TheSansMonoCd_W5Regular_11">System.Diagnostics</samp> namespace.</p>
<pre id="list8-1"><code>// Start the clock&#13;
var clock = Stopwatch.StartNew();&#13;
// Run the code to be measured&#13;
var result = SomeTask();&#13;
// Stop the clock, and record elapsed time&#13;
clock.Stop();&#13;
var millisecs = clock.ElapsedTicks * 1000.0 / Stopwatch.Frequency;</code></pre>
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 8-1: A simple benchmarking approach</samp></p>
<p class="TX"><span aria-label=" Page 252. " epub:type="pagebreak" id="pg_252" role="doc-pagebreak"/>The <samp class="SANS_TheSansMonoCd_W5Regular_11">Stopwatch</samp> class is a lightweight high-resolution timer that records elapsed time with very high precision. The <samp class="SANS_TheSansMonoCd_W5Regular_11">Stopwatch.Frequency</samp> value is the number of ticks per second, so by multiplying the count of elapsed ticks by <samp class="SANS_TheSansMonoCd_W5Regular_11">1000.0</samp> before dividing by the frequency, we can report the time taken with millisecond granularity. This technique simply measures the elapsed time since the clock was started, so it can’t, for instance, determine whether the code being measured is actually running for all that time. The clock continues to tick even if the code is interrupted (for example, by switching to a different thread).</p>
<p class="TX">Instrumenting code with a timer and recording it in the log or another audit trail can be a useful way to measure code running in a live system. However, measuring and reporting the performance takes time too, so we must be sure to take the measurements at a relatively high level. For instance, measuring and reporting how long code takes to respond to an <samp class="SANS_TheSansMonoCd_W5Regular_11">HTTP</samp> request or call a remote procedure probably wouldn’t significantly impact the application’s performance. On the other hand, using this technique in a tight loop might well introduce more overhead than the cost of the loop itself.</p>
<p class="TX">Benchmarking is also a useful way to explore performance in a test environment, perhaps to compare alternative approaches to solving a specific problem. The technique in <a href="#list8-1">Listing 8-1</a> is na<span class="accent">ï</span>ve in that it measures the code only once. A more accurate approach for measuring performance would run the code many times and report the average time. We could write our own framework based on <a href="#list8-1">Listing 8-1</a>, although a few freely available libraries for C# will do the heavy lifting for us, producing a report of the recorded performance along with other useful statistics, such as margin for error.</p>
</section>
<section aria-labelledby="sec4" epub:type="division">
<h3 class="H2" id="sec4"><span id="h-182"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">The Profiler</samp></h3>
<p class="TNI">Benchmarking will tell us overall how quickly a piece of code runs, but to determine what the code does in detail, we need a <i>profiler</i>. Using a benchmarking tool in combination with profiling will give us the most accurate measurements. Among the several kinds of profiler available, the two most common are performance profilers and memory profilers.</p>
<p class="TX">A <i>memory profiler</i> will show us where our program allocates memory, how much is being used, and when it’s garbage collected. If we need to find out which parts of our code are using the most CPU time or which methods are being called most often, a <i>performance profiler</i> will give us precise measurements, allowing us to target specific hot spots in the code and optimize them if necessary. While optimizing memory usage is important, in this chapter we’ll focus on discovering bottlenecks in our code by using a performance profiler.</p>
<p class="TX">Performance profilers usually operate on a release build of a program and so take into account any optimizations applied by the compiler and JIT compiler. Measuring a debug build for its performance usually makes little sense, although sometimes it can be useful: comparing the results of profiling both a debug build and a release build of the same code, for instance, can provide insights into some of the optimizations the JIT compiler performs.</p>
<p class="TX"><span aria-label=" Page 253. " epub:type="pagebreak" id="pg_253" role="doc-pagebreak"/>While performance measurements can give us an idea of where bottlenecks may be slowing our code, it’s vital to keep in mind that a program’s performance is affected by many factors other than the code, including the version of the CLR or the version of the software development kit (SDK) we use. Even running the same program twice on the same machine can produce a different result, depending on how cache memory is allocated or how instructions are pipelined by the CPU’s scheduler. The JIT compiler may also apply different optimizations for each run, possibly further affecting the result. We must therefore be cautious of attaching too much importance to the absolute times in a profiler’s report, and instead look for trends or obvious anomalies, such as results differing by an order of magnitude or more.</p>
<p class="TX">We’ll use a performance profiler to selectively measure specific aspects of code and analyze the profiler’s results. Remember that the specific results shown in this chapter are particular to the machine on which the test was performed, but we’ll try multiple approaches, measuring each attempt so that we can identify some common, repeatable patterns in the results.</p>
<p class="TX">To demonstrate how this works, next we’ll examine how simply changing a field’s type can dramatically affect the performance of code that relies on using <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp>.</p>
</section>
</section>
<section aria-labelledby="sec5" epub:type="division">
<h2 class="H1" id="sec5"><span id="h-183"/><samp class="SANS_Futura_Std_Bold_B_11">Measuring Basic Performance with Equals</samp></h2>
<p class="TNI">The <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp> method is an often neglected aspect of code optimization in C#. This method is a good candidate for performance measurement because it’s always available (since every type inherits it from the <samp class="SANS_TheSansMonoCd_W5Regular_11">object</samp> base class) but also customizable (as a virtual member of <samp class="SANS_TheSansMonoCd_W5Regular_11">object</samp>). In this section, we measure the default behavior of <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp> for a simple value type so that we can compare the profiler’s results with the results from overriding <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp> with our own implementation.</p>
<p class="TX">Struct types inherit a value-based equality comparison from the <samp class="SANS_TheSansMonoCd_W5Regular_11">ValueType</samp> class, overriding the default implementation defined by the <samp class="SANS_TheSansMonoCd_W5Regular_11">object</samp> universal base class. This ensures that when we copy an instance of a struct, the copy compares equal to the original by comparing the fields of each instance. We might be tempted to rely on this behavior, rather than implementing our own override of the <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp> method, because it keeps our type definitions shorter and simpler, like the <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp> struct in <a href="#list8-2">Listing 8-2</a>.</p>
<pre id="list8-2"><code>public readonly struct Color&#13;
{&#13;
    public Color(int r, int g, int b)&#13;
        =&gt; (Red, Green, Blue) = (r, g, b);&#13;
    public int Red {get;}&#13;
    public int Green {get;}&#13;
    public int Blue {get;}&#13;
}</code></pre>
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 8-2: Defining a simple struct type</samp></p>
<p class="TX"><span aria-label=" Page 254. " epub:type="pagebreak" id="pg_254" role="doc-pagebreak"/>Two instances of <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp> that have the same property values will compare equal. Furthermore, like all structs, <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp> inherits a value-based implementation of <samp class="SANS_TheSansMonoCd_W5Regular_11">GetHashCode</samp> from <samp class="SANS_TheSansMonoCd_W5Regular_11">ValueType</samp>, ensuring that two equal <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp> values always produce the same hash code. Additionally, <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp> is an immutable type, making it suitable for use as a key in a data structure that relies on hash codes for efficiency. In <a href="#list8-3">Listing 8-3</a>, we create many random <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp> instances and then add them to a <samp class="SANS_TheSansMonoCd_W5Regular_11">HashSet</samp> in a simple test that we can use to measure how well the <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp> struct performs.</p>
<pre id="list8-3"><code>var rng = new Random(1);&#13;
var items = Enumerable.Range(0, 25000)&#13;
    .Select(_ =&gt; rng.Next())&#13;
    .Select(r =&gt; new Color(r &gt;&gt; 16 &amp; 0xFF, r &gt;&gt; 8 &amp; 0xFF, r &amp; 0xFF))&#13;
    .ToHashSet();</code></pre>
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 8-3: Generating a hashing collection</samp></p>
<p class="TX">This <samp class="SANS_TheSansMonoCd_W5Regular_11">Random</samp> class is the Standard Library’s <i>pseudorandom number generator</i>, the name for an algorithm that uses a deterministic process to produce a sequence of numbers that <i>appear</i> random. Notably, the <samp class="SANS_TheSansMonoCd_W5Regular_11">Random</samp> class will produce the same sequence if it’s initialized with the same <i>seed</i>—that is, the value used to calculate the first number of the sequence.</p>
<blockquote>
<p class="NOTE"><span class="NoteHead"><samp class="SANS_Dogma_OT_Bold_B_21">NOTE</samp></span></p>
</blockquote>
<p class="NOTE-TXT"><i>Different versions of .NET (or .NET Core) may produce different sequences for a given seed.</i></p>
<p class="TX">In <a href="#list8-3">Listing 8-3</a>, we use <samp class="SANS_TheSansMonoCd_W5Regular_11">1</samp> as the seed and create new <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp> instances using the numbers generated by calling <samp class="SANS_TheSansMonoCd_W5Regular_11">Next</samp> on the random-number generator. Since we use the same seed each time, we’ll get the same sequence of <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp> instances each time the code runs. This characteristic is most often considered a downside of pseudorandom numbers, but it suits our purpose perfectly because we can run this code multiple times, and the same values for the <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp> instances will be generated for each run. In turn, comparing the performance of different runs is fair in that each run will be comparing identical sequences of <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp> values. We’re using a randomly generated sequence to ensure that the final <samp class="SANS_TheSansMonoCd_W5Regular_11">HashSet</samp> contains a reasonably realistic population of <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp> values.</p>
<p class="TX">In <a href="#list8-3">Listing 8-3</a>, we create each <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp> instance by masking off the <samp class="SANS_TheSansMonoCd_W5Regular_11">Red</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">Green</samp>, and <samp class="SANS_TheSansMonoCd_W5Regular_11">Blue</samp> values from each random number. The profiler output in <a href="#tab8-1">Table 8-1</a> shows the performance of the hash table’s constructor. For this test, we’re simply measuring elapsed time, also called <i>CPU sampling</i>, for each method.</p>
<figure class="table">
<table class="table">
<caption>
<p class="TT" id="tab8-1"><span aria-label=" Page 255. " epub:type="pagebreak" id="pg_255" role="doc-pagebreak"/><span class="Heavy"><samp class="SANS_Futura_Std_Heavy_B_11">Table 8-1:</samp></span> <samp class="SANS_Futura_Std_Book_11">Profile Report of Creating the</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">HashSet</samp></p>
</caption>
<thead>
<tr class="table">
<th class="table TCH" scope="col">
<p class="TCH"><samp class="SANS_Futura_Std_Heavy_B_11">Method</samp></p>
</th>
<th class="table TCH" scope="col">
<p class="TCH"><samp class="SANS_Futura_Std_Heavy_B_11">Time (ms)</samp></p>
</th>
<th class="table TCH" scope="col">
<p class="TCH"><samp class="SANS_Futura_Std_Heavy_B_11">Signature</samp></p>
</th>
</tr>
</thead>
<tbody>
<tr class="table">
<td class="table TBF">
<p class="TB"><samp class="SANS_TheSansMonoCd_W5Regular_11">87.9% HashSet'1..ctor</samp></p>
</td>
<td class="table TBF">
<p class="TB"><samp class="SANS_TheSansMonoCd_W5Regular_11">50</samp></p>
</td>
<td class="table TBF">
<p class="TB"><samp class="SANS_TheSansMonoCd_W5Regular_11">System.Collections.Generic.HashSet`1..ctor (IEnumerable, IEqualityComparer)</samp></p>
</td>
</tr>
<tr class="table">
<td class="table TB">
<p class="TB-1"><samp class="SANS_TheSansMonoCd_W5Regular_11">87.9% UnionWith</samp></p>
</td>
<td class="table TB">
<p class="TB"><samp class="SANS_TheSansMonoCd_W5Regular_11">50</samp></p>
</td>
<td class="table TB">
<p class="TB"><samp class="SANS_TheSansMonoCd_W5Regular_11">System.Collections.Generic.HashSet`1.UnionWith (IEnumerable)</samp></p>
</td>
</tr>
<tr class="table">
<td class="table TB">
<p class="TB-2"><samp class="SANS_TheSansMonoCd_W5Regular_11">87.9% AddIfNotPresent</samp></p>
</td>
<td class="table TB">
<p class="TB"><samp class="SANS_TheSansMonoCd_W5Regular_11">50</samp></p>
</td>
<td class="table TB">
<p class="TB"><samp class="SANS_TheSansMonoCd_W5Regular_11">System.Collections.Generic.HashSet`1.AddIfNot Present(T, out Int32)</samp></p>
</td>
</tr>
<tr class="table">
<td class="table TB">
<p class="TB-3"><samp class="SANS_TheSansMonoCd_W7Bold_B_11">36.5% Equals</samp></p>
</td>
<td class="table TB">
<p class="TB"><samp class="SANS_TheSansMonoCd_W7Bold_B_11">21</samp></p>
</td>
<td class="table TB">
<p class="TB"><samp class="SANS_TheSansMonoCd_W7Bold_B_11">System.ValueType.Equals(Object)</samp></p>
</td>
</tr>
<tr class="table">
<td class="table TBL">
<p class="TB-3"><samp class="SANS_TheSansMonoCd_W5Regular_11">14.0% [Garbage collection]</samp></p>
</td>
<td class="table TBL">
<p class="TB"><samp class="SANS_TheSansMonoCd_W5Regular_11">7.9</samp></p>
</td>
<td class="table TBL"/>
</tr>
</tbody>
</table>
</figure>
<p class="TX">We’re focusing on the creation of the <samp class="SANS_TheSansMonoCd_W5Regular_11">HashSet</samp> and ignoring everything else, including the random-number generation and creation of individual <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp> objects. Different profilers represent their reports differently, but the information presented is generally similar.</p>
<p class="TX">The indentation in the first column of this report shows the call stack being measured. The <samp class="SANS_TheSansMonoCd_W5Regular_11">HashSet</samp> constructor on the first line calls a method named <samp class="SANS_TheSansMonoCd_W5Regular_11">UnionWith</samp>, which in turn calls <samp class="SANS_TheSansMonoCd_W5Regular_11">AddIfNotPresent</samp>. This last method eventually calls the <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp> method. The leftmost value in the output shows the time spent by that method as a percentage of the test’s total time. In our test, creating the initial sequence of <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp> values takes up the remainder of the time but isn’t really relevant to testing <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp>. The next field is the simple name of the method, followed by the absolute time in milliseconds spent in that method.</p>
<p class="TX">Finally, the fully qualified name of the method indicates which specific method is being reported. Since our simple <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp> struct doesn’t provide its own implementation of <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp>, the output shows that <samp class="SANS_TheSansMonoCd_W5Regular_11">ValueType.Equals</samp> is used to add unique keys to the hash table.</p>
<p class="TX">As noted earlier, the actual times in milliseconds reported here could change based on a combination of many factors, so they shouldn’t be taken literally. However, they establish a baseline we can use to compare the results of other tests.</p>
<section aria-labelledby="sec6" epub:type="division">
<h3 class="H2" id="sec6"><span id="h-184"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Hidden Costs of Simplicity</samp></h3>
<p class="TNI">Our <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp> type uses three values for the RGB components. Although they’re being stored in <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp> properties, each one 4 bytes wide, we use only 1 byte for each value by masking off the lowest 8 bits of each argument to <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp>’s constructor. We might infer that we can save on storage space by storing the properties as <samp class="SANS_TheSansMonoCd_W5Regular_11">byte</samp> fields rather than <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>. <a href="#list8-4">Listing 8-4</a> shows the changed <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp> struct.</p>
<pre id="list8-4"><code>public readonly struct Color&#13;
{&#13;
    public Color(int r, int g, int b)&#13;
        =&gt; (Red, Green, Blue) = <b>((byte)r, (byte)g, (byte)b)</b>;&#13;
<span aria-label=" Page 256. " epub:type="pagebreak" id="pg_256" role="doc-pagebreak"/>&#13;
    public <b>byte</b> Red {get;}&#13;
    public <b>byte</b> Green {get;}&#13;
    public <b>byte</b> Blue {get;}&#13;
}</code></pre>
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 8-4: Storing byte fields for color components</samp></p>
<p class="TX">We still allow <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp> arguments to the <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp> constructor so that our users won’t have to explicitly cast the arguments to <samp class="SANS_TheSansMonoCd_W5Regular_11">byte</samp> when creating <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp> values. Casting the <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp> values explicitly to <samp class="SANS_TheSansMonoCd_W5Regular_11">byte</samp> has the same effect as the masking operations we used in <a href="#list8-3">Listing 8-3</a>: the value is truncated to just the lowest 8 bits. If we use this version of <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp> in the test to produce a <samp class="SANS_TheSansMonoCd_W5Regular_11">HashSet</samp> from <a href="#list8-3">Listing 8-3</a>, the results are quite different. <a href="#tab8-2">Table 8-2</a> shows just the call tree for <samp class="SANS_TheSansMonoCd_W5Regular_11">AddIfNotPresent</samp>.</p>
<figure class="table">
<table class="table">
<caption>
<p class="TT" id="tab8-2"><span class="Heavy"><samp class="SANS_Futura_Std_Heavy_B_11">Table 8-2:</samp></span> <samp class="SANS_Futura_Std_Book_11">Profile Report of Adding Objects with</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">byte</samp> <samp class="SANS_Futura_Std_Book_11">Fields to the</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">HashSet</samp></p>
</caption>
<thead>
<tr class="table">
<th class="table TCH" scope="col">
<p class="TCH"><samp class="SANS_Futura_Std_Heavy_B_11">Method</samp></p>
</th>
<th class="table TCH" scope="col">
<p class="TCH"><samp class="SANS_Futura_Std_Heavy_B_11">Time (ms)</samp></p>
</th>
<th class="table TCH" scope="col">
<p class="TCH"><samp class="SANS_Futura_Std_Heavy_B_11">Signature</samp></p>
</th>
</tr>
</thead>
<tbody>
<tr class="table">
<td class="table TBF">
<p class="TB"><samp class="SANS_TheSansMonoCd_W7Bold_B_11">99.9% AddIfNotPresent</samp></p>
</td>
<td class="table TBF">
<p class="TB"><samp class="SANS_TheSansMonoCd_W7Bold_B_11">7,494</samp></p>
</td>
<td class="table TBF">
<p class="TB"><samp class="SANS_TheSansMonoCd_W7Bold_B_11">System.Collections.Generic.HashSet`1 .AddIfNotPresent(T, out Int32)</samp></p>
</td>
</tr>
<tr class="table">
<td class="table TB">
<p class="TB-1"><samp class="SANS_TheSansMonoCd_W5Regular_11">39.6% Equals</samp></p>
</td>
<td class="table TB">
<p class="TB"><samp class="SANS_TheSansMonoCd_W5Regular_11">2,967</samp></p>
</td>
<td class="table TB">
<p class="TB"><samp class="SANS_TheSansMonoCd_W5Regular_11">System.ValueType.Equals(Object)</samp></p>
</td>
</tr>
<tr class="table">
<td class="table TB">
<p class="TB-1"><samp class="SANS_TheSansMonoCd_W5Regular_11">8.66% [Garbage collection]</samp></p>
</td>
<td class="table TB">
<p class="TB"><samp class="SANS_TheSansMonoCd_W5Regular_11">650</samp></p>
</td>
<td class="table TB"/>
</tr>
<tr class="table">
<td class="table TBL">
<p class="TB-1"><samp class="SANS_TheSansMonoCd_W5Regular_11">0.16% [Thread suspended]</samp></p>
</td>
<td class="table TBL">
<p class="TB"><samp class="SANS_TheSansMonoCd_W5Regular_11">12</samp></p>
</td>
<td class="table TBL"/>
</tr>
</tbody>
</table>
</figure>
<p class="TX">We see a dramatic change in the execution profile of the code, with the <samp class="SANS_TheSansMonoCd_W5Regular_11">AddIfNotPresent</samp> method taking well over seven full seconds to complete. Comparing this report to <a href="#tab8-1">Table 8-1</a>, we can see clearly that the main reason for the extra time is the <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp> method inherited by <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp> from the <samp class="SANS_TheSansMonoCd_W5Regular_11">ValueType</samp> base class.</p>
<p class="TX">In some instances, <samp class="SANS_TheSansMonoCd_W5Regular_11">ValueType.Equals</samp> can perform a <i>very</i> fast bitwise comparison, but with several caveats: this comparison can’t be used if any field is a reference, a floating-point number, or a type that itself overrides <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp>. Two different reference values could refer to objects of a type with its own <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp> method, and a bitwise comparison would compare them as not equal, even if <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp> would return <samp class="SANS_TheSansMonoCd_W5Regular_11">true</samp>. For the same reason, any value type with its own <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp> method could use that method to compare some values with different bit patterns as equal. Two floating-point numbers with matching bit patterns aren’t necessarily equal; in particular, if both values are <samp class="SANS_TheSansMonoCd_W5Regular_11">NaN</samp>, they shouldn’t compare equal.</p>
<p class="TX">Another condition for the fast comparison to be used is that a struct must be <i>tightly packed</i>, meaning its fields don’t require any padding to be properly aligned in memory. The three <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp> fields in the original implementation of <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp> would automatically be aligned in memory. However, using <samp class="SANS_TheSansMonoCd_W5Regular_11">byte</samp> instead means the fields aren’t tightly packed, so we must use another, much slower comparison, with the substantial performance penalty shown in <a href="#tab8-2">Table 8-2</a>.</p>
</section>
<section aria-labelledby="sec7" epub:type="division">
<h3 class="H2" id="sec7"><span id="h-185"/><span aria-label=" Page 257. " epub:type="pagebreak" id="pg_257" role="doc-pagebreak"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">The ValueType.Equals Method</samp></h3>
<p class="TNI">When the fast bitwise comparison isn’t applicable, the implementation of <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp> in <samp class="SANS_TheSansMonoCd_W5Regular_11">ValueType</samp> is necessarily very general, because it must work for any struct type, regardless of the number of fields the struct has or their type. In addition to having fields of built-in primitive types, a struct can contain references to class instances and instances of other user-defined values, any of which may have its own custom <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp> implementation.</p>
<p class="TX">The implementation of <samp class="SANS_TheSansMonoCd_W5Regular_11">ValueType.Equals</samp> first must determine which fields need to be compared. It does this by using <i>reflection</i>—programmatically inspecting (or changing) the run-time structure of the program—to discover all the instance fields, which immediately comes with a quite significant run-time cost. Reflection isn’t usually associated with high-performance algorithms, and this certainly accounts for the reduction in performance caused by altering our struct’s <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp> fields to use <samp class="SANS_TheSansMonoCd_W5Regular_11">byte</samp> instead.</p>
<p class="TX">After determining the array of fields, <samp class="SANS_TheSansMonoCd_W5Regular_11">ValueType.Equals</samp> obtains each field’s value. If the field value isn’t a <samp class="SANS_TheSansMonoCd_W5Regular_11">null</samp> reference, its <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp> method is called with the value from the corresponding field in the struct being compared. As a result, every value type field in both structs will be boxed in order to perform the comparison, because using reflection to obtain the values means each value is accessed via an <samp class="SANS_TheSansMonoCd_W5Regular_11">object</samp> reference, adding further cost.</p>
<p class="TX">The root cause of our performance problem is that the change from using <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp> properties to <samp class="SANS_TheSansMonoCd_W5Regular_11">byte</samp> values means that the underlying backing fields of <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp> are no longer tightly packed. Consequently, <samp class="SANS_TheSansMonoCd_W5Regular_11">ValueType.Equals</samp> can’t use the fast bitwise comparison and instead employs reflection to discover the values to be compared. To address this issue, in <a href="#list8-5">Listing 8-5</a> we override the <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp> method and provide our own implementation to compare the property values.</p>
<pre id="list8-5"><code>public readonly struct Color&#13;
{&#13;
    public Color(int r, int g, int b)&#13;
        =&gt; (Red, Green, Blue) = ((byte)r, (byte)g, (byte)b);&#13;
    public byte Red {get;}&#13;
    public byte Green {get;}&#13;
    public byte Blue {get;}&#13;
    <b>public override bool Equals(object? obj)</b>&#13;
        <b>=&gt;</b> <b>obj is Color other &amp;&amp;</b>&#13;
           <b>Red</b> <b>==</b> <b>other.Red &amp;&amp; Green</b> <b>==</b> <b>other.Green &amp;&amp; Blue</b> <b>==</b> <b>other.Blue;</b>&#13;
}</code></pre>
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 8-5: Overriding the Equals method</samp></p>
<p class="TX"><span aria-label=" Page 258. " epub:type="pagebreak" id="pg_258" role="doc-pagebreak"/>The report in <a href="#tab8-3">Table 8-3</a> from rerunning the test shows that while we’ve substantially improved its speed, we still have work to do.</p>
<figure class="table">
<table class="table">
<caption>
<p class="TT" id="tab8-3"><span class="Heavy"><samp class="SANS_Futura_Std_Heavy_B_11">Table 8-3:</samp></span> <samp class="SANS_Futura_Std_Book_11">How the Overridden</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp> <samp class="SANS_Futura_Std_Book_11">Method Performs</samp></p>
</caption>
<thead>
<tr class="table">
<th class="table TCH" scope="col">
<p class="TCH"><samp class="SANS_Futura_Std_Heavy_B_11">Method</samp></p>
</th>
<th class="table TCH" scope="col">
<p class="TCH"><samp class="SANS_Futura_Std_Heavy_B_11">Time (ms)</samp></p>
</th>
<th class="table TCH" scope="col">
<p class="TCH"><samp class="SANS_Futura_Std_Heavy_B_11">Signature</samp></p>
</th>
</tr>
</thead>
<tbody>
<tr class="table">
<td class="table TBF">
<p class="TB"><samp class="SANS_TheSansMonoCd_W5Regular_11">100% AddIfNotPresent</samp></p>
</td>
<td class="table TBF">
<p class="TB"><samp class="SANS_TheSansMonoCd_W5Regular_11">2,889</samp></p>
</td>
<td class="table TBF">
<p class="TB"><samp class="SANS_TheSansMonoCd_W5Regular_11">System.Collections.Generic.HashSet`1 .AddIfNotPresent(T,</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">out Int32)</samp></p>
</td>
</tr>
<tr class="table">
<td class="table TB">
<p class="TB-1"><samp class="SANS_TheSansMonoCd_W5Regular_11">20.4% Equals</samp></p>
</td>
<td class="table TB">
<p class="TB"><samp class="SANS_TheSansMonoCd_W5Regular_11">588</samp></p>
</td>
<td class="table TB">
<p class="TB"><samp class="SANS_TheSansMonoCd_W5Regular_11">Color.Equals(Object)</samp></p>
</td>
</tr>
<tr class="table">
<td class="table TBL">
<p class="TB-1"><samp class="SANS_TheSansMonoCd_W5Regular_11">8.15% [Garbage collection]</samp></p>
</td>
<td class="table TBL">
<p class="TB"><samp class="SANS_TheSansMonoCd_W5Regular_11">236</samp></p>
</td>
<td class="table TBL"/>
</tr>
</tbody>
</table>
</figure>
<p class="TX">Notice that our override of <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp> is consuming a much smaller percentage of the overall time in <samp class="SANS_TheSansMonoCd_W5Regular_11">AddIfNotPresent</samp>, although this approach is still much slower than the test using our original version of <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp> that had <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp> properties.</p>
<p class="TX">This report tells us that the majority of the time was spent in the code of <samp class="SANS_TheSansMonoCd_W5Regular_11">AddIfNotPresent</samp> as opposed to any methods called by it. To discover why, we’ll use a different kind of profiling, sometimes known as <i>instrumentation profiling</i>, or <i>tracing</i>, which records the number of times each method is called in a program. Because this requires the profiler to intrusively measure a running program, the time measurements are often much higher; however, knowing which methods are being called most often is valuable information. <a href="#tab8-4">Table 8-4</a> shows the tracing report for <samp class="SANS_TheSansMonoCd_W5Regular_11">AddIfNotPresent</samp> and the methods called within it, including the number of times each method was called.</p>
<figure class="table">
<table class="table">
<caption>
<p class="TT" id="tab8-4"><span class="Heavy"><samp class="SANS_Futura_Std_Heavy_B_11">Table 8-4:</samp></span> <samp class="SANS_Futura_Std_Book_11">Tracing Report for</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp></p>
</caption>
<thead>
<tr class="table">
<th class="table TCH" scope="col">
<p class="TCH"><samp class="SANS_Futura_Std_Heavy_B_11">Method</samp></p>
</th>
<th class="table TCH" scope="col">
<p class="TCH"><samp class="SANS_Futura_Std_Heavy_B_11">Time (ms)</samp></p>
</th>
<th class="table TCH" scope="col">
<p class="TCH"><samp class="SANS_Futura_Std_Heavy_B_11">Number of calls</samp></p>
</th>
<th class="table TCH" scope="col">
<p class="TCH"><samp class="SANS_Futura_Std_Heavy_B_11">Signature</samp></p>
</th>
</tr>
</thead>
<tbody>
<tr class="table">
<td class="table TBF">
<p class="TB"><samp class="SANS_TheSansMonoCd_W5Regular_11">99.9% AddIfNotPresent</samp></p>
</td>
<td class="table TBF">
<p class="TB"><samp class="SANS_TheSansMonoCd_W5Regular_11">16,681</samp></p>
</td>
<td class="table TBF">
<p class="TB"><samp class="SANS_TheSansMonoCd_W5Regular_11">25,000</samp></p>
</td>
<td class="table TBF">
<p class="TB"><samp class="SANS_TheSansMonoCd_W5Regular_11">[...]</samp></p>
</td>
</tr>
<tr class="table">
<td class="table TB">
<p class="TB-1"><samp class="SANS_TheSansMonoCd_W7Bold_B_11">40.3% Equals</samp></p>
</td>
<td class="table TB">
<p class="TB"><samp class="SANS_TheSansMonoCd_W7Bold_B_11">6,724</samp></p>
</td>
<td class="table TB">
<p class="TB"><samp class="SANS_TheSansMonoCd_W7Bold_B_11">312,222,485</samp></p>
</td>
<td class="table TB">
<p class="TB"><samp class="SANS_TheSansMonoCd_W7Bold_B_11">Color.Equals(Object)</samp></p>
</td>
</tr>
<tr class="table">
<td class="table TBL">
<p class="TB-1"><samp class="SANS_TheSansMonoCd_W5Regular_11">1.76%</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">[Garbage collection]</samp></p>
</td>
<td class="table TBL">
<p class="TB"><samp class="SANS_TheSansMonoCd_W5Regular_11">293</samp></p>
</td>
<td class="table TBL">
<p class="TB"><samp class="SANS_TheSansMonoCd_W5Regular_11">1,593</samp></p>
</td>
<td class="table TBL"/>
</tr>
</tbody>
</table>
</figure>
<p class="TX">This report has an extra column that shows the number of times each method was called during the program’s execution. The tracing report took significantly longer to run, but more importantly, it shows the <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp> method being invoked a huge number of times. In fact, the number of invocations of <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp> is suspiciously close to the triangular number of 25,000—the number of elements in the original sequence. The <i>triangular number</i> of some number <i>n</i> is the sum of the whole numbers from 1 to <i>n</i>. When <i>n</i> is 25,000, the triangular number is 312,512,500.</p>
<p class="TX">While we’ve customized <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp> for the <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp> struct, the <samp class="SANS_TheSansMonoCd_W5Regular_11">HashSet</samp> class also uses <samp class="SANS_TheSansMonoCd_W5Regular_11">GetHashCode</samp> when adding or searching for a key, and our <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp> type relies on the default <samp class="SANS_TheSansMonoCd_W5Regular_11">GetHashCode</samp> implementation inherited from <samp class="SANS_TheSansMonoCd_W5Regular_11">ValueType</samp>. Let’s look at how this relates to the number of times <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp> is called in our test.</p>
</section>
<section aria-labelledby="sec8" epub:type="division">
<h3 class="H2" id="sec8"><span id="h-186"/><span aria-label=" Page 259. " epub:type="pagebreak" id="pg_259" role="doc-pagebreak"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">The ValueType.GetHashCode Method</samp></h3>
<p class="TNI">As <span class="Xref"><a href="chapter5.xhtml">Chapter 5</a></span> explained, the elements in a <samp class="SANS_TheSansMonoCd_W5Regular_11">HashSet</samp> are unique; every key in the table exists only once. A new object is added to a <samp class="SANS_TheSansMonoCd_W5Regular_11">HashSet</samp> only if it doesn’t already exist in the table; otherwise, it’s ignored.</p>
<p class="TX">When we add an item to the <samp class="SANS_TheSansMonoCd_W5Regular_11">HashSet</samp> in this example, the implementation uses <samp class="SANS_TheSansMonoCd_W5Regular_11">GetHashCode</samp> to identify existing keys with the same hash code. The fact that the hash codes are the same doesn’t necessarily mean any of the existing keys have the same value as the new item. If no existing key has the same hash code as the new item, the new object is added to the table. If one or more existing keys have hash codes that match the new item’s hash code, the <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp> method is used to determine whether the item should be added. Each key with the same hash code is compared with the new item in turn, and if no match is found, the new item is added to the table as a new key.</p>
<p class="TX">Having <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp> being called so often in our test indicates that <samp class="SANS_TheSansMonoCd_W5Regular_11">GetHashCode</samp> for our <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp> type is producing hash codes that aren’t well distributed. When the first element is added to the hash table, <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp> isn’t called at all, because there’s nothing to compare with. If the second element has an identical hash code to the first, <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp> is called to determine if they’re identical keys. This process will repeat for each subsequent element that has the same hash code as an existing key.</p>
<p class="TX">If all of the <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp> objects in the initial sequence of 25,000 elements produce identical hash codes but have different values, adding the final new element will require a call to <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp> for all of the existing 24,999 keys.</p>
<p class="TX">In fact, the default implementation of <samp class="SANS_TheSansMonoCd_W5Regular_11">ValueType.GetHashCode</samp> inherited by the <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp> struct will likely produce many identical hash codes, regardless of whether the <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp> instances have different values. The reason is related to the poor performance of the implementation of <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp> provided by <samp class="SANS_TheSansMonoCd_W5Regular_11">ValueType</samp>, and it explains why the number of calls to <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp> is so close to the triangular number of the sequence length.</p>
<p class="TX">If instances of a struct can be compared using the fast bitwise comparison for <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp>, the <samp class="SANS_TheSansMonoCd_W5Regular_11">ValueType.GetHashCode</samp> method produces hash codes based on the bit pattern of the instance in memory. If, on the other hand, the struct isn’t eligible for the fast bitwise comparison, the default <samp class="SANS_TheSansMonoCd_W5Regular_11">GetHashCode</samp> implementation considers only the first non-<samp class="SANS_TheSansMonoCd_W5Regular_11">null</samp> instance field of the struct—the <samp class="SANS_TheSansMonoCd_W5Regular_11">Red</samp> property in our <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp> type—with the result that we can get a maximum of only 256 unique hash codes. We solve that problem by implementing our own <samp class="SANS_TheSansMonoCd_W5Regular_11">GetHashCode</samp> method to produce more unique hash codes, preferably so that each distinct <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp> value produces a unique hash code.</p>
</section>
<section aria-labelledby="sec9" epub:type="division">
<h3 class="H2" id="sec9"><span id="h-187"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">The HashCode.Combine Method</samp></h3>
<p class="TNI">In <a href="#list8-6">Listing 8-6</a>, we add our own override of <samp class="SANS_TheSansMonoCd_W5Regular_11">GetHashCode</samp> for the <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp> struct to complement our overridden <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp> method, and implement the new <samp class="SANS_TheSansMonoCd_W5Regular_11">GetHashCode</samp> by using the <samp class="SANS_TheSansMonoCd_W5Regular_11">HashCode.Combine</samp> method from the Standard Library.</p>
<pre id="list8-6"><code><span aria-label=" Page 260. " epub:type="pagebreak" id="pg_260" role="doc-pagebreak"/>public override bool Equals(object? obj)&#13;
    =&gt; obj is Color other &amp;&amp;&#13;
       Red == other.Red &amp;&amp; Green == other.Green &amp;&amp; Blue == other.Blue;&#13;
public override int GetHashCode()&#13;
    =&gt; HashCode.Combine(Red, Green, Blue);</code></pre>
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 8-6: Overriding a GetHashCode method</samp></p>
<p class="TX">The <samp class="SANS_TheSansMonoCd_W5Regular_11">Combine</samp> method produces well-distributed hash codes based on its inputs, and while we might be able to write our own carefully optimized replacement, doing so is far from trivial. Now when we run the test, we see that the combined effect of overriding both <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">GetHashCode</samp> reduces the number of calls to the <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp> method by a considerable amount, as shown in <a href="#tab8-5">Table 8-5</a>.</p>
<figure class="table">
<table class="table">
<caption>
<p class="TT" id="tab8-5"><span class="Heavy"><samp class="SANS_Futura_Std_Heavy_B_11">Table 8-5:</samp></span> <samp class="SANS_Futura_Std_Book_11">Tracing Report for the Overridden</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">GetHashCode</samp></p>
</caption>
<thead>
<tr class="table">
<th class="table TCH" scope="col">
<p class="TCH"><samp class="SANS_Futura_Std_Heavy_B_11">Method</samp></p>
</th>
<th class="table TCH" scope="col">
<p class="TCH"><samp class="SANS_Futura_Std_Heavy_B_11">Time (ms)</samp></p>
</th>
<th class="table TCH" scope="col">
<p class="TCH"><samp class="SANS_Futura_Std_Heavy_B_11">Number of calls</samp></p>
</th>
<th class="table TCH" scope="col">
<p class="TCH"><samp class="SANS_Futura_Std_Heavy_B_11">Signature</samp></p>
</th>
</tr>
</thead>
<tbody>
<tr class="table">
<td class="table TBF">
<p class="TB"><samp class="SANS_TheSansMonoCd_W5Regular_11">48.8% AddIfNotPresent</samp></p>
</td>
<td class="table TBF">
<p class="TB"><samp class="SANS_TheSansMonoCd_W5Regular_11">16</samp></p>
</td>
<td class="table TBF">
<p class="TB"><samp class="SANS_TheSansMonoCd_W5Regular_11">25,000</samp></p>
</td>
<td class="table TBF">
<p class="TB"><samp class="SANS_TheSansMonoCd_W5Regular_11">[...]</samp></p>
</td>
</tr>
<tr class="table">
<td class="table TB">
<p class="TB-1"><samp class="SANS_TheSansMonoCd_W5Regular_11">38.1% Combine</samp></p>
</td>
<td class="table TB">
<p class="TB"><samp class="SANS_TheSansMonoCd_W5Regular_11">12</samp></p>
</td>
<td class="table TB">
<p class="TB"><samp class="SANS_TheSansMonoCd_W5Regular_11">25,000</samp></p>
</td>
<td class="table TB">
<p class="TB"><samp class="SANS_TheSansMonoCd_W5Regular_11">System.HashCode.Combine(T1, T2, T3)</samp></p>
</td>
</tr>
<tr class="table">
<td class="table TB">
<p class="TB-1"><samp class="SANS_TheSansMonoCd_W5Regular_11">1.42% Resize</samp></p>
</td>
<td class="table TB">
<p class="TB"><samp class="SANS_TheSansMonoCd_W5Regular_11">0.5</samp></p>
</td>
<td class="table TB">
<p class="TB"><samp class="SANS_TheSansMonoCd_W5Regular_11">12</samp></p>
</td>
<td class="table TB">
<p class="TB"><samp class="SANS_TheSansMonoCd_W5Regular_11">System.Collections.Generic.HashSet`1 .Resize(Int32, Boolean)</samp></p>
</td>
</tr>
<tr class="table">
<td class="table TBL">
<p class="TB-1"><samp class="SANS_TheSansMonoCd_W7Bold_B_11">0.27% Equals</samp></p>
</td>
<td class="table TBL">
<p class="TB"><samp class="SANS_TheSansMonoCd_W7Bold_B_11">0.09</samp></p>
</td>
<td class="table TBL">
<p class="TB"><samp class="SANS_TheSansMonoCd_W7Bold_B_11">18</samp></p>
</td>
<td class="table TBL">
<p class="TB"><samp class="SANS_TheSansMonoCd_W7Bold_B_11">Color.Equals(Object)</samp></p>
</td>
</tr>
</tbody>
</table>
</figure>
<p class="TX">Even accounting for the overhead of counting the method calls, this report shows a vast improvement in speed compared with our previous results and demonstrates the close relationship between <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">GetHashCode</samp>. We pay a high cost in efficiency if we accept the default behavior of <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">GetHashCode</samp> provided by <samp class="SANS_TheSansMonoCd_W5Regular_11">ValueType</samp> rather than implementing those methods ourselves in our custom struct types.</p>
<p class="TX">If we revisit the profile of our original struct that had <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp> fields but no method overrides, we can see that even though that struct could be packed efficiently, the <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp> method is still invoked much more frequently than in our latest version (see <a href="#tab8-6">Table 8-6</a>).</p>
<figure class="table">
<table class="table">
<caption>
<p class="TT" id="tab8-6"><span class="Heavy"><samp class="SANS_Futura_Std_Heavy_B_11">Table 8-6:</samp></span> <samp class="SANS_Futura_Std_Book_11">Tracing Report for a Packed Struct with No Overrides</samp></p>
</caption>
<thead>
<tr class="table">
<th class="table TCH" scope="col">
<p class="TCH"><samp class="SANS_Futura_Std_Heavy_B_11">Method</samp></p>
</th>
<th class="table TCH" scope="col">
<p class="TCH"><samp class="SANS_Futura_Std_Heavy_B_11">Time (ms)</samp></p>
</th>
<th class="table TCH" scope="col">
<p class="TCH"><samp class="SANS_Futura_Std_Heavy_B_11">Number of calls</samp></p>
</th>
<th class="table TCH" scope="col">
<p class="TCH"><samp class="SANS_Futura_Std_Heavy_B_11">Signature</samp></p>
</th>
</tr>
</thead>
<tbody>
<tr class="table">
<td class="table TBF">
<p class="TB"><samp class="SANS_TheSansMonoCd_W5Regular_11">85.6% AddIfNotPresent</samp></p>
</td>
<td class="table TBF">
<p class="TB"><samp class="SANS_TheSansMonoCd_W5Regular_11">101</samp></p>
</td>
<td class="table TBF">
<p class="TB"><samp class="SANS_TheSansMonoCd_W5Regular_11">25,000</samp></p>
</td>
<td class="table TBF">
<p class="TB"><samp class="SANS_TheSansMonoCd_W5Regular_11">[...]</samp></p>
</td>
</tr>
<tr class="table">
<td class="table TB">
<p class="TB-1"><samp class="SANS_TheSansMonoCd_W7Bold_B_11">30.1% Equals</samp></p>
</td>
<td class="table TB">
<p class="TB"><samp class="SANS_TheSansMonoCd_W7Bold_B_11">36</samp></p>
</td>
<td class="table TB">
<p class="TB"><samp class="SANS_TheSansMonoCd_W7Bold_B_11">1,219,104</samp></p>
</td>
<td class="table TB">
<p class="TB"><samp class="SANS_TheSansMonoCd_W7Bold_B_11">System.ValueType.Equals(Object)</samp></p>
</td>
</tr>
<tr class="table">
<td class="table TB">
<p class="TB-1"><samp class="SANS_TheSansMonoCd_W5Regular_11">7.54% [Garbage collection]</samp></p>
</td>
<td class="table TB">
<p class="TB"><samp class="SANS_TheSansMonoCd_W5Regular_11">8.9</samp></p>
</td>
<td class="table TB">
<p class="TB"><samp class="SANS_TheSansMonoCd_W5Regular_11">17</samp></p>
</td>
<td class="table TB"/>
</tr>
<tr class="table">
<td class="table TBL">
<p class="TB-1"><samp class="SANS_TheSansMonoCd_W5Regular_11">0.42% Resize</samp></p>
</td>
<td class="table TBL">
<p class="TB"><samp class="SANS_TheSansMonoCd_W5Regular_11">0.5</samp></p>
</td>
<td class="table TBL">
<p class="TB"><samp class="SANS_TheSansMonoCd_W5Regular_11">12</samp></p>
</td>
<td class="table TBL">
<p class="TB"><samp class="SANS_TheSansMonoCd_W5Regular_11">System.Collections.Generic.HashSet`1 .Resize(Int32, Boolean)</samp></p>
</td>
</tr>
</tbody>
</table>
</figure>
<p class="TX">We’d certainly notice a performance problem if we were to scale up the number of elements being added to the <samp class="SANS_TheSansMonoCd_W5Regular_11">HashSet</samp>.</p>
<p class="TX"><span aria-label=" Page 261. " epub:type="pagebreak" id="pg_261" role="doc-pagebreak"/>Besides <samp class="SANS_TheSansMonoCd_W5Regular_11">HashSet</samp>, several other collection types rely on hash codes for efficiency, including <samp class="SANS_TheSansMonoCd_W5Regular_11">Dictionary</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">Lookup</samp> types. Therefore, it’s essential that we override both <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">GetHashCode</samp> methods for any type that could be used as a key for hashing collections.</p>
</section>
</section>
<section aria-labelledby="sec10" epub:type="division">
<h2 class="H1" id="sec10"><span id="h-188"/><samp class="SANS_Futura_Std_Bold_B_11">Optimizing Equality</samp></h2>
<p class="TNI">While overriding both <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">GetHashCode</samp> produces the most impressive performance improvements, we can do more to fine-tune equality comparisons. After all, the <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp> method is used in circumstances other than when we’re creating data structures that rely on hash codes.</p>
<p class="TX">Our <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp> struct is a relatively simple data type, and its <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp> method is already quite efficient. To probe the characteristics of <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp>, we’ll make a much more complex <samp class="SANS_TheSansMonoCd_W5Regular_11">Purchase</samp> value type, shown in <a href="#list8-7">Listing 8-7</a>. The <samp class="SANS_TheSansMonoCd_W5Regular_11">Purchase</samp> struct overrides both <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">GetHashCode</samp> with custom implementations but doesn’t yet implement the <samp class="SANS_TheSansMonoCd_W5Regular_11">IEquatable&lt; Purchase&gt;</samp> interface. We’ll implement that interface for <samp class="SANS_TheSansMonoCd_W5Regular_11">Purchase</samp> later to see how that affects the performance of <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp>.</p>
<pre id="list8-7"><code>public readonly struct Purchase&#13;
{&#13;
    public Purchase(Product item, DateTime ordered, int quantity)&#13;
        =&gt; (Item, Ordered, Quantity) = (item, ordered, quantity);&#13;
    <b>public Product   Item {get;}</b>&#13;
    public DateTime  Ordered {get;}&#13;
    public int       Quantity {get;}&#13;
    public override bool Equals(object? obj)&#13;
        =&gt; obj is Purchase other &amp;&amp;&#13;
           Item.Equals(other.Item) &amp;&amp;&#13;
           Ordered == other.Ordered &amp;&amp; Quantity == other.Quantity;&#13;
    public override int GetHashCode()&#13;
        =&gt; HashCode.Combine(Item, Ordered, Quantity);&#13;
}</code></pre>
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 8-7: Defining a more complex data type, Purchase</samp></p>
<p class="TX">The <samp class="SANS_TheSansMonoCd_W5Regular_11">Purchase</samp> type has three fields, one of which is another nontrivial type named <samp class="SANS_TheSansMonoCd_W5Regular_11">Product</samp>, shown here:</p>
<pre><code>public readonly struct Product&#13;
{&#13;
    public Product(int id, decimal price, string name)&#13;
        =&gt; (Id, Price, Name) = (id, price, name);&#13;
    public int     Id {get;}&#13;
    public decimal Price {get;}&#13;
    public string  Name {get;}&#13;
    public override bool Equals(object? obj)&#13;
        =&gt; obj is Product other &amp;&amp;&#13;
           Id == other.Id &amp;&amp; Price == other.Price &amp;&amp; Name == other.Name;&#13;
    public override int GetHashCode()&#13;
        =&gt; HashCode.Combine(Id, Price, Name);&#13;
}</code></pre>
<p class="TX">The <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp> method of <samp class="SANS_TheSansMonoCd_W5Regular_11">Purchase</samp> needs to do a little more work than the <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp> method for the <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp> type back in <a href="#list8-5">Listing 8-5</a>. When we compare two <samp class="SANS_TheSansMonoCd_W5Regular_11">Purchase</samp> instances for equality, the <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp> method must also ensure that the <samp class="SANS_TheSansMonoCd_W5Regular_11">Item</samp> properties match, which involves a method call to <samp class="SANS_TheSansMonoCd_W5Regular_11">Product.Equals</samp>.</p>
<blockquote>
<p class="NOTE"><span class="NoteHead"><samp class="SANS_Dogma_OT_Bold_B_21">NOTE</samp></span></p>
</blockquote>
<p class="NOTE-TXT"><i>The Purchase type is quite large—40 bytes plus padding, assuming a 64-bit architecture—so we should expect copying instances around to be less efficient than for the smaller Color type. That won’t affect our profiling, though, as we’ll still be comparing reports for the same types. We’ll return to the cost of copying large struct instances in “Copying Large Instances” on <a href="#sec18">page 272</a>.</i></p>
<p class="TX">Instead of a <samp class="SANS_TheSansMonoCd_W5Regular_11">HashSet</samp>, we’ll use the <samp class="SANS_TheSansMonoCd_W5Regular_11">SequenceEqual</samp> method to compare two very large lists of <samp class="SANS_TheSansMonoCd_W5Regular_11">Purchase</samp> objects, as shown in <a href="#list8-8">Listing 8-8</a>. This process will exercise the <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp> method, allowing us to measure its efficiency. To magnify the performance of <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp> compared to the cost of the surrounding code, we increase the number of elements to 10 million.</p>
<pre id="list8-8"><code>var items = Enumerable.Range(0, 10_000_000)&#13;
    .Select(id =&gt; new Purchase(new Product(id, id, "Some Description"),&#13;
                               DateTime.MinValue, id))&#13;
    .ToList();&#13;
Assert.That(items.SequenceEqual(items), Is.True);</code></pre>
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 8-8: Testing to exercise equality</samp></p>
<p class="TX">In the <samp class="SANS_TheSansMonoCd_W5Regular_11">Enumerable.Range</samp> method, we use digit separators, available since C# v7.0, to make the large literal number easy for human readers to parse. Digit separators make no difference to the compiler: the number we use for the length of the initial sequence is still a plain <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp> value.</p>
<p class="TX">The <samp class="SANS_TheSansMonoCd_W5Regular_11">SequenceEqual</samp> method compares two sequences and returns <samp class="SANS_TheSansMonoCd_W5Regular_11">true</samp> if they have the same elements in the same order. The algorithm obtains an element from each sequence and compares those elements by using the <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp> method. <samp class="SANS_TheSansMonoCd_W5Regular_11">SequenceEqual</samp> doesn’t try to optimize its result by checking if the two sequences are in fact the <i>same</i> sequence, so here we create only one sequence of 10 million elements and compare it with itself. <a href="#tab8-7">Table 8-7</a> shows the profiler report for the call to <samp class="SANS_TheSansMonoCd_W5Regular_11">SequenceEqual</samp>.</p>
<figure class="table">
<table class="table">
<caption>
<p class="TT" id="tab8-7"><span aria-label=" Page 263. " epub:type="pagebreak" id="pg_263" role="doc-pagebreak"/><span class="Heavy"><samp class="SANS_Futura_Std_Heavy_B_11">Table 8-7:</samp></span> <samp class="SANS_Futura_Std_Book_11">Exercising the</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp> <samp class="SANS_Futura_Std_Book_11">Method</samp></p>
</caption>
<thead>
<tr class="table">
<th class="table TCH" scope="col">
<p class="TCH"><samp class="SANS_Futura_Std_Heavy_B_11">Method</samp></p>
</th>
<th class="table TCH" scope="col">
<p class="TCH"><samp class="SANS_Futura_Std_Heavy_B_11">Time (ms)</samp></p>
</th>
<th class="table TCH" scope="col">
<p class="TCH"><samp class="SANS_Futura_Std_Heavy_B_11">Signature</samp></p>
</th>
</tr>
</thead>
<tbody>
<tr class="table">
<td class="table TBF">
<p class="TB"><samp class="SANS_TheSansMonoCd_W5Regular_11">77.5% SequenceEqual</samp></p>
</td>
<td class="table TBF">
<p class="TB"><samp class="SANS_TheSansMonoCd_W5Regular_11">1,227</samp></p>
</td>
<td class="table TBF">
<p class="TB"><samp class="SANS_TheSansMonoCd_W5Regular_11">System.Linq.Enumerable .SequenceEqual(IEnumerable, IEnumerable)</samp></p>
</td>
</tr>
<tr class="table">
<td class="table TB">
<p class="TB-1"><samp class="SANS_TheSansMonoCd_W5Regular_11">49.3% Equals</samp></p>
</td>
<td class="table TB">
<p class="TB"><samp class="SANS_TheSansMonoCd_W5Regular_11">781</samp></p>
</td>
<td class="table TB">
<p class="TB"><samp class="SANS_TheSansMonoCd_W5Regular_11">Purchase.Equals(Object)</samp></p>
</td>
</tr>
<tr class="table">
<td class="table TB">
<p class="TB-2"><samp class="SANS_TheSansMonoCd_W7Bold_B_11">24.3% [Garbage collection]</samp></p>
</td>
<td class="table TB">
<p class="TB"><samp class="SANS_TheSansMonoCd_W7Bold_B_11">384</samp></p>
</td>
<td class="table TB"/>
</tr>
<tr class="table">
<td class="table TB">
<p class="TB-2"><samp class="SANS_TheSansMonoCd_W5Regular_11">10.6% Equals</samp></p>
</td>
<td class="table TB">
<p class="TB"><samp class="SANS_TheSansMonoCd_W5Regular_11">168</samp></p>
</td>
<td class="table TB">
<p class="TB"><samp class="SANS_TheSansMonoCd_W5Regular_11">Product.Equals(Object)</samp></p>
</td>
</tr>
<tr class="table">
<td class="table TB">
<p class="TB-2"><samp class="SANS_TheSansMonoCd_W5Regular_11">0.75% get_Item</samp></p>
</td>
<td class="table TB">
<p class="TB"><samp class="SANS_TheSansMonoCd_W5Regular_11">12</samp></p>
</td>
<td class="table TB">
<p class="TB"><samp class="SANS_TheSansMonoCd_W5Regular_11">Purchase.get_Item()</samp></p>
</td>
</tr>
<tr class="table">
<td class="table TBL">
<p class="TB-2"><samp class="SANS_TheSansMonoCd_W5Regular_11">0.38% Unbox</samp></p>
</td>
<td class="table TBL">
<p class="TB"><samp class="SANS_TheSansMonoCd_W5Regular_11">6.0</samp></p>
</td>
<td class="table TBL">
<p class="TB"><samp class="SANS_TheSansMonoCd_W5Regular_11">System.Runtime.CompilerServices .CastHelpers.Unbox(Void*, Object)</samp></p>
</td>
</tr>
</tbody>
</table>
</figure>
<p class="TX">We can see that garbage collection contributes a significant portion of the time required by <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp>. Each call to <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp> with a <samp class="SANS_TheSansMonoCd_W5Regular_11">Purchase</samp> instance results in the argument being boxed, as <samp class="SANS_TheSansMonoCd_W5Regular_11">Purchase</samp> is a struct and the parameter type of the <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp> override is <samp class="SANS_TheSansMonoCd_W5Regular_11">object</samp>, a reference type. Furthermore, the <samp class="SANS_TheSansMonoCd_W5Regular_11">Purchase.Equals</samp> method calls <samp class="SANS_TheSansMonoCd_W5Regular_11">Product.Equals</samp>, which also requires its argument to be boxed. The consequence is that we’re allocating many boxed objects on the heap, placing the garbage collector under fairly significant pressure to keep memory usage under control.</p>
<p class="TX">In each <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp> method, the parameter needs to be unboxed back to its original type so that its properties can be compared; the cost of unboxing the <samp class="SANS_TheSansMonoCd_W5Regular_11">object</samp> parameter for each of the <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp> methods is tiny but has a measurable impact. We can avoid the costs of boxing, and much of the associated cost of garbage collection, by implementing <samp class="SANS_TheSansMonoCd_W5Regular_11">IEquatable&lt; T &gt;</samp> for both <samp class="SANS_TheSansMonoCd_W5Regular_11">Purchase</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">Product</samp> types.</p>
<section aria-labelledby="sec11" epub:type="division">
<h3 class="H2" id="sec11"><span id="h-189"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">The Effect of IEquatable&lt;T&gt;</samp></h3>
<p class="TNI">The <samp class="SANS_TheSansMonoCd_W5Regular_11">SequenceEqual</samp> method automatically selects the best (the most efficient) implementation of <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp> available to perform the comparisons. Internally, <samp class="SANS_TheSansMonoCd_W5Regular_11">SequenceEqual</samp> uses the <samp class="SANS_TheSansMonoCd_W5Regular_11">EqualityComparer</samp> helper class from <span class="Xref"><a href="chapter5.xhtml">Chapter 5</a></span> to determine how to compare elements. If the element type <samp class="SANS_TheSansMonoCd_W5Regular_11">T</samp> implements <samp class="SANS_TheSansMonoCd_W5Regular_11">IEquatable&lt; T &gt;</samp>, it’s guaranteed to implement a type-safe overload of <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp>, and that overload will be called by <samp class="SANS_TheSansMonoCd_W5Regular_11">SequenceEqual</samp>.</p>
<p class="TX">If we implement the <samp class="SANS_TheSansMonoCd_W5Regular_11">IEquatable&lt; Purchase&gt;</samp> interface and provide our own type-safe overload of <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp>, the <samp class="SANS_TheSansMonoCd_W5Regular_11">SequenceEqual</samp> method will use the <samp class="SANS_TheSansMonoCd_W5Regular_11">IEquatable&lt; Purchase&gt;</samp> interface method by default, avoiding the need for boxing and then unboxing the argument to <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp>. In turn, this reduces memory pressure because the arguments aren’t copied to the heap, resulting in fewer objects for the garbage collector to inspect. In our example, those reductions are considerable, so implementing the <samp class="SANS_TheSansMonoCd_W5Regular_11">IEquatable&lt; Purchase&gt;</samp> interface should produce a measurable benefit. <a href="#list8-9">Listing 8-9</a> shows the changes required in <samp class="SANS_TheSansMonoCd_W5Regular_11">Purchase</samp>.</p>
<pre id="list8-9"><code><span aria-label=" Page 264. " epub:type="pagebreak" id="pg_264" role="doc-pagebreak"/>public readonly struct Purchase : IEquatable&lt;Purchase&gt;&#13;
{&#13;
    <var>--snip--</var>&#13;
    public bool Equals(Purchase other)&#13;
        =&gt; Item.Equals(other.Item) &amp;&amp;&#13;
           Ordered == other.Ordered &amp;&amp; Quantity == other.Quantity;&#13;
    public override bool Equals(object? obj)&#13;
        =&gt; obj is Purchase other &amp;&amp; Equals(other);&#13;
}</code></pre>
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 8-9: The IEquatable</samp><span class="TheSansMonoCd_W5Regular_11">&lt;</span> <span class="TheSansMonoCd_W5Regular_Italic_I_11">Purchase</span><span class="TheSansMonoCd_W5Regular_11">&gt;</span> <samp class="SANS_Futura_Std_Book_Oblique_I_11">implementation</samp></p>
<p class="TX">We’ve added an <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals(Purchase other)</samp> overload to perform the comparisons between each of the property values. The original <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp> override still needs to unbox its <samp class="SANS_TheSansMonoCd_W5Regular_11">object</samp> parameter in order to call the type-safe <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp> overload, but the <samp class="SANS_TheSansMonoCd_W5Regular_11">SequenceEqual</samp> method won’t call <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals(object?)</samp> because we’ve also changed the <samp class="SANS_TheSansMonoCd_W5Regular_11">Purchase</samp> declaration to implement the <samp class="SANS_TheSansMonoCd_W5Regular_11">IEquatable&lt; Purchase&gt;</samp> interface. In <a href="#list8-10">Listing 8-10</a>, we make similar changes in <samp class="SANS_TheSansMonoCd_W5Regular_11">Product</samp> so that calling <samp class="SANS_TheSansMonoCd_W5Regular_11">Product.Equals</samp> from the <samp class="SANS_TheSansMonoCd_W5Regular_11">Purchase.Equals</samp> method won’t require boxing the <samp class="SANS_TheSansMonoCd_W5Regular_11">Product</samp> instance.</p>
<pre id="list8-10"><code>public readonly struct Product : IEquatable&lt;Product&gt;&#13;
{&#13;
    <var>--snip--</var>&#13;
    public bool Equals(Product other)&#13;
        =&gt; Id == other.Id &amp;&amp; Price == other.Price &amp;&amp; Name == other.Name;&#13;
    public override bool Equals(object? obj)&#13;
        =&gt; obj is Product other &amp;&amp; Equals(other);&#13;
}</code></pre>
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 8-10: Implementing IEquatable</samp><span class="TheSansMonoCd_W5Regular_11">&lt;</span> <span class="TheSansMonoCd_W5Regular_Italic_I_11">Product</span><span class="TheSansMonoCd_W5Regular_11">&gt;</span></p>
<p class="TX">The results of the test from <a href="#list8-8">Listing 8-8</a>, incorporating the changes from <a href="#list8-9">Listings 8-9</a> and <a href="#list8-10">8-10</a>, still with 10 million <samp class="SANS_TheSansMonoCd_W5Regular_11">Purchase</samp> elements, are shown in <a href="#tab8-8">Table 8-8</a>.</p>
<figure class="table">
<table class="table">
<caption>
<p class="TT" id="tab8-8"><span class="Heavy"><samp class="SANS_Futura_Std_Heavy_B_11">Table 8-8:</samp></span> <samp class="SANS_Futura_Std_Book_11">Measuring the Type-Safe</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp> <samp class="SANS_Futura_Std_Book_11">Method</samp></p>
</caption>
<thead>
<tr class="table">
<th class="table TCH" scope="col">
<p class="TCH"><samp class="SANS_Futura_Std_Heavy_B_11">Method</samp></p>
</th>
<th class="table TCH" scope="col">
<p class="TCH"><samp class="SANS_Futura_Std_Heavy_B_11">Time (ms)</samp></p>
</th>
<th class="table TCH" scope="col">
<p class="TCH"><samp class="SANS_Futura_Std_Heavy_B_11">Signature</samp></p>
</th>
</tr>
</thead>
<tbody>
<tr class="table">
<td class="table TBF">
<p class="TB"><samp class="SANS_TheSansMonoCd_W5Regular_11">62.6% SequenceEqual</samp></p>
</td>
<td class="table TBF">
<p class="TB"><samp class="SANS_TheSansMonoCd_W5Regular_11">546</samp></p>
</td>
<td class="table TBF">
<p class="TB"><samp class="SANS_TheSansMonoCd_W5Regular_11">System.Linq.Enumerable .SequenceEqual(IEnumerable, IEnumerable)</samp></p>
</td>
</tr>
<tr class="table">
<td class="table TB">
<p class="TB-1"><samp class="SANS_TheSansMonoCd_W7Bold_B_11">13.0% Equals</samp></p>
</td>
<td class="table TB">
<p class="TB"><samp class="SANS_TheSansMonoCd_W7Bold_B_11">114</samp></p>
</td>
<td class="table TB">
<p class="TB"><samp class="SANS_TheSansMonoCd_W7Bold_B_11">Purchase.Equals(Purchase)</samp></p>
</td>
</tr>
<tr class="table">
<td class="table TB">
<p class="TB-2"><samp class="SANS_TheSansMonoCd_W5Regular_11">5.48% Equals</samp></p>
</td>
<td class="table TB">
<p class="TB"><samp class="SANS_TheSansMonoCd_W5Regular_11">48</samp></p>
</td>
<td class="table TB">
<p class="TB"><samp class="SANS_TheSansMonoCd_W5Regular_11">Product.Equals(Product)</samp></p>
</td>
</tr>
<tr class="table">
<td class="table TB">
<p class="TB-2"><samp class="SANS_TheSansMonoCd_W5Regular_11">2.05% op_Equality</samp></p>
</td>
<td class="table TB">
<p class="TB"><samp class="SANS_TheSansMonoCd_W5Regular_11">18</samp></p>
</td>
<td class="table TB">
<p class="TB"><samp class="SANS_TheSansMonoCd_W5Regular_11">System.DateTime.op_Equality(DateTime, DateTime)</samp></p>
</td>
</tr>
<tr class="table">
<td class="table TB">
<p class="TB-2"><samp class="SANS_TheSansMonoCd_W5Regular_11">1.37% get_Ordered</samp></p>
</td>
<td class="table TB">
<p class="TB"><samp class="SANS_TheSansMonoCd_W5Regular_11">12</samp></p>
</td>
<td class="table TB">
<p class="TB"><samp class="SANS_TheSansMonoCd_W5Regular_11">Purchase.get_Ordered()</samp></p>
</td>
</tr>
<tr class="table">
<td class="table TBL">
<p class="TB-2"><samp class="SANS_TheSansMonoCd_W5Regular_11">1.37% get_Item</samp></p>
</td>
<td class="table TBL">
<p class="TB"><samp class="SANS_TheSansMonoCd_W5Regular_11">12</samp></p>
</td>
<td class="table TBL">
<p class="TB"><samp class="SANS_TheSansMonoCd_W5Regular_11">Purchase.get_Item()</samp></p>
</td>
</tr>
</tbody>
</table>
</figure>
<p class="TX"><span aria-label=" Page 265. " epub:type="pagebreak" id="pg_265" role="doc-pagebreak"/>Comparing this report with <a href="#tab8-7">Table 8-7</a>, we can see that the total time for <samp class="SANS_TheSansMonoCd_W5Regular_11">SequenceEqual</samp> has been greatly reduced, but also that our new <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp> method is significantly faster than the original <samp class="SANS_TheSansMonoCd_W5Regular_11">Purchase</samp> type’s version without the type-safe implementation of <samp class="SANS_TheSansMonoCd_W5Regular_11">IEquatable&lt; Purchase&gt;</samp>. Much of the difference is thanks to the lack of garbage collection, but we’re also benefiting from removing the need to box and unbox the <samp class="SANS_TheSansMonoCd_W5Regular_11">Purchase</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">Product</samp> values.</p>
</section>
<section aria-labelledby="sec12" epub:type="division">
<h3 class="H2" id="sec12"><span id="h-190"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Property Accesses</samp></h3>
<p class="TNI">Our <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals(Purchase)</samp> method spends a measurable portion of its time accessing properties to compare them. All of the properties of both <samp class="SANS_TheSansMonoCd_W5Regular_11">Purchase</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">Product</samp> are automatic properties, and every access to those properties is a method call—for example, the calls to <samp class="SANS_TheSansMonoCd_W5Regular_11">get_Item</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">get_Ordered</samp> shown in <a href="#tab8-8">Table 8-8</a>. While the JIT compiler may often be able to optimize such calls away by inlining the underlying method, there’s no guarantee that it will. In <a href="#list8-11">Listing 8-11</a>, we change <samp class="SANS_TheSansMonoCd_W5Regular_11">Purchase</samp> to introduce our own private fields and alter <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp> to compare the fields directly rather than accessing the property values for comparison.</p>
<pre id="list8-11"><code>public readonly struct Purchase : IEquatable&lt;Purchase&gt;&#13;
{&#13;
    public Purchase(Product item, DateTime ordered, int quantity)&#13;
        =&gt; (this.item, this.ordered, this.quantity) = (item, ordered, quantity);&#13;
    public Product  Item =&gt; item;&#13;
    public DateTime Ordered =&gt; ordered;&#13;
    public int      Quantity =&gt; quantity;&#13;
    public bool Equals(Purchase other)&#13;
        =&gt; item.Equals(other.item) &amp;&amp;&#13;
           <b>ordered</b> <b>==</b> <b>other.ordered &amp;&amp; quantity</b> <b>==</b> <b>other.quantity;</b>&#13;
    public override bool Equals(object? obj)&#13;
        =&gt; obj is Purchase other &amp;&amp; Equals(other);&#13;
    public override int GetHashCode()&#13;
        =&gt; HashCode.Combine(item, ordered, quantity);&#13;
    <b>private readonly Product item;</b>&#13;
    <b>private readonly DateTime ordered;</b>&#13;
    <b>private readonly int quantity;</b>&#13;
}</code></pre>
<p class="CodeListingCaptionWide"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 8-11: Comparing fields rather than properties</samp></p>
<p class="TX">Although not shown here, we also change <samp class="SANS_TheSansMonoCd_W5Regular_11">Product</samp> to replace its automatic properties with private fields. <a href="#tab8-9">Table 8-9</a> shows the results of comparing 10 million elements the same way we have previously.</p>
<figure class="table">
<table class="table">
<caption>
<p class="TT" id="tab8-9"><span aria-label=" Page 266. " epub:type="pagebreak" id="pg_266" role="doc-pagebreak"/><span class="Heavy"><samp class="SANS_Futura_Std_Heavy_B_11">Table 8-9:</samp></span> <samp class="SANS_Futura_Std_Book_11">Comparing the Performance of Fields vs. Properties</samp></p>
</caption>
<thead>
<tr class="table">
<th class="table TCH" scope="col">
<p class="TCH"><samp class="SANS_Futura_Std_Heavy_B_11">Method</samp></p>
</th>
<th class="table TCH" scope="col">
<p class="TCH"><samp class="SANS_Futura_Std_Heavy_B_11">Time (ms)</samp></p>
</th>
<th class="table TCH" scope="col">
<p class="TCH"><samp class="SANS_Futura_Std_Heavy_B_11">Signature</samp></p>
</th>
</tr>
</thead>
<tbody>
<tr class="table">
<td class="table TBF">
<p class="TB"><samp class="SANS_TheSansMonoCd_W5Regular_11">51.2% SequenceEqual</samp></p>
</td>
<td class="table TBF">
<p class="TB"><samp class="SANS_TheSansMonoCd_W5Regular_11">442</samp></p>
</td>
<td class="table TBF">
<p class="TB"><samp class="SANS_TheSansMonoCd_W5Regular_11">System.Linq.Enumerable .SequenceEqual(IEnumerable, IEnumerable)</samp></p>
</td>
</tr>
<tr class="table">
<td class="table TB">
<p class="TB-1"><samp class="SANS_TheSansMonoCd_W5Regular_11">9.73% Equals</samp></p>
</td>
<td class="table TB">
<p class="TB"><samp class="SANS_TheSansMonoCd_W5Regular_11">84</samp></p>
</td>
<td class="table TB">
<p class="TB"><samp class="SANS_TheSansMonoCd_W5Regular_11">Purchase.Equals(Purchase)</samp></p>
</td>
</tr>
<tr class="table">
<td class="table TB">
<p class="TB-2"><samp class="SANS_TheSansMonoCd_W5Regular_11">3.47% Equals</samp></p>
</td>
<td class="table TB">
<p class="TB"><samp class="SANS_TheSansMonoCd_W5Regular_11">30</samp></p>
</td>
<td class="table TB">
<p class="TB"><samp class="SANS_TheSansMonoCd_W5Regular_11">Product.Equals(Product)</samp></p>
</td>
</tr>
<tr class="table">
<td class="table TBL">
<p class="TB-2"><samp class="SANS_TheSansMonoCd_W5Regular_11">1.41% op_Equality</samp></p>
</td>
<td class="table TBL">
<p class="TB"><samp class="SANS_TheSansMonoCd_W5Regular_11">12</samp></p>
</td>
<td class="table TBL">
<p class="TB"><samp class="SANS_TheSansMonoCd_W5Regular_11">System.DateTime.op_Equality(DateTime, DateTime)</samp></p>
</td>
</tr>
</tbody>
</table>
</figure>
<p class="TX">Although replacing automatic properties with fields shows a small improvement, it’s an example of a micro-optimization. We’ve cut the time needed for <samp class="SANS_TheSansMonoCd_W5Regular_11">SequenceEqual</samp> by more than half compared to the version that didn’t implement <samp class="SANS_TheSansMonoCd_W5Regular_11">IEquatable&lt; Purchase&gt;</samp>, but we’re still talking about only a few hundred milliseconds in absolute time. We had to dramatically increase the size of the sequence to amplify the results enough to be observable, and most applications don’t routinely need to compare lists of 10 million elements.</p>
<p class="TX">Implementing the <samp class="SANS_TheSansMonoCd_W5Regular_11">IEquatable&lt; T &gt;</samp> interface is a much more important step. Not only do we benefit from an increase in speed, but our type makes much more efficient use of memory by not needing to box the argument to <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp>. Implementing <samp class="SANS_TheSansMonoCd_W5Regular_11">IEquatable&lt; T &gt;</samp> for value types is more than a performance optimization; it establishes that our type follows that protocol, enabling certain library features to operate more efficiently and signaling efficiency to human readers too.</p>
</section>
<section aria-labelledby="sec13" epub:type="division">
<h3 class="H2" id="sec13"><span id="h-191"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">The Equality Operators</samp></h3>
<p class="TNI">The final part of implementing a full set of equality comparisons for a type is to write our own <samp class="SANS_TheSansMonoCd_W5Regular_11">operator==</samp> with its companion <samp class="SANS_TheSansMonoCd_W5Regular_11">operator</samp><samp class="SANS_TheSansMonoCd_W5Regular_11">!</samp><samp class="SANS_TheSansMonoCd_W5Regular_11">=</samp>. <a href="#list8-12">Listing 8-12</a> shows those operators implemented for <samp class="SANS_TheSansMonoCd_W5Regular_11">Purchase</samp>.</p>
<pre id="list8-12"><code>public readonly struct Purchase : IEquatable&lt;Purchase&gt;&#13;
{&#13;
    <var>--snip--</var>&#13;
    public bool Equals(Purchase other)&#13;
        =&gt; item == other.item &amp;&amp;&#13;
           ordered == other.ordered &amp;&amp; quantity == other.quantity;&#13;
    public static bool operator==(Purchase left, Purchase right)&#13;
        =&gt; left.Equals(right);&#13;
    public static bool operator!=(Purchase left, Purchase right)&#13;
        =&gt; !left.Equals(right);&#13;
}</code></pre>
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 8-12: Implementing equality operators for Purchase</samp></p>
<p class="TX"><span aria-label=" Page 267. " epub:type="pagebreak" id="pg_267" role="doc-pagebreak"/>Again, we also add equality operators to the <samp class="SANS_TheSansMonoCd_W5Regular_11">Product</samp> type (not shown), allowing us to compare the <samp class="SANS_TheSansMonoCd_W5Regular_11">item</samp> field in <samp class="SANS_TheSansMonoCd_W5Regular_11">Purchase</samp> by using <samp class="SANS_TheSansMonoCd_W5Regular_11">==</samp> instead of calling its <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp> method. Each operator implementation simply forwards to our type-safe <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp> method, where the comparison is performed.</p>
<p class="TX">While we can write a test to call <samp class="SANS_TheSansMonoCd_W5Regular_11">operator==</samp> in order to measure its performance characteristics, we can also arrange for the <samp class="SANS_TheSansMonoCd_W5Regular_11">SequenceEqual</samp> method to call the operator rather than <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp> by providing our own equality comparer.</p>
<section aria-labelledby="sec14" epub:type="division">
<h4 class="H3" id="sec14"><samp class="SANS_Futura_Std_Bold_Condensed_B_11">The Generic IEqualityComparer&lt;T&gt; Interface</samp></h4>
<p class="TNI">The <samp class="SANS_TheSansMonoCd_W5Regular_11">SequenceEqual</samp> method doesn’t invoke <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp> directly on the sequence elements to compare them. Instead, it relies on an implementation of <samp class="SANS_TheSansMonoCd_W5Regular_11">IEqualityComparer&lt; T &gt;</samp>, which is part of the Standard Library and declared in the <samp class="SANS_TheSansMonoCd_W5Regular_11">System.Collections.Generic</samp> namespace.</p>
<p class="TX">An implementation of <samp class="SANS_TheSansMonoCd_W5Regular_11">IEqualityComparer&lt; T &gt;</samp> requires an <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp> method taking two parameters of type <samp class="SANS_TheSansMonoCd_W5Regular_11">T</samp>, and a <samp class="SANS_TheSansMonoCd_W5Regular_11">GetHashCode</samp> method with a single <samp class="SANS_TheSansMonoCd_W5Regular_11">T</samp> parameter. The Standard Library provides some default implementations of <samp class="SANS_TheSansMonoCd_W5Regular_11">IEqualityComparer&lt; T &gt;</samp>, including one for instances of <samp class="SANS_TheSansMonoCd_W5Regular_11">T</samp> that implement the <samp class="SANS_TheSansMonoCd_W5Regular_11">IEquatable&lt; T &gt;</samp> interface, which is what our uses of <samp class="SANS_TheSansMonoCd_W5Regular_11">SequenceEqual</samp> have relied upon thus far.</p>
<p class="TX">The <samp class="SANS_TheSansMonoCd_W5Regular_11">SequenceEqual</samp> method has an overload that takes a second parameter whose type is <samp class="SANS_TheSansMonoCd_W5Regular_11">IEqualityComparer&lt; T &gt;</samp>, so we can provide our own implementation to be used instead of the default comparer. In <a href="#list8-13">Listing 8-13</a>, we create our own implementation of the <samp class="SANS_TheSansMonoCd_W5Regular_11">IEqualityComparer&lt; T &gt;</samp> interface, substituting <samp class="SANS_TheSansMonoCd_W5Regular_11">Purchase</samp> as the generic parameter, and pass an instance of our custom comparer to <samp class="SANS_TheSansMonoCd_W5Regular_11">SequenceEqual</samp>.</p>
<pre id="list8-13"><code>public sealed class EqualsOperatorComparer : IEqualityComparer&lt;Purchase&gt;&#13;
{&#13;
    <b>public bool Equals(Purchase x, Purchase y)</b>&#13;
        <b>=&gt;</b> <b>x</b> <b>==</b> <b>y;</b>&#13;
    public int GetHashCode(Purchase obj)&#13;
        =&gt; obj.GetHashCode();&#13;
}&#13;
var items = Enumerable.Range(0, 10_000_000)&#13;
    .Select(MakePurchase)&#13;
    .ToList();&#13;
Assert.That(items.SequenceEqual(items, <b>new EqualsOperatorComparer()</b>));</code></pre>
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 8-13: Creating a custom IEqualityComparer</samp><span class="TheSansMonoCd_W5Regular_11">&lt;</span> <span class="TheSansMonoCd_W5Regular_Italic_I_11">T</span> <span class="TheSansMonoCd_W5Regular_11">&gt;</span> <samp class="SANS_Futura_Std_Book_Oblique_I_11">implementation</samp></p>
<p class="TX">Our implementation of <samp class="SANS_TheSansMonoCd_W5Regular_11">IEqualityComparer&lt; Purchase&gt;</samp> defines its <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp> method to compare its two parameter values with <samp class="SANS_TheSansMonoCd_W5Regular_11">==</samp> instead of the parameter type’s <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp> method. We don’t need a separate implementation for <samp class="SANS_TheSansMonoCd_W5Regular_11">Product</samp> because the <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp> member method in <samp class="SANS_TheSansMonoCd_W5Regular_11">Purchase</samp> uses <samp class="SANS_TheSansMonoCd_W5Regular_11">==</samp> directly to compare the <samp class="SANS_TheSansMonoCd_W5Regular_11">Product</samp> values. Now, when we use <samp class="SANS_TheSansMonoCd_W5Regular_11">SequenceEqual</samp> to compare <span aria-label=" Page 268. " epub:type="pagebreak" id="pg_268" role="doc-pagebreak"/>two sequences of <samp class="SANS_TheSansMonoCd_W5Regular_11">Purchase</samp> items, the algorithm will use <samp class="SANS_TheSansMonoCd_W5Regular_11">operator==</samp> for the comparisons. <a href="#tab8-10">Table 8-10</a> shows the profiler report for comparing 10 million <samp class="SANS_TheSansMonoCd_W5Regular_11">Purchase</samp> items.</p>
<figure class="table">
<table class="table">
<caption>
<p class="TT" id="tab8-10"><span class="Heavy"><samp class="SANS_Futura_Std_Heavy_B_11">Table 8-10:</samp></span> <samp class="SANS_Futura_Std_Book_11">How</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">operator==</samp> <samp class="SANS_Futura_Std_Book_11">Performs</samp></p>
</caption>
<thead>
<tr class="table">
<th class="table TCH" scope="col">
<p class="TCH"><samp class="SANS_Futura_Std_Heavy_B_11">Method</samp></p>
</th>
<th class="table TCH" scope="col">
<p class="TCH"><samp class="SANS_Futura_Std_Heavy_B_11">Time (ms)</samp></p>
</th>
<th class="table TCH" scope="col">
<p class="TCH"><samp class="SANS_Futura_Std_Heavy_B_11">Signature</samp></p>
</th>
</tr>
</thead>
<tbody>
<tr class="table">
<td class="table TBF">
<p class="TB"><samp class="SANS_TheSansMonoCd_W5Regular_11">48.8% SequenceEqual</samp></p>
</td>
<td class="table TBF">
<p class="TB"><samp class="SANS_TheSansMonoCd_W5Regular_11">475</samp></p>
</td>
<td class="table TBF">
<p class="TB"><samp class="SANS_TheSansMonoCd_W5Regular_11">System.Linq.Enumerable.SequenceEqual [...]</samp></p>
</td>
</tr>
<tr class="table">
<td class="table TB">
<p class="TB-1"><samp class="SANS_TheSansMonoCd_W5Regular_11">22.2% Equals</samp></p>
</td>
<td class="table TB">
<p class="TB"><samp class="SANS_TheSansMonoCd_W5Regular_11">216</samp></p>
</td>
<td class="table TB">
<p class="TB"><samp class="SANS_TheSansMonoCd_W5Regular_11">EqualsOperatorComparer .Equals(Purchase, Purchase)</samp></p>
</td>
</tr>
<tr class="table">
<td class="table TB">
<p class="TB-2"><samp class="SANS_TheSansMonoCd_W7Bold_B_11">9.28% op_Equality</samp></p>
</td>
<td class="table TB">
<p class="TB"><samp class="SANS_TheSansMonoCd_W7Bold_B_11">90</samp></p>
</td>
<td class="table TB">
<p class="TB"><samp class="SANS_TheSansMonoCd_W7Bold_B_11">Purchase.op_Equality(Purchase, Purchase)</samp></p>
</td>
</tr>
<tr class="table">
<td class="table TB">
<p class="TB-3"><samp class="SANS_TheSansMonoCd_W5Regular_11">9.28% Equals</samp></p>
</td>
<td class="table TB">
<p class="TB"><samp class="SANS_TheSansMonoCd_W5Regular_11">90</samp></p>
</td>
<td class="table TB">
<p class="TB"><samp class="SANS_TheSansMonoCd_W5Regular_11">Purchase.Equals(Purchase)</samp></p>
</td>
</tr>
<tr class="table">
<td class="table TB">
<p class="TB-4"><samp class="SANS_TheSansMonoCd_W5Regular_11">5.53% op_Equality</samp></p>
</td>
<td class="table TB">
<p class="TB"><samp class="SANS_TheSansMonoCd_W5Regular_11">54</samp></p>
</td>
<td class="table TB">
<p class="TB"><samp class="SANS_TheSansMonoCd_W5Regular_11">Product.op_Equality(Product, Product)</samp></p>
</td>
</tr>
<tr class="table">
<td class="table TBL">
<p class="TB-5"><samp class="SANS_TheSansMonoCd_W5Regular_11">3.69% Equals</samp></p>
</td>
<td class="table TBL">
<p class="TB"><samp class="SANS_TheSansMonoCd_W5Regular_11">36</samp></p>
</td>
<td class="table TBL">
<p class="TB"><samp class="SANS_TheSansMonoCd_W5Regular_11">Product.Equals(Product)</samp></p>
</td>
</tr>
</tbody>
</table>
</figure>
<p class="TX">When we define <samp class="SANS_TheSansMonoCd_W5Regular_11">operator==</samp> for any type, the compiler translates it to a static method named <samp class="SANS_TheSansMonoCd_W5Regular_11">op_Equality</samp>, shown in this profiler report. That method takes both of its parameters by value, so we’re making a lot of copies of both <samp class="SANS_TheSansMonoCd_W5Regular_11">Purchase</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">Product</samp> instances. We can reduce the number of copies needed by changing the <samp class="SANS_TheSansMonoCd_W5Regular_11">operator==</samp> methods to take their parameters by reference instead.</p>
</section>
<section aria-labelledby="sec15" epub:type="division">
<h4 class="H3" id="sec15"><samp class="SANS_Futura_Std_Bold_Condensed_B_11">Read-Only in Parameters</samp></h4>
<p class="TNI">To reap the benefits of altering our <samp class="SANS_TheSansMonoCd_W5Regular_11">operator==</samp> methods to take their parameters by reference rather than by value, we can use read-only <samp class="SANS_TheSansMonoCd_W5Regular_11">in</samp> parameters. They are specifically intended for avoiding copies of large value type instances and are appropriate when we don’t need to mutate the parameter variables.</p>
<p class="TX">We shouldn’t expect a huge improvement, however, because we can’t avoid all the copies being made when comparing the <samp class="SANS_TheSansMonoCd_W5Regular_11">Purchase</samp> elements in our sequence. In particular, the <samp class="SANS_TheSansMonoCd_W5Regular_11">EqualsOperatorComparer.Equals</samp> method must take its parameters by value to match the signature defined in the <samp class="SANS_TheSansMonoCd_W5Regular_11">IEqualityComparer&lt; T &gt;</samp> interface.</p>
<p class="TX">Similarly, as shown in <a href="#list8-14">Listing 8-14</a>, the type-safe <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp> method defined in <samp class="SANS_TheSansMonoCd_W5Regular_11">Purchase</samp> itself takes its parameter by value according to the <samp class="SANS_TheSansMonoCd_W5Regular_11">IEquatable&lt; T &gt;</samp> interface, but we can add a new overload of <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp> that uses an <samp class="SANS_TheSansMonoCd_W5Regular_11">in</samp> parameter and use the same mechanism to alter the equality operators to take all their parameters by reference.</p>
<pre id="list8-14"><code>public readonly struct Purchase : IEquatable&lt;Purchase&gt;&#13;
{&#13;
    <var>--snip--</var>&#13;
    <b>public bool Equals(in Purchase other)</b>&#13;
        <b>=&gt;</b> <b>item</b> <b>==</b> <b>other.item &amp;&amp;</b>&#13;
           <b>ordered</b> <b>==</b> <b>other.ordered &amp;&amp; quantity</b> <b>==</b> <b>other.quantity;</b>&#13;
    public bool Equals(Purchase other)&#13;
        =&gt; Equals(in other);&#13;
    public static bool operator==(<b>in Purchase left, in Purchase right</b>)&#13;
        =&gt; <b>left.Equals(in right);</b>&#13;
    public static bool operator!=(in Purchase left, in Purchase right)&#13;
        =&gt; !left.Equals(in right);&#13;
}</code></pre>
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 8-14: Overloading using in parameters</samp></p>
<p class="TX">We make the <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp> method with an <samp class="SANS_TheSansMonoCd_W5Regular_11">in</samp> parameter the main implementation and forward to it from the equality operators and the implementation of <samp class="SANS_TheSansMonoCd_W5Regular_11">IEquatable&lt; Purchase&gt;</samp>. Although <samp class="SANS_TheSansMonoCd_W5Regular_11">in</samp> parameters are transparent to calling code, the rules for overloading will give preference to the method with no parameter modifiers, unless we add an <samp class="SANS_TheSansMonoCd_W5Regular_11">in</samp> modifier to the argument when calling the method. Therefore, we explicitly select the overload with <samp class="SANS_TheSansMonoCd_W5Regular_11">in</samp> parameters by adding the <samp class="SANS_TheSansMonoCd_W5Regular_11">in</samp> keyword to the argument we pass wherever we call <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp>.</p>
<blockquote>
<p class="NOTE"><span class="NoteHead"><samp class="SANS_Dogma_OT_Bold_B_21">NOTE</samp></span></p>
</blockquote>
<p class="NOTE-TXT"><i>Replacing value parameters with in parameters is a version-breaking change, requiring extra care if binary compatibility is a consideration.</i></p>
<p class="TX">We don’t need to change the implementation of our <samp class="SANS_TheSansMonoCd_W5Regular_11">EqualsOperatorComparer</samp> to pass the arguments by reference, since our <samp class="SANS_TheSansMonoCd_W5Regular_11">operator==</samp> method doesn’t have an overload taking parameters by value. We can reuse the <samp class="SANS_TheSansMonoCd_W5Regular_11">EqualsOperatorComparer</samp> from <a href="#list8-13">Listing 8-13</a> to run the test, with the results shown in <a href="#tab8-11">Table 8-11</a>.</p>
<figure class="table">
<table class="table">
<caption>
<p class="TT" id="tab8-11"><span class="Heavy"><samp class="SANS_Futura_Std_Heavy_B_11">Table 8-11:</samp></span> <samp class="SANS_Futura_Std_Book_11">Results of Passing by Reference to</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">operator==</samp></p>
</caption>
<thead>
<tr class="table">
<th class="table TCH" scope="col">
<p class="TCH"><samp class="SANS_Futura_Std_Heavy_B_11">Method</samp></p>
</th>
<th class="table TCH" scope="col">
<p class="TCH"><samp class="SANS_Futura_Std_Heavy_B_11">Time (ms)</samp></p>
</th>
<th class="table TCH" scope="col">
<p class="TCH"><samp class="SANS_Futura_Std_Heavy_B_11">Signature</samp></p>
</th>
</tr>
</thead>
<tbody>
<tr class="table">
<td class="table TBF">
<p class="TB"><samp class="SANS_TheSansMonoCd_W5Regular_11">45.1% SequenceEqual</samp></p>
</td>
<td class="table TBF">
<p class="TB"><samp class="SANS_TheSansMonoCd_W5Regular_11">437</samp></p>
</td>
<td class="table TBF">
<p class="TB"><samp class="SANS_TheSansMonoCd_W5Regular_11">System.Linq.Enumerable.SequenceEqual [...]</samp></p>
</td>
</tr>
<tr class="table">
<td class="table TB">
<p class="TB-1"><samp class="SANS_TheSansMonoCd_W5Regular_11">20.9% Equals</samp></p>
</td>
<td class="table TB">
<p class="TB"><samp class="SANS_TheSansMonoCd_W5Regular_11">203</samp></p>
</td>
<td class="table TB">
<p class="TB"><samp class="SANS_TheSansMonoCd_W5Regular_11">EqualsOperatorComparer.Equals(Purchase, Purchase)</samp></p>
</td>
</tr>
<tr class="table">
<td class="table TB">
<p class="TB-2"><samp class="SANS_TheSansMonoCd_W5Regular_11">10.5% op_Equality</samp></p>
</td>
<td class="table TB">
<p class="TB"><samp class="SANS_TheSansMonoCd_W5Regular_11">102</samp></p>
</td>
<td class="table TB">
<p class="TB"><samp class="SANS_TheSansMonoCd_W5Regular_11">Purchase.op_Equality(in Purchase, in Purchase)</samp></p>
</td>
</tr>
<tr class="table">
<td class="table TB">
<p class="TB-3"><samp class="SANS_TheSansMonoCd_W5Regular_11">9.23% Equals</samp></p>
</td>
<td class="table TB">
<p class="TB"><samp class="SANS_TheSansMonoCd_W5Regular_11">90</samp></p>
</td>
<td class="table TB">
<p class="TB"><samp class="SANS_TheSansMonoCd_W5Regular_11">Purchase.Equals(in Purchase)</samp></p>
</td>
</tr>
<tr class="table">
<td class="table TB">
<p class="TB-4"><samp class="SANS_TheSansMonoCd_W5Regular_11">7.38% op_Equality</samp></p>
</td>
<td class="table TB">
<p class="TB"><samp class="SANS_TheSansMonoCd_W5Regular_11">72</samp></p>
</td>
<td class="table TB">
<p class="TB"><samp class="SANS_TheSansMonoCd_W5Regular_11">Product.op_Equality(in Product, in Product)</samp></p>
</td>
</tr>
<tr class="table">
<td class="table TBL">
<p class="TB-5"><samp class="SANS_TheSansMonoCd_W5Regular_11">7.38% Equals</samp></p>
</td>
<td class="table TBL">
<p class="TB"><samp class="SANS_TheSansMonoCd_W5Regular_11">72</samp></p>
</td>
<td class="table TBL">
<p class="TB"><samp class="SANS_TheSansMonoCd_W5Regular_11">Product.Equals(in Product)</samp></p>
</td>
</tr>
</tbody>
</table>
</figure>
<p class="TX">Comparing these results to <a href="#tab8-10">Table 8-10</a>, we can see the improvement is quite modest. While we certainly get some benefit from avoiding copying <samp class="SANS_TheSansMonoCd_W5Regular_11">Purchase</samp> objects, that benefit is limited to <samp class="SANS_TheSansMonoCd_W5Regular_11">operator==</samp> actually being called. <a href="#tab8-12">Table 8-12</a> shows a tracing report with counts of the number of method <span aria-label=" Page 270. " epub:type="pagebreak" id="pg_270" role="doc-pagebreak"/>calls, showing that the JIT compiler is inlining all but a very few calls to <samp class="SANS_TheSansMonoCd_W5Regular_11">operator==</samp>.</p>
<figure class="table">
<table class="table">
<caption>
<p class="TT" id="tab8-12"><span class="Heavy"><samp class="SANS_Futura_Std_Heavy_B_11">Table 8-12:</samp></span> <samp class="SANS_Futura_Std_Book_11">Tracing Report for Comparing</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">in</samp> <samp class="SANS_Futura_Std_Book_11">Parameter Values</samp></p>
</caption>
<thead>
<tr class="table">
<th class="table TCH" scope="col">
<p class="TCH"><samp class="SANS_Futura_Std_Heavy_B_11">Method</samp></p>
</th>
<th class="table TCH" scope="col">
<p class="TCH"><samp class="SANS_Futura_Std_Heavy_B_11">Time (ms)</samp></p>
</th>
<th class="table TCH" scope="col">
<p class="TCH"><samp class="SANS_Futura_Std_Heavy_B_11">Number of calls</samp></p>
</th>
<th class="table TCH" scope="col">
<p class="TCH"><samp class="SANS_Futura_Std_Heavy_B_11">Signature</samp></p>
</th>
</tr>
</thead>
<tbody>
<tr class="table">
<td class="table TBF">
<p class="TB"><samp class="SANS_TheSansMonoCd_W5Regular_11">1.88% SequenceEqual</samp></p>
</td>
<td class="table TBF">
<p class="TB"><samp class="SANS_TheSansMonoCd_W5Regular_11">2,013</samp></p>
</td>
<td class="table TBF">
<p class="TB"><samp class="SANS_TheSansMonoCd_W5Regular_11">1 call</samp></p>
</td>
<td class="table TBF">
<p class="TB"><samp class="SANS_TheSansMonoCd_W5Regular_11">System.Linq.Enumerable.SequenceEqual [...]</samp></p>
</td>
</tr>
<tr class="table">
<td class="table TB">
<p class="TB-1"><samp class="SANS_TheSansMonoCd_W5Regular_11">0.69% Equals</samp></p>
</td>
<td class="table TB">
<p class="TB"><samp class="SANS_TheSansMonoCd_W5Regular_11">735</samp></p>
</td>
<td class="table TB">
<p class="TB"><samp class="SANS_TheSansMonoCd_W5Regular_11">10,000,000 calls</samp></p>
</td>
<td class="table TB">
<p class="TB"><samp class="SANS_TheSansMonoCd_W5Regular_11">EqualsOperatorComparer.Equals(Purchase, Purchase)</samp></p>
</td>
</tr>
<tr class="table">
<td class="table TB">
<p class="TB-1"><samp class="SANS_TheSansMonoCd_W5Regular_11">[...]</samp></p>
</td>
<td class="table TB"/>
<td class="table TB"/>
<td class="table TB"/>
</tr>
<tr class="table">
<td class="table TBL">
<p class="TB-2"><samp class="SANS_TheSansMonoCd_W7Bold_B_11">0.08% op_Equality</samp></p>
</td>
<td class="table TBL">
<p class="TB"><samp class="SANS_TheSansMonoCd_W7Bold_B_11">82</samp></p>
</td>
<td class="table TBL">
<p class="TB"><samp class="SANS_TheSansMonoCd_W7Bold_B_11">126,402 calls</samp></p>
</td>
<td class="table TBL">
<p class="TB"><samp class="SANS_TheSansMonoCd_W7Bold_B_11">Purchase.op_Equality(in Purchase, in Purchase)</samp></p>
</td>
</tr>
</tbody>
</table>
</figure>
<p class="TX">While using <samp class="SANS_TheSansMonoCd_W5Regular_11">in</samp> parameters in our definition of <samp class="SANS_TheSansMonoCd_W5Regular_11">operator==</samp> is free in that it requires no changes to calling code, we shouldn’t expect too much from it. We also shouldn’t simply apply <samp class="SANS_TheSansMonoCd_W5Regular_11">in</samp> parameters routinely, even when using them wouldn’t detract from a method’s readability. Passing small value types by reference may incur a penalty due to the extra level of indirection required to access the value itself via a by-reference variable. As with any optimization feature in the code, we should introduce <samp class="SANS_TheSansMonoCd_W5Regular_11">in</samp> parameters only where our measurements show that they’re warranted.</p>
</section>
</section>
</section>
<section aria-labelledby="sec16" epub:type="division">
<h2 class="H1" id="sec16"><span id="h-192"/><samp class="SANS_Futura_Std_Bold_B_11">How Type Affects Performance</samp></h2>
<p class="TNI">Our choice of types in an application can affect its overall performance in various ways. The types we use to represent values in an application are the most important part of that choice because the other types will usually be classes in any case. Values, on the other hand, can be represented as structs, classes, records, or record structs. In this section, we’ll examine some of the factors that can help us decide between using struct types and class types to implement those value types, and how much those factors affect performance.</p>
<p class="TX">We often hear that structs, and therefore record structs, should be small because it’s expensive to copy large instances around in memory. With that in mind, we’ll start by attempting to isolate the cost of copying instances from the other factors affecting performance.</p>
<section aria-labelledby="sec17" epub:type="division">
<h3 class="H2" id="sec17"><span id="h-193"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Measuring the Cost of Copying</samp></h3>
<p class="TNI">As with our previous performance measurements, we need to establish a simple baseline against which we can compare further performance reports. Since we want to measure the cost of copying a large value type, first we have to measure the cost of copying a small, simple type, like the <samp class="SANS_TheSansMonoCd_W5Regular_11">IntField</samp> struct we create in <a href="#list8-15">Listing 8-15</a>.</p>
<pre id="list8-15"><code><span aria-label=" Page 271. " epub:type="pagebreak" id="pg_271" role="doc-pagebreak"/>public readonly struct IntField : IEquatable&lt;IntField&gt;&#13;
{&#13;
    public IntField(int value)&#13;
        =&gt; this.value = value;&#13;
    public bool Equals(IntField other)&#13;
        =&gt; value == other.value;&#13;
    private readonly int value;&#13;
}</code></pre>
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 8-15: Creating a simple struct with a single int field</samp></p>
<p class="TX">To exercise copying, we’ll again use the <samp class="SANS_TheSansMonoCd_W5Regular_11">SequenceEqual</samp> method, which copies elements from the sequences to compare them and will copy them again to call the <samp class="SANS_TheSansMonoCd_W5Regular_11">IEqualityComparer&lt; T</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">&gt;</samp><samp class="SANS_TheSansMonoCd_W5Regular_11">.Equals</samp> method. Here, we return to using the default equality comparer, which will call our type-safe <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp> method, passing its argument by value. <a href="#list8-16">Listing 8-16</a> shows the code we’ll use to produce our benchmark performance profile.</p>
<pre id="list8-16"><code>var items = Enumerable.Range(0, 10_000_000)&#13;
    .Select(i =&gt; new IntField(i))&#13;
    .ToList();&#13;
Assert.That(items.SequenceEqual(items));</code></pre>
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 8-16: Testing simple copies</samp></p>
<p class="TX">For this test, we’ll profile a debug build of this code to try to minimize the effects of the method inlining performed by the JIT compiler. Method arguments are copied only if the method is invoked normally, and inlining would make measuring the cost of those copies unreliable; two different runs of the code could easily make a different number of copies. <a href="#tab8-13">Table 8-13</a> shows the CPU sampling report for comparing two sequences of 10 million <samp class="SANS_TheSansMonoCd_W5Regular_11">IntField</samp> items in a debug build, which inhibits the JIT compiler from inlining method calls.</p>
<figure class="table">
<table class="table1">
<caption>
<p class="TT" id="tab8-13"><span class="Heavy"><samp class="SANS_Futura_Std_Heavy_B_11">Table 8-13:</samp></span> <samp class="SANS_Futura_Std_Book_11">Measuring the Cost of Copying a Simple Struct</samp></p>
</caption>
<thead>
<tr class="table">
<th class="table TCH" scope="col">
<p class="TCH"><samp class="SANS_Futura_Std_Heavy_B_11">Method</samp></p>
</th>
<th class="table TCH" scope="col">
<p class="TCH"><samp class="SANS_Futura_Std_Heavy_B_11">Time (ms)</samp></p>
</th>
<th class="table TCH" scope="col">
<p class="TCH"><samp class="SANS_Futura_Std_Heavy_B_11">Signature</samp></p>
</th>
</tr>
</thead>
<tbody>
<tr class="table">
<td class="table TBF">
<p class="TB"><samp class="SANS_TheSansMonoCd_W5Regular_11">57.0% SequenceEqual</samp></p>
</td>
<td class="table TBF">
<p class="TB"><samp class="SANS_TheSansMonoCd_W5Regular_11">90</samp></p>
</td>
<td class="table TBF">
<p class="TB"><samp class="SANS_TheSansMonoCd_W5Regular_11">System.Linq.Enumerable .SequenceEqual(IEnumerable, IEnumerable)</samp></p>
</td>
</tr>
<tr class="table">
<td class="table TBL">
<p class="TB-1"><samp class="SANS_TheSansMonoCd_W5Regular_11">7.60% Equals</samp></p>
</td>
<td class="table TBL">
<p class="TB"><samp class="SANS_TheSansMonoCd_W5Regular_11">12</samp></p>
</td>
<td class="table TBL">
<p class="TB"><samp class="SANS_TheSansMonoCd_W5Regular_11">IntField.Equals(IntField)</samp></p>
</td>
</tr>
</tbody>
</table>
</figure>
<p class="TX">The <samp class="SANS_TheSansMonoCd_W5Regular_11">SequenceEqual</samp> algorithm does little other than obtain an element from each sequence and compare one to the other with <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp>. The difference between the time taken by <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp> and the total time spent in <samp class="SANS_TheSansMonoCd_W5Regular_11">SequenceEqual</samp> here is all overhead, representing the time taken to obtain each pair of elements from the sequences and copy the arguments for <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp>.</p>
</section>
<section aria-labelledby="sec18" epub:type="division">
<h3 class="H2" id="sec18"><span id="h-194"/><span aria-label=" Page 272. " epub:type="pagebreak" id="pg_272" role="doc-pagebreak"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Copying Large Instances</samp></h3>
<p class="TNI">Copying a simple struct type such as the <samp class="SANS_TheSansMonoCd_W5Regular_11">IntField</samp> struct in <a href="#list8-15">Listing 8-15</a> is no more expensive than copying a plain <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp> value; a simple test (not shown here) that compares two sequences of <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp> values will confirm it. The <samp class="SANS_TheSansMonoCd_W5Regular_11">IntPlus3x16</samp> struct in <a href="#list8-17">Listing 8-17</a>, which adds three entirely redundant <samp class="SANS_TheSansMonoCd_W5Regular_11">Guid</samp> fields, is significantly larger than the <samp class="SANS_TheSansMonoCd_W5Regular_11">IntField</samp> struct. Each <samp class="SANS_TheSansMonoCd_W5Regular_11">Guid</samp> is 16 bytes, making this struct somewhat larger than even the most generous recommended limit for the size of a value type.</p>
<pre id="list8-17"><code>public readonly struct IntPlus3x16 : IEquatable&lt;IntPlus3x16&gt;&#13;
{&#13;
    public IntPlus3x16(int value)&#13;
        =&gt; this.value = value;&#13;
    public bool Equals(IntPlus3x16 other)&#13;
        =&gt; value == other.value;&#13;
    private readonly int value;&#13;
    <b>private readonly Guid _padding1</b> <b>=</b> <b>Guid.Empty;</b>&#13;
    <b>private readonly Guid _padding2</b> <b>=</b> <b>Guid.Empty;</b>&#13;
    <b>private readonly Guid _padding3</b> <b>=</b> <b>Guid.Empty;</b>&#13;
}</code></pre>
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 8-17: Creating an extremely large struct</samp></p>
<p class="TX">Note one subtlety in the <samp class="SANS_TheSansMonoCd_W5Regular_11">IntPlus3x16</samp> struct: the <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp> method doesn’t consider any of the <samp class="SANS_TheSansMonoCd_W5Regular_11">Guid</samp> fields of the type, because they’re always all identical in any case. The reason is that we’re trying to measure just the cost of copying, so this <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp> method performs precisely the same operations as the <samp class="SANS_TheSansMonoCd_W5Regular_11">IntField</samp> type in <a href="#list8-15">Listing 8-15</a>. While the padding fields play no part in the <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp> method or any other operation, the <samp class="SANS_TheSansMonoCd_W5Regular_11">IntPlus3x16</samp> type is a struct and therefore copied by value, so <i>every</i> field will be copied. We run the same test from <a href="#list8-16">Listing 8-16</a>, with the results shown in <a href="#tab8-14">Table 8-14</a>.</p>
<figure class="table">
<table class="table1">
<caption>
<p class="TT" id="tab8-14"><span class="Heavy"><samp class="SANS_Futura_Std_Heavy_B_11">Table 8-14:</samp></span> <samp class="SANS_Futura_Std_Book_11">Measuring the Cost of Copying an Extra-Large Struct</samp></p>
</caption>
<thead>
<tr class="table">
<th class="table TCH" scope="col">
<p class="TCH"><samp class="SANS_Futura_Std_Heavy_B_11">Method</samp></p>
</th>
<th class="table TCH" scope="col">
<p class="TCH"><samp class="SANS_Futura_Std_Heavy_B_11">Time (ms)</samp></p>
</th>
<th class="table TCH" scope="col">
<p class="TCH"><samp class="SANS_Futura_Std_Heavy_B_11">Signature</samp></p>
</th>
</tr>
</thead>
<tbody>
<tr class="table">
<td class="table TBF">
<p class="TB"><samp class="SANS_TheSansMonoCd_W5Regular_11">52.5% SequenceEqual</samp></p>
</td>
<td class="table TBF">
<p class="TB"><samp class="SANS_TheSansMonoCd_W5Regular_11">228</samp></p>
</td>
<td class="table TBF">
<p class="TB"><samp class="SANS_TheSansMonoCd_W5Regular_11">System.Linq.Enumerable .SequenceEqual(IEnumerable, IEnumerable)</samp></p>
</td>
</tr>
<tr class="table">
<td class="table TBL">
<p class="TB-1"><samp class="SANS_TheSansMonoCd_W5Regular_11">2.71% Equals</samp></p>
</td>
<td class="table TBL">
<p class="TB"><samp class="SANS_TheSansMonoCd_W5Regular_11">12</samp></p>
</td>
<td class="table TBL">
<p class="TB"><samp class="SANS_TheSansMonoCd_W5Regular_11">IntPlus3x16.Equals(IntPlus3x16)</samp></p>
</td>
</tr>
</tbody>
</table>
</figure>
<p class="TX">Compare <a href="#tab8-14">Table 8-14</a> with <a href="#tab8-13">Table 8-13</a>: the time spent in the <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp> method is identical in both reports, although the <samp class="SANS_TheSansMonoCd_W5Regular_11">SequenceEqual</samp> method has taken over twice as long to complete because of the extra overhead of copying the instances of the larger <samp class="SANS_TheSansMonoCd_W5Regular_11">IntPlus3x16</samp> type. The <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp> method in both tests is performing the same operation, so the increase in time must be entirely due to the cost of copying instances.</p>
</section>
<section aria-labelledby="sec19" epub:type="division">
<h3 class="H2" id="sec19"><span id="h-195"/><span aria-label=" Page 273. " epub:type="pagebreak" id="pg_273" role="doc-pagebreak"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Weighing Object Construction Costs</samp></h3>
<p class="TNI">The cost of copying a large struct is not the only aspect to consider when using a type with several fields. For one thing, equality comparisons will usually take every field or property into account, making those comparisons more costly than for a type with only one or two fields. Initializing an instance of a type with several fields also comes with a cost.</p>
<p class="TX">The <samp class="SANS_TheSansMonoCd_W5Regular_11">Purchase</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">Product</samp> types in <a href="#list8-18">Listing 8-18</a> are the positional record struct equivalents of the <samp class="SANS_TheSansMonoCd_W5Regular_11">Purchase</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">Product</samp> structs we defined earlier in <a href="#list8-7">Listing 8-7</a>. Because they’re record struct types, the compiler generates all the equality comparisons, making them much simpler to define than their struct counterparts.</p>
<pre id="list8-18"><code>public readonly record struct Product&#13;
    (int Id, decimal Price, string Name);&#13;
public readonly record struct Purchase&#13;
    (Product Item, DateTime Ordered, int Quantity);</code></pre>
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 8-18: Defining Product and Purchase as record structs</samp></p>
<p class="TX">We’ll use the <samp class="SANS_TheSansMonoCd_W5Regular_11">CompareSequences</samp> method shown in <a href="#list8-19">Listing 8-19</a> to create a sequence of <samp class="SANS_TheSansMonoCd_W5Regular_11">Purchase</samp> instances and record the performance. We return here to profiling a release build so that the results account for any optimizations afforded by the JIT (or AOT) compiler.</p>
<pre id="list8-19"><code>private static Purchase MakePurchase(int id)&#13;
    =&gt; new Purchase(new Product(id, id, "Some Description"),&#13;
        DateTime.MinValue, id);&#13;
public static void CompareSequences(int count)&#13;
{&#13;
    var items = Enumerable.Range(0, count)&#13;
        <b>.Select(MakePurchase)</b>&#13;
        .ToList();&#13;
    Assert.That(items.SequenceEqual(items));&#13;
}</code></pre>
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 8-19: Creating a sequence of randomly generated objects</samp></p>
<p class="TX">The <samp class="SANS_TheSansMonoCd_W5Regular_11">CompareSequences</samp> method follows a pattern similar to that we’ve used previously to create a sequence and then call <samp class="SANS_TheSansMonoCd_W5Regular_11">SequenceEqual</samp> to compare the elements. For the purposes of making the performance report clear, we use <samp class="SANS_TheSansMonoCd_W5Regular_11">MakePurchase</samp> as a method group argument for the <samp class="SANS_TheSansMonoCd_W5Regular_11">Select</samp> expression. That way, we can measure its performance directly, without introducing any overhead by using a lambda expression—something we’ll return to in <span class="Xref">“How Common Idioms and Practices Affect Performance” on <a href="#sec23">page 279</a></span>. <a href="#tab8-15">Table 8-15</a> shows the profiler report for creating 10 million <samp class="SANS_TheSansMonoCd_W5Regular_11">Purchase</samp> objects using the <samp class="SANS_TheSansMonoCd_W5Regular_11">MakePurchase</samp> method.</p>
<figure class="table">
<table class="table">
<caption>
<p class="TT" id="tab8-15"><span aria-label=" Page 274. " epub:type="pagebreak" id="pg_274" role="doc-pagebreak"/><span class="Heavy"><samp class="SANS_Futura_Std_Heavy_B_11">Table 8-15:</samp></span> <samp class="SANS_Futura_Std_Book_11">Performance Report for Creating the</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">Purchase</samp> <samp class="SANS_Futura_Std_Book_11">Sequence</samp></p>
</caption>
<thead>
<tr class="table">
<th class="table TCH" scope="col">
<p class="TCH"><samp class="SANS_Futura_Std_Heavy_B_11">Method</samp></p>
</th>
<th class="table TCH" scope="col">
<p class="TCH"><samp class="SANS_Futura_Std_Heavy_B_11">Time (ms)</samp></p>
</th>
<th class="table TCH" scope="col">
<p class="TCH"><samp class="SANS_Futura_Std_Heavy_B_11">Signature</samp></p>
</th>
</tr>
</thead>
<tbody>
<tr class="table">
<td class="table TBF">
<p class="TB"><samp class="SANS_TheSansMonoCd_W5Regular_11">29.4% MakePurchase</samp></p>
</td>
<td class="table TBF">
<p class="TB"><samp class="SANS_TheSansMonoCd_W5Regular_11">294</samp></p>
</td>
<td class="table TBF">
<p class="TB"><samp class="SANS_TheSansMonoCd_W5Regular_11">MakePurchase(Int32)</samp></p>
</td>
</tr>
<tr class="table">
<td class="table TB">
<p class="TB-1"><samp class="SANS_TheSansMonoCd_W5Regular_11">2.45% op_Implicit</samp></p>
</td>
<td class="table TB">
<p class="TB"><samp class="SANS_TheSansMonoCd_W5Regular_11">25</samp></p>
</td>
<td class="table TB">
<p class="TB"><samp class="SANS_TheSansMonoCd_W5Regular_11">System.Decimal.op_Implicit(Int32)</samp></p>
</td>
</tr>
<tr class="table">
<td class="table TB">
<p class="TB-1"><samp class="SANS_TheSansMonoCd_W5Regular_11">2.03% Purchase..ctor</samp></p>
</td>
<td class="table TB">
<p class="TB"><samp class="SANS_TheSansMonoCd_W5Regular_11">20</samp></p>
</td>
<td class="table TB">
<p class="TB"><samp class="SANS_TheSansMonoCd_W5Regular_11">Purchase..ctor(Product, DateTime, Int32)</samp></p>
</td>
</tr>
<tr class="table">
<td class="table TBL">
<p class="TB-1"><samp class="SANS_TheSansMonoCd_W5Regular_11">1.41% Product..ctor</samp></p>
</td>
<td class="table TBL">
<p class="TB"><samp class="SANS_TheSansMonoCd_W5Regular_11">14</samp></p>
</td>
<td class="table TBL">
<p class="TB"><samp class="SANS_TheSansMonoCd_W5Regular_11">Product..ctor(Int32, Decimal, String)</samp></p>
</td>
</tr>
</tbody>
</table>
</figure>
<p class="TX">While the nested constructor for the <samp class="SANS_TheSansMonoCd_W5Regular_11">Product</samp> type increases the time taken to create <samp class="SANS_TheSansMonoCd_W5Regular_11">Purchase</samp> objects, the majority of the time is spent within the implementation of <samp class="SANS_TheSansMonoCd_W5Regular_11">MakePurchase</samp>, suggesting that initializing the instances and copying them around is the costlier factor. In particular, creating a new <samp class="SANS_TheSansMonoCd_W5Regular_11">Product</samp> and then copying the instance to the <samp class="SANS_TheSansMonoCd_W5Regular_11">Purchase</samp> constructor is one copy we can avoid by making <samp class="SANS_TheSansMonoCd_W5Regular_11">Product</samp> a reference type.</p>
<section aria-labelledby="sec20" epub:type="division">
<h4 class="H3" id="sec20"><samp class="SANS_Futura_Std_Bold_Condensed_B_11">Reference Type Performance</samp></h4>
<p class="TNI">When we copy a reference variable, the object instance isn’t copied at all, making the copy inexpensive. Here we make <samp class="SANS_TheSansMonoCd_W5Regular_11">Product</samp> a sealed record instead of a read-only record struct:</p>
<pre><code>public sealed record Product&#13;
    (int Id, decimal Price, string Name);</code></pre>
<p class="TX">Records using this positional syntax are immutable reference types by default. For the <samp class="SANS_TheSansMonoCd_W5Regular_11">Product</samp> type, the compiler inserts <samp class="SANS_TheSansMonoCd_W5Regular_11">init</samp>-only properties for the <samp class="SANS_TheSansMonoCd_W5Regular_11">Id</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">Price</samp>, and <samp class="SANS_TheSansMonoCd_W5Regular_11">Name</samp> properties, meaning that one instance can be safely and efficiently referenced by several containing objects. Since none of the properties has a <samp class="SANS_TheSansMonoCd_W5Regular_11">set</samp> accessor, there’s no risk of inadvertent changes being made via aliasing references. More pertinently for our test, once the <samp class="SANS_TheSansMonoCd_W5Regular_11">Product</samp> instance is created, only the reference to it needs to be passed to the <samp class="SANS_TheSansMonoCd_W5Regular_11">Purchase</samp> constructor.</p>
<p class="TX">For this test, we leave the <samp class="SANS_TheSansMonoCd_W5Regular_11">Purchase</samp> type as a record struct, since we’re trying to avoid having to copy its nested <samp class="SANS_TheSansMonoCd_W5Regular_11">Product</samp>. However, using a reference type for <samp class="SANS_TheSansMonoCd_W5Regular_11">Product</samp> introduces other overhead, as we can see in the profiler report in <a href="#tab8-16">Table 8-16</a> for creating 10 million <samp class="SANS_TheSansMonoCd_W5Regular_11">Purchase</samp> objects.</p>
<figure class="table">
<table class="table">
<caption>
<p class="TT" id="tab8-16"><span class="Heavy"><samp class="SANS_Futura_Std_Heavy_B_11">Table 8-16:</samp></span> <samp class="SANS_Futura_Std_Book_11">Performance Report for Creating Reference Type Values</samp></p>
</caption>
<thead>
<tr class="table">
<th class="table TCH" scope="col">
<p class="TCH"><samp class="SANS_Futura_Std_Heavy_B_11">Method</samp></p>
</th>
<th class="table TCH" scope="col">
<p class="TCH"><samp class="SANS_Futura_Std_Heavy_B_11">Time (ms)</samp></p>
</th>
<th class="table TCH" scope="col">
<p class="TCH"><samp class="SANS_Futura_Std_Heavy_B_11">Signature</samp></p>
</th>
</tr>
</thead>
<tbody>
<tr class="table">
<td class="table TBF">
<p class="TB"><samp class="SANS_TheSansMonoCd_W5Regular_11">77.8% MakePurchase</samp></p>
</td>
<td class="table TBF">
<p class="TB"><samp class="SANS_TheSansMonoCd_W5Regular_11">1,409</samp></p>
</td>
<td class="table TBF">
<p class="TB"><samp class="SANS_TheSansMonoCd_W5Regular_11">MakePurchase(Int32)</samp></p>
</td>
</tr>
<tr class="table">
<td class="table TB">
<p class="TB-1"><samp class="SANS_TheSansMonoCd_W7Bold_B_11">34.9% [Garbage collection]</samp></p>
</td>
<td class="table TB">
<p class="TB"><samp class="SANS_TheSansMonoCd_W7Bold_B_11">632</samp></p>
</td>
<td class="table TB"/>
</tr>
<tr class="table">
<td class="table TB">
<p class="TB-1"><samp class="SANS_TheSansMonoCd_W5Regular_11">0.33% Product..ctor</samp></p>
</td>
<td class="table TB">
<p class="TB"><samp class="SANS_TheSansMonoCd_W5Regular_11">6.0</samp></p>
</td>
<td class="table TB">
<p class="TB"><samp class="SANS_TheSansMonoCd_W5Regular_11">Product..ctor(Int32, Decimal, String)</samp></p>
</td>
</tr>
<tr class="table">
<td class="table TBL">
<p class="TB-1"><samp class="SANS_TheSansMonoCd_W5Regular_11">0.33% Purchase..ctor</samp></p>
</td>
<td class="table TBL">
<p class="TB"><samp class="SANS_TheSansMonoCd_W5Regular_11">6.0</samp></p>
</td>
<td class="table TBL">
<p class="TB"><samp class="SANS_TheSansMonoCd_W5Regular_11">Purchase..ctor(Product, DateTime, Int32)</samp></p>
</td>
</tr>
</tbody>
</table>
</figure>
<p class="TX"><span aria-label=" Page 275. " epub:type="pagebreak" id="pg_275" role="doc-pagebreak"/>The <samp class="SANS_TheSansMonoCd_W5Regular_11">MakePurchase</samp> method is significantly slower than in <a href="#tab8-15">Table 8-15</a>, with the main culprit being garbage collection. Changing <samp class="SANS_TheSansMonoCd_W5Regular_11">Product</samp> to be a record rather than a record struct has put considerable pressure on the garbage collector, which takes time even if it can’t collect any objects.</p>
<p class="TX">The lesson here is that the common advice to use value types for objects that are short-lived is at least partly related to memory pressure and the cost of garbage collection. Value type instances, because they aren’t allocated on the heap, don’t incur those costs. Copying even huge object instances isn’t always the most significant expense, so changing large value types to be reference types to avoid copying can, as in this example, have a detrimental effect on a program’s overall performance.</p>
<p class="TX">We have other factors to consider. If, for instance, we expect many of the <samp class="SANS_TheSansMonoCd_W5Regular_11">Purchase</samp> objects in an application to have identical <samp class="SANS_TheSansMonoCd_W5Regular_11">Product</samp> values, we may benefit considerably by having all those <samp class="SANS_TheSansMonoCd_W5Regular_11">Purchase</samp> instances sharing the same <samp class="SANS_TheSansMonoCd_W5Regular_11">Product</samp> instance, making a reference type implementation much more attractive.</p>
</section>
<section aria-labelledby="sec21" epub:type="division">
<h4 class="H3" id="sec21"><samp class="SANS_Futura_Std_Bold_Condensed_B_11">Benefits of Reference Equality</samp></h4>
<p class="TNI">The <samp class="SANS_TheSansMonoCd_W5Regular_11">MakePurchase</samp> method from <a href="#list8-19">Listing 8-19</a> that we’ve been using to create <samp class="SANS_TheSansMonoCd_W5Regular_11">Purchase</samp> instances creates a new <samp class="SANS_TheSansMonoCd_W5Regular_11">Product</samp> object for each <samp class="SANS_TheSansMonoCd_W5Regular_11">Purchase</samp> object. In <a href="#list8-20">Listing 8-20</a>, we change <samp class="SANS_TheSansMonoCd_W5Regular_11">MakePurchase</samp> so that rather than creating a new <samp class="SANS_TheSansMonoCd_W5Regular_11">Product</samp> each time, we assign one of a small number of shared <samp class="SANS_TheSansMonoCd_W5Regular_11">Product</samp> instances to each new <samp class="SANS_TheSansMonoCd_W5Regular_11">Purchase</samp>. Since <samp class="SANS_TheSansMonoCd_W5Regular_11">Product</samp> is a record and therefore a reference type, each <samp class="SANS_TheSansMonoCd_W5Regular_11">Product</samp> will be shared by many <samp class="SANS_TheSansMonoCd_W5Regular_11">Purchase</samp> objects.</p>
<pre id="list8-20"><code>private static readonly List&lt;Product&gt; SharedProducts = new()&#13;
{&#13;
    new Product(0, 0, "Some Description"),&#13;
    new Product(1, 1, "Some Description"),&#13;
    new Product(2, 2, "Some Description"),&#13;
    new Product(3, 3, "Some Description"),&#13;
    new Product(4, 4, "Some Description"),&#13;
};&#13;
private static Purchase MakePurchase(int id)&#13;
{&#13;
    <b>var component</b> <b>=</b> <b>SharedProducts[id % SharedProducts.Count];</b>&#13;
    return new Purchase(component, DateTime.MinValue, id);&#13;
}</code></pre>
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 8-20: Sharing references among objects</samp></p>
<p class="TX">We initialize a short list of <samp class="SANS_TheSansMonoCd_W5Regular_11">Product</samp> instances before creating any <samp class="SANS_TheSansMonoCd_W5Regular_11">Purchase</samp> objects. A <samp class="SANS_TheSansMonoCd_W5Regular_11">Product</samp> reference is selected from this list according to the <samp class="SANS_TheSansMonoCd_W5Regular_11">id</samp> value used to create a <samp class="SANS_TheSansMonoCd_W5Regular_11">Purchase</samp>. Now that the <samp class="SANS_TheSansMonoCd_W5Regular_11">MakePurchase</samp> method isn’t creating any new <samp class="SANS_TheSansMonoCd_W5Regular_11">Product</samp> instances, we’d expect it to run much more quickly, which the report in <a href="#tab8-17">Table 8-17</a> confirms.</p>
<figure class="table">
<table class="table">
<caption>
<p class="TT" id="tab8-17"><span aria-label=" Page 276. " epub:type="pagebreak" id="pg_276" role="doc-pagebreak"/><span class="Heavy"><samp class="SANS_Futura_Std_Heavy_B_11">Table 8-17:</samp></span> <samp class="SANS_Futura_Std_Book_11">Assigning Preallocated</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">Product</samp> <samp class="SANS_Futura_Std_Book_11">Objects</samp></p>
</caption>
<thead>
<tr class="table">
<th class="table TCH" scope="col">
<p class="TCH"><samp class="SANS_Futura_Std_Heavy_B_11">Method</samp></p>
</th>
<th class="table TCH" scope="col">
<p class="TCH"><samp class="SANS_Futura_Std_Heavy_B_11">Time (ms)</samp></p>
</th>
<th class="table TCH" scope="col">
<p class="TCH"><samp class="SANS_Futura_Std_Heavy_B_11">Signature</samp></p>
</th>
</tr>
</thead>
<tbody>
<tr class="table">
<td class="table TBF">
<p class="TB"><samp class="SANS_TheSansMonoCd_W5Regular_11">17.1% MakePurchase</samp></p>
</td>
<td class="table TBF">
<p class="TB"><samp class="SANS_TheSansMonoCd_W5Regular_11">86</samp></p>
</td>
<td class="table TBF">
<p class="TB"><samp class="SANS_TheSansMonoCd_W5Regular_11">MakePurchase(Int32)</samp></p>
</td>
</tr>
<tr class="table">
<td class="table TB">
<p class="TB-1"><samp class="SANS_TheSansMonoCd_W5Regular_11">2.38% Purchase..ctor</samp></p>
</td>
<td class="table TB">
<p class="TB"><samp class="SANS_TheSansMonoCd_W5Regular_11">12</samp></p>
</td>
<td class="table TB">
<p class="TB"><samp class="SANS_TheSansMonoCd_W5Regular_11">Purchase..ctor(Product, DateTime, Int32)</samp></p>
</td>
</tr>
<tr class="table">
<td class="table TBL">
<p class="TB-1"><samp class="SANS_TheSansMonoCd_W5Regular_11">1.18% get_Item</samp></p>
</td>
<td class="table TBL">
<p class="TB"><samp class="SANS_TheSansMonoCd_W5Regular_11">5.9</samp></p>
</td>
<td class="table TBL">
<p class="TB"><samp class="SANS_TheSansMonoCd_W5Regular_11">System.Collections.Generic.List`1 .get_Item(Int32)</samp></p>
</td>
</tr>
</tbody>
</table>
</figure>
<p class="TX">More significantly, comparing <samp class="SANS_TheSansMonoCd_W5Regular_11">Purchase</samp> instances for equality will now be much faster because so many of them share a <samp class="SANS_TheSansMonoCd_W5Regular_11">Product</samp> instance. The implementation of <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp> for record types includes the simple optimization of starting with an identity comparison of the two references. When two <samp class="SANS_TheSansMonoCd_W5Regular_11">Product</samp> variables that are being compared both refer to the same instance in memory, there’s no need to continue checking the individual fields, since they must be identical. <a href="#tab8-18">Table 8-18</a> shows the report for comparing sequence elements for 10 million <samp class="SANS_TheSansMonoCd_W5Regular_11">Purchase</samp> objects.</p>
<figure class="table">
<table class="table">
<caption>
<p class="TT" id="tab8-18"><span class="Heavy"><samp class="SANS_Futura_Std_Heavy_B_11">Table 8-18:</samp></span> <samp class="SANS_Futura_Std_Book_11">Comparing Sequences with Shared References</samp></p>
</caption>
<thead>
<tr class="table">
<th class="table TCH" scope="col">
<p class="TCH"><samp class="SANS_Futura_Std_Heavy_B_11">Method</samp></p>
</th>
<th class="table TCH" scope="col">
<p class="TCH"><samp class="SANS_Futura_Std_Heavy_B_11">Time (ms)</samp></p>
</th>
<th class="table TCH" scope="col">
<p class="TCH"><samp class="SANS_Futura_Std_Heavy_B_11">Signature</samp></p>
</th>
</tr>
</thead>
<tbody>
<tr class="table">
<td class="table TBF">
<p class="TB"><samp class="SANS_TheSansMonoCd_W5Regular_11">68.3% SequenceEqual</samp></p>
</td>
<td class="table TBF">
<p class="TB"><samp class="SANS_TheSansMonoCd_W5Regular_11">350</samp></p>
</td>
<td class="table TBF">
<p class="TB"><samp class="SANS_TheSansMonoCd_W5Regular_11">System.Linq.Enumerable .SequenceEqual(IEnumerable, IEnumerable)</samp></p>
</td>
</tr>
<tr class="table">
<td class="table TB">
<p class="TB-1"><samp class="SANS_TheSansMonoCd_W5Regular_11">27.1% Equals</samp></p>
</td>
<td class="table TB">
<p class="TB"><samp class="SANS_TheSansMonoCd_W5Regular_11">139</samp></p>
</td>
<td class="table TB">
<p class="TB"><samp class="SANS_TheSansMonoCd_W5Regular_11">Purchase.Equals(Purchase)</samp></p>
</td>
</tr>
<tr class="table">
<td class="table TB">
<p class="TB-2"><samp class="SANS_TheSansMonoCd_W5Regular_11">11.7% get_Default</samp></p>
</td>
<td class="table TB">
<p class="TB"><samp class="SANS_TheSansMonoCd_W5Regular_11">60</samp></p>
</td>
<td class="table TB">
<p class="TB"><samp class="SANS_TheSansMonoCd_W5Regular_11">System.Collections.Generic .EqualityComparer`1.get_Default()</samp></p>
</td>
</tr>
<tr class="table">
<td class="table TB">
<p class="TB-2"><samp class="SANS_TheSansMonoCd_W5Regular_11">9.36% Equals</samp></p>
</td>
<td class="table TB">
<p class="TB"><samp class="SANS_TheSansMonoCd_W5Regular_11">48</samp></p>
</td>
<td class="table TB">
<p class="TB"><samp class="SANS_TheSansMonoCd_W5Regular_11">System.Collections.Generic .GenericEqualityComparer`1.Equals(T, T)</samp></p>
</td>
</tr>
<tr class="table">
<td class="table TBL">
<p class="TB-1"><samp class="SANS_TheSansMonoCd_W5Regular_11">3.52% Equals</samp></p>
</td>
<td class="table TBL">
<p class="TB"><samp class="SANS_TheSansMonoCd_W5Regular_11">18</samp></p>
</td>
<td class="table TBL">
<p class="TB"><samp class="SANS_TheSansMonoCd_W5Regular_11">Product.Equals(Product)</samp></p>
</td>
</tr>
</tbody>
</table>
</figure>
<p class="TX">If we run the same test by using a record struct for <samp class="SANS_TheSansMonoCd_W5Regular_11">Product</samp>—that is, assigning one of a few precreated instances of <samp class="SANS_TheSansMonoCd_W5Regular_11">Product</samp> to each <samp class="SANS_TheSansMonoCd_W5Regular_11">Purchase</samp>—we can compare the performance of sharing references versus copying each <samp class="SANS_TheSansMonoCd_W5Regular_11">Product</samp>. <a href="#tab8-19">Table 8-19</a> shows the report for <samp class="SANS_TheSansMonoCd_W5Regular_11">SequenceEqual</samp> for 10 million <samp class="SANS_TheSansMonoCd_W5Regular_11">Purchase</samp> objects when <samp class="SANS_TheSansMonoCd_W5Regular_11">Product</samp> is a record struct.</p>
<figure class="table">
<table class="table">
<caption>
<p class="TT" id="tab8-19"><span class="Heavy"><samp class="SANS_Futura_Std_Heavy_B_11">Table 8-19:</samp></span> <samp class="SANS_Futura_Std_Book_11">Comparing Sequences with Copied Instances</samp></p>
</caption>
<thead>
<tr class="table">
<th class="table TCH" scope="col">
<p class="TCH"><samp class="SANS_Futura_Std_Heavy_B_11">Method</samp></p>
</th>
<th class="table TCH" scope="col">
<p class="TCH"><samp class="SANS_Futura_Std_Heavy_B_11">Time (ms)</samp></p>
</th>
<th class="table TCH" scope="col">
<p class="TCH"><samp class="SANS_Futura_Std_Heavy_B_11">Signature</samp></p>
</th>
</tr>
</thead>
<tbody>
<tr class="table">
<td class="table TBF">
<p class="TB"><samp class="SANS_TheSansMonoCd_W5Regular_11">59.5% SequenceEqual</samp></p>
</td>
<td class="table TBF">
<p class="TB"><samp class="SANS_TheSansMonoCd_W5Regular_11">591</samp></p>
</td>
<td class="table TBF">
<p class="TB"><samp class="SANS_TheSansMonoCd_W5Regular_11">System.Linq.Enumerable .SequenceEqual(IEnumerable, IEnumerable)</samp></p>
</td>
</tr>
<tr class="table">
<td class="table TB">
<p class="TB-1"><samp class="SANS_TheSansMonoCd_W5Regular_11">13.3% Equals</samp></p>
</td>
<td class="table TB">
<p class="TB"><samp class="SANS_TheSansMonoCd_W5Regular_11">132</samp></p>
</td>
<td class="table TB">
<p class="TB"><samp class="SANS_TheSansMonoCd_W5Regular_11">Purchase.Equals(Purchase)</samp></p>
</td>
</tr>
<tr class="table">
<td class="table TB">
<p class="TB-2"><samp class="SANS_TheSansMonoCd_W5Regular_11">12.7% Equals</samp></p>
</td>
<td class="table TB">
<p class="TB"><samp class="SANS_TheSansMonoCd_W5Regular_11">126</samp></p>
</td>
<td class="table TB">
<p class="TB"><samp class="SANS_TheSansMonoCd_W5Regular_11">System.Collections.Generic .GenericEqualityComparer`1.Equals(T, T)</samp></p>
</td>
</tr>
<tr class="table">
<td class="table TB">
<p class="TB-3"><samp class="SANS_TheSansMonoCd_W5Regular_11">9.01% Equals</samp></p>
</td>
<td class="table TB">
<p class="TB"><samp class="SANS_TheSansMonoCd_W5Regular_11">89</samp></p>
</td>
<td class="table TB">
<p class="TB"><samp class="SANS_TheSansMonoCd_W5Regular_11">Product.Equals(Product)</samp></p>
</td>
</tr>
<tr class="table">
<td class="table TB">
<p class="TB-3"><samp class="SANS_TheSansMonoCd_W5Regular_11">1.22% Equals</samp></p>
</td>
<td class="table TB">
<p class="TB"><samp class="SANS_TheSansMonoCd_W5Regular_11">12</samp></p>
</td>
<td class="table TB">
<p class="TB"><samp class="SANS_TheSansMonoCd_W5Regular_11">System.DateTime.Equals(DateTime)</samp></p>
</td>
</tr>
<tr class="table">
<td class="table TBL">
<p class="TB-2"><samp class="SANS_TheSansMonoCd_W5Regular_11">0.60% get_Default</samp></p>
</td>
<td class="table TBL">
<p class="TB"><samp class="SANS_TheSansMonoCd_W5Regular_11">6.0</samp></p>
</td>
<td class="table TBL">
<p class="TB"><samp class="SANS_TheSansMonoCd_W5Regular_11">System.Collections.Generic .EqualityComparer`1.get_Default()</samp></p>
</td>
</tr>
</tbody>
</table>
</figure>
<p class="TX"><span aria-label=" Page 277. " epub:type="pagebreak" id="pg_277" role="doc-pagebreak"/>Although the headline time for the <samp class="SANS_TheSansMonoCd_W5Regular_11">Purchase.Equals</samp> method is almost identical in each case, the <samp class="SANS_TheSansMonoCd_W5Regular_11">SequenceEqual</samp> method using the record struct in <a href="#tab8-19">Table 8-19</a> is considerably slower than for the record in <a href="#tab8-18">Table 8-18</a>. Record structs can’t take advantage of the simple reference identity optimization available to records, although many of the calls to <samp class="SANS_TheSansMonoCd_W5Regular_11">Product.Equals</samp> will have been inlined by the JIT compiler. The result is that we see the extra cost of having to copy the record struct values and compare their fields in <samp class="SANS_TheSansMonoCd_W5Regular_11">SequenceEqual</samp>, rather than <samp class="SANS_TheSansMonoCd_W5Regular_11">Purchase.Equals</samp>.</p>
</section>
</section>
<section aria-labelledby="sec22" epub:type="division">
<h3 class="H2" id="sec22"><span id="h-196"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Measuring the Compiler-Generated Equals Method</samp></h3>
<p class="TNI">The positional record struct syntax used in <a href="#list8-18">Listing 8-18</a> for the <samp class="SANS_TheSansMonoCd_W5Regular_11">Purchase</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">Product</samp> types makes their definition compact, but that comes with minor, although measurable, efficiency compromises. The type-safe <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp> method implementing the <samp class="SANS_TheSansMonoCd_W5Regular_11">IEquatable&lt; T &gt;</samp> interface for records and record structs is generated by the compiler, whether or not they use the positional syntax. While convenient, that’s not necessarily the most efficient implementation. When we’re working with many objects, it can be worth our while to write our own <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp> method for record and record struct types, in which case the compiler won’t generate one for us.</p>
<p class="TX">You saw in <span class="Xref"><a href="chapter5.xhtml">Chapter 5</a></span> that the compiler inserts code to obtain the default <samp class="SANS_TheSansMonoCd_W5Regular_11">EqualityComparer</samp> object for each field. For example, <a href="#list8-21">Listing 8-21</a> shows roughly the <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp> method created by the compiler for the <samp class="SANS_TheSansMonoCd_W5Regular_11">Purchase</samp> record struct in <a href="#list8-18">Listing 8-18</a>.</p>
<pre id="list8-21"><code>public bool Equals(Purchase other)&#13;
    =&gt; EqualityComparer&lt;Product&gt;.Default.Equals(_Item_field, other._Item_field) &amp;&amp;&#13;
       EqualityComparer&lt;DateTime&gt;.Default.Equals(_Ordered_field, other._Ordered_field) &amp;&amp;&#13;
       EqualityComparer&lt;int&gt;.Default.Equals(_Quantity_field, other._Quantity_field);</code></pre>
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 8-21: A record struct’s Equals method</samp></p>
<p class="TX">The real names of the backing fields assigned by the compiler are invalid in regular C#, so there’s no chance they could clash with any of our own identifiers; the names used here merely illustrate the idea. Despite using the backing fields directly rather than accessing the properties to perform the comparisons, obtaining the default <samp class="SANS_TheSansMonoCd_W5Regular_11">EqualityComparer</samp> implementation for each field on <i>every call</i> to <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp> could impair efficiency. <a href="#tab8-20">Table 8-20</a> shows the profiler output when using the <samp class="SANS_TheSansMonoCd_W5Regular_11">SequenceEqual</samp> method to compare two lists of 10 million <samp class="SANS_TheSansMonoCd_W5Regular_11">Purchase</samp> record struct objects.</p>
<figure class="table">
<table class="table">
<caption>
<p class="TT" id="tab8-20"><span aria-label=" Page 278. " epub:type="pagebreak" id="pg_278" role="doc-pagebreak"/><span class="Heavy"><samp class="SANS_Futura_Std_Heavy_B_11">Table 8-20:</samp></span> <samp class="SANS_Futura_Std_Book_11">Comparing Sequences with Record Struct Instances</samp></p>
</caption>
<thead>
<tr class="table">
<th class="table TCH" scope="col">
<p class="TCH"><samp class="SANS_Futura_Std_Heavy_B_11">Method</samp></p>
</th>
<th class="table TCH" scope="col">
<p class="TCH"><samp class="SANS_Futura_Std_Heavy_B_11">Time (ms)</samp></p>
</th>
<th class="table TCH" scope="col">
<p class="TCH"><samp class="SANS_Futura_Std_Heavy_B_11">Signature</samp></p>
</th>
</tr>
</thead>
<tbody>
<tr class="table">
<td class="table TBF">
<p class="TB"><samp class="SANS_TheSansMonoCd_W5Regular_11">55.7% SequenceEqual</samp></p>
</td>
<td class="table TBF">
<p class="TB"><samp class="SANS_TheSansMonoCd_W5Regular_11">558</samp></p>
</td>
<td class="table TBF">
<p class="TB"><samp class="SANS_TheSansMonoCd_W5Regular_11">System.Linq.Enumerable .SequenceEqual(IEnumerable, IEnumerable)</samp></p>
</td>
</tr>
<tr class="table">
<td class="table TB">
<p class="TB"><samp class="SANS_TheSansMonoCd_W5Regular_11">13.7% Equals</samp></p>
</td>
<td class="table TB">
<p class="TB"><samp class="SANS_TheSansMonoCd_W5Regular_11">138</samp></p>
</td>
<td class="table TB">
<p class="TB"><samp class="SANS_TheSansMonoCd_W5Regular_11">Purchase.Equals(Purchase)</samp></p>
</td>
</tr>
<tr class="table">
<td class="table TB">
<p class="TB-1"><samp class="SANS_TheSansMonoCd_W5Regular_11">10.2% Equals</samp></p>
</td>
<td class="table TB">
<p class="TB"><samp class="SANS_TheSansMonoCd_W5Regular_11">102</samp></p>
</td>
<td class="table TB">
<p class="TB"><samp class="SANS_TheSansMonoCd_W5Regular_11">System.Collections.Generic .GenericEqualityComparer`1.Equals(T, T)</samp></p>
</td>
</tr>
<tr class="table">
<td class="table TB">
<p class="TB-3"><samp class="SANS_TheSansMonoCd_W5Regular_11">3.58% Equals</samp></p>
</td>
<td class="table TB">
<p class="TB"><samp class="SANS_TheSansMonoCd_W5Regular_11">36</samp></p>
</td>
<td class="table TB">
<p class="TB"><samp class="SANS_TheSansMonoCd_W5Regular_11">Product.Equals(Product)</samp></p>
</td>
</tr>
<tr class="table">
<td class="table TB">
<p class="TB-2"><samp class="SANS_TheSansMonoCd_W5Regular_11">1.80% Equals</samp></p>
</td>
<td class="table TB">
<p class="TB"><samp class="SANS_TheSansMonoCd_W5Regular_11">18</samp></p>
</td>
<td class="table TB">
<p class="TB"><samp class="SANS_TheSansMonoCd_W5Regular_11">System.Decimal.Equals(Decimal)</samp></p>
</td>
</tr>
<tr class="table">
<td class="table TB">
<p class="TB-2"><samp class="SANS_TheSansMonoCd_W5Regular_11">0.60% Equals</samp></p>
</td>
<td class="table TB">
<p class="TB"><samp class="SANS_TheSansMonoCd_W5Regular_11">6.0</samp></p>
</td>
<td class="table TB">
<p class="TB"><samp class="SANS_TheSansMonoCd_W5Regular_11">System.Int32.Equals(Int32)</samp></p>
</td>
</tr>
<tr class="table">
<td class="table TBL">
<p class="TB-1"><samp class="SANS_TheSansMonoCd_W5Regular_11">0.60% get_Default</samp></p>
</td>
<td class="table TBL">
<p class="TB"><samp class="SANS_TheSansMonoCd_W5Regular_11">6.0</samp></p>
</td>
<td class="table TBL">
<p class="TB"><samp class="SANS_TheSansMonoCd_W5Regular_11">System.Collections.Generic .EqualityComparer`1.get_Default()</samp></p>
</td>
</tr>
</tbody>
</table>
</figure>
<p class="TX">While the JIT compiler may inline some or all of the uses of the <samp class="SANS_TheSansMonoCd_W5Regular_11">EqualityComparer&lt; T</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">&gt;</samp><samp class="SANS_TheSansMonoCd_W5Regular_11">.Default</samp> property and the calls to its <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp> method, there’s no guarantee that it will be able to do so. As we did earlier when replacing property accesses with fields, we can define our own <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp> method to directly compare the values without needing to use <samp class="SANS_TheSansMonoCd_W5Regular_11">EqualityComparer&lt; T &gt;</samp>. However, we can’t access the compiler-generated backing fields for the properties generated for a positional record struct. Instead, in <a href="#list8-22">Listing 8-22</a> we use a simple record struct for <samp class="SANS_TheSansMonoCd_W5Regular_11">Purchase</samp>, where we define our own private fields and a constructor to initialize them.</p>
<pre id="list8-22"><code>public readonly record struct Purchase&#13;
{&#13;
    public Purchase(Product item, DateTime ordered, int quantity)&#13;
        =&gt; (this.item, this.ordered, this.quantity) =&#13;
              (item, ordered, quantity);&#13;
    <var>--snip--</var>&#13;
    public bool Equals(Purchase other)&#13;
        =&gt; item.Equals(other.item) &amp;&amp;&#13;
           ordered.Equals(other.ordered) &amp;&amp; quantity == other.quantity;&#13;
    private readonly Product item;&#13;
    private readonly DateTime ordered;&#13;
    private readonly int quantity;&#13;
}</code></pre>
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 8-22: Constructing a private field for the Purchase struct</samp></p>
<p class="TX">We also add our own implementation of <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp> to directly compare the fields we’ve defined. This custom <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp> replaces the implementation that the compiler would have introduced had we not defined our own. We’d also need to add properties to expose the field values, although neither that nor the <samp class="SANS_TheSansMonoCd_W5Regular_11">Product</samp> type, which changes in a similar way, is shown here. Rerunning the code to compare two sequences of 10 million <samp class="SANS_TheSansMonoCd_W5Regular_11">Purchase</samp> items produces the report shown in <a href="#tab8-21">Table 8-21</a>.</p>
<figure class="table">
<table class="table">
<caption>
<p class="TT" id="tab8-21"><span aria-label=" Page 279. " epub:type="pagebreak" id="pg_279" role="doc-pagebreak"/><span class="Heavy"><samp class="SANS_Futura_Std_Heavy_B_11">Table 8-21:</samp></span> <samp class="SANS_Futura_Std_Book_11">A Comparison Using Customized</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp></p>
</caption>
<thead>
<tr class="table">
<th class="table TCH" scope="col">
<p class="TCH"><samp class="SANS_Futura_Std_Heavy_B_11">Method</samp></p>
</th>
<th class="table TCH" scope="col">
<p class="TCH"><samp class="SANS_Futura_Std_Heavy_B_11">Time (ms)</samp></p>
</th>
<th class="table TCH" scope="col">
<p class="TCH"><samp class="SANS_Futura_Std_Heavy_B_11">Signature</samp></p>
</th>
</tr>
</thead>
<tbody>
<tr class="table">
<td class="table TBF">
<p class="TB"><samp class="SANS_TheSansMonoCd_W5Regular_11">100% SequenceEqual</samp></p>
</td>
<td class="table TBF">
<p class="TB"><samp class="SANS_TheSansMonoCd_W5Regular_11">440</samp></p>
</td>
<td class="table TBF">
<p class="TB"><samp class="SANS_TheSansMonoCd_W5Regular_11">System.Linq.Enumerable .SequenceEqual(IEnumerable, IEnumerable)</samp></p>
</td>
</tr>
<tr class="table">
<td class="table TB">
<p class="TB-1"><samp class="SANS_TheSansMonoCd_W5Regular_11">12.3% Equals</samp></p>
</td>
<td class="table TB">
<p class="TB"><samp class="SANS_TheSansMonoCd_W5Regular_11">54</samp></p>
</td>
<td class="table TB">
<p class="TB"><samp class="SANS_TheSansMonoCd_W5Regular_11">Purchase.Equals(Purchase)</samp></p>
</td>
</tr>
<tr class="table">
<td class="table TB">
<p class="TB-2"><samp class="SANS_TheSansMonoCd_W5Regular_11">8.18% Equals</samp></p>
</td>
<td class="table TB">
<p class="TB"><samp class="SANS_TheSansMonoCd_W5Regular_11">36</samp></p>
</td>
<td class="table TB">
<p class="TB"><samp class="SANS_TheSansMonoCd_W5Regular_11">Product.Equals(Product)</samp></p>
</td>
</tr>
<tr class="table">
<td class="table TBL">
<p class="TB-2"><samp class="SANS_TheSansMonoCd_W5Regular_11">1.36% Equals</samp></p>
</td>
<td class="table TBL">
<p class="TB"><samp class="SANS_TheSansMonoCd_W5Regular_11">6.0</samp></p>
</td>
<td class="table TBL">
<p class="TB"><samp class="SANS_TheSansMonoCd_W5Regular_11">System.DateTime.Equals(DateTime)</samp></p>
</td>
</tr>
</tbody>
</table>
</figure>
<p class="TX">By providing our own <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp> method, we’ve improved the performance of <samp class="SANS_TheSansMonoCd_W5Regular_11">SequenceEqual</samp> by around 20 percent compared with the results in <a href="#tab8-20">Table 8-20</a>, partly because our implementation may be giving the JIT compiler more effective opportunities for inlining code. Comparing larger sequences produces similar results, so if we’re particularly sensitive to performance and frequently compare many items, this kind of optimization may be beneficial.</p>
<p class="TX">The performance improvement we see here occurs primarily because <samp class="SANS_TheSansMonoCd_W5Regular_11">Purchase</samp> is a relatively complex type. A much simpler positional record struct—for example, one with a single <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp> field—most likely wouldn’t benefit from the optimizations we made in <samp class="SANS_TheSansMonoCd_W5Regular_11">Purchase</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">Product</samp>. The principal benefit of the positional record syntax is its simplicity, which makes it clear to any reader what the type represents. We sacrificed that simplicity for a small gain in raw performance, an improvement that was visible only with the help of a profiler. This example highlights the importance of measuring performance before trying to hand-optimize our code by second-guessing the compiler.</p>
</section>
</section>
<section aria-labelledby="sec23" epub:type="division">
<h2 class="H1" id="sec23"><span id="h-197"/><samp class="SANS_Futura_Std_Bold_B_11">How Common Idioms and Practices Affect Performance</samp></h2>
<p class="TNI">Some common practices in C# draw undue criticism regarding performance. It’s natural and common to believe that a higher level of abstraction in source code comes with a cost in performance, and that’s true to some extent: C# is a <i>high-level</i> programming language, and our programs are ultimately translated to native machine code over multiple steps. We could handcraft our own machine code to perform the same task, but C# code is more portable, more easily maintained, considerably less error-prone, and much easier to read and write than machine code. Those benefits usually far outweigh any cost in performance.</p>
<p class="TX">It’s not, however, universally true that high-level code results in performance penalties. In this section, we’ll investigate looping and pattern matching, two common C# features that enable us to succinctly express complex ideas in C# while providing performance comparable or even superior to their lower-level counterparts.</p>
<section aria-labelledby="sec24" epub:type="division">
<h3 class="H2" id="sec24"><span id="h-198"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Looping and Iteration</samp></h3>
<p class="TNI">In this chapter, we’ve used LINQ in its <i>fluent syntax</i> form several times for the purposes of creating sequences of objects. LINQ, which has been part of C# for many years, will be recognizable to most programmers with more than <span aria-label=" Page 280. " epub:type="pagebreak" id="pg_280" role="doc-pagebreak"/>a passing familiarity for the language and its idioms. <a href="#list8-23">Listing 8-23</a> shows an example of using the fluent syntax to create a list of <samp class="SANS_TheSansMonoCd_W5Regular_11">Purchase</samp> objects.</p>
<pre id="list8-23"><code>private static Purchase MakePurchase(int id)&#13;
    =&gt; new Purchase(new Product(id, id, "Some Description"),&#13;
        DateTime.MinValue, id);&#13;
var items = Enumerable.Range(0, count)&#13;
    .Select(i =&gt; MakePurchase(i))&#13;
    .ToList();</code></pre>
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 8-23: LINQ fluent syntax</samp></p>
<p class="TX">LINQ has an alternative <i>query syntax</i> that some C# programmers find more agreeable. <a href="#list8-24">Listing 8-24</a> shows the equivalent query syntax for creating the <samp class="SANS_TheSansMonoCd_W5Regular_11">items</samp> sequence in <a href="#list8-23">Listing 8-23</a>.</p>
<pre id="list8-24"><code>var query = from i in Enumerable.Range(0, count)&#13;
            select MakePurchase(i);&#13;
var items = query.ToList();</code></pre>
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 8-24: LINQ query syntax</samp></p>
<p class="TX">The compiler generates identical CIL for both <a href="#list8-23">Listings 8-23</a> and <a href="#list8-24">8-24</a>, so the choice between them is primarily driven by which we find clearer to read. One optimization is possible, although it can be applied only to the fluent version: avoiding the lambda as an argument to the <samp class="SANS_TheSansMonoCd_W5Regular_11">Select</samp> method. That lambda needs to capture the <samp class="SANS_TheSansMonoCd_W5Regular_11">i</samp> variable so the compiler will generate a closure object, which results in an extra level of indirection to call the <samp class="SANS_TheSansMonoCd_W5Regular_11">MakePurchase</samp> method. To avoid the closure, we can instead pass <samp class="SANS_TheSansMonoCd_W5Regular_11">MakePurchase</samp> as a method group argument, as shown in <a href="#list8-25">Listing 8-25</a>.</p>
<pre id="list8-25"><code>var items = Enumerable.Range(0, count)&#13;
    .Select(MakePurchase)&#13;
    .ToList();</code></pre>
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 8-25: Optimizing LINQ by using a method group</samp></p>
<p class="TX">To compare the efficiency of each approach, first we profile the version from <a href="#list8-23">Listing 8-23</a>, which uses a lambda. <a href="#tab8-22">Table 8-22</a> shows the report for creating a list of 10 million items.</p>
<figure class="table">
<table class="table">
<caption>
<p class="TT" id="tab8-22"><span class="Heavy"><samp class="SANS_Futura_Std_Heavy_B_11">Table 8-22:</samp></span> <samp class="SANS_Futura_Std_Book_11">Performance of Creating a Sequence Using LINQ with a Lambda</samp></p>
</caption>
<thead>
<tr class="table">
<th class="table TCH" scope="col">
<p class="TCH"><samp class="SANS_Futura_Std_Heavy_B_11">Method</samp></p>
</th>
<th class="table TCH" scope="col">
<p class="TCH"><samp class="SANS_Futura_Std_Heavy_B_11">Time (ms)</samp></p>
</th>
<th class="table TCH" scope="col">
<p class="TCH"><samp class="SANS_Futura_Std_Heavy_B_11">Signature</samp></p>
</th>
</tr>
</thead>
<tbody>
<tr class="table">
<td class="table TBF">
<p class="TB"><samp class="SANS_TheSansMonoCd_W5Regular_11">98.1% ToList</samp></p>
</td>
<td class="table TBF">
<p class="TB"><samp class="SANS_TheSansMonoCd_W5Regular_11">415</samp></p>
</td>
<td class="table TBF">
<p class="TB"><samp class="SANS_TheSansMonoCd_W5Regular_11">System.Linq.Enumerable .ToList(IEnumerable)</samp></p>
</td>
</tr>
<tr class="table">
<td class="table TB">
<p class="TB-1"><samp class="SANS_TheSansMonoCd_W5Regular_11">36.0% MakePurchase</samp></p>
</td>
<td class="table TB">
<p class="TB"><samp class="SANS_TheSansMonoCd_W5Regular_11">152</samp></p>
</td>
<td class="table TB">
<p class="TB"><samp class="SANS_TheSansMonoCd_W5Regular_11">MakePurchase(Int32)</samp></p>
</td>
</tr>
<tr class="table">
<td class="table TB">
<p class="TB-1"><samp class="SANS_TheSansMonoCd_W7Bold_B_11">31.3%</samp> <samp class="SANS_TheSansMonoCd_W7Bold_B_11">&lt; Closure&gt;b__3_0</samp></p>
</td>
<td class="table TB">
<p class="TB"><samp class="SANS_TheSansMonoCd_W7Bold_B_11">132</samp></p>
</td>
<td class="table TB">
<p class="TB"><samp class="SANS_TheSansMonoCd_W7Bold_B_11">&lt;&gt;c.&lt; Closure&gt;b__3_0(Int32)</samp></p>
</td>
</tr>
<tr class="table">
<td class="table TBL">
<p class="TB-2"><samp class="SANS_TheSansMonoCd_W5Regular_11">31.3% MakePurchase</samp></p>
</td>
<td class="table TBL">
<p class="TB"><samp class="SANS_TheSansMonoCd_W5Regular_11">132</samp></p>
</td>
<td class="table TBL">
<p class="TB"><samp class="SANS_TheSansMonoCd_W5Regular_11">MakePurchase(Int32)</samp></p>
</td>
</tr>
</tbody>
</table>
</figure>
<p class="TX"><span aria-label=" Page 281. " epub:type="pagebreak" id="pg_281" role="doc-pagebreak"/>The identifier name <samp class="SANS_TheSansMonoCd_W5Regular_11">&lt;&gt; c</samp> is the closure object the compiler generates to capture the <samp class="SANS_TheSansMonoCd_W5Regular_11">i</samp> variable, and one example of the compiler introducing names that would be illegal in our own code. The closure has an instance method, <samp class="SANS_TheSansMonoCd_W5Regular_11">&lt; Closure&gt;b__3_0</samp>, which in turn calls our <samp class="SANS_TheSansMonoCd_W5Regular_11">MakePurchase</samp> method. The <samp class="SANS_TheSansMonoCd_W5Regular_11">MakePurchase</samp> method makes two appearances in this report—both inside and outside the closure method—as a result of the JIT compiler inlining some calls to the <samp class="SANS_TheSansMonoCd_W5Regular_11">&lt; Closure&gt;b__3_0</samp> method and calling <samp class="SANS_TheSansMonoCd_W5Regular_11">MakePurchase</samp> directly.</p>
<p class="TX">The report in <a href="#tab8-23">Table 8-23</a> shows the performance when using the method group approach to create 10 million items.</p>
<figure class="table">
<table class="table1">
<caption>
<p class="TT" id="tab8-23"><span class="Heavy"><samp class="SANS_Futura_Std_Heavy_B_11">Table 8-23:</samp></span> <samp class="SANS_Futura_Std_Book_11">Performance of Creating a Sequence Using LINQ with a Method Group</samp></p>
</caption>
<thead>
<tr class="table">
<th class="table TCH" scope="col">
<p class="TCH"><samp class="SANS_Futura_Std_Heavy_B_11">Method</samp></p>
</th>
<th class="table TCH" scope="col">
<p class="TCH"><samp class="SANS_Futura_Std_Heavy_B_11">Time (ms)</samp></p>
</th>
<th class="table TCH" scope="col">
<p class="TCH"><samp class="SANS_Futura_Std_Heavy_B_11">Signature</samp></p>
</th>
</tr>
</thead>
<tbody>
<tr class="table">
<td class="table TBF">
<p class="TB"><samp class="SANS_TheSansMonoCd_W5Regular_11">100% ToList</samp></p>
</td>
<td class="table TBF">
<p class="TB"><samp class="SANS_TheSansMonoCd_W5Regular_11">430</samp></p>
</td>
<td class="table TBF">
<p class="TB"><samp class="SANS_TheSansMonoCd_W5Regular_11">System.Linq.Enumerable.ToList(IEnumerable)</samp></p>
</td>
</tr>
<tr class="table">
<td class="table TBL">
<p class="TB-1"><samp class="SANS_TheSansMonoCd_W5Regular_11">71.9% MakePurchase</samp></p>
</td>
<td class="table TBL">
<p class="TB"><samp class="SANS_TheSansMonoCd_W5Regular_11">309</samp></p>
</td>
<td class="table TBL">
<p class="TB"><samp class="SANS_TheSansMonoCd_W5Regular_11">MakePurchase(Int32)</samp></p>
</td>
</tr>
</tbody>
</table>
</figure>
<p class="TX">Somewhat counterintuitively, the version with the closure object was just slightly faster than that with the method group. We shouldn’t read too much into that, as the difference is well within the margin for error when comparing runs. However, it does tell us that no matter the absolute difference, using a lambda carries no significant performance penalty.</p>
<p class="TX">The closure object representing the lambda is created only once for the whole expression, not for every element produced for the <samp class="SANS_TheSansMonoCd_W5Regular_11">Select</samp> method. Even though the closure object represents an extra level of indirection for each call to <samp class="SANS_TheSansMonoCd_W5Regular_11">MakePurchase</samp>, the JIT compiler inlines many of the calls to the closure’s <samp class="SANS_TheSansMonoCd_W5Regular_11">&lt; Closure&gt;b__3_0</samp> method and either calls <samp class="SANS_TheSansMonoCd_W5Regular_11">MakePurchase</samp> directly or inlines its contents too.</p>
<p class="TX">We could create a similar sequence in a few other ways. Let’s investigate two common approaches to see how their performance compares with using LINQ.</p>
<section aria-labelledby="sec25" epub:type="division">
<h4 class="H3" id="sec25"><samp class="SANS_Futura_Std_Bold_Condensed_B_11">The Iterator Approach</samp></h4>
<p class="TNI"><i>Iterators</i> are a fundamental part of C# and underpin other higher-level features, including LINQ. In fact, LINQ has become so ubiquitous in modern C# that it can be easy to forget that it’s based on two system interfaces: the <samp class="SANS_TheSansMonoCd_W5Regular_11">IEnumerable&lt; T &gt;</samp> interface, which is an abstract view of a sequence of elements of type <samp class="SANS_TheSansMonoCd_W5Regular_11">T</samp>, and the <samp class="SANS_TheSansMonoCd_W5Regular_11">IEnumerator&lt; T &gt;</samp> interface, which represents an iterator that can get each element of an <samp class="SANS_TheSansMonoCd_W5Regular_11">IEnumerable&lt; T &gt;</samp> one at a time. The basic mechanics are that the <samp class="SANS_TheSansMonoCd_W5Regular_11">IEnumerable&lt; T &gt;</samp> interface has a single method named <samp class="SANS_TheSansMonoCd_W5Regular_11">GetEnumerator</samp> that returns an implementation of <samp class="SANS_TheSansMonoCd_W5Regular_11">IEnumerator&lt; T &gt;</samp>.</p>
<p class="TX">Both interfaces are largely hidden in modern code, although <samp class="SANS_TheSansMonoCd_W5Regular_11">IEnumerable&lt; T &gt;</samp> remains important as the protocol for types that represent sequences and as the home of the extension methods, such as <samp class="SANS_TheSansMonoCd_W5Regular_11">Select</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">Where</samp>, that make up most of the LINQ system.</p>
<p class="TX">The <samp class="SANS_TheSansMonoCd_W5Regular_11">IEnumerator&lt; T &gt;</samp> interface also forms the basis for the <samp class="SANS_TheSansMonoCd_W5Regular_11">foreach</samp> loop, which is one way of enumerating the elements of a sequence that <span aria-label=" Page 282. " epub:type="pagebreak" id="pg_282" role="doc-pagebreak"/>implements <samp class="SANS_TheSansMonoCd_W5Regular_11">IEnumerable&lt; T &gt;</samp>. In <a href="#list8-26">Listing 8-26</a>, we write our own simple <samp class="SANS_TheSansMonoCd_W5Regular_11">ToList</samp> method, which allows us to record its performance for comparison with the LINQ equivalents. Our <samp class="SANS_TheSansMonoCd_W5Regular_11">ToList</samp> uses <samp class="SANS_TheSansMonoCd_W5Regular_11">foreach</samp> to populate a list of <samp class="SANS_TheSansMonoCd_W5Regular_11">Purchase</samp> objects and therefore depends on the iterator provided by the <samp class="SANS_TheSansMonoCd_W5Regular_11">Enumerable.Range</samp> method.</p>
<pre id="list8-26"><code>public static List&lt;Purchase&gt; ToList(int count)&#13;
{&#13;
    var items = new List&lt;Purchase&gt;();&#13;
    foreach(var i in Enumerable.Range(0, count))&#13;
    {&#13;
        items.Add(MakePurchase(i));&#13;
    }&#13;
    return items;&#13;
}</code></pre>
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 8-26: Populating a list using foreach</samp></p>
<p class="TX">Comparing our <samp class="SANS_TheSansMonoCd_W5Regular_11">ToList</samp> method with the LINQ version in <a href="#list8-23">Listing 8-23</a>, the first thing to notice is that we need to declare the target list of <samp class="SANS_TheSansMonoCd_W5Regular_11">Purchase</samp> objects before the loop. The <samp class="SANS_TheSansMonoCd_W5Regular_11">foreach</samp> loop obtains an <samp class="SANS_TheSansMonoCd_W5Regular_11">IEnumerator&lt; int&gt;</samp> from <samp class="SANS_TheSansMonoCd_W5Regular_11">Enumerable.Range</samp>, and the body of the <samp class="SANS_TheSansMonoCd_W5Regular_11">foreach</samp> block is run for each element in the iterator. We can see the basic mechanics when we look at the profiler’s report for the <samp class="SANS_TheSansMonoCd_W5Regular_11">ToList</samp> method in <a href="#tab8-24">Table 8-24</a>.</p>
<figure class="table">
<table class="table">
<caption>
<p class="TT" id="tab8-24"><span class="Heavy"><samp class="SANS_Futura_Std_Heavy_B_11">Table 8-24:</samp></span> <samp class="SANS_Futura_Std_Book_11">Profiling the Iterator Approach</samp></p>
</caption>
<thead>
<tr class="table">
<th class="table TCH" scope="col">
<p class="TCH"><samp class="SANS_Futura_Std_Heavy_B_11">Method</samp></p>
</th>
<th class="table TCH" scope="col">
<p class="TCH"><samp class="SANS_Futura_Std_Heavy_B_11">Time (ms)</samp></p>
</th>
<th class="table TCH" scope="col">
<p class="TCH"><samp class="SANS_Futura_Std_Heavy_B_11">Signature</samp></p>
</th>
</tr>
</thead>
<tbody>
<tr class="table">
<td class="table TBF">
<p class="TB"><samp class="SANS_TheSansMonoCd_W5Regular_11">100% ToList</samp></p>
</td>
<td class="table TBF">
<p class="TB"><samp class="SANS_TheSansMonoCd_W5Regular_11">638</samp></p>
</td>
<td class="table TBF">
<p class="TB"><samp class="SANS_TheSansMonoCd_W5Regular_11">ToList(Int32)</samp></p>
</td>
</tr>
<tr class="table">
<td class="table TB">
<p class="TB-1"><samp class="SANS_TheSansMonoCd_W5Regular_11">41.2% AddWithResize</samp></p>
</td>
<td class="table TB">
<p class="TB"><samp class="SANS_TheSansMonoCd_W5Regular_11">263</samp></p>
</td>
<td class="table TB">
<p class="TB"><samp class="SANS_TheSansMonoCd_W5Regular_11">System.Collections.Generic.List`1 .AddWithResize(T)</samp></p>
</td>
</tr>
<tr class="table">
<td class="table TB">
<p class="TB-1"><samp class="SANS_TheSansMonoCd_W5Regular_11">38.1% MakePurchase</samp></p>
</td>
<td class="table TB">
<p class="TB"><samp class="SANS_TheSansMonoCd_W5Regular_11">243</samp></p>
</td>
<td class="table TB">
<p class="TB"><samp class="SANS_TheSansMonoCd_W5Regular_11">MakePurchase(Int32)</samp></p>
</td>
</tr>
<tr class="table">
<td class="table TB">
<p class="TB-1"><samp class="SANS_TheSansMonoCd_W5Regular_11">0.95% MoveNext</samp></p>
</td>
<td class="table TB">
<p class="TB"><samp class="SANS_TheSansMonoCd_W5Regular_11">6.1</samp></p>
</td>
<td class="table TB">
<p class="TB"><samp class="SANS_TheSansMonoCd_W5Regular_11">System.Linq.Enumerable+RangeIterator .MoveNext()</samp></p>
</td>
</tr>
<tr class="table">
<td class="table TBL">
<p class="TB-1"><samp class="SANS_TheSansMonoCd_W5Regular_11">0.95% get_Current</samp></p>
</td>
<td class="table TBL">
<p class="TB"><samp class="SANS_TheSansMonoCd_W5Regular_11">6.0</samp></p>
</td>
<td class="table TBL">
<p class="TB"><samp class="SANS_TheSansMonoCd_W5Regular_11">System.Linq.Enumerable+Iterator`1 .get_Current()</samp></p>
</td>
</tr>
</tbody>
</table>
</figure>
<p class="TX">This profile report shows the workings of the <samp class="SANS_TheSansMonoCd_W5Regular_11">foreach</samp> construct; the <samp class="SANS_TheSansMonoCd_W5Regular_11">get_Current</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">MoveNext</samp> methods belong to the <samp class="SANS_TheSansMonoCd_W5Regular_11">IEnumerator&lt; T &gt;</samp> interface and, as their names suggest, allow us to obtain the current element and move the iterator to the next item in the sequence.</p>
<p class="TX">This report also shows that our handcrafted <samp class="SANS_TheSansMonoCd_W5Regular_11">ToList</samp> is considerably slower than the LINQ version reported in <a href="#tab8-22">Table 8-22</a>, but we haven’t made optimal use of the <samp class="SANS_TheSansMonoCd_W5Regular_11">List&lt; Purchase&gt;</samp> facilities. Since we know in advance the number of items we need, we can avoid most of the expense of the <samp class="SANS_TheSansMonoCd_W5Regular_11">AddWithResize</samp> method and specify the list’s capacity in the constructor call like this:</p>
<pre><code>var items = new List&lt;Purchase&gt;(count);</code></pre>
<p class="TX"><span aria-label=" Page 283. " epub:type="pagebreak" id="pg_283" role="doc-pagebreak"/>By explicitly requesting a capacity, we allocate enough memory for <samp class="SANS_TheSansMonoCd_W5Regular_11">count</samp> items before adding new elements so that the list won’t need resizing when it runs out of space. If we rerun our profile test, as <a href="#tab8-25">Table 8-25</a> shows, it’s much more in line with the previous tests.</p>
<figure class="table">
<table class="table">
<caption>
<p class="TT" id="tab8-25"><span class="Heavy"><samp class="SANS_Futura_Std_Heavy_B_11">Table 8-25:</samp></span> <samp class="SANS_Futura_Std_Book_11">Preallocating a List’s Capacity</samp></p>
</caption>
<thead>
<tr class="table">
<th class="table TCH" scope="col">
<p class="TCH"><samp class="SANS_Futura_Std_Heavy_B_11">Method</samp></p>
</th>
<th class="table TCH" scope="col">
<p class="TCH"><samp class="SANS_Futura_Std_Heavy_B_11">Time (ms)</samp></p>
</th>
<th class="table TCH" scope="col">
<p class="TCH"><samp class="SANS_Futura_Std_Heavy_B_11">Signature</samp></p>
</th>
</tr>
</thead>
<tbody>
<tr class="table">
<td class="table TBF">
<p class="TB"><samp class="SANS_TheSansMonoCd_W5Regular_11">100% ToList</samp></p>
</td>
<td class="table TBF">
<p class="TB"><samp class="SANS_TheSansMonoCd_W5Regular_11">426</samp></p>
</td>
<td class="table TBF">
<p class="TB"><samp class="SANS_TheSansMonoCd_W5Regular_11">ToList(Int32)</samp></p>
</td>
</tr>
<tr class="table">
<td class="table TB">
<p class="TB-1"><samp class="SANS_TheSansMonoCd_W5Regular_11">63.0% MakePurchase</samp></p>
</td>
<td class="table TB">
<p class="TB"><samp class="SANS_TheSansMonoCd_W5Regular_11">268</samp></p>
</td>
<td class="table TB">
<p class="TB"><samp class="SANS_TheSansMonoCd_W5Regular_11">MakePurchase(Int32)</samp></p>
</td>
</tr>
<tr class="table">
<td class="table TB">
<p class="TB-1"><samp class="SANS_TheSansMonoCd_W5Regular_11">4.28% MoveNext</samp></p>
</td>
<td class="table TB">
<p class="TB"><samp class="SANS_TheSansMonoCd_W5Regular_11">18</samp></p>
</td>
<td class="table TB">
<p class="TB"><samp class="SANS_TheSansMonoCd_W5Regular_11">System.Linq.Enumerable+RangeIterator .MoveNext()</samp></p>
</td>
</tr>
<tr class="table">
<td class="table TBL">
<p class="TB-1"><samp class="SANS_TheSansMonoCd_W5Regular_11">1.41% get_Current</samp></p>
</td>
<td class="table TBL">
<p class="TB"><samp class="SANS_TheSansMonoCd_W5Regular_11">6.0</samp></p>
</td>
<td class="table TBL">
<p class="TB"><samp class="SANS_TheSansMonoCd_W5Regular_11">System.Linq.Enumerable+Iterator`1 .get_Current()</samp></p>
</td>
</tr>
</tbody>
</table>
</figure>
<p class="TX">Our tests demonstrate that using LINQ, at least for the reasonably simple task of generating a sequence of elements, is at least as efficient as using the <samp class="SANS_TheSansMonoCd_W5Regular_11">foreach</samp> loop. We can try one other approach, however: the <samp class="SANS_TheSansMonoCd_W5Regular_11">for</samp> loop.</p>
</section>
<section aria-labelledby="sec26" epub:type="division">
<h4 class="H3" id="sec26"><samp class="SANS_Futura_Std_Bold_Condensed_B_11">The Loop Approach</samp></h4>
<p class="TNI">Our method of creating a list of <samp class="SANS_TheSansMonoCd_W5Regular_11">Purchase</samp> objects is based on creating a sequence of <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp> values and translating them with the <samp class="SANS_TheSansMonoCd_W5Regular_11">Select</samp> method into a new sequence of <samp class="SANS_TheSansMonoCd_W5Regular_11">Purchase</samp> objects. <a href="#list8-27">Listing 8-27</a> shows how we achieve the same result with a basic <samp class="SANS_TheSansMonoCd_W5Regular_11">for</samp> loop, which doesn’t rely on iterators and merely runs the body of the loop the number of times specified in the loop condition.</p>
<pre id="list8-27"><code>public static List&lt;Purchase&gt; ToList(int count)&#13;
{&#13;
    var items = new List&lt;Purchase&gt;(count);&#13;
    for(int i = 0; i != count; ++i)&#13;
    {&#13;
        items.Add(MakePurchase(i));&#13;
    }&#13;
    return items;&#13;
}</code></pre>
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 8-27: Using a simple for loop</samp></p>
<p class="TX">As we did for the <samp class="SANS_TheSansMonoCd_W5Regular_11">foreach</samp> loop, we must create the target <samp class="SANS_TheSansMonoCd_W5Regular_11">List&lt; Purchase&gt;</samp> before entering the loop, and we use the constructor to set its capacity. In the loop’s body, we use the <samp class="SANS_TheSansMonoCd_W5Regular_11">MakePurchase</samp> method to add a new <samp class="SANS_TheSansMonoCd_W5Regular_11">Purchase</samp> as we have previously. <a href="#tab8-26">Table 8-26</a> shows the profiler report for creating a list of 10 million <samp class="SANS_TheSansMonoCd_W5Regular_11">Purchase</samp> objects with the <samp class="SANS_TheSansMonoCd_W5Regular_11">for</samp> loop.</p>
<figure class="table">
<table class="table">
<caption>
<p class="TT" id="tab8-26"><span aria-label=" Page 284. " epub:type="pagebreak" id="pg_284" role="doc-pagebreak"/><span class="Heavy"><samp class="SANS_Futura_Std_Heavy_B_11">Table 8-26:</samp></span> <samp class="SANS_Futura_Std_Book_11">The Direct</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">for</samp> <samp class="SANS_Futura_Std_Book_11">Loop Performance</samp></p>
</caption>
<thead>
<tr class="table">
<th class="table TCH" scope="col">
<p class="TCH"><samp class="SANS_Futura_Std_Heavy_B_11">Method</samp></p>
</th>
<th class="table TCH" scope="col">
<p class="TCH"><samp class="SANS_Futura_Std_Heavy_B_11">Time (ms)</samp></p>
</th>
<th class="table TCH" scope="col">
<p class="TCH"><samp class="SANS_Futura_Std_Heavy_B_11">Signature</samp></p>
</th>
</tr>
</thead>
<tbody>
<tr class="table">
<td class="table TBF">
<p class="TB"><samp class="SANS_TheSansMonoCd_W5Regular_11">100% ToList</samp></p>
</td>
<td class="table TBF">
<p class="TB"><samp class="SANS_TheSansMonoCd_W5Regular_11">417</samp></p>
</td>
<td class="table TBF">
<p class="TB"><samp class="SANS_TheSansMonoCd_W5Regular_11">ToList(Int32)</samp></p>
</td>
</tr>
<tr class="table">
<td class="table TB">
<p class="TB-1"><samp class="SANS_TheSansMonoCd_W5Regular_11">67.3% MakePurchase</samp></p>
</td>
<td class="table TB">
<p class="TB"><samp class="SANS_TheSansMonoCd_W5Regular_11">281</samp></p>
</td>
<td class="table TB">
<p class="TB"><samp class="SANS_TheSansMonoCd_W5Regular_11">MakePurchase(Int32)</samp></p>
</td>
</tr>
<tr class="table">
<td class="table TBL">
<p class="TB-2"><samp class="SANS_TheSansMonoCd_W5Regular_11">5.70% op_Implicit</samp></p>
</td>
<td class="table TBL">
<p class="TB"><samp class="SANS_TheSansMonoCd_W5Regular_11">24</samp></p>
</td>
<td class="table TBL">
<p class="TB"><samp class="SANS_TheSansMonoCd_W5Regular_11">System.Decimal.op_Implicit(Int32)</samp></p>
</td>
</tr>
</tbody>
</table>
</figure>
<p class="TX">Once again, there’s no significant difference between the performance of the <samp class="SANS_TheSansMonoCd_W5Regular_11">for</samp> loop approach and that of the other approaches we’ve tried. The main difference between using LINQ and using either the <samp class="SANS_TheSansMonoCd_W5Regular_11">foreach</samp> or <samp class="SANS_TheSansMonoCd_W5Regular_11">for</samp> loop is one of style: the LINQ code is more direct and allows us to express our intent declaratively, whereas the <samp class="SANS_TheSansMonoCd_W5Regular_11">for</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">foreach</samp> loops are more procedural. The LINQ expression allows us to focus on the outcome we require, whereas both looping approaches focus on the steps or instructions to follow.</p>
</section>
</section>
<section aria-labelledby="sec27" epub:type="division">
<h3 class="H2" id="sec27"><span id="h-199"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Pattern Matching and Selection</samp></h3>
<p class="TNI">One common benefit of a declarative rather than procedural style is that we write less code to achieve the same result. While this saves on the amount of typing we do, that is just a side effect. The real benefit comes from having less syntax for a human reader to comprehend. Replacing explicit loops with LINQ-style functional expressions is one example. Many of the LINQ expressions are based on loops internally, but the loop constructs themselves are hidden from user code. Manually iterating sequences with loops and explicit conditions can be prone to errors, and complex loop constructs are generally harder for a human reader to follow than a call to a method like <samp class="SANS_TheSansMonoCd_W5Regular_11">Select</samp> or <samp class="SANS_TheSansMonoCd_W5Regular_11">ToList</samp>.</p>
<p class="TX">The other common application of declarative techniques is in selection code: replacing <samp class="SANS_TheSansMonoCd_W5Regular_11">if</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">switch</samp> statements with pattern-matching expressions.</p>
<p class="TX">Consider the constructor in <a href="#list8-28">Listing 8-28</a>, which validates the parameter value by matching it against the rules specified by some patterns.</p>
<pre id="list8-28"><code>private const double ZeroKelvin = -273.15;&#13;
private Temperature(double celsius)&#13;
    =&gt; amount = celsius switch&#13;
    {&#13;
        double.NaN&#13;
            =&gt; throw new ArgumentException(<var>--snip--</var>),&#13;
        &lt; ZeroKelvin or double.PositiveInfinity&#13;
            =&gt; throw new ArgumentOutOfRangeException(<var>--snip--</var>),&#13;
        _ =&gt; celsius&#13;
    };</code></pre>
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 8-28: Pattern matching for validation</samp></p>
<p class="TX"><span aria-label=" Page 285. " epub:type="pagebreak" id="pg_285" role="doc-pagebreak"/>The <samp class="SANS_TheSansMonoCd_W5Regular_11">Temperature</samp> constructor throws an exception if the argument given is <samp class="SANS_TheSansMonoCd_W5Regular_11">double.NaN</samp> and also prohibits values that are less than <samp class="SANS_TheSansMonoCd_W5Regular_11">ZeroKelvin</samp> or equal to <samp class="SANS_TheSansMonoCd_W5Regular_11">PositiveInfinity</samp>. Values for the <samp class="SANS_TheSansMonoCd_W5Regular_11">celsius</samp> parameter that don’t match either of those rules are assigned to the <samp class="SANS_TheSansMonoCd_W5Regular_11">amount</samp> field by the discard pattern, which is the final pattern in the <samp class="SANS_TheSansMonoCd_W5Regular_11">switch</samp> expression.</p>
<p class="TX">Compare <a href="#list8-28">Listing 8-28</a> with <a href="#list8-29">Listing 8-29</a>, which achieves exactly the same outcome but uses <samp class="SANS_TheSansMonoCd_W5Regular_11">if…else</samp> statements to test the incoming parameter value.</p>
<pre id="list8-29"><code>private Temperature(double celsius)&#13;
{&#13;
    if(celsius is double.NaN)&#13;
    {&#13;
        throw new ArgumentException(<var>--snip--</var>);&#13;
    }&#13;
    else if(celsius &lt; ZeroKelvin || celsius is double.PositiveInfinity)&#13;
    {&#13;
        throw new ArgumentOutOfRangeException(<var>--snip--</var>);&#13;
    }&#13;
    else&#13;
    {&#13;
        this.amount = celsius;&#13;
    }&#13;
}</code></pre>
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 8-29: Chaining if and else for validation</samp></p>
<p class="TX">We could make this code less syntax-heavy by removing the redundant <samp class="SANS_TheSansMonoCd_W5Regular_11">else</samp> statements and allowing the <samp class="SANS_TheSansMonoCd_W5Regular_11">if</samp> blocks to fall through if the value doesn’t meet the <samp class="SANS_TheSansMonoCd_W5Regular_11">if</samp> condition. While doing so would make the code shorter, it’s more error-prone if new conditions are added.</p>
<p class="TX">Another alternative is to use a <samp class="SANS_TheSansMonoCd_W5Regular_11">switch</samp> statement, as shown in <a href="#list8-30">Listing 8-30</a>.</p>
<pre id="list8-30"><code>switch (celsius)&#13;
{&#13;
    case double.NaN:&#13;
         throw new ArgumentException(<var>--snip--</var>);&#13;
    case &lt; ZeroKelvin:&#13;
    case double.PositiveInfinity:&#13;
         throw new ArgumentOutOfRangeException(<var>--snip--</var>);&#13;
    default:&#13;
         this.amount = celsius;&#13;
         break;&#13;
}</code></pre>
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 8-30: Using a switch statement for validation</samp></p>
<p class="TX">This version is closer to the <samp class="SANS_TheSansMonoCd_W5Regular_11">switch</samp> expression in <a href="#list8-28">Listing 8-28</a>, and the two forms of <samp class="SANS_TheSansMonoCd_W5Regular_11">switch</samp> can be easily confused. The principal difference is that here we assign the <samp class="SANS_TheSansMonoCd_W5Regular_11">amount</samp> field as part of the <samp class="SANS_TheSansMonoCd_W5Regular_11">default</samp> leg, whereas in the <samp class="SANS_TheSansMonoCd_W5Regular_11">switch</samp> expression, the <samp class="SANS_TheSansMonoCd_W5Regular_11">amount</samp> field is assigned the value of the whole expression.</p>
<p class="TX"><span aria-label=" Page 286. " epub:type="pagebreak" id="pg_286" role="doc-pagebreak"/>In a departure from the rest of this chapter, we don’t need to run a performance profile to compare <a href="#list8-28">Listings 8-28</a> through <a href="#list8-30">8-30</a> because the compiler produces almost identical code for each—broadly, the same code as shown in <a href="#list8-29">Listing 8-29</a>. The compiler may change the order of the conditions in the CIL, but that doesn’t change the logic in any way.</p>
</section>
</section>
<section aria-labelledby="sec28" epub:type="division">
<h2 class="H1" id="sec28"><span id="h-200"/><samp class="SANS_Futura_Std_Bold_B_11">Summary</samp></h2>
<blockquote epub:type="epigraph" role="doc-epigraph">
<p class="EP"><i>We do not consider it as good engineering practice to consume a resource lavishly just because it happens to be cheap.</i></p>
<footer class="EPS">—Niklaus Wirth, <i>Project Oberon: The Design of an Operating System, a Compiler, and a Computer</i></footer></blockquote>
<p class="BodyContinued">Code optimized by hand is often harder for a human reader to follow, usually because it frequently involves replacing simple idioms, such as loops and pattern matching, with lower-level constructs. When a program runs more slowly than we think it should, it can be tempting to dive straight in and change the parts of the code we suspect are bottlenecks. Programmers’ optimization instincts are, however, notoriously unreliable. We’re likely to make our code more difficult to read while failing to improve performance in any meaningful way.</p>
<p class="TX">Optimizing code by hand is almost always an exercise in exchanging clarity and simplicity for performance. We can judge whether this is a reasonable trade only by measuring the performance before and after the change. Even when we improve performance in a section of code, we must still decide whether we’ve made the code less clear and, if so, whether the change is justified. We must also be certain that our optimizations haven’t changed the program’s behavior in any way. Slow, correct code is always preferable to incorrect code, however good its performance. That’s not to say that good enough can’t be correct—frequently a compromise is necessary between performance and accuracy or precision—but we need to know the point at which inaccurate really does mean incorrect.</p>
<p class="TX">The use of well-known idioms and patterns helps human readers easily understand code. Correspondingly, when we depart from those common designs, we make our code harder to follow. Therefore, we must be selective in applying optimizations to the areas of code that will bring the greatest benefits.</p>
<p class="TX">Overriding the behavior of <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp> isn’t difficult for the vast majority of types, but it adds an implementation detail that represents extra cognitive overhead for anyone who needs to <i>understand</i> our code.</p>
<p class="TX">Using records to represent value-like types removes much of that added complexity because the compiler generates the correct implementations for us. However, even accepting that default behavior won’t necessarily yield the most efficient code.</p>
<p class="TX">Careful code optimization, supported by evidence from a profiler, can yield better performance in both speed <i>and</i> memory use. Modern computers are fast and usually have more than enough memory, but that doesn’t mean we should waste either resource.</p>
</section>
</section>
</div></body></html>