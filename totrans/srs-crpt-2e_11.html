<html><head></head><body>
<div id="book-content">
<div id="sbo-rt-content"><section epub:type="chapter" role="doc-chapter" aria-labelledby="ch8">&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_157" aria-label="157"/>&#13;
<hgroup>&#13;
<h2 class="CHAPTER" id="ch8">&#13;
<span class="CN"><samp class="SANS_Futura_Std_Bold_Condensed_B_11">8</samp></span>&#13;
<span class="CT"><samp class="SANS_Dogma_OT_Bold_B_11">AUTHENTICATED ENCRYPTION</samp></span>&#13;
</h2>&#13;
</hgroup>&#13;
<figure class="opener"><img class="opener" src="../images/opener.jpg" alt="" width="401" height="386"/></figure>&#13;
<p class="TNI1">This chapter is about a type of algorithm that protects not only a message’s confidentiality but also its authenticity. Recall from <span class="chapterintro_Xref"><a href="chapter7.xhtml">Chapter 7</a></span> that message authentication codes (MACs) protect a message’s authenticity by creating a tag, which is a kind of signature. Like MACs, the authenticated encryption (AE) algorithms in this chapter produce an authentication tag, but they also encrypt the message. In other words, a single AE algorithm offers the features of both a normal cipher and a MAC.</p>&#13;
<p class="TX">Combining a cipher and a MAC can achieve varying levels of authenticated encryption, as you’ll learn throughout this chapter. We’ll review several ways to combine MACs with ciphers, discuss which methods are the most secure, and explore ciphers that produce both a ciphertext and an authentication tag. We’ll then look at four important authenticated <span role="doc-pagebreak" epub:type="pagebreak" id="pg_158" aria-label="158"/>ciphers: three block cipher–based constructions, with a focus on the popular Advanced Encryption Standard in Galois Counter Mode (AES-GCM), and a cipher that uses only a permutation algorithm.</p>&#13;
<section epub:type="division" aria-labelledby="sec1">&#13;
<h3 class="H1" id="sec1"><span id="h1-54"/><samp class="SANS_Futura_Std_Bold_B_11">Authenticated Encryption Using MACs</samp></h3>&#13;
<p class="TNI"><a href="chapter8.xhtml#fig8-1">Figure 8-1</a> shows three ways that MACs and ciphers can be combined to both encrypt and authenticate a plaintext: encrypt-and-MAC, MAC-then-encrypt, and encrypt-then-MAC.</p>&#13;
<figure class="IMG"><img id="fig8-1" class="img7" src="../images/fig8-1.jpg" alt="" width="1029" height="501"/>&#13;
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 8-1: Cipher and MAC combinations</samp></p></figcaption>&#13;
</figure>&#13;
<p class="TX">These combinations differ in the order in which you apply encryption and generate the authentication tag. The choice of a specific MAC or cipher algorithm is unimportant as long as each is secure in its own right and the MAC and cipher use distinct keys.</p>&#13;
<p class="TX">In the encrypt-and-MAC composition, the plaintext is encrypted and an authentication tag is generated directly from the plaintext, such that the two operations (encryption and authentication) are independent of each other and you can therefore compute them in parallel. In the MAC-then-encrypt scheme, you generate the tag from the plaintext first and then encrypt the plaintext and MAC together. In the encrypt-then-MAC method, you encrypt the plaintext first and then generate the tag from the ciphertext. Let’s see which method is likely to be the most secure.</p>&#13;
<section epub:type="division" aria-labelledby="sec2">&#13;
<h4 class="H2" id="sec2"><span id="h2-99"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Encrypt-and-MAC Approach</samp></h4>&#13;
<p class="TNI">The <i>encrypt-and-MAC</i> approach computes a ciphertext and a MAC tag separately. Given a plaintext <i>P</i>, the sender computes a ciphertext <i>C</i> = <b>E</b>(<i>K</i><sub>1</sub>, <i>P</i>), where <b>E</b> is an encryption algorithm and <i>C</i> is the resulting ciphertext. You calculate the authentication tag <i>T</i> from the plaintext as <i>T</i> = <b>MAC</b>(<i>K</i><sub>2</sub>, <i>P</i>). The two operations are independent and can therefore be computed in parallel.</p>&#13;
<p class="TX">Once you’ve generated the ciphertext and authentication tag, the sender transmits both to the intended recipient. When the recipient receives <i>C</i> and <i>T</i>, they decrypt <i>C</i> to obtain the plaintext <i>P</i> by computing <i>P</i> = <b>D</b>(<i>K</i><sub>1</sub>, <i>C</i>). Next, they compute <b>MAC</b>(<i>K</i><sub>2</sub>, <i>P</i>) using the decrypted plaintext and compare the <span role="doc-pagebreak" epub:type="pagebreak" id="pg_159" aria-label="159"/>result to the <i>T</i> received. This verification fails if either <i>C</i> or <i>T</i> was corrupted, and the message is deemed invalid.</p>&#13;
<p class="TX">In theory, encrypt-and-MAC is the least secure MAC and cipher composition because even a secure MAC could leak information on <i>P</i>, making <i>P</i> easier to recover. Because the goal of using MACs is simply to make tags unforgeable and because tags aren’t necessarily random looking, the authentication tag (<i>T</i>) of a plaintext (<i>P</i>) could still leak information even though the MAC is considered secure! (If the MAC is a pseudorandom function, the tag won’t leak anything on <i>P</i>.)</p>&#13;
<p class="TX">Still, despite its relative weakness, many systems continue supporting encrypt-and-MAC, including the secure transport layer protocol SSH, wherein each encrypted packet <i>C</i> is followed by the tag <i>T</i> = <b>MAC</b>(<i>K</i>, <i>N</i> || <i>P</i>), where <i>N</i> is a 32-bit sequence number that increments for each packet. In practice, encrypt-and-MAC has proven good enough for use with SSH, thanks to the use of strong MAC algorithms like HMAC-SHA-256 that don’t leak information on <i>P</i>. Enter the following command</p>&#13;
<pre><code>$<b> ssh -Q mac</b></code></pre>&#13;
<p class="Continued">to see the list of MACs supported by the OpenSSH software.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec3">&#13;
<h4 class="H2" id="sec3"><span id="h2-100"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">MAC-Then-Encrypt Composition</samp></h4>&#13;
<p class="TNI">The <i>MAC-then-encrypt</i> composition protects a message, <i>P</i>, by first computing the authentication tag <i>T</i> = <b>MAC</b>(<i>K</i><sub>2</sub>, <i>P</i>). Next, it creates the ciphertext by encrypting the plaintext and tag together, according to <i>C</i> = <b>E</b>(<i>K</i><sub>1</sub>, <i>P</i> || <i>T</i>).</p>&#13;
<p class="TX">Once these steps are complete, the sender transmits only <i>C</i>, which contains both the encrypted plaintext and tag. Upon receipt, the recipient decrypts <i>C</i> by computing <i>P</i> || <i>T</i> = <b>D</b>(<i>K</i><sub>1</sub>, <i>C</i>) to obtain the plaintext and tag <i>T</i>. Next, the recipient verifies the received tag <i>T</i> by computing a tag directly from the plaintext according to <b>MAC</b>(<i>K</i><sub>2</sub>, <i>P</i>) to confirm that the computed tag is equal to the tag <i>T</i>.</p>&#13;
<p class="TX">As with encrypt-and-MAC, when using MAC-then-encrypt, the recipient must decrypt <i>C</i> before determining whether they’re receiving corrupted packets—a process that exposes potentially corrupted plaintexts to the receiver. Nevertheless, MAC-then-encrypt is more secure than encrypt-and-MAC because it hides the plaintext’s authentication tag, thus preventing the tag from leaking information on the plaintext.</p>&#13;
<p class="TX">The TLS protocol has used MAC-then-encrypt for years, but TLS 1.3 replaced MAC-then-encrypt with authenticated ciphers (see <span class="Xref"><a href="chapter13.xhtml">Chapter 13</a></span> for more on TLS 1.3).</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec4">&#13;
<h4 class="H2" id="sec4"><span id="h2-101"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Encrypt-Then-MAC Composition</samp></h4>&#13;
<p class="TNI">The encrypt-then-MAC composition sends two values to the recipient: the ciphertext produced by <i>C</i> = <b>E</b>(<i>K</i><sub>1</sub>, <i>P</i>) and a tag based on the ciphertext, <i>T</i> = <b>MAC</b>(<i>K</i><sub>2</sub>, <i>C</i>). The receiver computes the tag using <b>MAC</b>(<i>K</i><sub>2</sub>, <i>C</i>) and verifies that it equals the <i>T</i> received. If the values are equal, the plaintext is computed as <i>P</i> = <b>D</b>(<i>K</i><sub>1</sub>, <i>C</i>); if they are not equal, the ciphertext is discarded.</p>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_160" aria-label="160"/>One advantage of this method is that the receiver needs to compute a MAC only to detect corrupt messages, meaning that there’s no need to decrypt a corrupt ciphertext. Also, attackers can’t send pairs of <i>C</i> and <i>T</i> to the receiver to decrypt unless they’ve broken the MAC, which makes it harder for attackers to transmit malicious data to the recipient.</p>&#13;
<p class="TX">This combination of features makes encrypt-then-MAC stronger than the encrypt-and-MAC and MAC-then-encrypt approaches. This is one reason why the widely used IPsec secure communications protocol suite uses it to protect packets (for example, within VPN tunnels).</p>&#13;
<p class="TX">Note that SSH and TLS don’t use encrypt-then-MAC because other approaches appeared adequate when SSH and TLS were created—not because theoretical weaknesses didn’t exist but because undesirable properties don’t necessarily become actual vulnerabilities.</p>&#13;
</section>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec5">&#13;
<h3 class="H1" id="sec5"><span id="h1-55"/><samp class="SANS_Futura_Std_Bold_B_11">Authenticated Ciphers</samp></h3>&#13;
<p class="TNI"><i>Authenticated ciphers</i> are an alternative to the cipher and MAC combinations. They’re like normal ciphers except that they return an authentication tag together with the ciphertext.</p>&#13;
<p class="TX">You represent the authenticated cipher encryption as <b>AE</b>(<i>K</i>, <i>P</i>) = (<i>C</i>, <i>T</i>). The term <b>AE</b> stands for <i>authenticated encryption</i>, which is based on a key (<i>K</i>) and a plaintext (<i>P</i>) and returns a ciphertext (<i>C</i>) and a generated authentication tag (<i>T</i>). In other words, a single authenticated cipher algorithm does the same job as a cipher and MAC combination, making it simpler, faster, and often more secure.</p>&#13;
<p class="TX">You represent authenticated cipher decryption by <b>AD</b>(<i>K</i>, <i>C</i>, <i>T</i>) = <i>P</i>. Here, <b>AD</b> stands for <i>authenticated decryption</i>, which returns a plaintext (<i>P</i>) given a ciphertext (<i>C</i>), tag (<i>T</i>), and key (<i>K</i>). If the tag validation fails, <b>AD</b> returns an error to prevent the recipient from processing a plaintext that may have been forged. By the same token, if <b>AD</b> returns a plaintext, it’s been encrypted by someone or something that knows the secret key.</p>&#13;
<p class="TX">The basic security requirements of an authenticated cipher are simple: its authentication should be as strong as a MAC’s, meaning it should be impossible to forge a ciphertext and tag pair (<i>C</i>, <i>T</i>) that the decryption function <b>AD</b> will accept and decrypt.</p>&#13;
<p class="TX">As far as confidentiality is concerned, an authenticated cipher is fundamentally stronger than a basic cipher because systems holding the secret key will decrypt a ciphertext only if the authentication tag is valid. If the tag is invalid, the plaintext is discarded. This characteristic prevents attackers from performing chosen-ciphertext queries, an attack where they create ciphertexts and ask for the corresponding plaintext.</p>&#13;
<section epub:type="division" aria-labelledby="sec6">&#13;
<h4 class="H2" id="sec6"><span id="h2-102"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Authenticated Encryption with Associated Data</samp></h4>&#13;
<p class="TNI">Cryptographers define <i>associated data</i> as any data processed by an authenticated cipher such that the data is authenticated (thanks to the authentication tag) but not encrypted. By default, all plaintext data fed to an authenticated cipher is encrypted <i>and</i> authenticated.</p>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_161" aria-label="161"/>Say you want to authenticate a message, including its unencrypted parts, but not encrypt the entire message—that is, you want to authenticate and transmit data in addition to an encrypted message. For example, if a cipher processes a network packet composed of a header followed by a payload, you might choose to encrypt the payload to hide the actual data transmitted, but not encrypt the header since it contains information required to deliver the packet to its final recipient. At the same time, you might still like to authenticate the header’s data to make sure that it’s received from the expected sender.</p>&#13;
<p class="TX">To accomplish these goals, cryptographers created the notion of <i>authenticated encryption with associated data (AEAD)</i>. An AEAD algorithm allows you to attach cleartext data to a ciphertext in such a way that if the cleartext data is corrupted, the authentication tag won’t validate, and the ciphertext won’t decrypt. Such cleartext data must be encoded and serialized in a secure way to prevent ambiguous interpretation of its content.</p>&#13;
<p class="TX">You can write an AEAD operation as <b>AEAD</b>(<i>K</i>, <i>P</i>, <i>A</i>) = (<i>C</i>, <i>A</i>, <i>T</i>). Given a key (<i>K</i>), plaintext (<i>P</i>), and associated data (<i>A</i>), AEAD returns the ciphertext, the unencrypted associated data <i>A</i>, and an authentication tag. AEAD leaves the unencrypted associated data unchanged, and the ciphertext is the encryption of plaintext. The authentication tag depends on both <i>P</i> and <i>A</i> and will be verified as valid only if neither <i>C</i> nor <i>A</i> has been modified.</p>&#13;
<p class="TX">Because the authenticated tag depends on <i>A</i>, you compute decryption with associated data by <b>ADAD</b>(<i>K</i>, <i>C</i>, <i>A</i>, <i>T</i>) = (<i>P</i>, <i>A</i>). Decryption requires the key, ciphertext, associated data, and tag in order to compute the plaintext and associated data, and it fails if either <i>C</i> or <i>A</i> has been corrupted.</p>&#13;
<p class="TX">When using AEAD, you can leave <i>A</i> or <i>P</i> empty. If the associated data <i>A</i> is empty, AEAD becomes a normal authenticated cipher; if <i>P</i> is empty, it’s just a MAC.</p>&#13;
<blockquote>&#13;
<p class="Note"><span class="NoteHead"><samp class="SANS_Dogma_OT_Bold_B_15">NOTE</samp></span></p>&#13;
</blockquote>&#13;
<p class="NOTE-TXT"><i>As of this writing, AEAD is the current norm for authenticated encryption. Because nearly all authenticated ciphers in use today support associated data, when referring to authenticated ciphers throughout this book, I’m referring to AEAD unless stated otherwise. When discussing AEAD operations of encryption and decryption, I’ll refer to them as</i> <b><i>AE</i></b> <i>and</i> <b><i>AD</i></b><i>, respectively.</i></p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec7">&#13;
<h4 class="H2" id="sec7"><span id="h2-103"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Predictability and Nonces</samp></h4>&#13;
<p class="TNI">Recall from <span class="Xref"><a href="chapter1.xhtml">Chapter 1</a></span> that to be secure, encryption schemes must be unpredictable and return different ciphertexts when called repeatedly to encrypt the same plaintext—otherwise, an attacker can determine whether the same plaintext was encrypted twice. To be unpredictable, block ciphers and stream ciphers feed the cipher an extra parameter: the initial value (IV) or <i>nonce</i>—a number that can be used only once. Authenticated ciphers use the same trick. Thus, you express authenticated encryption as <b>AE</b>(<i>K</i>, <i>P</i>, <i>A</i>, <i>N</i>), where <i>N</i> is a nonce. It’s up to the encryption operation to pick a nonce that has never been used before with the same key.</p>&#13;
<p class="TX">As with block and stream ciphers, decryption with an authenticated cipher requires the nonce used for encryption to perform correctly. You <span role="doc-pagebreak" epub:type="pagebreak" id="pg_162" aria-label="162"/>can thus express decryption as <b>AD</b>(<i>K</i>, <i>C</i>, <i>A</i>, <i>T</i>, <i>N</i>) = (<i>P</i>, <i>A</i>), where <i>N</i> is the nonce used to create <i>C</i> and <i>T</i>.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec8">&#13;
<h4 class="H2" id="sec8"><span id="h2-104"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Criteria for a Good Authenticated Cipher</samp></h4>&#13;
<p class="TNI">Researchers have been struggling since the early 2000s to define what makes a good authenticated cipher, and the answer is still elusive. Because of AEAD’s many inputs that play different roles, it’s harder to define a notion of security than it is for basic ciphers that only encrypt a message. For example, the research article “Nonces Are Noticed: AEAD Revisited,” available at <i><a href="https://eprint.iacr.org/2019/624">https://<wbr/>eprint<wbr/>.iacr<wbr/>.org<wbr/>/2019<wbr/>/624</a></i>, proposed a theoretical framework for nonce-based encryption. Nevertheless, in this section, I’ll summarize the most important criteria to consider when evaluating the security, performance, and functionality of an authenticated cipher.</p>&#13;
<section epub:type="division" aria-labelledby="sec9">&#13;
<h5 class="H3" id="sec9"><samp class="SANS_Futura_Std_Bold_Condensed_B_11">Security</samp></h5>&#13;
<p class="TNI">The most important criteria to measure the strength of an authenticated cipher are its ability to protect the confidentiality of data (that is, the secrecy of the plaintext) and the authenticity and integrity of the communication (as with the MAC’s ability to detect corrupted messages). An authenticated cipher must compete in both leagues: its confidentiality must be as strong as that of the strongest cipher, and its authenticity as strong as that of the best MAC. In other words, if you remove the authentication part in an AEAD, you should get a secure cipher, and if you remove the encryption part, you should get a strong MAC.</p>&#13;
<p class="TX">Another measure of the strength of an authenticated cipher’s security is based on its fragility when faced with repeated nonces. For example, if a nonce is reused, can an attacker decrypt ciphertexts or learn the difference between plaintexts?</p>&#13;
<p class="TX">Researchers call this notion of robustness <i>misuse resistance</i> and have designed misuse-resistant authenticated ciphers to weigh the impact of a repeated nonce and attempt to determine whether confidentiality, authenticity, or both would be compromised in the face of such an attack, as well as what information about the encrypted data would likely leak.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec10">&#13;
<h5 class="H3" id="sec10"><samp class="SANS_Futura_Std_Bold_Condensed_B_11">Performance</samp></h5>&#13;
<p class="TNI">As with every cryptographic algorithm, you measure the throughput of an authenticated cipher in bits processed per second. This speed depends on the number of operations performed by the cipher’s algorithm and on the extra cost of the authentication functionality. The extra security features of authenticated ciphers come with a performance hit. However, the measure of a cipher’s performance isn’t just about pure speed. It’s also about parallelizability, structure, and whether the cipher is streamable. Let’s examine these notions more closely.</p>&#13;
<p class="TX">A cipher’s <i>parallelizability</i> is a measure of its ability to process multiple data blocks simultaneously without waiting for the previous block’s <span role="doc-pagebreak" epub:type="pagebreak" id="pg_163" aria-label="163"/>processing to complete. Block cipher–based designs can be easily parallelizable when each block can be processed independently of the other blocks. For example, the CTR block cipher mode from <span class="Xref"><a href="chapter4.xhtml">Chapter 4</a></span> is parallelizable, whereas the CBC encryption mode is not, because blocks are chained.</p>&#13;
<p class="TX">The internal structure of an authenticated cipher is another important performance criteria. There are two main types of structure: one-layer and two-layer. In a two-layer structure (for example, in the widely used AES-GCM), one algorithm processes the plaintext, and then a second algorithm processes the result. Typically, the first layer is the encryption layer, and the second is the authentication layer. But as you might expect, a two-layer structure complicates implementation and tends to slow down computations.</p>&#13;
<p class="TX">An authenticated cipher is <i>streamable</i> (also called an <i>online</i> cipher) when it can process a message block by block and discard any already-processed blocks. In contrast, nonstreamable ciphers must store the entire message, typically because they need to make two consecutive passes over the data: one from the start to the end and the other from the end to the start of the data obtained from the first pass.</p>&#13;
<p class="TX">Because of potentially high memory requirements, some applications won’t work with nonstreamable ciphers. For example, a router could receive an encrypted block of data, decrypt it, and then return the plaintext block before moving on to decrypt the subsequent block of the message, though the recipient of the decrypted message would still have to verify the authentication tag sent at the end of the decrypted data stream.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec11">&#13;
<h5 class="H3" id="sec11"><samp class="SANS_Futura_Std_Bold_Condensed_B_11">Other Features</samp></h5>&#13;
<p class="TNI">Functional criteria are the features of a cipher or its implementation that don’t directly relate to either security or performance. For example, some authenticated ciphers allow only associated data to precede the data to be encrypted (because they need access to it to start encryption). Others require associated data to follow the data to be encrypted or support the inclusion of associated data anywhere—even between chunks of plaintext. This last case is the best, because it enables users to protect their data in any possible situation, but it’s also the hardest to design securely: more features often bring more complexity and potential vulnerabilities.</p>&#13;
<p class="TX">Another piece of functional criteria to consider relates to whether you can use the same core algorithm for both encryption and decryption. For example, many authenticated ciphers are based on the AES block cipher, which specifies the use of two similar algorithms for encrypting and decrypting a block. As discussed in <span class="Xref"><a href="chapter4.xhtml">Chapter 4</a></span>, the CBC block cipher mode requires both algorithms, but the CTR mode requires only the encryption algorithm. Likewise, authenticated ciphers may not need both algorithms. Although the extra cost of implementing both encryption and decryption algorithms won’t impact most software, it’s often noticeable on low-cost dedicated hardware, where you measure implementation cost in terms of logic gates, or the silicon area occupied by the cryptography.</p>&#13;
</section>&#13;
</section>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec12">&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_164" aria-label="164"/>&#13;
<h3 class="H1" id="sec12"><span id="h1-56"/><samp class="SANS_Futura_Std_Bold_B_11">The AES-GCM Authenticated Cipher Standard</samp></h3>&#13;
<p class="TNI">AES-GCM is the most widely used authenticated cipher. AES-GCM is based on the AES algorithm, and the Galois counter mode (GCM) of operation is essentially a tweak of the CTR mode that incorporates a small and efficient component to compute an authentication tag. As I write this, AES-GCM is a NIST standard (SP 800-38D), is part of NSA’s Suite B, and is recognized by the IETF for the secure network protocols IPsec, SSH, and TLS 1.2 and 1.3.</p>&#13;
<blockquote>&#13;
<p class="Note"><span class="NoteHead"><samp class="SANS_Dogma_OT_Bold_B_15">NOTE</samp></span></p>&#13;
</blockquote>&#13;
<p class="NOTE-TXT"><i>Although GCM works with any block cipher, you’ll probably see it used only with AES.</i></p>&#13;
<section epub:type="division" aria-labelledby="sec13">&#13;
<h4 class="H2" id="sec13"><span id="h2-105"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">GCM Internals</samp></h4>&#13;
<p class="TNI"><a href="chapter8.xhtml#fig8-2">Figure 8-2</a> shows how AES-GCM works: AES instances parameterized by a secret key (<i>K</i>) transform a block composed of the nonce (<i>N</i>) concatenated with a counter (starting here at 1, then incremented to 2, 3, and so on) and then XOR the result with a plaintext block to obtain a ciphertext block. So far, that’s nothing new when compared to the CTR mode.</p>&#13;
<figure class="IMG"><img id="fig8-2" class="img5" src="../images/fig8-2.jpg" alt="" width="546" height="767"/>&#13;
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 8-2: The AES-GCM mode, applied to one associated data block,</samp> <samp class="SANS_Futura_Std_Book_11">A</samp><samp class="SANS_Futura_Std_Book_Oblique_I-SUB_11">1</samp><samp class="SANS_Futura_Std_Book_Oblique_I_11">, and two plaintext blocks,</samp> <samp class="SANS_Futura_Std_Book_11">P</samp><samp class="SANS_Futura_Std_Book_Oblique_I-SUB_11">1</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">and</samp> <samp class="SANS_Futura_Std_Book_11">P</samp><samp class="SANS_Futura_Std_Book_Oblique_I-SUB_11">2</samp><samp class="SANS_Futura_Std_Book_Oblique_I_11">. The circled multiplication sign represents polynomial multipli- cation by</samp> <samp class="SANS_Futura_Std_Book_11">H</samp><samp class="SANS_Futura_Std_Book_Oblique_I_11">, the authentication key derived from</samp> <samp class="SANS_Futura_Std_Book_11">K</samp><samp class="SANS_Futura_Std_Book_Oblique_I_11">.</samp></p></figcaption>&#13;
</figure>&#13;
<p class="TX">The ciphertext blocks are then mixed using a combination of XORs and multiplications (as you’ll see next). You can see AES-GCM as doing (1) an encryption in CTR mode and (2) a MAC over the ciphertext blocks. Therefore, AES-GCM is essentially an encrypt-then-MAC construction, where AES-CTR encrypts using a 128-bit key (<i>K</i>) and a 96-bit nonce (<i>N</i>).</p>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_165" aria-label="165"/>To authenticate the ciphertext, GCM uses a Wegman–Carter MAC (see <span class="Xref"><a href="chapter7.xhtml">Chapter 7</a></span>), which XORs the value <b>AES</b>(<i>K</i>, <i>N</i> || 0) with the output of the universal hash function <i>GHASH</i>. In <a href="chapter8.xhtml#fig8-2">Figure 8-2</a>, GHASH corresponds to the series of operations “<span class="symbol">⊗</span><sub>H</sub>” followed by the XOR with len(<i>A</i>) || len(<i>C</i>), or the bit length of <i>A</i> (the associated data) followed by the bit length of <i>C</i> (the ciphertext).</p>&#13;
<p class="TX">You can thus express the authentication tag’s value as <i>T</i> = <b>GHASH</b> (<i>H</i>, <i>A</i>, <i>C</i>) <span class="symbol">⊕</span> <b>AES</b>(<i>K</i>, <i>N</i> || 0), where <i>H</i> is the <i>hash key</i>, or <i>authentication key</i>. This key is determined as <i>H</i> = <b>AES</b>(<i>K</i>, 0), which is the encryption of the block equal to a sequence of null bytes (I didn’t include this step in <a href="chapter8.xhtml#fig8-2">Figure 8-2</a> for clarity).</p>&#13;
<blockquote>&#13;
<p class="Note"><span class="NoteHead"><samp class="SANS_Dogma_OT_Bold_B_15">NOTE</samp></span></p>&#13;
</blockquote>&#13;
<p class="NOTE-TXT"><i>In GCM, GHASH doesn’t use</i> <span class="note_Italic">K</span> <i>directly in order to ensure that if GHASH’s key is compromised, the master key</i> <span class="note_Italic">K</span> <i>remains secret. Given</i> <span class="note_Italic">K</span><i>, you can get</i> <span class="note_Italic">H</span> <i>by computing</i> <b><i>AES</i></b><i>(</i><span class="note_Italic">K</span><i>, 0), but you can’t recover</i> <span class="note_Italic">K</span> <i>from that value, since</i> <span class="note_Italic">K</span> <i>acts here as AES’s key.</i></p>&#13;
<p class="TX">GHASH uses <i>polynomial notation</i> to multiply each ciphertext block with the authentication key <i>H</i>. This use of polynomial multiplication makes GHASH fast in hardware and software, thanks, to a special polynomial multiplication instruction available in many common microprocessors (<samp class="SANS_TheSansMonoCd_W5Regular_11">CLMUL</samp>, for carry-less multiplication).</p>&#13;
<p class="TX">Alas, GHASH is far from ideal. For one thing, its speed is suboptimal. Even when using the <samp class="SANS_TheSansMonoCd_W5Regular_11">CLMUL</samp> instruction, the AES-CTR layer that encrypts the plaintext remains faster than the GHASH MAC. Second, GHASH is painful to implement correctly. In fact, even the experienced developers of the OpenSSL project, by far the most-used cryptographic piece of software in the world, got AES-GCM’s GHASH wrong. One commit had a bug in a <samp class="SANS_TheSansMonoCd_W5Regular_11">gcm_ghash_clmul</samp> function that allowed attackers to forge valid MACs for the AES-GCM. (Fortunately, Intel engineers spotted the error before the bug entered the next OpenSSL release.)</p>&#13;
<aside class="box" aria-label="box-3">&#13;
<p class="BoxTitle" id="box-3"><samp class="SANS_Dogma_OT_Bold_B_11">POLYNOMIAL MULTIPLICATION</samp></p>&#13;
<p class="BoxFirst"><samp class="SANS_Futura_Std_Book_11">While more complicated than classic integer arithmetic, polynomial multiplication is simpler for computers because there are no carries. Specifically, you can compute</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">modular</samp> <samp class="SANS_Futura_Std_Book_11">multiplication of polynomials, in a structure defined by a given polynomial (such structures are called</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">quotient rings</samp><samp class="SANS_Futura_Std_Book_11">). For example, say you want to compute the product of the polynomials (1 +</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">X</samp> <samp class="SANS_Futura_Std_Book_11">+</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">X</samp><samp class="SANS_Futura_Std_Book_SUP_11">2</samp><samp class="SANS_Futura_Std_Book_11">) and (1 +</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">X</samp><samp class="SANS_Futura_Std_Book_SUP_11">2</samp><samp class="SANS_Futura_Std_Book_11">) modulo (1 +</samp><samp class="SANS_Futura_Std_Book_Oblique_I_11">X</samp> <samp class="SANS_Futura_Std_Book_11">+</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">X</samp><samp class="SANS_Futura_Std_Book_SUP_11">3</samp><samp class="SANS_Futura_Std_Book_11">). You first multiply the two polynomials (1 +</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">X</samp> <samp class="SANS_Futura_Std_Book_11">+</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">X</samp><samp class="SANS_Futura_Std_Book_SUP_11">2</samp><samp class="SANS_Futura_Std_Book_11">) and (1 +</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">X</samp><samp class="SANS_Futura_Std_Book_SUP_11">2</samp><samp class="SANS_Futura_Std_Book_11">) as though you’re doing normal polynomial multiplication, thus giving the following (the two terms</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">X</samp><samp class="SANS_Futura_Std_Book_SUP_11">2</samp> <samp class="SANS_Futura_Std_Book_11">cancel each other out because you work with Boolean polynomials, a world wherein 1 + 1 = 0):</samp></p>&#13;
&#13;
&#13;
<p class="EQ"><samp class="SANS_Futura_Std_Book_11">(1 +</samp><samp class="SANS_Futura_Std_Book_Oblique_I_11">X</samp> <samp class="SANS_Futura_Std_Book_11">+</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">X</samp><samp class="SANS_Futura_Std_Book_SUP_11">2</samp><samp class="SANS_Futura_Std_Book_11">) ⊗ (1 + </samp><samp class="SANS_Futura_Std_Book_Oblique_I_11">X</samp><samp class="SANS_Futura_Std_Book_SUP_11">2</samp><samp class="SANS_Futura_Std_Book_11">) = 1 +</samp><samp class="SANS_Futura_Std_Book_Oblique_I_11">X</samp> <samp class="SANS_Futura_Std_Book_11">+</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">X</samp><samp class="SANS_Futura_Std_Book_SUP_11">3</samp> + <samp class="SANS_Futura_Std_Book_Oblique_I_11">X</samp><samp class="SANS_Futura_Std_Book_SUP_11">4</samp></p>&#13;
<p class="Box"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_166" aria-label="166"/><samp class="SANS_Futura_Std_Book_11">You apply modulo reduction, reducing 1 +</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">X</samp> <samp class="SANS_Futura_Std_Book_11">+</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">X</samp><samp class="SANS_Futura_Std_Book_SUP_11">3</samp> <samp class="SANS_Futura_Std_Book_11">+</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">X</samp><samp class="SANS_Futura_Std_Book_SUP_11">4</samp> <samp class="SANS_Futura_Std_Book_11">modulo 1 +</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">X</samp> <samp class="SANS_Futura_Std_Book_11">+</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">X</samp><samp class="SANS_Futura_Std_Book_SUP_11">3</samp> <samp class="SANS_Futura_Std_Book_11">to give</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">X + X</samp><samp class="SANS_Futura_Std_Book_SUP_11">2</samp><samp class="SANS_Futura_Std_Book_11">, because you can write 1+</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">X</samp> <samp class="SANS_Futura_Std_Book_11">+</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">X</samp><samp class="SANS_Futura_Std_Book_SUP_11">3</samp> <samp class="SANS_Futura_Std_Book_11">+</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">X</samp><samp class="SANS_Futura_Std_Book_SUP_11">4</samp> <samp class="SANS_Futura_Std_Book_11">as (1 +</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">X</samp><samp class="SANS_Futura_Std_Book_11">)</samp> ⊗ <samp class="SANS_Futura_Std_Book_11">(1 +</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">X</samp> <samp class="SANS_Futura_Std_Book_11">+</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">X</samp><samp class="SANS_Futura_Std_Book_SUP_11">3</samp><samp class="SANS_Futura_Std_Book_11">) +</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">X</samp> <samp class="SANS_Futura_Std_Book_11">+</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">X</samp><samp class="SANS_Futura_Std_Book_SUP_11">2</samp><samp class="SANS_Futura_Std_Book_11">. In more general terms,</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">A</samp> <samp class="SANS_Futura_Std_Book_11">+</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">BC</samp> <samp class="SANS_Futura_Std_Book_11">modulo</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">B</samp> <samp class="SANS_Futura_Std_Book_11">is equal to</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">A</samp><samp class="SANS_Futura_Std_Book_11">, by definition of modular reduction.</samp></p>&#13;
</aside>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec14">&#13;
<h4 class="H2" id="sec14"><span id="h2-106"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">GCM Security</samp></h4>&#13;
<p class="TNI">AES-GCM’s biggest weakness is its fragility in the face of nonce repetition. If you use the same nonce <i>N</i> twice to encrypt two distinct messages, then an attacker observing the two ciphertexts can determine the value of the XOR between their respective plaintexts. They can also retrieve the authentication key <i>H</i> and use it to forge tags for any ciphertext, associated data, or combination thereof.</p>&#13;
<p class="TX">A look at the basic algebra behind AES-GCM’s computations (see <a href="chapter8.xhtml#fig8-2">Figure 8-2</a>) helps clarify this fragility. You compute a tag (<i>T</i>) as <i>T</i> = <b>GHASH</b> (<i>H</i>, <i>A</i>, <i>C</i>) <span class="symbol">⊕</span> <b>AES</b>(<i>K</i>, <i>N</i> || 0), where GHASH is a universal hash function with linearly related inputs and outputs.</p>&#13;
<p class="TX">If you compute two tags, <i>T</i><sub>1</sub> and <i>T</i><sub>2</sub>, with the same nonce <i>N</i>, the AES part will vanish. If you have two tags, <i>T</i><sub>1</sub> = <b>GHASH</b>(<i>H</i>, <i>A</i><sub>1</sub>, <i>C</i><sub>1</sub>) <span class="symbol">⊕</span> <b>AES</b>(<i>K</i>, <i>N</i> || 0) and <i>T</i><sub>2</sub> = <b>GHASH</b>(<i>H</i>, <i>A</i><sub>2</sub>, <i>C</i><sub>2</sub>) <span class="symbol">⊕</span> <b>AES</b>(<i>K</i>, <i>N</i> || 0), XORing them together results in the following:</p>&#13;
<figure class="DIS-IMG"><img class="img1" src="../images/pg166-1.jpg" alt="" width="1387" height="181"/></figure>&#13;
<p class="TX">If you use the same nonce twice, an attacker can thus recover the value <b>GHASH</b>(<i>H</i>, <i>A</i><sub>1</sub>, <i>C</i><sub>1</sub>) <span class="symbol">⊕</span> <b>GHASH</b>(<i>H</i>, <i>A</i><sub>2</sub>, <i>C</i><sub>2</sub>) for some known <i>A</i><sub>1</sub>, <i>C</i><sub>1</sub>, <i>A</i><sub>2</sub>, and <i>C</i><sub>2</sub>. The linearity of GHASH then allows an attacker to recover <i>H</i>.</p>&#13;
<p class="TX">In 2016, researchers scanned the internet for instances of AES-GCM exposed through HTTPS servers, in search of systems with repeating nonces (see the research article <i><a href="https://eprint.iacr.org/2016/475">https://<wbr/>eprint<wbr/>.iacr<wbr/>.org<wbr/>/2016<wbr/>/475</a></i>). They found 184 servers with repeating nonces, including 23 that always used the all-zero string as a nonce.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec15">&#13;
<h4 class="H2" id="sec15"><span id="h2-107"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">GCM Efficiency</samp></h4>&#13;
<p class="TNI">An advantage of GCM mode is that GCM encryption and decryption process blocks independently, allowing you to parallelize their computation. However, the GMAC computation isn’t parallelizable, because it must be computed from the beginning to the end of the ciphertext once GHASH has processed any associated data. This lack of parallelizability means that any system that receives the plaintext first and then the associated data has <span role="doc-pagebreak" epub:type="pagebreak" id="pg_167" aria-label="167"/>to wait until all associated data is read and hashed before hashing the first ciphertext block.</p>&#13;
<p class="TX">However, GCM is streamable: since the computations in its two layers can be pipelined, there’s no need to store all ciphertext blocks before computing GHASH because GHASH processes each block as it’s encrypted. In other words, <i>P</i><sub>1</sub> encrypts to <i>C</i><sub>1</sub>, then GHASH processes <i>C</i><sub>1</sub> while <i>P</i><sub>2</sub> encrypts to <i>C</i><sub>2</sub>, then <i>P</i><sub>1</sub> and <i>C</i><sub>1</sub> are no longer needed, and so on.</p>&#13;
</section>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec16">&#13;
<h3 class="H1" id="sec16"><span id="h1-57"/><samp class="SANS_Futura_Std_Bold_B_11">The OCB Authenticated Cipher Mode</samp></h3>&#13;
<p class="TNI">First developed in 2001, <i>offset codebook (OCB)</i> predates GCM, and like GCM it produces an authenticated cipher from a block cipher, though it does so faster and more simply. OCB has yet to see wider adoption because until 2021, the use of OCB was patented and required a license from its inventor. OCB is now free for anyone to use in any application.</p>&#13;
<p class="TX">Unlike GCM, OCB blends encryption and authentication into one processing layer that uses a single key. There’s no separate authentication layer, so OCB provides authentication mostly for free and performs nearly as many block cipher calls as a nonauthenticated cipher would—OCB is almost as simple as the ECB mode (see <span class="Xref"><a href="chapter4.xhtml">Chapter 4</a></span>), except that it’s more secure.</p>&#13;
<section epub:type="division" aria-labelledby="sec17">&#13;
<h4 class="H2" id="sec17"><span id="h2-108"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">OCB Internals</samp></h4>&#13;
<p class="TNI"><a href="chapter8.xhtml#fig8-3">Figure 8-3</a> shows how OCB works: it encrypts each plaintext block <i>P</i> to a ciphertext block <i>C</i> = <b>E</b>(<i>K</i>, <i>P</i> <span class="symbol">⊕</span> <i>O</i>) <span class="symbol">⊕</span> <i>O</i>, where <b>E</b> is a block cipher encryption function. Here, <i>O</i> (the <i>offset</i>) is a value that depends on the key and the nonce incremented for each new block processed.</p>&#13;
<figure class="IMG"><img id="fig8-3" class="img7" src="../images/fig8-3.jpg" alt="" width="614" height="361"/>&#13;
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 8-3: The OCB encryption process when run on two plaintext blocks, with no associated data</samp></p></figcaption>&#13;
</figure>&#13;
<p class="TX">To produce the authentication tag, OCB first XORs the plaintext blocks together to compute <i>S</i> = <i>P</i><sub>1</sub> <span class="symbol">⊕</span> <i>P</i><sub>2</sub> <span class="symbol">⊕</span> <i>P</i><sub>3</sub> <span class="symbol">⊕</span> . . . The tag is then <i>T</i> = <b>E</b>(<i>K</i>, <i>S</i> <span class="symbol">⊕</span> <i>O</i><sup>*</sup>), where <i>O</i><sup>*</sup> is an offset value computed from the offset of the last plaintext block processed.</p>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_168" aria-label="168"/>Like AES-GCM, OCB also supports associated data as a series of blocks, <i>A</i><sub>1</sub>, <i>A</i><sub>2</sub>, and so on. When an OCB encrypted message contains associated data, calculate the authentication tag according to the formula</p>&#13;
<figure class="DIS-IMG"><img class="img1" src="../images/pg168-1.jpg" alt="" width="1388" height="45"/></figure>&#13;
<p class="Continued">where OCB defines different offsets from those used to encrypt <i>P</i>.</p>&#13;
<p class="TX">Unlike GCM and encrypt-then-MAC, which combine ciphertext blocks to form the tag, OCB calculates the authentication tag by combining plaintext data. There’s nothing wrong with this approach, and OCB is backed by solid security proofs.</p>&#13;
<blockquote>&#13;
<p class="Note"><span class="NoteHead"><samp class="SANS_Dogma_OT_Bold_B_15">NOTE</samp></span></p>&#13;
</blockquote>&#13;
<p class="NOTE-TXT"><i>For more on how to implement OCB, see either RFC 7253 or the 2011 paper “The Software Performance of Authenticated-Encryption Modes” by Ted Krovetz and Phillip Rogaway, which covers the latest and best version of OCB, OCB3. For further details on OCB, see the FAQ at</i> <span class="note_LinkURL_Italic"><a href="http://web.cs.ucdavis.edu/rogaway/ocb/ocb-faq.htm">http://<wbr/>web<wbr/>.cs<wbr/>.ucdavis<wbr/>.edu<wbr/>/rogaway<wbr/>/ocb<wbr/>/ocb<wbr/>-faq<wbr/>.htm</a></span>.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec18">&#13;
<h4 class="H2" id="sec18"><span id="h2-109"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">OCB Security</samp></h4>&#13;
<p class="TNI">OCB is a bit less fragile than GCM against repeated nonces. If you use a nonce twice, an attacker that sees the two ciphertexts could notice that, say, the third plaintext block of the first message is identical to the third plaintext block of the second message. With GCM, attackers can find not only duplicates but also the XOR differences between blocks at the same position. The impact of repeated nonces is therefore worse with GCM than with OCB.</p>&#13;
<p class="TX">As with GCM, repeated nonces jeopardize the authenticity of OCB, though less potently. For example, an attacker could combine blocks from two messages authenticated with OCB to create another encrypted message with the same checksum and tag as one of the original two messages, but the attacker wouldn’t be able to recover a secret key as with GCM.</p>&#13;
<p class="TX">In 2023, cryptographers discovered that using OCB3 with very short nonces (6 bits) causes its security to significantly reduce; see the article at <i><a href="https://eprint.iacr.org/2023/326">https://<wbr/>eprint<wbr/>.iacr<wbr/>.org<wbr/>/2023<wbr/>/326</a></i>. Note that the version OCB2 was broken, as described in the article at <i><a href="https://eprint.iacr.org/2019/311.pdf">https://<wbr/>eprint<wbr/>.iacr<wbr/>.org<wbr/>/2019<wbr/>/311<wbr/>.pdf</a></i>.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec19">&#13;
<h4 class="H2" id="sec19"><span id="h2-110"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">OCB Efficiency</samp></h4>&#13;
<p class="TNI">OCB and GCM are about equally efficient. Like GCM, OCB is parallelizable and streamable. In terms of raw efficiency, GCM and OCB make about as many calls to the underlying block cipher (usually AES), but OCB is slightly faster than GCM because it simply XORs the plaintext rather than performing something like the relatively expensive GHASH computation. (In earlier generations of Intel microprocessors, AES-GCM used to be more than three times slower than AES-OCB because AES and GHASH instructions had to compete for CPU resources and couldn’t be run in parallel.)</p>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_169" aria-label="169"/>An important difference between OCB and GCM implementations is that OCB needs both the block cipher’s encryption and decryption functions to encrypt and decrypt, increasing the cost of hardware implementations when only limited silicon is available for crypto components. In contrast, GCM uses only the encryption function for both encryption and decryption.</p>&#13;
</section>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec20">&#13;
<h3 class="H1" id="sec20"><span id="h1-58"/><samp class="SANS_Futura_Std_Bold_B_11">The SIV Authenticated Cipher Mode</samp></h3>&#13;
<p class="TNI"><i>Synthetic IV (SIV)</i> is an authenticated cipher mode typically used with AES. Unlike GCM and OCB, SIV is secure even if you use the same nonce twice: an attacker that gets two ciphertexts encrypted using the same nonce would only be able to learn whether the same plaintext was encrypted twice. Unlike with GCM or OCB, the attacker would be unable to tell whether the first block of the two messages is the same, because the nonce used to encrypt is first computed as a combination of the given nonce and the plaintext.</p>&#13;
<p class="TX">The SIV construction specification is more general than that of GCM. Instead of specifying detailed internals as with GCM’s GHASH, SIV simply tells you how to combine a cipher (<b>E</b>) and a pseudorandom function (<b>PRF</b>) to get an authenticated cipher: you first compute the tag <i>T</i> = <b>PRF</b>(<i>K</i><sub>1</sub>, <i>N</i> || <i>P</i>) and then the ciphertext <i>C</i> = <b>E</b>(<i>K</i><sub>2</sub>, <i>T</i>, <i>P</i>), where <i>T</i> acts as the nonce of <b>E</b>. Thus, SIV needs two keys (<i>K</i><sub>1</sub> and <i>K</i><sub>2</sub>) and a nonce (<i>N</i>).</p>&#13;
<p class="TX">The major limitation of SIV is that it’s not streamable: after computing <i>T</i>, it must keep the entire plaintext <i>P</i> in memory. In other words, to encrypt a 100GB plaintext with SIV, you must first store the 100GB so that SIV encryption can read it.</p>&#13;
<p class="TX">The document RFC 5297, based on the 2006 paper “Deterministic Authenticated-Encryption” by Phillip Rogaway and Thomas Shrimpton, specifies SIV as using CMAC-AES (a MAC construction using AES) as a PRF and AES-CTR as a cipher. In 2015, a more efficient version of SIV was proposed, GCM-SIV, which combines GCM’s fast GHASH function and SIV’s mode and is nearly as fast as GCM. Like the original SIV, however, GCM-SIV isn’t streamable. (For more information, see <i><a href="https://eprint.iacr.org/2015/102">https://<wbr/>eprint<wbr/>.iacr<wbr/>.org<wbr/>/2015<wbr/>/102</a></i>.)</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec21">&#13;
<h3 class="H1" id="sec21"><span id="h1-59"/><samp class="SANS_Futura_Std_Bold_B_11">Permutation-Based AEAD</samp></h3>&#13;
<p class="TNI">Now for a totally different approach to building an authenticated cipher: instead of building a mode of operation around a block cipher like AES, we’ll look at a cipher that builds a mode around a permutation. A permutation simply transforms an input to an output of the same size, reversibly, without using a key, that’s the simplest component imaginable. Better still, the resulting AEAD is fast, provably secure, and more resistant to nonce reuse than GCM and OCB.</p>&#13;
<p class="TX"><a href="chapter8.xhtml#fig8-4">Figure 8-4</a> shows how a permutation-based AEAD works: from a fixed initial state <i>H</i><sub>0</sub>, you XOR the key <i>K</i> followed by the nonce <i>N</i> to the internal <span role="doc-pagebreak" epub:type="pagebreak" id="pg_170" aria-label="170"/>state, to obtain a new value of the internal state that’s the same size as the original. You then transform the new state with a permutation <b>P</b> and get a new value of the state. Now you XOR the first plaintext block <i>P</i><sub>1</sub> to the state and take the resulting value as the first ciphertext block <i>C</i><sub>1</sub>, where <i>P</i><sub>1</sub> and <i>C</i><sub>1</sub> are equal in size but shorter than the state.</p>&#13;
<figure class="IMG"><img id="fig8-4" class="img7" src="../images/fig8-4.jpg" alt="" width="659" height="279"/>&#13;
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 8-4: A permutation-based authenticated cipher</samp></p></figcaption>&#13;
</figure>&#13;
<p class="TX">To encrypt a second block, transform the state with <b>P</b>, XOR the next plaintext block <i>P</i><sub>2</sub> to the current state, and take the resulting value as <i>C</i><sub>2</sub>. Then iterate over all plaintext blocks and, following the last call to <b>P</b>, take bits from the internal state as the authentication tag <i>T</i>, as in the right side of <a href="chapter8.xhtml#fig8-4">Figure 8-4</a>.</p>&#13;
<blockquote>&#13;
<p class="Note"><span class="NoteHead"><samp class="SANS_Dogma_OT_Bold_B_15">NOTE</samp></span></p>&#13;
</blockquote>&#13;
<p class="NOTE-TXT"><i>You can adapt the mode in <a href="chapter8.xhtml#fig8-4">Figure 8-4</a> to support associated data, but the process is a bit more complicated, so I’ll skip its description.</i></p>&#13;
<p class="TX">Designing <i>secure</i> permutation-based authenticated ciphers has certain requirements. First, only XOR input values to a part of the state: the larger this part, the more control a successful attacker has on the internal state and thus the lower the cipher’s security. Indeed, all security relies on the secrecy of the internal state.</p>&#13;
<p class="TX">Also, you must properly pad blocks with extra bits in a way that ensures that any two different messages yield different results. As a counterexample, if the last plaintext block is shorter than a complete block, it shouldn’t just be padded with 0s; otherwise, a plaintext block of, say, 2 bytes (0000) would result in a complete plaintext block (0000 . . . 0000), as would a block of 3 bytes (000000). As a result, you’d get the same tag for both messages, although they differ in size.</p>&#13;
<p class="TX">If you reuse a nonce in such a permutation-based cipher, the impact isn’t as bad as with GCM or OCB—the strength of the authentication tag won’t be compromised. If you repeat a nonce, an attacker would only learn whether the two encrypted messages begin with the same value, as well as the length of this common value, or prefix. For example, although encrypting the two six-block messages <i>ABCXYZ</i> and <i>ABCDYZ</i> (each letter symbolizing a block here) with the same nonce might yield the two ciphertexts <i>JKLTUV</i> and <i>JKLMNO</i>, which have identical prefixes, attackers wouldn’t be able to learn that the two plaintexts shared the same final two blocks (<i>YZ</i>).</p>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_171" aria-label="171"/>In terms of performance, permutation-based ciphers offer the benefits of a single layer of operations, streamable processing, and the use of a single-core algorithm for encryption and decryption. However, they aren’t parallelizable like GCM or OCB because new calls to <b>P</b> need to wait for the previous call to complete.</p>&#13;
<blockquote>&#13;
<p class="Note"><span class="NoteHead"><samp class="SANS_Dogma_OT_Bold_B_15">NOTE</samp></span></p>&#13;
</blockquote>&#13;
<p class="NOTE-TXT"><i>If you’re tempted to pick your favorite permutation and make up your own authenticated cipher, please don’t. You’re likely to get the details wrong and end up with an insecure cipher. Read the specifications written by experienced cryptographers for algorithms such as Keyak (an algorithm derived from Keccak), the Duplex construction, and deck functions on</i> <span class="note_LinkURL_Italic"><a href="https://keccak.team">https://<wbr/>keccak<wbr/>.team</a></span><i>. You’ll see that permutation-based ciphers are more complex than they first appear.</i></p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec22">&#13;
<h3 class="H1" id="sec22"><span id="h1-60"/><samp class="SANS_Futura_Std_Bold_B_11">How Things Can Go Wrong</samp></h3>&#13;
<p class="TNI">Authenticated ciphers have a larger attack surface than hash functions or block ciphers because they aim to achieve both confidentiality <i>and</i> authenticity. They take several different input values and must remain secure regardless of whether the input contains only associated data and no encrypted data, extremely large plaintexts, or different key sizes. They must also be secure for all nonce values against attackers who collect numerous message/tag pairs and, to some extent, against accidental repetition of nonces.</p>&#13;
<p class="TX">That’s a lot to ask, and even AES-GCM has several imperfections.</p>&#13;
<section epub:type="division" aria-labelledby="sec23">&#13;
<h4 class="H2" id="sec23"><span id="h2-111"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">AES-GCM and Weak Hash Keys</samp></h4>&#13;
<p class="TNI">One of AES-GCM’s weaknesses is in its authentication algorithm GHASH: certain values of the hash key <i>H</i> greatly simplify attacks against GCM’s authentication mechanism. Specifically, if the value <i>H</i> belongs to some specific, mathematically defined subgroups of all 128-bit strings, attackers might be able to guess a valid authentication tag for some message simply by shuffling the blocks of a previous message.</p>&#13;
<p class="TX">To understand this weakness, let’s look at how GHASH works.</p>&#13;
<section epub:type="division" aria-labelledby="sec24">&#13;
<h5 class="H3" id="sec24"><samp class="SANS_Futura_Std_Bold_Condensed_B_11">GHASH Internals</samp></h5>&#13;
<p class="TNI">As you saw in <a href="chapter8.xhtml#fig8-2">Figure 8-2</a>, GHASH starts with a 128-bit value, <i>H</i>, initially set to <b>AES</b>(<i>K</i>, 0), and then repeatedly computes</p>&#13;
<figure class="DIS-IMG"><img class="img1" src="../images/pg171-1.jpg" alt="" width="1362" height="40"/></figure>&#13;
<p class="Continued">starting from <i>X</i><sub>0</sub> = 0 and processing ciphertext blocks <i>C</i><sub>1</sub>, <i>C</i><sub>2</sub>, and so on. GHASH returns the final <i>X</i><span class="ePub-I-SUB">i</span> to compute the final tag.</p>&#13;
<p class="TX">Say for the sake of simplicity that all <i>C</i><span class="ePub-I-SUB">i</span> values are equal to 1 so that for any <i>I</i> you have this:</p>&#13;
<figure class="DIS-IMG"><img class="img1" src="../images/pg171-2.jpg" alt="" width="1362" height="40"/></figure>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_172" aria-label="172"/>Next, computing X<sub>1</sub> from our first equation yields</p>&#13;
<figure class="DIS-IMG"><img class="img1" src="../images/pg172-1.jpg" alt="" width="1404" height="40"/></figure>&#13;
<p class="Continued">substituting <i>X</i><sub>0</sub> with 0 and <i>C</i><sub>1</sub> with 1, to yield the following:</p>&#13;
<figure class="DIS-IMG"><img class="img1" src="../images/pg172-2.jpg" alt="" width="1404" height="37"/></figure>&#13;
<p class="TX">Thanks to the distributive property of <span class="symbol">⊗</span> over <span class="symbol">⊕</span>, we substitute <i>X</i><sub>1</sub> with <i>H</i> and <i>C</i><sub>2</sub> with 1 and then compute the next value, <i>X</i><sub>2</sub>, as</p>&#13;
<figure class="DIS-IMG"><img class="img1" src="../images/pg172-3.jpg" alt="" width="1404" height="48"/></figure>&#13;
<p class="Continued">where <i>H</i> <sup>2</sup> is <i>H</i> squared, or <i>H</i> <span class="symbol">⊗</span> <i>H</i>.</p>&#13;
<p class="TX">Now you derive <i>X</i><sub>3</sub> by substituting <i>X</i><sub>2</sub> for its derivation, and obtain the following:</p>&#13;
<figure class="DIS-IMG"><img class="img1" src="../images/pg172-4.jpg" alt="" width="1404" height="60"/></figure>&#13;
<p class="TX">Next, you derive <i>X</i><sub>4</sub> to be <i>X</i><sub>4</sub> = <i>H</i> <sup>4</sup> <span class="symbol">⊕</span> <i>H</i> <sup>3</sup> <span class="symbol">⊕</span> <i>H</i> <sup>2</sup> <span class="symbol">⊕</span> <i>H</i>, and so on, and eventually the last <i>X</i><span class="ePub-I-SUB">i</span> is this:</p>&#13;
<figure class="DIS-IMG"><img class="img1" src="../images/pg172-5.jpg" alt="" width="1404" height="47"/></figure>&#13;
<p class="TX">Remember that you set all blocks <i>C</i><span class="ePub-I-SUB">i</span> equal to 1. If these values are arbitrary instead, you end up with the following:</p>&#13;
<figure class="DIS-IMG"><img class="img1" src="../images/pg172-6.jpg" alt="" width="1404" height="46"/></figure>&#13;
<p class="TX">GHASH then XORs the message’s length to this last <i>X</i><span class="ePub-I-SUB">n</span>, multiplies the result by <i>H</i>, and XORs this value with <b>AES</b>(<i>K</i>, <i>N</i> || 0) to create the final authentication tag, <i>T</i>.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec25">&#13;
<h5 class="H3" id="sec25"><samp class="SANS_Futura_Std_Bold_Condensed_B_11">Where Things Break</samp></h5>&#13;
<p class="TNI">What can go wrong from here? Let’s look first at the simplest cases:</p>&#13;
<ul class="ul">&#13;
<li class="BL">If <i>H</i> = 0, then <i>X</i><span class="ePub-I-SUB">n</span> = 0 regardless of the <i>C</i><span class="ePub-I-SUB">i</span> values and thus regardless of the message. That is, all messages will have the same authentication tag if <i>H</i> is 0.</li>&#13;
<li class="BL">If <i>H</i> = 1, then the tag is just an XOR of the ciphertext blocks, and reordering the ciphertext blocks will give the same authentication tag.</li>&#13;
</ul>&#13;
<p class="TX">Since 0 and 1 are only two of 2<sup>128</sup> possible values of <i>H</i>, there’s only a 2/2<sup>128</sup> = 1/2<sup>127</sup> chance of these occurring. But there are other weak values as well—namely, all values of <i>H</i> that belong to a <i>short cycle</i> when raised to <i>i</i>th powers. For example, the value of <i>H</i> <samp class="SANS_TheSansMonoCd_W5Regular_11">10d04d25f93556e69f58ce2f8d035a4</samp> belongs to a cycle of length 5, as it satisfies <i>H</i><sup>5</sup> = <i>H</i>, and therefore <i>H</i> <i><sup>e</sup></i> = <i>H</i> for any <i>e</i> that is a multiple of 5 (the very definition of cycle with respect to fifth powers). Consequently, in the preceding expression of the final GHASH <span role="doc-pagebreak" epub:type="pagebreak" id="pg_173" aria-label="173"/>value <i>X</i><span class="ePub-I-SUB">n</span>, swapping the blocks <i>C</i><span class="ePub-I-SUB">n</span> (multiplied to <i>H</i>) and the block <i>C</i><span class="ePub-I-SUB">n –</span> <sub>4</sub> (multiplied to <i>H</i><sup>5</sup>) leaves the authentication tag unchanged, which amounts to a forgery. An attacker may exploit this property to construct a new message and its valid tag without knowing the key, which should be impossible for a secure authenticated cipher.</p>&#13;
<p class="TX">The preceding example is based on a cycle of length 5, but there are many cycles of greater length and therefore many values of <i>H</i> that are weaker than they should be. The upshot is that, in the unlikely case that <i>H</i> belongs to a short cycle of values and attackers can forge as many authentication tags as they want, unless they know <i>H</i> or <i>K</i>, they can’t determine <i>H</i>’s cycle length. While attackers can’t exploit this vulnerability, you can avoid it by carefully choosing the polynomial used for modulo reductions.</p>&#13;
<blockquote>&#13;
<p class="Note"><span class="NoteHead"><samp class="SANS_Dogma_OT_Bold_B_15">NOTE</samp></span></p>&#13;
</blockquote>&#13;
<p class="NOTE-TXT"><i>For further details on this attack, read “Cycling Attacks on GCM, GHASH and Other Polynomial MACs and Hashes” by Markku-Juhani O. Saarinen, available at</i> <span class="note_LinkURL_Italic"><a href="https://eprint.iacr.org/2011/202">https://<wbr/>eprint<wbr/>.iacr<wbr/>.org<wbr/>/2011<wbr/>/202</a></span>.</p>&#13;
</section>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec26">&#13;
<h4 class="H2" id="sec26"><span id="h2-112"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">AES-GCM and Small Tags</samp></h4>&#13;
<p class="TNI">In practice, AES-GCM usually returns 128-bit tags, but it can produce tags of any length. Unfortunately, when using shorter tags, the probability of forgery increases significantly.</p>&#13;
<p class="TX">When using a 128-bit tag, an attacker who attempts a forgery should succeed with a probability of 1/2<sup>128</sup> because there are 2<sup>128</sup> possible 128-bit tags. (Generally, with an <i>n</i>-bit tag, the probability of success should be 1/2<i><sup>n</sup></i>, where 2<i><sup>n</sup></i> is the number of possible values of an <i>n</i>-bit tag.) But when using shorter tags, the probability of forgery is much higher than 1/2<i><sup>n</sup></i> due to weaknesses in the structure of GCM that are beyond the scope of this discussion. For example, a 32-bit tag allows an attacker who knows the authentication tag of some 2MB message to succeed with a chance of 1/2<sup>16</sup> instead of 1/2<sup>32</sup>.</p>&#13;
<p class="TX">Generally, with <i>n</i>-bit tags, the probability of forgery isn’t 1/2<i><sup>n</sup></i> but rather 2<i><sup>m</sup></i>/2<i><sup>n</sup></i>, where 2<i><sup>m</sup></i> is the number of blocks of the longest message for which a successful attacker observed the tag. For example, if you use 48-bit tags and process messages of 4GB (or 2<sup>28</sup> blocks of 16 bytes each), the probability of a forgery is 2<sup>28</sup>/2<sup>48</sup> = 1/2<sup>20</sup>, or about one chance in a million. That’s a relatively high chance as far as cryptography is concerned. (For more information on this attack, see the 2005 paper “Authentication Weaknesses in GCM” by Niels Ferguson.)</p>&#13;
</section>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec27">&#13;
<h3 class="H1" id="sec27"><span id="h1-61"/><samp class="SANS_Futura_Std_Bold_B_11">Further Reading</samp></h3>&#13;
<p class="TNI">To learn more about authenticated ciphers, visit the home page of CAESAR, the Competition for Authenticated Encryption: Security, Applicability, and Robustness (<i><a href="http://competitions.cr.yp.to/caesar.html">http://<wbr/>competitions<wbr/>.cr<wbr/>.yp<wbr/>.to<wbr/>/caesar<wbr/>.html</a></i>). Started in 2012, CAESAR was a crypto competition in the style of the AES and SHA-3 competitions, though it isn’t organized by NIST.</p>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_174" aria-label="174"/>The CAESAR competition attracted an impressive number of innovative designs: from OCB-like modes to permutation-based modes (such as NORX and Keyak), as well as totally original algorithms (such as AEZ or AEGIS). In 2019, CAESAR concluded with the selection of a portfolio of seven algorithms divided into three categories, which you can find on its official page at <i><a href="https://competitions.cr.yp.to/caesar-submissions.html">https://<wbr/>competitions<wbr/>.cr<wbr/>.yp<wbr/>.to<wbr/>/caesar<wbr/>-submissions<wbr/>.html</a></i>.</p>&#13;
<p class="TX">Another competition where you can find authenticated encryption algorithms was NIST’s Lightweight Cryptography project. Running from 2017 to 2023, it aimed at standardizing algorithms optimized for resource-constrained environments (memory, processor size, and so on) such as embedded platforms. The winner of the competition was Ascon, a family of permutation-based algorithms, presented in detail on its official site at <i><a href="https://ascon.iaik.tugraz.at">https://<wbr/>ascon<wbr/>.iaik<wbr/>.tugraz<wbr/>.at</a></i>. To discover the other candidate algorithms and the work presented at the project workshops, visit <i><a href="https://csrc.nist.gov/Projects/lightweight-cryptography">https://<wbr/>csrc<wbr/>.nist<wbr/>.gov<wbr/>/Projects<wbr/>/lightweight<wbr/>-cryptography</a></i>.</p>&#13;
<p class="TX">In this chapter, we focused on GCM, but a handful of other modes are used in real applications as well. Specifically, the counter with CBC-MAC (CCM) and EAX modes competed with GCM for standardization in the early 2000s, and although GCM was selected, its competitors are used in a few applications. For example, CCM is used in the WPA2 Wi-Fi encryption protocol. Consider reading these ciphers’ specifications and reviewing their relative security and performance merits.</p>&#13;
<p class="TX">This concludes our discussion of symmetric-key cryptography! You’ve seen block ciphers, stream ciphers, (keyed) hash functions, and now authenticated ciphers—all the main cryptography components that work with a symmetric key, or no key at all. Before we move to <i>asymmetric</i> cryptography, <span class="Xref"><a href="chapter9.xhtml">Chapter 9</a></span> focuses on computer science and math, to provide background for asymmetric schemes such as RSA (<span class="Xref"><a href="chapter10.xhtml">Chapter 10</a></span>) and Diffie–Hellman (<span class="Xref"><a href="chapter11.xhtml">Chapter 11</a></span>).</p>&#13;
</section>&#13;
</section>&#13;
</div>
</div>
</body></html>