- en: '**8'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: TWO BALLISTIC CHRONOGRAPHS**
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/common-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: This project is a device for measuring the velocity of a projectile. It originally
    measured the velocity of pellets from air-soft and paintball guns, and it evolved
    to be capable of measuring projectile velocities from BB and pellet guns before
    finally measuring velocities of over 3,000 feet per second (fps) from higher-powered
    weapons. The main intention of this project is not to measure the velocities of
    traditional fire-arms, but this project does have that capability, and the end
    of this chapter describes how to use it to measure the velocity of a 9 mm bullet.
  prefs: []
  type: TYPE_NORMAL
- en: 'The Ballistic Chronograph was meant to be simple, but it turned out a little
    more complex than originally planned. The result is two projects: the Full Ballistic
    Chronograph and a more diminutive and simpler device I call the Chronograph Lite
    (see [Figure 8-1](ch08.xhtml#ch08fig8-1)).'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/fig8_1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 8-1: The Chronograph Lite with a projectile-acceleration channel attached
    to a 0.177 caliber pellet gun*'
  prefs: []
  type: TYPE_NORMAL
- en: I’ve attempted to make each Ballistic Chronograph system both flexible and accurate.
    The flexibility comes from separating the sensor elements from the readout and
    permitting different types of sensors to measure different devices—and producing
    different readouts with the same acceleration channel.
  prefs: []
  type: TYPE_NORMAL
- en: In this project, you will use some components not too frequently encountered
    in Arduino projects, such as a crystal oscillator to provide precise timing (outside
    of the crystal oscillator used in the Nano), infrared LEDs, phototransistors,
    logic gates, a 12-stage digital counter, and a digital-to-analog converter (DAC)
    to help perform the counting function.
  prefs: []
  type: TYPE_NORMAL
- en: '**A WORD OF WARNING**'
  prefs: []
  type: TYPE_NORMAL
- en: With deference to Jean Shepherd’s *A Christmas Story* (in which everyone warns
    Ralphie, “You’re going to shoot your eye out!”), remember that any firearm is
    inherently dangerous, and many air-powered weapons can fire at lethal force. Whether
    you test an air-powered device or a weapon using high-powered bullets, use extreme
    caution. The Full Ballistic Chronograph and the Lite version were developed, tested,
    and made primarily for lower-powered weapons using CO[2] and air power to accelerate
    projectiles. Though the device is capable of measuring bullets from traditional
    firearms, such as the 9 mm pistol mentioned earlier, it was not developed or tested
    for that application. I strongly recommend that you not attempt to use the device
    you build in this chapter in such applications.
  prefs: []
  type: TYPE_NORMAL
- en: '**What Is a Ballistic Chronograph?**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A device for measuring the velocity of a high-speed projectile exiting a firearm
    is generally known as a *ballistic chronograph*. The term *chronograph* was co-opted
    from the horological community and is now widely used to describe instruments
    for measuring the speed of bullets, arrows, darts, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter proposes two versions of the Ballistic Chronograph: one offering
    the ability to accurately measure very high-speed projectiles and a Lite version
    offering a little less precision but a far simpler implementation. Though I refer
    to the simpler build as the “Lite” version, it is by no means unsophisticated.'
  prefs: []
  type: TYPE_NORMAL
- en: '***Commercial Chronographs***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: There are several commercially available chronographs, most of which are intended
    for high-powered pistols and rifles. Chronographs are usually placed on the ground
    or a table in front of the shooter. Most of the popular commercial devices depend
    on ambient sunlight for operation and, therefore, don’t work indoors or on overcast
    days. And while they are modestly priced, they are not really cheap.
  prefs: []
  type: TYPE_NORMAL
- en: Chronographs vary from simple two-wire devices (still in use and believed by
    some to be the most accurate) to relatively elaborate units with digital memory,
    average velocity calculations, and other features. The two-wire approach simply
    uses two thin strands of wire (36- or 40-gauge wire will do) stretched between
    two pairs of contacts accurately spaced apart. The projectile is shot and breaks
    the first wire to start a timer, and then, if you have good aim, breaks the second
    wire to stop the timer. The time between breakages is calculated to provide a
    speed value in feet or meters per second. The very early chronographs were built
    with a clock, which had readouts of ones and zeros displayed in a bank of LEDs.
    The binary number had to be translated to a decimal number and then calculated
    with the distance between the wires to get the velocity.
  prefs: []
  type: TYPE_NORMAL
- en: '***Measuring Muzzle Velocity***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Now that you know what types of prebuilt chronographs are out there, let’s take
    a look at the physics of the device. A projectile leaving the muzzle of a weapon
    has a velocity imparted to it by some propellant, such as air, CO[2], or the gas
    created by the rapid oxidation of the fuel in gunpowder. The projectile travels
    down the barrel and exits the muzzle. The speed of the projectile as it exits
    is called *muzzle velocity*.
  prefs: []
  type: TYPE_NORMAL
- en: The muzzle velocity of air-powered guns tends to vary depending on several factors,
    including the charge of the propellant, cleanliness of the barrel, and projectile-to-barrel
    matchup. Some air rifles can be pumped to almost 3,000 psi (pounds per square
    inch) to fire larger projectiles at relatively significant velocities. These larger
    air guns have relatively low muzzle velocities in the sub-1,000 fps range, but
    they pack a real punch. Compared to conventional air rifles, which shoot 0.177-inch
    pellets that pack between 15 and 25 ft-lbs (foot-pounds) of power, these larger-bore
    rifles offer between 500 and 700 ft-lbs of power.
  prefs: []
  type: TYPE_NORMAL
- en: Ideally, you would want to measure the velocity as close to the end of the barrel
    as possible. However, this can be difficult, and some chronograph makers claim
    that the velocity is not attenuated much in the first several feet (or even yards)
    of travel. On the other hand, there is little doubt that air resistance is a significant
    factor, and the projectile will slow at least somewhat in the first few feet—especially
    in the case of larger projectiles.
  prefs: []
  type: TYPE_NORMAL
- en: '***This Project’s Approach***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: As in the two-wire ballistic chronograph systems, we’re trying to measure the
    time it takes for a projectile to travel a fixed distance. But instead of breaking
    thin wires, this project takes advantage of an infrared light source and light-sensitive
    receiver, as illustrated in [Figure 8-2](ch08.xhtml#ch08fig8-2).
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/fig8_2.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 8-2: The basic principle in measuring the speed of the projectile is
    to have it break a beam of light to start a clock and then break another beam
    of light to stop the clock*.'
  prefs: []
  type: TYPE_NORMAL
- en: Two pairs of LEDs and IR sensors are arranged so that the IR sensor normally
    detects the light source. But when the projectile breaks the light beam of the
    first pair, the sensor goes dark and changes its electrical state. The processor
    senses this change and starts a timer. When the projectile interrupts a second
    source/receiver pair, the timer stops. The two sets of light sources and receivers
    are set an accurate distance apart so the time of travel can be relatively easily
    calculated into projectile speed.
  prefs: []
  type: TYPE_NORMAL
- en: For a simple example, say the beams of light are set a foot apart. A projectile
    interrupts a beam of light and starts the clock; when the projectile interrupts
    the second beam of light, the clock stops. If the microcontroller’s timer measured
    1 second, the velocity would be 1 foot in 1 second, or 1 fps.
  prefs: []
  type: TYPE_NORMAL
- en: This system can be used with a variety of projectiles and provide a digital
    readout on an LCD. Unlike other approaches, this device separates out the sensor
    bank from the electronics such that, if desired, different sensors can be swapped
    in and out for different firearms or even different applications. For instance,
    you could set up a sensor channel and do some basic physics experiments by dropping
    small objects through it and recording their velocity.
  prefs: []
  type: TYPE_NORMAL
- en: '**The Chronograph Lite**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: First, we’ll take a look at the Chronograph Lite, which is simple to construct
    and has only a handful of parts.
  prefs: []
  type: TYPE_NORMAL
- en: '***Required Tools***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Soldering iron and solder
  prefs: []
  type: TYPE_NORMAL
- en: Drill and drill bits (1/2, 1/4, and 1/8 inches)
  prefs: []
  type: TYPE_NORMAL
- en: Philips head and slotted screwdrivers
  prefs: []
  type: TYPE_NORMAL
- en: Saw (keyhole or saber saw)
  prefs: []
  type: TYPE_NORMAL
- en: '***Parts List***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: One Arduino Pro Mini or clone
  prefs: []
  type: TYPE_NORMAL
- en: Two IR LEDs, about 650–850 nm Two IR photosensors (I used the Honeywell Optoschmitt
    SA5600.)
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Some users have had trouble matching the IR LEDs with the Optoschmitt photosensors.
    If you run into this problem, try the Honeywell SE3450/5450 or equivalent. Another
    option is to use two Adafruit IR Break Beams (part #2167) instead of the separate
    LEDs and sensors. The IR Break Beams will work for the Chronograph Lite, but the
    output must be inverted for the full version.)*'
  prefs: []
  type: TYPE_NORMAL
- en: One 270-ohm, 1/8 W resistor (Optional) Two 10-kilohm, 1/8 W resistors (if using
    phototransistors rather than Optoschmitt photosensors)
  prefs: []
  type: TYPE_NORMAL
- en: One channel holding two LED/sensor pairs One 16×2 LCD
  prefs: []
  type: TYPE_NORMAL
- en: One I²C adapter, if not included with the LCD One x4 adapter housing (see “[Connectors
    Used in This Book](ch00.xhtml#ch00lev1sec6)” on [page 18](ch00.xhtml#page_18))
  prefs: []
  type: TYPE_NORMAL
- en: Four female pins for housing (see “[Connectors Used in This Book](ch00.xhtml#ch00lev1sec6)”
    on [page 18](ch00.xhtml#page_18))
  prefs: []
  type: TYPE_NORMAL
- en: One SPST switch One momentary NO switch
  prefs: []
  type: TYPE_NORMAL
- en: One 9V battery connector
  prefs: []
  type: TYPE_NORMAL
- en: One 9V battery
  prefs: []
  type: TYPE_NORMAL
- en: One Hammond 1591 BTCL enclosure or equivalent
  prefs: []
  type: TYPE_NORMAL
- en: Two 7 1/2 × 1 1/2 × 0.06–inch aluminum pieces
  prefs: []
  type: TYPE_NORMAL
- en: One 1 3/8 × 7 1/2–inch piece of 1 3/8-inch acrylic sheet
  prefs: []
  type: TYPE_NORMAL
- en: 'Two #10-24×1-inch nylon screws'
  prefs: []
  type: TYPE_NORMAL
- en: 'Two #10×24 nylon nuts'
  prefs: []
  type: TYPE_NORMAL
- en: Four 4-40×1/2-inch screws
  prefs: []
  type: TYPE_NORMAL
- en: Eight 4-40 nuts
  prefs: []
  type: TYPE_NORMAL
- en: Four 4-40 washers
  prefs: []
  type: TYPE_NORMAL
- en: Assorted 28-gauge hookup wire
  prefs: []
  type: TYPE_NORMAL
- en: '***Downloads***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '**Sketch** *ChronographLite.ino*'
  prefs: []
  type: TYPE_NORMAL
- en: '**Templates** *PanelCutoutLite.pdf, PanelCutout.pdf, AccelerationChannel.pdf*'
  prefs: []
  type: TYPE_NORMAL
- en: '***The Schematic***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Outside the Arduino board, the circuitry for this project is not very complex.
    The schematic in [Figure 8-3](ch08.xhtml#ch08fig8-3) uses the I²C bus to power
    the LCD, two connections for the photosensors, and two connections for the clear
    switch.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/fig8_3.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 8-3: The schematic of the Chronograph Lite. The primary schematic shows
    the phototransistors and the alternate section shows the Honeywell Optoschmitt
    sensors (bottom left)*.'
  prefs: []
  type: TYPE_NORMAL
- en: '***Building a Test Bed***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '[Figure 8-4](ch08.xhtml#ch08fig8-4) shows the test bed that was used to prove
    the concept and develop the sketch. I suggest you build your own and install your
    LEDs and photosensors into it before building the breadboard.'
  prefs: []
  type: TYPE_NORMAL
- en: For this test bed, I cut two pieces of cardboard approximately 2×6 inches and
    punched them to fit two pairs of IR LEDs and phototransistors that were spaced
    3 inches apart. I then screwed the cardboard to a 1-inch-thick piece of wood,
    though you could glue or staple it if you prefer. When you build yours, be sure
    that each phototransistor is directly opposite an IR LED in the channel.
  prefs: []
  type: TYPE_NORMAL
- en: 'After installing the IR LEDs and phototransistors into the test bed, I recommend
    preparing them for the breadboard as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Connect the two IR LED anodes with a piece of wire by soldering or wire-wrapping.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Solder one 24-inch length of wire to the combined LED anodes. If you’re using
    solid-core wire that fits in a breadboard, you can just strip the other end of
    the 24-inch wire. If you’re using stranded-core wire, attach a male crimp pin
    to the end of the wire.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Connect the two IR LED cathodes with a piece of wire by soldering or wire-wrapping.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Connect the two phototransistor emitters with a wire by soldering or wire-wrapping.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Connect the combined IR LED cathodes to the combined phototransistor emitters;
    I suggest soldering a long wire.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Solder a 24-inch length of wire to the combined LED cathodes and phototransistor
    emitters, and finish the other end of the wire with a male crimp pin, as you did
    in step 2.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Solder a 24-inch length of wire to each phototransistor’s collector, and finish
    the other end of the wire with a male crimp pin, as you did in step 2.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In [Figure 8-4](ch08.xhtml#ch08fig8-4), the LEDs and light sensors (these will
    be phototransistors or Honeywell Optoschmitt sensors depending on your choice)
    are placed in holes punched in the cardboard of the acceleration channel.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/fig8_4.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 8-4: The test bed I initially used to check out the chronograph concept*'
  prefs: []
  type: TYPE_NORMAL
- en: I used a relatively small hole punch so that friction would hold them in place.
    You could instead glue them with hot glue or contact cement. I used a 24-inch
    length of four-conductor telephone wire to connect the channel to the breadboard,
    but any wire will do. In the completed version and in other prototypes, I just
    used four lengths of 30-gauge twisted wire because it was more flexible. Alternatively,
    you could build the final sensor channel now.
  prefs: []
  type: TYPE_NORMAL
- en: The LEDs and phototransistors will need to be wired to the Arduino, as indicated
    in the schematic diagram in [Figure 8-3](ch08.xhtml#ch08fig8-3). I wired the LED
    anodes to the power supply through a 270-ohm resistor (R3). In the case of the
    phototransistors, I set them up so that the emitters were grounded and each collector
    went through a 10-kilohm resistor (R1 and R2) to the positive of the power supply
    for an open-collector configuration. Thus, if the beam of light were interrupted,
    the phototransistor would conduct, and the voltage at the collector would drop.
  prefs: []
  type: TYPE_NORMAL
- en: '****NOTE****'
  prefs: []
  type: TYPE_NORMAL
- en: '*If you use the Honeywell Optoschmitt SA5600/5610, the 10-kilohm resistors
    (R1 and R2) are not required, as they are included in the SA5600/5610 chip. The
    wiring of the Optoschmitt sensors is shown in the lower left of the schematic
    in [Figure 8-3](ch08.xhtml#ch08fig8-3)*.'
  prefs: []
  type: TYPE_NORMAL
- en: Rather than shooting up the office with live paintballs, BBs, or pellets, I
    set up the gig vertically so a projectile could be dropped through the light beams
    to test the system. This method meant that the velocities measured didn’t approach
    those of a projectile leaving a weapon’s barrel, but it was good enough for an
    initial proof-of-concept experiment. The higher the target was dropped from, the
    higher the recorded velocity—that is, if your aim is good. (Remember *s* = (1/2)*at*²,
    where *s* is displacement or distance, *a* is acceleration due to gravity, *t*
    is time, and initial velocity is zero.)
  prefs: []
  type: TYPE_NORMAL
- en: If ambient light causes problems in testing, an additional piece of cardboard
    can be taped to the top (side) of the two pieces of cardboard to shade the sensor,
    though I didn’t find this was a problem in any of the experiments I conducted.
  prefs: []
  type: TYPE_NORMAL
- en: '***The Breadboard***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The next step is to build a breadboard, as shown in [Figure 8-5](ch08.xhtml#ch08fig8-5).
    For this, we’ll use the Chronograph Lite schematic in [Figure 8-3](ch08.xhtml#ch08fig8-3).
    The most complicated part of the circuit is wiring up the photosensors and LEDs,
    which are not plugged directly into the breadboard but rather need to be installed
    in the sensor channel, as described in the previous section.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/fig8_5.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 8-5: Photosensors and LEDs in the early prototype attached to the breadboard
    via discrete wires. To test the unit, a coin was dropped through the channel*.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Whether you have already made the finished channel or are using the cardboard
    prototype, you will need to connect the sensors and LEDs in the channel to the
    breadboard—or, for that matter, to the completed unit—with four wires: positive,
    ground, first sensor, and second sensor.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s how to wire the breadboard:'
  prefs: []
  type: TYPE_NORMAL
- en: Connect the red positive rails together and the blue negative rails together.
    Do not connect the red positive rail and blue negative rail to each other under
    any circumstances—it will result in a short circuit and damage to components.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Insert the Arduino Pro Mini or clone in the breadboard, leaving a fair amount
    of room—about four or five rows—at one end.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Connect the VCC pin on the Mini to the red positive rail.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Connect the GND pin on the Mini to the blue negative rail.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Take two 10-kilohm resistors (R1 and R2) and connect one end of each to the
    red positive rail. (Note that these are not required if you are using the Optoschmitt
    SA5600 photosensor.)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Connect the other end of resistor R1 to pin D4 on the Mini via a jumper wire.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Connect the other end of resistor R2 to pin D2 on the Mini via a jumper wire.
    (If you use the Optoschmitt photosensor, you can connect pins D2 and D4 directly
    to the output pins on the photosensors, as shown in the bottom left of [Figure
    8-3](ch08.xhtml#ch08fig8-3).)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Connect the collector pin of phototransistor Q1 to pin D2 on the Nano using
    the attached 24-inch wire.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Connect the collector pin of phototransistor Q2 to pin D4 on the Nano using
    the attached 24-inch wire.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Connect one end of the 270-ohm resistor R3 to the red positive rail.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Connect the other end of resistor R3 through one of the 24-inch lengths of wire
    to an empty row on the breadboard.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Connect the combined anodes of LED 1 and LED 2 to the row where you connected
    resistor R3 in step 9 via the attached 24-inch wire. Refer to [Figure 8-3](ch08.xhtml#ch08fig8-3)
    to see how the LEDs are wired together and to the breadboard.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Connect the 5V pin and the GND pin on the Mini to VCC and GND on the LCD, respectively.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Connect pin A4 on the Mini to the SDA connection on the LCD.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Connect pin A5 on the Mini to the SCL connection on the LCD.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now you’re ready to enter the sketch.
  prefs: []
  type: TYPE_NORMAL
- en: '***The Sketch***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Now to write the sketch to make things work. Here is the sketch for the Chronograph
    Lite:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The sketch is pretty straightforward. After setting up the variables and inputs,
    a `while` loop waits for the first sensor to be interrupted by checking the condition
    `digitalRead(2) == 1` ➊. When tripped, the clock is started with `start_time =
    micros();` ➋, and another `while` loop counts until the second sensor is activated
    (because the second sensor is plugged into pin D4, this `while` loop checks whether
    `digitalRead(4) == 1` ➌). When the second sensor is activated, the clock is stopped
    with `stop_time = micros()` ➍.
  prefs: []
  type: TYPE_NORMAL
- en: The sketch then calculates the time that lapsed between the first sensor and
    the second with `time_of_flight = stop_time – start_time` at ➎. Once the sketch
    makes its calculations, it provides instructions to display the results on the
    LCD screen.
  prefs: []
  type: TYPE_NORMAL
- en: All you need to do now is load the sketch, stand the test channel up as in [Figure
    8-4](ch08.xhtml#ch08fig8-4), and drop a projectile like a marble through the cardboard
    channel. To begin, power the Mini with the programmer. Alternatively, you can
    use a separate regulated 5V power supply connected to the 5V terminal on the Mini,
    or you can connect a battery to the VIN port of the Mini and use the Mini’s on-board
    regulator. Do *not* connect a 9V battery to the 5V supply rails—it could burn
    everything out.
  prefs: []
  type: TYPE_NORMAL
- en: When you’re satisfied that the sensors are working, you can attach your temporary
    sensor channel to a real air pistol if you’d like to test the circuit further
    (see [Figure 8-6](ch08.xhtml#ch08fig8-6)).
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/fig8_6.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 8-6: Photoelectric sensors in an early prototype, attached to a Crossman
    0.177 caliber air pistol. The setup was obviously primitive, using a C-clamp to
    hold the channel to the weapon. Because the test channel was so simple, I set
    it up on my desk*.'
  prefs: []
  type: TYPE_NORMAL
- en: If this is enough for your needs, you can package this up and skip everything
    in “[The Full Ballistic Chronograph](ch08.xhtml#ch08lev1sec3)” on [page 233](ch08.xhtml#page_233).
    The Chronograph Lite should work well for games and low- and medium-velocity weapons
    (less than 600 fps), such as pellet guns, BB guns, airsoft weapons, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: Despite satisfactory performance, however, I was bothered by the fact that,
    while the Arduino can count microseconds, it can deliver results only as multiples
    of four, so in reality the resolution is only 4 microseconds. That is why I developed
    the Full Ballistic Chronograph project. If this bothers you, too, and you don’t
    plan to package up the Chronograph Lite, you can skip to “[The Full Ballistic
    Chronograph](ch08.xhtml#ch08lev1sec3)” on [page 233](ch08.xhtml#page_233) now.
  prefs: []
  type: TYPE_NORMAL
- en: '**TESTING THE CHRONOGR APH LITE WITH A PROJECTILE SIMUL ATOR**'
  prefs: []
  type: TYPE_NORMAL
- en: To test the Chronograph Lite or Full Ballistic Chronograph for errors, I made
    a simulator to simulate the effect of a projectile traveling through the two sensors
    rather than shooting up my work area with pellets or paintballs. I primarily used
    the simulator in development—it is not necessary for the completion or use of
    either chronograph in this chapter—but it provides some insight into how to turn
    on and off relatively high-speed signals.
  prefs: []
  type: TYPE_NORMAL
- en: I used a square-wave generator (see [Chapter 9](ch09.xhtml#ch09) if you want
    to create your own) and made a very simple breadboard simulator. The schematic
    of the simulator, shown in [Figure 8-7](ch08.xhtml#ch08fig8-7), includes only
    the turn-on and turn-off functions and is driven by the square-wave generator.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/fig8_7.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 8-7: Schematic of the simulator used to simulate the sequential firing
    of the Optoschmitt sensors. It is used in conjunction with a square-wave generator.
    Resistor R1 and capacitor C1 can be adjusted for satisfactory debounce, but the
    values shown worked well. (continued)*'
  prefs: []
  type: TYPE_NORMAL
- en: The simulator receives a clock signal from the square-wave generator. On initiation,
    depressing the switch (labeled SW in [Figure 8-7](ch08.xhtml#ch08fig8-7)) on the
    simulator begins the sequence of start and stop signals from the CD4017 decade
    counter. A manual switch (SW) fires the simulator after a debounce from a NE 555
    timer. The function of the simulator is to turn the connections to the photosensors
    on and off just as if a projectile were traveling through the start and stop LED/photosensor
    pair. [Figure 8-8](ch08.xhtml#ch08fig8-8) shows a breadboard for the simulator
    with the finished board and square-wave generator.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/fig8_8.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 8-8: The simulator breadboard and the square-wave generator hooked
    up to the finished prototype board for the Full Ballistic Chronograph. The simulator
    works equally well with either the Chronograph Lite or the Full Ballistic Chronograph*.'
  prefs: []
  type: TYPE_NORMAL
- en: '***Construction***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: To complete the Chronograph Lite project, all you have left to do is to package
    the Mini, display, battery, and appropriate switches in an enclosure, leaving
    a connector exposed to connect the unit to the sensor channel. Unlike most of
    the other projects in this book, I did not use a shield for the Chronograph Lite,
    because the wiring to the Mini was sufficiently
  prefs: []
  type: TYPE_NORMAL
- en: straightforward that it did not require one. I used a Hammond ABS plastic enclosure
    1591 BTCL, as indicated in the parts list. See [Figure 8-9](ch08.xhtml#ch08fig8-9)
    for the completed Chronograph Lite.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/fig8_9.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 8-9: Front view of completed Chronograph Lite. A hole is cut into the
    enclosure to the right of the screen to allow space for the backlight protrusion*.'
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 8-10](ch08.xhtml#ch08fig8-10) shows the template for the enclosure.
    You can download a PDF of this drawing from *[https://www.nostarch.com/arduinoplayground/](https://www.nostarch.com/arduinoplayground/)*
    and use it to mark and center punch the enclosure for the holes.'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/fig8_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 8-10: Template for holes and display for the Chronograph Lite*'
  prefs: []
  type: TYPE_NORMAL
- en: 'I prepared the enclosure for the Chronograph Lite as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Carefully mark, center punch, and drill 1/2-inch holes for the corners of the
    display (A), 1/8-inch holes for the mounting holes for the display (B), 1/4-inch
    holes for the on/off switch (C), and 1/4-inch holes for the clear switch (D).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: For the LCD screen, mark the edges of the 1/2-inch holes (A). Draw lines connecting
    the edges so you have a rectangle to cut out. (You can use a Sharpie marker and
    clean excess markings later with alcohol.) Drill the holes and cut the opening
    along those lines using a keyhole or saber saw.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: There’s a slight protrusion in the middle of the LCD on the right-hand side
    (facing up); this is part of the backlight assembly. You can cut a hole to accommodate
    for this, as I did in [Figure 8-10](ch08.xhtml#ch08fig8-10), or you can leave
    the edge straight and use spacers to keep the protrusion from hitting the enclosure.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Mount the display and fasten it in with 1/2-inch-long 4-40 mounting screws and
    nuts. If you made a cut out for the LCD backlight protrusion, you can mount the
    display directly. If you did not, use extra 4-40 nuts to space the display back
    from the face of the enclosure. If needed, add additional washers; 4-40 nuts can
    vary in thickness.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Mount the *on* and *clr* switches as indicated in [Figure 8-9](ch08.xhtml#ch08fig8-9).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now to wire up the Pro Mini. There is no shield, so we will solder directly
    to the Pro Mini board as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Solder the wires for the I²C connection. To make your life easier, use colored
    wire and create a code for yourself. Solder connections to the 5V (some clone
    boards may say VCC) and GND pins on the Nano. Then, solder 3-inch wires to pins
    A4 and A5 on the Nano. Connect the other end of these wires to a four-pin female
    connector. (See “[Connectors Used in This Book](ch00.xhtml#ch00lev1sec6)” on [page
    18](ch00.xhtml#page_18) for details on making Pololu connectors.) Connect the
    5V and GND pins on the Nano to 5V and GND on the LCD. Connect pin A4 on the Nano
    to SDA on the I²C board, and A5 on the Nano to SDL on the I²C.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Connect the positive (red) wire of the battery connector to one side of the
    SPST switch. Connect the other side of the switch to the VIN terminal on the Nano
    (some clone boards may say RAW).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Solder the black (negative) wire from the battery connector to the GND pin on
    the Nano.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Finally, connect the Nano to the sensor channel as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Prepare a four-conductor female Pololu connector with four color-coded wires
    approximately 3.5 inches long. Attach two wires (I suggest red and black) from
    this connector to the VCC and GND pins on the Nano.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Connect the remaining two connectors to pins 2 (D2) and 4 (D4) on the Nano.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Make a slot or hole in the side of the enclosure, and run the Pololu connector
    with the sensor channel connections through it (see [Figure 8-11](ch08.xhtml#ch08fig8-11)).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![image](../images/fig8_11.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: '*Figure 8-11: A slot in the enclosure for threading the four-pin sensor channel
    connector through. The connector is mounted with double-sided adhesive*'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Connect one side of the *clr* pushbutton to GND and the other side to the RST
    (reset) pin on the Nano.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally, connect the battery, screw on the top of the enclosure, plug in the
    sensor channel, and flip the switch to turn on the device.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You should be all set to use your Chronograph Lite. Go to “[Final Setup and
    Operation](ch08.xhtml#ch08lev1sec5)” on [page 252](ch08.xhtml#page_252) for instructions
    on using the Chronograph Lite.
  prefs: []
  type: TYPE_NORMAL
- en: '**The Full Ballistic Chronograph**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: While the Chronograph Lite worked well and I used it to successfully measure
    projectile speeds, I had a nagging feeling that it could be better. If you’re
    using the device for slow-speed projectiles—that is, 600 fps or less—the accuracy
    of the Chronograph Lite is more than enough. But the restriction to 4 microseconds
    of resolution resulted in what I perceived to be a fair amount of error in feet-per-second
    (fps) at higher speeds, so I decided to construct the Full Ballistic Chronograph.
  prefs: []
  type: TYPE_NORMAL
- en: '***Required Tools***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Soldering iron and solder
  prefs: []
  type: TYPE_NORMAL
- en: Drill and drill bits (1/2, 1/4, and 1/8 inches) Philips head and slotted screwdrivers
    Saw (keyhole or saber saw)
  prefs: []
  type: TYPE_NORMAL
- en: '***Parts List***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Assembling the Full Ballistic Chronograph is relatively simple. Here’s what
    you’ll need:'
  prefs: []
  type: TYPE_NORMAL
- en: One Arduino Nano or clone
  prefs: []
  type: TYPE_NORMAL
- en: One 16×4 LCD
  prefs: []
  type: TYPE_NORMAL
- en: One I²C adapter, if not included with the LCD One PCB shield
  prefs: []
  type: TYPE_NORMAL
- en: One enclosure (Hammond 1591 BTCL)
  prefs: []
  type: TYPE_NORMAL
- en: Four 1/2-inch×4-40 screws Four 4-40 nuts
  prefs: []
  type: TYPE_NORMAL
- en: One 3PDT toggle switch
  prefs: []
  type: TYPE_NORMAL
- en: Two momentary pushbutton switches Four 0.100×4 female headers
  prefs: []
  type: TYPE_NORMAL
- en: Four female X4 shells
  prefs: []
  type: TYPE_NORMAL
- en: Sixteen (eight male, eight female) adapter pins One 4 MHz crystal
  prefs: []
  type: TYPE_NORMAL
- en: One TI SN 74LVC1GX04 crystal-oscillator driver One SOT23 adapter board
  prefs: []
  type: TYPE_NORMAL
- en: One HCT 4011 4-input NAND gate One CD4013 dual D flip-flop
  prefs: []
  type: TYPE_NORMAL
- en: One CD4040 12-stage binary counter One ADC DAC8562 digital-to-analog converter
    One LM7805 voltage regulator
  prefs: []
  type: TYPE_NORMAL
- en: One NPN transistor 2N5172 (or equivalent) Four 5-kilohm, 1/8 W resistors
  prefs: []
  type: TYPE_NORMAL
- en: One 1-megaohm, 1/8 W resistor
  prefs: []
  type: TYPE_NORMAL
- en: One 1-kilohm, 1/8 W resistor
  prefs: []
  type: TYPE_NORMAL
- en: One 1.5-kilohm, 1/8 W resistor
  prefs: []
  type: TYPE_NORMAL
- en: One 270-kilohm, 1/8 W resistor
  prefs: []
  type: TYPE_NORMAL
- en: One 4.7 MFD tantalum capacitor Two 33 pF capacitors
  prefs: []
  type: TYPE_NORMAL
- en: One 0.01 μF capacitor
  prefs: []
  type: TYPE_NORMAL
- en: One 5 mm LED
  prefs: []
  type: TYPE_NORMAL
- en: Two IR detectors (I used the Honeywell Optoschmitt SD5610.) Two IR LEDS, about
    850–950 nm 28- or 30-gauge hookup wire
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*For the Full Ballistic Chronograph, you will have to use the inverted version
    of the chip, the SA5610, or externally invert the signals. See the note at the
    bottom of [Figure 8-3](ch08.xhtml#ch08fig8-3)*.'
  prefs: []
  type: TYPE_NORMAL
- en: '***Downloads***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '**Sketch** *FullBallisticChronograph.ino*'
  prefs: []
  type: TYPE_NORMAL
- en: '**Templates** *ChronoCover.pdf, AccelerationChannel.pdf*'
  prefs: []
  type: TYPE_NORMAL
- en: '**PCBs** *ChronoPCB.pcb, LEDHolder.pcb, SensorHolder.pcb*'
  prefs: []
  type: TYPE_NORMAL
- en: '***Improving the Accuracy***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: There are several possible solutions for improving the accuracy of the chronograph.
    The Arduino Nano uses a 16 MHz clock, yet when configured using the Arduino Nano
    platform and IDE, it results in a 1 microsecond resolution (±2 microseconds),
    even though the period—the time between cycles—of a 16 MHz clock is 1/16,000,000
    of a second, or 0.063 micro seconds. While a processor could never resolve down
    to its own clock speed, it’s probably capable of much better than 1 microsecond.
    Clearly there is some overhead in the current project—perhaps part hardware (the
    components in the Arduino board) and part software (the compiler and firmware
    part of the IDE)—that limits performance. Here are some ideas I had to improve
    accuracy, starting with one that didn’t make it into the final project but that
    I think is educational.
  prefs: []
  type: TYPE_NORMAL
- en: '**Digging into Machine Code**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: One possible solution is to dig into the basic Atmel machine and AVR code. Without
    going into excruciating detail, AVR assembly is the functional language of the
    Atmel chip. The Arduino community has surrounded that with special code that lets
    the AVR run in the Arduino environment.
  prefs: []
  type: TYPE_NORMAL
- en: According to the ATmega328 data sheets, it’s possible to directly address the
    individual timers on the ATmega328 and get the resolution required. However, looking
    into it, I saw that this method could prove overly complex and figured there had
    to be another way.
  prefs: []
  type: TYPE_NORMAL
- en: '**Creating a High-Speed Window**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: The time of flight of a projectile that we want to look at covers a range of
    roughly 90 microseconds (about 3,000 fps in a 3-inch distance) to 950 microseconds
    (about 260 fps in the same 3-inch distance) from fastest to slowest. Relative
    to the higher frequencies of some clocks, such as the 16 MHz clock of the processor,
    90 microseconds is a fair amount of time.
  prefs: []
  type: TYPE_NORMAL
- en: One method for measuring the velocity is to open a timing window when the first
    beam of light is interrupted that lets a stream of high-speed signal through until
    the second beam is interrupted. While the window is open, the pulses in that signal
    will be counted; when the window is closed, the count will represent the time
    the window was open.
  prefs: []
  type: TYPE_NORMAL
- en: 'As an example, say the window opens and a signal of 10 cycles per second (cps)
    passes through until the window closes; 100 cycles are counted. For this illustration,
    the Arduino’s clock is the high-speed signal. When you know the distance the projectile
    traveled, you can use some simple arithmetic to determine the time of travel and
    the speed: 100 cycles at 10 cps gives us 10 seconds. If the distance were 1 meter
    and 100 cycles were counted while the window was open, the speed would be 1 meter
    per 10 seconds or 0.1 m/s.'
  prefs: []
  type: TYPE_NORMAL
- en: A single NAND logic gate can be used to make a window that can be opened and
    closed. A *logic gate* is simply an electronically controlled switch that outputs
    a voltage only under certain conditions, corresponding to a Boolean logic equation.
    *NAND* is the Boolean expression for “not AND,” and a *NAND gate* outputs a voltage
    when its two inputs are not the same.
  prefs: []
  type: TYPE_NORMAL
- en: I sampled both a 74HC00 high-speed NAND gate and a standard CD4011BC gate, and
    the standard part works fine. There are several other parts that will work, too—what
    you’re looking for is a part with a propagation delay (T[PD]) under 100 nanoseconds.
  prefs: []
  type: TYPE_NORMAL
- en: '**Selecting a Counter**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: After deciding to take the window approach, the next thing to consider is how
    high you need to count. If you were to count in integers from 1 to 100, for example,
    you would need a counter that could count to 100, which would provide a resolution
    of 100\. If you scaled that up, the counter could provide a range from 10 to 1,000
    or from 100 to 10,000\. If that range were the result of the calculation for fps,
    you would then have a resolution of only 1,000 fps (each increment would equal
    100 fps) plus any included error, which we’ll go into later.
  prefs: []
  type: TYPE_NORMAL
- en: So where should you go from here? To the parts bin, of course, to see what counters
    are available to count the signal passing through that window. When selecting
    a counter, you need to consider how fast it needs to be and how many pulses you
    want it to count. The tried-and-true CD4040, 12-bit, serial-in, parallel-out,
    digital counter seemed capable of doing the job. (The CD4040 worked at the 4 MHz
    frequency, but you could always use a faster one, like the 74HC4040 or 74HCT4040.)
    The CD4040 will provide a digital count from 0 to 4095, or 2^(12).
  prefs: []
  type: TYPE_NORMAL
- en: '**Selecting a Clock Speed**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Next, consider what signal frequency is needed in order to suit the range of
    projectile speeds. I started with the assumption that I wanted to achieve a
  prefs: []
  type: TYPE_NORMAL
- en: range of roughly 300 fps to 2,500 fps with as much latitude on both ends as
    possible.
  prefs: []
  type: TYPE_NORMAL
- en: Further, while the counter will ideally count from zero to the maximum 4,095
    counts, there is the possibility of some error. So rather arbitrarily, I chose
    to look at the total digital count between 400 and 4,000 to account for the possibility
    of error.
  prefs: []
  type: TYPE_NORMAL
- en: 'Given the number of cycles counted, the signal frequency, and the distance
    traveled, the velocity of a projectile can be found with the following calculations:'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f0237-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Let’s go through the arithmetic for a projectile that travels 0.25 feet (3
    inches) within 4,000 cycles of a 2 MHz signal:'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f0237-02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: For a 4 MHz clock, a full 4,000 cycle count will amount to about 281 fps for
    the low end of the speed range. At the high end, given 400 cycles counted and
    a 2 MHz clock signal, you will measure 1,250 fps, and at 4 MHz, you can measure
    up to 2,500 fps.
  prefs: []
  type: TYPE_NORMAL
- en: You can be creative with your frequency. If you elect to use a 2 MHz clock,
    it will provide maximum resolution in the very low-speed range. If, on the other
    hand, you select a 4 MHz clock, you will be in the middle of the resolution range.
    An 8 MHz clock will provide a very good resolution in the fast range (faster than
    any conventional weapon) but will curtail performance at the lower-speed range.
  prefs: []
  type: TYPE_NORMAL
- en: Because I anticipated that the bulk of speeds I needed to measure would fall
    in the middle of the counting range, a clock around 4 MHz sounded good. I was
    not anticipating many occasions when velocities would be in the sub-300 fps range,
    and at the high end, it looked like accuracy could be maintained to well over
    5,000 fps (a digital count of just under 200, which might be stretching it a little
    but seemed to work well in simulations).
  prefs: []
  type: TYPE_NORMAL
- en: If your projectiles remain in the sub-300 fps range, I suggest revisiting the
    Chronograph Lite. If, for some reason, you want to stay in the lower fps range
    but require maximum accuracy with perhaps multiple digits, build the Full Ballistic
    Chronograph with the slower clock rate. You can simply swap out the 4 MHz crystal
    for a 2 MHz crystal and adjust the sketch to slide the range down to the lower
    area.
  prefs: []
  type: TYPE_NORMAL
- en: '**Adjusting the Clock Speed**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: To address the speed of the clock (the signal that is gated to the counter),
    the most accurate method by far is to use a crystal-controlled oscillator, which
    generally has errors only in the sub-50 parts per million range. I configured
    a 4 MHz crystal with the TI SN 74LVC1GX04 crystal-oscillator driver experimentally
    and it worked well, so I used one in the final project.
  prefs: []
  type: TYPE_NORMAL
- en: While I did look at, review, and test single-chip oscillators, such as the Maximum
    stand-alone oscillator (7375), it was not quite as stable as the crystal-controlled
    version.
  prefs: []
  type: TYPE_NORMAL
- en: '***Designing the Full Ballistic Chronograph***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Now, we have the means to clock the signal into the 4040 counter, but we need
    to figure out how to display the velocity on the LCD. One method would be to use
    a different counter with a serial output that would be clocked directly into the
    Nano. Another possibility would be to take the parallel data from the CD4040,
    serialize it with a shift register, and feed the result to the Nano.
  prefs: []
  type: TYPE_NORMAL
- en: However, I took a different direction, as illustrated in the block diagram in
    [Figure 8-12](ch08.xhtml#ch08fig8-12). I decided to use a 12-bit digital-to-analog
    converter (DAC) to accept the parallel digital signals and convert them to a single
    analog value. DACs and their counterpart, analog-to-digital converters (ADCs),
    are used in digital music, TVs, and a host of other areas where an analog input
    needs to be digitized, manipulated, transferred, stored, and eventually output
    to return an analog signal. I thought this would be a good opportunity to introduce
    the capabilities of digital-to-analog converters.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/fig8_12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 8-12: Block diagram of the Full Ballistic Chronograph*'
  prefs: []
  type: TYPE_NORMAL
- en: The process in [Figure 8-12](ch08.xhtml#ch08fig8-12) depicts the operation of
    the chronograph using a simulator. In actual operation, the simulator would be
    replaced with the two LED-sensor pairs. The simulator, under control of the firing
    switch, initiates a start signal that remains active until the second stop switch
    is activated after a period determined by the square-wave generator. This essentially
    simulates the projectile passing through the first and then the second pair of
    sensors.
  prefs: []
  type: TYPE_NORMAL
- en: When the start switch is activated initially, it turns on the *flip-flop*—a
    bistate device that turns on with the activation of the start switch and remains
    on until the stop switch is activated. The flip-flop feeds the trigger of the
    gate. When the trigger (T) is inactive—that is, when it’s set to a logical 0—the
    signal from the oscillator at input (A) cannot go through the gate to output (B).
    When the trigger is activated (set to a logical 1), the gate allows the signal
    from the oscillator (A) to travel through the gate to output (B) and eventually
    to the input of the binary counter. The binary counter counts the number of pulses
    that pass from the oscillator through the gate and stops counting when the gate
    closes.
  prefs: []
  type: TYPE_NORMAL
- en: The outputs of the binary counter are fed to the DAC. They represent binary
    numbers from 0 through 4,095—that is, 0 through 2^(12) – 1\. The DAC converts
    these digital values to a single analog value. The technique of this conversion
    depends on the type of DAC used; for example, in the DAC8562 used here, an R-2R
    resistor ladder is switched, and a transistor is used to yield the output. (For
    complete information, look up the data sheet from Analog Devices on the DAC8562.)
  prefs: []
  type: TYPE_NORMAL
- en: The output of the DAC has a scale of 0V to 4.095V corresponding to the digital
    inputs. This output is then directed to one of the analog inputs on the Arduino
    Nano, which provides the inverse function of the DAC and converts the analog signal
    back into a digital format that the Nano can handle. The Nano takes that signal
    and, following instruction from the sketch, adjusts the value to represent the
    velocity in fps for the time it takes the projectile to travel the 3 inches. The
    Nano finally sends that data to the LCD, which displays the velocity of the projectile
    and travel time.
  prefs: []
  type: TYPE_NORMAL
- en: '***The Schematic***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Figures 8-13 and 8-14 show the schematic diagrams for the completed Full Ballistic
    Chronograph. Note the extra gates at the bottom. I included these in the schematic
    because they are available to you in the NAND gate and flip-flop IC packages suggested
    for this project, but my design does not use them. If you want to add functionality,
    they are available.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/fig8_13.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 8-13: Schematic of the Full Ballistic Chronograph*'
  prefs: []
  type: TYPE_NORMAL
- en: Another thing included in the schematic that we haven’t covered is the reset
    button. In the Full Ballistic Chronograph, I included a button to trigger the
    reset rather than having it reset automatically. I could have set it so that the
    result was displayed on the LCD for a fixed period of time before the system reset,
    but it might have turned out that the number was erased before users had time
    to record it, or users may have found themselves sitting idle while it timed out.
    I decided a reset button would be more convenient.
  prefs: []
  type: TYPE_NORMAL
- en: Because resetting the microcontroller wasn’t going to upset the sequence of
    things, I chose to use a hard reset on the controller through transistor Q1\.
    To reset the CD4040 and the DAC, I used the reset signal and then inverted it
    using one of the CD4011’s four NAND gates with the two inputs tied together. SW2
    manually closes the second set of sensors in case the first pair of sensors fires
    and not the second, and SW3 is the power and battery switch.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/fig8_14.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 8-14: Inverters for Optoschmitt or Adafruit sensors if you use the
    SA5600 instead of the SA5610\. This circuit uses the previously unused gates of
    the CD4011 NAND gate as logic inverters. They are not accommodated for in the
    PCB, so you will have to wire them by hand*.'
  prefs: []
  type: TYPE_NORMAL
- en: '***The Sketch***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The sketch for the Full Ballistic Chronograph is relatively straightforward:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: In this sketch, the software receives an analog signal from the DAC at X and
    converts it to a digital value. It then goes through a couple of quick mathematical
    operations to come up with the time of flight (`Time`), calculates the speed in
    feet per second (`FPS`), and finally exports those values to the LCD.
  prefs: []
  type: TYPE_NORMAL
- en: In designing electronic circuits, there are always tradeoffs between hardware
    and software. Many of these have to do with timing issues and built-in latencies
    in software-based approaches. In this instance, the tradeoff is the need for greater
    accuracy not available with the straight Arduino IDE approach without dropping
    to some level of native code. To avoid native code, the Full Ballistic Chronograph
    has more complex hardware than the Chronograph Lite.
  prefs: []
  type: TYPE_NORMAL
- en: '***The Shield***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Unlike the Chronograph Lite, the Full Ballistic Chronograph is best built on
    a shield. The shield is a little more involved than some of the others in this
    book, but don’t be intimidated. [Figure 8-15](ch08.xhtml#ch08fig8-15) shows the
    actual traces of the shield, while [Figure 8-16](ch08.xhtml#ch08fig8-16) shows
    the silkscreen image with the part placements and hole configuration. For this
    project, I opted for a double-sided board because the circuit was a little more
    complex than some of the others and because it allowed me to minimize the space
    required. The complete PCB file is available for download at *[https://www.nostarch.com/arduinoplayground/](https://www.nostarch.com/arduinoplayground/)*.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/fig8_15.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 8-15: Trace patterns for the shield. The darker gray is the upper copper
    layer, and lighter gray is the lower layer*.'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/fig8_16.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 8-16: The component placement on the shield*'
  prefs: []
  type: TYPE_NORMAL
- en: I attempted to keep the shield footprint to a minimum to make it possible for
    the user to squeeze the system into a small portable enclosure. As is, the finished
    Full Ballistic Chronograph fits easily in a 11×8×4 cm box.
  prefs: []
  type: TYPE_NORMAL
- en: This is another case where I opted to outsource the PCB construction after I
    had made and refined the first sample myself and made sure all critical connections
    could be soldered on both sides of the board. [Figure 8-17](ch08.xhtml#ch08fig8-17)
    shows the raw board as it was received from the service bureau.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/fig8_17.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 8-17: The Full Ballistic Chronograph circuit board before population*'
  prefs: []
  type: TYPE_NORMAL
- en: '***Soldering the Full Ballistic Chronograph***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Once you have all your parts, follow this guide to build the Full Ballistic
    Chronograph:'
  prefs: []
  type: TYPE_NORMAL
- en: Prepare the oscillator adapter board by soldering the headers in place. Solder
    the chip to the adapter using one of the approaches suggested in “[Using SOICs](ch00.xhtml#ch00lev1sec7)”
    on [page 20](ch00.xhtml#page_20).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Begin populating the PCB. I usually like to start with the components that go
    under the Nano—in this case, the oscillator adapter board, resistors, crystal,
    and CD4011\. Place them in the PCB, as indicated in [Figure 8-15](ch08.xhtml#ch08fig8-15).
    Next, I like to include the headers that the Nano plugs into. Once again, it’s
    not necessary to fully populate all the headers for the Nano. While on occasion
    I do use a full complement of headers, I tend to populate only those with connections,
    as well as a pair at the very top, in order to simplify alignment when plugging
    in the Nano. Additionally, there should be enough to mechanically support the
    Nano. Solder these headers in place now.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Populate the balance of the board, including the headers for the I²C display
    and the sensor channel. Solder wire pigtails to the connections on the board for
    the reset and clear switches, LED, and positive and negative power supply. The
    lead sensor—the one that is interrupted by the projectile first—should be the
    one wired to pin 6 of the 4013, with or without the inverter circuit; the other
    sensor should be connected to pin 4.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '***Construction***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '[Figure 8-18](ch08.xhtml#ch08fig8-18) shows the positions for the holes and
    cutout in the enclosure. You can download a copy of [Figure 8-18](ch08.xhtml#ch08fig8-18)
    from *[https://www.nostarch.com/arduinoplayground/](https://www.nostarch.com/arduinoplayground/)*
    and use it as a template.'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/fig8_18.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 8-18: The holes and LCD cutout on the cover of the enclosure*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Prepare the enclosure for the Full Ballistic Chronograph as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Prepare the cover of the enclosure, as shown in [Figure 8-18](ch08.xhtml#ch08fig8-18),
    by drilling 1/2-inch holes for cutting out the LCD (A); 1/8-inch holes for mounting
    the LCD (B); 1/8-inch holes enlarged with a reamer for a tight fit for the 5 mm
    LED (F); and 1/4-inch holes for the momentary clear switch (D), momentary reset
    switch (E), and on/off switch (C).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Mark the edges of the 1/2-inch holes (A) and connect lines tangent to the holes—you
    can use a Sharpie marker and clean excess marks later with alcohol.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Cut the opening for the display using a keyhole or saber saw.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: There’s a slight protrusion in the middle of the LCD on the right-hand side
    (facing up). This is part of the backlight assembly. You can cut a hole to accommodate
    this, as I did on both the Full Ballistic Chronograph and Chronograph Lite, or
    you can leave the edge straight and use spacers to keep the protrusion from hitting
    the enclosure. Even though I cut a space for the protrusion, I used a one-nut
    spacer anyway to space the connections on the top of the screen away from the
    front of the enclosure (see [Figure 8-19](ch08.xhtml#ch08fig8-19)).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![image](../images/fig8_19.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: '*Figure 8-19: The four-conductor female connector is mounted to the side of
    the enclosure using double-sided adhesive*.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Mount the LCD’s I²C assembly to the front of the enclosure.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Mount the switches to the enclosure. Connect the switches and LED as shown in
    the schematic in [Figure 8-13](ch08.xhtml#ch08fig8-13). Use pigtailed wires as
    indicated in step 3 of “[Soldering the Full Ballistic Chronograph](ch08.xhtml#ch08lev2sec20)”
    on [page 244](ch08.xhtml#page_244).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Prepare cable assemblies to connect the shield to the I²C adapter and the 4-pin
    female connector that connects the Full Ballistic Chronograph to the sensor channel.
    (See “[Connectors Used in This Book](ch00.xhtml#ch00lev1sec6)” on [page 18](ch00.xhtml#page_18)
    if you’ve never built a connector yourself.)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Stick the shield to the bottom of the enclosure using double-sided adhesive.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Mount the battery holder using a 4-40 flathead screw or double-sided adhesive.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Make a cut in the side of the enclosure to feed the wires through to the connector
    for the sensor channel connection. The width of a single hacksaw blade is sufficient
    for 28-gauge wire.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Mount the connector for the sensor channel to the enclosure with double-sided
    adhesive, as shown in [Figure 8-19](ch08.xhtml#ch08fig8-19).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**The Sensor Channel**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We built a sensor channel test bed earlier in the chapter, but now we’ll build
    a more permanent sensor channel and look at the sensor and LED pair we’ll use
    inside.
  prefs: []
  type: TYPE_NORMAL
- en: '***Building the Sensor Channel***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The sensor channel is a U-shaped tunnel that fastens to the muzzle of a weapon
    and holds the photo detector/LED pairs that handle the switching. This channel
    can be constructed out of a variety of materials. I used a 3/8-inch section of
    acrylic and two pieces of 0.060-inch thick aluminum (see [Figure 8-20](ch08.xhtml#ch08fig8-20)).
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/fig8_20.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 8-20: The completed sensor channel shown from the top (right side up).
    Note the feed-through holes in the acrylic for the positive and negative power
    supply connections to the LEDs (boxed). Also note the current-limiting resistor
    on the PCB holding the LEDs (circled). The cross-hatch area is foam taped to protect
    the weapon’s slide from being scratched*.'
  prefs: []
  type: TYPE_NORMAL
- en: You could just as easily use mild sheet steel for the side pieces. The top piece,
    shown in [Figure 8-20](ch08.xhtml#ch08fig8-20), could be any lightweight material,
    such as phenolic, Lexan, or another plastic to support the side pieces. I chose
    clear acrylic because it allowed me to see the gun without having to look down
    the barrel. You can get a wider look at the whole channel, including the sensor
    cable, in [Figure 8-21](ch08.xhtml#ch08fig8-21).
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/fig8_21.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 8-21: The channel with the cable attached and the PCB mounted so that
    the connector faces toward the back (where the weapon attaches)*'
  prefs: []
  type: TYPE_NORMAL
- en: There are two PCBs, attached to either side of the channel with double-sided
    tape, to hold the LEDs and photosensors. These PCBs are slightly different from
    each other, as shown in [Figures 8-22](ch08.xhtml#ch08fig8-22) and [8-23](ch08.xhtml#ch08fig8-23).
    PCB files for these boards are available to download at *[https://www.nostarch.com/arduinoplayground/](https://www.nostarch.com/arduinoplayground/)*.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/fig8_22.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 8-22: The pattern for the PCB that holds the LEDs and mounts to the
    sensor channel. Note the current-limiting resistor*.'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/fig8_23.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 8-23: The PCB pattern for the phototransistor side of the sensor channel.
    Note the three pins for each phototransistor. The edge fingers are for soldering
    to headers that connect to the main processing and display board via an umbilical
    cable*.'
  prefs: []
  type: TYPE_NORMAL
- en: The acrylic top of the sensor channel measured 1 3/8 × 7 5/8 inches. I used
    a straight wooden dowel to line the barrel up with the sensors/LEDs. Note that
    there is a slight indentation, made with a 1/2-inch drill bit, in the top of the
    acrylic to allow for the optical sight of the Crossman T4 air pistol.
  prefs: []
  type: TYPE_NORMAL
- en: 'The aluminum sheets used for the sides measured 1 3/8 × 7 5/8 inches. I drilled
    the holes to fasten the aluminum sides to the acrylic top with a #30 drill bit
    and spaced the holes 1 inch apart. The acrylic was drilled with a #43 drill bit
    and tapped for 4-40 screws. See [Figure 8-24](ch08.xhtml#ch08fig8-24) for drilling
    specifications for both the acrylic and aluminum pieces. The holes for the acrylic
    are drilled through the width.'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/fig8_24.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 8-24: Dimensions for holes in the acrylic top and aluminum sides of
    the sensor channel. This template can be downloaded and used as a stencil for
    marking and center-punching holes*.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In addition, as a feed-through for the wires from the LED side to the photo
    detector side, I drilled two #43 holes on either side of the fourth mounting holes
    on both the acrylic and aluminum pieces. The exact location of these holes is
    not critical.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In addition to the holes for fastening the acrylic, the aluminum required two
    holes on each side for the LEDs and photo detector pairs, and another two holes
    on one side for mounting to the barrel (slide) of the gun (A and B in [Figure
    8-24](ch08.xhtml#ch08fig8-24)), drilled with a #25 drill and tapped for a 10-24
    screw. Check out how big the IR LEDs are. Most are 5 mm, and a 3/16-inch hole
    is generally a close fit. The Optoschmitt sensor also fits snugly in a 3/16-inch
    hole. The holes for the LEDs and photosensors can be measured exactly 3 inches
    apart, or you can measure them yourself to match with the PCBs mounted on the
    side.'
  prefs: []
  type: TYPE_NORMAL
- en: Depending on the weapon(s) you intend to use, you may want to adjust the positioning
    of holes A and B in [Figure 8-24](ch08.xhtml#ch08fig8-24). The sensor channel
    can also accommodate more tapped holes for multiple weapons. To mount the sensor
    channel to the top of the gun, I used nylon screws with locking nuts. The nylon
    screws were able to tighten against the blued-steel finish of the pistol without
    marring it.
  prefs: []
  type: TYPE_NORMAL
- en: The screws for mounting the gun worked well with the Crossman T4 as well as
    on an older Crossman pellet gun (see [Figure 8-25](ch08.xhtml#ch08fig8-25)).
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/fig8_25.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 8-25: The sensor channel mounted on an older Crossman pellet gun. This
    angle shows the top (acrylic) side of the channel*.'
  prefs: []
  type: TYPE_NORMAL
- en: On the inside of the channel, I placed some double-sided adhesive foam tape
    (if you can find a single-sided adhesive foam tape, all the better) to give it
    a more snug fit and protect the weapon from damage. I left the protective covering
    on the other side of the foam so it would not adhere to the weapon or mar the
    finish.
  prefs: []
  type: TYPE_NORMAL
- en: Depending on the weapon you are using, you might want to add an extra layer
    of foam to pad the channel so the center of the barrel is closer to the center
    of the channel. But as long as the barrel is not so far on either side that the
    projectile could strike either the LED or photo detector, centering the barrel
    perfectly is not critical.
  prefs: []
  type: TYPE_NORMAL
- en: It is critical, however, to center the vertical adjustment so the LED/detector
    pairs line up with the trajectory of the projectile. To set this alignment, I
    used a straight wooden dowel of the same diameter as the bore of the barrel, inserted
    it partially into the barrel of the weapon, and then adjusted the position so
    it lined up with the LED/detector pairs. Once it’s aligned, tighten the nylon
    screws to secure the channel to the weapon.
  prefs: []
  type: TYPE_NORMAL
- en: '***Optoschmitt Light Sensors and UV LEDs***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In preparing the sensor channel, I sampled several different types of LEDs and
    detectors to see which offered the best price and performance. Units purchased
    on eBay (UV LED and phototransistor pairs) worked well, and I used them in early
    prototype versions. However, I continued to search for a sensor that I was sure
    would be fast enough and provide good sensitivity in a narrow field, which helps
    to exclude ambient light. After reviewing several samples, I chose the Optoschmitt
    SD5610 detector from Honeywell—so named, I guess, because it includes Schmitt-trigger
    circuitry (see [Figure 8-26](ch08.xhtml#ch08fig8-26)).
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/fig8_26.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 8-26: Schematic for the Optoschmitt SD5610 detector I used in the chronograph.
    Note that the 10-kilohm pull-up resistor is included, but the inverter function
    is not included in the schematic*.'
  prefs: []
  type: TYPE_NORMAL
- en: The Optoschmitt SD5610 sensor is a little pricey, but it features a 6-degree
    acceptance angle, which worked well for projectiles of all sizes, including very
    small and large ones. It also reduced the effects of ambient light.
  prefs: []
  type: TYPE_NORMAL
- en: 'According to the manufacturer, the photodetector consists of a photodiode,
    amplifier, voltage regulator, Schmitt trigger, and an NPN output transistor with
    a 10-kilohm (nominal) pull-up resistor (see [Figure 8-26](ch08.xhtml#ch08fig8-26)).
    The internal pull-up resistor eliminates the need for an external resistor in
    the circuit. Note that there are two versions of this device: the SD5600 and the
    SD5610\. The SD5610 includes an inverter so that the output is low when the ambient
    light is above the turn-on threshold. Because I required the inverted output,
    I used the SD5610\. The spectral sensitivity is greatest in the 800 to 850 nm
    wavelength—the area of most common IR LEDs. Additional information on the SD5600
    series can be obtained at Honeywell’s website.'
  prefs: []
  type: TYPE_NORMAL
- en: For the LEDs, I just used regular IR LEDs that claimed output in the 850–950
    nm range. I simply bought a bag of 50 units on eBay, and they work fine. Alternatively,
    SparkFun offers single units very cheaply.
  prefs: []
  type: TYPE_NORMAL
- en: The LEDs and photosensors should be soldered on the PCBs made for them and should
    fit snuggly into the holes. I fastened the PCB to the sides of the acceleration
    channel using some standard 3M double-sided adhesive tape.
  prefs: []
  type: TYPE_NORMAL
- en: '***Sensor Umbilical Cable***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The cable I used to connect the sensor channel to the Full Ballistic Chronograph’s
    PCB is made from four lengths of 30-gauge wire twisted together, fastened with
    masking tape, and connected to a female four-conductor Pololu connector at each
    end. These connectors are not polarized and do not have a detent, so they can
    be relatively easily unplugged or plugged in the other way. Before you plug them
    in, make sure to line up the color-coded wire.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*I initially attempted to use a length of four-conductor telephone cable, but
    it was too stiff and caused problems*.'
  prefs: []
  type: TYPE_NORMAL
- en: The channel and completed chronograph can be connected easily. If you used colored
    wire, you’ll know that the plug is connected correctly because it is not polarized.
  prefs: []
  type: TYPE_NORMAL
- en: '**Final Setup and Operation**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Once you’ve finished assembling the unit and sensor channel, it’s time to take
    it out on the range and give it a try. Both the Chronograph Lite and the Full
    Ballistic Chronograph have been designed to operate from battery power, so you
    don’t need to plug them in. Set up the umbilical cable to connect the sensor channel
    to the chronograph unit, and then mount the channel to the weapon securely (see
    [Figure 8-27](ch08.xhtml#ch08fig8-27)).
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/fig8_27.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 8-27: The completed Full Ballistic Chronograph with the acceleration
    channel mounted to a Crossman 0.177 caliber pellet gun*'
  prefs: []
  type: TYPE_NORMAL
- en: Once the channel is attached to the weapon, carefully align the barrel of the
    weapon with the LED/detectors in the channel by using a straight dowel the same
    diameter as the bore of the barrel or by making a simple adapter that uses a straight
    length of tubing (see [Figure 8-28](ch08.xhtml#ch08fig8-28)).
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/fig8_28.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 8-28: Using a small diameter brass rod with a Teflon end to set up
    proper alignment between the barrel of a Crossman T-4 CO[2] pistol and the sensor/detectors
    in the sensor channel*'
  prefs: []
  type: TYPE_NORMAL
- en: '**WARNING**'
  prefs: []
  type: TYPE_NORMAL
- en: Always use caution when handling a weapon. *Do not look down the length of the
    barrel to align it. Look through the clear acrylic top of the sensor channel*.
  prefs: []
  type: TYPE_NORMAL
- en: '***Using the Full Ballistic Chronograph***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: After aligning the barrel as best as possible, turn on the Full Ballistic Chronograph
    and press the reset button. Aim carefully at your target and fire the weapon.
    The velocity of the projectile in feet per second and the time it took to travel
    the 3 inches between sensors should appear on the LCD screen. To make another
    measurement, simply press the reset switch and fire again.
  prefs: []
  type: TYPE_NORMAL
- en: If by any chance you fail to align the weapon in the channel correctly, there
    is a possibility that the projectile will interrupt the first set of photosensors
    and not the second. In this case, you can press the clear switch and then the
    reset switch to try again. The clear switch simply closes the connection for the
    second photosensor set.
  prefs: []
  type: TYPE_NORMAL
- en: The Full Ballistic Chronograph should give accurate readings from about 300
    fps to well over 2,000 fps.
  prefs: []
  type: TYPE_NORMAL
- en: '***Using the Chronograph Lite***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The Chronograph Lite operates in much the same way, only it automatically resets
    so no reset button is required. However, should the projectile fail to interrupt
    the second set of sensors/detectors, it will be necessary to clear the display
    by pressing the clear button. Essentially, this does the same thing as interrupting
    the second sensor/LED pair, but you should always use the clear button and never
    attempt to interrupt the second sensor/detector pair with an external object—especially
    your finger. Should the weapon accidentally fire, you could sustain a severe injury.
    The Chronograph Lite will provide accurate measurements from about 200 fps to
    well over 1,000 fps, but its accuracy tends to roll off as it approaches 700 fps.
  prefs: []
  type: TYPE_NORMAL
- en: '**HIGH-POWERED WEAPON TESTING**'
  prefs: []
  type: TYPE_NORMAL
- en: Unless you are experienced with firearms, I strongly recommend against using
    the Chronograph to measure high-powered weapons. That said, I did test the Full
    Ballistic Chronograph on a few of them.
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 8-29](ch08.xhtml#ch08fig8-29) shows the sensor channel mounted to a
    Smithfield XP/M 9 mm semiautomatic pistol. I tested the Chronograph with a number
    of cartridges, and the measurements came within a couple fps of the manufacturer’s
    specification of the bullet. For example, the Remington JHP claims the bullet
    travels at 1,155 fps, and I measured about 1,152 fps. Other weapons also measured
    close to the published velocities.'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/fig8_29.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 8-29: A Smithfield XP/M 9 mm pistol set up with the sensor channel
    for the Full Ballistic Chronograph. The magazine is intentionally inserted backward
    for safety reasons*.'
  prefs: []
  type: TYPE_NORMAL
