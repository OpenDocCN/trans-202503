- en: <hgroup>
  id: totrans-0
  prefs: []
  type: TYPE_NORMAL
  zh: <hgroup>
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">B</samp> <samp class="SANS_Dogma_OT_Bold_B_11">MODIFIABLE
    PRIORITY QUEUES</samp>
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">B</samp> <samp class="SANS_Dogma_OT_Bold_B_11">可修改优先队列</samp>
- en: </hgroup>
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: </hgroup>
- en: '![](../images/opener.jpg)'
  id: totrans-3
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/opener.jpg)'
- en: Several algorithms in this book, such as Dijkstra’s algorithm and A* search,
    use an augmented priority queue that allows the program to modify the priority
    of existing elements. For completeness, this appendix describes and provides the
    code for this data structure.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本书中的几个算法，如 Dijkstra 算法和 A* 搜索，使用了增强型优先队列，允许程序修改现有元素的优先级。为完整起见，本附录描述并提供了该数据结构的代码。
- en: While many standard heap implementations support the addition and removal of
    items, they often do not support efficiently changing an item’s priority. We’ll
    provide a brief overview of heaps, then define a small extension to the standard
    priority queue that uses a dictionary to map each item’s location in the heap.
    This mapping allows us to efficiently look up a given item and change its priority.
    Finally, we present code to implement a modifiable priority queue.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然许多标准堆实现支持添加和移除元素，但它们通常不支持高效地更改元素的优先级。我们将简要概述堆，然后定义一个对标准优先队列的小扩展，该扩展使用字典来映射每个元素在堆中的位置。此映射允许我们高效地查找给定的元素并更改其优先级。最后，我们将展示用于实现可修改优先队列的代码。
- en: '## <samp class="SANS_Futura_Std_Bold_B_11">Heaps</samp>'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: '## <samp class="SANS_Futura_Std_Bold_B_11">堆</samp>'
- en: The core of our priority queue data structure is the heap data structure. This
    section provides a short introduction to heaps using material adapted from my
    previous book, *Data Structures the Fun Way*. We’ll cover just enough discussion
    of heaps to explain the code but won’t go into significant depth; you can learn
    more about the details of heaps and their properties in the aforementioned book.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 我们优先队列数据结构的核心是堆数据结构。本节提供了一个简短的堆介绍，内容来自我之前的书《*数据结构的有趣方式*》。我们将讨论足够的堆内容来解释代码，但不会深入探讨；你可以在上述书籍中学习更多关于堆及其性质的详细信息。
- en: '*Heaps* are variants of the binary tree that maintain a special ordered relationship
    between a node and its children. A *max heap* orders the elements according to
    the max heap property, which states that the value at any node in the tree is
    larger than or equal to the values of its child nodes. A *min heap* orders the
    elements according to the min heap property, which states that the value at any
    node in the tree is smaller than or equal to the values of its child nodes. For
    the priority queue, we use a max heap to order items by their priority.'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: '*堆* 是一种二叉树的变种，它在节点与其子节点之间维持一种特殊的有序关系。*最大堆* 按照最大堆属性对元素进行排序，该属性规定树中任意节点的值都大于或等于其子节点的值。*最小堆*
    按照最小堆属性对元素进行排序，该属性规定树中任意节点的值都小于或等于其子节点的值。对于优先队列，我们使用最大堆根据优先级对元素进行排序。'
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Heap Items</samp>
  id: totrans-9
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">堆元素</samp>
- en: We define each item in the priority queue with two variables. The item’s *value*
    is the information we are storing about the object. This can be an integer (node’s
    index), string (node’s name), or even an object. The item’s *priority* is the
    floating-point number that we use to determine which item is extracted next from
    the priority queue.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用两个变量来定义优先队列中的每个元素。元素的 *值* 是我们存储的关于该对象的信息。这可以是整数（节点的索引）、字符串（节点的名称）或甚至是对象。元素的
    *优先级* 是一个浮动小数，用于确定优先队列中下一个被提取的元素。
- en: 'We use a wrapper data structure <samp class="SANS_TheSansMonoCd_W5Regular_11">HeapItem</samp>
    to store the combination of an item’s value and priority:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用一个包装数据结构 <samp class="SANS_TheSansMonoCd_W5Regular_11">HeapItem</samp> 来存储项的值和优先级的组合：
- en: '[PRE0]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The data structure consists of a constructor that initializes the object and
    code to overload both the less-than ❶ and greater-than ❷ comparisons to compare
    the priorities. This data structure is not strictly necessary and adds some overhead;
    we could alternately use a tuple. However, we’ll rely on <samp class="SANS_TheSansMonoCd_W5Regular_11">HeapItem</samp>
    throughout this chapter to make the code more readable.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 该数据结构包含一个构造函数来初始化对象，并重载了小于 ❶ 和大于 ❷ 比较运算符以比较优先级。这个数据结构并非严格必要，增加了一些开销；我们可以选择使用元组。但是，在本章中，我们将依赖于
    <samp class="SANS_TheSansMonoCd_W5Regular_11">HeapItem</samp> 来使代码更具可读性。
- en: '### <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Array-Based
    Storage</samp>'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '### <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">基于数组的存储</samp>'
- en: While heaps are defined in terms of trees, we use a standard array-based implementation
    that is particularly efficient. Each element in the array corresponds to a node
    in the tree with the root node at index 1 (we skip index 0, as is conventional
    for heaps). Child node indices are defined relative to the indices of their parents;
    a node at index *i*, for instance, has children at indices 2*i* and 2*i* + 1\.
    We likewise compute the index of the parent of node *i* as <samp class="SANS_TheSansMonoCd_W5Regular_11">Floor</samp>(*i*/2).
    This indexing scheme, shown in [Figure B-1](#figB-1), allows the algorithm to
    easily compute the index of a child based on that of the parent and the index
    of a parent based on a child.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然堆是通过树来定义的，但我们使用基于数组的标准实现方式，这种方式特别高效。数组中的每个元素对应树中的一个节点，根节点位于索引1（我们跳过索引0，这是堆的常规做法）。子节点的索引是相对于其父节点的索引定义的；例如，索引为*i*的节点，其子节点的索引分别为2*i*和2*i*
    + 1。我们同样可以计算出索引*i*节点的父节点的索引，公式为<samp class="SANS_TheSansMonoCd_W5Regular_11">Floor</samp>(*i*/2)。这种索引方案，如[图B-1](#figB-1)所示，使得算法可以轻松地基于父节点的索引计算子节点的索引，反之亦然。
- en: '![A heap represented both as an array and as a tree with arrows indicating
    where each node sits in the array. The root node 95 corresponds to the first element
    in the array at index 1\. The node’s two children, 71 and 63, are the second and
    third elements of the array.](../images/f0b001.jpg)'
  id: totrans-16
  prefs: []
  type: TYPE_IMG
  zh: '![一个堆以数组和树的形式表示，箭头指示每个节点在数组中的位置。根节点95对应数组中的第一个元素，索引为1。节点的两个子节点71和63分别是数组中的第二和第三个元素。](../images/f0b001.jpg)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure B-1: A heap represented
    as a tree (left) and an array (right)</samp>'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图B-1：堆以树形（左）和数组（右）表示</samp>
- en: Although the items in the array are not in sorted order, the first item is always
    the front item in terms of priority. In a max heap, the first item in the array
    has the maximum priority. In a min heap, the first item has the minimum priority.
    This means we can access the “next” item from our heap with a simple lookup.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管数组中的项目并未按照排序顺序排列，但第一个项目总是优先级最高的。在最大堆中，数组中的第一个项目具有最大优先级；而在最小堆中，第一个项目具有最小优先级。这意味着我们可以通过简单的查找来访问堆中的“下一个”项目。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Element Swaps</samp>
  id: totrans-19
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">元素交换</samp>
- en: Both insertion and removal of items involve breaking the heap property and swapping
    pairs elements to restore it. Anytime we have an item out of place, we can fix
    the ordering by either swapping it upward with its parent or swapping it downward
    with one of its children. We repeat this process, using the item’s new position,
    until it has the correct location in the heap.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 插入和移除项目都会破坏堆的性质，并通过交换元素对来恢复它。每当我们发现一个项目位置不正确时，可以通过将其与父节点向上交换或与子节点向下交换来修正排序。我们重复这个过程，直到该项处于堆中的正确位置。
- en: In the case of max heaps, we swap an element up if its priority is larger than
    that of its parent. In [Figure B-2](#figB-2), for example, the element 56 is out
    of place. When we compare it to its parent in [Figure B-2(a)](#figB-2), we see
    that 56 is larger than 41, which violates the max heap property. We can fix this
    by swapping those two elements, placing 56 in the correct location with respect
    to its parent, as shown in [Figure B-2(b)](#figB-2).
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在最大堆的情况下，如果一个元素的优先级比它的父节点大，我们就将该元素向上交换。例如，在[图B-2](#figB-2)中，元素56的位置不正确。当我们将其与父节点[图B-2(a)](#figB-2)进行比较时，我们看到56大于41，这违反了最大堆的性质。我们可以通过交换这两个元素来修正它，将56放置到相对于父节点的正确位置，正如[图B-2(b)](#figB-2)所示。
- en: '![In (A) node 56 is out of place with a parent of 41\. A dashed circle indicates
    that we are comparing these two nodes. In (B) the nodes have been swapped and
    a dashed circle indicates that we are comparing node 56 with its new parent 71.](../images/f0b002.jpg)'
  id: totrans-22
  prefs: []
  type: TYPE_IMG
  zh: '![在（A）中，节点56的位置不正确，父节点为41。虚线圆圈表示我们正在比较这两个节点。在（B）中，节点已被交换，虚线圆圈表示我们正在将节点56与其新的父节点71进行比较。](../images/f0b002.jpg)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure B-2: A heap element
    that is out of place (a) and the resulting upward comparisons and swaps (b)</samp>'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图B-2：一个不合适的堆元素（a）和结果向上比较与交换（b）</samp>
- en: Similarly, we swap an element down in a max heap if its priority is smaller
    than either of its children. In this case, we must also choose which child to
    use for the swap, selecting the larger of the two children to maintain the max
    heap property. In [Figure B-3](#figB-3), for instance, the element 29 is out of
    place. When we compare its priority to that of its children in [Figure B-3(a)](#figB-3),
    we see that 29 is smaller than 71 and 29 is smaller than 41, both of which violate
    the max heap property. We fix this by swapping element 29 with the larger of its
    two children, as shown in [Figure B-3(b)](#figB-3).
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，如果一个元素的优先级小于其子节点中的任何一个，我们就将其在最大堆中向下交换。在这种情况下，我们还必须选择哪个子节点进行交换，选择两个子节点中较大的一个，以保持最大堆的性质。例如，在[图
    B-3](#figB-3)中，元素29的位置不对。当我们将其优先级与其子节点在[图 B-3(a)](#figB-3)中的优先级进行比较时，我们发现29小于71，并且29小于41，这违反了最大堆的性质。我们通过将元素29与其两个子节点中较大的那个交换来修复这一点，如[图
    B-3(b)](#figB-3)所示。
- en: '![In (A) node 29 is out of place with respect to both children 71 and 41\.
    In (B) node 29 has been swapped with 71.](../images/f0b003.jpg)'
  id: totrans-25
  prefs: []
  type: TYPE_IMG
  zh: '![在(A)中，节点29相对于其子节点71和41的位置不对。在(B)中，节点29已经与71交换。](../images/f0b003.jpg)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure B-3: A heap element
    that is out of place (a) and the resulting downward comparisons and swaps (b)</samp>'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图 B-3：一个位置不对的堆元素（a）以及由此产生的向下比较和交换（b）</samp>
- en: When fixing a min heap, we reverse the comparisons. We swap an element upward
    if its priority is smaller than that of its parent or downward if its priority
    is larger than either of its two children. When swapping downward, we choose the
    child with the smaller priority to maintain the min heap property.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在修复最小堆时，我们反转比较的方向。如果一个元素的优先级小于其父节点的优先级，我们就将其向上交换；如果其优先级大于两个子节点中的任何一个，则将其向下交换。在向下交换时，我们选择优先级较小的子节点，以保持最小堆的性质。
- en: <samp class="SANS_Futura_Std_Bold_B_11">Modifiable Priority Queue</samp>
  id: totrans-28
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">可修改优先队列</samp>
- en: The modifiable priority queue consists of a class wrapping a standard heap-based
    priority queue and a dictionary mapping items to their location in the heap’s
    array. This structure is shown in [Figure B-4](#figB-4) with the dictionary (indexed
    by the item’s value) on the left and an array-based maximum heap on the right.
    As shown, each of the dictionary’s entries points to the item’s index in the heap
    array.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 可修改的优先队列由一个封装标准基于堆的优先队列的类和一个将项目映射到堆数组位置的字典组成。该结构如[图 B-4](#figB-4)所示，字典（按项目的值索引）位于左侧，基于数组的最大堆位于右侧。如图所示，字典中的每个条目都指向堆数组中该项目的索引。
- en: '![a table on the left represents a dictionary mapping the key (item’s value)
    to an index. A list on the right represents the heap with each entry containing
    a value, priority pair. The value “Node 1” on the left maps to row 4 in the heap.](../images/f0b004.jpg)'
  id: totrans-30
  prefs: []
  type: TYPE_IMG
  zh: '![左侧的表格表示一个字典，将键（项目的值）映射到索引。右侧的列表表示堆，其中每个条目包含一个值和优先级对。左侧的“节点1”映射到堆中的第4行。](../images/f0b004.jpg)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure B-4: The two data structures
    inside the priority queue class</samp>'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图 B-4：优先队列类中的两个数据结构</samp>
- en: Given these attributes, we define a simple interface that allows us to insert
    (value, priority) pairs into the priority queue, remove values from the front
    of the priority queue, and change the priority for an existing value. We also
    include several convenience functions for operations like getting the size or
    checking that a value is in the priority queue.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 给定这些属性，我们定义了一个简单的接口，使我们能够将(value, priority)对插入到优先队列中，从优先队列的前端移除值，并更改现有值的优先级。我们还包括了几个方便的函数，用于获取大小或检查某个值是否在优先队列中。
- en: 'This appendix provides the code for the functions that make up the priority
    queue’s interface:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 本附录提供了构成优先队列接口的函数代码：
- en: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">dequeue()</samp>Removes the top
    item from the priority queue and returns its value
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">dequeue()</samp> 从优先队列中移除顶部项并返回其值。
- en: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">enqueue(value, priority)</samp>Inserts
    a new (value, priority) pair into the priority queue
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">enqueue(value, priority)</samp>
    将一个新的(value, priority)对插入到优先队列中。
- en: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">get_priority(value)</samp>Returns
    the value’s floating-point priority
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">get_priority(value)</samp> 返回该值的浮动优先级。
- en: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">in_queue(value)</samp>Returns a
    Boolean indicating whether a given value is in the priority queue
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">in_queue(value)</samp>返回一个布尔值，指示给定值是否在优先队列中
- en: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">is_empty()</samp>Returns a Boolean
    indicating whether the priority queue is empty
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">is_empty()</samp>返回一个布尔值，指示优先队列是否为空
- en: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">peek_top()</samp>Returns the top
    item on the priority queue
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">peek_top()</samp>返回优先队列中的顶部项目
- en: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">peek_top_priority()</samp>Returns
    the priority of the top item in the queue
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">peek_top_priority()</samp>返回队列中顶部项目的优先级
- en: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">peek_top_value()</samp>Returns
    the value of the top item in the queue
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">peek_top_value()</samp>返回队列中顶部项目的值
- en: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">size()</samp>Returns the number
    of items in the priority queue
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">size()</samp>返回优先队列中的项目数
- en: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">update_priority(value, priority)</samp>Updates
    the priority of the item with a given value
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">update_priority(value, priority)</samp>更新具有给定值的项目的优先级
- en: <samp class="SANS_Futura_Std_Bold_B_11">The Data Structure</samp>
  id: totrans-44
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">数据结构</samp>
- en: 'The <samp class="SANS_TheSansMonoCd_W5Regular_11">PriorityQueue</samp> class
    provides a wrapper around the heap and dictionary of indices. It contains the
    following attributes:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">PriorityQueue</samp>类为堆和索引字典提供了一个封装。它包含以下属性：
- en: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">array_size</samp> **(**<samp class="SANS_TheSansMonoCd_W7Bold_B_11">int</samp>**) **Stores
    the total length of the heap array
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">array_size</samp> **(**<samp class="SANS_TheSansMonoCd_W7Bold_B_11">int</samp>**) **存储堆数组的总长度
- en: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">heap_array</samp> **(**<samp class="SANS_TheSansMonoCd_W7Bold_B_11">list</samp>**) **Stores
    <samp class="SANS_TheSansMonoCd_W5Regular_11">HeapItems</samp>, which serves as
    the heap-ordered internal storage for the priority queue
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">heap_array</samp> **(**<samp class="SANS_TheSansMonoCd_W7Bold_B_11">list</samp>**) **存储<samp
    class="SANS_TheSansMonoCd_W5Regular_11">HeapItems</samp>，作为优先队列的堆排序内部存储
- en: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">last_index</samp> **(**<samp class="SANS_TheSansMonoCd_W7Bold_B_11">int</samp>**) **Stores
    the index of the last element in the heap
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">last_index</samp> **(**<samp class="SANS_TheSansMonoCd_W7Bold_B_11">int</samp>**) **存储堆中最后一个元素的索引
- en: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">is_min_heap</samp> **(**<samp class="SANS_TheSansMonoCd_W7Bold_B_11">bool</samp>**) **Indicates
    whether a <samp class="SANS_TheSansMonoCd_W5Regular_11">PriorityQueue</samp> object
    is a min heap (<samp class="SANS_TheSansMonoCd_W5Regular_11">True</samp>) or max
    heap (<samp class="SANS_TheSansMonoCd_W5Regular_11">False</samp>)
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">is_min_heap</samp> **(**<samp class="SANS_TheSansMonoCd_W7Bold_B_11">bool</samp>**) **指示一个<samp
    class="SANS_TheSansMonoCd_W5Regular_11">PriorityQueue</samp>对象是最小堆（<samp class="SANS_TheSansMonoCd_W5Regular_11">True</samp>）还是最大堆（<samp
    class="SANS_TheSansMonoCd_W5Regular_11">False</samp>）
- en: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">indices</samp> **(**<samp class="SANS_TheSansMonoCd_W7Bold_B_11">dict</samp>**) **Stores
    a map of the <samp class="SANS_TheSansMonoCd_W5Regular_11">HeapItem</samp>’s value
    to its index in <samp class="SANS_TheSansMonoCd_W5Regular_11">heap_array</samp>,
    allowing the efficient lookup of items by their value
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">indices</samp> **(**<samp class="SANS_TheSansMonoCd_W7Bold_B_11">dict</samp>**) **存储一个映射，将<samp
    class="SANS_TheSansMonoCd_W5Regular_11">HeapItem</samp>的值映射到其在<samp class="SANS_TheSansMonoCd_W5Regular_11">heap_array</samp>中的索引，从而实现通过值高效查找项目
- en: 'We define a constructor that initializes the attributes to those values of
    an empty priority queue and provides a few basic functions:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 我们定义了一个构造函数，它将属性初始化为空优先队列的值，并提供一些基本功能：
- en: '[PRE1]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">PriorityQueue</samp> constructor
    pre-allocates <samp class="SANS_TheSansMonoCd_W5Regular_11">heap_array</samp>
    given an estimated size ❶. As we’ll see later, the heap uses array doubling to
    increase the size if more than <samp class="SANS_TheSansMonoCd_W5Regular_11">array_size</samp>
    elements are needed.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">PriorityQueue</samp>构造函数根据估算的大小预分配<samp
    class="SANS_TheSansMonoCd_W5Regular_11">heap_array</samp> ❶。正如我们稍后所见，如果需要的元素超过<samp
    class="SANS_TheSansMonoCd_W5Regular_11">array_size</samp>，堆会使用数组扩展来增加大小。
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">size()</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">is_empty()</samp>
    functions both use the value of <samp class="SANS_TheSansMonoCd_W5Regular_11">last_index</samp>
    to determine the number of items in the priority queue. Note that because we are
    using 1-indexing in this case, the number of elements in the <samp class="SANS_TheSansMonoCd_W5Regular_11">PriorityQueue</samp>
    always equals <samp class="SANS_TheSansMonoCd_W5Regular_11">last_index</samp>
    and the heap is empty when <samp class="SANS_TheSansMonoCd_W5Regular_11">last_index</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">==</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">0</samp>.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">size()</samp> 和 <samp class="SANS_TheSansMonoCd_W5Regular_11">is_empty()</samp>
    函数都使用 <samp class="SANS_TheSansMonoCd_W5Regular_11">last_index</samp> 的值来确定优先队列中的项数。请注意，因为在这种情况下我们使用的是
    1 索引，所以 <samp class="SANS_TheSansMonoCd_W5Regular_11">PriorityQueue</samp> 中的元素数量始终等于
    <samp class="SANS_TheSansMonoCd_W5Regular_11">last_index</samp>，当 <samp class="SANS_TheSansMonoCd_W5Regular_11">last_index</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">==</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">0</samp>
    时，堆是空的。
- en: The next two functions use the priority queue’s <samp class="SANS_TheSansMonoCd_W5Regular_11">indices</samp>
    dictionary, which maps each item’s value to its index in order to efficiently
    look up items. The <samp class="SANS_TheSansMonoCd_W5Regular_11">in_queue()</samp>
    function checks whether a value is in the queue by checking whether it is in <samp
    class="SANS_TheSansMonoCd_W5Regular_11">indices</samp>. The <samp class="SANS_TheSansMonoCd_W5Regular_11">get_priority()</samp>
    function starts by checking whether the item is in the priority queue and, if
    not, returning <samp class="SANS_TheSansMonoCd_W5Regular_11">None</samp>. Otherwise,
    it uses <samp class="SANS_TheSansMonoCd_W5Regular_11">indices</samp> to find the
    correct <samp class="SANS_TheSansMonoCd_W5Regular_11">HeapItem</samp> and return
    its priority. As with other functions that can return multiple types, we make
    use of <samp class="SANS_TheSansMonoCd_W5Regular_11">Union</samp> from Python’s
    <samp class="SANS_TheSansMonoCd_W5Regular_11">typing</samp> library.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的两个函数使用优先队列的 <samp class="SANS_TheSansMonoCd_W5Regular_11">indices</samp>
    字典，该字典将每个项的值映射到其在队列中的索引，以便高效查找项。<samp class="SANS_TheSansMonoCd_W5Regular_11">in_queue()</samp>
    函数通过检查值是否存在于 <samp class="SANS_TheSansMonoCd_W5Regular_11">indices</samp> 中来检查值是否在队列中。<samp
    class="SANS_TheSansMonoCd_W5Regular_11">get_priority()</samp> 函数首先检查项是否在优先队列中，如果不在，则返回
    <samp class="SANS_TheSansMonoCd_W5Regular_11">None</samp>。否则，它使用 <samp class="SANS_TheSansMonoCd_W5Regular_11">indices</samp>
    查找正确的 <samp class="SANS_TheSansMonoCd_W5Regular_11">HeapItem</samp> 并返回其优先级。与其他可以返回多种类型的函数一样，我们使用了
    Python 的 <samp class="SANS_TheSansMonoCd_W5Regular_11">typing</samp> 库中的 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">Union</samp>。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Defining Helper Functions</samp>
  id: totrans-56
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">定义辅助函数</samp>
- en: We also define several internal helper functions to support the heap operations.
    Since we allow the heap to be configurable as either a min heap or a max heap,
    these functions encapsulate the different logic needed for those two settings.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还定义了几个内部辅助函数以支持堆操作。由于我们允许堆可配置为最小堆或最大堆，这些函数封装了这两种设置所需的不同逻辑。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Checking Inversions</samp>
  id: totrans-58
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">检查反转</samp>
- en: 'The first helper function checks whether a node and its parents are in the
    wrong ordering for the heap:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个辅助函数检查节点及其父节点是否在堆的错误顺序中：
- en: '[PRE2]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The code for <samp class="SANS_TheSansMonoCd_W5Regular_11">_elements_inverted()</samp>
    starts with bounds checks on the indices of the node’s parent and its child ❶.
    If either index is invalid, the code returns <samp class="SANS_TheSansMonoCd_W5Regular_11">False</samp>.
    Since we will use this function later in this section to determine whether nodes
    need to be swapped within the heap, this prevents swaps past the bounds of the
    array. The check accounts for the heap’s use of an array starting at index 1 by
    disallowing index 0.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">_elements_inverted()</samp> 函数的代码首先对节点父节点和子节点的索引进行边界检查
    ❶。如果任一索引无效，代码将返回 <samp class="SANS_TheSansMonoCd_W5Regular_11">False</samp>。由于我们将在本节稍后使用此函数来确定是否需要在堆中交换节点，这样可以防止交换超出数组的边界。该检查考虑到了堆使用从索引
    1 开始的数组，因此不允许索引 0。
- en: The code then branches on whether it is dealing with a min heap or max heap
    ❷. In the former case, the code checks whether the elements are inverted by checking
    whether the parent’s priority is larger than the child’s priority. In the case
    of a max heap, the code checks for inversion by checking whether the parent’s
    priority is smaller than the child’s priority. Because we overloaded these two
    comparisons within the <samp class="SANS_TheSansMonoCd_W5Regular_11">HeapItem</samp>,
    the code is always checking the item’s relative priorities.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，代码根据是处理最小堆还是最大堆来分支 ❷。在最小堆的情况下，代码通过检查父节点的优先级是否大于子节点的优先级来判断元素是否被反转。在最大堆的情况下，代码通过检查父节点的优先级是否小于子节点的优先级来检查是否存在反转。由于我们在<samp
    class="SANS_TheSansMonoCd_W5Regular_11">HeapItem</samp>中重载了这两种比较，代码始终检查项目的相对优先级。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Swapping Elements</samp>
  id: totrans-63
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">交换元素</samp>
- en: 'The second helper function swaps two elements in the heap’s array. This operation
    requires a bit of extra logic because we have to not only swap the objects but
    also update their corresponding entries in the <samp class="SANS_TheSansMonoCd_W5Regular_11">indices</samp>
    dictionary:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个辅助函数交换堆数组中的两个元素。这个操作需要一些额外的逻辑，因为我们不仅需要交换对象，还需要更新它们在<samp class="SANS_TheSansMonoCd_W5Regular_11">indices</samp>字典中的相应条目：
- en: '[PRE3]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Again, the code for <samp class="SANS_TheSansMonoCd_W5Regular_11">_swap_elements()</samp>
    starts with bounds checking ❶, returning early if either index is out of bounds.
    The code then extracts both heap items, swaps their positions in the array, and
    updates their indices in the dictionary ❷.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，<samp class="SANS_TheSansMonoCd_W5Regular_11">_swap_elements()</samp>的代码首先进行边界检查
    ❶，如果任一索引越界则提前返回。然后，代码提取两个堆项目，交换它们在数组中的位置，并更新它们在字典中的索引 ❷。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Propagating Elements Upward</samp>
  id: totrans-67
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">向上传播元素</samp>
- en: 'The third helper function implements the upward propagation described earlier
    in the appendix:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 第三个辅助函数实现了附录中描述的向上传播：
- en: '[PRE4]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">_propagate_up()</samp> code
    starts by computing the index of the parent. It then uses a <samp class="SANS_TheSansMonoCd_W5Regular_11">while</samp>
    loop to keep swapping the element upward while it has the wrong ordering relative
    to its parent ❶. Because <samp class="SANS_TheSansMonoCd_W5Regular_11">_elements_inverted()</samp>
    returns <samp class="SANS_TheSansMonoCd_W5Regular_11">False</samp> when either
    index is out of bounds, the loop will also terminate when the element in question
    reaches the front of the array (index 1 and parent index 0).
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">_propagate_up()</samp>代码首先计算父节点的索引。然后，它使用<samp
    class="SANS_TheSansMonoCd_W5Regular_11">while</samp>循环不断地将元素向上交换，直到它相对于父节点的顺序正确
    ❶。由于<samp class="SANS_TheSansMonoCd_W5Regular_11">_elements_inverted()</samp>在任一索引越界时返回<samp
    class="SANS_TheSansMonoCd_W5Regular_11">False</samp>，当元素到达数组的前面（索引1和父节点索引0）时，循环也会终止。
- en: Each time the loop finds that the element is still out of place, it swaps that
    element with its parent. The code then updates the element’s index and computes
    the index of the new parent.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 每次循环发现元素仍然不在正确位置时，它会将该元素与其父节点交换。代码然后更新元素的索引，并计算新父节点的索引。
- en: '#### <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Propagating Elements
    Downward</samp>'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '#### <samp class="SANS_Futura_Std_Bold_Condensed_B_11">向下传播元素</samp>'
- en: 'The final helper function implements the downward propagation described earlier:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 最终的辅助函数实现了之前描述的向下传播：
- en: '[PRE5]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">_propagate_down()</samp> code
    uses a <samp class="SANS_TheSansMonoCd_W5Regular_11">while</samp> loop to continually
    swap the element downward until it either is the last element in the array or
    is not inverted with respect to its children. The code checks both the left and
    right child using the <samp class="SANS_TheSansMonoCd_W5Regular_11">_elements_inverted()</samp>
    function, which also handles bounds checking for the array. If it finds a child
    with an inverted priority ❶, the code performs the swap. Otherwise, it breaks
    out of the loop ❷.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">_propagate_down()</samp>代码使用<samp
    class="SANS_TheSansMonoCd_W5Regular_11">while</samp>循环不断将元素向下交换，直到它成为数组中的最后一个元素或相对于子节点的顺序正确。代码使用<samp
    class="SANS_TheSansMonoCd_W5Regular_11">_elements_inverted()</samp>函数检查左右子节点，该函数还处理数组的边界检查。如果找到具有反转优先级的子节点
    ❶，代码会执行交换。否则，它会跳出循环 ❷。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Adding Items</samp>
  id: totrans-76
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">添加项目</samp>
- en: We add (*enqueue*) a new element to the heap by first appending it to the back
    of the array, which corresponds to the first empty space in the bottom level of
    the tree. Since this location does not account for the item’s priority, we have
    likely broken the heap property. We rectify this by swapping the item upward until
    it is in the correct location.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过先将新元素附加到数组的末尾来添加 (*enqueue*) 新元素，这对应于树底层第一个空位。由于这个位置没有考虑到项目的优先级，因此我们很可能破坏了堆的性质。我们通过交换该元素向上移动，直到它处于正确的位置来修正这一点。
- en: 'The code for enqueuing performs the heap insertion as well as the additional
    bookkeeping:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 入队的代码执行堆插入以及额外的书籍管理：
- en: '[PRE6]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The code for the <samp class="SANS_TheSansMonoCd_W5Regular_11">enqueue()</samp>
    function starts by checking whether the object already exists in the priority
    queue by determining whether its value is in <samp class="SANS_TheSansMonoCd_W5Regular_11">indices</samp>
    ❶. If so, it updates the item’s priority and returns. The code does not insert
    items with duplicate values.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">enqueue()</samp> 函数的代码首先检查对象是否已经存在于优先队列中，方法是判断它的值是否在
    <samp class="SANS_TheSansMonoCd_W5Regular_11">indices</samp> 中 ❶。如果是，它更新项目的优先级并返回。代码不会插入具有重复值的项目。
- en: The code next checks that the list has sufficient space for new elements ❷.
    If not, it must allocate more space before inserting the item and uses array doubling
    to increase the size.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 代码接下来检查列表是否有足够的空间容纳新元素 ❷。如果没有，它必须在插入项目之前分配更多空间，并使用数组扩展来增加大小。
- en: Finally, the code inserts the element at the end of <samp class="SANS_TheSansMonoCd_W5Regular_11">heap_array</samp>.
    It marks this location in the <samp class="SANS_TheSansMonoCd_W5Regular_11">indices</samp>
    dictionary for later lookups, then uses <samp class="SANS_TheSansMonoCd_W5Regular_11">_propagate_up()</samp>
    to fix any ordering problems the insertion caused. Importantly, the <samp class="SANS_TheSansMonoCd_W5Regular_11">_propagate_up()</samp>
    function uses the <samp class="SANS_TheSansMonoCd_W5Regular_11">_swap_elements()</samp>
    function, which updates <samp class="SANS_TheSansMonoCd_W5Regular_11">indices</samp>.
    Therefore, although the code initially sets <samp class="SANS_TheSansMonoCd_W5Regular_11">indices[value]</samp>
    to <samp class="SANS_TheSansMonoCd_W5Regular_11">last_index</samp>, it correctly
    updates this index mapping throughout the process.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，代码将元素插入到 <samp class="SANS_TheSansMonoCd_W5Regular_11">heap_array</samp>
    的末尾。它在 <samp class="SANS_TheSansMonoCd_W5Regular_11">indices</samp> 字典中标记该位置，以便后续查找，然后使用
    <samp class="SANS_TheSansMonoCd_W5Regular_11">_propagate_up()</samp> 修正插入造成的任何排序问题。重要的是，<samp
    class="SANS_TheSansMonoCd_W5Regular_11">_propagate_up()</samp> 函数使用 <samp class="SANS_TheSansMonoCd_W5Regular_11">_swap_elements()</samp>
    函数，这会更新 <samp class="SANS_TheSansMonoCd_W5Regular_11">indices</samp>。因此，尽管代码最初将
    <samp class="SANS_TheSansMonoCd_W5Regular_11">indices[value]</samp> 设置为 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">last_index</samp>，它会在整个过程中正确更新此索引映射。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Removing Items</samp>
  id: totrans-83
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">移除项目</samp>
- en: We remove (*dequeue*) the top node by replacing it with the last value in the
    array. This jumps the last node in our heap to the root of the tree, very likely
    breaking the heap property in the process. We correct the relative ordering by
    propagating the item down the tree until it is no longer out of order with respect
    to its children.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过用数组中的最后一个值替换顶部节点来移除 (*dequeue*) 顶部节点。这将最后一个节点跳到树的根部，这很可能破坏堆的性质。我们通过将该元素向下传播，直到它不再与其子节点顺序错误来修正相对顺序。
- en: 'The code for dequeuing performs the heap removal as well as the additional
    bookkeeping:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 出队的代码执行堆移除以及额外的书籍管理：
- en: '[PRE7]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The code for the <samp class="SANS_TheSansMonoCd_W5Regular_11">dequeue()</samp>
    function starts by checking whether the queue is empty and, if so, returns <samp
    class="SANS_TheSansMonoCd_W5Regular_11">None</samp>. (Depending on the context
    of the code, we might alternatively want to raise an error.)
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">dequeue()</samp> 函数的代码首先检查队列是否为空，如果为空，则返回
    <samp class="SANS_TheSansMonoCd_W5Regular_11">None</samp>。（根据代码的上下文，我们可能需要引发错误。）
- en: If the queue is not empty, the code updates the heap and index mapping. First,
    it swaps the last element in <samp class="SANS_TheSansMonoCd_W5Regular_11">heap_array</samp>
    into the first position, saving the old root as <samp class="SANS_TheSansMonoCd_W5Regular_11">result</samp>
    ❶. Second, it removes the former top element (<samp class="SANS_TheSansMonoCd_W5Regular_11">result</samp>)
    from both the array and the index map. Third, it fixes any breakages to the heap
    property using the <samp class="SANS_TheSansMonoCd_W5Regular_11">_propagate_down()</samp>
    function. Finally, it returns the result’s value.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 如果队列不为空，代码更新堆和索引映射。首先，它将 <samp class="SANS_TheSansMonoCd_W5Regular_11">heap_array</samp>
    中的最后一个元素交换到第一个位置，并将旧根保存为 <samp class="SANS_TheSansMonoCd_W5Regular_11">result</samp>
    ❶。第二步，它从数组和索引映射中删除原来的顶部元素（<samp class="SANS_TheSansMonoCd_W5Regular_11">result</samp>）。第三步，使用
    <samp class="SANS_TheSansMonoCd_W5Regular_11">_propagate_down()</samp> 函数修复堆属性的任何破坏。最后，返回结果的值。
- en: '### <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Modifying Priorities</samp>'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '### <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">修改优先级</samp>'
- en: 'The final operation supported by the modifiable priority queue is to change
    the priority of an element. This involves looking up the element’s location in
    <samp class="SANS_TheSansMonoCd_W5Regular_11">heap_array</samp>, changing the
    priority, and fixing any resulting breakages of the heap property using either
    the <samp class="SANS_TheSansMonoCd_W5Regular_11">_propagate_up()</samp> or <samp
    class="SANS_TheSansMonoCd_W5Regular_11">_propagate _down()</samp> functions. The
    majority of this code consists of determining which of the two propagation functions
    it should use:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 可修改优先级队列支持的最终操作是更改元素的优先级。这涉及到查找元素在 <samp class="SANS_TheSansMonoCd_W5Regular_11">heap_array</samp>
    中的位置，修改优先级，并使用 <samp class="SANS_TheSansMonoCd_W5Regular_11">_propagate_up()</samp>
    或 <samp class="SANS_TheSansMonoCd_W5Regular_11">_propagate_down()</samp> 函数修复由于优先级变化导致的堆属性破坏。大部分代码都是确定应该使用哪个传播函数：
- en: '[PRE8]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The code starts by determining if the value is in the priority queue by checking
    that <samp class="SANS_TheSansMonoCd_W5Regular_11">value</samp> is in the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">indices</samp> dictionary. If not, there
    is nothing to update, and it can return immediately.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 代码首先通过检查 <samp class="SANS_TheSansMonoCd_W5Regular_11">value</samp> 是否在 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">indices</samp> 字典中来确定值是否在优先级队列中。如果没有，则没有需要更新的内容，可以立即返回。
- en: If the value is in the priority queue, the code looks up and saves the item’s
    current index (<samp class="SANS_TheSansMonoCd_W5Regular_11">index</samp>) and
    priority (<samp class="SANS_TheSansMonoCd_W5Regular_11">old_priority</samp>),
    then sets the new priority. At this point the code must determine which propagation
    function to use, depending on whether the object is a min heap and whether the
    new priority is larger or smaller than the old priority. The code uses <samp class="SANS_TheSansMonoCd_W5Regular_11">_propagate_up()</samp>
    if the object is a min heap and the old priority is larger, or if the object is
    a max heap and the old priority is smaller. Alternatively, it uses <samp class="SANS_TheSansMonoCd_W5Regular_11">_propagate_down()</samp>
    if the object is a min heap and the old priority is smaller, or if the object
    is a max heap and the old priority is larger.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 如果值在优先级队列中，代码查找并保存该项的当前索引（<samp class="SANS_TheSansMonoCd_W5Regular_11">index</samp>）和优先级（<samp
    class="SANS_TheSansMonoCd_W5Regular_11">old_priority</samp>），然后设置新的优先级。此时，代码必须根据对象是否为最小堆以及新优先级是否大于旧优先级来确定使用哪个传播函数。如果对象是最小堆且旧优先级较大，或对象是最大堆且旧优先级较小，则代码使用
    <samp class="SANS_TheSansMonoCd_W5Regular_11">_propagate_up()</samp>；如果对象是最小堆且旧优先级较小，或对象是最大堆且旧优先级较大，则使用
    <samp class="SANS_TheSansMonoCd_W5Regular_11">_propagate_down()</samp>。
- en: <samp class="SANS_Futura_Std_Bold_B_11">Peek Functions</samp>
  id: totrans-94
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">查看函数</samp>
- en: 'In addition to the standard priority enqueue/dequeue type functions presented
    in this appendix, we provide a few additional convenience functions to perform
    operations that allow us to peek at the top value—that is, to look at it without
    dequeuing it. We can return the entire <samp class="SANS_TheSansMonoCd_W5Regular_11">HeapItem</samp>
    for the top item (or <samp class="SANS_TheSansMonoCd_W5Regular_11">None</samp>
    if the queue is empty), the item’s value, or the item’s priority:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 除了本附录中介绍的标准优先级入队/出队函数外，我们还提供了一些额外的便捷函数，执行允许我们查看顶部值的操作——即在不出队的情况下查看它。我们可以返回顶部项的整个
    <samp class="SANS_TheSansMonoCd_W5Regular_11">HeapItem</samp>（如果队列为空，则返回 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">None</samp>），项的值，或项的优先级：
- en: '[PRE9]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Each of these three functions provides a useful mechanism for examining the
    “best” item in the priority queue without modifying the queue and can be useful
    for debugging.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 这三个函数中的每一个都提供了一种有用的机制，用于在不修改队列的情况下检查优先队列中的“最佳”项，并且在调试时非常有用。
