- en: <hgroup>
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">B</samp> <samp class="SANS_Dogma_OT_Bold_B_11">MODIFIABLE
    PRIORITY QUEUES</samp>
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: </hgroup>
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/opener.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Several algorithms in this book, such as Dijkstra’s algorithm and A* search,
    use an augmented priority queue that allows the program to modify the priority
    of existing elements. For completeness, this appendix describes and provides the
    code for this data structure.
  prefs: []
  type: TYPE_NORMAL
- en: While many standard heap implementations support the addition and removal of
    items, they often do not support efficiently changing an item’s priority. We’ll
    provide a brief overview of heaps, then define a small extension to the standard
    priority queue that uses a dictionary to map each item’s location in the heap.
    This mapping allows us to efficiently look up a given item and change its priority.
    Finally, we present code to implement a modifiable priority queue.
  prefs: []
  type: TYPE_NORMAL
- en: '## <samp class="SANS_Futura_Std_Bold_B_11">Heaps</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: The core of our priority queue data structure is the heap data structure. This
    section provides a short introduction to heaps using material adapted from my
    previous book, *Data Structures the Fun Way*. We’ll cover just enough discussion
    of heaps to explain the code but won’t go into significant depth; you can learn
    more about the details of heaps and their properties in the aforementioned book.
  prefs: []
  type: TYPE_NORMAL
- en: '*Heaps* are variants of the binary tree that maintain a special ordered relationship
    between a node and its children. A *max heap* orders the elements according to
    the max heap property, which states that the value at any node in the tree is
    larger than or equal to the values of its child nodes. A *min heap* orders the
    elements according to the min heap property, which states that the value at any
    node in the tree is smaller than or equal to the values of its child nodes. For
    the priority queue, we use a max heap to order items by their priority.'
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Heap Items</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We define each item in the priority queue with two variables. The item’s *value*
    is the information we are storing about the object. This can be an integer (node’s
    index), string (node’s name), or even an object. The item’s *priority* is the
    floating-point number that we use to determine which item is extracted next from
    the priority queue.
  prefs: []
  type: TYPE_NORMAL
- en: 'We use a wrapper data structure <samp class="SANS_TheSansMonoCd_W5Regular_11">HeapItem</samp>
    to store the combination of an item’s value and priority:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The data structure consists of a constructor that initializes the object and
    code to overload both the less-than ❶ and greater-than ❷ comparisons to compare
    the priorities. This data structure is not strictly necessary and adds some overhead;
    we could alternately use a tuple. However, we’ll rely on <samp class="SANS_TheSansMonoCd_W5Regular_11">HeapItem</samp>
    throughout this chapter to make the code more readable.
  prefs: []
  type: TYPE_NORMAL
- en: '### <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Array-Based
    Storage</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: While heaps are defined in terms of trees, we use a standard array-based implementation
    that is particularly efficient. Each element in the array corresponds to a node
    in the tree with the root node at index 1 (we skip index 0, as is conventional
    for heaps). Child node indices are defined relative to the indices of their parents;
    a node at index *i*, for instance, has children at indices 2*i* and 2*i* + 1\.
    We likewise compute the index of the parent of node *i* as <samp class="SANS_TheSansMonoCd_W5Regular_11">Floor</samp>(*i*/2).
    This indexing scheme, shown in [Figure B-1](#figB-1), allows the algorithm to
    easily compute the index of a child based on that of the parent and the index
    of a parent based on a child.
  prefs: []
  type: TYPE_NORMAL
- en: '![A heap represented both as an array and as a tree with arrows indicating
    where each node sits in the array. The root node 95 corresponds to the first element
    in the array at index 1\. The node’s two children, 71 and 63, are the second and
    third elements of the array.](../images/f0b001.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure B-1: A heap represented
    as a tree (left) and an array (right)</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: Although the items in the array are not in sorted order, the first item is always
    the front item in terms of priority. In a max heap, the first item in the array
    has the maximum priority. In a min heap, the first item has the minimum priority.
    This means we can access the “next” item from our heap with a simple lookup.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Element Swaps</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Both insertion and removal of items involve breaking the heap property and swapping
    pairs elements to restore it. Anytime we have an item out of place, we can fix
    the ordering by either swapping it upward with its parent or swapping it downward
    with one of its children. We repeat this process, using the item’s new position,
    until it has the correct location in the heap.
  prefs: []
  type: TYPE_NORMAL
- en: In the case of max heaps, we swap an element up if its priority is larger than
    that of its parent. In [Figure B-2](#figB-2), for example, the element 56 is out
    of place. When we compare it to its parent in [Figure B-2(a)](#figB-2), we see
    that 56 is larger than 41, which violates the max heap property. We can fix this
    by swapping those two elements, placing 56 in the correct location with respect
    to its parent, as shown in [Figure B-2(b)](#figB-2).
  prefs: []
  type: TYPE_NORMAL
- en: '![In (A) node 56 is out of place with a parent of 41\. A dashed circle indicates
    that we are comparing these two nodes. In (B) the nodes have been swapped and
    a dashed circle indicates that we are comparing node 56 with its new parent 71.](../images/f0b002.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure B-2: A heap element
    that is out of place (a) and the resulting upward comparisons and swaps (b)</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: Similarly, we swap an element down in a max heap if its priority is smaller
    than either of its children. In this case, we must also choose which child to
    use for the swap, selecting the larger of the two children to maintain the max
    heap property. In [Figure B-3](#figB-3), for instance, the element 29 is out of
    place. When we compare its priority to that of its children in [Figure B-3(a)](#figB-3),
    we see that 29 is smaller than 71 and 29 is smaller than 41, both of which violate
    the max heap property. We fix this by swapping element 29 with the larger of its
    two children, as shown in [Figure B-3(b)](#figB-3).
  prefs: []
  type: TYPE_NORMAL
- en: '![In (A) node 29 is out of place with respect to both children 71 and 41\.
    In (B) node 29 has been swapped with 71.](../images/f0b003.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure B-3: A heap element
    that is out of place (a) and the resulting downward comparisons and swaps (b)</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: When fixing a min heap, we reverse the comparisons. We swap an element upward
    if its priority is smaller than that of its parent or downward if its priority
    is larger than either of its two children. When swapping downward, we choose the
    child with the smaller priority to maintain the min heap property.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Modifiable Priority Queue</samp>
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The modifiable priority queue consists of a class wrapping a standard heap-based
    priority queue and a dictionary mapping items to their location in the heap’s
    array. This structure is shown in [Figure B-4](#figB-4) with the dictionary (indexed
    by the item’s value) on the left and an array-based maximum heap on the right.
    As shown, each of the dictionary’s entries points to the item’s index in the heap
    array.
  prefs: []
  type: TYPE_NORMAL
- en: '![a table on the left represents a dictionary mapping the key (item’s value)
    to an index. A list on the right represents the heap with each entry containing
    a value, priority pair. The value “Node 1” on the left maps to row 4 in the heap.](../images/f0b004.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure B-4: The two data structures
    inside the priority queue class</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: Given these attributes, we define a simple interface that allows us to insert
    (value, priority) pairs into the priority queue, remove values from the front
    of the priority queue, and change the priority for an existing value. We also
    include several convenience functions for operations like getting the size or
    checking that a value is in the priority queue.
  prefs: []
  type: TYPE_NORMAL
- en: 'This appendix provides the code for the functions that make up the priority
    queue’s interface:'
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">dequeue()</samp>Removes the top
    item from the priority queue and returns its value
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">enqueue(value, priority)</samp>Inserts
    a new (value, priority) pair into the priority queue
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">get_priority(value)</samp>Returns
    the value’s floating-point priority
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">in_queue(value)</samp>Returns a
    Boolean indicating whether a given value is in the priority queue
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">is_empty()</samp>Returns a Boolean
    indicating whether the priority queue is empty
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">peek_top()</samp>Returns the top
    item on the priority queue
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">peek_top_priority()</samp>Returns
    the priority of the top item in the queue
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">peek_top_value()</samp>Returns
    the value of the top item in the queue
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">size()</samp>Returns the number
    of items in the priority queue
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">update_priority(value, priority)</samp>Updates
    the priority of the item with a given value
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">The Data Structure</samp>
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The <samp class="SANS_TheSansMonoCd_W5Regular_11">PriorityQueue</samp> class
    provides a wrapper around the heap and dictionary of indices. It contains the
    following attributes:'
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">array_size</samp> **(**<samp class="SANS_TheSansMonoCd_W7Bold_B_11">int</samp>**) **Stores
    the total length of the heap array
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">heap_array</samp> **(**<samp class="SANS_TheSansMonoCd_W7Bold_B_11">list</samp>**) **Stores
    <samp class="SANS_TheSansMonoCd_W5Regular_11">HeapItems</samp>, which serves as
    the heap-ordered internal storage for the priority queue
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">last_index</samp> **(**<samp class="SANS_TheSansMonoCd_W7Bold_B_11">int</samp>**) **Stores
    the index of the last element in the heap
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">is_min_heap</samp> **(**<samp class="SANS_TheSansMonoCd_W7Bold_B_11">bool</samp>**) **Indicates
    whether a <samp class="SANS_TheSansMonoCd_W5Regular_11">PriorityQueue</samp> object
    is a min heap (<samp class="SANS_TheSansMonoCd_W5Regular_11">True</samp>) or max
    heap (<samp class="SANS_TheSansMonoCd_W5Regular_11">False</samp>)
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">indices</samp> **(**<samp class="SANS_TheSansMonoCd_W7Bold_B_11">dict</samp>**) **Stores
    a map of the <samp class="SANS_TheSansMonoCd_W5Regular_11">HeapItem</samp>’s value
    to its index in <samp class="SANS_TheSansMonoCd_W5Regular_11">heap_array</samp>,
    allowing the efficient lookup of items by their value
  prefs: []
  type: TYPE_NORMAL
- en: 'We define a constructor that initializes the attributes to those values of
    an empty priority queue and provides a few basic functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">PriorityQueue</samp> constructor
    pre-allocates <samp class="SANS_TheSansMonoCd_W5Regular_11">heap_array</samp>
    given an estimated size ❶. As we’ll see later, the heap uses array doubling to
    increase the size if more than <samp class="SANS_TheSansMonoCd_W5Regular_11">array_size</samp>
    elements are needed.
  prefs: []
  type: TYPE_NORMAL
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">size()</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">is_empty()</samp>
    functions both use the value of <samp class="SANS_TheSansMonoCd_W5Regular_11">last_index</samp>
    to determine the number of items in the priority queue. Note that because we are
    using 1-indexing in this case, the number of elements in the <samp class="SANS_TheSansMonoCd_W5Regular_11">PriorityQueue</samp>
    always equals <samp class="SANS_TheSansMonoCd_W5Regular_11">last_index</samp>
    and the heap is empty when <samp class="SANS_TheSansMonoCd_W5Regular_11">last_index</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">==</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">0</samp>.
  prefs: []
  type: TYPE_NORMAL
- en: The next two functions use the priority queue’s <samp class="SANS_TheSansMonoCd_W5Regular_11">indices</samp>
    dictionary, which maps each item’s value to its index in order to efficiently
    look up items. The <samp class="SANS_TheSansMonoCd_W5Regular_11">in_queue()</samp>
    function checks whether a value is in the queue by checking whether it is in <samp
    class="SANS_TheSansMonoCd_W5Regular_11">indices</samp>. The <samp class="SANS_TheSansMonoCd_W5Regular_11">get_priority()</samp>
    function starts by checking whether the item is in the priority queue and, if
    not, returning <samp class="SANS_TheSansMonoCd_W5Regular_11">None</samp>. Otherwise,
    it uses <samp class="SANS_TheSansMonoCd_W5Regular_11">indices</samp> to find the
    correct <samp class="SANS_TheSansMonoCd_W5Regular_11">HeapItem</samp> and return
    its priority. As with other functions that can return multiple types, we make
    use of <samp class="SANS_TheSansMonoCd_W5Regular_11">Union</samp> from Python’s
    <samp class="SANS_TheSansMonoCd_W5Regular_11">typing</samp> library.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Defining Helper Functions</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We also define several internal helper functions to support the heap operations.
    Since we allow the heap to be configurable as either a min heap or a max heap,
    these functions encapsulate the different logic needed for those two settings.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Checking Inversions</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The first helper function checks whether a node and its parents are in the
    wrong ordering for the heap:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The code for <samp class="SANS_TheSansMonoCd_W5Regular_11">_elements_inverted()</samp>
    starts with bounds checks on the indices of the node’s parent and its child ❶.
    If either index is invalid, the code returns <samp class="SANS_TheSansMonoCd_W5Regular_11">False</samp>.
    Since we will use this function later in this section to determine whether nodes
    need to be swapped within the heap, this prevents swaps past the bounds of the
    array. The check accounts for the heap’s use of an array starting at index 1 by
    disallowing index 0.
  prefs: []
  type: TYPE_NORMAL
- en: The code then branches on whether it is dealing with a min heap or max heap
    ❷. In the former case, the code checks whether the elements are inverted by checking
    whether the parent’s priority is larger than the child’s priority. In the case
    of a max heap, the code checks for inversion by checking whether the parent’s
    priority is smaller than the child’s priority. Because we overloaded these two
    comparisons within the <samp class="SANS_TheSansMonoCd_W5Regular_11">HeapItem</samp>,
    the code is always checking the item’s relative priorities.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Swapping Elements</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The second helper function swaps two elements in the heap’s array. This operation
    requires a bit of extra logic because we have to not only swap the objects but
    also update their corresponding entries in the <samp class="SANS_TheSansMonoCd_W5Regular_11">indices</samp>
    dictionary:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Again, the code for <samp class="SANS_TheSansMonoCd_W5Regular_11">_swap_elements()</samp>
    starts with bounds checking ❶, returning early if either index is out of bounds.
    The code then extracts both heap items, swaps their positions in the array, and
    updates their indices in the dictionary ❷.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Propagating Elements Upward</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The third helper function implements the upward propagation described earlier
    in the appendix:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">_propagate_up()</samp> code
    starts by computing the index of the parent. It then uses a <samp class="SANS_TheSansMonoCd_W5Regular_11">while</samp>
    loop to keep swapping the element upward while it has the wrong ordering relative
    to its parent ❶. Because <samp class="SANS_TheSansMonoCd_W5Regular_11">_elements_inverted()</samp>
    returns <samp class="SANS_TheSansMonoCd_W5Regular_11">False</samp> when either
    index is out of bounds, the loop will also terminate when the element in question
    reaches the front of the array (index 1 and parent index 0).
  prefs: []
  type: TYPE_NORMAL
- en: Each time the loop finds that the element is still out of place, it swaps that
    element with its parent. The code then updates the element’s index and computes
    the index of the new parent.
  prefs: []
  type: TYPE_NORMAL
- en: '#### <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Propagating Elements
    Downward</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: 'The final helper function implements the downward propagation described earlier:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">_propagate_down()</samp> code
    uses a <samp class="SANS_TheSansMonoCd_W5Regular_11">while</samp> loop to continually
    swap the element downward until it either is the last element in the array or
    is not inverted with respect to its children. The code checks both the left and
    right child using the <samp class="SANS_TheSansMonoCd_W5Regular_11">_elements_inverted()</samp>
    function, which also handles bounds checking for the array. If it finds a child
    with an inverted priority ❶, the code performs the swap. Otherwise, it breaks
    out of the loop ❷.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Adding Items</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We add (*enqueue*) a new element to the heap by first appending it to the back
    of the array, which corresponds to the first empty space in the bottom level of
    the tree. Since this location does not account for the item’s priority, we have
    likely broken the heap property. We rectify this by swapping the item upward until
    it is in the correct location.
  prefs: []
  type: TYPE_NORMAL
- en: 'The code for enqueuing performs the heap insertion as well as the additional
    bookkeeping:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The code for the <samp class="SANS_TheSansMonoCd_W5Regular_11">enqueue()</samp>
    function starts by checking whether the object already exists in the priority
    queue by determining whether its value is in <samp class="SANS_TheSansMonoCd_W5Regular_11">indices</samp>
    ❶. If so, it updates the item’s priority and returns. The code does not insert
    items with duplicate values.
  prefs: []
  type: TYPE_NORMAL
- en: The code next checks that the list has sufficient space for new elements ❷.
    If not, it must allocate more space before inserting the item and uses array doubling
    to increase the size.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the code inserts the element at the end of <samp class="SANS_TheSansMonoCd_W5Regular_11">heap_array</samp>.
    It marks this location in the <samp class="SANS_TheSansMonoCd_W5Regular_11">indices</samp>
    dictionary for later lookups, then uses <samp class="SANS_TheSansMonoCd_W5Regular_11">_propagate_up()</samp>
    to fix any ordering problems the insertion caused. Importantly, the <samp class="SANS_TheSansMonoCd_W5Regular_11">_propagate_up()</samp>
    function uses the <samp class="SANS_TheSansMonoCd_W5Regular_11">_swap_elements()</samp>
    function, which updates <samp class="SANS_TheSansMonoCd_W5Regular_11">indices</samp>.
    Therefore, although the code initially sets <samp class="SANS_TheSansMonoCd_W5Regular_11">indices[value]</samp>
    to <samp class="SANS_TheSansMonoCd_W5Regular_11">last_index</samp>, it correctly
    updates this index mapping throughout the process.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Removing Items</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We remove (*dequeue*) the top node by replacing it with the last value in the
    array. This jumps the last node in our heap to the root of the tree, very likely
    breaking the heap property in the process. We correct the relative ordering by
    propagating the item down the tree until it is no longer out of order with respect
    to its children.
  prefs: []
  type: TYPE_NORMAL
- en: 'The code for dequeuing performs the heap removal as well as the additional
    bookkeeping:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The code for the <samp class="SANS_TheSansMonoCd_W5Regular_11">dequeue()</samp>
    function starts by checking whether the queue is empty and, if so, returns <samp
    class="SANS_TheSansMonoCd_W5Regular_11">None</samp>. (Depending on the context
    of the code, we might alternatively want to raise an error.)
  prefs: []
  type: TYPE_NORMAL
- en: If the queue is not empty, the code updates the heap and index mapping. First,
    it swaps the last element in <samp class="SANS_TheSansMonoCd_W5Regular_11">heap_array</samp>
    into the first position, saving the old root as <samp class="SANS_TheSansMonoCd_W5Regular_11">result</samp>
    ❶. Second, it removes the former top element (<samp class="SANS_TheSansMonoCd_W5Regular_11">result</samp>)
    from both the array and the index map. Third, it fixes any breakages to the heap
    property using the <samp class="SANS_TheSansMonoCd_W5Regular_11">_propagate_down()</samp>
    function. Finally, it returns the result’s value.
  prefs: []
  type: TYPE_NORMAL
- en: '### <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Modifying Priorities</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: 'The final operation supported by the modifiable priority queue is to change
    the priority of an element. This involves looking up the element’s location in
    <samp class="SANS_TheSansMonoCd_W5Regular_11">heap_array</samp>, changing the
    priority, and fixing any resulting breakages of the heap property using either
    the <samp class="SANS_TheSansMonoCd_W5Regular_11">_propagate_up()</samp> or <samp
    class="SANS_TheSansMonoCd_W5Regular_11">_propagate _down()</samp> functions. The
    majority of this code consists of determining which of the two propagation functions
    it should use:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: The code starts by determining if the value is in the priority queue by checking
    that <samp class="SANS_TheSansMonoCd_W5Regular_11">value</samp> is in the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">indices</samp> dictionary. If not, there
    is nothing to update, and it can return immediately.
  prefs: []
  type: TYPE_NORMAL
- en: If the value is in the priority queue, the code looks up and saves the item’s
    current index (<samp class="SANS_TheSansMonoCd_W5Regular_11">index</samp>) and
    priority (<samp class="SANS_TheSansMonoCd_W5Regular_11">old_priority</samp>),
    then sets the new priority. At this point the code must determine which propagation
    function to use, depending on whether the object is a min heap and whether the
    new priority is larger or smaller than the old priority. The code uses <samp class="SANS_TheSansMonoCd_W5Regular_11">_propagate_up()</samp>
    if the object is a min heap and the old priority is larger, or if the object is
    a max heap and the old priority is smaller. Alternatively, it uses <samp class="SANS_TheSansMonoCd_W5Regular_11">_propagate_down()</samp>
    if the object is a min heap and the old priority is smaller, or if the object
    is a max heap and the old priority is larger.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Peek Functions</samp>
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In addition to the standard priority enqueue/dequeue type functions presented
    in this appendix, we provide a few additional convenience functions to perform
    operations that allow us to peek at the top value—that is, to look at it without
    dequeuing it. We can return the entire <samp class="SANS_TheSansMonoCd_W5Regular_11">HeapItem</samp>
    for the top item (or <samp class="SANS_TheSansMonoCd_W5Regular_11">None</samp>
    if the queue is empty), the item’s value, or the item’s priority:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Each of these three functions provides a useful mechanism for examining the
    “best” item in the priority queue without modifying the queue and can be useful
    for debugging.
  prefs: []
  type: TYPE_NORMAL
