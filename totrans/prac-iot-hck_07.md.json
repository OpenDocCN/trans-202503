["```\n$ **./Orthanc**\n<timestamp> main.cpp:1305] Orthanc version: 1.4.2\n<timestamp> OrthancInitialization.cpp:216] Using the default Orthanc configuration\n<timestamp> OrthancInitialization.cpp:1050] SQLite index directory: \"XXX\"\n<timestamp> OrthancInitialization.cpp:1120] Storage directory: \"XXX\"\n<timestamp> HttpClient.cpp:739] HTTPS will use the CA certificates from this file: ./orthancAndPluginsOSX.stable\n<timestamp> LuaContext.cpp:103] Lua says: Lua toolbox installed\n<timestamp> LuaContext.cpp:103] Lua says: Lua toolbox installed\n<timestamp> ServerContext.cpp:299] Disk compression is disabled\n<timestamp> ServerIndex.cpp:1449] No limit on the number of stored patients\n<timestamp> ServerIndex.cpp:1466] No limit on the size of the storage area\n<timestamp> ServerContext.cpp:164] Reloading the jobs from the last execution of Orthanc\n<timestamp> JobsEngine.cpp:281] The jobs engine has started with 2 threads\n<timestamp> main.cpp:848] DICOM server listening with AET ORTHANC on port: 4242\n<timestamp> MongooseServer.cpp:1088] HTTP compression is enabled\n<timestamp> MongooseServer.cpp:1002] HTTP server listening on port: 8042 (HTTPS encryption is disabled, remote access is not allowed)\n<timestamp> main.cpp:667] Orthanc has started\n```", "```\ndisable_lua = false\n```", "```\n$ **tshark -X lua_script:<your Lua test script>**\n```", "```\n$ **tshark -X lua_script:test.lua**\nHello from Lua\nCapturing on 'ens33'\n```", "```\ndicom_protocol = Proto(\"dicom-a\",  \"DICOM A-Type message\")\n```", "```\n1 pdu_type = ProtoField.uint8(\"dicom-a.pdu_type\",\"pduType\",base.DEC, {[1]=\"ASSOC Request\",\n [2]=\"ASSOC Accept\",\n [3]=\"ASSOC Reject\",\n [4]=\"Data\",\n [5]=\"RELEASE Request\",\n [6]=\"RELEASE Response\",\n [7]=\"ABORT\"}) -- unsigned 8-bit integer\n2 message_length = ProtoField.uint16(\"dicom-a.message_length\", \"messageLength\", base.DEC) -- unsigned 16-bit integer\n3 dicom_protocol.fields = {pdu_type, message_length}\n```", "```\nfunction dicom_protocol.dissector(buffer, pinfo, tree)\n1  pinfo.cols.protocol = dicom_protocol.name\n  local subtree = tree:add(dicom_protocol, buffer(), \"DICOM PDU\")\n  subtree:add_le(pdu_type, buffer(0,1)) -- big endian\n  subtree:add(message_length, buffer(2,4)) -- skip 1 byte\nend\n```", "```\nlocal tcp_port = DissectorTable.get(\"tcp.port\")\ntcp_port:add(4242, dicom_protocol)\n```", "```\ndicom_protocol = Proto(\"dicom-a\",  \"DICOM A-Type message\")\npdu_type = ProtoField.uint8(\"dicom-a.pdu_type\", \"pduType\", base.DEC, {[1]=\"ASSOC Request\", [2]=\"ASSOC Accept\", [3]=”ASSOC Reject”, [4]=”Data”, [5]=”RELEASE Request”, [6]=”RELEASE Response”, [7]=”ABORT”})\nmessage_length = ProtoField.uint16(\"dicom-a.message_length\", \"messageLength\", base.DEC)\n\ndicom_protocol.fields = {message_length, pdu_type} 1\n\nfunction dicom_protocol.dissector(buffer, pinfo, tree)\n  pinfo.cols.protocol = dicom_protocol.name\n  local subtree = tree:add(dicom_protocol, buffer(), \"DICOM PDU\")\n  subtree:add_le(pdu_type, buffer(0,1))\n  subtree:add(message_length, buffer(2,4))\nend\n\nlocal tcp_port = DissectorTable.get(\"tcp.port\")\ntcp_port:add(4242, dicom_protocol)\n```", "```\n protocol_version = ProtoField.uint8(\"dicom-a.protocol_version\", \"protocolVersion\", base.DEC)\ncalling_application = ProtoField.string(1 \"dicom-a.calling_app\", 2 \"callingApplication\")\ncalled_application = ProtoField.string(\"dicom-a.called_app\", \"calledApplication\")\n```", "````### Populating the Dissector Function    After adding our new ProtoFields as fields to our protocol dissector, we need to add code to populate them in our dissector function, `dicom_protocol.dissector()`, so they’re included in the protocol display tree:    ``` 1 local pdu_id = buffer(0, 1):uint() -- Convert to unsigned int  if pdu_id == 1 or pdu_id == 2 then -- ASSOC-REQ (1) / ASSOC-RESP (2)     local assoc_tree = 2subtree:add(dicom_protocol, buffer(), \"ASSOCIATE REQ/RSP\")     assoc_tree:add(protocol_version, buffer(6, 2))     assoc_tree:add(calling_application, buffer(10, 16))     assoc_tree:add(called_application, buffer(26, 16)) end ```    Our dissector should add the extracted fields to a subtree in our protocol tree. To create a subtree, we call the `add()` function from our existing protocol tree 2. Now our simple dissector can identify PDU types, message lengths, the type of ASSOCIATE message 1, the protocol, the calling application, and the called application. [Figure 5-7](#figure5-7) shows the result.  ![f05007](Images/f05007.png)    Figure 5-7: Subtrees added to existing protocol trees      ### Parsing Variable-Length Fields    Now that we’ve identified and parsed the fixed-length sections, let’s parse the message’s variable-length fields. In DICOM, we use identifiers called *contexts* to store, represent, and negotiate different features. We’ll show you how to locate the three different types of contexts available: the Application Context, Presentation Contexts, and User Info Context, which have a variable number of item fields. But we won’t write code to parse the item contents.    For each of the contexts, we’ll add a subtree that displays the length of the context and the variable number of context items. Modify the main protocol dissector so it looks as follows:    ``` function dicom_protocol.dissector(buffer, pinfo, tree)   pinfo.cols.protocol = dicom_protocol.name   local subtree = tree:add(dicom_protocol, buffer(), \"DICOM PDU\")   local pkt_len = buffer(2, 4):uint()   local pdu_id = buffer(0, 1):uint()   subtree:add_le(pdu_type, buffer(0,1))   subtree:add(message_length, buffer(2,4))   if pdu_id == 1 or pdu_id == 2 then -- ASSOC-REQ (1) / ASSOC-RESP (2)     local assoc_tree = subtree:add(dicom_protocol, buffer(), \"ASSOCIATE REQ/RSP\")     assoc_tree:add(protocol_version, buffer(6, 2))     assoc_tree:add(calling_application, buffer(10, 16))     assoc_tree:add(called_application, buffer(26, 16))      --Extract Application Context 1     local context_variables_length = buffer(76,2):uint() 2     local app_context_tree = assoc_tree:add(dicom_protocol, buffer(74, context_variables_length + 4), \"Application Context\") 3     app_context_tree:add(app_context_type, buffer(74, 1))     app_context_tree:add(app_context_length, buffer(76, 2))     app_context_tree:add(app_context_name, buffer(78, context_variables_length))  --Extract Presentation Context(s) 4     local presentation_items_length = buffer(78 + context_variables_length + 2, 2):uint()     local presentation_context_tree = assoc_tree:add(dicom_protocol, buffer(78 + context_variables_length, presentation_items_length + 4), \"Presentation Context\")     presentation_context_tree:add(presentation_context_type, buffer(78 + context_variables_length, 1))     presentation_context_tree:add(presentation_context_length, buffer(78 + context_variables_length + 2, 2))  \t    -- TODO: Extract Presentation Context Items\t      --Extract User Info Context 5     local user_info_length = buffer(78 + context_variables_length + 2 + presentation_items_length + 2 + 2, 2):uint()     local userinfo_context_tree = assoc_tree:add(dicom_protocol, buffer(78 + context_variables_length + presentation_items_length + 4, user_info_length + 4), \"User Info Context\")     userinfo_context_tree:add(userinfo_length, buffer(78 + context_variables_length + 2 + presentation_items_length + 2 + 2, 2))      -- TODO: Extract User Info Context Items   end end ```    When working with network protocols, you’ll often find variable-length fields that require you to calculate offsets. It’s very important that you get the length values correct, because all offset calculations depend on them.    Keeping this in mind, we extract the Application Context 1, Presentation Contexts 4, and User Info Context 5. For each context, we extract the length of the context 2 and add a subtree for the information contained in that context 3. We add individual fields using the `add()` function and calculate the string offsets based on the length of the fields. We obtain all of this from the packet received using the `buffer()` function.    ### Testing the Dissector    After applying the changes referenced in “Parsing Variable-Length Fields,” make sure your DICOM packets are parsed correctly by checking the reported lengths. You should now see a subtree for each context ([Figure 5-8](#figure5-8)). Note that because we provide a buffer range in our new subtrees, you can select them to highlight the corresponding section. Take a moment to verify that each context of the DICOM protocol is recognized as expected.  ![f05008](Images/f05008.png)    Figure 5-8: User Info Context is 58\\. The highlighted message is 62 bytes (58 bytes of data, 1 byte for the type, 1 reserved byte, and 2 bytes for the size).      If you want more practice, we encourage you to add fields from the different contexts to the dissector. You can grab a DICOM packet capture from the Wireshark Packet Sample page, where we submitted a capture containing a DICOM ping. You’ll also find the full example, including TCP fragmentation, in this book’s online resources. Remember that you can reload the Lua scripts at any time to test your latest dissector without restarting Wireshark by clicking **Analyze**▶**Reload Lua plugins**.    ## Writing a DICOM Service Scanner for the Nmap Scripting Engine    Earlier in this chapter, you learned that DICOM has a ping-like utility called a C-Echo request formed by several A-type messages. You then wrote a Lua dissector to analyze these messages with Wireshark. Now you’ll use Lua to tackle another task: writing a DICOM *service scanner*. The scanner will identify DICOM service providers (DSP) remotely on networks to actively test their configurations and even launch attacks. Because Nmap is well known for its scanning capabilities and its scripting engine also runs in Lua, it’s the perfect tool for writing such a scanner.    For this exercise, we’ll focus on the subset of functions related to sending a partial C-ECHO request.    ### Writing an Nmap Scripting Engine Library for DICOM    We’ll begin by creating an Nmap Scripting Engine library for our DICOM-related code. We’ll use the library to store any functions used in socket creation and destruction, sending and receiving DICOM packets, and actions like associating and querying services.    Nmap already includes libraries to help you perform common input/output (I/O) operations, socket handling, and other tasks. Take a moment to review the library collection so you’ll know what’s already available. Read the documentation for these scripts and libraries at [https://nmap.org/nsedoc/](https://nmap.org/nsedoc/).    You can usually find Nmap Scripting Engine libraries in the *<installation directory>/nselib*/ folder. Locate this directory, and then create a file called *dicom.lua*. In this file, begin by declaring other standard Lua and Nmap Scripting Engine libraries used. Also, tell the environment the name of the new library:    ``` local nmap = require \"nmap\" local stdnse = require \"stdnse\" local string = require \"string\" local table = require \"table\" local nsedebug = require \"nsedebug\"  _ENV = stdnse.module(\"dicom\", stdnse.seeall) ```    In this case, we’ll use four different libraries: two Nmap Scripting Engine libraries ( *nmap* and *stdnse*) and two standard Lua libraries (*string* and *table*). The Lua libraries *string* and *table* are, unsurprisingly, for string and table operations. We’ll mainly use the *nmap* library socket handling, and we’ll use *stdnse* for reading user-supplied arguments and printing debug statements when necessary. We’ll also use the helpful *nsedebug* library, which displays different data types in a human-readable form.    ### DICOM Codes and Constants    Now let’s define some constants to store the PDU codes, UUID values, and the minimum and maximum allowed size for packets. Doing so will allow you to write cleaner code that is easier to maintain. In Lua, we typically define constants in capital letters:    ``` local MIN_SIZE_ASSOC_REQ = 68 -- Min size of a ASSOCIATE req 1 local MAX_SIZE_PDU = 128000 -- Max size of any PDU local MIN_HEADER_LEN = 6 -- Min length of a DICOM heade local PDU_NAMES = {} local PDU_CODES = {} local UID_VALUES = {} -- Table for PDU names to codes 2 PDU_CODES = {    ASSOCIATE_REQUEST  = 0x01,   ASSOCIATE_ACCEPT   = 0x02,   ASSOCIATE_REJECT   = 0x03,  DATA               = 0x04,   RELEASE_REQUEST    = 0x05,   RELEASE_RESPONSE   = 0x06,   ABORT              = 0x07 } -- Table for UID names to values UID_VALUES = {   VERIFICATION_SOP = \"1.2.840.10008.1.1\", -- Verification SOP Class   APPLICATION_CONTEXT = \"1.2.840.10008.3.1.1.1\", -- DICOM Application Context Name   IMPLICIT_VR = \"1.2.840.10008.1.2\", -- Implicit VR Little Endian: Default Transfer Syntax for DICOM   FIND_QUERY = \"1.2.840.10008.5.1.4.1.2.2.1\" -- Study Root Query/Retrieve Information Model - FIND }  -- We store the names using their codes as keys for printing PDU type names for i, v in pairs(PDU_CODES) do   PDU_NAMES[v] = i end ```    Here we define constant values for common DICOM operation codes. We also define tables to represent different data classes through UIDs 2 and DICOM-specific packet lengths 1. Now we’re ready to start communicating with the service.    ### Writing Socket Creation and Destruction Functions    To send and receive data, we’ll use the Nmap Scripting Engine library *nmap*. Because socket creation and destruction are common operations, it’s a good idea to write functions for them inside our new library. Let’s write our first function, `dicom.start_connection()`, which creates a socket to the DICOM service:    ``` 1 --- -- start_connection(host, port) starts socket to DICOM service -- -- @param host Host object -- @param port Port table -- @return (status, socket) If status is true, the DICOM object holding the socket is returned. --                          If status is false, socket is the error message. --- function start_connection(host, port)   local dcm = {}   local status, err 2  dcm['socket'] = nmap.new_socket()    status, err = dcm['socket']:connect(host, port, \"tcp\")    if(status == false) then     return false, \"DICOM: Failed to connect to service: \" .. err   end   return true, dcm end ```    Note the *NSEdoc block format* at the beginning of the function 1. If you’re planning on submitting your script to the official Nmap repository, you must format it according to the rules described in the Nmap code standards page ([https://secwiki.org/w/Nmap/Code_Standards](https://secwiki.org/w/Nmap/Code_Standards)). Our new function, `dicom.start_connection(host, port)`, takes the host and port table containing the scanned service information, creates a table, and assigns a field named `‘socket’` to our newly created socket 2. We’ll omit the `close_connection` function for now to save space, because it’s a very similar process to starting a connection (you just make a call to `close()` instead of `connect()`). When the operation succeeds, the function returns the boolean `true` and the new DICOM object.    ### Defining Functions for Sending and Receiving DICOM Packets    Similarly, we create functions for sending and receiving DICOM packets:    ``` -- send(dcm, data) Sends DICOM packet over established socket -- -- @param dcm DICOM object -- @param data Data to send -- @return status True if data was sent correctly, otherwise false and error message is returned. function send(dcm, data)   local status, err   stdnse.debug2(\"DICOM: Sending DICOM packet (%d bytes)\", #data)   if dcm[\"socket\"] ~= nil then    1 status, err = dcm[\"socket\"]:send(data)     if status == false then       return false, err     end   else     return false, \"No socket available\"   end   return true end  -- receive(dcm) Reads DICOM packets over an established socket -- -- @param dcm DICOM object -- @return (status, data) Returns data if status true, otherwise data is the error message. function receive(dcm)  2 local status, data = dcm[\"socket\"]:receive()   if status == false then     return false, data   end   stdnse.debug2(\"DICOM: receive() read %d bytes\", #data)   return true, data end ```    The `send(dcm, data)` and `receive(dcm)` functions use the Nmap socket functions `send()` and `receive()`, respectively. They access the connection handle stored in the `dcm['socket']` variable to read 2 and write DICOM packets 1 over the socket.    Note the `stdnse.debug[1-9]` calls, which are used to print debug statements when Nmap is running with the debugging flag (`-d`). In this case, using `stdnse.debug2()` will print when the debugging level is set to 2 or higher.    ### Creating DICOM Packet Headers    Now that we’ve set up the basic network I/O operations, let’s create the functions in charge of forming the DICOM messages. As mentioned previously, a DICOM PDU uses a header to indicate its type and length. In the Nmap Scripting Engine, we use strings to store the byte streams and the string functions `string.pack()` and `string.unpack()` to encode and retrieve the information, taking into account different formats and endianness. To use `string.pack()` and `string.unpack()`, you’ll need to become familiar with Lua’s format strings, because you’ll need to represent data in various formats. You can read about them at [https://www.lua.org/manual/5.3/manual.html#6.4.2](https://www.lua.org/manual/5.3/manual.html#6.4.2). Take a moment to learn the endianness notations and common conversions.    ``` --- -- pdu_header_encode(pdu_type, length) encodes the DICOM PDU header -- -- @param pdu_type PDU type as an unsigned integer -- @param length Length of the DICOM message -- @return (status, dcm) If status is true, the header is returned. --                       If status is false, dcm is the error message. --- function pdu_header_encode(pdu_type, length)   -- Some simple sanity checks, we do not check ranges to allow users to create malformed packets.   if not(type(pdu_type)) == \"number\" then 1     return false, \"PDU Type must be an unsigned integer. Range:0-7\"   end   if not(type(length)) == \"number\" then     return false, \"Length must be an unsigned integer.\"   end    local header = string.pack(\"2<B >B I43\",                             pdu_type, -- PDU Type ( 1 byte - unsigned integer in Big Endian )                             0,        -- Reserved section ( 1 byte that should be set to 0x0 )                             length)   -- PDU Length ( 4 bytes - unsigned integer in Little Endian)    if #header < MIN_HEADER_LEN then     return false, \"Header must be at least 6 bytes. Something went wrong.\"   end   return true, header 4 end ```    The `pdu_header_encode()` function will encode the PDU type and length information. After doing some simple sanity checks 1, we define the `header` variable. To encode the byte stream according to the proper endianness and format, we use `string.pack()` and the format string `<B >B I4`, where `<B` represents a single byte in Big Endian 2, and `>B I4` represents a byte, followed by an unsigned integer of four bytes, in Little Endian 3. The function returns a boolean representing the operation status and the result 4.    ### Writing the A-ASSOCIATE Requests Message Contexts    Additionally, we need to write a function that sends and parses the A-ASSOCIATE requests and responses. As you saw earlier in this chapter, the A-ASSOCIATE request message contains different types of contexts: Application, Presentations, and User Info. Because this is a longer function, let’s break it into parts.    The Application Context explicitly defines the service elements and options. In DICOM, you’ll often see *Information Object Definitions* (*IODs*) that represent data objects managed through a central registry. You’ll find the full list of IODs at [http://dicom.nema.org/dicom/2013/output/chtml/part06/chapter_A.html](http://dicom.nema.org/dicom/2013/output/chtml/part06/chapter_A.html). We’ll be reading these IODs from the constant definitions we placed at the beginning of our library. Let’s start the DICOM connection and create the Application Context.    ``` --- -- associate(host, port) Attempts to associate to a DICOM Service Provider by sending an A-ASSOCIATE request. -- -- @param host Host object -- @param port Port object -- @return (status, dcm) If status is true, the DICOM object is returned. --                       If status is false, dcm is the error message. ---  function associate(host, port, calling_aet_arg, called_aet_arg)   local application_context = \"\"   local presentation_context = \"\"   local userinfo_context = \"\"    local status, dcm = start_connection(host, port)   if status == false then     return false, dcm   end    application_context = string.pack(\">1B 2B 3I2 4c\" .. #UID_VALUES[\"APPLICATION_CONTEXT\"],                                     0x10, -- Item type (1 byte)                                     0x0,   -- Reserved ( 1 byte)                                     #UID_VALUES[\"APPLICATION_CONTEXT\"], -- Length (2 bytes)                                     UID_VALUES[\"APPLICATION_CONTEXT\"]) -- Application Context OID ```    An Application Context includes its type (one byte) 1, a reserved field (one byte) 2, the length of the context (two bytes) 3, and the value represented by OIDs 4. To represent this structure in Lua, we use the format string `B B I2 C[#length]`. We can omit the size value from strings of one byte.    We create the Presentation and User Info Contexts in a similar way. Here is the Presentation Context, which defines the Abstract and Transfer Syntax. The *Abstract Syntax* and *Transfer Syntax* are sets of rules for formatting and exchanging objects, and we represent them with IODs.    ``` presentation_context = string.pack(\">B B I2 B B B B B B I2 c\" .. #UID_VALUES[\"VERIFICATION_SOP\"] .. \"B B I2 c\".. #UID_VALUES[\"IMPLICIT_VR\"],                                     0x20, -- Presentation context type ( 1 byte )                                     0x0,  -- Reserved ( 1 byte )                                     0x2e,   -- Item Length ( 2 bytes )                                     0x1,  -- Presentation context id ( 1 byte )                                     0x0,0x0,0x0,  -- Reserved ( 3 bytes )                                     0x30, -- Abstract Syntax Tree ( 1 byte )                                     0x0,  -- Reserved ( 1 byte )                                     0x11,     -- Item Length ( 2 bytes )                                     UID_VALUES[\"VERIFICATION_SOP\"],                                     0x40, -- Transfer Syntax ( 1 byte )                                     0x0,  -- Reserved ( 1 byte )                                     0x11,     -- Item Length ( 2 bytes )                                     UID_VALUES[\"IMPLICIT_VR\"]) ```    Note that there can be several Presentation Contexts. Next, we define the User Info Context:    ```  local implementation_id = \"1.2.276.0.7230010.3.0.3.6.2\"   local implementation_version = \"OFFIS_DCMTK_362\"   userinfo_context = string.pack(\">B B I2 B B I2 I4 B B I2 c\" .. #implementation_id .. \" B B I2 c\".. #implementation_version,                                 0x50,    -- Type 0x50 (1 byte)                                 0x0,     -- Reserved ( 1 byte )                                 0x3a,    -- Length ( 2 bytes )                                 0x51,    -- Type 0x51 ( 1 byte)                                  0x0,     -- Reserved ( 1 byte)                                 0x04,     -- Length ( 2 bytes )                                 0x4000,   -- DATA ( 4 bytes )                                 0x52,    -- Type 0x52 (1 byte)                                 0x0,      -- Reserved (1 byte)                                 0x1b,    -- Length (2 bytes)                                 implementation_id, -- Impl. ID (#implementation_id bytes)                                 0x55,   -- Type 0x55 (1 byte)                                 0x0,     -- Reserved (1 byte)                                 #implementation_version,  -- Length (2 bytes)                                 implementation_version) ```    We now have three variables holding the contexts: `application_context`, `presentation_context`, and `userinfo_context`.    ### Reading Script Arguments in the Nmap Scripting Engine    We’ll append the contexts we just created to the header and A-ASSOCIATE request. To allow other scripts to pass arguments to our function and use different values for the calling and called application entity titles, we’ll offer two options: an optional argument or user supplied input. In the Nmap Scripting Engine, you can read script arguments supplied by `--script-args` using the Nmap Scripting Engine function `stdnse.get_script_args()`, as follows:    ``` local called_ae_title = called_aet_arg or stdnse.get_script_args(\"dicom.called_aet\") or \"ANY-SCP\"   local calling_ae_title = calling_aet_arg or stdnse.get_script_args(\"dicom.calling_aet\") or \"NMAP-DICOM\"   if #calling_ae_title > 16 or #called_ae_title > 16 then     return false, \"Calling/Called AET field can't be longer than 16 bytes.\"   end ```    The structure that holds the application entity titles must be 16 bytes long, so we use `string.rep()` to fill in the rest of the buffer with spaces:    ```  --Fill the rest of buffer with %20   called_ae_title = called_ae_title .. string.rep(\" \", 16 - #called_ae_title)   calling_ae_title = calling_ae_title .. string.rep(\" \", 16 - #calling_ae_title) ```    Now we can define our own calling and called application entity titles using script arguments. We could also use script arguments to write a tool that attempts to guess the correct application entity as if we were brute forcing a password.    ### Defining the A-ASSOCIATE Request Structure    Let’s put our A-ASSOCIATE request together. We define its structure the same way we did in the contexts:    ```  -- ASSOCIATE request   local assoc_request = string.pack(\"1>I2 2I2 3c16 4c16 5c32 6c\" .. application_context:len() .. \" 7c\" .. presentation_context:len() .. \" 8c\".. userinfo_context:len(),                                   0x1, -- Protocol version ( 2 bytes )                                   0x0, -- Reserved section ( 2 bytes that should be set to 0x0 )                                   called_ae_title, -- Called AE title ( 16 bytes)                                   calling_ae_title, -- Calling AE title ( 16 bytes)                                   0x0, -- Reserved section ( 32 bytes set to 0x0 )                                   application_context,                                   presentation_context,                                   userinfo_context) ```    We begin by specifying the protocol version (two bytes) 1, a reserved section (two bytes) 2, the called application entity title (16 bytes) 3, the calling application entity title (16 bytes) 4, another reserved section (32 bytes) 5, and the contexts we just created (`application` 6, `presentation` 7, and `userinfo` 8) .    Now our A-ASSOCIATE request is just missing its header. It’s time to use the `dicom.pdu_header_encode()` function we defined earlier to generate it:    ``` local status, header = pdu_header_encode(PDU_CODES[\"ASSOCIATE_REQUEST\"], #assoc_request) 1    -- Something might be wrong with our header   if status == false then     return false, header   end  assoc_request = header .. assoc_request 2   stdnse.debug2(\"PDU len minus header:%d\", #assoc_request-#header)   if #assoc_request < MIN_SIZE_ASSOC_REQ then     return false, string.format(\"ASSOCIATE request PDU must be at least %d bytes and we tried to send %d.\", MIN_SIZE_ASSOC_REQ, #assoc_request)   end ```    We create a header 1 with the PDU type set to the A-ASSOCIATE request value and then append the message body 2. We also add some error-checking logic here.    Now we can send the complete A-ASSOCIATE request and read the response with some help from our previously defined functions for sending and reading DICOM packets:    ```  status, err = send(dcm, assoc_request)   if status == false then     return false, string.format(\"Couldn't send ASSOCIATE request:%s\", err)   end   status, err = receive(dcm)   if status == false then     return false, string.format(\"Couldn't read ASSOCIATE response:%s\", err)   end    if #err < MIN_SIZE_ASSOC_RESP  then     return false, \"ASSOCIATE response too short.\"   end ```    Great! Next, we’ll need to detect the PDU type used to accept or reject the connection.    ### Parsing A-ASSOCIATE Responses    At this point, the only task left to do is parse the response with some help from `string.unpack()`. It’s similar to `string.pack()`, and we use format strings to define the structure to be read. In this case, we read the response type (one byte), the reserved field (one byte), the length (four bytes), and the protocol version (two bytes) corresponding to the format string `>B B I4 I2`:    ```  local resp_type, _, resp_length, resp_version = string.unpack(\">B B I4 I2\", err)   stdnse.debug1(\"PDU Type:%d Length:%d Protocol:%d\", resp_type, resp_length, resp_version) ```    Then we check the response code to see if it matches the PDU code for ASSOCIATE acceptance or rejection:    ```  if resp_type == PDU_CODES[\"ASSOCIATE_ACCEPT\"] then     stdnse.debug1(\"ASSOCIATE ACCEPT message found!\")     return true, dcm   elseif resp_type == PDU_CODES[\"ASSOCIATE_REJECT\"] then     stdnse.debug1(\"ASSOCIATE REJECT message found!\")     return false, \"ASSOCIATE REJECT received\"   else     return false, \"Unexpected response:\" .. resp_type   end end -- end of function ```    If we receive an ASSOCIATE acceptance message, we’ll return true; otherwise, we’ll return false.    ### Writing the Final Script    Now that we’ve implemented a function to associate with the service, we create the script that loads the library and calls the `dicom.associate()` function:    ``` description = [[ Attempts to discover DICOM servers (DICOM Service Provider) through a partial C-ECHO request.  C-ECHO requests are commonly known as DICOM ping as they are used to test connectivity. Normally, a 'DICOM ping' is formed as follows: * Client -> A-ASSOCIATE request -> Server * Server -> A-ASSOCIATE ACCEPT/REJECT -> Client * Client -> C-ECHO request -> Server * Server -> C-ECHO response -> Client * Client -> A-RELEASE request -> Server * Server -> A-RELEASE response -> Client  For this script we only send the A-ASSOCIATE request and look for the success code in the response as it seems to be a reliable way of detecting a DICOM Service Provider. ]]  --- -- @usage nmap -p4242 --script dicom-ping <target> -- @usage nmap -sV --script dicom-ping <target> --  -- @output -- PORT     STATE SERVICE REASON -- 4242/tcp open  dicom   syn-ack -- |_dicom-ping: DICOM Service Provider discovered ---  author = \"Paulino Calderon <calderon()calderonpale.com>\" license = \"Same as Nmap--See http://nmap.org/book/man-legal.html\" categories = {\"discovery\", \"default\"}  local shortport = require \"shortport\" local dicom = require \"dicom\" local stdnse = require \"stdnse\" local nmap = require \"nmap\"  portrule = shortport.port_or_service({104, 2761, 2762, 4242, 11112}, \"dicom\", \"tcp\", \"open\")  action = function(host, port)   local dcm_conn_status, err = dicom.associate(host, port)   if dcm_conn_status == false then     stdnse.debug1(\"Association failed:%s\", err)     if nmap.verbosity() > 1 then       return string.format(\"Association failed:%s\", err)     else       return nil     end   end   -- We have confirmed it is DICOM, update the service name   port.version.name = \"dicom\"   nmap.set_port_version(host, port)    return \"DICOM Service Provider discovered\"  end ```    First, we fill in some required fields, such as a description, author, license, categories, and an execution rule. We declare the main function of the script with the name `action` as a Lua function. You can learn more about script formats by reading the official documentation ([https://nmap.org/book/nse-script-format.html](https://nmap.org/book/nse-script-format.html)) or by reviewing the collection of official scripts.    If the script finds a DICOM service, the script returns the following output:    ``` Nmap scan report for 127.0.0.1  PORT     STATE SERVICE REASON 4242/tcp open  dicom   syn-ack |_dicom-ping: DICOM Service Provider discovered Final times for host: srtt: 214 rttvar: 5000  to: 100000 ```    Otherwise, the script returns no output, because by default Nmap only shows information when it accurately detects a service.    ## Conclusion    In this chapter, you learned how to work with new network protocols and created tools for the most popular frameworks for network scanning (Nmap) and traffic analysis (Wireshark). You also learned how to perform common operations, such as creating common data structures, handling strings, and performing network I/O operations, to quickly prototype new network security tools in Lua. With this knowledge, you can tackle the challenges presented in this chapter (or new ones) to hone your Lua skills. In the constantly evolving IoT world, the ability to quickly write new network exploitation tools is very handy.    In addition, don’t forget to stick to a methodology when performing security assessments. The one presented in this chapter is only a starting point for understanding and detecting network protocol anomalies. Because the topic is very extensive, we couldn’t cover all common tasks related to protocol analysis, but we highly recommend *Attacking Network Protocols* by James Forshaw (No Starch Press, 2018).````"]