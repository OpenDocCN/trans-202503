- en: '14'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Motors and Movement
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter you will
  prefs: []
  type: TYPE_NORMAL
- en: Use a servo to create an analog thermometer
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Learn how to control the speed and direction of DC electric motors
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Learn how to control small stepper motors
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use an Arduino motor shield
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Begin work on a motorized robot vehicle
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use simple microswitches for collision avoidance
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use infrared and ultrasonic distance sensors for collision avoidance
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Making Small Motions with Servos
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A *servo* (short for *servomechanism*) is an electric motor with a built-in
    sensor. It can be commanded to rotate to a specific angular position. By attaching
    the shaft of the servo to other machines, like wheels, gears, and levers, you
    can precisely control items in the external world. For example, you might use
    a servo to control the steering of a remote control car by connecting the servo
    to a *horn*, a small arm or bar that the servo rotates. An example of a horn is
    one of the hands on an analog clock. [Figure 14-1](#figure14-1) shows a servo
    and three types of horns.
  prefs: []
  type: TYPE_NORMAL
- en: '![f14001](image_fi/500587c14/f14001.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 14-1: A servo and various horns'
  prefs: []
  type: TYPE_NORMAL
- en: Selecting a Servo
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'When you’re selecting a servo, consider several parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: Speed The time it takes for the servo to rotate, usually measured in seconds
    per angular degree, revolutions per minute (RPM), or seconds per 60 degrees.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Rotational range The angular range through which the servo can rotate—for example,
    180 degrees (half of a full rotation) or 360 degrees (one complete rotation).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Current How much current the servo draws. When using a servo with an Arduino,
    you may need to use an external power supply for the servo.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Torque The amount of force the servo can exert when rotating. The greater the
    torque, the heavier the item the servo can control. The torque produced is generally
    proportional to the amount of current used.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The servo shown in [Figure 14-1](#figure14-1) is a generic SG90-type servo.
    It is inexpensive and can rotate up to 180 degrees, as shown in [Figure 14-2](#figure14-2).
  prefs: []
  type: TYPE_NORMAL
- en: '![f14002](image_fi/500587c14/f14002.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 14-2: Example servo rotation range'
  prefs: []
  type: TYPE_NORMAL
- en: Connecting a Servo
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It’s easy to connect a servo to an Arduino because it needs only three wires.
    If you’re using the SG90, the darkest wire connects to GND, the center wire connects
    to 5 V, and the lightest wire (the *pulse* or *data* wire) connects to a digital
    pin. If you’re using a different servo, check its data sheet for the correct wiring.
  prefs: []
  type: TYPE_NORMAL
- en: Putting a Servo to Work
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Now let’s put our servo to work. In this sketch, the servo will turn through
    its rotational range. Connect the servo to your Arduino as described, with the
    pulse wire connected to digital pin 4, and then enter and upload the sketch in
    [Listing 14-1](#listing14-1).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 14-1: Servo demonstration sketch'
  prefs: []
  type: TYPE_NORMAL
- en: 'In this sketch, we use the Servo library, which needs to be installed. Follow
    the instructions outlined in Chapter 7\. In the Library Manager, find and then
    install the “Servo by Michael Margolis, Arduino” library. Create an instance of
    the servo with the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, in `void setup()`, we tell the Arduino which digital pin the servo control
    is using:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we simply move the servo with the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Here, `x` is an integer between 0 and 180 representing the angular position
    to which the servo will be moved. When running the sketch in [Listing 14-1](#listing14-1),
    the servo will rotate across its maximum range, stopping at the extremes (0 degrees
    and 180 degrees) and at the midpoint (90 degrees). When looking at your servo,
    note that the 180-degree position is on the left and 0 degrees is on the right.
  prefs: []
  type: TYPE_NORMAL
- en: In addition to pushing or pulling objects, servos can be used to communicate
    data in a similar way as an analog gauge. For example, you could use a servo as
    an analog thermometer, as you’ll see in Project 37.
  prefs: []
  type: TYPE_NORMAL
- en: 'Project #37: Building an Analog Thermometer'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Using our servo and the TMP36 temperature sensor from earlier chapters, we’ll
    build an analog thermometer. We’ll measure the temperature and then convert this
    measurement to an angle between 0 and 180 degrees to indicate a temperature between
    0 and 30 degrees Celsius. The servo will rotate to the angle that matches the
    current temperature.
  prefs: []
  type: TYPE_NORMAL
- en: The Hardware
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The required hardware is minimal:'
  prefs: []
  type: TYPE_NORMAL
- en: One TMP36 temperature sensor
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: One breadboard
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: One small servo
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Various connecting wires
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Arduino and USB cable
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Schematic
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The circuit is also very simple, as shown in [Figure 14-3](#figure14-3).
  prefs: []
  type: TYPE_NORMAL
- en: '![f14003](image_fi/500587c14/f14003.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 14-3: Schematic for Project 37'
  prefs: []
  type: TYPE_NORMAL
- en: The Sketch
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The sketch will determine the temperature using the same method used in Project
    8 in Chapter 4. Then it will convert the temperature into an angular rotation
    value for the servo.
  prefs: []
  type: TYPE_NORMAL
- en: 'Enter and upload the following sketch:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Most of this sketch should be clear to you at this point, but the function
    `calculateservo()` at 1 is new. This function converts the temperature into the
    matching angle for the servo to use according to the following formula:'
  prefs: []
  type: TYPE_NORMAL
- en: angle = (–6 × temperature) + 180
  prefs: []
  type: TYPE_NORMAL
- en: 'You might find it useful to make a *backing sheet* to show the range of temperatures
    that the servo will display, with a small arrow to create a realistic effect.
    An example is shown in [Figure 14-4](#figure14-4). You can download a printable
    version of the backing sheet from the book’s website: [https://nostarch.com/arduino-workshop-2nd-edition/](https://nostarch.com/arduino-workshop-2nd-edition/).'
  prefs: []
  type: TYPE_NORMAL
- en: '![f14004](image_fi/500587c14/f14004.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 14-4: A backing sheet indicates the temperature on our thermometer.'
  prefs: []
  type: TYPE_NORMAL
- en: Using Electric Motors
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The next step in our motor-controlling journey is to work with small electric
    motors. Small motors are used for many applications, from small fans to toy cars
    to model railroads.
  prefs: []
  type: TYPE_NORMAL
- en: Selecting a Motor
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'As with servos, you need to consider several parameters when you’re choosing
    an electric motor:'
  prefs: []
  type: TYPE_NORMAL
- en: The operating voltage The voltage at which the motor is designed to operate.
    This can vary, from 3 V to more than 12 V.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The current without a load The amount of current the motor uses at its operating
    voltage while spinning freely, without anything connected to the motor’s shaft.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The stall current The amount of current used by the motor when it is trying
    to turn but cannot because of the load on the motor.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The speed at the operating voltage The motor’s speed in RPM.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Our example will use a small, inexpensive electric motor with a speed of 8,540
    RPM when running on 3 V, similar to the one shown in [Figure 14-5](#figure14-5).
  prefs: []
  type: TYPE_NORMAL
- en: '![f14005](image_fi/500587c14/f14005.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 14-5: Our small electric motor'
  prefs: []
  type: TYPE_NORMAL
- en: To control our motor we’ll use a transistor, introduced in Chapter 3. Because
    our motor uses up to 0.7 A of current (more than can be passed by the BC548 transistor),
    we’ll use a transistor called a Darlington for this project.
  prefs: []
  type: TYPE_NORMAL
- en: The TIP120 Darlington Transistor
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A *Darlington transistor* is nothing more than two transistors connected together.
    It can handle high currents and voltages. The TIP120 Darlington can pass up to
    5 A of current at 60 V, which is more than enough to control our small motor.
    The TIP120 uses a similar schematic symbol as the BC548, as shown in [Figure 14-6](#figure14-6),
    but the TIP120 transistor is physically larger than the BC548.
  prefs: []
  type: TYPE_NORMAL
- en: '![f14006](image_fi/500587c14/f14006.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 14-6: TIP120 schematic symbol'
  prefs: []
  type: TYPE_NORMAL
- en: The TIP120 uses the TO-220 housing style, as shown in [Figure 14-7](#figure14-7).
  prefs: []
  type: TYPE_NORMAL
- en: '![f14007](image_fi/500587c14/f14007.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 14-7: The TIP120'
  prefs: []
  type: TYPE_NORMAL
- en: When you’re looking at the TIP120 from the labeled side, the pins from left
    to right are base (B), collector (C), and emitter (E). The metal heat sink tab
    is also connected to the collector.
  prefs: []
  type: TYPE_NORMAL
- en: 'Project #38: Controlling the Motor'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this project, we’ll control the motor by adjusting the speed.
  prefs: []
  type: TYPE_NORMAL
- en: The Hardware
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The following hardware is required:'
  prefs: []
  type: TYPE_NORMAL
- en: One small 3 V electric motor
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: One 1 kΩ resistor (R1)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: One breadboard
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: One 1N4004 diode
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: One TIP120 Darlington transistor
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A separate 3 V power source
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Various connecting wires
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Arduino and USB cable
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You must use a separate power source for motors, because the Arduino cannot
    supply enough current for the motor in all possible situations. If the motor becomes
    stuck, then it will draw up to its *stall current*, which could be more than 1
    A. That’s more than the Arduino can supply, and if it attempts to supply that
    much current the Arduino could be permanently damaged.
  prefs: []
  type: TYPE_NORMAL
- en: A separate battery holder is a simple solution. For a 3 V supply, a two-cell
    AA battery holder with flying leads will suffice, such as the one shown in [Figure
    14-8](#figure14-8).
  prefs: []
  type: TYPE_NORMAL
- en: '![f14008](image_fi/500587c14/f14008.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 14-8: A two-cell AA battery holder'
  prefs: []
  type: TYPE_NORMAL
- en: The Schematic
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Assemble the circuit as shown in the schematic in [Figure 14-9](#figure14-9).
  prefs: []
  type: TYPE_NORMAL
- en: '![f14009](image_fi/500587c14/f14009.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 14-9: Schematic for Project 38'
  prefs: []
  type: TYPE_NORMAL
- en: The Sketch
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In this project, we’ll adjust the speed of the motor from stopped (zero) to
    the maximum and then reduce it back to zero. Enter and upload the following sketch:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'We control the speed of the motor using pulse-width modulation (as demonstrated
    in Project 3 in Chapter 3). Recall that we can do this only with digital pins
    3, 5, 6, 9, 10, and 11\. Using this method, current is applied to the motor in
    short bursts: the longer the burst, the faster the speed, as the motor is on more
    than it is off during a set period of time. So at 1, the motor speed starts at
    zero and increases slowly; you can control the acceleration by changing the `delay`
    value at 2. At 3, the motor is running as fast as possible and holds that speed
    for 5 seconds. Then, from 4, the process reverses, and the motor slows to a stop.'
  prefs: []
  type: TYPE_NORMAL
- en: The diode is used in the same way it was with the relay control circuit described
    in Figure 3-19 on page 42 to protect the circuit. When the current is switched
    off from the motor, stray current exists for a brief time inside the motor’s coil
    and has to go somewhere. The diode allows the stray current to loop around through
    the coil until it dissipates as a tiny amount of heat.
  prefs: []
  type: TYPE_NORMAL
- en: Using Small Stepper Motors
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Stepper motors are different from regular DC motors, in that they divide a full
    rotation of the motor into a fixed number of steps. They do this by using two
    coil windings that are independently controlled. So instead of controlling a rotation
    with varying voltage as with a regular DC motor, you instead turn on or off the
    coils in a stepper motor in a certain pattern to rotate the shaft in either direction
    a set number of times. This control makes steppers ideal for jobs that need precise
    motor positioning. They are quite commonly found in devices from computer printers
    to advanced manufacturing devices.
  prefs: []
  type: TYPE_NORMAL
- en: We will demonstrate stepper motor operation using the model 28BYJ-48, as shown
    in [Figure 14-10](#figure14-10). This type of stepper motor can be controlled
    to rotate to one of 4,096 positions; that is, one full rotation is divided into
    4,096 steps.
  prefs: []
  type: TYPE_NORMAL
- en: '![f14010](image_fi/500587c14/f14010.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 14-10: A stepper motor and controller board'
  prefs: []
  type: TYPE_NORMAL
- en: The board next to the motor is used as an interface between your Arduino and
    the stepper motor, making connection easy and fast. It is usually supplied along
    with the stepper motor. A close-up is shown in [Figure 14-11](#figure14-11).
  prefs: []
  type: TYPE_NORMAL
- en: '![f14011](image_fi/500587c14/f14011.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 14-11: The stepper motor controller board'
  prefs: []
  type: TYPE_NORMAL
- en: Now to connect your stepper motor to the Arduino. Make the connections as shown
    in [Table 14-1](#table14-1).
  prefs: []
  type: TYPE_NORMAL
- en: 'Table 14-1: Connections Between the Stepper Motor Controller Board and the
    Arduino'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Control board pin label** | **Arduino pin** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| IN1 | D8 |'
  prefs: []
  type: TYPE_TB
- en: '| IN2 | D9 |'
  prefs: []
  type: TYPE_TB
- en: '| IN3 | D10 |'
  prefs: []
  type: TYPE_TB
- en: '| IN4 | D11 |'
  prefs: []
  type: TYPE_TB
- en: '| 5–12 V+ | 5 V |'
  prefs: []
  type: TYPE_TB
- en: '| 5–12 V− | GND |'
  prefs: []
  type: TYPE_TB
- en: You can briefly run the stepper motor using power from your Arduino if nothing
    else is drawing power from the Arduino. However, this is not recommended. Instead,
    use an external 5 V power supply such as a plug pack or other convenient source.
    As the controller board doesn’t have a DC socket, you can use an external socket
    with terminal blocks to make easy, solderless connections, as shown in [Figure
    14-12](#figure14-12).
  prefs: []
  type: TYPE_NORMAL
- en: '![f14012](image_fi/500587c14/f14012.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 14-12: DC socket terminal block'
  prefs: []
  type: TYPE_NORMAL
- en: You can then connect jumper wires from the + and – connectors on the terminal
    blocks to those on the stepper motor controller board. To simplify controlling
    the stepper motor in our Arduino sketches, you can use a neat Arduino library
    called CheapStepper. You can download it from [https://github.com/tyhenry/CheapStepper/archive/master.zip](https://github.com/tyhenry/CheapStepper/archive/master.zip)
    and install it using the method described in Chapter 7.
  prefs: []
  type: TYPE_NORMAL
- en: Once you have successfully installed the library and connected your stepper
    motor as described earlier, enter and upload [Listing 14-2](#listing14-2).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 14-2: Testing the stepper motor'
  prefs: []
  type: TYPE_NORMAL
- en: 'Operation of the stepper motor is quite simple. We first include the library
    at 1 and create an instance of the motor at 2. (If you wish to change the digital
    pins used for the controller board, update them here.) The control function uses
    `true` and `false` for clockwise and counterclockwise rotation, respectively,
    so we assign these to Boolean variables at 3 to make things clearer. Finally,
    the motor can be instructed to rotate to one of the 4,096 positions using the
    function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: where the direction is either `clockwise` or `cclockwise` and the location is
    a value between 0 and 4,095\. This is done starting at 5 and repeatedly through
    the end of the sketch.
  prefs: []
  type: TYPE_NORMAL
- en: 'Furthermore, in `void setup()` at 4, we set the motor’s rotational speed to
    20 RPM using:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: This is the recommended speed for our stepper motor. Other motors will vary,
    so you should check with the supplier for these details.
  prefs: []
  type: TYPE_NORMAL
- en: A few moments after you upload the sketch, your stepper motor will start rotating
    to various positions, and you can see the commands echoed in the Serial Monitor,
    as shown in [Figure 14-13](#figure14-13).
  prefs: []
  type: TYPE_NORMAL
- en: '![f14013](image_fi/500587c14/f14013.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 14-13: Commands sent to the stepper motor'
  prefs: []
  type: TYPE_NORMAL
- en: 'Project #39: Building and Controlling a Robot Vehicle'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Although controlling the speed of one DC motor can be useful, let’s move into
    more interesting territory by controlling four DC motors at once and affecting
    their speed *and* direction. Our goal is to construct a four-wheeled vehicle-style
    robot that we’ll continue to work on in the next few chapters. Here I’ll describe
    the construction and basic control of our robot.
  prefs: []
  type: TYPE_NORMAL
- en: Our robot has four motors that each control one wheel, allowing it to travel
    at various speeds as well as rotate in place. You will be able to control the
    speed and direction of travel, and you will also learn how to add parts to enable
    collision avoidance and remote control. Once you have completed the projects in
    this book, you will have a solid foundation for creating your own versions of
    this robot and bringing your ideas to life.
  prefs: []
  type: TYPE_NORMAL
- en: The Hardware
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You’ll need the following hardware :'
  prefs: []
  type: TYPE_NORMAL
- en: Robot vehicle chassis with four DC motors and wheels
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Four-cell AA battery holder with wired output
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Four alkaline AA cells
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: L293D Motor Drive Shield for Arduino
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Arduino and USB cable
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Chassis
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The foundation of any robot is a solid chassis containing the motors, drivetrain,
    and power supply. An Arduino-powered robot also needs to have room to mount the
    Arduino and various external parts.
  prefs: []
  type: TYPE_NORMAL
- en: You can choose from many chassis models available on the market. To keep things
    simple, we’re using an inexpensive robot chassis that includes four small DC motors
    that operate at around 6 V DC and matching wheels, as shown in [Figure 14-14](#figure14-14).
  prefs: []
  type: TYPE_NORMAL
- en: '![f14014](image_fi/500587c14/f14014.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 14-14: Our robot chassis'
  prefs: []
  type: TYPE_NORMAL
- en: The task of physically assembling the robot chassis will vary between models,
    and you may need a few basic tools such as screwdrivers and pliers. If you’re
    not sure about your final design but wish to get your robot moving, a favored
    technique is to hold the electronics to the chassis with sticky products such
    as Blu Tack.
  prefs: []
  type: TYPE_NORMAL
- en: The Power Supply
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The motors included with the robot chassis typically operate at around 6 V DC,
    so we’ll use a four-cell AA battery holder to power our robot, as shown in [Figure
    14-15](#figure14-15).
  prefs: []
  type: TYPE_NORMAL
- en: '![f14015](image_fi/500587c14/f14015.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 14-15: A battery holder for four AA cells'
  prefs: []
  type: TYPE_NORMAL
- en: Some AA cell battery holders will not have the wiring needed to connect to our
    project and instead will have connections for a 9 V battery snap (as our unit
    in [Figure 14-15](#figure14-15) does). In this case, you’ll need a battery snap
    like the one in [Figure 14-16](#figure14-16).
  prefs: []
  type: TYPE_NORMAL
- en: '![f14016](image_fi/500587c14/f14016.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 14-16: A battery cable used to connect the battery holder to the Arduino'
  prefs: []
  type: TYPE_NORMAL
- en: The Schematic
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The final requirement is to create the circuitry to control the four motors
    in the chassis. Although we could use the circuitry shown in [Figure 14-9](#figure14-9)
    for each of the motors, this wouldn’t allow us to control the direction of the
    motors and could be somewhat inconvenient to wire up ourselves. Instead, we’ll
    use a *motor shield*. A motor shield contains the circuitry we need to handle
    the higher current drawn by the motors and accepts commands from the Arduino to
    control both the speed and direction of the motors. For our robot, we’ll use an
    L293D Motor Drive Shield for Arduino, as shown in [Figure 14-17](#figure14-17).
  prefs: []
  type: TYPE_NORMAL
- en: '![f14017](image_fi/500587c14/f14017.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 14-17: An L293D Motor Drive Shield for Arduino'
  prefs: []
  type: TYPE_NORMAL
- en: Connecting the Motor Shield
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Making the required connections to the motor shield is simple: connect the
    wires from the battery holder to the terminal block at the bottom left of the
    shield, as shown in [Figure 14-18](#figure14-18). The black wire (negative) must
    be on the right side and the red wire on the left.'
  prefs: []
  type: TYPE_NORMAL
- en: '![f14018](image_fi/500587c14/f14018.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 14-18: DC power connection'
  prefs: []
  type: TYPE_NORMAL
- en: Next you need to connect each DC motor to the motor shield. We’ll refer to the
    two DC motors at the front of the chassis as motor 2 (left) and motor 1 (right)
    and the two DC motors at the rear as motor 3 (left) and motor 4 (right). Each
    motor will have a red and a black wire, so connect them to the matching terminal
    blocks on the left-hand and right-hand side of the motor shield, as shown in [Figure
    14-19](#figure14-19).
  prefs: []
  type: TYPE_NORMAL
- en: '![f14019](image_fi/500587c14/f14019.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 14-19: Connecting the motors'
  prefs: []
  type: TYPE_NORMAL
- en: When connecting the wires from the DC motors, note that the black wires are
    on the outside ends of the terminal blocks and the red wires are on the internal
    ends. Furthermore, each terminal block is labeled with our matching motor number
    (M1, M2, M3, and M4) for easy reference.
  prefs: []
  type: TYPE_NORMAL
- en: If your motor’s wires are not color coded, you may have to swap them after the
    first run to determine which way is forward or backward.
  prefs: []
  type: TYPE_NORMAL
- en: After you’ve connected the power and motor wires to the shield and the shield
    to your Arduino, the robot should look something like the one in [Figure 14-20](#figure14-20).
  prefs: []
  type: TYPE_NORMAL
- en: '![f14020](image_fi/500587c14/f14020.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 14-20: Our robot is ready for action!'
  prefs: []
  type: TYPE_NORMAL
- en: The Sketch
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Now to get the robot moving. To simplify its operation, we first need to download
    and install the Arduino library for the motor drive shield. Follow the instructions
    outlined in Chapter 7\. In the Library Manager, find and then install the “Adafruit
    Motor Shield library by Adafruit.”
  prefs: []
  type: TYPE_NORMAL
- en: After a moment, the Adafruit Motor Shield library v1 will appear. Click **Install**
    and wait for the library to be installed. You can then close the Library Manager
    window.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we’ll create some functions to operate our robot. Because two motors are
    involved, we’ll need four movements:'
  prefs: []
  type: TYPE_NORMAL
- en: Forward motion
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reverse motion
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Rotate clockwise
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Rotate counterclockwise
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Thus, we’ll need four functions in our sketch to match our four movements:
    `goForward()`, `goBackward()`, `rotateLeft()`, and `rotateRight()`. Each accepts
    a value in milliseconds, which is the length of time required to operate the movement,
    and a PWM value between 0 and 255\. For example, to move forward for 2 seconds
    at full speed, we’d use `goForward(255,2000)`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Enter and save the following sketch (but don’t upload it just yet):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Controlling the robot is easy thanks to the four custom functions in the sketch.
    Each custom function makes use of the library functions used to control a motor.
    Before you can use these functions, you need to create an instance for each motor,
    as shown at 1.
  prefs: []
  type: TYPE_NORMAL
- en: 'The direction of travel for each motor is set using:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: The value of `direction` is either `FORWARD`, `REVERSE`, or `RELEASE`, to set
    the motor’s rotational direction forward or backward or cut power to the motor,
    respectively.
  prefs: []
  type: TYPE_NORMAL
- en: 'To set the speed of the motor, we use:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: The value of `speed` is between `0` and `255`; it is the range of PWM used to
    control the rotational speed of the motor.
  prefs: []
  type: TYPE_NORMAL
- en: 'Therefore, in each of our four custom functions at 2, we use the combination
    of the motor speed and directional controls to control all four motors at once.
    Each of the custom functions accepts two parameters: `speed` (our PWM value) and
    `duration` (the amount of time to run the motor).'
  prefs: []
  type: TYPE_NORMAL
- en: Upload the sketch, remove the USB cable, and connect the battery cable to the
    Arduino power socket. Then place the robot on carpet or a clean surface and let
    it drive about. Experiment with the movement functions in the sketch to control
    your robot; this will help you become familiar with the time delays and how they
    relate to distance traveled.
  prefs: []
  type: TYPE_NORMAL
- en: Connecting Extra Hardware to the Robot
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Some motor drive shields for Arduino may not have stacking header sockets to
    enable you to put another shield on top, and they might not allow easy connection
    of wires from sensors, etc. In this case, you should use a *terminal shield* for
    Arduino, an example of which is shown in [Figure 14-21](#figure14-21).
  prefs: []
  type: TYPE_NORMAL
- en: '![f14021](image_fi/500587c14/f14021.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 14-21: A terminal shield for Arduino'
  prefs: []
  type: TYPE_NORMAL
- en: Terminal shields allow for easy wiring of hardware or sensors to the Arduino’s
    input and output pins without any soldering, and they can also be used to build
    your own circuitry for more permanent uses later.
  prefs: []
  type: TYPE_NORMAL
- en: Sensing Collisions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now that our robot can move, we can start to add sensors. These will tell the
    robot when it has bumped into something, or they will measure the distance between
    the robot and an object in its path so that it can avoid a crash. We’ll use three
    methods of collision avoidance: microswitches, infrared, and ultrasonic.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Project #40: Detecting Robot Vehicle Collisions with a Microswitch'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A *microswitch* can act like the simple push button we used in Chapter 4, but
    the microswitch component is physically larger and includes a large metal bar
    that serves as the actuator (see [Figure 14-22](#figure14-22)).
  prefs: []
  type: TYPE_NORMAL
- en: '![f14022](image_fi/500587c14/f14022.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 14-22: A microswitch'
  prefs: []
  type: TYPE_NORMAL
- en: When using a microswitch, you connect one wire to the bottom contact and the
    other to the contact labeled NO (normally open) to ensure that current flows only
    when the bar is pressed. We’ll mount the microswitch on the front of our robot
    so that when the robot hits an object, the bar will be pressed, causing current
    to flow and making the robot reverse direction or take another action.
  prefs: []
  type: TYPE_NORMAL
- en: The Schematic
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The microswitch hardware is wired like a single push button, as shown in [Figure
    14-23](#figure14-23).
  prefs: []
  type: TYPE_NORMAL
- en: '![f14023](image_fi/500587c14/f14023.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 14-23: Schematic for Project 40'
  prefs: []
  type: TYPE_NORMAL
- en: The Sketch
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We connect the microswitch to an interrupt port (digital pin 2). Although you
    might think we should have a function called by the interrupt to make the robot
    reverse for a few moments, that’s not possible, because the `delay()` function
    doesn’t operate inside functions called by interrupts. We must think a little
    differently in this case.
  prefs: []
  type: TYPE_NORMAL
- en: Instead, the function `goForward()` will turn on the motors if two conditions
    are met for the variables `crash` and the Boolean `move`. If `crash` is `true`,
    the motors will reverse at a slower speed for 2 seconds to back away from a collision
    situation.
  prefs: []
  type: TYPE_NORMAL
- en: We can’t use `delay()` because of the interrupt, so we measure the amount of
    time that the motors run by reading `millis()` at the start and comparing that
    against the current value of `millis()`. When the difference is greater than or
    equal to the required duration, `move` is set to `false` and the motors stop.
  prefs: []
  type: TYPE_NORMAL
- en: 'Enter and upload the following sketch:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: This sketch uses an advanced method of moving forward, in that two variables
    are used to monitor movement while the robot is in motion. The first is the Boolean
    variable `crash`. If the robot bumps into something and activates the microswitch,
    then an interrupt is called, which runs the function `backOut()` at 1. It is here
    that the variable `crash` is changed from `false` to `true`. The second variable
    that is monitored is the Boolean variable `move`. In the function `goForward()`,
    we use `millis()` at 2 to calculate constantly whether the robot has finished
    moving for the required period of time (set by the parameter `duration`).
  prefs: []
  type: TYPE_NORMAL
- en: At 4, the function calculates whether the elapsed time is less than the required
    time, and if so, the variable `move` is set to `true`. Therefore, the robot is
    allowed to move forward only if it has not crashed and not run out of time. If
    a crash has been detected, the function `goBackward()` at 3 is called, at which
    point the robot will reverse slowly for 2 seconds and then resume as normal.
  prefs: []
  type: TYPE_NORMAL
- en: Infrared Distance Sensors
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Our next method of collision avoidance uses an infrared (IR) distance sensor.
    This sensor bounces an infrared light signal off a surface in front of it and
    returns a voltage that is relative to the distance between the sensor and the
    surface. Infrared sensors are useful for collision detection because they are
    inexpensive, but they’re not ideal for *exact* distance measuring. We’ll use the
    Sharp GP2Y0A21YK0F analog sensor, shown in [Figure 14-24](#figure14-24), for our
    project.
  prefs: []
  type: TYPE_NORMAL
- en: '![f14024](image_fi/500587c14/f14024.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 14-24: The Sharp IR sensor'
  prefs: []
  type: TYPE_NORMAL
- en: Wiring It Up
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To wire the sensor, connect the red and black wires on the sensor to 5 V and
    GND, respectively, with the white wire connecting to an analog input pin on your
    Arduino. We’ll use `analogRead()` to measure the voltage returned from the sensor.
    The graph in [Figure 14-25](#figure14-25) shows the relationship between the distance
    measured and the output voltage.
  prefs: []
  type: TYPE_NORMAL
- en: '![f14025](image_fi/500587c14/f14025.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 14-25: Graph of IR sensor distance versus output voltage'
  prefs: []
  type: TYPE_NORMAL
- en: Testing the IR Distance Sensor
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Because the relationship between distance and output is not easily represented
    with an equation, we’ll categorize the readings into 5 cm stages. To demonstrate
    this, we’ll use a simple example. Connect your infrared sensor’s white lead to
    analog pin 0, the red lead to 5 V, and the black lead to GND. Then enter and upload
    the sketch shown in [Listing 14-3](#listing14-3).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 14-3: IR sensor demonstration sketch'
  prefs: []
  type: TYPE_NORMAL
- en: The sketch reads the voltage from the IR sensor at 1 and then uses a series
    of `if` statements at 2 to choose which approximate distance is being returned.
    We determine the distance from the voltage returned by the sensor using two parameters.
    The first is the voltage-to-distance relationship, as displayed in [Figure 14-25](#figure14-25).
    Then, using the knowledge (from Project 6 in Chapter 4) that `analogRead()` returns
    a value between 0 and 1,023 relative to a voltage between 0 V and around 5 V,
    we can calculate the approximate distance returned by the sensor.
  prefs: []
  type: TYPE_NORMAL
- en: After uploading the sketch, open the Serial Monitor and experiment by moving
    your hand or a piece of paper at various distances from the sensor. The Serial
    Monitor should return the approximate distance, as shown in [Figure 14-26](#figure14-26).
  prefs: []
  type: TYPE_NORMAL
- en: '![f14026](image_fi/500587c14/f14026.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 14-26: Results of [Listing 14-3](#listing14-3)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Project #41: Detecting Robot Vehicle Collisions with an IR Distance Sensor'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now let’s use the IR sensor with our robot vehicle instead of the microswitch.
    We’ll use a slightly modified version of Project 40\. Instead of using an interrupt,
    we’ll create the function `checkDistance()`, which changes the variable `crash`
    to `true` if the distance measured by the IR sensor is around 20 cm or less. We’ll
    use this in the `goForward()` forward motion `do-while` loop.
  prefs: []
  type: TYPE_NORMAL
- en: The Sketch
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Connect the IR sensor to your robot and then enter and upload this sketch:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: This sketch operates using the same methods used in Project 40, except this
    version constantly takes distance measurements at 1 and sets the `crash` variable
    to `true` if the distance between the IR sensor and an object is less than about
    20 cm.
  prefs: []
  type: TYPE_NORMAL
- en: 'Modifying the Sketch: Adding More Sensors'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: After running the robot and using this sensor, you should see the benefits of
    using a non-contact collision sensor. It’s simple to add more sensors to the same
    robot, such as sensors at the front and rear or at each corner. You should be
    able to add code to check each sensor in turn and make a decision based on the
    returned distance value.
  prefs: []
  type: TYPE_NORMAL
- en: Ultrasonic Distance Sensors
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Our final method of collision avoidance uses an *ultrasonic distance sensor*.
    This sensor bounces a sound wave of an ultra-high frequency (that cannot be heard
    by the human ear) off a surface and measures the amount of time it takes for the
    sound to return to the sensor. We’ll use the common HC-SR04-type ultrasonic distance
    sensor, shown in [Figure 14-27](#figure14-27), for this project, because it’s
    inexpensive and accurate to around 2 cm.
  prefs: []
  type: TYPE_NORMAL
- en: '![f14027](image_fi/500587c14/f14027.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 14-27: The HC-SR04 ultrasonic distance sensor'
  prefs: []
  type: TYPE_NORMAL
- en: An ultrasonic sensor’s accuracy and range mean it can measure distances between
    about 2 and 450 cm. However, because the sound wave needs to be reflected back
    to the sensor, the sensor must be angled less than 15 degrees away from the direction
    of travel.
  prefs: []
  type: TYPE_NORMAL
- en: Connecting the Ultrasonic Sensor
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To connect the sensor, attach the Vcc (5 V) and GND leads to their connectors
    on the motor drive shield, attach the Trig pin to digital pin D2, and attach the
    Echo pin to digital pin D13\. We use D2 and D13 as they are not used by the motor
    drive shield. However, if you’re just testing or experimenting with the sensor
    without the robot, you can connect the wires directly to your Arduino board.
  prefs: []
  type: TYPE_NORMAL
- en: To simplify operation of the sensor, download the Arduino library from [https://github.com/Martinsos/arduino-lib-hc-sr04/archive/master.zip](https://github.com/Martinsos/arduino-lib-hc-sr04/archive/master.zip)
    and install it as explained in Chapter 7. Once the library is installed, you can
    run the test sketch in [Listing 14-4](#listing14-4) to see how the sensor works.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 14-4: Ultrasonic sensor demonstration sketch'
  prefs: []
  type: TYPE_NORMAL
- en: Retrieving the distance from the sensor is quite simple thanks to the library.
    At 1, we create an instance and declare which digital pins are connected to the
    sensor. Then at 2, we have a floating-point variable used to store the distance
    returned from the sensor’s library function. Finally, the distance is generated
    at 3 for display in the Serial Monitor.
  prefs: []
  type: TYPE_NORMAL
- en: Testing the Ultrasonic Sensor
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: After uploading the sketch, open the Serial Monitor and move an object toward
    and away from the sensor. The distance to the object should be returned in centimeters.
    See how it works in [Figure 14-28](#figure14-28).
  prefs: []
  type: TYPE_NORMAL
- en: '![f14028](image_fi/500587c14/f14028.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 14-28: Results from [Listing 14-4](#listing14-4)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Project #42: Detecting Collisions with an Ultrasonic Distance Sensor'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now that you understand how the sensor works, let’s use it with our robot.
  prefs: []
  type: TYPE_NORMAL
- en: The Sketch
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In the following sketch, we check for distances between the robot and an object
    of 5 cm or less, which will give the robot a reason to back up. Enter and upload
    the following sketch to see for yourself:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: The operation of this sketch should be quite familiar by now. Once again, we
    constantly measure the distance at 1 and then change the variable `crash` to `true`
    if the distance between the ultrasonic sensor and an object in its path is less
    than 5 cm. Watching the robot magically avoid colliding with things or having
    a battle of wits with a pet can be quite amazing.
  prefs: []
  type: TYPE_NORMAL
- en: Looking Ahead
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this chapter, you learned how to introduce your Arduino-based projects to
    the world of movement. Using simple motors, or pairs of motors, with a motor shield,
    you can create projects that can move on their own and even avoid obstacles. We
    used three types of sensors to demonstrate a range of accuracies and sensor costs,
    so you can now make decisions based on your requirements and project budget.
  prefs: []
  type: TYPE_NORMAL
- en: By now, I hope you are experiencing and enjoying the ability to design and construct
    such things. But it doesn’t stop here. In the next chapter, we move outdoors and
    harness the power of satellite navigation.
  prefs: []
  type: TYPE_NORMAL
