- en: <hgroup>
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">15</samp> <samp class="SANS_Dogma_OT_Bold_B_11">BIPARTITE
    GRAPH MATCHING</samp>
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: </hgroup>
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/opener.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Many problems in business and logistics consist of matching items from two different
    sets. We might want to match people with jobs, conferences with locations, vehicles
    with routes, or adopted pets with homes. In each case, we must ask which item
    from one set is compatible with which item from the second set. This chapter explores
    this problem, called *bipartite graph matching*, in detail.
  prefs: []
  type: TYPE_NORMAL
- en: 'A *bipartite graph* is a graph consisting of two disjoint sets of nodes where
    each edge always has one end in each set. This graph naturally lends itself to
    the matching problem: each set of nodes represents one of the sets of items that
    we want to match, while edges indicate compatibility between the items.'
  prefs: []
  type: TYPE_NORMAL
- en: This chapter begins by discussing the broader concept of matching on a graph
    before formally introducing undirected bipartite graphs and bipartite matching
    algorithms, showing along the way how graph matching encompasses a rich set of
    problems, from assigning partners for group work to scheduling jobs in a data
    center, and technical challenges.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Matching</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A *matching* on an undirected graph is a set of edges that do not share any
    nodes. In other words, each edge in the matching connects two different nodes,
    and each node is adjacent to at most one edge. We can visualize matchings via
    pairing up students for project work using their friendship connections. Each
    edge in the matching represents two friends (the edge’s two nodes) who will collaborate
    on the project. As a natural consequence of this pairwise assignment, we pair
    up only students with existing social connections and do not guarantee that all
    students will find a partner.
  prefs: []
  type: TYPE_NORMAL
- en: The general concept of matching opens up a range of problems we can solve. As
    concrete examples for this chapter, let’s examine two particularly useful matching
    problems. First, finding a *maximum-cardinality matching* (sometimes shortened
    to *maximum matching*) consists of finding a matching with the most edges. This
    corresponds to finding an assignment of students to pairs that creates the most
    groups. Second, a *maximal matching* is any matching where no additional edges
    can be added without breaking the matching property. While a maximum-cardinality
    matching is always a maximal matching, the converse is not true.
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 15-1](#fig15-1) shows examples of these two matching types. We cannot
    add any more edges to the maximal matching in [Figure 15-1(a)](#fig15-1), represented
    by the bold edges, without reusing a node. Meanwhile, [Figure 15-1(b)](#fig15-1)
    is both a maximal matching and a maximum-cardinality matching: we cannot create
    a matching for this graph with more than three edges.'
  prefs: []
  type: TYPE_NORMAL
- en: '![A graph with undirected edges (0,1), (0,3), (1, 2), (1, 4), (1, 5), (2, 5)
    and (4, 5). (A) has edges (0, 3) and (1, 5) bolded. (B) has edges (0, 3), (1,
    2), and (4, 5) bolded.](../images/f15001.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 15-1: Maximal (a) and
    maximum-cardinality (b) matching</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: The problem of finding a *maximum-weight matching* consists of finding the matching
    in a weighted graph that maximizes the sum of the edge weights. This corresponds
    to prioritizing the strength of the students’ friendships when allocating the
    groups. While this approach is useful in the context of maximizing a reward function
    such as student happiness, it does not necessarily lead to a maximum-cardinality
    matching. For example, [Figure 15-2](#fig15-2) shows a maximum-weight matching
    that is not a maximum-cardinality matching. Two pairs of nodes {0, 1} and {2,
    5} are matched, while nodes 3 and 4 are left out.
  prefs: []
  type: TYPE_NORMAL
- en: '![A graph with undirected, weighted edges. Edge (0,1) has weight 10\. Edge
    (0,3) has weight 1\. Edge (1, 2) has weight 3\. Edge (1, 4) has weight 5\. Edge
    (1, 5) has weight 1\. Edge (2, 5) has weight 19\. Edge (4, 5) has weight 4\. The
    edges (0, 1) and (2, 5) are bolded.](../images/f15002.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 15-2: The maximum- weight
    matching on a graph</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: The list of possible matching problems continues beyond these initial examples.
    We could ask whether a graph has a *perfect matching*, where every node is included
    exactly once; find a maximum-cardinality matching that minimizes the sum of the
    edge weights; or find a matching that maximizes the weight while keeping below
    a given number of edges. Throughout the rest of the chapter, we will focus primarily
    on maximum-cardinality matching, one of the simplest and most broadly applicable
    formulations, in the context of a specific graph type.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Bipartite Graphs</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As noted earlier, a *bipartite graph* can be partitioned into two disjoint sets
    of nodes such that no edge connects two nodes in the same set. Bipartite graphs
    are often visualized as two parallel lines of nodes, as shown in [Figure 15-3](#fig15-3).
    The left and right columns define the two sets of nodes. Every edge in the graph
    spans the columns.
  prefs: []
  type: TYPE_NORMAL
- en: '![A graph with seven nodes and undirected edges (0, 3), (0, 5), (2, 1), (2,
    5), (4, 3), (4, 5) and (6, 1). The even nodes are in a column on the left and
    the odd nodes are in a column on the right. All edges go between two columns.](../images/f15003.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 15-3: A bipartite graph
    with seven nodes</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: Bipartite graphs provide a natural model for pairwise matching problems. In
    a canonical example, the items on the left represent people and the ones on the
    right represent the jobs for which they are qualified, summarizing a complex set
    of constraints in a simple graph.
  prefs: []
  type: TYPE_NORMAL
- en: Although matching is the focus of this chapter, the usefulness of bipartite
    graphs does not end there. Bipartite graphs can model a range of phenomena, from
    physical bridges crossing a river to spies watching each other at a party.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Bipartite Labeling</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Given an undirected graph, we can ask whether it is a bipartite graph and, if
    so, which node is part of which set. We can use the properties of a bipartite
    graph to perform both this check and the labeling of which nodes are in which
    set. We know that any path through an undirected bipartite graph must zigzag between
    the two sets, and a node can never have a neighbor within its own set. We use
    a simple search, either breadth-first or depth-first, to traverse the undirected
    graph and assign labels to nodes. The key is that we arbitrarily assign the first
    node one label and then alternate labels each time we cross an edge. If we ever
    find two neighbors with the same label, we know the graph is not bipartite.
  prefs: []
  type: TYPE_NORMAL
- en: We can picture the algorithm in the context of competing spy agencies at a cocktail
    party. The agencies consist of disjoint sets of spies, represented as nodes. Each
    edge signifies the connection between two people who are watching each other.
    The spies are well trained and can each keep an eye on multiple people at once—Spy
    A might be watching Spy B, Spy C, and Spy D!
  prefs: []
  type: TYPE_NORMAL
- en: A bored waiter, unaware of the true identities of anyone in the ballroom, uses
    the opportunity to determine which spies work together. They start by picking
    one spy at random and assigning them to the green team. They determine all the
    people that spy is watching and assign each of them to the yellow team. Then,
    for each of the newly discovered yellow members, the waiter determines who they
    are watching and assigns those people being watched to the green team. The process
    bounces back and forth, uncovering the affiliations of each person as the waiter
    serves various appetizers.
  prefs: []
  type: TYPE_NORMAL
- en: Of course, if the waiter ever finds a spy watching a member of their own team,
    they know they do not have a bipartite graph. Maybe the agencies sent internal
    affairs or there is a double agent. Regardless, the situation is no longer as
    clear as yellow versus green and probably is not something with which the waiter
    wants to be involved.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">The Code</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The code for bipartite graph labeling in [Listing 15-1](#list15-1) uses a breadth-first
    search to iteratively explore the graph and label nodes as belonging to either
    the right or left side.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 15-1: Labeling nodes
    according to which side of the bipartite graph they occupy</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">bipartite_labeling()</samp>
    function maintains a list mapping each node index to one of three states (unlabeled
    = <samp class="SANS_TheSansMonoCd_W5Regular_11">None</samp>, right = <samp class="SANS_TheSansMonoCd_W5Regular_11">False</samp>,
    or left = <samp class="SANS_TheSansMonoCd_W5Regular_11">True</samp>) using a combination
    of Boolean and <samp class="SANS_TheSansMonoCd_W5Regular_11">None</samp> values.
    The code starts by setting up the list of labels (<samp class="SANS_TheSansMonoCd_W5Regular_11">label</samp>)
    and a queue (<samp class="SANS_TheSansMonoCd_W5Regular_11">pending</samp>), which
    requires us to import Python’s <samp class="SANS_TheSansMonoCd_W5Regular_11">queue</samp>
    library. Each label is initialized to <samp class="SANS_TheSansMonoCd_W5Regular_11">None</samp>,
    indicating that the algorithm has not yet seen a node and given it a label. This
    list will serve the roles of both tracking the seen nodes in breadth-first search
    and storing the labels.
  prefs: []
  type: TYPE_NORMAL
- en: The main body of the code is a repeated breadth-first search where an outer
    loop starts a new search on any unvisited node ❶. A <samp class="SANS_TheSansMonoCd_W5Regular_11">for</samp>
    loop checks whether each potential starting node has already been seen by a previous
    search. If so (the node’s label is not <samp class="SANS_TheSansMonoCd_W5Regular_11">None</samp>),
    the code skips it ❷. If the node has not been seen, the code adds it to the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">pending</samp> queue for the breadth-first
    search, marks it as belonging to the left-hand side (label of <samp class="SANS_TheSansMonoCd_W5Regular_11">True</samp>),
    and starts a new breadth-first search from that node ❸.
  prefs: []
  type: TYPE_NORMAL
- en: During each step of the breadth-first search, the code gets the current node
    being explored and uses its label to determine that of its neighbors ❹. That is,
    the current node’s neighbors must all have the opposite label; otherwise, the
    graph is not bipartite. The code iterates over the node’s edges and checks each
    neighbor. If the neighbor has not been seen (label is <samp class="SANS_TheSansMonoCd_W5Regular_11">None</samp>)
    ❺, the code sets the label (marking it seen) and adds it to the <samp class="SANS_TheSansMonoCd_W5Regular_11">pending</samp>
    queue. If the node has been seen, the code takes the opportunity to check the
    validity of its label ❻. If the label does not match what is expected, the graph
    has two connected nodes on the same side and therefore is not bipartite. It immediately
    returns <samp class="SANS_TheSansMonoCd_W5Regular_11">None</samp> to indicate
    the problem.
  prefs: []
  type: TYPE_NORMAL
- en: If the code successfully finishes the series of breadth-first searches needed
    to explore every node, it returns a list of node labels as <samp class="SANS_TheSansMonoCd_W5Regular_11">True</samp>
    or <samp class="SANS_TheSansMonoCd_W5Regular_11">False</samp> values. Otherwise,
    it returns <samp class="SANS_TheSansMonoCd_W5Regular_11">None</samp> to indicate
    the graph is not bipartite. As with other examples throughout the book, we need
    to import <samp class="SANS_TheSansMonoCd_W5Regular_11">Union</samp> from Python’s
    <samp class="SANS_TheSansMonoCd_W5Regular_11">typing</samp> library to support
    type hints for these multiple return values.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">An Example</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '[Figure 15-4](#fig15-4) shows the steps of the bipartite labeling algorithm
    working on an example seven-node graph. In [Figure 15-4(a)](#fig15-4), an arbitrary
    node (0) is chosen, given the first label (<samp class="SANS_TheSansMonoCd_W5Regular_11">True</samp>),
    and added to the queue to explore. This corresponds to the waiter selecting the
    first spy to watch and assigning them to the green team.'
  prefs: []
  type: TYPE_NORMAL
- en: After exploring node 0, the algorithm finds two neighbors, as shown in [Figure
    15-4(b)](#fig15-4). It gives nodes 3 and 5 <samp class="SANS_TheSansMonoCd_W5Regular_11">False</samp>
    labels to indicate they are in the opposite set from node 0\. Both nodes are also
    added to the queue.
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 15-4(c)](#fig15-4) shows the search’s state after exploring node 3
    and discovering just one new neighbor, node 4\. Since node 3 had a label of <samp
    class="SANS_TheSansMonoCd_W5Regular_11">False</samp>, the search gives node 4
    a label of <samp class="SANS_TheSansMonoCd_W5Regular_11">True</samp>. The algorithm
    also checks all previously seen nodes, in this case node 0, to confirm their labels
    match the expected value. For the bored waiter, this step corresponds to watching
    the first person identified as a member of the yellow team. The waiter shifts
    behind a potted plant and notes that person 3 is watching person 0 back, as must
    be expected of any good spy. After a moment, the waiter notes that person 3 is
    also watching person 4\. The waiter has found another member of the green team
    and notes this on a cocktail napkin.'
  prefs: []
  type: TYPE_NORMAL
- en: The search continues through the graph one node at a time. At each step, the
    algorithm examines the full set of neighbors, labeling new ones and adding them
    to the queue as well as checking known neighbors’ labels for consistency. The
    search ends in [Figure 15-4(h)](#fig15-4) after every node has been checked.
  prefs: []
  type: TYPE_NORMAL
- en: '![Each subfigure shows the graph from Fig. 15-3 with seven nodes and undirected
    edges (0, 3), (0, 5), (2, 1), (2, 5), (4, 3), (4, 5) and (6, 1). In subfigure
    B, node 0 is circled and the label list reads [T, /, /, F, /, F, /]](../images/f15004.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 15-4: The steps of a
    successful bipartite graph check</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: We can also use this same algorithm to identify non-bipartite graphs. [Figure
    15-5](#fig15-5) shows the same algorithm on a non-bipartite graph, formed by adding
    a single additional edge to the graph in [Figure 15-4](#fig15-4). For the first
    few steps, the search progresses similarly to that in [Figure 15-4](#fig15-4).
    An arbitrary initial node is chosen in [Figure 15-5(a)](#fig15-5) and explored
    in [Figure 15-5(b)](#fig15-5). The first hint of trouble occurs in [Figure 15-5(c)](#fig15-5),
    where node 1 is labeled as occurring on the left-hand side because it is a neighbor
    of node 3\. We can easily tell this is a mistake from the visual representation,
    but the algorithm does not have that information yet. From its perspective, node
    1 could very well be on the left-hand side. The algorithm will not see the problem
    until it proceeds further.
  prefs: []
  type: TYPE_NORMAL
- en: '![A similar set of graphs to Figure 15-4 with an additional edge (1, 3). In
    subfigure E, node 1 is circled and the label array has an X through the entry
    for node 2.](../images/f15005.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 15-5: The steps of an
    unsuccessful bipartite graph check</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: The algorithm finally notices the problem in [Figure 15-5(e)](#fig15-5), when
    it explores node 1\. Since node 1’s own label is <samp class="SANS_TheSansMonoCd_W5Regular_11">True</samp>,
    it expects its neighbors to be <samp class="SANS_TheSansMonoCd_W5Regular_11">False</samp>.
    This fails as soon as it checks node 2\. Node 2 was previously labeled <samp class="SANS_TheSansMonoCd_W5Regular_11">True</samp>
    while exploring node 5, but node 2 cannot be both <samp class="SANS_TheSansMonoCd_W5Regular_11">True</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">False</samp>. The graph is not
    bipartite.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Use Cases</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The *bipartite matching problem* consists of solving the matching problem on
    a bipartite graph and can be used to solve a number of real-world optimization
    and assignment problems. Due to the structure of the bipartite graph, each selected
    edge will join a single node from the left side with a single node from the right
    side. Depending on the task, the problem might be trying to maximize different
    criteria, such as the number of matches or the sum of the used edge weights. This
    formulation encompasses a wide range of real-world problems that we might not
    normally consider in the graph context, from job scheduling to planning office
    building organization to matching heroes with monsters in a magical dungeon.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Scheduling Jobs</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Suppose a physics laboratory wants to maximize the number of concurrent simulations
    run on its machines. The machines vary in capability, but each can run only a
    single program at a time. The scientists each submit a program to the human scheduler
    and urge the scheduler to prioritize their own work first. Yet each program comes
    with its own requirements, such as high memory or a GPU. The scheduler must respect
    these constraints, limiting the number of valid assignments.
  prefs: []
  type: TYPE_NORMAL
- en: The scheduler, sensing the perfect opportunity to employ a bipartite matching
    algorithm, models the allocations as an undirected graph. They list the scientists’
    jobs in the left column and the computers in the right, then draw an edge from
    a program to a machine if the job can run on that machine. The jobs requiring
    high memory have edges to the high-memory machines, the jobs requiring GPUs have
    edges to the machines with GPUs, and so forth. Satisfied at their representation,
    they set about finding the maximum number of jobs that they can schedule at one
    time.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Assigning Office
    Space</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The Happy Data Structures corporation is looking to move into a new office.
    While most teams are counting down to move-in day with anticipation of the new
    space, the planners are worrying about how to assign each team to a work area
    in the new building. Each workspace has constraints based on the properties of
    the area, including natural light, access to resources, and size.
  prefs: []
  type: TYPE_NORMAL
- en: After days of collecting long lists of requirements, the planners decide to
    model the problem as a bipartite-graph-matching problem. One set of nodes represents
    the teams and the other represents the workspaces. Spaces that are compatible
    with a team’s needs are joined by an edge. Each team can be assigned only to a
    single space, and each space can have only a single team. The planners use bipartite
    graph matching between the teams and spaces to find an assignment of all teams
    to spaces that satisfy their constraints.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Planning Quest Battles</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'An adventuring party is exploring a magical dungeon when they stumble upon
    a room full of monsters. Each adventurer agrees to take on a single monster, but
    the group needs to (quickly) make the assignments. Some assignments are invalid:
    the wizard cannot fight the magic-resistant lizard, and the sword master cannot
    challenge the cloud of vapor.'
  prefs: []
  type: TYPE_NORMAL
- en: In a twist on the canonical job allocation problem, the party models the problem
    as a bipartite graph assignment. They use one set of nodes to represent the adventurers
    and the other to represent the monsters. Compatible enemies are linked with an
    edge. Now they just need to efficiently match each adventurer with an enemy.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Exhaustive Algorithms</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: One straightforward approach to finding a variety of matchings, including maximum
    cardinality and maximum weight, is to simply try every combination of edges. We
    could enumerate all 2^|*^E*^| possible sets of used edges, throw away ones that
    use any node more than once, and score the rest based on our metric of interest.
    In this section, we briefly consider an algorithm based on depth-first search
    that performs this *exhaustive search*. This algorithm provides a baseline to
    which to compare more computationally efficient approaches.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Matching Data</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'To simplify and generalize the code in this section, we employ a wrapper data
    structure around the matching assignments that track both the assignments and
    the current score. The <samp class="SANS_TheSansMonoCd_W5Regular_11">Matching</samp>
    object holds three pieces of information about the current matching:'
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">num_nodes</samp> **(**<samp class="SANS_TheSansMonoCd_W7Bold_B_11">int</samp>**) **Stores
    the total number of nodes in the graph
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">assignments</samp> **(**<samp class="SANS_TheSansMonoCd_W7Bold_B_11">list</samp>**) **Stores
    a mapping of each node to its partner or <samp class="SANS_TheSansMonoCd_W5Regular_11">-1</samp>
    if the node is unmatched
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">score</samp> **(**<samp class="SANS_TheSansMonoCd_W7Bold_B_11">float</samp>**) **Stores
    the matching’s score
  prefs: []
  type: TYPE_NORMAL
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">assignments</samp> list is
    bidirectional and stores the partners for both sides of the bipartite graph. For
    example, the inclusion of edge (0, 4) would result in <samp class="SANS_TheSansMonoCd_W5Regular_11">assignments[0]=4</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">assignments[4]=0</samp>.
  prefs: []
  type: TYPE_NORMAL
- en: 'To implement this wrapper data structure, we define a constructor to create
    an empty matching and provide functions adding and removing edges from the matching:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: To simplify the example, neither the <samp class="SANS_TheSansMonoCd_W5Regular_11">add_edge()</samp>
    nor <samp class="SANS_TheSansMonoCd_W5Regular_11">remove_edge()</samp> functions
    check node validity or whether a node is currently assigned. In real-world production
    software, you’ll often want to add checks that no node is used twice and that
    the added edge exists within the graph using similar checks to those in [Chapter
    1](chapter1.xhtml).
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Exhaustive Scoring</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: We use an approach based on recursive depth-first search to enumerate which
    edges are used. Instead of exploring depth-first over the nodes, we explore over
    node assignments.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, consider the bipartite graph in [Figure 15-6](#fig15-6). Node
    0 has three options for matching: nothing, node 1, or node 3\. The same applies
    to node 2.'
  prefs: []
  type: TYPE_NORMAL
- en: '![A graph with four nodes and edges (0, 1), (0, 3), (2, 1) and (2, 3). The
    even nodes are in a single column on the left while the odd nodes are in a single
    column on the right.](../images/f15006.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 15-6: A bipartite graph
    with four nodes</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: We can visualize the space of potential matchings for the graph in [Figure 15-6](#fig15-6)
    as a tree where each level indicates the assignment of one of the left-hand nodes.
    This tree is shown in [Figure 15-7](#fig15-7). The first level of the tree splits
    into three scenarios based on the three different options for node 0\. The left
    branch represents the options if we leave node 0 unpaired. The central branch
    represents the options with node 0 paired to node 1\. The right branch represents
    the options with node 0 paired to node 3\. We limit the search space by considering
    only potential matches that correspond to edges in the graph.
  prefs: []
  type: TYPE_NORMAL
- en: '![A tree showing potential matches. Each node is a vector of matches for each
    node. The root node is [–1, –1, –1, 1] while the rightmost bottom node is [3,
    2, 1, 0].](../images/f15007.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 15-7: A search tree
    over the potential node-matching assignments</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: The second level of the tree in [Figure 15-7](#fig15-7) shows similar splits
    for the assignment of node 2\. Since node 0 is already assigned in two of the
    three branches, those branches can split only into two sub-options.
  prefs: []
  type: TYPE_NORMAL
- en: Since this approach is performing an exhaustive search, it will work for a variety
    of bipartite matching problems, including maximum cardinality and maximum weight.
    As we will see, the only factor that changes is how we compute the matching’s
    score.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">The Code</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'We implement a search for the maximum-weight matching over this tree using
    a recursive algorithm:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The outer wrapper function <samp class="SANS_TheSansMonoCd_W5Regular_11">bipartite_matching_exh()</samp>
    labels the sides of the graph ❶ and sets up the <samp class="SANS_TheSansMonoCd_W5Regular_11">Matching</samp>
    data structure. It returns <samp class="SANS_TheSansMonoCd_W5Regular_11">None</samp>
    if the graph is not bipartite (again necessitating the inclusion of <samp class="SANS_TheSansMonoCd_W5Regular_11">import
    Union</samp> to support the type hints for multiple return values). It then calls
    the recursive function to do the matching ❷.
  prefs: []
  type: TYPE_NORMAL
- en: The recursive function <samp class="SANS_TheSansMonoCd_W5Regular_11">matching_recursive()</samp>
    starts by checking whether it has hit the bottom of the search ❸, where everything
    on the left-hand side has been assigned (even if to <samp class="SANS_TheSansMonoCd_W5Regular_11">-1</samp>).
    If there are no more nodes to assign, it returns a copy of the <samp class="SANS_TheSansMonoCd_W5Regular_11">Matching</samp>
    as the best assignments found down this branch using the <samp class="SANS_TheSansMonoCd_W5Regular_11">deepcopy()</samp>
    function from Python’s <samp class="SANS_TheSansMonoCd_W5Regular_11">copy</samp>
    library. The code performs the copy to effectively snapshot this match and separate
    it from the <samp class="SANS_TheSansMonoCd_W5Regular_11">current</samp> object
    that it will continue to modify during the rest of the search. The use of <samp
    class="SANS_TheSansMonoCd_W5Regular_11">deepcopy()</samp> requires the inclusion
    of <samp class="SANS_TheSansMonoCd_W5Regular_11">import copy</samp> at the top
    of the file.
  prefs: []
  type: TYPE_NORMAL
- en: The code then checks whether this node is on the left-hand side of the graph
    ❹. Since the code makes assignments only from the left nodes, we skip the right
    ones by calling the recursive function with the current matching at the next index.
    While the code could be modified to test both sides, assigning the right-side
    nodes is unnecessary. Each edge can be used only once and is guaranteed to be
    adjacent to a left-side node.
  prefs: []
  type: TYPE_NORMAL
- en: The code then checks each available option for a match to the current node and
    saves the best one, starting with the choice of leaving the current node (<samp
    class="SANS_TheSansMonoCd_W5Regular_11">index</samp>) unassigned by calling the
    recursive function with the current matching at the next index ❺. The code saves
    the best matching down this branch for later comparison as <samp class="SANS_TheSansMonoCd_W5Regular_11">best</samp>.
    It then uses a <samp class="SANS_TheSansMonoCd_W5Regular_11">for</samp> loop to
    iterate through each of the current node’s neighbors, checking the current matching
    assignments so it can skip nodes that are already assigned to others ❻. The code
    adds each viable neighbor to the matching, uses the recursive function to get
    the best matching down that path, updates the <samp class="SANS_TheSansMonoCd_W5Regular_11">best</samp>
    matching if necessary, and removes the edge from the matching. Finally, it returns
    the best matching down this entire branch.
  prefs: []
  type: TYPE_NORMAL
- en: We can change the implementation from the maximum-weight matching in the code
    to a maximum-cardinality matching by changing the score passed to the matching.
    That is, we swap <samp class="SANS_TheSansMonoCd_W5Regular_11">1.0</samp> for
    <samp class="SANS_TheSansMonoCd_W5Regular_11">edge.weight</samp> when adding or
    removing edges. With this change, the search selects matchings with the higher
    number of assigned edges instead of the greater total weight.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">An Example</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: We can visualize this function by looking at the state of the current matching
    each time the algorithm hits the bottom of the recursion. [Figure 15-8](#fig15-8)
    shows the first nine times the algorithm hits the end of the recursion on an example
    graph.
  prefs: []
  type: TYPE_NORMAL
- en: Since the algorithm tests the no-assignment (<samp class="SANS_TheSansMonoCd_W5Regular_11">-1</samp>)
    branch first, the recursion encounters the full assignment <samp class="SANS_TheSansMonoCd_W5Regular_11">[-1,-1,-1,-1]</samp>
    in [Figure 15-8(a)](#fig15-8). After evaluating this empty matching, the search
    backtracks and tests alternate assignments for node 4 while keeping the assignments
    for nodes 0 and 2 from previous decisions fixed. This produces the matchings in
    [Figures 15-8(b)](#fig15-8), [15-8(c)](#fig15-8), and [15-8(d)](#fig15-8). It
    is not until [Figure 15-8(f)](#fig15-8) that the algorithm evaluates a matching
    with two edges used.
  prefs: []
  type: TYPE_NORMAL
- en: '![Each subgraph shows a six-node bipartite graph with zero or more edges bolded.
    The score is the sum of the weights of the bolded edges.](../images/f15008.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 15-8: The first nine
    steps of the exhaustive search algorithm</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: While the exhaustive algorithm is both complete and generalizable, it is far
    from efficient, especially on large graphs. Even the search of the six-node graph
    in [Figure 15-8](#fig15-8) explores 34 different assignments. The next section
    introduces one of the specialized algorithms that exist to efficiently solve individual
    matching problems.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Solving the Maximum-Cardinality Bipartite
    Problem</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This section shows how to use the max-flow algorithms from the previous chapter
    to solve the maximum-cardinality bipartite problem efficiently. We can transform
    the maximum-cardinality bipartite problem directly into a maximum-flow problem
    by transforming the bipartite graph into a flow network with directed edges and
    unit weights. [Figure 15-9(a)](#fig15-9) shows a bipartite graph and [Figure 15-9(b)](#fig15-9)
    shows the result of this transformation. We add a single source node *s* that
    feeds all the nodes in the left column. We add a single sink node *t* to accept
    flow from the nodes in the right column. Each edge in the graph is directed from
    left to right and has a capacity of 1\. (To reduce clutter, the illustration does
    not include the capacity of the edges.)
  prefs: []
  type: TYPE_NORMAL
- en: '![(A) shows a bipartite graph with five nodes on the left and four on the right.
    The graph has edges (0, 1), (0, 5), (0, 7), (2, 1), (4, 3), (4, 7), (6, 1), and
    (8, 3). (B) shows an expanded graph with an additional source node feeding the
    left-hand nodes and a sink node fed by the right-hand nodes.](../images/f15009.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 15-9: A bipartite graph
    (a) and its flow network version (b)</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: Using this setup, the source node can supply each of the left-hand nodes with
    up to a single unit of flow. Similarly, each node in the right-hand column can
    provide at most 1 unit of flow to the sink. Given the constraint that the flow
    into a node must equal the flow out of it, each node on the left can send flow
    to at most 1 unit of flow to a node on the right. Each node on the right can accept
    at most 1 unit of flow from a node on the left. The maximum flow is equal to the
    maximum number of pairs we can assign.
  prefs: []
  type: TYPE_NORMAL
- en: '#### <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">The Code</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: 'The code for performing maximum-cardinality bipartite matching with the max-flow
    algorithm reuses the Edmonds-Karp implementation from [Chapter 14](chapter14.xhtml)
    to do all the heavy lifting. Much of the wrapper function itself transforms the
    graph by adding a source and sink node, then later pruning the unneeded edges:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">bipartite_matching_max_flow()</samp>
    function returns either a list of assignments (in the same bidirectional format
    as <samp class="SANS_TheSansMonoCd_W5Regular_11">Matching</samp> class’s <samp
    class="SANS_TheSansMonoCd_W5Regular_11">assignments</samp> list) or <samp class="SANS_TheSansMonoCd_W5Regular_11">None</samp>
    if the graph is not bipartite.
  prefs: []
  type: TYPE_NORMAL
- en: To build the augmented graph, the code first must know which nodes are on which
    side of the bipartite graph. It reuses the <samp class="SANS_TheSansMonoCd_W5Regular_11">bipartite_labeling()</samp>
    function from [Listing 15-1](#list15-1), taking the opportunity to also check
    for non-bipartite graphs.
  prefs: []
  type: TYPE_NORMAL
- en: The code then builds an augmented graph. First, it creates a new (directed)
    graph with two extra nodes for the source and sink ❶. Second, it adds directed
    edges, each with a capacity of <samp class="SANS_TheSansMonoCd_W5Regular_11">1</samp>,
    going from the left column to the right column, using the <samp class="SANS_TheSansMonoCd_W5Regular_11">labeling</samp>
    list to determine in which column a node belongs. Finally, the code connects the
    source and sink ❷. It adds edges from the source to each of the original graph’s
    left-hand nodes and edges from each of the original graph’s right-hand nodes to
    the sink.
  prefs: []
  type: TYPE_NORMAL
- en: The code runs the Edmonds-Karp algorithm on the graph to find the maximum flow
    through it ❸. Each <samp class="SANS_TheSansMonoCd_W5Regular_11">CapacityEdge</samp>
    in the resulting graph (<samp class="SANS_TheSansMonoCd_W5Regular_11">residual</samp>)
    that has used flow are connected. However, the overall graph also still contains
    the source node, the sink node, and all their corresponding edges. The code iterates
    through the edges and fills in the assignments for each <samp class="SANS_TheSansMonoCd_W5Regular_11">CapacityEdge</samp>
    where <samp class="SANS_TheSansMonoCd_W5Regular_11">used</samp> is greater than
    zero, the origin is not the source node, and the destination is not the sink node
    ❹.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">An Example</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '[Figure 15-10](#fig15-10) shows the steps the maximum-flow algorithm takes
    as it identifies a matching on the example bipartite graph in [Figure 15-9](#fig15-9).
    Edges at capacity (<samp class="SANS_TheSansMonoCd_W5Regular_11">used</samp> equals
    1) after each step of the algorithm are bolded.'
  prefs: []
  type: TYPE_NORMAL
- en: We can picture this algorithm in the context of the job-scheduling algorithm
    introduced in “Use Cases” on [page 263](chapter15.xhtml#pg_263). Job 0 (node 0)
    is the most flexible job, with the ability to run on three of the four machines.
    In contrast, jobs 2, 6, and 8 are limited to running on specific machines.
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 15-10(a)](#fig15-10) shows the initial state where the algorithm has
    added the source node, the sink node, and all the corresponding edges. No edges
    carry any flow yet. This corresponds to starting in an empty state with no jobs
    scheduled to run on any machine.'
  prefs: []
  type: TYPE_NORMAL
- en: '[Figures 15-10(b)](#fig15-10) and [15-10(c)](#fig15-10) show the state of assignments
    after the code finds the first two augmenting paths. During the first round, it
    discovers that the unassigned job 0 can run on the unused machine 1 and makes
    that assignment. In the second round, it does the same with job 4 and machine
    3.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Things get interesting at this point, as shown in [Figure 15-10(d)](#fig15-10).
    By assigning job 0 to machine 1, the algorithm has blocked both jobs 2 and 6,
    as both can only run on machine 1\. Luckily, the algorithm can handle this by
    finding a new augmenting path: (*s*, 2), (2, 1), (1, 0), (0, 5), (5, *t*). In
    doing so, it pushes flow backward along the edge (0, 1), unassigning job 0 from
    machine 1\. The result is an assignment with one more job scheduled.'
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 15-10(e)](#fig15-10) shows a similar multi-step augmenting path. This
    new path consists of edges (*s*, 8), (8, 3), (3, 4), (4, 7), and (7, *t*). The
    code unassigns job 4 from machine 3 and then assigns job 4 to machine 7 and job
    8 to machine 3.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Each subfigure shows the same graph with different edges bolded to indicate
    the used paths. (B) has a single path (s, 0), (0, 1), (1, t) bolded.](../images/f15010.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 15-10: The max-flow
    algorithm operating on an augmented bipartite graph</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: After the maximum-flow algorithm completes, it has produced the graph in [Figure
    15-10(e)](#fig15-10). To produce the matching list, it then walks the edges of
    the residual graph. It skips all edges connected to either the source node *s*
    or the sink node *t*, since those were not part of the original bipartite graph.
    It saves all connections with nonzero flow. The result with matched edges (0,
    5), (2, 1), (4, 7), and (8, 3) is shown in [Figure 15-11](#fig15-11). The unused
    connections in the original bipartite graph are shown in thin gray lines for reference.
  prefs: []
  type: TYPE_NORMAL
- en: '![A bipartite graph with five nodes on the left and four on the right. The
    graph has edges (0, 1), (0, 5), (0, 7), (2, 1), (4, 3), (4, 7), (6, 1), and (8,
    3). The edges (0, 5), (2, 1), (4, 7), and (8, 3) are bolded.](../images/f15011.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 15-11: A bipartite graph
    with edges in the maximum-cardinality matching bolded</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: The maximum-flow algorithm will only find a single maximum-cardinality matching
    that is not necessarily unique. In [Figure 15-11](#fig15-11), for example, alternative
    matchings are possible. Instead of including the edge (2, 1), we could have included
    the edge (6, 1).
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Why This Matters</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Bipartite graphs enable us to translate a range of assignment problems to equivalent
    graph algorithms, allowing access to a wealth of powerful graph algorithms. In
    doing so, we can solve problems that we might not initially think of as graph-based.
    A clear example of this flexibility is the maximum-cardinality matching problem,
    which transforms the problem of matching items from two disjoint sets into a graph
    problem that we can solve with maximum-flow algorithms.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section of the book, we switch topics and consider a variety of
    computationally challenging problems on graphs. [Chapter 16](chapter16.xhtml)
    introduces the problem of assigning colors to graph nodes such that no two neighbors
    share a color. [Chapter 17](chapter17.xhtml) considers a variety of other useful
    node assignment problems. Finally, [Chapter 18](chapter18.xhtml) extends the examination
    of challenging problems to that of finding specific types of paths through graphs.
  prefs: []
  type: TYPE_NORMAL
