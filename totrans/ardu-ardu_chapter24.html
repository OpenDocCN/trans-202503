<html xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops" lang="en" xml:lang="en">
<head>
<title>Arduino for Arduinians</title>
<meta content="text/html; charset=utf-8" http-equiv="default-style"/>
<link href="../styles/stylesheet.css" rel="stylesheet" type="text/css"/>
<meta content="urn:uuid:67118b6d-3178-4c1c-99a1-6e412fe74179" name="Adept.expected.resource"/>
</head>
<body epub:type="bodymatter">
<section aria-labelledby="ch24" epub:type="chapter" role="doc-chapter">
<header>
<h1 class="CHAPTER" id="ch24">
<span class="CN"><span aria-label=" Page 413. " epub:type="pagebreak" id="pg_413" role="doc-pagebreak"/><samp class="SANS_Futura_Std_Bold_Condensed_B_11">24</samp></span>
<span class="CT"><samp class="SANS_Dogma_OT_Bold_B_11">THE ESP32 CAMERA BOARD</samp></span>
</h1>
</header>
<figure class="opener"><img alt="" class="opener" src="../images/opener-img.png"/>
</figure>
<p class="INTRO">In the past, to use an Arduino with a digital camera, you’d have to hack into the camera’s remote-control system and control it with the Arduino’s digital output pins. Today, thanks to the release of the inexpensive ESP32 dev board with a camera (also known as the ESP32 camera board), you can easily control a small digital camera in your projects and save the images for review or streaming over Wi-Fi.</p>
<p class="TX">The ESP32 camera board uses the same ESP32 microcontroller with Wi-Fi as found on the ESP32 dev board used in <span class="Xref"><a href="chapter19.xhtml">Chapters 19</a> through <a href="chapter24.xhtml">24</a></span>. However, the camera board is a much more compact unit and includes a connection for a tiny but useful camera module, which is usually included with purchase of the ESP32 camera board. It may also be the most complex device you’ve controlled with an Arduino-compatible board in this book so far.</p>
<p class="TX"><span aria-label=" Page 414. " epub:type="pagebreak" id="pg_414" role="doc-pagebreak"/>In this chapter, you’ll learn to:</p>
<ul class="ul">
<li class="BL">Configure ESP32 camera boards for Arduino</li>
<li class="BL">Build a simple video-streaming device</li>
<li class="BL">Control ESP32 camera boards to capture still images on command</li>
</ul>
<section aria-labelledby="sec1" epub:type="division">
<h2 class="H1" id="sec1"><span id="h1-170"/><samp class="SANS_Futura_Std_Bold_B_11">Selecting an ESP32 Camera</samp></h2>
<p class="TNI">This chapter is based on the AI- Thinker ESP32 CAM module, a small board that contains the ESP32 hardware, a microSD memory card socket, a small power regulator, and a connector for a small camera. The package should also include the camera module.</p>
<p class="TX">Some ESP32 camera boards, such as PMD Way part 97263257 (shown in <a href="chapter24.xhtml#fig24-1">Figure 24-1</a>), have no USB interface to save space.</p>
<figure class="IMG"><img alt="A PHOTO OF THE ESP32 CAMERA BOARD SET" class="img4" id="fig24-1" src="../images/fig24-1.png"/>
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 24-1: An ESP32 camera board</samp></p></figcaption>
</figure>
<p class="TX">If that’s the case for the module you purchase, you’ll need a USB-to-serial cable like the PL2303TA cable shown in <a href="chapter24.xhtml#fig24-2">Figure 24-2</a> (PMD Way part 727859). You’ll use this cable to power the ESP32 camera for uploading sketches and monitoring serial output in the Arduino IDE’s Serial Monitor.</p>
<figure class="IMG"><img alt="A PHOTO OF THE USB-TO-TTL CABLE" class="img4" id="fig24-2" src="../images/fig24-2.png"/>
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 24-2: A USB-to-TTL cable</samp></p></figcaption>
</figure>
<p class="TX">Alternatively, you can source the ESP32 camera with a matching USB interface board such as PMD Way part 26409000, shown in <a href="chapter24.xhtml#fig24-3">Figure 24-3</a>.</p>
<figure class="IMG"><img alt="A PHOTO OF THE ESP32 CAMERA BOARD WITH THE USB INTERFACE BOARD" class="img4" id="fig24-3" src="../images/fig24-3.png"/>
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 24-3: An ESP32 camera board with a USB interface board</samp></p></figcaption>
</figure>
<p class="TX"><span aria-label=" Page 415. " epub:type="pagebreak" id="pg_415" role="doc-pagebreak"/>I chose the ESP32 camera board used as shown in <a href="chapter24.xhtml#fig24-1">Figure 24-1</a> not only because it’s the most popular model but because it allows you to use an external Wi-Fi antenna to enable a greater operational distance from the Wi-Fi access point. Usually, the module used is shipped configured to use the external antenna. You can still use it without the antenna, but the Wi-Fi range will not be optimal.</p>
<p class="TX">After initial experimentation, you may want to substitute your default camera lens with a different lens type for zoom or wide-angle photography or use a longer cable between the camera and the ESP32 camera board. You can purchase these lenses from PMD Way (see part 26401000, for example) or your ESP32 camera board supplier. However, these extra camera types aren’t required for the projects in this chapter.</p>
</section>
<section aria-labelledby="sec2" epub:type="division">
<h2 class="H1" id="sec2"><span id="h1-171"/><samp class="SANS_Futura_Std_Bold_B_11">Setting Up the ESP32 Camera</samp></h2>
<p class="TNI">Once you’ve purchased your ESP32 camera board, you’ll need to set it up to receive sketches and operate properly.</p>
<p class="TX">If you haven’t already, turn to <span class="Xref"><a href="chapter19.xhtml">Chapter 19</a></span> and complete the instructions in <span class="Xref">“Configuring the Arduino IDE for the ESP32”</span> through <span class="Xref">“Testing the ESP32”</span> to get your ESP32 working. Next, connect the ESP32 camera to your PC. If you have the USB interface board as shown in <a href="chapter24.xhtml#fig24-2">Figure 24-2</a>, connect via a USB cable as usual. If you’re using the alternate USB-to-TTL cable for the USB interface, connect the pins of the ESP32 camera to the cable as shown in <a href="chapter24.xhtml#tab24-1">Table 24-1</a>.</p>
<figure class="table">
<p class="TableTitle" id="tab24-1"><span class="Heavy"><samp class="SANS_Futura_Std_Heavy_B_11">Table 24-1:</samp></span> <samp class="SANS_Futura_Std_Book_11">Connections Between ESP32 Camera and USB-TTL Cable</samp></p>
<table class="table">
<thead>
<tr>
<th class="table TCH" scope="col"><p class="TCH"><samp class="SANS_Futura_Std_Heavy_B_11">ESP32 camera pin</samp></p></th>
<th class="table TCH" scope="col"><p class="TCH"><samp class="SANS_Futura_Std_Heavy_B_11">Cable connector</samp></p></th>
</tr>
</thead>
<tbody>
<tr>
<td class="table TBF"><p class="TB"><samp class="SANS_Futura_Std_Book_11">5V</samp></p></td>
<td class="table TBF"><p class="TB"><samp class="SANS_Futura_Std_Book_11">5V (red)</samp></p></td>
</tr>
<tr>
<td class="table TB"><p class="TB"><samp class="SANS_Futura_Std_Book_11">GND</samp></p></td>
<td class="table TB"><p class="TB"><samp class="SANS_Futura_Std_Book_11">GND (black)</samp></p></td>
</tr>
<tr>
<td class="table TB"><p class="TB"><samp class="SANS_Futura_Std_Book_11">U0T</samp></p></td>
<td class="table TB"><p class="TB"><samp class="SANS_Futura_Std_Book_11">RX (white)</samp></p></td>
</tr>
<tr>
<td class="table TBL"><p class="TB"><samp class="SANS_Futura_Std_Book_11">U0R</samp></p></td>
<td class="table TBL"><p class="TB"><samp class="SANS_Futura_Std_Book_11">TX (green)</samp></p></td>
</tr>
</tbody>
</table>
</figure>
<p class="TX">If you’re using the USB-to-TTL cable, you must also connect a jumper wire between a GND pin and the IO0 pin before uploading a sketch. After uploading the sketch, you must disconnect and reconnect the USB cable to the PC and then remove the IO0 to GND wire and press the reset button on the board to start the sketch. You’ll need to do this every time you upload a sketch.</p>
<p class="TX">Once you’ve connected your ESP32 camera to your PC, open the Arduino IDE and set the board to AI Thinker ESP-32 CAM by selecting <b>Tools</b> <img alt="" class="inline" src="../images/arr.png"/> <b>Board</b> <img alt="" class="inline" src="../images/arr.png"/> <b>esp32</b>. You may also need to set the USB port to the one used by your USB interface by selecting <b>Tools</b> <img alt="" class="inline" src="../images/arr.png"/> <b>Port</b>.</p>
<p class="TX">Open the WiFiScan example sketch included with the Arduino Wi-Fi library. Upload this sketch to your ESP32 camera board, and open the <span aria-label=" Page 416. " epub:type="pagebreak" id="pg_416" role="doc-pagebreak"/>Serial Monitor. You should see the available Wi-Fi networks in your nearby area listed, as shown in <a href="chapter24.xhtml#fig24-4">Figure 24-4</a>.</p>
<figure class="IMG"><img alt="A SCREENSHOT OF THE WIFISCAN SKETCH’S OUTPUT, SHOWING THE AVAILABLE NETWORK AND STRENGTH" class="img5" id="fig24-4" src="../images/fig24-4.png"/>
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 24-4: Example output from running the WiFiScan example sketch</samp></p></figcaption>
</figure>
<p class="TX">The received signal strength indicator (RSSI) value in <a href="chapter24.xhtml#fig24-4">Figure 24-4</a> is a measurement of how well the ESP32 camera board can hear a signal from your Wi-Fi access point. The closer to 0, the better the signal. The CH value is the Wi-Fi channel to your Wi-Fi access point; most access points have 16 channels. Finally, the Encryption type shows which form of encryption protocol is used for the listed Wi-Fi access points. If the WiFiScan example sketch worked correctly, your ESP32 camera board is ready to use.</p>
<p class="TX">If your camera didn’t arrive preconnected to the board, you’ll now need to attach it. Working slowly and carefully, pry open the black plastic hinged strip across the connector, as shown in <a href="chapter24.xhtml#fig24-5">Figure 24-5</a>. It may help to use some plastic tweezers instead of your fingers.</p>
<figure class="IMG"><img alt="A PHOTO OF THE OPEN CAMERA CONNECTOR ON THE ESP32 CAMERA BOARD" class="img5" id="fig24-5" src="../images/fig24-5.png"/>
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 24-5: Opening the camera cable connector on the ESP32 camera board</samp></p></figcaption>
</figure>
<p class="TX">Slide the camera’s interface cable into the connector on the ESP32 camera board. The camera lens should face upward during this process, with the cable sliding in just a few millimeters. Don’t exert too much force; <span aria-label=" Page 417. " epub:type="pagebreak" id="pg_417" role="doc-pagebreak"/>if you run into an obstacle, the cable has gone far enough, as shown in <a href="chapter24.xhtml#fig24-6">Figure 24-6</a>.</p>
<figure class="IMG"><img alt="A PHOTO OF THE CAMERA CONNECTOR INSERTED INTO THE ESP32 CAMERA BOARD" class="img5" id="fig24-6" src="../images/fig24-6.png"/>
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 24-6: Inserting the camera cable connector on the ESP32 camera board</samp></p></figcaption>
</figure>
<p class="TX">Finally, push the black plastic hinged strip across the connector down until it clicks into place, which also secures the camera connector cable into the ESP32 camera board, as shown in <a href="chapter24.xhtml#fig24-7">Figure 24-7</a>.</p>
<figure class="IMG"><img alt="A PHOTO OF THE CAMERA INSTALLED INTO THE ESP32 CAMERA BOARD" class="img7" id="fig24-7" src="../images/fig24-7.png"/>
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 24-7: The camera installed into the ESP32 camera board</samp></p></figcaption>
</figure>
<p class="TX">If there is a protective plastic cover over the lens, carefully remove it by pulling the tab on one side of the protector. You’re ready to test your camera by using it to stream video across your Wi-Fi network.</p>
<p class="HeadProject"><span id="h1-172"/><span aria-label=" Page 418. " epub:type="pagebreak" id="pg_418" role="doc-pagebreak"/><samp class="SANS_Futura_Std_Heavy_B_21">Project #69: Streaming Video from a Basic Camera Server</samp></p>
<p class="TNI">In this project, you’ll control the ESP32 camera module remotely over a Wi-Fi local-area network using a web browser interface, experimenting with various settings on the camera interface to adjust the camera’s image or video stream.</p>
<p class="TX">For hardware, you’ll need just the ESP32 camera module and USB interface as described in the previous section. For the sketch, you’ll need to download the project files from the book’s website at <a href="https://nostarch.com/arduino-arduinians"><i>https://<wbr/>nostarch<wbr/>.com<wbr/>/arduino<wbr/>-arduinians</i></a>, as usual. However, this chapter’s projects include extra files beyond the usual <i>.ino</i> sketch file. For this project, you only need to open the <i>project69.ino</i> file, and the Arduino IDE will automatically open the rest. As shown in <a href="chapter24.xhtml#fig24-8">Figure 24-8</a>, you should see the included files as tabs under the menu bar.</p>
<figure class="IMG"><img alt="A SCREENSHOT OF THE VIDEO FRAMERATE DATA DISPLAY" class="img7" id="fig24-8" src="../images/fig24-8.png"/>
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 24-8: All project file tabs being displayed in Arduino IDE</samp></p></figcaption>
</figure>
<p class="TX">The additional files (<i>app_httpd.cpp</i>, <i>camera_index.h</i>, and <i>camera_pins.h</i>) include data to define the GPIO pins for the ESP32 camera board and include data to help display the web page for the camera. This project operates a predefined interface, so you can’t modify much of it. You’ll only need to concern yourself with the <i>.ino</i> sketch file.</p>
<p class="TX">In the Project #69 sketch, add your Wi-Fi network and name in the SSID and password fields, as originally explained in <span class="Xref">Project #55 in <a href="chapter19.xhtml">Chapter 19</a></span>. Once you’ve connected your ESP32 camera to your computer, upload the sketch and then open the Serial Monitor in the Arduino IDE. If your USB interface is via the external cable, remember to remove the wire link from IO0 to GND and then press <b>RESET</b> on the camera module.</p>
<p class="TX">You should see the IP address that the ESP32 camera is using appear on the Serial Monitor, as shown in <a href="chapter24.xhtml#fig24-9">Figure 24-9</a>.</p>
<figure class="IMG"><img alt="A SCREENSHOT OF THE IDE SERIAL MONITOR, DISPLAYING THE CAMERA’S IP ADDRESS" class="img7" id="fig24-9" src="../images/fig24-9.png"/>
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 24-9: Example output from Serial Monitor displaying the camera’s IP address</samp></p></figcaption>
</figure>
<p class="TX">Open a web browser on your PC or mobile device connected to the same Wi-Fi network and visit the IP address shown in the Serial Monitor. The ESP32 camera should serve a web page with various controls and <span aria-label=" Page 419. " epub:type="pagebreak" id="pg_419" role="doc-pagebreak"/>settings. Click <b>Start Stream</b> at the bottom of the page. The live video stream from the camera should appear on your screen, as shown in <a href="chapter24.xhtml#fig24-10">Figure 24-10</a>. (The video in the figure was taken from my kitchen table.)</p>
<figure class="IMG"><img alt="A SCREENSHOT OF THE CAMERA STREAMING WEBPAGE" class="img9" id="fig24-10" src="../images/fig24-10.png"/>
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 24-10: Example output from the camera streaming page</samp></p></figcaption>
</figure>
<p class="TX">Take some time to experiment with the settings, adjusting the brightness, contrast, and so on. When streaming video, the greater the quality of the image, the greater the amount of data being transmitted over the network. If you find the video update speed, or <i>frame rate</i>, too slow or jerky, change the resolution using the drop-down menu. You can also switch to streaming in black and white, as this requires much less data transmission than color. If you’re curious about the frame rate at the time of operation, you can view it in the Serial Monitor when the camera is streaming, as shown in <a href="chapter24.xhtml#fig24-11">Figure 24-11</a>.</p>
<figure class="IMG"><img alt="A SCREENSHOT OF THE VIDEO FRAMERATE DATA DISPLAY" class="img7" id="fig24-11" src="../images/fig24-11.png"/>
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 24-11: Example frame rate output from an ESP32 camera</samp></p></figcaption>
</figure>
<p class="TX"><span aria-label=" Page 420. " epub:type="pagebreak" id="pg_420" role="doc-pagebreak"/>If you’re not happy with the quality or brightness of the video or images, you may need better external lighting or to reposition your camera to allow more ambient light to reach the lens.</p>
<p class="TX">Let’s take a look at the <i>.ino</i> sketch file:</p>
<span id="pro-69"/>

<pre><code>// Project #69 - Camera web server

#include "esp_camera.h"
#include &lt;WiFi.h&gt;

#define CAMERA_MODEL_AI_THINKER
#include "camera_pins.h"

const char* ssid = "<var>SSID</var>";
const char* password = "<var>password</var>";

void startCameraServer();

void setup()
{
  <span aria-label="annotation1" class="CodeAnnotationHang1">❶</span> Serial.begin(115200);
    Serial.setDebugOutput(true);
    Serial.println();

  <span aria-label="annotation2" class="CodeAnnotationHang1">❷</span> camera_config_t config;
    config.ledc_channel = LEDC_CHANNEL_0;
    config.ledc_timer = LEDC_TIMER_0;
    config.pin_d0 = Y2_GPIO_NUM;
    config.pin_d1 = Y3_GPIO_NUM;
    config.pin_d2 = Y4_GPIO_NUM;
    config.pin_d3 = Y5_GPIO_NUM;
    config.pin_d4 = Y6_GPIO_NUM;
    config.pin_d5 = Y7_GPIO_NUM;
    config.pin_d6 = Y8_GPIO_NUM;
    config.pin_d7 = Y9_GPIO_NUM;
    config.pin_xclk = XCLK_GPIO_NUM;
    config.pin_pclk = PCLK_GPIO_NUM;
    config.pin_vsync = VSYNC_GPIO_NUM;
    config.pin_href = HREF_GPIO_NUM;
    config.pin_sscb_sda = SIOD_GPIO_NUM;
    config.pin_sscb_scl = SIOC_GPIO_NUM;
    config.pin_pwdn = PWDN_GPIO_NUM;
    config.pin_reset = RESET_GPIO_NUM;
    config.xclk_freq_hz = 20000000;
    config.pixel_format = PIXFORMAT_JPEG;
  <span aria-label="annotation3" class="CodeAnnotationHang1">❸</span> config.frame_size = FRAMESIZE_UXGA;
    config.jpeg_quality = 10;
    config.fb_count = 2;

  <span aria-label="annotation4" class="CodeAnnotationHang1">❹</span> esp_err_t err = esp_camera_init(&amp;config);
    if (err != ESP_OK)
    {
      <span aria-label="annotation5" class="CodeAnnotationHang1">❺</span> Serial.printf("Camera init failed with error 0x%x", err);
        return;
<span aria-label=" Page 421. " epub:type="pagebreak" id="pg_421" role="doc-pagebreak"/>    }
  <span aria-label="annotation6" class="CodeAnnotationHang1">❻</span> s-&gt;set_framesize(s, FRAMESIZE_QVGA); // Set default frame size

  <span aria-label="annotation7" class="CodeAnnotationHang1">❼</span> WiFi.begin(ssid, password);
    while (WiFi.status() != WL_CONNECTED)
    {
        delay(500);
        Serial.print(".");
    }
    Serial.println(" ");
    Serial.println("WiFi connected");

    startCameraServer();

  <span aria-label="annotation8" class="CodeAnnotationHang1">❽</span> Serial.print("Camera Ready! Use 'http://");
    Serial.print(WiFi.localIP());
    Serial.println(" ' to connect");
}

void loop() {}
</code></pre>

<p class="TX">The sketch includes the required libraries and then defines the ESP32 camera type, allowing the correct pinout labels to be associated for the Arduino IDE to use. Be sure you’ve inserted your Wi-Fi network’s name and password in the appropriate fields.</p>
<p class="TX">In <samp class="SANS_TheSansMonoCd_W5Regular_11">void setup()</samp>, the code activates the Serial Monitor for debugging <span aria-label="annotation1" class="CodeAnnotationCode">❶</span>. It makes the Arduino GPIO associations for the camera interface pins <span aria-label="annotation2" class="CodeAnnotationCode">❷</span> and then defines the default image size and quality <span aria-label="annotation3" class="CodeAnnotationCode">❸</span>. If there’s a problem initializing the camera, this is articulated <span aria-label="annotation4" class="CodeAnnotationCode">❹</span>. The following <samp class="SANS_TheSansMonoCd_W5Regular_11">printf()</samp> function is available only when using ESP32-compatible Arduino, not Arduino boards themselves. It allows the display of a variable’s value within a string of text. For example, the line at <span aria-label="annotation5" class="CodeAnnotationCode">❺</span> will display the error code stored in variable <samp class="SANS_TheSansMonoCd_W5Regular_11">err</samp> at position <samp class="SANS_TheSansMonoCd_W5Regular_11">%x</samp> in hexadecimal.</p>
<p class="TX">The default image frame size is set to Quarter-VGA (320 <span class="symbol">×</span> 240 pixels, or QVGA) for speed <span aria-label="annotation6" class="CodeAnnotationCode">❻</span>. As the QVGA resolution is smaller, less data is required for each frame, meaning the frame rate can be higher and result in smoother video.</p>
<p class="TX">After making the Wi-Fi connection <span aria-label="annotation7" class="CodeAnnotationCode">❼</span>, the sketch displays the ESP32 camera’s web page IP address in the Serial Monitor <span aria-label="annotation8" class="CodeAnnotationCode">❽</span>. Have fun experimenting with the camera. There are plenty of ways to use this inexpensive piece of hardware, such as monitoring property entrances, watching children from another room, or viewing a bird’s nest. Now is a good time to learn about maximizing the Wi-Fi range with an external antenna.</p>
</section>
<section aria-labelledby="sec3" epub:type="division">
<h2 class="H1" id="sec3"><span id="h1-173"/><samp class="SANS_Futura_Std_Bold_B_11">External Wi-Fi Antenna</samp></h2>
<p class="TNI">The recommended ESP32 camera board in this chapter allows for the use of an external Wi-Fi antenna, which makes a longer distance from the Wi-Fi <span aria-label=" Page 422. " epub:type="pagebreak" id="pg_422" role="doc-pagebreak"/>access point possible. When shopping for an antenna, make sure to find one that includes the cable from the antenna to the ESP32 camera board. The socket on the board is called a <i>uFL</i> or <i>mini ipex connector</i>. The external antenna and cable should be sold in sets but are usually not included with the camera, meaning you need to order them separately.</p>
<p class="TX"><a href="chapter24.xhtml#fig24-12">Figure 24-12</a> shows an example external antenna and cable, PMD Way part 70202023.</p>
<figure class="IMG"><img alt="A PHOTO OF THE EXTERNAL ANTENNA AND CABLE" class="img5" id="fig24-12" src="../images/fig24-12.png"/>
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 24-12: An external antenna and cable</samp></p></figcaption>
</figure>
<p class="TX">To check the module antenna configuration, turn the module over so you can see the antenna socket, the tiny round copper ring just below the antenna on the PCB, as shown in <a href="chapter24.xhtml#fig24-13">Figure 24-13</a>.</p>
<figure class="IMG"><img alt="A PHOTO OF THE ESP32 CAMERA BOARD ANTENNA SOCKET" class="img5" id="fig24-13" src="../images/fig24-13.png"/>
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 24-13: An ESP32 camera board antenna socket</samp></p></figcaption>
</figure>
<p class="TX">On the left of the socket should be three tiny PCB pads—top, bottom, and left. Two of the pads should be bridged by a surface-mount resistor. If the bottom and left pads are bridged in this way, as shown in <a href="chapter24.xhtml#fig24-14">Figure 24-14</a>, you’re ready for an external antenna that can be connected into the socket, as shown in <a href="chapter24.xhtml#fig24-13">Figure 24-13</a>.</p>
<figure class="IMG"><img alt="A PHOTO OF THE ESP32 CAMERA BOARD ANTENNA BRIDGING RESISTORS" class="img3" id="fig24-14" src="../images/fig24-14.png"/>
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 24-14: ESP32 camera board bridging resistors</samp></p></figcaption>
</figure>
<p class="TX">However, if your board has the resistor across the top and left pad, you’ll need to desolder and resolder it to the correct position. To do this, you’ll need a fine-tip soldering iron or a hot-air gun suitable for surface-mount component reflow work, as well as a small amount of solder. If this is a problem for you, check with your board supplier before ordering your ESP32 camera board, if possible.</p>
<p class="TX">Using the antenna greatly improves the radio range of the ESP32 camera board. Once you have the external antenna and cable connected, you can easily demonstrate the improvement in radio range by running the WiFiScan demonstration sketch used earlier in the chapter. For example, <a href="chapter24.xhtml#fig24-15">Figure 24-15</a> shows the results of the sketch without the antenna and then with the antenna connected.</p>
<figure class="IMG"><img alt="A SCREENSHOT OF THE WIFISCAN RESULTS" class="img5" id="fig24-15" src="../images/fig24-15.png"/>
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 24-15: WiFiScan results with and without an external antenna</samp></p></figcaption>
</figure>
<p class="TX"><span aria-label=" Page 423. " epub:type="pagebreak" id="pg_423" role="doc-pagebreak"/>Without the antenna connected, the output shows an RSSI value of <span class="symbol">−</span>92; with the antenna connected, however, the RSSI value is <span class="symbol">−</span>57.</p>
<p class="TX">Now that you know how to test Wi-Fi for the ESP32 camera board and set up video streaming, I’ll show you how to take photos on command and save them to the microSD card with the time and date stored in the filename of each image for easy reference.</p>
<p class="HeadProject"><span id="h1-174"/><samp class="SANS_Futura_Std_Heavy_B_21">Project #70: Taking Photos and Saving Them to a Memory Card</samp></p>
<p class="TNI">This project demonstrates how to control the onboard camera to take a photo at your command. You can use the code from this project in your own sketches to create time-lapse cameras, cameras triggered by sensors or switches, or just your own simple portable digital camera.</p>
<p class="TX">For hardware, you’ll need the ESP32 camera board with matching USB interface and a microSD memory card on which to store the captured images. If you haven’t already done so, format the microSD card for use with the camera, setting the filesystem type to FAT32. Any normal format procedure on a PC, Mac, or Linux machine will have the option to set the filesystem type.</p>
<p class="TX">Insert the formatted card into your ESP32 camera, then connect the ESP32 camera to your computer and upload the Project #70 sketch. Open the Serial Monitor in the Arduino IDE. If your USB interface is via the external cable, remember to remove the wire link from IO0 to GND and then press <b>RESET</b> on the camera module.</p>
<p class="TX">The Serial Monitor should display the filename of the images the ESP32 camera has created, as shown in <a href="chapter24.xhtml#fig24-16">Figure 24-16</a>.</p>
<figure class="IMG"><img alt="A SCREENSHOT OF THE SERIAL MONITOR OUTPUT WITH THE IMAGE FILENAMES" class="img6" id="fig24-16" src="../images/fig24-16.png"/>
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 24-16: Serial Monitor output of image filenames</samp></p></figcaption>
</figure>
<p class="TX"><span aria-label=" Page 424. " epub:type="pagebreak" id="pg_424" role="doc-pagebreak"/>To stop the camera and review the results, disconnect the USB cable from the computer and insert the microSD card into the computer. Open the file manager for your PC and navigate to the drive representing the microSD card, and you should find the images taken by your ESP32 camera. For example, <a href="chapter24.xhtml#fig24-17">Figure 24-17</a> shows a photo of the view from my office.</p>
<figure class="IMG"><img alt="A SCREENSHOT OF THE EXAMPLE OUTPUT FROM PROJECT #70" class="img8" id="fig24-17" src="../images/fig24-17.png"/>
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 24-17: Example output from Project #70</samp></p></figcaption>
</figure>
<p class="TX">Let’s see how this works:</p>
<span id="pro-70"/>

<pre><code>// Project #70 - Save images to microSD card

#include "esp_camera.h"
#include "soc/soc.h"
#include "soc/rtc_cntl_reg.h"
#include "driver/rtc_io.h"
#include "FS.h"
#include "SD_MMC.h"

// Pin definitions for CAMERA_MODEL_AI_THINKER
#define PWDN_GPIO_NUM 32
#define RESET_GPIO_NUM −1
#define XCLK_GPIO_NUM 0
#define SIOD_GPIO_NUM 26
#define SIOC_GPIO_NUM 27
#define Y9_GPIO_NUM 35
#define Y8_GPIO_NUM 34
#define Y7_GPIO_NUM 39
#define Y6_GPIO_NUM 36
#define Y5_GPIO_NUM 21
#define Y4_GPIO_NUM 19
#define Y3_GPIO_NUM 18
#define Y2_GPIO_NUM 5
#define VSYNC_GPIO_NUM 25
<span aria-label=" Page 425. " epub:type="pagebreak" id="pg_425" role="doc-pagebreak"/>#define HREF_GPIO_NUM 23
#define PCLK_GPIO_NUM 22

<span aria-label="annotation1" class="CodeAnnotationHang">❶</span> int imageCounter = 0;

void configESPCamera()
{
    // Object for camera configuration parameters:
    camera_config_t config;

  <span aria-label="annotation2" class="CodeAnnotationHang1">❷</span> config.ledc_channel = LEDC_CHANNEL_0;
    config.ledc_timer = LEDC_TIMER_0;
    config.pin_d0 = Y2_GPIO_NUM;
    config.pin_d1 = Y3_GPIO_NUM;
    config.pin_d2 = Y4_GPIO_NUM;
    config.pin_d3 = Y5_GPIO_NUM;
    config.pin_d4 = Y6_GPIO_NUM;
    config.pin_d5 = Y7_GPIO_NUM;
    config.pin_d6 = Y8_GPIO_NUM;
    config.pin_d7 = Y9_GPIO_NUM;
    config.pin_xclk = XCLK_GPIO_NUM;
    config.pin_pclk = PCLK_GPIO_NUM;
    config.pin_vsync = VSYNC_GPIO_NUM;
    config.pin_href = HREF_GPIO_NUM;
    config.pin_sscb_sda = SIOD_GPIO_NUM;
    config.pin_sscb_scl = SIOC_GPIO_NUM;
    config.pin_pwdn = PWDN_GPIO_NUM;
    config.pin_reset = RESET_GPIO_NUM;
    config.xclk_freq_hz = 20000000;
    config.pixel_format = PIXFORMAT_JPEG;
    config.frame_size = FRAMESIZE_UXGA;
    config.jpeg_quality = 10;
    config.fb_count = 2;

    esp_err_t err = esp_camera_init(&amp;config);
    if (err != ESP_OK)
    {
        Serial.printf("Camera init failed with error 0x%x", err);
        return;
    }

    // Set camera quality parameters:
    sensor_t *s = esp_camera_sensor_get();

  <span aria-label="annotation3" class="CodeAnnotationHang1">❸</span> // Brightness (−2 to 2)
    s-&gt;set_brightness(s, 0);
    // Contrast (−2 to 2)
    s-&gt;set_contrast(s, 0);
    // Saturation (−2 to 2)
    s-&gt;set_saturation(s, 0);
    // Special effects (0 - none, 1 - negative, 2 - grayscale,
    // 3 - red tint, 4 - green tint, 5 - blue tint, 6 - sepia)
    s-&gt;set_special_effect(s,  0);
    // Auto white balance (0 = disable , 1 = enable)
<span aria-label=" Page 426. " epub:type="pagebreak" id="pg_426" role="doc-pagebreak"/>    s-&gt;set_whitebal(s, 1);
    // Auto white balance gain (0 = disable , 1 = enable)
    s-&gt;set_awb_gain(s, 1);
    // WB MODES (0 - automatic, 1 - sunny, 2 - cloudy,
    // 3 - office, 4 - home)
    s-&gt;set_wb_mode(s,  0);
    // EXPOSURE CONTROLS (0 = disable , 1 = enable)
    s-&gt;set_exposure_ctrl(s, 1);
    // AEC2 (0 = disable , 1 = enable)
    s-&gt;set_aec2(s, 0);
    // AE LEVELS (−2 to 2)
    s-&gt;set_ae_level(s, 0);
    // AEC VALUES (0 to 1200)
    s-&gt;set_aec_value(s, 300);
    // GAIN CONTROLS (0 = disable , 1 = enable)
    s-&gt;set_gain_ctrl(s, 1);
    // AGC GAIN (0 to 30)
    s-&gt;set_agc_gain(s, 0);
    // GAIN CEILING (0 to 6)
    s-&gt;set_gainceiling(s, (gainceiling_t)0);
    // BPC (0 = disable , 1 = enable)
    s-&gt;set_bpc(s, 0);
    // WPC (0 = disable , 1 = enable)
    s-&gt;set_wpc(s, 1);
    // RAW GMA (0 = disable , 1 = enable)
    s-&gt;set_raw_gma(s, 1);
    // LENC (0 = disable , 1 = enable)
    s-&gt;set_lenc(s, 1);
    // HORIZ MIRROR (0 = disable , 1 = enable)
    s-&gt;set_hmirror(s, 0);
    // VERT FLIP (0 = disable , 1 = enable)
    s-&gt;set_vflip(s, 0);
    // DCW (0 = disable , 1 = enable)
    s-&gt;set_dcw(s, 1);
    // COLOR  BAR PATTERN (0 = disable , 1 = enable)
    s-&gt;set_colorbar(s, 0);
}

void initMicroSDCard()
{
    if (!SD_MMC.begin())
    {
        Serial.println("microSD card failed");
        return;
    }
    uint8_t cardType = SD_MMC.cardType();
    if (cardType == CARD_NONE)
    {
        Serial.println("microSD card not found");
        return;
    }
}

<span aria-label=" Page 427. " epub:type="pagebreak" id="pg_427" role="doc-pagebreak"/>void takeNewPhoto(String path)
{
    // Set up frame buffer:
    camera_fb_t *fb = esp_camera_fb_get();

    if (!fb)
    {
        Serial.println("Camera capture failed");
        return;
    }

    // Save picture to microSD card:
    fs::FS &amp;fs = SD_MMC;
    File file = fs.open(path.c_str(), FILE_WRITE);
    if (!file)
    {
        Serial.println("Couldn't open file in write mode!");
    } else
    {
        file.write(fb-&gt;buf, fb-&gt;len);
        Serial.printf("File saved as: %s\n", path.c_str());
    }
    file.close();
    esp_camera_fb_return(fb);
}

void captureImage()
{
    imageCounter += 1;
    // Build image path and filename:
    String path = "/ESP32CAM_" + String(imageCounter) + ".jpg";
    Serial.printf("Picture file name: %s\n", path.c_str());
    takeNewPhoto(path);
}

void setup()
{
    Serial.begin(115200);
    WRITE_PERI_REG(RTC_CNTL_BROWN_OUT_REG, 0);
    configESPCamera();
    initMicroSDCard();
}

void loop()
{
    captureImage();
    delay(5000);
}
</code></pre>

<p class="TX">The sketch includes all the required libraries and then gives the pin definitions for the AI-Thinker ESP32 camera board. Every time the camera takes a photo, the program tracks the number of photos using the <samp class="SANS_TheSansMonoCd_W5Regular_11">image</samp><samp class="SANS_TheSansMonoCd_W5Regular_11">Counter</samp> <span aria-label=" Page 428. " epub:type="pagebreak" id="pg_428" role="doc-pagebreak"/>integer variable <span aria-label="annotation1" class="CodeAnnotationCode">❶</span>, which will become part of the image’s filename (as demonstrated in <a href="chapter24.xhtml#fig24-17">Figure 24-17</a>).</p>
<p class="TX">The sketch also defines the pin numbers used for connection to the camera <span aria-label="annotation2" class="CodeAnnotationCode">❷</span>, saves the image type, and defines the image size and quality from <samp class="SANS_TheSansMonoCd_W5Regular_11">config.pixel_format</samp>. This is set to the <i>.jpg</i> file type, an image size of UXGA (1,600 <span class="symbol">×</span> 1,200 pixels), and a maximum quality of 10 (the higher the number, the lower the image quality). Other camera settings <span aria-label="annotation3" class="CodeAnnotationCode">❸</span> include white balance control, brightness, contrast, and so on. The comments in the sketch above each of these parameters describe their value ranges, so you can experiment with the values to get the desired result for your camera installation.</p>
<p class="TX">The <samp class="SANS_TheSansMonoCd_W5Regular_11">initMicroSDCard()</samp> function contains the initialization for the microSD card circuitry, while the <samp class="SANS_TheSansMonoCd_W5Regular_11">takeNewPhoto()</samp>function enables the camera to take and save an image; its parameter is the filename with which to store the image. The crux of the sketch is <samp class="SANS_TheSansMonoCd_W5Regular_11">captureImage()</samp>, which the program calls to capture images. This function increments the <samp class="SANS_TheSansMonoCd_W5Regular_11">imageCounter</samp> variable and inserts it into a string for the image filename beginning with <i>/ESP32CAM_</i> (which you can change to meet your needs) and adds the <i>.jpg</i> file extension to the end. Note that if you reset the ESP32 board before retrieving images from the memory card, they will be overwritten.</p>
<p class="TX">In <samp class="SANS_TheSansMonoCd_W5Regular_11">void setup()</samp>, the sketch initializes the Serial Monitor, followed by the <samp class="SANS_TheSansMonoCd_W5Regular_11">WRITE_PERI_REG()</samp> function that turns off brown-out detection for the camera. This function allows the camera to keep operating (though at a lower quality) if the supply voltage drops temporarily. The sketch initializes the camera and the microSD card circuitry. Finally, it captures a new image by calling <samp class="SANS_TheSansMonoCd_W5Regular_11">captureImage()</samp>, followed by an arbitrary five-second delay.</p>
<p class="TX">You can build your own digital photography projects around the sketch for this project, which contains everything you need to control the camera—simply adjust the camera settings to your liking and call the <samp class="SANS_TheSansMonoCd_W5Regular_11">captureImage()</samp> function when you need a photo taken. The process of capturing an image and saving it to the microSD card takes around two seconds, though, so you can’t force it to work any faster than that.</p>
<p class="TX">Now that you can take your own photos, it’s time to learn about the pinouts on your ESP32 camera board so you can interact with external devices to expand your projects.</p>
</section>
<section aria-labelledby="sec4" epub:type="division">
<h2 class="H1" id="sec4"><span id="h1-175"/><samp class="SANS_Futura_Std_Bold_B_11">The ESP32 Camera Pinouts</samp></h2>
<p class="TNI">As with the ESP32 dev board, the ESP32 camera board has a range of GPIO pins you can use for noncamera operations. Once you understand these pinouts, you can use them in your own projects as needed. <a href="chapter24.xhtml#tab24-2">Table 24-2</a> shows the pin labels and their matching Arduino use.</p>
<figure class="table">
<p class="TableTitle" id="tab24-2"><span aria-label=" Page 429. " epub:type="pagebreak" id="pg_429" role="doc-pagebreak"/><span class="Heavy"><samp class="SANS_Futura_Std_Heavy_B_11">Table 24-2:</samp></span> <samp class="SANS_Futura_Std_Book_11">ESP32 Camera Pinouts</samp></p>
<table class="table">
<thead>
<tr>
<th class="table TCH" scope="col"><p class="TCH"><samp class="SANS_Futura_Std_Heavy_B_11">Pin label</samp></p></th>
<th class="table TCH" scope="col"><p class="TCH"><samp class="SANS_Futura_Std_Heavy_B_11">Pin use</samp></p></th>
<th class="table TCH" scope="col"><p class="TCH"><samp class="SANS_Futura_Std_Heavy_B_11">Note</samp></p></th>
</tr>
</thead>
<tbody>
<tr>
<td class="table TBF"><p class="TB"><samp class="SANS_Futura_Std_Book_11">5V</samp></p></td>
<td class="table TBF"><p class="TB"><samp class="SANS_Futura_Std_Book_11">5 V power input</samp></p></td>
<td class="table TBF"><p class="TB"><samp class="SANS_Futura_Std_Book_11">n/a</samp></p></td>
</tr>
<tr>
<td class="table TB"><p class="TB"><samp class="SANS_Futura_Std_Book_11">GND</samp></p></td>
<td class="table TB"><p class="TB"><samp class="SANS_Futura_Std_Book_11">GND</samp></p></td>
<td class="table TB"><p class="TB"><samp class="SANS_Futura_Std_Book_11">n/a</samp></p></td>
</tr>
<tr>
<td class="table TB"><p class="TB"><samp class="SANS_Futura_Std_Book_11">IO12</samp></p></td>
<td class="table TB"><p class="TB"><samp class="SANS_Futura_Std_Book_11">GPIO pin</samp></p></td>
<td class="table TB"><p class="TB"><samp class="SANS_Futura_Std_Book_11">n/a</samp></p></td>
</tr>
<tr>
<td class="table TB"><p class="TB"><samp class="SANS_Futura_Std_Book_11">IO13</samp></p></td>
<td class="table TB"><p class="TB"><samp class="SANS_Futura_Std_Book_11">GPIO pin</samp></p></td>
<td class="table TB"><p class="TB"><samp class="SANS_Futura_Std_Book_11">n/a</samp></p></td>
</tr>
<tr>
<td class="table TB"><p class="TB"><samp class="SANS_Futura_Std_Book_11">IO15</samp></p></td>
<td class="table TB"><p class="TB"><samp class="SANS_Futura_Std_Book_11">GPIO pin</samp></p></td>
<td class="table TB"><p class="TB"><samp class="SANS_Futura_Std_Book_11">n/a</samp></p></td>
</tr>
<tr>
<td class="table TB"><p class="TB"><samp class="SANS_Futura_Std_Book_11">IO14</samp></p></td>
<td class="table TB"><p class="TB"><samp class="SANS_Futura_Std_Book_11">GPIO pin</samp></p></td>
<td class="table TB"><p class="TB"><samp class="SANS_Futura_Std_Book_11">n/a</samp></p></td>
</tr>
<tr>
<td class="table TB"><p class="TB"><samp class="SANS_Futura_Std_Book_11">IO2</samp></p></td>
<td class="table TB"><p class="TB"><samp class="SANS_Futura_Std_Book_11">GPIO pin</samp></p></td>
<td class="table TB"><p class="TB"><samp class="SANS_Futura_Std_Book_11">n/a</samp></p></td>
</tr>
<tr>
<td class="table TB"><p class="TB"><samp class="SANS_Futura_Std_Book_11">IO4</samp></p></td>
<td class="table TB"><p class="TB"><samp class="SANS_Futura_Std_Book_11">GPIO pin</samp></p></td>
<td class="table TB"><p class="TB"><samp class="SANS_Futura_Std_Book_11">Controls onboard bright LED</samp></p></td>
</tr>
<tr>
<td class="table TB"><p class="TB"><samp class="SANS_Futura_Std_Book_11">3V3</samp></p></td>
<td class="table TB"><p class="TB"><samp class="SANS_Futura_Std_Book_11">3.3 V power input</samp></p></td>
<td class="table TB"><p class="TB"><samp class="SANS_Futura_Std_Book_11">Preferable to use 5 V</samp></p></td>
</tr>
<tr>
<td class="table TB"><p class="TB"><samp class="SANS_Futura_Std_Book_11">IO16</samp></p></td>
<td class="table TB"><p class="TB"><samp class="SANS_Futura_Std_Book_11">GPIO pin</samp></p></td>
<td class="table TB"><p class="TB"><samp class="SANS_Futura_Std_Book_11">n/a</samp></p></td>
</tr>
<tr>
<td class="table TB"><p class="TB"><samp class="SANS_Futura_Std_Book_11">IO0</samp></p></td>
<td class="table TB"><p class="TB"><samp class="SANS_Futura_Std_Book_11">Code uploading/GPIO pin</samp></p></td>
<td class="table TB"><p class="TB"><samp class="SANS_Futura_Std_Book_11">Connect to GND to upload code</samp></p></td>
</tr>
<tr>
<td class="table TB"><p class="TB"><samp class="SANS_Futura_Std_Book_11">GND</samp></p></td>
<td class="table TB"><p class="TB"><samp class="SANS_Futura_Std_Book_11">GND</samp></p></td>
<td class="table TB"><p class="TB"><samp class="SANS_Futura_Std_Book_11">n/a</samp></p></td>
</tr>
<tr>
<td class="table TB"><p class="TB"><samp class="SANS_Futura_Std_Book_11">VCC</samp></p></td>
<td class="table TB"><p class="TB"><samp class="SANS_Futura_Std_Book_11">Power output</samp></p></td>
<td class="table TB"><p class="TB"><samp class="SANS_Futura_Std_Book_11">Output, not input!</samp></p></td>
</tr>
<tr>
<td class="table TB"><p class="TB"><samp class="SANS_Futura_Std_Book_11">UOR</samp></p></td>
<td class="table TB"><p class="TB"><samp class="SANS_Futura_Std_Book_11">Serial RX (receive)</samp></p></td>
<td class="table TB"><p class="TB"><samp class="SANS_Futura_Std_Book_11">n/a</samp></p></td>
</tr>
<tr>
<td class="table TB"><p class="TB"><samp class="SANS_Futura_Std_Book_11">UOT</samp></p></td>
<td class="table TB"><p class="TB"><samp class="SANS_Futura_Std_Book_11">Serial TX (transmit)</samp></p></td>
<td class="table TB"><p class="TB"><samp class="SANS_Futura_Std_Book_11">n/a</samp></p></td>
</tr>
<tr>
<td class="table TBL"><p class="TB"><samp class="SANS_Futura_Std_Book_11">GND</samp></p></td>
<td class="table TBL"><p class="TB"><samp class="SANS_Futura_Std_Book_11">GND</samp></p></td>
<td class="table TBL"><p class="TB"><samp class="SANS_Futura_Std_Book_11">n/a</samp></p></td>
</tr>
</tbody>
</table>
</figure>
<p class="TX">If you’re using the camera, it’s preferable to power the ESP32 camera with 5 V; otherwise, 3.3 V is fine. Running at the lower voltage can cause a slight image degradation. I recommend a 5 V DC with at least 500 mA of current from an external power supply when building your own projects that include more hardware than just the board.</p>
<p class="TX">The bright white “flash” LED is connected to GPIO pin IO4 and can be turned on and off like any digital output pin. It’s also connected to the microSD card socket circuit and will turn on when the card is being accessed. This LED generates a lot of heat, so when controlling it for your own projects, don’t run it continuously for longer than one second before allowing time for it to cool off.</p>
<p class="TX">There is a small red LED on the other side of the camera module that is connected internally as GPIO pin 33. It’s wired inversely so that setting that pin LOW turns the LED on and HIGH turns it off. Overall, the GPIO pins can be used as inputs or outputs. Remember that the logic voltage is 3.3 V, not 5 V.</p>
</section>
<section aria-labelledby="sec5" epub:type="division">
<h2 class="H1" id="sec5"><span id="h1-176"/><samp class="SANS_Futura_Std_Bold_B_11">Moving On</samp></h2>
<p class="TNI">In this chapter, you learned to harness the inexpensive and useful ESP32 camera board for video streaming or taking photos and saving them to a <span aria-label=" Page 430. " epub:type="pagebreak" id="pg_430" role="doc-pagebreak"/>memory card. This adds a final skill set to the six ESP32-based chapters, which have demonstrated various ways of controlling projects remotely and logging and displaying data.</p>
<p class="TX">This marks the final chapter of <i>Arduino for Arduinians</i>! To continue your Arduino journey, check out the epilogue for some next steps.</p>
</section>
</section>
</body>
</html>