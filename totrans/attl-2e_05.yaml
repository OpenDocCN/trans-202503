- en: '5'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '5'
- en: 'MORE FUN WITH AUTOCONF: CONFIGURING USER OPTIONS'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 更有趣的Autoconf：配置用户选项
- en: '*Hope is not the conviction that something will turn out well, but the certainty
    that something makes sense, regardless of how it turns out.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: '*希望不是确信某事会顺利发展，而是确信某事有意义，无论结果如何。*'
- en: —Václav Havel*, Disturbing the Peace
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: —瓦茨拉夫·哈维尔*，《打破和平》
- en: '![Image](../images/common.jpg)'
  id: totrans-4
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/common.jpg)'
- en: In [Chapter 4](ch04.xhtml), we discussed the essentials of Autoconf—how to bootstrap
    a new or existing project and how to understand some of the basic aspects of *configure.ac*
    files. In this chapter, we cover some of the more complex Autoconf macros. We’ll
    begin by discussing how to substitute our own variables into template files (for
    example, *Makefile.in*) and how to define our own preprocessor definitions from
    within the configuration script. Throughout this chapter, we’ll continue to develop
    functionality in the Jupiter project by adding important checks and tests. We’ll
    cover the all-important `AC_OUTPUT` macro, and we’ll conclude by discussing the
    application of user-defined project configuration options as specified in the
    *configure.ac* file.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第4章](ch04.xhtml)中，我们讨论了Autoconf的基本内容——如何启动一个新的或现有的项目，以及如何理解一些*configure.ac*文件的基本方面。在本章中，我们将介绍一些更复杂的Autoconf宏。我们将从讨论如何将自定义变量替换到模板文件（例如*Makefile.in*）中开始，并介绍如何在配置脚本中定义我们自己的预处理器定义。在本章中，我们将继续通过添加重要的检查和测试来开发Jupiter项目的功能。我们将涵盖至关重要的`AC_OUTPUT`宏，最后将讨论如何应用在*configure.ac*文件中指定的用户定义的项目配置选项。
- en: In addition to all this, I’ll present an analysis technique you can use to decipher
    the inner workings of macros. Using the somewhat complex `AC_CHECK``_PROG` macro
    as an example, I’ll show you some ways to find out what’s going on under the hood.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 除此之外，我将介绍一种分析技巧，可以帮助你解读宏的内部工作原理。以稍微复杂的`AC_CHECK_PROG`宏为例，我将向你展示一些了解其工作原理的方法。
- en: Substitutions and Definitions
  id: totrans-7
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 替换和定义
- en: 'We’ll begin this chapter by discussing three of the most important macros in
    the Autoconf suite: `AC_SUBST` and `AC_DEFINE`, along with the latter’s twin brother,
    `AC_DEFINE_UNQUOTED`.'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将通过讨论Autoconf套件中三个最重要的宏开始本章内容：`AC_SUBST`和`AC_DEFINE`，以及后者的兄弟宏`AC_DEFINE_UNQUOTED`。
- en: These macros provide the primary mechanisms for communication between the configuration
    process and the build and execution processes. Values that are *substituted* into
    generated files provide configuration information to the build process, while
    values defined in preprocessor variables provide configuration information at
    build time to the compiler and at runtime to the built programs and libraries.
    As a result, it’s well worth becoming thoroughly familiar with `AC_SUBST` and
    `AC_DEFINE`.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 这些宏提供了配置过程与构建和执行过程之间的主要通信机制。*替换*到生成文件中的值为构建过程提供配置信息，而在预处理器变量中定义的值则在构建时为编译器提供配置信息，并在运行时为构建的程序和库提供配置信息。因此，深入了解`AC_SUBST`和`AC_DEFINE`是非常值得的。
- en: '*AC_SUBST*'
  id: totrans-10
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*AC_SUBST*'
- en: 'You can use `AC_SUBST` to extend the variable substitution functionality that’s
    such an integral part of Autoconf. Every Autoconf macro that has anything to do
    with substitution variables ultimately calls this macro to create the substitution
    variables from existing shell variables. Sometimes the shell variables are inherited
    from the environment; other times, higher-level macros set the shell variables
    as part of their functionality before calling `AC_SUBST`. The signature of this
    macro is rather trivial (note that the square brackets in this prototype represent
    optional arguments, not Autoconf quotes):'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用`AC_SUBST`扩展Autoconf中作为核心部分的变量替换功能。每个与替换变量相关的Autoconf宏，最终都会调用这个宏，从现有的Shell变量中创建替换变量。有时这些Shell变量来自环境变量；有时，较高级的宏会在调用`AC_SUBST`之前，作为其功能的一部分设置这些Shell变量。这个宏的签名相对简单（注意，该原型中的方括号表示可选参数，而不是Autoconf的引用）：
- en: '[PRE0]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '**NOTE**'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*If you choose to omit any trailing optional parameters when invoking M4 macros,
    you may also omit the trailing commas.^([1](footnote.xhtml#ch05fn1)) However,
    if you omit any arguments from the middle of the list, you must provide the commas
    as placeholders for the missing arguments.*'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '*如果在调用M4宏时选择省略任何尾随的可选参数，你也可以省略尾随的逗号。^([1](footnote.xhtml#ch05fn1))然而，如果你省略了中间部分的任何参数，必须为缺失的参数提供逗号作为占位符。*'
- en: The first argument, *`shell_var`*, represents a shell variable whose value you
    wish to substitute into all files generated by `config.status` from templates.
    The optional second parameter is the value assigned to the variable. If it isn’t
    specified, the shell variable’s current value will be used, whether it’s inherited
    or set by some previous shell code.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个参数，*`shell_var`*，表示一个 shell 变量，其值将被替换到通过 `config.status` 从模板生成的所有文件中。可选的第二个参数是赋给该变量的值。如果没有指定，shell
    变量的当前值将被使用，无论它是继承的还是由某些之前的 shell 代码设置的。
- en: The substitution variable will have the same name as the shell variable, except
    that it will be bracketed with at signs (`@`) in the template files. Thus, a shell
    variable named `my_var` would become the substitution variable reference `@my_var@`,
    and you could use it in any template file.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 替代变量将与 shell 变量具有相同的名称，只是在模板文件中，它将被 `@` 符号括起来。因此，一个名为 `my_var` 的 shell 变量将变成替代变量引用
    `@my_var@`，你可以在任何模板文件中使用它。
- en: 'Calls to `AC_SUBST` in *configure.ac* should not be made conditionally; that
    is, they should not be called within conditional shell statements like `if`-`then`-`else`
    constructs. The reason becomes clear when you carefully consider the purpose of
    `AC_SUBST`: you’ve already hardcoded substitution variable references into your
    template files, so you’d better use `AC_SUBST` for each variable unconditionally,
    or else your output files will retain the variable references rather than the
    values that should have been substituted.'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *configure.ac* 中调用 `AC_SUBST` 不应具有条件性；也就是说，它们不应在类似 `if`-`then`-`else` 结构的条件
    shell 语句中被调用。当你仔细考虑 `AC_SUBST` 的目的时，这一点变得清晰：你已经将替代变量引用硬编码到模板文件中，因此你最好对每个变量无条件地使用
    `AC_SUBST`，否则输出文件将保留变量引用，而不是应该被替换的值。
- en: '*AC_DEFINE*'
  id: totrans-18
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*AC_DEFINE*'
- en: The `AC_DEFINE` and `AC_DEFINE_UNQUOTED` macros define C-preprocessor macros,
    which can be simple or function-like macros. These are either defined in the *config.h.in*
    template (if you use `AC_CONFIG_HEADERS`) or passed on the compiler command line
    (via the `@DEFS@` substitution variable) in *Makefile.in* templates. Recall that
    if you don’t write *config.h.in* yourself, `autoheader` will write it based on
    calls to these macros in your *configure.ac* file.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '`AC_DEFINE` 和 `AC_DEFINE_UNQUOTED` 宏定义 C 预处理器宏，这些宏可以是简单的宏或类似函数的宏。这些宏要么在 *config.h.in*
    模板中定义（如果你使用 `AC_CONFIG_HEADERS`），要么通过 *Makefile.in* 模板中的 `@DEFS@` 替代变量传递给编译器命令行。回想一下，如果你没有自己编写
    *config.h.in*，`autoheader` 会根据你在 *configure.ac* 文件中调用这些宏的情况自动生成它。'
- en: 'These two macro names actually represent four different Autoconf macros. Here
    are their prototypes:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个宏名称实际上代表四个不同的 Autoconf 宏。以下是它们的原型：
- en: '[PRE1]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The difference between the normal and the `UNQUOTED` versions of these macros
    is that the normal versions use, verbatim, the specified value as the value of
    the preprocessor macro. The `UNQUOTED` versions perform shell expansion on the
    *`value`* argument, and they use the result as the value of the preprocessor macro.
    Thus, you should use `AC_DEFINE_UNQUOTED` if the value contains shell variables
    that you want `configure` to expand. (Setting a C-preprocessor macro in a header
    file to an unexpanded shell variable makes no sense, because neither the C compiler
    nor the preprocessor will know what to do with it when the source code is compiled.)
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 这些宏的正常版本与 `UNQUOTED` 版本的区别在于，正常版本原样使用指定的值作为预处理器宏的值。`UNQUOTED` 版本对 *`value`*
    参数进行 shell 扩展，并使用结果作为预处理器宏的值。因此，如果值包含你希望 `configure` 扩展的 shell 变量，应该使用 `AC_DEFINE_UNQUOTED`。（在头文件中将
    C 预处理器宏设置为未扩展的 shell 变量没有意义，因为 C 编译器或预处理器在编译源代码时都不知道该如何处理它。）
- en: The difference between the single- and multi-argument versions lies in the way
    the preprocessor macros are defined. The single-argument versions simply guarantee
    that the macro is *defined* in the preprocessor namespace, while the multi-argument
    versions ensure that the macro is defined with a specific value.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 单参数版本和多参数版本的区别在于预处理器宏的定义方式。单参数版本仅保证宏在预处理器命名空间中被*定义*，而多参数版本确保宏以特定的值被定义。
- en: The optional third parameter, *`description`*, tells `autoheader` to add a comment
    for this macro to the *config.h.in* template. (If you don’t use `autoheader`,
    it makes no sense to pass a description here—hence, its optional status.) If you
    wish to define a preprocessor macro without a value and provide a *`description`*,
    you should use the multi-argument versions of these macros but leave the `value`
    argument empty. Another option is to use `AH_TEMPLATE`—an `autoheader`-specific
    macro—which does the same thing as `AC_DEFINE` when a *`description`* is given
    but no *`value`* is required.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 可选的第三个参数，*`description`*，告诉`autoheader`在*config.h.in*模板中为此宏添加注释。（如果你不使用`autoheader`，传递描述就没有意义——因此，它是可选的。）如果你希望定义一个没有值的预处理器宏并提供*`description`*，你应该使用这些宏的多参数版本，但将`value`参数留空。另一种选择是使用`AH_TEMPLATE`——一个特定于`autoheader`的宏——它在给定*`description`*但不需要*`value`*时，与`AC_DEFINE`做相同的事情。
- en: Checking for Compilers
  id: totrans-25
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 检查编译器
- en: 'The `AC_PROG_CC` macro ensures that the user’s system has a working C-language
    compiler. Here’s the prototype for this macro:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '`AC_PROG_CC`宏确保用户系统中有一个有效的C语言编译器。以下是这个宏的原型：'
- en: '[PRE2]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: If your code requires a particular flavor or brand of C compiler, you can pass
    a whitespace-separated list of program names in this argument. For example, if
    you use `AC_PROG_CC([cc cl gcc]`), the macro expands into shell code that searches
    for `cc`, `cl`, and `gcc`, in that order. Usually, the optional argument is omitted,
    allowing the macro to find the best compiler option available on the user’s system.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的代码需要特定类型或品牌的C编译器，你可以在这个参数中传递一个由空格分隔的程序名称列表。例如，如果你使用`AC_PROG_CC([cc cl gcc])`，该宏会扩展为在shell代码中搜索`cc`、`cl`和`gcc`，按此顺序进行。通常，可选的参数会被省略，允许宏找到用户系统中最佳的编译器选项。
- en: You’ll recall from “An Even Quicker Start with `autoscan`” on [page 95](ch04.xhtml#page_95)
    that when `autoscan` noticed C source files in the directory tree, it inserted
    a no-argument call to this macro into Jupiter’s *configure.scan* file. [Listing
    5-1](ch05.xhtml#ch05ex1) reproduces the relevant portion of the generated *configure.scan*
    file.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 你会记得在“通过`autoscan`更快开始”中提到的内容，位于[第95页](ch04.xhtml#page_95)，当`autoscan`在目录树中发现C源文件时，它会在Jupiter的*configure.scan*文件中插入一个无参数调用该宏的命令。[列表5-1](ch05.xhtml#ch05ex1)复现了生成的*configure.scan*文件中的相关部分。
- en: '[PRE3]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '*Listing 5-1:* configure.scan: *Checking for compilers and other programs*'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表5-1:* configure.scan：*检查编译器和其他程序*'
- en: '**NOTE**'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*If the source files in Jupiter’s directory tree had been suffixed with* .cc,
    .cxx, *or* .C *(all common extensions for C++ source files), *`autoscan`* would
    have instead inserted a call to *`AC_PROG_CXX`*.*'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '*如果Jupiter目录树中的源文件后缀是* .cc, .cxx, *或* .C *（这些都是常见的C++源文件扩展名），*`autoscan`*会改为插入对*`AC_PROG_CXX`*的调用。*'
- en: The `AC_PROG_CC` macro looks for `gcc` and then `cc` in the system search path.
    If it doesn’t find either, it looks for other C compilers. When it finds a compatible
    compiler, the macro sets a well-known variable, `CC`, to the full path of the
    program, with options for portability as needed, unless the user has already set
    `CC` in the environment or on the `configure` command line.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '`AC_PROG_CC`宏在系统搜索路径中查找`gcc`，然后是`cc`。如果它没有找到任何一个，它会继续查找其他C编译器。当它找到一个兼容的编译器时，宏会设置一个已知的变量`CC`，并根据需要提供移植性选项，除非用户已经在环境变量或`configure`命令行中设置了`CC`。'
- en: 'The `AC_PROG_CC` macro also defines the following Autoconf substitution variables,
    some of which you may recognize as *user variables* (listed in [Table 3-2](ch03.xhtml#ch03tab2)
    on [page 71](ch03.xhtml#page_71)):'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '`AC_PROG_CC`宏还定义了以下Autoconf替换变量，其中一些你可能会认作是*用户变量*（在[表格3-2](ch03.xhtml#ch03tab2)中的[第71页](ch03.xhtml#page_71)列出）：'
- en: '`@CC@` (full path of compiler)'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@CC@`（编译器的完整路径）'
- en: '`@CFLAGS@` (for example, `-g -O2` for `gcc`)'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@CFLAGS@`（例如，`-g -O2`用于`gcc`）'
- en: '`@CPPFLAGS@` (empty by default)'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@CPPFLAGS@`（默认空）'
- en: '`@EXEEXT@` (for example, *.exe*)'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@EXEEXT@`（例如，*.exe*）'
- en: '`@OBJEXT@` (for example, *o*)^([2](footnote.xhtml#ch05fn2))'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@OBJEXT@`（例如，*o*）^([2](footnote.xhtml#ch05fn2))'
- en: '`AC_PROG_CC` configures these substitution variables, but unless you use them
    in your *Makefile.in* templates, you’re just wasting time running `./configure`.
    Conveniently, we’re already using them in our *Makefile.in* templates, because
    earlier in the Jupiter project, we added them to our compiler command line and
    then added a default value for `CFLAGS` that the user could override on the `make`
    command line.'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '`AC_PROG_CC` 配置这些替换变量，但除非你在你的*Makefile.in*模板中使用它们，否则你只是浪费时间运行`./configure`。方便的是，我们已经在我们的*Makefile.in*模板中使用了它们，因为在Jupiter项目的早期，我们将它们添加到了我们的编译命令行中，并为`CFLAGS`添加了一个默认值，用户可以在`make`命令行中覆盖它。'
- en: The only thing left to do is ensure that `config.status` substitutes values
    for these variable references. [Listing 5-2](ch05.xhtml#ch05ex2) shows the relevant
    portions of the *src* directory *Makefile.in* template and the changes necessary
    to make this happen.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 唯一剩下的事情是确保`config.status`为这些变量引用进行替换。[列表 5-2](ch05.xhtml#ch05ex2)显示了*src*目录*Makefile.in*模板的相关部分以及使这一切发生所需的更改。
- en: Git tag 5.0
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: Git 标签 5.0
- en: '[PRE4]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '*Listing 5-2:* src/Makefile.in: *Using Autoconf compiler and flag substitution
    variables*'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 5-2:* src/Makefile.in: *使用 Autoconf 编译器和标志替换变量*'
- en: Checking for Other Programs
  id: totrans-46
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 检查其他程序
- en: Immediately following the call to `AC_PROG_CC` (refer to [Listing 5-1](ch05.xhtml#ch05ex1))
    is a call to `AC_PROG_INSTALL`. All of the `AC_PROG_*` macros set (and then substitute,
    using `AC_SUBST`) various environment variables that point to the located utilities.
    `AC_PROG_INSTALL` does the same thing for the `install` utility. To use this check,
    you need to use the associated Autoconf substitution variables in your *Makefile.in*
    templates, just as we did earlier with `@CC@`, `@CFLAGS@`, and `@CPPFLAGS@`. [Listing
    5-3](ch05.xhtml#ch05ex3) illustrates these changes.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 紧接在调用`AC_PROG_CC`之后（请参见[列表 5-1](ch05.xhtml#ch05ex1)）是调用`AC_PROG_INSTALL`。所有的`AC_PROG_*`宏都会设置（然后使用`AC_SUBST`进行替换）指向已定位工具的各种环境变量。`AC_PROG_INSTALL`为`install`工具做了相同的事情。要使用此检查，你需要在你的*Makefile.in*模板中使用相关的Autoconf替换变量，就像我们之前对`@CC@`、`@CFLAGS@`和`@CPPFLAGS@`所做的那样。[列表
    5-3](ch05.xhtml#ch05ex3)展示了这些更改。
- en: Git tag 5.1
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: Git 标签 5.1
- en: '[PRE5]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '*Listing 5-3:* src/Makefile.in: *Substituting the `install` utility in your
    Makefile.in templates*'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 5-3:* src/Makefile.in: *在你的 Makefile.in 模板中替换 `install` 实用程序*'
- en: The value of `@INSTALL@` is obviously the path of the located installation program.
    The value of `@INSTALL_DATA@` is `${INSTALL} -m 0644`. Based on this, you might
    think that the values of `@INSTALL_PROGRAM@` and `@INSTALL_SCRIPT@` would be something
    like `${INSTALL} -m 0755`, but they’re not. These values are set simply to `${INSTALL}`.^([3](footnote.xhtml#ch05fn3))
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '`@INSTALL@`的值显然是已定位的安装程序的路径。`@INSTALL_DATA@`的值是`${INSTALL} -m 0644`。基于此，你可能会认为`@INSTALL_PROGRAM@`和`@INSTALL_SCRIPT@`的值会是`${INSTALL}
    -m 0755`之类的，但事实并非如此。这些值被简单地设置为`${INSTALL}`。^([3](footnote.xhtml#ch05fn3))'
- en: You might also need to test for other important utility programs, including
    `lex`, `yacc`, `sed`, and `awk`. If your program requires one or more of these
    tools, you can add invocations of `AC_PROG_LEX`, `AC_PROG_YACC`, `AC_PROG_SED`,
    or `AC_PROG_AWK`. If it detects files in your project’s directory tree with *.yy*
    or *.ll* extensions, `autoscan` will add invocations of `AC_PROG_YACC` and `AC_PROG_LEX`
    to *configure.scan*.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能还需要检查其他重要的实用程序，包括`lex`、`yacc`、`sed`和`awk`。如果你的程序需要这些工具中的一个或多个，你可以添加`AC_PROG_LEX`、`AC_PROG_YACC`、`AC_PROG_SED`或`AC_PROG_AWK`的调用。如果它在你项目的目录树中检测到带有*.yy*或*.ll*扩展名的文件，`autoscan`将会将`AC_PROG_YACC`和`AC_PROG_LEX`的调用添加到*configure.scan*中。
- en: You can check for about a dozen different programs using these more specialized
    macros. If a program check fails, the resulting `configure` script will fail with
    a message indicating that the required utility could not be found and that the
    build cannot continue until it has been properly installed.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用这些更专业的宏检查大约十几种不同的程序。如果程序检查失败，生成的`configure`脚本将失败，并显示一条消息，指示无法找到所需的工具，并且在工具正确安装之前，构建无法继续。
- en: The program and compiler checks cause `autoconf` to substitute specially named
    variables into template files. You can find the names of the variables for each
    macro in the *GNU Autoconf Manual*. You should use these `make` variables in commands
    within your *Makefile.in* templates to invoke the tools they represent. The Autoconf
    macros will set the values of these variables according to the tools they find
    installed on the user’s system, *if the user has not already set them in the environment*.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 程序和编译器检查会导致 `autoconf` 将特别命名的变量替换到模板文件中。你可以在 *GNU Autoconf Manual* 中找到每个宏的变量名称。你应该在
    *Makefile.in* 模板中的命令中使用这些 `make` 变量来调用它们代表的工具。Autoconf 宏会根据用户系统上安装的工具设置这些变量的值，*如果用户尚未在环境中设置它们*。
- en: This is a key aspect of Autoconf-generated `configure` scripts—the user can
    *always* override anything `configure` will do to the environment by exporting
    or setting an appropriate variable before executing `configure`.^([4](footnote.xhtml#ch05fn4))
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 这是 Autoconf 生成的 `configure` 脚本中的一个关键方面——用户可以 *始终* 通过在执行 `configure` 之前导出或设置适当的变量来覆盖
    `configure` 对环境所做的任何更改。^([4](footnote.xhtml#ch05fn4))
- en: 'For example, if the user chooses to build with a specific version of `bison`
    installed in the home directory, they could enter the following command in order
    to ensure that `$(YACC)` refers to the correct version of `bison` and that the
    shell code `AC_PROG_YACC` generates does little more than substitute the existing
    value of `YACC` for `@YACC@` in your *Makefile.in* templates:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果用户选择使用安装在主目录中的特定版本的 `bison` 构建，可以输入以下命令，以确保 `$(YACC)` 引用正确版本的 `bison`，并且
    shell 代码 `AC_PROG_YACC` 生成的内容仅仅是将现有的 `YACC` 值替换为你 *Makefile.in* 模板中的 `@YACC@`：
- en: '[PRE6]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '**NOTE**'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*Passing the variable setting to *`configure`* as a parameter is functionally
    similar to setting the variable for the *`configure`* process on the command line
    in the shell environment (for example, *`YACC="$HOME/bin/bison -y" ./configure`*).
    The advantage of using the syntax given in this example is that *`config.status
    --recheck`* can then track the value and properly re-execute *`configure`* from
    the makefile with the options that were originally given to it. Thus, you should
    always use the parameter syntax, rather than the shell environment syntax, to
    set variables for *`configure`*. For ways to enforce the use of this syntax, see
    the documentation for *`AC_ARG_VAR`* in the Autoconf manual.*'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '*将变量设置作为参数传递给*`configure`*的功能类似于在shell环境中通过命令行为*`configure`*进程设置变量（例如，*`YACC="$HOME/bin/bison
    -y" ./configure`*）。使用此示例中给出的语法的优点是，*`config.status --recheck`* 可以跟踪该值，并通过最初传递给它的选项正确地重新执行
    *`configure`*。因此，你应该始终使用参数语法，而不是shell环境语法，来为 *`configure`* 设置变量。有关强制使用此语法的方法，请参阅
    Autoconf 手册中 *`AC_ARG_VAR`* 的文档。'
- en: To check for the existence of a program not covered by these more specialized
    macros, you can use the generic `AC_CHECK_PROG` macro or write your own special-purpose
    macro (see [Chapter 16](ch16.xhtml)).
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 要检查某个程序是否存在，如果该程序未被这些更专用的宏覆盖，你可以使用通用的 `AC_CHECK_PROG` 宏，或编写你自己的特定用途宏（参见[第16章](ch16.xhtml)）。
- en: 'The key points to take away here are as follows:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 这里需要记住的关键点如下：
- en: '`AC_PROG_*` macros check for the existence of programs.'
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`AC_PROG_*` 宏用于检查程序是否存在。'
- en: If they find a program, a substitution variable is created.
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果找到程序，则会创建一个替代变量。
- en: You should use these substitution variables in your *Makefile.in* templates
    to execute associated utilities.
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你应该在 *Makefile.in* 模板中使用这些替代变量来执行相关的工具。
- en: A Common Problem with Autoconf
  id: totrans-65
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Autoconf 中的一个常见问题
- en: 'We should take this opportunity to address a particular problem developers
    new to the Autotools consistently encounter. Here’s the formal definition of `AC_CHECK_PROG`,
    as you will find it in the *GNU Autoconf Manual*:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应借此机会解决开发者在使用 Autotools 时常遇到的一个问题。以下是 *GNU Autoconf Manual* 中给出的 `AC_CHECK_PROG`
    的正式定义：
- en: '[PRE7]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Check whether program `prog-to-check-for` exists in *`path`*. If it is found,
    set *`variable`* to *`value-if-found`*, otherwise to *`value-if-not-found`*, if
    given. Always pass over *`reject`* (an absolute filename) even if it is the first
    found in the search path; in that case, set *`variable`* using the absolute filename
    of the *`prog-to-check-for`* found that is not *`reject`*. If *`variable`* was
    already set, do nothing. Calls *`AC_SUBST`* for *`variable`*. The result of this
    test can be overridden by setting the *`variable`* variable or the cache variable
    *`ac_cv_prog_variable`*.^([5](footnote.xhtml#ch05fn5))
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 检查程序`prog-to-check-for`是否存在于*`path`*中。如果找到，设置*`variable`*为*`value-if-found`*，否则设置为*`value-if-not-found`*，如果给定的话。即使*`reject`*（一个绝对路径文件名）在搜索路径中最先找到，也总是跳过它；在这种情况下，使用找到的不是*`reject`*的*`prog-to-check-for`*的绝对路径名来设置*`variable`*。如果*`variable`*已经设置，则不做任何操作。调用*`AC_SUBST`*为*`variable`*。此测试的结果可以通过设置*`variable`*变量或缓存变量*`ac_cv_prog_variable`*来覆盖。^([5](footnote.xhtml#ch05fn5))
- en: 'This is pretty dense language, but after a careful reading, you can extract
    the following from this description:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 这段话比较复杂，但仔细阅读后，你可以从中提取以下内容：
- en: If *`prog-to-check-for`* is found in the system search path, then *`variable`*
    is set to *`value-if-found`*; otherwise, it’s set to *`value-if-not-found`*.
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果在系统搜索路径中找到*`prog-to-check-for`*，则*`variable`*被设置为*`value-if-found`*；否则，设置为*`value-if-not-found`*。
- en: If *`reject`* is specified (as a full path), and it’s the same as the program
    found in the system search path in the previous step, then skip it and continue
    to the next matching program in the system search path.
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果指定了*`reject`*（作为完整路径），并且它与在前一步中在系统搜索路径中找到的程序相同，则跳过它并继续搜索系统搜索路径中的下一个匹配程序。
- en: If *`reject`* is found first in *`path`* and then another match (other than
    *`reject`*) is found, set *`variable`* to the absolute path name of the second
    (non-*`reject`*) match.
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果*`reject`*首先在*`path`*中找到，然后找到另一个匹配项（不同于*`reject`*），则将*`variable`*设置为第二个（非*`reject`*）匹配项的绝对路径名。
- en: If the user has already set *`variable`* in the environment, then *`variable`*
    is left untouched (thereby allowing the user to override the check by setting
    *`variable`* before running `configure`).
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果用户已经在环境中设置了*`variable`*，则*`variable`*保持不变（从而允许用户在运行`configure`之前通过设置*`variable`*来覆盖检查）。
- en: '`AC_SUBST` is called on *`variable`* to make it an Autoconf substitution variable.'
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调用`AC_SUBST`以使*`variable`*成为Autoconf替代变量。
- en: 'Upon first reading this description, there appears to be a conflict: we see
    in the first item that *`variable`* will be set to one of two specified values,
    based on whether or not *`prog-to-check-for`* is found in the system search path.
    But then we see in the third item that *`variable`* will be set to the full path
    of some program if *`reject`* is found first and skipped.'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 初读这段描述时，似乎存在冲突：在第一项中，我们看到如果在系统搜索路径中找到*`prog-to-check-for`*，*`variable`*将被设置为两个指定值之一。但随后我们在第三项中看到，如果首先找到并跳过*`reject`*，则*`variable`*将被设置为某个程序的完整路径。
- en: Discovering the real functionality of `AC_CHECK_PROG` is as easy as reading
    a little shell script. While you could refer to the definition of `AC_CHECK_PROG`
    in Autoconf’s *programs.m4* macro file, you’ll be one level removed from the actual
    shell code that performs the check. Wouldn’t it be better to just look at the
    shell script that `AC_CHECK_PROG` generates? We’ll use Jupiter’s *configure.ac*
    file to play with this concept. Temporarily modify your *configure.ac* file according
    to the changes highlighted in [Listing 5-4](ch05.xhtml#ch05ex4).
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 发现`AC_CHECK_PROG`的真实功能就像读一个小的shell脚本一样简单。虽然你可以参考Autoconf的*programs.m4*宏文件中对`AC_CHECK_PROG`的定义，但那时你会离执行检查的实际shell代码有一层隔离。直接查看`AC_CHECK_PROG`生成的shell脚本岂不是更好？我们将使用Jupiter的*configure.ac*文件来玩这个概念。暂时根据[列表
    5-4](ch05.xhtml#ch05ex4)中突出显示的更改修改你的*configure.ac*文件。
- en: '[PRE8]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '*Listing 5-4: A first attempt at using `AC_CHECK_PROG`*'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 5-4：首次尝试使用`AC_CHECK_PROG`*'
- en: Now execute `autoconf`, open the resulting `configure` script, and search for
    `_DEBUG_START_`.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 现在执行`autoconf`，打开生成的`configure`脚本，并搜索`_DEBUG_START_`。
- en: '**NOTE**'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*The *`_DEBUG_START_`* and *`_DEBUG_END_`* strings are known as picket fences.
    I added these to* configure.ac *for the sole purpose of helping me find the beginning
    and end of the shell code generated by the *`AC_CHECK_PROG`* macro. I chose these
    names in particular because you’re not likely to find them anywhere else in the
    generated *`configure`* script.^([6](footnote.xhtml#ch05fn6))*'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '*`_DEBUG_START_`* 和 *`_DEBUG_END_`* 字符串被称为栅栏。我将它们添加到 *configure.ac* 中，唯一目的是帮助我找到由
    *`AC_CHECK_PROG`* 宏生成的 shell 代码的开始和结束位置。我特意选择这些名称，因为在生成的 *`configure`* 脚本中，你不太可能找到它们。^([6](footnote.xhtml#ch05fn6))'
- en: '[Listing 5-5](ch05.xhtml#ch05ex5) shows the portion of `configure` this macro
    generates.'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 5-5](ch05.xhtml#ch05ex5) 显示了该宏生成的 `configure` 代码部分。'
- en: '[PRE9]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '*Listing 5-5: A portion of `configure` generated by `AC_CHECK_PROG`*'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 5-5：由 `AC_CHECK_PROG` 生成的 `configure` 代码部分*'
- en: The opening comment at ➊ in this shell script is a clue that `AC_CHECK_PROG`
    has some undocumented functionality. Apparently, you may pass in arguments along
    with the program name in the *`prog-to-check-for`* parameter. Shortly, we’ll look
    at a situation in which you might want to do that.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在此 shell 脚本的 ➊ 位置，开头的注释提示 `AC_CHECK_PROG` 具有一些未记录的功能。显然，你可以在 *`prog-to-check-for`*
    参数中传递参数和程序名称。稍后，我们将查看一种可能需要这样做的情况。
- en: 'Farther down in the script at ➋, you can see that the *`reject`* parameter
    was added into the mix in order to allow `configure` to search for a particular
    version of a tool. From the code at ➌, we can see that our `bash_var` variable
    can have three different values: either empty if the requested program is not
    found in the search path, the program specified if it’s found, or the full path
    of the program specified if *`reject`* is found first.'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在脚本的 ➋ 位置，你可以看到 *`reject`* 参数被添加进来，以便让 `configure` 搜索特定版本的工具。从 ➌ 位置的代码中，我们可以看到我们的
    `bash_var` 变量可能有三种不同的值：如果请求的程序在搜索路径中未找到，则为空；如果找到了指定的程序，则为该程序；如果 *`reject`* 首先被找到，则为指定程序的完整路径。
- en: Where do you use *`reject`*? Well, for instance, on Solaris systems with proprietary
    Sun tools installed, the default C compiler is often the Solaris C compiler. But
    some software may require the use of the GNU C compiler instead. As maintainers,
    we don’t know which compiler will be found first in a user’s search path. `AC_CHECK_PROG`
    allows us to ensure that `gcc` is used with a full path if another C compiler
    is found first in the search path.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '*`reject`* 是在哪里使用的呢？例如，在安装了专有 Sun 工具的 Solaris 系统上，默认的 C 编译器通常是 Solaris C 编译器。但是某些软件可能需要使用
    GNU C 编译器。作为维护者，我们不知道哪个编译器会在用户的搜索路径中首先找到。`AC_CHECK_PROG` 允许我们确保如果搜索路径中首先找到其他 C
    编译器，`gcc` 会被使用，并且会提供完整的路径。'
- en: As I mentioned earlier, M4 macros are aware of the fact that arguments are given,
    empty, or missing, and they do different things based on these conditions. Many
    of the standard Autoconf macros are written to take full advantage of empty or
    unspecified optional arguments and generate entirely different shell code in each
    of these conditions. Autoconf macros may also optimize the generated shell code
    for these different conditions.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我之前提到的，M4 宏会意识到传递的参数是给定的、为空的，还是缺失的，并根据这些条件执行不同的操作。许多标准的 Autoconf 宏被编写成充分利用空的或未指定的可选参数，并在每种条件下生成完全不同的
    shell 代码。Autoconf 宏还可以根据这些不同的条件优化生成的 shell 代码。
- en: 'Given what we now know, we probably should have called `AC_CHECK_PROG` in this
    manner instead:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 根据我们现在知道的内容，我们可能应该改为这样调用 `AC_CHECK_PROG`：
- en: '[PRE10]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: You can see in this example that the manual is technically accurate. If *`reject`*
    isn’t specified and `bash` is found in the system path, then `bash_shell` will
    be set to `bash -x`. If `bash` is *not* found in the system path, then `bash_shell`
    will be set to the empty string. If, on the other hand, *`reject`* *is* specified
    and the undesired version of `bash` is found *first* in the path, then `bash_shell`
    will be set to the full path of the *next* version found in the path, along with
    the originally specified argument (`-x`). The reason the macro uses the full path
    in this case is to make sure that `configure` will avoid executing the version
    that was found first in the path—*`reject`*. The rest of the configuration script
    can now use the `bash_shell` variable to run the desired Bash shell, as long as
    it doesn’t test out empty.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以从这个例子中看到手册在技术上是准确的。如果没有指定*`reject`*，并且系统路径中找到了`bash`，那么`bash_shell`将被设置为`bash
    -x`。如果系统路径中*没有*找到`bash`，那么`bash_shell`将被设置为空字符串。另一方面，如果*`reject`* *被*指定，并且在路径中首先找到不想要的`bash`版本，那么`bash_shell`将被设置为路径中找到的*下一个*版本的完整路径，并带上最初指定的参数（`-x`）。宏之所以在这种情况下使用完整路径，是为了确保`configure`避免执行路径中首先找到的版本——*`reject`*。接下来的配置脚本可以使用`bash_shell`变量来运行所需的Bash
    shell，只要它不为空。
- en: '**NOTE**'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*If you’re following along in your own code, don’t forget to remove the temporary
    code from [Listing 5-4](ch05.xhtml#ch05ex4) from your* configure.ac *file*.'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '*如果你在自己的代码中跟着一起操作，别忘了从你的* configure.ac *文件中移除[清单 5-4](ch05.xhtml#ch05ex4)中的临时代码*。'
- en: Checks for Libraries and Header Files
  id: totrans-94
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 库和头文件检查
- en: The decision of whether or not to use an external library in a project is a
    tough one. On one hand, you want to reuse existing code to provide required functionality
    instead of writing it yourself. Reuse is one of the hallmarks of the open source
    software world. On the other hand, you don’t want to depend on functionality that
    may not exist on all target platforms or that may require significant porting
    in order to make the libraries you need available where you need them.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 是否在项目中使用外部库是一个艰难的决定。一方面，你希望重用现有代码来提供所需的功能，而不是自己编写。重用是开源软件世界的一个标志。另一方面，你不想依赖那些在所有目标平台上可能不存在，或者可能需要进行大量移植才能使你需要的库在所需位置可用的功能。
- en: Occasionally, library-based functionality can differ in minor ways between platforms.
    Although the functionality may be essentially equivalent, the libraries may have
    different package names or different API signatures. The POSIX threads (*pthread*)
    library, for example, is similar in functionality to many native threading libraries,
    but the libraries’ APIs are usually different in minor ways, and their package
    and library names are almost always different. Consider what would happen if we
    tried to build a multithreaded project on a system that didn’t support *pthread*;
    in a case like this, you might want to use the *libthreads* library on Solaris
    instead.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 偶尔，基于库的功能在不同平台之间可能会有所不同。尽管这些功能在本质上是等效的，但库的包名或API签名可能会有所不同。例如，POSIX线程库（*pthread*）在功能上类似于许多本地线程库，但这些库的API通常会有一些微小的差异，而且它们的包名和库名几乎总是不同。假设我们尝试在一个不支持*pthread*的系统上构建一个多线程项目，考虑一下会发生什么；在这种情况下，你可能想在Solaris上使用*libthreads*库。
- en: Autoconf library selection macros allow generated configuration scripts to intelligently
    select the libraries that provide the necessary functionality, even if those libraries
    are named differently between platforms. To illustrate the use of the Autoconf
    library selection macros, we’ll add some trivial (and fairly contrived) multithreading
    capabilities to the Jupiter project that will allow `jupiter` to print its message
    using a background thread. We’ll use the *pthread* API as our base threading model.
    In order to accomplish this with our Autoconf-based configuration script, we need
    to add the *pthread* library to our project build system.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: Autoconf库选择宏允许生成的配置脚本智能地选择提供必要功能的库，即使这些库在不同平台之间的名称不同。为了说明Autoconf库选择宏的使用，我们将为Jupiter项目添加一些微不足道（而且相当牵强的）多线程功能，使得`jupiter`能够使用后台线程打印其信息。我们将使用*pthread*
    API作为我们的基础线程模型。为了通过基于Autoconf的配置脚本实现这一点，我们需要将*pthread*库添加到我们的项目构建系统中。
- en: '**NOTE**'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*The proper use of multithreading requires the definition of additional substitution
    variables containing appropriate flags, libraries, and definitions. The *`AX_PTHREAD`*
    macro does all of this for you. You can find the documentation for *`AX_PTHREAD`*
    at the Autoconf Macro Archive website.^([7](footnote.xhtml#ch05fn7)) See “Doing
    Threads the Right Way” on [page 384](ch14.xhtml#page_384) for examples of using
    *`AX_PTHREAD`*.*'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '*正确使用多线程需要定义额外的替代变量，这些变量包含适当的标志、库和定义。*`AX_PTHREAD`* 宏会为你完成所有这些工作。你可以在 Autoconf
    宏库网站上找到 *`AX_PTHREAD`* 的文档。^([7](footnote.xhtml#ch05fn7)) 请参阅 [第384页](ch14.xhtml#page_384)中的“正确使用线程”章节，了解如何使用
    *`AX_PTHREAD`* 的示例。*'
- en: First, let’s tackle the changes to the source code. We’ll modify *main.c* so
    that the message is printed by a secondary thread, as shown in [Listing 5-6](ch05.xhtml#ch05ex6).
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们解决源代码的更改。我们将修改 *main.c*，使消息由一个辅助线程打印，正如在 [列表 5-6](ch05.xhtml#ch05ex6)
    中所示。
- en: Git tag 5.2
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: Git 标签 5.2
- en: '[PRE11]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '*Listing 5-6:* src/main.c: *Adding multithreading to the Jupiter project source
    code*'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 5-6:* src/main.c: *向 Jupiter 项目源代码中添加多线程*'
- en: This is clearly a ridiculous use of a thread; nevertheless, it *is* the prototypical
    form of thread usage. Consider a hypothetical situation in which the background
    thread performs some long calculation and `main` is doing other things while `print_it`
    is working. On a multiprocessor machine, using a thread in this manner could literally
    double a program’s throughput.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 这显然是一个荒谬的线程使用方式；然而，它 *确实* 是线程使用的典型形式。考虑一个假设的情况，其中后台线程执行一些长时间的计算，而 `main` 正在做其他事情，同时
    `print_it` 也在工作。在多处理器机器上，以这种方式使用线程可以将程序的吞吐量翻倍。
- en: Now all we need is a way to determine which libraries should be added to the
    compiler (linker) command line. If we weren’t using Autoconf, we’d just add the
    library to our linker command line in the makefile, as shown in [Listing 5-7](ch05.xhtml#ch05ex7).
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们只需要一种方法来确定应该将哪些库添加到编译器（链接器）命令行中。如果我们不使用 Autoconf，我们只需将库添加到 makefile 中的链接器命令行中，正如在
    [列表 5-7](ch05.xhtml#ch05ex7) 中所示。
- en: '[PRE12]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '*Listing 5-7: Manually adding the* pthread *library to the compiler command
    line*'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 5-7：手动将 pthread 库添加到编译命令行中*'
- en: 'Instead, we’ll use the Autoconf-provided `AC_SEARCH_LIBS` macro, an enhanced
    version of the basic `AC_CHECK_LIB` macro. The `AC_SEARCH_LIBS` macro allows us
    to test for required functionality within a list of libraries. If the functionality
    exists in one of the specified libraries, an appropriate command line option is
    added to the `@LIBS@` substitution variable, which we would then use in a *Makefile.in*
    template on the compiler (linker) command line. Here is the formal definition
    of `AC_SEARCH_LIBS` from the *GNU Autoconf Manual*:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，我们将使用 Autoconf 提供的 `AC_SEARCH_LIBS` 宏，这是基础的 `AC_CHECK_LIB` 宏的增强版。`AC_SEARCH_LIBS`
    宏允许我们在一个库列表中测试所需的功能。如果某个指定的库中存在所需功能，合适的命令行选项会被添加到 `@LIBS@` 替代变量中，然后我们会在 *Makefile.in*
    模板中使用该变量，将其添加到编译器（链接器）命令行中。以下是来自 *GNU Autoconf 手册* 的 `AC_SEARCH_LIBS` 宏的正式定义：
- en: '[PRE13]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Search for a library defining *`function`* if it’s not already available. This
    equates to calling `AC_LINK_IFELSE([AC_LANG_CALL([],` `[`*`function`*`])])` first
    with no libraries, then for each library listed in *`search-libs`*.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 如果库中还没有定义 *`function`*，则搜索一个定义该函数的库。这相当于首先调用 `AC_LINK_IFELSE([AC_LANG_CALL([],`
    `[`*`function`*`])])`，并且不使用任何库，然后对每个在 *`search-libs`* 中列出的库进行操作。
- en: Add `-l`*`library`* to `LIBS` for the first library found to contain *`function`*,
    and run *`action-if-found`*. If *`function`* is not found, run *`action-if-not-found`*.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 将 `-l`*`library`* 添加到 `LIBS` 中，以便为找到的第一个包含 *`function`* 的库添加链接，并运行 *`action-if-found`*。如果未找到
    *`function`*，则运行 *`action-if-not-found`*。
- en: 'If linking with *`library`* results in unresolved symbols that would be resolved
    by linking with additional libraries, give those libraries as the *`other-libraries`*
    argument, separated by spaces: for example, `-lXt -lX11`. Otherwise, this macro
    fails to detect that *`function`* is present, because linking the test program
    always fails with unresolved symbols.'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 如果与 *`library`* 链接时出现未解析的符号，而这些符号通过与额外库的链接可以解析，则将这些库作为 *`other-libraries`* 参数传递，多个库之间用空格分隔：例如
    `-lXt -lX11`。否则，这个宏将无法检测到 *`function`* 是否存在，因为测试程序始终由于未解析的符号而无法链接。
- en: The result of this test is cached in the `ac_cv_search` *`function`* variable
    as `none required` if *`function`* is already available, as `no` if no library
    containing *`function`* was found, otherwise as the `-l`*`library`* option that
    needs to be prepended to `LIBS`.^([8](footnote.xhtml#ch05fn8))
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 这个测试的结果被缓存到`ac_cv_search` *`function`*变量中，如果*`function`*已经可用，则为`none required`，如果未找到包含*`function`*的库，则为`no`，否则为需要添加到`LIBS`前缀的`-l`*`library`*选项。^([8](footnote.xhtml#ch05fn8))
- en: Can you see why the generated configuration script is so large? When you pass
    a particular function in a call to `AC_SEARCH_LIBS`, linker command line arguments
    are added to a substitution variable called `@LIBS@`. These arguments ensure that
    you will link with a library that contains the function passed in. If multiple
    libraries are listed in the second parameter, separated by whitespace, `configure`
    will determine which of these libraries are available on your user’s system and
    use the most appropriate one.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 你能看出为什么生成的配置脚本如此庞大吗？当你在调用`AC_SEARCH_LIBS`时传递一个特定的函数，链接器命令行参数会被添加到一个名为`@LIBS@`的替代变量中。这些参数确保你将链接到包含传递函数的库。如果第二个参数中列出了多个库，并且由空格分隔，`configure`将确定这些库中哪些在用户的系统上可用，并使用最合适的一个。
- en: '[Listing 5-8](ch05.xhtml#ch05ex8) shows how to use `AC_SEARCH_LIBS` in Jupiter’s
    *configure.ac* file to find the library that contains the `pthread_create` function.
    `AC_SEARCH_LIBS` won’t add anything to the `@LIBS@` variable if it doesn’t find
    `pthread_create` in the *pthread* library.'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 5-8](ch05.xhtml#ch05ex8)展示了如何在Jupiter的*configure.ac*文件中使用`AC_SEARCH_LIBS`来查找包含`pthread_create`函数的库。如果`AC_SEARCH_LIBS`没有在*pthread*库中找到`pthread_create`，它将不会向`@LIBS@`变量添加任何内容。'
- en: '[PRE14]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '*Listing 5-8:* configure.ac: *Using `AC_SEARCH_LIBS` to check for the* pthread
    *library on the system*'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '*示例 5-8:* configure.ac: *使用`AC_SEARCH_LIBS`检查系统上的*pthread*库*'
- en: As we’ll discuss in detail in [Chapter 7](ch07.xhtml), naming patterns for libraries
    differ among systems. For example, some systems name libraries *lib*basename*.so*,
    while others use *lib*basename*.sa* or *lib*basename*.a*. Cigwin-based systems
    generate libraries named *cig*basename*.dll*. `AC_SEARCH_LIBS` addresses this
    situation (quite elegantly) by using the compiler to calculate the actual name
    of the library from its *basename*; it does this by attempting to link a small
    test program with the requested function from the test library. Only `-l`*`basename`*
    is passed on the compiler command line—a near-universal convention among Unix
    compilers.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在[第7章](ch07.xhtml)中将详细讨论的那样，不同系统的库命名规则各不相同。例如，一些系统将库命名为*lib*basename*.so*，而其他系统使用*lib*basename*.sa*或*lib*basename*.a*。基于Cygwin的系统生成命名为*cig*basename*.dll*的库。`AC_SEARCH_LIBS`通过使用编译器计算库的实际名称来优雅地解决了这个问题；它通过尝试将一个小的测试程序与测试库中的请求函数链接来实现这一点。编译器命令行上只传递`-l`*`basename`*，这是Unix编译器之间的一个几乎通用的约定。
- en: We’ll have to modify *src/Makefile.in* again in order to properly use the now-populated
    `@LIBS@` variable, as shown in [Listing 5-9](ch05.xhtml#ch05ex9).
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将不得不再次修改*src/Makefile.in*，以便正确使用现在已填充的`@LIBS@`变量，正如[示例 5-9](ch05.xhtml#ch05ex9)所示。
- en: '[PRE15]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '*Listing 5-9:* src/Makefile.in: *Using the `@LIBS@` substitution variable*'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '*示例 5-9:* src/Makefile.in: *使用`@LIBS@`替代变量*'
- en: '**NOTE**'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*I added *`$(LIBS)`* after the source files on the compiler command line because
    the linker cares about object file order—it searches files for required functions
    in the order they are specified on the command line.*'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '*我在编译器命令行上的源文件之后添加了*`$(LIBS)`*，因为链接器关心目标文件的顺序——它会按命令行上指定的顺序搜索文件中的必需函数。*'
- en: I want *main.c* to be the primary source of object code for `jupiter`, so I’ll
    continue to add additional objects, including libraries, to the command line after
    this file.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 我希望*main.c*成为`jupiter`的主要目标代码来源，所以我会继续将其他目标文件，包括库，添加到这个文件之后的命令行中。
- en: '*Is It Right or Just Good Enough?*'
  id: totrans-125
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*这对吗，还是只是够好？*'
- en: At this point, we’ve ensured that our build system will properly use *pthread*
    on most systems.^([9](footnote.xhtml#ch05fn9)) If our system needs a particular
    library, that library’s name will be added to the `@LIBS@` variable and then subsequently
    used on the compiler command line. But we’re not done yet.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经确保我们的构建系统能在大多数系统上正确使用*pthread*。^([9](footnote.xhtml#ch05fn9)) 如果我们的系统需要特定的库，该库的名称将被添加到`@LIBS@`变量中，然后在编译器命令行上使用。但我们还没有完成。
- en: 'This system *usually* works fine, but it still fails in corner cases. Because
    we want to provide an excellent user experience, we’ll take Jupiter’s build system
    to the next level. In doing this, we need to make a design decision: in case `configure`
    fails to locate a *pthread* library on a user’s system, should we fail the build
    process or build a `jupiter` program without multithreading?'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 这个系统*通常*工作得很好，但在某些极端情况下可能会失败。因为我们希望提供卓越的用户体验，所以我们将把Jupiter的构建系统提升到一个新的水平。在此过程中，我们需要做出一个设计决策：如果`configure`未能在用户的系统上找到*pthread*库，我们是应该让构建过程失败，还是构建一个没有多线程的`jupiter`程序？
- en: If we choose to fail the build, the user will notice, because the build will
    stop with an error message (though it may not be a very friendly one—either the
    compile or link process will fail with a cryptic error message about a missing
    header file or an undefined symbol). On the other hand, if we choose to build
    a single-threaded version of `jupiter`, we’ll need to display some clear message
    that the program is being built without multithreading functionality and explain
    why.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们选择让构建失败，用户会注意到，因为构建会因错误信息而停止（尽管这个错误信息可能并不是很友好——编译或链接过程会因缺失头文件或未定义符号而出现难以理解的错误信息）。另一方面，如果我们选择构建一个单线程版本的`jupiter`，我们需要显示一些清晰的消息，说明程序正在构建时没有多线程功能，并解释原因。
- en: One potential problem is that some users’ systems may have a *pthread* shared
    library installed but not the *pthread.h* header file—most likely because the
    *pthread* executable (shared-library) package was installed but the developer
    package wasn’t. Shared libraries are often packaged independently of static libraries
    and header files, and while executables are installed as part of a dependency
    chain for higher-level applications, developer packages are typically installed
    directly by a user.^([10](footnote.xhtml#ch05fn10)) For this reason, Autoconf
    provides macros to test for the existence of both libraries and header files.
    We can use the `AC_CHECK_HEADERS` macro to ensure the existence of a particular
    header file.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 一个潜在的问题是，有些用户的系统可能安装了*pthread*共享库，但没有安装*pthread.h*头文件——很可能是因为安装了*pthread*可执行文件（共享库）包，但没有安装开发者包。共享库通常与静态库和头文件分开打包，虽然可执行文件作为更高层次应用程序的依赖链的一部分安装，但开发者包通常由用户直接安装。^([10](footnote.xhtml#ch05fn10))
    因此，Autoconf提供了宏来测试库和头文件的存在。我们可以使用`AC_CHECK_HEADERS`宏来确保特定头文件的存在。
- en: Autoconf checks are very thorough. They usually ensure not only that a file
    exists but also that the file is the correct one, because they allow you to specify
    assertions about the file that the macro then verifies. The `AC_CHECK_HEADERS`
    macro doesn’t just scan the filesystem for the requested header. Like `AC_SEARCH_LIBS`,
    the `AC_CHECK_HEADERS` macro builds a short test program in the appropriate language
    and then compiles it to ensure that the compiler can both find and use the file.
    In essence, Autoconf macros try to test not just for the existence of specific
    features but for the functionality required from those features.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: Autoconf的检查非常彻底。它们通常不仅确保文件存在，而且确保文件是正确的，因为它们允许你指定关于文件的断言，然后宏会验证这些断言。`AC_CHECK_HEADERS`宏不仅仅是扫描文件系统寻找请求的头文件。像`AC_SEARCH_LIBS`一样，`AC_CHECK_HEADERS`宏会构建一个短小的测试程序，并将其编译，以确保编译器既能找到该文件，又能使用它。本质上，Autoconf宏不仅仅是测试特定功能是否存在，而是测试这些功能所需的功能性。
- en: 'The `AC_CHECK_HEADERS` macro is defined in the *GNU Autoconf Manual* as follows:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: '`AC_CHECK_HEADERS`宏在*GNU Autoconf Manual*中的定义如下：'
- en: '[PRE16]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: For each given system header file *`header-file`* in the blank-separated argument
    list that exists, define `HAVE_`*`header-file`* (in all capitals). If *`action-if-found`*
    is given, it is additional shell code to execute when one of the header files
    is found. You can give it a value of `break` to break out of the loop on the first
    match. If *`action-if-not-found`* is given, it is executed when one of the header
    files is not found.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 对于空格分隔的每个给定系统头文件*`header-file`*，如果它存在，则定义`HAVE_`*`header-file`*（全大写）。如果给定了*`action-if-found`*，它是找到某个头文件时执行的额外Shell代码。你可以给它一个`break`的值，在第一次匹配时跳出循环。如果给定了*`action-if-not-found`*，则在没有找到某个头文件时执行该代码。
- en: '*`includes`* is interpreted as in `AC_CHECK_HEADER`, in order to choose the
    set of preprocessor directives supplied before the header under test.^([11](footnote.xhtml#ch05fn11))'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '*`includes`*的解释方式与`AC_CHECK_HEADER`相同，用于选择在测试头文件之前提供的一组预处理指令。^([11](footnote.xhtml#ch05fn11))'
- en: Normally, `AC_CHECK_HEADERS` is called only with a list of desired header files
    in the first argument. The remaining arguments are optional and are not often
    used because the macro works pretty well without them.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，`AC_CHECK_HEADERS` 只会在第一个参数中调用一个所需头文件的列表。其余参数是可选的，且不常使用，因为该宏在没有这些参数时通常已经能很好地工作。
- en: We’ll add a check for the *pthread.h* header file to *configure.ac* using `AC_CHECK_HEADERS`.
    As you may have noticed, *configure.ac* already calls `AC_CHECK_HEADERS` looking
    for *stdlib.h*. `AC_CHECK_HEADERS` accepts a list of filenames, so we’ll just
    add *pthread.h* to the list, using a space to separate the filenames, as shown
    in [Listing 5-10](ch05.xhtml#ch05ex10).
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用 `AC_CHECK_HEADERS` 在 *configure.ac* 中检查 *pthread.h* 头文件。如你所见，*configure.ac*
    已经调用了 `AC_CHECK_HEADERS` 来查找 *stdlib.h*。`AC_CHECK_HEADERS` 接受一个文件名列表，所以我们只需将 *pthread.h*
    添加到该列表中，文件名之间用空格分隔，如[示例 5-10](ch05.xhtml#ch05ex10)所示。
- en: Git tag 5.3
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: Git 标签 5.3
- en: '[PRE17]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '*Listing 5-10:* configure.ac: *Adding* pthread.h *to the `AC_CHECK_HEADERS`
    macro*'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '*示例 5-10:* configure.ac: *将* pthread.h *添加到 `AC_CHECK_HEADERS` 宏中*'
- en: In order to make this package available to as many people as possible, we’ll
    use the dual-mode build approach, which will allow us to provide at least *some*
    form of the `jupiter` program to users without a *pthread* library. In order to
    accomplish this, we need to add some conditional preprocessor statements to *src/main.c*,
    as shown in [Listing 5-11](ch05.xhtml#ch05ex11).
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让尽可能多的人使用这个包，我们将使用双模式构建方法，这将允许我们在没有 *pthread* 库的情况下，至少提供 `jupiter` 程序的某种形式给用户。为了实现这一点，我们需要在
    *src/main.c* 中添加一些条件预处理器语句，如[示例 5-11](ch05.xhtml#ch05ex11)所示。
- en: '[PRE18]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '*Listing 5-11:* src/main.c: *Adding conditional code, based on the existence
    of* pthread.h'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '*示例 5-11:* src/main.c: *根据 pthread.h 的存在添加条件代码*'
- en: In this version of *main.c*, we’ve added a conditional check for the header
    file. If the shell script generated by `AC_CHECK_HEADERS` locates the *pthread.h*
    header file, the `HAVE_PTHREAD_H` macro will be defined with the value `1` in
    the user’s *config.h* file. If the shell script doesn’t find the header file,
    the original `#undef` statement will be left commented out in *config.h*. Because
    we rely on these definitions, we also need to include *config.h* at the top of
    *main.c*.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个版本的 *main.c* 中，我们添加了对头文件的条件检查。如果 `AC_CHECK_HEADERS` 生成的 shell 脚本找到了 *pthread.h*
    头文件，`HAVE_PTHREAD_H` 宏将在用户的 *config.h* 文件中定义为值 `1`。如果 shell 脚本没有找到该头文件，原始的 `#undef`
    语句将保留在 *config.h* 中被注释掉。因为我们依赖于这些定义，我们还需要在 *main.c* 的顶部包含 *config.h*。
- en: If you choose not to use the `AC_CONFIG_HEADERS` macro in *configure.ac*, then
    `@DEFS@` will contain all the definitions generated by all the macros that call
    `AC_DEFINE`. In this example, we’ve used `AC_CONFIG_HEADERS`, so *config.h.in*
    will contain most of these definitions, and `@DEFS@` will only contain `HAVE_CONFIG_H`,
    which we don’t actually use.^([12](footnote.xhtml#ch05fn12)) The *config.h.in*
    template method significantly shortens the compiler command line (and also makes
    it simple to take a snapshot of the template and modify it by hand for non-Autotools
    platforms). [Listing 5-12](ch05.xhtml#ch05ex12) shows the required changes to
    the *src/Makefile.in* template.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你选择不在 *configure.ac* 中使用 `AC_CONFIG_HEADERS` 宏，那么 `@DEFS@` 将包含所有通过调用 `AC_DEFINE`
    宏生成的定义。在这个例子中，我们使用了 `AC_CONFIG_HEADERS`，因此 *config.h.in* 将包含大部分这些定义，而 `@DEFS@`
    只会包含 `HAVE_CONFIG_H`，而我们实际上并未使用它。^([12](footnote.xhtml#ch05fn12)) *config.h.in*
    模板方法显著缩短了编译器命令行（并且也使得在非 Autotools 平台上手动修改模板并拍摄快照变得简单）。[示例 5-12](ch05.xhtml#ch05ex12)
    显示了对 *src/Makefile.in* 模板的必要更改。
- en: '[PRE19]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '*Listing 5-12:* src/Makefile.in: *Adding the use of `@DEFS@` to the src-level
    makefile*'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '*示例 5-12:* src/Makefile.in: *在 src 级别的 Makefile 中添加 `@DEFS@` 的使用*'
- en: '**NOTE**'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*I’ve added *`$(DEFS)`* before *`$(CPPFLAGS)`*, giving the end user the option
    to override any of my policy decisions on the command line*.'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '*我在 *`$(DEFS)`* 前添加了 *`$(CPPFLAGS)`*，给最终用户提供了在命令行中覆盖我的任何政策决策的选项*。'
- en: We now have everything we need to conditionally build the `jupiter` program.
    If the user’s system has *pthread* functionality installed, the user will automatically
    build a version of `jupiter` that uses multiple threads of execution; otherwise,
    they’ll have to settle for serialized execution. The only thing left to do is
    to add some code to *configure.ac* such that if `configure` can’t find the *pthread*
    library, it will display a message indicating that it will build a program that
    uses serialized execution.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在拥有了所有需要的条件来构建 `jupiter` 程序。如果用户的系统已安装 *pthread* 功能，用户将自动构建一个使用多线程执行的 `jupiter`
    版本；否则，他们只能选择串行执行。剩下的工作就是向 *configure.ac* 中添加一些代码，以便如果 `configure` 找不到 *pthread*
    库，它将显示一条消息，指示将构建一个使用串行执行的程序。
- en: Now, consider the unlikely scenario of a user who has the header file installed
    but doesn’t have the library. For example, if the user executes `./configure`
    with `CPPFLAGS=-I/usr/local/include` but neglects to add `LDFLAGS=-L/usr/local/lib`,
    it will seem to `configure` that the header is available but the library is missing.
    This condition is easily remedied by simply skipping the header file check entirely
    if `configure` can’t find the library. [Listing 5-13](ch05.xhtml#ch05ex13) shows
    the required changes to *configure.ac*.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，考虑一个不太可能的情况：用户已安装头文件，但没有安装库。例如，如果用户执行 `./configure` 时使用了 `CPPFLAGS=-I/usr/local/include`，但忽略了添加
    `LDFLAGS=-L/usr/local/lib`，`configure` 会认为头文件可用，但库缺失。只需简单地跳过头文件检查（如果 `configure`
    找不到库），就能轻松解决此问题。[清单 5-13](ch05.xhtml#ch05ex13) 显示了对 *configure.ac* 所做的必要更改。
- en: Git tag 5.4
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: Git 标签 5.4
- en: '[PRE20]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '*Listing 5-13:* configure.ac: *Adding code to indicate that multithreading
    is not available during configuration*'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 5-13:* configure.ac: *添加代码以指示在配置过程中多线程不可用*'
- en: 'Now, when we run `./bootstrap.sh` and `./configure`, we’ll see some additional
    output (highlighted here):'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当我们运行 `./bootstrap.sh` 和 `./configure` 时，我们将看到一些额外的输出（在此处突出显示）：
- en: '[PRE21]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'If a user’s system is missing the *pthread.h* header file, for instance, they’d
    see different output. To emulate this for testing purposes, we can use a trick
    involving Autoconf cache variables. By presetting the cache variable that represents
    the presence of the *pthread.h* header to `no`, we can trick `configure` into
    not even looking for *pthread.h* because it assumes the search has already been
    done if the cache variable is already set. Let’s try it out:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果用户的系统缺少 *pthread.h* 头文件，他们将看到不同的输出。为了测试此情况，我们可以使用一个涉及 Autoconf 缓存变量的技巧。通过预设表示
    *pthread.h* 头文件存在的缓存变量为 `no`，我们可以欺骗 `configure` 使其根本不去查找 *pthread.h*，因为如果缓存变量已经设置，它会认为搜索已经完成。让我们尝试一下：
- en: '[PRE22]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Had we chosen to fail the build if the *pthread.h* header file or the *pthread*
    libraries were not found, then the source code would have been simpler; there
    would have been no need for conditional compilation. In that case, we could change
    *configure.ac* to look like [Listing 5-14](ch05.xhtml#ch05ex14).
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们选择在找不到 *pthread.h* 头文件或 *pthread* 库时使构建失败，那么源代码将会更简单；无需进行条件编译。在这种情况下，我们可以将
    *configure.ac* 更改为如下 [清单 5-14](ch05.xhtml#ch05ex14) 所示。
- en: '[PRE23]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '*Listing 5-14: Failing the build if no* pthread *library is found*'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 5-14: 如果未找到 *pthread* 库，则使构建失败*'
- en: '**NOTE**'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*Autoconf macros generate shell code that checks for the existence of system
    features and sets variables based on these tests. However, it’s up to you as maintainer
    to add shell code to* configure.ac *that makes functional decisions based on the
    contents of the resulting variables*.'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: '*Autoconf 宏生成的 Shell 代码用于检查系统功能的存在，并根据这些测试设置变量。然而，作为维护者，你需要向 configure.ac 中添加
    Shell 代码，以便根据结果变量的内容做出功能决策。*'
- en: '*Printing Messages*'
  id: totrans-163
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*打印消息*'
- en: 'In the preceding examples, we used a few Autoconf macros to display messages
    to the user during configuration: `AC_MSG_WARN` and `AC_MSG_ERROR`. Here are the
    prototypes for the various `AC_MSG_*` macros provided by Autoconf:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，我们使用了几个 Autoconf 宏来在配置过程中显示消息：`AC_MSG_WARN` 和 `AC_MSG_ERROR`。以下是 Autoconf
    提供的各种 `AC_MSG_*` 宏的原型：
- en: '[PRE24]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The `AC_MSG_CHECKING` and `AC_MSG_RESULT` macros are designed to be used together.
    The `AC_MSG_CHECKING` macro prints a line indicating that it’s checking for a
    particular feature, but it doesn’t print a carriage return at the end of this
    line. Once the feature has been found (or not found) on the user’s machine, the
    `AC_MSG_RESULT` macro prints the result at the end of the line, followed by a
    carriage return that completes the line started by `AC_MSG_CHECKING`. The *`result-description`*
    text should make sense in the context of the *`feature-description`* message.
    For instance, the message `Looking for a C compiler...` might be terminated either
    with the name of the compiler found or with the text `not found`.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: '`AC_MSG_CHECKING` 和 `AC_MSG_RESULT` 宏是配合使用的。`AC_MSG_CHECKING` 宏会打印一行，指示正在检查某个特性，但不会在该行的末尾打印换行符。当该特性在用户的机器上找到（或未找到）后，`AC_MSG_RESULT`
    宏会打印结果，并在行的末尾添加换行符，完成由 `AC_MSG_CHECKING` 开始的行。*`result-description`* 文本应在 *`feature-description`*
    消息的上下文中有意义。例如，消息 `Looking for a C compiler...` 可能以找到的编译器名称结束，或者以 `not found` 结束。'
- en: '**NOTE**'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*You as the* configure.ac *author should strive to not allow additional text
    to be displayed between these two macro invocations, as it becomes difficult for
    the user to follow if there is unrelated text between the two sets of output*.'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: '*作为 configure.ac 的作者，您应尽力避免这两个宏调用之间出现额外的文本，因为如果这两组输出之间有不相关的文本，用户会很难跟踪*。'
- en: 'The `AC_MSG_NOTICE` and `AC_MSG_WARN` macros simply print a string to the screen.
    The leading text for `AC_MSG_WARN` is `configure: WARNING:`, whereas that of `AC_MSG_NOTICE`
    is simply `configure:`.'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: '`AC_MSG_NOTICE` 和 `AC_MSG_WARN` 宏仅将字符串打印到屏幕上。`AC_MSG_WARN` 的前缀文本是 `configure:
    WARNING:`，而 `AC_MSG_NOTICE` 的前缀文本仅为 `configure:`。'
- en: 'The `AC_MSG_ERROR` and `AC_MSG_FAILURE` macros generate an error message, stop
    the configuration process, and return an error code to the shell. The leading
    text for `AC_MSG_ERROR` is `configure: error:`. The `AC_MSG_FAILURE` macro prints
    a notice indicating the directory in which the error occurred, the user-specified
    message, and then the text `See ''config.log'' for more details`. The optional
    second parameter (*`exit-status`*) in these macros allows the maintainer to specify
    a particular status code to be returned to the shell. The default value is `1`.'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: '`AC_MSG_ERROR` 和 `AC_MSG_FAILURE` 宏会生成错误消息，停止配置过程，并将错误代码返回给 shell。`AC_MSG_ERROR`
    的前缀文本是 `configure: error:`。`AC_MSG_FAILURE` 宏会打印一条通知，指示错误发生的目录、用户指定的消息，然后是文本 `See
    ''config.log'' for more details`。这些宏中的可选第二个参数 (*`exit-status`*) 允许维护者指定返回给 shell
    的特定状态码。默认值是 `1`。'
- en: The text messages output by these macros are displayed to `stdout` and sent
    to the *config.log* file, so it’s important to use these macros instead of simply
    using shell `echo` or `printf` statements.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 这些宏输出的文本消息会显示在 `stdout` 上，并发送到 *config.log* 文件中，因此使用这些宏很重要，而不是仅仅使用 shell 的 `echo`
    或 `printf` 语句。
- en: Supplying multiple lines of text in the first argument of these macros is especially
    important in the case of warning messages that merely indicate that the build
    is continuing with limitations. On a fast build machine in a large configuration
    process, a single-line warning message could zip right past without even being
    noticed by the user. This is less of a problem in cases where `configure` terminates
    with an error, because the user will easily discover the issue at the end of the
    output.^([13](footnote.xhtml#ch05fn13))
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些宏的第一个参数中提供多行文本尤其重要，特别是在警告消息的情况下，警告仅表示构建在有限制的情况下继续进行。在大型配置过程中，快速构建机器上，一条单行警告信息可能会快速出现并被用户忽略。对于
    `configure` 因错误终止的情况，这不是问题，因为用户很容易在输出的最后发现问题。^([13](footnote.xhtml#ch05fn13))
- en: Supporting Optional Features and Packages
  id: totrans-173
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 支持可选功能和包
- en: We’ve discussed the different ways to handle situations when a *pthread* library
    exists and when it doesn’t. But what if a user wants to build a single-threaded
    version of `jupiter` when the *pthread* library *is* installed? We certainly don’t
    want to add a note to Jupiter’s *README* file telling the user to rename their
    *pthread* libraries! Neither do we want the user to have to use our Autoconf cache
    variable trick.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经讨论了如何处理 *pthread* 库存在与否的不同情况。但如果用户希望在安装了 *pthread* 库的情况下构建 `jupiter` 的单线程版本怎么办？我们当然不希望在
    Jupiter 的 *README* 文件中添加一条提示，告诉用户重命名他们的 *pthread* 库！我们也不希望用户必须使用我们的 Autoconf 缓存变量技巧。
- en: 'Autoconf provides two macros for working with optional features and external
    software packages: `AC_ARG_ENABLE` and `AC_ARG_WITH`. Their prototypes are as
    follows:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: Autoconf 提供了两个用于处理可选功能和外部软件包的宏：`AC_ARG_ENABLE` 和 `AC_ARG_WITH`。它们的原型如下：
- en: '[PRE25]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'As with many Autoconf macros, these two are used simply to set some environment
    variables:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 与许多 Autoconf 宏一样，这两个宏仅用于设置一些环境变量：
- en: AC_ARG_WITH `${withval}` and `${with_`package`}`
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: AC_ARG_WITH `${withval}` 和 `${with_`package`}`
- en: AC_ARG_ENABLE `${enableval}` and `${enable_`feature`}`
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: AC_ARG_ENABLE `${enableval}` 和 `${enable_`feature`}`
- en: The macros can also be used in a more complex form, where the environment variables
    are used by shell script in the macros’ optional arguments. In either case, the
    resulting variable must be used in *configure.ac*, or it will be pointless to
    perform the check.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 宏也可以以更复杂的形式使用，其中环境变量由 shell 脚本在宏的可选参数中使用。无论哪种情况，生成的变量必须在*configure.ac*中使用，否则执行检查就没有意义。
- en: The macros are designed to add the options `--enable-feature[=yes|no]` (or `--disable-feature`)
    and `--with-package[=arg]` (or `--without-package`) to the generated configuration
    script’s command line interface, along with appropriate help text to the output
    generated when the user enters `./configure --help`. If the user gives these options,
    the macros set the preceding environment variables within the script. (The values
    of these variables may be used later in the script to set or clear various preprocessor
    definitions or substitution variables.)
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 这些宏的设计目的是将选项 `--enable-feature[=yes|no]`（或 `--disable-feature`）和 `--with-package[=arg]`（或
    `--without-package`）添加到生成的配置脚本的命令行界面，并在用户输入 `./configure --help` 时生成适当的帮助文本。如果用户提供了这些选项，宏将在脚本中设置前面的环境变量。（这些变量的值可能稍后在脚本中用于设置或清除各种预处理器定义或替代变量。）
- en: '`AC_ARG_WITH` controls your project’s use of optional external software packages,
    while `AC_ARG_ENABLE` controls the inclusion or exclusion of optional software
    features. The choice to use one or the other is often a matter of perspective
    on the software you’re considering, and sometimes it’s simply a matter of preference,
    as these macros provide somewhat overlapping sets of functionality.'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: '`AC_ARG_WITH` 控制项目对可选外部软件包的使用，而 `AC_ARG_ENABLE` 控制可选软件功能的包含或排除。选择使用其中一个或另一个通常取决于你对正在考虑的软件的看法，有时只是个人偏好，因为这两个宏提供的功能集有些重叠。'
- en: For instance, in the Jupiter project, it could be justifiably argued that Jupiter’s
    use of *pthread* constitutes the use of an external software package, so you’d
    use `AC_ARG_WITH`. However, it could also be said that *asynchronous processing*
    is a software feature that might be enabled via `AC_ARG_ENABLE`. In fact, both
    of these statements are true, and which option you use should be dictated by a
    high-level architectural perspective on the feature or package to which you’re
    providing optional access. The *pthread* library supplies more than just thread
    creation functions—it also provides mutexes and condition variables, both of which
    may be used by a library package that doesn’t create threads. If a project provides
    a library that needs to act in a thread-safe manner within a multithreaded process,
    it will probably use mutex objects from the *pthread* library, but it may never
    create a thread. Thus, a user may choose to disable asynchronous execution as
    a feature at configuration time, but the project will still need to link to the
    *pthread* library in order to access the mutex functionality. In such cases, it
    makes more sense to specify `--enable-async-exec` than `--with-pthreads`.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在 Jupiter 项目中，可以合理地认为 Jupiter 使用 *pthread* 代表使用了一个外部软件包，因此你会使用 `AC_ARG_WITH`。然而，也可以说
    *异步处理* 是一个可以通过 `AC_ARG_ENABLE` 启用的软件功能。事实上，这两种说法都是正确的，选择使用哪个选项应该由对你所提供可选访问的功能或软件包的高层架构视角来决定。*pthread*
    库不仅提供线程创建函数，还提供互斥锁和条件变量，这些都可以被一个不创建线程的库包使用。如果一个项目提供的库需要在多线程进程中以线程安全的方式工作，它很可能会使用
    *pthread* 库中的互斥锁对象，但可能永远不会创建线程。因此，用户可以选择在配置时禁用异步执行功能，但项目仍然需要链接到 *pthread* 库以访问互斥锁功能。在这种情况下，指定
    `--enable-async-exec` 比 `--with-pthreads` 更有意义。
- en: In general, you should use `AC_ARG_WITH` when the user needs to choose between
    implementations of a feature provided by different packages or internally within
    the project. For instance, if `jupiter` had some reason to encrypt a file, it
    might be written to use either an internal encryption algorithm or an external
    encryption library. The default configuration might use an internal algorithm,
    but the package might allow the user to override the default with the command
    line option `--with-libcrypto`. When it comes to security, the use of a widely
    understood library can really help your package gain community trust.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 一般来说，当用户需要在不同包或项目内部提供的不同功能实现之间进行选择时，你应该使用`AC_ARG_WITH`。例如，如果`jupiter`有某种原因需要加密文件，它可能会选择使用内部加密算法或外部加密库。默认配置可能使用内部算法，但该包可能允许用户通过命令行选项`--with-libcrypto`来覆盖默认值。谈到安全性，使用广为人知的库确实能帮助你的包获得社区的信任。
- en: '*Coding Up the Feature Option*'
  id: totrans-185
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*为功能选项编写代码*'
- en: Having decided to use `AC_ARG_ENABLE`, how do we enable or disable the `async-exec`
    feature by default? The difference in how these two cases are encoded in *configure.ac*
    is limited to the help text and the shell script passed in the *`action-if-not-given`*
    argument. The help text describes the available options and the default value,
    and the shell script indicates what we want to happen if the option is *not* specified.
    (Of course, if it is specified, we don’t need to assume anything.)
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 决定使用`AC_ARG_ENABLE`后，我们如何默认启用或禁用`async-exec`功能呢？这两种情况下如何在*configure.ac*中编码的区别仅限于帮助文本和传递给*`action-if-not-given`*参数的shell脚本。帮助文本描述了可用的选项和默认值，而shell脚本则指明了如果没有指定选项时希望发生的情况。（当然，如果指定了，我们不需要假设任何事情。）
- en: Say we decide that asynchronous execution is a risky or experimental feature
    that we want to disable by default. In this situation, we could add the code shown
    in [Listing 5-15](ch05.xhtml#ch05ex15) to *configure.ac*.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们决定将异步执行作为一个风险较大或实验性的功能，默认情况下希望禁用它。在这种情况下，我们可以将[Listing 5-15](ch05.xhtml#ch05ex15)中的代码添加到*configure.ac*中。
- en: '[PRE26]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '*Listing 5-15: Feature disabled by default*'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: '*Listing 5-15: 默认情况下禁用的功能*'
- en: On the other hand, if we decide that asynchronous execution is fundamental to
    Jupiter, we should probably enable it by default, as in [Listing 5-16](ch05.xhtml#ch05ex16).
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，如果我们决定异步执行对Jupiter来说是基本功能，那么我们可能应该像[Listing 5-16](ch05.xhtml#ch05ex16)中那样默认启用它。
- en: '[PRE27]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '*Listing 5-16: Feature enabled by default*'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: '*Listing 5-16: 默认情况下启用的功能*'
- en: Now, the question is, do we check for the library and header file regardless
    of the user’s desire for this feature, or do we only check for them if the `async-exec`
    feature is enabled? In this case, it’s a matter of preference, because we’re using
    the *pthread* library only for this feature. (If we were also using it for non-feature-specific
    reasons, we’d have to check for it in either case.)
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 现在问题是，我们是否在不管用户是否需要这个功能的情况下检查库和头文件，还是只有在启用`async-exec`功能时才检查？在这种情况下，这是一个偏好问题，因为我们仅为这个功能使用*pthread*库。（如果我们还因为非特定功能的原因使用它，那么无论如何都必须检查它。）
- en: In cases where we need the library even if the feature is disabled, we would
    add `AC_ARG_ENABLE`, as in the preceding example, and an additional invocation
    of `AC_DEFINE` to create a *config.h* definition specifically for this feature.
    Since we don’t really want to enable the feature if the library or header file
    is missing—even if the user specifically requested it—we’ll also add some shell
    code to turn the feature off if either is missing, as shown in [Listing 5-17](ch05.xhtml#ch05ex17).
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 在需要即使功能禁用也需要库的情况下，我们会像前面的例子那样添加`AC_ARG_ENABLE`，并额外调用`AC_DEFINE`来为这个功能创建一个*config.h*定义。由于我们并不希望在库或头文件缺失时启用该功能——即使用户特别要求启用——我们还会添加一些shell代码，在库或头文件缺失时将该功能关闭，如[Listing
    5-17](ch05.xhtml#ch05ex17)所示。
- en: Git tag 5.5
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: Git 标签 5.5
- en: '[PRE28]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '*Listing 5-17:* configure.ac: *Properly managing an optional feature during
    configuration*'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: '*Listing 5-17:* configure.ac: *在配置期间正确管理可选功能*'
- en: We’re replacing our original library check with a new check for command line
    arguments, which has the added benefit of checking for the library for the default
    case that occurs when the user doesn’t specify a preference. As you can see, much
    of the existing code is the same, with some additional script around it to account
    for user command line choices.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在将原有的库检查替换为新的命令行参数检查，这样不仅能检查用户未指定偏好的默认情况下的库，还带来了额外的好处。正如你所看到的，现有的大部分代码保持不变，只是添加了一些额外的脚本来处理用户的命令行选择。
- en: '**NOTE**'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*There are places in [Listing 5-17](ch05.xhtml#ch05ex17) that appear to have
    gratuitous whitespace or arbitrary indentation. This is intentional, as it causes
    output to be formatted properly when *`configure`* is being run. We’ll fix some
    of this later as we add additional macros to our toolbox*.'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: '*在[清单 5-17](ch05.xhtml#ch05ex17)中有些地方似乎有多余的空白或任意的缩进。这是故意的，因为它使得在运行`configure`时输出能够正确格式化。我们将在稍后通过添加额外的宏来修复其中一些问题*。'
- en: Notice that at ➊, I’ve also added an additional test for a `yes` value in the
    `async_exec` variable, because this text really belongs to the feature test, not
    to the *pthread* library test. Remember, we’re trying to create a logical separation
    between testing for *pthread* functionality and testing for the requirements of
    the `async-exec` feature itself.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，在➊处，我还添加了一个对`async_exec`变量中`yes`值的额外测试，因为这些文本真正属于功能测试，而不是*pthread*库测试。请记住，我们正在尝试在测试*pthread*功能和测试`async-exec`功能本身的需求之间创建逻辑分隔。
- en: Of course, now we also have to modify *src/main.c* to use the new definition,
    as shown in [Listing 5-18](ch05.xhtml#ch05ex18).
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，现在我们还必须修改*src/main.c*，以使用新的定义，如[清单 5-18](ch05.xhtml#ch05ex18)所示。
- en: '[PRE29]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '*Listing 5-18:* src/main.c: *Changing the conditional around `async-exec`-specific
    code*'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 5-18:* src/main.c: *更改`async-exec`特定代码的条件*'
- en: Notice that we’ve left the `HAVE_PTHREAD_H` check around the inclusion of the
    header file in order to facilitate the use of *pthread.h* in ways besides those
    required by this feature.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们保留了`HAVE_PTHREAD_H`检查以便在包含头文件时，可以便于以不同于此功能要求的方式使用*pthread.h*。
- en: In order to check for the library and header file only if the feature is enabled,
    we wrap the original check code in a test of `async_exec`, as shown in [Listing
    5-19](ch05.xhtml#ch05ex19).
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 为了仅在启用该功能时检查库和头文件，我们将原始的检查代码包装在`async_exec`的测试中，如[清单 5-19](ch05.xhtml#ch05ex19)所示。
- en: Git tag 5.6
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: Git标签 5.6
- en: '[PRE30]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '*Listing 5-19:* configure.ac: *Checking for the library and header file only
    if a feature is enabled*'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 5-19:* configure.ac: *仅在启用功能时检查库和头文件*'
- en: This time, we’ve moved the test for `async_exec` from being just around the
    message statement to being around the entire set of header and library checks,
    which means we won’t even look for *pthread* header and libraries if the user
    has disabled the `async_exec` feature.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 这次，我们将`async_exec`的测试从仅围绕消息语句移动到围绕整个头文件和库检查集合，这意味着如果用户禁用了`async_exec`功能，我们甚至不会查找*pthread*头文件和库。
- en: '*Formatting Help Strings*'
  id: totrans-211
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*格式化帮助字符串*'
- en: We’ll make one final change to our use of `AC_ARG_ENABLE` in [Listing 5-17](ch05.xhtml#ch05ex17).
    Notice that in the second argument, there are exactly two spaces between the open
    square bracket and the start of the argument text. You’ll also notice that the
    number of spaces between the argument and the description depends on the length
    of the argument text, because the description text is supposed to be presented
    to the user aligned with a particular column. There are four spaces between `--disable-async-exec`
    and the description in [Listings 5-16](ch05.xhtml#ch05ex16) and [5-17](ch05.xhtml#ch05ex17),
    but there are five spaces after `--enable-async-exec` in [Listing 5-15](ch05.xhtml#ch05ex15)
    because the word *enable* is one character shorter than the word *disable*.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将对[清单 5-17](ch05.xhtml#ch05ex17)中`AC_ARG_ENABLE`的使用做最后的修改。请注意，在第二个参数中，方括号和参数文本开始之间正好有两个空格。你还会注意到，参数和描述之间的空格数量取决于参数文本的长度，因为描述文本应该与特定列对齐呈现。在[清单
    5-16](ch05.xhtml#ch05ex16)和[5-17](ch05.xhtml#ch05ex17)中，`--disable-async-exec`和描述之间有四个空格，但在[清单
    5-15](ch05.xhtml#ch05ex15)中，`--enable-async-exec`后面有五个空格，因为单词*enable*比*disable*少一个字符。
- en: But what if the Autoconf project maintainers decide to change the format of
    the help text for configuration scripts? Or what if you modify your option name
    but forget to adjust the indentation on your help text?
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，如果Autoconf项目的维护者决定更改配置脚本的帮助文本格式怎么办？或者如果你修改了选项名称，但忘记调整帮助文本的缩进呢？
- en: 'To solve these potential problems, we’ll turn to an Autoconf helper macro called
    `AS_HELP_STRING`, whose prototype is as follows:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这些潜在问题，我们将使用一个名为`AS_HELP_STRING`的Autoconf助手宏，其原型如下：
- en: '[PRE31]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: This macro’s sole purpose is to abstract away knowledge about the number of
    spaces that should be embedded in the help text at various places. To use it,
    replace the second argument in `AC_ARG_ENABLE` with a call to `AS_HELP_STRING`,
    as shown in [Listing 5-20](ch05.xhtml#ch05ex20).
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 这个宏的唯一目的是抽象化关于在帮助文本中的各个位置应该嵌入多少空格的知识。要使用它，只需将`AC_ARG_ENABLE`中的第二个参数替换为`AS_HELP_STRING`的调用，如[清单
    5-20](ch05.xhtml#ch05ex20)所示。
- en: Git tag 5.7
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: Git标签 5.7
- en: '[PRE32]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: '*Listing 5-20:* configure.ac: *Using `AS_HELP_STRING`*'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 5-20:* configure.ac: *使用`AS_HELP_STRING`*'
- en: '**NOTE**'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*For details on the funky character sequences around *`default: no`* in [Listing
    5-20](ch05.xhtml#ch05ex20), see “Quadrigraphs” on [page 143](ch05.xhtml#page_143).*'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: '*关于[清单 5-20](ch05.xhtml#ch05ex20)中围绕*`default: no`*的奇怪字符序列的详细信息，请参阅第[143页](ch05.xhtml#page_143)的“Quadrigraphs”。*'
- en: Checks for Type and Structure Definitions
  id: totrans-222
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 检查类型和结构定义
- en: Now let’s consider how we might test for system- or compiler-provided type and
    structure definitions. When writing cross-platform networking software, one quickly
    learns that the data sent between machines needs to be formatted in a way that
    doesn’t depend on a particular CPU or operating system architecture. Some systems’
    native integer sizes are 32 bits, while others’ are 64 bits. Some systems store
    integer values in memory and on disk from least-significant byte to most-significant
    byte, while others do the reverse.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们考虑如何测试系统或编译器提供的类型和结构定义。在编写跨平台网络软件时，人们很快就会意识到，机器之间发送的数据需要以一种不依赖于特定CPU或操作系统架构的方式进行格式化。一些系统的本地整数大小是32位，而另一些则是64位。有些系统将整数值从最低有效字节到最高有效字节存储在内存和磁盘中，而另一些则相反。
- en: Let’s consider an example. When using C-language structures to format network
    messages, one of the first roadblocks you’ll encounter is the lack of basic C-language
    types that have the same size from one platform to another. A CPU with a 32-bit
    machine word size would likely have a C compiler with 32-bit `int` and `unsigned`
    types. The sizes of the basic integer types in the C language are implementation
    defined. This is by design, in order to allow implementations to use sizes for
    `char`, `short`, `int`, and `long` that are optimal for each platform.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑一个例子。当使用C语言结构格式化网络消息时，你将遇到的第一个障碍是缺乏从一个平台到另一个平台具有相同大小的基本C语言类型。一个32位机器字大小的CPU可能会有一个32位的`int`和`unsigned`类型。C语言中基本整数类型的大小是实现定义的。这是设计使然，目的是允许实现使用对每个平台最优的`char`、`short`、`int`和`long`的大小。
- en: While this language feature is great for optimizing software designed to run
    on one platform, it’s not very helpful when choosing types to move data *between*
    platforms. In order to address this problem, engineers have tried everything from
    sending network data as strings (think XML and JSON) to inventing their own sized
    types.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管这一语言特性对于优化设计为在单个平台上运行的软件非常有用，但在选择类型以便将数据*在平台之间*移动时却并不太有帮助。为了解决这个问题，工程师们尝试了从将网络数据作为字符串发送（如XML和JSON）到发明自己的大小类型的各种方法。
- en: In an attempt to remedy this shortcoming in the language, the C99 standard provides
    the sized types `int`*`N`*`_t` and `uint`*`N`*`_t`, where *`N`* may be `8`, `16`,
    `32`, or `64`. Unfortunately, not all of today’s compilers provide these types.
    (Not surprisingly, GNU C has been at the forefront for some time now, providing
    C99-sized types with the inclusion of the *stdint.h* header file.)
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 为了弥补语言中的这一不足，C99标准提供了大小类型`int`*`N`*`_t`和`uint`*`N`*`_t`，其中*`N`*可以是`8`、`16`、`32`或`64`。不幸的是，并不是所有今天的编译器都提供这些类型。（不足为奇的是，GNU
    C已经领先一段时间，提供了通过包含*stdint.h*头文件来支持C99大小的类型。）
- en: To alleviate the pain to some extent, Autoconf provides macros for determining
    whether C99-specific standardized types exist on a user’s platform and then defining
    them if they don’t exist. For example, you can add a call to `AC_TYPE_UINT16_T`
    to *configure.ac* in order to ensure that `uint16_t` exists on your users’ platforms,
    either as a system definition in *stdint.h* or the non-standard but more prolific
    *inttypes.h*, or as an Autoconf definition in *config.h*.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在某种程度上缓解这一痛苦，Autoconf提供了宏来确定C99特定的标准化类型是否存在于用户的平台上，然后在它们不存在时进行定义。例如，你可以在*configure.ac*中添加一个`AC_TYPE_UINT16_T`的调用，以确保`uint16_t`在你的用户平台上存在，不管是作为*stdint.h*中的系统定义，还是作为更为普遍的非标准*inttypes.h*，或者作为Autoconf在*config.h*中的定义。
- en: The compiler tests for such integer-based types are typically written by a configuration
    script as a bit of C code that looks like the code shown in [Listing 5-21](ch05.xhtml#ch05ex21).
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 这些针对整数类型的编译器测试通常由配置脚本编写，作为一段类似于[示例 5-21](ch05.xhtml#ch05ex21)中的 C 代码。
- en: '[PRE33]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: '*Listing 5-21: A compiler check for a proper implementation of `uint16_t`*'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: '*示例 5-21：编译器检查 `uint16_t` 的正确实现*'
- en: You’ll notice that the important line in [Listing 5-21](ch05.xhtml#ch05ex21)
    is at ➊, which is where `test_array` is declared. Autoconf is relying on the fact
    that all C compilers will generate an error if you attempt to define an array
    with a negative size. If `uint16_t` isn’t exactly 16 bits of unsigned data on
    this platform, the array size will be negative.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 你会注意到，在[示例 5-21](ch05.xhtml#ch05ex21)中，重要的代码行在 ➊ 位置，即 `test_array` 的声明位置。Autoconf
    依赖于一个事实，即所有 C 编译器在你尝试定义一个负大小的数组时都会生成错误。如果在该平台上 `uint16_t` 不是恰好为 16 位的无符号数据，则数组大小将是负数。
- en: 'Notice, too, that the bracketed expression in the listing is a compile-time
    expression.^([14](footnote.xhtml#ch05fn14)) Whether this could have been done
    with simpler syntax is anyone’s guess, but this code does the trick on all the
    compilers Autoconf supports. The array is defined with a nonnegative size only
    if the following three conditions are met:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 还要注意，示例中的带括号的表达式是一个编译时表达式。^([14](footnote.xhtml#ch05fn14)) 是否能通过更简单的语法来实现，这谁也说不清，但这段代码在所有
    Autoconf 支持的编译器中都能成功运行。只有在满足以下三个条件时，数组才会被定义为非负大小：
- en: '`uint16_t` is defined in one of the included header files.'
  id: totrans-233
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`uint16_t` 在其中一个包含的头文件中定义。'
- en: The size of `uint16_t` is exactly 16 bits.
  id: totrans-234
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`uint16_t` 的大小恰好是 16 位。'
- en: '`uint16_t` is unsigned on this platform.'
  id: totrans-235
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`uint16_t` 在此平台上是无符号的。'
- en: Follow the pattern shown in [Listing 5-22](ch05.xhtml#ch05ex22) to use the definitions
    provided by this macro. Even on systems where *stdint.h* or *inttypes.h* is not
    available, Autoconf will add code to *config.h* that defines `uint16_t` if the
    system header files don’t provide it, so you can use the type in your source code
    without additional tests.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 按照[示例 5-22](ch05.xhtml#ch05ex22)中显示的模式使用此宏提供的定义。即使在没有 *stdint.h* 或 *inttypes.h*
    的系统上，Autoconf 也会在 *config.h* 中添加代码，如果系统的头文件没有提供 `uint16_t`，它将会定义该类型，这样你就可以在源代码中使用该类型，而无需额外的测试。
- en: '[PRE34]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: '*Listing 5-22: Source code that properly uses Autoconf’s `uint16_t` definitions*'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: '*示例 5-22：正确使用 Autoconf 的 `uint16_t` 定义的源代码*'
- en: Autoconf offers a few dozen type checks like `AC_TYPE_UINT16_T`, as detailed
    in Section 5.9 of the *GNU Autoconf Manual*. In addition, a generic type check
    macro, `AC_CHECK_TYPES`, allows you to specify a comma-separated list of questionable
    types that your project needs.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: Autoconf 提供了几十种类型检查，如 `AC_TYPE_UINT16_T`，详情请参见《*GNU Autoconf 手册*》的第 5.9 节。此外，通用类型检查宏
    `AC_CHECK_TYPES` 允许你指定一个逗号分隔的、你项目需要的可疑类型列表。
- en: '**NOTE**'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*This list is comma separated because some definitions (like *`struct fooble`*)
    may have embedded spaces. Since they are comma delimited, you must use Autoconf’s
    square-bracket quotes around this parameter if you list more than one type.*'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: '*这个列表使用逗号分隔，因为某些定义（比如 *`struct fooble`*）可能包含空格。由于它们是用逗号分隔的，因此如果列出多个类型，必须使用
    Autoconf 的方括号引号围绕这个参数。*'
- en: 'Here is the formal declaration of `AC_CHECK_TYPES`:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 这是 `AC_CHECK_TYPES` 的正式声明：
- en: '[PRE35]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: If you don’t specify a list of header files in the last parameter, the default
    headers will be used in the compiler test by way of the macro `AC_INCLUDES_DEFAULT`,
    which expands to the text shown in [Listing 5-23](ch05.xhtml#ch05ex23).
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你没有在最后一个参数中指定头文件列表，则在编译器测试中将使用默认头文件，通过宏 `AC_INCLUDES_DEFAULT` 来实现，宏扩展为[示例
    5-23](ch05.xhtml#ch05ex23)中显示的文本。
- en: '[PRE36]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: '*Listing 5-23: The definition of `AC_INCLUDES_DEFAULT`, as of Autoconf version
    2.69*'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: '*示例 5-23：Autoconf 版本 2.69 中 `AC_INCLUDES_DEFAULT` 的定义*'
- en: If you know that your type is not defined in one of these header files, you
    should specify one or more header files to be included in the test, as shown in
    [Listing 5-24](ch05.xhtml#ch05ex24). This listing includes the default header
    files first, followed by the additional header files (which will often need some
    of the defaults anyway).
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你知道你的类型没有在这些头文件之一中定义，那么你应该指定一个或多个需要包含在测试中的头文件，如[示例 5-24](ch05.xhtml#ch05ex24)所示。这个列表首先包括默认的头文件，然后是额外的头文件（通常仍然需要一些默认头文件）。
- en: '[PRE37]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: '*Listing 5-24: Using a nondefault set of `include`s in the check for `struct
    doodah`*'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: '*示例 5-24：在检查 `struct doodah` 时使用非默认的 `include` 集*'
- en: Notice at ➊ in [Listing 5-24](ch05.xhtml#ch05ex24) that I’ve wrapped the last
    parameter of the macro over three lines in *configure.ac*, without indentation.
    The text of this argument is included verbatim in the test source file, so you’ll
    want to be sure that whatever you put into this argument is actually valid code
    in the language you’re using.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意在[清单5-24](ch05.xhtml#ch05ex24)中的➊，我将宏的最后一个参数分成了三行写在*configure.ac*文件中，并且没有缩进。这个参数的文本会原样包含在测试源文件中，因此你需要确保你放入这个参数中的内容在你使用的编程语言中是有效的代码。
- en: '**NOTE**'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*Test-related problems are often the sorts of things that developers complain
    about with regard to Autoconf. When you have problems with such syntax, check
    the* config.log *file for the complete source code for all failed tests, including
    the compiler output generated during compilation of the test. This information
    often provides the solution to your problem*.'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: '*与测试相关的问题通常是开发者在使用Autoconf时抱怨的类型。当你遇到这种语法问题时，请检查*config.log*文件，里面包含了所有失败测试的完整源代码，包括在编译测试时生成的编译器输出。这些信息通常能提供解决问题的线索*。'
- en: The AC_OUTPUT Macro
  id: totrans-253
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: AC_OUTPUT宏
- en: Finally, we come to the `AC_OUTPUT` macro, which expands, within `configure`,
    into shell code that generates the `config.status` script based on the data specified
    in the previous macro expansions. All other macros must be used before `AC_OUTPUT`
    is expanded, or they will be of little value to your generated `configure` script.
    (Additional shell script may be placed in *configure.ac* after `AC_OUTPUT`, but
    it will not affect the configuration or file generation performed by `config.status`.)
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们来到了`AC_OUTPUT`宏，它在`configure`中展开为shell代码，根据前面宏展开中指定的数据生成`config.status`脚本。所有其他宏必须在`AC_OUTPUT`展开之前使用，否则它们对你生成的`configure`脚本将没有多大价值。（额外的shell脚本可以在`AC_OUTPUT`之后放入*configure.ac*中，但它不会影响`config.status`执行的配置或文件生成。）
- en: Consider adding shell `echo` or `printf` statements after `AC_OUTPUT` to tell
    the user how the build system is configured based on the specified command line
    options. You can also use these statements to tell the user about additional useful
    targets for `make`. For example, we might add code to Jupiter’s *configure.ac*
    file *after* `AC_OUTPUT`, as shown in [Listing 5-25](ch05.xhtml#ch05ex25).
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑在`AC_OUTPUT`后添加shell的`echo`或`printf`语句，告诉用户构建系统是如何根据指定的命令行选项进行配置的。你还可以使用这些语句告诉用户`make`的其他有用目标。例如，我们可以在Jupiter的*configure.ac*文件中，在`AC_OUTPUT`*之后*添加代码，如[清单5-25](ch05.xhtml#ch05ex25)所示。
- en: Git tag 5.8
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: Git标签5.8
- en: '[PRE38]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: '*Listing 5-25:* configure.ac: *Adding configuration summary text to the output
    of `configure`*'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单5-25：* configure.ac: *将配置摘要文本添加到`configure`的输出中*'
- en: Adding such output to the end of *configure.ac* is a handy project feature,
    because it tells the user, at a glance, exactly what happened during configuration.
    Since variables such as `async_exec` are set to `yes` or `no` based on configuration,
    the user can see whether the requested configuration actually took place.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 在*configure.ac*文件的末尾添加这样的输出是一个方便的项目功能，因为它可以让用户一目了然地看到配置过程中发生了什么。由于像`async_exec`这样的变量会根据配置设置为`yes`或`no`，用户可以看到请求的配置是否真正生效。
- en: '**NOTE**'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*Version 2.62 (and later) of Autoconf does a much better job of deciphering
    the user’s intent with respect to the use of square brackets than earlier versions
    do. In the past, you might have needed to use a quadrigraph to force Autoconf
    to display a square bracket, but now you can use the character itself. Most of
    the problems that occur are a result of not properly quoting arguments. This enhanced
    functionality comes primarily from enhancements to Autoconf library macros that
    might accept square bracket characters in arguments. To ensure that square brackets
    are not misinterpreted in your own* configure.ac *code, you should read up on
    M4 double quotation in “Quoting Rules” on [page 438](ch16.xhtml#page_438)*.'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: '*Autoconf版本2.62（及之后版本）比早期版本更好地解读用户关于方括号使用的意图。在过去，你可能需要使用四重符号强制Autoconf显示一个方括号，但现在你可以直接使用字符本身。大多数发生的问题是由于没有正确引用参数。这种增强的功能主要来自Autoconf库宏的增强，它们可能接受带方括号字符的参数。为了确保方括号在你自己的*configure.ac*代码中不会被误解，你应该阅读“引用规则”中的M4双重引号部分，详见[第438页](ch16.xhtml#page_438)*。'
- en: '**QUADRIGRAPHS**'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: '**四重符号**'
- en: Those funny character sequences around the word `<target>` in [Listing 5-25](ch05.xhtml#ch05ex25)
    are called *quadrigraph sequences* or simply *quadrigraphs*. They serve the same
    purpose as escape sequences, but quadrigraphs are a little more reliable than
    escaped characters or escape sequences because they’re never subject to ambiguity.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 在[清单5-25](ch05.xhtml#ch05ex25)中，围绕单词`<target>`的那些有趣的字符序列被称为*四字符序列*，简称*四字符组*。它们与转义序列的作用相同，但四字符组比转义字符或转义序列更可靠，因为它们永远不会受到歧义的影响。
- en: The sequence `@<:@` is the quadrigraph sequence for the open square bracket
    character, while `@:>@` is the quadrigraph for the closed square bracket character.
    These quadrigraphs will *always* be output by `autom4te` as literal square bracket
    characters. This happens after M4 is finished with the file, so it has no opportunity
    to misinterpret them as Autoconf quote characters.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 序列`@<:@`是方括号字符的四字符序列，而`@:>@`是闭合方括号字符的四字符序列。这些四字符组将*始终*由`autom4te`输出为字面意义上的方括号字符。这发生在M4处理完文件后，因此没有机会将它们误解为Autoconf的引号字符。
- en: If you’re interested in studying quadrigraphs in more detail, check out Section
    8 of the *GNU Autoconf Manual*.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你有兴趣更详细地研究四字符组，请查阅*GNU Autoconf手册*的第8节。
- en: Summary
  id: totrans-266
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we covered some of the more advanced constructs found in the
    *configure.ac* files for many projects. We started with the macros required to
    generate substitution variables. I refer to these as “advanced” macros because
    many of the higher-level Autoconf macros use `AC_SUBST` and `AC_DEFINE` internally,
    making them somewhat transparent to you. However, knowing about them helps you
    to understand how Autoconf works and provides some of the background information
    necessary for you to learn to write your own macros.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们介绍了许多项目的*configure.ac*文件中发现的一些更高级的结构。我们从生成替代变量所需的宏开始。我称这些为“高级”宏，因为许多更高级别的Autoconf宏在内部使用`AC_SUBST`和`AC_DEFINE`，使它们对你来说有些透明。然而，了解这些宏有助于你理解Autoconf的工作原理，并为你学习编写自己的宏提供必要的背景信息。
- en: We covered checks for compilers and other tools, as well as checks for less
    common data types and structures on your users’ systems. The examples in this
    chapter were designed to help you to understand the proper use of the Autoconf
    type- and structure-definition check macros, as well as others.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 我们讲解了编译器和其他工具的检查，以及在用户系统上检查一些不太常见的数据类型和结构。本章中的示例旨在帮助你理解Autoconf类型和结构定义检查宏的正确使用方法，以及其他相关宏。
- en: 'We also examined a technique for debugging the use of complex Autoconf macros:
    using picket fences around a macro invocation in *configure.ac* in order to quickly
    locate the associated generated text in `configure`. We looked at checks for libraries
    and header files, and we examined some of the details involved in the proper use
    of these Autoconf macros. We went into great detail about building a robust and
    user-friendly configuration process, including the addition of project-specific
    command line options to Autoconf-generated `configure` scripts.'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还研究了一种调试复杂Autoconf宏使用的技巧：在*configure.ac*中的宏调用周围使用栅栏，快速定位`configure`中生成的相关文本。我们查看了库和头文件的检查，并审视了这些Autoconf宏正确使用的一些细节。我们详细探讨了构建一个健壮且用户友好的配置过程，包括向Autoconf生成的`configure`脚本添加项目特定的命令行选项。
- en: Finally, we discussed the proper placement of the `AC_OUTPUT` macro in *configure.ac*,
    as well as the addition of some summary-generation shell code designed to help
    your users understand what happened during the configuration of your project on
    their system.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们讨论了`AC_OUTPUT`宏在*configure.ac*中的正确位置，以及添加一些总结生成的Shell代码，旨在帮助用户了解在其系统上配置你的项目时发生了什么。
- en: 'An important Autconf concept to take away from [Chapters 4](ch04.xhtml) and
    [5](ch05.xhtml) was stated at the very start of [Chapter 4](ch04.xhtml): Autoconf
    generates shell scripts from the shell source code you write into *configure.ac*.
    That means you have *complete* control over what ends up in your configuration
    script, as long as you understand the proper use of the macros you’re invoking.
    In fact, you can do anything you want in *configure.ac*. Autoconf macros are there
    simply to make what you choose to do more consistent and simpler for you to write.
    The less you rely on Autoconf macros to perform configuration tasks, the less
    consistent your users’ configuration experiences will be relative to other open
    source projects they download and build.'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 从[第4章](ch04.xhtml)和[第5章](ch05.xhtml)中要带走的一个重要 Autoconf 概念，在[第4章](ch04.xhtml)的开头就已明确指出：Autoconf
    从你写入 *configure.ac* 的 shell 源代码生成 shell 脚本。这意味着，只要你理解所调用宏的正确用法，你就能对最终生成的配置脚本拥有
    *完全* 的控制权。事实上，你可以在 *configure.ac* 中做任何你想做的事情。Autoconf 宏的存在，仅仅是为了让你选择的操作更加一致，并且更容易编写。你越少依赖
    Autoconf 宏来执行配置任务，你的用户在配置过程中与其他开源项目相比，就越不一致。
- en: The next chapter takes us away from Autoconf for a while, as we turn our attention
    to GNU Automake, an Autotools toolchain add-on that abstracts many of the details
    of creating very functional makefiles for software projects.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 下一章将暂时离开 Autoconf，我们将关注 GNU Automake，这是一个 Autotools 工具链的附加组件，它抽象化了为软件项目创建功能强大的
    makefile 的许多细节。
