- en: '**14**'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**BASIC DATA VISUALIZATION**'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/common-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Data visualization is an important part of a statistical analysis. The visualization
    tools appropriate for a given data set are dependent upon the types of variables
    (as per the definitions in [Sections 13.1.1](ch13.xhtml#ch13lev2sec112) and [13.1.2](ch13.xhtml#ch13lev2sec113))
    for which you’ve made observations. In this chapter, you’ll look at the most commonly
    used data plots in statistical analyses and see examples using both base R graphics
    and `ggplot2` functionality.
  prefs: []
  type: TYPE_NORMAL
- en: '**14.1 Barplots and Pie Charts**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Barplots and pie charts are commonly used to visualize qualitative data by category
    frequency. In this section you’ll learn how to generate both using R.
  prefs: []
  type: TYPE_NORMAL
- en: '***14.1.1 Building a Barplot***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: A *barplot* draws either vertical or horizontal bars, typically separated by
    white space, to visualize frequencies according to the relevant categories. Though
    the raw frequencies themselves are usually displayed, a barplot can also be used
    to visualize other quantities, such as means or proportions, which directly depend
    upon these frequencies.
  prefs: []
  type: TYPE_NORMAL
- en: As an example, let’s use the `mtcars` data set from [Exercise 13.4](ch13.xhtml#ch13exc4)
    (b) on [page 287](ch13.xhtml#page_287). Detailing various characteristics of 32
    classic performance cars in the mid-1970s, the first five records can be viewed
    directly from the prompt.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The documentation in `?mtcars` explains the variables that have been recorded.
    Of these, `cyl` provides the number of cylinders in each engine—four, six, or
    eight. To find out how many cars were observed with each number of cylinders,
    you can use `table`, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The result is easily displayed as a barplot, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: You can find the resulting barplot on the left of [Figure 14-1](ch14.xhtml#ch14fig1).
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f14-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-1: Two examples of barplots of data from* `mtcars` *using base R
    graphics. Left: The simplest, default version, using one categorical variable.
    Right: A “dodged” barplot illustrating various visual options and using two categorical
    variables.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'This plot displays the number of four-, six-, and eight-cylinder cars in the
    data set but is admittedly rather uninteresting, and without annotations it’s
    not clear what’s being summarized. Fortunately, it’s easy to annotate such plots
    and further split up the frequencies of each bar according to an additional categorical
    variable. Consider the following code where, this time, you’re finding the counts
    associated with `cyl` by transmission (`am`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: If you aim to produce a barplot that’s *stacked* (where bars are split up vertically)
    or *dodged* (where bars are broken up and placed beside each other), `barplot`
    requests its first argument as a suitably arranged matrix. You could construct
    it from the previous two vectors using `matrix`, but it’s easier to just continue
    using `table`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, you can cross-tabulate counts by supplying two categorical
    or discrete vectors of equal length to `table`; the first vector stipulates row
    counts, and the second defines the columns. The outcome is a matrix object; here
    it’s a 2 × 3 structure providing the quantities of the four-, six-, and eight-cylinder
    automatic cars in the first row and the quantities of the manual cars in the second.
    The rule is that each column of the barplot will correspond to a column of the
    supplied matrix; these will be further split with respect to each row of the supplied
    matrix. The plot on the right of [Figure 14-1](ch14.xhtml#ch14fig1) is the result
    of the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The help file `?barplot` explains the options here in detail. To label the bars
    according to the categories of the column variable of the matrix that was initially
    passed to `barplot`, you use a character vector of the appropriate length passed
    to `names.arg`. The options `beside=TRUE` and `horiz=TRUE` select a dodged, horizontal
    barplot. If both options were `FALSE`, a stacked, vertical barplot would be selected.
    The argument `las=1` forces the labels on the vertical axis to appear horizontally,
    rather than parallel to it. The final two arguments, `legend.text` and `args.legend`,
    are used for the legend—you could have drawn a legend separately as in [Section
    7.3](ch07.xhtml#ch07lev1sec25) via `legend`, but this way automates the color
    assignment to ensure the reference keys match the precise shading of the bars
    themselves.
  prefs: []
  type: TYPE_NORMAL
- en: 'Similar plots may be produced using `ggplot2`. If you load the installed package
    with `library("ggplot2")` and enter the following, it will produce the most basic
    barplot, given on the left of [Figure 14-2](ch14.xhtml#ch14fig2):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Note here that the relevant geom is `"bar"` (or `geom_bar` if used separately,
    as you’ll see in a moment) and that the default mapping variable in `qplot` must
    be supplied as a factor (in `mtcars` the vector `mtcars$cyl` is just numeric,
    which is fine for `barplot`, but `ggplot2` functionality is a bit more strict).
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f14-02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-2: Two examples of barplots of data from* `mtcars` *using* `ggplot2`
    *functionality. Left: The most simple* `qplot` *version, using one categorical
    variable. Right: A “dodged” barplot, the same as in [Figure 14-1](ch14.xhtml#ch14fig1),
    based on the supply of various additional geoms and scaling options.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Again, you can create far more complicated images depending upon what you want
    to display. To produce a `ggplot2` version of the dodged barplot from 14-1, call
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: You can find the result on the right in [Figure 14-2](ch14.xhtml#ch14fig2).
  prefs: []
  type: TYPE_NORMAL
- en: Note a number of new additions to the basic `qplot` setup. The default mapping,
    by `cyl`, remains the same as earlier. You further specify that the bars should
    be filled according to a factor created by using the transmission variable `am`;
    so, each `cyl` bar is instructed to split according to that variable. The initial
    call to `qplot` was “empty,” in the sense that `geom="blank"`, and therefore drawing
    begins with the addition of `geom_bar` to the `ggplot2` object. It becomes a dodged
    barplot through `position="dodge"`; as in base R graphics, the default behavior
    is to generate a stacked plot. The `scale_x_discrete` modifier specifies labels
    for each category of the default `cyl` mapping; the `scale_y_continuous` modifier
    is employed to control the axis labels for the frequencies.
  prefs: []
  type: TYPE_NORMAL
- en: Further, adding `theme_bw()` to the object changes the visual theme of the image;
    in the current example, I’ve chosen to remove the gray background because it’s
    too similar in color to the manual car bars. Adding `coord_flip` to the object
    flips the axes and provides horizontal bars rather than the default vertical style
    (note that the calls to the `scale_` functions are used with respect to the unflipped
    image). The default behavior of `fill` is to use colors, so you use the `scale_fill_grey`
    modifier to force this to be grayscale and to alter the labels of the automatically
    generated legend to match at the same time.
  prefs: []
  type: TYPE_NORMAL
- en: The most prominent advantage of using `ggplot2` over base R graphics in this
    case lies in the fact that you don’t need to manually tabulate counts or design
    specific matrix structures of these frequencies—the variable mappings do this
    automatically. For practice, I encourage you to experiment with this code example,
    omitting or modifying some of the additions to the `qplot` object to assess the
    impact on the resulting image.
  prefs: []
  type: TYPE_NORMAL
- en: '***14.1.2 A Quick Pie Chart***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The venerable *pie chart* is an alternative option for visualizing frequency-based
    quantities across levels of categorical variables, with appropriately sized “slices”
    representing the relative counts of each categorical variable.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: You can find the resulting plot in [Figure 14-3](ch14.xhtml#ch14fig3).
  prefs: []
  type: TYPE_NORMAL
- en: Though it’s possible to achieve with some effort, there is no direct “pie” geom
    in `ggplot2`. This may, at least in part, be due to the general preference of
    statisticians for barplots over pie charts. That fact itself is even summarized
    in the help file `?pie`!
  prefs: []
  type: TYPE_NORMAL
- en: Pie charts are a bad way of displaying information. The eye is good at judging
    linear measures and bad at judging relative areas.
  prefs: []
  type: TYPE_NORMAL
- en: Furthermore, barplots are of greater value than pie charts if you want frequencies
    split by a *second* categorical variable or if the levels of a factor are ordered.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f14-03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-3: A pie chart of the frequencies of total cylinders of the cars
    in the* `mtcars` *data frame*'
  prefs: []
  type: TYPE_NORMAL
- en: '**14.2 Histograms**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The barplot is intuitively sensible for counting observations in relation to
    categorical variables but is of virtually no use if the variable you’re interested
    in is numeric-continuous. To visualize the distribution of continuous measurements,
    you can use a *histogram*—a tool that’s sometimes confused with a barplot owing
    to its similar appearance. A histogram also measures frequencies, but in targeting
    a numeric-continuous variable, it’s first necessary to “bin” the observed data,
    meaning to define intervals and then count the number of continuous observations
    that fall within each one. The size of this interval is known as the *binwidth*.
  prefs: []
  type: TYPE_NORMAL
- en: For a simple example of a histogram, consider the horsepower data of the 32
    cars in `mtcars`, given in the fourth column, named `hp`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: For this section, define horsepowers of all performance cars from that era as
    your population and assume that these observations represent a sample from that
    population. Using base R graphics, the `hist` command takes a vector of numeric-continuous
    observations and produces a histogram, as shown on the left in [Figure 14-4](ch14.xhtml#ch14fig4).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: '![image](../images/f14-04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-4: Illustrating the default behavior of* `hist` *on the* `mtcars`
    *horsepower data (left); customizing binwidth, color, and title options, as well
    as adding markers of centrality (right)*'
  prefs: []
  type: TYPE_NORMAL
- en: You can immediately see that the histogram on the left has used binwidths of
    50 units spanning the range of the data, providing you with a quick and useful
    first impression of the distribution of horsepower measurements. It seems to be
    centered roughly in the range of 75 to 150, tapering off on the right (this is
    known as a *right* or *positive skew*; more terminology will be covered in [Section
    15.2.4](ch15.xhtml#ch15lev2sec136)).
  prefs: []
  type: TYPE_NORMAL
- en: The accuracy of a histogram as a representation of the shape of a distribution
    of measurements depends solely upon the widths of the intervals used to bin the
    data. Binwidths are controlled in `hist` by the `breaks` argument. You can manually
    set these by supplying a vector, giving each breakpoint, to `breaks`. This is
    done in the following code by halving the width of each bin from 50 to 25 and
    widening the overall range somewhat, using an evenly spaced sequence.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: This plot, given on the right in [Figure 14-4](ch14.xhtml#ch14fig4), shows the
    result of using the narrower bins, as well as making the bars gray and adding
    a more readable title. It also includes vertical lines denoting the mean and median,
    using `abline`, and a legend (refer back to [Section 7.3](ch07.xhtml#ch07lev1sec25)).
  prefs: []
  type: TYPE_NORMAL
- en: With the smaller binwidth, more detail is visible in the distribution. However,
    using narrower bins risks highlighting “unimportant features” (in other words,
    features of the histogram that represent natural variation as a consequence of
    the finite-sized sample). These typically occur at locations on the scale where
    data are scarce. For example, the single 335 horsepower car has produced an isolated
    bar on the right of the scale, but you might reasonably conclude that this is
    not a precise, accurate reflection of a “true bump” at that location in terms
    of the overall population. It’s therefore important to note that choosing the
    interval widths is a balancing act of sorts.
  prefs: []
  type: TYPE_NORMAL
- en: You want to choose a width that gives you a good idea of the distribution of
    measurements without emphasizing unimportant detail by using too small a binwidth.
    Equivalently, you also want to avoid hiding important features by using too *large*
    a binwidth. To address this, there are data-driven algorithms that use the scale
    of the recorded observations to try to calculate an appropriately balanced binwidth.
    You can supply a character string to `breaks`, giving the name of the algorithm
    that you want to employ. The default `breaks="Sturges"` often works well, though
    it’s worth trying a small number of alternative widths when exploring data in
    this way. For further details on this and other ways to use `breaks`, the documentation
    `?hist` provides clear and concise instruction.
  prefs: []
  type: TYPE_NORMAL
- en: 'The issues surrounding intervals and their widths is emphasized in a different
    way in `ggplot2`. By default, the `qplot` function produces a histogram when you
    supply it with a single numeric vector but no value for the `geom` argument:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: You can find the result on the left in [Figure 14-5](ch14.xhtml#ch14fig5). Note,
    however, that a notification from `qplot` concerning the binwidths is printed
    to the console.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f14-05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-5: Illustrating the default behavior of* `qplot` *on the* `mtcars`
    *horsepower data (left); customizing binwidth, color, and title options, as well
    as adding markers of centrality (right)*'
  prefs: []
  type: TYPE_NORMAL
- en: 'If you don’t explicitly specify the bins, exactly 30 intervals will be used
    to span the range of the data. Inspecting the relevant geom documentation given
    with a call to `?geom_histogram` tells you the following:'
  prefs: []
  type: TYPE_NORMAL
- en: By default, `stat_bin` uses 30 bins. This is not a good default, but the idea
    is to get you experimenting with different binwidths. You may need to look at
    a few to uncover the full story behind your data.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, rather than defaulting to a data-driven algorithm such as `hist`, `ggplot2`
    encourages users to become aware of the issue and actively set their own binwidths.
    You can see that 30 bins yields inappropriately narrow intervals for this example—there
    are many gaps where no observations have fallen. There are a number of ways to
    choose histogram intervals in `qplot`, one of which is to use `breaks` as earlier,
    supplying it with an appropriate numeric vector of interval endpoints. To re-create
    the plot on the right of [Figure 14-4](ch14.xhtml#ch14fig4) using `ggplot2` functionality,
    use the following code, which produces the right-hand plot in [Figure 14-5](ch14.xhtml#ch14fig5):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Starting with a `"blank"` geom, `geom_histogram` completes most of the work,
    with `color` governing the bar outline color and `fill` the internal color of
    the bars. The argument `closed="right"` determines that each interval is “closed”
    (in other words, exclusive) on the right and “open” (in other words, inclusive)
    on the left, the same as the default noted in `?hist`. The `geom_vline` function
    is used to add the vertical mean and median lines; here, the `mapping` must be
    instructed to change using `aes` and the locations of these lines. To ensure a
    correctly labeled legend is created for the mean and median, you must also instruct
    `linetype` in `aes` to be mapped to the desired values. In this case, this is
    simply a factor comprised of the two desired “levels.”
  prefs: []
  type: TYPE_NORMAL
- en: Since you’re manually adding these lines and the associated mapping to the `ggplot2`
    object, the legend itself must be instructed to appear with `show.legend=TRUE`.
    By default, the two lines will be drawn `lty=1` (solid) and `lty=2` (dashed),
    but to match the earlier plot, you want `lty=2` and `lty=3` (dotted). You can
    add the `scale_linetype_manual` modifier to make this change; the desired line
    type numbers are passed as a vector to `values`. Finally, to suppress the automatic
    inclusion of a title for your manually added legend, the `labs(linetype="")` addition
    instructs the scale associated with the variable mapped to `linetype` in the `aes`
    call to be displayed without this title.
  prefs: []
  type: TYPE_NORMAL
- en: The choice between using `ggplot2` and base R graphics often comes down to your
    intended goal. For automated handling of graphics, especially where categorical
    variables are used to separate subsets of the data set, `ggplot2` is particularly
    powerful. On the other hand, if you require manual control over the creation of
    a given image, traditional R graphics can be easier to handle, and you don’t need
    to keep track of multiple aesthetic variable mappings.
  prefs: []
  type: TYPE_NORMAL
- en: '**14.3 Box-and-Whisker Plots**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: An especially popular alternative to the histogram is the *box-and-whisker plot*,
    or simply *boxplot* for short. This is merely a visual representation of the five-number
    summary discussed in [Section 13.2.3](ch13.xhtml#ch13lev2sec118).
  prefs: []
  type: TYPE_NORMAL
- en: '***14.3.1 Stand-Alone Boxplots***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Let’s return to the built-in `quakes` data frame of the 1,000 seismic events
    near Fiji. For the sake of comparison, you can examine both a histogram and a
    boxplot of the magnitudes of these events using default base R behavior. The following
    code produces the images given in [Figure 14-6](ch14.xhtml#ch14fig6):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: '![image](../images/f14-06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-6: Default histogram (left) and boxplot (right) of the magnitude
    data from* `quakes`*. On the boxplot, commentary (superimposed externally) points
    out the key information displayed.*'
  prefs: []
  type: TYPE_NORMAL
- en: Like the histogram, a boxplot shows important features of the distribution,
    such as global (in other words, overall) centrality, spread, and skewness. It’s
    not really possible to see local features, such as multiple significant peaks
    in the distribution, however. As the labeling arrows point out, the line in the
    middle of the box represents the median, the lower and upper edges of the box
    show the respective quartiles, perpendicular lines (the *whiskers*) extending
    from the box indicate the minimum and the maximum, and any dots drawn beyond the
    whiskers are deemed to be points of extremity or outliers. By default, `boxplot`
    defines an outlier as an observation that lies more than 1.5 times the IQR below
    the lower quartile or above the upper quartile. This is done to prevent the whiskers
    from extending too far and overemphasizing any skew. Thus, the “maximum” and “minimum”
    values marked by the whiskers are not always the raw, overall maximum or minimum
    values in the data set because a value that has been deemed an “outlier” might
    actually represent the highest or lowest value. You can control the nature of
    this classification via the `range` argument in `boxplot`, though the default
    of `range=1.5` is usually sensible for basic data exploration.
  prefs: []
  type: TYPE_NORMAL
- en: '***14.3.2 Side-by-Side Boxplots***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'One particularly pleasing aspect of these plots is the ease with which you
    can compare the five-number summary distributions of different groups with *side-by-side*
    boxplots. Again using the `quakes` data, define the following corresponding factor
    and inspect the first five elements (review use of the `cut` command from [Section
    4.3.3](ch04.xhtml#ch04lev2sec48) if necessary):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Recall that the `stations` variable records how many monitoring stations detected
    each event. This code has produced a factor breaking up these observations into
    one of three groups—events detected by 50 stations or fewer, between 51 and 100
    stations, and between 101 and 150 stations. Thus, you can compare the distributions
    of the magnitudes of the events according to these three groups. The following
    line produces the left image of [Figure 14-7](ch14.xhtml#ch14fig7):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: With this line of code, you should note new syntax in the form of a tilde, `~`,
    shown here in `quakes$mag~stations.fac`. You can read the `~` as “on,” “by,” or
    “according to” (you’ll use the tilde notation frequently in [Chapters 20](ch20.xhtml#ch20)
    through [22](ch22.xhtml#ch22)). Here you’re instructing `boxplot` to plot `quakes$mag`
    *according to* `station.fac` so that a separate boxplot is produced for each group,
    naturally given in the order listed in the grouping factor. Optional arguments
    are also employed to control axis labeling and box color. Your interpretation
    of this plot mirrors what you can see in [Figure 13-6](ch13.xhtml#ch13fig6), in
    that the higher the recorded magnitude, the more stations that detected a given
    seismic event.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f14-07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-7: Side-by-side boxplots of the* `quakes` *magnitudes, split by
    the three groups identified by* `station.fac`*, using base R graphics (left) and*
    `ggplot2` *functionality (right)*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Turning to `ggplot2` functionality, `qplot` can produce the same type of plot
    easily, with the following producing the image on the right in [Figure 14-7](ch14.xhtml#ch14fig7):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: The default boxplots look a little different, though you can make the same interpretations.
    In this use of `qplot`, you supply the boxplot grouping factor as the *x*-axis
    variable (first argument) and the continuous variable for which you require boxplots
    as the *y*-axis variable (second argument). Here I’ve explicitly set `geom="boxplot"`
    to ensure a boxplot display, and I’ve added axis labels.
  prefs: []
  type: TYPE_NORMAL
- en: '**14.4 Scatterplots**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A *scatterplot* is most frequently used to identify a relationship between the
    observed values of two different numeric-continuous variables, displayed as *x*-*y*
    coordinate plots. The coordinate-wise nature of base R graphics lends itself naturally
    to the creation of scatterplots, so you’ve seen several examples already in this
    book. However, not every *x*-*y* coordinate-based plot is always called a scatterplot;
    a scatterplot usually assumes there is some “relationship of interest” present.
    For example, a plot of spatial coordinates like [Figure 13-1](ch13.xhtml#ch13fig1)
    might not be regarded as a scatterplot, but a plot of the earthquake magnitude
    against the number of stations detecting the event, like [Figure 13-6](ch13.xhtml#ch13fig6),
    would be.
  prefs: []
  type: TYPE_NORMAL
- en: 'I’ll finish this chapter by expanding on how you can use scatterplots to explore
    more than two continuous variables. To do this, let’s access another ready-to-use
    R data set, namely, the famous `iris` data. Collected in the mid-1930s, this data
    frame of 150 rows and 5 columns consists of petal and sepal measurements for three
    species of perennial iris flowers—*Iris setosa*, *Iris virginica*, and *Iris versicolor*
    ([Anderson, 1935](ref.xhtml#ref03); [Fisher, 1936](ref.xhtml#ref24)). You can
    view the first five records here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Looking through `?iris`, you can see that there are 50 observations for each
    variable, recorded in centimeters (cm), for each species.
  prefs: []
  type: TYPE_NORMAL
- en: '***14.4.1 Single Plot***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: You can modify a simple scatterplot to split the plotted points according to
    a categorical variable, exposing potential differences between any visible relationships
    with respect to the continuous variables. For example, using base R graphics,
    you can examine the petal measurements according to the three species. Using the
    “stepping-stone” approach first explained in [Chapter 7](ch07.xhtml#ch07), you
    can manually build up this plot by first using `type="n"` to generate an empty
    plotting region of the correct dimensions and subsequently adding the points corresponding
    to each species, altering point character and color as desired.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: You can find the plot in [Figure 14-8](ch14.xhtml#ch14fig8). Note that the *Iris
    virginica* species has the largest petals, followed by *Iris versicolor*, and
    the smallest petals belong to *Iris setosa*. However, this code, while functional,
    is fairly cumbersome. You can generate the same image more simply by first setting
    up vectors that specify the desired point character and color *for each individual
    observation*.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f14-08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-8: A scatterplot of petal measurements split by species from the
    built-in* `iris` *data frame*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the two objects created here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'The first line creates a vector `iris_pch` of equal length to the number of
    observations in `iris`, with every entry being `19`. Vector subsetting then overwrites
    the entries corresponding to *Iris versicolor* and sets the point character to
    `1`. The same steps are followed to create `iris_col`; first an appropriately
    sized vector is filled with the character strings `"black"`, and then those entries
    corresponding to *Iris virginica* are overwritten and set to `"gray"`. With that,
    note that the single line shown next, when followed by the same call to `legend`
    as earlier, will produce an identical plot:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: '***14.4.2 Matrix of Plots***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The “single” type of planar scatterplot is really useful only when comparing
    *two* numeric-continuous variables. When there are more continuous variables of
    interest, it isn’t possible to display this information satisfactorily on a single
    plot. A simple and common solution is to generate a two-variable scatterplot for
    each pair of variables and show them together in a structured way; this is referred
    to as a *scatterplot matrix*. Making use of the `iris_pch` and `iris_col` vectors
    created earlier, you can generate a scatterplot matrix for all four continuous
    variables in `iris`, retaining the distinction between species. Working with base
    R graphics, use the `pairs` function.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: You can find the result of this line in [Figure 14-9](ch14.xhtml#ch14fig9).
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f14-09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-9: A scatterplot matrix with respect to all four continuous measurements
    in the data frame*'
  prefs: []
  type: TYPE_NORMAL
- en: The easiest way to use `pairs` is to supply a matrix or data frame of the raw
    observations as its first argument, done here by selecting all columns of `iris`
    except the `Species` column (`iris[,1:4]`). The interpretation of the plots depends
    upon the labeling of the diagonal panels, running from the top left to the bottom
    right. They will appear in the same order as the columns given as the first argument.
    These “label panels” allow you to determine which individual plot in the matrix
    corresponds to each pair of variables. For example, the first column of the scatterplot
    matrix in [Figure 14-9](ch14.xhtml#ch14fig9) corresponds to an *x*-axis variable
    of Sepal Length; the third row of the matrix corresponds to a *y*-axis variable
    of Petal Length, and each row and column displays a scale that is constant moving
    left/right or up/down, respectively. This means that plots above the diagonal
    are mirrored in those below it—the plot of Petal Width (*y*) on Sepal Width (*x*)
    at position row 4, column 2 displays the same data as the scatterplot at position
    row 2, column 4 but flipped on its axes. As such, `pairs` includes an option to
    display only those scatterplots above *or* below the diagonal, by setting either
    `lower.panel=NULL` or `upper.panel=NULL` to suppress one or the other.
  prefs: []
  type: TYPE_NORMAL
- en: Scatterplot matrices therefore allow for an easier comparison of the collection
    of pairwise relationships formed by observations made on multiple continuous variables.
    In this matrix, note there’s a strong positive linear association between petal
    measurements but a weaker relationship between the sepal measurements. Furthermore,
    although *Iris setosa* may reasonably be considered the smallest flower in terms
    of its petals, the same can’t be said in terms of its sepals.
  prefs: []
  type: TYPE_NORMAL
- en: For those working with `ggplot2`, you know that it’s natural to split the points
    according to a categorical variable, as in the following example.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: You can find the result in [Figure 14-10](ch14.xhtml#ch14fig10).
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f14-10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-10: Using* `ggplot2` *functionality to plot petal dimensions for
    the three* `iris` *species, with point* `shape` *as the aesthetic modifier*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here, I’ve split up the points using the `Species` variable mapped to `shape`
    (the equivalent of the base R terminology `pch`), and I’ve modified the point
    types using the `scale_shape_manual` modifier. I’ve also simplified the title
    of the automatically generated legend with `labs`, as done in [Section 14.2](ch14.xhtml#ch14lev1sec45).
    Scatterplot matrices, however, are not easily achievable using only `ggplot2`.
    To generate a matrix in a `ggplot2` style, it’s recommended that you download
    the `GGally` package ([Schloerke et al., 2014](ref.xhtml#ref58)) to access the
    `ggpairs` function. This package is designed to be an extension or add-on of `ggplot2`.
    It’s installed from CRAN as per usual—for example, by running `install.packages("GGally")`—and
    must be loaded via `library("GGally")` prior to use. After this is done, as a
    quick example, the following code produces the plot in [Figure 14-11](ch14.xhtml#ch14fig11):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Though you might see familiar warnings related to the histogram binwidths, `ggpairs`
    offers an impressive visual array for such a short line of code. The output not
    only gives you the lower half of the scatterplot matrix produced with `pairs`
    but also provides equivalent histograms along the bottom and boxplots along the
    right. It also displays the estimates of the correlation coefficients. As shown,
    you can map a variable to an aesthetic modifier to split up the plotted observations
    based on factor levels. In [Figure 14-11](ch14.xhtml#ch14fig11), this is done
    by color, and you instruct `ggpairs` to operate on the `Species` variable. Documentation
    found in `?ggpairs` gives concise information on the various options that control
    the presence and appearance of the individual plots.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f14-11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-11: Generation of a scatterplot matrix using `ggpairs` from the
    `GGally` package, using color to separate the species. Note the useful addition
    of estimated correlation coefficients and distributional plots.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**Exercise 14.1**'
  prefs: []
  type: TYPE_NORMAL
- en: Recall the built-in `InsectSprays` data frame, containing counts of insects
    on various agricultural units treated with one of six sprays.
  prefs: []
  type: TYPE_NORMAL
- en: Produce a histogram of the counts of insects using base R graphics.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Obtain the total number of insects found according to each spray (this was also
    asked in [Exercise 13.2](ch13.xhtml#ch13exc2) (f) on [page 273](ch13.xhtml#page_273)).
    Then, use base R graphics to produce a vertical barplot and a pie chart of these
    totals, labeling each plot appropriately.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Use `ggplot2` functionality to generate side-by-side boxplots of the counts
    of insects according to each spray type and include appropriate axis labels and
    a title.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Yet another of R’s useful ready-to-use data sets is `USArrests`, containing
    data on the number of arrests for murder, rape, and assault per 100,000 individuals
    in each of the 50 states of the United States, recorded in 1973 (see, for example,
    [McNeil, 1977](ref.xhtml#ref46)). It also includes a variable giving the percentage
    of urban-based population in each state. Briefly inspect the data frame object
    and the accompanying documentation `?USArrests`. Then complete the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Use `ggplot2` functionality to generate a right-exclusive histogram of the proportion
    of urban population for the states. Set your breaks to be 10 units each, between
    0 and 100\. Have the histogram show the first quartile, the median, and the third
    quartile; then provide a matching legend. Use colors as you like and include appropriate
    axis annotation.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The code `t(as.matrix(USArrests[,-3]))` creates a matrix of the `USArrests`
    data without the urban population column, and the built-in R object `state.abb`
    provides the two-letter state abbreviations, in alphabetical order, as a character
    vector. Use these two structures and base R graphics to produce a horizontal,
    stacked barplot with the horizontal bars labeled with state abbreviations and
    with each bar split according to the type of crime (murder, rape, and assault).
    Include a legend.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Define a new factor vector `urbancat` that is set to `1` if the corresponding
    state has an urban population percentage greater than the median percentage and
    is set to `0` otherwise.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a new copy of `USArrests` in your workspace, after deleting the `UrbanPop`
    column, leaving just the three crime rate variables. Then insert a new, fourth
    column in this object with `urbancat`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Use the data frame from (g) to produce a scatterplot matrix and other associated
    plots of the three crime rates against one another via `GGally` functionality.
    Use color to split the crime rates according to the two levels of `urbancat`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Return to the built-in `quakes` data set.
  prefs: []
  type: TYPE_NORMAL
- en: Create a factor vector corresponding to the magnitudes. Each entry should assume
    one of three categories based on breaks marked by the minimum magnitude, the ![image](../images/1by3.jpg)
    th quantile, the ![image](../images/2by3.jpg) th quantile, and the maximum magnitude.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Re-create the plot shown next, where low-, medium-, and high-magnitude events,
    according to your factor vector from (i), are plotted with `pch` being assigned
    `1`, `2`, and `3`, respectively.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![image](../images/f0307-01.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: Add a legend to the plot from (j) to reference the three `pch` values.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Important Code in This Chapter**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '| **Function/operator** | **Brief description** | **First occurrence** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `barplot` | Create a barplot | [Section 14.1.1](ch14.xhtml#ch14lev2sec122),
    [p. 290](ch14.xhtml#page_290) |'
  prefs: []
  type: TYPE_TB
- en: '| `geom_bar` | Barplot geom | [Section 14.1.1](ch14.xhtml#ch14lev2sec122),
    [p. 292](ch14.xhtml#page_292) |'
  prefs: []
  type: TYPE_TB
- en: '| `scale_x_discrete` | Modify discrete *x*-axis (`ggplot2`) | [Section 14.1.1](ch14.xhtml#ch14lev2sec122),
    [p. 292](ch14.xhtml#page_292) |'
  prefs: []
  type: TYPE_TB
- en: '| `scale_y_continuous` | Modify continuous *y*-axis | [Section 14.1.1](ch14.xhtml#ch14lev2sec122),
    [p. 292](ch14.xhtml#page_292) |'
  prefs: []
  type: TYPE_TB
- en: '| `theme_bw` | Black-and-white color theme | [Section 14.1.1](ch14.xhtml#ch14lev2sec122),
    [p. 292](ch14.xhtml#page_292) |'
  prefs: []
  type: TYPE_TB
- en: '| `coord_flip` | Switch *x*- and *y*-axes | [Section 14.1.1](ch14.xhtml#ch14lev2sec122),
    [p. 292](ch14.xhtml#page_292) |'
  prefs: []
  type: TYPE_TB
- en: '| `scale_fill_grey` | Filled colors as grayscale | [Section 14.1.1](ch14.xhtml#ch14lev2sec122),
    [p. 292](ch14.xhtml#page_292) |'
  prefs: []
  type: TYPE_TB
- en: '| `pie` | Create a pie chart | [Section 14.1.2](ch14.xhtml#ch14lev2sec123),
    [p. 293](ch14.xhtml#page_293) |'
  prefs: []
  type: TYPE_TB
- en: '| `hist` | Create a histogram | [Section 14.2](ch14.xhtml#ch14lev1sec45), [p.
    294](ch14.xhtml#page_294) |'
  prefs: []
  type: TYPE_TB
- en: '| `geom_histogram` | Histogram geom | [Section 14.2](ch14.xhtml#ch14lev1sec45),
    [p. 297](ch14.xhtml#page_297) |'
  prefs: []
  type: TYPE_TB
- en: '| `geom_vline` | Add vertical lines geom | [Section 14.2](ch14.xhtml#ch14lev1sec45),
    [p. 297](ch14.xhtml#page_297) |'
  prefs: []
  type: TYPE_TB
- en: '| `scale_linetype_manual` | Alter `ggplot2` line types | [Section 14.2](ch14.xhtml#ch14lev1sec45),
    [p. 297](ch14.xhtml#page_297) |'
  prefs: []
  type: TYPE_TB
- en: '| `labs` | `ggplot2` legend labels | [Section 14.2](ch14.xhtml#ch14lev1sec45),
    [p. 297](ch14.xhtml#page_297) |'
  prefs: []
  type: TYPE_TB
- en: '| `boxplot` | Create boxplots | [Section 14.3.1](ch14.xhtml#ch14lev2sec124),
    [p. 298](ch14.xhtml#page_298) |'
  prefs: []
  type: TYPE_TB
- en: '| `~` | Plot “according to” | [Section 14.3.2](ch14.xhtml#ch14lev2sec125),
    [p. 299](ch14.xhtml#page_299) |'
  prefs: []
  type: TYPE_TB
- en: '| `pairs` | Scatterplot matrix | [Section 14.4.2](ch14.xhtml#ch14lev2sec127),
    [p. 303](ch14.xhtml#page_303) |'
  prefs: []
  type: TYPE_TB
- en: '| `scale_shape_manual` | Alter `ggplot2` point characters | [Section 14.4.2](ch14.xhtml#ch14lev2sec127),
    [p. 304](ch14.xhtml#page_304) |'
  prefs: []
  type: TYPE_TB
- en: '| `ggpairs` | Scatterplot matrix (`GGally`) | [Section 14.4.2](ch14.xhtml#ch14lev2sec127),
    [p. 304](ch14.xhtml#page_304) |'
  prefs: []
  type: TYPE_TB
