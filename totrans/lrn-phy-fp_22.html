<html><head></head><body><div id="sbo-rt-content"><h2 class="h2" id="ch20"><span epub:type="pagebreak" id="page_363"/><span class="big">20</span><br/>SPRINGS, BILLIARD BALLS, AND A GUITAR STRING</h2>&#13;
<div class="image1"><img src="Images/common.jpg" alt="Image" width="189" height="189"/></div>&#13;
<p class="noindent">This chapter applies the ideas and theory of the previous chapter to three specific examples. The first is a system of two masses and two springs hanging from a fixed ceiling, the second is a billiard ball collision, and the third is a guitar string modeled as a long line of particles connected to their neighbors with springs.</p>&#13;
<p class="indent">A few things will be different in this chapter. We’ll take a closer look at the approximate numerical calculation we have been doing, treating numerical issues in more detail than we have in previous chapters. We’ll examine momentum and energy conservation in the context of approximate numerical calculation. We’ll also introduce a method for asynchronous animation where the calculations are done first and then made into a movie that can be watched afterward. Asynchronous animation is appropriate when the calculations get too intense to be done on the time scale of human impatience to see the results.</p>&#13;
<h3 class="h3" id="ch20lev1"><span epub:type="pagebreak" id="page_364"/>Introductory Code</h3>&#13;
<p class="noindent"><a href="ch20.xhtml#ch20list1">Listing 20-1</a> shows the introductory code for the <code>MOExamples</code> module we’ll develop in this chapter (<em>MO</em> for <em>Multiple Objects</em>). As usual, we import the functions and types we want to use in this module.</p>&#13;
<pre id="ch20list1">{-# OPTIONS -Wall #-}&#13;
&#13;
module MOExamples where&#13;
&#13;
import SimpleVec&#13;
   ( R, Vec, (^+^), (^-^), (*^), vec, zeroV, magnitude&#13;
   , sumV, iHat, jHat, kHat, xComp, yComp, zComp )&#13;
import Mechanics1D ( TimeStep, NumericalMethod, euler, rungeKutta4 )&#13;
import Mechanics3D&#13;
   ( ParticleState(..), HasTime(..), defaultParticleState&#13;
   , earthSurfaceGravity, customLabel, orient, disk )&#13;
import MultipleObjects&#13;
   ( MultiParticleState(..), DMultiParticleState, Force(..), TwoBodyForce&#13;
   , newtonSecondMPS, updateMPS, statesMPS, eulerCromerMPS&#13;
   , linearSpring, fixedLinearSpring, billiardForce )&#13;
import Graphics.Gnuplot.Simple&#13;
import qualified Graphics.Gloss as G&#13;
import qualified Vis as V</pre>&#13;
<p class="listing"><em>Listing 20-1: Opening lines of code for the <span class="codeitalic1">MOExamples</span> module</em></p>&#13;
<p class="indent">The types <code>ParticleState</code> and <code>MultiParticleState</code> are the state-description types we use for one particle and multiple particles, respectively. The function <code>newtonSecondMPS</code> creates a differential equation from a list of internal and external forces. The functions <code>euler</code>, <code>eulerCromerMPS</code>, and <code>rungeKutta4</code> are used to solve differential equations. We import the type class <code>HasTime</code> so we can use the <code>timeOf</code> function that belongs to it, and because we make explicit reference to <code>HasTime</code> in one of the exercises.</p>&#13;
<h3 class="h3" id="ch20lev2">Two Masses and Two Springs</h3>&#13;
<p class="noindent">As a first example of a system with multiple objects, let’s analyze the situation in <a href="ch20.xhtml#ch20fig1">Figure 20-1</a>.</p>&#13;
<div class="imagel" id="ch20fig1"><img src="Images/365fig01.jpg" alt="Image" width="260" height="391"/></div>&#13;
<p class="figcap"><em>Figure 20-1: A system of two masses and two springs</em></p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_365"/>In <a href="ch20.xhtml#ch20fig1">Figure 20-1</a> we have two masses and two springs. The upper spring is attached to a fixed ceiling and has spring constant <em>k</em><sub>1</sub> and equilibrium length <em>re</em><sub>1</sub>. The lower spring connects the two objects and has spring constant <em>k</em><sub>2</sub> and equilibrium length <em>re</em><sub>2</sub>. The upper object has mass <em>m</em><sub>0</sub>, and the lower object has mass <em>m</em><sub>1</sub>. Earth surface gravity acts on each of the objects.</p>&#13;
<h4 class="h4" id="ch20lev3">Forces</h4>&#13;
<p class="noindent">There are a total of four forces acting in this situation: three external forces and one internal force. The list <code>twoSpringsForces</code> contains the four forces, which we will describe in the order they are listed.</p>&#13;
<pre>twoSpringsForces :: [Force]&#13;
twoSpringsForces&#13;
    = [ExternalForce 0 (fixedLinearSpring 100 0.5 zeroV)&#13;
      ,InternalForce 0 1 (linearSpring 100 0.5)&#13;
      ,ExternalForce 0 earthSurfaceGravity&#13;
      ,ExternalForce 1 earthSurfaceGravity&#13;
      ]</pre>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_366"/>Since one end is fixed, the upper spring acts as an external force on object 0. The relevant one-body force is <code>fixedLinearSpring 100 0.5 zeroV</code>, the force from a linear spring with spring constant 100 N/m and equilibrium length 0.5 m attached to the ceiling at the origin. The lower spring acts as an internal force between objects 0 and 1. It also has spring constant 100 N/m and equilibrium length 0.5 m. The last two forces describe the gravitational force Earth exerts on each of the two objects.</p>&#13;
<h4 class="h4" id="ch20lev4">Animation Functions</h4>&#13;
<p class="noindent">We’d like to animate the oscillation of the objects using not-gloss. We need to specify the five ingredients that serve as inputs to the <code>simulateVis</code> function: a time-scale factor, an animation rate, an initial state, a display function, and a state-update function. We choose a time-scale factor of 1 and an animation rate of 20 frames/second.</p>&#13;
<p class="indent">In the initial state, we must give the mass, initial position, and velocity of each object. We let <img class="inline" src="Images/366equ01.jpg" alt="Image" width="475" height="26"/> <img class="inline" src="Images/366equ01a.jpg" alt="Image" width="276" height="27"/> and <strong>v</strong><sub>1</sub>(0) = 0 m/s, where <strong>r</strong><sub><em>j</em></sub> and <strong>v</strong><sub><em>j</em></sub> are the position and velocity functions of particle <em>j</em>. The code for the initial state is as follows:</p>&#13;
<pre>twoSpringsInitial :: MultiParticleState&#13;
twoSpringsInitial&#13;
    = MPS [defaultParticleState&#13;
           { mass   = 2&#13;
           , posVec = 0.4 *^ jHat ^-^ 0.3 *^ kHat }&#13;
          ,defaultParticleState&#13;
           { mass   = 3&#13;
           , posVec = 0.4 *^ jHat ^-^ 0.8 *^ kHat }&#13;
          ]</pre>&#13;
<p class="indent">We use the <code>MPS</code> constructor, the one constructor for the <code>MultiParticleState</code> data type, to transform a list of single-particle states into a multi-particle state. We set the charge, time, and velocity of each particle to 0 since that is the value in <code>defaultParticleState</code>.</p>&#13;
<p class="indent">The function that involves most of the physics is <code>twoSpringsUpdate</code>, the state-update function for the system. Here is the code:</p>&#13;
<pre>twoSpringsUpdate :: TimeStep&#13;
                 -&gt; MultiParticleState  -- old state&#13;
                 -&gt; MultiParticleState  -- new state&#13;
twoSpringsUpdate dt = updateMPS (eulerCromerMPS dt) twoSpringsForces</pre>&#13;
<p class="indent">The time step gets the local name <code>dt</code>. Recall that, in animation, we do not choose the time step directly. We choose it indirectly through the time-scale factor and animation rate, and then the animation packages do their best to adhere to that rate, although they make no promises. Since the old state is not named on the left of the equal sign of the definition, the return type is <code>MultiParticleState -&gt; MultiParticleState</code>. We use <code>updateMPS</code> to create <span epub:type="pagebreak" id="page_367"/>the state-update function. It returns a state-update function when given a numerical method and a list of forces. We choose Euler-Cromer with time step <code>dt</code> as our numerical method, and we give the list of forces we wrote earlier.</p>&#13;
<p class="indent">We have specified the time-scale factor, the animation rate, the initial state, and the state-update function we will use for our animation. We will discuss the display function next when we look at the stand-alone program for the animation.</p>&#13;
<h4 class="h4" id="ch20lev5">Stand-Alone Animation Program</h4>&#13;
<p class="noindent"><a href="ch20.xhtml#ch20list2">Listing 20-2</a> shows a stand-alone program for 3D animation of the two masses and two springs.</p>&#13;
<pre id="ch20list2"><span class="ent">➊</span> {-# OPTIONS -Wall #-}&#13;
&#13;
   import SimpleVec ( R, zeroV )&#13;
   import Mechanics3D ( posVec, simulateVis, v3FromVec )&#13;
   import MultipleObjects ( MultiParticleState(..) )&#13;
   import MOExamples ( twoSpringsInitial, twoSpringsUpdate )&#13;
   import Vis ( VisObject(..), Flavour(..), red, green, blue )&#13;
&#13;
   main :: IO ()&#13;
   main = simulateVis 1 20 twoSpringsInitial twoSpringsVisObject twoSpringsUpdate&#13;
&#13;
   twoSpringsVisObject :: MultiParticleState -&gt; VisObject R&#13;
<span class="ent">➋</span> twoSpringsVisObject (MPS sts)&#13;
    <span class="ent">➌</span> = let r0 = posVec (sts !! 0)&#13;
          <span class="ent">➍</span> r1 = posVec (sts !! 1)&#13;
          <span class="ent">➎</span> springsObj = Line Nothing [v3FromVec zeroV&#13;
                                       ,v3FromVec r0&#13;
                                       ,v3FromVec r1] <span class="ent">➏</span> blue&#13;
          <span class="ent">➐</span> objs = [Trans (v3FromVec r0) (Sphere 0.1 Solid red)&#13;
                    ,Trans (v3FromVec r1) (Sphere 0.1 Solid green)&#13;
                    ,springsObj&#13;
                    ]&#13;
          <span class="ent">➑</span> vpm = 1  -- Vis units per meter&#13;
      <span class="ent">➒</span> in Scale (vpm,vpm,vpm) $ VisObjects objs</pre>&#13;
<p class="listing"><em>Listing 20-2: Stand-alone program for a 3D animation of two masses and two springs</em></p>&#13;
<p class="indent">The program begins by turning on warnings <span class="ent">➊</span> and then imports the needed types and functions. The program makes imports from the <code>SimpleVec</code> module of <a href="ch10.xhtml">Chapter 10</a>, the <code>Mechanics3D</code> module of <a href="ch16.xhtml">Chapter 16</a>, the <code>Multiple</code> <code>Objects</code> module of <a href="ch19.xhtml">Chapter 19</a>, and the <code>MOExamples</code> module of the current chapter. It imports <code>zeroV</code> from the <code>SimpleVec</code> module to be able to refer to the origin, where a spring is attached. The program imports <code>R</code> because it is used in the type <code>VisObject R</code>.</p>&#13;
<p class="indent">Let’s discuss the imports from the <code>Mechanics3D</code> module. The program imports the <code>posVec</code> function, the extraction function of the <code>ParticleState</code> data <span epub:type="pagebreak" id="page_368"/>type that returns the position vector of a particle state. The only state variable needed in the display function is position. None of the other state variables have anything to contribute to what the picture should look like for a given state. The program imports <code>simulateVis</code>, the principal function that produces the animation. The program also imports <code>v3FromVec</code> to convert a vector with type <code>Vec</code> into a vector with type <code>V3</code>, not-gloss’s vector type.</p>&#13;
<p class="indent">From the <code>MultipleObjects</code> module, we import the <code>MultiParticleState</code> type with its constructor so we can refer to the type in the type signature for the display function and use the constructor <code>MPS</code> to pattern match on the input in the definition of the display function. From the <code>MOExamples</code> module of the current chapter, we import the initial state and the state-update function, two of the five ingredients needed for an animation.</p>&#13;
<p class="indent">From the module <code>Vis</code>, the program imports the <code>VisObject</code> type with its constructors, which include <code>Line</code>, <code>Sphere</code>, <code>Trans</code>, <code>Scale</code>, and <code>VisObjects</code>. We import the <code>Flavour</code> type with its constructors because a sphere is required to be either solid or wire-frame, and the <code>Solid</code> data constructor we use is a constructor of <code>Flavour</code>. The program also imports the colors <code>red</code>, <code>green</code>, and <code>blue</code>.</p>&#13;
<p class="indent">The main program is named <code>main</code> and has type <code>IO ()</code>. It calls <code>simulateVis</code> with the five ingredients needed to make an animation, which includes the display function <code>twoSpringsVisObject</code> defined in the stand-alone program.</p>&#13;
<p class="indent">The display function <code>twoSpringsVisObject</code> produces a picture from the state of the system. The definition of the display function begins by pattern matching on the input so that the body of the function has access to the two-element list of single-particle states <code>sts</code> <span class="ent">➋</span>. We give local names <code>r0</code> and <code>r1</code> to the positions of the two objects <span class="ent">➌</span> <span class="ent">➍</span>. The local variable <code>springsObj</code> is a picture of two lines that represent the two springs <span class="ent">➎</span>. To construct a picture of two lines, we use the <code>Line</code> data constructor.</p>&#13;
<p class="indent">Let’s take a look at the type of <code>Line</code> in not-gloss.</p>&#13;
<pre>Prelude Graphics.Gloss&gt;  <span class="codestrong1">:m Vis Linear.V3</span>&#13;
Prelude Vis Linear.V3&gt;  <span class="codestrong1">:t Line</span>&#13;
Line :: Maybe a -&gt; [V3 a] -&gt; Color -&gt; VisObject a</pre>&#13;
<p class="indent">This <code>Line</code> has three inputs. The first has to do with line width. To get the default line width, in <a href="ch20.xhtml#ch20list2">Listing 20-2</a> we supply <code>Nothing</code> for the first input <span class="ent">➎</span>. The second input is a list of vectors, each vector having not-gloss’s native <code>V3 a</code> type. In our use, the type variable <code>a</code> stands for the type <code>R</code>. We convert from <code>Vec</code> to <code>V3 R</code> with <code>v3FromVec</code> <span class="ent">➎</span>. The third input is a color, for which the program supplies <code>blue</code> <span class="ent">➏</span>.</p>&#13;
<p class="indent">We define <code>objs</code> to be a list of pictures of the two masses and the two springs <span class="ent">➐</span>. The pictures of the masses are spheres, translated to the positions contained in the state.</p>&#13;
<p class="indent">We then define a spatial-scale factor <code>vpm</code> to be 1 Vis-unit/meter <span class="ent">➑</span>. Of course, scaling by 1 is unnecessary, but the code makes it easy to change the value to something else. Finally, <code>VisObjects</code> combines multiple pictures into a single picture and <code>Scale</code> scales the entire result <span class="ent">➒</span>.</p>&#13;
<h4 class="h4" id="ch20lev6"><span epub:type="pagebreak" id="page_369"/>Using Mechanical Energy as a Guide to Numerical Accuracy</h4>&#13;
<p class="noindent">The system of two masses and two springs that we’ve been exploring should conserve mechanical energy. In this section, we’ll discuss the types of energy a system of particles can have, and we’ll see how to use energy as a tool to assess the accuracy of our numerical methods.</p>&#13;
<h5 class="h5" id="ch20lev7">Kinetic Energy</h5>&#13;
<p class="noindent">Each moving particle has an energy of motion called <em>kinetic energy</em>. The kinetic energy of a single particle is one half the particle’s mass multiplied by the square of its speed. We’ll use small capitals <em>KE</em> for the kinetic energy of a single particle. Kinetic energy is a scalar whose SI units are Joules (J).</p>&#13;
&#13;
<div class="imagec"><img src="Images/369equ01.jpg" alt="Image" width="94" height="45"/></div>&#13;
<p class="indent">The speed <em>v</em> = |<strong>v</strong>| is the magnitude of the velocity <strong>v</strong>. Here is a Haskell function that returns the kinetic energy of one particle:</p>&#13;
<pre>kineticEnergy :: ParticleState -&gt; R&#13;
kineticEnergy st = let m = mass st&#13;
                       v = magnitude (velocity st)&#13;
                   in (1/2) * m * v**2</pre>&#13;
<p class="indent">The kinetic energy of a system of particles is the sum of the kinetic energies for each particle in the system. We use uppercase <em>KE</em> to denote system kinetic energy. In a system of particles, the kinetic energy of particle <em>n</em>, which has mass <em>m<sub>n</sub></em> and velocity <strong>v</strong><sub><em>n</em></sub>, is given by</p>&#13;
<div class="imagec"><img src="Images/369equ02.jpg" alt="Image" width="116" height="44"/></div>&#13;
<p class="noindent">and the system kinetic energy is</p>&#13;
<div class="imagec"><img src="Images/369equ03.jpg" alt="Image" width="233" height="54"/></div>&#13;
<p class="indent">Here is a Haskell function that returns the kinetic energy of a system of particles:</p>&#13;
<pre>systemKE :: MultiParticleState -&gt; R&#13;
systemKE (MPS sts) = sum [kineticEnergy st | st &lt;- sts]</pre>&#13;
<h5 class="h5" id="ch20lev8">Potential Energy</h5>&#13;
<p class="noindent">Some forces are distinguished in that they can be associated with a <em>potential energy</em>. Such forces are called <em>conservative</em> and include the elastic force of a spring and the force of gravity as examples.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_370"/>A spring acquires potential energy by being compressed or extended from its equilibrium position. The spring can be used to store energy in this way. A linear spring with spring constant <em>k</em> that is displaced (compressed or extended) a distance <em>x</em> from its equilibrium position has a potential energy</p>&#13;
<div class="imagec"><img src="Images/370equ01.jpg" alt="Image" width="410" height="45"/></div>&#13;
<p class="indent">The type of potential energy associated with a spring is called <em>elastic potential energy</em>. The function <code>linearSpringPE</code> computes the elastic potential energy of a spring given its spring constant, equilibrium length, and particle states at each end.</p>&#13;
<pre>linearSpringPE :: R              -- spring constant&#13;
               -&gt; R              -- equilibrium length&#13;
               -&gt; ParticleState  -- state of particle at one end of spring&#13;
               -&gt; ParticleState  -- state of particle at other end of spring&#13;
               -&gt; R              -- potential energy of the spring&#13;
linearSpringPE k re st1 st2&#13;
    = let r1 = posVec st1&#13;
          r2 = posVec st2&#13;
          r21 = r2 ^-^ r1&#13;
          r21mag = magnitude r21&#13;
      in k * (r21mag - re)**2 / 2</pre>&#13;
<p class="indent">This function is similar to the function <code>linearSpring</code> we wrote in <a href="ch19.xhtml">Chapter 19</a>, except that instead of calculating a force, it calculates a potential energy. The displacement from equilibrium <em>x</em> in Equation 20.1 is the difference between the distance <code>r21mag</code> from one end of the spring to the other and the spring’s equilibrium length <code>re</code>.</p>&#13;
<p class="indent">An object near Earth’s surface has a <em>gravitational potential energy</em> that depends on its height. An object with mass <em>m</em> has potential energy</p>&#13;
<p class="centere">PE<sub><em>g</em></sub> = <em>mgh</em></p>&#13;
<p class="noindent">where <em>g</em> is Earth’s gravitational acceleration constant and <em>h</em> is the object’s height above some reference level, such as Earth’s surface. The function <code>earthSurfaceGravityPE</code> computes the gravitational potential energy of an object near Earth’s surface given its particle state.</p>&#13;
<pre>-- z direction is toward the sky&#13;
-- assumes SI units&#13;
earthSurfaceGravityPE :: ParticleState -&gt; R&#13;
earthSurfaceGravityPE st&#13;
    = let g = 9.80665  -- m/s^2&#13;
          m = mass st&#13;
          z = zComp (posVec st)&#13;
      in m * g * z</pre>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_371"/>This function is similar to the function <code>earthSurfaceGravity</code> we wrote in <a href="ch16.xhtml">Chapter 16</a>, except that instead of calculating a force, it calculates a potential energy.</p>&#13;
<p class="indent">Returning now to the example of two masses and two springs, the total potential energy is the elastic potential energy of each spring plus the gravitational potential energy of each mass.</p>&#13;
<pre>twoSpringsPE :: MultiParticleState -&gt; R&#13;
twoSpringsPE (MPS sts)&#13;
    = linearSpringPE 100 0.5 defaultParticleState (sts !! 0)&#13;
      + linearSpringPE 100 0.5 (sts !! 0) (sts !! 1)&#13;
      + earthSurfaceGravityPE (sts !! 0)&#13;
      + earthSurfaceGravityPE (sts !! 1)</pre>&#13;
<p class="indent">Since the top spring is connected to a fixed ceiling, we use the default particle state for one end of the top spring to indicate that one end of the spring is fixed at the origin.</p>&#13;
<h5 class="h5" id="ch20lev9">Mechanical Energy</h5>&#13;
<p class="noindent">The <em>mechanical energy</em> of a system of particles is the sum of its kinetic energy and its potential energy. Systems with no non-conservative forces conserve mechanical energy. The mechanical energy of such a system at a later time is the same as it was earlier. Since we are doing approximate calculation, we cannot expect that our calculation of mechanical energy will stay exactly the same over time. Since we know that it would stay the same if we could do exact calculation, we can take the deviation that occurs in our calculation as a guide to the level of inaccuracy our numerical method is producing. For a system that should conserve mechanical energy, how well it is conserved in our calculations is an indication of our numerical method’s accuracy.</p>&#13;
<p class="indent">The function <code>twoSpringsME</code> computes the mechanical energy for the system of two masses and two springs.</p>&#13;
<pre>twoSpringsME :: MultiParticleState -&gt; R&#13;
twoSpringsME mpst = systemKE mpst + twoSpringsPE mpst</pre>&#13;
<p class="indent">Mechanical energy is conserved for this system because all of the forces involved are conservative. For the system of two masses and two springs, <a href="ch20.xhtml#ch20fig2">Figure 20-2</a> shows mechanical energy as a function of time for different numerical methods. The first column shows the Euler method, the second the Euler-Cromer, and the third the fourth-order Runge-Kutta. The first row uses a time step of 0.1 s, the second row 0.01 s, the third row 10<sup>–3</sup> s, and the fourth row 10<sup>–4</sup> s.</p>&#13;
<div class="imagel" id="ch20fig2"><img src="Images/372fig01.jpg" alt="Image" width="625" height="627"/></div>&#13;
<p class="figcap"><em>Figure 20-2: Mechanical energy as a function of time for different numerical methods. The change in mechanical energy is a measure of numerical inaccuracy.</em></p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_372"/>Mechanical energy tends to increase in the Euler method, oscillate in the Euler-Cromer method, and perhaps decrease in the fourth-order Runge-Kutta method. The horizontal axis shows a period of 10 seconds in each graph. The vertical axes show vastly different scales. If we take the difference between maximum mechanical energy and minimum mechanical energy over a 10-second time period as our measure of inaccuracy, we can make a table comparing the numerical methods. <a href="ch20.xhtml#ch20tab1">Table 20-1</a> shows such a comparison.</p>&#13;
<p class="tabcap" id="ch20tab1"><strong>Table 20-1:</strong> Change in Calculated Mechanical Energy for the Two-Mass and Two-Spring System over a 10-Second Interval for Different Numerical Methods</p>&#13;
<table class="all">&#13;
<colgroup>&#13;
<col style="width:25%"/>&#13;
<col style="width:25%"/>&#13;
<col style="width:25%"/>&#13;
<col style="width:25%"/>&#13;
</colgroup>&#13;
<thead>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-1bw_top"><p class="taba"><strong>Time step</strong></p></td>&#13;
<td style="vertical-align: top;" class="table-1bw_top"><p class="taba"><strong>Euler</strong></p></td>&#13;
<td style="vertical-align: top;" class="table-1bw_top"><p class="taba"><strong>Euler-Cromer</strong></p></td>&#13;
<td style="vertical-align: top;" class="table-1bw_top"><p class="taba"><strong>4th order RK</strong></p></td>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-h1aa_top-border"><p class="taba">10<sup>–1</sup>s</p></td>&#13;
<td style="vertical-align: top;" class="table-h1aa_top-border"><p class="taba">Way off</p></td>&#13;
<td style="vertical-align: top;" class="table-h1aa_top-border"><p class="taba">40%</p></td>&#13;
<td style="vertical-align: top;" class="table-h1aa_top-border"><p class="taba">7%</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;"><p class="taba">10<sup>–2</sup>s</p></td>&#13;
<td style="vertical-align: top;"><p class="taba">Way off</p></td>&#13;
<td style="vertical-align: top;"><p class="taba">4%</p></td>&#13;
<td style="vertical-align: top;"><p class="taba">10<sup>–4</sup>%</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="backcolort"><p class="taba">10<sup>–3</sup>s</p></td>&#13;
<td style="vertical-align: top;" class="backcolort"><p class="taba">20%</p></td>&#13;
<td style="vertical-align: top;" class="backcolort"><p class="taba">0.4%</p></td>&#13;
<td style="vertical-align: top;" class="backcolort"><p class="taba">10<sup>–8</sup>%</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-1bw_bot"><p class="taba">10<sup>–4</sup>s</p></td>&#13;
<td style="vertical-align: top;" class="table-1bw_bot"><p class="taba">2%</p></td>&#13;
<td style="vertical-align: top;" class="table-1bw_bot"><p class="taba">0.04%</p></td>&#13;
<td style="vertical-align: top;" class="table-1bw_bot"><p class="taba">10<sup>–11</sup>%</p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_373"/><a href="ch20.xhtml#ch20tab1">Table 20-1</a> shows maximum mechanical energy minus minimum mechanical energy over a 10-second period, expressed as a percentage of initial mechanical energy. The Euler method is not even close for time steps less than a millisecond. You can see this in the animation if you change the numerical method to the Euler method. The springs extend and droop in a horrible display of numerical inaccuracy. The table also shows how each 10-fold reduction in time step produces approximately a 10-fold improvement in accuracy for the two first-order methods, Euler and Euler-Cromer. A 10-fold decrease in time step for the fourth-order Runge-Kutta method produces a roughly 10<sup>4</sup>-fold improvement in accuracy. In this way, the fourth-order method shows why it is considered a fourth-order method.</p>&#13;
<p class="indent">Having seen a first example of multiple interacting objects, let’s look at a second example of interacting objects, that of a collision.</p>&#13;
<h3 class="h3" id="ch20lev10">A Collision</h3>&#13;
<p class="noindent">Our second example of multiple objects interacting is a collision between two billiard balls. For this example, we’ll go through the four data representations of <a href="ch19.xhtml#ch19fig2">Figure 19-2</a>, discuss the choice of parameters (including time step), look at momentum and energy conservation, discuss some numerical issues, and finally produce some animated results.</p>&#13;
<h4 class="h4" id="ch20lev11">Data Representations</h4>&#13;
<p class="noindent">The four data representations are a list of forces, a differential equation, a state-update function, and a list of states. We’ll discuss each of these in turn.</p>&#13;
<h5 class="h5" id="ch20lev12">Forces</h5>&#13;
<p class="noindent">We suppose that the elastic billiard interaction described in <a href="ch19.xhtml">Chapter 19</a> is the only force that acts on either particle. This elastic billiard interaction is an internal force that acts between the two billiard balls. Here is the list of one force:</p>&#13;
<pre>billiardForces :: R -&gt; [Force]&#13;
billiardForces k = [InternalForce 0 1 (billiardForce k (2*ballRadius))]</pre>&#13;
<p class="indent">The elastic billiard interaction requires that we specify a spring constant for the elastic repulsion and a threshold distance at which the repulsive force kicks in. We make the spring constant <code>k</code> an argument to the function <code>billiardForces</code> so we can delay committing to a particular value and so it will be easy to try out different values.</p>&#13;
<p class="indent">Each ball has a diameter of 6 cm. The threshold distance occurs when the centers of the balls are two radii apart. Because it’s always the same, we specify a particular value, <code>2*ballRadius</code>, for the threshold distance rather than making it an argument like we did for the spring constant. We name the ball radius because it’s used in two places: the list of forces we just wrote and the display function we write later in the chapter.</p>&#13;
<span epub:type="pagebreak" id="page_374"/>&#13;
<pre>ballRadius :: R&#13;
ballRadius = 0.03  -- 6cm diameter = 0.03m radius</pre>&#13;
<h5 class="h5" id="ch20lev13">Differential Equation</h5>&#13;
<p class="noindent">Newton’s second law transforms a list of forces into a differential equation. For multi-particle systems, <code>newtonSecondMPS</code> is the function that does this transformation. We give the name <code>billiardDiffEq k</code> to the differential equation that expresses Newton’s second law for two billiard balls acted on by <code>billiardForces k</code>.</p>&#13;
<pre>billiardDiffEq :: R -&gt; MultiParticleState -&gt; DMultiParticleState&#13;
billiardDiffEq k = newtonSecondMPS $ billiardForces k</pre>&#13;
<p class="indent">We continue to parameterize the differential equation by the spring constant <code>k</code> that we have not yet specified.</p>&#13;
<h5 class="h5" id="ch20lev14">State-Update Function</h5>&#13;
<p class="noindent">Next, we need a state-update function. The simplest way to write a state-update function uses the <code>updateMPS</code> function of <a href="ch19.xhtml#ch19fig2">Figure 19-2</a>.</p>&#13;
<pre>billiardUpdate&#13;
    :: (TimeStep -&gt; NumericalMethod MultiParticleState DMultiParticleState)&#13;
    -&gt; R         -- k&#13;
    -&gt; TimeStep  -- dt&#13;
    -&gt; MultiParticleState -&gt; MultiParticleState&#13;
billiardUpdate nMethod k dt = updateMPS (nMethod dt) (billiardForces k)</pre>&#13;
<p class="indent">This state-update function has the same form as others we have written, except that we included a numerical method and a spring constant as parameters so we can specify these items later. There are only three things that have type <code>TimeStep -&gt; NumericalMethod MultiParticleState DMultiParticleState</code> and can serve for the input <code>nMethod</code>: <code>euler</code>, <code>eulerCromerMPS</code>, and <code>rungeKutta4</code>. We need to specify one of these when we use this function, but for now we’ll delay that decision.</p>&#13;
<h5 class="h5" id="ch20lev15">List of States</h5>&#13;
<p class="noindent">The fourth data representation of <a href="ch19.xhtml#ch19fig2">Figure 19-2</a> is an evolver, which is a function that will produce a list of states when given an initial state. The simplest way to write an evolver uses the <code>statesMPS</code> function of <a href="ch19.xhtml#ch19fig2">Figure 19-2</a>.</p>&#13;
<pre>billiardEvolver&#13;
    :: (TimeStep -&gt; NumericalMethod MultiParticleState DMultiParticleState)&#13;
    -&gt; R         -- k&#13;
    -&gt; TimeStep  -- dt&#13;
    -&gt; MultiParticleState -&gt; [MultiParticleState]&#13;
billiardEvolver nMethod k dt = statesMPS (nMethod dt) (billiardForces k)</pre>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_375"/>To get a list of states from an evolver requires an initial state. In the initial state, we give the masses of each object as well as their initial positions and velocities. We’ll let each billiard ball have a mass of 160 grams. The first ball starts at the origin with an initial velocity of 0.2 m/s in the x-direction. The second ball starts at rest at coordinates (1 m, 0.02 m) in the xy-plane. The small y-component is present so that the collision will be slightly oblique rather than one dimensional. The code for the initial state is as follows:</p>&#13;
<pre>billiardInitial :: MultiParticleState&#13;
billiardInitial&#13;
    = let ballMass = 0.160  -- 160g&#13;
      in MPS [defaultParticleState { mass     = ballMass&#13;
                                   , posVec   = zeroV&#13;
                                   , velocity = 0.2 *^ iHat }&#13;
             ,defaultParticleState { mass     = ballMass&#13;
                                   , posVec   = iHat ^+^ 0.02 *^ jHat&#13;
                                   , velocity = zeroV }&#13;
             ]</pre>&#13;
<p class="indent">Let’s now name a list of states based on this initial state. The list</p>&#13;
<pre>billiardStates nMethod k dt</pre>&#13;
<p class="noindent">is an infinite list of states for the billiard collision when the calculation is done with numerical method <code>nMethod</code> (<code>euler</code>, <code>eulerCromerMPS</code>, or <code>rungeKutta4</code>), spring constant <code>k</code>, and time step <code>dt</code>.</p>&#13;
<pre>billiardStates&#13;
    :: (TimeStep -&gt; NumericalMethod MultiParticleState DMultiParticleState)&#13;
    -&gt; R         -- k&#13;
    -&gt; TimeStep  -- dt&#13;
    -&gt; [MultiParticleState]&#13;
billiardStates nMethod k dt&#13;
    = statesMPS (nMethod dt) (billiardForces k) billiardInitial</pre>&#13;
<p class="indent">Next we will want a finite list of states that we can use to make a graph, or to compare the value of some physical quantity, like momentum or kinetic energy, before the collision with the corresponding value after. The list <code>billiardStatesFinite nMethod k dt</code> is a finite list of states for the billiard collision when the calculation is done with numerical method <code>nMethod</code>, spring constant <code>k</code>, and time step <code>dt</code>.</p>&#13;
<pre>billiardStatesFinite&#13;
    :: (TimeStep -&gt; NumericalMethod MultiParticleState DMultiParticleState)&#13;
    -&gt; R         -- k&#13;
    -&gt; TimeStep  -- dt&#13;
    -&gt; [MultiParticleState]&#13;
billiardStatesFinite nMethod k dt&#13;
    = takeWhile (\st -&gt; timeOf st &lt;= 10) (billiardStates nMethod k dt)</pre>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_376"/>To form the finite list, we use <code>takeWhile</code> to select all of the states before 10 seconds elapse. As we will see soon, the collision occurs about 5 seconds into the simulation.</p>&#13;
<p class="indent">So far, we have delayed making any choices about numerical method, spring constant, or time step. Let’s turn to that issue next.</p>&#13;
<h4 class="h4" id="ch20lev16">Spring Constant and Time Step</h4>&#13;
<p class="noindent">In an introductory physics course, collisions are usually dealt with using conservation of momentum rather than by giving an explicit force for the interaction between two particles. Using conservation of momentum is elegant because we don’t need to know the force that acts between the particles; as long as it is short-lived, the system momentum before the collision must equal the system momentum after the collision. However, there are downsides to relying solely on conservation of momentum to analyze collisions. For example, for collisions in two dimensions, one usually needs information that is not present in the initial state of the system, such as the velocity of one of the particles <em>after</em> the collision, to find the velocities of both particles after the collision. If we know the nature of the force between the particles, on the other hand, then initial conditions suffice to determine the future motion of the particles.</p>&#13;
<p class="indent">On the practical side of things, our method of analyzing a collision by specifying an explicit force between the particles means that we need to make some choices. The elastic billiard collision requires that we specify a spring constant. Values that are too small or too large can introduce trouble for the numerical analysis of the collision with a finite time step. If the spring constant is too small, the objects will squish together during the collision, making their centers very close, and there is a risk that one object will pass through the other object instead of bouncing off of it. If the spring constant is too large, the spring will apply a very large force the first time the objects are within their separation threshold. The force may be so large that the objects may be outside their separation threshold by the very next time step. This would be a poor sampling of the force and could lead to poor numerical results.</p>&#13;
<p class="indent">If the time step is too large, one particle may move too far during one time step and entirely miss any state in which the particles are within their threshold separation. Even if the collision is not completely missed, a time step that is too large may give inaccurate results. Our general advice is to choose a time step that is small compared with the characteristic time scales of the situation.</p>&#13;
<p class="indent">We need to choose a spring constant for the interaction force in addition to the usual time step for numerical analysis. How should we choose these two things?</p>&#13;
<p class="indent">One way to choose a spring constant for the elastic interaction is to suppose that all of the initial kinetic energy of motion is transformed into potential energy in the spring. If this were true, we could write the following equation:</p>&#13;
<div class="imagec"><img src="Images/377equ01.jpg" alt="Image" width="114" height="44"/></div>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_377"/>The separation threshold for the two billiard balls we are considering is 6 cm; perhaps we would like the ball centers to get no closer than 5 cm to each other. Then the displacement from equilibrium should be no more than 1 cm. Using 1 cm for <em>x</em> in the equation above and solving for <em>k</em> gives us the following:</p>&#13;
<div class="imagec"><img src="Images/377equ02.jpg" alt="Image" width="374" height="53"/></div>&#13;
<p class="indent">This calculation is a rough way of making a reasonable guess for a spring constant. The initial kinetic energy in this collision is only partially transformed into elastic potential energy.</p>&#13;
<p class="indent">What are the relevant time scales for the collision? One time scale is the time it takes the moving billiard ball to traverse a distance equal to the threshold separation. This time is given by the threshold separation divided by the initial velocity of the moving ball.</p>&#13;
<div class="imagec"><img src="Images/377equ03.jpg" alt="Image" width="136" height="47"/></div>&#13;
<p class="indent">A second time scale comes from the spring constant and mass in the problem. If this were a problem in which the mass could oscillate on the spring, the period of oscillation would be proportional to <img class="inline" src="Images/377equ04.jpg" alt="Image" width="55" height="21"/>. Oscillation will not occur in this situation, but the collision can be viewed as taking place over the course of half a period of the oscillation that would occur if this were a full-fledged spring. The half period consists of the compression of the spring from equilibrium to closest approach, followed by the expansion of the spring back to equilibrium. This second spring-based time scale is</p>&#13;
<div class="imagec"><img src="Images/377equ05.jpg" alt="Image" width="239" height="63"/></div>&#13;
<p class="indent">The time step we choose for numerical analysis needs to be small compared with the smaller of the two time scales, namely 0.05 s. At this point, we have rough estimates for a spring constant and a time step. We will sharpen these estimates shortly, after we identify several desirable properties we want of our calculation and explore how these properties depend on the spring constant and time step. Two of the desirable properties are conservation of momentum and conservation of energy, which we look at next.</p>&#13;
<h4 class="h4" id="ch20lev17">Momentum and Energy Conservation</h4>&#13;
<p class="noindent">The basic wisdom about collisions that comes from an introductory physics course is that momentum is conserved in all collisions; however, energy is conserved only in <em>elastic collisions</em>. Our collision is elastic, so we expect both momentum and energy to be conserved.</p>&#13;
<h5 class="h5" id="ch20lev18"><span epub:type="pagebreak" id="page_378"/>Momentum Conservation</h5>&#13;
<p class="noindent">The momentum of a single particle is the particle’s mass multiplied by its velocity. The symbol <strong>p</strong> is conventionally used for momentum, which is a vector whose SI units are kg m/s.</p>&#13;
<p class="centere"><strong>p</strong> = m<strong>v</strong></p>&#13;
<p class="indent">(We saw in <a href="ch18.xhtml">Chapter 18</a> that relativity theory uses a different definition of momentum, but in <a href="ch19.xhtml">Chapter 19</a> and the current chapter, we’re focusing again on Newtonian mechanics.) Here is a Haskell function that returns the momentum of one particle:</p>&#13;
<pre>momentum :: ParticleState -&gt; Vec&#13;
momentum st = let m = mass st&#13;
                  v = velocity st&#13;
              in m *^ v</pre>&#13;
<p class="indent">The momentum of a system of particles is the vector sum of the momenta for each particle in the system. We use an uppercase <strong>P</strong> to denote system momentum. In a system of particles, the momentum of particle <em>n</em>, which has mass <em>m<sub>n</sub></em> and velocity <strong>v</strong><sub><em>n</em></sub>, is given by</p>&#13;
<p class="centere"><strong>p</strong><sub><em>n</em></sub> = <em>m<sub>n</sub></em><strong>v</strong><sub><em>n</em></sub></p>&#13;
<p class="noindent">and the system momentum is</p>&#13;
<div class="imagec"><img src="Images/378equ01.jpg" alt="Image" width="192" height="45"/></div>&#13;
<p class="indent">Here is a Haskell function that returns the momentum of a system of particles.</p>&#13;
<pre>systemP :: MultiParticleState -&gt; Vec&#13;
systemP (MPS sts) = sumV [momentum st | st &lt;- sts]</pre>&#13;
<p class="indent">In any system with only internal forces, the momentum of the system is conserved, meaning it stays the same over time. Our numerical calculations involve a finite time step, which must be small compared to characteristic time scales of the physical situation to give accurate results. Most quantities of physical interest become less and less accurate as the time step is increased. An exception is system momentum in the case where only internal forces are present. Our practice of categorizing forces as external or internal, along with our automatic application of Newton’s third law, guarantees that system momentum will be conserved in any situation without external forces, regardless of numerical method and regardless of time step. This is because each internal force, acting over the course of one time step, will change the momentum vector of one particle by some amount and the momentum vector of another particle by the opposite amount. System momentum does not change from time step to time step, even if the time step is so large that the results of the calculation are poor.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_379"/>Even in collisions where external forces are present, system momentum is usually approximately conserved because the internal forces of collision are usually strong compared with any external forces. Since collisions are typically short-lived, the effect of external forces over the short duration of the collision is usually quite small.</p>&#13;
<p class="indent">To confirm this conservation of system momentum, let’s write a function that computes percent change in system momentum. Since a list of states is a common information representation, we’ll use a finite list of multi-particle states for the input to this function, but we’ll only be comparing the first and last states in the list. Here is the function:</p>&#13;
<pre>percentChangePMag :: [MultiParticleState] -&gt; R&#13;
percentChangePMag mpsts&#13;
    = let p0 = systemP (head mpsts)&#13;
          p1 = systemP (last mpsts)&#13;
      in 100 * magnitude (p1 ^-^ p0) / magnitude p0</pre>&#13;
<p class="indent">We name the incoming list of multi-particle states <code>mpsts</code>, and we use the Prelude functions <code>head</code> and <code>last</code> to pick out the first and last states in the list, giving their system momenta the local names <code>p0</code> and <code>p1</code>, respectively. We proceed to take the difference between the final system momentum <code>p1</code> and the initial system momentum <code>p0</code>, form the magnitude of that momentum change vector, divide by the magnitude of the initial system momentum, and multiply by 100 to make a percentage.</p>&#13;
<h5 class="h5" id="ch20lev19">Creating Tables</h5>&#13;
<p class="noindent">To see how well system momentum is conserved in our calculations, let’s make a small table showing the percent change in system momentum for a few different time steps and a few different spring constants. The table will appear unwieldy if I allow the computer to display all 15 digits that it keeps around for double precision floating-point numbers (numbers of type <code>R</code> that we have been calling real numbers). The following <code>sigFigs</code> function rounds a number to a specified number of significant figures:</p>&#13;
<pre>sigFigs :: Int -&gt; R -&gt; Float&#13;
sigFigs n x = let expon :: Int&#13;
                  expon = floor (logBase 10 x) - n + 1&#13;
                  toInt :: R -&gt; Int&#13;
                  toInt = round&#13;
              in (10^^expon *) $ fromIntegral $ toInt (10^^(-expon) * x)</pre>&#13;
<p class="indent">This function works by dividing the input number <code>x</code> by 10<sup><em>m</em></sup> for some integer <em>m</em>, rounding the number, and then re-multiplying the number by 10<sup><em>m</em></sup>. The integer <em>m</em> is called <code>expon</code> in the code; its value depends on the number <code>n</code> of significant figures requested. The Prelude function <code>round</code> has a quite general type; I specialize it to my needs by defining a local function <code>toInt</code> with a simple, concrete type.</p>&#13;
<p class="indent">The final tool we need to make cute little tables, which we will use for momentum, energy, and a few other things, is a data type for tables with a <span epub:type="pagebreak" id="page_380"/><code>Show</code> instance that makes them appear in a nicely formatted way. First, we define a new data type <code>Table a</code>, which is a table of items of type <code>a</code>.</p>&#13;
<pre>data Justification = LJ | RJ deriving Show&#13;
&#13;
data Table a = Table Justification [[a]]</pre>&#13;
<p class="indent">The data type <code>Justification</code> is to specify whether we want a left-justified or right-justified table. A <code>Table a</code> contains a <code>Justification</code> along with a list of lists of items with type <code>a</code>.</p>&#13;
<p class="indent">We write an explicit show instance for the new data type that formats the output in a nice way.</p>&#13;
<pre>instance Show a =&gt; Show (Table a) where&#13;
    show (Table j xss)&#13;
        = let pairWithLength x = let str = show x in (str, length str)&#13;
              pairss = map (map pairWithLength) xss&#13;
              maxLength = maximum (map maximum (map (map snd) pairss))&#13;
              showPair (str,len)&#13;
                  = case j of&#13;
                      LJ -&gt; str ++ replicate (maxLength + 1 - len) ' '&#13;
                      RJ -&gt; replicate (maxLength + 1 - len) ' ' ++ str&#13;
              showLine pairs = concatMap showPair pairs ++ "\n"&#13;
          in init $ concatMap showLine pairss</pre>&#13;
<p class="indent">In the first line, we see a type class constraint; type <code>a</code> must be an instance of type class <code>Show</code> for <code>Table a</code> to be an instance of type class <code>Show</code>. An instance declaration for <code>Show</code> requires only that we define a function <code>show</code> that takes a <code>Table a</code> as input and produces a string as output. We define a local function <code>pairWithLength</code> that pairs the string representation of a value with the length of that string. We care about the length because we want to make columns that line up nicely. The local variable <code>pairss</code> is a list of lists of pairs of strings and lengths. The double <em>s</em> at the end of the name suggests a list of lists. We form <code>pairss</code> by mapping <code>map pairWithLength</code> onto the input list of lists, <code>xss</code>. Since each element of <code>xss</code> is a list, we apply <code>map pairWithLength</code> to each list in <code>xss</code>, so <code>pairWithLength</code> gets applied to each item in the list of lists.</p>&#13;
<p class="indent">The local variable <code>maxLength</code> finds the length of the longest item in the table. We then use this longest length to set the width of all the columns that will be displayed. We write local functions to show an individual item and a line of the table. Finally, we form the table by mapping <code>showLine</code> onto <code>pairss</code> and concatenating the results. If you find this trick for displaying tables interesting, by all means study it; otherwise, let’s move on and use it.</p>&#13;
<p class="indent">Here are tables that show the percent change in momentum for the Euler, Euler-Cromer, and fourth-order Runge-Kutta methods for several values of spring constant and time step:</p>&#13;
<pre>pTable :: (TimeStep -&gt; NumericalMethod MultiParticleState DMultiParticleState)&#13;
       -&gt; [R]         -- ks&#13;
       -&gt; [TimeStep]  -- dts&#13;
       <span epub:type="pagebreak" id="page_381"/>-&gt; Table Float&#13;
pTable nMethod ks dts&#13;
    = Table LJ [[sigFigs 2 $&#13;
                 percentChangePMag (billiardStatesFinite nMethod k dt)&#13;
                     | dt &lt;- dts] | k &lt;- ks]&#13;
&#13;
pTableEu :: [R]         -- ks&#13;
         -&gt; [TimeStep]  -- dts&#13;
         -&gt; Table Float&#13;
pTableEu = pTable euler</pre>&#13;
<p class="indent">We can view these tables in GHCi.</p>&#13;
<pre>Prelude Vis&gt;  <span class="codestrong1">:m</span>&#13;
Prelude&gt;  <span class="codestrong1">:l MOExamples</span>&#13;
[1 of 6] Compiling Newton2          ( Newton2.hs, interpreted )&#13;
[2 of 6] Compiling Mechanics1D      ( Mechanics1D.hs, interpreted )&#13;
[3 of 6] Compiling SimpleVec        ( SimpleVec.hs, interpreted )&#13;
[4 of 6] Compiling Mechanics3D      ( Mechanics3D.hs, interpreted )&#13;
[5 of 6] Compiling MultipleObjects  ( MultipleObjects.hs, interpreted )&#13;
[6 of 6] Compiling MOExamples       ( MOExamples.hs, interpreted )&#13;
Ok, six modules loaded.&#13;
*MOExamples&gt; <span class="codestrong1">pTable euler [10,30,100] [0.003,0.01,0.03,0.1]</span>&#13;
4.3e-14 0.0     0.0     0.0&#13;
0.0     0.0     0.0     0.0&#13;
2.2e-14 0.0     0.0     8.7e-14&#13;
*MOExamples&gt; <span class="codestrong1">pTable eulerCromerMPS [10,30,100] [0.003,0.01,0.03,0.1]</span>&#13;
0.0 0.0 0.0 0.0&#13;
0.0 0.0 0.0 0.0&#13;
0.0 0.0 0.0 0.0&#13;
*MOExamples&gt; <span class="codestrong1">pTable rungeKutta4 [10,30,100] [0.003,0.01,0.03,0.1]</span>&#13;
4.3e-14 2.2e-14 0.0     0.0&#13;
2.2e-14 0.0     2.2e-14 0.0&#13;
0.0     0.0     0.0     0.0</pre>&#13;
<p class="indent">Regardless of numerical method, spring constant, or time step, the percentage change in momentum is either 0 or something times 10<sup>–14</sup>. Since this is a percentage, we are really talking about a few parts in 10<sup>16</sup>, which is the accuracy of double-precision floating-point numbers. This deviation from 0 is not from the finite-step-size calculation we are doing; it’s because any calculation at all with floating-point numbers is approximate. The computer can’t divide by 10 exactly because it represents the fraction 1/10 with the repeating binary expansion 0.0001100110011 . . . (recall <a href="ch01.xhtml#ch1tab4">Table 1-4</a>). A few parts in 10<sup>16</sup> is the deviation from exactness we expect to see for any calculation that involves double-precision floating-point numbers.</p>&#13;
<p class="indent">With this understanding, these tables are showing us that system momentum is conserved for the billiard collision for any numerical method, any spring constant, and any step size. This is an example of the claim made <span epub:type="pagebreak" id="page_382"/>earlier that for any situation with only internal forces, system momentum is conserved regardless of numerical method, step size, or other parameters that describe the problem. Let’s now turn to look at the energy of a multi-particle system, which does not share this desirable property.</p>&#13;
<h5 class="h5" id="ch20lev20">Energy Conservation</h5>&#13;
<p class="noindent">With the exception of the short time in which the colliding objects are in contact with each other, the only form of energy present is the kinetic energy of the objects.</p>&#13;
<p class="indent">Let’s look at how system kinetic energy evolves in time for the billiard ball collision. During all of the time in which the collision is not occurring, kinetic energy will be conserved just fine because the velocities of the balls are not changing at all. During the short time in which the collision is occurring, some kinetic energy is transformed into elastic potential energy, held by our spring, before it is transformed back into kinetic energy. <a href="ch20.xhtml#ch20fig3">Figure 20-3</a> shows a graph of system kinetic energy versus time for the collision of two billiard balls.</p>&#13;
<div class="imagel" id="ch20fig3"><img src="Images/382fig01.jpg" alt="Image" width="525" height="393"/></div>&#13;
<p class="figcap"><em>Figure 20-3: System kinetic energy for two billiard balls colliding</em></p>&#13;
<p class="indent">We see that before the collision, which begins at a time of about 4.8 s, the system kinetic energy is conserved, as the incoming particle moves with a constant velocity. We see the expected dip in system kinetic energy as it is converted into elastic potential energy. The graph suggests that only about 40 percent of the system kinetic energy is so converted since it drops to about 1.9 mJ from its initial value of 3.2 mJ. As the spring expands from its state of maximal compression, elastic potential energy is converted back into kinetic energy, which remains constant after the collision.</p>&#13;
<p class="indent">In an elastic collision, the system kinetic energy after the collision should be the same as before the collision. We can see from the graph that system kinetic energy after the collision is close to, but not precisely, the same as <span epub:type="pagebreak" id="page_383"/>before. This difference is a result of the finite step size of our method, and it depends on numerical method, step size, and other parameters of the situation. We see from the graph that the Euler-Cromer and fourth-order Runge-Kutta methods produce slightly different results, including slightly different results for the final system kinetic energy.</p>&#13;
<p class="indent">The following code produced the graph in <a href="ch20.xhtml#ch20fig3">Figure 20-3</a>.</p>&#13;
<pre>systemKEWithTime :: IO ()&#13;
systemKEWithTime&#13;
    = let timeKEPairsEC&#13;
              = [(timeOf mpst, systemKE mpst)&#13;
                     | mpst &lt;- billiardStatesFinite eulerCromerMPS 30 0.03]&#13;
          timeKEPairsRK4&#13;
              = [(timeOf mpst, systemKE mpst)&#13;
                     | mpst &lt;- billiardStatesFinite rungeKutta4    30 0.03]&#13;
      in plotPaths [Key Nothing&#13;
                   ,Title "System Kinetic Energy versus Time"&#13;
                   ,XLabel "Time (s)"&#13;
                   ,YLabel "System Kinetic Energy (J)"&#13;
                   ,XRange (4,6)&#13;
                   ,PNG "SystemKE.png"&#13;
                   ,customLabel (4.1,0.0026) "dt = 0.03 s"&#13;
                   ,customLabel (4.1,0.0025) "k = 30 N/m"&#13;
                   ,customLabel (5.4,0.00329) "Euler-Cromer"&#13;
                   ,customLabel (5.4,0.00309) "Runge-Kutta 4"&#13;
                   ] [timeKEPairsEC,timeKEPairsRK4]</pre>&#13;
<p class="indent">Local variables <code>timeKEPairsEC</code> and <code>timeKEPairsRK4</code> hold lists of pairs of time and system kinetic energy for the Euler-Cromer and fourth-order Runge-Kutta methods. We then plot these lists of pairs using gnuplot’s <code>plotPaths</code> function.</p>&#13;
<h5 class="h5" id="ch20lev21">The Effect of the Step Size and Spring Constant on Kinetic Energy</h5>&#13;
<p class="noindent">System kinetic energy does not share the nice property of system momentum that guarantees its conservation regardless of step size. An accurate calculation of energy, like most physical quantities, requires a reasonably small step size. In fact, looking at how well system kinetic energy is conserved is a good way to determine whether we are using a step size that is small enough.</p>&#13;
<p class="indent">To study conservation of system kinetic energy for different step sizes and spring constants, let’s write a function that computes percent change in system kinetic energy. Since a list of states is a common information representation, we’ll use a finite list of multi-particle states for the input to this function, but we’ll only be comparing the first and last states in the list. Here is the function:</p>&#13;
<pre>percentChangeKE :: [MultiParticleState] -&gt; R&#13;
percentChangeKE mpsts&#13;
    = let ke0 = systemKE (head mpsts)<span epub:type="pagebreak" id="page_384"/>&#13;
          ke1 = systemKE (last mpsts)&#13;
      in 100 * (ke1 - ke0) / ke0</pre>&#13;
<p class="indent">We name the incoming list of multi-particle states <code>mpsts</code> and use the Prelude functions <code>head</code> and <code>last</code> to pick out the first and last states in the list, giving their system kinetic energies the local names <code>ke0</code> and <code>ke1</code>, respectively. We proceed to take the difference between the final system kinetic energy <code>ke1</code> and the initial system kinetic energy <code>ke0</code>, divide by the initial system kinetic energy, and multiply by 100 to make a percentage.</p>&#13;
<p class="indent">To explore conservation of kinetic energy, we’ll make some small tables showing the percent change in system kinetic energy for a few different time steps and a few different spring constants. The following <code>tenths</code> function rounds a number to one digit after the decimal point and helps to make a handsome table.</p>&#13;
<pre>tenths :: R -&gt; Float&#13;
tenths = let toInt :: R -&gt; Int&#13;
             toInt = round&#13;
         in (/ 10) . fromIntegral . toInt . (* 10)</pre>&#13;
<p class="indent">This function works by multiplying the input number <code>x</code> by 10, rounding the number, and then dividing the result by 10. The Prelude function <code>round</code> has a quite general type; I specialize it to my needs by defining a local function <code>toInt</code> with a simple, concrete type.</p>&#13;
<p class="indent">The function <code>keTable</code> produces a table of percent change in system kinetic energy when given a numerical method, a list of spring constants, and a list of time steps.</p>&#13;
<pre>keTable&#13;
    :: (TimeStep -&gt; NumericalMethod MultiParticleState DMultiParticleState)&#13;
    -&gt; [R]         -- ks&#13;
    -&gt; [TimeStep]  -- dts&#13;
    -&gt; Table Float&#13;
keTable nMethod ks dts&#13;
    = Table RJ [[tenths $&#13;
                 percentChangeKE (billiardStatesFinite nMethod k dt)&#13;
                     | dt &lt;- dts] | k &lt;- ks]</pre>&#13;
<p class="indent">We can view these tables in GHCi.</p>&#13;
<pre>*MOExamples&gt; <span class="codestrong1">keTable euler [10,30,100] [0.003,0.01,0.03,0.1]</span>&#13;
     4.2    15.9    68.7   705.7&#13;
     8.3    34.1   185.4  3117.9&#13;
    16.9    82.9   642.2 39907.1&#13;
*MOExamples&gt; <span class="codestrong1">keTable eulerCromerMPS [10,30,100] [0.003,0.01,0.03,0.1]</span>&#13;
    0.0    0.0   -0.3    6.2&#13;
    0.0    0.1    1.1  154.1&#13;
    0.0    0.3   -8.9 3705.2&#13;
    &#13;
<span epub:type="pagebreak" id="page_385"/>*MOExamples&gt; <span class="codestrong1">keTable rungeKutta4 [10,30,100] [0.003,0.01,0.03,0.1]</span>&#13;
   0.0   0.0   0.0  -2.8&#13;
   0.0  -0.1  -1.4 -14.6&#13;
   0.0  -0.5  -1.6  90.3</pre>&#13;
<p class="indent">Conservation is best in the upper-left corner of each table, where time step and spring constant are both small. It is not surprising that a smaller time step produces better results. A smaller spring constant causes the collision to last longer, taking place over a larger number of time steps. A calculation in which a collision takes place over only a handful of time steps is unlikely to be very accurate. On the other hand, a spring constant that is too small runs the risk of allowing the objects to get too close to each other. We take up this concern in the next section.</p>&#13;
<h4 class="h4" id="ch20lev22">Numerical Issues</h4>&#13;
<p class="noindent">We have suggested that an accurate calculation for a collision requires that multiple time steps take place during the collision. We have also noted that we don’t want the colliding objects to get too close to each other. These two desired properties for our calculation are in tension with each other because the first benefits from a small spring constant while the second benefits from a large spring constant. Let’s analyze these two desired properties in more detail.</p>&#13;
<h5 class="h5" id="ch20lev23">Time Steps During Collision</h5>&#13;
<p class="noindent">As mentioned earlier, if only a handful of time steps, or worse yet, only one or zero, elapse over the course of the collision, we are unlikely to get accurate results. This observation motivates us to ask how many time steps take place during the collision, or equivalently how many time steps occur with the balls within the threshold separation. The answer to this question depends on numerical method, spring constant, and time step. We’d like a large number of time steps (for example, at least 10).</p>&#13;
<p class="indent">The function <code>contactSteps</code> returns the number of time steps during which the balls are within their threshold separation of 6 cm. It takes a finite list of multi-particle states as input.</p>&#13;
<pre>contactSteps :: [MultiParticleState] -&gt; Int&#13;
contactSteps = length . takeWhile inContact . dropWhile (not . inContact)</pre>&#13;
<p class="indent">The function works by using <code>dropWhile</code> to discard the multi-particle states before there is contact between the balls; in other words, to discard the states before the balls come within 6 cm of each other. We use the <code>inContact</code> predicate, defined next, to decide whether, in a given multi-particle state, the balls are in contact, meaning that their centers are within 6 cm of each other. We then use <code>takeWhile</code> to keep the states in which the balls are in contact. Finally, we calculate the length of this list, which is the number of states, or time steps, in which the balls are in contact.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_386"/>The predicate <code>inContact</code> works by calculating the distance between the particle centers and comparing it to the threshold separation of twice the ball radius (6 cm).</p>&#13;
<pre>inContact :: MultiParticleState -&gt; Bool&#13;
inContact (MPS sts)&#13;
    = let r = magnitude $ posVec (sts !! 0) ^-^ posVec (sts !! 1)&#13;
      in r &lt; 2 * ballRadius</pre>&#13;
<p class="indent">The function <code>contactTable</code> returns this number of time steps in contact for a numerical method, a list of spring constants, and a list of time steps.</p>&#13;
<pre>contactTable&#13;
    :: (TimeStep -&gt; NumericalMethod MultiParticleState DMultiParticleState)&#13;
    -&gt; [R]         -- ks&#13;
    -&gt; [TimeStep]  -- dts&#13;
    -&gt; Table Int&#13;
contactTable nMethod ks dts&#13;
    = Table RJ [[contactSteps (billiardStatesFinite nMethod k dt)&#13;
                     | dt &lt;- dts] | k &lt;- ks]</pre>&#13;
<p class="indent">We use a list comprehension to form the list of lists that will get displayed as a table. Here are the results from GHCi:</p>&#13;
<pre>*MOExamples&gt; <span class="codestrong1">contactTable euler [10,30,100] [0.003,0.01,0.03,0.1]</span>&#13;
 89 27  9  3&#13;
 53 16  6  2&#13;
 29  9  3  2&#13;
*MOExamples&gt; <span class="codestrong1">contactTable eulerCromerMPS [10,30,100] [0.003,0.01,0.03,0.1]</span>&#13;
 89 27  9  2&#13;
 53 16  5  1&#13;
 29  9  3  1&#13;
*MOExamples&gt; <span class="codestrong1">contactTable rungeKutta4 [10,30,100] [0.003,0.01,0.03,0.1]</span>&#13;
 89 27  9  2&#13;
 53 16  5  1&#13;
 29  9  3  0</pre>&#13;
<p class="indent">There is not much difference among numerical methods. Regardless of numerical method, the best results appear in the upper-left corner of each table, where the spring constant and time step are both smallest. A small spring constant gives a loose (not stiff) spring, which compresses over a greater distance, allowing more time steps to take place during the collision.</p>&#13;
<p class="indent">Something may strike you as strange in the lower-right corner of the Runge-Kutta table, corresponding to <em>k</em> = 100 N/m and <em>dt</em> = 0.1 s. How is it possible that no times take place within the threshold distance? It is not because the time step is so large that the moving ball completely skips over the stationary ball without colliding. Rather, it is because a fourth-order Runge-Kutta step is made up of four substeps, using derivatives at four different places to compute a final change in values for the time step. When the two <span epub:type="pagebreak" id="page_387"/>balls are close but just outside the threshold separation, the Runge-Kutta step senses the repulsive force from one or more of the substeps. The spring constant is so large that a large repulsive force acts to repel the balls, and by the next actual time step, the balls have already repelled. So, the 0 listed in the table for number of time steps within the threshold separation is not so different from having one time step within the threshold; it’s not enough for an accurate calculation.</p>&#13;
<h5 class="h5" id="ch20lev24">Closest Separation</h5>&#13;
<p class="noindent">We don’t want the centers of the balls to get too close to each other. If we use a very small spring constant, the balls may compress until their centers coincide, or even move past each other. This is certainly not how billiard balls work. Billiard balls hardly compress at all, so to model them accurately requires a fairly large spring constant.</p>&#13;
<p class="indent">It is interesting and important to know how close the ball centers get to each other, so we can avoid choosing a spring constant that is too small. We wish to know the minimum separation of the balls, center to center, that occurs during the collision. The answer to this question depends on numerical method, spring constant, and time step.</p>&#13;
<p class="indent">The function <code>closest</code> returns the closest separation that the balls achieve during the collision. It takes a finite list of multi-particle states as input.</p>&#13;
<pre>closest :: [MultiParticleState] -&gt; R&#13;
closest = minimum . map separation</pre>&#13;
<p class="indent">All this function does is apply the <code>separation</code> function below to each multi-particle state in the finite list and calculate the minimum.</p>&#13;
<p class="indent">The <code>separation</code> function works by finding the displacement between ball centers and computing its magnitude.</p>&#13;
<pre>separation :: MultiParticleState -&gt; R&#13;
separation (MPS sts)&#13;
    = magnitude $ posVec (sts !! 0) ^-^ posVec (sts !! 1)</pre>&#13;
<p class="indent">The function <code>closestTable</code> returns a table of closest separations when given a numerical method, a list of spring constants, and a list of time steps.</p>&#13;
<pre>closestTable&#13;
    :: (TimeStep -&gt; NumericalMethod MultiParticleState DMultiParticleState)&#13;
    -&gt; [R]         -- ks&#13;
    -&gt; [TimeStep]  -- dts&#13;
    -&gt; Table Float&#13;
closestTable nMethod ks dts&#13;
    = Table RJ [[tenths $ (100*) $&#13;
                 closest (billiardStatesFinite nMethod k dt)&#13;
                     | dt &lt;- dts] | k &lt;- ks]</pre>&#13;
<p class="indent">We multiply by 100 to convert meters into centimeters, which are shown in the table.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_388"/>Here are the results from GHCi:</p>&#13;
<pre>*MOExamples&gt; <span class="codestrong1">closestTable euler [10,30,100] [0.003,0.01,0.03,0.1]</span>&#13;
 4.4 4.3 4.0 2.8&#13;
 5.0 4.9 4.6 2.8&#13;
 5.4 5.3 5.0 2.8&#13;
*MOExamples&gt; <span class="codestrong1">closestTable eulerCromerMPS [10,30,100] [0.003,0.01,0.03,0.1]</span>&#13;
 4.4 4.4 4.4 4.5&#13;
 5.1 5.1 5.0 4.5&#13;
 5.5 5.5 5.5 4.5&#13;
*MOExamples&gt; <span class="codestrong1">closestTable rungeKutta4 [10,30,100] [0.003,0.01,0.03,0.1]</span>&#13;
 4.4 4.4 4.4 4.7&#13;
 5.1 5.1 5.1 5.2&#13;
 5.5 5.5 5.5 6.3</pre>&#13;
<p class="indent">If our goal is to have minimal compression, resulting in a large closest separation, the lower-left corner of each table is where we want to be. This suggests a large spring constant.</p>&#13;
<p class="indent">We see, in the lower-right corner of the Runge-Kutta table, a closest distance of 6.3 cm, which seems impossible. How can the balls repel if they never get within the threshold separation? Again, the answer is that a time step of fourth-order Runge-Kutta is based on four substeps, some of which sample the repulsive force inside the threshold distance.</p>&#13;
<p class="indent">Suppose we desire parameters (spring constant and time step) that produce at least 10 time steps during the collision, allow a closest separation of no less than 5 cm, and conserve kinetic energy within one percent.</p>&#13;
<p class="indent">The Euler method is out. It doesn’t conserve kinetic energy to within one percent for any of the spring constants and time steps we sampled. Euler-Cromer could be used with <em>k</em> = 30 N/m and <em>dt</em> = 0.003 s or <em>dt</em> = 0.01 s, or with <em>k</em> = 100 N/m and <em>dt</em> = 0.003 s. Fourth-order Runge-Kutta could be used with the same parameters.</p>&#13;
<h4 class="h4" id="ch20lev25">Animated Results</h4>&#13;
<p class="noindent">We’d like to animate the collision of the billiard balls using gloss. We have already written a state-update function and an initial state. What remains is to write a display function, which we’ll do now.</p>&#13;
<pre>billiardPicture :: MultiParticleState -&gt; G.Picture&#13;
billiardPicture (MPS sts)&#13;
    = G.scale ppm ppm $ G.pictures [place st | st &lt;- sts]&#13;
      where&#13;
        ppm = 300  -- pixels per meter&#13;
        place st = G.translate (xSt st) (ySt st) blueBall&#13;
        xSt = realToFrac . xComp . posVec&#13;
        ySt = realToFrac . yComp . posVec&#13;
        blueBall = G.Color G.blue (disk $ realToFrac ballRadius)</pre>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_389"/>We use pattern matching on the input to give the name <code>sts</code> to the incoming list of single-particle states. This is a list with length 2 because there are two particles. Our display function uses the “scale the whole picture at the end” paradigm, using the <code>G.scale</code> function with the constant <code>ppm</code> as the number of pixels per meter for our one universal spatial scale factor. The pre-scaled picture is made with the <code>G.pictures</code> function, which combines a list of pictures, one for each ball. The list of pictures is formed using a list comprehension and the <code>place</code> function, to be defined in a few lines. This code could be used for a multi-particle system with any number of particles, as long as we are happy having each particle represented by a blue disk. (See Exercise 20.2 if you are offended by every particle being blue.)</p>&#13;
<p class="indent">The remainder of the <code>billiardPicture</code> display function consists of local constants and functions defined after the <code>where</code> keyword. Recall that <code>where</code>, like the <code>let</code>-<code>in</code> construction, allows us to define local variables; the local variables are used before the <code>where</code> keyword and defined after. The local variables in a <code>let</code>-<code>in</code> construction are defined before the <code>in</code> keyword and used after. The difference between the <code>let</code>-<code>in</code> construction and the <code>where</code> construction is similar to the difference between bottom-up thinking, where we define the smallest pieces first and build upward to the whole function, and top-down thinking, where we define the whole function first in terms of pieces we have not yet defined. Haskell supports and encourages both kinds of thinking by supplying these two constructions and allowing us to make definitions in terms of as-yet-undefined constants and functions.</p>&#13;
<p class="indent">The first local variable we define is the spatial scale factor <code>ppm</code>, which we set to 300 pixels per meter. Next, we define the local function <code>place</code>, which we have already used to translate a picture to the xy-coordinates specified in the position of the state. The function <code>place</code> uses the as-yet-undefined functions <code>xSt</code> and <code>ySt</code> to pull the coordinates out of a state, and the as-yet-undefined picture <code>blueBall</code> for a blue disk. The function <code>place</code> uses the <code>G.translate</code> function to translate the picture by the coordinates.</p>&#13;
<p class="indent">The local function <code>xSt</code> picks out the x-coordinate of position from the state and uses <code>realToFrac</code> to return a <code>Float</code>, which is the type that <code>G.translate</code> expects. The definition of <code>xSt</code> is written in point-free style, as a composition of three functions: <code>posVec</code>, which extracts the position from the state; <code>xComp</code>, which extracts the x-coordinate from the position; and <code>realToFrac</code>, which converts an <code>R</code> into a <code>Float</code>. The function <code>ySt</code> is just like <code>xSt</code> but for the y-coordinate. Finally, we define the local constant <code>blueBall</code> as a blue <code>disk</code> with radius <code>ballRadius</code>, which must get converted to a <code>Float</code> to match the expected input type of the <code>disk</code> function from <a href="ch17.xhtml">Chapter 17</a>.</p>&#13;
<p class="indent"><a href="ch20.xhtml#ch20list3">Listing 20-3</a> shows a stand-alone program that uses the <code>simulateGloss</code> function we wrote in <a href="ch16.xhtml">Chapter 16</a>. The stand-alone program consists of one definition: a main function called <code>main</code>.</p>&#13;
<pre id="ch20list3">{-# OPTIONS -Wall #-}&#13;
&#13;
import Mechanics3D ( simulateGloss )&#13;
import MultipleObjects (eulerCromerMPS )&#13;
&#13;
<span epub:type="pagebreak" id="page_390"/>import MOExamples ( billiardInitial, billiardPicture, billiardUpdate )&#13;
&#13;
main :: IO ()&#13;
main = simulateGloss 1 100 billiardInitial billiardPicture&#13;
       (billiardUpdate eulerCromerMPS 30)</pre>&#13;
<p class="listing"><em>Listing 20-3: Stand-alone program for a 2D animation of two billiard balls colliding</em></p>&#13;
<p class="indent">The <code>main</code> function uses the imported <code>simulateGloss</code> function to perform the animation. We choose a time-scale factor of 1 and an animate rate of 100 frames/second, giving a time step of 0.01 s. We choose a spring constant of 30 N/m. We import the initial state <code>billiardInitial</code>, the state-update function <code>billiardUpdate</code>, and the display function <code>billiardPicture</code> from the <code>MOExamples</code> module we have been writing in this chapter. When you run the animation, you’ll see one blue billiard ball moving to the right collide with a stationary blue billiard ball. The originally moving ball moves downward after the collision, while the originally stationary ball moves up and to the right.</p>&#13;
<h3 class="h3" id="ch20lev26">Wave on a Guitar String</h3>&#13;
<p class="noindent">In this section, we’ll model a wave on a guitar string. In particular, we’ll focus on the G string of a guitar. A typical G string has a mass of 0.8293 grams per meter. The distance from the neck of the guitar to the bottom, the two places where the string will stay fixed, is 65 cm. The fundamental vibration of the string, when played in an open position to make the note G, has a wavelength of 130 cm since the displacement of the string from equilibrium is a sine function that starts at 0 at the neck and returns to 0 at the bottom, completing only half a wavelength. Any open string on the guitar has 130 cm as the wavelength for its fundamental vibration.</p>&#13;
<p class="indent">We want a frequency of 196 Hz to make the note G. This is because convention dictates that frequencies of 55 Hz, 110 Hz, 220 Hz, 440 Hz, and 880 Hz each give some version of the note A. Doubling the frequency takes you to the same note, up one octave. The chromatic scale that people use has 12 “half steps” in one octave, or one doubling of the frequency. The note G is two half steps below A, so we must multiply the frequency of an A by 2<sup>–2/12</sup> to get the frequency of a G. For the guitar, we multiply 2<sup>–2/12</sup> by 220 Hz to get 196 Hz.</p>&#13;
<p class="indent">For any wave, wavelength <em>λ</em> and period <em>t</em> are related to wave speed <em>v</em> by</p>&#13;
<div class="imagec"><img src="Images/390equ01.jpg" alt="Image" width="49" height="44"/></div>&#13;
<p class="indent">This equation is easiest to understand for a traveling wave (that is, one in which a wave crest simply travels along at speed <em>v</em>). For a traveling wave, the crest passes through one wavelength of distance during each period of time, so its speed is its wavelength divided by its period, which is what the equation claims. Frequency <em>f</em> and period <em>t</em> are related by</p>&#13;
<div class="imagec"><img src="Images/390equ02.jpg" alt="Image" width="50" height="43"/></div>&#13;
<p class="noindent"><span epub:type="pagebreak" id="page_391"/>leading to the equation</p>&#13;
<p class="centere"><em>v</em> = <em>λf</em></p>&#13;
<p class="noindent">relating wave speed, wavelength, and frequency.</p>&#13;
<div class="note">&#13;
<p class="note-title"><span class="bg1">NOTE</span></p>&#13;
<p class="note-para"><em>Some people like to use the Greek letter <em>ν</em> (nu) for frequency, which allows them to respond to a common greeting with the following physics joke:</em></p>&#13;
<p class="note-parai"><strong><em>Friend:</em></strong> <em>What’s new? (nu?)</em></p>&#13;
<p class="note-parai"><strong><em>Jokester:</em></strong> <em>v over λ</em>!</p>&#13;
<p class="note-para"><em>Most people are unable to laugh outwardly at this joke, but surely they are laughing on the inside.</em></p>&#13;
</div>&#13;
<p class="indent">Since the two ends of a guitar string are fixed, the guitar string exhibits standing waves rather than traveling waves, but the equations just shown are still useful because the wave speed is related to the tension <em>F</em> in the string and the mass per unit length <em>μ</em> by</p>&#13;
<div class="imagec"><img src="Images/391equ01.jpg" alt="Image" width="70" height="63"/></div>&#13;
<p class="indent">When we tune the guitar, we change the tension, which changes the wave speed, which changes the frequency. Let’s calculate the tension we need to achieve a frequency of 196 Hz.</p>&#13;
<p class="indent">To achieve 196 Hz, we need a wave speed,</p>&#13;
<p class="centere"><em>v</em> = <em>λf</em> = (130 cm)(196 Hz) = 254.8 m/s</p>&#13;
<p class="noindent">which requires a tension:</p>&#13;
<p class="centere"><em>F</em> = <em>μv</em><sup>2</sup> = (0.8293 g/m)(254.8 m/s)<sup>2</sup> = 53.84 N</p>&#13;
<p class="indent">Thus, we need a tension of 53.84 N in the G string of our guitar.</p>&#13;
<h4 class="h4" id="ch20lev27">Forces</h4>&#13;
<p class="noindent">We will model the guitar string as 64 little point masses, spaced 1 cm from each other along the 65-cm length. Each mass is linked by springs to its two nearest neighbors. If we give each spring an equilibrium length of zero and a spring constant of 5384 N/m, each spring will produce a force of 53.84 N when it is extended by 1 cm, which is the distance between masses when the string is at rest. So, there will be 64 masses, 63 internal springs, and 2 external springs to connect to the two fixed ends at 0 cm and 65 cm. Here is the list of forces:</p>&#13;
<pre>-- 64 masses (0 to 63)&#13;
-- There are 63 internal springs, 2 external springs&#13;
forcesString :: [Force]&#13;
forcesString&#13;
    = [ExternalForce  0 (fixedLinearSpring 5384 0 (vec    0 0 0))&#13;
      ,ExternalForce 63 (fixedLinearSpring 5384 0 (vec 0.65 0 0))] ++&#13;
      [InternalForce n (n+1) (linearSpring 5384 0) | n &lt;- [0..62]]</pre>&#13;
<h4 class="h4" id="ch20lev28"><span epub:type="pagebreak" id="page_392"/>State-Update Function</h4>&#13;
<p class="noindent">To make an animation, we need a state-update function, and for that we must choose a numerical method. Either Euler-Cromer or fourth-order Runge-Kutta would do just fine. Here we choose Runge-Kutta because it’s slightly more accurate.</p>&#13;
<pre>stringUpdate :: TimeStep&#13;
             -&gt; MultiParticleState  -- old state&#13;
             -&gt; MultiParticleState  -- new state&#13;
stringUpdate dt = updateMPS (rungeKutta4 dt) forcesString</pre>&#13;
<h4 class="h4" id="ch20lev29">Initial State</h4>&#13;
<p class="noindent">We’ll need an initial state. In fact, it is interesting to explore several different initial states of the string. The function <code>stringInitialOvertone</code> produces an initial state in which the string lies in the xy-plane, not initially moving, with a sinusoidal pattern.</p>&#13;
<pre>stringInitialOvertone :: Int -&gt; MultiParticleState&#13;
stringInitialOvertone n&#13;
    = MPS [defaultParticleState&#13;
           { mass     = 0.8293e-3 * 0.65 / 64&#13;
           , posVec   = x *^ iHat ^+^ y *^ jHat&#13;
           , velocity = zeroV&#13;
           } | x &lt;- [0.01, 0.02 .. 0.64],&#13;
           let y = 0.005 * sin (fromIntegral n * pi * x / 0.65)]</pre>&#13;
<p class="indent">Using this function with an input of 1 produces the fundamental vibration we discussed earlier. <a href="ch20.xhtml#ch20fig4">Figure 20-4</a> demonstrates what <code>stringInitialOvertone 1</code> looks like.</p>&#13;
<div class="imagel" id="ch20fig4"><img src="Images/392fig01.jpg" alt="Image" width="498" height="369"/></div>&#13;
<p class="figcap"><em>Figure 20-4: Initial state for the fundamental mode of vibration for a guitar string, given by <span class="codeitalic1">stringInitialOvertone 1</span></em></p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_393"/>Higher numbers produce overtones that vibrate at higher frequencies. Using 2 will produce an overtone that vibrates at 392 Hz, while 3 will produce one that vibrates at 588 Hz. <a href="ch20.xhtml#ch20fig5">Figure 20-5</a> shows what <code>stringInitialOvertone 3</code> looks like.</p>&#13;
<div class="imagel" id="ch20fig5"><img src="Images/393fig01.jpg" alt="Image" width="656" height="487"/></div>&#13;
<p class="figcap"><em>Figure 20-5: Initial state for the second overtone of a guitar string, given by <span class="codeitalic1">stringInitialOvertone 3</span></em></p>&#13;
<p class="indent">The sound you hear from a guitar string is a mixture of the fundamental frequency along with overtones. The initial state <code>stringInitialPluck</code> is intended to approximate a pluck of the guitar string.</p>&#13;
<pre>stringInitialPluck :: MultiParticleState&#13;
stringInitialPluck = MPS [defaultParticleState&#13;
             { mass     = 0.8293e-3 * 0.65 / 64&#13;
             , posVec   = x *^ iHat ^+^ y *^ jHat&#13;
             , velocity = zeroV&#13;
             } | x &lt;- [0.01, 0.02 .. 0.64], let y = pluckEq x]&#13;
    where&#13;
      pluckEq :: R -&gt; R&#13;
      pluckEq x&#13;
          | x &lt;= 0.51  = 0.005 / (0.51 - 0.00) * (x - 0.00)&#13;
          | otherwise  = 0.005 / (0.51 - 0.65) * (x - 0.65)</pre>&#13;
<p class="indent">Suppose the pick touches the string 51 cm from the neck, in front of the hole in the guitar body. If the pick moves the string 5 mm at that point, the resulting string shape is given by <code>stringInitialPluck</code>, as shown in <a href="ch20.xhtml#ch20fig6">Figure 20-6</a>.</p>&#13;
<div class="imagel" id="ch20fig6"><img src="Images/394fig01.jpg" alt="Image" width="531" height="393"/></div>&#13;
<p class="figcap"><em>Figure 20-6: Initial state for a pluck of the guitar string, given by <span class="codeitalic1">string InitialPluck</span></em></p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_394"/>Exercise 20.10 asks you to write a function that produces an <em>xy</em> picture like this from a <code>MultiParticleState</code>.</p>&#13;
<h4 class="h4" id="ch20lev30">Stand-Alone Program</h4>&#13;
<p class="noindent"><a href="ch20.xhtml#ch20list4">Listing 20-4</a> shows a stand-alone program to make a 2D animation of the wave on a guitar string.</p>&#13;
<pre id="ch20list4">{-# OPTIONS -Wall #-}&#13;
&#13;
import SimpleVec ( zeroV, iHat, (*^), xComp, yComp )&#13;
import Mechanics3D ( ParticleState(..), simulateGloss )&#13;
import MultipleObjects ( MultiParticleState(..) )&#13;
import MOExamples&#13;
import Graphics.Gloss ( Picture(..), scale, blue )&#13;
&#13;
stringPicture :: MultiParticleState -&gt; Picture&#13;
stringPicture (MPS sts)&#13;
    = let rs = [zeroV] ++ [posVec st | st &lt;- sts] ++ [0.65 *^ iHat]&#13;
          xy r = (realToFrac $ xComp r, realToFrac $ yComp r)&#13;
          xys = map xy rs&#13;
          ppm = 400  -- pixels per meter&#13;
      in scale ppm (20*ppm) $ Color blue $ Line xys&#13;
&#13;
main :: IO ()&#13;
main = let initialState = stringInitialOvertone 3&#13;
       in simulateGloss 0.001 40 initialState stringPicture stringUpdate</pre>&#13;
<p class="listing"><em>Listing 20-4: Stand-alone program for a 2D animation of a guitar string</em></p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_395"/>We use a time-scale factor of 0.001, meaning that 1 ms of physical time corresponds to 1 s of animation time. The code in <a href="ch20.xhtml#ch20list4">Listing 20-4</a> uses the initial state <code>stringInitialOvertone 3</code>, but we could replace that initial state with <code>stringInitialOvertone 1</code> to animate the fundamental vibration or with <code>string</code> <code>InitialPluck</code> to animate the vibration resulting from a pluck. The fundamental frequency of 196 Hz represents a period of roughly 5 ms, so the fundamental vibration will take about 5 seconds of animation time to complete a period, while the overtone number 3 will take only 1.7 seconds of animation time to complete a period.</p>&#13;
<p class="indent">We use an animation rate of 40 frames/second, giving a time step of 25<em>μ</em>s. This choice is based on the important time scales of the problem. First, there is the period of the fundamental vibration, which is about 5 ms. The overtones have progressively shorter periods, namely</p>&#13;
<div class="imagec"><img src="Images/395equ01.jpg" alt="Image" width="245" height="45"/></div>&#13;
<p class="indent">Evidently, any finite time step we employ is going to lose some information about some of the higher overtones because their periods get arbitrarily small. (Our method of modeling the string with 64 masses also places limits on the number of overtones that can accurately be accounted for. Overtone number 200, for example, has about 100 crests and 100 troughs; we can’t possibly account for that if we’re only keeping track of the position of 64 masses.)</p>&#13;
<p class="indent">Besides the period of the fundamental vibration, one other time scale is very important to the vibrating string: the time it takes the wave to travel from one little mass to a neighboring mass. This time is given by the distance between masses divided by the wave speed.</p>&#13;
<div class="imagec"><img src="Images/395equ02.jpg" alt="Image" width="166" height="47"/></div>&#13;
<p class="indent">This time is about 40<em>μ</em>s, which is substantially shorter than the fundamental period.</p>&#13;
<p class="indent">There is a stability criterion for wave situations or any situation that has a spatial step size Δ<em>x</em> in which information travels at a finite velocity. That criterion says that the time step must be smaller than the time it takes information to travel one spatial step.</p>&#13;
<div class="imagec"><img src="Images/395equ03.jpg" alt="Image" width="74" height="44"/></div>&#13;
<p class="indent">More about this stability criterion can be found in [<strong><a href="bib.xhtml#bib18"><span class="green">18</span></a></strong>]. Using a time step above this threshold runs the risk of a numerical instability that produces nonsensical results. <a href="ch20.xhtml#ch20fig7">Figure 20-7</a> shows an example of numerical instability.</p>&#13;
<div class="imagel" id="ch20fig7"><img src="Images/396fig01.jpg" alt="Image" width="522" height="923"/></div>&#13;
<p class="figcap"><em>Figure 20-7: Example of numerical instability when the time step exceeds the time it takes information to travel between masses in the string. From top to bottom are three successive time steps.</em></p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_396"/><a href="ch20.xhtml#ch20fig7">Figure 20-7</a> shows the string for three successive time steps, numbers 10, 11, and 12, for a simulation with a time step of 100<em>μ</em>s, which is above the stability threshold. In just two time steps, the calculation goes from reasonable to ridiculous. The calculation with a 100-<em>μ</em>s time step is unstable. If we used this time step in an animation, the picture would rapidly become chaotic. I created the panels in <a href="ch20.xhtml#ch20fig7">Figure 20-7</a> with the commands</p>&#13;
<pre><span epub:type="pagebreak" id="page_397"/>mpsPos (iterate (stringUpdate 100e-6) (stringInitialOvertone 1) !! 10)&#13;
mpsPos (iterate (stringUpdate 100e-6) (stringInitialOvertone 1) !! 11)&#13;
mpsPos (iterate (stringUpdate 100e-6) (stringInitialOvertone 1) !! 12)</pre>&#13;
<p class="noindent">where <code>mpsPos</code> is the function you are asked to write in Exercise 20.10.</p>&#13;
<p class="indent">The time step must be smaller than 40<em>μ</em>s, which is why we chose 25<em>μ</em>s earlier.</p>&#13;
<h4 class="h4" id="ch20lev31">Asynchronous Animation</h4>&#13;
<p class="noindent">The animations for the guitar string produced by gloss and not-gloss are on the edge of my computer’s ability to carry out gracefully. After the animation runs for a little while, the frames seem to update less quickly, indicating that the computer is having trouble doing all of the calculations we are asking of it while at the same time displaying the results. As we ask more and more of the computer, there will come a time when it cannot do all of the calculations we want at a rate that would it allow it to display the results at the same time.</p>&#13;
<p class="indent">One solution for this situation is to use <em>asynchronous animation</em>, in which we do all of the calculations first and then sew the results together into a movie that we can watch later. <a href="ch20.xhtml#ch20list5">Listing 20-5</a> shows a stand-alone program that creates 1,000 PNG files, each showing a picture of the guitar string, spaced at 25-<em>μ</em>s intervals. These can be combined into an MP4 movie with an external program such as ffmpeg.</p>&#13;
<pre id="ch20list5">{-# OPTIONS -Wall #-}&#13;
&#13;
import SimpleVec ( R, zeroV, iHat, (*^), xComp, yComp )&#13;
import Mechanics3D ( ParticleState(..) )&#13;
import MultipleObjects ( MultiParticleState(..) )&#13;
import MOExamples&#13;
import Graphics.Gnuplot.Simple&#13;
&#13;
makePNG :: (Int,MultiParticleState) -&gt; IO ()&#13;
makePNG (n,MPS sts)&#13;
    = let rs = [zeroV] ++ [posVec st | st &lt;- sts] ++ [0.65 *^ iHat]&#13;
          xy r = (xComp r, yComp r)&#13;
          xys :: [(R,R)]&#13;
          xys = map xy rs&#13;
          threeDigitString = reverse $ take 3 $ reverse ("00" ++ show n)&#13;
          pngFilePath = "GnuplotWave" ++ threeDigitString ++ ".png"&#13;
      in plotPath [Title "Wave"&#13;
                  ,XLabel "Position (m)"&#13;
                  ,YLabel "Displacement (m)"&#13;
                  ,XRange (0,0.65)&#13;
                  ,YRange (-0.01,0.01)&#13;
                  <span epub:type="pagebreak" id="page_398"/>,PNG pngFilePath&#13;
                  ,Key Nothing&#13;
                  ] xys&#13;
&#13;
main :: IO ()&#13;
main = sequence_ $ map makePNG $ zip [0..999] $&#13;
       iterate (stringUpdate 25e-6) (stringInitialOvertone 3)</pre>&#13;
<p class="listing"><em>Listing 20-5: Stand-alone program for a 2D asynchronous animation of a flexible string</em></p>&#13;
<p class="indent">The function <code>makePNG</code> takes as input an integer and a multi-particle state and produces a PNG file showing the position of the string. The purpose of the integer is to label the output file; 0 produces the file <em>GnuplotWave000.png</em>, 8 produces the file <em>GnuplotWave008.png</em>, and 167 produces the file <em>Gnuplot Wave167.png</em>. Only integers between 0 and 999, inclusive, should be used with this function.</p>&#13;
<p class="indent">The function begins by naming the incoming integer <code>n</code> and, using pattern matching on the input, the incoming list of single-particle states <code>sts</code>. The function then defines several local variables in the <code>let</code> construction. The local variable <code>rs</code> is a list of 66 position vectors describing the position of the string. The list consists of the positions of the 64 little masses, augmented with the fixed positions of the string at each end. The local function <code>xy</code> produces an (x, y) pair from a position. The list <code>xys</code>, formed by mapping <code>xy</code> onto the list <code>rs</code> of positions, is the list of pairs we will ask gnuplot to plot.</p>&#13;
<p class="indent">The local string <code>threeDigitString</code> is a three-digit string based on the integer <code>n</code> given as input. The function works by using <code>show</code> to convert <code>n</code> to a string, prepending that string with zeros, and then taking the last three digits. We take the last three digits by reversing the string, taking the first three digits with <code>take 3</code>, and then reversing back. The <code>threeDigitString</code> is then used as part of the filename <code>pngFilePath</code>. In the body of the <code>let</code> construction, we use gnuplot’s <code>plotPath</code> function to plot the pairs <code>xys</code> that we defined earlier. Since we intend to animate the frames that gnuplot produces, it’s important that we specify the <code>XRange</code> and <code>YRange</code> attributes so that each frame has the same range.</p>&#13;
<p class="indent">Let’s turn our attention to the function <code>main</code>. We want to apply the function <code>makePNG</code> to each of 1,000 pairs of an integer with a multi-particle state. In an imperative language like Python, this would be an opportunity to use a loop. In a functional language like Haskell, this is an opportunity to use a list. The <code>main</code> function consists of several phrases separated by the function application operator <code>$</code>. Since this operator is right associative (recall <a href="ch01.xhtml#ch1tab2">Table 1-2</a>), it’s easiest to read the definition of <code>main</code> from right to left. The rightmost phrase,</p>&#13;
<pre>iterate (stringUpdate 25e-6) (stringInitialOvertone 3)</pre>&#13;
<p class="noindent">is an infinite list of multi-particle states, starting with overtone number 3, spaced 25<em>μ</em>s apart. Applying <code>zip [0..999]</code> to this infinite list produces a finite list, with each element being a pair of an integer and a multi-particle state. Applying <code>map makePNG</code> to this list of pairs produces a length-1,000 list with type <code>[IO ()]</code>. This is not the type we want the function <code>main</code> to have. We want <code>main</code> <span epub:type="pagebreak" id="page_399"/>to have type <code>IO ()</code>, which simply means that it does something. Haskell provides a function <code>sequence_</code> to convert a list of actions into a single action.</p>&#13;
<p class="indent">Here is the type of <code>sequence_</code>:</p>&#13;
<pre>*MOExamples&gt;  <span class="codestrong1">:t sequence_</span>&#13;
sequence_ :: (Foldable t, Monad m) =&gt; t (m a) -&gt; m ()</pre>&#13;
<p class="indent">We are using <code>sequence_</code> in a context where the <code>Foldable</code> thing is a list, the <code>Monad</code> is <code>IO</code>, and the type variable <code>a</code> is unit, so the concrete type for <code>sequence_</code> in our use is</p>&#13;
<pre>sequence_ :: [IO ()] -&gt; IO ()</pre>&#13;
<p class="noindent">which is just what we need to produce the correct type for <code>main</code>. The function <code>sequence_</code> assembles a list of actions into a single action by sequencing them. The following command asks the external program ffmpeg to combine all PNG files named <em>GnuplotWaveDDD.png</em>, where the capital Ds are digits. We ask for a frame rate of 40 frames/second. The final movie is called <em>GnuplotWave.mp4</em>.</p>&#13;
<pre>$ ffmpeg -framerate 40 -i GnuplotWave%03d.png GnuplotWave.mp4</pre>&#13;
<p class="indent">Note that the character after the percent sign is a zero and not the letter O. If you are using a Unix-like system, you can find documentation about ffmpeg, after you have installed it, with the command <code>man ffmpeg</code>.</p>&#13;
<p class="indent">When we are doing asynchronous animation, we specify the time step and the animation rate rather than the time-scale factor and the animation rate.</p>&#13;
<h3 class="h3" id="ch20lev32">Summary</h3>&#13;
<p class="noindent">In this chapter we examined three physical situations involving multiple interacting particles, applying the theory and ideas of <a href="ch19.xhtml">Chapter 19</a>. The first situation, with two masses and two springs, contains two particles and both internal and external forces.</p>&#13;
<p class="indent">Our second situation, a collision, has only internal forces and consequently conserves system momentum. We looked at conservation of momentum and energy in the context of the approximate numerical calculations we have been doing, and we found that momentum is conserved for all time steps, no matter how large. The collision also gave us an opportunity to look more deeply into numerical issues that affect the choice of technical parameters, such as the spring constant and time step.</p>&#13;
<p class="indent">Our third situation, the guitar string, involves many particles and suggests a transition into fields and waves. All along we have been discretizing time as a method to achieve practical results in mechanics problems; here, in using many particles to model a string, we are coming close to discretizing space as one would do to numerically solve field equations such as the Maxwell equations.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_400"/><a href="part02.xhtml">Part II</a> of this book has dealt with Newtonian mechanics. Starting with a single particle moving in one dimension, we have slowly and steadily introduced ideas and code to deal with more and more sophisticated situations in mechanics. We talked about which mechanics problems can be solved with algebra, which require integration from calculus, and which require differential equations. We developed some general-purpose ways of solving systems of differential equations, and we put them to use in the service of mechanics. We took advantage of Haskell’s type system to make simple data structures, like 3D vectors, to construct a sequence of information representations that lead from problem specification to problem solution, and to create a modular system in which it is easy to switch out one numerical method for another. We viewed Newton’s second law as the rule for constructing a differential equation from a list of forces. We built Newton’s third law into the infrastructure for interacting particles so it gets automatically applied to all of the internal forces acting in a multi-particle situation. I hope that I have convinced you that a functional language is a fruitful way to express the ideas of mechanics alongside the ideas required for solving problems in mechanics.</p>&#13;
<p class="indent">The next part of the book explores electromagnetic theory. It begins with a chapter about Coulomb’s law, which fits nicely into the framework of interacting particles we have developed. Coulomb’s law, like Newton’s law of universal gravity, is expressed as an internal force between two particles.</p>&#13;
<h3 class="h3" id="ch20lev33">Exercises</h3>&#13;
<p class="noindentts"><strong>Exercise 20.1.</strong> What is the type of local variable <code>v</code> in the function <code>kineticEnergy</code>? What is the type of local variable <code>v</code> in the function <code>momentum</code>?</p>&#13;
<p class="noindentts"><strong>Exercise 20.2.</strong> The <code>billiardPicture</code> display function we wrote will display any number of balls, but they are all blue. If you want an animation with billiard balls of different colors, you can modify the <code>billiardPicture</code> function to cycle through a list of colors.</p>&#13;
<p class="indent">Make a new function <code>billiardPictureColors</code> by starting with a copy of <code>billiardPicture</code> and making the following changes. First, replace the local name <code>blueBall</code> with a local function <code>coloredBall</code> that takes a color as input. Next, modify the local function <code>place</code> to take a color as a second argument and use the new <code>coloredBall</code> function instead of <code>blueBall</code>. Finally, replace the list comprehension <code>[place st | st &lt;- sts]</code> with</p>&#13;
<pre>(zipWith place sts (cycle [G.blue, G.red]))</pre>&#13;
<p class="indent">The latter will cycle through the colors blue and red. You can change this list to cycle through as many colors as you want.</p>&#13;
<p class="indent">Modify the main billiard collision program to use your new display function, <code>billiardPictureColors</code>, and check that it works.</p>&#13;
<p class="noindentts"><strong>Exercise 20.3.</strong> Using <a href="ch20.xhtml#ch20list3">Listing 20-3</a> as a starting point, animate a two-body gravitational system such as the sun and Earth. In place of <code>billiardForces</code>, write a list of forces called <code>sunEarthForces</code> that contains the only force present: <span epub:type="pagebreak" id="page_401"/>the universal gravity between the sun and Earth. In place of <code>billiardUpdate</code>, write an update function called <code>sunEarthUpdate</code>. In place of <code>billiardInitial</code>, write an initial state called <code>sunEarthInitial</code>, choosing appropriate values for the initial positions and velocities of the sun and Earth. In place of <code>billiard</code> <code>Picture</code>, write a display function called <code>sunEarthPicture</code>, making the sun yellow and Earth blue. You will not be able to display the size of the sun or Earth to scale with the orbital motion. Choose any convenient values for the object sizes. Choose a time-scale factor of <code>365*24*60</code> so that one year of physical time is one minute of animation time. Choose an animation rate of 60 frames/second. Confirm that the orbital period is approximately one year by observing that it takes one minute for the animated Earth to complete a revolution around the sun.</p>&#13;
<p class="noindentts"><strong>Exercise 20.4.</strong> In this problem, we investigate how Jupiter makes the sun wobble. We say that Jupiter orbits the sun because the sun is much more massive, but in a system consisting only of the sun and Jupiter, both objects orbit a point at the system’s center of mass. The center of mass is a weighted average of positions.</p>&#13;
<div class="imagec"><img src="Images/401equ01.jpg" alt="Image" width="161" height="51"/></div>&#13;
<p class="indent">The distance between the sun and Jupiter is about 8 × 10<sup>11</sup> m. The radius of the sun is 6.96 × 10<sup>8</sup> m. The mass of the sun is 1.99 × 10<sup>30</sup> kg. The mass of Jupiter is 1.90 × 10<sup>27</sup> kg.</p>&#13;
<p class="indent">Placing the sun at the origin in the equation above, and looking only at the radial component of the vectors, we find that the center of mass</p>&#13;
<div class="imagec"><img src="Images/401equ02.jpg" alt="Image" width="261" height="49"/></div>&#13;
<p class="noindentts">lies slightly outside the radius of the sun. We should be able to see the sun orbit about this center of mass in an animation.</p>&#13;
<p class="indent">Make an animation for the sun-Jupiter system using gloss or not-gloss. The only force is the universal gravity between the sun and Jupiter. Display the size of the sun to scale with the orbital motion, but zoom in on the sun, ignoring the display of Jupiter. If things go well, you should see the sun orbit a point slightly outside of its radius.</p>&#13;
<p class="indent">You do not need to include any of the center-of-mass calculations above to make this animation. However, for the center of mass to stay fixed, you will need to supply initial conditions that give zero momentum to the sun-Jupiter system. If you take the initial velocity of Jupiter to be in the y-direction, the sun will need to have a small initial velocity in the negative y-direction so that the total momentum is 0.</p>&#13;
<p class="indent">To obtain an initial velocity estimate for Jupiter, you may assume that Jupiter’s orbit is circular and that the radius of its orbit is the same as the sun-Jupiter distance. (This is only off by 0.1 percent.)</p>&#13;
<p class="noindentts"><strong>Exercise 20.5.</strong> Using realistic initial conditions, program an animation for the sun, Earth, and moon mutually interacting though gravity. The actual Earth-sun separation is about 500 times the Earth-moon separation, so <span epub:type="pagebreak" id="page_402"/>you won’t be able to resolve the Earth and moon as separate objects on the screen. To be able to see where the moon is relative to Earth, I suggest the following: instead of displaying the moon at the position you calculate, display the moon at a fake position that has the correct orientation but is 50 times as far from Earth as you calculate. An equation to use to calculate a fake moon position is</p>&#13;
<p class="centere"><strong>r</strong><sub>FM</sub> = <strong>r</strong><sub>E</sub> + <em>A</em>(<strong>r</strong><sub>M</sub> − <strong>r</strong><sub>E</sub>)</p>&#13;
<p class="noindentts">where <strong>r</strong><sub>FM</sub> is the position of the fake moon, <strong>r</strong><sub>M</sub> is the position of the (real) moon, <strong>r</strong><sub>E</sub> is the position of Earth, and <em>A</em> is a magnification factor that artificially magnifies the vector from Earth to moon for display purposes. Try <em>A</em> = 50 and see what happens. Note that the fake moon need only appear in the display function. This situation should involve three internal forces and no external forces.</p>&#13;
<p class="noindentts"><strong>Exercise 20.6.</strong> Using the <code>fixedLinearSpring</code> function, investigate a springy pendulum. Choose values for the spring constant <em>k</em>, the equilibrium length of the spring <em>r<sub>e</sub></em>, and the mass <em>m</em>.</p>&#13;
<p class="alphats">(a) Confirm, with an animation or a graph, that placing the mass a distance <em>r<sub>e</sub></em> + <em>mg</em>/<em>k</em> directly below the spot where the spring attaches to the ceiling, giving it no initial velocity, results in an equilibrium situation that allows the mass to hang motionless on the spring.</p>&#13;
<p class="alphats">(b) Choose an initial state in which the mass has no initial velocity and sits a distance <em>r<sub>e</sub></em> directly below the spot where the spring attaches to the ceiling. In this situation, the spring initially exerts no force on the mass, but gravity does exert a force. Confirm, with an animation or a graph, that the mass oscillates with an angular frequency <img class="inline" src="Images/402equ01.jpg" alt="Image" width="95" height="22"/>. This is equivalent to a period of <img class="inline" src="Images/402equ02.jpg" alt="Image" width="113" height="21"/>.</p>&#13;
<p class="alphats">(c) Investigate the horizontal oscillation of a pendulum by placing the mass, with no initial velocity, a distance <em>r<sub>e</sub></em> + <em>mg</em>/<em>k</em> from the ceiling attachment point, but not directly below that point. Allow the mass to evolve in time. Confirm, with an animation or a graph, that the angular frequency of oscillation is close to <img class="inline" src="Images/402equ03.jpg" alt="Image" width="86" height="27"/>, with <em>l</em> = <em>r<sub>e</sub></em> + <em>mg</em>/<em>k</em>, or, equivalently, that the period is <img class="inline" src="Images/402equ04.jpg" alt="Image" width="107" height="26"/>.</p>&#13;
<p class="alphats">(d) Find an initial position and velocity for the mass so that it undergoes horizontal circular motion.</p>&#13;
<p class="alphats">(e) If you now change the parameters so that</p>&#13;
<div class="imagec"><img src="Images/402equ05.jpg" alt="Image" width="59" height="43"/></div>&#13;
<p class="alphats-p">you may be able to find initial conditions in which the mass undergoes circular or elliptical motion in a vertical plane. See if this is possible.</p>&#13;
<p class="noindentts"><strong>Exercise 20.7.</strong> Consider two equal-mass billiard balls traveling toward each other with equal and opposite velocities. If they travel directly toward each other, say along the x-axis, the collision will be one dimensional. If, on the <span epub:type="pagebreak" id="page_403"/>other hand, their initial velocities are in the positive and negative x-direction, but there is a small y-component of displacement between them, the collision will be two dimensional. The angle at which the balls travel after the collision (which is the same for both balls because of the symmetry) depends on this initial y-component of displacement. There is some initial y-displacement that will produce a right angle. Find, by trial and error, this y-displacement for some spring constant and time step. It may not be what you expect. Try a different spring constant and/or time step. Can you explain why the y-displacement required to produce a right angle depends on the spring constant?</p>&#13;
<p class="noindentts"><strong>Exercise 20.8.</strong> Write an animation for the guitar string in which the string is modeled with 9 masses rather than 64. The distance between masses will be 6.5 cm rather than 1 cm. This increases the time-step stability threshold to 255<em>μ</em>s, so we can use a larger time step. We’re asking less of the computer, so the animation should run smoothly, even on older hardware. You’ll need to write new definitions for <code>forcesString</code>, <code>stringUpdate</code>, and <code>stringInitialOvertone</code>. The function <code>stringPicture</code> can remain the same. The spring constant for the springs will need to be different.</p>&#13;
<p class="noindentts"><strong>Exercise 20.9.</strong> To see what an animation looks like when a numerical instability occurs, modify the gloss animation of the guitar string so that the time step is 100<em>μ</em>s. You can do this by increasing the time-scale factor or by decreasing the animation rate.</p>&#13;
<p class="noindentts"><strong>Exercise 20.10.</strong> Write the functions</p>&#13;
<pre>mpsPos :: MultiParticleState -&gt; IO ()&#13;
mpsPos = undefined&#13;
&#13;
mpsVel :: MultiParticleState -&gt; IO ()&#13;
mpsVel = undefined</pre>&#13;
<p class="noindentts">that use gnuplot to graph the x- and y-components of position (for the first function) and velocity (for the second) for a multi-particle state as if it was a guitar string. Functions like these can help with debugging. You can use them to visualize what happens in the first several time steps, giving you clues to what might be wrong when things aren’t working.</p>&#13;
<p class="noindentts"><strong>Exercise 20.11.</strong> Write a 3D animation for the guitar string using <code>simulateVis</code>.</p>&#13;
<p class="noindentts"><strong>Exercise 20.12.</strong> Make a 3D animation of the guitar string in which the motion looks like that of a jump rope. You should be able to do this by changing the initial state so that the masses that make up the string have some initial velocity.</p>&#13;
<p class="noindentts"><strong>Exercise 20.13.</strong> Modify the function <code>makePNG</code> so that it uses four digits rather than three to label the output file. This allows for a longer animation of up to 10,000 frames. Test your function by making an animation of 2,000 frames.</p>&#13;
<p class="noindentts"><span epub:type="pagebreak" id="page_404"/><strong>Exercise 20.14.</strong> Write code to produce graphs like those in <a href="ch20.xhtml#ch20fig2">Figure 20-2</a>.</p>&#13;
<p class="noindentts"><strong>Exercise 20.15.</strong> Explore energy conservation for the guitar string. Mechanical energy should be conserved, but how well it is conserved depends on the time step. You will need to write an expression for the mechanical energy of this system.</p>&#13;
<p class="noindentts"><strong>Exercise 20.16.</strong> Most of our animated results up to now have been based on a state-update function and have used the <code>simulateGloss</code> or <code>simulateVis</code> functions. There is a way to animate a list of states, and we’ll explore that now. The functions <code>animateGloss</code> and <code>animateVis</code> that follow take as input a time-scale factor, a display function, and a list of states, and they produce an animation. The time step for the animation is obtained from the list of states. We do not specify an animation rate; that is calculated from the time-scale factor and time step.</p>&#13;
<pre>animateGloss :: HasTime s =&gt; R  -- time-scale factor&#13;
             -&gt; (s -&gt; G.Picture)&#13;
             -&gt; [s]&#13;
             -&gt; IO ()&#13;
animateGloss tsFactor displayFunc mpsts&#13;
    = let dtp = timeOf (mpsts !! 1) - timeOf (mpsts !! 0)&#13;
          n tp = round (tp / dtp)&#13;
          picFromAnimTime :: Float -&gt; G.Picture&#13;
          picFromAnimTime ta = displayFunc (mpsts !! n (tsFactor * realToFrac ta))&#13;
          displayMode = G.InWindow "My Window" (1000, 700) (10, 10)&#13;
      in G.animate displayMode G.black picFromAnimTime&#13;
     &#13;
animateVis :: HasTime s =&gt; R  -- time-scale factor&#13;
           -&gt; (s -&gt; V.VisObject R)&#13;
           -&gt; [s]&#13;
           -&gt; IO ()&#13;
animateVis tsFactor displayFunc mpsts&#13;
    = let dtp = timeOf (mpsts !! 1) - timeOf (mpsts !! 0)&#13;
          n tp = round (tp / dtp)&#13;
          picFromAnimTime :: Float -&gt; V.VisObject R&#13;
          picFromAnimTime ta = displayFunc (mpsts !! n (tsFactor * realToFrac ta))&#13;
      in V.animate V.defaultOpts (orient . picFromAnimTime)</pre>&#13;
<p class="indent"><a href="ch20.xhtml#ch20list6">Listing 20-6</a> is a stand-alone program using <code>animateGloss</code> to make the animation.</p>&#13;
<pre id="ch20list6">{-# OPTIONS -Wall #-}&#13;
&#13;
import MultipleObjects ( eulerCromerMPS )&#13;
import MOExamples&#13;
    ( animateGloss, billiardPicture, billiardStates )&#13;
&#13;
main :: IO ()&#13;
main = animateGloss 1 billiardPicture (billiardStates eulerCromerMPS 30 0.01)</pre>&#13;
<p class="listing"><em>Listing 20-6: Stand-alone program for a 2D animation of two billiard balls colliding</em></p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_405"/>Write a stand-alone program using <code>animateVis</code> to make the animation.</p>&#13;
<p class="noindentts"><strong>Exercise 20.17.</strong> The billiard collision we studied in this chapter is an elastic collision. Any collision in which the only force is <code>billiardForce</code> must be an elastic collision. How can we produce an inelastic collision? We need some sort of two-body force that can dissipate energy. The following two-body force can provide dissipation in a collision:</p>&#13;
<pre>dissipation :: R  -- damping constant&#13;
            -&gt; R  -- threshold center separation&#13;
            -&gt; TwoBodyForce&#13;
dissipation b re st1 st2&#13;
    = let r1 = posVec st1&#13;
          r2 = posVec st2&#13;
          v1 = velocity st1&#13;
          v2 = velocity st2&#13;
          r21 = r2 ^-^ r1&#13;
          v21 = v2 ^-^ v1&#13;
      in if magnitude r21 &gt;= re&#13;
         then zeroV&#13;
         else (-b) *^ v21</pre>&#13;
<p class="indent">When the distance between the particles is greater than or equal to the threshold separation, the particles feel no dissipation force. When the distance between the particles is less than the threshold separation, the particles feel a force proportional to the relative velocity in a direction that helps the relative velocity decrease in magnitude. Including this dissipation force along with <code>billiardForce</code> in the list of forces acting in a system results in an inelastic collision.</p>&#13;
<p class="indent">Revise the stand-alone program in <a href="ch20.xhtml#ch20list3">Listing 20-3</a> to produce an inelastic collision. A damping constant of 4 kg/s should produce a totally inelastic collision.</p>&#13;
<p class="indent">To confirm that this collision is inelastic, make a graph of mechanical energy as a function of time. Since a non-conservative force is present, mechanical energy will not be conserved. Mechanical energy should be conserved before the collision, drop rapidly during the collision, and then maintain at a lower value after the collision.<span epub:type="pagebreak" id="page_406"/></p>&#13;
</div></body></html>