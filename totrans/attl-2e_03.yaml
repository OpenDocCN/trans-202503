- en: '3'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: UNDERSTANDING THE GNU CODING STANDARDS
  prefs: []
  type: TYPE_NORMAL
- en: '*I don’t know what’s the matter with people: they don’t learn by understanding,
    they learn by some other way—by rote or something. Their knowledge is so fragile!'
  prefs: []
  type: TYPE_NORMAL
- en: —Richard Feynman*, “Surely You’re Joking, Mr. Feynman!”
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/common.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In [Chapter 2](ch02.xhtml), I gave an overview of the GNU Autotools and some
    resources that can help reduce the learning curve required to master them. In
    this chapter, we’re going to step back a little and examine project organization
    techniques that you can apply to any project, not just one that uses the Autotools.
  prefs: []
  type: TYPE_NORMAL
- en: When you’re done reading this chapter, you should be familiar with the common
    `make` targets and why they exist. You should also have a solid understanding
    of why projects are organized the way they are. You will, in fact, be well on
    your way to becoming an Autotools expert.
  prefs: []
  type: TYPE_NORMAL
- en: 'The information provided in this chapter comes primarily from two sources:'
  prefs: []
  type: TYPE_NORMAL
- en: The *GNU Coding Standards (GCS)*^([1](footnote.xhtml#ch03fn1))
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Filesystem Hierarchy Standard (FHS)*^([2](footnote.xhtml#ch03fn2))
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you’d like to brush up on your `make` syntax, you may also find the *GNU
    Make Manual* ^([3](footnote.xhtml#ch03fn3)) very useful. If you’re particularly
    interested in portable `make` syntax, then check out the POSIX man page for `make`.^([4](footnote.xhtml#ch03fn4))
    Note, however, there are current discussions on the Autotools mailing lists around
    making GNU `make` the target standard because it’s so widely available today.
    Therefore, portable `make` script isn’t as important as it used to be.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a New Project Directory Structure
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You need to ask yourself two questions when you’re setting up the build system
    for an open source software project:'
  prefs: []
  type: TYPE_NORMAL
- en: Which platforms will I target?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What do my users expect?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The first is an easy question—you get to decide which platforms to target, but
    you shouldn’t be too restrictive. Open source software projects are only as good
    as their communities, and arbitrarily limiting the number of platforms reduces
    the potential size of your community. However, you might consider supporting only
    current versions of your target platforms. You can check with user groups and
    communities to determine which versions of each are relevant.
  prefs: []
  type: TYPE_NORMAL
- en: The second question is more difficult to answer. First, let’s narrow the scope
    to something manageable. What you really need to ask is, *What do my users expect
    of my build system?* Experienced open source software developers become familiar
    with these expectations by downloading, unpacking, building, and installing hundreds
    of packages. Eventually, they come to know intuitively what users expect of a
    build system. But, even so, the processes of package configuration, build, and
    installation vary widely, so it’s difficult to define any solid norm.
  prefs: []
  type: TYPE_NORMAL
- en: Rather than taking a survey of every build system out there yourself, you can
    consult the Free Software Foundation (FSF), sponsor of the GNU project, which
    has done a lot of the legwork for you. The FSF provides some of the best definitive
    sources of information on free, open source software, including the *GCS*, which
    covers a wide variety of topics related to writing, publishing, and distributing
    free, open source software. Even many non-GNU open source software projects align
    themselves with the *GCS*. Why? Well, the FSF invented the concept of free software,
    and the ideas make sense, for the most part.^([5](footnote.xhtml#ch03fn5)) There
    are dozens of issues to consider when designing a system that manages packaging,
    building, and installing software, and the *GCS* takes most of them into account.
  prefs: []
  type: TYPE_NORMAL
- en: WHAT’S IN A NAME?
  prefs: []
  type: TYPE_NORMAL
- en: You probably know that open source software projects generally have quirky names—they
    might be named after some device, an invention, a Latin term, a past hero, an
    ancient god, or they might be named after some small, furry animal that has (vaguely)
    similar characteristics to the software. Some names are just made-up words or
    acronyms that are catchy and easy to pronounce. Another significant characteristic
    of a good project name is uniqueness—it’s important that your project be easy
    to distinguish from others. You also want your project name to be easy to distinguish
    from any other uses of the name in a search engine. Additionally, you should ensure
    that your project’s name does not have negative connotations in any language or
    culture.
  prefs: []
  type: TYPE_NORMAL
- en: Project Structure
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We’ll start with a basic sample project and build on it as we continue our
    exploration of source-level software distribution. We’ll call our project *Jupiter*
    and create a project directory structure using the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: We now have one source code directory called *src*, one C source file called
    *main.c*, and a makefile for each of the two directories in our project. Minimal,
    yes, but this is a new endeavor and the key to a successful open source software
    project is evolution. Start small and grow as needed—and as you have the time
    and inclination.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s start by adding support for building and cleaning our project. We’ll need
    to add other important capabilities to our build system later on, but these two
    will get us going. The top-level makefile does very little at this point; it merely
    passes requests down to *src/Makefile*, recursively. This constitutes a fairly
    common type of build system, known as a *recursive build system*, so named because
    makefiles recursively invoke `make` on subdirectory makefiles.^([6](footnote.xhtml#ch03fn6))
    We’ll spend a little time at the end of this chapter considering how to convert
    our recursive system into a nonrecursive system.
  prefs: []
  type: TYPE_NORMAL
- en: '[Listings 3-1](ch03.xhtml#ch03ex01) through [3-3](ch03.xhtml#ch03ex03) show
    the contents of each of these three files, thus far.'
  prefs: []
  type: TYPE_NORMAL
- en: Git tag 3.0
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 3-1: Makefile: An initial draft of a top-level makefile for Jupiter*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 3-2:* src/Makefile: *The first draft of Jupiter’s src directory makefile*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 3-3:* src/main.c: *The first version of the only C source file in
    the Jupiter project*'
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*As you read this code, you will probably notice places where a makefile or
    a source code file contains a construct that is not written in the simplest manner
    or is perhaps not written the way you would have chosen to write it. There is
    a method to my madness: I’ve tried to use constructs that are portable to many
    flavors of the *`make`* utility.*'
  prefs: []
  type: TYPE_NORMAL
- en: Now let’s discuss the basics of `make`. If you’re already pretty well versed
    in it, you can skip the next section. Otherwise, give it a quick read, and we’ll
    return our attention to the Jupiter project later in the chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Makefile Basics
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'If you don’t use `make` on a regular basis, it’s often difficult to remember
    exactly what goes where in a makefile, so here are a few things to keep in mind.
    Besides comments, which begin with a hash mark (`#`), there are only two basic
    types of entities in a makefile:'
  prefs: []
  type: TYPE_NORMAL
- en: Rule definitions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Variable assignments
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: While there are several other types of constructs in a makefile (including conditional
    statements, directives, extension rules, pattern rules, function variables, and
    include statements, among others), for our purposes, we’ll just touch lightly
    on them as needed instead of covering them all in detail. This doesn’t mean they’re
    unimportant. On the contrary, they’re very useful if you’re going to write your
    own complex build system by hand. However, our purpose is to gain the background
    necessary for understanding the GNU Autotools, so I’ll only cover the aspects
    of `make` you need to know to accomplish that goal.
  prefs: []
  type: TYPE_NORMAL
- en: If you want a broader education on `make` syntax, refer to the *GNU Make Manual*.
    For strictly portable syntax, the POSIX man page for `make` is an excellent reference.
    If you want to become a `make` expert, be prepared to spend a good deal of time
    studying these resources—there’s much more to the `make` utility than is initially
    apparent.
  prefs: []
  type: TYPE_NORMAL
- en: '*Rules*'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Rules follow the general format shown in [Listing 3-4](ch03.xhtml#ch03ex04).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 3-4: The syntax of a rule within a makefile*'
  prefs: []
  type: TYPE_NORMAL
- en: In this syntax definition, square brackets (`[` and `]`) denote optional portions
    of a rule and `<tab>` represents a tab (ctrl-i) character.
  prefs: []
  type: TYPE_NORMAL
- en: Except for the tab characters and the line feeds, all other whitespace is optional
    and ignored. When a line in a makefile begins with a tab character, `make` generally
    considers it a command (with the exception of continuation lines, discussed later).
    Indeed, one of the most frustrating aspects of makefile syntax to neophytes and
    experts alike is that commands must be prefixed with an essentially invisible
    character. The error messages generated by the legacy UNIX `make` utility when
    a required tab is missing (or has been converted to spaces by your editor), or
    when an unintentional tab is inserted at the start of a line that follows something
    that could be interpreted as a rule, are obscure at best. GNU `make` does a better
    job with such error messages. Nonetheless, be careful to use leading tab characters
    properly in your makefiles—always and only before commands.^([7](footnote.xhtml#ch03fn7))
  prefs: []
  type: TYPE_NORMAL
- en: Note that almost everything in a rule is optional; the only required aspect
    of a rule is the *`targets`* portion and its colon (`:`) character. Use of the
    first command, *`command-0`* and its preceding semicolon (`;`), is an optional
    form that’s generally discouraged by the Autotools, but is perfectly legitimate
    `make` syntax if you have a single command to execute. You may even combine *`command-0`*
    with additional commands, but this almost never done.
  prefs: []
  type: TYPE_NORMAL
- en: In general, *targets* are objects that need to be built, and *dependencies*
    are objects that provide source material for targets. Thus, targets are said to
    depend upon the dependencies. Dependencies are essentially *prerequisites* of
    the targets, and therefore they should be updated first.^([8](footnote.xhtml#ch03fn8))
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 3-5](ch03.xhtml#ch03ex05) shows the general layout of a makefile.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 3-5: The general layout of a makefile*'
  prefs: []
  type: TYPE_NORMAL
- en: The contents of a makefile comprise a *declarative language* wherein you define
    a set of desired goals and `make` decides the best way to accomplish those goals.
    The `make` utility is a rule-based command engine, and the rules at work indicate
    which commands should be executed and when. When you define commands within rules,
    you’re telling `make` that you want it to execute each of the following statements
    from a shell whenever the preceding target should be built. Presumably, the commands
    actually do create or update the target. The existence and timestamps of the files
    mentioned in the targets and dependencies of rules indicate whether the commands
    should be executed and in what order.
  prefs: []
  type: TYPE_NORMAL
- en: As `make` processes the text in a makefile, it builds a web of dependency chains
    (technically called a *directed acyclic graph*, or *DAG*). When building a particular
    target, `make` must walk backward through the entire graph to the beginning of
    each “chain.” While traversing a chain, `make` executes the commands for each
    rule, beginning with the rule farthest from the target and working forward to
    the rule for the desired target. As `make` discovers targets that are older than
    their dependencies, it must execute the associated set of commands to update those
    targets before it can process the next rule in the chain. As long as the rules
    are written correctly, this algorithm ensures that `make` will build a completely
    up-to-date product using the least number of operations possible. Indeed, as we’ll
    see shortly, when the rules in a makefile are written properly, it’s rather a
    joy to watch it run after various changes to files in the project.
  prefs: []
  type: TYPE_NORMAL
- en: '*Variables*'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Lines in a makefile containing an equal sign (`=`) are variable definitions.
    Variables in makefiles are somewhat similar to shell or environment variables,
    but there are some key differences.
  prefs: []
  type: TYPE_NORMAL
- en: 'In Bourne-shell syntax, you’d reference a variable in this manner: `${my_var}`.
    Equally viable, without the curly brackets, is `$my_var`. The syntax for referencing
    variables in a makefile is nearly identical, except that you have the choice of
    using curly brackets or parentheses: `$(my_var)`. To minimize confusion, it has
    become somewhat of a convention to use parentheses rather than curly brackets
    when dereferencing `make` variables. For single-character `make` variables, using
    these delimiters is optional, but you should use them in order to avoid ambiguity.
    For example, `$X` is functionally equivalent to `$(X)` or `${X}`, but `$(my_var)`
    would require parentheses so `make` does not interpret the reference as `$(m)y_var`.'
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*To dereference a shell variable inside a *`make`* command, escape the dollar
    sign by doubling it—for example, *`$${shell_var}`*. Escaping the dollar sign tells
    *`make`* not to interpret the variable reference but rather to treat it as literal
    text in the command. The variable reference is thus left to be interpolated by
    the shell when the command is executed.*'
  prefs: []
  type: TYPE_NORMAL
- en: By default, *`make`* reads the process environment into its variable table before
    processing the makefile; this allows you to access most environment variables
    without explicitly defining them in the makefile. Note, however, that variables
    set inside the makefile will override those obtained from the environment.^([9](footnote.xhtml#ch03fn9))
    It’s generally not a good idea to depend on the existence of environment variables
    in your build process, although it’s okay to use them conditionally. In addition,
    `make` defines several useful variables of its own, such as the `MAKE` variable,
    the value of which is the command used to invoke `make` for the current process.
  prefs: []
  type: TYPE_NORMAL
- en: You can assign variables at any point in the makefile. However, you should be
    aware that `make` processes a makefile in two passes. In the first pass, it gathers
    variables and rules into tables and internal structures. In the second pass, it
    resolves dependencies defined by the rules, invoking those rules as necessary
    to rebuild the dependencies based on the filesystem timestamps gathered during
    the first pass. If a dependency in a rule is newer than the target or if the target
    is missing, then `make` executes the commands of the rule to update the target.
    Some variable references are resolved immediately during the first pass while
    processing rules, and others are resolved later during the second pass while executing
    commands.
  prefs: []
  type: TYPE_NORMAL
- en: '*A Separate Shell for Each Command*'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: As it processes rules, `make` executes each command independently of those around
    it. That is, each individual command under a rule is executed in its own shell.
    This means that you cannot export a shell variable in one command and then try
    to access its value in the next.
  prefs: []
  type: TYPE_NORMAL
- en: To do something like this, you would have to string commands together on the
    same command line with command separator characters (for example, semicolons in
    Bourne-shell syntax). When you write commands like this, `make` passes the set
    of concatenated commands as one command line to the same shell. To avoid long
    command lines and increase readability, you can wrap them using a backslash at
    the end of each line—by convention, after the semicolon.^([10](footnote.xhtml#ch03fn10))
    The wrapped portion of such commands may also be preceded by a tab character.
    POSIX specifies that `make` remove all leading tab characters (even those following
    escaped newlines) before processing commands, but be aware that some implementations
    of `make` do output—usually harmlessly—the tab characters embedded within wrapped
    commands.^([11](footnote.xhtml#ch03fn11))
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 3-6](ch03.xhtml#ch03ex06) shows a few simple examples of multiple
    commands that will be executed by the same shell.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 3-6: A makefile with some examples of multiple commands executed by
    the same shell*'
  prefs: []
  type: TYPE_NORMAL
- en: In the first example at ➊, both lines are executed by the same shell because
    the backslash escapes the newline character between the lines. The `make` utility
    will remove any escaped newline characters before passing a single, multi-command
    statement to the shell. The second example at ➋ is identical to the first, from
    `make`’s perspective.
  prefs: []
  type: TYPE_NORMAL
- en: The third example at ➌ is a bit different. In this case, I’ve defined the `TMPDIR`
    variable only for the child process that will run `gcc`.^([12](footnote.xhtml#ch03fn12))
    Note the missing semicolon; as far as the shell is concerned, this is a single
    command.^([13](footnote.xhtml#ch03fn13))
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*If you choose to wrap commands with a trailing backslash, be sure that there
    are no spaces or other invisible characters after it. The backslash escapes the
    newline character, so it must immediately precede that character.*'
  prefs: []
  type: TYPE_NORMAL
- en: '*Variable Binding*'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Variables referenced in commands may be defined after the command in the makefile
    because such references are not bound to their values until just before `make`
    passes the command to the shell for execution—long after the entire makefile has
    been read. In general, `make` binds variables to values as late as it possibly
    can.
  prefs: []
  type: TYPE_NORMAL
- en: Since commands are processed at a later stage than rules, variable references
    in commands are bound later than those in rules. Variable references found in
    rules are expanded when `make` builds the directed graph from the rules in the
    makefile. Thus, a variable referenced in a rule must be fully defined in a makefile
    before the referencing rule. [Listing 3-7](ch03.xhtml#ch03ex07) shows a portion
    of a makefile that illustrates both of these concepts.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 3-7: Variable expansion in a makefile*'
  prefs: []
  type: TYPE_NORMAL
- en: In the rule at ➊, both references to `$(mytarget)` are expanded to `foo` because
    they’re processed during the first pass, when `make` is building the variable
    list and directed graph. However, the outcome is probably not what you’d expect,
    because both references to `$(mytarget)` in the command at ➋ are not expanded
    until much later, long after `make` has already assigned `bar` to `mytarget`,
    overwriting the original assignment of `foo`.
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 3-8](ch03.xhtml#ch03ex08) shows the same rule and command the way
    `make` sees them after the variables are fully expanded.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 3-8: The results after variable expansion of the code in [Listing
    3-7](ch03.xhtml#ch03ex07)*'
  prefs: []
  type: TYPE_NORMAL
- en: The moral of this story is that you should understand where variables will be
    expanded in makefile constructs so you’re not surprised when `make` refuses to
    act in a sane manner when it processes your makefile. It is good practice (and
    a good way to avoid headaches) to always assign variables before you intend to
    use them. For more information on immediate and deferred expansion of variables
    in makefiles, refer to “How make Reads a Makefile” in the *GNU Make Manual*.
  prefs: []
  type: TYPE_NORMAL
- en: '*Rules in Detail*'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The rules used in my examples, known as *common* `make` rules, contain a single
    colon character (`:`). The colon separates targets on the left from dependencies
    on the right.
  prefs: []
  type: TYPE_NORMAL
- en: Remember that targets are products—that is, filesystem entities that can be
    produced by running one or more commands, such as a C or C++ compiler, a linker,
    or a documentation generator like Doxygen or LaTeX. Dependencies, on the other
    hand, are source objects, or objects from which targets are created. These may
    be computer language source files, intermediate products built by a previous rule,
    or anything else that can be used by a command as a resource.
  prefs: []
  type: TYPE_NORMAL
- en: You can specify any target defined within a makefile rule directly on the `make`
    command line, and `make` will execute all the commands necessary to generate that
    target.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*If you don’t specify any targets on the *`make`* command line, *`make`* will
    use the default target—the first one it finds in the makefile.*'
  prefs: []
  type: TYPE_NORMAL
- en: For example, a C compiler takes dependency *main.c* as input and generates target
    *main.o*. A linker then takes dependency *main.o* as input and generates a named
    executable target—`program`, in this case.
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 3-1](ch03.xhtml#ch03fig01) shows the flow of data as it might be specified
    by the rules defined in a makefile.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/03fig01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 3-1: A data flow diagram for the compile and link processes*'
  prefs: []
  type: TYPE_NORMAL
- en: The `make` utility implements some fairly complex logic to determine when a
    rule should be run, based on whether a target exists and whether it is older than
    its dependencies. [Listing 3-9](ch03.xhtml#ch03ex09) shows a makefile containing
    rules, some of which execute the actions in [Figure 3-1](ch03.xhtml#ch03fig01).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 3-9: Using multiple `make` rules to compile and link a program*'
  prefs: []
  type: TYPE_NORMAL
- en: The first rule in this makefile says that `program` depends on *main.o*, *print.o*,
    and *display.o*. The remaining rules say that each *.o* file depends on the corresponding
    *.c* file. Ultimately, `program` depends on the three source files, but the object
    files are necessary as intermediate dependencies because there are two steps to
    the process—compile and link—with a result in between. For each rule, `make` uses
    an associated list of commands to build the rule’s target from its list of dependencies.
  prefs: []
  type: TYPE_NORMAL
- en: Unix compilers are designed as higher-level tools than linkers. They have built-in,
    low-level knowledge about system-specific linker requirements. In the makefile
    in [Listing 3-9](ch03.xhtml#ch03ex09), the ellipsis in the line at ➊ is a placeholder
    for a list of system-specific, low-level objects and libraries required to build
    all programs on this system. The compiler can be used to call the linker, silently
    passing these system-specific objects and libraries. (It’s so effective and widely
    used that it’s often difficult to discover how to manually execute the linker
    on a given system.) [Listing 3-10](ch03.xhtml#ch03ex10) shows how you might rewrite
    the makefile from [Listing 3-9](ch03.xhtml#ch03ex09) to use the compiler to compile
    the sources and call the linker in a single rule.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 3-10: Using a single `make` rule to compile sources into an executable*'
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Using a single rule and command to process both steps is possible in this
    case because the example is very basic. For larger projects, skipping from source
    to executable in a single step is usually not the wisest way to manage the build
    process. However, in either case, using the compiler to call the linker can ease
    the burden of determining the many system objects that need to be linked into
    an application, and, in fact, this very technique is used quite often. More complex
    examples, wherein each file is compiled separately, use the compiler to compile
    each source file into an object file and then use the compiler to call the linker
    to link them all together into an executable.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'In this example, I’ve added a `make` variable (`sources`) that allows us to
    consolidate all product dependencies into one location. We now have a list of
    source files captured in a variable definition that is referenced in two places:
    in the dependency list and on the command line.'
  prefs: []
  type: TYPE_NORMAL
- en: Automatic Variables
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: There may be other kinds of objects in a dependency list that are not in the
    `sources` variable, including precompiled objects and libraries. These other objects
    would have to be listed separately, both in the rule and on the command line.
    Wouldn’t it be nice if we had a shorthand notation for referencing the rule’s
    entire dependency list in the commands?
  prefs: []
  type: TYPE_NORMAL
- en: 'As it happens, various *automatic* variables can be used to reference portions
    of the controlling rule during the execution of a command. Unfortunately, most
    of these are all but useless if you care about portability between implementations
    of `make`. The `$@` variable (which references the current target) happens to
    be portable and useful, but most of the other automatic variables are too limited
    to be very useful.^([14](footnote.xhtml#ch03fn14)) The following is a complete
    list of portable automatic variables defined by POSIX for `make`:'
  prefs: []
  type: TYPE_NORMAL
- en: '`$@` refers to the full target name of the current target or the archive filename
    part of a library archive target. This variable is valid in both explicit and
    implicit rules.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`$%` refers to a member of an archive and is valid only when the current target
    is an archive member—that is, an object file that is a member of a static library.
    This variable is valid in both explicit and implicit rules.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`$?` refers to the list of dependencies that are newer than the current target.
    This variable is valid in both explicit and implicit rules.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`$<` refers to the member of the dependency list whose existence allowed the
    rule to be chosen for the target. This variable is only valid in implicit rules.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`$*` refers to the current target name with its suffix deleted. This variable
    is guaranteed by POSIX to be valid only in implicit rules.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: GNU `make` dramatically extends the POSIX-defined list, but since GNU extensions
    are not portable, it’s unwise to use any of these except `$@`.
  prefs: []
  type: TYPE_NORMAL
- en: Dependency Rules
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Let us now assume that *print.c* and *display.c* each have a header file of
    the same name, ending in *.h*. Each of these source files includes its own header
    file, but *main.c* includes both *print.h* and *display.h*. Given the makefiles
    of [Listings 3-9](ch03.xhtml#ch03ex09) and [3-10](ch03.xhtml#ch03ex10), what do
    you suppose would happen if you executed `make` to build `program`, then modified
    one of the header files—say *print.h*—and then re-executed `make`? Nothing would
    happen because `make` is unaware even of the existence of these header files.
    As far as `make` is concerned, you didn’t touch anything related to `program`.
  prefs: []
  type: TYPE_NORMAL
- en: In [Listing 3-11](ch03.xhtml#ch03ex11), I’ve replaced the `sources` variable
    with an `objects` variable and replaced the list of source files with a list of
    object files. This version of the makefile in [Listing 3-10](ch03.xhtml#ch03ex10)
    also eliminates redundancy by making use of both standard and automatic variables.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 3-11: Using automatic variables in a command*'
  prefs: []
  type: TYPE_NORMAL
- en: I’ve also added three *dependency rules*, which are rules without commands that
    clarify the relationships between compiler output files and dependent source and
    header files. Because *print.h* and *display.h* are (presumably) included by *main.c*,
    *main.c* must be recompiled if either of those files changes; however, `make`
    has no way of knowing that these two header files are included by *main.c*. Dependency
    rules allow the developer to tell `make` about such backend relationships.
  prefs: []
  type: TYPE_NORMAL
- en: Implicit Rules
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: If you attempt to mentally follow the dependency graph that `make` would build
    from the rules within the makefile in [Listing 3-11](ch03.xhtml#ch03ex11), you’ll
    find what appears to be a hole in the web. According to the last rule in the file,
    the `program` executable depends on *main.o*, *print.o*, and *display.o*. This
    rule also provides the command to link these objects into an executable (using
    the compiler merely to call the linker this time). The object files are tied to
    their corresponding C source and header files by the three dependency rules. But
    where are the commands that compile the *.c* files into *.o* files?
  prefs: []
  type: TYPE_NORMAL
- en: We could add these commands to the dependency rules, but there’s really no need
    because `make` has a *built-in* rule that knows how to build *.o* files from *.c*
    files. There’s nothing magic about `make`—it only knows about the relationships
    you describe to it through the rules you write. But `make` does have certain built-in
    rules that describe the relationships between, for example, *.c* files and *.o*
    files. This particular built-in rule provides commands for building anything with
    a *.o* extension from a file of the same base name with a *.c* extension. These
    built-in rules are called *suffix rules* or, more generally, *implicit rules*,
    because the name of the dependency (source file) is implied by the name of the
    target (object file).
  prefs: []
  type: TYPE_NORMAL
- en: To make the built-in implicit rules more widely usable, their commands often
    consume well-known `make` variables. If you set those variables, overriding the
    default values, you can wield some control over the execution of a built-in rule.
    For instance, the command in the standard POSIX definition of the built-in implicit
    rule for converting *.o* files to *.c* files is:^([15](footnote.xhtml#ch03fn15))
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Here, you can override just about every aspect of this built-in rule by setting
    your own values for `CC`, the compiler; `CPPFLAGS`, options passed to the C preprocessor;
    and `CFLAGS`, options passed to the C compiler.
  prefs: []
  type: TYPE_NORMAL
- en: You can write implicit rules yourself, if you wish. You can even override the
    default implicit rules with your own versions. Implicit rules are a powerful tool,
    and they shouldn’t be overlooked, but for the purposes of this book, we won’t
    go into any more detail. You can learn more about writing and using implicit rules
    within makefiles in “Using Implicit Rules” in the *GNU Make Manual*.
  prefs: []
  type: TYPE_NORMAL
- en: 'To illustrate this implicit functionality, I created trivial C source and header
    files to accompany the sample makefile from [Listing 3-11](ch03.xhtml#ch03ex11).
    Here’s what happened when I executed `make` on this makefile:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, `cc` was magically executed with `-c` and `-o` options to generate
    *main.o* from *main.c*. This is common command line syntax used to make a C-language
    compiler build objects from sources—it’s so common, in fact, that the functionality
    is built into `make`. If you look for `cc` on a modern GNU/Linux system, you’ll
    find that it’s a soft link in */usr/bin* that refers to the system’s GNU C compiler.
    On other systems, it refers to the system’s native C compiler. Calling the system
    C compiler *cc* has been a de facto standard for decades.^([16](footnote.xhtml#ch03fn16))
  prefs: []
  type: TYPE_NORMAL
- en: The extra spaces between `cc` and `-c` in that output under ➊ represent the
    spaces between the uses of the `CPPFLAGS` and `CFLAGS` variables, which are defined
    as empty by default.
  prefs: []
  type: TYPE_NORMAL
- en: But why did the `make` utility build only *main.o* when we typed `make` at ➊?
    Simply because the dependency rule for *main.o* provided the first (and thus,
    the default) target for the makefile. In this case, to build `program`, we needed
    to execute `make program`, as we did in ➋. Remember that when you enter `make`
    on the command line, the `make` utility attempts to build the first explicitly
    defined target within the file called *Makefile* in the current directory. If
    we wanted to make `program` the default target, we could rearrange the rules so
    the `program` rule would be the first one listed in the makefile.
  prefs: []
  type: TYPE_NORMAL
- en: 'To see the dependency rules in action, touch one of the header files and then
    rebuild the `program` target:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: After *display.h* was updated, only *display.o*, *main.o*, and `program` were
    rebuilt. The *print.o* object didn’t need to be rebuilt because *print.c* doesn’t
    depend on *display.h*, according to the rules specified in the makefile.
  prefs: []
  type: TYPE_NORMAL
- en: Phony Targets
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Targets are not always files. They can also be so-called *phony targets*, as
    in the case of `all` and `clean`. These targets don’t refer to true products in
    the filesystem but rather to particular outcomes or actions—when you make these
    targets, the project is *cleaned*, *all* products are built, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: Multiple Targets
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: In the same way that you can list multiple dependencies within a rule on the
    right side of a colon, you can combine rules for multiple targets with the same
    dependencies and commands by listing the targets on the left side of a colon,
    as shown in [Listing 3-12](ch03.xhtml#ch03ex12).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 3-12: Using multiple targets in a rule*'
  prefs: []
  type: TYPE_NORMAL
- en: 'While it may not be immediately apparent, this example contains two separate
    rules: one for each of the two targets, `all` and `clean`. Because these two rules
    have the same set of dependencies (none, in this case) and the same set of commands,
    we’re able to take advantage of a shorthand notation supported by `make` that
    allows us to combine their rules into one specification.'
  prefs: []
  type: TYPE_NORMAL
- en: To help you understand this concept, consider the `$@` variable in [Listing
    3-12](ch03.xhtml#ch03ex12). Which target does it refer to? Well, that depends
    on which rule is currently executing—the one for `all` or the one for `clean`.
    Since a rule can only be executed on a single target at any given time, `$@` can
    only ever refer to one target, even when the controlling rule specification contains
    several.
  prefs: []
  type: TYPE_NORMAL
- en: '*Resources for Makefile Authors*'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: GNU `make` is significantly more powerful than the original AT&T UNIX `make`
    utility, although GNU `make` is completely backward compatible, as long as you
    avoid GNU extensions. The *GNU Make Manual*^([17](footnote.xhtml#ch03fn17)) is
    available online, and O’Reilly has published an excellent book on the original
    AT&T UNIX `make` utility^([18](footnote.xhtml#ch03fn18)) and all of its many nuances.
    While you can still find this title, the publisher has since merged its content
    into a new edition that also covers GNU `make` extensions.^([19](footnote.xhtml#ch03fn19))
  prefs: []
  type: TYPE_NORMAL
- en: This concludes the general discussion of makefile syntax and the `make` utility,
    although we will look at additional makefile constructs as we encounter them throughout
    the rest of this chapter. With this general information behind us, let’s return
    to the Jupiter project and begin adding some more interesting functionality.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a Source Distribution Archive
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In order to actually get source code for Jupiter to our users, we’re going to
    have to create and distribute a source archive—a tarball. We could write a separate
    script to create the tarball, but since we can use phony targets to create arbitrary
    sets of functionality in makefiles, let’s design a `make` target to perform this
    task instead. Building a source archive for distribution is usually relegated
    to the `dist` target.
  prefs: []
  type: TYPE_NORMAL
- en: When designing a new `make` target, we need to consider whether its functionality
    should be distributed among the makefiles of the project or handled in a single
    location. Normally, the rule of thumb is to take advantage of a recursive build
    system’s nature by allowing each directory to manage its own portions of a process.
    We did just this in [Listing 3-1](ch03.xhtml#ch03ex01) when we passed control
    of building the `jupiter` program down to the *src* directory, where the source
    code is located. However, building a compressed archive from a directory structure
    isn’t really a recursive process.^([20](footnote.xhtml#ch03fn20)) This being the
    case, we’ll have to perform the entire task in one of the two makefiles.
  prefs: []
  type: TYPE_NORMAL
- en: Global processes are often handled by the makefile at the highest relevant level
    in the project directory structure. We’ll add the `dist` target to our top-level
    makefile, as shown in [Listing 3-13](ch03.xhtml#ch03ex13).
  prefs: []
  type: TYPE_NORMAL
- en: Git tag 3.1
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 3-13:* Makefile: Adding the `dist` target to the top-level makefile'
  prefs: []
  type: TYPE_NORMAL
- en: Besides the addition of the `dist` target at ➋, I’ve also made several other
    modifications. Let’s look at them one at a time. I’ve added the `dist` target
    to the `.PHONY` rule at ➎. The `.PHONY` rule is a special kind of built-in rule
    called a *dot-rule* or *directive*. The `make` utility understands several dot-rules.
    The purpose of `.PHONY` is simply to tell `make` that certain targets don’t generate
    filesystem objects. Normally, `make` determines which commands to run by comparing
    the timestamps of the targets to those of their dependencies in the filesystem—but
    phony targets don’t have associated filesystem objects. Using `.PHONY` ensures
    that `make` won’t go looking for nonexistent product files named after these targets.
    It also ensures that if a file or directory named *dist* somehow inadvertently
    gets added to the directory, `make` will still treat the `dist` target as non-real.
  prefs: []
  type: TYPE_NORMAL
- en: Adding a target to the `.PHONY` rule has another effect. Since `make` won’t
    be able to use timestamps to determine whether the target is up-to-date (that
    is, newer than its dependencies), `make` has no recourse but to *always* execute
    the commands associated with phony targets whenever these targets either are requested
    on the command line or appear in a dependency chain.
  prefs: []
  type: TYPE_NORMAL
- en: 'I’ve separated the functionality of the `dist` target into three separate rules
    (➋, ➌, and ➍) for the sake of readability, modularity, and maintenance. This is
    a great rule of thumb to follow in any software engineering process: *build large
    processes from smaller ones and reuse the smaller processes where it makes sense.*'
  prefs: []
  type: TYPE_NORMAL
- en: The `dist` target at ➋ depends on the existence of the ultimate goal—in this
    case, a source-level compressed archive package, *jupiter-1.0.tar.gz*. I’ve used
    one variable to hold the version number (which makes it easier to update the project
    version later) and another variable for the package name at ➊, which will make
    it easier to change the name if I ever decide to reuse this makefile for another
    project. I’ve also logically split the functions of package name and tarball name;
    the default tarball name is the package name, but we do have the option of making
    them different.
  prefs: []
  type: TYPE_NORMAL
- en: The rule that builds the tarball at ➌ indicates how this should be done with
    a command that uses the `gzip` and `tar` utilities to create the file. But, notice
    that the rule has a dependency—the directory to be archived. The directory name
    is derived from the tarball name and the package version number; it’s stored in
    yet another variable called `distdir`.
  prefs: []
  type: TYPE_NORMAL
- en: We don’t want object files and executables from our last build attempt to end
    up in the archive, so we need to build an image directory containing exactly what
    we want to ship—including any files required in the build and install processes
    and any additional documentation or license files. Unfortunately, this pretty
    much mandates the use of individual copy (`cp`) commands.
  prefs: []
  type: TYPE_NORMAL
- en: Since there’s a rule in the makefile (at ➍) that tells how this directory should
    be created, and since that rule’s target is a dependency of the tarball, `make`
    runs the commands for that rule *before* running the commands for the tarball
    rule. Recall that `make` processes rules to build dependencies recursively, from
    the bottom up, until it can run the commands for the requested target.^([21](footnote.xhtml#ch03fn21))
  prefs: []
  type: TYPE_NORMAL
- en: '*Forcing a Rule to Run*'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'There’s a subtle flaw in the `$(distdir)` target that may not be obvious right
    now, but it will rear its ugly head at the worst of times. If the archive image
    directory (*jupiter-1.0*) already exists when you execute `make dist`, then `make`
    won’t try to create it. Try this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Notice that the `dist` target didn’t copy any files—it just built an archive
    out of the existing *jupiter-1.0* directory, which was empty. Our users would
    get a real surprise when they unpack this tarball! Worse still, if the image directory
    from the previous attempt to archive happened to still be there, the new tarball
    would contain the now-outdated sources from our last attempt to create a distribution
    tarball.
  prefs: []
  type: TYPE_NORMAL
- en: The problem is that the `$(distdir)` target is a real target with no dependencies,
    which means that `make` will consider it up-to-date as long as it exists in the
    filesystem. We could add the `$(distdir)` target to the `.PHONY` rule to force
    `make` to rebuild it every time we make the `dist` target, but it’s not a phony
    target—it’s a real filesystem object. The proper way to ensure that `$(distdir)`
    is always rebuilt is to ensure that it doesn’t exist before `make` attempts to
    build it. One way to accomplish this is to create a true phony target that will
    always execute and then add that target to the dependency list for the `$(distdir)`
    target. A common name for this kind of target is `FORCE`, and I’ve implemented
    this concept in [Listing 3-14](ch03.xhtml#ch03ex14).
  prefs: []
  type: TYPE_NORMAL
- en: Git tag 3.2
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 3-14: Makefile: Using the `FORCE` target*'
  prefs: []
  type: TYPE_NORMAL
- en: The `FORCE` rule’s commands (at ➋) are executed every time because `FORCE` is
    a phony target. Since we made `FORCE` a dependency of the `$(distdir)` target
    (at ➊), we have the opportunity to delete any previously created files and directories
    *before* `make` begins to evaluate whether it should execute the commands for
    `$(distdir)`.
  prefs: []
  type: TYPE_NORMAL
- en: '*Leading Control Characters*'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: A leading dash character (`-`) on a command tells `make` not to care about the
    status code of the command it precedes. Normally, when `make` encounters a command
    that returns a nonzero status code to the shell, it will stop execution and display
    an error message, but if you use a leading dash, it will just ignore the error
    and continue. I use a leading dash on the first `rm` command in the `FORCE` rule
    because I want to delete previously created product files that may *or may not*
    exist, and `rm` will return an error if I attempt to delete a nonexistent file.
  prefs: []
  type: TYPE_NORMAL
- en: In general, a better option is to use the `-f` flag on the `rm` command line,
    which causes `rm` to ignore missing file errors. Another benefit of using `-f`
    is that we no longer need to redirect error messages to */dev/null*, as we really
    care about other errors—permission errors, for example. From this point on, we’ll
    remove the leading dash in front of any `rm` commands and ensure we use `-f`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another leading character that you may encounter is the at sign (`@`). A command
    prefixed with an at sign tells `make` not to perform its normal behavior of printing
    the command to the `stdout` device as it executes it. It is common to use a leading
    at sign on `echo` statements. You don’t want `make` to print `echo` statements,
    because then your message will be printed twice: once by `make` and then again
    by the `echo` statement itself.'
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*You may also combine these leading characters (*`@`*, *`-`*, and *`+`*) in
    any order. The plus (*`+`*) character is used to force a command to execute that
    would otherwise not be executed due, for example, to a *`-n`* command line option,
    which tells *`make`* to perform a so-called dry run. Some commands make sense
    even in a dry run.*'
  prefs: []
  type: TYPE_NORMAL
- en: It’s best to use the at sign judiciously. I usually reserve it for commands
    I *never* want to see, such as `echo` statements. If you like quiet build systems,
    consider using the global `.SILENT` directive in your makefiles. Or better still,
    simply do nothing, thereby allowing the user the option of adding the `-s` option
    to their `make` command lines. This enables the user to choose how much noise
    they want to see.
  prefs: []
  type: TYPE_NORMAL
- en: Automatically Testing a Distribution
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The rule for building the archive directory is probably the most frustrating
    rule in this makefile because it contains commands to copy individual files into
    the distribution directory. Every time we change the file structure in our project,
    we have to update this rule in our top-level makefile, or we’ll break the `dist`
    target. But there’s nothing more we can do—we’ve made the rule as simple as possible.
    Now we just have to remember to manage this process properly.
  prefs: []
  type: TYPE_NORMAL
- en: Unfortunately, though, even worse things than breaking the `dist` target could
    happen if you forget to update the `distdir` rule’s commands. It may *appear*
    that the `dist` target is working, but it may not actually be copying all of the
    required files into the tarball. In fact, it is far more likely that this, rather
    than an error, will occur, because adding files to a project is a more common
    activity than moving them around or deleting them. New files will not be copied,
    but the `dist` rule won’t notice the difference.
  prefs: []
  type: TYPE_NORMAL
- en: 'There is a way to perform a sort of self-check on the `dist` target. We can
    create another phony target, called `distcheck`, that does exactly what our users
    will do: unpack the tarball and build the project. We can have this rule’s commands
    perform this task in a temporary directory. If the build process fails, then the
    `distcheck` target will break, telling us that we forgot something crucial in
    our distribution.'
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 3-15](ch03.xhtml#ch03ex15) shows the modifications to our top-level
    makefile that are required to implement the `distcheck` target.'
  prefs: []
  type: TYPE_NORMAL
- en: Git tag 3.3
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 3-15: Makefile: Adding a `distcheck` target to the top-level makefile*'
  prefs: []
  type: TYPE_NORMAL
- en: The `distcheck` target depends on the tarball itself, so the rule that builds
    the tarball is executed first. The `make` utility then executes the `distcheck`
    commands, which unpack the tarball just built and then recursively run `make`
    on the `all` and `clean` targets within the resulting directory. If that process
    succeeds, the `distcheck` target prints out a message indicating that your users
    will likely not have a problem with this tarball.
  prefs: []
  type: TYPE_NORMAL
- en: Now all you have to do is remember to execute `make distcheck` *before* you
    post your tarballs for public distribution!
  prefs: []
  type: TYPE_NORMAL
- en: Unit Testing, Anyone?
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Some people insist that unit testing is evil, but the only honest rationale
    they can come up with for not doing it is laziness. Proper unit testing is hard
    work, but it pays off in the end. Those who do it have learned a lesson (usually
    in childhood) about the value of delayed gratification.
  prefs: []
  type: TYPE_NORMAL
- en: A good build system should incorporate proper unit testing. The most commonly
    used target for testing a build is the `check` target, so we’ll go ahead and add
    it in the usual manner. The actual unit test should probably go in *src/Makefile*
    because that’s where the `jupiter` executable is built, so we’ll pass the `check`
    target down from the top-level makefile.
  prefs: []
  type: TYPE_NORMAL
- en: But what commands do we put in the `check` rule? Well, `jupiter` is a pretty
    simple program—it prints the message *Hello from* some/path/*jupiter!* where *some/path*
    depends on the location from which `jupiter` was executed. I’ll use the `grep`
    utility to test that `jupiter` actually outputs such a string.
  prefs: []
  type: TYPE_NORMAL
- en: '[Listings 3-16](ch03.xhtml#ch03ex16) and [3-17](ch03.xhtml#ch03ex17) illustrate
    the modifications to our top-level and *src* directory makefiles, respectively.'
  prefs: []
  type: TYPE_NORMAL
- en: Git tag 3.4
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 3-16:* Makefile: *Passing the `check` target to src/Makefile*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 3-17:* src/Makefile: *Implementing the unit test in the `check` target*'
  prefs: []
  type: TYPE_NORMAL
- en: Note that `check` depends on `all`. We can’t really test our products unless
    they are up-to-date, reflecting any recent source code or build system changes
    that may have been made. It makes sense that if the user wants to test the products,
    they also want the products to exist and be up-to-date. We can ensure they exist
    and are current by adding `all` to `check`’s dependency list.
  prefs: []
  type: TYPE_NORMAL
- en: 'There’s one more enhancement we can make to our build system: we can add `check`
    to the list of targets executed by `make` in our `distcheck` rule, between the
    commands to make `all` and `clean`. [Listing 3-18](ch03.xhtml#ch03ex18) shows
    where this is done in the top-level makefile.'
  prefs: []
  type: TYPE_NORMAL
- en: Git tag 3.5
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 3-18:* Makefile: *Adding the `check` target to the `$(MAKE)` command*'
  prefs: []
  type: TYPE_NORMAL
- en: Now when we run `make distcheck`, it will test the entire build system shipped
    with the package.
  prefs: []
  type: TYPE_NORMAL
- en: Installing Products
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We’ve reached the point where our users’ experiences with Jupiter should be
    fairly painless—even pleasant—as far as building the project is concerned. Users
    will simply unpack the distribution tarball, change into the distribution directory,
    and type `make`. It really can’t get any simpler than that.
  prefs: []
  type: TYPE_NORMAL
- en: But we still lack one important feature—installation. In the case of the Jupiter
    project, this is fairly trivial. There’s only one program, and most users would
    guess correctly that to install it, they should copy `jupiter` into either their
    */usr/bin* or */usr/local/bin* directory. More complex projects, however, could
    cause users real consternation over where to put user and system binaries, libraries,
    header files, and documentation, including man pages, info pages, PDF files, and
    the more or less obligatory *README*, *AUTHORS*, *NEWS*, *INSTALL*, and *COPYING*
    files generally associated with GNU projects.
  prefs: []
  type: TYPE_NORMAL
- en: We don’t really want our users to have to figure all that out, so we’ll create
    an `install` target to manage putting things where they go once they’re built
    properly. In fact, why not just make installation part of the `all` target? Well,
    let’s not get carried away. There are actually a few good reasons for not doing
    this.
  prefs: []
  type: TYPE_NORMAL
- en: First, build and installation are separate logical concepts. The second reason
    is a matter of filesystem rights. Users have rights to build projects in their
    own home directories, but installation often requires *root*-level rights to copy
    files into system directories. Finally, there are several reasons why a user may
    wish to build but not install a project, so it would be unwise to tie these actions
    together.
  prefs: []
  type: TYPE_NORMAL
- en: 'While creating a distribution package may not be an inherently recursive process,
    installation certainly is, so we’ll allow each subdirectory in our project to
    manage installation of its own components. To do this, we need to modify both
    the top-level and the *src*-level makefiles. Changing the top-level makefile is
    easy: since there are no products to be installed in the top-level directory,
    we’ll just pass the responsibility on to *src/Makefile* in the usual way.'
  prefs: []
  type: TYPE_NORMAL
- en: The modifications for adding an `install` target are shown in [Listings 3-19](ch03.xhtml#ch03ex19)
    and [3-20](ch03.xhtml#ch03ex20).
  prefs: []
  type: TYPE_NORMAL
- en: Git tag 3.6
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 3-19:* Makefile: *Passing the `install` target to src/Makefile*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 3-20:* src/Makefile: *Implementing the `install` target*'
  prefs: []
  type: TYPE_NORMAL
- en: In the top-level makefile shown in [Listing 3-19](ch03.xhtml#ch03ex19), I’ve
    added `install` to the list of targets passed down to *src/Makefile*. The installation
    of files is handled by the *src*-level makefile shown in [Listing 3-20](ch03.xhtml#ch03ex20).
  prefs: []
  type: TYPE_NORMAL
- en: Installation is a bit more complex than simply copying files. If a file is placed
    in the */usr/bin* directory, then *root* should own it so that only *root* can
    delete or modify it. Additionally, the `jupiter` binary should be flagged executable,
    so I’ve used the `chmod` command to set the mode of the file as such. This is
    probably redundant, as the linker ensures that `jupiter` is created as an executable
    file, but some types of executable products are not generated by a linker—shell
    scripts, for example.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now our users can just type the following sequence of commands and the Jupiter
    project will be built, tested, and installed with the correct system attributes
    and ownership on their platforms:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: '*Installation Choices*'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: All of this is well and good, but it could be a bit more flexible with regard
    to where things are installed. Some users may be okay with having `jupiter` installed
    into the */usr/bin* directory. Others are going to ask why it isn’t installed
    into the */usr/local/bin* directory—after all, this is a common convention. We
    could change the target directory to */usr/local/bin*, but then users may ask
    why they don’t have the option of installing into their home directories. This
    is the perfect situation for a little command line–supported flexibility.
  prefs: []
  type: TYPE_NORMAL
- en: Another problem with our current build system is that we have to do a lot of
    stuff just to install files. Most Unix systems provide a system-level program—sometimes
    simply a shell script—called `install` that allows a user to specify various attributes
    of the files being installed. The proper use of this utility could simplify things
    a bit for Jupiter’s installation, so while we’re adding location flexibility,
    we might as well use the `install` utility, too. These modifications are shown
    in [Listings 3-21](ch03.xhtml#ch03ex21) and [3-22](ch03.xhtml#ch03ex22).
  prefs: []
  type: TYPE_NORMAL
- en: Git tag 3.7
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 3-21: Makefile: Adding a `prefix` variable*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 3-22:* src/Makefile: *Using the `prefix` variable in the `install`
    target*'
  prefs: []
  type: TYPE_NORMAL
- en: Notice that I only declared and assigned the `prefix` variable in the top-level
    makefile, but I referenced it in *src/Makefile*. I can do this because I used
    the `export` modifier at ➊ in the top-level makefile—this modifier exports the
    variable to the shell that `make` spawns when it executes itself in the *src*
    directory. This feature of `make` allows us to define all of our user variables
    in one obvious location—at the beginning of the top-level makefile.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*GNU *`make`* allows you to use the *`export`* keyword on the assignment line,
    but this syntax is not portable between GNU *`make`* and other versions of *`make`*.
    Technically, POSIX doesn’t support the use of *`export`* at all, but most *`make`*
    implementations support it.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'I’ve now declared the `prefix` variable to be */usr/local*, which is very nice
    for those who want to install `jupiter` in */usr/local/bin* but not so nice for
    those who want it in */usr/bin*. Fortunately, `make` allows you to define `make`
    variables on the command line, in this manner:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Remember that variables defined on the command line override those defined within
    the makefile.^([22](footnote.xhtml#ch03fn22)) Thus, users who want to install
    `jupiter` into the */usr/bin* directory now have the option of specifying this
    on the `make` command line.
  prefs: []
  type: TYPE_NORMAL
- en: With this system in place, our users may install `jupiter` into a *bin* directory
    beneath any directory they choose, including a location in their home directory
    (for which they do not need additional rights). This is, in fact, the reason we
    added the `install -d $(prefix)/bin` command at ➋ in [Listing 3-22](ch03.xhtml#ch03ex22)—this
    command creates the installation directory if it doesn’t already exist. Since
    we allow the user to define `prefix` on the `make` command line, we don’t actually
    know where the user is going to install `jupiter`; therefore, we have to be prepared
    for the possibility that the location may not yet exist. Give this a try:^([23](footnote.xhtml#ch03fn23))
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: '*Uninstalling a Package*'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: What if a user doesn’t like our package after they’ve installed it, and they
    just want to get it off their system? This is a fairly likely scenario for the
    Jupiter project, as it’s rather useless and takes up valuable space in the *bin*
    directory. In the case of *your* projects, however, it’s more likely that a user
    would want to do a clean install of a newer version of the project or replace
    the test build they downloaded from the project website with a professionally
    packaged version that comes with their Linux distribution. Support for an `uninstall`
    target would be very helpful in situations like these.
  prefs: []
  type: TYPE_NORMAL
- en: '[Listings 3-23](ch03.xhtml#ch03ex23) and [3-24](ch03.xhtml#ch03ex24) show the
    addition of an `uninstall` target to our two makefiles.'
  prefs: []
  type: TYPE_NORMAL
- en: Git tag 3.8
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 3-23:* Makefile: *Adding the `uninstall` target to the top-level makefile*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 3-24:* src/Makefile: *Adding the `uninstall` target to the src-level
    makefile*'
  prefs: []
  type: TYPE_NORMAL
- en: As with the `install` target, this target requires root-level rights if the
    user is using a system prefix, such as */usr* or */usr/local*. You should be very
    careful about how you write your `uninstall` targets; unless a directory belongs
    specifically to your package, you shouldn’t assume you created it. If you do,
    you may end up deleting a system directory like */usr/bin*!
  prefs: []
  type: TYPE_NORMAL
- en: On the other hand, we did create the directory in the `install` target if it
    was originally missing, so we should remove it if possible. Here, we can use the
    `rmdir` command, whose job it is to remove empty directories. Even if the directory
    is a system directory such as */usr/bin*, removing it is harmless if it’s empty,
    but `rmdir` will fail if it’s not empty. Recalling that command failure stops
    the `make` process, we’ll also prefix it with a dash character. And we don’t really
    want to see such a failure, so we’ll redirect it’s output to */dev/null*.
  prefs: []
  type: TYPE_NORMAL
- en: 'The list of things to maintain in our build system is getting out of hand.
    There are now two places we need to update when we change our installation processes:
    the `install` and `uninstall` targets. Unfortunately, this is really about the
    best we can hope for when writing our own makefiles, unless we resort to fairly
    complex shell script commands. But hang in there—in [Chapter 6](ch06.xhtml), I’ll
    show you how to rewrite this makefile in a much simpler way using GNU Automake.'
  prefs: []
  type: TYPE_NORMAL
- en: '*Testing Install and Uninstall*'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Now let’s add some code to our `distcheck` target to test the functionality
    of the `install` and `uninstall` targets. After all, it’s fairly important that
    both of these targets work correctly from our distribution tarballs, so we should
    test them in `distcheck` before declaring the tarball release worthy. [Listing
    3-25](ch03.xhtml#ch03ex25) illustrates the necessary changes to the top-level
    makefile.
  prefs: []
  type: TYPE_NORMAL
- en: Git tag 3.9
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 3-25:* Makefile: *Adding `distcheck` tests for the `install` and `uninstall`
    targets*'
  prefs: []
  type: TYPE_NORMAL
- en: Note that I used a double dollar sign on the `$${PWD}` variable references,
    ensuring that `make` passes the variable reference to the shell with the rest
    of the command line, rather than expanding it inline before executing the command.
    I wanted this variable to be dereferenced by the shell rather than by the `make`
    utility.^([24](footnote.xhtml#ch03fn24))
  prefs: []
  type: TYPE_NORMAL
- en: What we’re doing here is testing to ensure the `install` and `uninstall` targets
    don’t generate errors—but this isn’t very likely because all they do is install
    files into a temporary directory within the build directory. We could add some
    code immediately after the `make` `install` command that looks for the products
    that are supposed to be installed, but that’s more than I’m willing to do. One
    reaches a point of diminishing returns, where the code that does the checking
    is just as complex as the installation code—in which case, the check becomes pointless.
  prefs: []
  type: TYPE_NORMAL
- en: 'But there is something else we can do: we can write a more or less generic
    test that checks to see if everything we installed was properly removed. Since
    the stage directory was empty before our installation, it had better be in a similar
    state after we uninstall. [Listing 3-26](ch03.xhtml#ch03ex26) shows the addition
    of this test.'
  prefs: []
  type: TYPE_NORMAL
- en: Git tag 3.10
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 3-26:* Makefile: *Adding a test for leftover files after `uninstall`
    finishes*'
  prefs: []
  type: TYPE_NORMAL
- en: The test first generates a numeric value at ➊ in a shell variable called `remaining`,
    which represents the number of regular files found in the stage directory we used.
    If this number is not zero, the test prints a message to the console at ➋ indicating
    how many files were left behind by the `uninstall` commands and then it exits
    with an error. Exiting early leaves the stage directory intact so we can examine
    it to find out which files we forgot to uninstall.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*This test code represents a good use of multiple shell commands passed to
    a single shell. I had to do this here so that the value of *`remaining`* would
    be available for use by the *`if`* statement. Conditionals don’t work very well
    when the closing *`if`* is not executed by the same shell as the opening *`if`*!*'
  prefs: []
  type: TYPE_NORMAL
- en: I don’t want to alarm people by printing the embedded `echo` statement unless
    it really should be executed, so I prefixed the entire test with an at sign (`@`)
    so that `make` wouldn’t print the code to `stdout`. Since `make` considers these
    five lines of code a single command, the only way to suppress printing the `echo`
    statement is to suppress printing the entire command.
  prefs: []
  type: TYPE_NORMAL
- en: Now, this test isn’t perfect—not by a long shot. This code only checks for regular
    files. If your installation procedure creates any soft links, this test won’t
    notice if they’re left behind. The directory structure that’s built during installation
    is purposely left in place because the check code doesn’t know whether a subdirectory
    within the stage directory belongs to the system or to the project. The `uninstall`
    rule’s commands can be aware of which directories are project specific and properly
    remove them, but I don’t want to add project-specific knowledge into the `distcheck`
    tests—it’s that problem of diminishing returns again.
  prefs: []
  type: TYPE_NORMAL
- en: The Filesystem Hierarchy Standard
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You may be wondering by now where I’m getting these directory names. What if
    some Unix system out there doesn’t use */usr* or */usr/local*? For one thing,
    this is another reason for providing the `prefix` variable—to allow the user some
    choice in these matters. However, most Unix-like systems nowadays follow the *Filesystem
    Hierarchy Standard (FHS)* as closely as possible. The *FHS* defines a number of
    standard places, including the following root-level directories:'
  prefs: []
  type: TYPE_NORMAL
- en: '| */bin* | */etc* | */home* |'
  prefs: []
  type: TYPE_TB
- en: '| */opt* | */sbin* | */srv* |'
  prefs: []
  type: TYPE_TB
- en: '| */tmp* | */usr* | */var* |'
  prefs: []
  type: TYPE_TB
- en: 'This list is by no means exhaustive. I’ve only mentioned the directories that
    are most relevant to our study of open source project build systems. In addition,
    the *FHS* defines several standard locations beneath these root-level directories.
    For instance, the */usr* directory should contain the following subdirectories:'
  prefs: []
  type: TYPE_NORMAL
- en: '| */usr/bin* | */usr/include* | */usr/lib* |'
  prefs: []
  type: TYPE_TB
- en: '| */usr/local* | */usr/sbin* | */usr/share* |'
  prefs: []
  type: TYPE_TB
- en: '| */usr/src* |  |  |'
  prefs: []
  type: TYPE_TB
- en: The */usr/local* directory should contain a structure very similar to that of
    the */usr* directory. The */usr/local* directory provides a location for software
    installation that overrides versions of the same packages installed in the */usr*
    directory structure, because system software updates often overwrite software
    in */usr* without prejudice. The */usr/local* directory structure allows a system
    administrator to decide which version of a package to use on their system because
    */usr/local/bin* may be (and usually is) added to the `PATH` before */usr/bin*.
    A fair amount of thought has gone into designing the *FHS*, and the GNU Autotools
    take full advantage of this consensus of understanding.
  prefs: []
  type: TYPE_NORMAL
- en: Not only does the *FHS* define these standard locations, but it also explains
    in detail what they’re for and what types of files should be kept there. All in
    all, the *FHS* leaves you, as project maintainer, just enough flexibility and
    choice to keep your life interesting but not enough to make you wonder whether
    you’re installing your files in the right places.^([25](footnote.xhtml#ch03fn25))
  prefs: []
  type: TYPE_NORMAL
- en: Supporting Standard Targets and Variables
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In addition to those I’ve already mentioned, the *GNU Coding Standards* lists
    some important targets and variables that you should support in your projects—mainly
    because your users will expect support for them.
  prefs: []
  type: TYPE_NORMAL
- en: Some of the chapters in the *GCS* document should be taken with a grain of salt
    (unless you’re actually working on a GNU-sponsored project). For example, you
    probably won’t care much about the C source code formatting suggestions in [Chapter
    5](ch05.xhtml) of the *GCS*. Your users certainly won’t care, so you can use whatever
    source code formatting style you wish.
  prefs: []
  type: TYPE_NORMAL
- en: That’s not to say that all of [Chapter 5](ch05.xhtml) is worthless to non-GNU
    open source projects. The “Portability between System Types” and “Portability
    between CPUs” subsections, for instance, provide excellent information on C source
    code portability. Also, the “Internationalization” subsection gives some useful
    tips on using GNU software to internationalize your projects. We’ll consider internationalization
    in greater detail in [Chapter 11](ch11.xhtml) of this book.
  prefs: []
  type: TYPE_NORMAL
- en: While [Chapter 6](ch06.xhtml) of the *GCS* discusses documentation the GNU way,
    some sections of [Chapter 6](ch06.xhtml) describe various top-level text files
    commonly found in projects, such as the *AUTHORS*, *NEWS*, *INSTALL*, *README*,
    and *ChangeLog* files. These are all bits of information that the well-indoctrinated
    open source software user expects to see in any reputable project.
  prefs: []
  type: TYPE_NORMAL
- en: The *really* useful information in the *GCS* document begins in [Chapter 7](ch07.xhtml),
    “The Release Process.” This chapter is critical to you as a project maintainer
    because it defines what your users will expect of your projects’ build systems.
    [Chapter 7](ch07.xhtml) contains the de facto standards for the user options that
    packages provide in source-level distributions.
  prefs: []
  type: TYPE_NORMAL
- en: '*Standard Targets*'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The “How Configuration Should Work” subsection of [Chapter 7](ch07.xhtml) of
    the *GCS* defines the configuration process, which I cover briefly in “Configuring
    Your Package” on [page 77](ch03.xhtml#page_77). The “Makefile Conventions” subsection
    of the *GCS* covers all of the standard targets and many of the standard variables
    that users have come to expect in open source software packages. Standard targets
    defined by the *GCS* include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '| `all` | `install` | `install-html` |'
  prefs: []
  type: TYPE_TB
- en: '| `install-dvi` | `install-pdf` | `install-ps` |'
  prefs: []
  type: TYPE_TB
- en: '| `install-strip` | `uninstall` | `clean` |'
  prefs: []
  type: TYPE_TB
- en: '| `distclean` | `mostlyclean` | `maintainer-clean` |'
  prefs: []
  type: TYPE_TB
- en: '| `TAGS` | `info` | `dvi` |'
  prefs: []
  type: TYPE_TB
- en: '| `html` | `pdf` | `ps` |'
  prefs: []
  type: TYPE_TB
- en: '| `dist` | `check` | `installcheck` |'
  prefs: []
  type: TYPE_TB
- en: '| `installdirs` |  |  |'
  prefs: []
  type: TYPE_TB
- en: You don’t need to support all of these targets, but you should consider supporting
    the ones that make sense for your project. For example, if you build and install
    HTML pages, you should probably consider supporting the `html` and `install-html`
    targets. Autotools projects support these and more. Some targets are useful to
    end users, while others are useful only to project maintainers.
  prefs: []
  type: TYPE_NORMAL
- en: '*Standard Variables*'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Variables you should support as you see fit include those listed in the following
    table. In order to provide flexibility for the end user, most of these variables
    are defined in terms of a few of them and, ultimately, only one of them: `prefix`.
    For lack of a more standard name, I call these *prefix variables*. Most of these
    could be classified as *installation directory variables* that refer to standard
    locations, but there are a few exceptions, such as `srcdir`.'
  prefs: []
  type: TYPE_NORMAL
- en: These variables are meant to be fully resolved by `make`, so they’re defined
    in terms of `make` variables, using parentheses rather than curly brackets. [Table
    3-1](ch03.xhtml#ch03tab1) lists these prefix variables and their default values.
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 3-1:** Prefix Variables and Their Default Values'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Variable** | **Default Value** |'
  prefs: []
  type: TYPE_TB
- en: '| `prefix` | /usr/local |'
  prefs: []
  type: TYPE_TB
- en: '| `exec_prefix` | `$(prefix)` |'
  prefs: []
  type: TYPE_TB
- en: '| `bindir` | `$(exec_prefix)`/bin |'
  prefs: []
  type: TYPE_TB
- en: '| `sbindir` | `$(exec_prefix)`/sbin |'
  prefs: []
  type: TYPE_TB
- en: '| `libexecdir` | `$(exec_prefix)`/libexec |'
  prefs: []
  type: TYPE_TB
- en: '| `datarootdir` | `$(prefix)`/share |'
  prefs: []
  type: TYPE_TB
- en: '| `datadir` | `$(datarootdir)` |'
  prefs: []
  type: TYPE_TB
- en: '| `sysconfdir` | `$(prefix)`/etc |'
  prefs: []
  type: TYPE_TB
- en: '| `sharedstatedir` | `$(prefix)`/com |'
  prefs: []
  type: TYPE_TB
- en: '| `localstatedir` | `$(prefix)`/var |'
  prefs: []
  type: TYPE_TB
- en: '| `includedir` | `$(prefix)/`include |'
  prefs: []
  type: TYPE_TB
- en: '| `oldincludedir` | /usr/include |'
  prefs: []
  type: TYPE_TB
- en: '| `docdir` | `$(datarootdir)`/doc/`$(package)` |'
  prefs: []
  type: TYPE_TB
- en: '| `infodir` | `$(datarootdir)`/info |'
  prefs: []
  type: TYPE_TB
- en: '| `htmldir` | `$(docdir)` |'
  prefs: []
  type: TYPE_TB
- en: '| `dvidir` | `$(docdir)` |'
  prefs: []
  type: TYPE_TB
- en: '| `pdfdir` | `$(docdir)` |'
  prefs: []
  type: TYPE_TB
- en: '| `psdir` | `$(docdir)` |'
  prefs: []
  type: TYPE_TB
- en: '| `libdir` | `$(exec_prefix)`/lib |'
  prefs: []
  type: TYPE_TB
- en: '| `lispdir` | `$(datarootdir)`/emacs/site-lisp |'
  prefs: []
  type: TYPE_TB
- en: '| `localedir` | `$(datarootdir)`/locale |'
  prefs: []
  type: TYPE_TB
- en: '|  `mandir`  | `$(datarootdir)`/man |'
  prefs: []
  type: TYPE_TB
- en: '| `man`*`N`*`dir` | `$(mandir)`/man*N* (*N* = 1..9) |'
  prefs: []
  type: TYPE_TB
- en: '| `manext` | .1 |'
  prefs: []
  type: TYPE_TB
- en: '| `man`*`N`*`ext` | .*N* (*N* = 1..9) |'
  prefs: []
  type: TYPE_TB
- en: '| `srcdir` | The source-tree directory corresponding to the current directory
    in the build tree |'
  prefs: []
  type: TYPE_TB
- en: Autotools-based projects support these and other useful variables automatically,
    as needed; Automake provides full support for them, while Autoconf’s support is
    more limited. If you write your own makefiles and build systems, you should support
    as many of these as you use in your build and installation processes.
  prefs: []
  type: TYPE_NORMAL
- en: '*Adding Location Variables to Jupiter*'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: To support the variables that we’ve used so far in the Jupiter project, we need
    to add the `bindir` variable, as well as any variables that it relies on—in this
    case, the `exec_prefix` variable. [Listings 3-27](ch03.xhtml#ch03ex27) and [3-28](ch03.xhtml#ch03ex28)
    show how to do this in the top-level and *src* directory makefiles.
  prefs: []
  type: TYPE_NORMAL
- en: Git tag 3.11
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 3-27:* Makefile: *Adding the `bindir` variable*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 3-28:* src/Makefile: *Adding the `bindir` variable*'
  prefs: []
  type: TYPE_NORMAL
- en: Even though we only use `bindir` in *src/Makefile*, we have to export `prefix`,
    `exec_prefix`, and `bindir` because `bindir` is defined in terms of `exec_prefix`,
    which is itself defined in terms of `prefix`. When `make` runs the `install` commands,
    it will first resolve `bindir` to `$(exec_prefix)`*/bin*, then to `$(prefix)`*/bin*,
    and finally to */usr/local/bin*. Thus, *src/Makefile* needs to have access to
    all three variables during this process.
  prefs: []
  type: TYPE_NORMAL
- en: 'How do such recursive variable definitions make life better for the end user?
    After all, the user can change the root install location from */usr/local* to
    */usr* by simply typing the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'The ability to change prefix variables at multiple levels is particularly useful
    to a Linux distribution packager (an employee or volunteer at a Linux company
    whose job it is to professionally package your project as a *.deb* or *.rpm* package)
    who needs to install packages into very specific system locations. For example,
    a distro packager could use the following command to change the installation prefix
    to */usr* and the system configuration directory to */etc*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: Without the ability to change prefix variables at multiple levels, configuration
    files would end up in */usr/etc* because the default value of `$(sysconfdir)`
    is `$(prefix)`*/etc*.
  prefs: []
  type: TYPE_NORMAL
- en: Getting Your Project into a Linux Distro
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When a Linux distro picks up your package for distribution, your project magically
    moves from the realm of tens of users to that of tens of thousands of users—almost
    overnight. Some people will be using your software without even knowing it. Since
    one great value of open source software for the developer is free help in making
    your software better, this can be seen as a good thing—a dramatic increase in
    community size.
  prefs: []
  type: TYPE_NORMAL
- en: By following the *GCS* within your build system, you remove many of the barriers
    to including your project in a Linux distro. If your tarball follows all the usual
    conventions, distro packagers will immediately know what to do with it. These
    packagers generally get to decide, based on needed functionality and their feelings
    about your package, whether it should be included in their flavor of Linux. Since
    they have a fair amount of power in this process, it behooves you to please them.
  prefs: []
  type: TYPE_NORMAL
- en: Section 7 of the *GCS* contains a small subsection that talks about supporting
    *staged installations*. It is easy to support this concept in your build system,
    but if you neglect to support it, it will almost always cause problems for packagers.
  prefs: []
  type: TYPE_NORMAL
- en: Packaging systems such as the Red Hat Package Manager (RPM) accept one or more
    tarballs, a set of patch files, and a specification file. The so-called *spec
    file* describes the process of building and packaging your project for a particular
    system. In addition, it defines all of the products installed into the target
    installation directory structure. The package manager software uses this information
    to install your package into a temporary directory, from which it then pulls the
    specified products, storing them in a special binary archive that the package
    installation program (for example, `rpm`) understands.
  prefs: []
  type: TYPE_NORMAL
- en: To support staged installation, all you need is a variable named `DESTDIR` that
    acts as a sort of super-prefix to all of your installed products. To show you
    how this is done, I’ll add staged installation support to the Jupiter project.
    This is so trivial that it requires only four changes to *src/Makefile*. The required
    changes are highlighted in [Listing 3-29](ch03.xhtml#ch03ex29).
  prefs: []
  type: TYPE_NORMAL
- en: Git tag 3.12
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 3-29:* src/Makefile: *Adding staged build functionality*'
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, I’ve added the `$(DESTDIR)` prefix to the `$(bindir)` references
    in the `install` and `uninstall` targets that refer to installation paths. You
    don’t need to define a default value for `DESTDIR`, because when it is left undefined,
    it expands to an empty string, which has no effect on the paths to which it’s
    prepended.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Do not add a slash after *`$(DESTDIR)`*, which is usually empty. The prefix
    variables ultimately resolve to something starting with a slash; adding a slash
    after *`$(DESTDIR)`* is therefore redundant and, in some situations, can cause
    unintended side effects.*'
  prefs: []
  type: TYPE_NORMAL
- en: I didn’t need to add `$(DESTDIR)` to the `uninstall` rule’s `rm` command for
    the sake of the package manager, because package managers don’t care how your
    package is uninstalled. They only install your package so they can copy the products
    from a stage directory. To uninstall the stage directory, package managers simply
    delete it. Package manager programs such as `rpm` use their own rules for removing
    products from a system, and these rules are based on a package manager database
    rather than your `uninstall` target.
  prefs: []
  type: TYPE_NORMAL
- en: However, for the sake of symmetry, and to be complete, it doesn’t hurt to add
    `$(DESTDIR)` to `uninstall`. Besides, we need it to be complete for the sake of
    the `distcheck` target, which we’ll now modify to take advantage of our staged
    installation functionality. This modification is shown in [Listing 3-30](ch03.xhtml#ch03ex30).
  prefs: []
  type: TYPE_NORMAL
- en: Git tag 3.13
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 3-30:* Makefile: *Using `DESTDIR` in the `distcheck` target*'
  prefs: []
  type: TYPE_NORMAL
- en: Changing `prefix` to `DESTDIR` in the `install` and `uninstall` commands allows
    us to properly test a complete installation directory hierarchy, as we’ll see
    shortly.
  prefs: []
  type: TYPE_NORMAL
- en: 'At this point, an RPM spec file could provide the following text as the installation
    commands for the Jupiter package:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: Don’t worry about package manager file formats. Instead, just focus on providing
    staged installation functionality through the `DESTDIR` variable.
  prefs: []
  type: TYPE_NORMAL
- en: You may be wondering why the `prefix` variable couldn’t provide this functionality.
    For one thing, not every path in a system-level installation is defined relative
    to the `prefix` variable. The system configuration directory (`sysconfdir`), for
    instance, is often defined as */etc* by packagers. You can see in [Table 3-1](ch03.xhtml#ch03tab1)
    that the default definition of `sysconfdir` is `$(prefix)`*/etc*, so the only
    way `sysconfdir` would resolve to */etc* would be if you explicitly set it to
    do so on the `configure` or `make` command line. If you configured it that way,
    only a variable like `DESTDIR` would affect the base location of `sysconfdir`
    during staged installation. Other reasons for this will become clearer as we talk
    about project configuration later on in this chapter, and then again in the next
    two chapters.
  prefs: []
  type: TYPE_NORMAL
- en: Build vs. Installation Prefix Overrides
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'At this point, I’d like to digress slightly to explain an elusive (or at least
    nonobvious) concept regarding `prefix` and other path variables defined in the
    *GCS*. In the preceding examples, I used prefix overrides on the `make install`
    command line, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'The question I wish to address is: what is the difference between using a prefix
    override for `make all` and for `make install`? In our small sample makefiles,
    we’ve managed to avoid using prefixes in any targets not related to installation,
    so it may not be clear to you at this point that a prefix is *ever* useful during
    the build stage. However, prefix variables can be very useful during the build
    stage to substitute paths into source code at compile time, as shown in [Listing
    3-31](ch03.xhtml#ch03ex31).'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 3-31: Substituting paths into source code at compile time*'
  prefs: []
  type: TYPE_NORMAL
- en: In this example, I’m defining a C-preprocessor variable called `CFGDIR` on the
    compiler command line for use by *main.c*. Presumably, there’s some code in *main.c*
    like that shown in [Listing 3-32](ch03.xhtml#ch03ex32).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 3-32: Substituting `CFGDIR` at compile time*'
  prefs: []
  type: TYPE_NORMAL
- en: Later in the code, you might use the C global variable `cfgdir` to access the
    application’s configuration file.
  prefs: []
  type: TYPE_NORMAL
- en: Linux distro packagers often use different prefix overrides for build and install
    command lines in RPM spec files. During the build stage, the actual runtime directories
    are hardcoded into the executable using commands like the `./configure` command
    shown in [Listing 3-33](ch03.xhtml#ch03ex33).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 3-33: The portion of an RPM spec file that builds the source tree*'
  prefs: []
  type: TYPE_NORMAL
- en: Note that we have to explicitly specify `sysconfdir` along with `prefix`, because,
    as I mentioned earlier, the system configuration directory is usually outside
    of the `prefix` directory structure. The package manager installs these executables
    into a stage directory so it can then copy them out of their installed locations
    when it builds the binary installation package. The corresponding installation
    commands might look like those shown in [Listing 3-34](ch03.xhtml#ch03ex34).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 3-34: The installation portion of an RPM spec file*'
  prefs: []
  type: TYPE_NORMAL
- en: Using `DESTDIR` during installation will temporarily override *all* installation
    prefix variables, so you don’t have to remember which variables you’ve overridden
    during configuration. Given the configuration command shown in [Listing 3-33](ch03.xhtml#ch03ex33),
    using `DESTDIR` in the manner shown in [Listing 3-34](ch03.xhtml#ch03ex34) has
    the same effect as the code shown in [Listing 3-35](ch03.xhtml#ch03ex35).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 3-35: Overriding the default `sysconfdir` during installation*'
  prefs: []
  type: TYPE_NORMAL
- en: '**WARNING**'
  prefs: []
  type: TYPE_NORMAL
- en: '*The key point here is one that I touched on earlier. Never write your install
    target to build all or even part of your products in your makefiles. Installation
    functionality should be limited to copying files, if possible. Otherwise, your
    users won’t be able to access your staged installation features if they are using
    prefix overrides.*'
  prefs: []
  type: TYPE_NORMAL
- en: Another reason for limiting installation functionality in this way is that it
    allows the user to install sets of packages as a group into an isolated location
    and then create links to the actual files in the proper locations. Some people
    like to do this when they are testing out a package and want to keep track of
    all its components.^([26](footnote.xhtml#ch03fn26))
  prefs: []
  type: TYPE_NORMAL
- en: 'One final point: if you’re installing into a system directory hierarchy, you’ll
    need *root* permissions. People often run `make install` like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: If your `install` target depends on your build targets, and you’ve neglected
    to build them beforehand, `make` will happily build your program before installing
    it—but the local copies will all be owned by *root*. This inconvenience is easily
    avoided by having `make install` fail for lack of things to install, rather than
    jumping right into a build while running as *root*.
  prefs: []
  type: TYPE_NORMAL
- en: User Variables
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The *GCS* defines a set of variables that are sacred to the user. These variables
    should be *referenced* by a GNU build system but never *modified* by a GNU build
    system. These so-called *user variables* include those listed in [Table 3-2](ch03.xhtml#ch03tab2)
    for C and C++ programs.
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 3-2:** Some User Variables and Their Purposes'
  prefs: []
  type: TYPE_NORMAL
- en: '| Variables | Purpose |'
  prefs: []
  type: TYPE_TB
- en: '| `CC` | A reference to the system C compiler |'
  prefs: []
  type: TYPE_TB
- en: '| `CFLAGS` | Desired C compiler flags |'
  prefs: []
  type: TYPE_TB
- en: '| `CXX` | A reference to the system C++ compiler |'
  prefs: []
  type: TYPE_TB
- en: '|  `CXXFLAGS`  | Desired C++ compiler flags |'
  prefs: []
  type: TYPE_TB
- en: '| `LDFLAGS` | Desired linker flags |'
  prefs: []
  type: TYPE_TB
- en: '| `CPPFLAGS` | Desired C/C++ preprocessor flags |'
  prefs: []
  type: TYPE_TB
- en: '| *`--snip--`* |  |'
  prefs: []
  type: TYPE_TB
- en: This list is by no means comprehensive, and interestingly, there isn’t a comprehensive
    list to be found in the *GCS*. In fact, most of these variables come from the
    documentation for the `make` utility itself. These variables are used in the built-in
    rules of the `make` utility—they’re somewhat hardcoded into `make`, so they are
    effectively defined by `make`. You can find a fairly complete list of program
    name and flag variables in the “Variables Used by Implicit Rules” section of the
    *GNU Make Manual*.
  prefs: []
  type: TYPE_NORMAL
- en: Note that `make` assigns default values for many of these variables based on
    common Unix utility names. For example, the default value of `CC` is `cc`, which
    (at least on Linux systems) is a soft link to the GCC C compiler (`gcc`). On other
    systems, `cc` is a soft link to the system’s own compiler. Thus, we don’t need
    to set `CC` to `gcc`, which is good, because GCC may not be installed on non-Linux
    platforms. There may be times when you do wish to set `CC` on the `make` command
    line, such as when using an alternative compiler like `clang` or when using the
    `ccache` utility to cache `gcc` results for faster recompilation.
  prefs: []
  type: TYPE_NORMAL
- en: For our purposes, the variables shown in [Table 3-2](ch03.xhtml#ch03tab2) are
    sufficient, but for a more complex makefile, you should become familiar with the
    larger list outlined in the *GNU Make Manual*.
  prefs: []
  type: TYPE_NORMAL
- en: To use these variables in our makefiles, we’ll just replace `gcc` with `$(CC)`.
    We’ll do the same for `CFLAGS` and `CPPFLAGS`, although `CPPFLAGS` will be empty
    by default. The `CFLAGS` variable has no default value either, but this is a good
    time to add one. I like to use `-g` to build objects with symbols and `-O0` to
    disable optimizations for debug builds. The updates to *src/Makefile* are shown
    in [Listing 3-36](ch03.xhtml#ch03ex36).
  prefs: []
  type: TYPE_NORMAL
- en: Git tag 3.14
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 3-36:* src/Makefile: *Adding appropriate user variables*'
  prefs: []
  type: TYPE_NORMAL
- en: 'This works because the `make` utility allows such variables to be overridden
    by options on the command line. For example, to switch compilers and set some
    compiler command line options, a user need only type the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'In this case, our user has decided to use the `ccache` utility instead of `gcc`,
    generate debug symbols, and optimize their code using level-two optimizations.
    They’ve also decided to enable the `test` option through the use of a C-preprocessor
    definition. Note that these variables are set on the `make` command line; this
    apparently equivalent Bourne-shell syntax will not work as expected:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: The reason is that we’re merely setting environment variables in the local environment
    passed to the `make` utility by the shell. Remember that environment variables
    do not automatically override those set in the makefile. To get the functionality
    we want, we could use a little GNU `make`–specific syntax in our makefile, as
    shown in [Listing 3-37](ch03.xhtml#ch03ex37).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 3-37: Using the GNU `make`–specific query-assign operator (`?=`) in
    a makefile*'
  prefs: []
  type: TYPE_NORMAL
- en: The `?=` operator is a GNU `make`–specific operator, which will only set the
    variable in the makefile if it hasn’t already been set elsewhere. This means we
    can now override these particular variable settings by setting them in the environment.
    But don’t forget that this will only work in GNU `make`. In general, it’s better
    to set `make` variables on the `make` command line.
  prefs: []
  type: TYPE_NORMAL
- en: Nonrecursive Build Systems
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Now that we’ve spent all this time creating the perfect build system for our
    project, let’s take a look at a *more perfect* solution—a nonrecursive system.
    I mentioned at the start of this chapter that there was a problem with recursive
    builds that we’d discuss at a later point.
  prefs: []
  type: TYPE_NORMAL
- en: The fundamental problem with recursive build systems is that they artificially
    introduce flaws into `make`’s directed graph—the set of rules `make` uses to determine
    what depends on what and when something needs to be rebuilt. For Jupiter, very
    little can go wrong because there’s one top-level makefile invoking `make` on
    a single subdirectory makefile, but let’s consider a more complex project where
    multiple submodules, nested arbitrarily deeply, are interdependent upon each other
    in more complex ways.
  prefs: []
  type: TYPE_NORMAL
- en: With a single makefile, the one `make` process can “see the big picture.” That
    is, it can see and understand all of the interdependencies in the system, and
    it can create a DAG that properly represents all of the inter­dependencies among
    all of the filesystem objects within the project. With multiple makefiles, each
    child `make` process executed by parent `make` can see only a portion of the dependency
    graph. Ultimately, this can cause `make` to build products out of order so that
    a product that depends on prerequisites not within its own purview is built before
    those prerequisites are updated.
  prefs: []
  type: TYPE_NORMAL
- en: 'The preceding problem is compounded when you use *parallel* *`make`* by adding
    `-j` to the `make` command line. The `-j` option tells `make` to examine its DAG
    and find places where portions of the DAG do not depend on each other, then execute
    those portions at the same time. On a multiprocessor system, this can dramatically
    speed up the build process for large projects. However, this causes problems from
    two different angles. First, since `make` can’t see the whole picture, it can
    make incorrect assumptions about what things can be done in parallel. Second,
    as far as the top-level `make` is concerned, child `make` processes are all independent
    and can be run in parallel, which we can easily see is simply not true. For an
    example that does not even rely on the differences between recursive and nonrecursive
    build systems, consider the following command line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: As far as `make` is concerned, `clean` and `all` are 100 percent independent
    of each other, so `make` will happily run them both at the same time. Even a novice
    can see the problems with this assumption. The point is, `make` doesn’t understand
    the high-level relationship between `clean` and `all`. That relationship is understood
    only by the author of the makefile. Similar barriers to `make`’s understanding
    of the big picture are artificially introduced at the boundaries between parent
    and child `make` invocations in a recursive build system.
  prefs: []
  type: TYPE_NORMAL
- en: So, how hard is it to turn Jupiter’s recursive build system into a nonrecursive
    system? We want to maintain modularity, so we still want a *Makefile* in each
    directory that essentially manages the tasks of that directory. This is easily
    accomplished by using another feature of common `make`—the `include` directive.
    The `include` directive allows us to break up our single, parent-level makefile
    into chunks of directory-specific rules and then include just those snippets in
    the top-level makefile. [Listing 3-38](ch03.xhtml#ch03ex38) shows what the complete
    updated top-level makefile looks like.
  prefs: []
  type: TYPE_NORMAL
- en: Git tag 3.15
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 3-38:* Makefile: *A nonrecursive version of the top-level makefile*'
  prefs: []
  type: TYPE_NORMAL
- en: Three changes were made here, but please note that the only really significant
    change made to this makefile was the replacement of the rule at ➋ where recursion
    was done with a single rule for `all`, `clean`, `check`, `install`, `uninstall`,
    and an explicit `jupiter` target. Even this replacement could have been a simple
    deletion if we hadn’t cared that the new default target would have become `dist`,
    had we not added the `all` target at this location. I’ve also added an explicit
    `jupiter` target that maps to `src/jupiter` to maintain feature parity with the
    previous system.
  prefs: []
  type: TYPE_NORMAL
- en: The second change made was to include the *src*-level makefile at ➌. Finally,
    I also commented out the `export` statements at ➊ because we no longer need to
    export variables to child `make` processes; they’re left as comments simply for
    illustration.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let’s examine what changed in the *src*-level makefile. The complete, updated
    version is shown in [Listing 3-39](ch03.xhtml#ch03ex39).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 3-39:* src/Makefile: *A nonrecursive version of the src-level makefile*'
  prefs: []
  type: TYPE_NORMAL
- en: First, the `all` target was removed. We don’t need one here now because this
    makefile is not intended to be executed directly but, rather, included by the
    parent makefile. Hence, we do not need a default target. Second, all references
    to objects in the *src* directory are now referenced by paths that are relative
    to the parent directory. Again, this is because `make` is executed only once from
    the parent directory, so references to objects in the *src* directory must be
    considered relative to where `make` is running—the parent directory.
  prefs: []
  type: TYPE_NORMAL
- en: We also removed the `.PHONY` directive at the bottom because this directive
    contained a proper subset of the `.PHONY` directive in the parent makefile, making
    the directive redundant. In short, we merely converted this makefile into a snippet
    that could be included in the parent makefile, removed redundancies, and ensured
    that all filesystem references are now made relative to the parent directory.
    I hope you can see that these changes actually constitute a simplification of
    what we had before. Intuitively, it seems more complicated but it is actually
    simpler.
  prefs: []
  type: TYPE_NORMAL
- en: This makefile is a more accurate and faster version of our recursive system.
    I say “this makefile” because there is really only one makefile here—the included
    file can be pasted directly into the parent makefile at the point of inclusion
    (at ➋ in [Listing 3-38](ch03.xhtml#ch03ex38)), just as with inclusions of header
    files in C-language source files. Ultimately, after all the inclusions are resolved,
    there are only one makefile and one `make` process that executes commands based
    on the rules in that makefile.
  prefs: []
  type: TYPE_NORMAL
- en: One apparent drawback of nonrecursive build systems is that you cannot simply
    enter `make` while sitting in the *src* directory and build the portion of the
    project related to that directory. Instead, you have to change into the parent
    directory and run `make`, which builds everything. But this, too, is a fallacious
    concern because you’ve always had the ability to execute any portion of the build
    system you wished by specifying exactly the target you desired on the `make` command
    line. The difference is that now what gets built is actually what should get built
    because `make` understands the entire set of dependencies for any given target
    you command it to build.
  prefs: []
  type: TYPE_NORMAL
- en: As we’ll see in the coming chapters, Automake has full support for nonrecursive
    build systems. I encourage you to start writing your next project build system
    in a nonrecursive fashion because it can seem like an overwhelming task to retrofit
    an existing system, even though, as we’ve seen here, it’s not really all that
    difficult.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring Your Package
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The *GCS* describes the configuration process in the “How Configuration Should
    Work” subsection of Section 7\. Up to this point, we’ve been able to do about
    everything we’ve wanted to with Jupiter using only makefiles, so you might be
    wondering what configuration is actually for. The opening paragraphs of this subsection
    in the *GCS* answer our question:'
  prefs: []
  type: TYPE_NORMAL
- en: Each GNU distribution should come with a shell script named `configure`. This
    script is given arguments which describe the kind of machine and system you want
    to compile the program for. The `configure` script must record the configuration
    options so that they affect compilation.
  prefs: []
  type: TYPE_NORMAL
- en: The description here is the specification of the interface for the `configure`
    script in GNU packages. Many packages implement it using GNU Autoconf (see “Introduction”
    in Autoconf) and/or GNU Automake (see “Introduction” in Automake), but you do
    not have to use these tools. You can implement it any way you like; for instance,
    by making `configure` be a wrapper around a completely different configuration
    system.
  prefs: []
  type: TYPE_NORMAL
- en: Another way for the `configure` script to operate is to make a link from a standard
    name such as *config.h* to the proper configuration file for the chosen system.
    If you use this technique, the distribution should *not* contain a file named
    *config.h*. This is so that people won’t be able to build the program without
    configuring it first.
  prefs: []
  type: TYPE_NORMAL
- en: Another thing that `configure` can do is to edit the *Makefile*. If you do this,
    the distribution should *not* contain a file named *Makefile*. Instead, it should
    include a file *Makefile.in* which contains the input used for editing. Once again,
    this is so that people won’t be able to build the program without configuring
    it first.^([27](footnote.xhtml#ch03fn27))
  prefs: []
  type: TYPE_NORMAL
- en: 'So then, the primary tasks of a typical configuration script are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Generate files from templates containing replacement variables.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Generate a C-language header file (*config.h*) for inclusion by project source
    code.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Set user options for a particular `make` environment (debug flags and so on).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Set various package options as environment variables.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Test for the existence of tools, libraries, and header files.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For complex projects, configuration scripts often generate the project makefiles
    from one or more templates maintained by project developers. These templates contain
    configuration variables in a format that is easy to recognize (and substitute).
    The configuration script replaces these variables with values determined during
    the configuration process—either from command line options specified by the user
    or from a thorough analysis of the platform environment. This analysis entails
    such things as checking for the existence of certain system or package header
    files and libraries, searching various filesystem paths for required utilities
    and tools, and even running small programs designed to indicate the feature set
    of the shell, C compiler, or desired libraries.
  prefs: []
  type: TYPE_NORMAL
- en: The tool of choice for variable replacement has, in the past, been the `sed`
    stream editor. A simple `sed` command can replace all the configuration variables
    in a makefile template in a single pass through the file. However, Autoconf versions
    2.62 and newer prefer `awk` to `sed` for this process. The `awk` utility is almost
    as pervasive as `sed` these days, and it provides more functionality to allow
    for efficient replacement of many variables. For our purposes on the Jupiter project,
    either of these tools would suffice.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We have now created a complete project build system by hand, with one important
    exception: we haven’t designed a `configure` script according to the design criteria
    specified in the *GNU Coding Standards*. We could do this, but it would take a
    dozen more pages of text to build one that even comes close to conforming to these
    specifications. Still, there are a few key build features related specifically
    to the makefiles that the *GCS* indicates are desirable. Among these is the concept
    of vpath building. This is an important feature that can be properly illustrated
    only by actually writing a configuration script that works as specified by the
    *GCS*.'
  prefs: []
  type: TYPE_NORMAL
- en: Rather than spend the time and effort to do this now, I’d like to simply move
    on to a discussion of Autoconf in [Chapter 4](ch04.xhtml), which will allow us
    to build one of these configuration scripts in as little as two or three lines
    of code. With that behind us, it will be trivial to add vpath building and other
    common Autotools features to the Jupiter project.
  prefs: []
  type: TYPE_NORMAL
