- en: '3'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '3'
- en: UNDERSTANDING THE GNU CODING STANDARDS
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 理解GNU编码标准
- en: '*I don’t know what’s the matter with people: they don’t learn by understanding,
    they learn by some other way—by rote or something. Their knowledge is so fragile!'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: '*我不知道人们怎么了：他们不是通过理解来学习，而是通过其他方式——死记硬背什么的。他们的知识是如此脆弱！*'
- en: —Richard Feynman*, “Surely You’re Joking, Mr. Feynman!”
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: —理查德·费曼*，《你一定是在开玩笑，费曼先生！》
- en: '![Image](../images/common.jpg)'
  id: totrans-4
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/common.jpg)'
- en: In [Chapter 2](ch02.xhtml), I gave an overview of the GNU Autotools and some
    resources that can help reduce the learning curve required to master them. In
    this chapter, we’re going to step back a little and examine project organization
    techniques that you can apply to any project, not just one that uses the Autotools.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第2章](ch02.xhtml)中，我概述了GNU Autotools以及一些能够帮助减少学习曲线的资源。在这一章中，我们将稍微后退一步，探讨一些项目组织技巧，这些技巧不仅适用于使用Autotools的项目，也适用于任何项目。
- en: When you’re done reading this chapter, you should be familiar with the common
    `make` targets and why they exist. You should also have a solid understanding
    of why projects are organized the way they are. You will, in fact, be well on
    your way to becoming an Autotools expert.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 当你读完本章后，你应该熟悉常见的`make`目标及其存在的原因。你还应该对为什么项目会按这种方式组织有一个扎实的理解。事实上，你已经走在了成为Autotools专家的路上。
- en: 'The information provided in this chapter comes primarily from two sources:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 本章提供的信息主要来自两个来源：
- en: The *GNU Coding Standards (GCS)*^([1](footnote.xhtml#ch03fn1))
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*GNU 编码标准（GCS）*^([1](footnote.xhtml#ch03fn1))'
- en: The *Filesystem Hierarchy Standard (FHS)*^([2](footnote.xhtml#ch03fn2))
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*文件系统层次标准（FHS）*^([2](footnote.xhtml#ch03fn2))'
- en: If you’d like to brush up on your `make` syntax, you may also find the *GNU
    Make Manual* ^([3](footnote.xhtml#ch03fn3)) very useful. If you’re particularly
    interested in portable `make` syntax, then check out the POSIX man page for `make`.^([4](footnote.xhtml#ch03fn4))
    Note, however, there are current discussions on the Autotools mailing lists around
    making GNU `make` the target standard because it’s so widely available today.
    Therefore, portable `make` script isn’t as important as it used to be.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想复习一下`make`的语法，你可能会发现*GNU Make 手册* ^([3](footnote.xhtml#ch03fn3)) 非常有用。如果你特别感兴趣于便携式`make`语法，那么查看一下`make`的POSIX手册页^([4](footnote.xhtml#ch03fn4))吧。需要注意的是，目前在Autotools邮件列表中有关于将GNU
    `make`作为目标标准的讨论，因为如今它已广泛可用。因此，便携式`make`脚本的重要性不再像过去那样突出。
- en: Creating a New Project Directory Structure
  id: totrans-11
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建一个新的项目目录结构
- en: 'You need to ask yourself two questions when you’re setting up the build system
    for an open source software project:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 当你为一个开源软件项目设置构建系统时，你需要问自己两个问题：
- en: Which platforms will I target?
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我将针对哪些平台？
- en: What do my users expect?
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我的用户期望什么？
- en: The first is an easy question—you get to decide which platforms to target, but
    you shouldn’t be too restrictive. Open source software projects are only as good
    as their communities, and arbitrarily limiting the number of platforms reduces
    the potential size of your community. However, you might consider supporting only
    current versions of your target platforms. You can check with user groups and
    communities to determine which versions of each are relevant.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个问题是简单的——你可以决定目标平台，但不应过于限制。开源软件项目的好坏取决于其社区，而随意限制平台数量会减少你的社区的潜在规模。然而，你可以考虑只支持目标平台的当前版本。你可以通过与用户组和社区进行交流，确定哪些版本是相关的。
- en: The second question is more difficult to answer. First, let’s narrow the scope
    to something manageable. What you really need to ask is, *What do my users expect
    of my build system?* Experienced open source software developers become familiar
    with these expectations by downloading, unpacking, building, and installing hundreds
    of packages. Eventually, they come to know intuitively what users expect of a
    build system. But, even so, the processes of package configuration, build, and
    installation vary widely, so it’s difficult to define any solid norm.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个问题更难回答。首先，让我们将范围缩小到一个可管理的范畴。你真正需要问的是，*我的用户对我的构建系统有什么期望？* 有经验的开源软件开发人员通过下载、解压、构建和安装数百个软件包，逐渐了解这些期望。最终，他们会直觉地知道用户对构建系统的期望是什么。但即便如此，软件包的配置、构建和安装过程差异巨大，因此很难定义一个固有的标准。
- en: Rather than taking a survey of every build system out there yourself, you can
    consult the Free Software Foundation (FSF), sponsor of the GNU project, which
    has done a lot of the legwork for you. The FSF provides some of the best definitive
    sources of information on free, open source software, including the *GCS*, which
    covers a wide variety of topics related to writing, publishing, and distributing
    free, open source software. Even many non-GNU open source software projects align
    themselves with the *GCS*. Why? Well, the FSF invented the concept of free software,
    and the ideas make sense, for the most part.^([5](footnote.xhtml#ch03fn5)) There
    are dozens of issues to consider when designing a system that manages packaging,
    building, and installing software, and the *GCS* takes most of them into account.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 与其自己调查所有存在的构建系统，你可以查阅自由软件基金会（FSF），这是 GNU 项目的赞助商，它已经为你做了大量的工作。FSF 提供了一些关于自由开源软件的最佳权威信息来源，包括*GCS*，它涵盖了与编写、发布和分发自由开源软件相关的各种话题。即使是许多非
    GNU 的开源软件项目也与*GCS*保持一致。为什么？因为 FSF 发明了自由软件的概念，而且这些理念大多数情况下是有道理的。^([5](footnote.xhtml#ch03fn5))
    在设计一个管理软件打包、构建和安装的系统时，有几十个问题需要考虑，而*GCS* 已经考虑到了其中的大部分。
- en: WHAT’S IN A NAME?
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 名字代表什么？
- en: You probably know that open source software projects generally have quirky names—they
    might be named after some device, an invention, a Latin term, a past hero, an
    ancient god, or they might be named after some small, furry animal that has (vaguely)
    similar characteristics to the software. Some names are just made-up words or
    acronyms that are catchy and easy to pronounce. Another significant characteristic
    of a good project name is uniqueness—it’s important that your project be easy
    to distinguish from others. You also want your project name to be easy to distinguish
    from any other uses of the name in a search engine. Additionally, you should ensure
    that your project’s name does not have negative connotations in any language or
    culture.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能知道，开源软件项目通常有一些奇特的名字——它们可能以某种设备、发明、拉丁术语、过去的英雄、古代神祇命名，或者它们可能以某些小型毛茸茸的动物命名，这些动物与软件有（模糊的）相似特征。也有些名字是捏造的词或缩写，既吸引人又易于发音。一个好项目名字的另一个重要特征是独特性——你的项目必须容易与其他项目区分开来。你还希望项目名字在搜索引擎中能够与其他使用该名字的结果区分开。此外，你还应该确保项目的名字在任何语言或文化中没有负面含义。
- en: Project Structure
  id: totrans-20
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 项目结构
- en: 'We’ll start with a basic sample project and build on it as we continue our
    exploration of source-level software distribution. We’ll call our project *Jupiter*
    and create a project directory structure using the following commands:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从一个基本的示例项目开始，并在继续探索源代码级软件分发的过程中逐步构建它。我们将项目命名为*Jupiter*，并使用以下命令创建项目目录结构：
- en: '[PRE0]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: We now have one source code directory called *src*, one C source file called
    *main.c*, and a makefile for each of the two directories in our project. Minimal,
    yes, but this is a new endeavor and the key to a successful open source software
    project is evolution. Start small and grow as needed—and as you have the time
    and inclination.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了一个名为*src*的源代码目录，一个名为*main.c*的 C 源文件，以及两个目录中的每个文件都包含一个 makefile。简洁，是的，但这是一个新的尝试，成功的开源软件项目的关键在于演化。从小做起，根据需要扩展——以及根据你的时间和兴趣。
- en: Let’s start by adding support for building and cleaning our project. We’ll need
    to add other important capabilities to our build system later on, but these two
    will get us going. The top-level makefile does very little at this point; it merely
    passes requests down to *src/Makefile*, recursively. This constitutes a fairly
    common type of build system, known as a *recursive build system*, so named because
    makefiles recursively invoke `make` on subdirectory makefiles.^([6](footnote.xhtml#ch03fn6))
    We’ll spend a little time at the end of this chapter considering how to convert
    our recursive system into a nonrecursive system.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从添加支持构建和清理项目开始。稍后我们需要为构建系统添加其他重要功能，但这两个功能足以让我们开始。目前，顶级的 makefile 仅做了很少的工作；它只是将请求递归地传递给*src/Makefile*。这构成了一个相当常见的构建系统类型，称为*递归构建系统*，之所以这样命名，是因为
    makefile 会递归地调用 `make` 来处理子目录的 makefile。^([6](footnote.xhtml#ch03fn6)) 我们将在本章的最后花些时间思考如何将递归系统转换为非递归系统。
- en: '[Listings 3-1](ch03.xhtml#ch03ex01) through [3-3](ch03.xhtml#ch03ex03) show
    the contents of each of these three files, thus far.'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 3-1](ch03.xhtml#ch03ex01) 到 [3-3](ch03.xhtml#ch03ex03) 显示了目前为止这三份文件的内容。'
- en: Git tag 3.0
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: Git 标签 3.0
- en: '[PRE1]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '*Listing 3-1: Makefile: An initial draft of a top-level makefile for Jupiter*'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 3-1：Makefile：Jupiter 顶层 makefile 的初步草稿*'
- en: '[PRE2]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '*Listing 3-2:* src/Makefile: *The first draft of Jupiter’s src directory makefile*'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 3-2：* src/Makefile：*Jupiter 的 src 目录 makefile 的初步草稿*'
- en: '[PRE3]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '*Listing 3-3:* src/main.c: *The first version of the only C source file in
    the Jupiter project*'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 3-3：* src/main.c：*Jupiter 项目中唯一的 C 源文件的第一个版本*'
- en: '**NOTE**'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*As you read this code, you will probably notice places where a makefile or
    a source code file contains a construct that is not written in the simplest manner
    or is perhaps not written the way you would have chosen to write it. There is
    a method to my madness: I’ve tried to use constructs that are portable to many
    flavors of the *`make`* utility.*'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '*当你阅读这段代码时，你可能会注意到一些地方，其中的 makefile 或源代码文件包含了不是以最简单的方式编写的结构，或者可能不是你选择的编写方式。我的疯狂背后是有方法的：我试图使用许多
    *`make`* 工具可以兼容的结构。*'
- en: Now let’s discuss the basics of `make`. If you’re already pretty well versed
    in it, you can skip the next section. Otherwise, give it a quick read, and we’ll
    return our attention to the Jupiter project later in the chapter.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们讨论一下 `make` 的基础。如果你已经相当熟悉它了，可以跳过下一节。否则，快速阅读一下，我们稍后会在本章的后续部分回到 Jupiter 项目。
- en: Makefile Basics
  id: totrans-36
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Makefile 基础
- en: 'If you don’t use `make` on a regular basis, it’s often difficult to remember
    exactly what goes where in a makefile, so here are a few things to keep in mind.
    Besides comments, which begin with a hash mark (`#`), there are only two basic
    types of entities in a makefile:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不经常使用 `make`，通常很难记住在 makefile 中具体该放什么内容，因此这里有一些需要记住的要点。除了以井号（`#`）开头的注释外，makefile
    中只有两种基本类型的实体：
- en: Rule definitions
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 规则定义
- en: Variable assignments
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 变量赋值
- en: While there are several other types of constructs in a makefile (including conditional
    statements, directives, extension rules, pattern rules, function variables, and
    include statements, among others), for our purposes, we’ll just touch lightly
    on them as needed instead of covering them all in detail. This doesn’t mean they’re
    unimportant. On the contrary, they’re very useful if you’re going to write your
    own complex build system by hand. However, our purpose is to gain the background
    necessary for understanding the GNU Autotools, so I’ll only cover the aspects
    of `make` you need to know to accomplish that goal.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管在 makefile 中还有其他几种类型的结构（包括条件语句、指令、扩展规则、模式规则、函数变量和包含语句等），但为了我们的目的，我们只会在需要时简单提及它们，而不是详细讨论所有内容。这并不意味着它们不重要。相反，如果你要手动编写自己的复杂构建系统，它们非常有用。不过，我们的目标是为理解
    GNU Autotools 打下必要的基础，因此我只会讲解你需要了解的 `make` 相关部分。
- en: If you want a broader education on `make` syntax, refer to the *GNU Make Manual*.
    For strictly portable syntax, the POSIX man page for `make` is an excellent reference.
    If you want to become a `make` expert, be prepared to spend a good deal of time
    studying these resources—there’s much more to the `make` utility than is initially
    apparent.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想更深入了解 `make` 语法，可以参考 *GNU Make 手册*。对于严格的可移植语法，POSIX 中的 `make` 手册页是一个很好的参考。如果你想成为
    `make` 专家，要准备花费相当多的时间学习这些资源——`make` 工具的功能远比最初看到的要复杂得多。
- en: '*Rules*'
  id: totrans-42
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*规则*'
- en: Rules follow the general format shown in [Listing 3-4](ch03.xhtml#ch03ex04).
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 规则遵循 [清单 3-4](ch03.xhtml#ch03ex04) 中展示的通用格式。
- en: '[PRE4]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '*Listing 3-4: The syntax of a rule within a makefile*'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 3-4：Makefile 中规则的语法*'
- en: In this syntax definition, square brackets (`[` and `]`) denote optional portions
    of a rule and `<tab>` represents a tab (ctrl-i) character.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在此语法定义中，方括号（`[` 和 `]`）表示规则的可选部分，`<tab>` 表示一个制表符（ctrl-i）字符。
- en: Except for the tab characters and the line feeds, all other whitespace is optional
    and ignored. When a line in a makefile begins with a tab character, `make` generally
    considers it a command (with the exception of continuation lines, discussed later).
    Indeed, one of the most frustrating aspects of makefile syntax to neophytes and
    experts alike is that commands must be prefixed with an essentially invisible
    character. The error messages generated by the legacy UNIX `make` utility when
    a required tab is missing (or has been converted to spaces by your editor), or
    when an unintentional tab is inserted at the start of a line that follows something
    that could be interpreted as a rule, are obscure at best. GNU `make` does a better
    job with such error messages. Nonetheless, be careful to use leading tab characters
    properly in your makefiles—always and only before commands.^([7](footnote.xhtml#ch03fn7))
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 除了制表符字符和换行符外，所有其他空白字符都是可选的并且会被忽略。当makefile中的一行以制表符字符开始时，`make`通常会将其视为命令（续行除外，后面会讨论）。事实上，对于初学者和专家来说，makefile语法中最令人沮丧的一点就是命令必须以一个本质上不可见的字符为前缀。当遗留的UNIX
    `make`工具缺少所需的制表符（或被编辑器转换为空格），或当意外的制表符被插入到可能被解释为规则的行的开头时，生成的错误消息往往模糊不清。GNU `make`在这些错误消息上做得更好。尽管如此，在makefile中使用制表符字符时仍然要小心——它们必须始终且仅仅出现在命令之前。^([7](footnote.xhtml#ch03fn7))
- en: Note that almost everything in a rule is optional; the only required aspect
    of a rule is the *`targets`* portion and its colon (`:`) character. Use of the
    first command, *`command-0`* and its preceding semicolon (`;`), is an optional
    form that’s generally discouraged by the Autotools, but is perfectly legitimate
    `make` syntax if you have a single command to execute. You may even combine *`command-0`*
    with additional commands, but this almost never done.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，规则中的几乎所有内容都是可选的；规则中唯一必须的部分是*`targets`*部分及其冒号（`:`）字符。使用第一个命令，*`command-0`*及其前面的分号（`;`）是一种可选形式，通常Autotools不推荐使用，但如果你只有一个命令要执行，`make`语法是完全合法的。你甚至可以将*`command-0`*与其他命令结合使用，但这几乎从不发生。
- en: In general, *targets* are objects that need to be built, and *dependencies*
    are objects that provide source material for targets. Thus, targets are said to
    depend upon the dependencies. Dependencies are essentially *prerequisites* of
    the targets, and therefore they should be updated first.^([8](footnote.xhtml#ch03fn8))
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 一般来说，*目标*是需要构建的对象，而*依赖*是为目标提供源材料的对象。因此，目标被认为依赖于依赖。依赖本质上是目标的*前提条件*，因此应该首先更新它们。^([8](footnote.xhtml#ch03fn8))
- en: '[Listing 3-5](ch03.xhtml#ch03ex05) shows the general layout of a makefile.'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 3-5](ch03.xhtml#ch03ex05)展示了makefile的一般布局。'
- en: '[PRE5]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '*Listing 3-5: The general layout of a makefile*'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 3-5：makefile的一般布局*'
- en: The contents of a makefile comprise a *declarative language* wherein you define
    a set of desired goals and `make` decides the best way to accomplish those goals.
    The `make` utility is a rule-based command engine, and the rules at work indicate
    which commands should be executed and when. When you define commands within rules,
    you’re telling `make` that you want it to execute each of the following statements
    from a shell whenever the preceding target should be built. Presumably, the commands
    actually do create or update the target. The existence and timestamps of the files
    mentioned in the targets and dependencies of rules indicate whether the commands
    should be executed and in what order.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: makefile的内容包含一种*声明性语言*，在其中你定义了一组期望的目标，`make`决定实现这些目标的最佳方式。`make`工具是一个基于规则的命令引擎，工作中的规则指示哪些命令应当执行，以及何时执行。当你在规则中定义命令时，你实际上是在告诉`make`，当前面的目标需要构建时，你希望它从shell中执行以下每个语句。假定这些命令实际上会创建或更新目标。规则中提到的目标和依赖项的文件存在性和时间戳指示是否应该执行命令以及执行的顺序。
- en: As `make` processes the text in a makefile, it builds a web of dependency chains
    (technically called a *directed acyclic graph*, or *DAG*). When building a particular
    target, `make` must walk backward through the entire graph to the beginning of
    each “chain.” While traversing a chain, `make` executes the commands for each
    rule, beginning with the rule farthest from the target and working forward to
    the rule for the desired target. As `make` discovers targets that are older than
    their dependencies, it must execute the associated set of commands to update those
    targets before it can process the next rule in the chain. As long as the rules
    are written correctly, this algorithm ensures that `make` will build a completely
    up-to-date product using the least number of operations possible. Indeed, as we’ll
    see shortly, when the rules in a makefile are written properly, it’s rather a
    joy to watch it run after various changes to files in the project.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 当 `make` 处理 makefile 中的文本时，它会构建一个依赖关系链的网络（技术上称为*有向无环图*，或 *DAG*）。在构建特定目标时，`make`
    必须从整个图中倒推回到每个“链”的起始点。在遍历链时，`make` 会执行每个规则的命令，从距离目标最远的规则开始，一直到所需目标的规则。当 `make`
    发现某些目标比它们的依赖项更新较旧时，它必须执行相关的命令集来更新这些目标，然后才能处理链中的下一个规则。只要规则编写正确，这个算法确保了 `make` 会用尽可能少的操作构建一个完全最新的产品。实际上，正如我们稍后会看到的，当
    makefile 中的规则编写得当时，看它在项目中的文件发生变化后运行，实际上是一种乐趣。
- en: '*Variables*'
  id: totrans-55
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*变量*'
- en: Lines in a makefile containing an equal sign (`=`) are variable definitions.
    Variables in makefiles are somewhat similar to shell or environment variables,
    but there are some key differences.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 包含等号（`=`）的 makefile 行是变量定义。在 makefile 中的变量与 Shell 或环境变量有些相似，但也有一些关键的区别。
- en: 'In Bourne-shell syntax, you’d reference a variable in this manner: `${my_var}`.
    Equally viable, without the curly brackets, is `$my_var`. The syntax for referencing
    variables in a makefile is nearly identical, except that you have the choice of
    using curly brackets or parentheses: `$(my_var)`. To minimize confusion, it has
    become somewhat of a convention to use parentheses rather than curly brackets
    when dereferencing `make` variables. For single-character `make` variables, using
    these delimiters is optional, but you should use them in order to avoid ambiguity.
    For example, `$X` is functionally equivalent to `$(X)` or `${X}`, but `$(my_var)`
    would require parentheses so `make` does not interpret the reference as `$(m)y_var`.'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Bourne Shell 语法中，你可以这样引用一个变量：`${my_var}`。同样可以使用不带花括号的形式：`$my_var`。在 makefile
    中引用变量的语法几乎相同，不过你可以选择使用花括号或圆括号：`$(my_var)`。为了减少混淆，已成为一种约定，在取消引用 `make` 变量时使用圆括号而非花括号。对于单字符
    `make` 变量，使用这些分隔符是可选的，但为了避免歧义，应该使用它们。例如，`$X` 在功能上等同于 `$(X)` 或 `${X}`，但是 `$(my_var)`
    需要使用圆括号，以便 `make` 不会将引用解释为 `$(m)y_var`。
- en: '**NOTE**'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*To dereference a shell variable inside a *`make`* command, escape the dollar
    sign by doubling it—for example, *`$${shell_var}`*. Escaping the dollar sign tells
    *`make`* not to interpret the variable reference but rather to treat it as literal
    text in the command. The variable reference is thus left to be interpolated by
    the shell when the command is executed.*'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '*在*`make`*命令中取消引用一个 Shell 变量时，通过将美元符号加倍来转义它—例如，*`$${shell_var}`*。转义美元符号告诉*`make`*不要解释变量引用，而是将其视为命令中的字面文本。因此，变量引用将在命令执行时由
    Shell 进行插值。*'
- en: By default, *`make`* reads the process environment into its variable table before
    processing the makefile; this allows you to access most environment variables
    without explicitly defining them in the makefile. Note, however, that variables
    set inside the makefile will override those obtained from the environment.^([9](footnote.xhtml#ch03fn9))
    It’s generally not a good idea to depend on the existence of environment variables
    in your build process, although it’s okay to use them conditionally. In addition,
    `make` defines several useful variables of its own, such as the `MAKE` variable,
    the value of which is the command used to invoke `make` for the current process.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，*`make`* 在处理 makefile 之前会读取进程环境到其变量表中；这使你可以访问大多数环境变量，而无需在 makefile 中显式定义它们。然而，注意，在
    makefile 中设置的变量将覆盖从环境中获得的变量。^([9](footnote.xhtml#ch03fn9)) 通常，不建议在构建过程中依赖环境变量的存在，尽管可以在条件情况下使用它们。此外，`make`
    定义了几个有用的变量，例如 `MAKE` 变量，其值为当前进程中调用 `make` 的命令。
- en: You can assign variables at any point in the makefile. However, you should be
    aware that `make` processes a makefile in two passes. In the first pass, it gathers
    variables and rules into tables and internal structures. In the second pass, it
    resolves dependencies defined by the rules, invoking those rules as necessary
    to rebuild the dependencies based on the filesystem timestamps gathered during
    the first pass. If a dependency in a rule is newer than the target or if the target
    is missing, then `make` executes the commands of the rule to update the target.
    Some variable references are resolved immediately during the first pass while
    processing rules, and others are resolved later during the second pass while executing
    commands.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在 makefile 中的任何位置分配变量。然而，你需要注意的是，`make` 会对 makefile 进行两次处理。在第一次处理中，它会将变量和规则收集到表格和内部结构中。在第二次处理中，它会解析规则定义的依赖关系，根据第一次处理时收集到的文件系统时间戳调用规则，以重建依赖关系。如果规则中的依赖项比目标更新，或者目标缺失，那么
    `make` 会执行该规则的命令来更新目标。某些变量引用在第一次处理规则时会立即解析，而其他的则在执行命令时，在第二次处理中解析。
- en: '*A Separate Shell for Each Command*'
  id: totrans-62
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*每个命令使用单独的 Shell*'
- en: As it processes rules, `make` executes each command independently of those around
    it. That is, each individual command under a rule is executed in its own shell.
    This means that you cannot export a shell variable in one command and then try
    to access its value in the next.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理规则时，`make` 会独立执行每个命令。也就是说，规则下的每个命令都会在各自的 shell 中执行。这意味着你不能在一个命令中导出一个 shell
    变量，然后在下一个命令中尝试访问它的值。
- en: To do something like this, you would have to string commands together on the
    same command line with command separator characters (for example, semicolons in
    Bourne-shell syntax). When you write commands like this, `make` passes the set
    of concatenated commands as one command line to the same shell. To avoid long
    command lines and increase readability, you can wrap them using a backslash at
    the end of each line—by convention, after the semicolon.^([10](footnote.xhtml#ch03fn10))
    The wrapped portion of such commands may also be preceded by a tab character.
    POSIX specifies that `make` remove all leading tab characters (even those following
    escaped newlines) before processing commands, but be aware that some implementations
    of `make` do output—usually harmlessly—the tab characters embedded within wrapped
    commands.^([11](footnote.xhtml#ch03fn11))
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想做类似的事情，你需要将命令串联在同一命令行上，使用命令分隔符（例如，Bourne shell 语法中的分号）。当你像这样写命令时，`make`
    会将串联的命令作为一条命令行传递给同一个 shell。为了避免过长的命令行并增加可读性，你可以在每一行的末尾使用反斜杠将它们包裹起来——按照惯例，在分号后面。^([10](footnote.xhtml#ch03fn10))
    这类命令的包装部分也可以用制表符字符来开头。POSIX 指定 `make` 在处理命令之前会移除所有前导的制表符字符（即便是那些跟在转义的换行符后的制表符），但需要注意的是，某些
    `make` 实现可能会输出这些嵌入在包裹命令中的制表符字符——通常是无害的。^([11](footnote.xhtml#ch03fn11))
- en: '[Listing 3-6](ch03.xhtml#ch03ex06) shows a few simple examples of multiple
    commands that will be executed by the same shell.'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 3-6](ch03.xhtml#ch03ex06) 显示了一些简单的多命令示例，这些命令将由同一个 shell 执行。'
- en: '[PRE6]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '*Listing 3-6: A makefile with some examples of multiple commands executed by
    the same shell*'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 3-6：一个包含多个命令示例的 makefile，这些命令将由同一个 shell 执行*'
- en: In the first example at ➊, both lines are executed by the same shell because
    the backslash escapes the newline character between the lines. The `make` utility
    will remove any escaped newline characters before passing a single, multi-command
    statement to the shell. The second example at ➋ is identical to the first, from
    `make`’s perspective.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一个例子 ➊ 中，两行命令由同一个 shell 执行，因为反斜杠将两行之间的换行符转义。`make` 工具会在将一条多命令语句传递给 shell 之前，删除所有转义的换行符。第二个例子
    ➋ 与第一个例子在 `make` 的角度上是相同的。
- en: The third example at ➌ is a bit different. In this case, I’ve defined the `TMPDIR`
    variable only for the child process that will run `gcc`.^([12](footnote.xhtml#ch03fn12))
    Note the missing semicolon; as far as the shell is concerned, this is a single
    command.^([13](footnote.xhtml#ch03fn13))
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 第三个例子 ➌ 有些不同。在这种情况下，我仅为将运行 `gcc` 的子进程定义了 `TMPDIR` 变量。^([12](footnote.xhtml#ch03fn12))
    注意缺少的分号；从 shell 的角度来看，这只是一个单独的命令。^([13](footnote.xhtml#ch03fn13))
- en: '**NOTE**'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*If you choose to wrap commands with a trailing backslash, be sure that there
    are no spaces or other invisible characters after it. The backslash escapes the
    newline character, so it must immediately precede that character.*'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '*如果你选择用一个反斜杠来换行命令，请确保反斜杠后面没有空格或其他不可见字符。反斜杠转义了换行符，因此它必须紧接在换行符之前。*'
- en: '*Variable Binding*'
  id: totrans-72
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*变量绑定*'
- en: Variables referenced in commands may be defined after the command in the makefile
    because such references are not bound to their values until just before `make`
    passes the command to the shell for execution—long after the entire makefile has
    been read. In general, `make` binds variables to values as late as it possibly
    can.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在命令中引用的变量可能在makefile中的命令之后才被定义，因为这些引用的值直到`make`将命令传递给shell执行之前才会被绑定——也就是说，直到整个makefile被读取完之后。在一般情况下，`make`会尽可能推迟将变量绑定到值。
- en: Since commands are processed at a later stage than rules, variable references
    in commands are bound later than those in rules. Variable references found in
    rules are expanded when `make` builds the directed graph from the rules in the
    makefile. Thus, a variable referenced in a rule must be fully defined in a makefile
    before the referencing rule. [Listing 3-7](ch03.xhtml#ch03ex07) shows a portion
    of a makefile that illustrates both of these concepts.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 由于命令在规则之后处理，命令中的变量引用会比规则中的变量引用晚绑定。在规则中找到的变量引用在`make`根据规则构建有向图时会被扩展。因此，在规则中引用的变量必须在makefile中完全定义，且在引用规则之前。
    [清单 3-7](ch03.xhtml#ch03ex07)展示了一个makefile的部分内容，说明了这两个概念。
- en: '[PRE7]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '*Listing 3-7: Variable expansion in a makefile*'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 3-7：makefile中的变量扩展*'
- en: In the rule at ➊, both references to `$(mytarget)` are expanded to `foo` because
    they’re processed during the first pass, when `make` is building the variable
    list and directed graph. However, the outcome is probably not what you’d expect,
    because both references to `$(mytarget)` in the command at ➋ are not expanded
    until much later, long after `make` has already assigned `bar` to `mytarget`,
    overwriting the original assignment of `foo`.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在➊规则中，`$(mytarget)`的两个引用在第一次处理时都被扩展为`foo`，因为那时`make`正在构建变量列表和有向图。然而，结果可能并不是你预期的，因为在➋命令中的两个`$(mytarget)`引用要到稍后才会被扩展，远在`make`已经将`bar`赋值给`mytarget`，并覆盖了原本的`foo`赋值之后。
- en: '[Listing 3-8](ch03.xhtml#ch03ex08) shows the same rule and command the way
    `make` sees them after the variables are fully expanded.'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '[清单 3-8](ch03.xhtml#ch03ex08)展示了在变量完全扩展后，`make`如何看待相同的规则和命令。'
- en: '[PRE8]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '*Listing 3-8: The results after variable expansion of the code in [Listing
    3-7](ch03.xhtml#ch03ex07)*'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 3-8：代码在[清单 3-7](ch03.xhtml#ch03ex07)中的变量扩展结果*'
- en: The moral of this story is that you should understand where variables will be
    expanded in makefile constructs so you’re not surprised when `make` refuses to
    act in a sane manner when it processes your makefile. It is good practice (and
    a good way to avoid headaches) to always assign variables before you intend to
    use them. For more information on immediate and deferred expansion of variables
    in makefiles, refer to “How make Reads a Makefile” in the *GNU Make Manual*.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 这个故事的寓意是，你应该了解在makefile结构中，变量会在哪里被扩展，这样你就不会感到惊讶，当`make`处理你的makefile时不按预期的方式执行。良好的实践（也是避免头痛的好方法）是，在打算使用变量之前，总是先赋值给它们。有关makefile中变量的即时扩展和延迟扩展的更多信息，请参考*GNU
    Make手册*中的“make如何读取makefile”一节。
- en: '*Rules in Detail*'
  id: totrans-82
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*规则详细信息*'
- en: The rules used in my examples, known as *common* `make` rules, contain a single
    colon character (`:`). The colon separates targets on the left from dependencies
    on the right.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 我在示例中使用的规则，称为*常见*的`make`规则，包含一个冒号字符（`:`）。冒号将左边的目标与右边的依赖项分开。
- en: Remember that targets are products—that is, filesystem entities that can be
    produced by running one or more commands, such as a C or C++ compiler, a linker,
    or a documentation generator like Doxygen or LaTeX. Dependencies, on the other
    hand, are source objects, or objects from which targets are created. These may
    be computer language source files, intermediate products built by a previous rule,
    or anything else that can be used by a command as a resource.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，目标是产物——即通过执行一个或多个命令（如C或C++编译器、链接器，或者像Doxygen或LaTeX这样的文档生成器）可以生成的文件系统实体。而依赖关系则是源对象，或者是用来创建目标的对象。这些对象可能是计算机语言源文件、先前规则构建的中间产品，或者任何可以被命令用作资源的东西。
- en: You can specify any target defined within a makefile rule directly on the `make`
    command line, and `make` will execute all the commands necessary to generate that
    target.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在`make`命令行中直接指定任何在makefile规则中定义的目标，`make`将执行生成该目标所需的所有命令。
- en: '**NOTE**'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*If you don’t specify any targets on the *`make`* command line, *`make`* will
    use the default target—the first one it finds in the makefile.*'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '*如果你没有在`make`命令行中指定任何目标，`make`将使用默认目标——即它在makefile中找到的第一个目标。*'
- en: For example, a C compiler takes dependency *main.c* as input and generates target
    *main.o*. A linker then takes dependency *main.o* as input and generates a named
    executable target—`program`, in this case.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，一个 C 编译器接受依赖项 *main.c* 作为输入并生成目标 *main.o*。然后，链接器以 *main.o* 作为输入并生成一个命名的可执行目标——在这种情况下是
    `program`。
- en: '[Figure 3-1](ch03.xhtml#ch03fig01) shows the flow of data as it might be specified
    by the rules defined in a makefile.'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 3-1](ch03.xhtml#ch03fig01) 显示了数据流的过程，这些流程可能由 Makefile 中定义的规则指定。'
- en: '![Image](../images/03fig01.jpg)'
  id: totrans-90
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/03fig01.jpg)'
- en: '*Figure 3-1: A data flow diagram for the compile and link processes*'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 3-1：编译和链接过程的数据流图*'
- en: The `make` utility implements some fairly complex logic to determine when a
    rule should be run, based on whether a target exists and whether it is older than
    its dependencies. [Listing 3-9](ch03.xhtml#ch03ex09) shows a makefile containing
    rules, some of which execute the actions in [Figure 3-1](ch03.xhtml#ch03fig01).
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '`make` 工具实现了一些相当复杂的逻辑，用来判断何时执行一个规则，依据是目标文件是否存在，以及它是否比其依赖项旧。[列表 3-9](ch03.xhtml#ch03ex09)
    显示了一个包含规则的 Makefile，其中一些规则会执行 [图 3-1](ch03.xhtml#ch03fig01) 中的操作。'
- en: '[PRE9]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '*Listing 3-9: Using multiple `make` rules to compile and link a program*'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 3-9：使用多个 `make` 规则编译并链接程序*'
- en: The first rule in this makefile says that `program` depends on *main.o*, *print.o*,
    and *display.o*. The remaining rules say that each *.o* file depends on the corresponding
    *.c* file. Ultimately, `program` depends on the three source files, but the object
    files are necessary as intermediate dependencies because there are two steps to
    the process—compile and link—with a result in between. For each rule, `make` uses
    an associated list of commands to build the rule’s target from its list of dependencies.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 这个 Makefile 中的第一个规则指出，`program` 依赖于 *main.o*、*print.o* 和 *display.o*。其余的规则则表示每个
    *.o* 文件依赖于相应的 *.c* 文件。最终，`program` 依赖于这三个源文件，但由于过程分为编译和链接两个步骤，中间还需要生成结果，因此必须有对象文件作为中间依赖。在每个规则中，`make`
    使用关联的命令列表根据依赖项列表构建规则的目标。
- en: Unix compilers are designed as higher-level tools than linkers. They have built-in,
    low-level knowledge about system-specific linker requirements. In the makefile
    in [Listing 3-9](ch03.xhtml#ch03ex09), the ellipsis in the line at ➊ is a placeholder
    for a list of system-specific, low-level objects and libraries required to build
    all programs on this system. The compiler can be used to call the linker, silently
    passing these system-specific objects and libraries. (It’s so effective and widely
    used that it’s often difficult to discover how to manually execute the linker
    on a given system.) [Listing 3-10](ch03.xhtml#ch03ex10) shows how you might rewrite
    the makefile from [Listing 3-9](ch03.xhtml#ch03ex09) to use the compiler to compile
    the sources and call the linker in a single rule.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: Unix 编译器设计为比链接器更高级的工具。它们内置了关于特定系统链接器要求的低级知识。在 [列表 3-9](ch03.xhtml#ch03ex09)
    中的 Makefile，➊ 处的省略号是一个占位符，用于表示构建系统上所有程序所需的系统特定、低级对象和库的列表。编译器可以用来调用链接器，并默默地传递这些系统特定的对象和库。（这种方法非常有效且广泛使用，以至于通常很难发现如何在给定系统上手动执行链接器。）[列表
    3-10](ch03.xhtml#ch03ex10) 显示了你如何重写 [列表 3-9](ch03.xhtml#ch03ex09) 中的 Makefile，使用编译器来编译源代码并在单个规则中调用链接器。
- en: '[PRE10]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '*Listing 3-10: Using a single `make` rule to compile sources into an executable*'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 3-10：使用单个 `make` 规则将源代码编译成可执行文件*'
- en: '**NOTE**'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*Using a single rule and command to process both steps is possible in this
    case because the example is very basic. For larger projects, skipping from source
    to executable in a single step is usually not the wisest way to manage the build
    process. However, in either case, using the compiler to call the linker can ease
    the burden of determining the many system objects that need to be linked into
    an application, and, in fact, this very technique is used quite often. More complex
    examples, wherein each file is compiled separately, use the compiler to compile
    each source file into an object file and then use the compiler to call the linker
    to link them all together into an executable.*'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '*在这种情况下，使用单个规则和命令来处理这两个步骤是可行的，因为这个示例非常基础。对于更大的项目，通常不建议在一个步骤中直接从源代码跳到可执行文件。然而，在任何情况下，使用编译器调用链接器可以减轻确定需要链接到应用程序的许多系统对象的负担，实际上，这个技术非常常见并被广泛使用。更复杂的示例中，每个文件会被单独编译，编译器会将每个源文件编译成对象文件，然后使用编译器调用链接器将所有文件链接成一个可执行文件。*'
- en: 'In this example, I’ve added a `make` variable (`sources`) that allows us to
    consolidate all product dependencies into one location. We now have a list of
    source files captured in a variable definition that is referenced in two places:
    in the dependency list and on the command line.'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我添加了一个 `make` 变量（`sources`），它允许我们将所有产品依赖项整合到一个位置。现在，我们有一个源文件列表，该列表在两个地方引用：在依赖列表中和命令行中。
- en: Automatic Variables
  id: totrans-102
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 自动变量
- en: There may be other kinds of objects in a dependency list that are not in the
    `sources` variable, including precompiled objects and libraries. These other objects
    would have to be listed separately, both in the rule and on the command line.
    Wouldn’t it be nice if we had a shorthand notation for referencing the rule’s
    entire dependency list in the commands?
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 依赖列表中可能包含其他不是 `sources` 变量中的对象，包括预编译对象和库。这些其他对象必须在规则中和命令行中分别列出。如果我们能为引用规则的整个依赖列表提供简写形式，那该有多好？
- en: 'As it happens, various *automatic* variables can be used to reference portions
    of the controlling rule during the execution of a command. Unfortunately, most
    of these are all but useless if you care about portability between implementations
    of `make`. The `$@` variable (which references the current target) happens to
    be portable and useful, but most of the other automatic variables are too limited
    to be very useful.^([14](footnote.xhtml#ch03fn14)) The following is a complete
    list of portable automatic variables defined by POSIX for `make`:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，各种 *自动* 变量可以在执行命令时引用控制规则的部分。不幸的是，如果你关心 `make` 实现之间的可移植性，这些大多数都几乎无用。`$@`
    变量（引用当前目标）是可移植且有用的，但其他大多数自动变量过于有限，无法发挥太大作用。^([14](footnote.xhtml#ch03fn14)) 以下是
    POSIX 为 `make` 定义的完整可移植自动变量列表：
- en: '`$@` refers to the full target name of the current target or the archive filename
    part of a library archive target. This variable is valid in both explicit and
    implicit rules.'
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`$@` 指当前目标的完整目标名称或库归档目标的归档文件名部分。此变量在显式和隐式规则中都有效。'
- en: '`$%` refers to a member of an archive and is valid only when the current target
    is an archive member—that is, an object file that is a member of a static library.
    This variable is valid in both explicit and implicit rules.'
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`$%` 指归档成员，仅在当前目标是归档成员时有效——即静态库中的目标文件。此变量在显式和隐式规则中都有效。'
- en: '`$?` refers to the list of dependencies that are newer than the current target.
    This variable is valid in both explicit and implicit rules.'
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`$?` 指比当前目标更新的依赖项列表。此变量在显式和隐式规则中都有效。'
- en: '`$<` refers to the member of the dependency list whose existence allowed the
    rule to be chosen for the target. This variable is only valid in implicit rules.'
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`$<` 指依赖列表中允许选择该规则的依赖项。此变量仅在隐式规则中有效。'
- en: '`$*` refers to the current target name with its suffix deleted. This variable
    is guaranteed by POSIX to be valid only in implicit rules.'
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`$*` 指当前目标名称，去掉其后缀部分。POSIX 保证此变量仅在隐式规则中有效。'
- en: GNU `make` dramatically extends the POSIX-defined list, but since GNU extensions
    are not portable, it’s unwise to use any of these except `$@`.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: GNU `make` 大大扩展了 POSIX 定义的列表，但由于 GNU 扩展不可移植，除 `$@` 外不建议使用这些扩展。
- en: Dependency Rules
  id: totrans-111
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 依赖规则
- en: Let us now assume that *print.c* and *display.c* each have a header file of
    the same name, ending in *.h*. Each of these source files includes its own header
    file, but *main.c* includes both *print.h* and *display.h*. Given the makefiles
    of [Listings 3-9](ch03.xhtml#ch03ex09) and [3-10](ch03.xhtml#ch03ex10), what do
    you suppose would happen if you executed `make` to build `program`, then modified
    one of the header files—say *print.h*—and then re-executed `make`? Nothing would
    happen because `make` is unaware even of the existence of these header files.
    As far as `make` is concerned, you didn’t touch anything related to `program`.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 假设 *print.c* 和 *display.c* 各自有一个同名的头文件，以 *.h* 结尾。每个源文件都包含自己的头文件，但 *main.c* 包含了
    *print.h* 和 *display.h*。根据 [Listings 3-9](ch03.xhtml#ch03ex09) 和 [3-10](ch03.xhtml#ch03ex10)
    中的 makefile，如果你执行 `make` 来构建 `program`，然后修改其中一个头文件——比如 *print.h*，再重新执行 `make`，你觉得会发生什么？什么都不会发生，因为
    `make` 根本不知道这些头文件的存在。在 `make` 看来，你并没有更改任何与 `program` 相关的内容。
- en: In [Listing 3-11](ch03.xhtml#ch03ex11), I’ve replaced the `sources` variable
    with an `objects` variable and replaced the list of source files with a list of
    object files. This version of the makefile in [Listing 3-10](ch03.xhtml#ch03ex10)
    also eliminates redundancy by making use of both standard and automatic variables.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 在[列表3-11](ch03.xhtml#ch03ex11)中，我将`sources`变量替换为`objects`变量，并用对象文件列表替换了源文件列表。这个版本的makefile在[列表3-10](ch03.xhtml#ch03ex10)中也通过利用标准和自动变量，消除了冗余。
- en: '[PRE11]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '*Listing 3-11: Using automatic variables in a command*'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表3-11：在命令中使用自动变量*'
- en: I’ve also added three *dependency rules*, which are rules without commands that
    clarify the relationships between compiler output files and dependent source and
    header files. Because *print.h* and *display.h* are (presumably) included by *main.c*,
    *main.c* must be recompiled if either of those files changes; however, `make`
    has no way of knowing that these two header files are included by *main.c*. Dependency
    rules allow the developer to tell `make` about such backend relationships.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 我还添加了三个*依赖规则*，这些规则没有命令，目的是澄清编译器输出文件与依赖的源文件和头文件之间的关系。因为*print.h*和*display.h*（假定）被*main.c*包含，若这两个文件中的任何一个发生变化，*main.c*就必须重新编译；然而，`make`并不能知道这两个头文件是被*main.c*包含的。依赖规则允许开发者告知`make`这种后端关系。
- en: Implicit Rules
  id: totrans-117
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 隐式规则
- en: If you attempt to mentally follow the dependency graph that `make` would build
    from the rules within the makefile in [Listing 3-11](ch03.xhtml#ch03ex11), you’ll
    find what appears to be a hole in the web. According to the last rule in the file,
    the `program` executable depends on *main.o*, *print.o*, and *display.o*. This
    rule also provides the command to link these objects into an executable (using
    the compiler merely to call the linker this time). The object files are tied to
    their corresponding C source and header files by the three dependency rules. But
    where are the commands that compile the *.c* files into *.o* files?
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你试图根据[列表3-11](ch03.xhtml#ch03ex11)中的makefile规则，心算出`make`将构建的依赖图，你会发现网络中似乎有个漏洞。根据文件中的最后一条规则，`program`可执行文件依赖于*main.o*、*print.o*和*display.o*。此规则还提供了将这些目标链接成可执行文件的命令（这次只是调用链接器，而使用编译器）。这些目标文件通过三个依赖规则与它们对应的C源文件和头文件相关联。但编译*.c*文件成*.o*文件的命令在哪里？
- en: We could add these commands to the dependency rules, but there’s really no need
    because `make` has a *built-in* rule that knows how to build *.o* files from *.c*
    files. There’s nothing magic about `make`—it only knows about the relationships
    you describe to it through the rules you write. But `make` does have certain built-in
    rules that describe the relationships between, for example, *.c* files and *.o*
    files. This particular built-in rule provides commands for building anything with
    a *.o* extension from a file of the same base name with a *.c* extension. These
    built-in rules are called *suffix rules* or, more generally, *implicit rules*,
    because the name of the dependency (source file) is implied by the name of the
    target (object file).
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将这些命令添加到依赖规则中，但其实没有必要，因为`make`有一个*内建*规则，知道如何从*.c*文件构建*.o*文件。`make`并没有什么神奇之处——它只知道你通过编写规则描述给它的关系。但`make`确实有一些内建规则，描述了例如*.c*文件和*.o*文件之间的关系。这个特定的内建规则提供了从具有相同基础名称的*.c*文件构建任何*.o*扩展名文件的命令。这些内建规则被称为*后缀规则*，或者更一般地说，*隐式规则*，因为依赖关系（源文件）的名称是通过目标（目标文件）的名称隐含表达的。
- en: To make the built-in implicit rules more widely usable, their commands often
    consume well-known `make` variables. If you set those variables, overriding the
    default values, you can wield some control over the execution of a built-in rule.
    For instance, the command in the standard POSIX definition of the built-in implicit
    rule for converting *.o* files to *.c* files is:^([15](footnote.xhtml#ch03fn15))
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使内建隐式规则更广泛可用，它们的命令通常会使用一些知名的`make`变量。如果你设置了这些变量，覆盖了默认值，你可以对执行内建规则有一定的控制。例如，在内建隐式规则的标准POSIX定义中，*.o*文件转为*.c*文件的命令是：^([15](footnote.xhtml#ch03fn15))
- en: '[PRE12]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Here, you can override just about every aspect of this built-in rule by setting
    your own values for `CC`, the compiler; `CPPFLAGS`, options passed to the C preprocessor;
    and `CFLAGS`, options passed to the C compiler.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，你几乎可以通过设置`CC`（编译器）、`CPPFLAGS`（传递给C预处理器的选项）和`CFLAGS`（传递给C编译器的选项）来覆盖这个内建规则的各个方面。
- en: You can write implicit rules yourself, if you wish. You can even override the
    default implicit rules with your own versions. Implicit rules are a powerful tool,
    and they shouldn’t be overlooked, but for the purposes of this book, we won’t
    go into any more detail. You can learn more about writing and using implicit rules
    within makefiles in “Using Implicit Rules” in the *GNU Make Manual*.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 如果需要，你可以自己编写隐式规则。你甚至可以用自己的版本覆盖默认的隐式规则。隐式规则是一个强大的工具，不容忽视，但在本书中，我们不会深入讨论。你可以通过阅读*GNU
    Make手册*中的“使用隐式规则”部分，了解更多关于在makefile中编写和使用隐式规则的信息。
- en: 'To illustrate this implicit functionality, I created trivial C source and header
    files to accompany the sample makefile from [Listing 3-11](ch03.xhtml#ch03ex11).
    Here’s what happened when I executed `make` on this makefile:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 为了说明这种隐式功能，我创建了简单的C源代码和头文件，配合[列表3-11](ch03.xhtml#ch03ex11)中的示例makefile。以下是我执行`make`命令时发生的情况：
- en: '[PRE13]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: As you can see, `cc` was magically executed with `-c` and `-o` options to generate
    *main.o* from *main.c*. This is common command line syntax used to make a C-language
    compiler build objects from sources—it’s so common, in fact, that the functionality
    is built into `make`. If you look for `cc` on a modern GNU/Linux system, you’ll
    find that it’s a soft link in */usr/bin* that refers to the system’s GNU C compiler.
    On other systems, it refers to the system’s native C compiler. Calling the system
    C compiler *cc* has been a de facto standard for decades.^([16](footnote.xhtml#ch03fn16))
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，`cc`通过`-c`和`-o`选项被神奇地执行，从*main.c*生成*main.o*。这是常见的命令行语法，用于让C语言编译器从源代码构建对象，实际上，这种功能已内建在`make`中。如果你在现代的GNU/Linux系统中查找`cc`，你会发现它是*/usr/bin*中的一个软链接，指向系统的GNU
    C编译器。在其他系统中，它指向系统的本地C编译器。几十年来，调用系统C编译器为*cc*已经成为事实上的标准。^([16](footnote.xhtml#ch03fn16))
- en: The extra spaces between `cc` and `-c` in that output under ➊ represent the
    spaces between the uses of the `CPPFLAGS` and `CFLAGS` variables, which are defined
    as empty by default.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 在➊那行输出中，`cc`和`-c`之间的额外空格表示`CPPFLAGS`和`CFLAGS`变量之间的空格，这些变量默认被定义为空。
- en: But why did the `make` utility build only *main.o* when we typed `make` at ➊?
    Simply because the dependency rule for *main.o* provided the first (and thus,
    the default) target for the makefile. In this case, to build `program`, we needed
    to execute `make program`, as we did in ➋. Remember that when you enter `make`
    on the command line, the `make` utility attempts to build the first explicitly
    defined target within the file called *Makefile* in the current directory. If
    we wanted to make `program` the default target, we could rearrange the rules so
    the `program` rule would be the first one listed in the makefile.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，为什么我们在➊处输入`make`时，`make`工具只构建了*main.o*呢？仅仅是因为*main.o*的依赖规则提供了makefile中的第一个（因此也是默认）目标。在这种情况下，要构建`program`，我们需要执行`make
    program`，就像我们在➋所做的那样。记住，当你在命令行输入`make`时，`make`工具会尝试构建当前目录中名为*Makefile*的文件内第一个显式定义的目标。如果我们想让`program`成为默认目标，我们可以重新排列规则，使得`program`规则成为makefile中列出的第一个目标。
- en: 'To see the dependency rules in action, touch one of the header files and then
    rebuild the `program` target:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 为了查看依赖规则的实际作用，可以触摸其中一个头文件，然后重新构建`program`目标：
- en: '[PRE14]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: After *display.h* was updated, only *display.o*, *main.o*, and `program` were
    rebuilt. The *print.o* object didn’t need to be rebuilt because *print.c* doesn’t
    depend on *display.h*, according to the rules specified in the makefile.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 在更新了*display.h*之后，只有*display.o*、*main.o*和`program`被重新构建。由于*print.c*不依赖于*display.h*，根据makefile中指定的规则，*print.o*对象不需要重新构建。
- en: Phony Targets
  id: totrans-132
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 虚拟目标
- en: Targets are not always files. They can also be so-called *phony targets*, as
    in the case of `all` and `clean`. These targets don’t refer to true products in
    the filesystem but rather to particular outcomes or actions—when you make these
    targets, the project is *cleaned*, *all* products are built, and so on.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 目标并不总是文件。它们也可以是所谓的*虚拟目标*，例如`all`和`clean`。这些目标不指代文件系统中的真实产品，而是特定的结果或操作——当你执行这些目标时，项目会被*清理*，*所有*产品会被构建，等等。
- en: Multiple Targets
  id: totrans-134
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 多目标
- en: In the same way that you can list multiple dependencies within a rule on the
    right side of a colon, you can combine rules for multiple targets with the same
    dependencies and commands by listing the targets on the left side of a colon,
    as shown in [Listing 3-12](ch03.xhtml#ch03ex12).
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你可以在冒号右侧列出多个依赖项一样，你也可以通过在冒号左侧列出目标，将多个目标的规则与相同的依赖项和命令结合起来，如[列表3-12](ch03.xhtml#ch03ex12)所示。
- en: '[PRE15]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '*Listing 3-12: Using multiple targets in a rule*'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '*示例 3-12：在规则中使用多个目标*'
- en: 'While it may not be immediately apparent, this example contains two separate
    rules: one for each of the two targets, `all` and `clean`. Because these two rules
    have the same set of dependencies (none, in this case) and the same set of commands,
    we’re able to take advantage of a shorthand notation supported by `make` that
    allows us to combine their rules into one specification.'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这在一开始可能不太明显，但这个示例包含了两个独立的规则：一个针对 `all`，另一个针对 `clean`。因为这两个规则有相同的依赖集（在这种情况下没有依赖）和相同的命令集，我们可以利用
    `make` 支持的简写符号，将它们的规则合并为一个规范。
- en: To help you understand this concept, consider the `$@` variable in [Listing
    3-12](ch03.xhtml#ch03ex12). Which target does it refer to? Well, that depends
    on which rule is currently executing—the one for `all` or the one for `clean`.
    Since a rule can only be executed on a single target at any given time, `$@` can
    only ever refer to one target, even when the controlling rule specification contains
    several.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 为了帮助你理解这个概念，考虑 [示例 3-12](ch03.xhtml#ch03ex12) 中的 `$@` 变量。它指向哪个目标？这取决于当前执行的是哪个规则——是
    `all` 还是 `clean`。由于一个规则在任何给定时刻只能执行一个目标，`$@` 只能指向一个目标，即使控制规则的定义包含多个目标。
- en: '*Resources for Makefile Authors*'
  id: totrans-140
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*Makefile 作者的资源*'
- en: GNU `make` is significantly more powerful than the original AT&T UNIX `make`
    utility, although GNU `make` is completely backward compatible, as long as you
    avoid GNU extensions. The *GNU Make Manual*^([17](footnote.xhtml#ch03fn17)) is
    available online, and O’Reilly has published an excellent book on the original
    AT&T UNIX `make` utility^([18](footnote.xhtml#ch03fn18)) and all of its many nuances.
    While you can still find this title, the publisher has since merged its content
    into a new edition that also covers GNU `make` extensions.^([19](footnote.xhtml#ch03fn19))
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: GNU `make` 比原始的 AT&T UNIX `make` 工具要强大得多，尽管只要避免使用 GNU 扩展，GNU `make` 完全向后兼容。*GNU
    Make 手册*^([17](footnote.xhtml#ch03fn17)) 可以在线访问，而 O'Reilly 也出版了一本关于原始 AT&T UNIX
    `make` 工具的优秀书籍^([18](footnote.xhtml#ch03fn18))，详细讲解了它的各种细节。虽然你仍然可以找到这本书，但出版商已经将其内容合并进了一个新的版本，其中也涵盖了
    GNU `make` 的扩展。^([19](footnote.xhtml#ch03fn19))
- en: This concludes the general discussion of makefile syntax and the `make` utility,
    although we will look at additional makefile constructs as we encounter them throughout
    the rest of this chapter. With this general information behind us, let’s return
    to the Jupiter project and begin adding some more interesting functionality.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 这部分结束了对 makefile 语法和 `make` 工具的基本讨论，尽管在本章接下来的内容中，我们会在遇到时继续探讨其他 makefile 结构。通过这些基本信息的学习，让我们回到
    Jupiter 项目，开始添加一些更有趣的功能。
- en: Creating a Source Distribution Archive
  id: totrans-143
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建源代码分发档案
- en: In order to actually get source code for Jupiter to our users, we’re going to
    have to create and distribute a source archive—a tarball. We could write a separate
    script to create the tarball, but since we can use phony targets to create arbitrary
    sets of functionality in makefiles, let’s design a `make` target to perform this
    task instead. Building a source archive for distribution is usually relegated
    to the `dist` target.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 为了将 Jupiter 的源代码真正提供给用户，我们需要创建并分发一个源代码档案——一个 tarball。我们可以编写一个单独的脚本来创建这个 tarball，但既然我们可以使用虚拟目标在
    makefile 中创建任意功能集，为什么不设计一个 `make` 目标来执行这项任务呢？为分发构建源代码档案通常归属于 `dist` 目标。
- en: When designing a new `make` target, we need to consider whether its functionality
    should be distributed among the makefiles of the project or handled in a single
    location. Normally, the rule of thumb is to take advantage of a recursive build
    system’s nature by allowing each directory to manage its own portions of a process.
    We did just this in [Listing 3-1](ch03.xhtml#ch03ex01) when we passed control
    of building the `jupiter` program down to the *src* directory, where the source
    code is located. However, building a compressed archive from a directory structure
    isn’t really a recursive process.^([20](footnote.xhtml#ch03fn20)) This being the
    case, we’ll have to perform the entire task in one of the two makefiles.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 在设计一个新的 `make` 目标时，我们需要考虑它的功能是否应该在项目的 makefile 中分布，还是在单一位置处理。通常的经验法则是利用递归构建系统的特性，让每个目录管理自己部分的流程。我们在[示例
    3-1](ch03.xhtml#ch03ex01)中就是这么做的，将构建 `jupiter` 程序的控制权交给了包含源代码的 *src* 目录。然而，从目录结构中构建压缩档案并不真的是一个递归过程。^([20](footnote.xhtml#ch03fn20))
    因此，我们必须在两个 makefile 中执行整个任务。
- en: Global processes are often handled by the makefile at the highest relevant level
    in the project directory structure. We’ll add the `dist` target to our top-level
    makefile, as shown in [Listing 3-13](ch03.xhtml#ch03ex13).
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 全局进程通常由项目目录结构中最高相关级别的makefile处理。我们将在顶级makefile中添加`dist`目标，如[清单 3-13](ch03.xhtml#ch03ex13)所示。
- en: Git tag 3.1
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: Git标签 3.1
- en: '[PRE16]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '*Listing 3-13:* Makefile: Adding the `dist` target to the top-level makefile'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 3-13:* Makefile：将`dist`目标添加到顶级makefile中'
- en: Besides the addition of the `dist` target at ➋, I’ve also made several other
    modifications. Let’s look at them one at a time. I’ve added the `dist` target
    to the `.PHONY` rule at ➎. The `.PHONY` rule is a special kind of built-in rule
    called a *dot-rule* or *directive*. The `make` utility understands several dot-rules.
    The purpose of `.PHONY` is simply to tell `make` that certain targets don’t generate
    filesystem objects. Normally, `make` determines which commands to run by comparing
    the timestamps of the targets to those of their dependencies in the filesystem—but
    phony targets don’t have associated filesystem objects. Using `.PHONY` ensures
    that `make` won’t go looking for nonexistent product files named after these targets.
    It also ensures that if a file or directory named *dist* somehow inadvertently
    gets added to the directory, `make` will still treat the `dist` target as non-real.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 除了在➋处添加`dist`目标外，我还做了一些其他修改。我们一个一个地来看。我已将`dist`目标添加到➎处的`.PHONY`规则中。`.PHONY`规则是一种特殊的内置规则，叫做*点规则*或*指令*。`make`工具理解几种点规则。`.PHONY`的目的是简单地告诉`make`，某些目标不会生成文件系统对象。通常，`make`通过比较目标与其依赖项的时间戳来决定运行哪些命令——但虚拟目标没有关联的文件系统对象。使用`.PHONY`可以确保`make`不会去查找这些目标所命名的不存在的产品文件。它还确保，如果一个名为*dist*的文件或目录不小心被添加到目录中，`make`仍然会将`dist`目标视为非真实目标。
- en: Adding a target to the `.PHONY` rule has another effect. Since `make` won’t
    be able to use timestamps to determine whether the target is up-to-date (that
    is, newer than its dependencies), `make` has no recourse but to *always* execute
    the commands associated with phony targets whenever these targets either are requested
    on the command line or appear in a dependency chain.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 向`.PHONY`规则添加一个目标还有另一个效果。由于`make`无法通过时间戳来判断目标是否是最新的（即比它的依赖项更新），`make`唯一能做的就是*始终*执行与虚拟目标关联的命令，无论这些目标是通过命令行请求的，还是出现在依赖链中。
- en: 'I’ve separated the functionality of the `dist` target into three separate rules
    (➋, ➌, and ➍) for the sake of readability, modularity, and maintenance. This is
    a great rule of thumb to follow in any software engineering process: *build large
    processes from smaller ones and reuse the smaller processes where it makes sense.*'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 为了提高可读性、模块化和维护性，我将`dist`目标的功能分为三个单独的规则（➋、➌和➍）。这是任何软件工程过程中一个很好的经验法则：*将大型过程构建为较小的过程，并在合理的地方重用这些小的过程*。
- en: The `dist` target at ➋ depends on the existence of the ultimate goal—in this
    case, a source-level compressed archive package, *jupiter-1.0.tar.gz*. I’ve used
    one variable to hold the version number (which makes it easier to update the project
    version later) and another variable for the package name at ➊, which will make
    it easier to change the name if I ever decide to reuse this makefile for another
    project. I’ve also logically split the functions of package name and tarball name;
    the default tarball name is the package name, but we do have the option of making
    them different.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: ➋处的`dist`目标依赖于最终目标的存在——在这种情况下，是一个源级压缩归档包，*jupiter-1.0.tar.gz*。我使用了一个变量来保存版本号（这样以后更新项目版本更容易），另一个变量用于包名在➊处，这样如果我决定将这个makefile用于另一个项目时，改名就会更容易。我还在逻辑上将包名和tarball名的功能分开；默认的tarball名称是包名，但我们也有选择将它们设置为不同的名称。
- en: The rule that builds the tarball at ➌ indicates how this should be done with
    a command that uses the `gzip` and `tar` utilities to create the file. But, notice
    that the rule has a dependency—the directory to be archived. The directory name
    is derived from the tarball name and the package version number; it’s stored in
    yet another variable called `distdir`.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 构建tarball的规则在➌处指出了如何使用`gzip`和`tar`工具通过一个命令来创建该文件。但请注意，该规则有一个依赖关系——要归档的目录。目录名是从tarball的名称和包版本号派生的；它存储在另一个名为`distdir`的变量中。
- en: We don’t want object files and executables from our last build attempt to end
    up in the archive, so we need to build an image directory containing exactly what
    we want to ship—including any files required in the build and install processes
    and any additional documentation or license files. Unfortunately, this pretty
    much mandates the use of individual copy (`cp`) commands.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不希望上次构建尝试中的目标文件和可执行文件出现在归档中，因此我们需要构建一个图像目录，包含我们想要发布的所有内容——包括构建和安装过程中所需的任何文件，以及任何额外的文档或许可文件。不幸的是，这几乎要求必须使用单独的复制（`cp`）命令。
- en: Since there’s a rule in the makefile (at ➍) that tells how this directory should
    be created, and since that rule’s target is a dependency of the tarball, `make`
    runs the commands for that rule *before* running the commands for the tarball
    rule. Recall that `make` processes rules to build dependencies recursively, from
    the bottom up, until it can run the commands for the requested target.^([21](footnote.xhtml#ch03fn21))
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 makefile 中有一条规则（在 ➍ 处）指示如何创建这个目录，并且该规则的目标是 tarball 的依赖项，`make` 会先执行该规则的命令，再执行
    tarball 规则的命令。回想一下，`make` 会递归地处理规则，以从底部到顶部构建依赖关系，直到它能够执行请求的目标的命令。^([21](footnote.xhtml#ch03fn21))
- en: '*Forcing a Rule to Run*'
  id: totrans-157
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*强制执行规则*'
- en: 'There’s a subtle flaw in the `$(distdir)` target that may not be obvious right
    now, but it will rear its ugly head at the worst of times. If the archive image
    directory (*jupiter-1.0*) already exists when you execute `make dist`, then `make`
    won’t try to create it. Try this:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: '`$(distdir)` 目标中有一个微妙的缺陷，现在可能不太明显，但它将在最糟糕的时候露出它丑陋的面目。如果在执行 `make dist` 时归档图像目录
    (*jupiter-1.0*) 已经存在，那么 `make` 就不会尝试创建它。试试这个：'
- en: '[PRE17]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Notice that the `dist` target didn’t copy any files—it just built an archive
    out of the existing *jupiter-1.0* directory, which was empty. Our users would
    get a real surprise when they unpack this tarball! Worse still, if the image directory
    from the previous attempt to archive happened to still be there, the new tarball
    would contain the now-outdated sources from our last attempt to create a distribution
    tarball.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，`dist` 目标并没有复制任何文件——它只是从现有的 *jupiter-1.0* 目录中创建了一个归档文件，而该目录是空的。当用户解压这个 tarball
    时，肯定会大吃一惊！更糟糕的是，如果之前归档尝试中的图像目录仍然存在，那么新的 tarball 将包含我们上次尝试创建发行版 tarball 时的过时源代码。
- en: The problem is that the `$(distdir)` target is a real target with no dependencies,
    which means that `make` will consider it up-to-date as long as it exists in the
    filesystem. We could add the `$(distdir)` target to the `.PHONY` rule to force
    `make` to rebuild it every time we make the `dist` target, but it’s not a phony
    target—it’s a real filesystem object. The proper way to ensure that `$(distdir)`
    is always rebuilt is to ensure that it doesn’t exist before `make` attempts to
    build it. One way to accomplish this is to create a true phony target that will
    always execute and then add that target to the dependency list for the `$(distdir)`
    target. A common name for this kind of target is `FORCE`, and I’ve implemented
    this concept in [Listing 3-14](ch03.xhtml#ch03ex14).
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 问题在于，`$(distdir)` 目标是一个没有依赖关系的实际目标，这意味着只要它在文件系统中存在，`make` 就会认为它是最新的。我们可以将 `$(distdir)`
    目标添加到 `.PHONY` 规则中，以强制 `make` 每次执行 `dist` 目标时都重新构建它，但它并不是一个虚假目标——它是一个实际的文件系统对象。确保
    `$(distdir)` 始终被重新构建的正确方法是确保在 `make` 尝试构建它之前，它并不存在。实现这一目标的一种方式是创建一个真正的虚假目标，使其始终执行，然后将该目标添加到
    `$(distdir)` 目标的依赖列表中。此类目标的常见名称是 `FORCE`，我在 [Listing 3-14](ch03.xhtml#ch03ex14)
    中实现了这个概念。
- en: Git tag 3.2
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: Git 标签 3.2
- en: '[PRE18]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '*Listing 3-14: Makefile: Using the `FORCE` target*'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: '*Listing 3-14: Makefile: 使用 `FORCE` 目标*'
- en: The `FORCE` rule’s commands (at ➋) are executed every time because `FORCE` is
    a phony target. Since we made `FORCE` a dependency of the `$(distdir)` target
    (at ➊), we have the opportunity to delete any previously created files and directories
    *before* `make` begins to evaluate whether it should execute the commands for
    `$(distdir)`.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: '`FORCE` 规则的命令（在 ➋ 处）每次都会执行，因为 `FORCE` 是一个虚假目标。由于我们将 `FORCE` 作为 `$(distdir)`
    目标的依赖项（在 ➊ 处），我们有机会在 `make` 开始评估是否应执行 `$(distdir)` 的命令之前，删除任何先前创建的文件和目录。'
- en: '*Leading Control Characters*'
  id: totrans-166
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*领先的控制字符*'
- en: A leading dash character (`-`) on a command tells `make` not to care about the
    status code of the command it precedes. Normally, when `make` encounters a command
    that returns a nonzero status code to the shell, it will stop execution and display
    an error message, but if you use a leading dash, it will just ignore the error
    and continue. I use a leading dash on the first `rm` command in the `FORCE` rule
    because I want to delete previously created product files that may *or may not*
    exist, and `rm` will return an error if I attempt to delete a nonexistent file.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 命令前缀的破折号字符（`-`）告诉`make`不关心它所执行的命令返回的状态码。通常，当`make`遇到返回非零状态码的命令时，它会停止执行并显示错误信息，但如果你使用了破折号，它会忽略错误并继续执行。我在`FORCE`规则中的第一个`rm`命令前加了破折号，因为我想删除可能存在也可能不存在的先前创建的产品文件，如果尝试删除不存在的文件，`rm`会返回错误。
- en: In general, a better option is to use the `-f` flag on the `rm` command line,
    which causes `rm` to ignore missing file errors. Another benefit of using `-f`
    is that we no longer need to redirect error messages to */dev/null*, as we really
    care about other errors—permission errors, for example. From this point on, we’ll
    remove the leading dash in front of any `rm` commands and ensure we use `-f`.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 通常来说，一个更好的选择是在`rm`命令行中使用`-f`标志，这样`rm`就会忽略缺失文件的错误。使用`-f`的另一个好处是，我们不再需要将错误消息重定向到*/dev/null*，因为我们其实更关心其他错误——例如权限错误。从现在开始，我们将在所有`rm`命令前去掉破折号，并确保使用`-f`。
- en: 'Another leading character that you may encounter is the at sign (`@`). A command
    prefixed with an at sign tells `make` not to perform its normal behavior of printing
    the command to the `stdout` device as it executes it. It is common to use a leading
    at sign on `echo` statements. You don’t want `make` to print `echo` statements,
    because then your message will be printed twice: once by `make` and then again
    by the `echo` statement itself.'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会遇到的另一个重要符号是@符号（`@`）。以@符号为前缀的命令告诉`make`不要执行其正常行为，即在执行命令时不将命令打印到`stdout`设备。通常在`echo`语句前使用@符号。你不希望`make`打印`echo`语句，因为这样你的消息就会被打印两次：一次由`make`，然后再由`echo`语句本身打印。
- en: '**NOTE**'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*You may also combine these leading characters (*`@`*, *`-`*, and *`+`*) in
    any order. The plus (*`+`*) character is used to force a command to execute that
    would otherwise not be executed due, for example, to a *`-n`* command line option,
    which tells *`make`* to perform a so-called dry run. Some commands make sense
    even in a dry run.*'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: '*你还可以以任意顺序组合这些前导字符（*`@`*、*`-`*和*`+`*）。加号（*`+`*）字符用于强制执行一个原本不会执行的命令，例如由于`-n`命令行选项，它告诉`make`执行所谓的干运行。有些命令即使在干运行中也有意义。*'
- en: It’s best to use the at sign judiciously. I usually reserve it for commands
    I *never* want to see, such as `echo` statements. If you like quiet build systems,
    consider using the global `.SILENT` directive in your makefiles. Or better still,
    simply do nothing, thereby allowing the user the option of adding the `-s` option
    to their `make` command lines. This enables the user to choose how much noise
    they want to see.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 最好谨慎使用@符号。我通常将它保留用于那些我*永远*不想看到的命令，例如`echo`语句。如果你喜欢安静的构建系统，可以考虑在makefile中使用全局`.SILENT`指令。或者，更好的是，干脆什么都不做，让用户可以选择在其`make`命令行中添加`-s`选项，这样用户就可以选择他们想看到多少输出。
- en: Automatically Testing a Distribution
  id: totrans-173
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 自动测试分发
- en: The rule for building the archive directory is probably the most frustrating
    rule in this makefile because it contains commands to copy individual files into
    the distribution directory. Every time we change the file structure in our project,
    we have to update this rule in our top-level makefile, or we’ll break the `dist`
    target. But there’s nothing more we can do—we’ve made the rule as simple as possible.
    Now we just have to remember to manage this process properly.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 构建归档目录的规则可能是这个makefile中最令人沮丧的规则，因为它包含了将单个文件复制到分发目录中的命令。每次我们更改项目中的文件结构时，我们都必须在顶层makefile中更新这个规则，否则我们会破坏`dist`目标。但是我们能做的也不多——我们已经将这个规则简化到极限。现在我们只需要记住正确管理这个过程。
- en: Unfortunately, though, even worse things than breaking the `dist` target could
    happen if you forget to update the `distdir` rule’s commands. It may *appear*
    that the `dist` target is working, but it may not actually be copying all of the
    required files into the tarball. In fact, it is far more likely that this, rather
    than an error, will occur, because adding files to a project is a more common
    activity than moving them around or deleting them. New files will not be copied,
    but the `dist` rule won’t notice the difference.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，如果忘记更新`distdir`规则的命令，可能会发生比破坏`dist`目标更糟糕的事情。看起来`dist`目标似乎工作正常，但实际上可能没有将所有必要的文件复制到
    tarball 中。事实上，更有可能发生这种情况，而不是错误，因为添加文件到项目中比移动或删除文件更为常见。新文件将不会被复制，但`dist`规则不会注意到这个区别。
- en: 'There is a way to perform a sort of self-check on the `dist` target. We can
    create another phony target, called `distcheck`, that does exactly what our users
    will do: unpack the tarball and build the project. We can have this rule’s commands
    perform this task in a temporary directory. If the build process fails, then the
    `distcheck` target will break, telling us that we forgot something crucial in
    our distribution.'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 有一种方法可以对`dist`目标执行自检。我们可以创建另一个虚拟目标，叫做`distcheck`，它会做完全相同的事情：解压缩 tarball 并构建项目。我们可以让这个规则的命令在临时目录中执行这个任务。如果构建过程失败，那么`distcheck`目标会失败，告诉我们在分发包中遗漏了某些重要的内容。
- en: '[Listing 3-15](ch03.xhtml#ch03ex15) shows the modifications to our top-level
    makefile that are required to implement the `distcheck` target.'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: '[清单 3-15](ch03.xhtml#ch03ex15)展示了为了实现`distcheck`目标，我们对顶级 makefile 所做的修改。'
- en: Git tag 3.3
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: Git 标签 3.3
- en: '[PRE19]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '*Listing 3-15: Makefile: Adding a `distcheck` target to the top-level makefile*'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 3-15: Makefile: 向顶级 makefile 添加 `distcheck` 目标*'
- en: The `distcheck` target depends on the tarball itself, so the rule that builds
    the tarball is executed first. The `make` utility then executes the `distcheck`
    commands, which unpack the tarball just built and then recursively run `make`
    on the `all` and `clean` targets within the resulting directory. If that process
    succeeds, the `distcheck` target prints out a message indicating that your users
    will likely not have a problem with this tarball.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: '`distcheck`目标依赖于 tarball 本身，因此首先执行构建 tarball 的规则。然后，`make` 工具执行`distcheck`命令，它解压缩刚刚构建的
    tarball，然后在结果目录内递归地对`all`和`clean`目标运行`make`。如果该过程成功，`distcheck`目标将输出一条消息，表示用户在使用这个
    tarball 时很可能不会遇到问题。'
- en: Now all you have to do is remember to execute `make distcheck` *before* you
    post your tarballs for public distribution!
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你只需要记住在发布 tarball 供公众分发之前，执行 `make distcheck`！
- en: Unit Testing, Anyone?
  id: totrans-183
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 单元测试，谁来做？
- en: Some people insist that unit testing is evil, but the only honest rationale
    they can come up with for not doing it is laziness. Proper unit testing is hard
    work, but it pays off in the end. Those who do it have learned a lesson (usually
    in childhood) about the value of delayed gratification.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 有些人坚称单元测试是邪恶的，但他们能提出的唯一不做单元测试的理由就是懒惰。适当的单元测试是艰苦的工作，但最终是值得的。做单元测试的人通常在儿童时期就学会了一个关于延迟满足价值的教训。
- en: A good build system should incorporate proper unit testing. The most commonly
    used target for testing a build is the `check` target, so we’ll go ahead and add
    it in the usual manner. The actual unit test should probably go in *src/Makefile*
    because that’s where the `jupiter` executable is built, so we’ll pass the `check`
    target down from the top-level makefile.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 一个好的构建系统应该包括适当的单元测试。最常用的测试构建的目标是`check`目标，所以我们将像往常一样添加它。实际的单元测试可能应该放在*src/Makefile*中，因为这是构建`jupiter`可执行文件的地方，因此我们将从顶级
    makefile 传递`check`目标。
- en: But what commands do we put in the `check` rule? Well, `jupiter` is a pretty
    simple program—it prints the message *Hello from* some/path/*jupiter!* where *some/path*
    depends on the location from which `jupiter` was executed. I’ll use the `grep`
    utility to test that `jupiter` actually outputs such a string.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，我们应该在`check`规则中放入什么命令呢？嗯，`jupiter`是一个非常简单的程序——它打印消息 *Hello from* some/path/*jupiter!*，其中
    *some/path* 取决于从哪个位置执行`jupiter`。我将使用`grep`工具来测试`jupiter`是否确实输出了这样的字符串。
- en: '[Listings 3-16](ch03.xhtml#ch03ex16) and [3-17](ch03.xhtml#ch03ex17) illustrate
    the modifications to our top-level and *src* directory makefiles, respectively.'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: '[清单 3-16](ch03.xhtml#ch03ex16)和[3-17](ch03.xhtml#ch03ex17)分别展示了对顶级和*src*目录
    makefile 所做的修改。'
- en: Git tag 3.4
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: Git 标签 3.4
- en: '[PRE20]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '*Listing 3-16:* Makefile: *Passing the `check` target to src/Makefile*'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 3-16:* Makefile: *将 `check` 目标传递到 src/Makefile*'
- en: '[PRE21]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '*Listing 3-17:* src/Makefile: *Implementing the unit test in the `check` target*'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 3-17:* src/Makefile: *在 `check` 目标中实现单元测试*'
- en: Note that `check` depends on `all`. We can’t really test our products unless
    they are up-to-date, reflecting any recent source code or build system changes
    that may have been made. It makes sense that if the user wants to test the products,
    they also want the products to exist and be up-to-date. We can ensure they exist
    and are current by adding `all` to `check`’s dependency list.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，`check` 依赖于 `all`。除非产品是最新的，能够反映最近对源代码或构建系统所做的任何更改，否则我们无法真正测试我们的产品。如果用户想要测试产品，他们当然希望产品是存在的并且是最新的。我们可以通过将
    `all` 添加到 `check` 的依赖列表中来确保它们存在并且是当前的。
- en: 'There’s one more enhancement we can make to our build system: we can add `check`
    to the list of targets executed by `make` in our `distcheck` rule, between the
    commands to make `all` and `clean`. [Listing 3-18](ch03.xhtml#ch03ex18) shows
    where this is done in the top-level makefile.'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以对构建系统进行另一个改进：我们可以将 `check` 添加到 `distcheck` 规则中由 `make` 执行的目标列表中，放在执行 `all`
    和 `clean` 之间。[清单 3-18](ch03.xhtml#ch03ex18) 显示了在顶级 makefile 中执行此操作的位置。
- en: Git tag 3.5
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: Git 标签 3.5
- en: '[PRE22]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '*Listing 3-18:* Makefile: *Adding the `check` target to the `$(MAKE)` command*'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 3-18:* Makefile: *将 `check` 目标添加到 `$(MAKE)` 命令中*'
- en: Now when we run `make distcheck`, it will test the entire build system shipped
    with the package.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当我们运行 `make distcheck` 时，它将测试与包一起发布的整个构建系统。
- en: Installing Products
  id: totrans-199
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 安装产品
- en: We’ve reached the point where our users’ experiences with Jupiter should be
    fairly painless—even pleasant—as far as building the project is concerned. Users
    will simply unpack the distribution tarball, change into the distribution directory,
    and type `make`. It really can’t get any simpler than that.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经达到了这样的阶段，用户在构建 Jupiter 项目时应该会感到相当顺利——甚至愉快。用户只需要解压分发包，进入分发目录，然后输入 `make`。实际上，它已经简单到不能再简单了。
- en: But we still lack one important feature—installation. In the case of the Jupiter
    project, this is fairly trivial. There’s only one program, and most users would
    guess correctly that to install it, they should copy `jupiter` into either their
    */usr/bin* or */usr/local/bin* directory. More complex projects, however, could
    cause users real consternation over where to put user and system binaries, libraries,
    header files, and documentation, including man pages, info pages, PDF files, and
    the more or less obligatory *README*, *AUTHORS*, *NEWS*, *INSTALL*, and *COPYING*
    files generally associated with GNU projects.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 但我们仍然缺少一个重要的功能——安装。就 Jupiter 项目而言，这相对简单。只有一个程序，大多数用户会正确猜测，安装它时，他们应该将 `jupiter`
    复制到他们的 */usr/bin* 或 */usr/local/bin* 目录中。然而，更复杂的项目可能会让用户对将用户和系统二进制文件、库、头文件和文档（包括
    man 页、info 页、PDF 文件，以及通常与 GNU 项目相关联的 *README*、*AUTHORS*、*NEWS*、*INSTALL* 和 *COPYING*
    文件）放在哪里感到困惑。
- en: We don’t really want our users to have to figure all that out, so we’ll create
    an `install` target to manage putting things where they go once they’re built
    properly. In fact, why not just make installation part of the `all` target? Well,
    let’s not get carried away. There are actually a few good reasons for not doing
    this.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 我们实际上并不希望用户自己搞清楚这些问题，因此我们将创建一个 `install` 目标来管理在构建完成后将文件放到合适的位置。事实上，为什么不直接把安装作为
    `all` 目标的一部分呢？嗯，我们还是不要太冲动。实际上，存在一些不这样做的合理原因。
- en: First, build and installation are separate logical concepts. The second reason
    is a matter of filesystem rights. Users have rights to build projects in their
    own home directories, but installation often requires *root*-level rights to copy
    files into system directories. Finally, there are several reasons why a user may
    wish to build but not install a project, so it would be unwise to tie these actions
    together.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，构建和安装是两个独立的逻辑概念。第二个原因是文件系统权限的问题。用户有权限在自己的主目录中构建项目，但安装通常需要 *root* 权限才能将文件复制到系统目录。最后，用户可能有多个原因希望构建但不安装项目，因此将这些操作绑定在一起是不可取的。
- en: 'While creating a distribution package may not be an inherently recursive process,
    installation certainly is, so we’ll allow each subdirectory in our project to
    manage installation of its own components. To do this, we need to modify both
    the top-level and the *src*-level makefiles. Changing the top-level makefile is
    easy: since there are no products to be installed in the top-level directory,
    we’ll just pass the responsibility on to *src/Makefile* in the usual way.'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然创建分发包可能不是一个本质上递归的过程，但安装过程肯定是递归的，所以我们允许项目中的每个子目录管理其组件的安装。为此，我们需要修改顶级和 *src*
    级别的 makefile。修改顶级 makefile 很简单：因为顶级目录中没有需要安装的产品，我们只是按惯例将责任交给 *src/Makefile*。
- en: The modifications for adding an `install` target are shown in [Listings 3-19](ch03.xhtml#ch03ex19)
    and [3-20](ch03.xhtml#ch03ex20).
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 添加 `install` 目标的修改在[列表 3-19](ch03.xhtml#ch03ex19)和[3-20](ch03.xhtml#ch03ex20)中展示。
- en: Git tag 3.6
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: Git 标签 3.6
- en: '[PRE23]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '*Listing 3-19:* Makefile: *Passing the `install` target to src/Makefile*'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 3-19:* Makefile: *将 `install` 目标传递给 src/Makefile*'
- en: '[PRE24]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '*Listing 3-20:* src/Makefile: *Implementing the `install` target*'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 3-20:* src/Makefile: *实现 `install` 目标*'
- en: In the top-level makefile shown in [Listing 3-19](ch03.xhtml#ch03ex19), I’ve
    added `install` to the list of targets passed down to *src/Makefile*. The installation
    of files is handled by the *src*-level makefile shown in [Listing 3-20](ch03.xhtml#ch03ex20).
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 在[列表 3-19](ch03.xhtml#ch03ex19)中展示的顶级 makefile 中，我将 `install` 添加到了传递给 *src/Makefile*
    的目标列表中。文件的安装由[列表 3-20](ch03.xhtml#ch03ex20)中展示的 *src* 级别的 makefile 处理。
- en: Installation is a bit more complex than simply copying files. If a file is placed
    in the */usr/bin* directory, then *root* should own it so that only *root* can
    delete or modify it. Additionally, the `jupiter` binary should be flagged executable,
    so I’ve used the `chmod` command to set the mode of the file as such. This is
    probably redundant, as the linker ensures that `jupiter` is created as an executable
    file, but some types of executable products are not generated by a linker—shell
    scripts, for example.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 安装比简单复制文件要复杂一些。如果文件被放置在 */usr/bin* 目录中，那么 *root* 应该是其所有者，这样只有 *root* 才能删除或修改该文件。此外，`jupiter`
    二进制文件应该被标记为可执行文件，因此我使用了 `chmod` 命令来设置文件的权限。这可能是多余的，因为链接器确保 `jupiter` 被创建为可执行文件，但并不是所有类型的可执行产品都是由链接器生成的——例如
    shell 脚本。
- en: 'Now our users can just type the following sequence of commands and the Jupiter
    project will be built, tested, and installed with the correct system attributes
    and ownership on their platforms:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们的用户只需要输入以下命令序列，Jupiter 项目就会在他们的平台上以正确的系统属性和所有权进行构建、测试和安装：
- en: '[PRE25]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '*Installation Choices*'
  id: totrans-215
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*安装选项*'
- en: All of this is well and good, but it could be a bit more flexible with regard
    to where things are installed. Some users may be okay with having `jupiter` installed
    into the */usr/bin* directory. Others are going to ask why it isn’t installed
    into the */usr/local/bin* directory—after all, this is a common convention. We
    could change the target directory to */usr/local/bin*, but then users may ask
    why they don’t have the option of installing into their home directories. This
    is the perfect situation for a little command line–supported flexibility.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 这一切看起来都不错，但在安装位置上，可能还需要更灵活一些。有些用户可能可以接受将 `jupiter` 安装到 */usr/bin* 目录下，而另一些用户则会问为什么它不安装到
    */usr/local/bin* 目录——毕竟，这是一个常见的约定。我们可以将目标目录改为 */usr/local/bin*，但这时用户可能会问，为什么他们不能选择将其安装到自己的主目录中。这正是需要一点命令行支持灵活性的理想情况。
- en: Another problem with our current build system is that we have to do a lot of
    stuff just to install files. Most Unix systems provide a system-level program—sometimes
    simply a shell script—called `install` that allows a user to specify various attributes
    of the files being installed. The proper use of this utility could simplify things
    a bit for Jupiter’s installation, so while we’re adding location flexibility,
    we might as well use the `install` utility, too. These modifications are shown
    in [Listings 3-21](ch03.xhtml#ch03ex21) and [3-22](ch03.xhtml#ch03ex22).
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 我们当前构建系统的另一个问题是，安装文件需要做很多操作。大多数 Unix 系统提供了一个系统级的程序——有时只是一个简单的 shell 脚本——叫做 `install`，它允许用户指定安装文件的各种属性。正确使用这个工具可以简化
    Jupiter 的安装过程，因此在添加位置灵活性的同时，我们也可以使用 `install` 工具。这些修改在[列表 3-21](ch03.xhtml#ch03ex21)和[3-22](ch03.xhtml#ch03ex22)中有所展示。
- en: Git tag 3.7
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: Git 标签 3.7
- en: '[PRE26]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '*Listing 3-21: Makefile: Adding a `prefix` variable*'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 3-21: Makefile: 添加 `prefix` 变量*'
- en: '[PRE27]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '*Listing 3-22:* src/Makefile: *Using the `prefix` variable in the `install`
    target*'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 3-22：* src/Makefile：*在 `install` 目标中使用 `prefix` 变量*'
- en: Notice that I only declared and assigned the `prefix` variable in the top-level
    makefile, but I referenced it in *src/Makefile*. I can do this because I used
    the `export` modifier at ➊ in the top-level makefile—this modifier exports the
    variable to the shell that `make` spawns when it executes itself in the *src*
    directory. This feature of `make` allows us to define all of our user variables
    in one obvious location—at the beginning of the top-level makefile.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我只在顶级 makefile 中声明并赋值了 `prefix` 变量，但我在 *src/Makefile* 中引用了它。我之所以能这么做，是因为我在顶级
    makefile 的 ➊ 位置使用了 `export` 修饰符——这个修饰符将变量导出到 `make` 执行时在 *src* 目录中启动的 shell 中。`make`
    的这一功能使我们能够在一个明显的位置——顶级 makefile 的开头——定义所有用户变量。
- en: '**NOTE**'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*GNU *`make`* allows you to use the *`export`* keyword on the assignment line,
    but this syntax is not portable between GNU *`make`* and other versions of *`make`*.
    Technically, POSIX doesn’t support the use of *`export`* at all, but most *`make`*
    implementations support it.*'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: '*GNU *`make`* 允许你在赋值行使用 *`export`* 关键字，但这种语法在 GNU *`make`* 和其他版本的 *`make`*
    之间并不兼容。从技术上讲，POSIX 根本不支持使用 *`export`*，但大多数 *`make`* 实现都支持它。*'
- en: 'I’ve now declared the `prefix` variable to be */usr/local*, which is very nice
    for those who want to install `jupiter` in */usr/local/bin* but not so nice for
    those who want it in */usr/bin*. Fortunately, `make` allows you to define `make`
    variables on the command line, in this manner:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 我现在已经声明 `prefix` 变量为 */usr/local*，这对于那些想要将 `jupiter` 安装到 */usr/local/bin* 的用户非常有用，但对于那些希望将其安装到
    */usr/bin* 的用户就不太友好了。幸运的是，`make` 允许你在命令行上定义 `make` 变量，方法如下：
- en: '[PRE28]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Remember that variables defined on the command line override those defined within
    the makefile.^([22](footnote.xhtml#ch03fn22)) Thus, users who want to install
    `jupiter` into the */usr/bin* directory now have the option of specifying this
    on the `make` command line.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，命令行上定义的变量会覆盖在 makefile 中定义的变量。^([22](footnote.xhtml#ch03fn22)) 因此，想要将 `jupiter`
    安装到 */usr/bin* 目录的用户，现在可以在 `make` 命令行中指定这一点。
- en: With this system in place, our users may install `jupiter` into a *bin* directory
    beneath any directory they choose, including a location in their home directory
    (for which they do not need additional rights). This is, in fact, the reason we
    added the `install -d $(prefix)/bin` command at ➋ in [Listing 3-22](ch03.xhtml#ch03ex22)—this
    command creates the installation directory if it doesn’t already exist. Since
    we allow the user to define `prefix` on the `make` command line, we don’t actually
    know where the user is going to install `jupiter`; therefore, we have to be prepared
    for the possibility that the location may not yet exist. Give this a try:^([23](footnote.xhtml#ch03fn23))
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个系统，用户可以将 `jupiter` 安装到他们选择的任何目录下的 *bin* 目录中，包括他们的主目录中的位置（此时他们不需要额外的权限）。事实上，这就是我们在
    [清单 3-22](ch03.xhtml#ch03ex22) 的 ➋ 位置添加 `install -d $(prefix)/bin` 命令的原因——该命令在安装目录不存在时会创建它。由于我们允许用户在
    `make` 命令行上定义 `prefix`，我们实际上并不知道用户将 `jupiter` 安装在哪里；因此，我们必须为目录尚不存在的可能性做好准备。试试看吧：^([23](footnote.xhtml#ch03fn23))
- en: '[PRE29]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '*Uninstalling a Package*'
  id: totrans-231
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*卸载软件包*'
- en: What if a user doesn’t like our package after they’ve installed it, and they
    just want to get it off their system? This is a fairly likely scenario for the
    Jupiter project, as it’s rather useless and takes up valuable space in the *bin*
    directory. In the case of *your* projects, however, it’s more likely that a user
    would want to do a clean install of a newer version of the project or replace
    the test build they downloaded from the project website with a professionally
    packaged version that comes with their Linux distribution. Support for an `uninstall`
    target would be very helpful in situations like these.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 如果用户在安装了我们的软件包后不喜欢它，只想从系统中删除它怎么办？对于 Jupiter 项目来说，这种情况相当可能，因为它几乎没有用，而且会占用 *bin*
    目录中的宝贵空间。然而，对于你们的项目而言，更可能的是，用户希望进行一个全新安装，安装一个更新版本，或者用他们 Linux 发行版中带有的正式打包版本替换从项目网站上下载的测试版。在这种情况下，支持
    `uninstall` 目标会非常有用。
- en: '[Listings 3-23](ch03.xhtml#ch03ex23) and [3-24](ch03.xhtml#ch03ex24) show the
    addition of an `uninstall` target to our two makefiles.'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: '[清单 3-23](ch03.xhtml#ch03ex23) 和 [3-24](ch03.xhtml#ch03ex24) 展示了我们向两个 makefile
    中添加 `uninstall` 目标的过程。'
- en: Git tag 3.8
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: Git 标签 3.8
- en: '[PRE30]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '*Listing 3-23:* Makefile: *Adding the `uninstall` target to the top-level makefile*'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 3-23：* Makefile：*向顶级 makefile 中添加 `uninstall` 目标*'
- en: '[PRE31]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: '*Listing 3-24:* src/Makefile: *Adding the `uninstall` target to the src-level
    makefile*'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 3-24：* src/Makefile: *将 `uninstall` 目标添加到 src 级别的 makefile*'
- en: As with the `install` target, this target requires root-level rights if the
    user is using a system prefix, such as */usr* or */usr/local*. You should be very
    careful about how you write your `uninstall` targets; unless a directory belongs
    specifically to your package, you shouldn’t assume you created it. If you do,
    you may end up deleting a system directory like */usr/bin*!
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 与 `install` 目标一样，如果用户使用系统前缀（如 */usr* 或 */usr/local*），则该目标需要 root 权限。你应该非常小心如何编写
    `uninstall` 目标；除非目录专门属于你的软件包，否则不应该假设是你创建了它。如果你这么做，可能会删除像 */usr/bin* 这样的系统目录！
- en: On the other hand, we did create the directory in the `install` target if it
    was originally missing, so we should remove it if possible. Here, we can use the
    `rmdir` command, whose job it is to remove empty directories. Even if the directory
    is a system directory such as */usr/bin*, removing it is harmless if it’s empty,
    but `rmdir` will fail if it’s not empty. Recalling that command failure stops
    the `make` process, we’ll also prefix it with a dash character. And we don’t really
    want to see such a failure, so we’ll redirect it’s output to */dev/null*.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，如果在 `install` 目标中目录最初缺失，我们确实创建了该目录，因此如果可能的话，我们应该将其删除。在这里，我们可以使用 `rmdir`
    命令，它的作用是删除空目录。即使该目录是像 */usr/bin* 这样的系统目录，如果它为空，删除它也是无害的，但如果它不为空，`rmdir` 将失败。回想一下，命令失败会停止
    `make` 进程，因此我们也会在前面加上一个短横线字符。而且我们不想看到这样的失败，所以我们会将它的输出重定向到 */dev/null*。
- en: 'The list of things to maintain in our build system is getting out of hand.
    There are now two places we need to update when we change our installation processes:
    the `install` and `uninstall` targets. Unfortunately, this is really about the
    best we can hope for when writing our own makefiles, unless we resort to fairly
    complex shell script commands. But hang in there—in [Chapter 6](ch06.xhtml), I’ll
    show you how to rewrite this makefile in a much simpler way using GNU Automake.'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的构建系统中需要维护的事项列表已经有些失控了。当我们更改安装过程时，现在有两个地方需要更新：`install` 和 `uninstall` 目标。不幸的是，当编写自己的
    makefile 时，这大概是我们能期望的最好的结果，除非我们使用相当复杂的 shell 脚本命令。但坚持下去——在[第6章](ch06.xhtml)中，我将展示如何使用
    GNU Automake 以更简单的方式重写这个 makefile。
- en: '*Testing Install and Uninstall*'
  id: totrans-242
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*测试安装和卸载*'
- en: Now let’s add some code to our `distcheck` target to test the functionality
    of the `install` and `uninstall` targets. After all, it’s fairly important that
    both of these targets work correctly from our distribution tarballs, so we should
    test them in `distcheck` before declaring the tarball release worthy. [Listing
    3-25](ch03.xhtml#ch03ex25) illustrates the necessary changes to the top-level
    makefile.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们在 `distcheck` 目标中添加一些代码，测试 `install` 和 `uninstall` 目标的功能。毕竟，确保这两个目标在我们的发行版
    tarball 中正确运行是非常重要的，所以我们应该在声明 tarball 版本可发布之前，在 `distcheck` 中对它们进行测试。[列表 3-25](ch03.xhtml#ch03ex25)
    展示了顶层 makefile 中所需的更改。
- en: Git tag 3.9
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: Git 标签 3.9
- en: '[PRE32]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: '*Listing 3-25:* Makefile: *Adding `distcheck` tests for the `install` and `uninstall`
    targets*'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 3-25：* Makefile: *为 `install` 和 `uninstall` 目标添加 `distcheck` 测试*'
- en: Note that I used a double dollar sign on the `$${PWD}` variable references,
    ensuring that `make` passes the variable reference to the shell with the rest
    of the command line, rather than expanding it inline before executing the command.
    I wanted this variable to be dereferenced by the shell rather than by the `make`
    utility.^([24](footnote.xhtml#ch03fn24))
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我在 `$${PWD}` 变量引用中使用了双美元符号，确保 `make` 在执行命令之前将变量引用传递给 shell，而不是在行内展开它。我希望这个变量由
    shell 解引用，而不是由 `make` 工具解引用。^([24](footnote.xhtml#ch03fn24))
- en: What we’re doing here is testing to ensure the `install` and `uninstall` targets
    don’t generate errors—but this isn’t very likely because all they do is install
    files into a temporary directory within the build directory. We could add some
    code immediately after the `make` `install` command that looks for the products
    that are supposed to be installed, but that’s more than I’m willing to do. One
    reaches a point of diminishing returns, where the code that does the checking
    is just as complex as the installation code—in which case, the check becomes pointless.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里做的是测试，确保 `install` 和 `uninstall` 目标不会生成错误——但这不太可能，因为它们做的就是将文件安装到构建目录中的临时目录。我们可以在
    `make` `install` 命令之后立即添加一些代码，检查应该被安装的产品，但这超出了我的承受范围。到了一定的程度，做检查的代码和安装代码一样复杂——在这种情况下，检查就变得毫无意义。
- en: 'But there is something else we can do: we can write a more or less generic
    test that checks to see if everything we installed was properly removed. Since
    the stage directory was empty before our installation, it had better be in a similar
    state after we uninstall. [Listing 3-26](ch03.xhtml#ch03ex26) shows the addition
    of this test.'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 但是我们可以做其他事情：我们可以编写一个或多或少通用的测试，检查我们安装的所有东西是否都被正确删除。由于安装前阶段目录是空的，卸载后它最好保持相似的状态。[清单
    3-26](ch03.xhtml#ch03ex26)展示了这个测试的增加。
- en: Git tag 3.10
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: Git 标签 3.10
- en: '[PRE33]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: '*Listing 3-26:* Makefile: *Adding a test for leftover files after `uninstall`
    finishes*'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 3-26:* Makefile: *添加一个测试以检查`uninstall`完成后剩余的文件*'
- en: The test first generates a numeric value at ➊ in a shell variable called `remaining`,
    which represents the number of regular files found in the stage directory we used.
    If this number is not zero, the test prints a message to the console at ➋ indicating
    how many files were left behind by the `uninstall` commands and then it exits
    with an error. Exiting early leaves the stage directory intact so we can examine
    it to find out which files we forgot to uninstall.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 这个测试首先在➊生成一个数字值，存储在名为`remaining`的 shell 变量中，表示在我们使用的阶段目录中找到的常规文件数量。如果这个数字不为零，测试会在➋向控制台打印一条信息，指示有多少文件在`uninstall`命令执行后被遗留下来，然后它会带着错误退出。提前退出让阶段目录保持不变，这样我们可以检查它，找出我们忘记卸载的文件。
- en: '**NOTE**'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*This test code represents a good use of multiple shell commands passed to
    a single shell. I had to do this here so that the value of *`remaining`* would
    be available for use by the *`if`* statement. Conditionals don’t work very well
    when the closing *`if`* is not executed by the same shell as the opening *`if`*!*'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: '*这个测试代码很好地利用了多个 shell 命令传递给一个 shell。我不得不这样做，以便*`remaining`*的值可以被*`if`*语句使用。当闭合的*`if`*没有由与开头的*`if`*相同的
    shell 执行时，条件语句的工作效果不好！*'
- en: I don’t want to alarm people by printing the embedded `echo` statement unless
    it really should be executed, so I prefixed the entire test with an at sign (`@`)
    so that `make` wouldn’t print the code to `stdout`. Since `make` considers these
    five lines of code a single command, the only way to suppress printing the `echo`
    statement is to suppress printing the entire command.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 我不想通过打印嵌入的`echo`语句来吓到人们，除非它真的应该被执行，所以我在整个测试前加上了一个 at 符号（`@`），这样`make`就不会将代码打印到`stdout`。由于`make`将这五行代码视为一个命令，抑制打印`echo`语句的唯一方法是抑制打印整个命令。
- en: Now, this test isn’t perfect—not by a long shot. This code only checks for regular
    files. If your installation procedure creates any soft links, this test won’t
    notice if they’re left behind. The directory structure that’s built during installation
    is purposely left in place because the check code doesn’t know whether a subdirectory
    within the stage directory belongs to the system or to the project. The `uninstall`
    rule’s commands can be aware of which directories are project specific and properly
    remove them, but I don’t want to add project-specific knowledge into the `distcheck`
    tests—it’s that problem of diminishing returns again.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，这个测试并不完美——远远不完美。这个代码只检查常规文件。如果你的安装过程创建了软链接，这个测试将不会注意到它们是否被遗留下来。安装过程中构建的目录结构故意保持不变，因为检查代码并不知道阶段目录中的子目录是属于系统的还是属于项目的。`uninstall`规则中的命令可以知道哪些目录是项目特定的并正确地删除它们，但我不想在`distcheck`测试中加入项目特定的知识——这又是那个收益递减的问题。
- en: The Filesystem Hierarchy Standard
  id: totrans-258
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 文件系统层次标准
- en: 'You may be wondering by now where I’m getting these directory names. What if
    some Unix system out there doesn’t use */usr* or */usr/local*? For one thing,
    this is another reason for providing the `prefix` variable—to allow the user some
    choice in these matters. However, most Unix-like systems nowadays follow the *Filesystem
    Hierarchy Standard (FHS)* as closely as possible. The *FHS* defines a number of
    standard places, including the following root-level directories:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能现在在想，我是从哪里得到这些目录名的。如果某些 Unix 系统没有使用*/usr*或*/usr/local*怎么办呢？首先，这也是提供`prefix`变量的原因之一——让用户在这些问题上有一些选择。然而，现在大多数类
    Unix 系统尽可能遵循*文件系统层次标准（FHS）*。*FHS* 定义了多个标准位置，包括以下根级目录：
- en: '| */bin* | */etc* | */home* |'
  id: totrans-260
  prefs: []
  type: TYPE_TB
  zh: '| */bin* | */etc* | */home* |'
- en: '| */opt* | */sbin* | */srv* |'
  id: totrans-261
  prefs: []
  type: TYPE_TB
  zh: '| */opt* | */sbin* | */srv* |'
- en: '| */tmp* | */usr* | */var* |'
  id: totrans-262
  prefs: []
  type: TYPE_TB
  zh: '| */tmp* | */usr* | */var* |'
- en: 'This list is by no means exhaustive. I’ve only mentioned the directories that
    are most relevant to our study of open source project build systems. In addition,
    the *FHS* defines several standard locations beneath these root-level directories.
    For instance, the */usr* directory should contain the following subdirectories:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 这个列表绝不是详尽无遗的。我只提到了与我们研究开源项目构建系统最相关的目录。此外，*FHS* 定义了这些根级目录下的几个标准位置。例如，*/usr* 目录应包含以下子目录：
- en: '| */usr/bin* | */usr/include* | */usr/lib* |'
  id: totrans-264
  prefs: []
  type: TYPE_TB
  zh: '| */usr/bin* | */usr/include* | */usr/lib* |'
- en: '| */usr/local* | */usr/sbin* | */usr/share* |'
  id: totrans-265
  prefs: []
  type: TYPE_TB
  zh: '| */usr/local* | */usr/sbin* | */usr/share* |'
- en: '| */usr/src* |  |  |'
  id: totrans-266
  prefs: []
  type: TYPE_TB
  zh: '| */usr/src* |  |  |'
- en: The */usr/local* directory should contain a structure very similar to that of
    the */usr* directory. The */usr/local* directory provides a location for software
    installation that overrides versions of the same packages installed in the */usr*
    directory structure, because system software updates often overwrite software
    in */usr* without prejudice. The */usr/local* directory structure allows a system
    administrator to decide which version of a package to use on their system because
    */usr/local/bin* may be (and usually is) added to the `PATH` before */usr/bin*.
    A fair amount of thought has gone into designing the *FHS*, and the GNU Autotools
    take full advantage of this consensus of understanding.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: '*/usr/local* 目录应包含与 */usr* 目录非常相似的结构。*/usr/local* 目录为软件安装提供了一个位置，可以覆盖安装在 */usr*
    目录结构中的相同软件包版本，因为系统软件更新通常会覆盖 */usr* 中的软件而不加区别。*/usr/local* 目录结构允许系统管理员决定在系统上使用哪个版本的包，因为
    */usr/local/bin* 可能（且通常会）被添加到 `PATH` 中，优先于 */usr/bin*。设计 *FHS* 时经过了相当多的思考，GNU
    Autotools 充分利用了这一共识。'
- en: Not only does the *FHS* define these standard locations, but it also explains
    in detail what they’re for and what types of files should be kept there. All in
    all, the *FHS* leaves you, as project maintainer, just enough flexibility and
    choice to keep your life interesting but not enough to make you wonder whether
    you’re installing your files in the right places.^([25](footnote.xhtml#ch03fn25))
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: '*FHS* 不仅定义了这些标准位置，还详细解释了它们的用途以及应该存放哪些类型的文件。总的来说，*FHS* 给了你作为项目维护者足够的灵活性和选择，使你的工作既有趣又不至于让你怀疑是否把文件安装到了正确的位置。^([25](footnote.xhtml#ch03fn25))'
- en: Supporting Standard Targets and Variables
  id: totrans-269
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 支持标准目标和变量
- en: In addition to those I’ve already mentioned, the *GNU Coding Standards* lists
    some important targets and variables that you should support in your projects—mainly
    because your users will expect support for them.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 除了我已经提到的内容外，*GNU 编程标准* 列出了你应该在项目中支持的一些重要目标和变量——主要是因为用户会期待你对它们的支持。
- en: Some of the chapters in the *GCS* document should be taken with a grain of salt
    (unless you’re actually working on a GNU-sponsored project). For example, you
    probably won’t care much about the C source code formatting suggestions in [Chapter
    5](ch05.xhtml) of the *GCS*. Your users certainly won’t care, so you can use whatever
    source code formatting style you wish.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: '*GCS* 文档中的一些章节应谨慎对待（除非你正在进行一个 GNU 资助的项目）。例如，你可能不会太关心 *GCS* 中 [第 5 章](ch05.xhtml)
    关于 C 源代码格式的建议。你的用户肯定不会在乎，因此你可以使用任何你喜欢的源代码格式样式。'
- en: That’s not to say that all of [Chapter 5](ch05.xhtml) is worthless to non-GNU
    open source projects. The “Portability between System Types” and “Portability
    between CPUs” subsections, for instance, provide excellent information on C source
    code portability. Also, the “Internationalization” subsection gives some useful
    tips on using GNU software to internationalize your projects. We’ll consider internationalization
    in greater detail in [Chapter 11](ch11.xhtml) of this book.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 这并不是说 [第 5 章](ch05.xhtml) 对非 GNU 开源项目没有价值。例如，“系统类型间的可移植性”和“CPU 之间的可移植性”小节提供了有关
    C 源代码可移植性的宝贵信息。此外，“国际化”小节也提供了一些使用 GNU 软件进行项目国际化的有用建议。我们将在本书的 [第 11 章](ch11.xhtml)
    中更详细地讨论国际化。
- en: While [Chapter 6](ch06.xhtml) of the *GCS* discusses documentation the GNU way,
    some sections of [Chapter 6](ch06.xhtml) describe various top-level text files
    commonly found in projects, such as the *AUTHORS*, *NEWS*, *INSTALL*, *README*,
    and *ChangeLog* files. These are all bits of information that the well-indoctrinated
    open source software user expects to see in any reputable project.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然*GCS*的[第6章](ch06.xhtml)讨论了GNU方式的文档，但[第6章](ch06.xhtml)中的一些部分描述了项目中常见的各种顶级文本文件，如*AUTHORS*、*NEWS*、*INSTALL*、*README*和*ChangeLog*文件。这些信息都是受过良好开源软件培训的用户期待在任何声誉良好的项目中看到的内容。
- en: The *really* useful information in the *GCS* document begins in [Chapter 7](ch07.xhtml),
    “The Release Process.” This chapter is critical to you as a project maintainer
    because it defines what your users will expect of your projects’ build systems.
    [Chapter 7](ch07.xhtml) contains the de facto standards for the user options that
    packages provide in source-level distributions.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: '*真正*有用的信息出现在*GCS*文档的[第7章](ch07.xhtml)，“发布过程”。这一章对你作为项目维护者至关重要，因为它定义了用户对你项目构建系统的期望。[第7章](ch07.xhtml)包含了源代码分发包中用户选项的事实标准。'
- en: '*Standard Targets*'
  id: totrans-275
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*标准目标*'
- en: 'The “How Configuration Should Work” subsection of [Chapter 7](ch07.xhtml) of
    the *GCS* defines the configuration process, which I cover briefly in “Configuring
    Your Package” on [page 77](ch03.xhtml#page_77). The “Makefile Conventions” subsection
    of the *GCS* covers all of the standard targets and many of the standard variables
    that users have come to expect in open source software packages. Standard targets
    defined by the *GCS* include the following:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: '*GCS*文档[第7章](ch07.xhtml)中的“配置应如何工作”小节定义了配置过程，我在“配置你的包”一节中简要介绍了这一过程，见[第77页](ch03.xhtml#page_77)。*GCS*的“Makefile约定”小节涵盖了所有标准目标和许多用户在开源软件包中期望看到的标准变量。*GCS*定义的标准目标包括以下内容：'
- en: '| `all` | `install` | `install-html` |'
  id: totrans-277
  prefs: []
  type: TYPE_TB
  zh: '| `all` | `install` | `install-html` |'
- en: '| `install-dvi` | `install-pdf` | `install-ps` |'
  id: totrans-278
  prefs: []
  type: TYPE_TB
  zh: '| `install-dvi` | `install-pdf` | `install-ps` |'
- en: '| `install-strip` | `uninstall` | `clean` |'
  id: totrans-279
  prefs: []
  type: TYPE_TB
  zh: '| `install-strip` | `uninstall` | `clean` |'
- en: '| `distclean` | `mostlyclean` | `maintainer-clean` |'
  id: totrans-280
  prefs: []
  type: TYPE_TB
  zh: '| `distclean` | `mostlyclean` | `maintainer-clean` |'
- en: '| `TAGS` | `info` | `dvi` |'
  id: totrans-281
  prefs: []
  type: TYPE_TB
  zh: '| `TAGS` | `info` | `dvi` |'
- en: '| `html` | `pdf` | `ps` |'
  id: totrans-282
  prefs: []
  type: TYPE_TB
  zh: '| `html` | `pdf` | `ps` |'
- en: '| `dist` | `check` | `installcheck` |'
  id: totrans-283
  prefs: []
  type: TYPE_TB
  zh: '| `dist` | `check` | `installcheck` |'
- en: '| `installdirs` |  |  |'
  id: totrans-284
  prefs: []
  type: TYPE_TB
  zh: '| `installdirs` |  |  |'
- en: You don’t need to support all of these targets, but you should consider supporting
    the ones that make sense for your project. For example, if you build and install
    HTML pages, you should probably consider supporting the `html` and `install-html`
    targets. Autotools projects support these and more. Some targets are useful to
    end users, while others are useful only to project maintainers.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 你不需要支持所有这些目标，但应该考虑支持那些对你的项目有意义的目标。例如，如果你构建并安装HTML页面，你可能需要考虑支持`html`和`install-html`目标。Autotools项目支持这些及更多目标。有些目标对最终用户有用，而有些则仅对项目维护者有用。
- en: '*Standard Variables*'
  id: totrans-286
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*标准变量*'
- en: 'Variables you should support as you see fit include those listed in the following
    table. In order to provide flexibility for the end user, most of these variables
    are defined in terms of a few of them and, ultimately, only one of them: `prefix`.
    For lack of a more standard name, I call these *prefix variables*. Most of these
    could be classified as *installation directory variables* that refer to standard
    locations, but there are a few exceptions, such as `srcdir`.'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该根据需要支持的变量包括下表中列出的变量。为了为最终用户提供灵活性，大多数这些变量是通过其中一些变量定义的，最终归结为一个变量：`prefix`。由于没有更标准的名称，我将这些称为*前缀变量*。这些变量中的大多数可以归类为*安装目录变量*，它们指向标准位置，但也有一些例外，比如`srcdir`。
- en: These variables are meant to be fully resolved by `make`, so they’re defined
    in terms of `make` variables, using parentheses rather than curly brackets. [Table
    3-1](ch03.xhtml#ch03tab1) lists these prefix variables and their default values.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 这些变量的目的是由`make`完全解析，因此它们是通过`make`变量来定义的，使用圆括号而非花括号。[表 3-1](ch03.xhtml#ch03tab1)列出了这些前缀变量及其默认值。
- en: '**Table 3-1:** Prefix Variables and Their Default Values'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: '**表 3-1：** 前缀变量及其默认值'
- en: '| **Variable** | **Default Value** |'
  id: totrans-290
  prefs: []
  type: TYPE_TB
  zh: '| **变量** | **默认值** |'
- en: '| `prefix` | /usr/local |'
  id: totrans-291
  prefs: []
  type: TYPE_TB
  zh: '| `prefix` | /usr/local |'
- en: '| `exec_prefix` | `$(prefix)` |'
  id: totrans-292
  prefs: []
  type: TYPE_TB
  zh: '| `exec_prefix` | `$(prefix)` |'
- en: '| `bindir` | `$(exec_prefix)`/bin |'
  id: totrans-293
  prefs: []
  type: TYPE_TB
  zh: '| `bindir` | `$(exec_prefix)`/bin |'
- en: '| `sbindir` | `$(exec_prefix)`/sbin |'
  id: totrans-294
  prefs: []
  type: TYPE_TB
  zh: '| `sbindir` | `$(exec_prefix)`/sbin |'
- en: '| `libexecdir` | `$(exec_prefix)`/libexec |'
  id: totrans-295
  prefs: []
  type: TYPE_TB
  zh: '| `libexecdir` | `$(exec_prefix)`/libexec |'
- en: '| `datarootdir` | `$(prefix)`/share |'
  id: totrans-296
  prefs: []
  type: TYPE_TB
  zh: '| `datarootdir` | `$(prefix)`/share |'
- en: '| `datadir` | `$(datarootdir)` |'
  id: totrans-297
  prefs: []
  type: TYPE_TB
  zh: '| `datadir` | `$(datarootdir)` |'
- en: '| `sysconfdir` | `$(prefix)`/etc |'
  id: totrans-298
  prefs: []
  type: TYPE_TB
  zh: '| `sysconfdir` | `$(prefix)`/etc |'
- en: '| `sharedstatedir` | `$(prefix)`/com |'
  id: totrans-299
  prefs: []
  type: TYPE_TB
  zh: '| `sharedstatedir` | `$(prefix)`/com |'
- en: '| `localstatedir` | `$(prefix)`/var |'
  id: totrans-300
  prefs: []
  type: TYPE_TB
  zh: '| `localstatedir` | `$(prefix)`/var |'
- en: '| `includedir` | `$(prefix)/`include |'
  id: totrans-301
  prefs: []
  type: TYPE_TB
  zh: '| `includedir` | `$(prefix)/`include |'
- en: '| `oldincludedir` | /usr/include |'
  id: totrans-302
  prefs: []
  type: TYPE_TB
  zh: '| `oldincludedir` | /usr/include |'
- en: '| `docdir` | `$(datarootdir)`/doc/`$(package)` |'
  id: totrans-303
  prefs: []
  type: TYPE_TB
  zh: '| `docdir` | `$(datarootdir)`/doc/`$(package)` |'
- en: '| `infodir` | `$(datarootdir)`/info |'
  id: totrans-304
  prefs: []
  type: TYPE_TB
  zh: '| `infodir` | `$(datarootdir)`/info |'
- en: '| `htmldir` | `$(docdir)` |'
  id: totrans-305
  prefs: []
  type: TYPE_TB
  zh: '| `htmldir` | `$(docdir)` |'
- en: '| `dvidir` | `$(docdir)` |'
  id: totrans-306
  prefs: []
  type: TYPE_TB
  zh: '| `dvidir` | `$(docdir)` |'
- en: '| `pdfdir` | `$(docdir)` |'
  id: totrans-307
  prefs: []
  type: TYPE_TB
  zh: '| `pdfdir` | `$(docdir)` |'
- en: '| `psdir` | `$(docdir)` |'
  id: totrans-308
  prefs: []
  type: TYPE_TB
  zh: '| `psdir` | `$(docdir)` |'
- en: '| `libdir` | `$(exec_prefix)`/lib |'
  id: totrans-309
  prefs: []
  type: TYPE_TB
  zh: '| `libdir` | `$(exec_prefix)`/lib |'
- en: '| `lispdir` | `$(datarootdir)`/emacs/site-lisp |'
  id: totrans-310
  prefs: []
  type: TYPE_TB
  zh: '| `lispdir` | `$(datarootdir)`/emacs/site-lisp |'
- en: '| `localedir` | `$(datarootdir)`/locale |'
  id: totrans-311
  prefs: []
  type: TYPE_TB
  zh: '| `localedir` | `$(datarootdir)`/locale |'
- en: '|  `mandir`  | `$(datarootdir)`/man |'
  id: totrans-312
  prefs: []
  type: TYPE_TB
  zh: '|  `mandir`  | `$(datarootdir)`/man |'
- en: '| `man`*`N`*`dir` | `$(mandir)`/man*N* (*N* = 1..9) |'
  id: totrans-313
  prefs: []
  type: TYPE_TB
  zh: '| `man`*`N`*`dir` | `$(mandir)`/man*N* (*N* = 1..9) |'
- en: '| `manext` | .1 |'
  id: totrans-314
  prefs: []
  type: TYPE_TB
  zh: '| `manext` | .1 |'
- en: '| `man`*`N`*`ext` | .*N* (*N* = 1..9) |'
  id: totrans-315
  prefs: []
  type: TYPE_TB
  zh: '| `man`*`N`*`ext` | .*N* (*N* = 1..9) |'
- en: '| `srcdir` | The source-tree directory corresponding to the current directory
    in the build tree |'
  id: totrans-316
  prefs: []
  type: TYPE_TB
  zh: '| `srcdir` | 构建树中与当前目录对应的源代码树目录 |'
- en: Autotools-based projects support these and other useful variables automatically,
    as needed; Automake provides full support for them, while Autoconf’s support is
    more limited. If you write your own makefiles and build systems, you should support
    as many of these as you use in your build and installation processes.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 基于Autotools的项目会自动支持这些以及其他有用的变量，根据需要；Automake对此提供完全支持，而Autoconf的支持则较为有限。如果你编写自己的makefile和构建系统，你应该支持在构建和安装过程中使用的尽可能多的这些变量。
- en: '*Adding Location Variables to Jupiter*'
  id: totrans-318
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*将位置变量添加到Jupiter*'
- en: To support the variables that we’ve used so far in the Jupiter project, we need
    to add the `bindir` variable, as well as any variables that it relies on—in this
    case, the `exec_prefix` variable. [Listings 3-27](ch03.xhtml#ch03ex27) and [3-28](ch03.xhtml#ch03ex28)
    show how to do this in the top-level and *src* directory makefiles.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 为了支持我们在Jupiter项目中使用的变量，我们需要添加`bindir`变量，以及它所依赖的任何变量——在这种情况下，是`exec_prefix`变量。[列表
    3-27](ch03.xhtml#ch03ex27)和[3-28](ch03.xhtml#ch03ex28)展示了如何在顶级和*src*目录的makefile中进行此操作。
- en: Git tag 3.11
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: Git标签3.11
- en: '[PRE34]'
  id: totrans-321
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: '*Listing 3-27:* Makefile: *Adding the `bindir` variable*'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 3-27:* Makefile: *添加 `bindir` 变量*'
- en: '[PRE35]'
  id: totrans-323
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: '*Listing 3-28:* src/Makefile: *Adding the `bindir` variable*'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 3-28:* src/Makefile: *添加 `bindir` 变量*'
- en: Even though we only use `bindir` in *src/Makefile*, we have to export `prefix`,
    `exec_prefix`, and `bindir` because `bindir` is defined in terms of `exec_prefix`,
    which is itself defined in terms of `prefix`. When `make` runs the `install` commands,
    it will first resolve `bindir` to `$(exec_prefix)`*/bin*, then to `$(prefix)`*/bin*,
    and finally to */usr/local/bin*. Thus, *src/Makefile* needs to have access to
    all three variables during this process.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 即使我们只在*src/Makefile*中使用`bindir`，我们也必须导出`prefix`、`exec_prefix`和`bindir`，因为`bindir`是通过`exec_prefix`定义的，而`exec_prefix`又是通过`prefix`定义的。当`make`运行`install`命令时，它将首先将`bindir`解析为`$(exec_prefix)`*/bin*，然后为`$(prefix)`*/bin*，最后为*/usr/local/bin*。因此，*src/Makefile*在此过程中需要访问这三个变量。
- en: 'How do such recursive variable definitions make life better for the end user?
    After all, the user can change the root install location from */usr/local* to
    */usr* by simply typing the following:'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 这些递归变量定义如何使最终用户的生活更轻松？毕竟，用户只需输入以下命令，就可以将根安装位置从*/usr/local*更改为*/usr*：
- en: '[PRE36]'
  id: totrans-327
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'The ability to change prefix variables at multiple levels is particularly useful
    to a Linux distribution packager (an employee or volunteer at a Linux company
    whose job it is to professionally package your project as a *.deb* or *.rpm* package)
    who needs to install packages into very specific system locations. For example,
    a distro packager could use the following command to change the installation prefix
    to */usr* and the system configuration directory to */etc*:'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 在多个层级更改前缀变量的能力对于Linux发行版打包人员（在Linux公司工作的员工或志愿者，负责将你的项目专业地打包成*.deb*或*.rpm*包）尤其有用，因为他们需要将包安装到非常特定的系统位置。例如，发行版打包人员可以使用以下命令将安装前缀更改为*/usr*，系统配置目录更改为*/etc*：
- en: '[PRE37]'
  id: totrans-329
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Without the ability to change prefix variables at multiple levels, configuration
    files would end up in */usr/etc* because the default value of `$(sysconfdir)`
    is `$(prefix)`*/etc*.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有在多个层级更改前缀变量的能力，配置文件将最终位于*/usr/etc*，因为`$(sysconfdir)`的默认值是`$(prefix)`*/etc*。
- en: Getting Your Project into a Linux Distro
  id: totrans-331
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 将你的项目加入Linux发行版
- en: When a Linux distro picks up your package for distribution, your project magically
    moves from the realm of tens of users to that of tens of thousands of users—almost
    overnight. Some people will be using your software without even knowing it. Since
    one great value of open source software for the developer is free help in making
    your software better, this can be seen as a good thing—a dramatic increase in
    community size.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个 Linux 发行版接手你的软件包进行分发时，你的项目几乎一夜之间就从数十个用户的范围，扩展到数万个用户的范围—几乎是立竿见影。有些人甚至可能在不知情的情况下使用你的软件。由于开源软件对于开发者的一大价值是免费帮助改进软件，所以这可以看作是一件好事——社区规模的急剧增加。
- en: By following the *GCS* within your build system, you remove many of the barriers
    to including your project in a Linux distro. If your tarball follows all the usual
    conventions, distro packagers will immediately know what to do with it. These
    packagers generally get to decide, based on needed functionality and their feelings
    about your package, whether it should be included in their flavor of Linux. Since
    they have a fair amount of power in this process, it behooves you to please them.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 通过在你的构建系统中遵循 *GCS*，你去除了许多将你的项目包含到 Linux 发行版中的障碍。如果你的 tar 包遵循所有常规约定，发行版的打包人员会立刻知道该如何处理它。这些打包人员通常会根据所需的功能以及他们对你软件包的看法，决定是否将其包含到他们的
    Linux 版本中。由于他们在这个过程中拥有相当大的权力，取悦他们对你来说是有利的。
- en: Section 7 of the *GCS* contains a small subsection that talks about supporting
    *staged installations*. It is easy to support this concept in your build system,
    but if you neglect to support it, it will almost always cause problems for packagers.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: '*GCS* 的第7节包含一个小小的子节，讨论了支持 *分阶段安装* 的内容。在你的构建系统中支持这一概念很容易，但如果你忽视了它，几乎总是会给打包人员带来问题。'
- en: Packaging systems such as the Red Hat Package Manager (RPM) accept one or more
    tarballs, a set of patch files, and a specification file. The so-called *spec
    file* describes the process of building and packaging your project for a particular
    system. In addition, it defines all of the products installed into the target
    installation directory structure. The package manager software uses this information
    to install your package into a temporary directory, from which it then pulls the
    specified products, storing them in a special binary archive that the package
    installation program (for example, `rpm`) understands.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 包装系统，如 Red Hat 包管理器（RPM），接受一个或多个 tar 包、一组补丁文件和一个规范文件。所谓的 *spec 文件* 描述了在特定系统上构建和打包项目的过程。此外，它定义了所有安装到目标安装目录结构中的产品。包管理软件使用这些信息将你的软件包安装到临时目录中，然后从中提取指定的产品，将它们存储在包安装程序（例如
    `rpm`）能够理解的特殊二进制归档中。
- en: To support staged installation, all you need is a variable named `DESTDIR` that
    acts as a sort of super-prefix to all of your installed products. To show you
    how this is done, I’ll add staged installation support to the Jupiter project.
    This is so trivial that it requires only four changes to *src/Makefile*. The required
    changes are highlighted in [Listing 3-29](ch03.xhtml#ch03ex29).
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 要支持分阶段安装，你只需要一个名为 `DESTDIR` 的变量，它作为一个超级前缀作用于所有已安装的产品。为了向你展示如何实现这一点，我将给 Jupiter
    项目添加分阶段安装支持。这是非常简单的，只需对 *src/Makefile* 做四处更改即可。所需的更改在 [Listing 3-29](ch03.xhtml#ch03ex29)
    中已标出。
- en: Git tag 3.12
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: Git 标签 3.12
- en: '[PRE38]'
  id: totrans-338
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: '*Listing 3-29:* src/Makefile: *Adding staged build functionality*'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: '*Listing 3-29:* src/Makefile: *添加分阶段构建功能*'
- en: As you can see, I’ve added the `$(DESTDIR)` prefix to the `$(bindir)` references
    in the `install` and `uninstall` targets that refer to installation paths. You
    don’t need to define a default value for `DESTDIR`, because when it is left undefined,
    it expands to an empty string, which has no effect on the paths to which it’s
    prepended.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，我已经将 `$(DESTDIR)` 前缀添加到了 `install` 和 `uninstall` 目标中引用安装路径的 `$(bindir)`
    变量上。你无需为 `DESTDIR` 定义默认值，因为当它未定义时，它会展开为一个空字符串，这对其前置的路径没有影响。
- en: '**NOTE**'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*Do not add a slash after *`$(DESTDIR)`*, which is usually empty. The prefix
    variables ultimately resolve to something starting with a slash; adding a slash
    after *`$(DESTDIR)`* is therefore redundant and, in some situations, can cause
    unintended side effects.*'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: '*不要在*`$(DESTDIR)`* 后面加斜杠，通常它是空的。前缀变量最终解析为以斜杠开始的内容；因此，在*`$(DESTDIR)`* 后加斜杠是多余的，并且在某些情况下可能会引起意外的副作用。*'
- en: I didn’t need to add `$(DESTDIR)` to the `uninstall` rule’s `rm` command for
    the sake of the package manager, because package managers don’t care how your
    package is uninstalled. They only install your package so they can copy the products
    from a stage directory. To uninstall the stage directory, package managers simply
    delete it. Package manager programs such as `rpm` use their own rules for removing
    products from a system, and these rules are based on a package manager database
    rather than your `uninstall` target.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 我不需要为包管理器的原因在 `uninstall` 规则的 `rm` 命令中添加 `$(DESTDIR)`，因为包管理器不关心你的包是如何卸载的。它们只会安装你的包，以便从阶段目录中复制产品。要卸载阶段目录，包管理器只需要删除它。像
    `rpm` 这样的包管理程序使用它们自己的规则来从系统中删除产品，这些规则基于包管理器数据库，而不是你的 `uninstall` 目标。
- en: However, for the sake of symmetry, and to be complete, it doesn’t hurt to add
    `$(DESTDIR)` to `uninstall`. Besides, we need it to be complete for the sake of
    the `distcheck` target, which we’ll now modify to take advantage of our staged
    installation functionality. This modification is shown in [Listing 3-30](ch03.xhtml#ch03ex30).
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，为了对称性，并且为了完整性，将 `$(DESTDIR)` 添加到 `uninstall` 中并不会有坏处。此外，我们需要它来完整地支持 `distcheck`
    目标，我们将修改它，以便利用我们的分阶段安装功能。这个修改展示在[清单 3-30](ch03.xhtml#ch03ex30)中。
- en: Git tag 3.13
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: Git 标签 3.13
- en: '[PRE39]'
  id: totrans-346
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: '*Listing 3-30:* Makefile: *Using `DESTDIR` in the `distcheck` target*'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 3-30:* Makefile: *在 `distcheck` 目标中使用 `DESTDIR`*'
- en: Changing `prefix` to `DESTDIR` in the `install` and `uninstall` commands allows
    us to properly test a complete installation directory hierarchy, as we’ll see
    shortly.
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `install` 和 `uninstall` 命令中将 `prefix` 更改为 `DESTDIR` 使我们能够正确测试完整的安装目录层级，正如我们稍后将看到的那样。
- en: 'At this point, an RPM spec file could provide the following text as the installation
    commands for the Jupiter package:'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，一个 RPM 规范文件可以提供以下文本作为 Jupiter 包的安装命令：
- en: '[PRE40]'
  id: totrans-350
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Don’t worry about package manager file formats. Instead, just focus on providing
    staged installation functionality through the `DESTDIR` variable.
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 不要担心包管理器的文件格式。相反，只需专注于通过 `DESTDIR` 变量提供分阶段安装功能。
- en: You may be wondering why the `prefix` variable couldn’t provide this functionality.
    For one thing, not every path in a system-level installation is defined relative
    to the `prefix` variable. The system configuration directory (`sysconfdir`), for
    instance, is often defined as */etc* by packagers. You can see in [Table 3-1](ch03.xhtml#ch03tab1)
    that the default definition of `sysconfdir` is `$(prefix)`*/etc*, so the only
    way `sysconfdir` would resolve to */etc* would be if you explicitly set it to
    do so on the `configure` or `make` command line. If you configured it that way,
    only a variable like `DESTDIR` would affect the base location of `sysconfdir`
    during staged installation. Other reasons for this will become clearer as we talk
    about project configuration later on in this chapter, and then again in the next
    two chapters.
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会想，为什么 `prefix` 变量无法提供此功能。一方面，并不是系统级安装中的每个路径都是相对于 `prefix` 变量定义的。例如，系统配置目录（`sysconfdir`）通常由打包者定义为
    */etc*。你可以在[表 3-1](ch03.xhtml#ch03tab1)中看到，`sysconfdir` 的默认定义是 `$(prefix)`*/etc*，因此，只有显式在
    `configure` 或 `make` 命令行中设置它，`sysconfdir` 才会解析为 */etc*。如果你这样配置，只有像 `DESTDIR` 这样的变量才会在分阶段安装过程中影响
    `sysconfdir` 的基本位置。随着我们在本章稍后的项目配置讨论，和接下来的两章讲解，其他原因会变得更加清晰。
- en: Build vs. Installation Prefix Overrides
  id: totrans-353
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 构建与安装前缀重写
- en: 'At this point, I’d like to digress slightly to explain an elusive (or at least
    nonobvious) concept regarding `prefix` and other path variables defined in the
    *GCS*. In the preceding examples, I used prefix overrides on the `make install`
    command line, like this:'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，我想稍微离题一下，解释一下关于 `prefix` 和其他路径变量在 *GCS* 中定义的一个难以捉摸（或者至少不显而易见）的概念。在前面的例子中，我在
    `make install` 命令行上使用了 `prefix` 重写，像这样：
- en: '[PRE41]'
  id: totrans-355
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'The question I wish to address is: what is the difference between using a prefix
    override for `make all` and for `make install`? In our small sample makefiles,
    we’ve managed to avoid using prefixes in any targets not related to installation,
    so it may not be clear to you at this point that a prefix is *ever* useful during
    the build stage. However, prefix variables can be very useful during the build
    stage to substitute paths into source code at compile time, as shown in [Listing
    3-31](ch03.xhtml#ch03ex31).'
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 我想要解决的问题是：使用前缀覆盖 `make all` 和 `make install` 有什么区别？在我们的简化样本 makefile 中，我们设法避免在与安装无关的任何目标中使用前缀，所以你现在可能还不清楚前缀在构建阶段是否*有用*。然而，正如[清单
    3-31](ch03.xhtml#ch03ex31)所示，前缀变量在构建阶段通过在编译时替换路径到源代码中非常有用。
- en: '[PRE42]'
  id: totrans-357
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: '*Listing 3-31: Substituting paths into source code at compile time*'
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 3-31：在编译时将路径替换到源代码中*'
- en: In this example, I’m defining a C-preprocessor variable called `CFGDIR` on the
    compiler command line for use by *main.c*. Presumably, there’s some code in *main.c*
    like that shown in [Listing 3-32](ch03.xhtml#ch03ex32).
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我在编译器命令行中定义了一个名为 `CFGDIR` 的 C 预处理器变量，供 *main.c* 使用。假设在 *main.c* 中有类似于[清单
    3-32](ch03.xhtml#ch03ex32)所示的代码。
- en: '[PRE43]'
  id: totrans-360
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: '*Listing 3-32: Substituting `CFGDIR` at compile time*'
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 3-32：在编译时替换 `CFGDIR`*'
- en: Later in the code, you might use the C global variable `cfgdir` to access the
    application’s configuration file.
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 在代码中稍后，你可能会使用 C 全局变量 `cfgdir` 来访问应用程序的配置文件。
- en: Linux distro packagers often use different prefix overrides for build and install
    command lines in RPM spec files. During the build stage, the actual runtime directories
    are hardcoded into the executable using commands like the `./configure` command
    shown in [Listing 3-33](ch03.xhtml#ch03ex33).
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: Linux 发行版打包者通常会在 RPM 规范文件中的构建和安装命令行使用不同的前缀覆盖。在构建阶段，实际的运行时目录通过类似于[清单 3-33](ch03.xhtml#ch03ex33)中显示的
    `./configure` 命令被硬编码到可执行文件中。
- en: '[PRE44]'
  id: totrans-364
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: '*Listing 3-33: The portion of an RPM spec file that builds the source tree*'
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 3-33：构建源代码树的 RPM 规范文件部分*'
- en: Note that we have to explicitly specify `sysconfdir` along with `prefix`, because,
    as I mentioned earlier, the system configuration directory is usually outside
    of the `prefix` directory structure. The package manager installs these executables
    into a stage directory so it can then copy them out of their installed locations
    when it builds the binary installation package. The corresponding installation
    commands might look like those shown in [Listing 3-34](ch03.xhtml#ch03ex34).
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们必须显式地指定 `sysconfdir` 和 `prefix`，因为正如我之前提到的，系统配置目录通常位于 `prefix` 目录结构之外。包管理器将这些可执行文件安装到一个临时目录中，然后在构建二进制安装包时再从其安装位置复制它们。相应的安装命令可能类似于[清单
    3-34](ch03.xhtml#ch03ex34)中显示的命令。
- en: '[PRE45]'
  id: totrans-367
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: '*Listing 3-34: The installation portion of an RPM spec file*'
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 3-34：RPM 规范文件的安装部分*'
- en: Using `DESTDIR` during installation will temporarily override *all* installation
    prefix variables, so you don’t have to remember which variables you’ve overridden
    during configuration. Given the configuration command shown in [Listing 3-33](ch03.xhtml#ch03ex33),
    using `DESTDIR` in the manner shown in [Listing 3-34](ch03.xhtml#ch03ex34) has
    the same effect as the code shown in [Listing 3-35](ch03.xhtml#ch03ex35).
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 在安装过程中使用 `DESTDIR` 会临时覆盖 *所有* 安装前缀变量，因此你无需记住在配置时已覆盖哪些变量。根据[清单 3-33](ch03.xhtml#ch03ex33)中显示的配置命令，在[清单
    3-34](ch03.xhtml#ch03ex34)中显示的方式使用 `DESTDIR`，与[清单 3-35](ch03.xhtml#ch03ex35)中显示的代码效果相同。
- en: '[PRE46]'
  id: totrans-370
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: '*Listing 3-35: Overriding the default `sysconfdir` during installation*'
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 3-35：在安装过程中覆盖默认的 `sysconfdir`*'
- en: '**WARNING**'
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: '**警告**'
- en: '*The key point here is one that I touched on earlier. Never write your install
    target to build all or even part of your products in your makefiles. Installation
    functionality should be limited to copying files, if possible. Otherwise, your
    users won’t be able to access your staged installation features if they are using
    prefix overrides.*'
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: '*这里的关键点是我之前提到过的。永远不要在 makefile 中为 `make all` 或即使是部分产品构建编写安装目标。安装功能应该仅限于复制文件，尽可能如此。否则，如果用户使用前缀覆盖，他们将无法访问你的阶段安装功能。*'
- en: Another reason for limiting installation functionality in this way is that it
    allows the user to install sets of packages as a group into an isolated location
    and then create links to the actual files in the proper locations. Some people
    like to do this when they are testing out a package and want to keep track of
    all its components.^([26](footnote.xhtml#ch03fn26))
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 限制安装功能的另一个原因是，它允许用户将一组软件包作为一个整体安装到隔离位置，然后创建指向实际文件的链接到适当的位置。有些人在测试一个软件包时喜欢这样做，并希望追踪它的所有组件。^([26](footnote.xhtml#ch03fn26))
- en: 'One final point: if you’re installing into a system directory hierarchy, you’ll
    need *root* permissions. People often run `make install` like this:'
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一点：如果你正在安装到系统目录结构中，你需要*root*权限。人们通常会像这样运行 `make install`：
- en: '[PRE47]'
  id: totrans-376
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: If your `install` target depends on your build targets, and you’ve neglected
    to build them beforehand, `make` will happily build your program before installing
    it—but the local copies will all be owned by *root*. This inconvenience is easily
    avoided by having `make install` fail for lack of things to install, rather than
    jumping right into a build while running as *root*.
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的 `install` 目标依赖于构建目标，并且你之前忽略了构建它们，`make` 会在安装之前很高兴地构建你的程序——但是本地副本将全都由*root*拥有。通过让
    `make install` 因缺少需要安装的内容而失败，而不是在以*root*身份运行时直接进入构建过程，你可以轻松避免这种不便。
- en: User Variables
  id: totrans-378
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 用户变量
- en: The *GCS* defines a set of variables that are sacred to the user. These variables
    should be *referenced* by a GNU build system but never *modified* by a GNU build
    system. These so-called *user variables* include those listed in [Table 3-2](ch03.xhtml#ch03tab2)
    for C and C++ programs.
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: '*GCS* 定义了一组对用户至关重要的变量。这些变量应该被 GNU 构建系统*引用*，但永远不应该被 GNU 构建系统*修改*。这些所谓的*用户变量*包括在
    [表 3-2](ch03.xhtml#ch03tab2) 中列出的 C 和 C++ 程序相关的变量。'
- en: '**Table 3-2:** Some User Variables and Their Purposes'
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: '**表 3-2：** 一些用户变量及其用途'
- en: '| Variables | Purpose |'
  id: totrans-381
  prefs: []
  type: TYPE_TB
  zh: '| 变量 | 目的 |'
- en: '| `CC` | A reference to the system C compiler |'
  id: totrans-382
  prefs: []
  type: TYPE_TB
  zh: '| `CC` | 系统 C 编译器的引用 |'
- en: '| `CFLAGS` | Desired C compiler flags |'
  id: totrans-383
  prefs: []
  type: TYPE_TB
  zh: '| `CFLAGS` | 所需的 C 编译器标志 |'
- en: '| `CXX` | A reference to the system C++ compiler |'
  id: totrans-384
  prefs: []
  type: TYPE_TB
  zh: '| `CXX` | 系统 C++ 编译器的引用 |'
- en: '|  `CXXFLAGS`  | Desired C++ compiler flags |'
  id: totrans-385
  prefs: []
  type: TYPE_TB
  zh: '|  `CXXFLAGS`  | 所需的 C++ 编译器标志 |'
- en: '| `LDFLAGS` | Desired linker flags |'
  id: totrans-386
  prefs: []
  type: TYPE_TB
  zh: '| `LDFLAGS` | 所需的链接器标志 |'
- en: '| `CPPFLAGS` | Desired C/C++ preprocessor flags |'
  id: totrans-387
  prefs: []
  type: TYPE_TB
  zh: '| `CPPFLAGS` | 所需的 C/C++ 预处理器标志 |'
- en: '| *`--snip--`* |  |'
  id: totrans-388
  prefs: []
  type: TYPE_TB
  zh: '| *`--snip--`* |  |'
- en: This list is by no means comprehensive, and interestingly, there isn’t a comprehensive
    list to be found in the *GCS*. In fact, most of these variables come from the
    documentation for the `make` utility itself. These variables are used in the built-in
    rules of the `make` utility—they’re somewhat hardcoded into `make`, so they are
    effectively defined by `make`. You can find a fairly complete list of program
    name and flag variables in the “Variables Used by Implicit Rules” section of the
    *GNU Make Manual*.
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 这个列表绝不是详尽无遗的，值得注意的是，在 *GCS* 中并没有找到一个完整的列表。实际上，这些变量大多来自 `make` 工具本身的文档。这些变量用于
    `make` 工具的内建规则中——它们在 `make` 中有些是硬编码的，因此它们实际上由 `make` 定义。你可以在 *GNU Make Manual*
    的“隐式规则使用的变量”部分找到一个相对完整的程序名称和标志变量列表。
- en: Note that `make` assigns default values for many of these variables based on
    common Unix utility names. For example, the default value of `CC` is `cc`, which
    (at least on Linux systems) is a soft link to the GCC C compiler (`gcc`). On other
    systems, `cc` is a soft link to the system’s own compiler. Thus, we don’t need
    to set `CC` to `gcc`, which is good, because GCC may not be installed on non-Linux
    platforms. There may be times when you do wish to set `CC` on the `make` command
    line, such as when using an alternative compiler like `clang` or when using the
    `ccache` utility to cache `gcc` results for faster recompilation.
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，`make` 会根据常见的 Unix 工具名称为许多变量分配默认值。例如，`CC` 的默认值是 `cc`，在 Linux 系统上，`cc` 是指向
    GCC C 编译器（`gcc`）的软链接。在其他系统上，`cc` 是指向系统自有编译器的软链接。因此，我们不需要将 `CC` 设置为 `gcc`，这很好，因为在非
    Linux 平台上可能没有安装 GCC。你可能会在某些时候希望在 `make` 命令行中设置 `CC`，例如使用 `clang` 之类的替代编译器，或者在使用
    `ccache` 工具缓存 `gcc` 结果以加速重新编译时。
- en: For our purposes, the variables shown in [Table 3-2](ch03.xhtml#ch03tab2) are
    sufficient, but for a more complex makefile, you should become familiar with the
    larger list outlined in the *GNU Make Manual*.
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的目的来说，[表 3-2](ch03.xhtml#ch03tab2) 中显示的变量已经足够，但对于一个更复杂的 makefile，你应该熟悉 *GNU
    Make Manual* 中列出的更大列表。
- en: To use these variables in our makefiles, we’ll just replace `gcc` with `$(CC)`.
    We’ll do the same for `CFLAGS` and `CPPFLAGS`, although `CPPFLAGS` will be empty
    by default. The `CFLAGS` variable has no default value either, but this is a good
    time to add one. I like to use `-g` to build objects with symbols and `-O0` to
    disable optimizations for debug builds. The updates to *src/Makefile* are shown
    in [Listing 3-36](ch03.xhtml#ch03ex36).
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: 要在我们的makefile中使用这些变量，我们只需要将`gcc`替换为`$(CC)`。我们对`CFLAGS`和`CPPFLAGS`也做同样的处理，尽管`CPPFLAGS`默认是空的。`CFLAGS`变量也没有默认值，但这是一个添加默认值的好时机。我喜欢使用`-g`来构建带有符号的目标文件，使用`-O0`来禁用调试构建中的优化。对*src/Makefile*的更新见[列表
    3-36](ch03.xhtml#ch03ex36)。
- en: Git tag 3.14
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: Git标签 3.14
- en: '[PRE48]'
  id: totrans-394
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: '*Listing 3-36:* src/Makefile: *Adding appropriate user variables*'
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 3-36:* src/Makefile: *添加适当的用户变量*'
- en: 'This works because the `make` utility allows such variables to be overridden
    by options on the command line. For example, to switch compilers and set some
    compiler command line options, a user need only type the following:'
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 之所以有效，是因为`make`工具允许命令行选项覆盖这些变量。例如，要切换编译器并设置一些编译器命令行选项，用户只需要输入以下命令：
- en: '[PRE49]'
  id: totrans-397
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'In this case, our user has decided to use the `ccache` utility instead of `gcc`,
    generate debug symbols, and optimize their code using level-two optimizations.
    They’ve also decided to enable the `test` option through the use of a C-preprocessor
    definition. Note that these variables are set on the `make` command line; this
    apparently equivalent Bourne-shell syntax will not work as expected:'
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们的用户决定使用`ccache`工具代替`gcc`，生成调试符号，并通过二级优化来优化他们的代码。他们还决定通过使用C预处理器定义来启用`test`选项。请注意，这些变量是在`make`命令行中设置的；这种看似等效的Bourne
    shell语法将无法按预期工作：
- en: '[PRE50]'
  id: totrans-399
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: The reason is that we’re merely setting environment variables in the local environment
    passed to the `make` utility by the shell. Remember that environment variables
    do not automatically override those set in the makefile. To get the functionality
    we want, we could use a little GNU `make`–specific syntax in our makefile, as
    shown in [Listing 3-37](ch03.xhtml#ch03ex37).
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: 原因在于我们仅仅是在shell传递给`make`工具的本地环境中设置了环境变量。记住，环境变量不会自动覆盖在makefile中设置的变量。为了实现我们想要的功能，我们可以在makefile中使用一些GNU
    `make`特有的语法，如[列表 3-37](ch03.xhtml#ch03ex37)所示。
- en: '[PRE51]'
  id: totrans-401
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: '*Listing 3-37: Using the GNU `make`–specific query-assign operator (`?=`) in
    a makefile*'
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 3-37：在makefile中使用GNU `make`特有的查询赋值操作符（`?=`）*'
- en: The `?=` operator is a GNU `make`–specific operator, which will only set the
    variable in the makefile if it hasn’t already been set elsewhere. This means we
    can now override these particular variable settings by setting them in the environment.
    But don’t forget that this will only work in GNU `make`. In general, it’s better
    to set `make` variables on the `make` command line.
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: '`?=` 操作符是一个GNU `make`特有的操作符，只有在变量未在其他地方设置时，才会在makefile中设置该变量。这意味着我们现在可以通过在环境中设置这些特定的变量来覆盖它们。但请记住，这只在GNU
    `make`中有效。一般来说，最好在`make`命令行中设置`make`变量。'
- en: Nonrecursive Build Systems
  id: totrans-404
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 非递归构建系统
- en: Now that we’ve spent all this time creating the perfect build system for our
    project, let’s take a look at a *more perfect* solution—a nonrecursive system.
    I mentioned at the start of this chapter that there was a problem with recursive
    builds that we’d discuss at a later point.
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们花了这么多时间为我们的项目创建了完美的构建系统，接下来让我们看看一个*更完美*的解决方案——一个非递归系统。我在本章开始时提到过递归构建有一个问题，我们将在后面讨论。
- en: The fundamental problem with recursive build systems is that they artificially
    introduce flaws into `make`’s directed graph—the set of rules `make` uses to determine
    what depends on what and when something needs to be rebuilt. For Jupiter, very
    little can go wrong because there’s one top-level makefile invoking `make` on
    a single subdirectory makefile, but let’s consider a more complex project where
    multiple submodules, nested arbitrarily deeply, are interdependent upon each other
    in more complex ways.
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: 递归构建系统的根本问题在于它们人为地在`make`的有向图中引入了缺陷——`make`用来确定什么依赖什么以及何时需要重新构建的规则集。对于Jupiter来说，由于只有一个顶层makefile调用`make`并在单个子目录的makefile上执行，所以几乎不可能出错，但让我们考虑一个更复杂的项目，其中多个子模块以任意深度嵌套，彼此之间以更复杂的方式相互依赖。
- en: With a single makefile, the one `make` process can “see the big picture.” That
    is, it can see and understand all of the interdependencies in the system, and
    it can create a DAG that properly represents all of the inter­dependencies among
    all of the filesystem objects within the project. With multiple makefiles, each
    child `make` process executed by parent `make` can see only a portion of the dependency
    graph. Ultimately, this can cause `make` to build products out of order so that
    a product that depends on prerequisites not within its own purview is built before
    those prerequisites are updated.
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: 使用一个单一的 makefile，单个的 `make` 进程可以“看到全局”。也就是说，它能够看到并理解系统中所有的相互依赖关系，并且它可以创建一个正确表示项目中所有文件系统对象之间相互依赖关系的有向无环图（DAG）。使用多个
    makefile 时，父级 `make` 执行的每个子 `make` 进程只能看到依赖图的一部分。最终，这可能会导致 `make` 按顺序构建产品，导致一个依赖于不在自己视野中的前置条件的产品，在这些前置条件更新之前就被构建出来。
- en: 'The preceding problem is compounded when you use *parallel* *`make`* by adding
    `-j` to the `make` command line. The `-j` option tells `make` to examine its DAG
    and find places where portions of the DAG do not depend on each other, then execute
    those portions at the same time. On a multiprocessor system, this can dramatically
    speed up the build process for large projects. However, this causes problems from
    two different angles. First, since `make` can’t see the whole picture, it can
    make incorrect assumptions about what things can be done in parallel. Second,
    as far as the top-level `make` is concerned, child `make` processes are all independent
    and can be run in parallel, which we can easily see is simply not true. For an
    example that does not even rely on the differences between recursive and nonrecursive
    build systems, consider the following command line:'
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: 当你使用 *parallel* *`make`* 并在 `make` 命令行中添加 `-j` 选项时，前述问题会更加复杂。`-j` 选项告诉 `make`
    检查它的 DAG，找到那些不互相依赖的部分，然后同时执行这些部分。在多处理器系统上，这可以显著加速大项目的构建过程。然而，这从两个不同的角度带来了问题。首先，由于
    `make` 无法看到全局图景，它可能会对哪些任务可以并行执行做出错误的假设。其次，就顶级 `make` 来看，子 `make` 进程是完全独立的，可以并行运行，而这显然并非如此。一个不依赖于递归和非递归构建系统差异的例子是以下命令行：
- en: '[PRE52]'
  id: totrans-409
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: As far as `make` is concerned, `clean` and `all` are 100 percent independent
    of each other, so `make` will happily run them both at the same time. Even a novice
    can see the problems with this assumption. The point is, `make` doesn’t understand
    the high-level relationship between `clean` and `all`. That relationship is understood
    only by the author of the makefile. Similar barriers to `make`’s understanding
    of the big picture are artificially introduced at the boundaries between parent
    and child `make` invocations in a recursive build system.
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: 就 `make` 而言，`clean` 和 `all` 是 100% 独立的，因此 `make` 会很高兴地同时执行它们。即使是新手也能看出这个假设的问题。关键是，`make`
    不理解 `clean` 和 `all` 之间的高级关系。这种关系只有 makefile 的作者才理解。类似的障碍在递归构建系统中，父级和子级 `make`
    调用的边界之间人为地引入，导致 `make` 无法理解全局图景。
- en: So, how hard is it to turn Jupiter’s recursive build system into a nonrecursive
    system? We want to maintain modularity, so we still want a *Makefile* in each
    directory that essentially manages the tasks of that directory. This is easily
    accomplished by using another feature of common `make`—the `include` directive.
    The `include` directive allows us to break up our single, parent-level makefile
    into chunks of directory-specific rules and then include just those snippets in
    the top-level makefile. [Listing 3-38](ch03.xhtml#ch03ex38) shows what the complete
    updated top-level makefile looks like.
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，把 Jupiter 的递归构建系统转换为非递归系统有多难呢？我们希望保持模块化，因此我们仍然希望每个目录中有一个 *Makefile* 来管理该目录的任务。这可以通过使用常见的
    `make` 的另一个特性——`include` 指令来轻松实现。`include` 指令允许我们将单个的父级 makefile 拆分成特定目录规则的片段，然后将这些片段包含到顶级
    makefile 中。[Listing 3-38](ch03.xhtml#ch03ex38) 展示了更新后的完整顶级 makefile 的样子。
- en: Git tag 3.15
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: Git 标签 3.15
- en: '[PRE53]'
  id: totrans-413
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: '*Listing 3-38:* Makefile: *A nonrecursive version of the top-level makefile*'
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: '*Listing 3-38:* Makefile: *顶级 makefile 的非递归版本*'
- en: Three changes were made here, but please note that the only really significant
    change made to this makefile was the replacement of the rule at ➋ where recursion
    was done with a single rule for `all`, `clean`, `check`, `install`, `uninstall`,
    and an explicit `jupiter` target. Even this replacement could have been a simple
    deletion if we hadn’t cared that the new default target would have become `dist`,
    had we not added the `all` target at this location. I’ve also added an explicit
    `jupiter` target that maps to `src/jupiter` to maintain feature parity with the
    previous system.
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: 这里进行了三项更改，但请注意，实际上对这个 Makefile 做的唯一重大更改是在 ➋ 位置替换了递归规则，使用了一个单独的规则来处理 `all`、`clean`、`check`、`install`、`uninstall`
    和一个明确的 `jupiter` 目标。即便如此，如果我们不关心新的默认目标会变成 `dist`，如果我们没有在这个位置添加 `all` 目标，替换也可以仅仅是一个删除操作。我还添加了一个明确的
    `jupiter` 目标，它映射到 `src/jupiter`，以保持与旧系统的功能一致。
- en: The second change made was to include the *src*-level makefile at ➌. Finally,
    I also commented out the `export` statements at ➊ because we no longer need to
    export variables to child `make` processes; they’re left as comments simply for
    illustration.
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个更改是在 ➌ 位置包含了*src*级别的 Makefile。最后，我还注释掉了 ➊ 位置的 `export` 语句，因为我们不再需要将变量导出到子
    `make` 进程中；它们仅作为注释保留，用于示范。
- en: Now, let’s examine what changed in the *src*-level makefile. The complete, updated
    version is shown in [Listing 3-39](ch03.xhtml#ch03ex39).
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们来看一下*src*级别 Makefile 中的变化。完整的更新版本显示在 [Listing 3-39](ch03.xhtml#ch03ex39)
    中。
- en: '[PRE54]'
  id: totrans-418
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: '*Listing 3-39:* src/Makefile: *A nonrecursive version of the src-level makefile*'
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: '*Listing 3-39:* src/Makefile: *一个非递归版本的 src 级别 Makefile*'
- en: First, the `all` target was removed. We don’t need one here now because this
    makefile is not intended to be executed directly but, rather, included by the
    parent makefile. Hence, we do not need a default target. Second, all references
    to objects in the *src* directory are now referenced by paths that are relative
    to the parent directory. Again, this is because `make` is executed only once from
    the parent directory, so references to objects in the *src* directory must be
    considered relative to where `make` is running—the parent directory.
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，`all` 目标被移除。现在我们不再需要它，因为这个 Makefile 不是直接执行的，而是由父级 Makefile 引用。因此，我们不需要默认目标。第二，所有指向*src*目录中对象的引用现在都使用相对于父级目录的路径来表示。原因是
    `make` 只在父级目录中执行一次，因此，指向*src*目录中对象的引用必须相对于 `make` 执行的地方——即父级目录。
- en: We also removed the `.PHONY` directive at the bottom because this directive
    contained a proper subset of the `.PHONY` directive in the parent makefile, making
    the directive redundant. In short, we merely converted this makefile into a snippet
    that could be included in the parent makefile, removed redundancies, and ensured
    that all filesystem references are now made relative to the parent directory.
    I hope you can see that these changes actually constitute a simplification of
    what we had before. Intuitively, it seems more complicated but it is actually
    simpler.
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还移除了底部的 `.PHONY` 指令，因为这个指令包含了父级 Makefile 中 `.PHONY` 指令的一个适当子集，因此显得冗余。简而言之，我们只是将这个
    Makefile 转换为一个可以被包含在父级 Makefile 中的片段，移除了冗余，并确保所有文件系统引用现在都相对于父级目录。希望你能看到，这些更改实际上简化了我们之前的做法。直观上，它似乎更复杂，但实际上更简单。
- en: This makefile is a more accurate and faster version of our recursive system.
    I say “this makefile” because there is really only one makefile here—the included
    file can be pasted directly into the parent makefile at the point of inclusion
    (at ➋ in [Listing 3-38](ch03.xhtml#ch03ex38)), just as with inclusions of header
    files in C-language source files. Ultimately, after all the inclusions are resolved,
    there are only one makefile and one `make` process that executes commands based
    on the rules in that makefile.
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: 这个 Makefile 是我们递归系统的一个更准确且更快速的版本。我说“这个 Makefile”是因为这里实际上只有一个 Makefile——包含的文件可以直接粘贴到父级
    Makefile 中的引用位置（在 [Listing 3-38](ch03.xhtml#ch03ex38) 中的 ➋ 位置），就像在 C 语言源文件中包含头文件一样。最终，在所有包含解析完毕后，只有一个
    Makefile 和一个 `make` 进程执行基于该 Makefile 中规则的命令。
- en: One apparent drawback of nonrecursive build systems is that you cannot simply
    enter `make` while sitting in the *src* directory and build the portion of the
    project related to that directory. Instead, you have to change into the parent
    directory and run `make`, which builds everything. But this, too, is a fallacious
    concern because you’ve always had the ability to execute any portion of the build
    system you wished by specifying exactly the target you desired on the `make` command
    line. The difference is that now what gets built is actually what should get built
    because `make` understands the entire set of dependencies for any given target
    you command it to build.
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: 非递归构建系统的一个显而易见的缺点是，你不能仅仅在*src*目录下输入`make`来构建与该目录相关的项目部分。相反，你必须切换到父目录并运行`make`，这样会构建整个项目。但这也是一个错误的顾虑，因为你一直都有能力通过在`make`命令行上准确指定目标来执行构建系统的任何部分。不同之处在于，现在构建的实际上是应该构建的内容，因为`make`理解你命令它构建的任何目标的所有依赖关系。
- en: As we’ll see in the coming chapters, Automake has full support for nonrecursive
    build systems. I encourage you to start writing your next project build system
    in a nonrecursive fashion because it can seem like an overwhelming task to retrofit
    an existing system, even though, as we’ve seen here, it’s not really all that
    difficult.
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们将在接下来的章节中看到的，Automake完全支持非递归构建系统。我鼓励你开始以非递归方式编写下一个项目的构建系统，因为尽管如我们所见，实际上并不那么困难，但改造现有系统往往看起来是一个让人不知所措的任务。
- en: Configuring Your Package
  id: totrans-425
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 配置你的软件包
- en: 'The *GCS* describes the configuration process in the “How Configuration Should
    Work” subsection of Section 7\. Up to this point, we’ve been able to do about
    everything we’ve wanted to with Jupiter using only makefiles, so you might be
    wondering what configuration is actually for. The opening paragraphs of this subsection
    in the *GCS* answer our question:'
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: '*GCS*在第7节“配置应如何工作”小节中描述了配置过程。到目前为止，我们仅使用makefile就能够完成几乎所有的事情，因此你可能会好奇配置到底是做什么的。*GCS*中这一小节的开头段落回答了我们的疑问：'
- en: Each GNU distribution should come with a shell script named `configure`. This
    script is given arguments which describe the kind of machine and system you want
    to compile the program for. The `configure` script must record the configuration
    options so that they affect compilation.
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: 每个GNU分发包应附带一个名为`configure`的shell脚本。这个脚本会接受描述你想为其编译程序的机器和系统类型的参数。`configure`脚本必须记录配置选项，以便它们影响编译过程。
- en: The description here is the specification of the interface for the `configure`
    script in GNU packages. Many packages implement it using GNU Autoconf (see “Introduction”
    in Autoconf) and/or GNU Automake (see “Introduction” in Automake), but you do
    not have to use these tools. You can implement it any way you like; for instance,
    by making `configure` be a wrapper around a completely different configuration
    system.
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的描述是GNU软件包中`configure`脚本接口的规范。许多软件包使用GNU Autoconf（参见《Autoconf简介》）和/或GNU Automake（参见《Automake简介》）来实现它，但你不必使用这些工具。你可以以任何你喜欢的方式实现它；例如，可以让`configure`成为一个完全不同的配置系统的封装器。
- en: Another way for the `configure` script to operate is to make a link from a standard
    name such as *config.h* to the proper configuration file for the chosen system.
    If you use this technique, the distribution should *not* contain a file named
    *config.h*. This is so that people won’t be able to build the program without
    configuring it first.
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: '`configure`脚本操作的另一种方式是将标准名称（如*config.h*）链接到所选系统的正确配置文件。如果你使用这种技术，分发包应*不*包含名为*config.h*的文件。这样做是为了防止人们在没有先进行配置的情况下构建程序。'
- en: Another thing that `configure` can do is to edit the *Makefile*. If you do this,
    the distribution should *not* contain a file named *Makefile*. Instead, it should
    include a file *Makefile.in* which contains the input used for editing. Once again,
    this is so that people won’t be able to build the program without configuring
    it first.^([27](footnote.xhtml#ch03fn27))
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: '`configure`还能做的另一件事是编辑*Makefile*。如果这样做，分发包中应*不*包含名为*Makefile*的文件。相反，它应包含一个名为*Makefile.in*的文件，该文件包含用于编辑的输入。再一次，这是为了让人们在没有先配置的情况下无法构建程序。^([27](footnote.xhtml#ch03fn27))'
- en: 'So then, the primary tasks of a typical configuration script are as follows:'
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，典型配置脚本的主要任务如下：
- en: Generate files from templates containing replacement variables.
  id: totrans-432
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从包含替换变量的模板生成文件。
- en: Generate a C-language header file (*config.h*) for inclusion by project source
    code.
  id: totrans-433
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为项目源代码生成一个C语言头文件（*config.h*）以供包含。
- en: Set user options for a particular `make` environment (debug flags and so on).
  id: totrans-434
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为特定的`make`环境设置用户选项（调试标志等）。
- en: Set various package options as environment variables.
  id: totrans-435
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将各种包选项设置为环境变量。
- en: Test for the existence of tools, libraries, and header files.
  id: totrans-436
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试工具、库和头文件是否存在。
- en: For complex projects, configuration scripts often generate the project makefiles
    from one or more templates maintained by project developers. These templates contain
    configuration variables in a format that is easy to recognize (and substitute).
    The configuration script replaces these variables with values determined during
    the configuration process—either from command line options specified by the user
    or from a thorough analysis of the platform environment. This analysis entails
    such things as checking for the existence of certain system or package header
    files and libraries, searching various filesystem paths for required utilities
    and tools, and even running small programs designed to indicate the feature set
    of the shell, C compiler, or desired libraries.
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
  zh: 对于复杂的项目，配置脚本通常会从项目开发者维护的一个或多个模板生成项目的makefile。这些模板包含易于识别（并替换）的配置变量。配置脚本将这些变量替换为在配置过程中确定的值——这些值可能来自用户指定的命令行选项，也可能来自对平台环境的详细分析。此分析包括检查某些系统或包的头文件和库是否存在，搜索各个文件系统路径以寻找所需的工具和工具，甚至运行小程序来指示shell、C编译器或所需库的功能集。
- en: The tool of choice for variable replacement has, in the past, been the `sed`
    stream editor. A simple `sed` command can replace all the configuration variables
    in a makefile template in a single pass through the file. However, Autoconf versions
    2.62 and newer prefer `awk` to `sed` for this process. The `awk` utility is almost
    as pervasive as `sed` these days, and it provides more functionality to allow
    for efficient replacement of many variables. For our purposes on the Jupiter project,
    either of these tools would suffice.
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
  zh: 过去，变量替换的工具首选是`sed`流编辑器。一个简单的`sed`命令就可以在一次文件遍历中替换makefile模板中的所有配置变量。然而，Autoconf
    2.62及以后的版本更倾向于使用`awk`而不是`sed`来进行此操作。如今，`awk`工具几乎与`sed`一样普遍，它提供了更多的功能，允许高效地替换多个变量。对于我们Jupiter项目的需求，这两种工具都足够使用。
- en: Summary
  id: totrans-439
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 摘要
- en: 'We have now created a complete project build system by hand, with one important
    exception: we haven’t designed a `configure` script according to the design criteria
    specified in the *GNU Coding Standards*. We could do this, but it would take a
    dozen more pages of text to build one that even comes close to conforming to these
    specifications. Still, there are a few key build features related specifically
    to the makefiles that the *GCS* indicates are desirable. Among these is the concept
    of vpath building. This is an important feature that can be properly illustrated
    only by actually writing a configuration script that works as specified by the
    *GCS*.'
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经手动创建了一个完整的项目构建系统，唯一的重要例外是：我们还没有根据*GNU编码标准*（*GNU Coding Standards*）设计一个`configure`脚本。我们可以做这件事，但即便是勉强符合这些规范的脚本，也需要再写十几页的文本。然而，*GCS*中有一些与makefile特别相关的关键构建特性是非常理想的。其中之一就是vpath构建的概念。这是一个重要的特性，只有通过实际编写符合*GCS*规范的配置脚本才能恰当地展示。
- en: Rather than spend the time and effort to do this now, I’d like to simply move
    on to a discussion of Autoconf in [Chapter 4](ch04.xhtml), which will allow us
    to build one of these configuration scripts in as little as two or three lines
    of code. With that behind us, it will be trivial to add vpath building and other
    common Autotools features to the Jupiter project.
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
  zh: 我宁愿不花时间和精力现在完成这个，而是希望直接转到讨论[第4章](ch04.xhtml)中的Autoconf内容，这将使我们能够用两三行代码构建其中一个配置脚本。在这方面有了基础之后，将vpath构建和其他常见的Autotools功能添加到Jupiter项目中将变得非常简单。
