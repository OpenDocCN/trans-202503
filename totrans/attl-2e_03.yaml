- en: '3'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '3'
- en: UNDERSTANDING THE GNU CODING STANDARDS
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 理解GNU编码标准
- en: '*I don’t know what’s the matter with people: they don’t learn by understanding,
    they learn by some other way—by rote or something. Their knowledge is so fragile!'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: '*我不知道人们怎么了：他们不是通过理解来学习，而是通过其他方式——死记硬背什么的。他们的知识是如此脆弱！*'
- en: —Richard Feynman*, “Surely You’re Joking, Mr. Feynman!”
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: —理查德·费曼*，《你一定是在开玩笑，费曼先生！》
- en: '![Image](../images/common.jpg)'
  id: totrans-4
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/common.jpg)'
- en: In [Chapter 2](ch02.xhtml), I gave an overview of the GNU Autotools and some
    resources that can help reduce the learning curve required to master them. In
    this chapter, we’re going to step back a little and examine project organization
    techniques that you can apply to any project, not just one that uses the Autotools.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第2章](ch02.xhtml)中，我概述了GNU Autotools以及一些能够帮助减少学习曲线的资源。在这一章中，我们将稍微后退一步，探讨一些项目组织技巧，这些技巧不仅适用于使用Autotools的项目，也适用于任何项目。
- en: When you’re done reading this chapter, you should be familiar with the common
    `make` targets and why they exist. You should also have a solid understanding
    of why projects are organized the way they are. You will, in fact, be well on
    your way to becoming an Autotools expert.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 当你读完本章后，你应该熟悉常见的`make`目标及其存在的原因。你还应该对为什么项目会按这种方式组织有一个扎实的理解。事实上，你已经走在了成为Autotools专家的路上。
- en: 'The information provided in this chapter comes primarily from two sources:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 本章提供的信息主要来自两个来源：
- en: The *GNU Coding Standards (GCS)*^([1](footnote.xhtml#ch03fn1))
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*GNU 编码标准（GCS）*^([1](footnote.xhtml#ch03fn1))'
- en: The *Filesystem Hierarchy Standard (FHS)*^([2](footnote.xhtml#ch03fn2))
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*文件系统层次标准（FHS）*^([2](footnote.xhtml#ch03fn2))'
- en: If you’d like to brush up on your `make` syntax, you may also find the *GNU
    Make Manual* ^([3](footnote.xhtml#ch03fn3)) very useful. If you’re particularly
    interested in portable `make` syntax, then check out the POSIX man page for `make`.^([4](footnote.xhtml#ch03fn4))
    Note, however, there are current discussions on the Autotools mailing lists around
    making GNU `make` the target standard because it’s so widely available today.
    Therefore, portable `make` script isn’t as important as it used to be.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想复习一下`make`的语法，你可能会发现*GNU Make 手册* ^([3](footnote.xhtml#ch03fn3)) 非常有用。如果你特别感兴趣于便携式`make`语法，那么查看一下`make`的POSIX手册页^([4](footnote.xhtml#ch03fn4))吧。需要注意的是，目前在Autotools邮件列表中有关于将GNU
    `make`作为目标标准的讨论，因为如今它已广泛可用。因此，便携式`make`脚本的重要性不再像过去那样突出。
- en: Creating a New Project Directory Structure
  id: totrans-11
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建一个新的项目目录结构
- en: 'You need to ask yourself two questions when you’re setting up the build system
    for an open source software project:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 当你为一个开源软件项目设置构建系统时，你需要问自己两个问题：
- en: Which platforms will I target?
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我将针对哪些平台？
- en: What do my users expect?
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我的用户期望什么？
- en: The first is an easy question—you get to decide which platforms to target, but
    you shouldn’t be too restrictive. Open source software projects are only as good
    as their communities, and arbitrarily limiting the number of platforms reduces
    the potential size of your community. However, you might consider supporting only
    current versions of your target platforms. You can check with user groups and
    communities to determine which versions of each are relevant.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个问题是简单的——你可以决定目标平台，但不应过于限制。开源软件项目的好坏取决于其社区，而随意限制平台数量会减少你的社区的潜在规模。然而，你可以考虑只支持目标平台的当前版本。你可以通过与用户组和社区进行交流，确定哪些版本是相关的。
- en: The second question is more difficult to answer. First, let’s narrow the scope
    to something manageable. What you really need to ask is, *What do my users expect
    of my build system?* Experienced open source software developers become familiar
    with these expectations by downloading, unpacking, building, and installing hundreds
    of packages. Eventually, they come to know intuitively what users expect of a
    build system. But, even so, the processes of package configuration, build, and
    installation vary widely, so it’s difficult to define any solid norm.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个问题更难回答。首先，让我们将范围缩小到一个可管理的范畴。你真正需要问的是，*我的用户对我的构建系统有什么期望？* 有经验的开源软件开发人员通过下载、解压、构建和安装数百个软件包，逐渐了解这些期望。最终，他们会直觉地知道用户对构建系统的期望是什么。但即便如此，软件包的配置、构建和安装过程差异巨大，因此很难定义一个固有的标准。
- en: Rather than taking a survey of every build system out there yourself, you can
    consult the Free Software Foundation (FSF), sponsor of the GNU project, which
    has done a lot of the legwork for you. The FSF provides some of the best definitive
    sources of information on free, open source software, including the *GCS*, which
    covers a wide variety of topics related to writing, publishing, and distributing
    free, open source software. Even many non-GNU open source software projects align
    themselves with the *GCS*. Why? Well, the FSF invented the concept of free software,
    and the ideas make sense, for the most part.^([5](footnote.xhtml#ch03fn5)) There
    are dozens of issues to consider when designing a system that manages packaging,
    building, and installing software, and the *GCS* takes most of them into account.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 与其自己调查所有存在的构建系统，你可以查阅自由软件基金会（FSF），这是 GNU 项目的赞助商，它已经为你做了大量的工作。FSF 提供了一些关于自由开源软件的最佳权威信息来源，包括*GCS*，它涵盖了与编写、发布和分发自由开源软件相关的各种话题。即使是许多非
    GNU 的开源软件项目也与*GCS*保持一致。为什么？因为 FSF 发明了自由软件的概念，而且这些理念大多数情况下是有道理的。^([5](footnote.xhtml#ch03fn5))
    在设计一个管理软件打包、构建和安装的系统时，有几十个问题需要考虑，而*GCS* 已经考虑到了其中的大部分。
- en: WHAT’S IN A NAME?
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 名字代表什么？
- en: You probably know that open source software projects generally have quirky names—they
    might be named after some device, an invention, a Latin term, a past hero, an
    ancient god, or they might be named after some small, furry animal that has (vaguely)
    similar characteristics to the software. Some names are just made-up words or
    acronyms that are catchy and easy to pronounce. Another significant characteristic
    of a good project name is uniqueness—it’s important that your project be easy
    to distinguish from others. You also want your project name to be easy to distinguish
    from any other uses of the name in a search engine. Additionally, you should ensure
    that your project’s name does not have negative connotations in any language or
    culture.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能知道，开源软件项目通常有一些奇特的名字——它们可能以某种设备、发明、拉丁术语、过去的英雄、古代神祇命名，或者它们可能以某些小型毛茸茸的动物命名，这些动物与软件有（模糊的）相似特征。也有些名字是捏造的词或缩写，既吸引人又易于发音。一个好项目名字的另一个重要特征是独特性——你的项目必须容易与其他项目区分开来。你还希望项目名字在搜索引擎中能够与其他使用该名字的结果区分开。此外，你还应该确保项目的名字在任何语言或文化中没有负面含义。
- en: Project Structure
  id: totrans-20
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 项目结构
- en: 'We’ll start with a basic sample project and build on it as we continue our
    exploration of source-level software distribution. We’ll call our project *Jupiter*
    and create a project directory structure using the following commands:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从一个基本的示例项目开始，并在继续探索源代码级软件分发的过程中逐步构建它。我们将项目命名为*Jupiter*，并使用以下命令创建项目目录结构：
- en: '[PRE0]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: We now have one source code directory called *src*, one C source file called
    *main.c*, and a makefile for each of the two directories in our project. Minimal,
    yes, but this is a new endeavor and the key to a successful open source software
    project is evolution. Start small and grow as needed—and as you have the time
    and inclination.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了一个名为*src*的源代码目录，一个名为*main.c*的 C 源文件，以及两个目录中的每个文件都包含一个 makefile。简洁，是的，但这是一个新的尝试，成功的开源软件项目的关键在于演化。从小做起，根据需要扩展——以及根据你的时间和兴趣。
- en: Let’s start by adding support for building and cleaning our project. We’ll need
    to add other important capabilities to our build system later on, but these two
    will get us going. The top-level makefile does very little at this point; it merely
    passes requests down to *src/Makefile*, recursively. This constitutes a fairly
    common type of build system, known as a *recursive build system*, so named because
    makefiles recursively invoke `make` on subdirectory makefiles.^([6](footnote.xhtml#ch03fn6))
    We’ll spend a little time at the end of this chapter considering how to convert
    our recursive system into a nonrecursive system.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从添加支持构建和清理项目开始。稍后我们需要为构建系统添加其他重要功能，但这两个功能足以让我们开始。目前，顶级的 makefile 仅做了很少的工作；它只是将请求递归地传递给*src/Makefile*。这构成了一个相当常见的构建系统类型，称为*递归构建系统*，之所以这样命名，是因为
    makefile 会递归地调用 `make` 来处理子目录的 makefile。^([6](footnote.xhtml#ch03fn6)) 我们将在本章的最后花些时间思考如何将递归系统转换为非递归系统。
- en: '[Listings 3-1](ch03.xhtml#ch03ex01) through [3-3](ch03.xhtml#ch03ex03) show
    the contents of each of these three files, thus far.'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 3-1](ch03.xhtml#ch03ex01) 到 [3-3](ch03.xhtml#ch03ex03) 显示了目前为止这三份文件的内容。'
- en: Git tag 3.0
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: Git 标签 3.0
- en: '[PRE1]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '*Listing 3-1: Makefile: An initial draft of a top-level makefile for Jupiter*'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 3-1：Makefile：Jupiter 顶层 makefile 的初步草稿*'
- en: '[PRE2]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '*Listing 3-2:* src/Makefile: *The first draft of Jupiter’s src directory makefile*'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 3-2：* src/Makefile：*Jupiter 的 src 目录 makefile 的初步草稿*'
- en: '[PRE3]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '*Listing 3-3:* src/main.c: *The first version of the only C source file in
    the Jupiter project*'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 3-3：* src/main.c：*Jupiter 项目中唯一的 C 源文件的第一个版本*'
- en: '**NOTE**'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*As you read this code, you will probably notice places where a makefile or
    a source code file contains a construct that is not written in the simplest manner
    or is perhaps not written the way you would have chosen to write it. There is
    a method to my madness: I’ve tried to use constructs that are portable to many
    flavors of the *`make`* utility.*'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '*当你阅读这段代码时，你可能会注意到一些地方，其中的 makefile 或源代码文件包含了不是以最简单的方式编写的结构，或者可能不是你选择的编写方式。我的疯狂背后是有方法的：我试图使用许多
    *`make`* 工具可以兼容的结构。*'
- en: Now let’s discuss the basics of `make`. If you’re already pretty well versed
    in it, you can skip the next section. Otherwise, give it a quick read, and we’ll
    return our attention to the Jupiter project later in the chapter.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们讨论一下 `make` 的基础。如果你已经相当熟悉它了，可以跳过下一节。否则，快速阅读一下，我们稍后会在本章的后续部分回到 Jupiter 项目。
- en: Makefile Basics
  id: totrans-36
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Makefile 基础
- en: 'If you don’t use `make` on a regular basis, it’s often difficult to remember
    exactly what goes where in a makefile, so here are a few things to keep in mind.
    Besides comments, which begin with a hash mark (`#`), there are only two basic
    types of entities in a makefile:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不经常使用 `make`，通常很难记住在 makefile 中具体该放什么内容，因此这里有一些需要记住的要点。除了以井号（`#`）开头的注释外，makefile
    中只有两种基本类型的实体：
- en: Rule definitions
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 规则定义
- en: Variable assignments
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 变量赋值
- en: While there are several other types of constructs in a makefile (including conditional
    statements, directives, extension rules, pattern rules, function variables, and
    include statements, among others), for our purposes, we’ll just touch lightly
    on them as needed instead of covering them all in detail. This doesn’t mean they’re
    unimportant. On the contrary, they’re very useful if you’re going to write your
    own complex build system by hand. However, our purpose is to gain the background
    necessary for understanding the GNU Autotools, so I’ll only cover the aspects
    of `make` you need to know to accomplish that goal.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管在 makefile 中还有其他几种类型的结构（包括条件语句、指令、扩展规则、模式规则、函数变量和包含语句等），但为了我们的目的，我们只会在需要时简单提及它们，而不是详细讨论所有内容。这并不意味着它们不重要。相反，如果你要手动编写自己的复杂构建系统，它们非常有用。不过，我们的目标是为理解
    GNU Autotools 打下必要的基础，因此我只会讲解你需要了解的 `make` 相关部分。
- en: If you want a broader education on `make` syntax, refer to the *GNU Make Manual*.
    For strictly portable syntax, the POSIX man page for `make` is an excellent reference.
    If you want to become a `make` expert, be prepared to spend a good deal of time
    studying these resources—there’s much more to the `make` utility than is initially
    apparent.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想更深入了解 `make` 语法，可以参考 *GNU Make 手册*。对于严格的可移植语法，POSIX 中的 `make` 手册页是一个很好的参考。如果你想成为
    `make` 专家，要准备花费相当多的时间学习这些资源——`make` 工具的功能远比最初看到的要复杂得多。
- en: '*Rules*'
  id: totrans-42
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*规则*'
- en: Rules follow the general format shown in [Listing 3-4](ch03.xhtml#ch03ex04).
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 规则遵循 [清单 3-4](ch03.xhtml#ch03ex04) 中展示的通用格式。
- en: '[PRE4]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '*Listing 3-4: The syntax of a rule within a makefile*'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 3-4：Makefile 中规则的语法*'
- en: In this syntax definition, square brackets (`[` and `]`) denote optional portions
    of a rule and `<tab>` represents a tab (ctrl-i) character.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在此语法定义中，方括号（`[` 和 `]`）表示规则的可选部分，`<tab>` 表示一个制表符（ctrl-i）字符。
- en: Except for the tab characters and the line feeds, all other whitespace is optional
    and ignored. When a line in a makefile begins with a tab character, `make` generally
    considers it a command (with the exception of continuation lines, discussed later).
    Indeed, one of the most frustrating aspects of makefile syntax to neophytes and
    experts alike is that commands must be prefixed with an essentially invisible
    character. The error messages generated by the legacy UNIX `make` utility when
    a required tab is missing (or has been converted to spaces by your editor), or
    when an unintentional tab is inserted at the start of a line that follows something
    that could be interpreted as a rule, are obscure at best. GNU `make` does a better
    job with such error messages. Nonetheless, be careful to use leading tab characters
    properly in your makefiles—always and only before commands.^([7](footnote.xhtml#ch03fn7))
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 除了制表符字符和换行符外，所有其他空白字符都是可选的并且会被忽略。当makefile中的一行以制表符字符开始时，`make`通常会将其视为命令（续行除外，后面会讨论）。事实上，对于初学者和专家来说，makefile语法中最令人沮丧的一点就是命令必须以一个本质上不可见的字符为前缀。当遗留的UNIX
    `make`工具缺少所需的制表符（或被编辑器转换为空格），或当意外的制表符被插入到可能被解释为规则的行的开头时，生成的错误消息往往模糊不清。GNU `make`在这些错误消息上做得更好。尽管如此，在makefile中使用制表符字符时仍然要小心——它们必须始终且仅仅出现在命令之前。^([7](footnote.xhtml#ch03fn7))
- en: Note that almost everything in a rule is optional; the only required aspect
    of a rule is the *`targets`* portion and its colon (`:`) character. Use of the
    first command, *`command-0`* and its preceding semicolon (`;`), is an optional
    form that’s generally discouraged by the Autotools, but is perfectly legitimate
    `make` syntax if you have a single command to execute. You may even combine *`command-0`*
    with additional commands, but this almost never done.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，规则中的几乎所有内容都是可选的；规则中唯一必须的部分是*`targets`*部分及其冒号（`:`）字符。使用第一个命令，*`command-0`*及其前面的分号（`;`）是一种可选形式，通常Autotools不推荐使用，但如果你只有一个命令要执行，`make`语法是完全合法的。你甚至可以将*`command-0`*与其他命令结合使用，但这几乎从不发生。
- en: In general, *targets* are objects that need to be built, and *dependencies*
    are objects that provide source material for targets. Thus, targets are said to
    depend upon the dependencies. Dependencies are essentially *prerequisites* of
    the targets, and therefore they should be updated first.^([8](footnote.xhtml#ch03fn8))
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 一般来说，*目标*是需要构建的对象，而*依赖*是为目标提供源材料的对象。因此，目标被认为依赖于依赖。依赖本质上是目标的*前提条件*，因此应该首先更新它们。^([8](footnote.xhtml#ch03fn8))
- en: '[Listing 3-5](ch03.xhtml#ch03ex05) shows the general layout of a makefile.'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 3-5](ch03.xhtml#ch03ex05)展示了makefile的一般布局。'
- en: '[PRE5]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '*Listing 3-5: The general layout of a makefile*'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 3-5：makefile的一般布局*'
- en: The contents of a makefile comprise a *declarative language* wherein you define
    a set of desired goals and `make` decides the best way to accomplish those goals.
    The `make` utility is a rule-based command engine, and the rules at work indicate
    which commands should be executed and when. When you define commands within rules,
    you’re telling `make` that you want it to execute each of the following statements
    from a shell whenever the preceding target should be built. Presumably, the commands
    actually do create or update the target. The existence and timestamps of the files
    mentioned in the targets and dependencies of rules indicate whether the commands
    should be executed and in what order.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: makefile的内容包含一种*声明性语言*，在其中你定义了一组期望的目标，`make`决定实现这些目标的最佳方式。`make`工具是一个基于规则的命令引擎，工作中的规则指示哪些命令应当执行，以及何时执行。当你在规则中定义命令时，你实际上是在告诉`make`，当前面的目标需要构建时，你希望它从shell中执行以下每个语句。假定这些命令实际上会创建或更新目标。规则中提到的目标和依赖项的文件存在性和时间戳指示是否应该执行命令以及执行的顺序。
- en: As `make` processes the text in a makefile, it builds a web of dependency chains
    (technically called a *directed acyclic graph*, or *DAG*). When building a particular
    target, `make` must walk backward through the entire graph to the beginning of
    each “chain.” While traversing a chain, `make` executes the commands for each
    rule, beginning with the rule farthest from the target and working forward to
    the rule for the desired target. As `make` discovers targets that are older than
    their dependencies, it must execute the associated set of commands to update those
    targets before it can process the next rule in the chain. As long as the rules
    are written correctly, this algorithm ensures that `make` will build a completely
    up-to-date product using the least number of operations possible. Indeed, as we’ll
    see shortly, when the rules in a makefile are written properly, it’s rather a
    joy to watch it run after various changes to files in the project.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 当 `make` 处理 makefile 中的文本时，它会构建一个依赖关系链的网络（技术上称为*有向无环图*，或 *DAG*）。在构建特定目标时，`make`
    必须从整个图中倒推回到每个“链”的起始点。在遍历链时，`make` 会执行每个规则的命令，从距离目标最远的规则开始，一直到所需目标的规则。当 `make`
    发现某些目标比它们的依赖项更新较旧时，它必须执行相关的命令集来更新这些目标，然后才能处理链中的下一个规则。只要规则编写正确，这个算法确保了 `make` 会用尽可能少的操作构建一个完全最新的产品。实际上，正如我们稍后会看到的，当
    makefile 中的规则编写得当时，看它在项目中的文件发生变化后运行，实际上是一种乐趣。
- en: '*Variables*'
  id: totrans-55
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*变量*'
- en: Lines in a makefile containing an equal sign (`=`) are variable definitions.
    Variables in makefiles are somewhat similar to shell or environment variables,
    but there are some key differences.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 包含等号（`=`）的 makefile 行是变量定义。在 makefile 中的变量与 Shell 或环境变量有些相似，但也有一些关键的区别。
- en: 'In Bourne-shell syntax, you’d reference a variable in this manner: `${my_var}`.
    Equally viable, without the curly brackets, is `$my_var`. The syntax for referencing
    variables in a makefile is nearly identical, except that you have the choice of
    using curly brackets or parentheses: `$(my_var)`. To minimize confusion, it has
    become somewhat of a convention to use parentheses rather than curly brackets
    when dereferencing `make` variables. For single-character `make` variables, using
    these delimiters is optional, but you should use them in order to avoid ambiguity.
    For example, `$X` is functionally equivalent to `$(X)` or `${X}`, but `$(my_var)`
    would require parentheses so `make` does not interpret the reference as `$(m)y_var`.'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Bourne Shell 语法中，你可以这样引用一个变量：`${my_var}`。同样可以使用不带花括号的形式：`$my_var`。在 makefile
    中引用变量的语法几乎相同，不过你可以选择使用花括号或圆括号：`$(my_var)`。为了减少混淆，已成为一种约定，在取消引用 `make` 变量时使用圆括号而非花括号。对于单字符
    `make` 变量，使用这些分隔符是可选的，但为了避免歧义，应该使用它们。例如，`$X` 在功能上等同于 `$(X)` 或 `${X}`，但是 `$(my_var)`
    需要使用圆括号，以便 `make` 不会将引用解释为 `$(m)y_var`。
- en: '**NOTE**'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*To dereference a shell variable inside a *`make`* command, escape the dollar
    sign by doubling it—for example, *`$${shell_var}`*. Escaping the dollar sign tells
    *`make`* not to interpret the variable reference but rather to treat it as literal
    text in the command. The variable reference is thus left to be interpolated by
    the shell when the command is executed.*'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '*在*`make`*命令中取消引用一个 Shell 变量时，通过将美元符号加倍来转义它—例如，*`$${shell_var}`*。转义美元符号告诉*`make`*不要解释变量引用，而是将其视为命令中的字面文本。因此，变量引用将在命令执行时由
    Shell 进行插值。*'
- en: By default, *`make`* reads the process environment into its variable table before
    processing the makefile; this allows you to access most environment variables
    without explicitly defining them in the makefile. Note, however, that variables
    set inside the makefile will override those obtained from the environment.^([9](footnote.xhtml#ch03fn9))
    It’s generally not a good idea to depend on the existence of environment variables
    in your build process, although it’s okay to use them conditionally. In addition,
    `make` defines several useful variables of its own, such as the `MAKE` variable,
    the value of which is the command used to invoke `make` for the current process.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，*`make`* 在处理 makefile 之前会读取进程环境到其变量表中；这使你可以访问大多数环境变量，而无需在 makefile 中显式定义它们。然而，注意，在
    makefile 中设置的变量将覆盖从环境中获得的变量。^([9](footnote.xhtml#ch03fn9)) 通常，不建议在构建过程中依赖环境变量的存在，尽管可以在条件情况下使用它们。此外，`make`
    定义了几个有用的变量，例如 `MAKE` 变量，其值为当前进程中调用 `make` 的命令。
- en: You can assign variables at any point in the makefile. However, you should be
    aware that `make` processes a makefile in two passes. In the first pass, it gathers
    variables and rules into tables and internal structures. In the second pass, it
    resolves dependencies defined by the rules, invoking those rules as necessary
    to rebuild the dependencies based on the filesystem timestamps gathered during
    the first pass. If a dependency in a rule is newer than the target or if the target
    is missing, then `make` executes the commands of the rule to update the target.
    Some variable references are resolved immediately during the first pass while
    processing rules, and others are resolved later during the second pass while executing
    commands.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在 makefile 中的任何位置分配变量。然而，你需要注意的是，`make` 会对 makefile 进行两次处理。在第一次处理中，它会将变量和规则收集到表格和内部结构中。在第二次处理中，它会解析规则定义的依赖关系，根据第一次处理时收集到的文件系统时间戳调用规则，以重建依赖关系。如果规则中的依赖项比目标更新，或者目标缺失，那么
    `make` 会执行该规则的命令来更新目标。某些变量引用在第一次处理规则时会立即解析，而其他的则在执行命令时，在第二次处理中解析。
- en: '*A Separate Shell for Each Command*'
  id: totrans-62
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*每个命令使用单独的 Shell*'
- en: As it processes rules, `make` executes each command independently of those around
    it. That is, each individual command under a rule is executed in its own shell.
    This means that you cannot export a shell variable in one command and then try
    to access its value in the next.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理规则时，`make` 会独立执行每个命令。也就是说，规则下的每个命令都会在各自的 shell 中执行。这意味着你不能在一个命令中导出一个 shell
    变量，然后在下一个命令中尝试访问它的值。
- en: To do something like this, you would have to string commands together on the
    same command line with command separator characters (for example, semicolons in
    Bourne-shell syntax). When you write commands like this, `make` passes the set
    of concatenated commands as one command line to the same shell. To avoid long
    command lines and increase readability, you can wrap them using a backslash at
    the end of each line—by convention, after the semicolon.^([10](footnote.xhtml#ch03fn10))
    The wrapped portion of such commands may also be preceded by a tab character.
    POSIX specifies that `make` remove all leading tab characters (even those following
    escaped newlines) before processing commands, but be aware that some implementations
    of `make` do output—usually harmlessly—the tab characters embedded within wrapped
    commands.^([11](footnote.xhtml#ch03fn11))
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想做类似的事情，你需要将命令串联在同一命令行上，使用命令分隔符（例如，Bourne shell 语法中的分号）。当你像这样写命令时，`make`
    会将串联的命令作为一条命令行传递给同一个 shell。为了避免过长的命令行并增加可读性，你可以在每一行的末尾使用反斜杠将它们包裹起来——按照惯例，在分号后面。^([10](footnote.xhtml#ch03fn10))
    这类命令的包装部分也可以用制表符字符来开头。POSIX 指定 `make` 在处理命令之前会移除所有前导的制表符字符（即便是那些跟在转义的换行符后的制表符），但需要注意的是，某些
    `make` 实现可能会输出这些嵌入在包裹命令中的制表符字符——通常是无害的。^([11](footnote.xhtml#ch03fn11))
- en: '[Listing 3-6](ch03.xhtml#ch03ex06) shows a few simple examples of multiple
    commands that will be executed by the same shell.'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 3-6](ch03.xhtml#ch03ex06) 显示了一些简单的多命令示例，这些命令将由同一个 shell 执行。'
- en: '[PRE6]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '*Listing 3-6: A makefile with some examples of multiple commands executed by
    the same shell*'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 3-6：一个包含多个命令示例的 makefile，这些命令将由同一个 shell 执行*'
- en: In the first example at ➊, both lines are executed by the same shell because
    the backslash escapes the newline character between the lines. The `make` utility
    will remove any escaped newline characters before passing a single, multi-command
    statement to the shell. The second example at ➋ is identical to the first, from
    `make`’s perspective.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一个例子 ➊ 中，两行命令由同一个 shell 执行，因为反斜杠将两行之间的换行符转义。`make` 工具会在将一条多命令语句传递给 shell 之前，删除所有转义的换行符。第二个例子
    ➋ 与第一个例子在 `make` 的角度上是相同的。
- en: The third example at ➌ is a bit different. In this case, I’ve defined the `TMPDIR`
    variable only for the child process that will run `gcc`.^([12](footnote.xhtml#ch03fn12))
    Note the missing semicolon; as far as the shell is concerned, this is a single
    command.^([13](footnote.xhtml#ch03fn13))
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 第三个例子 ➌ 有些不同。在这种情况下，我仅为将运行 `gcc` 的子进程定义了 `TMPDIR` 变量。^([12](footnote.xhtml#ch03fn12))
    注意缺少的分号；从 shell 的角度来看，这只是一个单独的命令。^([13](footnote.xhtml#ch03fn13))
- en: '**NOTE**'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*If you choose to wrap commands with a trailing backslash, be sure that there
    are no spaces or other invisible characters after it. The backslash escapes the
    newline character, so it must immediately precede that character.*'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '*如果你选择用一个反斜杠来换行命令，请确保反斜杠后面没有空格或其他不可见字符。反斜杠转义了换行符，因此它必须紧接在换行符之前。*'
- en: '*Variable Binding*'
  id: totrans-72
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*变量绑定*'
- en: Variables referenced in commands may be defined after the command in the makefile
    because such references are not bound to their values until just before `make`
    passes the command to the shell for execution—long after the entire makefile has
    been read. In general, `make` binds variables to values as late as it possibly
    can.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在命令中引用的变量可能在makefile中的命令之后才被定义，因为这些引用的值直到`make`将命令传递给shell执行之前才会被绑定——也就是说，直到整个makefile被读取完之后。在一般情况下，`make`会尽可能推迟将变量绑定到值。
- en: Since commands are processed at a later stage than rules, variable references
    in commands are bound later than those in rules. Variable references found in
    rules are expanded when `make` builds the directed graph from the rules in the
    makefile. Thus, a variable referenced in a rule must be fully defined in a makefile
    before the referencing rule. [Listing 3-7](ch03.xhtml#ch03ex07) shows a portion
    of a makefile that illustrates both of these concepts.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 由于命令在规则之后处理，命令中的变量引用会比规则中的变量引用晚绑定。在规则中找到的变量引用在`make`根据规则构建有向图时会被扩展。因此，在规则中引用的变量必须在makefile中完全定义，且在引用规则之前。
    [清单 3-7](ch03.xhtml#ch03ex07)展示了一个makefile的部分内容，说明了这两个概念。
- en: '[PRE7]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '*Listing 3-7: Variable expansion in a makefile*'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 3-7：makefile中的变量扩展*'
- en: In the rule at ➊, both references to `$(mytarget)` are expanded to `foo` because
    they’re processed during the first pass, when `make` is building the variable
    list and directed graph. However, the outcome is probably not what you’d expect,
    because both references to `$(mytarget)` in the command at ➋ are not expanded
    until much later, long after `make` has already assigned `bar` to `mytarget`,
    overwriting the original assignment of `foo`.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在➊规则中，`$(mytarget)`的两个引用在第一次处理时都被扩展为`foo`，因为那时`make`正在构建变量列表和有向图。然而，结果可能并不是你预期的，因为在➋命令中的两个`$(mytarget)`引用要到稍后才会被扩展，远在`make`已经将`bar`赋值给`mytarget`，并覆盖了原本的`foo`赋值之后。
- en: '[Listing 3-8](ch03.xhtml#ch03ex08) shows the same rule and command the way
    `make` sees them after the variables are fully expanded.'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '[清单 3-8](ch03.xhtml#ch03ex08)展示了在变量完全扩展后，`make`如何看待相同的规则和命令。'
- en: '[PRE8]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '*Listing 3-8: The results after variable expansion of the code in [Listing
    3-7](ch03.xhtml#ch03ex07)*'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 3-8：代码在[清单 3-7](ch03.xhtml#ch03ex07)中的变量扩展结果*'
- en: The moral of this story is that you should understand where variables will be
    expanded in makefile constructs so you’re not surprised when `make` refuses to
    act in a sane manner when it processes your makefile. It is good practice (and
    a good way to avoid headaches) to always assign variables before you intend to
    use them. For more information on immediate and deferred expansion of variables
    in makefiles, refer to “How make Reads a Makefile” in the *GNU Make Manual*.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 这个故事的寓意是，你应该了解在makefile结构中，变量会在哪里被扩展，这样你就不会感到惊讶，当`make`处理你的makefile时不按预期的方式执行。良好的实践（也是避免头痛的好方法）是，在打算使用变量之前，总是先赋值给它们。有关makefile中变量的即时扩展和延迟扩展的更多信息，请参考*GNU
    Make手册*中的“make如何读取makefile”一节。
- en: '*Rules in Detail*'
  id: totrans-82
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*规则详细信息*'
- en: The rules used in my examples, known as *common* `make` rules, contain a single
    colon character (`:`). The colon separates targets on the left from dependencies
    on the right.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 我在示例中使用的规则，称为*常见*的`make`规则，包含一个冒号字符（`:`）。冒号将左边的目标与右边的依赖项分开。
- en: Remember that targets are products—that is, filesystem entities that can be
    produced by running one or more commands, such as a C or C++ compiler, a linker,
    or a documentation generator like Doxygen or LaTeX. Dependencies, on the other
    hand, are source objects, or objects from which targets are created. These may
    be computer language source files, intermediate products built by a previous rule,
    or anything else that can be used by a command as a resource.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，目标是产物——即通过执行一个或多个命令（如C或C++编译器、链接器，或者像Doxygen或LaTeX这样的文档生成器）可以生成的文件系统实体。而依赖关系则是源对象，或者是用来创建目标的对象。这些对象可能是计算机语言源文件、先前规则构建的中间产品，或者任何可以被命令用作资源的东西。
- en: You can specify any target defined within a makefile rule directly on the `make`
    command line, and `make` will execute all the commands necessary to generate that
    target.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在`make`命令行中直接指定任何在makefile规则中定义的目标，`make`将执行生成该目标所需的所有命令。
- en: '**NOTE**'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*If you don’t specify any targets on the *`make`* command line, *`make`* will
    use the default target—the first one it finds in the makefile.*'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '*如果你没有在`make`命令行中指定任何目标，`make`将使用默认目标——即它在makefile中找到的第一个目标。*'
- en: For example, a C compiler takes dependency *main.c* as input and generates target
    *main.o*. A linker then takes dependency *main.o* as input and generates a named
    executable target—`program`, in this case.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，一个 C 编译器接受依赖项 *main.c* 作为输入并生成目标 *main.o*。然后，链接器以 *main.o* 作为输入并生成一个命名的可执行目标——在这种情况下是
    `program`。
- en: '[Figure 3-1](ch03.xhtml#ch03fig01) shows the flow of data as it might be specified
    by the rules defined in a makefile.'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 3-1](ch03.xhtml#ch03fig01) 显示了数据流的过程，这些流程可能由 Makefile 中定义的规则指定。'
- en: '![Image](../images/03fig01.jpg)'
  id: totrans-90
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/03fig01.jpg)'
- en: '*Figure 3-1: A data flow diagram for the compile and link processes*'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 3-1：编译和链接过程的数据流图*'
- en: The `make` utility implements some fairly complex logic to determine when a
    rule should be run, based on whether a target exists and whether it is older than
    its dependencies. [Listing 3-9](ch03.xhtml#ch03ex09) shows a makefile containing
    rules, some of which execute the actions in [Figure 3-1](ch03.xhtml#ch03fig01).
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '`make` 工具实现了一些相当复杂的逻辑，用来判断何时执行一个规则，依据是目标文件是否存在，以及它是否比其依赖项旧。[列表 3-9](ch03.xhtml#ch03ex09)
    显示了一个包含规则的 Makefile，其中一些规则会执行 [图 3-1](ch03.xhtml#ch03fig01) 中的操作。'
- en: '[PRE9]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '*Listing 3-9: Using multiple `make` rules to compile and link a program*'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 3-9：使用多个 `make` 规则编译并链接程序*'
- en: The first rule in this makefile says that `program` depends on *main.o*, *print.o*,
    and *display.o*. The remaining rules say that each *.o* file depends on the corresponding
    *.c* file. Ultimately, `program` depends on the three source files, but the object
    files are necessary as intermediate dependencies because there are two steps to
    the process—compile and link—with a result in between. For each rule, `make` uses
    an associated list of commands to build the rule’s target from its list of dependencies.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 这个 Makefile 中的第一个规则指出，`program` 依赖于 *main.o*、*print.o* 和 *display.o*。其余的规则则表示每个
    *.o* 文件依赖于相应的 *.c* 文件。最终，`program` 依赖于这三个源文件，但由于过程分为编译和链接两个步骤，中间还需要生成结果，因此必须有对象文件作为中间依赖。在每个规则中，`make`
    使用关联的命令列表根据依赖项列表构建规则的目标。
- en: Unix compilers are designed as higher-level tools than linkers. They have built-in,
    low-level knowledge about system-specific linker requirements. In the makefile
    in [Listing 3-9](ch03.xhtml#ch03ex09), the ellipsis in the line at ➊ is a placeholder
    for a list of system-specific, low-level objects and libraries required to build
    all programs on this system. The compiler can be used to call the linker, silently
    passing these system-specific objects and libraries. (It’s so effective and widely
    used that it’s often difficult to discover how to manually execute the linker
    on a given system.) [Listing 3-10](ch03.xhtml#ch03ex10) shows how you might rewrite
    the makefile from [Listing 3-9](ch03.xhtml#ch03ex09) to use the compiler to compile
    the sources and call the linker in a single rule.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: Unix 编译器设计为比链接器更高级的工具。它们内置了关于特定系统链接器要求的低级知识。在 [列表 3-9](ch03.xhtml#ch03ex09)
    中的 Makefile，➊ 处的省略号是一个占位符，用于表示构建系统上所有程序所需的系统特定、低级对象和库的列表。编译器可以用来调用链接器，并默默地传递这些系统特定的对象和库。（这种方法非常有效且广泛使用，以至于通常很难发现如何在给定系统上手动执行链接器。）[列表
    3-10](ch03.xhtml#ch03ex10) 显示了你如何重写 [列表 3-9](ch03.xhtml#ch03ex09) 中的 Makefile，使用编译器来编译源代码并在单个规则中调用链接器。
- en: '[PRE10]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '*Listing 3-10: Using a single `make` rule to compile sources into an executable*'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 3-10：使用单个 `make` 规则将源代码编译成可执行文件*'
- en: '**NOTE**'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*Using a single rule and command to process both steps is possible in this
    case because the example is very basic. For larger projects, skipping from source
    to executable in a single step is usually not the wisest way to manage the build
    process. However, in either case, using the compiler to call the linker can ease
    the burden of determining the many system objects that need to be linked into
    an application, and, in fact, this very technique is used quite often. More complex
    examples, wherein each file is compiled separately, use the compiler to compile
    each source file into an object file and then use the compiler to call the linker
    to link them all together into an executable.*'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '*在这种情况下，使用单个规则和命令来处理这两个步骤是可行的，因为这个示例非常基础。对于更大的项目，通常不建议在一个步骤中直接从源代码跳到可执行文件。然而，在任何情况下，使用编译器调用链接器可以减轻确定需要链接到应用程序的许多系统对象的负担，实际上，这个技术非常常见并被广泛使用。更复杂的示例中，每个文件会被单独编译，编译器会将每个源文件编译成对象文件，然后使用编译器调用链接器将所有文件链接成一个可执行文件。*'
- en: 'In this example, I’ve added a `make` variable (`sources`) that allows us to
    consolidate all product dependencies into one location. We now have a list of
    source files captured in a variable definition that is referenced in two places:
    in the dependency list and on the command line.'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我添加了一个 `make` 变量（`sources`），它允许我们将所有产品依赖项整合到一个位置。现在，我们有一个源文件列表，该列表在两个地方引用：在依赖列表中和命令行中。
- en: Automatic Variables
  id: totrans-102
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 自动变量
- en: There may be other kinds of objects in a dependency list that are not in the
    `sources` variable, including precompiled objects and libraries. These other objects
    would have to be listed separately, both in the rule and on the command line.
    Wouldn’t it be nice if we had a shorthand notation for referencing the rule’s
    entire dependency list in the commands?
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 依赖列表中可能包含其他不是 `sources` 变量中的对象，包括预编译对象和库。这些其他对象必须在规则中和命令行中分别列出。如果我们能为引用规则的整个依赖列表提供简写形式，那该有多好？
- en: 'As it happens, various *automatic* variables can be used to reference portions
    of the controlling rule during the execution of a command. Unfortunately, most
    of these are all but useless if you care about portability between implementations
    of `make`. The `$@` variable (which references the current target) happens to
    be portable and useful, but most of the other automatic variables are too limited
    to be very useful.^([14](footnote.xhtml#ch03fn14)) The following is a complete
    list of portable automatic variables defined by POSIX for `make`:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，各种 *自动* 变量可以在执行命令时引用控制规则的部分。不幸的是，如果你关心 `make` 实现之间的可移植性，这些大多数都几乎无用。`$@`
    变量（引用当前目标）是可移植且有用的，但其他大多数自动变量过于有限，无法发挥太大作用。^([14](footnote.xhtml#ch03fn14)) 以下是
    POSIX 为 `make` 定义的完整可移植自动变量列表：
- en: '`$@` refers to the full target name of the current target or the archive filename
    part of a library archive target. This variable is valid in both explicit and
    implicit rules.'
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`$@` 指当前目标的完整目标名称或库归档目标的归档文件名部分。此变量在显式和隐式规则中都有效。'
- en: '`$%` refers to a member of an archive and is valid only when the current target
    is an archive member—that is, an object file that is a member of a static library.
    This variable is valid in both explicit and implicit rules.'
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`$%` 指归档成员，仅在当前目标是归档成员时有效——即静态库中的目标文件。此变量在显式和隐式规则中都有效。'
- en: '`$?` refers to the list of dependencies that are newer than the current target.
    This variable is valid in both explicit and implicit rules.'
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`$?` 指比当前目标更新的依赖项列表。此变量在显式和隐式规则中都有效。'
- en: '`$<` refers to the member of the dependency list whose existence allowed the
    rule to be chosen for the target. This variable is only valid in implicit rules.'
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`$<` 指依赖列表中允许选择该规则的依赖项。此变量仅在隐式规则中有效。'
- en: '`$*` refers to the current target name with its suffix deleted. This variable
    is guaranteed by POSIX to be valid only in implicit rules.'
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`$*` 指当前目标名称，去掉其后缀部分。POSIX 保证此变量仅在隐式规则中有效。'
- en: GNU `make` dramatically extends the POSIX-defined list, but since GNU extensions
    are not portable, it’s unwise to use any of these except `$@`.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: GNU `make` 大大扩展了 POSIX 定义的列表，但由于 GNU 扩展不可移植，除 `$@` 外不建议使用这些扩展。
- en: Dependency Rules
  id: totrans-111
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 依赖规则
- en: Let us now assume that *print.c* and *display.c* each have a header file of
    the same name, ending in *.h*. Each of these source files includes its own header
    file, but *main.c* includes both *print.h* and *display.h*. Given the makefiles
    of [Listings 3-9](ch03.xhtml#ch03ex09) and [3-10](ch03.xhtml#ch03ex10), what do
    you suppose would happen if you executed `make` to build `program`, then modified
    one of the header files—say *print.h*—and then re-executed `make`? Nothing would
    happen because `make` is unaware even of the existence of these header files.
    As far as `make` is concerned, you didn’t touch anything related to `program`.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 假设 *print.c* 和 *display.c* 各自有一个同名的头文件，以 *.h* 结尾。每个源文件都包含自己的头文件，但 *main.c* 包含了
    *print.h* 和 *display.h*。根据 [Listings 3-9](ch03.xhtml#ch03ex09) 和 [3-10](ch03.xhtml#ch03ex10)
    中的 makefile，如果你执行 `make` 来构建 `program`，然后修改其中一个头文件——比如 *print.h*，再重新执行 `make`，你觉得会发生什么？什么都不会发生，因为
    `make` 根本不知道这些头文件的存在。在 `make` 看来，你并没有更改任何与 `program` 相关的内容。
- en: In [Listing 3-11](ch03.xhtml#ch03ex11), I’ve replaced the `sources` variable
    with an `objects` variable and replaced the list of source files with a list of
    object files. This version of the makefile in [Listing 3-10](ch03.xhtml#ch03ex10)
    also eliminates redundancy by making use of both standard and automatic variables.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 在[列表3-11](ch03.xhtml#ch03ex11)中，我将`sources`变量替换为`objects`变量，并用对象文件列表替换了源文件列表。这个版本的makefile在[列表3-10](ch03.xhtml#ch03ex10)中也通过利用标准和自动变量，消除了冗余。
- en: '[PRE11]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '*Listing 3-11: Using automatic variables in a command*'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表3-11：在命令中使用自动变量*'
- en: I’ve also added three *dependency rules*, which are rules without commands that
    clarify the relationships between compiler output files and dependent source and
    header files. Because *print.h* and *display.h* are (presumably) included by *main.c*,
    *main.c* must be recompiled if either of those files changes; however, `make`
    has no way of knowing that these two header files are included by *main.c*. Dependency
    rules allow the developer to tell `make` about such backend relationships.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 我还添加了三个*依赖规则*，这些规则没有命令，目的是澄清编译器输出文件与依赖的源文件和头文件之间的关系。因为*print.h*和*display.h*（假定）被*main.c*包含，若这两个文件中的任何一个发生变化，*main.c*就必须重新编译；然而，`make`并不能知道这两个头文件是被*main.c*包含的。依赖规则允许开发者告知`make`这种后端关系。
- en: Implicit Rules
  id: totrans-117
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 隐式规则
- en: If you attempt to mentally follow the dependency graph that `make` would build
    from the rules within the makefile in [Listing 3-11](ch03.xhtml#ch03ex11), you’ll
    find what appears to be a hole in the web. According to the last rule in the file,
    the `program` executable depends on *main.o*, *print.o*, and *display.o*. This
    rule also provides the command to link these objects into an executable (using
    the compiler merely to call the linker this time). The object files are tied to
    their corresponding C source and header files by the three dependency rules. But
    where are the commands that compile the *.c* files into *.o* files?
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你试图根据[列表3-11](ch03.xhtml#ch03ex11)中的makefile规则，心算出`make`将构建的依赖图，你会发现网络中似乎有个漏洞。根据文件中的最后一条规则，`program`可执行文件依赖于*main.o*、*print.o*和*display.o*。此规则还提供了将这些目标链接成可执行文件的命令（这次只是调用链接器，而使用编译器）。这些目标文件通过三个依赖规则与它们对应的C源文件和头文件相关联。但编译*.c*文件成*.o*文件的命令在哪里？
- en: We could add these commands to the dependency rules, but there’s really no need
    because `make` has a *built-in* rule that knows how to build *.o* files from *.c*
    files. There’s nothing magic about `make`—it only knows about the relationships
    you describe to it through the rules you write. But `make` does have certain built-in
    rules that describe the relationships between, for example, *.c* files and *.o*
    files. This particular built-in rule provides commands for building anything with
    a *.o* extension from a file of the same base name with a *.c* extension. These
    built-in rules are called *suffix rules* or, more generally, *implicit rules*,
    because the name of the dependency (source file) is implied by the name of the
    target (object file).
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将这些命令添加到依赖规则中，但其实没有必要，因为`make`有一个*内建*规则，知道如何从*.c*文件构建*.o*文件。`make`并没有什么神奇之处——它只知道你通过编写规则描述给它的关系。但`make`确实有一些内建规则，描述了例如*.c*文件和*.o*文件之间的关系。这个特定的内建规则提供了从具有相同基础名称的*.c*文件构建任何*.o*扩展名文件的命令。这些内建规则被称为*后缀规则*，或者更一般地说，*隐式规则*，因为依赖关系（源文件）的名称是通过目标（目标文件）的名称隐含表达的。
- en: To make the built-in implicit rules more widely usable, their commands often
    consume well-known `make` variables. If you set those variables, overriding the
    default values, you can wield some control over the execution of a built-in rule.
    For instance, the command in the standard POSIX definition of the built-in implicit
    rule for converting *.o* files to *.c* files is:^([15](footnote.xhtml#ch03fn15))
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使内建隐式规则更广泛可用，它们的命令通常会使用一些知名的`make`变量。如果你设置了这些变量，覆盖了默认值，你可以对执行内建规则有一定的控制。例如，在内建隐式规则的标准POSIX定义中，*.o*文件转为*.c*文件的命令是：^([15](footnote.xhtml#ch03fn15))
- en: '[PRE12]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Here, you can override just about every aspect of this built-in rule by setting
    your own values for `CC`, the compiler; `CPPFLAGS`, options passed to the C preprocessor;
    and `CFLAGS`, options passed to the C compiler.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，你几乎可以通过设置`CC`（编译器）、`CPPFLAGS`（传递给C预处理器的选项）和`CFLAGS`（传递给C编译器的选项）来覆盖这个内建规则的各个方面。
- en: You can write implicit rules yourself, if you wish. You can even override the
    default implicit rules with your own versions. Implicit rules are a powerful tool,
    and they shouldn’t be overlooked, but for the purposes of this book, we won’t
    go into any more detail. You can learn more about writing and using implicit rules
    within makefiles in “Using Implicit Rules” in the *GNU Make Manual*.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 如果需要，你可以自己编写隐式规则。你甚至可以用自己的版本覆盖默认的隐式规则。隐式规则是一个强大的工具，不容忽视，但在本书中，我们不会深入讨论。你可以通过阅读*GNU
    Make手册*中的“使用隐式规则”部分，了解更多关于在makefile中编写和使用隐式规则的信息。
- en: 'To illustrate this implicit functionality, I created trivial C source and header
    files to accompany the sample makefile from [Listing 3-11](ch03.xhtml#ch03ex11).
    Here’s what happened when I executed `make` on this makefile:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 为了说明这种隐式功能，我创建了简单的C源代码和头文件，配合[列表3-11](ch03.xhtml#ch03ex11)中的示例makefile。以下是我执行`make`命令时发生的情况：
- en: '[PRE13]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: As you can see, `cc` was magically executed with `-c` and `-o` options to generate
    *main.o* from *main.c*. This is common command line syntax used to make a C-language
    compiler build objects from sources—it’s so common, in fact, that the functionality
    is built into `make`. If you look for `cc` on a modern GNU/Linux system, you’ll
    find that it’s a soft link in */usr/bin* that refers to the system’s GNU C compiler.
    On other systems, it refers to the system’s native C compiler. Calling the system
    C compiler *cc* has been a de facto standard for decades.^([16](footnote.xhtml#ch03fn16))
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，`cc`通过`-c`和`-o`选项被神奇地执行，从*main.c*生成*main.o*。这是常见的命令行语法，用于让C语言编译器从源代码构建对象，实际上，这种功能已内建在`make`中。如果你在现代的GNU/Linux系统中查找`cc`，你会发现它是*/usr/bin*中的一个软链接，指向系统的GNU
    C编译器。在其他系统中，它指向系统的本地C编译器。几十年来，调用系统C编译器为*cc*已经成为事实上的标准。^([16](footnote.xhtml#ch03fn16))
- en: The extra spaces between `cc` and `-c` in that output under ➊ represent the
    spaces between the uses of the `CPPFLAGS` and `CFLAGS` variables, which are defined
    as empty by default.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 在➊那行输出中，`cc`和`-c`之间的额外空格表示`CPPFLAGS`和`CFLAGS`变量之间的空格，这些变量默认被定义为空。
- en: But why did the `make` utility build only *main.o* when we typed `make` at ➊?
    Simply because the dependency rule for *main.o* provided the first (and thus,
    the default) target for the makefile. In this case, to build `program`, we needed
    to execute `make program`, as we did in ➋. Remember that when you enter `make`
    on the command line, the `make` utility attempts to build the first explicitly
    defined target within the file called *Makefile* in the current directory. If
    we wanted to make `program` the default target, we could rearrange the rules so
    the `program` rule would be the first one listed in the makefile.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，为什么我们在➊处输入`make`时，`make`工具只构建了*main.o*呢？仅仅是因为*main.o*的依赖规则提供了makefile中的第一个（因此也是默认）目标。在这种情况下，要构建`program`，我们需要执行`make
    program`，就像我们在➋所做的那样。记住，当你在命令行输入`make`时，`make`工具会尝试构建当前目录中名为*Makefile*的文件内第一个显式定义的目标。如果我们想让`program`成为默认目标，我们可以重新排列规则，使得`program`规则成为makefile中列出的第一个目标。
- en: 'To see the dependency rules in action, touch one of the header files and then
    rebuild the `program` target:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 为了查看依赖规则的实际作用，可以触摸其中一个头文件，然后重新构建`program`目标：
- en: '[PRE14]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: After *display.h* was updated, only *display.o*, *main.o*, and `program` were
    rebuilt. The *print.o* object didn’t need to be rebuilt because *print.c* doesn’t
    depend on *display.h*, according to the rules specified in the makefile.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 在更新了*display.h*之后，只有*display.o*、*main.o*和`program`被重新构建。由于*print.c*不依赖于*display.h*，根据makefile中指定的规则，*print.o*对象不需要重新构建。
- en: Phony Targets
  id: totrans-132
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 虚拟目标
- en: Targets are not always files. They can also be so-called *phony targets*, as
    in the case of `all` and `clean`. These targets don’t refer to true products in
    the filesystem but rather to particular outcomes or actions—when you make these
    targets, the project is *cleaned*, *all* products are built, and so on.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 目标并不总是文件。它们也可以是所谓的*虚拟目标*，例如`all`和`clean`。这些目标不指代文件系统中的真实产品，而是特定的结果或操作——当你执行这些目标时，项目会被*清理*，*所有*产品会被构建，等等。
- en: Multiple Targets
  id: totrans-134
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 多目标
- en: In the same way that you can list multiple dependencies within a rule on the
    right side of a colon, you can combine rules for multiple targets with the same
    dependencies and commands by listing the targets on the left side of a colon,
    as shown in [Listing 3-12](ch03.xhtml#ch03ex12).
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你可以在冒号右侧列出多个依赖项一样，你也可以通过在冒号左侧列出目标，将多个目标的规则与相同的依赖项和命令结合起来，如[列表3-12](ch03.xhtml#ch03ex12)所示。
- en: '[PRE15]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '*Listing 3-12: Using multiple targets in a rule*'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '*示例 3-12：在规则中使用多个目标*'
- en: 'While it may not be immediately apparent, this example contains two separate
    rules: one for each of the two targets, `all` and `clean`. Because these two rules
    have the same set of dependencies (none, in this case) and the same set of commands,
    we’re able to take advantage of a shorthand notation supported by `make` that
    allows us to combine their rules into one specification.'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这在一开始可能不太明显，但这个示例包含了两个独立的规则：一个针对 `all`，另一个针对 `clean`。因为这两个规则有相同的依赖集（在这种情况下没有依赖）和相同的命令集，我们可以利用
    `make` 支持的简写符号，将它们的规则合并为一个规范。
- en: To help you understand this concept, consider the `$@` variable in [Listing
    3-12](ch03.xhtml#ch03ex12). Which target does it refer to? Well, that depends
    on which rule is currently executing—the one for `all` or the one for `clean`.
    Since a rule can only be executed on a single target at any given time, `$@` can
    only ever refer to one target, even when the controlling rule specification contains
    several.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 为了帮助你理解这个概念，考虑 [示例 3-12](ch03.xhtml#ch03ex12) 中的 `$@` 变量。它指向哪个目标？这取决于当前执行的是哪个规则——是
    `all` 还是 `clean`。由于一个规则在任何给定时刻只能执行一个目标，`$@` 只能指向一个目标，即使控制规则的定义包含多个目标。
- en: '*Resources for Makefile Authors*'
  id: totrans-140
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*Makefile 作者的资源*'
- en: GNU `make` is significantly more powerful than the original AT&T UNIX `make`
    utility, although GNU `make` is completely backward compatible, as long as you
    avoid GNU extensions. The *GNU Make Manual*^([17](footnote.xhtml#ch03fn17)) is
    available online, and O’Reilly has published an excellent book on the original
    AT&T UNIX `make` utility^([18](footnote.xhtml#ch03fn18)) and all of its many nuances.
    While you can still find this title, the publisher has since merged its content
    into a new edition that also covers GNU `make` extensions.^([19](footnote.xhtml#ch03fn19))
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: GNU `make` 比原始的 AT&T UNIX `make` 工具要强大得多，尽管只要避免使用 GNU 扩展，GNU `make` 完全向后兼容。*GNU
    Make 手册*^([17](footnote.xhtml#ch03fn17)) 可以在线访问，而 O'Reilly 也出版了一本关于原始 AT&T UNIX
    `make` 工具的优秀书籍^([18](footnote.xhtml#ch03fn18))，详细讲解了它的各种细节。虽然你仍然可以找到这本书，但出版商已经将其内容合并进了一个新的版本，其中也涵盖了
    GNU `make` 的扩展。^([19](footnote.xhtml#ch03fn19))
- en: This concludes the general discussion of makefile syntax and the `make` utility,
    although we will look at additional makefile constructs as we encounter them throughout
    the rest of this chapter. With this general information behind us, let’s return
    to the Jupiter project and begin adding some more interesting functionality.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 这部分结束了对 makefile 语法和 `make` 工具的基本讨论，尽管在本章接下来的内容中，我们会在遇到时继续探讨其他 makefile 结构。通过这些基本信息的学习，让我们回到
    Jupiter 项目，开始添加一些更有趣的功能。
- en: Creating a Source Distribution Archive
  id: totrans-143
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建源代码分发档案
- en: In order to actually get source code for Jupiter to our users, we’re going to
    have to create and distribute a source archive—a tarball. We could write a separate
    script to create the tarball, but since we can use phony targets to create arbitrary
    sets of functionality in makefiles, let’s design a `make` target to perform this
    task instead. Building a source archive for distribution is usually relegated
    to the `dist` target.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 为了将 Jupiter 的源代码真正提供给用户，我们需要创建并分发一个源代码档案——一个 tarball。我们可以编写一个单独的脚本来创建这个 tarball，但既然我们可以使用虚拟目标在
    makefile 中创建任意功能集，为什么不设计一个 `make` 目标来执行这项任务呢？为分发构建源代码档案通常归属于 `dist` 目标。
- en: When designing a new `make` target, we need to consider whether its functionality
    should be distributed among the makefiles of the project or handled in a single
    location. Normally, the rule of thumb is to take advantage of a recursive build
    system’s nature by allowing each directory to manage its own portions of a process.
    We did just this in [Listing 3-1](ch03.xhtml#ch03ex01) when we passed control
    of building the `jupiter` program down to the *src* directory, where the source
    code is located. However, building a compressed archive from a directory structure
    isn’t really a recursive process.^([20](footnote.xhtml#ch03fn20)) This being the
    case, we’ll have to perform the entire task in one of the two makefiles.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 在设计一个新的 `make` 目标时，我们需要考虑它的功能是否应该在项目的 makefile 中分布，还是在单一位置处理。通常的经验法则是利用递归构建系统的特性，让每个目录管理自己部分的流程。我们在[示例
    3-1](ch03.xhtml#ch03ex01)中就是这么做的，将构建 `jupiter` 程序的控制权交给了包含源代码的 *src* 目录。然而，从目录结构中构建压缩档案并不真的是一个递归过程。^([20](footnote.xhtml#ch03fn20))
    因此，我们必须在两个 makefile 中执行整个任务。
- en: Global processes are often handled by the makefile at the highest relevant level
    in the project directory structure. We’ll add the `dist` target to our top-level
    makefile, as shown in [Listing 3-13](ch03.xhtml#ch03ex13).
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 全局进程通常由项目目录结构中最高相关级别的makefile处理。我们将在顶级makefile中添加`dist`目标，如[清单 3-13](ch03.xhtml#ch03ex13)所示。
- en: Git tag 3.1
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: Git标签 3.1
- en: '[PRE16]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '*Listing 3-13:* Makefile: Adding the `dist` target to the top-level makefile'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 3-13:* Makefile：将`dist`目标添加到顶级makefile中'
- en: Besides the addition of the `dist` target at ➋, I’ve also made several other
    modifications. Let’s look at them one at a time. I’ve added the `dist` target
    to the `.PHONY` rule at ➎. The `.PHONY` rule is a special kind of built-in rule
    called a *dot-rule* or *directive*. The `make` utility understands several dot-rules.
    The purpose of `.PHONY` is simply to tell `make` that certain targets don’t generate
    filesystem objects. Normally, `make` determines which commands to run by comparing
    the timestamps of the targets to those of their dependencies in the filesystem—but
    phony targets don’t have associated filesystem objects. Using `.PHONY` ensures
    that `make` won’t go looking for nonexistent product files named after these targets.
    It also ensures that if a file or directory named *dist* somehow inadvertently
    gets added to the directory, `make` will still treat the `dist` target as non-real.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 除了在➋处添加`dist`目标外，我还做了一些其他修改。我们一个一个地来看。我已将`dist`目标添加到➎处的`.PHONY`规则中。`.PHONY`规则是一种特殊的内置规则，叫做*点规则*或*指令*。`make`工具理解几种点规则。`.PHONY`的目的是简单地告诉`make`，某些目标不会生成文件系统对象。通常，`make`通过比较目标与其依赖项的时间戳来决定运行哪些命令——但虚拟目标没有关联的文件系统对象。使用`.PHONY`可以确保`make`不会去查找这些目标所命名的不存在的产品文件。它还确保，如果一个名为*dist*的文件或目录不小心被添加到目录中，`make`仍然会将`dist`目标视为非真实目标。
- en: Adding a target to the `.PHONY` rule has another effect. Since `make` won’t
    be able to use timestamps to determine whether the target is up-to-date (that
    is, newer than its dependencies), `make` has no recourse but to *always* execute
    the commands associated with phony targets whenever these targets either are requested
    on the command line or appear in a dependency chain.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 向`.PHONY`规则添加一个目标还有另一个效果。由于`make`无法通过时间戳来判断目标是否是最新的（即比它的依赖项更新），`make`唯一能做的就是*始终*执行与虚拟目标关联的命令，无论这些目标是通过命令行请求的，还是出现在依赖链中。
- en: 'I’ve separated the functionality of the `dist` target into three separate rules
    (➋, ➌, and ➍) for the sake of readability, modularity, and maintenance. This is
    a great rule of thumb to follow in any software engineering process: *build large
    processes from smaller ones and reuse the smaller processes where it makes sense.*'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 为了提高可读性、模块化和维护性，我将`dist`目标的功能分为三个单独的规则（➋、➌和➍）。这是任何软件工程过程中一个很好的经验法则：*将大型过程构建为较小的过程，并在合理的地方重用这些小的过程*。
- en: The `dist` target at ➋ depends on the existence of the ultimate goal—in this
    case, a source-level compressed archive package, *jupiter-1.0.tar.gz*. I’ve used
    one variable to hold the version number (which makes it easier to update the project
    version later) and another variable for the package name at ➊, which will make
    it easier to change the name if I ever decide to reuse this makefile for another
    project. I’ve also logically split the functions of package name and tarball name;
    the default tarball name is the package name, but we do have the option of making
    them different.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: ➋处的`dist`目标依赖于最终目标的存在——在这种情况下，是一个源级压缩归档包，*jupiter-1.0.tar.gz*。我使用了一个变量来保存版本号（这样以后更新项目版本更容易），另一个变量用于包名在➊处，这样如果我决定将这个makefile用于另一个项目时，改名就会更容易。我还在逻辑上将包名和tarball名的功能分开；默认的tarball名称是包名，但我们也有选择将它们设置为不同的名称。
- en: The rule that builds the tarball at ➌ indicates how this should be done with
    a command that uses the `gzip` and `tar` utilities to create the file. But, notice
    that the rule has a dependency—the directory to be archived. The directory name
    is derived from the tarball name and the package version number; it’s stored in
    yet another variable called `distdir`.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 构建tarball的规则在➌处指出了如何使用`gzip`和`tar`工具通过一个命令来创建该文件。但请注意，该规则有一个依赖关系——要归档的目录。目录名是从tarball的名称和包版本号派生的；它存储在另一个名为`distdir`的变量中。
- en: We don’t want object files and executables from our last build attempt to end
    up in the archive, so we need to build an image directory containing exactly what
    we want to ship—including any files required in the build and install processes
    and any additional documentation or license files. Unfortunately, this pretty
    much mandates the use of individual copy (`cp`) commands.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不希望上次构建尝试中的目标文件和可执行文件出现在归档中，因此我们需要构建一个图像目录，包含我们想要发布的所有内容——包括构建和安装过程中所需的任何文件，以及任何额外的文档或许可文件。不幸的是，这几乎要求必须使用单独的复制（`cp`）命令。
- en: Since there’s a rule in the makefile (at ➍) that tells how this directory should
    be created, and since that rule’s target is a dependency of the tarball, `make`
    runs the commands for that rule *before* running the commands for the tarball
    rule. Recall that `make` processes rules to build dependencies recursively, from
    the bottom up, until it can run the commands for the requested target.^([21](footnote.xhtml#ch03fn21))
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 makefile 中有一条规则（在 ➍ 处）指示如何创建这个目录，并且该规则的目标是 tarball 的依赖项，`make` 会先执行该规则的命令，再执行
    tarball 规则的命令。回想一下，`make` 会递归地处理规则，以从底部到顶部构建依赖关系，直到它能够执行请求的目标的命令。^([21](footnote.xhtml#ch03fn21))
- en: '*Forcing a Rule to Run*'
  id: totrans-157
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*强制执行规则*'
- en: 'There’s a subtle flaw in the `$(distdir)` target that may not be obvious right
    now, but it will rear its ugly head at the worst of times. If the archive image
    directory (*jupiter-1.0*) already exists when you execute `make dist`, then `make`
    won’t try to create it. Try this:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: '`$(distdir)` 目标中有一个微妙的缺陷，现在可能不太明显，但它将在最糟糕的时候露出它丑陋的面目。如果在执行 `make dist` 时归档图像目录
    (*jupiter-1.0*) 已经存在，那么 `make` 就不会尝试创建它。试试这个：'
- en: '[PRE17]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Notice that the `dist` target didn’t copy any files—it just built an archive
    out of the existing *jupiter-1.0* directory, which was empty. Our users would
    get a real surprise when they unpack this tarball! Worse still, if the image directory
    from the previous attempt to archive happened to still be there, the new tarball
    would contain the now-outdated sources from our last attempt to create a distribution
    tarball.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，`dist` 目标并没有复制任何文件——它只是从现有的 *jupiter-1.0* 目录中创建了一个归档文件，而该目录是空的。当用户解压这个 tarball
    时，肯定会大吃一惊！更糟糕的是，如果之前归档尝试中的图像目录仍然存在，那么新的 tarball 将包含我们上次尝试创建发行版 tarball 时的过时源代码。
- en: The problem is that the `$(distdir)` target is a real target with no dependencies,
    which means that `make` will consider it up-to-date as long as it exists in the
    filesystem. We could add the `$(distdir)` target to the `.PHONY` rule to force
    `make` to rebuild it every time we make the `dist` target, but it’s not a phony
    target—it’s a real filesystem object. The proper way to ensure that `$(distdir)`
    is always rebuilt is to ensure that it doesn’t exist before `make` attempts to
    build it. One way to accomplish this is to create a true phony target that will
    always execute and then add that target to the dependency list for the `$(distdir)`
    target. A common name for this kind of target is `FORCE`, and I’ve implemented
    this concept in [Listing 3-14](ch03.xhtml#ch03ex14).
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 问题在于，`$(distdir)` 目标是一个没有依赖关系的实际目标，这意味着只要它在文件系统中存在，`make` 就会认为它是最新的。我们可以将 `$(distdir)`
    目标添加到 `.PHONY` 规则中，以强制 `make` 每次执行 `dist` 目标时都重新构建它，但它并不是一个虚假目标——它是一个实际的文件系统对象。确保
    `$(distdir)` 始终被重新构建的正确方法是确保在 `make` 尝试构建它之前，它并不存在。实现这一目标的一种方式是创建一个真正的虚假目标，使其始终执行，然后将该目标添加到
    `$(distdir)` 目标的依赖列表中。此类目标的常见名称是 `FORCE`，我在 [Listing 3-14](ch03.xhtml#ch03ex14)
    中实现了这个概念。
- en: Git tag 3.2
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: Git 标签 3.2
- en: '[PRE18]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '*Listing 3-14: Makefile: Using the `FORCE` target*'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: '*Listing 3-14: Makefile: 使用 `FORCE` 目标*'
- en: The `FORCE` rule’s commands (at ➋) are executed every time because `FORCE` is
    a phony target. Since we made `FORCE` a dependency of the `$(distdir)` target
    (at ➊), we have the opportunity to delete any previously created files and directories
    *before* `make` begins to evaluate whether it should execute the commands for
    `$(distdir)`.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: '`FORCE` 规则的命令（在 ➋ 处）每次都会执行，因为 `FORCE` 是一个虚假目标。由于我们将 `FORCE` 作为 `$(distdir)`
    目标的依赖项（在 ➊ 处），我们有机会在 `make` 开始评估是否应执行 `$(distdir)` 的命令之前，删除任何先前创建的文件和目录。'
- en: '*Leading Control Characters*'
  id: totrans-166
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*领先的控制字符*'
- en: A leading dash character (`-`) on a command tells `make` not to care about the
    status code of the command it precedes. Normally, when `make` encounters a command
    that returns a nonzero status code to the shell, it will stop execution and display
    an error message, but if you use a leading dash, it will just ignore the error
    and continue. I use a leading dash on the first `rm` command in the `FORCE` rule
    because I want to delete previously created product files that may *or may not*
    exist, and `rm` will return an error if I attempt to delete a nonexistent file.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
- en: In general, a better option is to use the `-f` flag on the `rm` command line,
    which causes `rm` to ignore missing file errors. Another benefit of using `-f`
    is that we no longer need to redirect error messages to */dev/null*, as we really
    care about other errors—permission errors, for example. From this point on, we’ll
    remove the leading dash in front of any `rm` commands and ensure we use `-f`.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
- en: 'Another leading character that you may encounter is the at sign (`@`). A command
    prefixed with an at sign tells `make` not to perform its normal behavior of printing
    the command to the `stdout` device as it executes it. It is common to use a leading
    at sign on `echo` statements. You don’t want `make` to print `echo` statements,
    because then your message will be printed twice: once by `make` and then again
    by the `echo` statement itself.'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
- en: '*You may also combine these leading characters (*`@`*, *`-`*, and *`+`*) in
    any order. The plus (*`+`*) character is used to force a command to execute that
    would otherwise not be executed due, for example, to a *`-n`* command line option,
    which tells *`make`* to perform a so-called dry run. Some commands make sense
    even in a dry run.*'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
- en: It’s best to use the at sign judiciously. I usually reserve it for commands
    I *never* want to see, such as `echo` statements. If you like quiet build systems,
    consider using the global `.SILENT` directive in your makefiles. Or better still,
    simply do nothing, thereby allowing the user the option of adding the `-s` option
    to their `make` command lines. This enables the user to choose how much noise
    they want to see.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
- en: Automatically Testing a Distribution
  id: totrans-173
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The rule for building the archive directory is probably the most frustrating
    rule in this makefile because it contains commands to copy individual files into
    the distribution directory. Every time we change the file structure in our project,
    we have to update this rule in our top-level makefile, or we’ll break the `dist`
    target. But there’s nothing more we can do—we’ve made the rule as simple as possible.
    Now we just have to remember to manage this process properly.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
- en: Unfortunately, though, even worse things than breaking the `dist` target could
    happen if you forget to update the `distdir` rule’s commands. It may *appear*
    that the `dist` target is working, but it may not actually be copying all of the
    required files into the tarball. In fact, it is far more likely that this, rather
    than an error, will occur, because adding files to a project is a more common
    activity than moving them around or deleting them. New files will not be copied,
    but the `dist` rule won’t notice the difference.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
- en: 'There is a way to perform a sort of self-check on the `dist` target. We can
    create another phony target, called `distcheck`, that does exactly what our users
    will do: unpack the tarball and build the project. We can have this rule’s commands
    perform this task in a temporary directory. If the build process fails, then the
    `distcheck` target will break, telling us that we forgot something crucial in
    our distribution.'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 3-15](ch03.xhtml#ch03ex15) shows the modifications to our top-level
    makefile that are required to implement the `distcheck` target.'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
- en: Git tag 3.3
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '*Listing 3-15: Makefile: Adding a `distcheck` target to the top-level makefile*'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
- en: The `distcheck` target depends on the tarball itself, so the rule that builds
    the tarball is executed first. The `make` utility then executes the `distcheck`
    commands, which unpack the tarball just built and then recursively run `make`
    on the `all` and `clean` targets within the resulting directory. If that process
    succeeds, the `distcheck` target prints out a message indicating that your users
    will likely not have a problem with this tarball.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
- en: Now all you have to do is remember to execute `make distcheck` *before* you
    post your tarballs for public distribution!
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
- en: Unit Testing, Anyone?
  id: totrans-183
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Some people insist that unit testing is evil, but the only honest rationale
    they can come up with for not doing it is laziness. Proper unit testing is hard
    work, but it pays off in the end. Those who do it have learned a lesson (usually
    in childhood) about the value of delayed gratification.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
- en: A good build system should incorporate proper unit testing. The most commonly
    used target for testing a build is the `check` target, so we’ll go ahead and add
    it in the usual manner. The actual unit test should probably go in *src/Makefile*
    because that’s where the `jupiter` executable is built, so we’ll pass the `check`
    target down from the top-level makefile.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
- en: But what commands do we put in the `check` rule? Well, `jupiter` is a pretty
    simple program—it prints the message *Hello from* some/path/*jupiter!* where *some/path*
    depends on the location from which `jupiter` was executed. I’ll use the `grep`
    utility to test that `jupiter` actually outputs such a string.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
- en: '[Listings 3-16](ch03.xhtml#ch03ex16) and [3-17](ch03.xhtml#ch03ex17) illustrate
    the modifications to our top-level and *src* directory makefiles, respectively.'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
- en: Git tag 3.4
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '*Listing 3-16:* Makefile: *Passing the `check` target to src/Makefile*'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '*Listing 3-17:* src/Makefile: *Implementing the unit test in the `check` target*'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
- en: Note that `check` depends on `all`. We can’t really test our products unless
    they are up-to-date, reflecting any recent source code or build system changes
    that may have been made. It makes sense that if the user wants to test the products,
    they also want the products to exist and be up-to-date. We can ensure they exist
    and are current by adding `all` to `check`’s dependency list.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
- en: 'There’s one more enhancement we can make to our build system: we can add `check`
    to the list of targets executed by `make` in our `distcheck` rule, between the
    commands to make `all` and `clean`. [Listing 3-18](ch03.xhtml#ch03ex18) shows
    where this is done in the top-level makefile.'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
- en: Git tag 3.5
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '*Listing 3-18:* Makefile: *Adding the `check` target to the `$(MAKE)` command*'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
- en: Now when we run `make distcheck`, it will test the entire build system shipped
    with the package.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
- en: Installing Products
  id: totrans-199
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We’ve reached the point where our users’ experiences with Jupiter should be
    fairly painless—even pleasant—as far as building the project is concerned. Users
    will simply unpack the distribution tarball, change into the distribution directory,
    and type `make`. It really can’t get any simpler than that.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
- en: But we still lack one important feature—installation. In the case of the Jupiter
    project, this is fairly trivial. There’s only one program, and most users would
    guess correctly that to install it, they should copy `jupiter` into either their
    */usr/bin* or */usr/local/bin* directory. More complex projects, however, could
    cause users real consternation over where to put user and system binaries, libraries,
    header files, and documentation, including man pages, info pages, PDF files, and
    the more or less obligatory *README*, *AUTHORS*, *NEWS*, *INSTALL*, and *COPYING*
    files generally associated with GNU projects.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
- en: We don’t really want our users to have to figure all that out, so we’ll create
    an `install` target to manage putting things where they go once they’re built
    properly. In fact, why not just make installation part of the `all` target? Well,
    let’s not get carried away. There are actually a few good reasons for not doing
    this.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
- en: First, build and installation are separate logical concepts. The second reason
    is a matter of filesystem rights. Users have rights to build projects in their
    own home directories, but installation often requires *root*-level rights to copy
    files into system directories. Finally, there are several reasons why a user may
    wish to build but not install a project, so it would be unwise to tie these actions
    together.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
- en: 'While creating a distribution package may not be an inherently recursive process,
    installation certainly is, so we’ll allow each subdirectory in our project to
    manage installation of its own components. To do this, we need to modify both
    the top-level and the *src*-level makefiles. Changing the top-level makefile is
    easy: since there are no products to be installed in the top-level directory,
    we’ll just pass the responsibility on to *src/Makefile* in the usual way.'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
- en: The modifications for adding an `install` target are shown in [Listings 3-19](ch03.xhtml#ch03ex19)
    and [3-20](ch03.xhtml#ch03ex20).
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
- en: Git tag 3.6
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '*Listing 3-19:* Makefile: *Passing the `install` target to src/Makefile*'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '*Listing 3-20:* src/Makefile: *Implementing the `install` target*'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
- en: In the top-level makefile shown in [Listing 3-19](ch03.xhtml#ch03ex19), I’ve
    added `install` to the list of targets passed down to *src/Makefile*. The installation
    of files is handled by the *src*-level makefile shown in [Listing 3-20](ch03.xhtml#ch03ex20).
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
- en: Installation is a bit more complex than simply copying files. If a file is placed
    in the */usr/bin* directory, then *root* should own it so that only *root* can
    delete or modify it. Additionally, the `jupiter` binary should be flagged executable,
    so I’ve used the `chmod` command to set the mode of the file as such. This is
    probably redundant, as the linker ensures that `jupiter` is created as an executable
    file, but some types of executable products are not generated by a linker—shell
    scripts, for example.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
- en: 'Now our users can just type the following sequence of commands and the Jupiter
    project will be built, tested, and installed with the correct system attributes
    and ownership on their platforms:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '*Installation Choices*'
  id: totrans-215
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: All of this is well and good, but it could be a bit more flexible with regard
    to where things are installed. Some users may be okay with having `jupiter` installed
    into the */usr/bin* directory. Others are going to ask why it isn’t installed
    into the */usr/local/bin* directory—after all, this is a common convention. We
    could change the target directory to */usr/local/bin*, but then users may ask
    why they don’t have the option of installing into their home directories. This
    is the perfect situation for a little command line–supported flexibility.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
- en: Another problem with our current build system is that we have to do a lot of
    stuff just to install files. Most Unix systems provide a system-level program—sometimes
    simply a shell script—called `install` that allows a user to specify various attributes
    of the files being installed. The proper use of this utility could simplify things
    a bit for Jupiter’s installation, so while we’re adding location flexibility,
    we might as well use the `install` utility, too. These modifications are shown
    in [Listings 3-21](ch03.xhtml#ch03ex21) and [3-22](ch03.xhtml#ch03ex22).
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
- en: Git tag 3.7
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '*Listing 3-21: Makefile: Adding a `prefix` variable*'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '*Listing 3-22:* src/Makefile: *Using the `prefix` variable in the `install`
    target*'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
- en: Notice that I only declared and assigned the `prefix` variable in the top-level
    makefile, but I referenced it in *src/Makefile*. I can do this because I used
    the `export` modifier at ➊ in the top-level makefile—this modifier exports the
    variable to the shell that `make` spawns when it executes itself in the *src*
    directory. This feature of `make` allows us to define all of our user variables
    in one obvious location—at the beginning of the top-level makefile.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
- en: '*GNU *`make`* allows you to use the *`export`* keyword on the assignment line,
    but this syntax is not portable between GNU *`make`* and other versions of *`make`*.
    Technically, POSIX doesn’t support the use of *`export`* at all, but most *`make`*
    implementations support it.*'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
- en: 'I’ve now declared the `prefix` variable to be */usr/local*, which is very nice
    for those who want to install `jupiter` in */usr/local/bin* but not so nice for
    those who want it in */usr/bin*. Fortunately, `make` allows you to define `make`
    variables on the command line, in this manner:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Remember that variables defined on the command line override those defined within
    the makefile.^([22](footnote.xhtml#ch03fn22)) Thus, users who want to install
    `jupiter` into the */usr/bin* directory now have the option of specifying this
    on the `make` command line.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
- en: With this system in place, our users may install `jupiter` into a *bin* directory
    beneath any directory they choose, including a location in their home directory
    (for which they do not need additional rights). This is, in fact, the reason we
    added the `install -d $(prefix)/bin` command at ➋ in [Listing 3-22](ch03.xhtml#ch03ex22)—this
    command creates the installation directory if it doesn’t already exist. Since
    we allow the user to define `prefix` on the `make` command line, we don’t actually
    know where the user is going to install `jupiter`; therefore, we have to be prepared
    for the possibility that the location may not yet exist. Give this a try:^([23](footnote.xhtml#ch03fn23))
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '*Uninstalling a Package*'
  id: totrans-231
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: What if a user doesn’t like our package after they’ve installed it, and they
    just want to get it off their system? This is a fairly likely scenario for the
    Jupiter project, as it’s rather useless and takes up valuable space in the *bin*
    directory. In the case of *your* projects, however, it’s more likely that a user
    would want to do a clean install of a newer version of the project or replace
    the test build they downloaded from the project website with a professionally
    packaged version that comes with their Linux distribution. Support for an `uninstall`
    target would be very helpful in situations like these.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
- en: '[Listings 3-23](ch03.xhtml#ch03ex23) and [3-24](ch03.xhtml#ch03ex24) show the
    addition of an `uninstall` target to our two makefiles.'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
- en: Git tag 3.8
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '*Listing 3-23:* Makefile: *Adding the `uninstall` target to the top-level makefile*'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: '*Listing 3-24:* src/Makefile: *Adding the `uninstall` target to the src-level
    makefile*'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
- en: As with the `install` target, this target requires root-level rights if the
    user is using a system prefix, such as */usr* or */usr/local*. You should be very
    careful about how you write your `uninstall` targets; unless a directory belongs
    specifically to your package, you shouldn’t assume you created it. If you do,
    you may end up deleting a system directory like */usr/bin*!
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
- en: On the other hand, we did create the directory in the `install` target if it
    was originally missing, so we should remove it if possible. Here, we can use the
    `rmdir` command, whose job it is to remove empty directories. Even if the directory
    is a system directory such as */usr/bin*, removing it is harmless if it’s empty,
    but `rmdir` will fail if it’s not empty. Recalling that command failure stops
    the `make` process, we’ll also prefix it with a dash character. And we don’t really
    want to see such a failure, so we’ll redirect it’s output to */dev/null*.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
- en: 'The list of things to maintain in our build system is getting out of hand.
    There are now two places we need to update when we change our installation processes:
    the `install` and `uninstall` targets. Unfortunately, this is really about the
    best we can hope for when writing our own makefiles, unless we resort to fairly
    complex shell script commands. But hang in there—in [Chapter 6](ch06.xhtml), I’ll
    show you how to rewrite this makefile in a much simpler way using GNU Automake.'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
- en: '*Testing Install and Uninstall*'
  id: totrans-242
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Now let’s add some code to our `distcheck` target to test the functionality
    of the `install` and `uninstall` targets. After all, it’s fairly important that
    both of these targets work correctly from our distribution tarballs, so we should
    test them in `distcheck` before declaring the tarball release worthy. [Listing
    3-25](ch03.xhtml#ch03ex25) illustrates the necessary changes to the top-level
    makefile.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
- en: Git tag 3.9
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: '*Listing 3-25:* Makefile: *Adding `distcheck` tests for the `install` and `uninstall`
    targets*'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
- en: Note that I used a double dollar sign on the `$${PWD}` variable references,
    ensuring that `make` passes the variable reference to the shell with the rest
    of the command line, rather than expanding it inline before executing the command.
    I wanted this variable to be dereferenced by the shell rather than by the `make`
    utility.^([24](footnote.xhtml#ch03fn24))
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
- en: What we’re doing here is testing to ensure the `install` and `uninstall` targets
    don’t generate errors—but this isn’t very likely because all they do is install
    files into a temporary directory within the build directory. We could add some
    code immediately after the `make` `install` command that looks for the products
    that are supposed to be installed, but that’s more than I’m willing to do. One
    reaches a point of diminishing returns, where the code that does the checking
    is just as complex as the installation code—in which case, the check becomes pointless.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
- en: 'But there is something else we can do: we can write a more or less generic
    test that checks to see if everything we installed was properly removed. Since
    the stage directory was empty before our installation, it had better be in a similar
    state after we uninstall. [Listing 3-26](ch03.xhtml#ch03ex26) shows the addition
    of this test.'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
- en: Git tag 3.10
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: '*Listing 3-26:* Makefile: *Adding a test for leftover files after `uninstall`
    finishes*'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
- en: The test first generates a numeric value at ➊ in a shell variable called `remaining`,
    which represents the number of regular files found in the stage directory we used.
    If this number is not zero, the test prints a message to the console at ➋ indicating
    how many files were left behind by the `uninstall` commands and then it exits
    with an error. Exiting early leaves the stage directory intact so we can examine
    it to find out which files we forgot to uninstall.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
- en: '*This test code represents a good use of multiple shell commands passed to
    a single shell. I had to do this here so that the value of *`remaining`* would
    be available for use by the *`if`* statement. Conditionals don’t work very well
    when the closing *`if`* is not executed by the same shell as the opening *`if`*!*'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
- en: I don’t want to alarm people by printing the embedded `echo` statement unless
    it really should be executed, so I prefixed the entire test with an at sign (`@`)
    so that `make` wouldn’t print the code to `stdout`. Since `make` considers these
    five lines of code a single command, the only way to suppress printing the `echo`
    statement is to suppress printing the entire command.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
- en: Now, this test isn’t perfect—not by a long shot. This code only checks for regular
    files. If your installation procedure creates any soft links, this test won’t
    notice if they’re left behind. The directory structure that’s built during installation
    is purposely left in place because the check code doesn’t know whether a subdirectory
    within the stage directory belongs to the system or to the project. The `uninstall`
    rule’s commands can be aware of which directories are project specific and properly
    remove them, but I don’t want to add project-specific knowledge into the `distcheck`
    tests—it’s that problem of diminishing returns again.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
- en: The Filesystem Hierarchy Standard
  id: totrans-258
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You may be wondering by now where I’m getting these directory names. What if
    some Unix system out there doesn’t use */usr* or */usr/local*? For one thing,
    this is another reason for providing the `prefix` variable—to allow the user some
    choice in these matters. However, most Unix-like systems nowadays follow the *Filesystem
    Hierarchy Standard (FHS)* as closely as possible. The *FHS* defines a number of
    standard places, including the following root-level directories:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
- en: '| */bin* | */etc* | */home* |'
  id: totrans-260
  prefs: []
  type: TYPE_TB
- en: '| */opt* | */sbin* | */srv* |'
  id: totrans-261
  prefs: []
  type: TYPE_TB
- en: '| */tmp* | */usr* | */var* |'
  id: totrans-262
  prefs: []
  type: TYPE_TB
- en: 'This list is by no means exhaustive. I’ve only mentioned the directories that
    are most relevant to our study of open source project build systems. In addition,
    the *FHS* defines several standard locations beneath these root-level directories.
    For instance, the */usr* directory should contain the following subdirectories:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
- en: '| */usr/bin* | */usr/include* | */usr/lib* |'
  id: totrans-264
  prefs: []
  type: TYPE_TB
- en: '| */usr/local* | */usr/sbin* | */usr/share* |'
  id: totrans-265
  prefs: []
  type: TYPE_TB
- en: '| */usr/src* |  |  |'
  id: totrans-266
  prefs: []
  type: TYPE_TB
- en: The */usr/local* directory should contain a structure very similar to that of
    the */usr* directory. The */usr/local* directory provides a location for software
    installation that overrides versions of the same packages installed in the */usr*
    directory structure, because system software updates often overwrite software
    in */usr* without prejudice. The */usr/local* directory structure allows a system
    administrator to decide which version of a package to use on their system because
    */usr/local/bin* may be (and usually is) added to the `PATH` before */usr/bin*.
    A fair amount of thought has gone into designing the *FHS*, and the GNU Autotools
    take full advantage of this consensus of understanding.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
- en: Not only does the *FHS* define these standard locations, but it also explains
    in detail what they’re for and what types of files should be kept there. All in
    all, the *FHS* leaves you, as project maintainer, just enough flexibility and
    choice to keep your life interesting but not enough to make you wonder whether
    you’re installing your files in the right places.^([25](footnote.xhtml#ch03fn25))
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
- en: Supporting Standard Targets and Variables
  id: totrans-269
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In addition to those I’ve already mentioned, the *GNU Coding Standards* lists
    some important targets and variables that you should support in your projects—mainly
    because your users will expect support for them.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
- en: Some of the chapters in the *GCS* document should be taken with a grain of salt
    (unless you’re actually working on a GNU-sponsored project). For example, you
    probably won’t care much about the C source code formatting suggestions in [Chapter
    5](ch05.xhtml) of the *GCS*. Your users certainly won’t care, so you can use whatever
    source code formatting style you wish.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
- en: That’s not to say that all of [Chapter 5](ch05.xhtml) is worthless to non-GNU
    open source projects. The “Portability between System Types” and “Portability
    between CPUs” subsections, for instance, provide excellent information on C source
    code portability. Also, the “Internationalization” subsection gives some useful
    tips on using GNU software to internationalize your projects. We’ll consider internationalization
    in greater detail in [Chapter 11](ch11.xhtml) of this book.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
- en: While [Chapter 6](ch06.xhtml) of the *GCS* discusses documentation the GNU way,
    some sections of [Chapter 6](ch06.xhtml) describe various top-level text files
    commonly found in projects, such as the *AUTHORS*, *NEWS*, *INSTALL*, *README*,
    and *ChangeLog* files. These are all bits of information that the well-indoctrinated
    open source software user expects to see in any reputable project.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
- en: The *really* useful information in the *GCS* document begins in [Chapter 7](ch07.xhtml),
    “The Release Process.” This chapter is critical to you as a project maintainer
    because it defines what your users will expect of your projects’ build systems.
    [Chapter 7](ch07.xhtml) contains the de facto standards for the user options that
    packages provide in source-level distributions.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
- en: '*Standard Targets*'
  id: totrans-275
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The “How Configuration Should Work” subsection of [Chapter 7](ch07.xhtml) of
    the *GCS* defines the configuration process, which I cover briefly in “Configuring
    Your Package” on [page 77](ch03.xhtml#page_77). The “Makefile Conventions” subsection
    of the *GCS* covers all of the standard targets and many of the standard variables
    that users have come to expect in open source software packages. Standard targets
    defined by the *GCS* include the following:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
- en: '| `all` | `install` | `install-html` |'
  id: totrans-277
  prefs: []
  type: TYPE_TB
- en: '| `install-dvi` | `install-pdf` | `install-ps` |'
  id: totrans-278
  prefs: []
  type: TYPE_TB
- en: '| `install-strip` | `uninstall` | `clean` |'
  id: totrans-279
  prefs: []
  type: TYPE_TB
- en: '| `distclean` | `mostlyclean` | `maintainer-clean` |'
  id: totrans-280
  prefs: []
  type: TYPE_TB
- en: '| `TAGS` | `info` | `dvi` |'
  id: totrans-281
  prefs: []
  type: TYPE_TB
- en: '| `html` | `pdf` | `ps` |'
  id: totrans-282
  prefs: []
  type: TYPE_TB
- en: '| `dist` | `check` | `installcheck` |'
  id: totrans-283
  prefs: []
  type: TYPE_TB
- en: '| `installdirs` |  |  |'
  id: totrans-284
  prefs: []
  type: TYPE_TB
- en: You don’t need to support all of these targets, but you should consider supporting
    the ones that make sense for your project. For example, if you build and install
    HTML pages, you should probably consider supporting the `html` and `install-html`
    targets. Autotools projects support these and more. Some targets are useful to
    end users, while others are useful only to project maintainers.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
- en: '*Standard Variables*'
  id: totrans-286
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Variables you should support as you see fit include those listed in the following
    table. In order to provide flexibility for the end user, most of these variables
    are defined in terms of a few of them and, ultimately, only one of them: `prefix`.
    For lack of a more standard name, I call these *prefix variables*. Most of these
    could be classified as *installation directory variables* that refer to standard
    locations, but there are a few exceptions, such as `srcdir`.'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
- en: These variables are meant to be fully resolved by `make`, so they’re defined
    in terms of `make` variables, using parentheses rather than curly brackets. [Table
    3-1](ch03.xhtml#ch03tab1) lists these prefix variables and their default values.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 3-1:** Prefix Variables and Their Default Values'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
- en: '| **Variable** | **Default Value** |'
  id: totrans-290
  prefs: []
  type: TYPE_TB
- en: '| `prefix` | /usr/local |'
  id: totrans-291
  prefs: []
  type: TYPE_TB
- en: '| `exec_prefix` | `$(prefix)` |'
  id: totrans-292
  prefs: []
  type: TYPE_TB
- en: '| `bindir` | `$(exec_prefix)`/bin |'
  id: totrans-293
  prefs: []
  type: TYPE_TB
- en: '| `sbindir` | `$(exec_prefix)`/sbin |'
  id: totrans-294
  prefs: []
  type: TYPE_TB
- en: '| `libexecdir` | `$(exec_prefix)`/libexec |'
  id: totrans-295
  prefs: []
  type: TYPE_TB
- en: '| `datarootdir` | `$(prefix)`/share |'
  id: totrans-296
  prefs: []
  type: TYPE_TB
- en: '| `datadir` | `$(datarootdir)` |'
  id: totrans-297
  prefs: []
  type: TYPE_TB
- en: '| `sysconfdir` | `$(prefix)`/etc |'
  id: totrans-298
  prefs: []
  type: TYPE_TB
- en: '| `sharedstatedir` | `$(prefix)`/com |'
  id: totrans-299
  prefs: []
  type: TYPE_TB
- en: '| `localstatedir` | `$(prefix)`/var |'
  id: totrans-300
  prefs: []
  type: TYPE_TB
- en: '| `includedir` | `$(prefix)/`include |'
  id: totrans-301
  prefs: []
  type: TYPE_TB
- en: '| `oldincludedir` | /usr/include |'
  id: totrans-302
  prefs: []
  type: TYPE_TB
- en: '| `docdir` | `$(datarootdir)`/doc/`$(package)` |'
  id: totrans-303
  prefs: []
  type: TYPE_TB
- en: '| `infodir` | `$(datarootdir)`/info |'
  id: totrans-304
  prefs: []
  type: TYPE_TB
- en: '| `htmldir` | `$(docdir)` |'
  id: totrans-305
  prefs: []
  type: TYPE_TB
- en: '| `dvidir` | `$(docdir)` |'
  id: totrans-306
  prefs: []
  type: TYPE_TB
- en: '| `pdfdir` | `$(docdir)` |'
  id: totrans-307
  prefs: []
  type: TYPE_TB
- en: '| `psdir` | `$(docdir)` |'
  id: totrans-308
  prefs: []
  type: TYPE_TB
- en: '| `libdir` | `$(exec_prefix)`/lib |'
  id: totrans-309
  prefs: []
  type: TYPE_TB
- en: '| `lispdir` | `$(datarootdir)`/emacs/site-lisp |'
  id: totrans-310
  prefs: []
  type: TYPE_TB
- en: '| `localedir` | `$(datarootdir)`/locale |'
  id: totrans-311
  prefs: []
  type: TYPE_TB
- en: '|  `mandir`  | `$(datarootdir)`/man |'
  id: totrans-312
  prefs: []
  type: TYPE_TB
- en: '| `man`*`N`*`dir` | `$(mandir)`/man*N* (*N* = 1..9) |'
  id: totrans-313
  prefs: []
  type: TYPE_TB
- en: '| `manext` | .1 |'
  id: totrans-314
  prefs: []
  type: TYPE_TB
- en: '| `man`*`N`*`ext` | .*N* (*N* = 1..9) |'
  id: totrans-315
  prefs: []
  type: TYPE_TB
- en: '| `srcdir` | The source-tree directory corresponding to the current directory
    in the build tree |'
  id: totrans-316
  prefs: []
  type: TYPE_TB
- en: Autotools-based projects support these and other useful variables automatically,
    as needed; Automake provides full support for them, while Autoconf’s support is
    more limited. If you write your own makefiles and build systems, you should support
    as many of these as you use in your build and installation processes.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
- en: '*Adding Location Variables to Jupiter*'
  id: totrans-318
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: To support the variables that we’ve used so far in the Jupiter project, we need
    to add the `bindir` variable, as well as any variables that it relies on—in this
    case, the `exec_prefix` variable. [Listings 3-27](ch03.xhtml#ch03ex27) and [3-28](ch03.xhtml#ch03ex28)
    show how to do this in the top-level and *src* directory makefiles.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
- en: Git tag 3.11
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-321
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: '*Listing 3-27:* Makefile: *Adding the `bindir` variable*'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-323
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: '*Listing 3-28:* src/Makefile: *Adding the `bindir` variable*'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
- en: Even though we only use `bindir` in *src/Makefile*, we have to export `prefix`,
    `exec_prefix`, and `bindir` because `bindir` is defined in terms of `exec_prefix`,
    which is itself defined in terms of `prefix`. When `make` runs the `install` commands,
    it will first resolve `bindir` to `$(exec_prefix)`*/bin*, then to `$(prefix)`*/bin*,
    and finally to */usr/local/bin*. Thus, *src/Makefile* needs to have access to
    all three variables during this process.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
- en: 'How do such recursive variable definitions make life better for the end user?
    After all, the user can change the root install location from */usr/local* to
    */usr* by simply typing the following:'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  id: totrans-327
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'The ability to change prefix variables at multiple levels is particularly useful
    to a Linux distribution packager (an employee or volunteer at a Linux company
    whose job it is to professionally package your project as a *.deb* or *.rpm* package)
    who needs to install packages into very specific system locations. For example,
    a distro packager could use the following command to change the installation prefix
    to */usr* and the system configuration directory to */etc*:'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  id: totrans-329
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Without the ability to change prefix variables at multiple levels, configuration
    files would end up in */usr/etc* because the default value of `$(sysconfdir)`
    is `$(prefix)`*/etc*.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
- en: Getting Your Project into a Linux Distro
  id: totrans-331
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When a Linux distro picks up your package for distribution, your project magically
    moves from the realm of tens of users to that of tens of thousands of users—almost
    overnight. Some people will be using your software without even knowing it. Since
    one great value of open source software for the developer is free help in making
    your software better, this can be seen as a good thing—a dramatic increase in
    community size.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
- en: By following the *GCS* within your build system, you remove many of the barriers
    to including your project in a Linux distro. If your tarball follows all the usual
    conventions, distro packagers will immediately know what to do with it. These
    packagers generally get to decide, based on needed functionality and their feelings
    about your package, whether it should be included in their flavor of Linux. Since
    they have a fair amount of power in this process, it behooves you to please them.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
- en: Section 7 of the *GCS* contains a small subsection that talks about supporting
    *staged installations*. It is easy to support this concept in your build system,
    but if you neglect to support it, it will almost always cause problems for packagers.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
- en: Packaging systems such as the Red Hat Package Manager (RPM) accept one or more
    tarballs, a set of patch files, and a specification file. The so-called *spec
    file* describes the process of building and packaging your project for a particular
    system. In addition, it defines all of the products installed into the target
    installation directory structure. The package manager software uses this information
    to install your package into a temporary directory, from which it then pulls the
    specified products, storing them in a special binary archive that the package
    installation program (for example, `rpm`) understands.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
- en: To support staged installation, all you need is a variable named `DESTDIR` that
    acts as a sort of super-prefix to all of your installed products. To show you
    how this is done, I’ll add staged installation support to the Jupiter project.
    This is so trivial that it requires only four changes to *src/Makefile*. The required
    changes are highlighted in [Listing 3-29](ch03.xhtml#ch03ex29).
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
- en: Git tag 3.12
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  id: totrans-338
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: '*Listing 3-29:* src/Makefile: *Adding staged build functionality*'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, I’ve added the `$(DESTDIR)` prefix to the `$(bindir)` references
    in the `install` and `uninstall` targets that refer to installation paths. You
    don’t need to define a default value for `DESTDIR`, because when it is left undefined,
    it expands to an empty string, which has no effect on the paths to which it’s
    prepended.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
- en: '*Do not add a slash after *`$(DESTDIR)`*, which is usually empty. The prefix
    variables ultimately resolve to something starting with a slash; adding a slash
    after *`$(DESTDIR)`* is therefore redundant and, in some situations, can cause
    unintended side effects.*'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
- en: I didn’t need to add `$(DESTDIR)` to the `uninstall` rule’s `rm` command for
    the sake of the package manager, because package managers don’t care how your
    package is uninstalled. They only install your package so they can copy the products
    from a stage directory. To uninstall the stage directory, package managers simply
    delete it. Package manager programs such as `rpm` use their own rules for removing
    products from a system, and these rules are based on a package manager database
    rather than your `uninstall` target.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
- en: However, for the sake of symmetry, and to be complete, it doesn’t hurt to add
    `$(DESTDIR)` to `uninstall`. Besides, we need it to be complete for the sake of
    the `distcheck` target, which we’ll now modify to take advantage of our staged
    installation functionality. This modification is shown in [Listing 3-30](ch03.xhtml#ch03ex30).
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
- en: Git tag 3.13
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  id: totrans-346
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: '*Listing 3-30:* Makefile: *Using `DESTDIR` in the `distcheck` target*'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
- en: Changing `prefix` to `DESTDIR` in the `install` and `uninstall` commands allows
    us to properly test a complete installation directory hierarchy, as we’ll see
    shortly.
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
- en: 'At this point, an RPM spec file could provide the following text as the installation
    commands for the Jupiter package:'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  id: totrans-350
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Don’t worry about package manager file formats. Instead, just focus on providing
    staged installation functionality through the `DESTDIR` variable.
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
- en: You may be wondering why the `prefix` variable couldn’t provide this functionality.
    For one thing, not every path in a system-level installation is defined relative
    to the `prefix` variable. The system configuration directory (`sysconfdir`), for
    instance, is often defined as */etc* by packagers. You can see in [Table 3-1](ch03.xhtml#ch03tab1)
    that the default definition of `sysconfdir` is `$(prefix)`*/etc*, so the only
    way `sysconfdir` would resolve to */etc* would be if you explicitly set it to
    do so on the `configure` or `make` command line. If you configured it that way,
    only a variable like `DESTDIR` would affect the base location of `sysconfdir`
    during staged installation. Other reasons for this will become clearer as we talk
    about project configuration later on in this chapter, and then again in the next
    two chapters.
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
- en: Build vs. Installation Prefix Overrides
  id: totrans-353
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'At this point, I’d like to digress slightly to explain an elusive (or at least
    nonobvious) concept regarding `prefix` and other path variables defined in the
    *GCS*. In the preceding examples, I used prefix overrides on the `make install`
    command line, like this:'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  id: totrans-355
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'The question I wish to address is: what is the difference between using a prefix
    override for `make all` and for `make install`? In our small sample makefiles,
    we’ve managed to avoid using prefixes in any targets not related to installation,
    so it may not be clear to you at this point that a prefix is *ever* useful during
    the build stage. However, prefix variables can be very useful during the build
    stage to substitute paths into source code at compile time, as shown in [Listing
    3-31](ch03.xhtml#ch03ex31).'
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  id: totrans-357
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: '*Listing 3-31: Substituting paths into source code at compile time*'
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
- en: In this example, I’m defining a C-preprocessor variable called `CFGDIR` on the
    compiler command line for use by *main.c*. Presumably, there’s some code in *main.c*
    like that shown in [Listing 3-32](ch03.xhtml#ch03ex32).
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  id: totrans-360
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: '*Listing 3-32: Substituting `CFGDIR` at compile time*'
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
- en: Later in the code, you might use the C global variable `cfgdir` to access the
    application’s configuration file.
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
- en: Linux distro packagers often use different prefix overrides for build and install
    command lines in RPM spec files. During the build stage, the actual runtime directories
    are hardcoded into the executable using commands like the `./configure` command
    shown in [Listing 3-33](ch03.xhtml#ch03ex33).
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  id: totrans-364
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: '*Listing 3-33: The portion of an RPM spec file that builds the source tree*'
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
- en: Note that we have to explicitly specify `sysconfdir` along with `prefix`, because,
    as I mentioned earlier, the system configuration directory is usually outside
    of the `prefix` directory structure. The package manager installs these executables
    into a stage directory so it can then copy them out of their installed locations
    when it builds the binary installation package. The corresponding installation
    commands might look like those shown in [Listing 3-34](ch03.xhtml#ch03ex34).
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  id: totrans-367
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: '*Listing 3-34: The installation portion of an RPM spec file*'
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
- en: Using `DESTDIR` during installation will temporarily override *all* installation
    prefix variables, so you don’t have to remember which variables you’ve overridden
    during configuration. Given the configuration command shown in [Listing 3-33](ch03.xhtml#ch03ex33),
    using `DESTDIR` in the manner shown in [Listing 3-34](ch03.xhtml#ch03ex34) has
    the same effect as the code shown in [Listing 3-35](ch03.xhtml#ch03ex35).
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  id: totrans-370
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: '*Listing 3-35: Overriding the default `sysconfdir` during installation*'
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
- en: '**WARNING**'
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
- en: '*The key point here is one that I touched on earlier. Never write your install
    target to build all or even part of your products in your makefiles. Installation
    functionality should be limited to copying files, if possible. Otherwise, your
    users won’t be able to access your staged installation features if they are using
    prefix overrides.*'
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
- en: Another reason for limiting installation functionality in this way is that it
    allows the user to install sets of packages as a group into an isolated location
    and then create links to the actual files in the proper locations. Some people
    like to do this when they are testing out a package and want to keep track of
    all its components.^([26](footnote.xhtml#ch03fn26))
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
- en: 'One final point: if you’re installing into a system directory hierarchy, you’ll
    need *root* permissions. People often run `make install` like this:'
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  id: totrans-376
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: If your `install` target depends on your build targets, and you’ve neglected
    to build them beforehand, `make` will happily build your program before installing
    it—but the local copies will all be owned by *root*. This inconvenience is easily
    avoided by having `make install` fail for lack of things to install, rather than
    jumping right into a build while running as *root*.
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
- en: User Variables
  id: totrans-378
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The *GCS* defines a set of variables that are sacred to the user. These variables
    should be *referenced* by a GNU build system but never *modified* by a GNU build
    system. These so-called *user variables* include those listed in [Table 3-2](ch03.xhtml#ch03tab2)
    for C and C++ programs.
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 3-2:** Some User Variables and Their Purposes'
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
- en: '| Variables | Purpose |'
  id: totrans-381
  prefs: []
  type: TYPE_TB
- en: '| `CC` | A reference to the system C compiler |'
  id: totrans-382
  prefs: []
  type: TYPE_TB
- en: '| `CFLAGS` | Desired C compiler flags |'
  id: totrans-383
  prefs: []
  type: TYPE_TB
- en: '| `CXX` | A reference to the system C++ compiler |'
  id: totrans-384
  prefs: []
  type: TYPE_TB
- en: '|  `CXXFLAGS`  | Desired C++ compiler flags |'
  id: totrans-385
  prefs: []
  type: TYPE_TB
- en: '| `LDFLAGS` | Desired linker flags |'
  id: totrans-386
  prefs: []
  type: TYPE_TB
- en: '| `CPPFLAGS` | Desired C/C++ preprocessor flags |'
  id: totrans-387
  prefs: []
  type: TYPE_TB
- en: '| *`--snip--`* |  |'
  id: totrans-388
  prefs: []
  type: TYPE_TB
- en: This list is by no means comprehensive, and interestingly, there isn’t a comprehensive
    list to be found in the *GCS*. In fact, most of these variables come from the
    documentation for the `make` utility itself. These variables are used in the built-in
    rules of the `make` utility—they’re somewhat hardcoded into `make`, so they are
    effectively defined by `make`. You can find a fairly complete list of program
    name and flag variables in the “Variables Used by Implicit Rules” section of the
    *GNU Make Manual*.
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
- en: Note that `make` assigns default values for many of these variables based on
    common Unix utility names. For example, the default value of `CC` is `cc`, which
    (at least on Linux systems) is a soft link to the GCC C compiler (`gcc`). On other
    systems, `cc` is a soft link to the system’s own compiler. Thus, we don’t need
    to set `CC` to `gcc`, which is good, because GCC may not be installed on non-Linux
    platforms. There may be times when you do wish to set `CC` on the `make` command
    line, such as when using an alternative compiler like `clang` or when using the
    `ccache` utility to cache `gcc` results for faster recompilation.
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
- en: For our purposes, the variables shown in [Table 3-2](ch03.xhtml#ch03tab2) are
    sufficient, but for a more complex makefile, you should become familiar with the
    larger list outlined in the *GNU Make Manual*.
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
- en: To use these variables in our makefiles, we’ll just replace `gcc` with `$(CC)`.
    We’ll do the same for `CFLAGS` and `CPPFLAGS`, although `CPPFLAGS` will be empty
    by default. The `CFLAGS` variable has no default value either, but this is a good
    time to add one. I like to use `-g` to build objects with symbols and `-O0` to
    disable optimizations for debug builds. The updates to *src/Makefile* are shown
    in [Listing 3-36](ch03.xhtml#ch03ex36).
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
- en: Git tag 3.14
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  id: totrans-394
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: '*Listing 3-36:* src/Makefile: *Adding appropriate user variables*'
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
- en: 'This works because the `make` utility allows such variables to be overridden
    by options on the command line. For example, to switch compilers and set some
    compiler command line options, a user need only type the following:'
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  id: totrans-397
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'In this case, our user has decided to use the `ccache` utility instead of `gcc`,
    generate debug symbols, and optimize their code using level-two optimizations.
    They’ve also decided to enable the `test` option through the use of a C-preprocessor
    definition. Note that these variables are set on the `make` command line; this
    apparently equivalent Bourne-shell syntax will not work as expected:'
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  id: totrans-399
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: The reason is that we’re merely setting environment variables in the local environment
    passed to the `make` utility by the shell. Remember that environment variables
    do not automatically override those set in the makefile. To get the functionality
    we want, we could use a little GNU `make`–specific syntax in our makefile, as
    shown in [Listing 3-37](ch03.xhtml#ch03ex37).
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  id: totrans-401
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: '*Listing 3-37: Using the GNU `make`–specific query-assign operator (`?=`) in
    a makefile*'
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
- en: The `?=` operator is a GNU `make`–specific operator, which will only set the
    variable in the makefile if it hasn’t already been set elsewhere. This means we
    can now override these particular variable settings by setting them in the environment.
    But don’t forget that this will only work in GNU `make`. In general, it’s better
    to set `make` variables on the `make` command line.
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
- en: Nonrecursive Build Systems
  id: totrans-404
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Now that we’ve spent all this time creating the perfect build system for our
    project, let’s take a look at a *more perfect* solution—a nonrecursive system.
    I mentioned at the start of this chapter that there was a problem with recursive
    builds that we’d discuss at a later point.
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
- en: The fundamental problem with recursive build systems is that they artificially
    introduce flaws into `make`’s directed graph—the set of rules `make` uses to determine
    what depends on what and when something needs to be rebuilt. For Jupiter, very
    little can go wrong because there’s one top-level makefile invoking `make` on
    a single subdirectory makefile, but let’s consider a more complex project where
    multiple submodules, nested arbitrarily deeply, are interdependent upon each other
    in more complex ways.
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
- en: With a single makefile, the one `make` process can “see the big picture.” That
    is, it can see and understand all of the interdependencies in the system, and
    it can create a DAG that properly represents all of the inter­dependencies among
    all of the filesystem objects within the project. With multiple makefiles, each
    child `make` process executed by parent `make` can see only a portion of the dependency
    graph. Ultimately, this can cause `make` to build products out of order so that
    a product that depends on prerequisites not within its own purview is built before
    those prerequisites are updated.
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
- en: 'The preceding problem is compounded when you use *parallel* *`make`* by adding
    `-j` to the `make` command line. The `-j` option tells `make` to examine its DAG
    and find places where portions of the DAG do not depend on each other, then execute
    those portions at the same time. On a multiprocessor system, this can dramatically
    speed up the build process for large projects. However, this causes problems from
    two different angles. First, since `make` can’t see the whole picture, it can
    make incorrect assumptions about what things can be done in parallel. Second,
    as far as the top-level `make` is concerned, child `make` processes are all independent
    and can be run in parallel, which we can easily see is simply not true. For an
    example that does not even rely on the differences between recursive and nonrecursive
    build systems, consider the following command line:'
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  id: totrans-409
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: As far as `make` is concerned, `clean` and `all` are 100 percent independent
    of each other, so `make` will happily run them both at the same time. Even a novice
    can see the problems with this assumption. The point is, `make` doesn’t understand
    the high-level relationship between `clean` and `all`. That relationship is understood
    only by the author of the makefile. Similar barriers to `make`’s understanding
    of the big picture are artificially introduced at the boundaries between parent
    and child `make` invocations in a recursive build system.
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
- en: So, how hard is it to turn Jupiter’s recursive build system into a nonrecursive
    system? We want to maintain modularity, so we still want a *Makefile* in each
    directory that essentially manages the tasks of that directory. This is easily
    accomplished by using another feature of common `make`—the `include` directive.
    The `include` directive allows us to break up our single, parent-level makefile
    into chunks of directory-specific rules and then include just those snippets in
    the top-level makefile. [Listing 3-38](ch03.xhtml#ch03ex38) shows what the complete
    updated top-level makefile looks like.
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
- en: Git tag 3.15
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  id: totrans-413
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: '*Listing 3-38:* Makefile: *A nonrecursive version of the top-level makefile*'
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
- en: Three changes were made here, but please note that the only really significant
    change made to this makefile was the replacement of the rule at ➋ where recursion
    was done with a single rule for `all`, `clean`, `check`, `install`, `uninstall`,
    and an explicit `jupiter` target. Even this replacement could have been a simple
    deletion if we hadn’t cared that the new default target would have become `dist`,
    had we not added the `all` target at this location. I’ve also added an explicit
    `jupiter` target that maps to `src/jupiter` to maintain feature parity with the
    previous system.
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
- en: The second change made was to include the *src*-level makefile at ➌. Finally,
    I also commented out the `export` statements at ➊ because we no longer need to
    export variables to child `make` processes; they’re left as comments simply for
    illustration.
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
- en: Now, let’s examine what changed in the *src*-level makefile. The complete, updated
    version is shown in [Listing 3-39](ch03.xhtml#ch03ex39).
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  id: totrans-418
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: '*Listing 3-39:* src/Makefile: *A nonrecursive version of the src-level makefile*'
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
- en: First, the `all` target was removed. We don’t need one here now because this
    makefile is not intended to be executed directly but, rather, included by the
    parent makefile. Hence, we do not need a default target. Second, all references
    to objects in the *src* directory are now referenced by paths that are relative
    to the parent directory. Again, this is because `make` is executed only once from
    the parent directory, so references to objects in the *src* directory must be
    considered relative to where `make` is running—the parent directory.
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
- en: We also removed the `.PHONY` directive at the bottom because this directive
    contained a proper subset of the `.PHONY` directive in the parent makefile, making
    the directive redundant. In short, we merely converted this makefile into a snippet
    that could be included in the parent makefile, removed redundancies, and ensured
    that all filesystem references are now made relative to the parent directory.
    I hope you can see that these changes actually constitute a simplification of
    what we had before. Intuitively, it seems more complicated but it is actually
    simpler.
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
- en: This makefile is a more accurate and faster version of our recursive system.
    I say “this makefile” because there is really only one makefile here—the included
    file can be pasted directly into the parent makefile at the point of inclusion
    (at ➋ in [Listing 3-38](ch03.xhtml#ch03ex38)), just as with inclusions of header
    files in C-language source files. Ultimately, after all the inclusions are resolved,
    there are only one makefile and one `make` process that executes commands based
    on the rules in that makefile.
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
- en: One apparent drawback of nonrecursive build systems is that you cannot simply
    enter `make` while sitting in the *src* directory and build the portion of the
    project related to that directory. Instead, you have to change into the parent
    directory and run `make`, which builds everything. But this, too, is a fallacious
    concern because you’ve always had the ability to execute any portion of the build
    system you wished by specifying exactly the target you desired on the `make` command
    line. The difference is that now what gets built is actually what should get built
    because `make` understands the entire set of dependencies for any given target
    you command it to build.
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
- en: As we’ll see in the coming chapters, Automake has full support for nonrecursive
    build systems. I encourage you to start writing your next project build system
    in a nonrecursive fashion because it can seem like an overwhelming task to retrofit
    an existing system, even though, as we’ve seen here, it’s not really all that
    difficult.
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
- en: Configuring Your Package
  id: totrans-425
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The *GCS* describes the configuration process in the “How Configuration Should
    Work” subsection of Section 7\. Up to this point, we’ve been able to do about
    everything we’ve wanted to with Jupiter using only makefiles, so you might be
    wondering what configuration is actually for. The opening paragraphs of this subsection
    in the *GCS* answer our question:'
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
- en: Each GNU distribution should come with a shell script named `configure`. This
    script is given arguments which describe the kind of machine and system you want
    to compile the program for. The `configure` script must record the configuration
    options so that they affect compilation.
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
- en: The description here is the specification of the interface for the `configure`
    script in GNU packages. Many packages implement it using GNU Autoconf (see “Introduction”
    in Autoconf) and/or GNU Automake (see “Introduction” in Automake), but you do
    not have to use these tools. You can implement it any way you like; for instance,
    by making `configure` be a wrapper around a completely different configuration
    system.
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
- en: Another way for the `configure` script to operate is to make a link from a standard
    name such as *config.h* to the proper configuration file for the chosen system.
    If you use this technique, the distribution should *not* contain a file named
    *config.h*. This is so that people won’t be able to build the program without
    configuring it first.
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
- en: Another thing that `configure` can do is to edit the *Makefile*. If you do this,
    the distribution should *not* contain a file named *Makefile*. Instead, it should
    include a file *Makefile.in* which contains the input used for editing. Once again,
    this is so that people won’t be able to build the program without configuring
    it first.^([27](footnote.xhtml#ch03fn27))
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
- en: 'So then, the primary tasks of a typical configuration script are as follows:'
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
- en: Generate files from templates containing replacement variables.
  id: totrans-432
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Generate a C-language header file (*config.h*) for inclusion by project source
    code.
  id: totrans-433
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Set user options for a particular `make` environment (debug flags and so on).
  id: totrans-434
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Set various package options as environment variables.
  id: totrans-435
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Test for the existence of tools, libraries, and header files.
  id: totrans-436
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For complex projects, configuration scripts often generate the project makefiles
    from one or more templates maintained by project developers. These templates contain
    configuration variables in a format that is easy to recognize (and substitute).
    The configuration script replaces these variables with values determined during
    the configuration process—either from command line options specified by the user
    or from a thorough analysis of the platform environment. This analysis entails
    such things as checking for the existence of certain system or package header
    files and libraries, searching various filesystem paths for required utilities
    and tools, and even running small programs designed to indicate the feature set
    of the shell, C compiler, or desired libraries.
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
- en: The tool of choice for variable replacement has, in the past, been the `sed`
    stream editor. A simple `sed` command can replace all the configuration variables
    in a makefile template in a single pass through the file. However, Autoconf versions
    2.62 and newer prefer `awk` to `sed` for this process. The `awk` utility is almost
    as pervasive as `sed` these days, and it provides more functionality to allow
    for efficient replacement of many variables. For our purposes on the Jupiter project,
    either of these tools would suffice.
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-439
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We have now created a complete project build system by hand, with one important
    exception: we haven’t designed a `configure` script according to the design criteria
    specified in the *GNU Coding Standards*. We could do this, but it would take a
    dozen more pages of text to build one that even comes close to conforming to these
    specifications. Still, there are a few key build features related specifically
    to the makefiles that the *GCS* indicates are desirable. Among these is the concept
    of vpath building. This is an important feature that can be properly illustrated
    only by actually writing a configuration script that works as specified by the
    *GCS*.'
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
- en: Rather than spend the time and effort to do this now, I’d like to simply move
    on to a discussion of Autoconf in [Chapter 4](ch04.xhtml), which will allow us
    to build one of these configuration scripts in as little as two or three lines
    of code. With that behind us, it will be trivial to add vpath building and other
    common Autotools features to the Jupiter project.
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
