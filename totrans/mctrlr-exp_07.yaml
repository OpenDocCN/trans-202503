- en: '**7 RF430 Backdoors**'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: It’s not uncommon to find that an unlisted chip is actually a commercially available
    chip with a custom ROM. Such is the RF430TAL152, which is pretty much an RF430FRL152
    with a mask ROM that implements a blood glucose monitor in sensors sold under
    the Freestyle Libre brand.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we’ll discuss a backdoor in the RF430TAL152, first documented
    in Goodspeed and Apvrille (2019). We’ll begin with the freely available FRL152
    variant of the chip, then explore the TAL152 variant, its custom commands, and
    a backdoor.
  prefs: []
  type: TYPE_NORMAL
- en: '**RF430FRL152, Commercial Variant**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Both the TAL152 and the FRL152 have sensor applications in 7kB of masked ROM
    at `0x4400`. Neither of the chips contains flash memory; instead, they use a new
    memory technology called ferroelectric RAM, FRAM for short. Like flash memory,
    it’s non-volatile and the contents survive without power. Like SRAM, it’s very
    power efficient to write this memory.
  prefs: []
  type: TYPE_NORMAL
- en: Minor patches against the ROM are loaded into two kilobytes of FRAM at `0xF840`.
    A small second region of FRAM exists at `0x1A00`, holding a serial number and
    calibration values.
  prefs: []
  type: TYPE_NORMAL
- en: FRAM is a weird memory, so let’s quickly review its properties. At the lowest
    levels, writes take very little power and most bits survive for decades without
    power. Like DRAM and core memory, reads are destructive.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/f0078-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7.1: RF430TAL152 Surface'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/f0079-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7.2: RF430FRL152 Delayered'
  prefs: []
  type: TYPE_NORMAL
- en: Destructive reads and the occasional bit error would be a deal-breaker, so a
    memory controller corrects this with automated write-backs, error correction,
    and caching. At the higher levels, a programmer can pretend that it’s RAM, and
    the only contradicting evidence would be that sometimes reads take a little more
    time and a little more power than writes do. Isn’t that sweet?
  prefs: []
  type: TYPE_NORMAL
- en: The chip has a bit more SRAM than you might expect, 4kB of it at `0x4400`. SRAM
    is executable on the MSP430 architecture, and it can be mapped in place of half
    the ROM in order to develop custom ROMs. A developer could also store normal code
    in SRAM, at the risk of it being obliterated by a power failure.
  prefs: []
  type: TYPE_NORMAL
- en: Because changes to ROM require expensive mask revisions and fresh manufacturing,
    both the commercial and the custom ROM support patches in FRAM. These patches
    hook entries in a table of function pointers, redirecting calls from the ROM version
    of a function to its replacement in FRAM.
  prefs: []
  type: TYPE_NORMAL
- en: As the FRAM is used not just for code but also for data, it’s sort of a window
    into the remaining address space of the chip, and the first step to a full dump.
    You’ll see this later in the chapter, when we get around to exploiting a locked
    TAL152 chip.
  prefs: []
  type: TYPE_NORMAL
- en: The FRL152 can be read and written by JTAG at the frustratingly modern voltage
    of 1.5V. Texas Instruments helpfully sells a development kit, part number RF430FRL152HEVM,
    that includes level conversion to the 3.3V supported by their debugger tool. This
    allows the ROM to be extracted and disassembled from the commercial variant of
    the chip.
  prefs: []
  type: TYPE_NORMAL
- en: The RF430TAL152 in Freestyle Libre glucose sensors has a different ROM, and
    JTAG connections fail, but it speaks the same NFC Type V protocol, standardized
    as ISO 15693\. This protocol is well supported by Android, and poorly supported
    by USB readers on Linux, so it’s in the awkward position of being more easily
    exploited by a cellphone app than by a laptop!
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/f0081-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7.3: RF430FRL152 Memory Map'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/f0081-02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7.4: RF430FRL152 Carrier Board'
  prefs: []
  type: TYPE_NORMAL
- en: '**NFC-V from Android**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Let’s take a brief interruption to discuss how NFC tags work in Android and
    how to write a tool to communicate wirelessly with the RF430.
  prefs: []
  type: TYPE_NORMAL
- en: In Android, NFC Type V tags are accessed through the class `android.nfc.tech.NfcV`,
    whose `transceive()` function sends a byte array to the tag and returns the result.
    As tags have such wildly varying properties as their command sets, block sizes
    and addressing modes, these raw commands are used rather than higher-level wrappers.
  prefs: []
  type: TYPE_NORMAL
- en: NFC-V transactions begin with an option byte, which is usually `02`. Next comes
    a command byte and the optional command parameters. An explicit address can be
    stuck in the middle if indicated by the option byte. Commands above `A0` require
    the manufacturer’s number to follow, which for TI is `07`. See [Figure 7.5](ch07.xhtml#ch7fig5)
    for some example commands.
  prefs: []
  type: TYPE_NORMAL
- en: You can try out the low-level commands yourself in the NFC Tools app, whose
    Other/Advanced tab accepts raw commands after a scary disclaimer. Just set the
    I/O Class to `NfcV` and then send the following examples, before using them to
    implement our own high level functions for the chip.
  prefs: []
  type: TYPE_NORMAL
- en: We’ll get into more commands later, but for now you should pay attention to
    the general format. Here, `20` is the standard command to read a block from an
    8-bit block address and `C0` is the secret vendor command to read a block from
    a 16-bit block address. The first byte of each reply is zero for success, non-zero
    for failure.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/f0082-01.jpg)![Image](../images/f0083-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7.5: NFC-V Command Verbs'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/f0083-02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7.6: Example TAL152 Commands'
  prefs: []
  type: TYPE_NORMAL
- en: The `C0` (read) command and matching `C1` (write) command accept a 16-bit address,
    but they are still confined to a subset of FRAM and SRAM. In the next section,
    we’ll see how to write some shellcode into the FRL152 and then execute it as a
    way to implement a truly arbitrary read.
  prefs: []
  type: TYPE_NORMAL
- en: '**Shellcode on the FRL152**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: FRAM on the FRL152 might contain a table of command handlers. If this table
    is found, its entries are copied onto an array of function pointers near the beginning
    of SRAM. Further, the `C0` and `C1` commands allow us to freely read and write
    SRAM, so there’s plenty of control for remote code execution on the chip.
  prefs: []
  type: TYPE_NORMAL
- en: While we could overwrite the call stack, it is much easier to overwrite the
    function pointer table in early SRAM with a pointer to our function, because we
    can only perform writes of 4 or 8 bytes at a time.
  prefs: []
  type: TYPE_NORMAL
- en: There are plenty of functions to choose from, and an ideal hook would be one
    that won’t be missed by normal functions. We’d also prefer to have continuation
    wherever possible, so that executing the code doesn’t crash our target.
  prefs: []
  type: TYPE_NORMAL
- en: The function pointer we’ll overwrite is at `0x1C5C` in SRAM, pointing to `rom_rf13_senderror()`
    in ROM at `0x4FF6`. For proper continuation, the shellcode must write two bytes
    to the `RF13MTXF` peripheral and then return. Without these bytes, the protocol
    will be violated and a Java exception will be triggered. To unhook, we just write
    `0x4FF6` to `0x1C5C`, restoring the original handler.
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 7.7](ch07.xhtml#ch7fig7) shows my Java method for executing shellcode
    at an arbitrary address and returning two bytes to the caller. These bytes happen
    to be necessary for continuation, but it’s always nice to get a little feedback
    from an exploit.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/f0085-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7.7: Executing Shellcode in the RF430FRL152'
  prefs: []
  type: TYPE_NORMAL
- en: '**RF430TAL152, Medical Variant**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The TAL152 glucose sensor is very similar in layout and appearance to the off-the-shelf
    FRL152, with the difference being the contents of mask ROM and the JTAG configuration.
    In this section, we’ll trace the long road from first examining this chip to finally
    dumping its ROM and then writing custom firmware to FRAM.
  prefs: []
  type: TYPE_NORMAL
- en: When first experimenting with the chip, we find that there is one extra block
    of FRAM exposed by NFC. Every last page is write protected, and we cannot change
    any of them with the standard write command, `21`. The `C0` and `C1` vendor commands
    from the FRL152 do not exist here, so we also lack a convenient way to mess around
    with out-of-bounds memory.
  prefs: []
  type: TYPE_NORMAL
- en: But all is not lost! There is a table of function pointers on the final page,
    and the value of the reset vector at the very end of memory tells us that this
    ROM is different from the FRL152, so we know that the two devices have different
    software in their ROMs.
  prefs: []
  type: TYPE_NORMAL
- en: This table is in the portion of memory that is readable by NFC, so we can use
    a handy smartphone to read it. It is, however, write protected, so we’re not yet
    able to write patches to the table. We’re sadly unable to read the lower portions
    of FRAM, or any of ROM or SRAM at this point.
  prefs: []
  type: TYPE_NORMAL
- en: We see the table from [Figure 7.9](ch07.xhtml#ch7fig9), which begins at `0xFFCE`
    with the magic word `0xABAB` and then grows downward to the same word at a lower
    address, `0xFFB8`.^([1](footnotes.xhtml#ch7fn1)) Each entry in this table is a
    custom vendor command, and we see that much like the `C0` and `C1` commands that
    have been so handy on the FRL152, the TAL152 has commands `A0`, `A1`, `A2`, `A3`,
    and `A4`. The `A1` and `A3` handlers are in FRAM, where we can read at least part
    of their code.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/f0087-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7.8: RF430FRL152 FRAM Command Table'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/f0087-02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7.9: RF430TAL152 FRAM Command Table'
  prefs: []
  type: TYPE_NORMAL
- en: The table ends early, of course, with `E0`, `E1`, and `E2` being disabled by
    `E0`’s command number having been overwritten by the table end marker. These commands
    were available at some point in the manufacturing process, and we can read their
    command handlers from FRAM, but we cannot execute them.
  prefs: []
  type: TYPE_NORMAL
- en: Calling these functions is a bit disappointing. `A1` returns the device status
    of some sort, but the other `Ax` commands don’t even grace us with an error message
    in reply. The reason for this is hard to see from the partial assembly, but we
    later learned that they require a safety password.
  prefs: []
  type: TYPE_NORMAL
- en: Not yet being able to run the `A3` command, we read its disassembly. The function
    begins by calling another function at `0x1C20` and then proceeds to read a raw
    address and length before sending the requested number of 16-bit words out the
    RF13M peripheral to the reader.^([2](footnotes.xhtml#ch7fn2)) If we could just
    call this command, we could dump the ROM and reverse engineer the behavior of
    the other commands!
  prefs: []
  type: TYPE_NORMAL
- en: '**Sniffing the Readers**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: To get the password without already having a firmware dump, we had to sniff
    a legitimate reader’s attempts to call any `Ax` command other than `A1`, so that
    we could learn the password and then use `A3` to dump raw memory. We found this
    both by tapping the SPI bus of the manufacturer’s dedicated hardware reader and
    separately by observing the vendor’s Android app in Frida.^([3](footnotes.xhtml#ch7fn3))
  prefs: []
  type: TYPE_NORMAL
- en: The 32-bit password, `C2AD7521`, came as a parameter to the `A0` command, which
    initializes the glucose sensor after injection into a patient’s arm. Trying this
    same password in `A3`, followed by an address and length, gave us the ability
    to read raw memory. Sending this command in a loop gave complete dumps of ROM
    and SRAM, as well as a complete dump of the FRAM regions. These regions are not
    exposed by the standard read command, `20`, which takes a block address.
  prefs: []
  type: TYPE_NORMAL
- en: '**Inside the TAL152 ROM**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Loading this complete dump into Ghidra shows that the ROM is related to that
    of the FRL152, but that they have diverged quite a bit. The TAL152 implements
    no vendor commands directly; rather, they must be added through the patch table.
  prefs: []
  type: TYPE_NORMAL
- en: We also lacked the ability to write to FRAM, as it was write protected. Sure
    enough, `A2` write protects every FRAM page that is exposed by NFC, and `A4` unlocks
    those same pages! A list of commands is found in [Figure 7.5](ch07.xhtml#ch7fig5).
  prefs: []
  type: TYPE_NORMAL
- en: Calling the `A4` command, we can then unlock pages and begin mucking around.
    A simple write to `0xFFB8` will re-enable the `Ex` commands, allowing us to experiment
    with restoring old sensors. Or we can compile our own firmware to run inside of
    the TAL152, turning a glucose sensor into something entirely different.
  prefs: []
  type: TYPE_NORMAL
- en: '**Some Other Unlocking Techniques**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: While trying to dump the TAL152, we hit a few dead ends that might possibly
    work for you on other targets.
  prefs: []
  type: TYPE_NORMAL
- en: We can’t make a connection, but the JTAG of the TAL152 appears to be unlocked
    if it follows the same convention as the FRL152\. This might very well be caused
    by a custom activation key, but whether it is a different locking mechanism or
    a different key, we were unable to get a connection. I’ve since heard that the
    bonding wires go to different pins on the TAL152, and that a connection can be
    made by adjusting them, but I’ve not confirmed that in my own lab.
  prefs: []
  type: TYPE_NORMAL
- en: We tried to wipe these chips back to a factory setting by raising them above
    their Curie point. Our theory was that the heat might erase FRAM while preserving
    ROM, so that ROM would be freely read.
  prefs: []
  type: TYPE_NORMAL
- en: Texas Instruments Application Report SLAA526A, *MSP430 FRAM Quality and Reliability*,
    leads us to believe this temperature is near 430 ^°C. Short experiments involving
    a hot air gun and strong magnets were unsuccessful, but we hope someday to bake
    a chip in a kiln for many hours to look for bit failures.
  prefs: []
  type: TYPE_NORMAL
- en: Test pins on the chip aroused our curiosity, as other chips use them to enter
    a bootloader and these chips might use them to reset to a factory state. This
    could be as effective as overheating the FRAM, without the hassles of extreme
    temperatures.
  prefs: []
  type: TYPE_NORMAL
- en: It’s worth noting that our successful method—using the `A3` command with the
    manufacturer’s password—can be accomplished *either* by tapping the hardware reader’s
    SPI bus *or* by reading that same password out of the manufacturer’s Android application.
    In reverse engineering, any technique that works is a good one, and there’s often
    more than one way to win the game.
  prefs: []
  type: TYPE_NORMAL
