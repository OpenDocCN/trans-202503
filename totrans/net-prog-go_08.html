<html><head></head><body>
<section>&#13;
<header>&#13;
<h1 class="chapter">&#13;
<span class="ChapterNumber"><span epub:type="pagebreak" id="Page_119" title="119"/>6</span><br/>&#13;
<span class="ChapterTitle">Ensuring UDP Reliability</span>&#13;
</h1>&#13;
</header>&#13;
<figure class="opener">&#13;
<img alt="" src="image_fi/book_art/chapterart.png"/>&#13;
</figure>&#13;
<p class="ChapterIntro"><span class="xref" itemid="xref_target_Chapter 5">Chapter 5</span> introduced basic network applications using UDP and demonstrated the flexibility of Go’s <code>net</code> package and interfaces for writing portable code. This chapter picks up where the last one left off to introduce one method of ensuring reliability when communicating over UDP.</p>&#13;
<p>This chapter starts by introducing an application protocol built on top of UDP. We’ll cover a subset of types used by this protocol and demonstrate how they are used to reliably transfer data. We’ll then implement a server that allows clients to download files using the application protocol. Finally, we’ll download a file from our server and verify its integrity.</p>&#13;
<h2 id="h1-500884c06-0001">Reliable File Transfers Using TFTP</h2>&#13;
<p class="BodyFirst">As discussed in the preceding chapter, UDP is inherently unreliable. That means it’s your application’s job to make the UDP connection reliable. <span epub:type="pagebreak" id="Page_120" title="120"/>Since we spent the last chapter covering UDP and how it’s best used in situations that require a subset of TCP features, it’s only appropriate that we look at an example of such an application-level protocol. </p>&#13;
<p>The <em>Trivial File Transfer Protocol (TFTP)</em> is an example of an application protocol that ensures reliable data transfers over UDP. It allows two nodes to transfer files over UDP by implementing a subset of the features that make TCP reliable. A TFTP server implements ordered packet delivery, acknowledgments, and retransmissions. To distill this example down to the essential bits, your server allows clients to download binary data only. It does not support uploads, American Standard Code for Information Interchange (ASCII) transfers, or some of the later additions to TFTP specified outside RFC 1350. Your server expediently serves the same file, no matter what file the client requests, in the name of simplicity.</p>&#13;
<p>Please keep in mind that TFTP is not appropriate for secure file transmission. Though it adds reliability to UDP connections, it does not support encryption or authentication. If your application requires communication over UDP, you may want to use WireGuard (<a class="LinkURL" href="https://github.com/WireGuard/wireguard-go/">https://github.com/WireGuard/wireguard-go/</a>), an application that allows for secure communication over UDP.</p>&#13;
<p>The next few sections will implement a read-only TFTP server to teach you the basics of adding reliability to UDP. By <em>read-only</em>, I mean your server will allow clients to only download files, not upload them. You will start by defining the subset of constants and types your TFTP server supports. You will encapsulate as much of the type-related logic in each type’s methods. You’ll then implement the TFTP server portion of the code that will interact with clients and use the types we define to facilitate reliable file transfers.</p>&#13;
<h2 id="h1-500884c06-0002">TFTP Types</h2>&#13;
<p class="BodyFirst">Your TFTP server will accept read requests from the client, send data packets, transmit error packets, and accept acknowledgments from the client. To do this, you must define a few types in your code to represent client requests, transmitted data, acknowledgments, and errors. <a href="#listing6-1" id="listinganchor6-1">Listing 6-1</a> outlines key types used to cap packet sizes, identify operations, and codify various errors. </p>&#13;
<pre><code>package tftp&#13;
&#13;
import (&#13;
    "bytes"&#13;
    "encoding/binary"&#13;
    "errors"&#13;
    "io"&#13;
    "strings"&#13;
)&#13;
&#13;
const (&#13;
    DatagramSize = <span class="CodeAnnotation">1</span>516 // the maximum supported datagram size&#13;
    BlockSize = <span class="CodeAnnotation">2</span>DatagramSize – 4 // the DatagramSize minus a 4-byte header&#13;
)&#13;
&#13;
<span epub:type="pagebreak" id="Page_121" title="121"/><span class="CodeAnnotationHang">3</span> type OpCode uint16&#13;
&#13;
const (&#13;
    OpRRQ OpCode = iota + 1&#13;
    _            // no WRQ support&#13;
    OpData&#13;
    OpAck&#13;
    OpErr&#13;
)&#13;
&#13;
<span class="CodeAnnotationHang">4</span> type ErrCode uint16&#13;
&#13;
const (&#13;
    ErrUnknown ErrCode = iota&#13;
    ErrNotFound&#13;
    ErrAccessViolation&#13;
    ErrDiskFull&#13;
    ErrIllegalOp&#13;
    ErrUnknownID&#13;
    ErrFileExists&#13;
    ErrNoUser&#13;
)</code></pre>&#13;
<p class="CodeListingCaption"><a id="listing6-1">Listing 6-1</a>: Types and codes used by the TFTP server (<em>types.go</em>)</p>&#13;
<p>TFTP limits datagram packets to 516 bytes or fewer to avoid fragmentation. You define two constants to enforce the datagram size limit <span class="CodeAnnotation">1</span> and the maximum data block size <span class="CodeAnnotation">2</span>. The maximum block size is the datagram size minus a 4-byte header. The first 2 bytes of a TFTP packet’s header is an operation code <span class="CodeAnnotation">3</span>. </p>&#13;
<p>Each operation code is a 2-byte, unsigned integer. Your server supports four operations: a read request (RRQ), a data operation, an acknowledgment, and an error. Since your server is read-only, you skip the write request (WRQ) definition.</p>&#13;
<p>As with the operation codes, you define a series of unsigned 16-bit integer error codes <span class="CodeAnnotation">4</span> per the RFC. Although you don’t use all error codes in your server since it allows only downloads, a client could return these error codes in lieu of an acknowledgment packet. </p>&#13;
<p>The following sections detail the types that implement your server’s four supported operations.</p>&#13;
<h3 id="h2-500884c06-0001">Read Requests</h3>&#13;
<p class="BodyFirst">The server receives a <em>read request</em> packet when the client wants to download a file. The server must then respond with either a data packet or an error packet, both of which you’ll look at in the next few sections. Either packet serves as an acknowledgment to the client that the server received the read request. If the client does not receive a data or error packet, it may retransmit the read request until the server responds or the client gives up.</p>&#13;
<p><a href="#figure6-1" id="figureanchor6-1">Figure 6-1</a> illustrates the structure of a read request packet.</p>&#13;
<span epub:type="pagebreak" id="Page_122" title="122"/><figure>&#13;
<img alt="f06001" src="image_fi/500884c06/f06001.png"/>&#13;
<figcaption><p><a id="figure6-1">Figure 6-1</a>: Read request packet structure</p></figcaption>&#13;
</figure>&#13;
<p>The read request packet consists of a 2-byte operation code, a filename, a null byte, a mode, and a trailing null byte. An <em>operation code</em> is an integer that is unique to each of your operation types. Each type’s operation code corresponds to the integer detailed in RFC 1350. For example, a read request’s operation code is 1. The filename and mode are strings of varying lengths. The mode indicates to the server how it should send the file: netascii or octet. If a client requests a file using the <em>netascii</em> mode, the client must convert the file to match its own line-ending format. For our purposes, you will accept only the <em>octet</em> mode, which tells the server to send the file in a binary format, or as is.</p>&#13;
<p><a href="#listing6-2" id="listinganchor6-2">Listing 6-2</a> is a continuation of <a href="#listing6-1">Listing 6-1</a>. Here, you define the read request and its method that allows the server to marshal the request into a slice of bytes in preparation for writing to a network connection.</p>&#13;
<pre><code><var>--snip--</var>&#13;
&#13;
<span class="CodeAnnotationHang">1</span> type ReadReq struct {&#13;
    Filename string&#13;
    Mode     string&#13;
}&#13;
&#13;
// Although not used by our server, a client would make use of this method.&#13;
func (q ReadReq) MarshalBinary() ([]byte, error) {&#13;
    mode := "octet"&#13;
    if q.Mode != "" {&#13;
        mode = q.Mode&#13;
    }&#13;
&#13;
    // operation code + filename + 0 byte + mode + 0 byte&#13;
    cap := 2 + 2 + len(q.Filename) + 1 + len(q.Mode) + 1&#13;
&#13;
    b := new(bytes.Buffer)&#13;
    b.Grow(cap)&#13;
&#13;
    err := <span class="CodeAnnotation">2</span>binary.Write(b, binary.BigEndian, OpRRQ) // write operation code&#13;
    if err != nil {&#13;
        return nil, err&#13;
    }&#13;
&#13;
    _, err = b.WriteString(q.Filename) // write filename&#13;
    if err != nil {&#13;
        return nil, err&#13;
    }&#13;
&#13;
    err = <span class="CodeAnnotation">3</span>b.WriteByte(0) // write 0 byte&#13;
    if err != nil {&#13;
<span epub:type="pagebreak" id="Page_123" title="123"/>        return nil, err&#13;
    }&#13;
&#13;
    _, err = b.WriteString(mode) // write mode&#13;
    if err != nil {&#13;
        return nil, err&#13;
    }&#13;
&#13;
    err = <span class="CodeAnnotation">3</span>b.WriteByte(0) // write 0 byte&#13;
    if err != nil {&#13;
        return nil, err&#13;
    }&#13;
&#13;
    return b.Bytes(), nil&#13;
}</code></pre>&#13;
<p class="CodeListingCaption"><a id="listing6-2">Listing 6-2</a>: Read request and its binary marshaling method (<em>types.go</em> continued)</p>&#13;
<p>The struct representing your read request <span class="CodeAnnotation">1</span> needs to keep track of the filename and the mode. You insert the operation code <span class="CodeAnnotation">2</span> and null bytes <span class="CodeAnnotation">3</span> into the buffer while marshaling the packet to a byte slice.</p>&#13;
<p><a href="#listing6-3" id="listinganchor6-3">Listing 6-3</a> continues where <a href="#listing6-2">Listing 6-2</a> left off and rounds out the read request’s implementation by defining a method that allows the server to unmarshal a read request from a byte slice, typically read from a network connection with a client.</p>&#13;
<pre><code><var>--snip--</var>&#13;
&#13;
func (q *ReadReq) <span class="CodeAnnotation">1</span>UnmarshalBinary(p []byte) error {&#13;
    r := bytes.NewBuffer(p)&#13;
&#13;
    var code OpCode&#13;
&#13;
    err := <span class="CodeAnnotation">2</span>binary.Read(r, binary.BigEndian, &amp;code) // read operation code&#13;
    if err != nil {&#13;
        return err&#13;
    }&#13;
&#13;
    if code != OpRRQ {&#13;
        return errors.New("invalid RRQ")&#13;
    }&#13;
&#13;
    q.Filename, err = <span class="CodeAnnotation">3</span>r.ReadString(0) // read filename&#13;
    if err != nil {&#13;
        return errors.New("invalid RRQ")&#13;
    }&#13;
&#13;
    q.Filename = <span class="CodeAnnotation">4</span>strings.TrimRight(q.Filename, "\x00") // remove the 0-byte&#13;
    if len(q.Filename) == 0 {&#13;
        return errors.New("invalid RRQ")&#13;
    }&#13;
&#13;
    q.Mode, err = r.ReadString(0) // read mode&#13;
    if err != nil {&#13;
<span epub:type="pagebreak" id="Page_124" title="124"/>        return errors.New("invalid RRQ")&#13;
    }&#13;
&#13;
    q.Mode = strings.TrimRight(q.Mode, "\x00") // remove the 0-byte&#13;
    if len(q.Mode) == 0 {&#13;
        return errors.New("invalid RRQ")&#13;
    }&#13;
&#13;
    actual := strings.ToLower(q.Mode) // enforce octet mode&#13;
    if actual != "octet" {&#13;
        return errors.New("only binary transfers supported")&#13;
    }&#13;
&#13;
    return nil&#13;
}</code></pre>&#13;
<p class="CodeListingCaption"><a id="listing6-3">Listing 6-3</a>: Read request type implementation (<em>types.go</em> continued)</p>&#13;
<p>Your TFTP server’s read request, data, acknowledgment, and error packets all implement the <code>encoding.BinaryMarshaler</code> and <code>encoding.BinaryUnmarshaler</code> interfaces. These methods allow your types to marshal themselves to a binary format suitable for transmission over the network and from network bytes back into the original types. For example, the read request type can marshal itself into a byte slice that matches the read request format showed in <a href="#figure6-1">Figure 6-1</a> by using its <code>MarshalBinary</code> method from <a href="#listing6-2">Listing 6-2</a>. Likewise, it can constitute itself from a byte slice read from the network using its <code>UnmarshalBinary</code> method <span class="CodeAnnotation">1</span>. Although your server does not send a read request and make use of its <code>MarshalBinary</code> method, I encourage you to write a TFTP client that will marshal a read request to its binary form as you progress through this chapter. I leave it as an exercise for you to implement.</p>&#13;
<p>The <code>UnmarshalBinary</code> method returns <code>nil</code> only if the given byte slice matches the read request format. If you are unsure of whether a given byte slice is a read request, you can pass the byte slice to this method and make that determination based on the return value. You will see this in action when you look at the server code.</p>&#13;
<p>The <code>UnmarshalBinary</code> method reads in the first 2 bytes <span class="CodeAnnotation">2</span> and confirms the operation code is that of a read request. It then reads all bytes up to the first null byte <span class="CodeAnnotation">3</span> and strips the null byte delimiter <span class="CodeAnnotation">4</span>. The resulting string of bytes represents the filename. Similarly, you read in the mode, returning <code>nil</code> if everything is as expected. The server can then use the populated <code>ReadReq</code> to retrieve the requested file for the client.</p>&#13;
<h3 id="h2-500884c06-0002">Data Packets</h3>&#13;
<p class="BodyFirst">Clients receive <em>data packets</em> in response to their read requests, provided the server was able to retrieve the requested file. The server sends the file in a series of data packets, each of which has an assigned block number, starting at 1 and incrementing with every subsequent data packet. The block number allows the client to properly order the received data and account for duplicates. </p>&#13;
<p><span epub:type="pagebreak" id="Page_125" title="125"/>All data packets have a payload of 512 bytes except for the last packet. The client continues to read data packets until it receives a data packet whose payload is less than 512 bytes, indicating the end of the transmission. At any point, the client can return an error packet in place of an acknowledgment, and the server can return an error packet instead of a data packet. An error packet immediately terminates the transfer.</p>&#13;
<p><a href="#figure6-2" id="figureanchor6-2">Figure 6-2</a> shows the format of a data packet.</p>&#13;
<figure>&#13;
<img alt="f06002" src="image_fi/500884c06/f06002.png"/>&#13;
<figcaption><p><a id="figure6-2">Figure 6-2</a>: Data packet structure</p></figcaption>&#13;
</figure>&#13;
<p>Like the read request packet, the data packet’s first 2 bytes contain its operation code. The next 2 bytes represent the block number. The remaining bytes, up to 512, are the payload.</p>&#13;
<p>The server requires an acknowledgment from the client after each data packet. If the server does not receive a timely acknowledgment or an error from the client, the server will retry the transmission until it receives a reply or exhausts its number of retries. <a href="#figure6-3" id="figureanchor6-3">Figure 6-3</a> illustrates the initial communication between a client downloading a file from a TFTP server.</p>&#13;
<figure>&#13;
<img alt="f06003" src="image_fi/500884c06/f06003.png"/>&#13;
<figcaption><p><a id="figure6-3">Figure 6-3</a>: Downloading a file by using the Trivial File Transfer Protocol</p></figcaption>&#13;
</figure>&#13;
<p>Once the client has sent the initial read request packet, the server responds with the first block of data. Next, the client acknowledges receipt of block 1. The server receives the acknowledgment and replies with the second block of data. But in this contrived example, the server does not receive a timely reply from the client, so it resends block 2. The client receives block 2 and sends its acknowledgment. This back-and-forth continues until the server sends the last block with a payload of fewer than 512 bytes.</p>&#13;
<p><span epub:type="pagebreak" id="Page_126" title="126"/><a href="#listing6-4" id="listinganchor6-4">Listing 6-4</a> details the data type that is used for the actual data transfer.</p>&#13;
<pre><code><var>--snip--</var>&#13;
&#13;
<span class="CodeAnnotationHang">1</span> type Data struct {&#13;
    Block   uint16&#13;
    Payload io.Reader&#13;
}&#13;
&#13;
<span class="CodeAnnotationHang">2</span> func (d *Data) MarshalBinary() ([]byte, error) {&#13;
    b := new(bytes.Buffer)&#13;
    b.Grow(DatagramSize)&#13;
&#13;
    d.Block++ // block numbers increment from 1&#13;
&#13;
    err := binary.Write(b, binary.BigEndian, OpData) // write operation code&#13;
    if err != nil {&#13;
        return nil, err&#13;
    }&#13;
&#13;
    err = binary.Write(b, binary.BigEndian, d.Block) // write block number&#13;
    if err != nil {&#13;
        return nil, err&#13;
    }&#13;
&#13;
    // write up to BlockSize worth of bytes&#13;
    _, err = <span class="CodeAnnotation">3</span>io.CopyN(b, d.Payload, BlockSize)&#13;
    if err != nil &amp;&amp; err != io.EOF {&#13;
        return nil, err&#13;
    }&#13;
&#13;
    return b.Bytes(), nil&#13;
}</code></pre>&#13;
<p class="CodeListingCaption"><a id="listing6-4">Listing 6-4</a>: Data type and its binary marshaling method (<em>types.go</em> continued)</p>&#13;
<p>The <code>Data</code> struct <span class="CodeAnnotation">1</span> keeps track of the current block number and the data source. In this case, your payload is an <code>io.Reader</code> instead of a byte slice, the reasoning being that an <code>io.Reader</code> allows greater flexibility about where you retrieve the payload. You could just as easily use an <code>*os.File</code> object to read a file from the filesystem as you could use a <code>net.Conn</code> to read the data from another network connection. The <code>io.Reader</code> interface gives you options that a simple byte slice doesn’t. You’re relying on the reader to keep track of the bytes left to read, eliminating a lot of code you’d otherwise have to write.</p>&#13;
<p>Every call to <code>MarshalBinary</code><span class="CodeAnnotation">2</span> will return 516 bytes per call at most by relying on the <code>io.CopyN</code> function <span class="CodeAnnotation">3</span> and the <code>BlockSize</code> constant. Since you want <code>MarshalBinary</code> to modify the state, you need to use a pointer receiver. The intention is that the server can keep calling this method to get sequential blocks of data, each with an increasing block number, from the <code>io.Reader</code> until it exhausts the reader. Just like the client, the server needs to monitor <span epub:type="pagebreak" id="Page_127" title="127"/>the packet size returned by this method. When the packet size is less than 516 bytes, the server knows it received the last packet and should stop calling <code>MarshalBinary</code>. You’ll see this in action in the server code later in this chapter.</p>&#13;
<p>You may have recognized the potential for an integer overflow of the 16-bit, unsigned block number. If you send a payload larger than about 33.5MB (65,535 × 512 bytes), the block number will overflow back to 0. Your server will happily continue sending data packets, but the client may not be as graceful handling the overflow. You should consider mitigating overflow risks by limiting the file size the TFTP server will support so as not to trigger the overflow, recognizing that an overflow can occur and determining whether it is acceptable to the client, or using a different protocol altogether.</p>&#13;
<p><a href="#listing6-5" id="listinganchor6-5">Listing 6-5</a> finishes up the data type implementation with its binary unmarshaling method. This method follows the code in <a href="#listing6-4">Listing 6-4</a>.</p>&#13;
<pre><code><var>--snip--</var>&#13;
&#13;
func (d *Data) UnmarshalBinary(p []byte) error {&#13;
    <span class="CodeAnnotationHang">1</span> if l := len(p); l &lt; 4 || l &gt; DatagramSize {&#13;
        return errors.New("invalid DATA")&#13;
    }&#13;
&#13;
    var opcode&#13;
&#13;
    err := <span class="CodeAnnotation">2</span>binary.Read(bytes.NewReader(p[:2]), binary.BigEndian, &amp;opcode)&#13;
    if err != nil || opcode != OpData {&#13;
        return errors.New("invalid DATA")&#13;
    }&#13;
&#13;
    err = <span class="CodeAnnotation">3</span>binary.Read(bytes.NewReader(p[2:4]), binary.BigEndian, &amp;d.Block)&#13;
    if err != nil {&#13;
        return errors.New("invalid DATA")&#13;
    }&#13;
&#13;
    d.Payload = <span class="CodeAnnotation">4</span>bytes.NewBuffer(p[4:])&#13;
&#13;
    return nil&#13;
}</code></pre>&#13;
<p class="CodeListingCaption"><a id="listing6-5">Listing 6-5</a>: Data type implementation (<em>types.go</em> continued)</p>&#13;
<p>To unmarshal data, you perform an initial sanity check <span class="CodeAnnotation">1</span> to determine whether the packet size is within the expected bounds, making it worth reading the remaining bytes. You then read the operation code <span class="CodeAnnotation">2</span> and check it, then the block number <span class="CodeAnnotation">3</span>. Finally, you stuff the remaining bytes into a new buffer <span class="CodeAnnotation">4</span> and assign it to the <code>Payload</code> field.</p>&#13;
<p>The client uses the block number to send a corresponding acknowledgment to the server and to properly order this block of data among the other received blocks of data.</p>&#13;
<h3 id="h2-500884c06-0003"><span epub:type="pagebreak" id="Page_128" title="128"/>Acknowledgments</h3>&#13;
<p class="BodyFirst"><em>Acknowledgment packets</em> are only 4 bytes long, as shown in <a href="#figure6-4" id="figureanchor6-4">Figure 6-4</a>. </p>&#13;
<figure>&#13;
<img alt="f06004" src="image_fi/500884c06/f06004.png"/>&#13;
<figcaption><p><a id="figure6-4">Figure 6-4</a>: Acknowledgment packet structure</p></figcaption>&#13;
</figure>&#13;
<p>As in the other types, the first 2 bytes represent the operation code. The final 2 bytes contain the number of the acknowledged block.</p>&#13;
<p><a href="#listing6-6" id="listinganchor6-6">Listing 6-6</a> shows the entire implementation of the acknowledgment type, which follows <a href="#listing6-5">Listing 6-5</a>’s code.</p>&#13;
<pre><code><var>--snip--</var>&#13;
&#13;
<span class="CodeAnnotationHang">1</span> type Ack uint16&#13;
&#13;
func (a Ack) MarshalBinary() ([]byte, error) {&#13;
    cap := 2 + 2 // operation code + block number&#13;
&#13;
    b := new(bytes.Buffer)&#13;
    b.Grow(cap)&#13;
&#13;
    err := binary.Write(b, binary.BigEndian, OpAck) // write operation code&#13;
    if err != nil {&#13;
        return nil, err&#13;
    }&#13;
&#13;
    err = binary.Write(b, binary.BigEndian, a) // write block number&#13;
    if err != nil {&#13;
        return nil, err&#13;
    }&#13;
&#13;
    return b.Bytes(), nil&#13;
}&#13;
&#13;
func (a *Ack) UnmarshalBinary(p []byte) error {&#13;
    var code OpCode&#13;
&#13;
    r := bytes.NewReader(p)&#13;
&#13;
    err := binary.Read(r, binary.BigEndian, &amp;code) // read operation code&#13;
    if err != nil {&#13;
        return err&#13;
    }&#13;
&#13;
    if code != OpAck {&#13;
        return errors.New("invalid ACK")&#13;
    }&#13;
&#13;
<span epub:type="pagebreak" id="Page_129" title="129"/>    return binary.Read(r, binary.BigEndian, a) // read block number&#13;
}</code></pre>&#13;
<p class="CodeListingCaption"><a id="listing6-6">Listing 6-6</a>: Acknowledgment type implementation (<em>types.go</em> continued)</p>&#13;
<p>You represent an acknowledgment packet by using a 16-bit, unsigned integer <span class="CodeAnnotation">1</span>. This integer is set to the acknowledged block number. The <code>MarshalBinary</code> and <code>UnmarshalBinary</code> methods should look familiar by this point. They handle marshaling the operation code and block number to a byte slice and populating an <code>Ack</code> object from bytes read from the network, respectively.</p>&#13;
<h3 id="h2-500884c06-0004">Handling Errors</h3>&#13;
<p class="BodyFirst">In TFTP, clients and servers convey errors by using an <em>error packet</em>, illustrated in <a href="#figure6-5" id="figureanchor6-5">Figure 6-5</a>.</p>&#13;
<figure>&#13;
<img alt="f06005" src="image_fi/500884c06/f06005.png"/>&#13;
<figcaption><p><a id="figure6-5">Figure 6-5</a>: Error packet structure</p></figcaption>&#13;
</figure>&#13;
<p>Error packets consist of a 2-byte operation code, a 2-byte error code, an error message of variable length, and a terminating null byte.</p>&#13;
<p><a href="#listing6-7" id="listinganchor6-7">Listing 6-7</a> details the error type and its binary marshal method, a continuation of <a href="#listing6-6">Listing 6-6</a>. </p>&#13;
<pre><code><var>--snip--</var>&#13;
&#13;
<span class="CodeAnnotationHang">1</span> type Err struct {&#13;
    Error   ErrCode&#13;
    Message string&#13;
}&#13;
&#13;
func (e Err) MarshalBinary() ([]byte, error) {&#13;
    // operation code + error code + message + 0 byte&#13;
    cap := 2 + 2 + len(e.Message) + 1&#13;
&#13;
    b := new(bytes.Buffer)&#13;
    b.Grow(cap)&#13;
&#13;
    err := binary.Write(b, binary.BigEndian, OpErr) // write operation code&#13;
    if err != nil {&#13;
        return nil, err&#13;
    }&#13;
&#13;
    err = binary.Write(b, binary.BigEndian, e.Error) // write error code&#13;
    if err != nil {&#13;
        return nil, err&#13;
    }&#13;
&#13;
    _, err = b.WriteString(e.Message) // write message&#13;
    if err != nil {&#13;
<span epub:type="pagebreak" id="Page_130" title="130"/>        return nil, err&#13;
    }&#13;
&#13;
    err = b.WriteByte(0) // write 0 byte&#13;
    if err != nil {&#13;
        return nil, err&#13;
    }&#13;
&#13;
    return b.Bytes(), nil&#13;
}</code></pre>&#13;
<p class="CodeListingCaption"><a id="listing6-7">Listing 6-7</a>: Error type used for conveying errors between the client and server (<em>types.go</em> continued)</p>&#13;
<p>Like the read request, the error type <span class="CodeAnnotation">1</span> contains the minimum data required to craft an error packet: an error code and an error message. The <code>MarshalBinary</code> method populates a bytes buffer following the byte sequence detailed in <a href="#figure6-5">Figure 6-5</a>.</p>&#13;
<p><a href="#listing6-8" id="listinganchor6-8">Listing 6-8</a> completes the error type implementation with its binary unmarshaler method. This code is appended to the code in <a href="#listing6-7">Listing 6-7</a>.</p>&#13;
<pre><code><var>--snip--</var>&#13;
&#13;
func (e *Err) UnmarshalBinary(p []byte) error {&#13;
    r := bytes.NewBuffer(p)&#13;
&#13;
    var code OpCode&#13;
&#13;
    err := <span class="CodeAnnotation">1</span>binary.Read(r, binary.BigEndian, &amp;code) // read operation code&#13;
    if err != nil {&#13;
        return err&#13;
    }&#13;
&#13;
    if code != OpErr {&#13;
        return errors.New("invalid ERROR")&#13;
    }&#13;
&#13;
    err = <span class="CodeAnnotation">2</span>binary.Read(r, binary.BigEndian, &amp;e.Error) // read error message&#13;
    if err != nil {&#13;
        return err&#13;
    }&#13;
&#13;
    e.Message, err = <span class="CodeAnnotation">3</span>r.ReadString(0)&#13;
    e.Message = <span class="CodeAnnotation">4</span>strings.TrimRight(e.Message, "\x00") // remove the 0-byte&#13;
&#13;
    return err&#13;
}</code></pre>&#13;
<p class="CodeListingCaption"><a id="listing6-8">Listing 6-8</a>: Error type’s binary unmarshaler implementation (<em>types.go</em> continued)</p>&#13;
<p>The <code>UnmarshalBinary</code> method is quite simple in that it reads and verifies the operation code <span class="CodeAnnotation">1</span>, consumes the error code <span class="CodeAnnotation">2</span> and error message <span class="CodeAnnotation">3</span>, and strips the trailing null byte <span class="CodeAnnotation">4</span>.</p>&#13;
<h2 id="h1-500884c06-0003"><span epub:type="pagebreak" id="Page_131" title="131"/>The TFTP Server</h2>&#13;
<p class="BodyFirst">Now you’ll write the server code, which will use the types you defined to interact with TFTP clients. </p>&#13;
<h3 id="h2-500884c06-0005">Writing the Server Code</h3>&#13;
<p class="BodyFirst"><a href="#listing6-9" id="listinganchor6-9">Listing 6-9</a> describes your server type and the methods that allow it to serve incoming requests. The fact that your packet types implement the <code>encoding.BinaryMarshaler</code> and <code>encoding.BinaryUnmarshaler</code> interfaces means that your server code can act as a conduit between the network interface and these types, leading to simpler code. All your server must concern itself with is transferring byte slices between your types and the network connection. The logic in the type interfaces takes care of the rest.</p>&#13;
<pre><code>package tftp&#13;
&#13;
import (&#13;
    "bytes"&#13;
    "errors"&#13;
    "fmt"&#13;
    "log"&#13;
    "net"&#13;
    "time"&#13;
)&#13;
&#13;
type Server struct {&#13;
    <span class="CodeAnnotationHang">1</span> Payload []byte // the payload served for all read requests&#13;
    <span class="CodeAnnotationHang">2</span> Retries uint8 // the number of times to retry a failed transmission&#13;
    <span class="CodeAnnotationHang">3</span> Timeout time.Duration // the duration to wait for an acknowledgment&#13;
}&#13;
&#13;
func (s Server) ListenAndServe(addr string) error {&#13;
    conn, err := net.ListenPacket("udp", addr)&#13;
    if err != nil {&#13;
        return err&#13;
    }&#13;
    defer func() { _ = conn.Close() }()&#13;
&#13;
    log.Printf("Listening on %s ...\n", conn.LocalAddr())&#13;
&#13;
    return s.Serve(conn)&#13;
}&#13;
&#13;
func (s *Server) <span class="CodeAnnotation">4</span>Serve(conn net.PacketConn) error {&#13;
    if conn == nil {&#13;
        return errors.New("nil connection")&#13;
    }&#13;
&#13;
    if s.Payload == nil {&#13;
        return errors.New("payload is required")&#13;
    }&#13;
&#13;
<span epub:type="pagebreak" id="Page_132" title="132"/>    if s.Retries == 0 {&#13;
        s.Retries = 10&#13;
    }&#13;
&#13;
    if s.Timeout == 0 {&#13;
        s.Timeout = 6 * time.Second&#13;
    }&#13;
&#13;
    var rrq ReadReq&#13;
&#13;
    for {&#13;
        buf := make([]byte, DatagramSize)&#13;
&#13;
        _, addr, err := conn.ReadFrom(buf)&#13;
        if err != nil {&#13;
            return err&#13;
        }&#13;
&#13;
        err = <span class="CodeAnnotation">5</span>rrq.UnmarshalBinary(buf)&#13;
        if err != nil {&#13;
            log.Printf("[%s] bad request: %v", addr, err)&#13;
            continue&#13;
        }&#13;
&#13;
        <span class="CodeAnnotationHang">6</span> go s.handle(addr.String(), rrq)&#13;
    }&#13;
}</code></pre>&#13;
<p class="CodeListingCaption"><a id="listing6-9">Listing 6-9</a>: Server type implementation (<em>server.go</em>)</p>&#13;
<p>Our server maintains a payload <span class="CodeAnnotation">1</span> that it returns for every read request, a record of the number of times to attempt packet delivery <span class="CodeAnnotation">2</span>, and a time-out duration between each attempt <span class="CodeAnnotation">3</span>. The server’s <code>Serve</code> method accepts a <code>net.PacketConn</code> and uses it to read incoming requests <span class="CodeAnnotation">4</span>. Closing the network connection will cause the method to return.</p>&#13;
<p>The server reads up to 516 bytes from its connection and attempts to unmarshal the bytes to a <code>ReadReq</code> object <span class="CodeAnnotation">5</span>. Since your server is read-only, it’s interested only in servicing read requests. If the data read from the connection is a read request, the server passes it along to a handler method in a goroutine <span class="CodeAnnotation">6</span>. We’ll define that next.</p>&#13;
<h3 id="h2-500884c06-0006">Handling Read Requests</h3>&#13;
<p class="BodyFirst">The handler (<a href="#listing6-10" id="listinganchor6-10">Listing 6-10</a>) accepts read requests from the client and replies with the server’s payload. It uses the features you built into your TFTP server’s type system to improve the reliability of the data transfer over UDP. The handler sends one data packet and waits for an acknowledgment from the client before sending another data packet. It also attempts to retransmit the current data packet when it fails to receive a timely reply from the client.</p>&#13;
<span epub:type="pagebreak" id="Page_133" title="133"/><pre><code><var>--snip--</var>&#13;
&#13;
<span class="CodeAnnotationHang">1</span> func (s Server) handle(clientAddr string, rrq ReadReq) {&#13;
    log.Printf("[%s] requested file: %s", clientAddr, rrq.Filename)&#13;
&#13;
    conn, err := <span class="CodeAnnotation">2</span>net.Dial("udp", clientAddr)&#13;
    if err != nil {&#13;
        log.Printf("[%s] dial: %v", clientAddr, err)&#13;
        return&#13;
    }&#13;
    defer func() { _ = conn.Close() }()&#13;
&#13;
    var (&#13;
        ackPkt  Ack&#13;
        errPkt  Err&#13;
        dataPkt = <span class="CodeAnnotation">3</span>Data{Payload: bytes.NewReader(s.Payload)}&#13;
        buf     = make([]byte, DatagramSize)&#13;
    )&#13;
&#13;
NEXTPACKET:&#13;
    <span class="CodeAnnotationHang">4</span> for n := DatagramSize; n == DatagramSize; {&#13;
        data, err := dataPkt.MarshalBinary()&#13;
        if err != nil {&#13;
            log.Printf("[%s] preparing data packet: %v", clientAddr, err)&#13;
            return&#13;
        }&#13;
&#13;
    RETRY:&#13;
        <span class="CodeAnnotationHang">5</span> for i := s.Retries; i &gt; 0; i-- {&#13;
            <span class="CodeAnnotationHang">6</span> n, err = conn.Write(data) // send the data packet&#13;
            if err != nil {&#13;
                log.Printf("[%s] write: %v", clientAddr, err)&#13;
                return&#13;
            }&#13;
&#13;
            // wait for the client's ACK packet&#13;
            _ = conn.SetReadDeadline(time.Now().Add(s.Timeout))&#13;
&#13;
            _, err = conn.Read(buf)&#13;
            if err != nil {&#13;
                if nErr, ok := err.(net.Error); ok &amp;&amp; nErr.Timeout() {&#13;
                    continue RETRY&#13;
                }&#13;
&#13;
                log.Printf("[%s] waiting for ACK: %v", clientAddr, err)&#13;
                return&#13;
            }&#13;
&#13;
            switch {&#13;
            case ackPkt.UnmarshalBinary(buf) == nil:&#13;
                <span class="CodeAnnotationHang">7</span> if uint16(ackPkt) == dataPkt.Block {&#13;
                    // received ACK; send next data packet&#13;
                    continue NEXTPACKET&#13;
<span epub:type="pagebreak" id="Page_134" title="134"/>                }&#13;
            case errPkt.UnmarshalBinary(buf) == nil:&#13;
                log.Printf("[%s] received error: %v",&#13;
                    clientAddr, errPkt.Message)&#13;
                return&#13;
            default:&#13;
                log.Printf("[%s] bad packet", clientAddr)&#13;
            }&#13;
        }&#13;
&#13;
        log.Printf("[%s] exhausted retries", clientAddr)&#13;
        return&#13;
    }&#13;
&#13;
    log.Printf("[%s] sent %d blocks", clientAddr, dataPkt.Block)&#13;
}</code></pre>&#13;
<p class="CodeListingCaption"><a id="listing6-10">Listing 6-10</a>: Handling read requests (<em>server.go</em> continued)</p>&#13;
<p>This handler is a method <span class="CodeAnnotation">1</span> on your <code>Server</code> type that accepts a client address and a read request. It’s defined as a method because you need access to the <code>Server</code>’s fields. You then initiate a connection with the client by using <code>net.Dial</code><span class="CodeAnnotation">2</span>. The resulting UDP connection object created with <code>net.Dial</code>, if you remember, will read only packets from the client, freeing you from having to check the sender address on every <code>Read</code> call. You prepare a data object <span class="CodeAnnotation">3</span> by using the server’s payload, then enter a <code>for</code> loop to send each data packet <span class="CodeAnnotation">4</span>. This <code>for</code> loop will continue looping as long as the data packet size is equal to 516 bytes.</p>&#13;
<p>After marshaling the data object to a byte slice, you enter the <code>for</code> loop <span class="CodeAnnotation">5</span> meant to resend the data packet until you either exhaust the number of retries or successfully deliver the data packet. Writing the data packet to the network connection <span class="CodeAnnotation">6</span> updates the <code>n</code> loop variable with the number of bytes sent. If this value is 516 bytes, you iterate again when control passes back to the <code>for</code> loop <span class="CodeAnnotation">4</span> labeled <code>NEXTPACKET</code>. If this value is less than 516 bytes, you break out of the loop. </p>&#13;
<p>Before you determine whether the transfer is complete, you must first verify that the client successfully received the last data packet. You read bytes from the client and attempt to unmarshal them into an <code>Ack</code> object or <code>Err</code> object. If you successfully unmarshal them into an <code>Err</code> object, you know the client returned an error, so you should log that fact and return early. An early return from this handler means the transmission terminated short of sending the entire payload. For our purposes, this is unrecoverable. The client would need to re-request the file to initiate another transfer. </p>&#13;
<p>If you successfully unmarshal the bytes into an <code>Ack</code> object, you can then check the object’s <code>Block</code> value to determine whether it matches the block number of the current data packet <span class="CodeAnnotation">7</span>. If so, you iterate around the <code>for</code> loop <span class="CodeAnnotation">4</span> and send the next packet. If not, you iterate around the inner <code>for</code> loop <span class="CodeAnnotation">5</span> and resend the current data packet.</p>&#13;
<h3 id="h2-500884c06-0007"><span epub:type="pagebreak" id="Page_135" title="135"/>Starting the Server</h3>&#13;
<p class="BodyFirst">To start your TFTP server, you need to give the server two things: a file (its payload) and an address on which to listen for incoming requests (<a href="#listing6-11" id="listinganchor6-11">Listing 6-11</a>).</p>&#13;
<pre><code>package main&#13;
&#13;
import (&#13;
    "flag"&#13;
    "io/ioutil"&#13;
    "log"&#13;
&#13;
    "github.com/awoodbeck/gnp/ch06/tftp"&#13;
)&#13;
&#13;
var (&#13;
    address = flag.String("a", "127.0.0.1:69", "listen address")&#13;
    payload = flag.String("p", "payload.svg", "file to serve to clients")&#13;
)&#13;
&#13;
func main() {&#13;
    flag.Parse()&#13;
&#13;
    p, err := <span class="CodeAnnotation">1</span>ioutil.ReadFile(*payload)&#13;
    if err != nil {&#13;
        log.Fatal(err)&#13;
    }&#13;
&#13;
    s := <span class="CodeAnnotation">2</span>tftp.Server{Payload: p}&#13;
    <span class="CodeAnnotationHang">3</span> log.Fatal(s.ListenAndServe(*address))&#13;
}</code></pre>&#13;
<p class="CodeListingCaption"><a id="listing6-11">Listing 6-11</a>: Command line TFTP server implementation (<em>tftp.go</em>)</p>&#13;
<p>Once you’ve read the file <span class="CodeAnnotation">1</span> that your TFTP server will serve into a byte slice, you instantiate the server and assign the byte slice to the server’s <code>Payload</code> field <span class="CodeAnnotation">2</span>. The last step is calling its <code>ListenAndServe</code> method to establish the UDP connection on which it will listen for requests. The <code>ListenAndServe</code> method <span class="CodeAnnotation">3</span> calls the server’s <code>Serve</code> method for you, which listens on the network connection for incoming requests. The server will continue to run until you terminate it with a <span class="KeyCaps">ctrl</span>-C on the command line.</p>&#13;
<h2 id="h1-500884c06-0004">Downloading Files over UDP</h2>&#13;
<p class="BodyFirst">Now let’s try to download a file from the server you just wrote. First, you need to make sure you have a TFTP client installed. Windows has a native TFTP client that you can install through the Programs and Features section of the Control Panel by clicking the Turn Windows features on or off link. Select the <b>TFTP Client</b> checkbox and click the <b>OK</b> button to install it. Most <span epub:type="pagebreak" id="Page_136" title="136"/>Linux distributions have a TFTP client available for installation through the distribution’s package manager, and macOS has a TFTP client installed by default.</p>&#13;
<p>This example uses Windows 10. Start by running the TFTP server by running the code in <a href="#listing6-11">Listing 6-11</a> in a terminal:</p>&#13;
<pre><code>Microsoft Windows [Version 10.0.18362.449]&#13;
(c) 2019 Microsoft Corporation. All rights reserved.&#13;
&#13;
C:\Users\User\gnp\ch06\tftp\tftp&gt;<b>go run tftp.go</b>&#13;
2006/01/02 15:04:05 Listening on 127.0.0.1:69 ...</code></pre>&#13;
<p>The server should bind to UDP port 69 on 127.0.0.1 by default. Port 69 is a privileged port, and you may need root permissions on Linux. You may need to first build the binary by using <code>go build tftp.go</code> and then run the resulting binary by using the <code>sudo</code> command to bind to port 69: <code>sudo ./tftp</code>. The TFTP server should log a message to standard output that indicates it’s listening.</p>&#13;
<p>From a separate terminal, execute the TFTP client, making sure to pass the <code>-i</code> argument to tell the server you wish to initiate a binary (octet) transfer. Remember, your TFTP server doesn’t care what the source filename is because it returns the same payload regardless of the requested filename. You’ll use <em>test.svg</em> in this example:</p>&#13;
<pre><code>Microsoft Windows [Version 10.0.18362.449]&#13;
(c) 2019 Microsoft Corporation. All rights reserved.&#13;
&#13;
C:\Users\User&gt;<b>tftp -i 127.0.0.1 GET test.svg</b>&#13;
Transfer successful: 75352 bytes in 1 second(s), 75352 bytes/s</code></pre>&#13;
<p>Almost immediately upon pressing <span class="KeyCaps">enter</span>, the client should report the transfer was successful. The TFTP server’s terminal should show its progress as well:</p>&#13;
<pre><code>Microsoft Windows [Version 10.0.18362.449]&#13;
(c) 2019 Microsoft Corporation. All rights reserved.&#13;
&#13;
C:\Users\User\gnp\ch06\tftp\tftp&gt;<b>go run tftp.go</b>&#13;
2006/01/02 15:04:05 Listening on 127.0.0.1:69 ...&#13;
2006/01/02 15:04:05 [127.0.0.1:57944] requested file: test.svg&#13;
2006/01/02 15:04:05 [127.0.0.1:57944] sent 148 blocks</code></pre>&#13;
<p>You can confirm that the downloaded file is the same as the payload provided to the TFTP server by comparing <em>test.svg</em>’s checksum with the checksum of the server’s <em>payload.svg</em>. A <em>checksum</em> is a calculated value used to verify the integrity of a file. If two files are identical, they will have equivalent checksums. Linux and macOS both have various command line utilities for generating checksums, but you’ll use a pure Go implementation, as shown in <a href="#listing6-12" id="listinganchor6-12">Listing 6-12</a>.</p>&#13;
<span epub:type="pagebreak" id="Page_137" title="137"/><pre><code>package main&#13;
&#13;
import (&#13;
    "crypto/sha512"&#13;
    "flag"&#13;
    "fmt"&#13;
    "io/ioutil"&#13;
    "os"&#13;
)&#13;
&#13;
func init() {&#13;
    flag.Usage = func() {&#13;
        fmt.Printf("Usage: %s file...\n", os.Args[0])&#13;
        flag.PrintDefaults()&#13;
    }&#13;
}&#13;
&#13;
func main() {&#13;
    flag.Parse()&#13;
    for _, file := range <span class="CodeAnnotation">1</span>flag.Args() {&#13;
        fmt.Printf("%s  %s\n", checksum(file), file)&#13;
    }&#13;
}&#13;
&#13;
func checksum(file string) string {&#13;
    b, err := <span class="CodeAnnotation">2</span>ioutil.ReadFile(file)&#13;
    if err != nil {&#13;
        return err.Error()&#13;
    }&#13;
&#13;
    return fmt.Sprintf("%x", <span class="CodeAnnotation">3</span>sha512.Sum512_256(b))&#13;
}</code></pre>&#13;
<p class="CodeListingCaption"><a id="listing6-12">Listing 6-12</a>: Generating SHA512/256 checksums for given command line arguments (<em>sha512-256sum.go</em>)</p>&#13;
<p>This bit of code will accept one or more file paths as command line arguments <span class="CodeAnnotation">1</span> and generate SHA512/256 checksums <span class="CodeAnnotation">3</span> from their contents <span class="CodeAnnotation">2</span>.</p>&#13;
<p>A SHA512/256 checksum is a SHA512 checksum truncated to 256 bits. Calculating SHA512 on a 64-bit machine is faster than calculating a SHA256 checksum, because the SHA512 computation uses 64-bit words, whereas SHA256 uses 32-bit words. By truncating SHA512 to 256 bits, you eliminate a length extension hashing attack that SHA512 is vulnerable to by itself. SHA512/256 isn’t necessary here since you’re not using the checksum beyond verifying the integrity of a file, but you should be familiar with it, and it should be on your short list of hashing algorithms.</p>&#13;
<p>You can use the code from <a href="#listing6-12">Listing 6-12</a> in <a href="#listing6-13" id="listinganchor6-13">Listing 6-13</a> to verify that the file you downloaded (<em>test.svg</em>) is identical to the file the server sent (<em>payload.svg</em>). <span epub:type="pagebreak" id="Page_138" title="138"/>You’ll continue to use Windows as your target platform, but the code will work on Linux and macOS without changes:</p>&#13;
<pre><code>Microsoft Windows [Version 10.0.18362.449]&#13;
(c) 2019 Microsoft Corporation. All rights reserved.&#13;
&#13;
C:\Users\User\dev\gnp\ch06&gt;<b>go build sha512-256sum\sha512-256sum.go</b>&#13;
&#13;
C:\Users\User\dev\gnp\ch06&gt;<b>sha512-256sum \Users\User\test.svg</b>&#13;
&#13;
\Users\User\test.svg =&gt;&#13;
<span class="CodeAnnotationHang">1</span> 3f5794c522e83b827054183658ce63cb701dc49f4e59335f08b5c79c56873969&#13;
&#13;
C:\Users\User\dev\gnp\ch06&gt;<b>sha512-256sum tftp\tftp\payload.svg</b>&#13;
&#13;
tftp\tftp\payload.svg =&gt;&#13;
<span class="CodeAnnotationHang">2</span> 3f5794c522e83b827054183658ce63cb701dc49f4e59335f08b5c79c56873969</code></pre>&#13;
<p class="CodeListingCaption"><a id="listing6-13">Listing 6-13</a>: Generating SHA512/256 checksums for <em>test.svg</em> and <em>payload.svg</em></p>&#13;
<p>As you can see, the <em>test.svg</em> checksum <span class="CodeAnnotation">1</span> is equal to the <em>payload.svg</em> checksum <span class="CodeAnnotation">2</span>.</p>&#13;
<p>In this case, the <em>test.svg</em> file is an image of a gopher from Egon Elbre’s excellent <em>gophers</em> repository on GitHub (<a class="LinkURL" href="https://github.com/egonelbre/gophers/">https://github.com/egonelbre/gophers/</a>). If you opened the file in a web browser, you’d see the image in <a href="#figure6-6" id="figureanchor6-6">Figure 6-6</a>.</p>&#13;
<p>Although you transferred the payload over localhost and don’t expect data loss or corruption, the client and server still acknowledged every data packet, ensuring the proper delivery of the payload. </p>&#13;
<figure>&#13;
<img alt="f06006" src="image_fi/500884c06/f06006.png"/>&#13;
<figcaption><p><a id="figure6-6">Figure 6-6</a>: Downloaded payload from the TFTP server</p></figcaption>&#13;
</figure>&#13;
<h2 id="h1-500884c06-0005"><span epub:type="pagebreak" id="Page_139" title="139"/>What You’ve Learned</h2>&#13;
<p class="BodyFirst">UDP can be made reliable at the application level, as evident by the Trivial File Transfer Protocol. TFTP uses a combination of data packet sequence numbers and acknowledgments to ensure that the client and server agree on all transferred data, redelivering packets as necessary.</p>&#13;
<p>Liberal use of Go’s binary marshaling and unmarshaling interfaces allow you to implement types that make communication using TFTP straightforward. Each TFTP type meant for delivery over UDP implements the <code>encoding.BinaryMarshaler</code> interface to marshal its data into a format suitable for writing to a network connection. Likewise, each type you expect to read from a network connection should implement the <code>encoding.BinaryUnmarshaler</code> interface. Successfully unmarshaling binary data to your custom type allows you to determine what binary data was received and that it is correct.</p>&#13;
</section>&#13;
</body></html>