- en: <hgroup>
  prefs: []
  type: TYPE_NORMAL
- en: 3 SCOPE AND DELAYED EXPANSION
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: </hgroup>
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/chapter.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'In the prior chapter, you learned about variables, how to set them, and how
    to resolve their values. In this chapter, I’ll focus on the setlocal command,
    which is central to some significant and disparate features of Batch and alters
    when, where, and how you can handle variables. First, it defines *scope*: where
    and when those variables can be accessed and manipulated. Second, it enables a
    feature called *delayed expansion*, which alters how variables are resolved, one
    upshot of which allows you to store one variable inside another variable.'
  prefs: []
  type: TYPE_NORMAL
- en: All languages handle scope in some fashion, but delayed expansion, or something
    similar, is far less common, and you’ll see some surprising uses for it. Finally,
    the setlocal command enables *command extensions*, an awkward term for a mass
    of additional functionality that’s turned on for many other Batch commands.
  prefs: []
  type: TYPE_NORMAL
- en: Scope
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Scope defines the life span of a variable. A *global variable* can be set, resolved,
    deleted, and modified anywhere, and that works fine for most simple bat files.
    A *local variable* is created with a limited shelf life, meant to be accessible
    in a single section of code where it’s *in scope*. Where those modifications aren’t
    recognized, the variable is *out of scope*.
  prefs: []
  type: TYPE_NORMAL
- en: In Batch, the setlocal command starts a section of code where variables are
    in scope, and the endlocal command ends that section, making those variables out
    of scope. Everything defined or manipulated between the two commands is active
    in that space, but after execution of the endlocal command, those variables revert
    to their prior state.
  prefs: []
  type: TYPE_NORMAL
- en: 'To demonstrate, the following code writes the state of three variables to the
    console both in and out of scope of the setlocal command. One is defined only
    inside the scope of the setlocal, one only outside, and one both inside and outside.
    To the right of the echo commands, I’ve included remarks showing the results,
    in particular the resolved variables, written to the console:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'There’s a lot to unpack here. Let’s take the first variable defined: inAndOut
    is set to OUT ❶ before the setlocal ❷ is executed, meaning that it was set out
    of scope of the command. After the setlocal executes, the same variable is set
    to IN ❸ where it’s in scope. When inAndOut is first interrogated, it resolves
    to IN ❹ because it’s in scope. But after the endlocal ❺ executes, it’s out of
    scope and reverts to its prior state, which is OUT ❻. (As a side note, IN-N-OUT
    is always set to delicious.)'
  prefs: []
  type: TYPE_NORMAL
- en: Now consider the inner variable, which is defined just once, when it’s in scope.
    That is, after the setlocal ❷ executes, it’s set to IN ❸. The variable then resolves
    to the value of IN ❹ before the endlocal ❺ is executed, but here’s where it gets
    interesting; after the endlocal ❺, it reverts to its prior state of not being
    defined at all—that is, null or empty ❻.
  prefs: []
  type: TYPE_NORMAL
- en: The final variable is outer, and it’s also defined just one time, but when it’s
    out of scope. It’s set to OUT ❶ before the setlocal ❷ executes. As you might expect,
    the variable is still OUT ❻ after the endlocal ❺ executes when it’s out of scope.
    But as you might not expect, its value is also available while in scope of the
    setlocal ❷, as its value also is OUT ❹ before the endlocal ❺ executes.
  prefs: []
  type: TYPE_NORMAL
- en: 'This example shows that the setlocal command doesn’t inhibit us from using
    variables already in scope. Everything existing up to that point is still available.
    What it does is this: *a snapshot is taken of the environment at the moment that
    the* setlocal *executes, to which it returns when the* endlocal *executes.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Defining scope with the setlocal and endlocal commands has just one use, but
    it’s an important one: to hide or section off variables in a portion of code to
    prevent conflicts. By default, Batch variables are global; a variable set in one
    bat file can be resolved or reset in a called bat file and even in a called internal
    routine. By default, many other languages use the opposite methodology, limiting
    the scope of variables used inside called programs and routines. Sometimes global
    variables are perfectly fine, but in other instances, limiting the scope is the
    better option. The ability to define scope gives you the power to use what’s best
    for your application.'
  prefs: []
  type: TYPE_NORMAL
- en: If you’re coding a utility bat file that’ll be called by many other processes,
    you may have no idea what variables the calling process is using. Placing a setlocal
    at the top of your bat file and an endlocal at or near the end defines and limits
    scope. The upshot is that if you happened to use a variable name in common with
    the calling bat file, you won’t step on its variable, which allows the caller
    to invoke your bat file with the assurance that there’ll be no ill side effects.
    The same is often done with called internal routines. (In [Chapter 10](chapter10.xhtml),
    we’ll look at calling internal routines and other bat files.)
  prefs: []
  type: TYPE_NORMAL
- en: Defining scope raises an interesting question. If a utility bat file is called
    to perform a specific task, there’s a good chance that at least part of that task
    is to set and return a certain variable. There’s a means for allowing a variable
    or variables to survive an endlocal command, and I’ll share that in [Chapter 16](chapter16.xhtml).
  prefs: []
  type: TYPE_NORMAL
- en: Delayed Expansion
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The setlocal command is a multipronged tool. In addition to defining scope,
    it also enables delayed expansion when used with a very descriptive argument:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Fittingly, the argument is spelled out without any semblance of abbreviation.
  prefs: []
  type: TYPE_NORMAL
- en: 'Delayed expansion implements two rounds of variable resolution: the initial
    resolution and a delayed resolution or expansion. When the interpreter executes
    a bat file, it processes each line of code one by one, first reading in or parsing
    a line and then executing that line. The initial resolution happens as the interpreter
    parses the line, and the delayed expansion happens as it executes the line.'
  prefs: []
  type: TYPE_NORMAL
- en: This feature allows for some interesting behavior that isn’t available in most
    languages. For instance, you can treat the value of a variable as a variable itself—or
    its value can be treated as a portion of another variable name. In [Listing 3-1](#Lis3-1),
    Toyota is a variable name as well as a value; that’s not a coincidence.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 3-1: Setting Car and Toyota with delayed expansion enabled'
  prefs: []
  type: TYPE_NORMAL
- en: First, we need the setlocal command with the argument to enable delayed expansion.
    Next, we set Car to the make of a car, which is a Toyota in this case. But Toyota
    produces several models, and if we want to capture a particular model, we can
    set the variable defined as Toyota to the value Prius.
  prefs: []
  type: TYPE_NORMAL
- en: Values and Variables
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: As I mentioned previously, Toyota is both a value and a variable. It’s the value
    of the Car variable and also a variable containing the Prius value. Now we can
    execute three statements to write three variables to the console, as shown in
    [Listing 3-2](#Lis3-2).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 3-2: Resolving Car by three different means'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s the output [Listing 3-2](#Lis3-2) generates:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'The first resolution of Car is quite pedestrian by now. Surrounding the variable
    with percent signs (%) resolves it to its value of Toyota. The second command
    introduces something new: exclamation marks (!) are used as delimiters to resolve
    a variable, !Car!, instead of percent signs. The variable surrounded with exclamation
    marks also resolves to Toyota, but why have two different characters that perform
    the same function? The answer will present itself after we examine the final command.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The third resolution truly shows the power of delayed expansion. The variable
    is surrounded by percent signs, and that’s surrounded by exclamation marks. The
    interpreter first resolves %Car% to be Toyota. Make sure that you are seated for
    this next part: that value is now surrounded by exclamation marks, which causes
    it to be resolved yet again, so !Toyota! becomes Prius. Putting it all together,
    the variable is resolved like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '!%Car%! → !Toyota! → Prius'
  prefs: []
  type: TYPE_NORMAL
- en: 'To answer the question about two different characters performing the same function,
    the interpreter needs both to perform this resolution since we now have two rounds
    of it: percent signs do the inner resolution, and exclamation marks do the outer
    resolution. (Can’t we just encase the variable with two sets of double percent
    signs? No, the syntax for the for command has a specific purpose for the double
    percent signs, which you’ll learn about in [Chapter 17](chapter17.xhtml).)'
  prefs: []
  type: TYPE_NORMAL
- en: 'The best way to demonstrate exactly how delayed expansion affects the code
    is to run the same code without it enabled. If we remove the setlocal from [Listing
    3-1](#Lis3-1), the results of [Listing 3-2](#Lis3-2) are:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Without delayed expansion, the exclamation marks are treated as simple text
    and are of no significance to Batch. The !Car! variable isn’t resolved at all;
    the interpreter doesn’t even consider those three letters to be a variable. The
    !%Car%! variable experiences one round of variable resolution, but again, the
    exclamation marks are simply along for the ride.
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 2](chapter2.xhtml), I adeptly sidestepped an issue by mentioning
    that a variable name shouldn’t start with a number. Technically, you can set such
    a variable, but you won’t be able to resolve it with percent signs; you can do
    it only with exclamation marks and with delayed expansion enabled. The best way
    to deal with this little oddity is never to start variable names with numbers.
  prefs: []
  type: TYPE_NORMAL
- en: Now we have a variable that can be resolved to a value that’s resolved a second
    time to be yet another value. That’s not typically easily done, or even done at
    all, in those fancy modern compiled languages. To be honest, as cool as an entire
    word being both a variable and a value may be, it’s not used often in the real
    world, but partial variable names have many applications.
  prefs: []
  type: TYPE_NORMAL
- en: Partial Variable Names
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'This technique becomes even more interesting and useful when the resolved value
    is used as just a portion of a variable name. To demonstrate, consider these set
    commands defining the signature culinary masterpieces of five cities:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Each variable name, which is the concatenation of food and a common abbreviation
    for a city, is set to the dish for which that city is famous. Only five variables
    are shown, but you could define any number.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following set of variables has the same abbreviations for the five cities,
    where each is appended with Full and assigned the full name of the city:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Now consider this echo command with two examples of delayed expansion:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'If city is set to NO and delayed expansion is enabled, this command writes
    the following to the console:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'To understand how this worked, let’s first take a look at the !food%city%!
    variable. The inner variable, city, and its encasing percent signs is resolved
    to NO, revealing the foodNO variable. Next the exclamation mark delimiters resolve
    it to the most delicious sandwich ever created; no, it’s not a glorified ham and
    cheese sandwich. To summarize:'
  prefs: []
  type: TYPE_NORMAL
- en: '!food%city%! → !foodNO! → Muffuletta Sandwich'
  prefs: []
  type: TYPE_NORMAL
- en: 'Similarly, the full name of the city is also resolved in two steps. The only
    difference here is that the hardcoded portion of the variable name comes after
    the portion to be resolved:'
  prefs: []
  type: TYPE_NORMAL
- en: '!%city%Full! → !NOFull! → New Orleans'
  prefs: []
  type: TYPE_NORMAL
- en: 'The echo command behaves differently for different values of city, which is
    important to note. It writes the following four sentences to the console when
    the variable is set to NYC, Nash, Chic, and STL, respectively:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: I opened this section by suggesting that having a resolved value as just a portion
    of a variable name is more useful. This example is pedagogical, but you can easily
    extend the technique to something more practical. In the professional realm, instead
    of the realm of city-centric cuisines, you could create a set of variables to
    define the paths for the transmission of files to different facilities based on
    their location, say pathNYC, pathNash, and pathSTL. Then a single command to copy
    a file can use the same delayed expansion technique to transmit the file to one
    of many destinations. (I’ll use this technique again in [Chapter 5](chapter5.xhtml)
    when discussing substringing.)
  prefs: []
  type: TYPE_NORMAL
- en: Creative coders can make a seemingly unlimited use of delayed expansion, and
    we’ll get into some of those uses when we explore arrays and hash tables in [Chapter
    29](chapter29.xhtml). The for command in [Part II](part2.xhtml) will rely greatly
    on delayed expansion, and possibly its most interesting application will come
    in [Chapter 16](chapter16.xhtml) where a variable will be able to hold two values
    simultaneously.
  prefs: []
  type: TYPE_NORMAL
- en: Command Extensions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The setlocal command also accepts an argument that turns on command extensions.
    Unlike delayed expansion, command extensions should be active by default, but
    you can turn them on explicitly with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Enabling command extensions unlocks a great deal of additional functionality
    and available options for several Batch commands. For instance, the for command
    is indispensable for any Batch coder. We haven’t discussed it yet, but Batch has
    one variant of the for command when command extensions are disabled. With command
    extensions enabled, however, it becomes a turbocharged workhorse with at least
    10 forms. Even the set command discussed in [Chapter 2](chapter2.xhtml) (not often
    considered a dynamic or interesting command) has additional functionality and
    available options with this setting. The specific features vary from command to
    command, and you can retrieve their details at the command prompt via the help
    command (also covered in [Chapter 2](chapter2.xhtml)).
  prefs: []
  type: TYPE_NORMAL
- en: 'To demonstrate the additional functionality unlocked for just one command by
    enabling command extensions, return to the command prompt and enter the same command
    from the prior chapter to retrieve documentation on the set command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'After a short few lines of text detailing what the command does when command
    extensions aren’t enabled, the interpreter displays the following line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'What follows is all of the expanded functionality that has been unlocked. There’s
    far too much information to show it all, but in this small sample two previously
    unavailable options are shared:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: I mentioned these options in [Chapter 2](chapter2.xhtml), but I didn’t mention
    that command extensions turn them on. The help command gives you several times
    the amount of information about the set command’s functionality with command extensions
    enabled than it does when disabled, and the same is true for many other commands.
    As I introduce more commands, I encourage you to investigate them further with
    the help command to see a larger list of uses and options and to see what’s turned
    on with command extensions.
  prefs: []
  type: TYPE_NORMAL
- en: Final Thoughts on setlocal and endlocal
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'After two decades of coding bat files, I have some strong opinions on the use
    of the setlocal and endlocal commands, and I’m not shy about sharing them. Every
    high-level bat file that I write has this command at or near the very first line
    of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: I’m defining a high-level bat file as a bat file that isn’t called from another
    bat file. I’ve rarely come across an instance where I didn’t want command extensions
    and delayed expansion enabled. There’s virtually no cost for all the extra features.
    It’s as if you could turn your Toyota into a Lamborghini with none of the disadvantages
    such as cost and gas mileage. But in that rare instance, you can disable these
    features with the DisableExtensions and DisableDelayedExpansion arguments.
  prefs: []
  type: TYPE_NORMAL
- en: Additionally, whenever I code some logic that might adversely affect other code,
    I precede that logic with a simple setlocal command with no arguments and terminate
    it with a corresponding endlocal command. Don’t fret; delayed expansion is still
    enabled from the original setlocal command. You can even nest multiple setlocal
    and endlocal commands, creating subsections of code with a defined scope within
    subsections, but not more than 32 levels deep. I have never come close to this
    limitation, but if you do, you can nest further in a called routine or another
    bat file. (I’ll get to how those calls are performed in [Chapter 10](chapter10.xhtml).)
  prefs: []
  type: TYPE_NORMAL
- en: For the sake of completeness, it’s good form for that original setlocal to have
    a corresponding endlocal at the end of the bat file, but if omitted, the interpreter
    executes an implied endlocal before exiting the high-level bat file.
  prefs: []
  type: TYPE_NORMAL
- en: Crucially, this book is written with the assumption that command extensions
    and delayed expansion are enabled. In general, I won’t bore you with what functionality
    is unlocked with these settings and what isn’t. If an example from this book isn’t
    working in your testing, make sure that you’ve run this command with both of its
    enabling arguments.
  prefs: []
  type: TYPE_NORMAL
- en: NOTE
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*I have just one exception to the rule about starting all high-level bat files
    with the particular setlocal command mentioned previously, and it’s in this book.
    In later chapters I’ll provide some examples of very short bat files, maybe just
    two or three lines. These simple examples might not require this command, and
    its use might pull the focus away from the topic at hand. In those instances,
    I won’t include the command, but understand that it could and should be there.*'
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The main focus of this chapter was the setlocal command, which defines scope
    and enables command extensions. Most important, it enables delayed expansion,
    opening vast possibilities for defining and using variables.
  prefs: []
  type: TYPE_NORMAL
- en: With delayed expansion enabled, you saw how you can write out one of five sentences
    based on the value of a variable defining a city with just a single command. But
    if delayed expansion had been disabled, you may have resorted to interrogating
    that variable with five if commands. In the example laid out in this chapter,
    that would’ve been an inelegant solution, but in general, the if command is an
    important workhorse in any language, and Batch is no different. In the next chapter,
    I’ll discuss it in detail—and since this is Batch—its idiosyncrasies.
  prefs: []
  type: TYPE_NORMAL
