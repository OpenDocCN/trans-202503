<html><head></head><body>
<h2 class="h2b" id="ch06"><span epub:type="pagebreak" id="page_91"/><strong><span class="big">6</span></strong><br/><strong>ECU HACKING</strong></h2>&#13;
<p class="aut"><em>by Dave Blundell</em></p>&#13;
<div class="image"><img src="graphics/common-01.jpg" alt="image"/></div>&#13;
<p class="noindent">A vehicle typically has as many as a dozen or more electronic controllers, many of which are networked to communicate with each other. These computerized devices go by many different names, including <em>electronic control unit</em> or <em>engine control unit (ECU)</em>, <em>transmission control unit (TCU),</em> or <em>transmission control module (TCM)</em>.</p>&#13;
<p class="indent">While these terms may have specific meanings in a formal setting, similar terms are often used interchangeably in practice. What may be a TCU to one manufacturer is a TCM to another, yet both electronic controllers perform the same or extremely similar functions.</p>&#13;
<p class="indentb">Most automotive control modules have measures in place to prevent you from altering their code and operation; these range from very strong to laughably weak. You won’t know what you’re dealing with until you investigate a particular system. In this chapter, we’ll take a closer look at particular security mechanisms, but first we’ll examine strategies for gaining access <span epub:type="pagebreak" id="page_92"/>to these systems. Then in <a href="ch08.html#ch08">Chapter 8</a> we’ll look at some more specific ECU hacks, like glitch attacks and debugging. The attack vectors for ECUs fall into three different classes:</p>&#13;
<p class="uln"><strong>Front door attacks</strong> Commandeering the access mechanism of the original equipment manufacturer (OEM)</p>&#13;
<p class="uln"><strong>Backdoor attacks</strong> Applying more traditional hardware-hacking approaches</p>&#13;
<p class="uln"><strong>Exploits</strong> Discovering unintentional access mechanisms</p>&#13;
<p class="indentt">We’ll look at an overview of these attack classes, and then analyze the data you find. It’s worth remembering that while the goal for ECU and other control module hacking is often the same—to gain access in order to reprogram and change behavior—it’s unlikely there’ll be a “master key” for all controllers. However, OEMs are generally not very creative and seldom change their ways, so insight into one controller likely applies to similar models from the same manufacturer. Also, few of today’s auto manufacturers develop their own automotive computers from scratch, instead licensing prefabricated solutions from third parties like Denso, Bosch, Continental, and others. Because of this design methodology, it’s relatively common to see vehicles from different auto manufacturers using very similar computer systems sourced from the same vendors.</p>&#13;
<h3 class="h3" id="ch06lev1sec1"><strong>Front Door Attacks</strong></h3>&#13;
<p class="noindent">The OBD-II standard mandates that you be able to reprogram vehicles through the OBD-II connector, and reverse engineering the original method for programming is a guaranteed attack vector. We’ll examine J2534 and KWP2000 as examples of common protocols for programming.</p>&#13;
<h4 class="h4" id="ch06lev2sec1"><strong><em>J2534: The Standardized Vehicle Communication API</em></strong></h4>&#13;
<p class="noindent">The SAE J2534-1 standard, or simply <em>J2534</em>, was developed to promote interoperability among digital tool vendors through the use of the J2534 API, which outlines the recommended way for Microsoft Windows to communicate with a vehicle. (You can purchase the J2534 API from the SAE at <em><a href="http://standards.sae.org/j2534/1_200412/">http://standards.sae.org/j2534/1_200412/</a></em>.) Prior to the adoption of the J2534 standard, each software vendor created its own proprietary hardware and drivers for communicating with a vehicle in order to perform computerized repairs. Because these proprietary tools weren’t always available to smaller shops, the EPA mandated the adoption of the J2534 standard in 2004 to allow independent shops access to the same specialized computer tools used by dealerships. J2534 introduced a series of DLLs that map standard API calls to instructions necessary to communicate with a vehicle, thereby allowing multiple manufacturers to release software designed to work with J2534-compatible hardware.</p>&#13;
<h4 class="h4" id="ch06lev2sec2"><span epub:type="pagebreak" id="page_93"/><strong><em>Using J2534 Tools</em></strong></h4>&#13;
<p class="noindent">J2534 tools provide a convenient way to observe OEM tools interacting with vehicle computers. Manufacturers often leverage J2534 to update computer firmware and sometimes to provide powerful diagnostic software. By observing and capturing information exchanged with a vehicle using J2534, you can see how OEMs perform certain tasks, which may provide you with information that you need to unlock the “front door.”</p>&#13;
<p class="indent">When using J2534 tools to attack vehicle systems, the basic idea is to observe, record, analyze, and extend functionality. Of course, the first step is to obtain and configure a J2534 application and its corresponding interface hardware in order to perform a task you want to observe. Once you have your setup, the next step is to observe and record communications with the target while using the J2534 tools to perform an action on the target, like updating a configuration parameter.</p>&#13;
<p class="indent">There are two primary ways to observe J2534 transactions: by watching J2534 API calls on a PC using J2534 shim DLLs or by watching actual bus traffic using a separate sniffer tool to capture data.</p>&#13;
<p class="indent">J2534 tools are key to eavesdropping on the protocols built into the factory embedded vehicle systems, and they’re one of the primary ways to attack the front door. Successful analysis of this communication will give you the knowledge you need to access vehicle systems the way the OEMs do. It’ll also allow you to write applications with full access to read and reprogram systems, which will in turn enable you to communicate directly with a vehicle without having to use the J2534 interface or the OEM’s J2534 software.</p>&#13;
<h5 class="h5" id="ch06lev3sec1"><strong>J2534 Shim DLLs</strong></h5>&#13;
<p class="noindent">The J2534 shim is a software J2534 interface that connects to a physical J2534 interface and then passes along and logs all commands that it receives. This dummy interface is a kind of man-in-the-middle attack that allows you to record all API calls between the J2534 application and the target. You can then examine the log of commands to determine the actual data exchanged between the J2534 interface and the device.</p>&#13;
<p class="indent">To find an open source J2534 shim, search <em><a href="mailto:code.google.com">code.google.com</a></em> for <em>J2534-logger</em>. You should also be able to find precompiled binaries.</p>&#13;
<h5 class="h5" id="ch06lev3sec2"><strong>J2534 with a Sniffer</strong></h5>&#13;
<p class="noindent">You can also use J2534 to generate interesting traffic that you can then observe and record with a third party sniffer. There’s no magic here: this is just an excellent example of how to generate juicy packets that might otherwise be difficult to capture. (See <a href="ch05.html#ch05">Chapter 5</a> for more information on monitoring network traffic.)</p>&#13;
<h4 class="h4" id="ch06lev2sec3"><span epub:type="pagebreak" id="page_94"/><strong><em>KWP2000 and Other Earlier Protocols</em></strong></h4>&#13;
<p class="noindent">Before J2534, there were many flash-programmable ECUs and other control units, such as the Keyword Protocol 2000 (KWP2000 or ISO14230). From an OSI networking perspective, it’s primarily an application protocol. It can be used on top of CAN or ISO9141 as the physical layer. You’ll find a <em>huge</em> number of KWP2000 flasher tools that interface with a PC using a serial/ USB-serial interface and that support diagnostics and flashing using this protocol just by searching online. (For more on the Keyword Protocol 2000, see <a href="ch02.html#ch02">Chapter 2</a>.)</p>&#13;
<h4 class="h4" id="ch06lev2sec4"><strong><em>Capitalizing on Front Door Approaches: Seed-Key Algorithms</em></strong></h4>&#13;
<p class="noindent">Now that we’ve discussed how legitimate tools use the front door, it’s time to capitalize on this attack vector by learning how to operate the figurative “lock on the gate.” To do this, we must understand the algorithm that the embedded controller uses to authenticate valid users; this is almost always a seed-key algorithm. Seed-key algorithms usually generate a pseudorandom <em>seed</em> and expect a particular response, or <em>key</em>, for each seed before allowing access. A typical valid exchange could look something like this:</p>&#13;
<pre>ECU seed: 01 C3 45 22 84<br/>Tool key: 02 3C 54 22 48</pre>&#13;
<p class="noindent">or this:</p>&#13;
<pre>ECU seed: 04 57<br/>Tool key: 05 58</pre>&#13;
<p class="indentb">Unfortunately, there’s no standard seed-key algorithm. You might have a 16-bit seed and 16-bit key, a 32-bit seed and 16-bit key, or a 32-bit seed and 32-bit key. The algorithm that generates a key from a given seed also varies from platform to platform. Most algorithms are a combination of simple arithmetic operations and one or more values used as part of the computation. There are several techniques for figuring out these algorithms in order to give you access to the ECU:</p>&#13;
<p class="bull">• Obtain the firmware for the device in question through other means. Disassemble it and analyze the embedded code to find the code responsible for generating seed-key pairs.</p>&#13;
<p class="bull">• Obtain a legitimate software tool—for example, J2534 reflash software—that’s capable of generating legitimate seed-key pairs, and analyze the PC application code with a disassembler to determine the algorithm used.</p>&#13;
<p class="bull">• Observe a legitimate tool exchanging keys, and analyze the pairs for patterns.</p>&#13;
<p class="bull">• Create a device to spoof a legitimate tool into providing responses repeatedly. The main advantage of this method over purely passive observation is that it allows you to pick seeds for which you can reproduce the keys.</p>&#13;
<p class="indentt"><span epub:type="pagebreak" id="page_95"/>You can find more information about reverse engineering the seed-key algorithms used by General Motors at <em><a href="http://pcmhacking.net/forums/viewtopic.php?f=4&amp;t=1566&amp;start=10">http://pcmhacking.net/forums/viewtopic.php?f=4&amp;t=1566&amp;start=10</a></em>, and those used by VAG MED9.1 at <em><a href="http://nefariousmotorsports.com/forum/index.php?topic=4983.0">http://nefariousmotorsports.com/forum/index.php?topic=4983.0</a></em>.</p>&#13;
<h3 class="h3" id="ch06lev1sec2"><strong>Backdoor Attacks</strong></h3>&#13;
<p class="noindent">Sometimes front door attacks are too tricky; you may not have the right tools or the lock might be too hard to figure out. Don’t despair—remember that automotive control modules are embedded systems, so you can use all the usual hardware-hacking approaches. In fact, using more direct-to-hardware backdoor approaches often makes more sense than trying to reverse engineer the front door lock placed by the factory, especially when trying to reprogram engine modules. If you can obtain a dump of the module, you can often disassemble and analyze it to figure out how the keys to the front door work. The first step in a hardware backdoor attack is analyzing the circuit board.</p>&#13;
<p class="indent">When reversing a circuit board of any system, you should start with the largest chips first. These larger processor and memory chips are likely to be the most complex. It’s a good idea to make a list of part numbers to feed to Google, <em><a href="http://datasheet.com">datasheet.com</a></em>, or something similar, to obtain a copy of the data sheet. You’ll sometimes encounter custom application-specific integrated circuits (ASICs) and one-off chips, especially with older ECUs, which will prove more difficult than off-the-shelf parts. In many cases, you’ll have to infer the function of these parts based on how they’re connected to identifiable parts.</p>&#13;
<p class="indent">It’s critical to look out for memory chips—SRAM, EEPROM, FlashROM, one-time-programmable ROM, serial EEPROM, serial flash, NVSRAM, and so on. The type of memory used varies immensely from one platform to another; every single variety listed here has been found in the wild. Newer designs are less likely to have parallel memories and more likely to have serial chips. Newer microcontrollers are less likely to have any external memories at all, as their internal flash capacities have dramatically increased. Any nonvolatile memory chip present can be removed from the circuit board, read, and then replaced. <a href="ch08.html#ch08">Chapter 8</a> goes into much more detail on reverse engineering the circuit board.</p>&#13;
<h3 class="h3" id="ch06lev1sec3"><strong>Exploits</strong></h3>&#13;
<p class="noindent">Although arguably just another example of a backdoor approach, exploits deserve special attention. Rather than taking apart a computer, exploits involve feeding a system carefully crafted inputs to make it do things outside normal operation. Typically, exploits build on a bug or problem. This bug might cause a system to crash, reboot, or perform some undesirable behavior from the perspective of the vehicle user. Some of these bugs present the opportunity for buffer overflow attacks, which open the door for commandeering the vulnerable device merely by feeding it unexpected <span epub:type="pagebreak" id="page_96"/>inputs. A cleverly crafted set of inputs triggers the bug, which then makes the device execute arbitrary code provided by the attacker instead of triggering the usual fault condition.</p>&#13;
<p class="indent">Not all bugs can be turned into exploits, however—some bugs only cause problems or shut down core systems. And while bugs are usually discovered by accident, most exploits require careful craft. It is unlikely that you’d be able to turn a known bug into an exploit without also having prior knowledge of the system, usually gained from firmware analysis. At a bare minimum, you’d need basic knowledge of the architecture in order to write the necessary code. Most of the time, this knowledge needs to be gathered through research prior to writing an exploit.</p>&#13;
<p class="indent">It’s hard to find bugs that make suitable attack vectors and it’s often just as difficult to write exploits for them, so exploits that build on bugs are fairly uncommon. While it is foolish to discount the relevance of exploits, the other methods presented here and in <a href="ch08.html#ch08">Chapter 8</a> are much more practical paths to understanding and reprogramming automotive systems in most cases.</p>&#13;
<h3 class="h3" id="ch06lev1sec4"><strong>Reversing Automotive Firmware</strong></h3>&#13;
<p class="noindent">Hacking into an automotive control module far enough to retrieve its current firmware and configuration is really just the beginning of the adventure. At this point, you probably have anywhere from 4KB to 4MB of raw machine-ready code, with a mixture of various parameters and actual code that forms the program the processor will run. Let’s say you have a binary blob in the firmware from one of the hacks in this chapter or the chapters later in this book. Next you need to disassemble the binary.</p>&#13;
<p class="indent">First, you must know which chip this binary is for. There are several free decompilers for different chips out on the Internet. Otherwise you can drop some cash and buy IDA Pro, which supports a large variety of chips. These tools will convert the hex values in the binary into assembler instructions. The next stage is to figure out what exactly you are looking at.</p>&#13;
<p class="indent">When you’re starting to analyze raw data, a high-level understanding of the function of the devices you’re reverse engineering will be key to knowing what to look for. You can follow a number of <em>breadcrumbs</em>, or clues, for starters; these breadcrumbs are almost guaranteed to lead you to interesting and useful material. Next, we’ll look at a few specific examples of how to use common automotive controller functions to gain insight into their operation, which will hopefully allow us to change their behavior.</p>&#13;
<h4 class="h4" id="ch06lev2sec5"><strong><em>Self-Diagnostic System</em></strong></h4>&#13;
<p class="noindent">Every engine controller has some type of self-diagnostic system that typically monitors most critical engine functions, and analyzing this is an excellent route to understanding firmware. A good first step in investigative disassembly is to identify the location of these procedures. This will provide you with insight into the memory locations involved in all of the sensors and functions that are checked for errors. Any modern vehicle should support OBD-II packets, which standardize the diagnostic data reported. <span epub:type="pagebreak" id="page_97"/>Even controllers created prior to OBD-II standards have a way to report faults. Some have a system where an analog input is shorted to ground and either an internal LED or the “check engine” light flashes out the code. For example, knowing that code 10 refers to a failed intake air temperature sensor means you can find the piece of code that sets error code 10 to help you identify the internal variables associated with the air temperature sensor.</p>&#13;
<p class="indent">For more detailed information on using diagnostics, see <a href="ch04.html#ch04">Chapter 4</a>.</p>&#13;
<h4 class="h4" id="ch06lev2sec6"><strong><em>Library Procedures</em></strong></h4>&#13;
<p class="noindent">Being able to change the behavior of a control unit is often one of the primary goals of reverse engineering ECU firmware, and identifying data used by a controller is an important step in the process. Most ECUs have a set of library functions used for routine tasks throughout the code. Library functions used for table lookups are worth identifying early on in the reverse engineering process, as these can lead straight to the parameters you’re interested in. Each time a table is used, a function is called to fetch a result. Calls to this type of function are among the most frequent, making them easy to spot.</p>&#13;
<p class="indent">Usually each type of data stored within the ECU—one-dimensional array of bytes; two-dimensional array of words; three-dimensional array of unsigned, signed, and float shorts; and so on—has a unique reference function. When called, each table lookup routine needs to be passed, at a minimum, the table index (or start address) and the axis variables. Often, table lookup routines can be reused to pass information about the structure of the table, such as how many rows and columns are present.</p>&#13;
<p class="indent">Calibration data is usually stored in program memory, along with the routines accessing them. Microcontrollers typically have special instructions to access program memory, which provide a unique signature to search for and make table lookup routines particularly easy to spot. A secondary characteristic of these lookup routines is that they tend to have lots of interpolation math. In addition, table lookup routines are often grouped closely together in program memory, making it even easier to find others after you’ve found one. After identifying reference routines, searching for all calls to them can provide a key to identifying the vast majority of data used by the controller to make decisions. The arguments passed to these functions typically include the start address of a table, its structure or shape, and which variables index elements of the table. Armed with this information, you’re much closer to being able to change the behavior of the controller.</p>&#13;
<h5 class="h5" id="ch06lev3sec3"><strong>Finding Known Tables</strong></h5>&#13;
<p class="noindent">One way to identify tables is to leverage the specific physical and electrical characteristics of vehicle sensors, which will display identifiable characteristics within ECU firmware. For example, an ECU with a MAF sensor will have a table that translates raw readings of voltage or frequency from the MAF into airflow into the engine, providing an internal representation.</p>&#13;
<p class="indent">Fortunately for us, the signal output from an MAF is determined by physics—that is, King’s Law—so the curve will always have a characteristic shape, though it’ll be slightly different for each sensor. This will result in the <span epub:type="pagebreak" id="page_98"/>tables having a characteristic set of values that can be observed in the ROM. Armed with the knowledge that there will be universal data to identify, let’s take a closer look at how calibration data is displayed in different programs.</p>&#13;
<p class="indent"><a href="ch06.html#ch6fig1">Figures 6-1</a> and <a href="ch06.html#ch6fig2">6-2</a> show similarly shaped Ford and Nissan sensor curves; the similarity they illustrate extends to multiple manufacturers.</p>&#13;
<div class="image"><img src="graphics/f06-01.jpg" alt="image"/></div>&#13;
<p class="figcap"><a id="ch6fig1"/><em>Figure 6-1: Ford MAF transfer graph</em></p>&#13;
<div class="image"><img src="graphics/f06-02.jpg" alt="image"/></div>&#13;
<p class="figcap"><a id="ch6fig2"/><em>Figure 6-2: Nissan MAF VQ graph</em></p>&#13;
<p class="indent"><a href="ch06.html#ch6fig2">Figures 6-2</a> through <a href="ch06.html#ch6fig6">6-6</a> show five different views of the same data. <a href="ch06.html#ch6fig3">Figure 6-3</a> shows how the VQ curve pictured in <a href="ch06.html#ch6fig2">Figure 6-2</a> would look in a hex editor.</p>&#13;
<div class="image"><span epub:type="pagebreak" id="page_99"/><img src="graphics/f06-03.jpg" alt="image"/></div>&#13;
<p class="figcap"><a id="ch6fig3"/><em>Figure 6-3: VQ table in HxD hex editor: 128 bytes or 64- to 16-bit words</em></p>&#13;
<p class="indent"><a href="ch06.html#ch6fig4">Figures 6-4</a> and <a href="ch06.html#ch6fig5">6-5</a> show the VQ table in analyze.exe available from <em><a href="https://github.com/blundar/analyze.exe/">https://github.com/blundar/analyze.exe/</a></em>. A simple visualization tool, analyze.exe colors cells based on their numeric value. You can select the precision of the data—for example, 1 = 8-bit byte, 2 = 16-bit word, and 4 = 32-bit long—and how many rows and columns you want present. This simple visual arrangement often makes it easier to identify what is code and what is data than it is when you’re using a hex editor, as in <a href="ch06.html#ch6fig3">Figure 6-3</a>.</p>&#13;
<div class="image"><img src="graphics/f06-04.jpg" alt="image"/></div>&#13;
<p class="figcap"><a id="ch6fig4"/><em>Figure 6-4: VQ table in analyze.exe: values from 48 to 65535 in first four rows of 16×16-bit values</em></p>&#13;
<div class="image"><img src="graphics/f06-05.jpg" alt="image"/></div>&#13;
<p class="figcap"><a id="ch6fig5"/><em>Figure 6-5: First four rows of 16x16-bit values</em></p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_100"/>Look again at the first four rows of 16×16-bit values in <a href="ch06.html#ch6fig4">Figures 6-4</a> and <a href="ch06.html#ch6fig5">6-5</a> shaded in analyze.exe. Notice how the smooth nonlinear curve in <a href="ch06.html#ch6fig1">Figures 6-1</a> and <a href="ch06.html#ch6fig2">6-2</a> mimics the smooth nonlinear progression of values. <a href="ch06.html#ch6fig6">Figure 6-6</a> shows the same values in a 64-column layout, so you can see the full gradient of the first four rows from <a href="ch06.html#ch6fig5">Figure 6-5</a>. No matter what type of vehicle you’re looking at, the overall data structures will be similar.</p>&#13;
<div class="image"><img src="graphics/f06-06.jpg" alt="image"/></div>&#13;
<p class="figcap"><a id="ch6fig6"/><em>Figure 6-6: 64- to 16-bit words per row</em></p>&#13;
<p class="indent">Data visualization tools like hex editors or analyze.exe can also be useful when you don’t know the exact shape or pattern you are looking for. No matter what type of vehicle you’re looking at, data structures will have orders and patterns that are not typically seen in executable code. <a href="ch06.html#ch6fig7">Figure 6-7</a> shows an example of the clear visual pattern of data in analyze.exe—gradually changing values and repetition should stand out.</p>&#13;
<div class="image"><img src="graphics/f06-07.jpg" alt="image"/></div>&#13;
<p class="figcap"><a id="ch6fig7"/><em>Figure 6-7: Patterns and gradual changes in table data appear in a 2002 Chevrolet Camaro ROM visualized with analyze.exe</em></p>&#13;
<p class="indent">On the other hand, when you look at code like that in <a href="ch06.html#ch6fig8">Figure 6-8</a>, there is a more random, chaotic appearance. (In <a href="ch06.html#ch6fig7">Figures 6-7</a> and <a href="ch06.html#ch6fig8">6-8</a>, precision is set to 2 because the microcontroller unit used is a 16-bit processor and it’s reasonable to assume that a good chunk of the data items will be 16-bit as well.)</p>&#13;
<div class="image"><span epub:type="pagebreak" id="page_101"/><img src="graphics/f06-08.jpg" alt="image"/></div>&#13;
<p class="figcap"><a id="ch6fig8"/><em>Figure 6-8: This random code doesn’t have the neat, orderly patterns that are present in most tables.</em></p>&#13;
<h5 class="h5" id="ch06lev3sec4"><strong>More to Learn from the MCU</strong></h5>&#13;
<p class="noindent">Hopefully, these examples help connect knowledge of the table data you expect to find with their representation within a binary blob. Learning the capabilities of the microcontroller unit (MCU) used in a target system can shed light on the types of data to expect when looking over the binary data.</p>&#13;
<p class="indent">Generally, data representation formats are dictated by the hardware present. Knowing the size of registers on the MCU running the show can be a big help for identifying parameters. Most parameters tend to be the same size as or smaller than the registers of a given MCU. An 8-bit MCU, like a 68HC11, is likely to have lots of 8-bit data. It’s unusual to see mostly 4-byte, or 32-bit, unsigned long integers on an 8-bit MCU. While 16-bit data becomes more common on MCUs like the 68332, 32-bit data becomes the norm with MPC5xx Power Architecture MCUs and so on. It’s unusual to find floating-point data on an MCU that lacks a floating-point processor.</p>&#13;
<h4 class="h4" id="ch06lev2sec7"><strong><em>Comparing Bytes to Identify Parameters</em></strong></h4>&#13;
<p class="noindent">It’s often possible to get multiple bins that’ll run on the same physical ECU. The more the better! Doing a simple compare in a hex editor will show which bytes differ between the files. It’s common—but not guaranteed—for code to remain unchanged while parameters change. If less than 5 percent of the files differ, it’s generally safe to assume that the differences are parameters. If you know what’s been changed functionally between the two bins and you know which bytes have changed, you have further clues to help correlate changes in the ROM with changes in parameters.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_102"/><a href="ch06.html#ch6fig9">Figures 6-9</a> and <a href="ch06.html#ch6fig10">6-10</a> compare a 1996 V8 Mustang and a 1997 V6 Thunderbird, showing 6,667 differences out of 114,688 bytes. This is an extreme example of having the same code with different parameters, but there’s still only about a 5.8 percent difference compared to overall file size.</p>&#13;
<p class="indent">Most processors use an interrupt vector table defined by the processor being used. Referencing the processor’s data sheet will define the structure of interrupt routines, allowing you to quickly identify the interrupt handlers. Tracing interrupt pins on the processor to circuitry within the ECU to pins you can reference in a vehicle wiring diagram can help you identify code blocks used to service such hardware functions as fuel and spark control, crank and cam signal processing, and idle functions.</p>&#13;
<div class="image"><img src="graphics/f06-09.jpg" alt="image"/></div>&#13;
<p class="figcap"><a id="ch6fig9"/><em>Figure 6-9: Comparison of a 1996 V8 Mustang</em> (DXE2.bin) <em>and a 1997 V6 Thunderbird</em> (SPP3.bin)</p>&#13;
<div class="image"><span epub:type="pagebreak" id="page_103"/><img src="graphics/f06-10.jpg" alt="image"/></div>&#13;
<p class="figcap"><a id="ch6fig10"/><em>Figure 6-10: File compare function of the HxD hex editor</em></p>&#13;
<h4 class="h4" id="ch06lev2sec8"><strong><em>Identifying ROM Data with WinOLS</em></strong></h4>&#13;
<p class="noindent">WinOLS is a popular commercial program for modifying bins. It combines a series of tools for calculating and updating checksums within a ROM with a set of tools for identifying tables. <a href="ch06.html#ch6fig11">Figures 6-11</a> and <a href="ch06.html#ch6fig12">6-12</a> illustrate WinOLS in use.</p>&#13;
<p class="indent">If the ROM type is known, it has many templates that automatically identify configuration parameters. Most of the known built-in ROM types are geared toward Bosch Motronic ECUs. Templates and configurations can be saved, shared, and sold to enable users to make modifications to specific files with greater ease. WinOLS is arguably the most common software used for identifying interesting data within a ROM that doesn’t involve code analysis. It’s designed to facilitate rapid tuning changes to a controller.</p>&#13;
<div class="image"><span epub:type="pagebreak" id="page_104"/><img src="graphics/f06-11.jpg" alt="image"/></div>&#13;
<p class="figcap"><a id="ch6fig11"/><em>Figure 6-11: WinOLS supports 2D and 3D table views, as shown in these alternate views.</em></p>&#13;
<div class="image"><span epub:type="pagebreak" id="page_105"/><img src="graphics/f06-12.jpg" alt="image"/></div>&#13;
<p class="figcap"><a id="ch6fig12"/><em>Figure 6-12: WinOLS being used on a 2006 Volkswagen 2.0Tsi ECU</em></p>&#13;
<h3 class="h3" id="ch06lev1sec5"><span epub:type="pagebreak" id="page_106"/><strong>Code Analysis</strong></h3>&#13;
<p class="noindent">Code analysis can be a long, complicated task. If you’re starting from scratch, with no experience, it will likely take hundreds of hours to analyze a complex piece of code. Modern control units often have upward of a megabyte or two of code, which is a huge amount of code when you’re looking at it in assembly. An ECU from 1995 with 32 kilobytes (not megabytes) of code will have upward of 10,000 assembly instructions to sort out. Bottom line: do not underestimate how much work this approach will take. I’ll briefly introduce a few tools, but I don’t have the space to address the topic in sufficient depth for someone unfamiliar with the process. (After all, entire books have been written solely on code analysis.) Here, I’ll just talk through specific tools and methods particularly applicable to automotive embedded systems.</p>&#13;
<p class="indent">When analyzing a new target, first identify the architecture you’re working with. Knowing what processor executed the blob of binary will help you choose an appropriate software tool to further assist. If you can’t identify a processor based on the markings on the chip itself, search online for data sheets to identify it.</p>&#13;
<p class="indent">To analyze code, you might need to find a disassembler. A quick Google search reveals that there are lots of them out there. Some target a single architecture—for example, Dis51—and some are custom-written for automotive reverse engineering—for example, Dis66k. Others, like CATS dasm, IDA Pro, Hopper, dasmx, and objdump from the GNU Binary Utilities (binutils), target multiple processors. IDA Pro supports more embedded targets than just about any other program, but it’s also one of the most expensive disassemblers. GNU binutils also supports a pretty wide range of architectures, but the version included on most systems will be built only for the “native” architecture. Rebuilding binutils with all architectures enabled will open a few doors. Your budget and supported processors will determine which disassemblers are an option.</p>&#13;
<p class="indent">Bust out the disassembly tools and start trying to make sense of the mess, but as I warned earlier, this might take hundreds of hours. A divide-and-conquer mentality works best—focus on the smaller tasks rather than the project as a whole. If you obtained the binary by backdoor methods, you probably already took the ECU apart to identify the processor. If you cracked the J2534 programming routines, you might not have a clue what processor is running the show. In this case, you’re going to need to keep running it through a disassembler over and over using different settings until you get something that makes sense.</p>&#13;
<p class="indent">You’re looking for assembly code that disassembles cleanly, meaning that it looks like it makes logical sense. If you disassemble a binary for the wrong architecture or using the wrong settings, you’ll still see assembly instructions, but the assembler actions won’t make sense. Disassembly is a bit of an art, and it may take a little practice at seeing a “clean” assembler <span epub:type="pagebreak" id="page_107"/>to get the hang of identifying when a dissassembler is providing the correct response, especially when nonexecutable tables and data are scattered among the code.</p>&#13;
<p class="indentb">Here are some hints for making sense of disassembled code:</p>&#13;
<p class="bull">• OEMs love to patent stuff. If you can find the patents relevant to your system, you may end up with a guided tour of the code being disassembled. This is probably the most consistently available high-level procedural guide to help you understand the logic in an automotive computer. Patents usually lead production by at least one to two years, if not more.</p>&#13;
<p class="bull">• Look at any available software for manipulating the ECU at hand for insight into the structure and purpose of code segments. You can often infer a model of behavior from tables available to be modified in aftermarket software.</p>&#13;
<p class="bull">• Otherwise, start with a wiring diagram for the vehicle, and trace connections back through ECU circuitry to particular pins on the MCU. This should tell you which piece of MCU hardware handles which function. Cross reference the interrupt tables, or look for calls to service particular pieces of hardware in order to identify which piece(s) of code service that hardware function.</p>&#13;
<p class="indentt">A plain, or old-style, disassembler will output very verbose text. Each individual instruction is parsed. Some disassemblers will attempt to mark areas referenced as data and void disassembling them. Other disassemblers need to be specifically told which areas are code and which areas are data.</p>&#13;
<h4 class="h4" id="ch06lev2sec9"><strong><em>A Plain Disassembler at Work</em></strong></h4>&#13;
<p class="noindent">To see disassembly in action, we’ll look at a plain disassembly of a 1990 Nissan 300ZX Twin Turbo ROM. This ECU has a 28-pin external 27C256 EPROM, so it’s relatively easy to obtain its contents. This particular platform uses a HD6303 MCU, a derivative of the Motorola 6800 8-bit MCU that appears to be supported by the free disassembler DASMx (see <em><a href="http://www.16paws.com/ECU/DASMxx/DASMx.htm">http://www.16paws.com/ECU/DASMxx/DASMx.htm</a></em>). DASMx comes with minimal instructions: to disassemble <em>foo.bin</em>, create a file, <em>foo.sym</em>, that describes which platform is in use, and then create an entry point in memory to place the image, symbols you know about, and so on. Time for a crash course in the architecture!</p>&#13;
<p class="indent">A critical point about the memory structure is that the MCU can address 65535 bytes (64KB). This information tells you what to expect when looking at the addresses in your binary blob. Further reading suggests that the interrupt vector table lies at the <em>end</em> of addressable memory, with the reset vector—where every processor starts after a reset—at 0xFFFE/0xFFFF. Assuming that the 32KB (0x7FFF hex) binary blob we have from reading the <span epub:type="pagebreak" id="page_108"/>EPROM contains the interrupt vector table, we can figure out that the binary image needs to start at memory address 0x8000 for it to end at 0xFFFF (0xFFFF – 0x7FFF = 0x8000). It also helps to search online to see whether others are trying to do something similar. For example, the post at <em><a href="http://forum.nistune.com/viewtopic.php?f=2&amp;t=417">http://forum.nistune.com/viewtopic.php?f=2&amp;t=417</a></em> is for a smaller 16KB binary based on settings for a 0xC000 entry point. The more legwork and research you do prior to actually invoking a disassembler, the more likely you are to get reasonable results.</p>&#13;
<p class="indent"><a href="ch06.html#ch6fig13">Figure 6-13</a> shows the symbol table for the 300ZX binary. Next to each <code>symbol</code> is the memory address used by the firmware. These memory addresses can hold values such as incoming data from different physical pins on the chip or internal information, like timing.</p>&#13;
<div class="image"><img src="graphics/f06-13.jpg" alt="image"/></div>&#13;
<p class="figcap"><a id="ch6fig13"/><em>Figure 6-13: Symbol file for 32KB 300ZX binary disassembly with DASMx</em></p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_109"/>We’ll use DASMx to disassemble the binary. As shown in <a href="ch06.html#ch6fig14">Figure 6-14</a>, DASMx reports a Hitachi 6303 MCU with a source file length, or size, of 32KB, which is 32768 bytes.</p>&#13;
<div class="image"><img src="graphics/f06-14.jpg" alt="image"/></div>&#13;
<p class="figcap"><a id="ch6fig14"/><em>Figure 6-14: Running DASMx to disassemble 32KB 300ZX binary</em></p>&#13;
<p class="indent">Now cross your fingers and hope for a meaningful result!</p>&#13;
<p class="indent">The result is the vector table shown in <a href="ch06.html#ch6fig15">Figure 6-15</a>, which looks sane enough: all addresses are above the 0x8000 entry point specified. Notice that the reset vector (0xFFFE, <code>RES-vector</code>) has a pointer to the <code>RESET_entry</code> at 0xBE6D.</p>&#13;
<div class="image"><img src="graphics/f06-15.jpg" alt="image"/></div>&#13;
<p class="figcap"><a id="ch6fig15"/><em>Figure 6-15: Disassembled vector table</em></p>&#13;
<p class="indent">We can disassemble the code at 0xBE6D for the reset vector, which is also the entry point for code. In <a href="ch06.html#ch6fig16">Figure 6-16</a>, we see a routine, <code>RESET_entry</code>, that looks like it wipes a chunk of RAM. This is a plausible part of the initial reset sequence because often when booting, firmware will initialize the data region to all 0s.</p>&#13;
<div class="image"><span epub:type="pagebreak" id="page_110"/><img src="graphics/f06-16.jpg" alt="image"/></div>&#13;
<p class="figcap"><a id="ch6fig16"/><em>Figure 6-16: Reset vector disassembly</em></p>&#13;
<p class="indent">We’ve taken this example as far as obtaining a disassembled binary image and looking for basic sanity. Now, for the hard part: following the code, breaking it into routines, and trying to figure out how it works.</p>&#13;
<h4 class="h4" id="ch06lev2sec10"><strong><em>Interactive Disassemblers</em></strong></h4>&#13;
<p class="noindent">As of this writing, IDA Pro is the most popular interactive disassembler available. It performs the same tasks as the simple disassembler just discussed, and more. Specifically, IDA Pro names registers and variables; once IDA Pro identifies and names a variable, or memory address—for instance, $FC50–RPM—it gives all references to that variable within the code a descriptive name rather than a less-recognizable plain hex address. IDA Pro also graphs code to visualize program flow.</p>&#13;
<p class="indent">One of the advantages of IDA Pro is that it’s programmable to allow additional opcodes for customizing automotive processors and plugins for further processing disassembled code (for example, decompiling assembly into higher language code); it also lets you use structs, unions, classes, and other user-defined data types.</p>&#13;
<p class="indent">Lastly, IDA Pro supports more embedded platforms out of the box than just about any other disassembler currently available.</p>&#13;
<p class="indent">You don’t necessarily need these functions to successfully analyze code, but they make things substantially easier. <a href="ch06.html#ch6fig17">Figures 6-17</a> and <a href="ch06.html#ch6fig18">6-18</a> are screenshots from real code analysis with IDA Pro. Thanks to Matt Wallace for graciously posting these examples in a public forum.</p>&#13;
<p class="indent">The user in <a href="ch06.html#ch6fig18">Figure 6-18</a> obtained Acura NSX ECU firmware through a combination of hardware-hacking approaches, took the code apart, analyzed it using IDA Pro, and rewrote it. Next, the user determined the necessary functions to log data from the ECU and alter its operation. The result allowed the user to use forced induction—that is, turbochargers and superchargers—with a factory computer; this would have been impossible without ECU modification.</p>&#13;
<div class="image"><span epub:type="pagebreak" id="page_111"/><img src="graphics/f06-17.jpg" alt="image"/></div>&#13;
<p class="figcap"><a id="ch6fig17"/><em>Figure 6-17: IDA diagram showing a custom-written routine for NVRAM real-time programming</em></p>&#13;
<div class="image"><span epub:type="pagebreak" id="page_112"/><img src="graphics/f06-18.jpg" alt="image"/></div>&#13;
<p class="figcap"><a id="ch6fig18"/><em>Figure 6-18: IDA diagram of code for checking fuel injectors on NSX ECU</em></p>&#13;
<h3 class="h3" id="ch06lev1sec6"><span epub:type="pagebreak" id="page_113"/><strong>Summary</strong></h3>&#13;
<p class="noindent">Because hacking on the ECU often involves processors that are smaller than those used in more powerful modern devices, such as cell phones, the tools used for reversing the firmware differ for each target. By using a combination of techniques, such as data visualization to locate tables, and by reversing the firmware directly, you can identify the areas you’re interested in modifying. The methods discussed in this chapter are techniques commonly used by performance tuners to adjust how a vehicle handles fuel efficiency. All can be used to unlock features hidden in the code of your vehicle. We’ll look at performance tuning in more detail in <a href="ch13.html#ch13">Chapter 13</a>.<span epub:type="pagebreak" id="page_114"/></p>&#13;
</body></html>