- en: <hgroup>
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">7</samp> <samp class="SANS_Dogma_OT_Bold_B_11">KEYED
    HASHING</samp>
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: </hgroup>
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/opener.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The hash functions in [Chapter 6](chapter6.xhtml) take a message and return
    its hash value—typically a short string of 256 or 512 bits. Anyone can compute
    the hash value of a message and verify that a particular message hashes to a particular
    value. When you want only specific people to compute hashes, however, you’ll hash
    with secret keys using *keyed* hash functions.
  prefs: []
  type: TYPE_NORMAL
- en: 'Keyed hashing forms the basis of two types of cryptographic algorithms: *message
    authentication codes (MACs)*, which authenticate a message and protect its integrity,
    and *pseudorandom functions (PRFs)*, which produce random-looking hash-sized values.
    We’ll look at the similarities between MACs and PRFs in the first section of this
    chapter before reviewing how MACs and PRFs work. Some MACs and PRFs are based
    on hash functions, some are based on block ciphers, and others are original designs.
    Finally, we’ll discuss examples of attacks on otherwise-secure MACs.'
  prefs: []
  type: TYPE_NORMAL
- en: '### <samp class="SANS_Futura_Std_Bold_B_11">Message Authentication Codes</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: A MAC protects a message’s integrity and authenticity by creating a value *T*
    = **MAC**(*K*, *M*), called the authentication tag of the message, *M* (often
    confusingly called the MAC of *M*). Just as you can decrypt a message if you know
    a cipher’s key, you can validate that a message hasn’t been modified if you know
    a MAC’s key.
  prefs: []
  type: TYPE_NORMAL
- en: For example, say Alex and Bill share a key, *K*, and Alex sends a message, *M*,
    to Bill along with its authentication tag, *T* = **MAC**(*K*, *M*). Upon receiving
    the message and its authentication tag, Bill recomputes **MAC**(*K*, *M*) and
    checks that it’s equal to the authentication tag received. Because only Alex could
    have computed this value, Bill knows that the message wasn’t corrupted in transit
    (confirming its integrity), whether accidentally or maliciously, and that Alex
    sent that message (confirming its authenticity).
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">MACs in Secure Communication</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Secure communication systems often combine a cipher and a MAC to protect a message’s
    confidentiality, integrity, and authenticity. For example, the protocols in Internet
    Protocol Security (IPsec), SSH, and TLS generate a MAC for each transmitted network
    packet.
  prefs: []
  type: TYPE_NORMAL
- en: Not all communication systems use MACs. Sometimes an authentication tag can
    add unacceptable overhead to each packet, typically in the range of 64 to 128
    bits. For example, the old GSM mobile telephony standard encrypted packets encoding
    voice calls but didn’t authenticate them. An attacker could modify the encrypted
    audio signal, and the recipient wouldn’t notice.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Forgery and Chosen-Message
    Attacks</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: What does it mean for a MAC to be secure? First, as with a cipher, the secret
    key should remain secret. If a MAC is secure, an attacker shouldn’t be able to
    create a tag of some message if they don’t know the key. We call a fabricated
    message/tag pair a *forgery*, and recovering a key is a specific case of a more
    general class of *forgery attacks*. The security notion that posits that forgeries
    should be impossible to find is *unforgeability*. It should also be impossible
    to recover the secret key from a list of tags; otherwise, attackers could forge
    tags using the key.
  prefs: []
  type: TYPE_NORMAL
- en: What can an attacker do to break a MAC? In other words, what’s the attack model?
    The most basic attack model is the *known-message attack*, which passively collects
    messages and their associated tags (for example, by eavesdropping on a network).
    But real attackers can often launch *active* attacks because they can choose the
    messages to be authenticated and therefore get the MAC of the message they want.
    The standard model is thus *chosen-message attacks*, wherein attackers get tags
    for messages of their choice.
  prefs: []
  type: TYPE_NORMAL
- en: '#### <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Replay Attacks</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: MACs aren’t safe from attacks involving *replays* of tags. For example, if you
    were to eavesdrop on Alex and Bill’s communications, you could capture a message
    and its tag sent by Alex to Bill and later send them again to Bill pretending
    to be Alex. To prevent such *replay attacks*, protocols include a message number
    in each message. This number is incremented for each new message and authenticated
    along with the message by the MAC. The receiving party gets messages numbered
    1, 2, 3, 4, and so on. Thus, if an attacker tries to send message 1 again, the
    receiver notices that this message is out of order and that it’s a potential replay
    of the earlier message 1.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Pseudorandom Functions</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A PRF uses a secret key to return **PRF**(*K*, *M*), such that the output looks
    random. Because the key is secret, the output values are unpredictable to an attacker.
  prefs: []
  type: TYPE_NORMAL
- en: Unlike MACs, PRFs are not meant to be used on their own but as part of a cryptographic
    algorithm or protocol. For example, you can use PRFs to create block ciphers within
    the Feistel construction—see “How to Construct Block Ciphers” in [Chapter 4](chapter4.xhtml).
    Key derivation schemes use PRFs to generate cryptographic keys from a master key
    or password, and identification schemes use PRFs to generate a response from a
    random challenge. (Basically, a server sends a random challenge message, *M*,
    and the client returns **PRF**(*K*, *M*) in its response to prove that it knows
    *K*.) The 5G telephony standard uses a PRF to authenticate a SIM card and its
    service provider, and a similar PRF generates the encryption key and MAC key to
    be used during a phone call. The TLS protocol uses a PRF to generate key material
    from a master secret as well as session-specific random values. There’s even a
    PRF in the noncryptographic <samp class="SANS_TheSansMonoCd_W5Regular_11">hash()</samp>
    function built into the Python language to compare objects.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">PRF Security</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: To be secure, a pseudorandom function should have no pattern that sets its outputs
    apart from truly random values. An attacker who doesn’t know the key, *K*, shouldn’t
    be able to distinguish the outputs of **PRF**(*K*, *M*) from random values. Viewed
    differently, an attacker shouldn’t have any means of knowing whether they’re talking
    to a PRF algorithm or to a random function. The erudite phrase for that security
    notion is “ indistinguishability from a random function.” (To learn more about
    the theoretical foundations of PRFs, see Volume 1, Section 3.6 of Goldreich’s
    *Foundations of Cryptography*.)
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">PRFs Are Stronger
    Than MACs</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: PRFs and MACs are keyed hashes, but PRFs are fundamentally stronger than MACs
    because MACs have weaker security requirements. Whereas you would consider a MAC
    secure if an attacker can’t forge tags—that is, if they can’t guess the MAC’s
    outputs—a PRF is secure only if its outputs are indistinguishable random strings.
    If you can’t distinguish a PRF’s outputs from random strings, this implies their
    values can’t be guessed; in other words, any secure PRF is also a secure MAC.
  prefs: []
  type: TYPE_NORMAL
- en: 'The converse is not true, however: a secure MAC isn’t necessarily a secure
    PRF. For example, say you start with a secure PRF, **PRF1**, and you want to build
    a second PRF, **PRF2**, from it, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/pg142-1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Because **PRF2**’s output is defined as **PRF1**’s output followed by one 0
    bit, it doesn’t look as random as a true random string, and you can distinguish
    its outputs by that last 0 bit. Hence, **PRF2** is not a secure PRF. However,
    because **PRF1** is secure, **PRF2** would still make a secure MAC. If you were
    able to forge a tag, *T* = **PRF2**(*K*, *M*), for some *M*, then you’d also be
    able to forge a tag for **PRF1**, which you know to be impossible in the first
    place because PRF1 is a secure MAC. Thus, PRF2 is a keyed hash that’s a secure
    MAC but not a secure PRF.
  prefs: []
  type: TYPE_NORMAL
- en: 'But don’t worry: you won’t find such MAC constructions in real applications.
    In fact, many of the deployed or standardized MACs are also secure PRFs and are
    often used as either. For example, TLS uses the algorithm HMAC-SHA-256 both as
    a MAC and as a PRF.'
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">How to Create Keyed Hashes from Unkeyed
    Hashes</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Throughout cryptography’s history, MACs and PRFs have rarely been designed from
    scratch but rather have been built from existing algorithms, usually hash functions
    or block ciphers. It might seem obvious that you can produce a keyed hash function
    by feeding an (unkeyed) hash function a key and a message, but this is easier
    said than done.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">The Secret-Prefix
    Construction</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The first technique we’ll examine, the *secret-prefix construction*, turns a
    normal hash function into a keyed hash by prepending the key to the message and
    returning **Hash**(*K* || *M*). This approach is insecure when the hash function
    is vulnerable to length-extension attacks (see “The Length-Extension Attack” in
    [Chapter 6](chapter6.xhtml)) and when the hash supports keys of different lengths.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Insecurity Against Length-Extension
    Attacks</samp>
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Recall from [Chapter 6](chapter6.xhtml) that hash functions of the SHA-2 family
    allow attackers to compute the hash of a partially unknown message when given
    a hash of a shorter version of that message. In formal terms, the length-extension
    attack allows attackers to compute **Hash**(*K* || *M*[1] || *M*[2]) given only
    **Hash**(*K* || *M*[1]) and neither *M*[1] nor *K*. These functions allow attackers
    to forge valid MAC tags for free because they shouldn’t be able to guess the MAC
    of *M*[1] || *M*[2] given only the MAC of *M*[1]. This fact makes the secret-prefix
    construction insecure as a MAC and PRF when, for example, using it with SHA-256
    or SHA-512\. It’s a weakness of Merkle–Damgård to allow length-extension attacks,
    and none of the SHA-3 finalists do. The ability to thwart length-extension attacks
    was mandatory for SHA-3 submissions (see [Chapter 6](chapter6.xhtml)).
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Insecurity with Different
    Key Lengths</samp>
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: The secret-prefix construction is also insecure when allowing the use of keys
    of different lengths. For example, if the key *K* is the 24-bit hexadecimal string
    123abc and *M* is def00, then **Hash**() processes the value *K* || *M* = 123abcdef00\.
    If *K* is instead the 16-bit string 123a and *M* is bcdef000, then **Hash**()
    processes *K* || *M* = 123abcdef00, too. Therefore, the result of the secret-prefix
    construction **Hash**(*K* || *M*) is the same for both keys.
  prefs: []
  type: TYPE_NORMAL
- en: This problem is independent of the underlying hash; you can fix it by hashing
    the key’s length along with the key and the message—for example, by encoding the
    key’s bit length as a 16-bit integer, *L*, and then hashing **Hash**(*L* || *K*
    || *M*). You shouldn’t have to do this, however, as modern hash functions such
    as BLAKE2 and SHA-3 include a keyed mode that avoids these pitfalls and yields
    a secure PRF and thus a secure MAC as well.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">The Secret-Suffix
    Construction</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Instead of hashing the key before the message as in the secret-prefix construction,
    you can hash it *after*. And that’s exactly how the *secret-suffix construction*
    works by building a PRF from a hash function as **Hash**(*M* || *K*).
  prefs: []
  type: TYPE_NORMAL
- en: Putting the key at the end makes quite a difference. The length-extension attack
    that works against secret-prefix MACs won’t work against the secret suffix. Applying
    length extension to a secret-suffix MAC results in **Hash**(*M*[1] || *K* || *M*[2])
    from **Hash**(*M*[1] || *K*), but this isn’t a valid attack because **Hash**(*M*[1]
    || *K* || *M*[2]) isn’t a valid secret-suffix MAC; the key needs to be at the
    end.
  prefs: []
  type: TYPE_NORMAL
- en: However, the secret-suffix construction is weaker against another type of attack.
    Say you’ve got a collision for the hash **Hash**(*M*[1]) = **Hash**(*M*[2]), where
    *M*[1] and *M*[2] are two distinct messages, possibly of different sizes. In the
    case of an M–D hash function such as SHA-256, this implies that **Hash**(*M*[1]
    || *P*[1] || *K*) and **Hash**(*M*[2] || *P*[2] || *K*) will be equal too, where
    *P*[1] and *P*[2] are the padding data added to complete a block. After processing
    *M*[1] || *P*[1], the hash function’s state is the same as after processing *M*[2]
    || *P*[2]. Adding K to each instance preserves the equality of the state, leading
    to a collision regardless of *K*’s value.
  prefs: []
  type: TYPE_NORMAL
- en: 'To exploit this property, an attacker:'
  prefs: []
  type: TYPE_NORMAL
- en: 1.  Finds two colliding messages, *M*[1] and *M*[2]
  prefs: []
  type: TYPE_NORMAL
- en: 2.  Requests the MAC tag of *M*[1], **Hash**(*M*[1] || *K*)
  prefs: []
  type: TYPE_NORMAL
- en: 3.  Guesses that **Hash**(*M*[2] || *K*) is the same, thereby forging a valid
    tag and breaking the MAC’s security
  prefs: []
  type: TYPE_NORMAL
- en: '#### <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">The HMAC Construction</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: The *hash-based MAC (HMAC)* construction allows you to build a MAC from a hash
    function, which is more secure than either secret prefix or secret suffix. HMAC
    yields a secure PRF as long as the underlying hash is collision resistant, but
    even if that isn’t the case, HMAC still yields a secure PRF if the hash’s compression
    function is a PRF. The secure communication protocols IPsec, SSH, and TLS have
    all used HMAC. (You’ll find HMAC specifications in the NIST FIPS 198-1 standard
    and in RFC 2104.)
  prefs: []
  type: TYPE_NORMAL
- en: 'HMAC uses a hash function, **Hash**, to compute a MAC tag, as [Figure 7-1](chapter7.xhtml#fig7-1)
    shows and according to the following expression:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/pg144-1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The value *opad* (outer padding) is the hexadecimal string <samp class="SANS_TheSansMonoCd_W5Regular_11">5c5c5c.
    . .5c</samp> as long as **Hash**’s block size. The key, *K*, is usually shorter
    than one block that’s filled with <samp class="SANS_TheSansMonoCd_W5Regular_11">00</samp>
    bytes and XORed with *opad*. For example, if *K* is the 1-byte string <samp class="SANS_TheSansMonoCd_W5Regular_11">00</samp>,
    then *K* ⊕ *opad* = *opad*. (The same is true if *K* is the all-zero string of
    any length up to a block’s length.) *K* ⊕ *opad* is the first block processed
    by the outer call to **Hash**—namely, the leftmost **Hash** in the preceding equation,
    or the bottom hash in [Figure 7-1](chapter7.xhtml#fig7-1).
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/fig7-1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 7-1: The HMAC hash-based
    MAC construction for a hash function based on a compression function</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: The value *ipad* (inner padding) is a string (363636 . . . 36) as long as the
    **Hash**’s block size and completed with 00 bytes. The resulting block is the
    first processed by the inner call to **Hash**—namely, the rightmost **Hash** in
    the equation, or the top hash in [Figure 7-1](chapter7.xhtml#fig7-1).
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Dogma_OT_Bold_B_15">NOTE</samp>
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*The envelope method is a more secure construction than secret prefix or secret
    suffix. It’s expressed as* ***Hash****(*K *||* M *||* K*), a* sandwich MAC*, but
    it’s theoretically less secure than HMAC.*'
  prefs: []
  type: TYPE_NORMAL
- en: If SHA-256 is the hash function used as **Hash**, then you call the HMAC instance
    HMAC-SHA-256\. More generally, you call HMAC-*Hash* an HMAC instance using the
    hash function *Hash*. That means if someone asks you to use HMAC, you should always
    ask, “Which hash function?”
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">A Generic Attack
    Against Hash-Based MACs</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: There is one attack that works against all MACs based on an iterated hash function.
    Recall the attack in “The Secret-Suffix Construction” on [page 143](#sec12) where
    we used a hash collision to get a collision of MACs. You can use the same strategy
    to attack a secret-prefix MAC or HMAC, though the consequences are less devastating.
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 7-2](chapter7.xhtml#fig7-2) illustrates the secret-prefix MAC **Hash**(*K*
    || *M*).'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/fig7-2.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 7-2: The principle of
    the generic forgery attack on hash-based MACs</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: If the digest is *n* bits, you can find two messages, *M*[1] and *M*[2], such
    that **Hash**(*K* || *M*[1]) = **Hash**(*K* || *M*[2]), by requesting approximately
    2*^n*^(/2) MAC tags to the system holding the key. (Recall the birthday attack
    from [Chapter 6](chapter6.xhtml).) If the hash lends itself to length extension,
    as SHA-256 does, you can then use *M*[1] and *M*[2] to forge MACs by choosing
    some arbitrary data, *M*[3], and then querying the MAC oracle for **Hash**(*K*
    || *M*[1] || *M*[3]), which is the MAC of message *M*[1] || *M*[3]. As it turns
    out, this is also the MAC of message *M*[2] || *M*[3] because the hash’s internal
    state of *M*[1] and *M*[3] and *M*[2] and *M*[3] is the same. You’ve successfully
    forged a MAC tag. (The effort becomes infeasible as *n* grows beyond, say, 128
    bits.)
  prefs: []
  type: TYPE_NORMAL
- en: 'This attack works even if the hash function isn’t vulnerable to length extension,
    and it works for HMAC, too. This is because all that’s required is an internal
    collision in the hash function and not necessarily in the complete hash. The cost
    of the attack depends on both the size of the chaining value and the MAC’s length:
    if a MAC’s chaining value is 512 bits and its tags are 128 bits, a 2^(64) computation
    would find a MAC collision but probably not a collision in the internal state,
    since finding such a collision requires 2^(512/2) = 2^(256) operations on average.'
  prefs: []
  type: TYPE_NORMAL
- en: '### <samp class="SANS_Futura_Std_Bold_B_11">How to Create Keyed Hashes from
    Block Ciphers</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: The compression functions in many hash functions are built on block ciphers
    (see [Chapter 6](chapter6.xhtml)). For example, HMAC-SHA-256 PRF is a series of
    calls to SHA-256’s compression function, which is a block cipher that repeats
    a sequence of rounds. In other words, HMAC-SHA-256 is a block cipher inside a
    compression function inside a hash inside the HMAC construction. So why not use
    a block cipher directly rather than build such a layered construction?
  prefs: []
  type: TYPE_NORMAL
- en: '*Cipher-based MAC (CMAC)* is such a construction: it creates a MAC given only
    a block cipher, such as AES. Though less popular than HMAC, CMAC is deployed in
    many systems, including the Internet Key Exchange (IKE) protocol, which is part
    of the IPsec suite. IKE, for example, generates key material using the AES-CMAC-PRF-128
    construction as a core algorithm (or CMAC based on AES with 128-bit output). CMAC
    is specified in RFC 4493.'
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Breaking CBC-MAC</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: CMAC was designed in 2005 as an improved version of *CBC-MAC*, a simpler block
    cipher–based MAC derived from the cipher block chaining (CBC) block cipher mode
    of operation (see “Modes of Operation” in [Chapter 4](chapter4.xhtml)).
  prefs: []
  type: TYPE_NORMAL
- en: 'CBC-MAC, the ancestor of CMAC, is simple: to compute the tag of a message,
    *M*, given a block cipher, **E**, encrypt *M* in CBC mode with an all-zero initial
    value (IV) and discard all but the last ciphertext block. That is, compute'
  prefs: []
  type: TYPE_NORMAL
- en: '*C*[1] = **E**(*K*, *M*[1]), *C*[2] = **E**(*K*, *M*[2] ⊕ *C*[1]), *C*[3] =
    **E**(*K*, *M*[3] ⊕ *C*[2])'
  prefs: []
  type: TYPE_NORMAL
- en: and so on for each of *M*’s blocks and keep only the last *C*i—your CBC-MAC
    tag for *M*—simple, and simple to attack.
  prefs: []
  type: TYPE_NORMAL
- en: To understand why CBC-MAC is insecure, consider the CBC-MAC tag, *T*[1] = **E**(*K*,
    *M*[1]), of a single-block message, *M*[1], and the tag, *T*[2] = **E**(*K*, *M*[2]),
    of another single-block message, *M*[2]. Given these two pairs, (*M*[1], *T*[1])
    and (*M*[2], *T*[2]), you can deduce that *T*[2] is also the tag of the two-block
    message *M*[1] || (*M*[2] ⊕ *T*[1]). If you apply CBC-MAC to *M*[1] || (*M*[2]
    ⊕ *T*[1]) and compute *C*[1] = **E**(*K*, *M*[1]) = *T*[1] followed by *C*[2]
    = **E**(*K*, (*M*[2] ⊕ *T*[1]) ⊕ *T*[1]) = **E**(*K*, *M*[2]) = *T*[2], you can
    create a third message/tag pair from two message/tag pairs without knowing the
    key. That is, you can forge CBC-MAC tags, thereby breaking CBC-MAC’s security.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Fixing CBC-MAC</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: CMAC fixes CBC-MAC by processing the last block using a different key from the
    preceding blocks. To do this, CMAC first derives two keys, *K*[1] and *K*[2],
    from the main key, *K*, such that *K*, *K*[1], and *K*[2] are distinct. CMAC processes
    the last block using either *K*[1] or *K*[2], while the preceding blocks use *K*.
  prefs: []
  type: TYPE_NORMAL
- en: To determine *K*[1] and *K*[2], CMAC first computes a temporary value, *L* =
    **E**(0, *K*), where 0 acts as the key of the block cipher and *K* acts as the
    plaintext block. Then CMAC sets *K*[1] to (*L* << 1) if *L*’s most significant
    bit (MSB) is 0 and to (*L* << 1) ⊕ <samp class="SANS_TheSansMonoCd_W5Regular_11">87</samp>
    if *L*’s MSB is 1\. (The hexadecimal number <samp class="SANS_TheSansMonoCd_W5Regular_11">87</samp>,
    or 135 in decimal, is chosen for its mathematical properties when data blocks
    are 128 bits; a different value is needed when blocks aren’t 128 bits.) The key
    *K*[2] is set to (*K*[1] << 1) if *K*[1]’s MSB is 0 and to *K*[2] = (*K*[1] <<
    1) ⊕ <samp class="SANS_TheSansMonoCd_W5Regular_11">87</samp> otherwise.
  prefs: []
  type: TYPE_NORMAL
- en: Given *K*[1] and *K*[2], CMAC works like CBC-MAC, except for the last block.
    If the final message chunk *M*n is exactly the size of a block, CMAC returns **E**(*K*,
    *M*n ⊕ *C*n [− 1] ⊕ *K*[1]) as a tag, as [Figure 7-3](chapter7.xhtml#fig7-3) illustrates.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/fig7-3.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 7-3: The CMAC block
    cipher–based MAC construction when the message is a sequence of integral blocks</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: If *M*n has fewer bits than a block, CMAC pads it with a 1 bit and 0s and returns
    **E**(*K*, *M*n ⊕ *C*n [− 1] ⊕ *K*[2]) as a tag, as in [Figure 7-4](chapter7.xhtml#fig7-4).
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/fig7-4.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 7-4: The CMAC block
    cipher–based MAC construction when the last block of the message has to be padded
    with 1 bit and zeros to fill a block</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: The first case uses only *K*[1] and the second only *K*[2], but both use the
    main key *K* to process the message chunks that precede the final one.
  prefs: []
  type: TYPE_NORMAL
- en: 'Unlike the CBC encryption mode, CMAC doesn’t take an IV as a parameter and
    is deterministic: for the same key, CMAC always returns the same tag for a given
    message, *M*, because the computation of **CMAC**(*M*) isn’t randomized—and that’s
    fine because unlike encryption, MAC computation doesn’t have to be randomized
    to be secure, which eliminates the burden of having to choose random IV.  ###
    <samp class="SANS_Futura_Std_Bold_B_11">Dedicated MAC Designs</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: You’ve seen how to recycle hash functions and block ciphers to build PRFs that
    are secure as long as their underlying hash or cipher is secure. Schemes such
    as HMAC and CMAC simply combine available hash functions or block ciphers to yield
    a secure PRF or MAC. Reusing available algorithms is convenient, but is it the
    most efficient approach?
  prefs: []
  type: TYPE_NORMAL
- en: Intuitively, PRFs and MACs should require less work to be secure than unkeyed
    hash functions—their use of a secret key prevents attackers from playing with
    the algorithm because they don’t have the key. Also, PRFs and MACs expose only
    a short tag to attackers, unlike block ciphers, which expose a ciphertext as long
    as the message. Hence, PRFs and MACs shouldn’t need the maximum power of hash
    functions or block ciphers—this is the point of *dedicated design*, that is, algorithms
    created solely to serve as PRFs or MACs.
  prefs: []
  type: TYPE_NORMAL
- en: 'The sections that follow focus on two such algorithms: Poly1305 and SipHash.
    I’ll explain their design principles and why they’re (most likely) secure.'
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Poly1305</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The Poly1305 algorithm (pronounced *poly*-*thirteen*-*o-five*) was designed
    in 2005 by Daniel J. Bernstein (creator of the Salsa20 stream cipher from [Chapter
    5](chapter5.xhtml) and the ChaCha cipher that inspired the BLAKE and BLAKE2 hash
    functions from [Chapter 6](chapter6.xhtml)). Poly1305 is optimized to be superfast
    on modern CPUs, and as I write this, it’s one of the algorithms supported in TLS
    1.3 and in OpenSSH, among many other applications. Unlike Salsa20, the design
    of Poly1305 is built on techniques dating back to the 1970s—namely, universal
    hash functions and the Wegman–Carter construction.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Universal Hash Functions</samp>
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: The Poly1305 MAC uses a *universal hash function*. Such a hash function is weaker
    than a cryptographic hash function but much faster. Universal hash functions don’t
    have to be collision resistant, for example.
  prefs: []
  type: TYPE_NORMAL
- en: 'Like a PRF, a universal hash is parameterized by a secret key: given a message,
    *M*, and key, *K*, we’ll write **UH**(*K*, *M*) for the output of a universal
    hash function denoted **UH**. A universal hash function has only one security
    requirement: for any two messages *M*[1] and *M*[2], and a random key *K*, the
    probability that **UH**(*K*, *M*[1]) equals **UH**(*K*, *M*[2]) must be negligible.
    Unlike a PRF, a universal hash doesn’t need to be pseudorandom; there simply should
    be no pair (*M*[1], *M*[2]) that gives the same hash for many different keys.
    Because their security requirements are easier to satisfy, universal hash functions
    require fewer operations and are considerably faster than PRFs.'
  prefs: []
  type: TYPE_NORMAL
- en: 'You can use a universal hash as a MAC to authenticate no more than one message,
    however. For example, consider the universal *polynomial-evaluation* hash used
    in Poly1305\. (See the seminal 1974 article “Codes Which Detect Deception” by
    Edgar Gilbert, Jessie MacWilliams, and Neil Sloane for more on this notion.) This
    kind of polynomial-evaluation hash is parameterized by a prime number, *p*, and
    takes as input a key consisting of two numbers, *R* and *K*, in the range [1,
    *p*) and a message, *M*, consisting of *n* blocks (*M*[1], *M*[2], . . . , *M*n).
    You then compute the output of the universal hash as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/pg149-1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In this equation, the plus sign (+) denotes the addition of positive integers,
    *K* *^i* is the number *K* raised to the power *i*, and “mod *p*” denotes the
    reduction modulo *p* of the result (that is, the remainder of the division of
    the result by *p*; for example, 12 mod 10 = 2, 10 mod 10 = 0, 8 mod 10 = 8, and
    so on).
  prefs: []
  type: TYPE_NORMAL
- en: Because you want the hashing operation to be as fast as possible, universal
    hash-based MACs often work with message blocks of 128 bits and with a prime number,
    *p*, that’s slightly larger than 2^(128), such as 2^(128) + 51\. The 128-bit width
    allows for very fast implementations by efficiently using the 32- and 64-bit arithmetic
    units of common CPUs.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Security Limitations</samp>
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Universal hashes have one weakness: because a universal hash securely authenticates
    only one message, an attacker could break the preceding polynomial-evaluation
    MAC by requesting the tags of only two messages. Specifically, they could request
    the tag for a message where all blocks are zero—*M*[1] = *M*[2] = . . . = 0—to
    obtain the tag **UH**(*R*, *K*, 0) = *R*, thus finding the secret value *R*. Alternatively,
    they could request the tags for a message where *M*[1] = 1 and where *M*[2] =
    *M*[3] = . . . = 0 (whose tag is *T* = *R* + *K*), which allows them to find *K*
    by subtracting *R* from *T*. Now the attacker knows the whole key (*R*, *K*) and
    can forge MACs for any message.'
  prefs: []
  type: TYPE_NORMAL
- en: Fortunately, there’s a way to go from single-message security to multimessage
    security.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Wegman–Carter MACs</samp>
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: The trick to authenticating multiple messages using a universal hash function
    arrived thanks to IBM researchers Mark Wegman and Lawrence Carter and their 1981
    paper “New Hash Functions and Their Use in Authentication and Set Equality.” The
    Wegman–Carter construction builds a MAC from a universal hash function and a PRF,
    using two keys, *K*[1] and *K*[2], and it returns
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/pg149-2.jpg)'
  prefs: []
  type: TYPE_IMG
- en: where *N* is a nonce that must be used at most once for each key, *K*[2], and
    where **PRF**’s output is as large as that of the universal hash function **UH**.
    By adding these two values, **PRF**’s strong pseudorandom output masks the cryptographic
    weakness of **UH**. You can see this as the encryption of the universal hash’s
    result, where the PRF acts as a stream cipher and prevents the preceding attack
    by making it possible to authenticate multiple messages with the same key, *K*[1].
  prefs: []
  type: TYPE_NORMAL
- en: 'To recap, the Wegman–Carter construction **UH**(*K*[1], *M*) + **PRF**(*K*[2],
    *N*) gives a secure MAC if you assume the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**UH** is a secure universal hash.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**PRF** is a secure PRF.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Each nonce *N* is used only once for each key *K*[2].
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The output values of **UH** and **PRF** are long enough to ensure high enough
    security.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now let’s see how Poly1305 leverages the Wegman–Carter construction to build
    a secure and fast MAC.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Poly1305-AES</samp>
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Poly1305 was initially proposed as Poly1305-AES, combining the Poly1305 universal
    hash with the AES block cipher. Poly1305-AES is much faster than HMAC-based MACs,
    or even than CMACs, since it computes only one block of AES and processes the
    message in parallel through a series of simple arithmetic operations.
  prefs: []
  type: TYPE_NORMAL
- en: 'Given 128-bit *K*[1], *K*[2], and *N* and the message *M*, Poly1305-AES returns
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/pg150-1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The mod 2^(128) reduction ensures that the result fits in 128 bits. Poly1305
    parses the message *M* as a sequence of 128-bit blocks (*M*[1], *M*[2], . . .
    , *M*n) and appends a 129th bit to each block’s most significant bit to make all
    blocks 129 bits long. (If the last block is smaller than 16 bytes, it’s padded
    with a 1 bit followed by 0 bits before the final 129th bit.) Next, Poly1305 evaluates
    the polynomial to compute the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/pg150-2.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The result of this expression is an integer that’s at most 129 bits long. When
    you add this to the 128-bit value **AES**(*K*[2], *N*), the result is reduced
    modulo 2^(128) to produce a 128-bit MAC.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Dogma_OT_Bold_B_15">NOTE</samp>
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*I described the Wegman–Carter as using a PRF, but AES isn’t a PRF, it’s a
    pseudorandom permutation (PRP). However, that doesn’t matter because the Wegman–Carter
    construction works well with PRPs and PRFs. This is because if you’re given a
    function that’s either a PRF or a PRP, it’s hard to determine whether it’s a PRF
    of a PRP just by looking at the function’s output values. In other words, distinguishing
    a PRP from a PRF is computationally hard.*'
  prefs: []
  type: TYPE_NORMAL
- en: The security analysis of Poly1305-AES (see “The Poly1305-AES Message- Authentication
    Code” at *[https://<wbr>cr<wbr>.yp<wbr>.to<wbr>/mac<wbr>/poly1305<wbr>-20050329<wbr>.pdf](https://cr.yp.to/mac/poly1305-20050329.pdf)*)
    shows that Poly1305-AES is 128-bit secure as long as AES is a secure block cipher—and
    everything is implemented correctly, as with any cryptographic algorithm.
  prefs: []
  type: TYPE_NORMAL
- en: You can combine the Poly1305 universal hash with algorithms other than AES.
    For example, Poly1305 was used with the stream cipher ChaCha (see RFC 7539, “ChaCha20
    and Poly1305 for IETF Protocols”). There’s no doubt that Poly1305 will continue
    being used wherever a fast MAC is needed.
  prefs: []
  type: TYPE_NORMAL
- en: Although Poly1305 is fast and secure, it has several downsides. For one, its
    polynomial evaluation is difficult to implement efficiently, especially in the
    hands of those unfamiliar with the associated mathematical notions. (See examples
    at *[https://<wbr>github<wbr>.com<wbr>/floodyberry<wbr>/poly1305<wbr>-donna](https://github.com/floodyberry/poly1305-donna)*.)
    Second, on its own, it’s secure for only one message unless you use the Wegman–Carter
    construction. But in that case it requires a nonce, and if the nonce is repeated,
    the algorithm becomes insecure. Finally, Poly1305 is optimized for long messages,
    but it’s overkill if you process only small messages (say, fewer than 128 bytes).
    In such cases, SipHash is a good solution.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">SipHash</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'I designed SipHash in 2012 with Dan Bernstein initially to address a noncryptographic
    problem: denial-of-service attacks on hash tables. Hash tables are data structures,
    notably used in programming languages to efficiently store elements internally.
    Prior to SipHash, hash tables relied on noncryptographic keyed hash functions
    for which collisions were often easy to find, which could be exploited to slow
    down the system and perform denial-of-service attacks. We observed that a PRF
    would address this problem and set out to design SipHash, a PRF suitable for hash
    tables. Because hash tables process mostly short inputs, SipHash is optimized
    for short messages. SipHash is a full-blown PRF and MAC that shines where most
    inputs are short.'
  prefs: []
  type: TYPE_NORMAL
- en: 'SipHash uses a trick that makes it more secure than basic sponge functions:
    instead of XORing message blocks only once before the permutation, SipHash XORs
    them before and after the permutation, as [Figure 7-5](chapter7.xhtml#fig7-5)
    illustrates. The 128-bit key of SipHash is seen as two 64-bit words, *K*[1] and
    *K*[2], XORed to a 256-bit fixed initial state that’s seen as four 64-bit words.
    Next, the keys are discarded, and computing SipHash boils down to iterating through
    a core function called SipRound and then XORing message chunks to modify the four-word
    internal state. Finally, SipHash returns a 64-bit tag by XORing the four-state
    words together.'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/fig7-5.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 7-5: SipHash-2-4 processing
    a 15-byte message (a block,</samp> <samp class="SANS_Futura_Std_Book_11">M</samp><samp
    class="SANS_Futura_Std_Book_Oblique_I-SUB_11">1</samp><samp class="SANS_Futura_Std_Book_Oblique_I_11">,
    of 8 bytes and a block,</samp> <samp class="SANS_Futura_Std_Book_11">M</samp><samp
    class="SANS_Futura_Std_Book_Oblique_I-SUB_11">2</samp><samp class="SANS_Futura_Std_Book_Oblique_I_11">,
    of 7 bytes, plus 1 byte of padding)</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: 'The SipRound function uses a bunch of XORs together with additions and word
    rotations to make the function secure. SipRound transforms a state of four 64-bit
    words (*a*, *b*, *c*, *d*) by performing the following operations, top to bottom.
    The operations on the left and on the right are independent and can be carried
    out in parallel:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/pg152-1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Here, *a* += *b* is shorthand for *a* = *a* + *b*, and *b* <<< = 13 is shorthand
    for *b* = *b* <<< 13 (the 64-bit word *b* left-rotated 13 bits).
  prefs: []
  type: TYPE_NORMAL
- en: These simple operations on 64-bit words are almost all you need to implement
    to compute SipHash—although you won’t have to implement it yourself. You can find
    readily available implementations in most languages, such as C, Go, Java, JavaScript,
    Python, and Rust.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Dogma_OT_Bold_B_15">NOTE</samp>
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*I wrote* ***SipHash****-*x*-*y *as the SipHash version, meaning it makes*
    x *SipRounds between each message block injection and then* y *rounds. More rounds
    require more operations, which slows down operations but also increases security.
    The default version is SipHash-2-4 (simply noted as SipHash), and it has so far
    resisted cryptanalysis. Note that I also defined SipHash128, a version of SipHash
    producing 128-bit tags.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Many systems, such as the Rust language, the OpenBSD operating system, and
    the Bitcoin blockchain, use SipHash internally. The Linux kernel uses SipHash
    too and also uses HalfSipHash, “SipHash’s insecure younger cousin,” a smaller
    version with a 64-bit key and 32-bit output (see *[https://<wbr>docs<wbr>.kernel<wbr>.org<wbr>/security<wbr>/siphash<wbr>.html](https://docs.kernel.org/security/siphash.html)*).  ###
    <samp class="SANS_Futura_Std_Bold_B_11">How Things Can Go Wrong</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: Like ciphers and unkeyed hash functions, MACs and PRFs that are secure on paper
    can be vulnerable to attacks when used in a real setting. Let’s discuss two examples.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Timing Attacks on
    MAC Verification</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '*Side-channel attacks* target the implementation of a cryptographic algorithm
    rather than the algorithm itself. In particular, *timing attacks* use an algorithm’s
    execution time to determine secret information, such as keys, plaintext, and secret
    random values. Variable-time string comparison induces vulnerabilities not only
    in MAC verification but also in many other cryptographic and security functionalities.'
  prefs: []
  type: TYPE_NORMAL
- en: 'MACs can be vulnerable to timing attacks when a remote system verifies tags
    in a period of time that depends on the tag’s value, thereby allowing an attacker
    to determine the correct message tag by trying many incorrect ones to determine
    the one that takes the longest amount of time to complete. The problem occurs
    when a server compares the correct tag with an incorrect one by comparing the
    two strings byte per byte, in order, until the bytes differ. For example, the
    Python code in [Listing 7-1](chapter7.xhtml#Lis7-1) compares two strings byte
    per byte, in variable time: if the first bytes differ, the function returns after
    only one comparison; if the strings <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">y</samp> are identical, the
    function makes <samp class="SANS_TheSansMonoCd_W5Regular_11">n</samp> comparisons
    against the length of the strings.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 7-1: A comparison of
    two</samp> <samp class="SANS_Futura_Std_Book_11">n-</samp><samp class="SANS_Futura_Std_Book_Oblique_I_11">byte
    strings, taking variable time</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: To demonstrate the vulnerability of the <samp class="SANS_TheSansMonoCd_W5Regular_11">compare_mac()</samp>
    function, we’ll write a program that measures the execution time of 100,000 calls
    to <samp class="SANS_TheSansMonoCd_W5Regular_11">compare_mac()</samp>, first with
    identical 16-character <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">y</samp> values and then with
    <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">y</samp>
    values that differ in their third byte. The latter comparison should take noticeably
    less time because <samp class="SANS_TheSansMonoCd_W5Regular_11">compare_mac()</samp>
    compares fewer bytes than the identical <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">y</samp>, as [Listing 7-2](chapter7.xhtml#Lis7-2)
    shows.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 7-2: Measuring timing
    differences when executing</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">compare_mac()</samp>
    <samp class="SANS_Futura_Std_Book_Oblique_I_11">from [Listing 7-1](chapter7.xhtml#Lis7-1)</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: On a MacBook Pro with an ARM M1 chip, an execution of the program in [Listing
    7-2](chapter7.xhtml#Lis7-2) prints execution times of around 67 and 26 milliseconds,
    respectively. That difference is significant enough to identify what’s happening
    within the algorithm. Now move the difference to other offsets in the string,
    and you’ll observe different execution times for different offsets. If <samp class="SANS_TheSansMonoCd_W5Regular_11">MAC1</samp>
    is the correct MAC tag and <samp class="SANS_TheSansMonoCd_W5Regular_11">MAC2</samp>
    is the one tried by the attacker, you can easily identify the position of the
    first difference, which is the number of correctly guessed bytes.
  prefs: []
  type: TYPE_NORMAL
- en: 'If execution time doesn’t depend on a secret timing, timing attacks won’t work,
    which is why implementers strive to write *constant-time* implementations—that
    is, code that takes exactly the same time to complete for any secret input value.
    For example, the C function in [Listing 7-3](chapter7.xhtml#Lis7-3) compares two
    buffers of <samp class="SANS_TheSansMonoCd_W5Regular_11">size</samp> bytes in
    constant time: the temporary variable <samp class="SANS_TheSansMonoCd_W5Regular_11">result</samp>
    is nonzero if and only if there’s a difference somewhere in the two buffers.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 7-3: A constant-time
    comparison of two buffers for safer MAC verification</samp>  #### <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">When
    Sponges Leak</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: Permutation-based algorithms like SHA-3 and SipHash are simple, are easy to
    implement, and come with compact implementations, but they’re fragile in the face
    of side-channel attacks that recover a snapshot of the system’s state. For example,
    if a process can read the RAM and registers’ values at any time or read a core
    dump of the memory, an attacker can determine the internal state of SHA-3 in MAC
    mode, or the internal state of SipHash, and then compute the reverse of the permutation
    to recover the initial secret state. They can then forge tags for any message,
    breaking the MAC’s security.
  prefs: []
  type: TYPE_NORMAL
- en: Fortunately, this attack won’t work against compression function–based MACs
    such as HMAC-SHA-256 and keyed BLAKE2 because the attacker requires a snapshot
    of memory at the exact time when the key is used. The upshot is that if you’re
    in an environment where parts of a process’s memory may leak, you can use a MAC
    based on a noninvertible transform compression function rather than on a permutation.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Further Reading</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The venerable HMAC deserves more attention than I have space for here, and
    even more for the train of thought that led to its wide adoption and eventual
    demise when combined with a weak hash function. I recommend the 1996 paper “Keying
    Hash Functions for Message Authentication” by Mihir Bellare, Ran Canetti, and
    Hugo Krawczyk, which introduced HMAC and its cousin NMAC, and the 2006 follow-up
    paper by Bellare called “New Proofs for NMAC and HMAC: Security Without Collision-Resistance,”
    which proves that HMAC doesn’t need a collision-resistant hash but only a hash
    with a compression function that is a PRF. On the offensive side, the 2007 paper
    “Full Key-Recovery Attacks on HMAC/NMAC-MD4 and NMAC-MD5” by Pierre-Alain Fouque,
    Gaëtan Leurent, and Phong Nguyen shows how to attack HMAC and NMAC when they’re
    built on top of a brittle hash function such as MD4 or MD5\. (HMAC-MD5 and HMAC-SHA-1
    aren’t totally broken, but the risk is high enough.)'
  prefs: []
  type: TYPE_NORMAL
- en: The Wegman–Carter MACs are also worth more attention, both for their practical
    interest and for their underlying theory. The seminal papers by Wegman and Carter
    are available at *[https://<wbr>cr<wbr>.yp<wbr>.to<wbr>/bib<wbr>/entries<wbr>.html](https://cr.yp.to/bib/entries.html)*.
    Other state-of-the-art designs include UMAC and VMAC, which are among the fastest
    MACs on long messages.
  prefs: []
  type: TYPE_NORMAL
- en: One type of MAC not discussed in this chapter is *Pelican*, which uses the AES
    block cipher reduced to four rounds (down from 10 in the full block cipher) to
    authenticate chunks of messages within a simplistic construction, as described
    in *[https://<wbr>eprint<wbr>.iacr<wbr>.org<wbr>/2005<wbr>/088](https://eprint.iacr.org/2005/088)*.
    Pelican is more of a curiosity, though, and it’s rarely used in practice.
  prefs: []
  type: TYPE_NORMAL
- en: Last but not least, if you’re interested in finding vulnerabilities in cryptographic
    software, look for uses of CBC-MAC or for weaknesses caused by HMAC handling keys
    of arbitrary sizes—taking **Hash**(*K*) as the key rather than *K* if *K* is too
    long, thus making *K* and **Hash**(*K*) *equivalent keys*. Or just look for systems
    that don’t use MAC when they should—a frequent occurrence.
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 8](chapter8.xhtml), we’ll combine MACs with ciphers to protect a
    message’s authenticity, integrity, *and* confidentiality. We’ll also do this without
    MACs, thanks to authenticated ciphers, which combine the functionality of a basic
    cipher with that of a MAC by returning a tag along with each ciphertext.
  prefs: []
  type: TYPE_NORMAL
