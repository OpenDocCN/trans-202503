- en: <hgroup>
  id: totrans-0
  prefs: []
  type: TYPE_NORMAL
  zh: <hgroup>
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">7</samp> <samp class="SANS_Dogma_OT_Bold_B_11">KEYED
    HASHING</samp>
  id: totrans-1
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">7</samp> <samp class="SANS_Dogma_OT_Bold_B_11">带密钥的哈希</samp>
- en: </hgroup>
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: </hgroup>
- en: '![](../images/opener.jpg)'
  id: totrans-3
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/opener.jpg)'
- en: The hash functions in [Chapter 6](chapter6.xhtml) take a message and return
    its hash value—typically a short string of 256 or 512 bits. Anyone can compute
    the hash value of a message and verify that a particular message hashes to a particular
    value. When you want only specific people to compute hashes, however, you’ll hash
    with secret keys using *keyed* hash functions.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: '[第6章](chapter6.xhtml)中的哈希函数接收消息并返回其哈希值——通常是一个256位或512位的短字符串。任何人都可以计算消息的哈希值，并验证某条消息是否哈希到特定的值。然而，当你希望只有特定的人能够计算哈希时，你需要使用带有*密钥*的哈希函数进行哈希处理。'
- en: 'Keyed hashing forms the basis of two types of cryptographic algorithms: *message
    authentication codes (MACs)*, which authenticate a message and protect its integrity,
    and *pseudorandom functions (PRFs)*, which produce random-looking hash-sized values.
    We’ll look at the similarities between MACs and PRFs in the first section of this
    chapter before reviewing how MACs and PRFs work. Some MACs and PRFs are based
    on hash functions, some are based on block ciphers, and others are original designs.
    Finally, we’ll discuss examples of attacks on otherwise-secure MACs.'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 带密钥的哈希是两种加密算法的基础：*消息认证码（MACs）*，用于验证消息并保护其完整性，和 *伪随机函数（PRFs）*，用于生成看似随机的哈希大小值。我们将在本章的第一节中探讨MAC和PRF的相似之处，然后回顾MAC和PRF的工作原理。一些MAC和PRF基于哈希函数，一些基于分组密码，还有一些是原创设计。最后，我们将讨论针对本来安全的MAC的攻击示例。
- en: '### <samp class="SANS_Futura_Std_Bold_B_11">Message Authentication Codes</samp>'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: '### <samp class="SANS_Futura_Std_Bold_B_11">消息认证码</samp>'
- en: A MAC protects a message’s integrity and authenticity by creating a value *T*
    = **MAC**(*K*, *M*), called the authentication tag of the message, *M* (often
    confusingly called the MAC of *M*). Just as you can decrypt a message if you know
    a cipher’s key, you can validate that a message hasn’t been modified if you know
    a MAC’s key.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: MAC通过生成一个值 *T* = **MAC**(*K*, *M*) 来保护消息的完整性和真实性，这个值被称为消息 *M* 的身份验证标签（通常令人困惑地称为
    *M* 的MAC）。就像你知道加密算法的密钥就能解密消息一样，如果你知道MAC的密钥，你也可以验证消息是否没有被篡改。
- en: For example, say Alex and Bill share a key, *K*, and Alex sends a message, *M*,
    to Bill along with its authentication tag, *T* = **MAC**(*K*, *M*). Upon receiving
    the message and its authentication tag, Bill recomputes **MAC**(*K*, *M*) and
    checks that it’s equal to the authentication tag received. Because only Alex could
    have computed this value, Bill knows that the message wasn’t corrupted in transit
    (confirming its integrity), whether accidentally or maliciously, and that Alex
    sent that message (confirming its authenticity).
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设Alex和Bill共享一个密钥 *K*，并且Alex将消息 *M* 及其身份验证标签 *T* = **MAC**(*K*, *M*) 发送给Bill。在收到消息及其身份验证标签后，Bill重新计算
    **MAC**(*K*, *M*) 并检查它是否等于收到的身份验证标签。因为只有Alex才能计算出这个值，所以Bill知道消息在传输过程中没有被损坏（确认其完整性），无论是偶然的还是恶意的，同时也知道是Alex发送了这条消息（确认其真实性）。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">MACs in Secure Communication</samp>
  id: totrans-9
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">安全通信中的MAC</samp>
- en: Secure communication systems often combine a cipher and a MAC to protect a message’s
    confidentiality, integrity, and authenticity. For example, the protocols in Internet
    Protocol Security (IPsec), SSH, and TLS generate a MAC for each transmitted network
    packet.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 安全通信系统通常将加密算法和MAC结合使用，以保护消息的机密性、完整性和真实性。例如，互联网协议安全（IPsec）、SSH和TLS协议会为每个传输的网络数据包生成一个MAC。
- en: Not all communication systems use MACs. Sometimes an authentication tag can
    add unacceptable overhead to each packet, typically in the range of 64 to 128
    bits. For example, the old GSM mobile telephony standard encrypted packets encoding
    voice calls but didn’t authenticate them. An attacker could modify the encrypted
    audio signal, and the recipient wouldn’t notice.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 并非所有通信系统都使用MAC。 有时，身份验证标签可能会给每个数据包增加不可接受的开销，通常在64到128位之间。例如，旧的GSM移动通信标准加密了语音通话的数据包，但并未对其进行身份验证。攻击者可以修改加密后的音频信号，而接收者不会察觉。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Forgery and Chosen-Message
    Attacks</samp>
  id: totrans-12
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">伪造和选择消息攻击</samp>
- en: What does it mean for a MAC to be secure? First, as with a cipher, the secret
    key should remain secret. If a MAC is secure, an attacker shouldn’t be able to
    create a tag of some message if they don’t know the key. We call a fabricated
    message/tag pair a *forgery*, and recovering a key is a specific case of a more
    general class of *forgery attacks*. The security notion that posits that forgeries
    should be impossible to find is *unforgeability*. It should also be impossible
    to recover the secret key from a list of tags; otherwise, attackers could forge
    tags using the key.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 一个MAC（消息认证码）安全意味着什么？首先，和加密算法一样，秘密密钥应该保持机密。如果一个MAC是安全的，攻击者不应该在不知道密钥的情况下伪造某个消息的标签。我们将伪造的消息/标签对称为*伪造*，而恢复密钥是*伪造攻击*这一更广泛类别的特定案例。安全性概念认为，伪造应该是不可能被发现的，这就是*不可伪造性*。此外，也应该不可能从标签列表中恢复秘密密钥，否则攻击者可以使用密钥伪造标签。
- en: What can an attacker do to break a MAC? In other words, what’s the attack model?
    The most basic attack model is the *known-message attack*, which passively collects
    messages and their associated tags (for example, by eavesdropping on a network).
    But real attackers can often launch *active* attacks because they can choose the
    messages to be authenticated and therefore get the MAC of the message they want.
    The standard model is thus *chosen-message attacks*, wherein attackers get tags
    for messages of their choice.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 攻击者能做什么来破坏一个MAC？换句话说，攻击模型是什么？最基本的攻击模型是*已知消息攻击*，它被动地收集消息及其关联的标签（例如，通过监听网络）。但真实的攻击者往往可以发起*主动*攻击，因为他们可以选择要认证的消息，从而获得他们想要的消息的MAC。因此，标准模型是*选择消息攻击*，其中攻击者可以为自己选择的消息获取标签。
- en: '#### <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Replay Attacks</samp>'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '#### <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">重放攻击</samp>'
- en: MACs aren’t safe from attacks involving *replays* of tags. For example, if you
    were to eavesdrop on Alex and Bill’s communications, you could capture a message
    and its tag sent by Alex to Bill and later send them again to Bill pretending
    to be Alex. To prevent such *replay attacks*, protocols include a message number
    in each message. This number is incremented for each new message and authenticated
    along with the message by the MAC. The receiving party gets messages numbered
    1, 2, 3, 4, and so on. Thus, if an attacker tries to send message 1 again, the
    receiver notices that this message is out of order and that it’s a potential replay
    of the earlier message 1.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: MAC并不免疫于*重放攻击*。例如，如果你在监听Alex和Bill的通信，你可以捕获Alex发送给Bill的消息及其标签，并后来再次将其发送给Bill，伪装成Alex。为了防止这种*重放攻击*，协议会在每个消息中包含一个消息编号。每个新消息的编号递增，并与消息一起通过MAC进行认证。接收方会按顺序收到编号为1、2、3、4等的消息。因此，如果攻击者尝试再次发送消息1，接收方会注意到这条消息的顺序错乱，从而发现它可能是之前消息1的重放。
- en: <samp class="SANS_Futura_Std_Bold_B_11">Pseudorandom Functions</samp>
  id: totrans-17
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">伪随机函数</samp>
- en: A PRF uses a secret key to return **PRF**(*K*, *M*), such that the output looks
    random. Because the key is secret, the output values are unpredictable to an attacker.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 一个伪随机函数（PRF）使用秘密密钥返回**PRF**(*K*, *M*)，其输出看起来是随机的。由于密钥是秘密的，攻击者无法预测输出值。
- en: Unlike MACs, PRFs are not meant to be used on their own but as part of a cryptographic
    algorithm or protocol. For example, you can use PRFs to create block ciphers within
    the Feistel construction—see “How to Construct Block Ciphers” in [Chapter 4](chapter4.xhtml).
    Key derivation schemes use PRFs to generate cryptographic keys from a master key
    or password, and identification schemes use PRFs to generate a response from a
    random challenge. (Basically, a server sends a random challenge message, *M*,
    and the client returns **PRF**(*K*, *M*) in its response to prove that it knows
    *K*.) The 5G telephony standard uses a PRF to authenticate a SIM card and its
    service provider, and a similar PRF generates the encryption key and MAC key to
    be used during a phone call. The TLS protocol uses a PRF to generate key material
    from a master secret as well as session-specific random values. There’s even a
    PRF in the noncryptographic <samp class="SANS_TheSansMonoCd_W5Regular_11">hash()</samp>
    function built into the Python language to compare objects.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 不像 MAC，PRF 不是用来独立使用的，而是作为加密算法或协议的一部分。例如，你可以使用 PRF 在 Feistel 结构中创建分组密码——请参见[第
    4 章](chapter4.xhtml)《如何构造分组密码》。密钥派生方案使用 PRF 从主密钥或密码生成加密密钥，而身份验证方案使用 PRF 从随机挑战生成响应。（基本上，服务器发送一个随机挑战消息
    *M*，客户端则通过 **PRF**(*K*, *M*) 在响应中返回，以证明它知道 *K*。）5G 电信标准使用 PRF 来验证 SIM 卡和服务提供商，类似的
    PRF 生成在通话过程中使用的加密密钥和 MAC 密钥。TLS 协议使用 PRF 从主秘密和会话特定的随机值生成密钥材料。甚至在 Python 语言内置的非加密函数
    <samp class="SANS_TheSansMonoCd_W5Regular_11">hash()</samp> 中，也有一个 PRF 用于比较对象。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">PRF Security</samp>
  id: totrans-20
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">PRF 安全性</samp>
- en: To be secure, a pseudorandom function should have no pattern that sets its outputs
    apart from truly random values. An attacker who doesn’t know the key, *K*, shouldn’t
    be able to distinguish the outputs of **PRF**(*K*, *M*) from random values. Viewed
    differently, an attacker shouldn’t have any means of knowing whether they’re talking
    to a PRF algorithm or to a random function. The erudite phrase for that security
    notion is “ indistinguishability from a random function.” (To learn more about
    the theoretical foundations of PRFs, see Volume 1, Section 3.6 of Goldreich’s
    *Foundations of Cryptography*.)
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 为了保证安全，伪随机函数（PRF）应该没有任何模式，使其输出与真正的随机值有所区别。一个不知道密钥的攻击者，*K*，不应该能够区分 **PRF**(*K*,
    *M*) 的输出和随机值。换句话说，攻击者应该没有任何手段知道自己是在与一个 PRF 算法交互，还是与一个随机函数交互。这个安全概念的学术术语是“无法区分于随机函数”。（想了解更多关于
    PRF 理论基础的内容，请参见 Goldreich 的《*密码学基础*》第一卷，第 3.6 节。）
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">PRFs Are Stronger
    Than MACs</samp>
  id: totrans-22
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">PRF 比 MAC 更强</samp>
- en: PRFs and MACs are keyed hashes, but PRFs are fundamentally stronger than MACs
    because MACs have weaker security requirements. Whereas you would consider a MAC
    secure if an attacker can’t forge tags—that is, if they can’t guess the MAC’s
    outputs—a PRF is secure only if its outputs are indistinguishable random strings.
    If you can’t distinguish a PRF’s outputs from random strings, this implies their
    values can’t be guessed; in other words, any secure PRF is also a secure MAC.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: PRF 和 MAC 都是带密钥的哈希函数，但 PRF 本质上比 MAC 更强，因为 MAC 的安全要求较弱。你会认为一个 MAC 安全，如果攻击者无法伪造标签——也就是说，如果他们不能猜测
    MAC 的输出——而一个 PRF 只有在其输出是不可区分的随机字符串时才是安全的。如果你不能区分一个 PRF 的输出和随机字符串，这意味着它们的值无法被猜测；换句话说，任何安全的
    PRF 也是一个安全的 MAC。
- en: 'The converse is not true, however: a secure MAC isn’t necessarily a secure
    PRF. For example, say you start with a secure PRF, **PRF1**, and you want to build
    a second PRF, **PRF2**, from it, like this:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，反过来说，一个安全的 MAC 不一定是一个安全的 PRF。例如，假设你从一个安全的 PRF，**PRF1**，开始，并希望从中构建第二个 PRF，**PRF2**，像这样：
- en: '![](../images/pg142-1.jpg)'
  id: totrans-25
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/pg142-1.jpg)'
- en: Because **PRF2**’s output is defined as **PRF1**’s output followed by one 0
    bit, it doesn’t look as random as a true random string, and you can distinguish
    its outputs by that last 0 bit. Hence, **PRF2** is not a secure PRF. However,
    because **PRF1** is secure, **PRF2** would still make a secure MAC. If you were
    able to forge a tag, *T* = **PRF2**(*K*, *M*), for some *M*, then you’d also be
    able to forge a tag for **PRF1**, which you know to be impossible in the first
    place because PRF1 is a secure MAC. Thus, PRF2 is a keyed hash that’s a secure
    MAC but not a secure PRF.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 因为**PRF2**的输出被定义为**PRF1**的输出后跟一个0位，它看起来不像真正的随机字符串，你可以通过最后那个0位来区分其输出。因此，**PRF2**不是一个安全的PRF。然而，由于**PRF1**是安全的，**PRF2**仍然可以作为一个安全的MAC。如果你能够伪造一个标签，*T*
    = **PRF2**(*K*, *M*)，对于某些*M*，那么你也能伪造**PRF1**的标签，而你知道这本身是不可能的，因为PRF1是一个安全的MAC。因此，**PRF2**是一个带密钥的哈希，它是一个安全的MAC，但不是一个安全的PRF。
- en: 'But don’t worry: you won’t find such MAC constructions in real applications.
    In fact, many of the deployed or standardized MACs are also secure PRFs and are
    often used as either. For example, TLS uses the algorithm HMAC-SHA-256 both as
    a MAC and as a PRF.'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 但是别担心：你不会在实际应用中找到这样的MAC构造。事实上，许多已经部署或标准化的MAC也都是安全的PRF，且常常同时作为两者使用。例如，TLS使用HMAC-SHA-256算法既作为MAC，也作为PRF。
- en: <samp class="SANS_Futura_Std_Bold_B_11">How to Create Keyed Hashes from Unkeyed
    Hashes</samp>
  id: totrans-28
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">如何从未加密的哈希生成带密钥的哈希</samp>
- en: Throughout cryptography’s history, MACs and PRFs have rarely been designed from
    scratch but rather have been built from existing algorithms, usually hash functions
    or block ciphers. It might seem obvious that you can produce a keyed hash function
    by feeding an (unkeyed) hash function a key and a message, but this is easier
    said than done.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在密码学的历史中，MAC（消息认证码）和PRF（伪随机函数）很少是从零开始设计的，而是通常基于现有算法构建，通常是哈希函数或块密码。看起来很明显，你可以通过给（未加密的）哈希函数提供一个密钥和消息来生成一个带密钥的哈希函数，但这其实说起来容易做起来难。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">The Secret-Prefix
    Construction</samp>
  id: totrans-30
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">秘密前缀构造</samp>
- en: The first technique we’ll examine, the *secret-prefix construction*, turns a
    normal hash function into a keyed hash by prepending the key to the message and
    returning **Hash**(*K* || *M*). This approach is insecure when the hash function
    is vulnerable to length-extension attacks (see “The Length-Extension Attack” in
    [Chapter 6](chapter6.xhtml)) and when the hash supports keys of different lengths.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要讨论的第一个技术，*秘密前缀构造*，通过将密钥附加到消息前面，并返回**Hash**(*K* || *M*)，将普通哈希函数转换为带密钥的哈希。当哈希函数容易受到长度扩展攻击（参见[第6章](chapter6.xhtml)中的“长度扩展攻击”）时，以及当哈希支持不同长度的密钥时，这种方法是
    insecure 的。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Insecurity Against Length-Extension
    Attacks</samp>
  id: totrans-32
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">对长度扩展攻击的安全性问题</samp>
- en: Recall from [Chapter 6](chapter6.xhtml) that hash functions of the SHA-2 family
    allow attackers to compute the hash of a partially unknown message when given
    a hash of a shorter version of that message. In formal terms, the length-extension
    attack allows attackers to compute **Hash**(*K* || *M*[1] || *M*[2]) given only
    **Hash**(*K* || *M*[1]) and neither *M*[1] nor *K*. These functions allow attackers
    to forge valid MAC tags for free because they shouldn’t be able to guess the MAC
    of *M*[1] || *M*[2] given only the MAC of *M*[1]. This fact makes the secret-prefix
    construction insecure as a MAC and PRF when, for example, using it with SHA-256
    or SHA-512\. It’s a weakness of Merkle–Damgård to allow length-extension attacks,
    and none of the SHA-3 finalists do. The ability to thwart length-extension attacks
    was mandatory for SHA-3 submissions (see [Chapter 6](chapter6.xhtml)).
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 回想一下[第6章](chapter6.xhtml)中提到的，SHA-2系列的哈希函数允许攻击者在给定消息的较短版本的哈希值时，计算出部分未知消息的哈希值。用正式术语来说，长度扩展攻击使得攻击者可以在只知道**Hash**(*K*
    || *M*[1])的情况下，计算出**Hash**(*K* || *M*[1] || *M*[2])，而不知道*M*[1]或*K*。这些函数使得攻击者可以免费伪造有效的MAC标签，因为他们不应该仅凭*M*[1]的MAC就能猜测出*M*[1]
    || *M*[2]的MAC。这个事实使得当与SHA-256或SHA-512一起使用时，秘密前缀构造作为MAC和PRF是 insecure 的。这是Merkle–Damgård结构允许长度扩展攻击的一个弱点，而SHA-3的所有候选者都没有这个问题。抵御长度扩展攻击是SHA-3提交的必要条件（参见[第6章](chapter6.xhtml)）。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Insecurity with Different
    Key Lengths</samp>
  id: totrans-34
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">不同密钥长度的安全性问题</samp>
- en: The secret-prefix construction is also insecure when allowing the use of keys
    of different lengths. For example, if the key *K* is the 24-bit hexadecimal string
    123abc and *M* is def00, then **Hash**() processes the value *K* || *M* = 123abcdef00\.
    If *K* is instead the 16-bit string 123a and *M* is bcdef000, then **Hash**()
    processes *K* || *M* = 123abcdef00, too. Therefore, the result of the secret-prefix
    construction **Hash**(*K* || *M*) is the same for both keys.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 当允许使用不同长度的密钥时，密文前缀构造也是不安全的。例如，如果密钥 *K* 是 24 位的十六进制字符串 123abc，且 *M* 是 def00，那么
    **Hash**() 处理的值是 *K* || *M* = 123abcdef00。如果 *K* 是 16 位的字符串 123a，且 *M* 是 bcdef000，那么
    **Hash**() 处理的值也是 *K* || *M* = 123abcdef00。因此，密文前缀构造 **Hash**(*K* || *M*) 的结果对于两个密钥来说是相同的。
- en: This problem is independent of the underlying hash; you can fix it by hashing
    the key’s length along with the key and the message—for example, by encoding the
    key’s bit length as a 16-bit integer, *L*, and then hashing **Hash**(*L* || *K*
    || *M*). You shouldn’t have to do this, however, as modern hash functions such
    as BLAKE2 and SHA-3 include a keyed mode that avoids these pitfalls and yields
    a secure PRF and thus a secure MAC as well.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 这个问题与底层哈希函数无关；你可以通过将密钥的长度与密钥和消息一起哈希来修复它，例如，将密钥的位长编码为 16 位整数 *L*，然后哈希 **Hash**(*L*
    || *K* || *M*)。然而，现代哈希函数如 BLAKE2 和 SHA-3 已经包含了一个密钥模式，避免了这些问题，并且能生成安全的 PRF 和安全的
    MAC。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">The Secret-Suffix
    Construction</samp>
  id: totrans-37
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">密文后缀构造</samp>
- en: Instead of hashing the key before the message as in the secret-prefix construction,
    you can hash it *after*. And that’s exactly how the *secret-suffix construction*
    works by building a PRF from a hash function as **Hash**(*M* || *K*).
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 与在密文前缀结构中将密钥哈希到消息之前不同，您可以将其 *哈希在后面*。这正是 *密文后缀结构* 的工作方式，通过构建一个由哈希函数构成的伪随机函数（PRF），如
    **Hash**(*M* || *K*)。
- en: Putting the key at the end makes quite a difference. The length-extension attack
    that works against secret-prefix MACs won’t work against the secret suffix. Applying
    length extension to a secret-suffix MAC results in **Hash**(*M*[1] || *K* || *M*[2])
    from **Hash**(*M*[1] || *K*), but this isn’t a valid attack because **Hash**(*M*[1]
    || *K* || *M*[2]) isn’t a valid secret-suffix MAC; the key needs to be at the
    end.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 将密钥放在末尾会产生很大的不同。针对密文前缀 MAC 的长度扩展攻击无法对密文后缀起作用。对密文后缀 MAC 应用长度扩展会得到 **Hash**(*M*[1]
    || *K* || *M*[2])，而不是 **Hash**(*M*[1] || *K*)，但这并不是一个有效的攻击，因为 **Hash**(*M*[1]
    || *K* || *M*[2]) 不是一个有效的密文后缀 MAC；密钥需要在末尾。
- en: However, the secret-suffix construction is weaker against another type of attack.
    Say you’ve got a collision for the hash **Hash**(*M*[1]) = **Hash**(*M*[2]), where
    *M*[1] and *M*[2] are two distinct messages, possibly of different sizes. In the
    case of an M–D hash function such as SHA-256, this implies that **Hash**(*M*[1]
    || *P*[1] || *K*) and **Hash**(*M*[2] || *P*[2] || *K*) will be equal too, where
    *P*[1] and *P*[2] are the padding data added to complete a block. After processing
    *M*[1] || *P*[1], the hash function’s state is the same as after processing *M*[2]
    || *P*[2]. Adding K to each instance preserves the equality of the state, leading
    to a collision regardless of *K*’s value.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，密文后缀构造对于另一类攻击更为脆弱。假设你有一个哈希冲突 **Hash**(*M*[1]) = **Hash**(*M*[2])，其中 *M*[1]
    和 *M*[2] 是两个不同的消息，可能具有不同的大小。在像 SHA-256 这样的 M-D 哈希函数中，这意味着 **Hash**(*M*[1] || *P*[1]
    || *K*) 和 **Hash**(*M*[2] || *P*[2] || *K*) 也将相等，其中 *P*[1] 和 *P*[2] 是为了完成块而添加的填充数据。在处理
    *M*[1] || *P*[1] 后，哈希函数的状态与处理 *M*[2] || *P*[2] 后的状态相同。将 K 添加到每个实例中会保持状态的相等，从而导致冲突，无论
    *K* 的值如何。
- en: 'To exploit this property, an attacker:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 为了利用这一特性，攻击者：
- en: 1.  Finds two colliding messages, *M*[1] and *M*[2]
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 1.  找到两个冲突的消息，*M*[1] 和 *M*[2]。
- en: 2.  Requests the MAC tag of *M*[1], **Hash**(*M*[1] || *K*)
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 2.  请求 *M*[1] 的 MAC 标签，**Hash**(*M*[1] || *K*)
- en: 3.  Guesses that **Hash**(*M*[2] || *K*) is the same, thereby forging a valid
    tag and breaking the MAC’s security
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 3.  猜测 **Hash**(*M*[2] || *K*) 相同，从而伪造一个有效的标签，破坏 MAC 的安全性。
- en: '#### <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">The HMAC Construction</samp>'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '#### <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">HMAC 构造</samp>'
- en: The *hash-based MAC (HMAC)* construction allows you to build a MAC from a hash
    function, which is more secure than either secret prefix or secret suffix. HMAC
    yields a secure PRF as long as the underlying hash is collision resistant, but
    even if that isn’t the case, HMAC still yields a secure PRF if the hash’s compression
    function is a PRF. The secure communication protocols IPsec, SSH, and TLS have
    all used HMAC. (You’ll find HMAC specifications in the NIST FIPS 198-1 standard
    and in RFC 2104.)
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '*基于哈希的MAC（HMAC）*结构允许你从哈希函数构建一个MAC，这比使用秘密前缀或秘密后缀更安全。只要底层哈希是抗碰撞的，HMAC就能产生一个安全的伪随机函数（PRF），即使不是这种情况，只要哈希的压缩函数是PRF，HMAC仍能产生一个安全的PRF。IPsec、SSH和TLS等安全通信协议都使用了HMAC。（你可以在NIST
    FIPS 198-1标准和RFC 2104中找到HMAC规范。）'
- en: 'HMAC uses a hash function, **Hash**, to compute a MAC tag, as [Figure 7-1](chapter7.xhtml#fig7-1)
    shows and according to the following expression:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: HMAC使用哈希函数**哈希**来计算MAC标签，如[图7-1](chapter7.xhtml#fig7-1)所示，并根据以下表达式进行：
- en: '![](../images/pg144-1.jpg)'
  id: totrans-48
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/pg144-1.jpg)'
- en: The value *opad* (outer padding) is the hexadecimal string <samp class="SANS_TheSansMonoCd_W5Regular_11">5c5c5c.
    . .5c</samp> as long as **Hash**’s block size. The key, *K*, is usually shorter
    than one block that’s filled with <samp class="SANS_TheSansMonoCd_W5Regular_11">00</samp>
    bytes and XORed with *opad*. For example, if *K* is the 1-byte string <samp class="SANS_TheSansMonoCd_W5Regular_11">00</samp>,
    then *K* ⊕ *opad* = *opad*. (The same is true if *K* is the all-zero string of
    any length up to a block’s length.) *K* ⊕ *opad* is the first block processed
    by the outer call to **Hash**—namely, the leftmost **Hash** in the preceding equation,
    or the bottom hash in [Figure 7-1](chapter7.xhtml#fig7-1).
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 值*opad*（外填充）是十六进制字符串<samp class="SANS_TheSansMonoCd_W5Regular_11">5c5c5c. .
    .5c</samp>，其长度与**哈希**的块大小相同。密钥*K*通常比一个块要短，并且用<samp class="SANS_TheSansMonoCd_W5Regular_11">00</samp>字节填充并与*opad*进行异或操作。例如，如果*K*是1字节的字符串<samp
    class="SANS_TheSansMonoCd_W5Regular_11">00</samp>，那么*K* ⊕ *opad* = *opad*。（如果*K*是任何长度的全零字符串，直到块的长度，也是如此。）*K*
    ⊕ *opad*是由外部调用**哈希**处理的第一个块——即方程中最左边的**哈希**，或[图7-1](chapter7.xhtml#fig7-1)中的底部哈希。
- en: '![](../images/fig7-1.jpg)'
  id: totrans-50
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/fig7-1.jpg)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 7-1: The HMAC hash-based
    MAC construction for a hash function based on a compression function</samp>'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图7-1：基于压缩函数的哈希函数的HMAC基于哈希的MAC结构</samp>
- en: The value *ipad* (inner padding) is a string (363636 . . . 36) as long as the
    **Hash**’s block size and completed with 00 bytes. The resulting block is the
    first processed by the inner call to **Hash**—namely, the rightmost **Hash** in
    the equation, or the top hash in [Figure 7-1](chapter7.xhtml#fig7-1).
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 值*ipad*（内填充）是一个字符串（363636 . . . 36），其长度与**哈希**的块大小相同，并以00字节补充。得到的块是首先由**哈希**的内层调用处理的——即方程式中最右侧的**哈希**，或[图7-1](chapter7.xhtml#fig7-1)中的顶部哈希。
- en: <samp class="SANS_Dogma_OT_Bold_B_15">NOTE</samp>
  id: totrans-53
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: <samp class="SANS_Dogma_OT_Bold_B_15">注意</samp>
- en: '*The envelope method is a more secure construction than secret prefix or secret
    suffix. It’s expressed as* ***Hash****(*K *||* M *||* K*), a* sandwich MAC*, but
    it’s theoretically less secure than HMAC.*'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '*信封法是一种比秘密前缀或秘密后缀更安全的构造。它可以表示为* ***Hash****(*K *||* M *||* K*)，一种*三明治MAC*，但从理论上讲，它不如HMAC安全。*'
- en: If SHA-256 is the hash function used as **Hash**, then you call the HMAC instance
    HMAC-SHA-256\. More generally, you call HMAC-*Hash* an HMAC instance using the
    hash function *Hash*. That means if someone asks you to use HMAC, you should always
    ask, “Which hash function?”
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 如果使用SHA-256作为**哈希**函数，则称HMAC实例为HMAC-SHA-256。更一般地，称使用哈希函数*Hash*的HMAC实例为HMAC-*Hash*。这意味着如果有人要求你使用HMAC，你应该始终问：“使用哪种哈希函数？”
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">A Generic Attack
    Against Hash-Based MACs</samp>
  id: totrans-56
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">一种针对基于哈希的MAC的通用攻击</samp>
- en: There is one attack that works against all MACs based on an iterated hash function.
    Recall the attack in “The Secret-Suffix Construction” on [page 143](#sec12) where
    we used a hash collision to get a collision of MACs. You can use the same strategy
    to attack a secret-prefix MAC or HMAC, though the consequences are less devastating.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 有一种攻击方法可以针对所有基于迭代哈希函数的MAC进行攻击。回想一下在“秘密后缀构造”中对[第143页](#sec12)中的攻击，我们使用哈希碰撞来获取MAC的碰撞。你可以使用相同的策略来攻击秘密前缀MAC或HMAC，尽管后果不那么严重。
- en: '[Figure 7-2](chapter7.xhtml#fig7-2) illustrates the secret-prefix MAC **Hash**(*K*
    || *M*).'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '[图7-2](chapter7.xhtml#fig7-2)展示了秘密前缀MAC **哈希**(*K* || *M*)。'
- en: '![](../images/fig7-2.jpg)'
  id: totrans-59
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/fig7-2.jpg)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 7-2: The principle of
    the generic forgery attack on hash-based MACs</samp>'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图7-2：基于哈希的MAC的通用伪造攻击原理</samp>
- en: If the digest is *n* bits, you can find two messages, *M*[1] and *M*[2], such
    that **Hash**(*K* || *M*[1]) = **Hash**(*K* || *M*[2]), by requesting approximately
    2*^n*^(/2) MAC tags to the system holding the key. (Recall the birthday attack
    from [Chapter 6](chapter6.xhtml).) If the hash lends itself to length extension,
    as SHA-256 does, you can then use *M*[1] and *M*[2] to forge MACs by choosing
    some arbitrary data, *M*[3], and then querying the MAC oracle for **Hash**(*K*
    || *M*[1] || *M*[3]), which is the MAC of message *M*[1] || *M*[3]. As it turns
    out, this is also the MAC of message *M*[2] || *M*[3] because the hash’s internal
    state of *M*[1] and *M*[3] and *M*[2] and *M*[3] is the same. You’ve successfully
    forged a MAC tag. (The effort becomes infeasible as *n* grows beyond, say, 128
    bits.)
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 如果摘要是*n*位，你可以找到两个消息，*M*[1]和*M*[2]，使得**Hash**(*K* || *M*[1]) = **Hash**(*K* ||
    *M*[2])，通过向持有密钥的系统请求大约2*^n*^(/2)个MAC标签。（回想一下[第6章](chapter6.xhtml)中的生日攻击。）如果哈希函数支持长度扩展，像SHA-256那样，你可以使用*M*[1]和*M*[2]通过选择一些任意数据*M*[3]来伪造MAC，然后查询MAC预言机得到**Hash**(*K*
    || *M*[1] || *M*[3])，这就是消息*M*[1] || *M*[3]的MAC。结果证明，这也是消息*M*[2] || *M*[3]的MAC，因为*M*[1]和*M*[3]以及*M*[2]和*M*[3]的哈希内部状态是相同的。你已经成功伪造了一个MAC标签。（随着*n*增长到例如128位时，这项工作会变得不可行。）
- en: 'This attack works even if the hash function isn’t vulnerable to length extension,
    and it works for HMAC, too. This is because all that’s required is an internal
    collision in the hash function and not necessarily in the complete hash. The cost
    of the attack depends on both the size of the chaining value and the MAC’s length:
    if a MAC’s chaining value is 512 bits and its tags are 128 bits, a 2^(64) computation
    would find a MAC collision but probably not a collision in the internal state,
    since finding such a collision requires 2^(512/2) = 2^(256) operations on average.'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 即使哈希函数不容易受到长度扩展攻击，这个攻击仍然有效，它同样适用于HMAC。这是因为所需的只是哈希函数内部的碰撞，而不一定是在整个哈希值中的碰撞。攻击的成本取决于链值的大小和MAC的长度：如果一个MAC的链值是512位而它的标签是128位，2^(64)的计算将找到一个MAC碰撞，但可能不会在内部状态中找到碰撞，因为找到这样的碰撞平均需要2^(512/2)
    = 2^(256)次操作。
- en: '### <samp class="SANS_Futura_Std_Bold_B_11">How to Create Keyed Hashes from
    Block Ciphers</samp>'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '### <samp class="SANS_Futura_Std_Bold_B_11">如何从块密码创建带密钥的哈希</samp>'
- en: The compression functions in many hash functions are built on block ciphers
    (see [Chapter 6](chapter6.xhtml)). For example, HMAC-SHA-256 PRF is a series of
    calls to SHA-256’s compression function, which is a block cipher that repeats
    a sequence of rounds. In other words, HMAC-SHA-256 is a block cipher inside a
    compression function inside a hash inside the HMAC construction. So why not use
    a block cipher directly rather than build such a layered construction?
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 许多哈希函数中的压缩函数是建立在块密码上的（参见[第6章](chapter6.xhtml)）。例如，HMAC-SHA-256 PRF是对SHA-256压缩函数的一系列调用，SHA-256压缩函数本身就是一个块密码，重复执行一系列的轮次。换句话说，HMAC-SHA-256是一个块密码，嵌套在一个压缩函数内，再嵌套在哈希函数中，最后构建成HMAC。那么，为什么不直接使用块密码，而要构建这样一个层级结构呢？
- en: '*Cipher-based MAC (CMAC)* is such a construction: it creates a MAC given only
    a block cipher, such as AES. Though less popular than HMAC, CMAC is deployed in
    many systems, including the Internet Key Exchange (IKE) protocol, which is part
    of the IPsec suite. IKE, for example, generates key material using the AES-CMAC-PRF-128
    construction as a core algorithm (or CMAC based on AES with 128-bit output). CMAC
    is specified in RFC 4493.'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '*基于密码的MAC（CMAC）*就是这样的一个结构：它只使用一个块密码，如AES，来创建一个MAC。虽然比HMAC不那么流行，但CMAC已经被应用于许多系统中，包括互联网密钥交换（IKE）协议，它是IPsec套件的一部分。例如，IKE使用AES-CMAC-PRF-128结构作为核心算法（或基于AES的CMAC，输出为128位）。CMAC在RFC
    4493中有规范。'
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Breaking CBC-MAC</samp>
  id: totrans-66
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">破解CBC-MAC</samp>
- en: CMAC was designed in 2005 as an improved version of *CBC-MAC*, a simpler block
    cipher–based MAC derived from the cipher block chaining (CBC) block cipher mode
    of operation (see “Modes of Operation” in [Chapter 4](chapter4.xhtml)).
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: CMAC是在2005年设计的，作为*CBC-MAC*的改进版本，CBC-MAC是一种较简单的基于块密码的MAC，源自密码块链接（CBC）密码工作模式（参见[第4章](chapter4.xhtml)中的“工作模式”）。
- en: 'CBC-MAC, the ancestor of CMAC, is simple: to compute the tag of a message,
    *M*, given a block cipher, **E**, encrypt *M* in CBC mode with an all-zero initial
    value (IV) and discard all but the last ciphertext block. That is, compute'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: CBC-MAC，CMAC 的前身，十分简单：要计算消息 *M* 的标签，给定一个块密码 **E**，将 *M* 在 CBC 模式下使用全零初始值（IV）加密，然后丢弃除最后一个密文块外的所有块。也就是说，计算
- en: '*C*[1] = **E**(*K*, *M*[1]), *C*[2] = **E**(*K*, *M*[2] ⊕ *C*[1]), *C*[3] =
    **E**(*K*, *M*[3] ⊕ *C*[2])'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '*C*[1] = **E**(*K*, *M*[1]), *C*[2] = **E**(*K*, *M*[2] ⊕ *C*[1]), *C*[3] =
    **E**(*K*, *M*[3] ⊕ *C*[2])'
- en: and so on for each of *M*’s blocks and keep only the last *C*i—your CBC-MAC
    tag for *M*—simple, and simple to attack.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 对 *M* 的每个块进行同样的操作，仅保留最后一个 *C*i —— 即 *M* 的 CBC-MAC 标签 —— 简单，并且容易被攻击。
- en: To understand why CBC-MAC is insecure, consider the CBC-MAC tag, *T*[1] = **E**(*K*,
    *M*[1]), of a single-block message, *M*[1], and the tag, *T*[2] = **E**(*K*, *M*[2]),
    of another single-block message, *M*[2]. Given these two pairs, (*M*[1], *T*[1])
    and (*M*[2], *T*[2]), you can deduce that *T*[2] is also the tag of the two-block
    message *M*[1] || (*M*[2] ⊕ *T*[1]). If you apply CBC-MAC to *M*[1] || (*M*[2]
    ⊕ *T*[1]) and compute *C*[1] = **E**(*K*, *M*[1]) = *T*[1] followed by *C*[2]
    = **E**(*K*, (*M*[2] ⊕ *T*[1]) ⊕ *T*[1]) = **E**(*K*, *M*[2]) = *T*[2], you can
    create a third message/tag pair from two message/tag pairs without knowing the
    key. That is, you can forge CBC-MAC tags, thereby breaking CBC-MAC’s security.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 为了理解为什么 CBC-MAC 不安全，考虑单块消息 *M*[1] 的 CBC-MAC 标签，*T*[1] = **E**(*K*, *M*[1])，以及另一块单块消息
    *M*[2] 的标签，*T*[2] = **E**(*K*, *M*[2])。给定这两个配对，(*M*[1], *T*[1]) 和 (*M*[2], *T*[2])，你可以推导出
    *T*[2] 也是两块消息 *M*[1] || (*M*[2] ⊕ *T*[1]) 的标签。如果你将 CBC-MAC 应用于 *M*[1] || (*M*[2]
    ⊕ *T*[1]) 并计算 *C*[1] = **E**(*K*, *M*[1]) = *T*[1]，然后 *C*[2] = **E**(*K*, (*M*[2]
    ⊕ *T*[1]) ⊕ *T*[1]) = **E**(*K*, *M*[2]) = *T*[2]，你就能从两个消息/标签配对中创建出第三个消息/标签配对，而无需知道密钥。也就是说，你可以伪造
    CBC-MAC 标签，从而破坏 CBC-MAC 的安全性。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Fixing CBC-MAC</samp>
  id: totrans-72
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">修复 CBC-MAC</samp>
- en: CMAC fixes CBC-MAC by processing the last block using a different key from the
    preceding blocks. To do this, CMAC first derives two keys, *K*[1] and *K*[2],
    from the main key, *K*, such that *K*, *K*[1], and *K*[2] are distinct. CMAC processes
    the last block using either *K*[1] or *K*[2], while the preceding blocks use *K*.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: CMAC 通过使用与前面的块不同的密钥来处理最后一个块，从而修复了 CBC-MAC。为此，CMAC 首先从主密钥 *K* 中派生出两个密钥 *K*[1]
    和 *K*[2]，使得 *K*、*K*[1] 和 *K*[2] 是不同的。CMAC 使用 *K*[1] 或 *K*[2] 来处理最后一个块，而前面的块使用
    *K*。
- en: To determine *K*[1] and *K*[2], CMAC first computes a temporary value, *L* =
    **E**(0, *K*), where 0 acts as the key of the block cipher and *K* acts as the
    plaintext block. Then CMAC sets *K*[1] to (*L* << 1) if *L*’s most significant
    bit (MSB) is 0 and to (*L* << 1) ⊕ <samp class="SANS_TheSansMonoCd_W5Regular_11">87</samp>
    if *L*’s MSB is 1\. (The hexadecimal number <samp class="SANS_TheSansMonoCd_W5Regular_11">87</samp>,
    or 135 in decimal, is chosen for its mathematical properties when data blocks
    are 128 bits; a different value is needed when blocks aren’t 128 bits.) The key
    *K*[2] is set to (*K*[1] << 1) if *K*[1]’s MSB is 0 and to *K*[2] = (*K*[1] <<
    1) ⊕ <samp class="SANS_TheSansMonoCd_W5Regular_11">87</samp> otherwise.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确定 *K*[1] 和 *K*[2]，CMAC 首先计算一个临时值 *L* = **E**(0, *K*)，其中 0 作为块密码的密钥，*K* 作为明文块。然后，CMAC
    将 *K*[1] 设置为 (*L* << 1)，如果 *L* 的最高有效位（MSB）为 0；否则，将 *K*[1] 设置为 (*L* << 1) ⊕ <samp
    class="SANS_TheSansMonoCd_W5Regular_11">87</samp>，如果 *L* 的 MSB 为 1。（十六进制数 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">87</samp>，即十进制的 135，因其在数据块大小为 128 位时的数学性质而被选择；如果数据块大小不是
    128 位，则需要选择不同的值。）密钥 *K*[2] 被设置为 (*K*[1] << 1)，如果 *K*[1] 的 MSB 为 0；否则，*K*[2] =
    (*K*[1] << 1) ⊕ <samp class="SANS_TheSansMonoCd_W5Regular_11">87</samp>。
- en: Given *K*[1] and *K*[2], CMAC works like CBC-MAC, except for the last block.
    If the final message chunk *M*n is exactly the size of a block, CMAC returns **E**(*K*,
    *M*n ⊕ *C*n [− 1] ⊕ *K*[1]) as a tag, as [Figure 7-3](chapter7.xhtml#fig7-3) illustrates.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 给定 *K*[1] 和 *K*[2]，CMAC 的工作方式与 CBC-MAC 相似，唯一不同的是最后一块。如果最终消息块 *M*n 恰好等于一个块的大小，CMAC
    将返回 **E**(*K*, *M*n ⊕ *C*n [− 1] ⊕ *K*[1]) 作为标签，如[图 7-3](chapter7.xhtml#fig7-3)所示。
- en: '![](../images/fig7-3.jpg)'
  id: totrans-76
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/fig7-3.jpg)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 7-3: The CMAC block
    cipher–based MAC construction when the message is a sequence of integral blocks</samp>'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图 7-3：当消息是一个完整块序列时，基于 CMAC 块密码的
    MAC 构造</samp>
- en: If *M*n has fewer bits than a block, CMAC pads it with a 1 bit and 0s and returns
    **E**(*K*, *M*n ⊕ *C*n [− 1] ⊕ *K*[2]) as a tag, as in [Figure 7-4](chapter7.xhtml#fig7-4).
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 *M*n 的位数少于一个块，CMAC 会使用一个 1 位和零填充它，并返回 **E**(*K*, *M*n ⊕ *C*n [− 1] ⊕ *K*[2])
    作为标签，如[图 7-4](chapter7.xhtml#fig7-4)所示。
- en: '![](../images/fig7-4.jpg)'
  id: totrans-79
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/fig7-4.jpg)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 7-4: The CMAC block
    cipher–based MAC construction when the last block of the message has to be padded
    with 1 bit and zeros to fill a block</samp>'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图7-4：当消息的最后一个块必须用1位和零填充以填满一个块时，基于CMAC块密码的MAC构造</samp>
- en: The first case uses only *K*[1] and the second only *K*[2], but both use the
    main key *K* to process the message chunks that precede the final one.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个案例仅使用*K*[1]，第二个案例仅使用*K*[2]，但两者都使用主密钥*K*来处理在最后一个消息块之前的消息块。
- en: 'Unlike the CBC encryption mode, CMAC doesn’t take an IV as a parameter and
    is deterministic: for the same key, CMAC always returns the same tag for a given
    message, *M*, because the computation of **CMAC**(*M*) isn’t randomized—and that’s
    fine because unlike encryption, MAC computation doesn’t have to be randomized
    to be secure, which eliminates the burden of having to choose random IV.  ###
    <samp class="SANS_Futura_Std_Bold_B_11">Dedicated MAC Designs</samp>'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 与CBC加密模式不同，CMAC不接受IV（初始化向量）作为参数，并且是确定性的：对于同一个密钥，CMAC始终为给定的消息*M*返回相同的标签，因为**CMAC**(*M*)的计算不是随机化的——这没问题，因为与加密不同，MAC计算不需要随机化即可保证安全，这也避免了必须选择随机IV的负担。###
    <samp class="SANS_Futura_Std_Bold_B_11">专用MAC设计</samp>
- en: You’ve seen how to recycle hash functions and block ciphers to build PRFs that
    are secure as long as their underlying hash or cipher is secure. Schemes such
    as HMAC and CMAC simply combine available hash functions or block ciphers to yield
    a secure PRF or MAC. Reusing available algorithms is convenient, but is it the
    most efficient approach?
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经看到如何回收哈希函数和块密码算法来构建PRF，只要它们底层的哈希或密码算法是安全的，PRF也会是安全的。像HMAC和CMAC这样的方案只是简单地结合现有的哈希函数或块密码算法来生成一个安全的PRF或MAC。重用现有的算法虽然方便，但这是否是最有效的方法呢？
- en: Intuitively, PRFs and MACs should require less work to be secure than unkeyed
    hash functions—their use of a secret key prevents attackers from playing with
    the algorithm because they don’t have the key. Also, PRFs and MACs expose only
    a short tag to attackers, unlike block ciphers, which expose a ciphertext as long
    as the message. Hence, PRFs and MACs shouldn’t need the maximum power of hash
    functions or block ciphers—this is the point of *dedicated design*, that is, algorithms
    created solely to serve as PRFs or MACs.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 直观上，PRF（伪随机函数）和MAC（消息认证码）相比无密钥哈希函数在安全性上所需的工作量更少——它们使用了一个秘密密钥，防止攻击者篡改算法，因为攻击者没有密钥。此外，PRF和MAC仅暴露一个短标签给攻击者，而不像块密码算法那样暴露与消息同样长度的密文。因此，PRF和MAC不需要哈希函数或块密码算法的最大计算能力——这就是*专用设计*的意义所在，即专门为作为PRF或MAC而设计的算法。
- en: 'The sections that follow focus on two such algorithms: Poly1305 and SipHash.
    I’ll explain their design principles and why they’re (most likely) secure.'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的部分将重点介绍两种这样的算法：Poly1305和SipHash。我将解释它们的设计原理以及为什么它们（很可能）是安全的。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Poly1305</samp>
  id: totrans-86
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Poly1305</samp>
- en: The Poly1305 algorithm (pronounced *poly*-*thirteen*-*o-five*) was designed
    in 2005 by Daniel J. Bernstein (creator of the Salsa20 stream cipher from [Chapter
    5](chapter5.xhtml) and the ChaCha cipher that inspired the BLAKE and BLAKE2 hash
    functions from [Chapter 6](chapter6.xhtml)). Poly1305 is optimized to be superfast
    on modern CPUs, and as I write this, it’s one of the algorithms supported in TLS
    1.3 and in OpenSSH, among many other applications. Unlike Salsa20, the design
    of Poly1305 is built on techniques dating back to the 1970s—namely, universal
    hash functions and the Wegman–Carter construction.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: Poly1305算法（发音为*poly*-*thirteen*-*o-five*）是由Daniel J. Bernstein于2005年设计的（他也是[第5章](chapter5.xhtml)中的Salsa20流密码和启发BLAKE及BLAKE2哈希函数的ChaCha密码的创造者）。Poly1305经过优化，能够在现代CPU上实现超快的速度，截止目前，它已经成为TLS
    1.3和OpenSSH等多种应用程序中支持的算法之一。与Salsa20不同，Poly1305的设计基于上世纪70年代的技术——即通用哈希函数和Wegman–Carter构造方法。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Universal Hash Functions</samp>
  id: totrans-88
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">通用哈希函数</samp>
- en: The Poly1305 MAC uses a *universal hash function*. Such a hash function is weaker
    than a cryptographic hash function but much faster. Universal hash functions don’t
    have to be collision resistant, for example.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: Poly1305 MAC使用了*通用哈希函数*。这种哈希函数比加密哈希函数要弱，但速度更快。例如，通用哈希函数不必具备抗碰撞性。
- en: 'Like a PRF, a universal hash is parameterized by a secret key: given a message,
    *M*, and key, *K*, we’ll write **UH**(*K*, *M*) for the output of a universal
    hash function denoted **UH**. A universal hash function has only one security
    requirement: for any two messages *M*[1] and *M*[2], and a random key *K*, the
    probability that **UH**(*K*, *M*[1]) equals **UH**(*K*, *M*[2]) must be negligible.
    Unlike a PRF, a universal hash doesn’t need to be pseudorandom; there simply should
    be no pair (*M*[1], *M*[2]) that gives the same hash for many different keys.
    Because their security requirements are easier to satisfy, universal hash functions
    require fewer operations and are considerably faster than PRFs.'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 类似于伪随机函数（PRF），通用哈希由一个秘密密钥参数化：给定一个消息 *M* 和密钥 *K*，我们用 **UH**(*K*, *M*) 表示通用哈希函数
    **UH** 的输出。通用哈希函数只有一个安全要求：对于任意两个消息 *M*[1] 和 *M*[2]，以及一个随机密钥 *K*，**UH**(*K*, *M*[1])
    等于 **UH**(*K*, *M*[2]) 的概率必须是微不足道的。与 PRF 不同，通用哈希不需要是伪随机的；只是不能有一对 (*M*[1]，*M*[2])
    对，能够在多个不同的密钥下生成相同的哈希值。由于它们的安全要求更容易满足，通用哈希函数需要的运算较少，比 PRF 快得多。
- en: 'You can use a universal hash as a MAC to authenticate no more than one message,
    however. For example, consider the universal *polynomial-evaluation* hash used
    in Poly1305\. (See the seminal 1974 article “Codes Which Detect Deception” by
    Edgar Gilbert, Jessie MacWilliams, and Neil Sloane for more on this notion.) This
    kind of polynomial-evaluation hash is parameterized by a prime number, *p*, and
    takes as input a key consisting of two numbers, *R* and *K*, in the range [1,
    *p*) and a message, *M*, consisting of *n* blocks (*M*[1], *M*[2], . . . , *M*n).
    You then compute the output of the universal hash as follows:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，你只能将通用哈希用作 MAC 来验证最多一个消息。例如，考虑 Poly1305 中使用的通用 *多项式评估* 哈希。（更多关于这一概念的信息，请参见
    Edgar Gilbert、Jessie MacWilliams 和 Neil Sloane 在1974年发表的开创性文章《检测欺骗的编码》）。这种多项式评估哈希是由一个质数
    *p* 参数化的，它接受一个由两个数字 *R* 和 *K* 组成的密钥（范围为 [1, *p*））以及一个包含 *n* 个块的消息 *M*（*M*[1]，*M*[2]，.
    . . ，*M*n）。然后，你可以按照以下方式计算通用哈希的输出：
- en: '![](../images/pg149-1.jpg)'
  id: totrans-92
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/pg149-1.jpg)'
- en: In this equation, the plus sign (+) denotes the addition of positive integers,
    *K* *^i* is the number *K* raised to the power *i*, and “mod *p*” denotes the
    reduction modulo *p* of the result (that is, the remainder of the division of
    the result by *p*; for example, 12 mod 10 = 2, 10 mod 10 = 0, 8 mod 10 = 8, and
    so on).
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在此方程中，加号（+）表示正整数的加法，*K*^i 是 *K* 的 *i* 次方，"mod *p*" 表示结果对 *p* 取模（即结果除以 *p* 的余数；例如，12
    mod 10 = 2，10 mod 10 = 0，8 mod 10 = 8，依此类推）。
- en: Because you want the hashing operation to be as fast as possible, universal
    hash-based MACs often work with message blocks of 128 bits and with a prime number,
    *p*, that’s slightly larger than 2^(128), such as 2^(128) + 51\. The 128-bit width
    allows for very fast implementations by efficiently using the 32- and 64-bit arithmetic
    units of common CPUs.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 因为你希望哈希操作尽可能快速，基于通用哈希的 MAC 通常使用 128 位的消息块和一个略大于 2^(128) 的质数 *p*，例如 2^(128) +
    51。128 位宽度通过高效使用常见 CPU 的 32 位和 64 位算术单元，允许非常快速的实现。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Security Limitations</samp>
  id: totrans-95
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">安全限制</samp>
- en: 'Universal hashes have one weakness: because a universal hash securely authenticates
    only one message, an attacker could break the preceding polynomial-evaluation
    MAC by requesting the tags of only two messages. Specifically, they could request
    the tag for a message where all blocks are zero—*M*[1] = *M*[2] = . . . = 0—to
    obtain the tag **UH**(*R*, *K*, 0) = *R*, thus finding the secret value *R*. Alternatively,
    they could request the tags for a message where *M*[1] = 1 and where *M*[2] =
    *M*[3] = . . . = 0 (whose tag is *T* = *R* + *K*), which allows them to find *K*
    by subtracting *R* from *T*. Now the attacker knows the whole key (*R*, *K*) and
    can forge MACs for any message.'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 通用哈希有一个弱点：由于通用哈希只能安全地验证一个消息，攻击者可以通过请求两个消息的标签来突破之前的多项式评估 MAC。具体来说，他们可以请求一个所有块都为零的消息的标签——*M*[1]
    = *M*[2] = . . . = 0——从而得到标签 **UH**(*R*, *K*, 0) = *R*，进而找出秘密值 *R*。或者，他们可以请求一个消息的标签，其中
    *M*[1] = 1 且 *M*[2] = *M*[3] = . . . = 0（其标签为 *T* = *R* + *K*），这样他们就可以通过从 *T*
    中减去 *R* 来找出 *K*。现在攻击者知道了整个密钥（*R*，*K*），并且能够伪造任何消息的 MAC。
- en: Fortunately, there’s a way to go from single-message security to multimessage
    security.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，存在一种方法可以将单消息安全性提升到多消息安全性。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Wegman–Carter MACs</samp>
  id: totrans-98
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Wegman–Carter MAC</samp>
- en: The trick to authenticating multiple messages using a universal hash function
    arrived thanks to IBM researchers Mark Wegman and Lawrence Carter and their 1981
    paper “New Hash Functions and Their Use in Authentication and Set Equality.” The
    Wegman–Carter construction builds a MAC from a universal hash function and a PRF,
    using two keys, *K*[1] and *K*[2], and it returns
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 使用通用哈希函数对多个消息进行身份验证的技巧得益于IBM研究员Mark Wegman和Lawrence Carter以及他们1981年发表的论文《新哈希函数及其在身份验证和集合相等中的应用》。Wegman–Carter结构通过使用两个密钥，*K*[1]和*K*[2]，以及通用哈希函数和伪随机函数（PRF）来构建MAC，返回结果为：
- en: '![](../images/pg149-2.jpg)'
  id: totrans-100
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/pg149-2.jpg)'
- en: where *N* is a nonce that must be used at most once for each key, *K*[2], and
    where **PRF**’s output is as large as that of the universal hash function **UH**.
    By adding these two values, **PRF**’s strong pseudorandom output masks the cryptographic
    weakness of **UH**. You can see this as the encryption of the universal hash’s
    result, where the PRF acts as a stream cipher and prevents the preceding attack
    by making it possible to authenticate multiple messages with the same key, *K*[1].
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 其中*N*是一个随机数，必须针对每个密钥*K*[2]使用最多一次，而**PRF**的输出与通用哈希函数**UH**的输出大小相同。通过将这两个值相加，**PRF**的强伪随机输出掩盖了**UH**的加密弱点。你可以将其视为对通用哈希结果的加密，其中PRF充当流密码，并通过使得使用相同密钥*K*[1]可以验证多个消息，来防止之前的攻击。
- en: 'To recap, the Wegman–Carter construction **UH**(*K*[1], *M*) + **PRF**(*K*[2],
    *N*) gives a secure MAC if you assume the following:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 总结一下，Wegman–Carter结构**UH**(*K*[1], *M*) + **PRF**(*K*[2], *N*)在假设以下条件的情况下，提供了一个安全的MAC：
- en: '**UH** is a secure universal hash.'
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**UH**是一个安全的通用哈希。'
- en: '**PRF** is a secure PRF.'
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**PRF**是一个安全的伪随机函数。'
- en: Each nonce *N* is used only once for each key *K*[2].
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个随机数*N*只针对每个密钥*K*[2]使用一次。
- en: The output values of **UH** and **PRF** are long enough to ensure high enough
    security.
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**UH**和**PRF**的输出值足够长，确保具有足够的安全性。'
- en: Now let’s see how Poly1305 leverages the Wegman–Carter construction to build
    a secure and fast MAC.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们看看Poly1305如何利用Wegman–Carter结构来构建一个安全且快速的MAC。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Poly1305-AES</samp>
  id: totrans-108
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Poly1305-AES</samp>
- en: Poly1305 was initially proposed as Poly1305-AES, combining the Poly1305 universal
    hash with the AES block cipher. Poly1305-AES is much faster than HMAC-based MACs,
    or even than CMACs, since it computes only one block of AES and processes the
    message in parallel through a series of simple arithmetic operations.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: Poly1305最初被提议为Poly1305-AES，结合了Poly1305通用哈希和AES块密码。Poly1305-AES比基于HMAC的MAC，甚至比CMAC还要快，因为它只计算一个AES块，并通过一系列简单的算术运算并行处理消息。
- en: 'Given 128-bit *K*[1], *K*[2], and *N* and the message *M*, Poly1305-AES returns
    the following:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 给定128位的*K*[1]、*K*[2]和*N*，以及消息*M*，Poly1305-AES返回以下结果：
- en: '![](../images/pg150-1.jpg)'
  id: totrans-111
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/pg150-1.jpg)'
- en: 'The mod 2^(128) reduction ensures that the result fits in 128 bits. Poly1305
    parses the message *M* as a sequence of 128-bit blocks (*M*[1], *M*[2], . . .
    , *M*n) and appends a 129th bit to each block’s most significant bit to make all
    blocks 129 bits long. (If the last block is smaller than 16 bytes, it’s padded
    with a 1 bit followed by 0 bits before the final 129th bit.) Next, Poly1305 evaluates
    the polynomial to compute the following:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 模2^(128)的约简确保结果适合128位。Poly1305将消息*M*解析为一系列128位的块（*M*[1]，*M*[2]，...，*M*n），并将每个块的最高有效位附加一个第129位，使得所有块的长度为129位。（如果最后一个块小于16字节，它会先填充一个1位，接着是0位，然后再添加最后的第129位。）接着，Poly1305计算该多项式，得到以下结果：
- en: '![](../images/pg150-2.jpg)'
  id: totrans-113
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/pg150-2.jpg)'
- en: The result of this expression is an integer that’s at most 129 bits long. When
    you add this to the 128-bit value **AES**(*K*[2], *N*), the result is reduced
    modulo 2^(128) to produce a 128-bit MAC.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 这个表达式的结果是一个最多129位长的整数。当你将其与128位的值**AES**(*K*[2], *N*)相加时，结果会模2^(128)约简，生成一个128位的MAC。
- en: <samp class="SANS_Dogma_OT_Bold_B_15">NOTE</samp>
  id: totrans-115
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: <samp class="SANS_Dogma_OT_Bold_B_15">注意</samp>
- en: '*I described the Wegman–Carter as using a PRF, but AES isn’t a PRF, it’s a
    pseudorandom permutation (PRP). However, that doesn’t matter because the Wegman–Carter
    construction works well with PRPs and PRFs. This is because if you’re given a
    function that’s either a PRF or a PRP, it’s hard to determine whether it’s a PRF
    of a PRP just by looking at the function’s output values. In other words, distinguishing
    a PRP from a PRF is computationally hard.*'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '*我曾经描述过Wegman–Carter使用PRF，但AES不是PRF，它是伪随机置换（PRP）。然而，这不影响结果，因为Wegman–Carter结构在PRP和PRF上都能很好地工作。这是因为如果你给定一个函数，它既可以是PRF也可以是PRP，单从函数的输出值无法判断它是PRF还是PRP。换句话说，区分PRP和PRF在计算上是困难的。*'
- en: The security analysis of Poly1305-AES (see “The Poly1305-AES Message- Authentication
    Code” at *[https://<wbr>cr<wbr>.yp<wbr>.to<wbr>/mac<wbr>/poly1305<wbr>-20050329<wbr>.pdf](https://cr.yp.to/mac/poly1305-20050329.pdf)*)
    shows that Poly1305-AES is 128-bit secure as long as AES is a secure block cipher—and
    everything is implemented correctly, as with any cryptographic algorithm.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: Poly1305-AES 的安全分析（参见 *[https://<wbr>cr<wbr>.yp<wbr>.to<wbr>/mac<wbr>/poly1305<wbr>-20050329<wbr>.pdf](https://cr.yp.to/mac/poly1305-20050329.pdf)*
    中的 "Poly1305-AES 消息认证码"）表明，只要 AES 是一个安全的分组密码，并且所有实现都正确，Poly1305-AES 就是 128 位安全的——这与任何加密算法一样。
- en: You can combine the Poly1305 universal hash with algorithms other than AES.
    For example, Poly1305 was used with the stream cipher ChaCha (see RFC 7539, “ChaCha20
    and Poly1305 for IETF Protocols”). There’s no doubt that Poly1305 will continue
    being used wherever a fast MAC is needed.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以将 Poly1305 通用哈希与 AES 之外的其他算法结合使用。例如，Poly1305 被与流密码 ChaCha 一起使用（参见 RFC 7539，"ChaCha20
    和 Poly1305 用于 IETF 协议"）。毫无疑问，Poly1305 将继续在需要快速 MAC 的地方得到应用。
- en: Although Poly1305 is fast and secure, it has several downsides. For one, its
    polynomial evaluation is difficult to implement efficiently, especially in the
    hands of those unfamiliar with the associated mathematical notions. (See examples
    at *[https://<wbr>github<wbr>.com<wbr>/floodyberry<wbr>/poly1305<wbr>-donna](https://github.com/floodyberry/poly1305-donna)*.)
    Second, on its own, it’s secure for only one message unless you use the Wegman–Carter
    construction. But in that case it requires a nonce, and if the nonce is repeated,
    the algorithm becomes insecure. Finally, Poly1305 is optimized for long messages,
    but it’s overkill if you process only small messages (say, fewer than 128 bytes).
    In such cases, SipHash is a good solution.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管 Poly1305 既快速又安全，但它也有一些缺点。首先，它的多项式评估实现起来较为复杂，特别是对于那些不熟悉相关数学概念的人来说尤为困难。（参见
    *[https://<wbr>github<wbr>.com<wbr>/floodyberry<wbr>/poly1305<wbr>-donna](https://github.com/floodyberry/poly1305-donna)*
    的示例。）其次，单独使用时，它只对一个消息是安全的，除非你使用 Wegman-Carter 构造。但是在这种情况下，它需要使用一个 nonce，并且如果 nonce
    被重复使用，算法将变得不安全。最后，Poly1305 对长消息进行了优化，但如果仅处理小消息（比如少于 128 字节），它就显得有些过度。在这种情况下，SipHash
    是一个不错的解决方案。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">SipHash</samp>
  id: totrans-120
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">SipHash</samp>
- en: 'I designed SipHash in 2012 with Dan Bernstein initially to address a noncryptographic
    problem: denial-of-service attacks on hash tables. Hash tables are data structures,
    notably used in programming languages to efficiently store elements internally.
    Prior to SipHash, hash tables relied on noncryptographic keyed hash functions
    for which collisions were often easy to find, which could be exploited to slow
    down the system and perform denial-of-service attacks. We observed that a PRF
    would address this problem and set out to design SipHash, a PRF suitable for hash
    tables. Because hash tables process mostly short inputs, SipHash is optimized
    for short messages. SipHash is a full-blown PRF and MAC that shines where most
    inputs are short.'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 我与 Dan Bernstein 一起在 2012 年设计了 SipHash，最初是为了解决一个非加密问题：哈希表的拒绝服务攻击。哈希表是一种数据结构，特别用于编程语言中高效地存储元素。在
    SipHash 之前，哈希表依赖于非加密的密钥哈希函数，这些哈希函数经常能轻易找到冲突，这可以被利用来减慢系统速度并执行拒绝服务攻击。我们观察到伪随机函数（PRF）可以解决这个问题，于是着手设计了
    SipHash，一个适用于哈希表的 PRF。由于哈希表主要处理短输入，SipHash 对短消息进行了优化。SipHash 是一个完整的 PRF 和 MAC，在大多数输入较短的场景下表现出色。
- en: 'SipHash uses a trick that makes it more secure than basic sponge functions:
    instead of XORing message blocks only once before the permutation, SipHash XORs
    them before and after the permutation, as [Figure 7-5](chapter7.xhtml#fig7-5)
    illustrates. The 128-bit key of SipHash is seen as two 64-bit words, *K*[1] and
    *K*[2], XORed to a 256-bit fixed initial state that’s seen as four 64-bit words.
    Next, the keys are discarded, and computing SipHash boils down to iterating through
    a core function called SipRound and then XORing message chunks to modify the four-word
    internal state. Finally, SipHash returns a 64-bit tag by XORing the four-state
    words together.'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: SipHash 使用了一个技巧，使它比基本的海绵函数更安全：它不是在置换前仅对消息块进行一次异或运算，而是在置换前后都对消息块进行异或运算，正如 [图
    7-5](chapter7.xhtml#fig7-5) 所示。SipHash 的 128 位密钥被视为两个 64 位字，*K*[1] 和 *K*[2]，它们异或成一个
    256 位的固定初始状态，这个状态又被视为四个 64 位字。接下来，密钥被丢弃，计算 SipHash 就简化为通过一个叫做 SipRound 的核心函数进行迭代，然后将消息块异或到四字内部状态中。最后，SipHash
    通过将四个状态字异或在一起，返回一个 64 位标签。
- en: '![](../images/fig7-5.jpg)'
  id: totrans-123
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/fig7-5.jpg)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 7-5: SipHash-2-4 processing
    a 15-byte message (a block,</samp> <samp class="SANS_Futura_Std_Book_11">M</samp><samp
    class="SANS_Futura_Std_Book_Oblique_I-SUB_11">1</samp><samp class="SANS_Futura_Std_Book_Oblique_I_11">,
    of 8 bytes and a block,</samp> <samp class="SANS_Futura_Std_Book_11">M</samp><samp
    class="SANS_Futura_Std_Book_Oblique_I-SUB_11">2</samp><samp class="SANS_Futura_Std_Book_Oblique_I_11">,
    of 7 bytes, plus 1 byte of padding)</samp>'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图7-5：SipHash-2-4 处理一个15字节的消息（一个块，</samp>
    <samp class="SANS_Futura_Std_Book_11">M</samp><samp class="SANS_Futura_Std_Book_Oblique_I-SUB_11">1</samp><samp
    class="SANS_Futura_Std_Book_Oblique_I_11">，8字节，和一个块，</samp> <samp class="SANS_Futura_Std_Book_11">M</samp><samp
    class="SANS_Futura_Std_Book_Oblique_I-SUB_11">2</samp><samp class="SANS_Futura_Std_Book_Oblique_I_11">，7字节，再加1字节填充）</samp>
- en: 'The SipRound function uses a bunch of XORs together with additions and word
    rotations to make the function secure. SipRound transforms a state of four 64-bit
    words (*a*, *b*, *c*, *d*) by performing the following operations, top to bottom.
    The operations on the left and on the right are independent and can be carried
    out in parallel:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: SipRound函数使用一堆XOR运算以及加法和字旋转来使函数安全。 SipRound通过从上到下执行以下操作来转换四个64位字（*a*、*b*、*c*、*d*）的状态。左侧和右侧的操作是独立的，可以并行执行：
- en: '![](../images/pg152-1.jpg)'
  id: totrans-126
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/pg152-1.jpg)'
- en: Here, *a* += *b* is shorthand for *a* = *a* + *b*, and *b* <<< = 13 is shorthand
    for *b* = *b* <<< 13 (the 64-bit word *b* left-rotated 13 bits).
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，*a* += *b* 是 *a* = *a* + *b* 的简写，*b* <<< = 13 是 *b* = *b* <<< 13 的简写（64位字
    *b* 左旋13位）。
- en: These simple operations on 64-bit words are almost all you need to implement
    to compute SipHash—although you won’t have to implement it yourself. You can find
    readily available implementations in most languages, such as C, Go, Java, JavaScript,
    Python, and Rust.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 这些对64位字的简单操作几乎是您需要实现以计算SipHash的全部内容——尽管您不必自己实现它。 您可以在大多数语言中找到现成的实现，如C、Go、Java、JavaScript、Python和Rust。
- en: <samp class="SANS_Dogma_OT_Bold_B_15">NOTE</samp>
  id: totrans-129
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: <samp class="SANS_Dogma_OT_Bold_B_15">注意</samp>
- en: '*I wrote* ***SipHash****-*x*-*y *as the SipHash version, meaning it makes*
    x *SipRounds between each message block injection and then* y *rounds. More rounds
    require more operations, which slows down operations but also increases security.
    The default version is SipHash-2-4 (simply noted as SipHash), and it has so far
    resisted cryptanalysis. Note that I also defined SipHash128, a version of SipHash
    producing 128-bit tags.*'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '*我写了* ***SipHash****-*x*-*y *作为SipHash版本，意味着在每个消息块注入之间进行* x *个SipRounds，然后进行*
    y *轮。更多轮次需要更多操作，这会减慢操作速度，但也会增加安全性。 默认版本是SipHash-2-4（简称为SipHash），迄今为止它已经抵抗了密码分析。
    请注意，我还定义了SipHash128，SipHash的一个生成128位标签的版本。*'
- en: 'Many systems, such as the Rust language, the OpenBSD operating system, and
    the Bitcoin blockchain, use SipHash internally. The Linux kernel uses SipHash
    too and also uses HalfSipHash, “SipHash’s insecure younger cousin,” a smaller
    version with a 64-bit key and 32-bit output (see *[https://<wbr>docs<wbr>.kernel<wbr>.org<wbr>/security<wbr>/siphash<wbr>.html](https://docs.kernel.org/security/siphash.html)*).  ###
    <samp class="SANS_Futura_Std_Bold_B_11">How Things Can Go Wrong</samp>'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 许多系统，如Rust语言、OpenBSD操作系统和比特币区块链，内部使用SipHash。Linux内核也使用SipHash，并且还使用HalfSipHash，“SipHash的不安全的年轻表亲”，一个具有64位密钥和32位输出的较小版本（参见*[https://<wbr>docs<wbr>.kernel<wbr>.org<wbr>/security<wbr>/siphash<wbr>.html](https://docs.kernel.org/security/siphash.html)*）。###
    <samp class="SANS_Futura_Std_Bold_B_11">事情可能出错的地方</samp>
- en: Like ciphers and unkeyed hash functions, MACs and PRFs that are secure on paper
    can be vulnerable to attacks when used in a real setting. Let’s discuss two examples.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 像密码和无密钥哈希函数一样，纸面上安全的MAC和PRF在实际环境中使用时可能会受到攻击。 让我们讨论两个例子。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Timing Attacks on
    MAC Verification</samp>
  id: totrans-133
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">MAC验证的时序攻击</samp>
- en: '*Side-channel attacks* target the implementation of a cryptographic algorithm
    rather than the algorithm itself. In particular, *timing attacks* use an algorithm’s
    execution time to determine secret information, such as keys, plaintext, and secret
    random values. Variable-time string comparison induces vulnerabilities not only
    in MAC verification but also in many other cryptographic and security functionalities.'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '*侧信道攻击* 针对的是加密算法的实现而不是算法本身。特别是 *时序攻击* 利用算法的执行时间来确定秘密信息，如密钥、明文和秘密随机值。变时间字符串比较不仅在MAC验证中引入漏洞，还在许多其他加密和安全功能中引入漏洞。'
- en: 'MACs can be vulnerable to timing attacks when a remote system verifies tags
    in a period of time that depends on the tag’s value, thereby allowing an attacker
    to determine the correct message tag by trying many incorrect ones to determine
    the one that takes the longest amount of time to complete. The problem occurs
    when a server compares the correct tag with an incorrect one by comparing the
    two strings byte per byte, in order, until the bytes differ. For example, the
    Python code in [Listing 7-1](chapter7.xhtml#Lis7-1) compares two strings byte
    per byte, in variable time: if the first bytes differ, the function returns after
    only one comparison; if the strings <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">y</samp> are identical, the
    function makes <samp class="SANS_TheSansMonoCd_W5Regular_11">n</samp> comparisons
    against the length of the strings.'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 当远程系统在依赖于标签值的时间内验证标签时，MAC（消息认证码）可能会受到定时攻击的影响，从而允许攻击者通过尝试多个错误的标签来确定正确的消息标签，最终找出完成时间最长的那个。当服务器逐字节按顺序比较正确的标签和错误标签，直到字节不同时，问题就出现了。例如，[列表
    7-1](chapter7.xhtml#Lis7-1)中的 Python 代码逐字节按可变时间比较两个字符串：如果第一个字节不同，函数仅经过一次比较就返回；如果字符串
    <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp> 和 <samp class="SANS_TheSansMonoCd_W5Regular_11">y</samp>
    相同，函数会根据字符串的长度进行 <samp class="SANS_TheSansMonoCd_W5Regular_11">n</samp> 次比较。
- en: '[PRE0]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 7-1: A comparison of
    two</samp> <samp class="SANS_Futura_Std_Book_11">n-</samp><samp class="SANS_Futura_Std_Book_Oblique_I_11">byte
    strings, taking variable time</samp>'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">列表 7-1：比较两个</samp> <samp class="SANS_Futura_Std_Book_11">n-</samp><samp
    class="SANS_Futura_Std_Book_Oblique_I_11">字节字符串，采用可变时间</samp>
- en: To demonstrate the vulnerability of the <samp class="SANS_TheSansMonoCd_W5Regular_11">compare_mac()</samp>
    function, we’ll write a program that measures the execution time of 100,000 calls
    to <samp class="SANS_TheSansMonoCd_W5Regular_11">compare_mac()</samp>, first with
    identical 16-character <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">y</samp> values and then with
    <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">y</samp>
    values that differ in their third byte. The latter comparison should take noticeably
    less time because <samp class="SANS_TheSansMonoCd_W5Regular_11">compare_mac()</samp>
    compares fewer bytes than the identical <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">y</samp>, as [Listing 7-2](chapter7.xhtml#Lis7-2)
    shows.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 为了演示 <samp class="SANS_TheSansMonoCd_W5Regular_11">compare_mac()</samp> 函数的漏洞，我们将编写一个程序，测量
    100,000 次调用 <samp class="SANS_TheSansMonoCd_W5Regular_11">compare_mac()</samp>
    的执行时间，首先是相同的 16 字符 <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp> 和 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">y</samp> 值，然后是第三个字节不同的 <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp>
    和 <samp class="SANS_TheSansMonoCd_W5Regular_11">y</samp> 值。后者的比较应该花费明显更少的时间，因为
    <samp class="SANS_TheSansMonoCd_W5Regular_11">compare_mac()</samp> 比较的字节比相同的 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">x</samp> 和 <samp class="SANS_TheSansMonoCd_W5Regular_11">y</samp>
    少，正如[列表 7-2](chapter7.xhtml#Lis7-2)所示。
- en: '[PRE1]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 7-2: Measuring timing
    differences when executing</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">compare_mac()</samp>
    <samp class="SANS_Futura_Std_Book_Oblique_I_11">from [Listing 7-1](chapter7.xhtml#Lis7-1)</samp>'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">列表 7-2：执行</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">compare_mac()</samp>
    <samp class="SANS_Futura_Std_Book_Oblique_I_11">时测量时间差异，来自[列表 7-1](chapter7.xhtml#Lis7-1)</samp>
- en: On a MacBook Pro with an ARM M1 chip, an execution of the program in [Listing
    7-2](chapter7.xhtml#Lis7-2) prints execution times of around 67 and 26 milliseconds,
    respectively. That difference is significant enough to identify what’s happening
    within the algorithm. Now move the difference to other offsets in the string,
    and you’ll observe different execution times for different offsets. If <samp class="SANS_TheSansMonoCd_W5Regular_11">MAC1</samp>
    is the correct MAC tag and <samp class="SANS_TheSansMonoCd_W5Regular_11">MAC2</samp>
    is the one tried by the attacker, you can easily identify the position of the
    first difference, which is the number of correctly guessed bytes.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 在搭载ARM M1芯片的MacBook Pro上，[列表 7-2](chapter7.xhtml#Lis7-2)中的程序执行时间分别约为67毫秒和26毫秒。这个差异足够大，可以帮助识别算法内部发生了什么。现在，将差异转移到字符串中的其他偏移位置，你将会观察到不同偏移位置的执行时间不同。如果<code
    class="SANS_TheSansMonoCd_W5Regular_11">MAC1</code>是正确的MAC标签，而<code class="SANS_TheSansMonoCd_W5Regular_11">MAC2</code>是攻击者尝试的标签，你就能轻松识别第一个差异的位置，这个位置表示正确猜测的字节数。
- en: 'If execution time doesn’t depend on a secret timing, timing attacks won’t work,
    which is why implementers strive to write *constant-time* implementations—that
    is, code that takes exactly the same time to complete for any secret input value.
    For example, the C function in [Listing 7-3](chapter7.xhtml#Lis7-3) compares two
    buffers of <samp class="SANS_TheSansMonoCd_W5Regular_11">size</samp> bytes in
    constant time: the temporary variable <samp class="SANS_TheSansMonoCd_W5Regular_11">result</samp>
    is nonzero if and only if there’s a difference somewhere in the two buffers.'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 如果执行时间不依赖于某个秘密时序，那么定时攻击将无法生效，这也是实现者努力编写*恒定时间*实现的原因——即无论输入的秘密值是什么，代码完成所需的时间都完全相同。例如，[列表
    7-3](chapter7.xhtml#Lis7-3)中的C函数以恒定时间比较两个<code class="SANS_TheSansMonoCd_W5Regular_11">size</code>字节的缓冲区：临时变量<code
    class="SANS_TheSansMonoCd_W5Regular_11">result</code>只有在两个缓冲区之间存在差异时才为非零。
- en: '[PRE2]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 7-3: A constant-time
    comparison of two buffers for safer MAC verification</samp>  #### <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">When
    Sponges Leak</samp>'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '<code class="SANS_Futura_Std_Book_Oblique_I_11">列表 7-3：用于更安全的MAC验证的恒定时间比较两个缓冲区</code>  ####
    <code class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">当海绵泄漏时</code>'
- en: Permutation-based algorithms like SHA-3 and SipHash are simple, are easy to
    implement, and come with compact implementations, but they’re fragile in the face
    of side-channel attacks that recover a snapshot of the system’s state. For example,
    if a process can read the RAM and registers’ values at any time or read a core
    dump of the memory, an attacker can determine the internal state of SHA-3 in MAC
    mode, or the internal state of SipHash, and then compute the reverse of the permutation
    to recover the initial secret state. They can then forge tags for any message,
    breaking the MAC’s security.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 基于置换的算法，如SHA-3和SipHash，简单、易于实现，且具有紧凑的实现，但在面对恢复系统状态快照的旁路攻击时，它们比较脆弱。例如，如果一个进程能够随时读取RAM和寄存器的值，或者读取内存的核心转储，攻击者就能确定SHA-3在MAC模式下的内部状态，或SipHash的内部状态，然后计算置换的逆操作来恢复初始的秘密状态。之后，他们可以伪造任何消息的标签，从而破坏MAC的安全性。
- en: Fortunately, this attack won’t work against compression function–based MACs
    such as HMAC-SHA-256 and keyed BLAKE2 because the attacker requires a snapshot
    of memory at the exact time when the key is used. The upshot is that if you’re
    in an environment where parts of a process’s memory may leak, you can use a MAC
    based on a noninvertible transform compression function rather than on a permutation.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，这种攻击对基于压缩函数的MAC（如HMAC-SHA-256和带密钥的BLAKE2）无效，因为攻击者需要在密钥使用的精确时刻捕获内存快照。结果是，如果你处于一个可能泄露进程部分内存的环境中，你可以使用基于不可逆变换压缩函数的MAC，而不是基于置换的MAC。
- en: <samp class="SANS_Futura_Std_Bold_B_11">Further Reading</samp>
  id: totrans-147
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <code class="SANS_Futura_Std_Bold_B_11">进一步阅读</code>
- en: 'The venerable HMAC deserves more attention than I have space for here, and
    even more for the train of thought that led to its wide adoption and eventual
    demise when combined with a weak hash function. I recommend the 1996 paper “Keying
    Hash Functions for Message Authentication” by Mihir Bellare, Ran Canetti, and
    Hugo Krawczyk, which introduced HMAC and its cousin NMAC, and the 2006 follow-up
    paper by Bellare called “New Proofs for NMAC and HMAC: Security Without Collision-Resistance,”
    which proves that HMAC doesn’t need a collision-resistant hash but only a hash
    with a compression function that is a PRF. On the offensive side, the 2007 paper
    “Full Key-Recovery Attacks on HMAC/NMAC-MD4 and NMAC-MD5” by Pierre-Alain Fouque,
    Gaëtan Leurent, and Phong Nguyen shows how to attack HMAC and NMAC when they’re
    built on top of a brittle hash function such as MD4 or MD5\. (HMAC-MD5 and HMAC-SHA-1
    aren’t totally broken, but the risk is high enough.)'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 受人尊敬的 HMAC 值得更多的关注，比我在这里所能提到的要多得多，特别是它的广泛应用和最终因与弱哈希函数结合而导致的衰退背后的思维过程。我推荐 1996
    年由 Mihir Bellare、Ran Canetti 和 Hugo Krawczyk 撰写的论文《消息认证的哈希函数键控》，该论文介绍了 HMAC 及其同类
    NMAC，还有 2006 年 Bellare 撰写的后续论文《NMAC 和 HMAC 的新证明：无需碰撞抗性的安全性》，该论文证明了 HMAC 不需要碰撞抗性的哈希函数，只需要具有压缩函数的伪随机函数（PRF）的哈希函数。在进攻方面，Pierre-Alain
    Fouque、Gaëtan Leurent 和 Phong Nguyen 在 2007 年的论文《HMAC/NMAC-MD4 和 NMAC-MD5 的完整密钥恢复攻击》中展示了如何攻击基于脆弱哈希函数（如
    MD4 或 MD5）构建的 HMAC 和 NMAC。（HMAC-MD5 和 HMAC-SHA-1 并未完全崩溃，但风险已经足够高。）
- en: The Wegman–Carter MACs are also worth more attention, both for their practical
    interest and for their underlying theory. The seminal papers by Wegman and Carter
    are available at *[https://<wbr>cr<wbr>.yp<wbr>.to<wbr>/bib<wbr>/entries<wbr>.html](https://cr.yp.to/bib/entries.html)*.
    Other state-of-the-art designs include UMAC and VMAC, which are among the fastest
    MACs on long messages.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: Wegman–Carter MACs 也值得更多关注，无论是从实际应用的角度，还是从其底层理论的角度。Wegman 和 Carter 的开创性论文可以在
    *[https://<wbr>cr<wbr>.yp<wbr>.to<wbr>/bib<wbr>/entries<wbr>.html](https://cr.yp.to/bib/entries.html)*
    中找到。其他前沿设计包括 UMAC 和 VMAC，它们是处理长消息时速度最快的 MAC 之一。
- en: One type of MAC not discussed in this chapter is *Pelican*, which uses the AES
    block cipher reduced to four rounds (down from 10 in the full block cipher) to
    authenticate chunks of messages within a simplistic construction, as described
    in *[https://<wbr>eprint<wbr>.iacr<wbr>.org<wbr>/2005<wbr>/088](https://eprint.iacr.org/2005/088)*.
    Pelican is more of a curiosity, though, and it’s rarely used in practice.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 本章没有讨论的另一种 MAC 是 *Pelican*，它使用经过简化的 AES 区块密码（将完整区块密码的 10 轮减少到 4 轮）来验证消息块，在一种简易结构中进行认证，具体描述可以参考
    *[https://<wbr>eprint<wbr>.iacr<wbr>.org<wbr>/2005<wbr>/088](https://eprint.iacr.org/2005/088)*。不过，Pelican
    更多的是一个好奇心驱动的研究，实际上很少被使用。
- en: Last but not least, if you’re interested in finding vulnerabilities in cryptographic
    software, look for uses of CBC-MAC or for weaknesses caused by HMAC handling keys
    of arbitrary sizes—taking **Hash**(*K*) as the key rather than *K* if *K* is too
    long, thus making *K* and **Hash**(*K*) *equivalent keys*. Or just look for systems
    that don’t use MAC when they should—a frequent occurrence.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 最后但同样重要的是，如果你有兴趣寻找密码学软件中的漏洞，可以关注 CBC-MAC 的使用，或者关注由于 HMAC 处理任意大小的密钥而导致的弱点——如果
    *K* 太长，就将 **Hash**(*K*) 作为密钥，而不是 *K*，从而使得 *K* 和 **Hash**(*K*) 成为 *等效密钥*。或者，你也可以关注那些应该使用
    MAC 却没有使用的系统——这种情况很常见。
- en: In [Chapter 8](chapter8.xhtml), we’ll combine MACs with ciphers to protect a
    message’s authenticity, integrity, *and* confidentiality. We’ll also do this without
    MACs, thanks to authenticated ciphers, which combine the functionality of a basic
    cipher with that of a MAC by returning a tag along with each ciphertext.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [第 8 章](chapter8.xhtml) 中，我们将结合 MAC 和密码学算法来保护消息的真实性、完整性和*保密性*。我们也会在没有使用 MAC
    的情况下实现这一目标，得益于认证密码，它将基础密码和 MAC 的功能结合在一起，每次加密时都会返回一个标签。
