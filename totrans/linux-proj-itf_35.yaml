- en: Chapter 35. Process Priorities and Scheduling
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第 35 章 进程优先级与调度
- en: This chapter discusses various system calls and process attributes that determine
    when and which processes obtain access to the CPU(s). We begin by describing the
    *nice* value, a process characteristic that influences the amount of CPU time
    that a process is allocated by the kernel scheduler. We follow this with a description
    of the POSIX realtime scheduling API. This API allows us to define the policy
    and priority used for scheduling processes, giving us much tighter control over
    how processes are allocated to the CPU. We conclude with a discussion of the system
    calls for setting a process’s CPU affinity mask, which determines the set of CPUs
    on which a process running on a multiprocessor system will run.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章讨论了各种系统调用和进程属性，这些属性决定了何时以及哪些进程可以访问 CPU。我们首先描述了*nice*值，它是一个进程特性，影响内核调度器为进程分配的
    CPU 时间量。接着，我们介绍了 POSIX 实时调度 API。该 API 允许我们定义调度进程时使用的策略和优先级，从而对进程如何分配到 CPU 上提供更紧密的控制。最后，我们讨论了设置进程
    CPU 亲和性掩码的系统调用，CPU 亲和性掩码决定了在多处理器系统上运行的进程将在哪些 CPU 上运行。
- en: Process Priorities (Nice Values)
  id: totrans-2
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 进程优先级（Nice 值）
- en: 'On Linux, as with most other UNIX implementations, the default model for scheduling
    processes for use of the CPU is *round-robin time-sharing*. Under this model,
    each process in turn is permitted to use the CPU for a brief period of time, known
    as a *time slice* or *quantum*. Round-robin time-sharing satisfies two important
    requirements of an interactive multitasking system:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Linux 中，和大多数其他 UNIX 实现一样，调度进程使用 CPU 的默认模型是 *轮转时间共享*。在这个模型下，每个进程依次被允许使用 CPU
    一段简短的时间，这段时间被称为 *时间片* 或 *量子*。轮转时间共享满足了交互式多任务系统的两个重要要求：
- en: '*Fairness*: Each process gets a share of the CPU.'
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*公平性*：每个进程都能获得 CPU 的一部分。'
- en: '*Responsiveness*: A process doesn’t need to wait for long periods before it
    receives use of the CPU.'
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*响应性*：进程不需要长时间等待才能使用 CPU。'
- en: Under the round-robin time-sharing algorithm, processes can’t exercise direct
    control over when and for how long they will be able to use the CPU. By default,
    each process in turn receives use of the CPU until its time slice runs out or
    it voluntarily gives up the CPU (for example, by putting itself to sleep or performing
    a disk read). If all processes attempt to use the CPU as much as possible (i.e.,
    no process ever sleeps or blocks on an I/O operation), then they will receive
    a roughly equal share of the CPU.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在轮转时间共享算法下，进程无法直接控制自己何时以及能使用 CPU 多长时间。默认情况下，每个进程依次获得 CPU 使用权，直到其时间片耗尽或自愿放弃 CPU（例如，通过使自己休眠或执行磁盘读取）。如果所有进程都尽可能多地使用
    CPU（即，没有进程会休眠或阻塞 I/O 操作），那么它们将大致平等地分配到 CPU。
- en: However, one process attribute, the *nice value*, allows a process to indirectly
    influence the kernel’s scheduling algorithm. Each process has a nice value in
    the range -20 (high priority) to +19 (low priority); the default is 0 (refer to
    [Figure 35-1](ch35.html#range_and_interpretation_of_the_process "Figure 35-1. Range
    and interpretation of the process nice value")). In traditional UNIX implementations,
    only privileged processes can assign themselves (or other processes) a negative
    (high) priority. (We’ll explain some Linux differences in [Modifying and Retrieving
    Policies and Priorities](ch35.html#modifying_and_retrieving_policies_and_pr "Modifying
    and Retrieving Policies and Priorities").) Unprivileged processes can only lower
    their priority, by assuming a nice value greater than the default of 0\. By doing
    this, they are being “nice” to other processes, and this fact gives the attribute
    its name.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，有一个进程属性——*nice 值*，允许进程间接影响内核的调度算法。每个进程都有一个 nice 值，范围从 -20（高优先级）到 +19（低优先级）；默认值为
    0（参见 [图 35-1](ch35.html#range_and_interpretation_of_the_process "Figure 35-1. Range
    and interpretation of the process nice value")）。在传统的 UNIX 实现中，只有具有特权的进程才能为自己（或其他进程）分配一个负数（高）优先级。（我们将在
    [修改和检索策略与优先级](ch35.html#modifying_and_retrieving_policies_and_pr "Modifying and
    Retrieving Policies and Priorities") 中解释一些 Linux 的差异。）无特权的进程只能通过设置比默认值 0 更大的 nice
    值来降低其优先级。通过这样做，它们“对其他进程友好”，这一事实也给该属性起了这个名字。
- en: The nice value is inherited by a child created via *fork()* and preserved across
    an *exec()*.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: nice 值通过 *fork()* 创建的子进程继承，并在 *exec()* 调用时保持不变。
- en: Note
  id: totrans-9
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Rather than returning the actual nice value, the *getpriority()* system call
    service routine returns a number in the range 1 (low priority) to 40 (high priority),
    calculated according to the formula *unice = 20 - knice*. This is done to avoid
    having a negative return value from a system call service routine, which is used
    to indicate an error. (See the description of system call service routines in
    Section 3.1.) Applications are unaware of the manipulated value returned by the
    system call service routine, since the C library *getpriority()* wrapper function
    reverses the calculation, returning the value *20 - unice* to the calling program.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: '*getpriority()* 系统调用服务例程并不返回实际的 nice 值，而是返回一个介于 1（低优先级）和 40（高优先级）之间的数字，计算公式为
    *unice = 20 - knice*。这样做是为了避免系统调用服务例程返回负值，负值用于表示错误。（参见 3.1 节中对系统调用服务例程的描述。）应用程序不会意识到系统调用服务例程返回的值已经被操控，因为
    C 库中的 *getpriority()* 包装函数会将计算反转，返回 *20 - unice* 的值给调用程序。'
- en: '![Range and interpretation of the process nice value](figs/web/35-1_PROCPRI-nice-scale90.png.jpg)Figure 35-1. Range
    and interpretation of the process nice value'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: '![进程 nice 值的范围和解释](figs/web/35-1_PROCPRI-nice-scale90.png.jpg)图 35-1. 进程 nice
    值的范围和解释'
- en: Effect of the nice value
  id: totrans-12
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: nice 值的影响
- en: Processes are not scheduled in a strict hierarchy by nice value; rather, the
    nice value acts as weighting factor that causes the kernel scheduler to favor
    processes with higher priorities. Giving a process a low priority (i.e., high
    nice value) won’t cause it to be completely starved of the CPU, but causes it
    to receive relatively less CPU time. The extent to which the nice value influences
    the scheduling of a process has varied across Linux kernel versions, as well as
    across UNIX systems.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 进程的调度不是严格按照 nice 值的层级顺序进行的；相反，nice 值作为一个加权因子，使内核调度器倾向于优先调度优先级较高的进程。将进程设置为低优先级（即，高
    nice 值）不会导致其完全无法获得 CPU，但会使其相对获得较少的 CPU 时间。nice 值对进程调度的影响在不同版本的 Linux 内核以及不同的 UNIX
    系统之间有所不同。
- en: Note
  id: totrans-14
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Starting in kernel 2.6.23, a new kernel scheduling algorithm means that relative
    differences in nice values have a much stronger effect than in previous kernels.
    As a result, processes with low nice values receive less CPU than before, and
    processes with high nice values obtain a greater proportion of the CPU.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 从内核 2.6.23 开始，一种新的内核调度算法意味着，相较于以前的内核，nice 值之间的相对差异对调度的影响要强得多。因此，具有较低 nice 值的进程比以前获得的
    CPU 时间要少，而具有较高 nice 值的进程则获得更多的 CPU 时间。
- en: Retrieving and modifying priorities
  id: totrans-16
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 检索和修改优先级
- en: The *getpriority()* and *setpriority()* system calls allow a process to retrieve
    and change its own nice value or that of another process.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '*getpriority()* 和 *setpriority()* 系统调用允许进程检索和更改自身或其他进程的 nice 值。'
- en: '[PRE0]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Note
  id: totrans-19
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Returns (possibly negative) nice value of specified process on success, or -1
    on error
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 成功时返回指定进程的（可能为负的）nice 值，出错时返回 -1
- en: '[PRE1]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Note
  id: totrans-22
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Returns 0 on success, or -1 on error
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 成功时返回 0，出错时返回 -1
- en: 'Both system calls take the arguments *which* and *who*, identifying the process(es)
    whose priority is to be retrieved or modified. The *which* argument determines
    how *who* is interpreted. This argument takes one of the following values:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个系统调用都接受 *which* 和 *who* 作为参数，用于标识需要获取或修改优先级的进程。*which* 参数决定了如何解释 *who*。该参数的值可以是以下之一：
- en: '`PRIO_PROCESS`'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '`PRIO_PROCESS`'
- en: Operate on the process whose process ID equals *who*. If *who* is 0, use the
    caller’s process ID.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 对进程进行操作，该进程的进程 ID 等于 *who*。如果 *who* 为 0，则使用调用者的进程 ID。
- en: '`PRIO_PGRP`'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '`PRIO_PGRP`'
- en: Operate on all of the members of the process group whose process group ID equals
    *who*. If *who* is 0, use the caller’s process group.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 对进程组中所有进程进行操作，该进程组的进程组 ID 等于 *who*。如果 *who* 为 0，则使用调用者的进程组。
- en: '`PRIO_USER`'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '`PRIO_USER`'
- en: Operate on all processes whose real user ID equals *who*. If *who* is 0, use
    the caller’s real user ID.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 对所有真实用户 ID 等于 *who* 的进程进行操作。如果 *who* 为 0，则使用调用者的真实用户 ID。
- en: The *id_t* data type, used for the *who* argument, is an integer type of sufficient
    size to accommodate a process ID or a user ID.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '*id_t* 数据类型用于 *who* 参数，是一种足够大的整数类型，可以容纳进程 ID 或用户 ID。'
- en: The *getpriority()* system call returns the nice value of the process specified
    by *which* and *who*. If multiple processes match the criteria specified (which
    may occur if *which* is `PRIO_PGRP` or `PRIO_USER`), then the nice value of the
    process with the highest priority (i.e., lowest numerical value) is returned.
    Since *getpriority()* may legitimately return a value of -1 on a successful call,
    we must test for an error by setting *errno* to 0 prior to the call, and then
    checking for a -1 return status and a nonzero *errno* value after the call.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '*getpriority()* 系统调用返回由 *which* 和 *who* 指定的进程的 nice 值。如果有多个进程匹配指定的标准（例如 *which*
    为 `PRIO_PGRP` 或 `PRIO_USER`），则返回优先级最高（即数值最小）的进程的 nice 值。由于 *getpriority()* 在成功调用时可能合法地返回
    -1，我们必须通过在调用前将 *errno* 设置为 0，然后在调用后检查 -1 的返回状态和非零的 *errno* 值来检测错误。'
- en: The *setpriority()* system call sets the nice value of the process(es) specified
    by *which* and *who* to the value specified in *prio*. Attempts to set a nice
    value to a number outside the permitted range (-20 to +19) are silently bounded
    to this range.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '*setpriority()* 系统调用将由 *which* 和 *who* 指定的进程的 nice 值设置为 *prio* 中指定的值。尝试将 nice
    值设置为超出允许范围的数字（-20 到 +19）将被默默地限制在这个范围内。'
- en: Note
  id: totrans-34
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Historically, the nice value was changed using the call *nice(incr)*, which
    added *incr* to the calling process’s nice value. This function is still available,
    but it is superseded by the more general *setpriority()* system call.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 历史上，nice 值是通过调用 *nice(incr)* 来更改的，该调用将 *incr* 添加到调用进程的 nice 值。这个函数仍然可用，但已经被更通用的
    *setpriority()* 系统调用所取代。
- en: The command-line analogs of *setpriority()* are *nice(1)*, which can be used
    by unprivileged users to run a command with a lower priority or by privileged
    users to run a command with a raised priority, and *renice(8)*, which can be used
    by the superuser to change the nice value of an existing process.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '*setpriority()* 的命令行类似命令是 *nice(1)*，普通用户可以使用它来以较低的优先级运行命令，而特权用户可以用它来以提高的优先级运行命令；*renice(8)*
    可以由超级用户用来更改现有进程的 nice 值。'
- en: A privileged (`CAP_SYS_NICE`) process can change the priority of any process.
    An unprivileged process may change its own priority (by specifying *which* as
    `PRIO_PROCESS`, and *who* as 0) or the priority of another (target) process, if
    its effective user ID matches the real or effective user ID of the target process.
    The Linux permission rules for *setpriority()* differ from SUSv3, which specifies
    that an unprivileged process can change the priority of another process if its
    real or effective user ID matches the effective user ID of the target process.
    UNIX implementations show some variation on this point. Some follow the SUSv3
    rules, but others—notably the BSDs—behave in the same way as Linux.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 一个具有特权的（`CAP_SYS_NICE`）进程可以更改任何进程的优先级。一个没有特权的进程可以更改其自身的优先级（通过将 *which* 设置为 `PRIO_PROCESS`，*who*
    设置为 0），或者如果其有效用户 ID 与目标进程的实际用户 ID 或有效用户 ID 匹配，则可以更改另一个（目标）进程的优先级。Linux 中的 *setpriority()*
    权限规则与 SUSv3 不同，SUSv3 规定没有特权的进程可以更改另一个进程的优先级，只要其实际用户 ID 或有效用户 ID 与目标进程的有效用户 ID
    匹配。UNIX 的实现对此点有所不同。一些遵循 SUSv3 规则，而另一些，尤其是 BSD 系统，行为与 Linux 相同。
- en: Note
  id: totrans-38
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: In Linux kernels before 2.6.12, the permission rules for calls to *setpriority()*
    by unprivileged processes are different from later kernels (and also deviate from
    SUSv3). An unprivileged process can change the priority of another process if
    its real or effective user ID matches the real user ID of the target process.
    From Linux 2.6.12 onward, the permissions checks were changed to be consistent
    with other similar APIs available on Linux, such as *sched_setscheduler()* and
    *sched_setaffinity()*.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Linux 2.6.12 之前的内核中，无特权进程对 *setpriority()* 的调用权限规则与后来的内核不同（并且也与 SUSv3 偏离）。一个没有特权的进程可以更改另一个进程的优先级，只要其实际用户
    ID 与目标进程的实际用户 ID 匹配。从 Linux 2.6.12 开始，权限检查被修改为与 Linux 上其他类似的 API（如 *sched_setscheduler()*
    和 *sched_setaffinity()*）一致。
- en: In Linux kernels before 2.6.12, an unprivileged process may use *setpriority()*
    only to (irreversibly) lower its own or another process’s nice value. A privileged
    (`CAP_SYS_NICE`) process can use *setpriority()* to raise nice values.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Linux 2.6.12 之前的内核中，一个没有特权的进程只能使用 *setpriority()* 来（不可逆地）降低其自身或其他进程的 nice
    值。一个具有特权的（`CAP_SYS_NICE`）进程可以使用 *setpriority()* 来提高 nice 值。
- en: Since kernel 2.6.12, Linux provides the `RLIMIT_NICE` resource limit, which
    permits unprivileged processes to increase nice values. An unprivileged process
    can raise its own nice value to the maximum specified by the formula *20 - rlim_cur*,
    where *rlim_cur* is the current `RLIMIT_NICE` soft resource limit. As an example,
    if a process’s `RLIMIT_NICE` soft limit is 25, then its nice value can be raised
    to -5\. From this formula, and the knowledge that the nice value has the range
    +19 (low) to -20 (high), we can deduce that the effectively useful range of the
    `RLIMIT_NICE` limit is 1 (low) to 40 (high). (`RLIMIT_NICE` doesn’t use the number
    range +19 to -20 because some negative resource-limit values have special meanings—for
    example, `RLIM_INFINITY` has the same representation as -1.)
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 从内核版本 2.6.12 开始，Linux 提供了`RLIMIT_NICE`资源限制，允许无特权进程提高 nice 值。无特权进程可以将自己的 nice
    值提高到由公式*20 - rlim_cur*指定的最大值，其中*rlim_cur*是当前的`RLIMIT_NICE`软资源限制。例如，如果进程的`RLIMIT_NICE`软限制为
    25，则其 nice 值可以提高到 -5。从这个公式以及 nice 值的范围是+19（低）到-20（高）这一已知信息中，我们可以推断出`RLIMIT_NICE`限制的有效可用范围是
    1（低）到 40（高）。（`RLIMIT_NICE`不使用+19到-20的数字范围，因为一些负值资源限制有特殊含义——例如，`RLIM_INFINITY`与-1有相同的表示。）
- en: An unprivileged process can make a *setpriority()* call to change the nice value
    of another (target) process, if the effective user ID of the process calling *setpriority()*
    matches the real or effective user ID of the target process, and the change to
    the nice value is consistent with the target process’s `RLIMIT_NICE` limit.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 一个无特权进程可以调用*setpriority()*来改变另一个（目标）进程的 nice 值，前提是调用*setpriority()*的进程的有效用户
    ID 与目标进程的实际或有效用户 ID 匹配，并且对 nice 值的更改符合目标进程的`RLIMIT_NICE`限制。
- en: The program in [Example 35-1](ch35.html#modifying_and_retrieving_a_process_numbe
    "Example 35-1. Modifying and retrieving a process’s nice value") uses *setpriority()*
    to change the nice value of the process(es) specified by its command-line arguments
    (which correspond to the arguments of *setpriority()*), and then calls *getpriority()*
    to verify the change.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 35-1](ch35.html#modifying_and_retrieving_a_process_numbe "示例 35-1. 修改和检索进程的
    nice 值")中的程序使用*setpriority()*来改变通过命令行参数指定的进程的 nice 值（这些参数对应于*setpriority()*的参数），然后调用*getpriority()*来验证更改。'
- en: Example 35-1. Modifying and retrieving a process’s nice value
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 35-1. 修改和检索进程的 nice 值
- en: '[PRE2]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Overview of Realtime Process Scheduling
  id: totrans-46
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实时进程调度概述
- en: 'The standard kernel scheduling algorithm usually provides adequate performance
    and responsiveness for the mixture of interactive and background processes typically
    run on a system. However, realtime applications have more stringent requirements
    of a scheduler, including the following:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 标准的内核调度算法通常能为系统中运行的交互式和后台进程的混合提供足够的性能和响应能力。然而，实时应用程序对调度器有更严格的要求，主要包括以下几点：
- en: A realtime application must provide a guaranteed maximum response time for external
    inputs. In many cases, these guaranteed maximum response times must be quite small
    (e.g., of the order of a fraction of a second). For example, a slow response by
    a vehicle navigation system could be catastrophic. To satisfy this requirement,
    the kernel must provide the facility for a high-priority process to obtain control
    of the CPU in a timely fashion, preempting any process that may currently be running.
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实时应用程序必须为外部输入提供一个保证的最大响应时间。在许多情况下，这些保证的最大响应时间必须非常短（例如，达到几分之一秒的数量级）。例如，车辆导航系统的响应迟缓可能会导致灾难性后果。为了满足这一要求，内核必须提供一个机制，使高优先级进程能够及时获取
    CPU 控制权，抢占任何当前可能正在运行的进程。
- en: Note
  id: totrans-49
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'A time-critical application may need to take other steps to avoid unacceptable
    delays. For example, to avoid being delayed by a page fault, an application can
    lock all of its virtual memory into RAM using *mlock()* or *mlockall()* (described
    in [Memory Locking: *mlock()* and *mlockall()*](ch50.html#memory_locking_colon_mlock_open_parenthe
    "Memory Locking: mlock() and mlockall()")).'
  id: totrans-50
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 一个时间敏感的应用程序可能需要采取其他措施，以避免不可接受的延迟。例如，为了避免因页面错误导致的延迟，应用程序可以使用*mlock()*或*mlockall()*（在[内存锁定：*mlock()*和*mlockall()*](ch50.html#memory_locking_colon_mlock_open_parenthe
    "内存锁定：mlock()和mlockall()")中描述）将其所有虚拟内存锁定到 RAM 中。
- en: A high-priority process should be able to maintain exclusive access to the CPU
    until it completes or voluntarily relinquishes the CPU.
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 高优先级进程应能够保持对 CPU 的独占访问，直到它完成任务或自愿放弃 CPU。
- en: A realtime application should be able to control the precise order in which
    its component processes are scheduled.
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实时应用程序应该能够控制其各个组件进程的精确调度顺序。
- en: 'SUSv3 specifies a realtime process scheduling API (originally defined in POSIX.1b)
    that partly addresses these requirements. This API provides two realtime scheduling
    policies: `SCHED_RR` and `SCHED_FIFO`. Processes operating under either of these
    policies always have priority over processes scheduled using the standard round-robin
    time-sharing policy described in [Process Priorities (Nice Values)](ch35.html#process_priorities_open_parenthesis_nice
    "Process Priorities (Nice Values)"), which the realtime scheduling API identifies
    using the constant `SCHED_OTHER`.'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: SUSv3 指定了一个实时进程调度 API（最初定义于 POSIX.1b），该 API 部分地解决了这些需求。该 API 提供了两种实时调度策略：`SCHED_RR`
    和 `SCHED_FIFO`。运行在这两种策略下的进程总是优先于使用标准轮转时间共享策略（在[进程优先级（Nice 值）](ch35.html#process_priorities_open_parenthesis_nice
    "Process Priorities (Nice Values)")中描述的）调度的进程，这些进程的调度策略被实时调度 API 识别为常量 `SCHED_OTHER`。
- en: Each of the realtime policies allows for a range of priority levels. SUSv3 requires
    that an implementation provide at least 32 discrete priorities for the realtime
    policies. In each scheduling policy, runnable processes with higher priority always
    have precedence over lower-priority processes when seeking access to the CPU.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 每种实时策略都允许一系列的优先级级别。SUSv3 要求实现至少提供 32 个离散的实时优先级。在每个调度策略中，具有更高优先级的可运行进程总是优先于较低优先级的进程获取
    CPU 访问权限。
- en: Note
  id: totrans-55
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The statement that runnable processes with higher priority always have precedence
    over lower-priority processes needs to be qualified for multiprocessor Linux systems
    (including hyperthreaded systems). On a multiprocessor system, each CPU has a
    separate run queue (this provides better performance than a single system-wide
    run queue), and processes are prioritized only per CPU run queue. For example,
    on a dual-processor system with three processes, process A with realtime priority
    20 could be queued waiting for CPU 0, which is currently running process B with
    priority 30, even though CPU 1 is running process C with a priority of 10.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 需要对“具有更高优先级的可运行进程总是优先于较低优先级进程”这一说法进行修正，特别是对于多处理器 Linux 系统（包括超线程系统）。在多处理器系统中，每个
    CPU 都有一个独立的运行队列（这比单一的系统级全局队列能提供更好的性能），进程的优先级仅在每个 CPU 的运行队列内起作用。例如，在一个双处理器系统上，有三个进程，进程
    A（实时优先级 20）可能会在 CPU 0 上排队，等待执行，尽管此时 CPU 0 正在运行优先级为 30 的进程 B，而 CPU 1 正在运行优先级为 10
    的进程 C。
- en: Realtime applications that employ multiple processes (or threads) can use the
    CPU affinity API described in [CPU Affinity](ch35.html#cpu_affinity "CPU Affinity")
    to avoid any problems that might result from this scheduling behavior. For example,
    on a four-processor system, all noncritical processes could be isolated onto a
    single CPU, leaving the other three CPUs available for use by the application.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 使用多个进程（或线程）的实时应用程序可以使用在[CPU 亲和性](ch35.html#cpu_affinity "CPU Affinity")中描述的
    CPU 亲和性 API，以避免因调度行为可能导致的问题。例如，在一个四处理器系统中，所有非关键进程可以被隔离到单个 CPU 上，剩余的三个 CPU 可供应用程序使用。
- en: Linux provides 99 realtime priority levels, numbered 1 (lowest) to 99 (highest),
    and this range applies in both realtime scheduling policies. The priorities in
    each policy are equivalent. This means that, given two processes with the same
    priority, one operating under the `SCHED_RR` policy and the other under `SCHED_FIFO`,
    either may be the next one eligible for execution, depending on the order in which
    they were scheduled. In effect, each priority level maintains a queue of runnable
    processes, and the next process to run is selected from the front of the highest-priority
    nonempty queue.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: Linux 提供了 99 个实时优先级，从 1（最低）到 99（最高），这一范围适用于两种实时调度策略。在每种策略中的优先级是等价的。这意味着，假设有两个优先级相同的进程，一个运行在
    `SCHED_RR` 策略下，另一个运行在 `SCHED_FIFO` 策略下，哪个进程将成为下一个可执行进程，取决于它们的调度顺序。实际上，每个优先级级别都维护着一个可运行进程的队列，下一步执行的进程从最高优先级且非空队列的前端选出。
- en: POSIX realtime versus hard realtime
  id: totrans-59
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: POSIX 实时与硬实时
- en: Applications with all of the requirements listed at the start of this section
    are sometimes referred to as *hard* realtime applications. However, the POSIX
    realtime process scheduling API doesn’t satisfy all of these requirements. In
    particular, it provides no way for an application to guarantee response times
    for handling input. To make such guarantees requires operating system features
    that are not part of the mainline Linux kernel (nor most other standard operating
    systems). The POSIX API merely provides us with so-called *soft* realtime, allowing
    us to control which processes are scheduled for use of the CPU.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 开头列出的所有要求都符合的应用程序有时被称为*硬*实时应用程序。然而，POSIX实时进程调度API并不能满足所有这些要求。特别是，它没有为应用程序提供保证输入处理响应时间的方法。要实现这样的保证，需要操作系统具备一些并非Linux主线内核（或大多数其他标准操作系统）的一部分的特性。POSIX
    API仅提供了所谓的*软*实时功能，使我们能够控制哪些进程被调度使用CPU。
- en: Adding support for hard realtime applications is difficult to achieve without
    imposing an overhead on the system that conflicts with the performance requirements
    of the time-sharing applications that form the majority of applications on typical
    desktop and server systems. This is why most UNIX kernels—including, historically,
    Linux—have not natively supported realtime applications. Nevertheless, starting
    from around version 2.6.18, various features have been added to the Linux kernel
    with the eventual aim of allowing Linux to natively provide full support for hard
    realtime applications, without imposing the aforementioned overhead for time-sharing
    operation.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 为硬实时应用程序提供支持是困难的，因为这会在不影响典型桌面和服务器系统上大多数应用程序的时间共享性能要求的情况下，给系统带来额外的开销。这也是为什么大多数UNIX内核——包括历史上的Linux——并没有原生支持实时应用程序。然而，从大约2.6.18版本开始，Linux内核加入了多项特性，最终目标是使Linux原生支持硬实时应用程序，而不会给时间共享操作带来上述开销。
- en: The `SCHED_RR` Policy
  id: totrans-62
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`SCHED_RR`策略'
- en: 'Under the `SCHED_RR` (round-robin) policy, processes of equal priority are
    executed in a round-robin time-sharing fashion. A process receives a fixed-length
    time slice each time it uses the CPU. Once scheduled, a process employing the
    `SCHED_RR` policy maintains control of the CPU until either:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在`SCHED_RR`（轮转调度）策略下，具有相同优先级的进程按照轮转时间共享的方式执行。每次进程使用CPU时，都会获得一个固定长度的时间片。一旦被调度，采用`SCHED_RR`策略的进程将保持对CPU的控制，直到以下情况之一发生：
- en: it reaches the end of its time slice;
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它达到了时间片的末尾；
- en: it voluntarily relinquishes the CPU, either by performing a blocking system
    call or by calling the *sched_yield()* system call (described in [Relinquishing
    the CPU](ch35.html#relinquishing_the_cpu "Relinquishing the CPU"));
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它主动放弃CPU，可能是通过执行一个阻塞系统调用或调用*sched_yield()*系统调用（详见[放弃CPU](ch35.html#relinquishing_the_cpu
    "Relinquishing the CPU")）；
- en: it terminates; or
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它终止；或者
- en: it is preempted by a higher-priority process.
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它被一个更高优先级的进程抢占。
- en: For the first two events above, when a process running under the `SCHED_RR`
    policy loses access to the CPU, it is placed at the back of the queue for its
    priority level. In the final case, when the higher-priority process has ceased
    execution, the preempted process continues execution, consuming the remainder
    of its time slice (i.e., the preempted process remains at the head of the queue
    for its priority level).
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 对于上述前两个事件，当在`SCHED_RR`策略下运行的进程失去对CPU的访问时，它将被放置在其优先级级别的队列末尾。在最后一种情况下，当更高优先级的进程停止执行时，被抢占的进程将继续执行，消耗其剩余的时间片（即，被抢占的进程仍然位于其优先级级别队列的前端）。
- en: 'In both the `SCHED_RR` and the `SCHED_FIFO` policies, the currently running
    process may be preempted for one of the following reasons:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在`SCHED_RR`和`SCHED_FIFO`策略中，当前运行的进程可能会因以下原因之一被抢占：
- en: a higher-priority process that was blocked became unblocked (e.g., an I/O operation
    on which it was waiting completed);
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个被阻塞的高优先级进程变得不再阻塞（例如，等待的I/O操作完成）；
- en: the priority of another process was raised to a higher level than the currently
    running process; or
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 另一个进程的优先级被提升到比当前运行进程更高的水平；或者
- en: the priority of the currently running process was decreased to a lower value
    than that of some other runnable process.
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当前运行进程的优先级被降低到比其他可运行进程更低的值。
- en: The `SCHED_RR` policy is similar to the standard round-robin time-sharing scheduling
    algorithm (`SCHED_OTHER`), in that it allows a group of processes with the same
    priority to share access to the CPU. The most notable difference is the existence
    of strictly distinct priority levels, with higher-priority processes always taking
    precedence over lower-priority processes. By contrast, a low nice value (i.e.,
    high priority) doesn’t give a process exclusive access to the CPU; it merely gives
    the process a favorable weighting in scheduling decisions. As noted in [Process
    Priorities (Nice Values)](ch35.html#process_priorities_open_parenthesis_nice "Process
    Priorities (Nice Values)"), a process with a low priority (i.e., high nice value)
    always receives at least some CPU time. The other important difference is that
    the `SCHED_RR` policy allows us to precisely control the order in which processes
    are scheduled.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '`SCHED_RR` 策略类似于标准的轮询时间分片调度算法（`SCHED_OTHER`），允许一组具有相同优先级的进程共享 CPU 访问权限。最显著的区别是存在严格区分的优先级级别，高优先级的进程总是优先于低优先级的进程。相比之下，较低的
    nice 值（即高优先级）并不会赋予进程独占 CPU 的权限；它仅仅是在调度决策中赋予进程一个有利的权重。如在[进程优先级（Nice 值）](ch35.html#process_priorities_open_parenthesis_nice
    "进程优先级（Nice 值）")中所述，低优先级的进程（即高 nice 值）始终会获得至少一些 CPU 时间。另一个重要的区别是，`SCHED_RR` 策略允许我们精确控制进程调度的顺序。'
- en: The `SCHED_FIFO` Policy
  id: totrans-74
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`SCHED_FIFO` 策略'
- en: 'The `SCHED_FIFO` (first-in, first-out) policy is similar to the `SCHED_RR`
    policy. The major difference is that there is no time slice. Once a `SCHED_FIFO`
    process gains access to the CPU, it executes until either:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '`SCHED_FIFO`（先进先出）策略类似于 `SCHED_RR` 策略。主要区别在于没有时间片。一旦 `SCHED_FIFO` 进程获得 CPU
    访问权限，它会一直执行，直到以下任一情况发生：'
- en: it voluntarily relinquishes the CPU (in the same manner as described for the
    `SCHED_FIFO` policy above);
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它会自愿释放 CPU（与上述 `SCHED_FIFO` 策略中的描述相同）；
- en: it terminates; or
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它终止；或者
- en: it is preempted by a higher-priority process (in the same circumstances as described
    for the `SCHED_FIFO` policy above).
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它被一个更高优先级的进程抢占（与上述 `SCHED_FIFO` 策略描述的情况相同）。
- en: In the first case, the process is placed at the back of the queue for its priority
    level. In the last case, when the higher-priority process has ceased execution
    (by blocking or terminating), the preempted process continues execution (i.e.,
    the preempted process remains at the head of the queue for its priority level).
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一种情况下，进程会被放置在其优先级级别队列的末尾。在最后一种情况下，当高优先级进程停止执行（通过阻塞或终止）时，抢占的进程继续执行（即抢占的进程仍然保持在其优先级级别队列的头部）。
- en: The `SCHED_BATCH` and `SCHED_IDLE` Policies
  id: totrans-80
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`SCHED_BATCH` 和 `SCHED_IDLE` 策略'
- en: 'The Linux 2.6 kernel series added two nonstandard scheduling policies: `SCHED_BATCH`
    and `SCHED_IDLE`. Although these policies are set via the POSIX realtime scheduling
    API, they are not actually realtime policies.'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: Linux 2.6 内核系列新增了两种非标准的调度策略：`SCHED_BATCH` 和 `SCHED_IDLE`。尽管这些策略是通过 POSIX 实时调度
    API 设置的，但它们实际上并不是实时策略。
- en: The `SCHED_BATCH` policy, added in kernel 2.6.16, is similar to the default
    `SCHED_OTHER` policy. The difference is that the `SCHED_BATCH` policy causes jobs
    that frequently wake up to be scheduled less often. This policy is intended for
    batch-style execution of processes.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '`SCHED_BATCH` 策略是在内核 2.6.16 中新增的，它与默认的 `SCHED_OTHER` 策略类似。区别在于，`SCHED_BATCH`
    策略会使那些频繁唤醒的任务被调度得更少。这种策略适用于批处理风格的进程执行。'
- en: The `SCHED_IDLE` policy, added in kernel 2.6.23, is also similar to `SCHED_OTHER`,
    but provides functionality equivalent to a very low nice value (i.e., lower than
    +19). The process nice value has no meaning for this policy. It is intended for
    running low-priority jobs that will receive a significant proportion of the CPU
    only if no other job on the system requires the CPU.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '`SCHED_IDLE` 策略是在内核 2.6.23 中新增的，它也类似于 `SCHED_OTHER`，但提供了相当于非常低 nice 值（即低于 +19）的功能。此策略下，进程的
    nice 值没有意义。它用于运行低优先级任务，这些任务只有在系统中没有其他任务需要 CPU 时，才会获得 CPU 的大部分时间。'
- en: Realtime Process Scheduling API
  id: totrans-84
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实时进程调度 API
- en: We now look at the various system calls constituting the realtime process scheduling
    API. These system calls allow us to control process scheduling policies and priorities.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在来看看构成实时进程调度 API 的各种系统调用。这些系统调用允许我们控制进程的调度策略和优先级。
- en: Note
  id: totrans-86
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Although realtime scheduling has been a part of Linux since version 2.0 of the
    kernel, several problems persisted for a long time in the implementation. A number
    of features of the implementation remained broken in the 2.2 kernel, and even
    in early 2.4 kernels. Most of these problems were rectified by about kernel 2.4.20.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管实时调度自 Linux 内核 2.0 版本起就已成为其一部分，但该实现中存在的多个问题在很长一段时间内未能解决。许多实现中的特性在 2.2 内核中存在缺陷，甚至在早期的
    2.4 内核中也未得到修复。大多数问题在大约内核 2.4.20 版本时得到纠正。
- en: Realtime Priority Ranges
  id: totrans-88
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 实时优先级范围
- en: The *sched_get_priority_min()* and *sched_get_priority_max()* system calls return
    the available priority range for a scheduling policy.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '*sched_get_priority_min()* 和 *sched_get_priority_max()* 系统调用返回可用的调度策略优先级范围。'
- en: '[PRE3]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Note
  id: totrans-91
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Both return nonnegative integer priority on success, or -1 on error
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 成功时返回非负整数优先级，错误时返回 -1
- en: For both system calls, *policy* specifies the scheduling policy about which
    we wish to obtain information. For this argument, we specify either `SCHED_RR`
    or `SCHED_FIFO`. The *sched_get_priority_min()* system call returns the minimum
    priority for the specified policy, and *sched_get_priority_max()* returns the
    maximum priority. On Linux, these system calls return the numbers 1 and 99, respectively,
    for both the `SCHED_RR` and `SCHED_FIFO` policies. In other words, the priority
    ranges of the two realtime policies completely coincide, and `SCHED_RR` and `SCHED_FIFO`
    processes with the same priority are equally eligible for scheduling. (Which one
    is scheduled first depends on their order in the queue for that priority level.)
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这两个系统调用，*policy* 指定我们希望获取信息的调度策略。对于此参数，我们指定 `SCHED_RR` 或 `SCHED_FIFO`。*sched_get_priority_min()*
    系统调用返回指定策略的最小优先级，而 *sched_get_priority_max()* 返回最大优先级。在 Linux 中，这些系统调用分别为 `SCHED_RR`
    和 `SCHED_FIFO` 策略返回 1 和 99。换句话说，这两种实时策略的优先级范围完全重合，具有相同优先级的 `SCHED_RR` 和 `SCHED_FIFO`
    进程在调度时的资格相同。（首先被调度的进程取决于它们在该优先级级别队列中的顺序。）
- en: The range of realtime priorities differs from one UNIX implementation to another.
    Therefore, instead of hard-coding priority values into an application, we should
    specify priorities relative to the return value from one of these functions. Thus,
    the lowest `SCHED_RR` priority would be specified as *sched_get_priority_min(SCHED_FIFO)*,
    the next higher priority as *sched_get_priority_min(SCHED_FIFO) + 1*, and so on.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 实时优先级的范围在不同的 UNIX 实现之间有所不同。因此，我们不应将优先级值硬编码到应用程序中，而应根据这些函数的返回值来指定优先级。比如，最低的 `SCHED_RR`
    优先级应指定为 *sched_get_priority_min(SCHED_FIFO)*，下一个更高的优先级指定为 *sched_get_priority_min(SCHED_FIFO)
    + 1*，依此类推。
- en: Note
  id: totrans-95
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: SUSv3 doesn’t require that the `SCHED_RR` and `SCHED_FIFO` policies use the
    same priority ranges, but they do so on most UNIX implementations. For example,
    on Solaris 8, the priority range for both policies is 0 to 59, and on FreeBSD
    6.1, it is 0 to 31.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: SUSv3 并未要求 `SCHED_RR` 和 `SCHED_FIFO` 策略使用相同的优先级范围，但大多数 UNIX 实现采用相同的范围。例如，在 Solaris
    8 中，两个策略的优先级范围是 0 到 59，而在 FreeBSD 6.1 中则是 0 到 31。
- en: Modifying and Retrieving Policies and Priorities
  id: totrans-97
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 修改和检索策略与优先级
- en: In this section, we look at the system calls that modify and retrieve scheduling
    policies and priorities.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 本节我们将讨论修改和检索调度策略与优先级的系统调用。
- en: Modifying scheduling policies and priorities
  id: totrans-99
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 修改调度策略和优先级
- en: The *sched_setscheduler()* system call changes both the scheduling policy and
    the priority of the process whose process ID is specified in *pid*. If *pid* is
    specified as 0, the attributes of the calling process are changed.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '*sched_setscheduler()* 系统调用更改指定进程 ID 为 *pid* 的进程的调度策略和优先级。如果 *pid* 被指定为 0，则更改调用进程的属性。'
- en: '[PRE4]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Note
  id: totrans-102
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Returns 0 on success, or -1 on error
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 成功时返回 0，错误时返回 -1
- en: 'The *param* argument is a pointer to a structure of the following form:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '*param* 参数是指向以下形式结构体的指针：'
- en: '[PRE5]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: SUSv3 defines the *param* argument as a structure to allow an implementation
    to include additional implementation-specific fields, which may be useful if an
    implementation provides additional scheduling policies. However, like most UNIX
    implementations, Linux provides just the *sched_priority* field, which specifies
    the scheduling priority. For the `SCHED_RR` and `SCHED_FIFO` policies, this must
    be a value in the range indicated by *sched_get_priority_min()* and *sched_get_priority_max()*;
    for other policies, the priority must be 0.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: SUSv3 定义了 *param* 参数为一个结构，允许实现包含额外的特定实现字段，这在实现提供额外调度策略时可能很有用。然而，像大多数 UNIX 实现一样，Linux
    仅提供 *sched_priority* 字段，用于指定调度优先级。对于 `SCHED_RR` 和 `SCHED_FIFO` 策略，该值必须在 *sched_get_priority_min()*
    和 *sched_get_priority_max()* 指定的范围内；对于其他策略，优先级必须为 0。
- en: The *policy* argument determines the scheduling policy for the process. It is
    specified as one of the policies shown in [Table 35-1](ch35.html#linux_realtime_and_nonrealtime_schedulin
    "Table 35-1. Linux realtime and nonrealtime scheduling policies").
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '*policy* 参数决定了进程的调度策略。它作为 [表 35-1](ch35.html#linux_realtime_and_nonrealtime_schedulin
    "表 35-1. Linux 实时和非实时调度策略") 中显示的策略之一来指定。'
- en: Table 35-1. Linux realtime and nonrealtime scheduling policies
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 表 35-1. Linux 实时和非实时调度策略
- en: '| Policy | Description | SUSv3 |'
  id: totrans-109
  prefs: []
  type: TYPE_TB
  zh: '| 策略 | 描述 | SUSv3 |'
- en: '| --- | --- | --- |'
  id: totrans-110
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| `SCHED_FIFO` | Realtime first-in first-out | • |'
  id: totrans-111
  prefs: []
  type: TYPE_TB
  zh: '| `SCHED_FIFO` | 实时先到先服务 | • |'
- en: '| `SCHED_RR` | Realtime round-robin | • |'
  id: totrans-112
  prefs: []
  type: TYPE_TB
  zh: '| `SCHED_RR` | 实时轮转调度 | • |'
- en: '| `SCHED_OTHER` | Standard round-robin time-sharing | • |'
  id: totrans-113
  prefs: []
  type: TYPE_TB
  zh: '| `SCHED_OTHER` | 标准轮转时间共享 | • |'
- en: '| `SCHED_BATCH` | Similar to `SCHED_OTHER`, but intended for batch execution
    (since Linux 2.6.16) |   |'
  id: totrans-114
  prefs: []
  type: TYPE_TB
  zh: '| `SCHED_BATCH` | 类似于 `SCHED_OTHER`，但用于批处理执行（自 Linux 2.6.16 起） |   |'
- en: '| `SCHED_IDLE` | Similar to `SCHED_OTHER`, but with priority even lower than
    nice value +19 (since Linux 2.6.23) |   |'
  id: totrans-115
  prefs: []
  type: TYPE_TB
  zh: '| `SCHED_IDLE` | 类似于 `SCHED_OTHER`，但优先级比 nice 值 +19 还低（自 Linux 2.6.23 起） |
      |'
- en: A successful *sched_setscheduler()* call moves the process specified by *pid*
    to the back of the queue for its priority level.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 成功的 *sched_setscheduler()* 调用会将由 *pid* 指定的进程移至其优先级级别队列的末尾。
- en: SUSv3 specifies that the return value of a successful *sched_setscheduler()*
    call should be the previous scheduling policy. However, Linux deviates from the
    standard in that a successful call returns 0\. A portable application should test
    for success by checking that the return status is not -1.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: SUSv3 指定成功的 *sched_setscheduler()* 调用的返回值应为之前的调度策略。然而，Linux 偏离了标准，成功的调用返回 0。便携式应用程序应该通过检查返回状态不是
    -1 来测试成功。
- en: The scheduling policy and priority are inherited by a child created via *fork()*,
    and they are preserved across an *exec()*.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 调度策略和优先级会被通过 *fork()* 创建的子进程继承，并且会在 *exec()* 调用中保持不变。
- en: The *sched_setparam()* system call provides a subset of the functionality of
    *sched_setscheduler()*. It modifies the scheduling priority of a process while
    leaving the policy unchanged.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '*sched_setparam()* 系统调用提供了 *sched_setscheduler()* 功能的一个子集。它修改进程的调度优先级，而不改变调度策略。'
- en: '[PRE6]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Note
  id: totrans-121
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Returns 0 on success, or -1 on error
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 成功时返回 0，出错时返回 -1
- en: The *pid* and *param* arguments are the same as for *sched_setscheduler()*.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '*pid* 和 *param* 参数与 *sched_setscheduler()* 中相同。'
- en: A successful *sched_setparam()* call moves the process specified by *pid* to
    the back of the queue for its priority level.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 成功的 *sched_setparam()* 调用会将由 *pid* 指定的进程移至其优先级级别队列的末尾。
- en: The program in [Example 35-2](ch35.html#modifying_process_scheduling_policies_an
    "Example 35-2. Modifying process scheduling policies and priorities") uses *sched_setscheduler()*
    to set the policy and priority of the processes specified by its command-line
    arguments. The first argument is a letter specifying a scheduling policy, the
    second is an integer priority, and the remaining arguments are the process IDs
    of the processes whose scheduling attributes are to be changed.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 35-2](ch35.html#modifying_process_scheduling_policies_an "示例 35-2. 修改进程调度策略和优先级")
    中的程序使用 *sched_setscheduler()* 来设置通过命令行参数指定的进程的策略和优先级。第一个参数是一个字母，指定调度策略，第二个参数是整数优先级，剩余的参数是要更改调度属性的进程
    ID。'
- en: Example 35-2. Modifying process scheduling policies and priorities
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 35-2. 修改进程调度策略和优先级
- en: '[PRE7]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Privileges and resource limits affecting changes to scheduling parameters
  id: totrans-128
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 影响调度参数更改的权限和资源限制
- en: In kernels before 2.6.12, a process generally must be privileged (`CAP_SYS_NICE`)
    to make changes to scheduling policies and priorities. The one exception to this
    requirement is that an unprivileged process can change the scheduling policy of
    a process to `SCHED_OTHER` if the effective user ID of the caller matches either
    the real or effective user ID of the target process.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 在 2.6.12 之前的内核中，进程通常必须具有特权（`CAP_SYS_NICE`）才能更改调度策略和优先级。唯一的例外是，如果调用者的有效用户 ID
    与目标进程的实际或有效用户 ID 匹配，则无特权的进程可以将进程的调度策略更改为 `SCHED_OTHER`。
- en: 'Since kernel 2.6.12, the rules about setting realtime scheduling policies and
    priorities have changed with the introduction of a new, nonstandard resource limit,
    `RLIMIT_RTPRIO`. As with older kernels, privileged (`CAP_SYS_NICE`) processes
    can make arbitrary changes to the scheduling policy and priority of any process.
    However, an unprivileged process can also change scheduling policies and priorities,
    according to the following rules:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 自内核版本 2.6.12 起，设置实时调度策略和优先级的规则发生了变化，新增了一个非标准资源限制 `RLIMIT_RTPRIO`。与较早版本的内核一样，特权进程（`CAP_SYS_NICE`）可以对任何进程的调度策略和优先级进行任意更改。然而，无特权进程也可以根据以下规则更改调度策略和优先级：
- en: If the process has a nonzero `RLIMIT_RTPRIO` soft limit, then it can make arbitrary
    changes to its scheduling policy and priority, subject to the constraint that
    the upper limit on the realtime priority that it may set is the maximum of its
    current realtime priority (if the process is currently operating under a realtime
    policy) and the value of its `RLIMIT_RTPRIO` soft limit.
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果进程的 `RLIMIT_RTPRIO` 软限制非零，那么它可以对其调度策略和优先级进行任意更改，但前提是它可以设置的实时优先级上限为其当前实时优先级（如果进程当前使用实时策略）和
    `RLIMIT_RTPRIO` 软限制的最大值。
- en: If the value of a process’s `RLIMIT_RTPRIO` soft limit is 0, then the only change
    that it can make is to lower its realtime scheduling priority or to switch from
    a realtime policy to a nonrealtime policy.
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果进程的 `RLIMIT_RTPRIO` 软限制值为 0，那么它能进行的唯一更改是降低其实时调度优先级或从实时策略切换到非实时策略。
- en: The `SCHED_IDLE` policy is special. A process that is operating under this policy
    can’t make any changes to its policy, regardless of the value of the `RLIMIT_RTPRIO`
    resource limit.
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SCHED_IDLE` 策略是特殊的。正在使用该策略的进程无法对其策略进行任何更改，无论 `RLIMIT_RTPRIO` 资源限制的值如何。'
- en: Policy and priority changes can also be performed from another unprivileged
    process, as long as the effective user ID of that process matches either the real
    or effective user ID of the target process.
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 策略和优先级的更改也可以由另一个无特权进程执行，只要该进程的有效用户 ID 与目标进程的实际或有效用户 ID 匹配。
- en: A process’s soft `RLIMIT_RTPRIO` limit determines only what changes can be made
    to its own scheduling policy and priority, either by the process itself or by
    another unprivileged process. A nonzero limit doesn’t give an unprivileged process
    the ability to change the scheduling policy and priority of other processes.
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 进程的软 `RLIMIT_RTPRIO` 限制仅决定该进程自身的调度策略和优先级可以进行哪些更改，无论是由该进程自身还是由其他无特权进程进行。非零限制不会赋予无特权进程更改其他进程调度策略和优先级的能力。
- en: Note
  id: totrans-136
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Starting with kernel 2.6.25, Linux adds the concept of realtime scheduling groups,
    configurable via the `CONFIG_RT_GROUP_SCHED` kernel option, which also affect
    the changes that can be made when setting realtime scheduling policies. See the
    kernel source file `Documentation/scheduler/sched-rt-group.txt` for details.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 从内核版本 2.6.25 开始，Linux 引入了实时调度组的概念，可以通过 `CONFIG_RT_GROUP_SCHED` 内核选项进行配置，该选项还会影响设置实时调度策略时可以进行的更改。详情请参见内核源文件
    `Documentation/scheduler/sched-rt-group.txt`。
- en: Retrieving scheduling policies and priorities
  id: totrans-138
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 检索调度策略和优先级
- en: The *sched_getscheduler()* and *sched_getparam()* system calls retrieve the
    scheduling policy and priority of a process.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '*sched_getscheduler()* 和 *sched_getparam()* 系统调用用于检索进程的调度策略和优先级。'
- en: '[PRE8]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Note
  id: totrans-141
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Returns scheduling policy, or -1 on error
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 返回调度策略，出错时返回 -1
- en: '[PRE9]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Note
  id: totrans-144
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Returns 0 on success, or -1 on error
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 成功时返回 0，出错时返回 -1
- en: For both of these system calls, *pid* specifies the ID of the process about
    which information is to be retrieved. If *pid* is 0, information is retrieved
    about the calling process. Both system calls can be used by an unprivileged process
    to retrieve information about any process, regardless of credentials.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这两个系统调用，*pid* 参数指定要检索信息的进程 ID。如果 *pid* 为 0，则检索调用进程的信息。这两个系统调用都可以被无特权进程用来检索任何进程的信息，无论其凭证如何。
- en: The *sched_getparam()* system call returns the realtime priority of the specified
    process in the *sched_priority* field of the *sched_param* structure pointed to
    by *param*.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '*sched_getparam()*系统调用返回指定进程的实时优先级，该优先级存储在*sched_param*结构体的*sched_priority*字段中，*param*指向该结构体。'
- en: Upon successful execution, *sched_getscheduler()* returns one of the policies
    shown earlier in [Table 35-1](ch35.html#linux_realtime_and_nonrealtime_schedulin
    "Table 35-1. Linux realtime and nonrealtime scheduling policies").
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 在成功执行后，*sched_getscheduler()*会返回[表35-1](ch35.html#linux_realtime_and_nonrealtime_schedulin
    "表35-1. Linux实时和非实时调度策略")中显示的策略之一。
- en: 'The program in [Example 35-3](ch35.html#retrieving_process_scheduling_policies_a
    "Example 35-3. Retrieving process scheduling policies and priorities") uses *sched_getscheduler()*
    and *sched_getparam()* to retrieve the policy and priority of all of the processes
    whose process IDs are given as command-line arguments. The following shell session
    demonstrates the use of this program, as well as the program in [Example 35-2](ch35.html#modifying_process_scheduling_policies_an
    "Example 35-2. Modifying process scheduling policies and priorities"):'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例35-3](ch35.html#retrieving_process_scheduling_policies_a "示例35-3. 检索进程调度策略和优先级")中的程序使用*sched_getscheduler()*和*sched_getparam()*来检索所有通过命令行参数给定的进程ID的策略和优先级。以下的shell会话演示了如何使用该程序，以及[示例35-2](ch35.html#modifying_process_scheduling_policies_an
    "示例35-2. 修改进程调度策略和优先级")中的程序：'
- en: '[PRE10]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Example 35-3. Retrieving process scheduling policies and priorities
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 示例35-3. 检索进程调度策略和优先级
- en: '[PRE11]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Preventing realtime processes from locking up the system
  id: totrans-153
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 防止实时进程锁死系统
- en: 'Since `SCHED_RR` and `SCHED_FIFO` processes preempt any lower-priority processes
    (e.g., the shell under which the program is run), when developing applications
    that use these policies, we need to be aware of the possibility that a runaway
    realtime process could lock up the system by hogging the CPU. Programmatically,
    there are a few of ways to avoid this possibility:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`SCHED_RR`和`SCHED_FIFO`进程会抢占任何低优先级的进程（例如，运行程序的shell），因此在开发使用这些策略的应用程序时，我们需要意识到一个可能性：一个失控的实时进程可能会通过占用CPU锁死系统。从编程角度来看，有几种方法可以避免这种情况：
- en: Establish a suitably low soft CPU time resource limit (`RLIMIT_CPU`, described
    in [Details of Specific Resource Limits](ch36.html#details_of_specific_resource_limits
    "Details of Specific Resource Limits")) using *setrlimit()*. If the process consumes
    too much CPU time, it will be sent a `SIGXCPU` signal, which kills the process
    by default.
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用*setrlimit()*设置一个适当低的软CPU时间资源限制（`RLIMIT_CPU`，详见[具体资源限制的详细信息](ch36.html#details_of_specific_resource_limits
    "具体资源限制的详细信息")）。如果进程消耗了过多的CPU时间，它将收到一个`SIGXCPU`信号，默认情况下会终止该进程。
- en: Set an alarm timer using *alarm()*. If the process continues running for a wall
    clock time that exceeds the number of seconds specified in the *alarm()* call,
    then it will be killed by a `SIGALRM` signal.
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用*alarm()*设置一个定时器。如果进程继续运行超过*alarm()*调用中指定的秒数，那么它将被`SIGALRM`信号终止。
- en: Create a watchdog process that runs with a high realtime priority. This process
    can loop repeatedly, sleeping for a specified interval, and then waking and monitoring
    the status of other processes. Such monitoring could include measuring the value
    of the CPU time clock for each process (see the discussion of the *clock_getcpuclockid()*
    function in [Obtaining the Clock ID of a Specific Process or Thread](ch23.html#obtaining_the_clock_id_of_a_specific_pro
    "Obtaining the Clock ID of a Specific Process or Thread")) and checking its scheduling
    policy and priority using *sched_getscheduler()* and *sched_getparam()*. If a
    process is deemed to be misbehaving, the watchdog thread could lower the process’s
    priority, or stop or terminate it by sending an appropriate signal.
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个以高实时优先级运行的看门狗进程。该进程可以反复循环，每次睡眠一段时间，然后唤醒并监控其他进程的状态。此类监控可能包括测量每个进程的CPU时间时钟值（请参见[获取特定进程或线程的时钟ID](ch23.html#obtaining_the_clock_id_of_a_specific_pro
    "获取特定进程或线程的时钟ID")）并使用*sched_getscheduler()*和*sched_getparam()*检查其调度策略和优先级。如果一个进程被认为行为不当，看门狗线程可以降低该进程的优先级，或通过发送适当的信号来停止或终止它。
- en: Since kernel 2.6.25, Linux provides a nonstandard resource limit, `RLIMIT_RTTIME`,
    for controlling the amount of CPU time that can be consumed in a single burst
    by a process running under a realtime scheduling policy. Specified in microseconds,
    `RLIMIT_RTTIME` limits the amount of CPU time that the process may consume without
    performing a system call that blocks. When the process does perform such a call,
    the count of consumed CPU time is reset to 0\. The count of consumed CPU time
    is not reset if the process is preempted by a higher-priority process, is scheduled
    off the CPU because its time slice expired (for a `SCHED_RR` process), or calls
    *sched_yield()* ([Relinquishing the CPU](ch35.html#relinquishing_the_cpu "Relinquishing
    the CPU")). If the process reaches its limit of CPU time, then, as with `RLIMIT_CPU`,
    it will be sent a `SIGXCPU` signal, which kills the process by default.
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从内核 2.6.25 开始，Linux 提供了一个非标准的资源限制 `RLIMIT_RTTIME`，用于控制在实时调度策略下，进程在单次突发中可以消耗的
    CPU 时间。`RLIMIT_RTTIME` 以微秒为单位，限制进程在不进行阻塞系统调用的情况下可以消耗的 CPU 时间。当进程执行此类系统调用时，已消耗的
    CPU 时间会被重置为 0。如果进程被更高优先级的进程抢占，或由于时间片耗尽（对于 `SCHED_RR` 进程）被调度离开 CPU，或调用了 *sched_yield()*，已消耗的
    CPU 时间计数不会被重置（[放弃 CPU](ch35.html#relinquishing_the_cpu "放弃 CPU")）。如果进程达到了其 CPU
    时间限制，那么与 `RLIMIT_CPU` 类似，它会收到一个 `SIGXCPU` 信号，默认情况下会终止该进程。
- en: Note
  id: totrans-159
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The changes in kernel 2.6.25 can also help prevent runaway realtime processes
    from locking up the system. For details, see the kernel source file `Documentation/scheduler/sched-rt-group.txt`.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 内核 2.6.25 中的更改也有助于防止实时进程因占用过多 CPU 时间而导致系统死锁。详细信息，请参阅内核源文件 `Documentation/scheduler/sched-rt-group.txt`。
- en: Preventing child processes from inheriting privileged scheduling policies
  id: totrans-161
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 防止子进程继承特权调度策略
- en: 'Linux 2.6.32 added `SCHED_RESET_ON_FORK` as a value that can be specified in
    *policy* when calling *sched_setscheduler()*. This is a flag value that is ORed
    with one of the policies in [Table 35-1](ch35.html#linux_realtime_and_nonrealtime_schedulin
    "Table 35-1. Linux realtime and nonrealtime scheduling policies"). If this flag
    is set, then children that are created by this process using *fork()* do not inherit
    privileged scheduling policies and priorities. The rules are as follows:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: Linux 2.6.32 引入了 `SCHED_RESET_ON_FORK` 作为可以在调用 *sched_setscheduler()* 时指定的 *policy*
    值。这是一个标志位，和 [表 35-1](ch35.html#linux_realtime_and_nonrealtime_schedulin "表 35-1.
    Linux 实时和非实时调度策略") 中的某个策略进行 OR 运算。如果设置了此标志，则使用 *fork()* 创建的子进程不会继承特权调度策略和优先级。规则如下：
- en: If the calling process has a realtime scheduling policy (`SCHED_RR` or `SCHED_FIFO`),
    then the policy in child processes is reset to the standard round-robin time-sharing
    policy, `SCHED_OTHER`.
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果调用进程采用实时调度策略（`SCHED_RR` 或 `SCHED_FIFO`），则子进程的调度策略会被重置为标准的轮转时间共享策略 `SCHED_OTHER`。
- en: If the process has a negative (i.e., high) nice value, then the nice value in
    child processes is reset to 0.
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果进程的优先级值为负值（即较高的优先级），则子进程的优先级值会被重置为 0。
- en: The `SCHED_RESET_ON_FORK` flag was designed to be used in media-playback applications.
    It permits the creation of single processes that have realtime scheduling policies
    that can’t be passed to child processes. Using the `SCHED_RESET_ON_FORK` flag
    prevents the creation of fork bombs that try to evade the ceiling set by the `RLIMIT_RTTIME`
    resource limit by creating multiple children running under realtime scheduling
    policies.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: '`SCHED_RESET_ON_FORK` 标志旨在用于媒体播放应用程序。它允许创建具有实时调度策略的单个进程，这些策略不能传递给子进程。使用 `SCHED_RESET_ON_FORK`
    标志可以防止通过创建多个子进程并在实时调度策略下运行，试图规避 `RLIMIT_RTTIME` 资源限制的 fork 炸弹。'
- en: Once the `SCHED_RESET_ON_FORK` flag has been enabled for a process, only a privileged
    process (`CAP_SYS_NICE`) can disable it. When a child process is created, its
    reset-on-fork flag is disabled.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦启用了 `SCHED_RESET_ON_FORK` 标志，只有具有特权的进程（`CAP_SYS_NICE`）才能禁用它。当创建子进程时，其重置标志会被禁用。
- en: Relinquishing the CPU
  id: totrans-167
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 放弃 CPU
- en: 'A realtime process may voluntarily relinquish the CPU in two ways: by invoking
    a system call that blocks the process (e.g., a *read()* from a terminal) or by
    calling *sched_yield()*.'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 实时进程可以通过两种方式主动放弃 CPU：通过调用会阻塞进程的系统调用（例如，*read()* 从终端读取）或调用 *sched_yield()*。
- en: '[PRE12]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Note
  id: totrans-170
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Returns 0 on success, or -1 on error
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 成功时返回 0，出错时返回 -1
- en: The operation of *sched_yield()* is simple. If there are any other queued runnable
    processes at the same priority level as the calling process, then the calling
    process is placed at the back of the queue, and the process at the head of the
    queue is scheduled to use the CPU. If no other runnable processes are queued at
    this priority, then *sched_yield()* does nothing; the calling process simply continues
    using the CPU.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: '*sched_yield()*的操作很简单。如果有任何其他队列中等待运行的进程，其优先级与调用进程相同，那么调用进程将被放到队列的末尾，队列头部的进程将被调度使用CPU。如果在该优先级下没有其他可运行的进程，则*sched_yield()*不做任何操作；调用进程继续使用CPU。'
- en: Although SUSv3 permits a possible error return from *sched_yield()*, this system
    call always succeeds on Linux, as well as on many other UNIX implementations.
    Portable applications should nevertheless always check for an error return.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管SUSv3允许*sched_yield()*可能返回错误，但在Linux及许多其他UNIX实现中，该系统调用总是成功的。可移植应用程序仍然应该始终检查错误返回。
- en: The use of *sched_yield()* for nonrealtime processes is undefined.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 对于非实时进程，使用*sched_yield()*的行为是未定义的。
- en: The `SCHED_RR` Time Slice
  id: totrans-175
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`SCHED_RR`时间片'
- en: The *sched_rr_get_interval()* system call enables us to find out the length
    of the time slice allocated to a `SCHED_RR` process each time it is granted use
    of the CPU.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: '*sched_rr_get_interval()*系统调用使我们能够查找分配给`SCHED_RR`进程的时间片的长度，每次它获得CPU使用权时都会返回该时间片的长度。'
- en: '[PRE13]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Note
  id: totrans-178
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Returns 0 on success, or -1 on error
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 成功时返回0，出错时返回-1
- en: 'As with the other process scheduling system calls, *pid* identifies the process
    about which we want to obtain information, and specifying *pid* as 0 means the
    calling process. The time slice is returned in the *timespec* structure pointed
    to by *tp*:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 与其他进程调度系统调用一样，*pid*标识我们要获取信息的进程，指定*pid*为0表示调用进程。时间片的值会以*timespec*结构返回，该结构由*tp*指针指向：
- en: '[PRE14]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Note
  id: totrans-182
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: On recent 2.6 kernels, the realtime round-robin time slice is 0.1 seconds.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 在最近的2.6内核中，实时轮转时间片为0.1秒。
- en: CPU Affinity
  id: totrans-184
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: CPU亲和性
- en: When a process is rescheduled to run on a multiprocessor system, it doesn’t
    necessarily run on the same CPU on which it last executed. The usual reason it
    may run on another CPU is that the original CPU is already busy.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个进程在多处理器系统中重新调度运行时，它不一定会在最后执行的同一CPU上运行。它可能运行在其他CPU上的常见原因是原来的CPU已经忙碌。
- en: 'When a process changes CPUs, there is a performance impact: in order for a
    line of the process’s data to be loaded into the cache of the new CPU, it must
    first be invalidated (i.e., either discarded if it is unmodified, or flushed to
    main memory if it was modified), if present in the cache of the old CPU. (To prevent
    cache inconsistencies, multiprocessor architectures allow data to be kept in only
    one CPU cache at a time.) This invalidation costs execution time. Because of this
    performance impact, the Linux (2.6) kernel tries to ensure *soft* CPU affinity
    for a process—wherever possible, the process is rescheduled to run on the same
    CPU.'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个进程更换CPU时，会有性能影响：为了将进程数据的一行加载到新CPU的缓存中，它必须首先被使无效（即，如果数据未被修改，则丢弃；如果数据被修改，则刷新到主内存），如果它存在于旧CPU的缓存中。（为了防止缓存不一致，多处理器架构允许数据只能存在于一个CPU缓存中。）这种使无效的操作会消耗执行时间。由于这个性能影响，Linux（2.6）内核会尽量确保进程具有*软*CPU亲和性——尽可能地，进程会重新调度到相同的CPU上运行。
- en: Note
  id: totrans-187
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: A *cache line* is the cache analog of a page in a virtual memory management
    system. It is the size of the unit used for transfers between the CPU cache and
    main memory. Typical line sizes range from 32 to 128 bytes. For further information,
    see [Schimmel, 1994] and [Drepper, 2007].
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: '*缓存行*是虚拟内存管理系统中页面的缓存类比。它是用于CPU缓存与主内存之间传输的单位大小。典型的缓存行大小范围从32字节到128字节。如需更多信息，请参见[Schimmel,
    1994]和[Drepper, 2007]。'
- en: One of the fields in the Linux-specific `/proc/`*PID*`/stat` file displays the
    number of the CPU on which a process is currently executing or last executed.
    See the *proc(5)* manual page for details.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: Linux特有的`/proc/`*PID*`/stat`文件中的一个字段显示了进程当前正在执行或最后执行的CPU编号。详细信息请参见*proc(5)*手册页。
- en: 'Sometimes, it is desirable to set *hard* CPU affinity for a process, so that
    it is explicitly restricted to always running on one, or a subset, of the available
    CPUs. Among the reasons we may want to do this are the following:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，我们希望为进程设置*硬*CPU亲和性，以便明确限制其始终在一个或多个可用CPU上运行。我们可能希望这样做的原因包括：
- en: We can avoid the performance impacts caused by invalidation of cached data.
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以避免因缓存数据使无效而导致的性能影响。
- en: If multiple threads (or processes) are accessing the same data, then we may
    obtain performance benefits by confining them all to the same CPU, so that they
    don’t contend for the data and thus cause cache misses.
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果多个线程（或进程）访问相同的数据，那么通过将它们都限制在同一个CPU上，我们可能会获得性能上的好处，这样它们就不会争夺数据，从而避免缓存未命中的问题。
- en: For a time-critical application, it may be desirable to confine most processes
    on the system to other CPUs, while reserving one or more CPUs for the time-critical
    application.
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于时间敏感的应用，可能希望将系统中的大部分进程限制在其他CPU上，同时为时间敏感的应用保留一个或多个CPU。
- en: Note
  id: totrans-194
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The *isolcpus* kernel boot option can be used to isolate one or more CPUs from
    the normal kernel scheduling algorithms. The only way to move a process on or
    off a CPU that has been isolated is via the CPU affinity system calls described
    in this section. The *isolcpus* boot option is the preferred method of implementing
    the last of the scenarios listed above. For details, see the kernel source file
    `Documentation/kernel-parameters.txt`.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: '*isolcpus* 内核启动选项可用于将一个或多个CPU从正常的内核调度算法中隔离。移动进程到一个已隔离的CPU，或将其移出，唯一的方法是通过本节描述的CPU亲和性系统调用。*isolcpus*
    启动选项是实现上述场景中最后一种情况的首选方法。有关详细信息，请参见内核源文件 `Documentation/kernel-parameters.txt`。'
- en: Linux also provides a *cpuset* kernel option, which can be used on systems containing
    large numbers of CPUs to achieve more sophisticated control over how the CPUs
    and memory are allocated to processes. For details, see the kernel source file
    `Documentation/cpusets.txt`.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: Linux 还提供了一个*cpuset*内核选项，可以在包含大量CPU的系统上使用，以实现更复杂的CPU和内存分配控制。有关详细信息，请参见内核源文件
    `Documentation/cpusets.txt`。
- en: 'Linux 2.6 provides a pair of nonstandard system calls to modify and retrieve
    the hard CPU affinity of a process: *sched_setaffinity()* and *sched_getaffinity()*.'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: Linux 2.6 提供了一对非标准的系统调用，用于修改和获取进程的硬件CPU亲和性：*sched_setaffinity()* 和 *sched_getaffinity()*。
- en: Note
  id: totrans-198
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Many other UNIX implementations provide interfaces for controlling CPU affinity.
    For example, HP-UX and Solaris provide a *pset_bind()* system call.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 许多其他UNIX实现也提供了控制CPU亲和性的接口。例如，HP-UX和Solaris提供了*pset_bind()*系统调用。
- en: The *sched_setaffinity()* system call sets the CPU affinity of the process specified
    by *pid*. If *pid* is 0, the CPU affinity of the calling process is changed.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: '*sched_setaffinity()* 系统调用设置由*pid*指定的进程的CPU亲和性。如果*pid*为0，则会改变调用进程的CPU亲和性。'
- en: '[PRE15]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Note
  id: totrans-202
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Returns 0 on success, or -1 on error
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 成功时返回0，出错时返回-1。
- en: The CPU affinity to be assigned to the process is specified in the *cpu_set_t*
    structure pointed to by *set*.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 要分配给进程的CPU亲和性在由*set*指向的*cpu_set_t*结构中指定。
- en: Note
  id: totrans-205
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: CPU affinity is actually a per-thread attribute that can be adjusted independently
    for each of the threads in a thread group. If we want to change the CPU affinity
    of a specific thread in a multithreaded process, we can specify *pid* as the value
    returned by a call to *gettid()* in that thread. Specifying *pid* as 0 means the
    calling thread.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: CPU亲和性实际上是每个线程的属性，可以独立调整线程组中每个线程的亲和性。如果我们想要改变多线程进程中特定线程的CPU亲和性，可以将*pid*指定为该线程调用*gettid()*返回的值。将*pid*指定为0表示调用线程。
- en: Although the *cpu_set_t* data type is implemented as a bit mask, we should treat
    it as an opaque structure. All manipulations of the structure should be done using
    the macros `CPU_ZERO()`, `CPU_SET()`, `CPU_CLR()`, and `CPU_ISSET()`.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管*cpu_set_t*数据类型是以位掩码的形式实现的，但我们应该将其视为一个不透明的结构体。所有对该结构体的操作都应该通过宏 `CPU_ZERO()`、`CPU_SET()`、`CPU_CLR()`
    和 `CPU_ISSET()` 来进行。
- en: '[PRE16]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Note
  id: totrans-209
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Returns true (1) if *cpu* is in *set*, or false (0) otherwise
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 如果*cpu*在*set*中，则返回真（1）；否则返回假（0）。
- en: 'These macros operate on the CPU set pointed to by *set* as follows:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 这些宏对由*set*指向的CPU集合进行如下操作：
- en: '`CPU_ZERO()` initializes *set* to be empty.'
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CPU_ZERO()` 将*set*初始化为空。'
- en: '`CPU_SET()` adds the CPU *cpu* to *set*.'
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CPU_SET()` 将CPU *cpu* 添加到*set*中。'
- en: '`CPU_CLR()` removes the CPU *cpu* from *set*.'
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CPU_CLR()` 从*set*中移除CPU *cpu*。'
- en: '`CPU_ISSET()` returns true if the CPU *cpu* is a member of *set*.'
  id: totrans-215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CPU_ISSET()` 如果CPU *cpu* 是*set*的成员，则返回真。'
- en: Note
  id: totrans-216
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The GNU C library also provides a number of other macros for working with CPU
    sets. See the *CPU_SET(3)* manual page for details.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: GNU C库还提供了一些其他宏，用于操作CPU集合。有关详细信息，请参见*CPU_SET(3)*手册页。
- en: The CPUs in a CPU set are numbered starting at 0\. The `<sched.h>` header file
    defines the constant `CPU_SETSIZE` to be one greater than the maximum CPU number
    that can be represented in a *cpu_set_t* variable. `CPU_SETSIZE` has the value
    1024.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: CPU集合中的CPU编号从0开始。`<sched.h>`头文件定义了常量`CPU_SETSIZE`，它比可以在*cpu_set_t*变量中表示的最大CPU编号大1。`CPU_SETSIZE`的值为1024。
- en: The *len* argument given to *sched_setaffinity()* should specify the number
    of bytes in the *set* argument (i.e., *sizeof(cpu_set_t)*).
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 传递给*sched_setaffinity()*的*len*参数应指定*set*参数中字节的数量（即，*sizeof(cpu_set_t)*）。
- en: 'The following code confines the process identified by *pid* to running on any
    CPU other than the first CPU of a four-processor system:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码将由*pid*标识的进程限制为在四核系统的除第一个CPU外的其他CPU上运行：
- en: '[PRE17]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: If the CPUs specified in *set* don’t correspond to any CPUs on the system, then
    *sched_setaffinity()* fails with the error `EINVAL`.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 如果*set*中指定的CPU与系统中的任何CPU不匹配，则*sched_setaffinity()*将返回错误`EINVAL`。
- en: If *set* doesn’t include the CPU on which the calling process is currently running,
    then the process is migrated to one of the CPUs in *set*.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 如果*set*不包括调用进程当前正在运行的CPU，则该进程将迁移到*set*中的其他CPU。
- en: An unprivileged process may set the CPU affinity of another process only if
    its effective user ID matches the real or effective user ID of the target process.
    A privileged (`CAP_SYS_NICE`) process may set the CPU affinity of any process.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 非特权进程只有在其有效用户ID与目标进程的真实或有效用户ID匹配时，才可以设置另一个进程的CPU亲和性。具有特权（`CAP_SYS_NICE`）的进程可以设置任何进程的CPU亲和性。
- en: The *sched_getaffinity()* system call retrieves the CPU affinity mask of the
    process specified by *pid*. If *pid* is 0, the CPU affinity mask of the calling
    process is returned.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: '*sched_getaffinity()*系统调用检索由*pid*指定的进程的CPU亲和性掩码。如果*pid*为0，则返回调用进程的CPU亲和性掩码。'
- en: '[PRE18]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Note
  id: totrans-227
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Returns 0 on success, or -1 on error
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 成功时返回0，错误时返回-1。
- en: The CPU affinity mask is returned in the *cpu_set_t* structure pointed to by
    *set*. The *len* argument should be set to indicate the number of bytes in this
    structure (i.e., *sizeof(cpu_set_t)*). We can use the `CPU_ISSET()` macro to determine
    which CPUs are in the returned *set*.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: CPU亲和性掩码将保存在指向*set*的*cpu_set_t*结构中返回。*len*参数应设置为指示此结构中字节数的值（即，*sizeof(cpu_set_t)*）。我们可以使用`CPU_ISSET()`宏来确定返回的*set*中哪些CPU可用。
- en: If the CPU affinity mask of the target process has not otherwise been modified,
    *sched_getaffinity()* returns a set containing all of the CPUs on the system.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 如果目标进程的CPU亲和性掩码没有其他修改，*sched_getaffinity()*将返回包含系统中所有CPU的集合。
- en: No permission checking is performed by *sched_getaffinity()*; an unprivileged
    process can retrieve the CPU affinity mask of any process on the system.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: '*sched_getaffinity()*不执行权限检查；非特权进程可以检索系统中任何进程的CPU亲和性掩码。'
- en: A child process created by *fork()* inherits its parent’s CPU affinity mask,
    and this mask is preserved across an *exec()*.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 由*fork()*创建的子进程继承其父进程的CPU亲和性掩码，并且这个掩码会在执行*exec()*时被保留。
- en: The *sched_setaffinity()* and *sched_getaffinity()* system calls are Linux-specific.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: '*sched_setaffinity()*和*sched_getaffinity()*系统调用是Linux特有的。'
- en: Note
  id: totrans-234
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The `t_sched_setaffinity.c` and `t_sched_getaffinity.c` programs in the `procpri`
    subdirectory in the source code distribution for this book demonstrate the use
    of *sched_setaffinity()* and *sched_getaffinity()*.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 本书源代码分发包中`procpri`子目录下的`t_sched_setaffinity.c`和`t_sched_getaffinity.c`程序演示了*sched_setaffinity()*和*sched_getaffinity()*的使用。
- en: Summary
  id: totrans-236
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 总结
- en: The default kernel scheduling algorithm employs a round-robin time-sharing policy.
    By default, all processes have equal access to the CPU under this policy, but
    we can set a process’s nice value to a number in the range -20 (high priority)
    to +19 (low priority) to cause the scheduler to favor or disfavor that process.
    However, even if we give a process the lowest priority, it is not completely starved
    of the CPU.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 默认的内核调度算法采用轮转时间共享策略。在此策略下，所有进程默认对CPU拥有平等访问权限，但我们可以将进程的优先级值（nice值）设置为-20（高优先级）到+19（低优先级）之间的一个数字，来使调度器倾向于或偏向于某个进程。然而，即使我们将进程的优先级设置为最低，它也不会完全被剥夺CPU资源。
- en: Linux also implements the POSIX realtime scheduling extensions. These allow
    an application to precisely control the allocation of the CPU to processes. Processes
    operating under the two realtime scheduling policies, `SCHED_RR` (round-robin)
    and `SCHED_FIFO` (first-in, first-out), always have priority over processes operating
    under nonrealtime policies. Realtime processes have priorities in the range 1
    (low) to 99 (high). As long as it is runnable, a higher-priority process completely
    excludes lower-priority processes from the CPU. A process operating under the
    `SCHED_FIFO` policy maintains exclusive access to the CPU until either it terminates,
    it voluntarily relinquishes the CPU, or it is preempted because a higher-priority
    process became runnable. Similar rules apply to the `SCHED_RR` policy, with the
    addition that if multiple processes are running at the same priority, then the
    CPU is shared among these processes in a round-robin fashion.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: Linux 还实现了 POSIX 实时调度扩展。这些扩展允许应用程序精确控制 CPU 对进程的分配。在两个实时调度策略 `SCHED_RR`（轮转）和
    `SCHED_FIFO`（先进先出）下运行的进程总是优先于非实时策略下运行的进程。实时进程的优先级范围为 1（低）到 99（高）。只要可以运行，优先级较高的进程会完全排除优先级较低的进程对
    CPU 的使用。一个运行在 `SCHED_FIFO` 策略下的进程在终止、主动放弃 CPU 或被更高优先级的进程抢占前，将保持对 CPU 的独占访问。对于
    `SCHED_RR` 策略，也适用类似规则，额外的规定是，如果多个进程在相同优先级下运行，那么 CPU 将以轮转的方式在这些进程之间共享。
- en: A process’s CPU affinity mask can be used to restrict the process to running
    on a subset of the CPUs available on a multiprocessor system. This can improve
    the performance of certain types of applications.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 一个进程的 CPU 亲和性掩码可以用来限制该进程只在多处理器系统中可用的部分 CPU 上运行。这可以提高某些类型应用程序的性能。
- en: Further information
  id: totrans-240
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 更多信息
- en: '[Love, 2010] provides background detail on process priorities and scheduling
    on Linux. [Gallmeister, 1995] provides further information about the POSIX realtime
    scheduling API. Although targeted at POSIX threads, much of the discussion of
    the realtime scheduling API in [Butenhof, 1996] is useful background to the realtime
    scheduling discussion in this chapter.'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: '[Love, 2010] 提供了有关 Linux 上进程优先级和调度的背景详细信息。[Gallmeister, 1995] 提供了关于 POSIX 实时调度
    API 的更多信息。虽然针对 POSIX 线程，许多关于实时调度 API 的讨论在 [Butenhof, 1996] 中对于本章的实时调度讨论仍然具有有用的背景意义。'
- en: For further information about CPU affinity and controlling the allocation of
    threads to CPUs and memory nodes on multiprocessor systems, see the kernel source
    file `Documentation/cpusets.txt`, and the *mbind(2)*, *set_mempolicy(2)*, and
    *cpuset(7)* manual pages.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 有关 CPU 亲和性以及在多处理器系统上控制线程分配到 CPU 和内存节点的更多信息，请参见内核源文件 `Documentation/cpusets.txt`，以及
    *mbind(2)*、*set_mempolicy(2)* 和 *cpuset(7)* 手册页。
- en: Exercises
  id: totrans-243
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习
- en: Implement the *nice(1)* command.
  id: totrans-244
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现 *nice(1)* 命令。
- en: 'Write a set-user-ID-*root* program that is the realtime scheduling analog of
    *nice(1)*. The command-line interface of this program should be as follows:'
  id: totrans-245
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写一个设置用户 ID 为 *root* 的程序，它是 *nice(1)* 的实时调度对应物。该程序的命令行接口应如下所示：
- en: '[PRE19]'
  id: totrans-246
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: In the above command, *policy* is *r* for `SCHED_RR` or *f* for `SCHED_FIFO`.
    This program should drop its privileged ID before execing the command, for the
    reasons described in [Retrieving and Modifying Real, Effective, and Saved Set
    IDs](ch09.html#retrieving_and_modifying_real_comma_effe "Retrieving and Modifying
    Real, Effective, and Saved Set IDs") and [Be Careful When Executing a Program](ch38.html#be_careful_when_executing_a_program
    "Be Careful When Executing a Program").
  id: totrans-247
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在上述命令中，*policy* 为 `SCHED_RR` 的 *r* 或 `SCHED_FIFO` 的 *f*。该程序在执行命令之前应放弃其特权 ID，原因如
    [检索和修改真实、有效和保存的 ID](ch09.html#retrieving_and_modifying_real_comma_effe "检索和修改真实、有效和保存的
    ID") 和 [执行程序时要小心](ch38.html#be_careful_when_executing_a_program "执行程序时要小心") 中所述。
- en: Write a program that places itself under the `SCHED_FIFO` scheduling policy
    and then creates a child process. Both processes should execute a function that
    causes the process to consume a maximum of 3 seconds of CPU time. (This can be
    done by using a loop in which the *times()* system call is repeatedly called to
    determine the amount of CPU time so far consumed.) After each quarter of a second
    of consumed CPU time, the function should print a message that displays the process
    ID and the amount of CPU time so far consumed. After each second of consumed CPU
    time, the function should call *sched_yield()* to yield the CPU to the other process.
    (Alternatively, the processes could raise each other’s scheduling priority using
    *sched_setparam()*.) The program’s output should demonstrate that the two processes
    alternately execute for 1 second of CPU time. (Note carefully the advice given
    in [Modifying and Retrieving Policies and Priorities](ch35.html#modifying_and_retrieving_policies_and_pr
    "Modifying and Retrieving Policies and Priorities") about preventing a runaway
    realtime process from hogging the CPU.)
  id: totrans-248
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写一个程序，将其自身置于`SCHED_FIFO`调度策略下，并创建一个子进程。两个进程都应执行一个函数，使进程最多消耗3秒的CPU时间。（这可以通过在循环中反复调用*times()*系统调用来确定已消耗的CPU时间。）每当消耗四分之一秒的CPU时间时，函数应打印一条消息，显示进程ID和到目前为止消耗的CPU时间。每当消耗一秒的CPU时间时，函数应调用*sched_yield()*将CPU让给另一个进程。（或者，进程也可以使用*sched_setparam()*提高彼此的调度优先级。）程序的输出应演示两个进程交替执行，每个进程消耗1秒的CPU时间。（请仔细注意在[修改和检索策略与优先级](ch35.html#modifying_and_retrieving_policies_and_pr
    "修改和检索策略与优先级")中给出的建议，避免一个实时进程占用CPU过多。）
- en: If two processes use a pipe to exchange a large amount of data on a multiprocessor
    system, the communication should be faster if the processes run on the same CPU
    than if they run on different CPUs. The reason is that when the two processes
    run on the same CPU, the pipe data will be more quickly accessed because it can
    remain in that CPU’s cache. By contrast, when the processes run on separate CPUs,
    the benefits of the CPU cache are lost. If you have access to a multiprocessor
    system, write a program that uses *sched_setaffinity()* to demonstrate this effect,
    by forcing the processes either onto the same CPUs or onto different CPUs. ([Chapter 44](ch44.html
    "Chapter 44. Pipes and FIFOs") describes the use of pipes.)
  id: totrans-249
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果两个进程在多处理器系统上使用管道交换大量数据，且这两个进程运行在同一CPU上时，通信速度应该比它们运行在不同的CPU上时更快。原因是，当两个进程运行在同一CPU上时，管道数据能够更快地被访问，因为它可以保留在该CPU的缓存中。相比之下，当进程运行在不同的CPU上时，CPU缓存的优势就会丧失。如果你可以访问多处理器系统，编写一个程序，使用*sched_setaffinity()*来演示这种效果，强制将进程运行在相同的CPU上或不同的CPU上。（[第44章](ch44.html
    "第44章 管道和FIFO")描述了管道的使用。）
- en: Note
  id: totrans-250
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The advantage in favor of processes running on the same CPU won’t hold true
    on hyperthreaded systems and on some modern multiprocessor architectures where
    the CPUs do share the cache. In these cases, the advantage will be in favor of
    processes running on different CPUs. Information about the CPU topology of a multiprocessor
    system can be obtained by inspecting the contents of the Linux-specific `/proc/cpuinfo`
    file.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 在超线程系统和一些现代多处理器架构中，进程运行在同一CPU上的优势并不成立，因为这些CPU共享缓存。在这种情况下，优势将会偏向于运行在不同CPU上的进程。关于多处理器系统的CPU拓扑信息，可以通过查看Linux特定的`/proc/cpuinfo`文件的内容来获取。
