- en: Chapter 35. Process Priorities and Scheduling
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This chapter discusses various system calls and process attributes that determine
    when and which processes obtain access to the CPU(s). We begin by describing the
    *nice* value, a process characteristic that influences the amount of CPU time
    that a process is allocated by the kernel scheduler. We follow this with a description
    of the POSIX realtime scheduling API. This API allows us to define the policy
    and priority used for scheduling processes, giving us much tighter control over
    how processes are allocated to the CPU. We conclude with a discussion of the system
    calls for setting a process’s CPU affinity mask, which determines the set of CPUs
    on which a process running on a multiprocessor system will run.
  prefs: []
  type: TYPE_NORMAL
- en: Process Priorities (Nice Values)
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'On Linux, as with most other UNIX implementations, the default model for scheduling
    processes for use of the CPU is *round-robin time-sharing*. Under this model,
    each process in turn is permitted to use the CPU for a brief period of time, known
    as a *time slice* or *quantum*. Round-robin time-sharing satisfies two important
    requirements of an interactive multitasking system:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Fairness*: Each process gets a share of the CPU.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Responsiveness*: A process doesn’t need to wait for long periods before it
    receives use of the CPU.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Under the round-robin time-sharing algorithm, processes can’t exercise direct
    control over when and for how long they will be able to use the CPU. By default,
    each process in turn receives use of the CPU until its time slice runs out or
    it voluntarily gives up the CPU (for example, by putting itself to sleep or performing
    a disk read). If all processes attempt to use the CPU as much as possible (i.e.,
    no process ever sleeps or blocks on an I/O operation), then they will receive
    a roughly equal share of the CPU.
  prefs: []
  type: TYPE_NORMAL
- en: However, one process attribute, the *nice value*, allows a process to indirectly
    influence the kernel’s scheduling algorithm. Each process has a nice value in
    the range -20 (high priority) to +19 (low priority); the default is 0 (refer to
    [Figure 35-1](ch35.html#range_and_interpretation_of_the_process "Figure 35-1. Range
    and interpretation of the process nice value")). In traditional UNIX implementations,
    only privileged processes can assign themselves (or other processes) a negative
    (high) priority. (We’ll explain some Linux differences in [Modifying and Retrieving
    Policies and Priorities](ch35.html#modifying_and_retrieving_policies_and_pr "Modifying
    and Retrieving Policies and Priorities").) Unprivileged processes can only lower
    their priority, by assuming a nice value greater than the default of 0\. By doing
    this, they are being “nice” to other processes, and this fact gives the attribute
    its name.
  prefs: []
  type: TYPE_NORMAL
- en: The nice value is inherited by a child created via *fork()* and preserved across
    an *exec()*.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Rather than returning the actual nice value, the *getpriority()* system call
    service routine returns a number in the range 1 (low priority) to 40 (high priority),
    calculated according to the formula *unice = 20 - knice*. This is done to avoid
    having a negative return value from a system call service routine, which is used
    to indicate an error. (See the description of system call service routines in
    Section 3.1.) Applications are unaware of the manipulated value returned by the
    system call service routine, since the C library *getpriority()* wrapper function
    reverses the calculation, returning the value *20 - unice* to the calling program.
  prefs: []
  type: TYPE_NORMAL
- en: '![Range and interpretation of the process nice value](figs/web/35-1_PROCPRI-nice-scale90.png.jpg)Figure 35-1. Range
    and interpretation of the process nice value'
  prefs: []
  type: TYPE_NORMAL
- en: Effect of the nice value
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Processes are not scheduled in a strict hierarchy by nice value; rather, the
    nice value acts as weighting factor that causes the kernel scheduler to favor
    processes with higher priorities. Giving a process a low priority (i.e., high
    nice value) won’t cause it to be completely starved of the CPU, but causes it
    to receive relatively less CPU time. The extent to which the nice value influences
    the scheduling of a process has varied across Linux kernel versions, as well as
    across UNIX systems.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Starting in kernel 2.6.23, a new kernel scheduling algorithm means that relative
    differences in nice values have a much stronger effect than in previous kernels.
    As a result, processes with low nice values receive less CPU than before, and
    processes with high nice values obtain a greater proportion of the CPU.
  prefs: []
  type: TYPE_NORMAL
- en: Retrieving and modifying priorities
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The *getpriority()* and *setpriority()* system calls allow a process to retrieve
    and change its own nice value or that of another process.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Returns (possibly negative) nice value of specified process on success, or -1
    on error
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Returns 0 on success, or -1 on error
  prefs: []
  type: TYPE_NORMAL
- en: 'Both system calls take the arguments *which* and *who*, identifying the process(es)
    whose priority is to be retrieved or modified. The *which* argument determines
    how *who* is interpreted. This argument takes one of the following values:'
  prefs: []
  type: TYPE_NORMAL
- en: '`PRIO_PROCESS`'
  prefs: []
  type: TYPE_NORMAL
- en: Operate on the process whose process ID equals *who*. If *who* is 0, use the
    caller’s process ID.
  prefs: []
  type: TYPE_NORMAL
- en: '`PRIO_PGRP`'
  prefs: []
  type: TYPE_NORMAL
- en: Operate on all of the members of the process group whose process group ID equals
    *who*. If *who* is 0, use the caller’s process group.
  prefs: []
  type: TYPE_NORMAL
- en: '`PRIO_USER`'
  prefs: []
  type: TYPE_NORMAL
- en: Operate on all processes whose real user ID equals *who*. If *who* is 0, use
    the caller’s real user ID.
  prefs: []
  type: TYPE_NORMAL
- en: The *id_t* data type, used for the *who* argument, is an integer type of sufficient
    size to accommodate a process ID or a user ID.
  prefs: []
  type: TYPE_NORMAL
- en: The *getpriority()* system call returns the nice value of the process specified
    by *which* and *who*. If multiple processes match the criteria specified (which
    may occur if *which* is `PRIO_PGRP` or `PRIO_USER`), then the nice value of the
    process with the highest priority (i.e., lowest numerical value) is returned.
    Since *getpriority()* may legitimately return a value of -1 on a successful call,
    we must test for an error by setting *errno* to 0 prior to the call, and then
    checking for a -1 return status and a nonzero *errno* value after the call.
  prefs: []
  type: TYPE_NORMAL
- en: The *setpriority()* system call sets the nice value of the process(es) specified
    by *which* and *who* to the value specified in *prio*. Attempts to set a nice
    value to a number outside the permitted range (-20 to +19) are silently bounded
    to this range.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Historically, the nice value was changed using the call *nice(incr)*, which
    added *incr* to the calling process’s nice value. This function is still available,
    but it is superseded by the more general *setpriority()* system call.
  prefs: []
  type: TYPE_NORMAL
- en: The command-line analogs of *setpriority()* are *nice(1)*, which can be used
    by unprivileged users to run a command with a lower priority or by privileged
    users to run a command with a raised priority, and *renice(8)*, which can be used
    by the superuser to change the nice value of an existing process.
  prefs: []
  type: TYPE_NORMAL
- en: A privileged (`CAP_SYS_NICE`) process can change the priority of any process.
    An unprivileged process may change its own priority (by specifying *which* as
    `PRIO_PROCESS`, and *who* as 0) or the priority of another (target) process, if
    its effective user ID matches the real or effective user ID of the target process.
    The Linux permission rules for *setpriority()* differ from SUSv3, which specifies
    that an unprivileged process can change the priority of another process if its
    real or effective user ID matches the effective user ID of the target process.
    UNIX implementations show some variation on this point. Some follow the SUSv3
    rules, but others—notably the BSDs—behave in the same way as Linux.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In Linux kernels before 2.6.12, the permission rules for calls to *setpriority()*
    by unprivileged processes are different from later kernels (and also deviate from
    SUSv3). An unprivileged process can change the priority of another process if
    its real or effective user ID matches the real user ID of the target process.
    From Linux 2.6.12 onward, the permissions checks were changed to be consistent
    with other similar APIs available on Linux, such as *sched_setscheduler()* and
    *sched_setaffinity()*.
  prefs: []
  type: TYPE_NORMAL
- en: In Linux kernels before 2.6.12, an unprivileged process may use *setpriority()*
    only to (irreversibly) lower its own or another process’s nice value. A privileged
    (`CAP_SYS_NICE`) process can use *setpriority()* to raise nice values.
  prefs: []
  type: TYPE_NORMAL
- en: Since kernel 2.6.12, Linux provides the `RLIMIT_NICE` resource limit, which
    permits unprivileged processes to increase nice values. An unprivileged process
    can raise its own nice value to the maximum specified by the formula *20 - rlim_cur*,
    where *rlim_cur* is the current `RLIMIT_NICE` soft resource limit. As an example,
    if a process’s `RLIMIT_NICE` soft limit is 25, then its nice value can be raised
    to -5\. From this formula, and the knowledge that the nice value has the range
    +19 (low) to -20 (high), we can deduce that the effectively useful range of the
    `RLIMIT_NICE` limit is 1 (low) to 40 (high). (`RLIMIT_NICE` doesn’t use the number
    range +19 to -20 because some negative resource-limit values have special meanings—for
    example, `RLIM_INFINITY` has the same representation as -1.)
  prefs: []
  type: TYPE_NORMAL
- en: An unprivileged process can make a *setpriority()* call to change the nice value
    of another (target) process, if the effective user ID of the process calling *setpriority()*
    matches the real or effective user ID of the target process, and the change to
    the nice value is consistent with the target process’s `RLIMIT_NICE` limit.
  prefs: []
  type: TYPE_NORMAL
- en: The program in [Example 35-1](ch35.html#modifying_and_retrieving_a_process_numbe
    "Example 35-1. Modifying and retrieving a process’s nice value") uses *setpriority()*
    to change the nice value of the process(es) specified by its command-line arguments
    (which correspond to the arguments of *setpriority()*), and then calls *getpriority()*
    to verify the change.
  prefs: []
  type: TYPE_NORMAL
- en: Example 35-1. Modifying and retrieving a process’s nice value
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Overview of Realtime Process Scheduling
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The standard kernel scheduling algorithm usually provides adequate performance
    and responsiveness for the mixture of interactive and background processes typically
    run on a system. However, realtime applications have more stringent requirements
    of a scheduler, including the following:'
  prefs: []
  type: TYPE_NORMAL
- en: A realtime application must provide a guaranteed maximum response time for external
    inputs. In many cases, these guaranteed maximum response times must be quite small
    (e.g., of the order of a fraction of a second). For example, a slow response by
    a vehicle navigation system could be catastrophic. To satisfy this requirement,
    the kernel must provide the facility for a high-priority process to obtain control
    of the CPU in a timely fashion, preempting any process that may currently be running.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: 'A time-critical application may need to take other steps to avoid unacceptable
    delays. For example, to avoid being delayed by a page fault, an application can
    lock all of its virtual memory into RAM using *mlock()* or *mlockall()* (described
    in [Memory Locking: *mlock()* and *mlockall()*](ch50.html#memory_locking_colon_mlock_open_parenthe
    "Memory Locking: mlock() and mlockall()")).'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: A high-priority process should be able to maintain exclusive access to the CPU
    until it completes or voluntarily relinquishes the CPU.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A realtime application should be able to control the precise order in which
    its component processes are scheduled.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'SUSv3 specifies a realtime process scheduling API (originally defined in POSIX.1b)
    that partly addresses these requirements. This API provides two realtime scheduling
    policies: `SCHED_RR` and `SCHED_FIFO`. Processes operating under either of these
    policies always have priority over processes scheduled using the standard round-robin
    time-sharing policy described in [Process Priorities (Nice Values)](ch35.html#process_priorities_open_parenthesis_nice
    "Process Priorities (Nice Values)"), which the realtime scheduling API identifies
    using the constant `SCHED_OTHER`.'
  prefs: []
  type: TYPE_NORMAL
- en: Each of the realtime policies allows for a range of priority levels. SUSv3 requires
    that an implementation provide at least 32 discrete priorities for the realtime
    policies. In each scheduling policy, runnable processes with higher priority always
    have precedence over lower-priority processes when seeking access to the CPU.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The statement that runnable processes with higher priority always have precedence
    over lower-priority processes needs to be qualified for multiprocessor Linux systems
    (including hyperthreaded systems). On a multiprocessor system, each CPU has a
    separate run queue (this provides better performance than a single system-wide
    run queue), and processes are prioritized only per CPU run queue. For example,
    on a dual-processor system with three processes, process A with realtime priority
    20 could be queued waiting for CPU 0, which is currently running process B with
    priority 30, even though CPU 1 is running process C with a priority of 10.
  prefs: []
  type: TYPE_NORMAL
- en: Realtime applications that employ multiple processes (or threads) can use the
    CPU affinity API described in [CPU Affinity](ch35.html#cpu_affinity "CPU Affinity")
    to avoid any problems that might result from this scheduling behavior. For example,
    on a four-processor system, all noncritical processes could be isolated onto a
    single CPU, leaving the other three CPUs available for use by the application.
  prefs: []
  type: TYPE_NORMAL
- en: Linux provides 99 realtime priority levels, numbered 1 (lowest) to 99 (highest),
    and this range applies in both realtime scheduling policies. The priorities in
    each policy are equivalent. This means that, given two processes with the same
    priority, one operating under the `SCHED_RR` policy and the other under `SCHED_FIFO`,
    either may be the next one eligible for execution, depending on the order in which
    they were scheduled. In effect, each priority level maintains a queue of runnable
    processes, and the next process to run is selected from the front of the highest-priority
    nonempty queue.
  prefs: []
  type: TYPE_NORMAL
- en: POSIX realtime versus hard realtime
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Applications with all of the requirements listed at the start of this section
    are sometimes referred to as *hard* realtime applications. However, the POSIX
    realtime process scheduling API doesn’t satisfy all of these requirements. In
    particular, it provides no way for an application to guarantee response times
    for handling input. To make such guarantees requires operating system features
    that are not part of the mainline Linux kernel (nor most other standard operating
    systems). The POSIX API merely provides us with so-called *soft* realtime, allowing
    us to control which processes are scheduled for use of the CPU.
  prefs: []
  type: TYPE_NORMAL
- en: Adding support for hard realtime applications is difficult to achieve without
    imposing an overhead on the system that conflicts with the performance requirements
    of the time-sharing applications that form the majority of applications on typical
    desktop and server systems. This is why most UNIX kernels—including, historically,
    Linux—have not natively supported realtime applications. Nevertheless, starting
    from around version 2.6.18, various features have been added to the Linux kernel
    with the eventual aim of allowing Linux to natively provide full support for hard
    realtime applications, without imposing the aforementioned overhead for time-sharing
    operation.
  prefs: []
  type: TYPE_NORMAL
- en: The `SCHED_RR` Policy
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Under the `SCHED_RR` (round-robin) policy, processes of equal priority are
    executed in a round-robin time-sharing fashion. A process receives a fixed-length
    time slice each time it uses the CPU. Once scheduled, a process employing the
    `SCHED_RR` policy maintains control of the CPU until either:'
  prefs: []
  type: TYPE_NORMAL
- en: it reaches the end of its time slice;
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: it voluntarily relinquishes the CPU, either by performing a blocking system
    call or by calling the *sched_yield()* system call (described in [Relinquishing
    the CPU](ch35.html#relinquishing_the_cpu "Relinquishing the CPU"));
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: it terminates; or
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: it is preempted by a higher-priority process.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For the first two events above, when a process running under the `SCHED_RR`
    policy loses access to the CPU, it is placed at the back of the queue for its
    priority level. In the final case, when the higher-priority process has ceased
    execution, the preempted process continues execution, consuming the remainder
    of its time slice (i.e., the preempted process remains at the head of the queue
    for its priority level).
  prefs: []
  type: TYPE_NORMAL
- en: 'In both the `SCHED_RR` and the `SCHED_FIFO` policies, the currently running
    process may be preempted for one of the following reasons:'
  prefs: []
  type: TYPE_NORMAL
- en: a higher-priority process that was blocked became unblocked (e.g., an I/O operation
    on which it was waiting completed);
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: the priority of another process was raised to a higher level than the currently
    running process; or
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: the priority of the currently running process was decreased to a lower value
    than that of some other runnable process.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `SCHED_RR` policy is similar to the standard round-robin time-sharing scheduling
    algorithm (`SCHED_OTHER`), in that it allows a group of processes with the same
    priority to share access to the CPU. The most notable difference is the existence
    of strictly distinct priority levels, with higher-priority processes always taking
    precedence over lower-priority processes. By contrast, a low nice value (i.e.,
    high priority) doesn’t give a process exclusive access to the CPU; it merely gives
    the process a favorable weighting in scheduling decisions. As noted in [Process
    Priorities (Nice Values)](ch35.html#process_priorities_open_parenthesis_nice "Process
    Priorities (Nice Values)"), a process with a low priority (i.e., high nice value)
    always receives at least some CPU time. The other important difference is that
    the `SCHED_RR` policy allows us to precisely control the order in which processes
    are scheduled.
  prefs: []
  type: TYPE_NORMAL
- en: The `SCHED_FIFO` Policy
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `SCHED_FIFO` (first-in, first-out) policy is similar to the `SCHED_RR`
    policy. The major difference is that there is no time slice. Once a `SCHED_FIFO`
    process gains access to the CPU, it executes until either:'
  prefs: []
  type: TYPE_NORMAL
- en: it voluntarily relinquishes the CPU (in the same manner as described for the
    `SCHED_FIFO` policy above);
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: it terminates; or
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: it is preempted by a higher-priority process (in the same circumstances as described
    for the `SCHED_FIFO` policy above).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the first case, the process is placed at the back of the queue for its priority
    level. In the last case, when the higher-priority process has ceased execution
    (by blocking or terminating), the preempted process continues execution (i.e.,
    the preempted process remains at the head of the queue for its priority level).
  prefs: []
  type: TYPE_NORMAL
- en: The `SCHED_BATCH` and `SCHED_IDLE` Policies
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The Linux 2.6 kernel series added two nonstandard scheduling policies: `SCHED_BATCH`
    and `SCHED_IDLE`. Although these policies are set via the POSIX realtime scheduling
    API, they are not actually realtime policies.'
  prefs: []
  type: TYPE_NORMAL
- en: The `SCHED_BATCH` policy, added in kernel 2.6.16, is similar to the default
    `SCHED_OTHER` policy. The difference is that the `SCHED_BATCH` policy causes jobs
    that frequently wake up to be scheduled less often. This policy is intended for
    batch-style execution of processes.
  prefs: []
  type: TYPE_NORMAL
- en: The `SCHED_IDLE` policy, added in kernel 2.6.23, is also similar to `SCHED_OTHER`,
    but provides functionality equivalent to a very low nice value (i.e., lower than
    +19). The process nice value has no meaning for this policy. It is intended for
    running low-priority jobs that will receive a significant proportion of the CPU
    only if no other job on the system requires the CPU.
  prefs: []
  type: TYPE_NORMAL
- en: Realtime Process Scheduling API
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We now look at the various system calls constituting the realtime process scheduling
    API. These system calls allow us to control process scheduling policies and priorities.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Although realtime scheduling has been a part of Linux since version 2.0 of the
    kernel, several problems persisted for a long time in the implementation. A number
    of features of the implementation remained broken in the 2.2 kernel, and even
    in early 2.4 kernels. Most of these problems were rectified by about kernel 2.4.20.
  prefs: []
  type: TYPE_NORMAL
- en: Realtime Priority Ranges
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The *sched_get_priority_min()* and *sched_get_priority_max()* system calls return
    the available priority range for a scheduling policy.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Both return nonnegative integer priority on success, or -1 on error
  prefs: []
  type: TYPE_NORMAL
- en: For both system calls, *policy* specifies the scheduling policy about which
    we wish to obtain information. For this argument, we specify either `SCHED_RR`
    or `SCHED_FIFO`. The *sched_get_priority_min()* system call returns the minimum
    priority for the specified policy, and *sched_get_priority_max()* returns the
    maximum priority. On Linux, these system calls return the numbers 1 and 99, respectively,
    for both the `SCHED_RR` and `SCHED_FIFO` policies. In other words, the priority
    ranges of the two realtime policies completely coincide, and `SCHED_RR` and `SCHED_FIFO`
    processes with the same priority are equally eligible for scheduling. (Which one
    is scheduled first depends on their order in the queue for that priority level.)
  prefs: []
  type: TYPE_NORMAL
- en: The range of realtime priorities differs from one UNIX implementation to another.
    Therefore, instead of hard-coding priority values into an application, we should
    specify priorities relative to the return value from one of these functions. Thus,
    the lowest `SCHED_RR` priority would be specified as *sched_get_priority_min(SCHED_FIFO)*,
    the next higher priority as *sched_get_priority_min(SCHED_FIFO) + 1*, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: SUSv3 doesn’t require that the `SCHED_RR` and `SCHED_FIFO` policies use the
    same priority ranges, but they do so on most UNIX implementations. For example,
    on Solaris 8, the priority range for both policies is 0 to 59, and on FreeBSD
    6.1, it is 0 to 31.
  prefs: []
  type: TYPE_NORMAL
- en: Modifying and Retrieving Policies and Priorities
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this section, we look at the system calls that modify and retrieve scheduling
    policies and priorities.
  prefs: []
  type: TYPE_NORMAL
- en: Modifying scheduling policies and priorities
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The *sched_setscheduler()* system call changes both the scheduling policy and
    the priority of the process whose process ID is specified in *pid*. If *pid* is
    specified as 0, the attributes of the calling process are changed.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Returns 0 on success, or -1 on error
  prefs: []
  type: TYPE_NORMAL
- en: 'The *param* argument is a pointer to a structure of the following form:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: SUSv3 defines the *param* argument as a structure to allow an implementation
    to include additional implementation-specific fields, which may be useful if an
    implementation provides additional scheduling policies. However, like most UNIX
    implementations, Linux provides just the *sched_priority* field, which specifies
    the scheduling priority. For the `SCHED_RR` and `SCHED_FIFO` policies, this must
    be a value in the range indicated by *sched_get_priority_min()* and *sched_get_priority_max()*;
    for other policies, the priority must be 0.
  prefs: []
  type: TYPE_NORMAL
- en: The *policy* argument determines the scheduling policy for the process. It is
    specified as one of the policies shown in [Table 35-1](ch35.html#linux_realtime_and_nonrealtime_schedulin
    "Table 35-1. Linux realtime and nonrealtime scheduling policies").
  prefs: []
  type: TYPE_NORMAL
- en: Table 35-1. Linux realtime and nonrealtime scheduling policies
  prefs: []
  type: TYPE_NORMAL
- en: '| Policy | Description | SUSv3 |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `SCHED_FIFO` | Realtime first-in first-out | • |'
  prefs: []
  type: TYPE_TB
- en: '| `SCHED_RR` | Realtime round-robin | • |'
  prefs: []
  type: TYPE_TB
- en: '| `SCHED_OTHER` | Standard round-robin time-sharing | • |'
  prefs: []
  type: TYPE_TB
- en: '| `SCHED_BATCH` | Similar to `SCHED_OTHER`, but intended for batch execution
    (since Linux 2.6.16) |   |'
  prefs: []
  type: TYPE_TB
- en: '| `SCHED_IDLE` | Similar to `SCHED_OTHER`, but with priority even lower than
    nice value +19 (since Linux 2.6.23) |   |'
  prefs: []
  type: TYPE_TB
- en: A successful *sched_setscheduler()* call moves the process specified by *pid*
    to the back of the queue for its priority level.
  prefs: []
  type: TYPE_NORMAL
- en: SUSv3 specifies that the return value of a successful *sched_setscheduler()*
    call should be the previous scheduling policy. However, Linux deviates from the
    standard in that a successful call returns 0\. A portable application should test
    for success by checking that the return status is not -1.
  prefs: []
  type: TYPE_NORMAL
- en: The scheduling policy and priority are inherited by a child created via *fork()*,
    and they are preserved across an *exec()*.
  prefs: []
  type: TYPE_NORMAL
- en: The *sched_setparam()* system call provides a subset of the functionality of
    *sched_setscheduler()*. It modifies the scheduling priority of a process while
    leaving the policy unchanged.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Returns 0 on success, or -1 on error
  prefs: []
  type: TYPE_NORMAL
- en: The *pid* and *param* arguments are the same as for *sched_setscheduler()*.
  prefs: []
  type: TYPE_NORMAL
- en: A successful *sched_setparam()* call moves the process specified by *pid* to
    the back of the queue for its priority level.
  prefs: []
  type: TYPE_NORMAL
- en: The program in [Example 35-2](ch35.html#modifying_process_scheduling_policies_an
    "Example 35-2. Modifying process scheduling policies and priorities") uses *sched_setscheduler()*
    to set the policy and priority of the processes specified by its command-line
    arguments. The first argument is a letter specifying a scheduling policy, the
    second is an integer priority, and the remaining arguments are the process IDs
    of the processes whose scheduling attributes are to be changed.
  prefs: []
  type: TYPE_NORMAL
- en: Example 35-2. Modifying process scheduling policies and priorities
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Privileges and resource limits affecting changes to scheduling parameters
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In kernels before 2.6.12, a process generally must be privileged (`CAP_SYS_NICE`)
    to make changes to scheduling policies and priorities. The one exception to this
    requirement is that an unprivileged process can change the scheduling policy of
    a process to `SCHED_OTHER` if the effective user ID of the caller matches either
    the real or effective user ID of the target process.
  prefs: []
  type: TYPE_NORMAL
- en: 'Since kernel 2.6.12, the rules about setting realtime scheduling policies and
    priorities have changed with the introduction of a new, nonstandard resource limit,
    `RLIMIT_RTPRIO`. As with older kernels, privileged (`CAP_SYS_NICE`) processes
    can make arbitrary changes to the scheduling policy and priority of any process.
    However, an unprivileged process can also change scheduling policies and priorities,
    according to the following rules:'
  prefs: []
  type: TYPE_NORMAL
- en: If the process has a nonzero `RLIMIT_RTPRIO` soft limit, then it can make arbitrary
    changes to its scheduling policy and priority, subject to the constraint that
    the upper limit on the realtime priority that it may set is the maximum of its
    current realtime priority (if the process is currently operating under a realtime
    policy) and the value of its `RLIMIT_RTPRIO` soft limit.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the value of a process’s `RLIMIT_RTPRIO` soft limit is 0, then the only change
    that it can make is to lower its realtime scheduling priority or to switch from
    a realtime policy to a nonrealtime policy.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `SCHED_IDLE` policy is special. A process that is operating under this policy
    can’t make any changes to its policy, regardless of the value of the `RLIMIT_RTPRIO`
    resource limit.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Policy and priority changes can also be performed from another unprivileged
    process, as long as the effective user ID of that process matches either the real
    or effective user ID of the target process.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A process’s soft `RLIMIT_RTPRIO` limit determines only what changes can be made
    to its own scheduling policy and priority, either by the process itself or by
    another unprivileged process. A nonzero limit doesn’t give an unprivileged process
    the ability to change the scheduling policy and priority of other processes.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Starting with kernel 2.6.25, Linux adds the concept of realtime scheduling groups,
    configurable via the `CONFIG_RT_GROUP_SCHED` kernel option, which also affect
    the changes that can be made when setting realtime scheduling policies. See the
    kernel source file `Documentation/scheduler/sched-rt-group.txt` for details.
  prefs: []
  type: TYPE_NORMAL
- en: Retrieving scheduling policies and priorities
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The *sched_getscheduler()* and *sched_getparam()* system calls retrieve the
    scheduling policy and priority of a process.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Returns scheduling policy, or -1 on error
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Returns 0 on success, or -1 on error
  prefs: []
  type: TYPE_NORMAL
- en: For both of these system calls, *pid* specifies the ID of the process about
    which information is to be retrieved. If *pid* is 0, information is retrieved
    about the calling process. Both system calls can be used by an unprivileged process
    to retrieve information about any process, regardless of credentials.
  prefs: []
  type: TYPE_NORMAL
- en: The *sched_getparam()* system call returns the realtime priority of the specified
    process in the *sched_priority* field of the *sched_param* structure pointed to
    by *param*.
  prefs: []
  type: TYPE_NORMAL
- en: Upon successful execution, *sched_getscheduler()* returns one of the policies
    shown earlier in [Table 35-1](ch35.html#linux_realtime_and_nonrealtime_schedulin
    "Table 35-1. Linux realtime and nonrealtime scheduling policies").
  prefs: []
  type: TYPE_NORMAL
- en: 'The program in [Example 35-3](ch35.html#retrieving_process_scheduling_policies_a
    "Example 35-3. Retrieving process scheduling policies and priorities") uses *sched_getscheduler()*
    and *sched_getparam()* to retrieve the policy and priority of all of the processes
    whose process IDs are given as command-line arguments. The following shell session
    demonstrates the use of this program, as well as the program in [Example 35-2](ch35.html#modifying_process_scheduling_policies_an
    "Example 35-2. Modifying process scheduling policies and priorities"):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Example 35-3. Retrieving process scheduling policies and priorities
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Preventing realtime processes from locking up the system
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Since `SCHED_RR` and `SCHED_FIFO` processes preempt any lower-priority processes
    (e.g., the shell under which the program is run), when developing applications
    that use these policies, we need to be aware of the possibility that a runaway
    realtime process could lock up the system by hogging the CPU. Programmatically,
    there are a few of ways to avoid this possibility:'
  prefs: []
  type: TYPE_NORMAL
- en: Establish a suitably low soft CPU time resource limit (`RLIMIT_CPU`, described
    in [Details of Specific Resource Limits](ch36.html#details_of_specific_resource_limits
    "Details of Specific Resource Limits")) using *setrlimit()*. If the process consumes
    too much CPU time, it will be sent a `SIGXCPU` signal, which kills the process
    by default.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Set an alarm timer using *alarm()*. If the process continues running for a wall
    clock time that exceeds the number of seconds specified in the *alarm()* call,
    then it will be killed by a `SIGALRM` signal.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Create a watchdog process that runs with a high realtime priority. This process
    can loop repeatedly, sleeping for a specified interval, and then waking and monitoring
    the status of other processes. Such monitoring could include measuring the value
    of the CPU time clock for each process (see the discussion of the *clock_getcpuclockid()*
    function in [Obtaining the Clock ID of a Specific Process or Thread](ch23.html#obtaining_the_clock_id_of_a_specific_pro
    "Obtaining the Clock ID of a Specific Process or Thread")) and checking its scheduling
    policy and priority using *sched_getscheduler()* and *sched_getparam()*. If a
    process is deemed to be misbehaving, the watchdog thread could lower the process’s
    priority, or stop or terminate it by sending an appropriate signal.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Since kernel 2.6.25, Linux provides a nonstandard resource limit, `RLIMIT_RTTIME`,
    for controlling the amount of CPU time that can be consumed in a single burst
    by a process running under a realtime scheduling policy. Specified in microseconds,
    `RLIMIT_RTTIME` limits the amount of CPU time that the process may consume without
    performing a system call that blocks. When the process does perform such a call,
    the count of consumed CPU time is reset to 0\. The count of consumed CPU time
    is not reset if the process is preempted by a higher-priority process, is scheduled
    off the CPU because its time slice expired (for a `SCHED_RR` process), or calls
    *sched_yield()* ([Relinquishing the CPU](ch35.html#relinquishing_the_cpu "Relinquishing
    the CPU")). If the process reaches its limit of CPU time, then, as with `RLIMIT_CPU`,
    it will be sent a `SIGXCPU` signal, which kills the process by default.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The changes in kernel 2.6.25 can also help prevent runaway realtime processes
    from locking up the system. For details, see the kernel source file `Documentation/scheduler/sched-rt-group.txt`.
  prefs: []
  type: TYPE_NORMAL
- en: Preventing child processes from inheriting privileged scheduling policies
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Linux 2.6.32 added `SCHED_RESET_ON_FORK` as a value that can be specified in
    *policy* when calling *sched_setscheduler()*. This is a flag value that is ORed
    with one of the policies in [Table 35-1](ch35.html#linux_realtime_and_nonrealtime_schedulin
    "Table 35-1. Linux realtime and nonrealtime scheduling policies"). If this flag
    is set, then children that are created by this process using *fork()* do not inherit
    privileged scheduling policies and priorities. The rules are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: If the calling process has a realtime scheduling policy (`SCHED_RR` or `SCHED_FIFO`),
    then the policy in child processes is reset to the standard round-robin time-sharing
    policy, `SCHED_OTHER`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the process has a negative (i.e., high) nice value, then the nice value in
    child processes is reset to 0.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `SCHED_RESET_ON_FORK` flag was designed to be used in media-playback applications.
    It permits the creation of single processes that have realtime scheduling policies
    that can’t be passed to child processes. Using the `SCHED_RESET_ON_FORK` flag
    prevents the creation of fork bombs that try to evade the ceiling set by the `RLIMIT_RTTIME`
    resource limit by creating multiple children running under realtime scheduling
    policies.
  prefs: []
  type: TYPE_NORMAL
- en: Once the `SCHED_RESET_ON_FORK` flag has been enabled for a process, only a privileged
    process (`CAP_SYS_NICE`) can disable it. When a child process is created, its
    reset-on-fork flag is disabled.
  prefs: []
  type: TYPE_NORMAL
- en: Relinquishing the CPU
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'A realtime process may voluntarily relinquish the CPU in two ways: by invoking
    a system call that blocks the process (e.g., a *read()* from a terminal) or by
    calling *sched_yield()*.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Returns 0 on success, or -1 on error
  prefs: []
  type: TYPE_NORMAL
- en: The operation of *sched_yield()* is simple. If there are any other queued runnable
    processes at the same priority level as the calling process, then the calling
    process is placed at the back of the queue, and the process at the head of the
    queue is scheduled to use the CPU. If no other runnable processes are queued at
    this priority, then *sched_yield()* does nothing; the calling process simply continues
    using the CPU.
  prefs: []
  type: TYPE_NORMAL
- en: Although SUSv3 permits a possible error return from *sched_yield()*, this system
    call always succeeds on Linux, as well as on many other UNIX implementations.
    Portable applications should nevertheless always check for an error return.
  prefs: []
  type: TYPE_NORMAL
- en: The use of *sched_yield()* for nonrealtime processes is undefined.
  prefs: []
  type: TYPE_NORMAL
- en: The `SCHED_RR` Time Slice
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The *sched_rr_get_interval()* system call enables us to find out the length
    of the time slice allocated to a `SCHED_RR` process each time it is granted use
    of the CPU.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Returns 0 on success, or -1 on error
  prefs: []
  type: TYPE_NORMAL
- en: 'As with the other process scheduling system calls, *pid* identifies the process
    about which we want to obtain information, and specifying *pid* as 0 means the
    calling process. The time slice is returned in the *timespec* structure pointed
    to by *tp*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: On recent 2.6 kernels, the realtime round-robin time slice is 0.1 seconds.
  prefs: []
  type: TYPE_NORMAL
- en: CPU Affinity
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When a process is rescheduled to run on a multiprocessor system, it doesn’t
    necessarily run on the same CPU on which it last executed. The usual reason it
    may run on another CPU is that the original CPU is already busy.
  prefs: []
  type: TYPE_NORMAL
- en: 'When a process changes CPUs, there is a performance impact: in order for a
    line of the process’s data to be loaded into the cache of the new CPU, it must
    first be invalidated (i.e., either discarded if it is unmodified, or flushed to
    main memory if it was modified), if present in the cache of the old CPU. (To prevent
    cache inconsistencies, multiprocessor architectures allow data to be kept in only
    one CPU cache at a time.) This invalidation costs execution time. Because of this
    performance impact, the Linux (2.6) kernel tries to ensure *soft* CPU affinity
    for a process—wherever possible, the process is rescheduled to run on the same
    CPU.'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A *cache line* is the cache analog of a page in a virtual memory management
    system. It is the size of the unit used for transfers between the CPU cache and
    main memory. Typical line sizes range from 32 to 128 bytes. For further information,
    see [Schimmel, 1994] and [Drepper, 2007].
  prefs: []
  type: TYPE_NORMAL
- en: One of the fields in the Linux-specific `/proc/`*PID*`/stat` file displays the
    number of the CPU on which a process is currently executing or last executed.
    See the *proc(5)* manual page for details.
  prefs: []
  type: TYPE_NORMAL
- en: 'Sometimes, it is desirable to set *hard* CPU affinity for a process, so that
    it is explicitly restricted to always running on one, or a subset, of the available
    CPUs. Among the reasons we may want to do this are the following:'
  prefs: []
  type: TYPE_NORMAL
- en: We can avoid the performance impacts caused by invalidation of cached data.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If multiple threads (or processes) are accessing the same data, then we may
    obtain performance benefits by confining them all to the same CPU, so that they
    don’t contend for the data and thus cause cache misses.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For a time-critical application, it may be desirable to confine most processes
    on the system to other CPUs, while reserving one or more CPUs for the time-critical
    application.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The *isolcpus* kernel boot option can be used to isolate one or more CPUs from
    the normal kernel scheduling algorithms. The only way to move a process on or
    off a CPU that has been isolated is via the CPU affinity system calls described
    in this section. The *isolcpus* boot option is the preferred method of implementing
    the last of the scenarios listed above. For details, see the kernel source file
    `Documentation/kernel-parameters.txt`.
  prefs: []
  type: TYPE_NORMAL
- en: Linux also provides a *cpuset* kernel option, which can be used on systems containing
    large numbers of CPUs to achieve more sophisticated control over how the CPUs
    and memory are allocated to processes. For details, see the kernel source file
    `Documentation/cpusets.txt`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Linux 2.6 provides a pair of nonstandard system calls to modify and retrieve
    the hard CPU affinity of a process: *sched_setaffinity()* and *sched_getaffinity()*.'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Many other UNIX implementations provide interfaces for controlling CPU affinity.
    For example, HP-UX and Solaris provide a *pset_bind()* system call.
  prefs: []
  type: TYPE_NORMAL
- en: The *sched_setaffinity()* system call sets the CPU affinity of the process specified
    by *pid*. If *pid* is 0, the CPU affinity of the calling process is changed.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Returns 0 on success, or -1 on error
  prefs: []
  type: TYPE_NORMAL
- en: The CPU affinity to be assigned to the process is specified in the *cpu_set_t*
    structure pointed to by *set*.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: CPU affinity is actually a per-thread attribute that can be adjusted independently
    for each of the threads in a thread group. If we want to change the CPU affinity
    of a specific thread in a multithreaded process, we can specify *pid* as the value
    returned by a call to *gettid()* in that thread. Specifying *pid* as 0 means the
    calling thread.
  prefs: []
  type: TYPE_NORMAL
- en: Although the *cpu_set_t* data type is implemented as a bit mask, we should treat
    it as an opaque structure. All manipulations of the structure should be done using
    the macros `CPU_ZERO()`, `CPU_SET()`, `CPU_CLR()`, and `CPU_ISSET()`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Returns true (1) if *cpu* is in *set*, or false (0) otherwise
  prefs: []
  type: TYPE_NORMAL
- en: 'These macros operate on the CPU set pointed to by *set* as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`CPU_ZERO()` initializes *set* to be empty.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`CPU_SET()` adds the CPU *cpu* to *set*.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`CPU_CLR()` removes the CPU *cpu* from *set*.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`CPU_ISSET()` returns true if the CPU *cpu* is a member of *set*.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The GNU C library also provides a number of other macros for working with CPU
    sets. See the *CPU_SET(3)* manual page for details.
  prefs: []
  type: TYPE_NORMAL
- en: The CPUs in a CPU set are numbered starting at 0\. The `<sched.h>` header file
    defines the constant `CPU_SETSIZE` to be one greater than the maximum CPU number
    that can be represented in a *cpu_set_t* variable. `CPU_SETSIZE` has the value
    1024.
  prefs: []
  type: TYPE_NORMAL
- en: The *len* argument given to *sched_setaffinity()* should specify the number
    of bytes in the *set* argument (i.e., *sizeof(cpu_set_t)*).
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code confines the process identified by *pid* to running on any
    CPU other than the first CPU of a four-processor system:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: If the CPUs specified in *set* don’t correspond to any CPUs on the system, then
    *sched_setaffinity()* fails with the error `EINVAL`.
  prefs: []
  type: TYPE_NORMAL
- en: If *set* doesn’t include the CPU on which the calling process is currently running,
    then the process is migrated to one of the CPUs in *set*.
  prefs: []
  type: TYPE_NORMAL
- en: An unprivileged process may set the CPU affinity of another process only if
    its effective user ID matches the real or effective user ID of the target process.
    A privileged (`CAP_SYS_NICE`) process may set the CPU affinity of any process.
  prefs: []
  type: TYPE_NORMAL
- en: The *sched_getaffinity()* system call retrieves the CPU affinity mask of the
    process specified by *pid*. If *pid* is 0, the CPU affinity mask of the calling
    process is returned.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Returns 0 on success, or -1 on error
  prefs: []
  type: TYPE_NORMAL
- en: The CPU affinity mask is returned in the *cpu_set_t* structure pointed to by
    *set*. The *len* argument should be set to indicate the number of bytes in this
    structure (i.e., *sizeof(cpu_set_t)*). We can use the `CPU_ISSET()` macro to determine
    which CPUs are in the returned *set*.
  prefs: []
  type: TYPE_NORMAL
- en: If the CPU affinity mask of the target process has not otherwise been modified,
    *sched_getaffinity()* returns a set containing all of the CPUs on the system.
  prefs: []
  type: TYPE_NORMAL
- en: No permission checking is performed by *sched_getaffinity()*; an unprivileged
    process can retrieve the CPU affinity mask of any process on the system.
  prefs: []
  type: TYPE_NORMAL
- en: A child process created by *fork()* inherits its parent’s CPU affinity mask,
    and this mask is preserved across an *exec()*.
  prefs: []
  type: TYPE_NORMAL
- en: The *sched_setaffinity()* and *sched_getaffinity()* system calls are Linux-specific.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `t_sched_setaffinity.c` and `t_sched_getaffinity.c` programs in the `procpri`
    subdirectory in the source code distribution for this book demonstrate the use
    of *sched_setaffinity()* and *sched_getaffinity()*.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The default kernel scheduling algorithm employs a round-robin time-sharing policy.
    By default, all processes have equal access to the CPU under this policy, but
    we can set a process’s nice value to a number in the range -20 (high priority)
    to +19 (low priority) to cause the scheduler to favor or disfavor that process.
    However, even if we give a process the lowest priority, it is not completely starved
    of the CPU.
  prefs: []
  type: TYPE_NORMAL
- en: Linux also implements the POSIX realtime scheduling extensions. These allow
    an application to precisely control the allocation of the CPU to processes. Processes
    operating under the two realtime scheduling policies, `SCHED_RR` (round-robin)
    and `SCHED_FIFO` (first-in, first-out), always have priority over processes operating
    under nonrealtime policies. Realtime processes have priorities in the range 1
    (low) to 99 (high). As long as it is runnable, a higher-priority process completely
    excludes lower-priority processes from the CPU. A process operating under the
    `SCHED_FIFO` policy maintains exclusive access to the CPU until either it terminates,
    it voluntarily relinquishes the CPU, or it is preempted because a higher-priority
    process became runnable. Similar rules apply to the `SCHED_RR` policy, with the
    addition that if multiple processes are running at the same priority, then the
    CPU is shared among these processes in a round-robin fashion.
  prefs: []
  type: TYPE_NORMAL
- en: A process’s CPU affinity mask can be used to restrict the process to running
    on a subset of the CPUs available on a multiprocessor system. This can improve
    the performance of certain types of applications.
  prefs: []
  type: TYPE_NORMAL
- en: Further information
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '[Love, 2010] provides background detail on process priorities and scheduling
    on Linux. [Gallmeister, 1995] provides further information about the POSIX realtime
    scheduling API. Although targeted at POSIX threads, much of the discussion of
    the realtime scheduling API in [Butenhof, 1996] is useful background to the realtime
    scheduling discussion in this chapter.'
  prefs: []
  type: TYPE_NORMAL
- en: For further information about CPU affinity and controlling the allocation of
    threads to CPUs and memory nodes on multiprocessor systems, see the kernel source
    file `Documentation/cpusets.txt`, and the *mbind(2)*, *set_mempolicy(2)*, and
    *cpuset(7)* manual pages.
  prefs: []
  type: TYPE_NORMAL
- en: Exercises
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Implement the *nice(1)* command.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Write a set-user-ID-*root* program that is the realtime scheduling analog of
    *nice(1)*. The command-line interface of this program should be as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In the above command, *policy* is *r* for `SCHED_RR` or *f* for `SCHED_FIFO`.
    This program should drop its privileged ID before execing the command, for the
    reasons described in [Retrieving and Modifying Real, Effective, and Saved Set
    IDs](ch09.html#retrieving_and_modifying_real_comma_effe "Retrieving and Modifying
    Real, Effective, and Saved Set IDs") and [Be Careful When Executing a Program](ch38.html#be_careful_when_executing_a_program
    "Be Careful When Executing a Program").
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Write a program that places itself under the `SCHED_FIFO` scheduling policy
    and then creates a child process. Both processes should execute a function that
    causes the process to consume a maximum of 3 seconds of CPU time. (This can be
    done by using a loop in which the *times()* system call is repeatedly called to
    determine the amount of CPU time so far consumed.) After each quarter of a second
    of consumed CPU time, the function should print a message that displays the process
    ID and the amount of CPU time so far consumed. After each second of consumed CPU
    time, the function should call *sched_yield()* to yield the CPU to the other process.
    (Alternatively, the processes could raise each other’s scheduling priority using
    *sched_setparam()*.) The program’s output should demonstrate that the two processes
    alternately execute for 1 second of CPU time. (Note carefully the advice given
    in [Modifying and Retrieving Policies and Priorities](ch35.html#modifying_and_retrieving_policies_and_pr
    "Modifying and Retrieving Policies and Priorities") about preventing a runaway
    realtime process from hogging the CPU.)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If two processes use a pipe to exchange a large amount of data on a multiprocessor
    system, the communication should be faster if the processes run on the same CPU
    than if they run on different CPUs. The reason is that when the two processes
    run on the same CPU, the pipe data will be more quickly accessed because it can
    remain in that CPU’s cache. By contrast, when the processes run on separate CPUs,
    the benefits of the CPU cache are lost. If you have access to a multiprocessor
    system, write a program that uses *sched_setaffinity()* to demonstrate this effect,
    by forcing the processes either onto the same CPUs or onto different CPUs. ([Chapter 44](ch44.html
    "Chapter 44. Pipes and FIFOs") describes the use of pipes.)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The advantage in favor of processes running on the same CPU won’t hold true
    on hyperthreaded systems and on some modern multiprocessor architectures where
    the CPUs do share the cache. In these cases, the advantage will be in favor of
    processes running on different CPUs. Information about the CPU topology of a multiprocessor
    system can be obtained by inspecting the contents of the Linux-specific `/proc/cpuinfo`
    file.
  prefs: []
  type: TYPE_NORMAL
