- en: <hgroup>
  prefs: []
  type: TYPE_NORMAL
- en: 1 KOTLIN BASICS
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: </hgroup>
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/icon.jpg)'
  prefs: []
  type: TYPE_IMG
- en: This chapter will guide you through the fundamental building blocks of the Kotlin
    programming language. We’ll explore essential language features such as comments,
    variables, operators, flow control structures, functions (including lambda expressions),
    and basic input and output techniques.
  prefs: []
  type: TYPE_NORMAL
- en: Together, these elements allow you to manage and manipulate data within your
    code, govern the program’s behavior so that it responds dynamically to different
    scenarios, and keep your code well organized and easy to maintain. Understanding
    these basic elements will also pave the way for the more sophisticated language
    features discussed in [Chapter 2](chapter2.xhtml), such as arrays, collections,
    and custom data structures (including classes).
  prefs: []
  type: TYPE_NORMAL
- en: The topics covered here are core elements in any programming language, serving
    as the foundational elements for application development. If you’ve already worked
    with another language, these elements will look familiar in Kotlin. Conversely,
    if Kotlin is your first language, what you learn here will be readily transferable
    to other languages. We’ll explore these components in a practical way, with short
    code snippets illustrating each new idea. At the end of the chapter, we’ll tie
    everything together with a simple project.
  prefs: []
  type: TYPE_NORMAL
- en: I’m assuming you’re using the free version of IntelliJ IDEA as your integrated
    development environment (IDE) for developing and running code. See the appendix
    for instructions on installing, setting up, and using this tool with a basic “Hello,
    world!” program.
  prefs: []
  type: TYPE_NORMAL
- en: Using Comments
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A *comment* is a line (or several lines) of explanatory text in a code file
    that the compiler will ignore when it runs the code. The text is meant to provide
    helpful hints, such as what the next code segment does, why a particular method
    was chosen, or how to properly use a language feature in a code segment. When
    you’re coding, you should insert comments to remind yourself what each piece of
    code is about. Experienced coders know that documenting code is essential to guard
    against forgetting important details down the road. Also, when others use or build
    on your code, your comments can be a lifesaver.
  prefs: []
  type: TYPE_NORMAL
- en: 'In Kotlin, you have two main ways to add comments. The first is to use // to
    start a single-line comment. The compiler will ignore anything on the line after
    the two slashes. The other way is to use /* and */ to start and end a comment
    that spans multiple lines. Here’s an example of how these two commenting styles
    work:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Kotlin also provides a third type of comment, which is used for automatically
    generating documentation. This sort of comment begins with /** and ends with */.
    Documentation comments are used to describe variables, functions, and classes
    more formally, and they often include tags such as @param, @return, and @throws
    to explain standard aspects of a piece of code. Here’s an example that compares
    multiline and documentation comments:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: While these two types of comments use a similar syntax, they serve different
    purposes. Multiline comments are intended to be read within the code file itself.
    Documentation comments, on the other hand, are intended to be exported from the
    code file to generate official documentation for production-ready code that other
    developers can consult.
  prefs: []
  type: TYPE_NORMAL
- en: Variables
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In coding, a *variable* is a name given to a data element. For simplicity, we
    can think of variables as containers that hold various data types in a computer’s
    memory. Once assigned, the variable name can be used as a stand-in for the value
    it represents. In this way, variables allow us to store and manage data, enabling
    the persistence of information within a program.
  prefs: []
  type: TYPE_NORMAL
- en: Every variable should have a meaningful name that clearly describes its purpose
    or function or otherwise reflects the nature of the data assigned to it. For example,
    a variable holding a person’s name could be called name, and a variable holding
    a person’s age could be called age. By convention, variable names should consist
    of a lowercase word or use *camelCase* to join multiple words. In the latter case,
    no spaces appear between words, and every word after the first starts with a capital
    letter, as in lastName or ageInYears.
  prefs: []
  type: TYPE_NORMAL
- en: In Kotlin, you create a new variable by *declaring* its name with a keyword
    such as val or var and *initializing* it (assigning it to a value). (A *keyword*
    is a reserved word that has a special meaning in a programming language. A keyword
    can’t be used as an identifier—for example, as a variable or function name.) Which
    keyword you use depends on whether you want the variable’s value to stay the same
    or change during program execution. A variable declared with val is *read-only*,
    meaning its value can’t change after it’s been initialized. A variable declared
    with var is *mutable*, meaning the variable can be assigned a different value
    after it’s been initialized. You can change the value of a mutable variable as
    many times as needed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider this example, where we use two variables to create a message:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'We declare two variables, name and age, and assign them the values "John Sinclair"
    and 30, respectively. Both variables are declared with the val keyword, so they
    can’t be reassigned to different values later. We then include both variables
    in a message to be printed to the console by adding a dollar sign ($) before each
    variable name. (We’ll discuss how this syntax works in more detail in “Working
    with Strings” on [page 14](#pg_14).) If you run this code (using CTRL-SHIFT-F10
    in IntelliJ IDEA), the output should look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Notice how the output shows the values assigned to the name and age variables
    rather than the variable names themselves. But what if we want to assign new values
    to these variables over the course of the program? For that, we have to use the
    var keyword instead of val, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Here we declare the name and age variables with the var keyword, giving them
    the same initial values as before. Then we assign them new values ❶. Notice that
    the second time around, we no longer need the var (or val) keyword when setting
    the values of the variables. Once we’ve declared and initialized a variable for
    the first time, we can work with the variable using only its name.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you now run the program, this is what you should see:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: We’ve successfully reassigned the variable names because they were declared
    with the var keyword. Try changing the var keyword back to val for one or both
    variables and running the code again. The IDE will instantly generate an error
    message about how you can’t assign a new value to a variable declared with val,
    and it won’t let you run the program until you fix the error.
  prefs: []
  type: TYPE_NORMAL
- en: Constants
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Kotlin also provides the const keyword (short for *constant*) for setting the
    immutable value of a variable at the beginning of a file. The value must be known
    during compilation of the code. Declaring a variable with const is allowed only
    for primitive types or strings. (We discuss the common data types in Kotlin in
    the next section.) The judicious use of constants has two important benefits:
    it improves program efficiency in accessing fixed values, and it improves code
    clarity by avoiding hardcoded “magic numbers” deep inside the code without clear
    context. Here’s an example of creating a variable with the const keyword:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: In this case, we know the value of the mathematical constant pi, and we know
    that this value won’t change over the course of a program, so it makes sense to
    declare it using the const keyword at the start of the program. In Kotlin, it’s
    customary to use all caps for top-level constant names, as we’ve done here for
    PI. Multiple words can be joined using an underscore.
  prefs: []
  type: TYPE_NORMAL
- en: Kotlin has many other naming conventions for various code constructs. [Table
    1-1](chapter1.xhtml#tab1-1) summarizes the most common ones.
  prefs: []
  type: TYPE_NORMAL
- en: 'Table 1-1: Naming Conventions in Kotlin'
  prefs: []
  type: TYPE_NORMAL
- en: '| Name | Convention | Example |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| Package name | Use lowercase letters with no underscores.Join multiple words
    or use camelCase.Use reverse domain notation (autogenerated by the IDE). | org.example.myProject
    |'
  prefs: []
  type: TYPE_TB
- en: '| Class name | Use PascalCase for class and inheritance names.Choose words
    that are nouns or noun phrases. | FlightSimulation |'
  prefs: []
  type: TYPE_TB
- en: '| Function name | Use camelCase for function and method names.Use verbs or
    verb phrases. | calculateShortestPath() |'
  prefs: []
  type: TYPE_TB
- en: '| Variable name | Use a single word or camelCase to join multiple words.Choose
    a word that describes the purpose, function, or property of the variable (make
    it meaningful). | username |'
  prefs: []
  type: TYPE_TB
- en: '| Constant and final variable name | Use uppercase letters with underscores
    to separate words. | MAX_VALUE |'
  prefs: []
  type: TYPE_TB
- en: These naming conventions are based on the recommendations in the official Kotlin
    documentation at [https://kotlinlang.org](https://kotlinlang.org). We’ll revisit
    them as we discuss the code constructs they relate to.
  prefs: []
  type: TYPE_NORMAL
- en: Common Data Types
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: A value in code can be of various *data types*. For example, a value might represent
    a number, some text, or a logical value (true or false). In Kotlin, each variable
    is associated with a specific data type, and once a variable’s data type has been
    set, it can’t hold values of other types. A variable with a numeric value can
    be associated with different types, such as Int for whole numbers only or Double
    or Float for numbers with decimal components. A variable holding text values can
    be of type Char for a single character or type String for multiple characters.
    A logical value will have a Boolean type. [Table 1-2](chapter1.xhtml#tab1-2) lists
    the common data types in Kotlin and their key characteristics.
  prefs: []
  type: TYPE_NORMAL
- en: 'Table 1-2: Common Kotlin Data Types'
  prefs: []
  type: TYPE_NORMAL
- en: '| Data type | Description | Size (in bits) | Range of values |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| Byte | Signed integer | 8 | –128 to 127 |'
  prefs: []
  type: TYPE_TB
- en: '| Short | Signed integer | 16 | –32,768 to 32,767 |'
  prefs: []
  type: TYPE_TB
- en: '| Int | Signed integer | 32 | –2,147,483,648 to 2,147,483,647 |'
  prefs: []
  type: TYPE_TB
- en: '| Long | Signed integer | 64 | –9,223,372,036,854,775,808 to 9,223,372,036,854,775,807
    |'
  prefs: []
  type: TYPE_TB
- en: '| Float | Floating point (single precision) | 32 | –3.4028235E+38 to 3.4028235E+38
    |'
  prefs: []
  type: TYPE_TB
- en: '| Double | Floating point (double precision) | 64 | –1.7976931348623157E+308
    to 1.7976931348623157E+308 |'
  prefs: []
  type: TYPE_TB
- en: '| Char | 16-bit Unicode character | 16 | 0 to 65,535 (in decimal) |'
  prefs: []
  type: TYPE_TB
- en: '| Boolean | Represents true or false | 1 | true or false |'
  prefs: []
  type: TYPE_TB
- en: '| String | A sequence of characters | Varies | N/A |'
  prefs: []
  type: TYPE_TB
- en: We choose the data type for a variable based on problem-specific needs, focusing
    on factors such as the data type’s ability to accommodate values, its level of
    precision, and its memory utilization. If you know a numeric variable will hold
    only integer values, for example, Int would be a better choice than Float. If
    those values need to be exceptionally large, Long would be more appropriate than
    Int.
  prefs: []
  type: TYPE_NORMAL
- en: Type Inference
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'When declaring a variable in Kotlin, it isn’t mandatory to explicitly specify
    its data type. The Kotlin compiler excels at *inferring* the variable’s data type
    based on the assigned value. Here, for example, Kotlin infers that name is of
    type String, since its value is a series of characters enclosed in quotation marks:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'You also have the option to explicitly declare a variable’s data type. Here’s
    how to explicitly declare name as a String:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: To declare the data type, we place a colon after the variable name, followed
    by the desired type. This can be any acceptable data type, including custom data
    types you might have created to represent complex structures with specific properties
    and behaviors (for example, classes or data classes, which we’ll discuss in [Chapter
    2](chapter2.xhtml)).
  prefs: []
  type: TYPE_NORMAL
- en: 'For numeric values, Kotlin infers the Int type if a variable is first assigned
    a whole-number value or the Double type if it’s assigned a value with a decimal
    component. If you need a different numeric type, you can explicitly indicate it
    by using a type suffix at the end of the value itself, such as L for Long and
    f for Float. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: In this code, regularInt is inferred as Int by default, while floatNumber and
    longNumber are explicitly declared to be of types Float and Long, respectively,
    using the f and L suffixes.
  prefs: []
  type: TYPE_NORMAL
- en: Type Casting
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '*Type casting*, also known as *type conversion*, is the process of changing
    a variable’s or expression’s data type to another compatible data type. (An *expression*
    is a code snippet that evaluates to a particular data type.) This process is primarily
    used to resolve type mismatches. In general, Kotlin enforces strict type checking
    to prevent common sources of runtime errors, such as unintended type conversions.
    Implicit type casting may be allowed only when no risk of data loss or unexpected
    behavior exists. For example, smaller numeric types can be implicitly promoted
    to larger numeric types since no risk of data loss exists, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'We take the value of the intNumber variable and assign it to the longNumber
    variable, implicitly converting the value from type Int to Long. This may work,
    but the default setting of most IDEs is to prevent the use of implicit type casting
    altogether. Instead, you’re encouraged to use explicit type-casting methods to
    achieve type conversion. Some of the common type-casting methods supported in
    Kotlin include toByte(), toInt(), toLong(), toShort(), toDouble(), toFloat(),
    toChar(), and toString(). Here is an example of explicit type casting:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: We first create the intNumber variable and assign it a value of 44. The compiler
    will infer intNumber to be of the Int type. Then we explicitly cast it to type
    Double using the toDouble() method before assigning it to doubleNumber.
  prefs: []
  type: TYPE_NORMAL
- en: 'Since type casting is allowed only when the associated data types are compatible,
    not all conversions are possible. For example, you can’t always convert a text
    type into a numeric or logical type. To illustrate, try running the following
    lines of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Here we try to take the string in the message variable and cast it to an integer
    with the toInt() method. This will throw a NumberFormatException error at runtime,
    indicating the conversion isn’t possible due to the incompatible data types. This
    error seems reasonable: How should Kotlin know the numeric equivalent of the "Hello,
    world!" string?'
  prefs: []
  type: TYPE_NORMAL
- en: Operators
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*Operators* are special symbols for manipulating variables and other values
    in your code. Each operator performs a specific mathematical, logical, or text-based
    operation. In this section, we’ll review the most common categories of operators
    in Kotlin.'
  prefs: []
  type: TYPE_NORMAL
- en: Arithmetic
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Arithmetic operators are for performing basic mathematical operations such
    as addition (+), subtraction (-), multiplication (*), and division (/). Here are
    some examples of how to use arithmetic operators in Kotlin:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Here we apply the four main arithmetic operations to the a and b variables.
    Notice that when you divide two integers using the division operator /, the result
    is also an integer, with any fractional part discarded. In this case, 20 / 7 gives
    a result of 2, not 2.857143. If you need to retain the fractional part, you must
    convert one of the numbers into a floating-point number, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Here, quotientInt will have a value of 2, but quotientFloat will have a value
    of 2.857143 since we use toFloat() to convert a from an integer to a floating-point
    number.
  prefs: []
  type: TYPE_NORMAL
- en: 'The *remainder* or *modulo* operator is another mathematical operator we’ll
    use many times in this book. It’s designated by the % symbol. This operator returns
    only the remainder from the integer division of two numbers. Here’s an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: In this example, a % b returns the remainder when a is divided by b. Since 20
    divided by 7 has a remainder of 6, the value of result is 6. Can you guess what
    the result would be if we flipped the numbers around—that is, if we calculated
    7 % 20? Additionally, what would be the result of the integer division 7 / 20?
    These questions may sound trivial, but I encourage you to write a few lines of
    code to verify your guesses.
  prefs: []
  type: TYPE_NORMAL
- en: 'Kotlin uses the same order of operations for arithmetic operators as regular
    mathematics: division and multiplication take precedence over addition and subtraction.
    To avoid confusion about the order of operations, it’s good practice to use parentheses
    to clearly isolate different operational blocks. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: In the first calculation, 5 + 3 * 2, multiplication takes precedence over addition,
    so it evaluates to 5 + (3 * 2), resulting in 11. In the second calculation, (5
    + 3) * 2, the addition inside the parentheses is performed first, and then the
    multiplication, resulting in 16. This demonstrates how using parentheses can clarify
    and control the order of operations in mathematical expressions.
  prefs: []
  type: TYPE_NORMAL
- en: '#### Assignment'
  prefs: []
  type: TYPE_NORMAL
- en: 'Assignment operators are used to assign values to variables. We’ve already
    been using the main assignment operator (=) throughout this chapter’s examples
    to set a variable’s value from scratch. Other assignment operators, like += and
    -=, take a variable’s existing value and modify it. Here are some examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: The assignment a += 5 is equivalent to saying, “Take the value of a, add 5 to
    it, and put the result back in the a variable.” Similar assignment operators exist
    for the other three arithmetic operations.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can try using += with a string variable too, if it was declared with var.
    For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Be mindful that this operation essentially creates a new string and assigns
    it to the previously used variable name, rather than directly modifying the old
    string (which is discarded). For strings, other assignment operators (for example,
    -=) will generate errors.
  prefs: []
  type: TYPE_NORMAL
- en: Unary
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Whereas most operators have two operands, unary operators have just one. The
    *increment* (++) and *decrement* (--) unary operators increase or decrease a variable’s
    value by 1, respectively. Here’s how to use these operators in Kotlin:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Essentially, a++ is a shorter way of writing a += 1, itself a shorter way of
    writing a = a + 1. Likewise, a-- is equivalent to a -= 1.
  prefs: []
  type: TYPE_NORMAL
- en: Relational
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Relational operators compare two values and return a Boolean value (true or
    false) based on the comparison. These operators include == and != for equality
    and inequality, and > and < for greater than and less than. Here are some examples
    of these operators in action:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: In this code segment, isEqual will be false because a and b aren’t equal, and
    isNotEqual will be true. Meanwhile, isGreater will be true because a is greater
    than b, and isLesser will be false. Notice how we put each comparison in parentheses.
    This isn’t strictly necessary, but it helps visually separate the comparison from
    the assignment operation it’s a part of.
  prefs: []
  type: TYPE_NORMAL
- en: 'The preceding examples used numeric values, but relational operators can also
    be used for comparing strings:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: In Kotlin, strings are compared lexicographically, character by character, based
    on their Unicode values. The comparison starts from the first character of each
    string and continues until a difference is found or one of the strings ends. The
    string with the smaller Unicode value at the first differing character is considered
    lesser. This implies that earlier letters in the alphabet are considered lesser
    than later letters and that uppercase letters are considered lesser than lowercase
    letters.
  prefs: []
  type: TYPE_NORMAL
- en: Logical
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Logical operators are used to perform logical operations such as AND (&&),
    OR (||), and NOT (!) on Boolean values. Here are some examples of how to use logical
    operators in Kotlin:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: The result of a logical operation involving two Boolean values can be summarized
    in a *truth table* like the one shown in [Table 1-3](chapter1.xhtml#tab1-3). A
    truth table shows the output corresponding to every possible combination of input
    values.
  prefs: []
  type: TYPE_NORMAL
- en: 'Table 1-3: Truth Table for Two Logical Values'
  prefs: []
  type: TYPE_NORMAL
- en: '| Value 1 | Value 2 | AND | OR |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| true | true | true | true |'
  prefs: []
  type: TYPE_TB
- en: '| true | false | false | true |'
  prefs: []
  type: TYPE_TB
- en: '| false | true | false | true |'
  prefs: []
  type: TYPE_TB
- en: '| false | false | false | false |'
  prefs: []
  type: TYPE_TB
- en: In this table, the operands are Boolean values, which can be either true or
    false. For example, in the first row, both Value 1 and Value 2 are true. The result
    of an AND operation on these operands is true, and the result of an OR operation
    is also true. Unlike AND and OR, a NOT operation has just one Boolean operand,
    which gets inverted. For instance, the NOT operator turns true into false.
  prefs: []
  type: TYPE_NORMAL
- en: Working with Strings
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In Kotlin, a *string* is a sequence of characters represented by the String
    data type. Strings are helpful for storing and manipulating text data in a program.
    They’re commonly used to represent words, sentences, and other textual information.
    User input data is also initially read as strings and then converted as needed
    into other types using functions such as toInt(), toDouble(), and toBoolean().
  prefs: []
  type: TYPE_NORMAL
- en: The individual characters in a string are numbered, or *indexed*, starting from
    zero. You can access a specific character in a string by placing its index in
    square brackets after the variable name representing that string. For example,
    to get the second character of a string in the msg variable, use msg[1]. Alternatively,
    you can use the get() method of the String class to retrieve the character at
    a specific index. For example, msg.get(1) returns the same second character as
    msg[1].
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we’ll discuss some common techniques for working with strings.
    Keep in mind as you read that strings are immutable objects in Kotlin, so once
    a string is created, its content can’t be changed. Any operation that appears
    to modify a string creates a new string, and the original value is discarded.
  prefs: []
  type: TYPE_NORMAL
- en: Concatenation
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '*Concatenation* is the process of combining two or more strings into a single
    string. In Kotlin, you can do this in multiple ways. For example, you can use
    the + operator, or you can use a string’s plus() method. Both techniques are demonstrated
    here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'In this code segment, we first create two string variables, a and b, with values
    "Hello," and "world!", respectively. Then we use the + operator to concatenate
    (join) the two strings and add a space (the string " ") in between, assigning
    the resulting string to the c variable. The output of println(c) is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Notice how we call the plus() method twice in the same expression to concatenate
    string a with a space and string b. This technique is known as *method chaining*;
    the second method call is applied to the result of the first.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another way to join multiple strings is to use the buildString function, as
    in this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: We create a variable c to hold the concatenated string and append all the string
    segments through a single call to the buildString function.
  prefs: []
  type: TYPE_NORMAL
- en: String Templates
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Most characters that appear between the opening and closing quotation marks
    of a string are interpreted literally as ordinary text. *String templates*, however,
    are a powerful feature in Kotlin that allow you to embed code within a string.
    They’re a concise and expressive way to combine static text with dynamic values
    resulting from variables, expressions, or even function calls. As hinted at when
    we first discussed variables, string templates use dollar signs ($) to signal
    that what follows should be treated as code rather than as literal text. For example,
    consider the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Here we embed the variables name and age within the message string template
    using the $ symbol. The values of these variables are automatically substituted
    into the resulting string when it’s evaluated. When you run this code snippet,
    the output should therefore look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Notice how John and 30 have been inserted into the string in place of $name
    and $age. Compare the string template syntax with how we might generate the same
    message using string concatenation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: The string template version is much more readable and spares us from the tedium
    of including all the + operators and remembering to add spaces to the strings
    before and after each variable. This isn’t to say that string concatenation is
    never useful, but if your goal is to inject values from your code into a string,
    a string template is likely the better choice.
  prefs: []
  type: TYPE_NORMAL
- en: 'String templates can also handle more complex expressions by enclosing them
    within braces (the {and} symbols) after the dollar sign. This allows you to perform
    calculations, access object properties, or invoke functions directly within the
    template. Here’s an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: The ${x + y} in this string template tells Kotlin to add the values in the x
    and y variables and insert the result into the string.
  prefs: []
  type: TYPE_NORMAL
- en: Escape Sequences
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '*Escape sequences* are special character combinations used in strings to represent
    characters such as whitespace that are difficult to input directly. They’re prefixed
    with a backslash. For example, the escape sequence \n represents a newline character,
    and \t represents a tab character. Escape sequences are often used within string
    templates to format the output. Here’s an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'In this example, the \n in the middle of the message string adds a line break
    between the name and age, improving the formatting of the output. If you run the
    code, the output should break across two lines, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Other common escape sequences include \\ for a backslash and \$ for a dollar
    sign. These are needed because otherwise a backslash in a string is interpreted
    as the start of an escape sequence and a dollar sign as the start of some Kotlin
    code to be inserted into a string template.
  prefs: []
  type: TYPE_NORMAL
- en: '### Null and Nullable Types'
  prefs: []
  type: TYPE_NORMAL
- en: '*Null* represents the absence of a value. By default, Kotlin’s type system
    assumes that a variable can’t hold null. Consider this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'The str variable is declared to be of the String type, so its value must be
    a string. Trying to set the variable to null will therefore trigger an error.
    If you want to allow a variable to be null, you must explicitly declare the variable
    to be of a *nullable type* by appending ? to the type declaration, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'The type declaration str: String? indicates that the str variable can hold
    either a string or null. Because the variable is of the String? nullable type,
    setting it to null is now valid and won’t cause an error.'
  prefs: []
  type: TYPE_NORMAL
- en: Kotlin’s not-nullable-by-default type system is designed to prevent *null pointer
    exceptions*, which are common runtime errors in languages that freely allow variables
    to have null values. A null pointer exception occurs when a program tries to access
    or manipulate data using a null reference, which doesn’t point to a valid memory
    location or object. Proper handling of null values is essential to prevent these
    exceptions and the code from crashing.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can ensure null safety in Kotlin in multiple ways. One way is to explicitly
    check whether a nullable variable holds null, before accessing its properties
    or methods. For instance:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: In this example, we check whether the variable str is null by using an if...else
    conditional statement. If str is not null, its length property is accessed; otherwise,
    -1 is assigned to len. (We’ll discuss conditional statements in the next section.)
  prefs: []
  type: TYPE_NORMAL
- en: 'Another mechanism is Kotlin’s *safe call operator* (?.), which allows us to
    call a method on a nullable object without risking an error. If the object contains
    null, the result is null as well. Otherwise, the method is called as usual. For
    example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: In this case, if str is null, len will be assigned null; otherwise, len will
    be assigned the length (number of characters) of str.
  prefs: []
  type: TYPE_NORMAL
- en: 'Kotlin also provides the *Elvis operator* (?:). Used in conjunction with the
    safe call operator, it allows you to give a default value (instead of null) for
    an expression involving a nullable object. If the object isn’t null, the expression
    will be evaluated as normal; otherwise, the default value will be used. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'In this case, if str isn’t null, its length will be assigned to the len variable;
    otherwise, the value after the ?: operator (-1) will be assigned.'
  prefs: []
  type: TYPE_NORMAL
- en: NOTE
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*The examples we’ve discussed so far have focused on the* String? *nullable
    type, but note that the* ? *operator can be applied to other data types, such
    as* Int*,* Double*, or even* Boolean*. This flexibility in using nullable types
    is particularly helpful when working with user input.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, Kotlin has another related operator called the *null assertion operator*
    (also called the *double-bang operator*), denoted by two exclamation points (!!).
    It can be used to assert that a nullable variable doesn’t contain null even though
    the compiler can’t guarantee this to be true. Using !! is a way of saying that
    you’re sure a particular nullable variable isn’t null so that the compiler will
    skip checking for nullability. Here’s an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: We declare name as a nullable string, but by using !! while accessing the string’s
    length, we’re asserting that it’s not null. If name actually were null, this snippet
    would result in a NullPointerException. As such, it’s best to avoid or limit the
    use of the null assertion operator and favor safer constructs like safe calls
    (?.) and null checks (?:). Alternatively, aim to design your code to reduce nullable
    types, for increased reliability and predictability.
  prefs: []
  type: TYPE_NORMAL
- en: Flow Control
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*Flow control* is an essential aspect of programming, providing mechanisms
    to regulate when and how code is executed. Kotlin’s flow control constructs enable
    developers to create flexible and dynamic programs by effectively managing the
    sequence of statements and controlling the program’s behavior. In this section
    we’ll discuss two important types of control structures: conditionals and loops.
    These concepts are foundational to any programming language.'
  prefs: []
  type: TYPE_NORMAL
- en: Conditional Statements
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Conditional statements allow you to determine what a program should do based
    on certain tests. Kotlin has two primary conditional statements: if and when.
    They both introduce branching into code, the idea that a program can take different
    forks depending on the circumstances. In general, if statements are appropriate
    for straightforward binary decisions or when facing a limited number of conditions.
    On the other hand, if you need to manage several conditions, handle various cases,
    or strive for cleaner and more structured code when implementing branching logic,
    when could be your preferred tool.'
  prefs: []
  type: TYPE_NORMAL
- en: if Statements
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'An if statement runs a block of code when a given condition evaluates to true.
    Here’s a simple example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: The condition for an if statement, in this case x > 0, must be an expression
    that evaluates to a Boolean true or false value, and it must be given in parentheses
    after the if keyword. The code after the condition will run if the condition is
    true, so this snippet prints a message only when the variable x has a positive
    value. If x isn’t positive, the println statement will simply be skipped.
  prefs: []
  type: TYPE_NORMAL
- en: 'An if statement can have an optional else clause that gets executed if the
    test expression evaluates to false. Once an else clause is included (or if there’s
    just an if clause but it includes multiple lines of code), the body of each clause
    should be indented and enclosed in braces, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: This time, since the x > 0 condition evaluates to false, the code in the else
    clause will run. Notice how the opening brace goes on the same line as the if
    or else keyword, while the closing brace goes on a new line after the last statement
    in that clause.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can extend an if...else structure to include three or more possible branches
    by adding else if clauses between the initial if and the final else. Each else
    if clause adds a new condition to test if the previous condition is found to be
    false. Here’s an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: Here, we initialize two variables, a and b, with the values 100 and -30, respectively.
    Subsequently, we declare a variable max of type Int without providing an initial
    value ❶. (In Kotlin, this is allowed as long as the variable will eventually be
    initialized before using it for the first time.) We then use an if...else if...else
    structure to compare the values of a and b and print an appropriate message. First,
    the if clause tests if a is greater than b. If this fails, the else if clause
    tests if a is less than b. If this also fails, a and b must be equal, as the else
    clause says.
  prefs: []
  type: TYPE_NORMAL
- en: 'The syntax for this kind of control structure is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: You can adjust this template by adding more else if blocks or deleting them
    altogether, depending on your needs.
  prefs: []
  type: TYPE_NORMAL
- en: when Statements
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'A when statement checks a value against multiple conditions and executes the
    code block of the first matching condition. If you’re familiar with switch statements
    from languages like Java, C, or C++, the concept is similar. A when statement
    can also have an else clause for when none of the conditions match, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: We assign a value of 5 to the variable x, then use a when statement to test
    this variable’s value. Each line of the when statement has its own conditional
    test (such as x > 0) followed by the -> symbol, which points to the expression
    that should be executed if the condition is true. As soon as a true condition
    is found, the remainder of the when statement is skipped, even if it contains
    additional tests that would pass. In this case, since x is greater than 0, the
    when statement will print "x is positive".
  prefs: []
  type: TYPE_NORMAL
- en: As with if statements, including an else clause in a when statement is optional.
    However, it’s considered good practice to provide an else clause; it improves
    the robustness of your code by offering a fallback option for unmatched cases.
  prefs: []
  type: TYPE_NORMAL
- en: 'It’s also possible to provide the variable to be tested in parentheses immediately
    after the when keyword. In this case, the when statement conducts tests based
    on exact values or ranges of values for that variable, without repeating the variable
    name. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: Here, we pass the hour variable to the when statement, which prints different
    greetings based on the variable’s value. For example, the condition in 0..11 tests
    whether the value of hour is between 0 and 11, inclusive. We’ll look more closely
    at how to use the .. operator to specify a range of values in the next section,
    when we discuss loops.
  prefs: []
  type: TYPE_NORMAL
- en: Loops
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '*Loops* are essential constructs in programming that allow you to repeat a
    block of code multiple times. Kotlin offers a few types of loops, each with its
    own use cases and advantages. In this section, we’ll explore loops in Kotlin,
    including how to specify ranges for iteration.'
  prefs: []
  type: TYPE_NORMAL
- en: for Loops
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'A for loop iterates through the elements in a collection, such as an array,
    list, or range. One common usage is to loop through a range of numbers, effectively
    creating a loop with a fixed number of repetitions. As we just saw with when statements,
    an inclusive range is specified in Kotlin using the .. operator. Here’s how this
    syntax fits with a for loop:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'The logic governing a for loop is given in parentheses immediately after the
    for keyword. In this case, we create the loop variable i, which takes on values
    1 through 4 (inclusive). In the body of the loop, which is enclosed in braces,
    we print the current value of i using a string template. This for loop should
    produce the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'If you want to create a range that excludes the last value, use the until keyword
    instead of the .. operator. Additionally, with either style of range, you can
    specify a *step* value to increment the loop variable by some amount other than
    1. Here we use an until range with a step size of 3:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'In this example, the loop variable i begins with a value of 1 and then increases
    by 3 each time through the loop, taking on the values 4 and 7 before the loop
    terminates. The output should look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: Notice that there’s no output line for when i is 10. This is because we used
    until, which excludes the upper bound of the range.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you need a for loop to iterate in reverse order, create a range with the
    downTo keyword. This keyword allows you to specify a range where the loop variable
    starts at a higher value and counts down to a lower value. Like the .. operator,
    downTo ranges are inclusive. Here’s how it works:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'This for loop should output the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: Thanks to the downTo keyword, the looping variable i counts down from 4 to 1.
  prefs: []
  type: TYPE_NORMAL
- en: continue and break Statements
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Kotlin makes it possible to disrupt the flow of a for loop using the continue
    and break keywords. Usually, these keywords work in conjunction with an if statement
    to interrupt the loop when some condition is met. The continue keyword halts the
    current iteration of the loop and immediately skips ahead to the next iteration.
    Here’s an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'When the loop variable is set to 3, the loop will continue by moving on to
    the next value of the loop variable. As a result, the println() function won’t
    execute when i is 3, yielding the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'The break keyword, by contrast, completely terminates a for loop, as shown
    here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'This loop will “break” when the loop variable equals 3. As a result, the output
    should look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: Even though the range had a few values to go, the break keyword ended the loop
    early.
  prefs: []
  type: TYPE_NORMAL
- en: Nested and Named for Loops
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'It’s common to nest one for loop inside another such that the entire inner
    for loop executes multiple times, as determined by the outer loop. Here’s an example
    of a nested set of for loops that prints a pattern of asterisks in a square shape:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'In this example, the outer loop for (i in 1..size) iterates over the rows,
    and the inner loop for (j in 1..size) iterates over the columns within each row.
    The print("* ") statement prints an asterisk followed by a space for each element
    in a row. Unlike println(), the print() function ❶ doesn’t add a newline character
    each time it’s called, so each time through the outer loop, the inner loop will
    print a series of asterisks all together on one line. The empty println() statement
    after the inner loop ❷ moves the cursor to the next line to separate the rows.
    The output of this code, with size set to 4, should look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'When you have nested loops, it can be helpful—though not strictly necessary—to
    assign each loop a name. The name comes before the for keyword and must be followed
    by an at sign (@). If the loops are named, you can explicitly apply keywords like
    continue and break to one loop or the other by adding the loop’s name after the
    keyword. This gives you more control over when and how the nested loops can be
    disrupted. Here’s an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'We have two nested for loops, named loop1 and loop2. The loop variables, i
    and j, both vary from 1 to 5 inclusive. Ignoring the conditional logic inside
    loop2 for a moment, this nested loop would iterate for a total of 25 (5 × 5) times,
    printing each (i,j) pair, starting with (1,1) through (1,5) for the first time
    through loop1, then (2,1) through (2,5) for the second, and so on. The output
    would look like this, with the println() after each full cycle of the inner loop
    again ensuring that each group of five pairs is printed on its own line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'Now consider what the conditional logic in the inner loop does ❶. It applies
    the break keyword specifically to loop2 (using the syntax break@loop2) if i and
    j are equal, halting the inner loop and returning to the outer loop for the call
    to println(). (Notice how the @ symbol follows the loop name when the name is
    being assigned but precedes it when the name is being referenced.) This logic
    prints only the lower-left portion of the grid of (i,j) pairs, up to the main
    diagonal, where i and j are equal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: In truth, specifying that break applies to loop2 isn’t necessary here, since
    by default, keywords like break and continue apply to the innermost loop that
    contains them—in this case, loop2. Still, including the loop name helps clarify
    the intent behind the code. Furthermore, consider that another way to achieve
    a similar result would be to replace break@loop2 with continue@loop1, in which
    case referencing the loop name becomes necessary. I encourage you to try making
    this change as an exercise—you’ll also need to think about what to do with the
    call to println() to keep the output nicely formatted.
  prefs: []
  type: TYPE_NORMAL
- en: while Loops
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'A while loop is best employed when you need to repetitively execute a code
    block but you don’t know the exact number of iterations in advance. It keeps looping
    until a termination condition is satisfied. The condition is given in parentheses
    after the while keyword, before the start of the loop body. Here’s an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'We initialize the count variable to 0, then create a while loop that will continue
    repeating as long as the condition count < 4 remains true. The loop checks this
    condition *before* each repetition. Inside the loop, we print the current value
    of count and then increase its value by 1 using a unary ++ operator to get ready
    for the next iteration. This should produce the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: At the end of the fourth time through the loop, count increments from 3 to 4.
    Then, when the loop gets ready to start its fifth iteration, it finds that the
    loop condition is no longer true and the loop terminates.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another style of while loop uses the condition while (true). Since true always
    evaluates to true, this theoretically sets up an infinite loop. The real conditional
    logic of halting the loop is instead moved inside the loop body itself. Here’s
    the same while loop as before, implemented in this other style:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: This time we use an if statement at the end of the loop body to trigger the
    break keyword and terminate the loop when count is greater than or equal to 4.
    Without this conditional, the program would get stuck in an infinite loop, causing
    it to run indefinitely.
  prefs: []
  type: TYPE_NORMAL
- en: 'One further variation on the while loop is the do...while loop, which has the
    following syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: A do...while loop checks the stopping condition *after* each iteration, rather
    than before. This ensures that the loop will be executed at least once. By contrast,
    if the condition for a regular while loop is already false before the loop begins,
    it won’t execute at all.
  prefs: []
  type: TYPE_NORMAL
- en: Just like for loops, you can nest multiple while loops and use them with the
    continue keyword as well as with break.
  prefs: []
  type: TYPE_NORMAL
- en: Functions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A *function* is a reusable block of code that performs a specific task or computation.
    Functions are a fundamental building block of any Kotlin program and are used
    to encapsulate logic, promote code reusability, and improve code organization.
    Kotlin’s standard library comes with many built-in functions to simplify common
    programming tasks. One example is the println() function we’ve been using throughout
    this chapter to output text to the console; other examples include various mathematical
    functions, some of which we’ll explore shortly. For more specialized tasks particular
    to the application at hand, you’ll have to create your own custom functions. We’ll
    discuss how to do that as well.
  prefs: []
  type: TYPE_NORMAL
- en: Built-in Mathematical Functions
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Throughout this book, we’ll leverage a multitude of mathematical functions
    that come prepackaged in the standard Kotlin library. For example, you can effortlessly
    compute the square root of a number with the sqrt() function or raise a value
    to a specific power (exponent) using the pow() function. These functions are part
    of the kotlin.math package and must be *imported* at the start of a program using
    the import keyword. Here’s a simple program that uses these two functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'First, we import the two math functions we need. Then we use them to calculate
    the square root of x (squareRoot) and y to the second power (toThePower2) inside
    the string templates using the ${} syntax discussed in “String Templates” on [page
    15](#pg_15). The code segment should produce the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: In some cases, you may need to use many built-in functions in the same module.
    Technically, it’s possible to import the entire collection by including an asterisk
    (*) in the import statement. For example, import kotlin .math.* would import every
    function in the kotlin.math module. It’s considered good practice to import only
    the functions you need, however. This approach helps avoid *namespace pollution*,
    where your code gets cluttered with unnecessary—or worse, conflicting—identifiers
    like variable and function names. Importing only what you need gives you more
    flexibility to name your own variables and functions without causing conflicts
    with the names of the built-in functions.
  prefs: []
  type: TYPE_NORMAL
- en: The remaining functions in the kotlin.math module handle trigonometry and other
    useful mathematical computations. For a comprehensive list of standard mathematical
    functions available and instructions on how to use them, search for kotlin.math
    in the official Kotlin documentation at [https://kotlinlang.org](https://kotlinlang.org).
  prefs: []
  type: TYPE_NORMAL
- en: Custom Functions
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'When you have some code that accomplishes a particular task in your application—especially
    a task that will be repeated—it’s common to encapsulate that code in a custom
    function. This keeps your code well organized and efficient. Each custom function
    must be *declared*, or defined, before it can be used. Here’s Kotlin’s syntax
    for a function declaration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: The declaration begins with the fun keyword, followed by the function name and
    a set of parentheses. Inside the parentheses, you provide the names of the function’s
    *parameters*, if any, along with their data types. These parameters serve as placeholders
    for values that the function expects to receive when it’s called. They allow you
    to pass data into the function. A function can have many parameters of different
    data types (including parameters that are other functions) or no parameters at
    all, in which case the function name will be followed by a set of empty parentheses.
    When a function is called, specific values, called *arguments*, are provided for
    the parameters. Notice that function parameters are implicitly treated as read-only
    (immutable) variables within the function body. Using val or var on function parameters
    is not allowed.
  prefs: []
  type: TYPE_NORMAL
- en: After the parameter list, the function declaration continues with a colon (:)
    followed by the function’s *return type*. This specifies the data type of the
    value the function will generate and provide to its caller. The built-in sqrt()
    function we discussed in “Built-in Mathematical Functions” on [page 28](#pg_28)
    returns the square root of its parameter as either a Double or a Float, for example.
    If a function returns nothing, you can omit the return type. It will be assumed
    to be Unit, akin to the void type in other languages. A function would return
    nothing if, for example, its purpose is to print output to the console, make changes
    to global variables, make changes to elements of an array or object supplied to
    the function as an argument, or call other functions.
  prefs: []
  type: TYPE_NORMAL
- en: Taken together, the function name and the parameter names and types define the
    *signature* of the function. The compiler uses function signatures to determine
    which function to use when multiple functions have the same name but different
    parameters (a practice called *function overloading* that we’ll discuss shortly).
    The return type isn’t part of the function signature, but it’s an important part
    of the function declaration nonetheless.
  prefs: []
  type: TYPE_NORMAL
- en: Once the function signature and the return type are specified (when applicable),
    all that remains is to declare the function *body*, which is enclosed in braces.
    This is the block of code that will be executed when the function is called. It
    may include additional variable declarations, conditional statements, loops, and
    expressions—anything necessary for the function to do its work.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s now examine a real function that performs a simple task: adding two integers
    together and returning the result. Here’s the function’s declaration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: We declare a function named add() that takes two parameters, x and y, both of
    type Int, and returns a value also of type Int. The function body calculates x
    + y and uses the return keyword to deliver that result to the function caller.
    Note that if the return type implied by the value being returned is different
    from the function’s declared return type, the compiler will generate an error.
    In this case, since both x and y are integers, x + y will be an integer as well.
  prefs: []
  type: TYPE_NORMAL
- en: 'With the add() function declared, we can call it from main() as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: 'We declare the a and b variables and initialize them to 3 and 6, respectively.
    Next, we declare sum and assign it the value returned by add(). Running this code
    should yield the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: Kotlin enforces strong typing, so the compiler will flag errors for mismatches
    between declared parameter types and the types of the arguments passed to the
    function. The number of arguments should also match the number of parameters,
    unless some parameters are assigned default values.
  prefs: []
  type: TYPE_NORMAL
- en: Providing Default Parameter Values
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'If a parameter has the same value most of the time a function is called, it
    can be given a default, preset value when the function is declared. This way,
    you need to provide an argument for that parameter only when you want it to be
    something other than the default. The parameters with default values should be
    listed last in the function declaration. Here’s an example of how to declare a
    default parameter value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: The greet() function takes two parameters, name and greeting, and combines them
    to print out a customized greeting. A value for name will need to be provided
    each time the function is called, but if no value for greeting is specified, the
    function will use the default value of "Hello". This default value is set in the
    parameter list, after the parameter’s data type.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we call the function with greet("Nathan"), supplying an argument only for
    the name parameter, it should result in the following output, including the default
    value for greeting:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: Consider how you would call this function if you wanted it to instead print
    "Good morning, Nathan!" as a message.
  prefs: []
  type: TYPE_NORMAL
- en: Using Named Arguments
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: When a function has many parameters, keeping track of their order and type can
    be a hassle. Using *named arguments* comes in handy in such situations. This is
    a style of function call where you include the parameter names along with the
    desired argument values. With the names included, the arguments can be given in
    any order.
  prefs: []
  type: TYPE_NORMAL
- en: 'Say you’ve declared this function with four parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: 'Calling the function using named arguments relieves you from the burden of
    remembering the order in which the parameters were declared:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: Here each argument is given in the form parameterName = value. This function
    call will work just fine, even though the parameters are out of order, thanks
    to the use of named arguments. This is allowed as long as you provide names for
    all arguments or the compiler is able to figure out the order of the arguments.
  prefs: []
  type: TYPE_NORMAL
- en: Overloading a Function
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '*Function overloading* in Kotlin allows you to define multiple functions with
    the same name in the same scope but with different parameter lists. Perhaps they
    have a different number of parameters, or the parameters are of different data
    types. Here’s an example of function overloading:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: 'We declare two functions called add() with different parameter lists; one adds
    two integers, and the other adds two floating-point numbers. When the add() function
    is called, the compiler will determine which version of the function to invoke
    by comparing the argument types to the declared function signatures. This is how
    you would call both functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: With function overloading, you can use the same function name for operations
    that conceptually do the same thing (in this case, addition) but with different
    parameter types. This makes your code more readable, intuitive, and error resistant.
    In this example, we’ve anticipated that we may want to add floating-point numbers
    as well as integers. Overloading the function gives us the flexibility to do either
    without triggering an error.
  prefs: []
  type: TYPE_NORMAL
- en: Referencing a Function Without Calling It
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'In Kotlin, you can use the member reference operator (::) to refer to a function
    by its name without actually invoking it. This is helpful in many situations,
    such as when you need to assign a function reference to a variable. Say you have
    two functions and you’re trying to decide which to use in your code. Perhaps they’re
    both ways of accomplishing the same task and you want to see which is more efficient,
    or perhaps they implement two different operations that would be appropriate in
    different situations. Rather than rewriting all the code to call one function
    or the other, you can assign to a variable a reference to the appropriate function
    and then call the function (whichever one you choose) via the variable, minimizing
    the changes to the code. Here’s an example illustrating how this works:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: 'We first declare two functions: add() calculates the sum of x and y, and multiply()
    calculates the product of x and y. We’ll want to use only one of these functions
    in main(). To control which one, we declare a Boolean variable useAdd and set
    it to true. Inside the main() function, we then create another variable named
    selectedFunction and use *conditional expression syntax* to set its value to one
    of the functions ❶. This syntax uses an if...else structure to return a value
    and assign it to a variable based on a condition—in this case, the state of the
    useAdd variable. If useAdd is true, selectedFunction is assigned a reference to
    add(); otherwise, it references multiply(). Notice how we precede each function
    name with the :: operator and don’t include parentheses after the function name,
    since we’re referencing rather than invoking the functions. With the selectedFunction
    variable holding a reference to a function, we can now invoke that function by
    calling selectedFunction() rather than by calling add() or multiply() directly
    ❷. We store the returned value in the result variable and print it to the console.'
  prefs: []
  type: TYPE_NORMAL
- en: Try changing the value of useAdd from true to false to switch between using
    add() and multiply(). Then consider how convenient this solution is for toggling
    between two functions, especially if you need to use the function in multiple
    places in the code. Instead of updating the function name at each usage, we can
    simply change the value of useAdd and rely on the selectedFunction variable to
    stand in for whichever function we want.
  prefs: []
  type: TYPE_NORMAL
- en: 'The :: operator is particularly useful when you need to pass a function reference
    as an argument to another function. Here’s an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: 'We define a function called printMessage() that takes a string parameter and
    prints it to the console. We also define another function called applyFunction()
    with two parameters: function, which will hold a reference to a function, and
    input, a string. The function parameter’s type needs to match the parameter and
    return types of the function it will reference; (String) -> Unit indicates that
    the function will take a string as a parameter and return nothing. In the body
    of applyFunction(), we call whatever function was passed in, using the input string
    as its argument.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In main(), we create a reference to printMessage() using :: and pass it to
    applyFunction() along with the string "Hello, Kotlin!" as the second argument.
    This will effectively make applyFunction() call printMessage() with the given
    string and print it to the console. The output should be:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: 'Of course, you can do more with the :: operator than we’ve discussed here.
    I encourage you to consult the official Kotlin documentation to explore the operator’s
    other use cases.'
  prefs: []
  type: TYPE_NORMAL
- en: Scope Functions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In Kotlin, *scope functions* are a set of built-in functions used to manage
    the scope of variables, access properties of objects, and execute a block of code
    in a specific context. The scope functions in Kotlin are run, with, let, also,
    and apply. They’re often used to simplify and improve the readability of code,
    especially when working with objects or managing the flow of operations. Here
    is a simple example of how to use the run function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: 'We begin by declaring a variable called result. Its value is determined by
    the last expression within a code block executed using the run scope function.
    Inside this block, we define and assign values to two integers, and the final
    expression computes their sum. The resulting value from this final expression
    is returned by the code block and assigned to the result variable. Finally, we
    use println() to print the value of result, which will display Result: 30.'
  prefs: []
  type: TYPE_NORMAL
- en: Lambda Expressions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*Lambda expressions*, often referred to simply as *lambdas*, are a way to define
    and pass around blocks of function-like code in a flexible and concise manner.
    They’re essentially anonymous functions, allowing you to create functions on the
    fly without giving them a name. Lambda expressions are a fundamental part of functional
    programming, a programming style or paradigm that uses functions as the main building
    blocks. They make it easier to work with *higher-order functions*, functions that
    can take functions as arguments, return functions as values, or both. Higher-order
    functions can help create reusable and modular code that can be customized with
    different functions.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s an example of a simple lambda that takes in a name and generates a greeting:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: 'The lambda itself is the part of the code enclosed in braces: {name -> "Hello,
    $name!"}. It consists of input parameters (in this case, just one, name) and a
    body ("Hello, $name!"), separated by an arrow (->) symbol. Think of this arrow
    as passing the parameters along to the lambda body. The return keyword is implied
    in the lambda body; if the body consists of a single expression, that expression
    will automatically be returned.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In this example, we assign the lambda to the greet variable. The (String) ->
    String before the assignment operator specifies the lambda’s parameter and return
    types, again using the -> symbol to separate the two. We can also incorporate
    these type declarations into the lambda itself, in which case we’d write the entire
    expression as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: Here we specify that the name parameter is of the String type from within the
    braces. With this syntax, the return type, like the return keyword itself, is
    implied.
  prefs: []
  type: TYPE_NORMAL
- en: 'Whichever syntax we use, we now have a function that returns a string greeting
    inside the greet variable. We can therefore call the lambda via this variable,
    just like we would call an ordinary function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: 'Lambdas are often used for quick manipulation of data, such as adding two numbers
    or calculating the square of a number:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: 'Lambda parameters can be explicitly typed or inferred. For simple lambdas,
    Kotlin can infer types automatically. Also, if a lambda has a single parameter,
    you can omit the parameter declaration and use the implicit it keyword directly
    in the lambda’s body as a stand-in for the parameter. This is what we’ve done
    for the square lambda: {it * it} indicates that the lambda will take a single
    unnamed parameter and multiply it by itself.'
  prefs: []
  type: TYPE_NORMAL
- en: Lambdas can span multiple lines to carry out more complex tasks and can be nested
    like for loops. We’ll use multiline, nested lambdas in the next section in relation
    to copying the content of a file.
  prefs: []
  type: TYPE_NORMAL
- en: '### Basic Input and Output'
  prefs: []
  type: TYPE_NORMAL
- en: Most commercial software these days has a graphical user interface (GUI) so
    that you can easily interact with it. You can create a GUI for your Kotlin app
    using third-party tools such as JavaFX or Jetpack Compose, but we won’t cover
    that in this book. Instead, in this section we’ll focus on how to work with text-based
    input and output in Kotlin. This helps you quickly test and debug your code. Text-based
    output is also useful for tasks like scripting, keeping logs, and watching what’s
    happening on networks of computers and devices, which is what system administrators
    often do.
  prefs: []
  type: TYPE_NORMAL
- en: Console-Based Input and Output
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'To get user input from the console in Kotlin, use the readln() function. It
    returns whatever text the user enters into the console or an empty string if the
    user simply presses the ENTER key. Here’s an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, the user input (a line of text) is read into the userInput variable and
    then displayed as output to the console using the familiar println() function.
    If the user just presses ENTER, then readln() will return an empty string, and
    the program will end normally after printing the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: When reading input from the console in Kotlin, keep in mind that all input is
    initially treated as text, resulting in a String data type. If you require a different
    data type, you must perform type casting, assuming the types are compatible. It’s
    also helpful to inform users about the expected input type by using prompts such
    as Enter your name or Enter an integer.
  prefs: []
  type: TYPE_NORMAL
- en: 'Even with a clear prompt, though, you shouldn’t automatically assume that the
    input will be valid. The user may input incorrect characters that can’t be successfully
    type-cast into the desired format. To prevent the program from crashing due to
    potential errors, it’s essential to implement error-handling mechanisms when receiving
    input from users. This extra step ensures robustness and a smoother user experience.
    Here’s a complete example of a fail-safe method for reading an integer from the
    console:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: 'We begin by creating a while loop that continues to run until a valid input
    is provided. Next, we read the user input as a string and assign that to a variable
    called num. We check the validity of the input inside a try...catch construct
    for graceful error handling. This construct consists of two code blocks: a try
    block containing the code you’d like to run and a catch block containing an alternative
    code path or fallback option in case an error occurs during the try block. The
    catch block prevents the entire program from crashing abruptly from an error.
    This mechanism helps with debugging during testing and improves the overall user
    experience in commercial applications.'
  prefs: []
  type: TYPE_NORMAL
- en: In this case, the try block attempts to convert the user’s input, stored in
    the variable num, into an integer using toInt(). If this conversion is successful,
    a message containing the integer value is printed.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, if the conversion fails and a NumberFormatException is raised, the
    catch block is activated, printing an error message before the next iteration
    of the while loop begins. Notice the (e: NumberFormatException) immediately after
    the catch keyword. This specifies the particular type of exception that the catch
    block is designed to handle.'
  prefs: []
  type: TYPE_NORMAL
- en: '#### Simple File Operations'
  prefs: []
  type: TYPE_NORMAL
- en: 'Kotlin provides simple and effective ways to read and write files, a feature
    that’s very helpful when you want to retrieve previously saved data or save the
    data from the current run of a program. For this functionality, Kotlin relies
    on the Java standard library. For example, here’s how to read data from a file
    using Java’s File and Scanner classes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: 'The example shows how to read a text file line by line. After importing the
    File and Scanner classes, we assign a string containing the full pathname of the
    input file to the inputFile variable. We then use this variable to create the
    File object called file ❶, which in turn is used to create a Scanner object called
    sc ❷ that gives us access to the file’s contents. Then, in a while loop, we read
    the content of the file one line at a time using the Scanner object’s nextLine()
    method and print the result to the console. The loop continues until we reach
    the end of the file, indicated when the Scanner object’s hasNextLine() method
    returns false. We place all this code in a try block and use a corresponding catch
    block to handle any errors that arise while trying to access the file—for example,
    if the filename or filepath is wrong. The (e: Exception) indicates the catch block
    can handle any kind of exception, unlike the earlier catch block that was designed
    specifically for exceptions of type NumberFormatException. In this case, the catch
    block prints the default error message associated with the exception, accessible
    as e.message.'
  prefs: []
  type: TYPE_NORMAL
- en: 'My test file at location *inputfile.txt* contained a limerick, and the program
    reproduced it on the console line by line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: 'To read from *and* write to a file, you can’t use the Scanner class, since
    it doesn’t support writing output. Instead, you can use the appendText() method
    of the File class. Here’s a simple example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: This Kotlin code reads all the lines from an input file (*inputfile.txt*) and
    writes them to an output file (*outputfile.txt*). The input file is represented
    using one File object ❶ and the output file with another ❷. We use the File class’s
    readLines() method to read all the lines from the input file and return them as
    a list of strings ❸. (A *list* in Kotlin is a collection of items; in this case
    it’s a collection of strings, one for each line of the file. We’ll discuss lists
    in detail in [Chapter 2](chapter2.xhtml).) We store this list of strings in the
    lines variable. We then use a for loop to iterate over the lines list, with the
    looping variable line standing for one line at a time ❹. For each line, we use
    the appendText() method to add the line to the output file. We also append a newline
    character (\n) to the end of each line to ensure it’s written on its own line
    of the output file. We conclude the code by printing a message to the console,
    indicating that the input file has been copied to the output file.
  prefs: []
  type: TYPE_NORMAL
- en: Notice that we didn’t use the try...catch block in this example, as the goal
    was to quickly show how to write data to a file. In real-world applications, file
    operations may have to be wrapped in a try...catch block to handle potential exceptions
    or errors, depending on your specific requirements.
  prefs: []
  type: TYPE_NORMAL
- en: You can use many other techniques for reading from and writing to files in Java
    and Kotlin. See the official Kotlin documentation for information about other
    methods.
  prefs: []
  type: TYPE_NORMAL
- en: 'Project 1: Build a Console-Based Calculator'
  prefs: []
  type: TYPE_NORMAL
- en: Now that we’ve explored some of the basic features of Kotlin, let’s put that
    knowledge to work in a real project. We’ll develop an interactive, console-based
    calculator application. The application will take a pair of valid numbers as input,
    ask the reader to choose an arithmetic operation (addition, subtraction, multiplication,
    or division), and then display the result of that operation in the console. We’ll
    also program the application to show helpful error messages when required.
  prefs: []
  type: TYPE_NORMAL
- en: At the start of any coding project, it’s crucial to begin by creating a mental
    map of the application’s structure. This involves identifying the necessary variables
    and data structures, as well as pinpointing the essential functionalities that
    the program should include. Once these components are identified, we can move
    forward by generating a list of the key components that need to be implemented,
    followed by the actual coding phase.
  prefs: []
  type: TYPE_NORMAL
- en: 'For more complex projects, it can also be beneficial to create a flowchart
    visualizing the application logic or to develop detailed pseudocode offering step-by-step
    instructions for coding the entire project. However, given the relatively straightforward
    nature of the calculator project, we’ll start by listing its key components:'
  prefs: []
  type: TYPE_NORMAL
- en: '1.  Input collection: We’ll gather user input for two numbers and ensure the
    inputs are valid.'
  prefs: []
  type: TYPE_NORMAL
- en: '2.  Operation selection: The user will choose addition, subtraction, multiplication,
    or division.'
  prefs: []
  type: TYPE_NORMAL
- en: '3.  Calculation: The selected operation will be applied to the input numbers.'
  prefs: []
  type: TYPE_NORMAL
- en: '4.  Result display: The calculated result will be presented to the user via
    the console.'
  prefs: []
  type: TYPE_NORMAL
- en: '5.  Error messages: Throughout steps 1 through 3, we’ll display helpful error
    messages for invalid inputs, such as nonnumerical characters for the number inputs
    or an unrecognized mathematical operation.'
  prefs: []
  type: TYPE_NORMAL
- en: We’ll use these five key components to guide the development process as we start
    coding our first mini project.
  prefs: []
  type: TYPE_NORMAL
- en: The Code
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: We’ll discuss the code from the top down, starting with the main() function,
    which coordinates the program’s actions through a series of helper functions.
    This approach allows us to align the code with the key components we outlined.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: We begin by importing the exitProcess() function from Kotlin’s standard library.
    We’ll use this method to exit the program if the user provides invalid input or
    if the code comes across an invalid operation type (for example, division by zero).
  prefs: []
  type: TYPE_NORMAL
- en: 'The main() function itself is divided into four clear steps, each related to
    one of the key project functions. In the first step, we ask the user to provide
    two numbers, which we store in the number1 and number2 variables. To manage and
    verify the input, we use the readDoubleInput() function, declared here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: This function takes a single argument, a string serving as a prompt for user
    input in the console. It returns a numeric value (of type Double) if the user
    provides a valid input. The function displays the prompt using print() rather
    than println() so that the user’s response will go on the same line. Then it reads
    the user’s input with readln() and processes the string input inside a try...catch
    block. When the string is successfully converted into a numeric value of type
    Double, its value is returned. Otherwise, we enter the catch part of the block,
    where an error message is printed, and the program exits with an error code of
    1.
  prefs: []
  type: TYPE_NORMAL
- en: NOTE
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*When using the* exitProcess() *function, any integer can be used as an error
    code. However, it’s important to first decide on a scheme for error codes based
    on the different types of errors that the application might generate. This will
    allow you to quickly locate the source of the error. In more complex projects,
    creating and maintaining a log or wiki of error codes is recommended.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'After the main() function receives two valid numeric values (number1 and number2),
    we move on to step 2, choosing the mathematical operation. For that, we first
    call the showChoices() function, which offers a list of arithmetic operations
    to the user. This function is simply made up of a number of println() calls:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we use the getArithmeticOperation() function to take in a valid operation
    from the user. The result is assigned to the string variable operation in main().
    Here’s what the getArithmeticOperation() function looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: Within this function, the user is prompted to select one of the four valid arithmetic
    operators. This choice is captured using the readln() method. Subsequently, we
    use an if statement to verify whether the user input is valid. Specifically, if
    the string "+-*/" does not include the user’s input, an error message is printed,
    indicating that an invalid operator has been provided. The program then terminates
    with an error code of 2.
  prefs: []
  type: TYPE_NORMAL
- en: 'Back in main(), we can now move to step 3 and call the performCalculation()
    function to carry out the selected arithmetic operation and return the result.
    Here’s that function’s declaration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: 'This function takes in the two input numbers and the string containing the
    desired operation as parameters and returns the result of the calculation as a
    number of type Double. It employs a when statement to execute the desired calculation
    based on the value of operation. By this stage, both the numbers and the operation
    type have been validated. However, one potential source of error remains: division
    by zero. We address this with an if...else block in the "/" case of the when statement,
    which prints an error message and exits the program if number2 is 0.0.'
  prefs: []
  type: TYPE_NORMAL
- en: Notice that we also include an else clause for the overall when statement ❶,
    even though no further errors should remain at this point (hence the “Unexpected
    error encountered” message). Having this clause as a fallback is good practice
    in case unexpected issues or compiler bugs lead to unpredictable errors.
  prefs: []
  type: TYPE_NORMAL
- en: With the calculation performed, our main() function moves on to step 4 and displays
    the result using a string template. Looking back at main(), notice how our use
    of custom functions to encapsulate the various individual tasks of the program
    has kept the main() function itself tidy and easy to read. In this way, functions
    help us maintain well-organized applications.
  prefs: []
  type: TYPE_NORMAL
- en: The Result
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Here’s a sample run of the program to multiply two numbers, 37 and 9\. The user
    input is shown in bold.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE94]'
  prefs: []
  type: TYPE_PRE
- en: Notice that even though the inputs are integers, they get converted to the Double
    type before conducting the multiplication. That is, 37 becomes 37.0 and 9 becomes
    9.0, as shown at the end of the output under Result. Feel free to experiment with
    invalid numbers or operators and observe how the program behaves. We can learn
    a lot from our mistakes!
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, we covered an array of fundamental elements of the Kotlin language.
    You learned how to use comments to enhance code clarity, variables to store and
    manage data, and operators to manipulate that data. You explored flow control
    structures like conditionals and loops to dictate your program’s behavior, and
    functions to encapsulate and reuse code effectively. With lambda expressions,
    you saw a way to write and use functions on the fly and got a glimpse of the functional
    programming style. You also practiced receiving input and providing output, for
    both console- and file-based interactions. To conclude the chapter, you gained
    hands-on practice bringing these elements together through a project implementing
    a console-based calculator.
  prefs: []
  type: TYPE_NORMAL
- en: Resource
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Kotlin. “Kotlin Docs.” (The official Kotlin documentation.) Accessed June 15,
    2024\. *[https://kotlinlang.org/docs/home.xhtml](https://kotlinlang.org/docs/home.xhtml)*.
  prefs: []
  type: TYPE_NORMAL
