- en: <hgroup>
  id: totrans-0
  prefs: []
  type: TYPE_NORMAL
  zh: <hgroup>
- en: 1 KOTLIN BASICS
  id: totrans-1
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 1 Kotlin 基础
- en: </hgroup>
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: </hgroup>
- en: '![](../images/icon.jpg)'
  id: totrans-3
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/icon.jpg)'
- en: This chapter will guide you through the fundamental building blocks of the Kotlin
    programming language. We’ll explore essential language features such as comments,
    variables, operators, flow control structures, functions (including lambda expressions),
    and basic input and output techniques.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将引导你了解 Kotlin 编程语言的基本构建模块。我们将探索语言的核心特性，如注释、变量、运算符、流程控制结构、函数（包括 Lambda 表达式）以及基本的输入输出技术。
- en: Together, these elements allow you to manage and manipulate data within your
    code, govern the program’s behavior so that it responds dynamically to different
    scenarios, and keep your code well organized and easy to maintain. Understanding
    these basic elements will also pave the way for the more sophisticated language
    features discussed in [Chapter 2](chapter2.xhtml), such as arrays, collections,
    and custom data structures (including classes).
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 这些元素结合起来，允许你在代码中管理和操作数据，控制程序的行为，使其能够动态响应不同的场景，同时保持代码的良好组织和易于维护。理解这些基本元素也为[第2章](chapter2.xhtml)中讨论的更复杂语言特性打下基础，例如数组、集合和自定义数据结构（包括类）。
- en: The topics covered here are core elements in any programming language, serving
    as the foundational elements for application development. If you’ve already worked
    with another language, these elements will look familiar in Kotlin. Conversely,
    if Kotlin is your first language, what you learn here will be readily transferable
    to other languages. We’ll explore these components in a practical way, with short
    code snippets illustrating each new idea. At the end of the chapter, we’ll tie
    everything together with a simple project.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 这里涉及的主题是任何编程语言中的核心元素，是应用程序开发的基础。如果你已经使用过其他语言，这些元素在 Kotlin 中看起来会很熟悉。反之，如果 Kotlin
    是你的第一种语言，你在这里学到的知识也可以轻松迁移到其他语言。我们将以实践的方式探索这些组件，每个新想法都有简短的代码片段进行说明。在本章的末尾，我们将通过一个简单的项目将所有内容串联起来。
- en: I’m assuming you’re using the free version of IntelliJ IDEA as your integrated
    development environment (IDE) for developing and running code. See the appendix
    for instructions on installing, setting up, and using this tool with a basic “Hello,
    world!” program.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 我假设你正在使用 IntelliJ IDEA 的免费版本作为开发环境（IDE）来开发和运行代码。有关安装、设置和使用该工具的说明，请参见附录，并试着运行一个基本的“Hello,
    world!”程序。
- en: Using Comments
  id: totrans-8
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用注释
- en: A *comment* is a line (or several lines) of explanatory text in a code file
    that the compiler will ignore when it runs the code. The text is meant to provide
    helpful hints, such as what the next code segment does, why a particular method
    was chosen, or how to properly use a language feature in a code segment. When
    you’re coding, you should insert comments to remind yourself what each piece of
    code is about. Experienced coders know that documenting code is essential to guard
    against forgetting important details down the road. Also, when others use or build
    on your code, your comments can be a lifesaver.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: '*注释* 是代码文件中一行（或多行）解释性文本，编译器在运行代码时会忽略这些文本。文本的目的是提供有用的提示，例如下一段代码的作用、为什么选择特定方法，或如何在代码段中正确使用某个语言特性。在编写代码时，你应该插入注释，以提醒自己每一段代码的含义。经验丰富的程序员知道，文档化代码是防止将来遗忘重要细节的关键。而且，当其他人使用或基于你的代码进行开发时，你的注释可能会成为救命稻草。'
- en: 'In Kotlin, you have two main ways to add comments. The first is to use // to
    start a single-line comment. The compiler will ignore anything on the line after
    the two slashes. The other way is to use /* and */ to start and end a comment
    that spans multiple lines. Here’s an example of how these two commenting styles
    work:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Kotlin 中，你有两种主要方式来添加注释。第一种是使用 // 来开始单行注释。编译器会忽略双斜杠后的内容。另一种方法是使用 /* 和 */ 来开始和结束跨越多行的注释。以下是这两种注释风格的示例：
- en: '[PRE0]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Kotlin also provides a third type of comment, which is used for automatically
    generating documentation. This sort of comment begins with /** and ends with */.
    Documentation comments are used to describe variables, functions, and classes
    more formally, and they often include tags such as @param, @return, and @throws
    to explain standard aspects of a piece of code. Here’s an example that compares
    multiline and documentation comments:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: Kotlin 还提供了第三种类型的注释，用于自动生成文档。这种注释以 /** 开始，以 */ 结束。文档注释用于更正式地描述变量、函数和类，并且通常包含
    @param、@return 和 @throws 等标签，用以解释代码的标准部分。以下是一个比较多行注释和文档注释的示例：
- en: '[PRE1]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: While these two types of comments use a similar syntax, they serve different
    purposes. Multiline comments are intended to be read within the code file itself.
    Documentation comments, on the other hand, are intended to be exported from the
    code file to generate official documentation for production-ready code that other
    developers can consult.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这两种类型的注释使用了相似的语法，但它们的目的不同。多行注释旨在代码文件内部阅读。而文档注释则是为了从代码文件中导出，以生成正式的文档供其他开发人员参考生产就绪代码。
- en: Variables
  id: totrans-15
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 变量
- en: In coding, a *variable* is a name given to a data element. For simplicity, we
    can think of variables as containers that hold various data types in a computer’s
    memory. Once assigned, the variable name can be used as a stand-in for the value
    it represents. In this way, variables allow us to store and manage data, enabling
    the persistence of information within a program.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在编程中，*变量*是赋予数据元素的名称。为了简单起见，我们可以将变量视为存储计算机内存中各种数据类型的容器。一旦赋值，变量名就可以作为它所代表的值的代名词。通过这种方式，变量使我们能够存储和管理数据，从而实现程序中信息的持久性。
- en: Every variable should have a meaningful name that clearly describes its purpose
    or function or otherwise reflects the nature of the data assigned to it. For example,
    a variable holding a person’s name could be called name, and a variable holding
    a person’s age could be called age. By convention, variable names should consist
    of a lowercase word or use *camelCase* to join multiple words. In the latter case,
    no spaces appear between words, and every word after the first starts with a capital
    letter, as in lastName or ageInYears.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 每个变量应该有一个有意义的名称，清楚地描述它的用途或功能，或者反映所赋予数据的性质。例如，存储一个人名字的变量可以叫做 name，而存储一个人年龄的变量可以叫做
    age。根据约定，变量名应由小写单词组成，或者使用*驼峰命名法*连接多个单词。在后一种情况下，单词之间没有空格，每个单词的首字母大写，例如 lastName
    或 ageInYears。
- en: In Kotlin, you create a new variable by *declaring* its name with a keyword
    such as val or var and *initializing* it (assigning it to a value). (A *keyword*
    is a reserved word that has a special meaning in a programming language. A keyword
    can’t be used as an identifier—for example, as a variable or function name.) Which
    keyword you use depends on whether you want the variable’s value to stay the same
    or change during program execution. A variable declared with val is *read-only*,
    meaning its value can’t change after it’s been initialized. A variable declared
    with var is *mutable*, meaning the variable can be assigned a different value
    after it’s been initialized. You can change the value of a mutable variable as
    many times as needed.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Kotlin 中，你可以通过使用关键字如 val 或 var 声明变量的名称，并为其*初始化*（赋值）。(*关键字*是编程语言中具有特殊含义的保留字。关键字不能作为标识符使用——例如，不能用作变量名或函数名。)
    你选择哪个关键字取决于你是否希望变量的值在程序执行期间保持不变或发生变化。使用 val 声明的变量是*只读的*，意味着其值在初始化后不能更改。使用 var
    声明的变量是*可变的*，意味着该变量在初始化后可以被赋予不同的值。你可以根据需要多次更改可变变量的值。
- en: 'Consider this example, where we use two variables to create a message:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 参考这个例子，我们使用两个变量创建一个消息：
- en: '[PRE2]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'We declare two variables, name and age, and assign them the values "John Sinclair"
    and 30, respectively. Both variables are declared with the val keyword, so they
    can’t be reassigned to different values later. We then include both variables
    in a message to be printed to the console by adding a dollar sign ($) before each
    variable name. (We’ll discuss how this syntax works in more detail in “Working
    with Strings” on [page 14](#pg_14).) If you run this code (using CTRL-SHIFT-F10
    in IntelliJ IDEA), the output should look like this:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 我们声明了两个变量，name 和 age，并分别为它们赋值为“John Sinclair”和 30。这两个变量都是使用 val 关键字声明的，因此它们不能在之后被重新赋值。然后，我们通过在每个变量名前加上美元符号（$）将这两个变量包含在要打印到控制台的消息中。（我们将在“处理字符串”一章中详细讨论这种语法的工作原理，[请参见第14页](#pg_14)。）如果你运行这段代码（在
    IntelliJ IDEA 中使用 CTRL-SHIFT-F10），输出应该如下所示：
- en: '[PRE3]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Notice how the output shows the values assigned to the name and age variables
    rather than the variable names themselves. But what if we want to assign new values
    to these variables over the course of the program? For that, we have to use the
    var keyword instead of val, as shown here:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 注意输出中显示的是赋给 name 和 age 变量的值，而不是变量名本身。但如果我们希望在程序执行过程中为这些变量赋予新值怎么办？为此，我们必须使用 var
    关键字，而不是 val，如下所示：
- en: '[PRE4]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Here we declare the name and age variables with the var keyword, giving them
    the same initial values as before. Then we assign them new values ❶. Notice that
    the second time around, we no longer need the var (or val) keyword when setting
    the values of the variables. Once we’ve declared and initialized a variable for
    the first time, we can work with the variable using only its name.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用 `var` 关键字声明了 `name` 和 `age` 变量，赋予它们与之前相同的初始值。然后我们给它们分配了新值 ❶。注意第二次赋值时，我们不再需要
    `var`（或 `val`）关键字。一旦我们第一次声明并初始化了变量，就可以仅使用变量名来操作它。
- en: 'If you now run the program, this is what you should see:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 如果现在运行程序，应该看到以下内容：
- en: '[PRE5]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: We’ve successfully reassigned the variable names because they were declared
    with the var keyword. Try changing the var keyword back to val for one or both
    variables and running the code again. The IDE will instantly generate an error
    message about how you can’t assign a new value to a variable declared with val,
    and it won’t let you run the program until you fix the error.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经成功地重新分配了变量名，因为它们是用 `var` 关键字声明的。尝试将 `var` 关键字改回 `val`，然后重新运行代码。IDE 会立即生成一条错误信息，说明不能给用
    `val` 声明的变量赋新值，在修复错误之前无法运行程序。
- en: Constants
  id: totrans-29
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 常量
- en: 'Kotlin also provides the const keyword (short for *constant*) for setting the
    immutable value of a variable at the beginning of a file. The value must be known
    during compilation of the code. Declaring a variable with const is allowed only
    for primitive types or strings. (We discuss the common data types in Kotlin in
    the next section.) The judicious use of constants has two important benefits:
    it improves program efficiency in accessing fixed values, and it improves code
    clarity by avoiding hardcoded “magic numbers” deep inside the code without clear
    context. Here’s an example of creating a variable with the const keyword:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: Kotlin 还提供了 `const` 关键字（*constant* 的缩写），用于在文件开始时设置不可变的变量值。该值必须在代码编译期间已知。仅允许对原始数据类型或字符串使用
    `const` 声明变量。（我们将在下一节中讨论 Kotlin 的常见数据类型。）明智地使用常量有两个重要的好处：它提高了程序访问固定值的效率，并通过避免在代码深处硬编码没有明确上下文的“魔法数字”来提高代码的可读性。以下是使用
    `const` 关键字创建变量的示例：
- en: '[PRE6]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: In this case, we know the value of the mathematical constant pi, and we know
    that this value won’t change over the course of a program, so it makes sense to
    declare it using the const keyword at the start of the program. In Kotlin, it’s
    customary to use all caps for top-level constant names, as we’ve done here for
    PI. Multiple words can be joined using an underscore.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们知道数学常量 pi 的值，并且我们知道这个值在程序执行过程中不会改变，所以在程序开始时使用 `const` 关键字声明它是合理的。在
    Kotlin 中，习惯上使用全大写字母来表示顶级常量的名称，正如我们在这里为 PI 所做的那样。多个单词可以使用下划线连接。
- en: Kotlin has many other naming conventions for various code constructs. [Table
    1-1](chapter1.xhtml#tab1-1) summarizes the most common ones.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: Kotlin 还有许多其他命名约定适用于各种代码构造。[表 1-1](chapter1.xhtml#tab1-1) 总结了最常见的命名约定。
- en: 'Table 1-1: Naming Conventions in Kotlin'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 表 1-1：Kotlin 中的命名约定
- en: '| Name | Convention | Example |'
  id: totrans-35
  prefs: []
  type: TYPE_TB
  zh: '| 名称 | 约定 | 示例 |'
- en: '| --- | --- | --- |'
  id: totrans-36
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| Package name | Use lowercase letters with no underscores.Join multiple words
    or use camelCase.Use reverse domain notation (autogenerated by the IDE). | org.example.myProject
    |'
  id: totrans-37
  prefs: []
  type: TYPE_TB
  zh: '| 包名 | 使用小写字母且不带下划线。连接多个单词或使用驼峰式命名法。使用反向域名表示法（由 IDE 自动生成）。 | org.example.myProject
    |'
- en: '| Class name | Use PascalCase for class and inheritance names.Choose words
    that are nouns or noun phrases. | FlightSimulation |'
  id: totrans-38
  prefs: []
  type: TYPE_TB
  zh: '| 类名 | 对于类和继承名称，使用 PascalCase。选择名词或名词短语。 | FlightSimulation |'
- en: '| Function name | Use camelCase for function and method names.Use verbs or
    verb phrases. | calculateShortestPath() |'
  id: totrans-39
  prefs: []
  type: TYPE_TB
  zh: '| 函数名 | 对于函数和方法名称，使用驼峰式命名法。使用动词或动词短语。 | calculateShortestPath() |'
- en: '| Variable name | Use a single word or camelCase to join multiple words.Choose
    a word that describes the purpose, function, or property of the variable (make
    it meaningful). | username |'
  id: totrans-40
  prefs: []
  type: TYPE_TB
  zh: '| 变量名 | 使用单个单词或驼峰式命名法连接多个单词。选择一个描述变量目的、功能或属性的单词（使其有意义）。 | username |'
- en: '| Constant and final variable name | Use uppercase letters with underscores
    to separate words. | MAX_VALUE |'
  id: totrans-41
  prefs: []
  type: TYPE_TB
  zh: '| 常量和最终变量名 | 使用大写字母并用下划线分隔单词。 | MAX_VALUE |'
- en: These naming conventions are based on the recommendations in the official Kotlin
    documentation at [https://kotlinlang.org](https://kotlinlang.org). We’ll revisit
    them as we discuss the code constructs they relate to.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 这些命名约定基于 [Kotlin 官方文档](https://kotlinlang.org) 中的建议。我们将在讨论与之相关的代码构造时重新回顾它们。
- en: Common Data Types
  id: totrans-43
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 常见数据类型
- en: A value in code can be of various *data types*. For example, a value might represent
    a number, some text, or a logical value (true or false). In Kotlin, each variable
    is associated with a specific data type, and once a variable’s data type has been
    set, it can’t hold values of other types. A variable with a numeric value can
    be associated with different types, such as Int for whole numbers only or Double
    or Float for numbers with decimal components. A variable holding text values can
    be of type Char for a single character or type String for multiple characters.
    A logical value will have a Boolean type. [Table 1-2](chapter1.xhtml#tab1-2) lists
    the common data types in Kotlin and their key characteristics.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 代码中的一个值可以是各种*数据类型*。例如，一个值可能表示数字、一些文本或逻辑值（真或假）。在 Kotlin 中，每个变量都与特定的数据类型相关联，一旦变量的数据类型被设置，它就不能包含其他类型的值。一个持有数值的变量可以关联不同的类型，例如，Int
    仅用于整数，或者 Double 或 Float 用于包含小数部分的数字。一个持有文本值的变量可以是 Char 类型（单个字符）或 String 类型（多个字符）。一个逻辑值将是
    Boolean 类型。[表 1-2](chapter1.xhtml#tab1-2)列出了 Kotlin 中常见的数据类型及其主要特征。
- en: 'Table 1-2: Common Kotlin Data Types'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 表 1-2：Kotlin 常见数据类型
- en: '| Data type | Description | Size (in bits) | Range of values |'
  id: totrans-46
  prefs: []
  type: TYPE_TB
  zh: '| 数据类型 | 描述 | 大小（以位为单位） | 值的范围 |'
- en: '| --- | --- | --- | --- |'
  id: totrans-47
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- |'
- en: '| Byte | Signed integer | 8 | –128 to 127 |'
  id: totrans-48
  prefs: []
  type: TYPE_TB
  zh: '| Byte | 有符号整数 | 8 | –128 到 127 |'
- en: '| Short | Signed integer | 16 | –32,768 to 32,767 |'
  id: totrans-49
  prefs: []
  type: TYPE_TB
  zh: '| Short | 有符号整数 | 16 | –32,768 到 32,767 |'
- en: '| Int | Signed integer | 32 | –2,147,483,648 to 2,147,483,647 |'
  id: totrans-50
  prefs: []
  type: TYPE_TB
  zh: '| Int | 有符号整数 | 32 | –2,147,483,648 到 2,147,483,647 |'
- en: '| Long | Signed integer | 64 | –9,223,372,036,854,775,808 to 9,223,372,036,854,775,807
    |'
  id: totrans-51
  prefs: []
  type: TYPE_TB
  zh: '| Long | 有符号整数 | 64 | –9,223,372,036,854,775,808 到 9,223,372,036,854,775,807
    |'
- en: '| Float | Floating point (single precision) | 32 | –3.4028235E+38 to 3.4028235E+38
    |'
  id: totrans-52
  prefs: []
  type: TYPE_TB
  zh: '| Float | 浮点数（单精度） | 32 | –3.4028235E+38 到 3.4028235E+38 |'
- en: '| Double | Floating point (double precision) | 64 | –1.7976931348623157E+308
    to 1.7976931348623157E+308 |'
  id: totrans-53
  prefs: []
  type: TYPE_TB
  zh: '| Double | 浮点数（双精度） | 64 | –1.7976931348623157E+308 到 1.7976931348623157E+308
    |'
- en: '| Char | 16-bit Unicode character | 16 | 0 to 65,535 (in decimal) |'
  id: totrans-54
  prefs: []
  type: TYPE_TB
  zh: '| Char | 16 位 Unicode 字符 | 16 | 0 到 65,535（十进制） |'
- en: '| Boolean | Represents true or false | 1 | true or false |'
  id: totrans-55
  prefs: []
  type: TYPE_TB
  zh: '| Boolean | 表示真或假 | 1 | true 或 false |'
- en: '| String | A sequence of characters | Varies | N/A |'
  id: totrans-56
  prefs: []
  type: TYPE_TB
  zh: '| String | 字符序列 | 可变 | N/A |'
- en: We choose the data type for a variable based on problem-specific needs, focusing
    on factors such as the data type’s ability to accommodate values, its level of
    precision, and its memory utilization. If you know a numeric variable will hold
    only integer values, for example, Int would be a better choice than Float. If
    those values need to be exceptionally large, Long would be more appropriate than
    Int.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 我们根据特定问题的需求选择变量的数据类型，重点考虑数据类型能够容纳的值、精度级别和内存使用等因素。例如，如果你知道一个数值变量只会保存整数值，那么 Int
    会比 Float 更合适。如果这些值需要非常大，那么 Long 会比 Int 更适用。
- en: Type Inference
  id: totrans-58
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 类型推断
- en: 'When declaring a variable in Kotlin, it isn’t mandatory to explicitly specify
    its data type. The Kotlin compiler excels at *inferring* the variable’s data type
    based on the assigned value. Here, for example, Kotlin infers that name is of
    type String, since its value is a series of characters enclosed in quotation marks:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Kotlin 中声明变量时，并不强制要求显式指定其数据类型。Kotlin 编译器擅长根据赋予的值*推断*变量的数据类型。例如，在此代码中，Kotlin
    会推断出 name 是 String 类型，因为它的值是由引号括起来的一系列字符：
- en: '[PRE7]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'You also have the option to explicitly declare a variable’s data type. Here’s
    how to explicitly declare name as a String:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以选择显式声明变量的数据类型。以下是如何显式声明 name 为 String 类型：
- en: '[PRE8]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: To declare the data type, we place a colon after the variable name, followed
    by the desired type. This can be any acceptable data type, including custom data
    types you might have created to represent complex structures with specific properties
    and behaviors (for example, classes or data classes, which we’ll discuss in [Chapter
    2](chapter2.xhtml)).
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 要声明数据类型，我们在变量名后加冒号，后面跟上所需的类型。这可以是任何合法的数据类型，包括你可能创建的自定义数据类型，用于表示具有特定属性和行为的复杂结构（例如，类或数据类，我们将在[第
    2 章](chapter2.xhtml)中讨论）。
- en: 'For numeric values, Kotlin infers the Int type if a variable is first assigned
    a whole-number value or the Double type if it’s assigned a value with a decimal
    component. If you need a different numeric type, you can explicitly indicate it
    by using a type suffix at the end of the value itself, such as L for Long and
    f for Float. For example:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 对于数值类型，Kotlin会推断如果变量第一次被赋予一个整数值，则为Int类型；如果赋值为一个带小数部分的值，则为Double类型。如果需要不同的数值类型，可以通过在值的末尾使用类型后缀显式地指明，例如L表示Long，f表示Float。例如：
- en: '[PRE9]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: In this code, regularInt is inferred as Int by default, while floatNumber and
    longNumber are explicitly declared to be of types Float and Long, respectively,
    using the f and L suffixes.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在这段代码中，regularInt默认被推断为Int类型，而floatNumber和longNumber则通过使用f和L后缀显式声明为Float和Long类型。
- en: Type Casting
  id: totrans-67
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 类型转换
- en: '*Type casting*, also known as *type conversion*, is the process of changing
    a variable’s or expression’s data type to another compatible data type. (An *expression*
    is a code snippet that evaluates to a particular data type.) This process is primarily
    used to resolve type mismatches. In general, Kotlin enforces strict type checking
    to prevent common sources of runtime errors, such as unintended type conversions.
    Implicit type casting may be allowed only when no risk of data loss or unexpected
    behavior exists. For example, smaller numeric types can be implicitly promoted
    to larger numeric types since no risk of data loss exists, as shown here:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '*类型转换*，也称为*类型转换*，是将变量或表达式的数据类型转换为另一种兼容数据类型的过程。（*表达式*是评估为特定数据类型的代码片段。）这个过程主要用于解决类型不匹配问题。通常，Kotlin会执行严格的类型检查，以防止常见的运行时错误来源，例如意外的类型转换。只有在不存在数据丢失或意外行为的风险时，才允许隐式类型转换。例如，可以隐式地将较小的数值类型提升为较大的数值类型，因为不存在数据丢失的风险，如下所示：'
- en: '[PRE10]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'We take the value of the intNumber variable and assign it to the longNumber
    variable, implicitly converting the value from type Int to Long. This may work,
    but the default setting of most IDEs is to prevent the use of implicit type casting
    altogether. Instead, you’re encouraged to use explicit type-casting methods to
    achieve type conversion. Some of the common type-casting methods supported in
    Kotlin include toByte(), toInt(), toLong(), toShort(), toDouble(), toFloat(),
    toChar(), and toString(). Here is an example of explicit type casting:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 我们获取intNumber变量的值并将其赋给longNumber变量，隐式地将该值从Int类型转换为Long类型。这可能是有效的，但大多数IDE的默认设置是完全禁止使用隐式类型转换。相反，建议你使用显式的类型转换方法来实现类型转换。在Kotlin中，常见的类型转换方法包括toByte()、toInt()、toLong()、toShort()、toDouble()、toFloat()、toChar()和toString()。下面是一个显式类型转换的例子：
- en: '[PRE11]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: We first create the intNumber variable and assign it a value of 44. The compiler
    will infer intNumber to be of the Int type. Then we explicitly cast it to type
    Double using the toDouble() method before assigning it to doubleNumber.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先创建intNumber变量并赋值为44。编译器将推断intNumber为Int类型。然后，我们使用toDouble()方法将其显式转换为Double类型，并将其赋值给doubleNumber。
- en: 'Since type casting is allowed only when the associated data types are compatible,
    not all conversions are possible. For example, you can’t always convert a text
    type into a numeric or logical type. To illustrate, try running the following
    lines of code:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 由于类型转换仅在相关数据类型兼容时才允许，并非所有转换都是可能的。例如，你不能总是将文本类型转换为数值类型或逻辑类型。为了说明这一点，尝试运行以下代码行：
- en: '[PRE12]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Here we try to take the string in the message variable and cast it to an integer
    with the toInt() method. This will throw a NumberFormatException error at runtime,
    indicating the conversion isn’t possible due to the incompatible data types. This
    error seems reasonable: How should Kotlin know the numeric equivalent of the "Hello,
    world!" string?'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们尝试将消息变量中的字符串通过toInt()方法转换为整数。这将在运行时抛出NumberFormatException错误，表示由于数据类型不兼容，转换无法完成。这个错误看起来是合理的：Kotlin怎么知道“Hello,
    world!”字符串的数字等价物呢？
- en: Operators
  id: totrans-76
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 操作符
- en: '*Operators* are special symbols for manipulating variables and other values
    in your code. Each operator performs a specific mathematical, logical, or text-based
    operation. In this section, we’ll review the most common categories of operators
    in Kotlin.'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '*操作符*是用于操作代码中变量和其他值的特殊符号。每个操作符执行特定的数学、逻辑或基于文本的操作。在本节中，我们将回顾Kotlin中最常见的操作符类别。'
- en: Arithmetic
  id: totrans-78
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 算术
- en: 'Arithmetic operators are for performing basic mathematical operations such
    as addition (+), subtraction (-), multiplication (*), and division (/). Here are
    some examples of how to use arithmetic operators in Kotlin:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 算术运算符用于执行基本的数学运算，如加法（+）、减法（-）、乘法（*）和除法（/）。以下是一些如何在 Kotlin 中使用算术运算符的例子：
- en: '[PRE13]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Here we apply the four main arithmetic operations to the a and b variables.
    Notice that when you divide two integers using the division operator /, the result
    is also an integer, with any fractional part discarded. In this case, 20 / 7 gives
    a result of 2, not 2.857143. If you need to retain the fractional part, you must
    convert one of the numbers into a floating-point number, as shown here:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们对 a 和 b 变量应用了四个主要的算术运算。请注意，当你使用除法运算符 `/` 除以两个整数时，结果也是一个整数，任何小数部分都会被舍弃。在这种情况下，20
    / 7 的结果是 2，而不是 2.857143。如果你需要保留小数部分，必须将其中一个数字转换为浮点数，如下所示：
- en: '[PRE14]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Here, quotientInt will have a value of 2, but quotientFloat will have a value
    of 2.857143 since we use toFloat() to convert a from an integer to a floating-point
    number.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`quotientInt` 的值为 2，但 `quotientFloat` 的值为 2.857143，因为我们使用 `toFloat()` 将
    a 从整数转换为浮点数。
- en: 'The *remainder* or *modulo* operator is another mathematical operator we’ll
    use many times in this book. It’s designated by the % symbol. This operator returns
    only the remainder from the integer division of two numbers. Here’s an example:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '*余数* 或 *取模* 运算符是我们在本书中将多次使用的另一个数学运算符。它由 `%` 符号表示。这个运算符仅返回两个数字整数除法的余数。以下是一个例子：'
- en: '[PRE15]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: In this example, a % b returns the remainder when a is divided by b. Since 20
    divided by 7 has a remainder of 6, the value of result is 6. Can you guess what
    the result would be if we flipped the numbers around—that is, if we calculated
    7 % 20? Additionally, what would be the result of the integer division 7 / 20?
    These questions may sound trivial, but I encourage you to write a few lines of
    code to verify your guesses.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，`%` 运算符返回当 a 被 b 除时的余数。由于 20 除以 7 的余数是 6，所以结果的值是 6。你能猜出如果我们交换这两个数字——也就是计算
    7 % 20，结果会是多少吗？另外，整数除法 7 / 20 的结果会是多少呢？这些问题可能听起来很简单，但我鼓励你写几行代码来验证你的猜测。
- en: 'Kotlin uses the same order of operations for arithmetic operators as regular
    mathematics: division and multiplication take precedence over addition and subtraction.
    To avoid confusion about the order of operations, it’s good practice to use parentheses
    to clearly isolate different operational blocks. For example:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: Kotlin 使用与常规数学相同的运算符优先级：除法和乘法优先于加法和减法。为了避免对运算顺序的混淆，最好使用括号来清晰地隔离不同的运算块。例如：
- en: '[PRE16]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: In the first calculation, 5 + 3 * 2, multiplication takes precedence over addition,
    so it evaluates to 5 + (3 * 2), resulting in 11. In the second calculation, (5
    + 3) * 2, the addition inside the parentheses is performed first, and then the
    multiplication, resulting in 16. This demonstrates how using parentheses can clarify
    and control the order of operations in mathematical expressions.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一个计算中，5 + 3 * 2，乘法优先于加法，因此计算为 5 + (3 * 2)，结果为 11。第二个计算中，(5 + 3) * 2，括号内的加法先执行，然后是乘法，结果为
    16。这演示了如何通过使用括号来明确和控制数学表达式中的运算顺序。
- en: '#### Assignment'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '#### 赋值'
- en: 'Assignment operators are used to assign values to variables. We’ve already
    been using the main assignment operator (=) throughout this chapter’s examples
    to set a variable’s value from scratch. Other assignment operators, like += and
    -=, take a variable’s existing value and modify it. Here are some examples:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 赋值运算符用于给变量赋值。在本章的例子中，我们已经使用了主要的赋值运算符（=）来初始化变量的值。其他赋值运算符，如 `+=` 和 `-=`，会修改变量的现有值。以下是一些例子：
- en: '[PRE17]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The assignment a += 5 is equivalent to saying, “Take the value of a, add 5 to
    it, and put the result back in the a variable.” Similar assignment operators exist
    for the other three arithmetic operations.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 赋值 `a += 5` 相当于说：“取 a 的值，给它加 5，然后将结果放回 a 变量中。”其他三个算术运算的赋值运算符也有类似的用法。
- en: 'You can try using += with a string variable too, if it was declared with var.
    For example:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 如果字符串变量是用 `var` 声明的，你也可以尝试使用 `+=`。例如：
- en: '[PRE18]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Be mindful that this operation essentially creates a new string and assigns
    it to the previously used variable name, rather than directly modifying the old
    string (which is discarded). For strings, other assignment operators (for example,
    -=) will generate errors.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，这个操作本质上是创建一个新的字符串并将其赋值给之前使用的变量名，而不是直接修改旧的字符串（旧字符串会被丢弃）。对于字符串，其他赋值运算符（例如，-=）会产生错误。
- en: Unary
  id: totrans-97
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 一元
- en: 'Whereas most operators have two operands, unary operators have just one. The
    *increment* (++) and *decrement* (--) unary operators increase or decrease a variable’s
    value by 1, respectively. Here’s how to use these operators in Kotlin:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数运算符都有两个操作数，而一元运算符只有一个。*增量*（++）和 *减量*（--）一元运算符分别将变量的值增加或减少 1。以下是如何在 Kotlin
    中使用这些运算符：
- en: '[PRE19]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Essentially, a++ is a shorter way of writing a += 1, itself a shorter way of
    writing a = a + 1. Likewise, a-- is equivalent to a -= 1.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 本质上，a++ 是 a += 1 的简写，a += 1 又是 a = a + 1 的简写。同样，a-- 等同于 a -= 1。
- en: Relational
  id: totrans-101
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 关系
- en: 'Relational operators compare two values and return a Boolean value (true or
    false) based on the comparison. These operators include == and != for equality
    and inequality, and > and < for greater than and less than. Here are some examples
    of these operators in action:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 关系运算符比较两个值并根据比较结果返回布尔值（true 或 false）。这些运算符包括用于相等和不等的 == 和 !=，以及用于大于和小于的 > 和
    <。以下是这些运算符的示例：
- en: '[PRE20]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: In this code segment, isEqual will be false because a and b aren’t equal, and
    isNotEqual will be true. Meanwhile, isGreater will be true because a is greater
    than b, and isLesser will be false. Notice how we put each comparison in parentheses.
    This isn’t strictly necessary, but it helps visually separate the comparison from
    the assignment operation it’s a part of.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个代码段中，isEqual 将是 false，因为 a 和 b 不相等，isNotEqual 将是 true。与此同时，isGreater 将是 true，因为
    a 大于 b，isLesser 将是 false。请注意，我们将每个比较放在括号中。这并不是严格必要的，但它有助于在视觉上将比较与它所参与的赋值操作分开。
- en: 'The preceding examples used numeric values, but relational operators can also
    be used for comparing strings:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的例子使用了数值，但关系运算符也可以用于比较字符串：
- en: '[PRE21]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: In Kotlin, strings are compared lexicographically, character by character, based
    on their Unicode values. The comparison starts from the first character of each
    string and continues until a difference is found or one of the strings ends. The
    string with the smaller Unicode value at the first differing character is considered
    lesser. This implies that earlier letters in the alphabet are considered lesser
    than later letters and that uppercase letters are considered lesser than lowercase
    letters.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Kotlin 中，字符串是按字典顺序逐字符比较的，基于它们的 Unicode 值。比较从每个字符串的第一个字符开始，直到找到差异或其中一个字符串结束为止。第一个不同字符的
    Unicode 值较小的字符串被视为较小的字符串。这意味着字母表中较前的字母被认为较小，大写字母被认为较小于小写字母。
- en: Logical
  id: totrans-108
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 逻辑
- en: 'Logical operators are used to perform logical operations such as AND (&&),
    OR (||), and NOT (!) on Boolean values. Here are some examples of how to use logical
    operators in Kotlin:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 逻辑运算符用于对布尔值执行逻辑运算，如 AND（&&）、OR（||）和 NOT（!）。以下是如何在 Kotlin 中使用逻辑运算符的示例：
- en: '[PRE22]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The result of a logical operation involving two Boolean values can be summarized
    in a *truth table* like the one shown in [Table 1-3](chapter1.xhtml#tab1-3). A
    truth table shows the output corresponding to every possible combination of input
    values.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 涉及两个布尔值的逻辑操作的结果可以通过一个 *真值表* 来总结，如[表 1-3](chapter1.xhtml#tab1-3)所示。真值表显示了每个可能输入值组合对应的输出结果。
- en: 'Table 1-3: Truth Table for Two Logical Values'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 表 1-3：两个逻辑值的真值表
- en: '| Value 1 | Value 2 | AND | OR |'
  id: totrans-113
  prefs: []
  type: TYPE_TB
  zh: '| Value 1 | Value 2 | AND | OR |'
- en: '| --- | --- | --- | --- |'
  id: totrans-114
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- |'
- en: '| true | true | true | true |'
  id: totrans-115
  prefs: []
  type: TYPE_TB
  zh: '| true | true | true | true |'
- en: '| true | false | false | true |'
  id: totrans-116
  prefs: []
  type: TYPE_TB
  zh: '| true | false | false | true |'
- en: '| false | true | false | true |'
  id: totrans-117
  prefs: []
  type: TYPE_TB
  zh: '| false | true | false | true |'
- en: '| false | false | false | false |'
  id: totrans-118
  prefs: []
  type: TYPE_TB
  zh: '| false | false | false | false |'
- en: In this table, the operands are Boolean values, which can be either true or
    false. For example, in the first row, both Value 1 and Value 2 are true. The result
    of an AND operation on these operands is true, and the result of an OR operation
    is also true. Unlike AND and OR, a NOT operation has just one Boolean operand,
    which gets inverted. For instance, the NOT operator turns true into false.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个表中，操作数是布尔值，可以是 true 或 false。例如，在第一行中，Value 1 和 Value 2 都为 true。对这些操作数进行 AND
    操作的结果是 true，OR 操作的结果也是 true。与 AND 和 OR 不同，NOT 操作只有一个布尔操作数，并且该操作数会被取反。例如，NOT 操作符将
    true 变为 false。
- en: Working with Strings
  id: totrans-120
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 操作字符串
- en: In Kotlin, a *string* is a sequence of characters represented by the String
    data type. Strings are helpful for storing and manipulating text data in a program.
    They’re commonly used to represent words, sentences, and other textual information.
    User input data is also initially read as strings and then converted as needed
    into other types using functions such as toInt(), toDouble(), and toBoolean().
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 在Kotlin中，*字符串*是由String数据类型表示的一系列字符。字符串在程序中非常有用，可以用来存储和处理文本数据。它们通常用于表示单词、句子以及其他文本信息。用户输入的数据通常也会先作为字符串读取，然后根据需要通过函数如toInt()、toDouble()和toBoolean()转换为其他类型。
- en: The individual characters in a string are numbered, or *indexed*, starting from
    zero. You can access a specific character in a string by placing its index in
    square brackets after the variable name representing that string. For example,
    to get the second character of a string in the msg variable, use msg[1]. Alternatively,
    you can use the get() method of the String class to retrieve the character at
    a specific index. For example, msg.get(1) returns the same second character as
    msg[1].
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 字符串中的各个字符是按顺序编号的，或者说是*索引*，从零开始。你可以通过在表示该字符串的变量名后面加上方括号中的索引来访问字符串中的特定字符。例如，要获取msg变量中字符串的第二个字符，可以使用msg[1]。另外，你还可以使用String类的get()方法来检索特定索引处的字符。例如，msg.get(1)返回与msg[1]相同的第二个字符。
- en: In this section, we’ll discuss some common techniques for working with strings.
    Keep in mind as you read that strings are immutable objects in Kotlin, so once
    a string is created, its content can’t be changed. Any operation that appears
    to modify a string creates a new string, and the original value is discarded.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将讨论一些常见的字符串操作技巧。在阅读时请记住，Kotlin中的字符串是不可变对象，因此一旦创建了一个字符串，它的内容是无法更改的。任何看似修改字符串的操作都会创建一个新字符串，原始值会被丢弃。
- en: Concatenation
  id: totrans-124
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 连接
- en: '*Concatenation* is the process of combining two or more strings into a single
    string. In Kotlin, you can do this in multiple ways. For example, you can use
    the + operator, or you can use a string’s plus() method. Both techniques are demonstrated
    here:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '*连接*是将两个或多个字符串合并为一个字符串的过程。在Kotlin中，你可以使用多种方式实现这一点。例如，你可以使用+运算符，或者你可以使用字符串的plus()方法。这里演示了这两种技术：'
- en: '[PRE23]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'In this code segment, we first create two string variables, a and b, with values
    "Hello," and "world!", respectively. Then we use the + operator to concatenate
    (join) the two strings and add a space (the string " ") in between, assigning
    the resulting string to the c variable. The output of println(c) is:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 在这段代码中，我们首先创建了两个字符串变量a和b，分别赋值为"Hello,"和"world!"。然后我们使用+运算符将两个字符串连接（拼接）在一起，并在它们之间添加一个空格（字符串"
    "），将结果字符串赋值给c变量。println(c)的输出是：
- en: '[PRE24]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Notice how we call the plus() method twice in the same expression to concatenate
    string a with a space and string b. This technique is known as *method chaining*;
    the second method call is applied to the result of the first.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 注意我们在同一个表达式中调用了两次plus()方法，将字符串a与空格以及字符串b连接起来。这种技术被称为*方法链*；第二次方法调用是应用于第一次方法调用的结果。
- en: 'Another way to join multiple strings is to use the buildString function, as
    in this example:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种连接多个字符串的方法是使用buildString函数，如以下示例所示：
- en: '[PRE25]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: We create a variable c to hold the concatenated string and append all the string
    segments through a single call to the buildString function.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了一个变量c来存储连接后的字符串，并通过一次调用buildString函数将所有字符串片段附加在一起。
- en: String Templates
  id: totrans-133
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 字符串模板
- en: 'Most characters that appear between the opening and closing quotation marks
    of a string are interpreted literally as ordinary text. *String templates*, however,
    are a powerful feature in Kotlin that allow you to embed code within a string.
    They’re a concise and expressive way to combine static text with dynamic values
    resulting from variables, expressions, or even function calls. As hinted at when
    we first discussed variables, string templates use dollar signs ($) to signal
    that what follows should be treated as code rather than as literal text. For example,
    consider the following code snippet:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 字符串中出现在开头和结尾的引号之间的大多数字符会被字面理解为普通文本。然而，*字符串模板*是Kotlin中的一个强大功能，它允许你在字符串中嵌入代码。它们是一种简洁而富有表现力的方式，可以将静态文本与来自变量、表达式甚至函数调用的动态值结合起来。如我们在最初讨论变量时所暗示的那样，字符串模板使用美元符号（$）来表示接下来的内容应被视为代码，而不是字面文本。例如，考虑以下代码片段：
- en: '[PRE26]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Here we embed the variables name and age within the message string template
    using the $ symbol. The values of these variables are automatically substituted
    into the resulting string when it’s evaluated. When you run this code snippet,
    the output should therefore look like this:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用 $ 符号将变量 name 和 age 嵌入到消息字符串模板中。这些变量的值在字符串评估时会自动被替换为实际的值。因此，当你运行这段代码时，输出应该像这样：
- en: '[PRE27]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Notice how John and 30 have been inserted into the string in place of $name
    and $age. Compare the string template syntax with how we might generate the same
    message using string concatenation:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，John 和 30 已经替换了字符串中的 $name 和 $age。比较字符串模板语法与我们使用字符串连接生成相同消息的方式：
- en: '[PRE28]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: The string template version is much more readable and spares us from the tedium
    of including all the + operators and remembering to add spaces to the strings
    before and after each variable. This isn’t to say that string concatenation is
    never useful, but if your goal is to inject values from your code into a string,
    a string template is likely the better choice.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 字符串模板版本更加易读，省去了包含所有 + 操作符以及记得在每个变量前后添加空格的繁琐。这并不是说字符串连接永远没有用处，但如果你的目标是将代码中的值注入到字符串中，字符串模板可能是更好的选择。
- en: 'String templates can also handle more complex expressions by enclosing them
    within braces (the {and} symbols) after the dollar sign. This allows you to perform
    calculations, access object properties, or invoke functions directly within the
    template. Here’s an example:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 字符串模板还可以处理更复杂的表达式，通过在美元符号后面使用大括号（{和}符号）将其括起来。这允许你在模板中直接执行计算、访问对象属性或调用函数。下面是一个例子：
- en: '[PRE29]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: The ${x + y} in this string template tells Kotlin to add the values in the x
    and y variables and insert the result into the string.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 这个字符串模板中的 ${x + y} 告诉 Kotlin 将 x 和 y 变量的值相加，并将结果插入到字符串中。
- en: Escape Sequences
  id: totrans-144
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 转义序列
- en: '*Escape sequences* are special character combinations used in strings to represent
    characters such as whitespace that are difficult to input directly. They’re prefixed
    with a backslash. For example, the escape sequence \n represents a newline character,
    and \t represents a tab character. Escape sequences are often used within string
    templates to format the output. Here’s an example:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '*转义序列* 是在字符串中表示像空白符这样难以直接输入的字符的特殊字符组合。它们以反斜杠为前缀。例如，转义序列 \n 表示换行符，\t 表示制表符。转义序列常用于字符串模板中以格式化输出。下面是一个例子：'
- en: '[PRE30]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'In this example, the \n in the middle of the message string adds a line break
    between the name and age, improving the formatting of the output. If you run the
    code, the output should break across two lines, like this:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，消息字符串中间的 \n 添加了一个换行符，在姓名和年龄之间创建了一个行断裂，从而改善了输出的格式。如果你运行代码，输出应该会分成两行，如下所示：
- en: '[PRE31]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Other common escape sequences include \\ for a backslash and \$ for a dollar
    sign. These are needed because otherwise a backslash in a string is interpreted
    as the start of an escape sequence and a dollar sign as the start of some Kotlin
    code to be inserted into a string template.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 其他常见的转义序列包括 \\ 表示反斜杠和 \$ 表示美元符号。这些是必需的，因为如果没有这些符号，字符串中的反斜杠会被解释为转义序列的开始，而美元符号会被解释为开始
    Kotlin 代码并将其插入到字符串模板中。
- en: '### Null and Nullable Types'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '### Null 和可空类型'
- en: '*Null* represents the absence of a value. By default, Kotlin’s type system
    assumes that a variable can’t hold null. Consider this example:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: '*Null* 表示没有值。默认情况下，Kotlin 的类型系统假设变量不能包含 null。考虑这个例子：'
- en: '[PRE32]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'The str variable is declared to be of the String type, so its value must be
    a string. Trying to set the variable to null will therefore trigger an error.
    If you want to allow a variable to be null, you must explicitly declare the variable
    to be of a *nullable type* by appending ? to the type declaration, as shown here:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: str 变量被声明为 String 类型，因此它的值必须是一个字符串。尝试将该变量设置为 null 将会触发错误。如果你想允许变量为 null，必须通过在类型声明后附加
    ? 来显式声明变量为*可空类型*，如下所示：
- en: '[PRE33]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'The type declaration str: String? indicates that the str variable can hold
    either a string or null. Because the variable is of the String? nullable type,
    setting it to null is now valid and won’t cause an error.'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: '类型声明 str: String? 表示 str 变量可以包含字符串或 null。由于该变量是 String? 可空类型，因此将其设置为 null 现在是有效的，并且不会导致错误。'
- en: Kotlin’s not-nullable-by-default type system is designed to prevent *null pointer
    exceptions*, which are common runtime errors in languages that freely allow variables
    to have null values. A null pointer exception occurs when a program tries to access
    or manipulate data using a null reference, which doesn’t point to a valid memory
    location or object. Proper handling of null values is essential to prevent these
    exceptions and the code from crashing.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: Kotlin 的默认非空类型系统旨在防止 *空指针异常*，这是在允许变量具有 null 值的语言中常见的运行时错误。空指针异常发生在程序尝试使用空引用访问或操作数据时，而空引用不指向有效的内存位置或对象。正确处理空值对于防止这些异常和程序崩溃至关重要。
- en: 'You can ensure null safety in Kotlin in multiple ways. One way is to explicitly
    check whether a nullable variable holds null, before accessing its properties
    or methods. For instance:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过多种方式确保 Kotlin 中的空安全性。其中一种方法是在访问可空变量的属性或方法之前，显式地检查它是否为 null。例如：
- en: '[PRE34]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: In this example, we check whether the variable str is null by using an if...else
    conditional statement. If str is not null, its length property is accessed; otherwise,
    -1 is assigned to len. (We’ll discuss conditional statements in the next section.)
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们通过使用 if...else 条件语句检查变量 str 是否为 null。如果 str 不是 null，则访问其 length 属性；否则，将
    -1 赋值给 len。（我们将在下一节讨论条件语句。）
- en: 'Another mechanism is Kotlin’s *safe call operator* (?.), which allows us to
    call a method on a nullable object without risking an error. If the object contains
    null, the result is null as well. Otherwise, the method is called as usual. For
    example:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种机制是 Kotlin 的 *安全调用运算符* (?.)，它允许我们在可空对象上调用方法，而不会引发错误。如果对象为 null，结果也将是 null；否则，方法将像往常一样被调用。例如：
- en: '[PRE35]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: In this case, if str is null, len will be assigned null; otherwise, len will
    be assigned the length (number of characters) of str.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，如果 str 为 null，则 len 将被赋值为 null；否则，len 将被赋值为 str 的长度（字符数）。
- en: 'Kotlin also provides the *Elvis operator* (?:). Used in conjunction with the
    safe call operator, it allows you to give a default value (instead of null) for
    an expression involving a nullable object. If the object isn’t null, the expression
    will be evaluated as normal; otherwise, the default value will be used. For example:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: Kotlin 还提供了 *Elvis 运算符* (?:)。它与安全调用运算符一起使用时，可以为涉及可空对象的表达式提供默认值（而非 null）。如果对象不是
    null，则正常评估表达式；否则，将使用默认值。例如：
- en: '[PRE36]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'In this case, if str isn’t null, its length will be assigned to the len variable;
    otherwise, the value after the ?: operator (-1) will be assigned.'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: '在这种情况下，如果 str 不是 null，则其长度将被赋值给 len 变量；否则，将使用 ?: 运算符后的值（-1）。'
- en: NOTE
  id: totrans-166
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 注意
- en: '*The examples we’ve discussed so far have focused on the* String? *nullable
    type, but note that the* ? *operator can be applied to other data types, such
    as* Int*,* Double*, or even* Boolean*. This flexibility in using nullable types
    is particularly helpful when working with user input.*'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: '*到目前为止，我们讨论的示例主要集中在* String? *可空类型，但请注意，* ? *运算符也可以应用于其他数据类型，如* Int*、* Double*，甚至是*
    Boolean*。在处理用户输入时，使用可空类型的灵活性特别有帮助。*'
- en: 'Finally, Kotlin has another related operator called the *null assertion operator*
    (also called the *double-bang operator*), denoted by two exclamation points (!!).
    It can be used to assert that a nullable variable doesn’t contain null even though
    the compiler can’t guarantee this to be true. Using !! is a way of saying that
    you’re sure a particular nullable variable isn’t null so that the compiler will
    skip checking for nullability. Here’s an example:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，Kotlin 还有一个相关的运算符，叫做 *空断言运算符*（也称为 *双感叹号运算符*），用两个感叹号 (!!) 表示。它可以用来断言一个可空变量不为
    null，尽管编译器无法保证这一点。使用 !! 是在告诉编译器你确信某个可空变量不为 null，这样编译器就会跳过 null 安全检查。以下是一个示例：
- en: '[PRE37]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: We declare name as a nullable string, but by using !! while accessing the string’s
    length, we’re asserting that it’s not null. If name actually were null, this snippet
    would result in a NullPointerException. As such, it’s best to avoid or limit the
    use of the null assertion operator and favor safer constructs like safe calls
    (?.) and null checks (?:). Alternatively, aim to design your code to reduce nullable
    types, for increased reliability and predictability.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将 name 声明为可空字符串，但在访问字符串的长度时使用 !!，这意味着我们断言它不为 null。如果 name 实际上为 null，代码将抛出
    NullPointerException。因此，最好避免或限制使用空断言运算符，而是使用更安全的构造，如安全调用 (?.) 和空检查 (?:)。或者，旨在设计代码以减少可空类型，从而提高可靠性和可预测性。
- en: Flow Control
  id: totrans-171
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 流程控制
- en: '*Flow control* is an essential aspect of programming, providing mechanisms
    to regulate when and how code is executed. Kotlin’s flow control constructs enable
    developers to create flexible and dynamic programs by effectively managing the
    sequence of statements and controlling the program’s behavior. In this section
    we’ll discuss two important types of control structures: conditionals and loops.
    These concepts are foundational to any programming language.'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: '*流程控制*是编程中的一个重要方面，它提供了机制来调节代码的执行时机和方式。Kotlin 的流程控制结构使开发者能够通过有效管理语句的顺序和控制程序的行为，创建灵活且动态的程序。在本节中，我们将讨论两种重要的控制结构：条件语句和循环。这些概念是任何编程语言的基础。'
- en: Conditional Statements
  id: totrans-173
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 条件语句
- en: 'Conditional statements allow you to determine what a program should do based
    on certain tests. Kotlin has two primary conditional statements: if and when.
    They both introduce branching into code, the idea that a program can take different
    forks depending on the circumstances. In general, if statements are appropriate
    for straightforward binary decisions or when facing a limited number of conditions.
    On the other hand, if you need to manage several conditions, handle various cases,
    or strive for cleaner and more structured code when implementing branching logic,
    when could be your preferred tool.'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 条件语句允许你根据特定的测试来决定程序应该做什么。Kotlin 有两种主要的条件语句：if 和 when。它们都引入了代码的分支结构，即程序可以根据不同情况走不同的分支。一般来说，if
    语句适用于直接的二元决策或面对有限条件时；而如果你需要处理多个条件、管理各种情况，或者在实现分支逻辑时希望代码更加简洁和结构化，when 可能是你的首选工具。
- en: if Statements
  id: totrans-175
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: if 语句
- en: 'An if statement runs a block of code when a given condition evaluates to true.
    Here’s a simple example:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 当给定条件的计算结果为真时，if 语句会运行一段代码。以下是一个简单的示例：
- en: '[PRE38]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: The condition for an if statement, in this case x > 0, must be an expression
    that evaluates to a Boolean true or false value, and it must be given in parentheses
    after the if keyword. The code after the condition will run if the condition is
    true, so this snippet prints a message only when the variable x has a positive
    value. If x isn’t positive, the println statement will simply be skipped.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: if 语句的条件，在本例中为 x > 0，必须是一个能够计算出布尔值（真或假）的表达式，并且必须放在 if 关键字后面的括号中。如果条件为真，条件后的代码将被执行，因此这段代码仅在变量
    x 为正值时打印消息。如果 x 不是正数，println 语句将被跳过。
- en: 'An if statement can have an optional else clause that gets executed if the
    test expression evaluates to false. Once an else clause is included (or if there’s
    just an if clause but it includes multiple lines of code), the body of each clause
    should be indented and enclosed in braces, as shown here:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: if 语句可以有一个可选的 else 子句，当测试表达式计算结果为假时，else 子句会被执行。一旦包含了 else 子句（或者只有 if 子句但包含了多行代码），每个子句的主体应该缩进并用花括号括起来，如下所示：
- en: '[PRE39]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: This time, since the x > 0 condition evaluates to false, the code in the else
    clause will run. Notice how the opening brace goes on the same line as the if
    or else keyword, while the closing brace goes on a new line after the last statement
    in that clause.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 这次，由于 x > 0 条件计算结果为假，else 子句中的代码将被执行。注意，左花括号与 if 或 else 关键字在同一行，而右花括号则在该子句最后一条语句之后的新一行上。
- en: 'You can extend an if...else structure to include three or more possible branches
    by adding else if clauses between the initial if and the final else. Each else
    if clause adds a new condition to test if the previous condition is found to be
    false. Here’s an example:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过在初始 if 语句和最终 else 语句之间添加 else if 子句，扩展 if...else 结构来包含三个或更多的可能分支。每个 else
    if 子句都会添加一个新条件，用于测试前一个条件是否为假。以下是一个示例：
- en: '[PRE40]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Here, we initialize two variables, a and b, with the values 100 and -30, respectively.
    Subsequently, we declare a variable max of type Int without providing an initial
    value ❶. (In Kotlin, this is allowed as long as the variable will eventually be
    initialized before using it for the first time.) We then use an if...else if...else
    structure to compare the values of a and b and print an appropriate message. First,
    the if clause tests if a is greater than b. If this fails, the else if clause
    tests if a is less than b. If this also fails, a and b must be equal, as the else
    clause says.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们初始化了两个变量`a`和`b`，分别赋值为100和-30。随后，我们声明了一个类型为Int的`max`变量，但没有提供初始值❶。（在Kotlin中，只要变量在首次使用之前会被初始化，这是允许的。）然后，我们使用`if...else
    if...else`结构来比较`a`和`b`的值并打印相应的消息。首先，`if`子句测试`a`是否大于`b`。如果不成立，`else if`子句会测试`a`是否小于`b`。如果这个条件也不成立，那么`a`和`b`必须相等，因为`else`子句这么说。
- en: 'The syntax for this kind of control structure is:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 这种控制结构的语法是：
- en: '[PRE41]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: You can adjust this template by adding more else if blocks or deleting them
    altogether, depending on your needs.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过添加更多的`else if`块或完全删除它们来调整这个模板，具体取决于你的需求。
- en: when Statements
  id: totrans-188
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: when语句
- en: 'A when statement checks a value against multiple conditions and executes the
    code block of the first matching condition. If you’re familiar with switch statements
    from languages like Java, C, or C++, the concept is similar. A when statement
    can also have an else clause for when none of the conditions match, as shown here:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: '`when`语句会将一个值与多个条件进行比较，并执行第一个匹配条件的代码块。如果你熟悉Java、C或C++等语言中的`switch`语句，概念是类似的。`when`语句还可以包含一个`else`子句，用于在没有条件匹配时执行，如下所示：'
- en: '[PRE42]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: We assign a value of 5 to the variable x, then use a when statement to test
    this variable’s value. Each line of the when statement has its own conditional
    test (such as x > 0) followed by the -> symbol, which points to the expression
    that should be executed if the condition is true. As soon as a true condition
    is found, the remainder of the when statement is skipped, even if it contains
    additional tests that would pass. In this case, since x is greater than 0, the
    when statement will print "x is positive".
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将5赋值给变量x，然后使用`when`语句测试该变量的值。`when`语句的每一行都有自己的条件测试（如`x > 0`），后跟`->`符号，指向在条件为真时应执行的表达式。只要找到一个为真的条件，`when`语句将跳过其余部分，即使它包含其他可能满足的测试。在这个例子中，由于x大于0，`when`语句会打印“x是正数”。
- en: As with if statements, including an else clause in a when statement is optional.
    However, it’s considered good practice to provide an else clause; it improves
    the robustness of your code by offering a fallback option for unmatched cases.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 与`if`语句一样，在`when`语句中包含`else`子句是可选的。然而，通常建议提供一个`else`子句；它通过为未匹配的情况提供后备选项，从而提高了代码的健壮性。
- en: 'It’s also possible to provide the variable to be tested in parentheses immediately
    after the when keyword. In this case, the when statement conducts tests based
    on exact values or ranges of values for that variable, without repeating the variable
    name. For example:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 也可以在`when`关键字后立即用括号提供要测试的变量。在这种情况下，`when`语句会根据该变量的确切值或值的范围进行测试，而无需重复变量名。例如：
- en: '[PRE43]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Here, we pass the hour variable to the when statement, which prints different
    greetings based on the variable’s value. For example, the condition in 0..11 tests
    whether the value of hour is between 0 and 11, inclusive. We’ll look more closely
    at how to use the .. operator to specify a range of values in the next section,
    when we discuss loops.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将`hour`变量传递给`when`语句，基于该变量的值打印不同的问候语。例如，0..11中的条件测试`hour`的值是否在0到11之间（包括0和11）。我们将在下一节讨论循环时，更详细地介绍如何使用`..`运算符指定值的范围。
- en: Loops
  id: totrans-196
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 循环
- en: '*Loops* are essential constructs in programming that allow you to repeat a
    block of code multiple times. Kotlin offers a few types of loops, each with its
    own use cases and advantages. In this section, we’ll explore loops in Kotlin,
    including how to specify ranges for iteration.'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: '*循环*是编程中不可或缺的结构，它们允许你多次重复一段代码。Kotlin 提供了几种类型的循环，每种都有其特定的使用场景和优势。在本节中，我们将探讨
    Kotlin 中的循环，包括如何指定迭代的范围。'
- en: for Loops
  id: totrans-198
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: for循环
- en: 'A for loop iterates through the elements in a collection, such as an array,
    list, or range. One common usage is to loop through a range of numbers, effectively
    creating a loop with a fixed number of repetitions. As we just saw with when statements,
    an inclusive range is specified in Kotlin using the .. operator. Here’s how this
    syntax fits with a for loop:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 一个 for 循环通过集合中的元素进行迭代，比如数组、列表或范围。一个常见的用法是遍历一系列数字，从而有效地创建一个固定次数重复的循环。正如我们刚才在
    when 语句中看到的那样，Kotlin 使用 .. 运算符来指定一个包含上限的范围。下面是这种语法如何与 for 循环配合使用的：
- en: '[PRE44]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'The logic governing a for loop is given in parentheses immediately after the
    for keyword. In this case, we create the loop variable i, which takes on values
    1 through 4 (inclusive). In the body of the loop, which is enclosed in braces,
    we print the current value of i using a string template. This for loop should
    produce the following output:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 一个 for 循环的逻辑由紧随其后的圆括号中的内容给出。在这种情况下，我们创建了循环变量 i，它取值 1 到 4（包含 4）。在循环体中（由花括号括起来），我们使用字符串模板打印
    i 的当前值。这个 for 循环应产生如下输出：
- en: '[PRE45]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'If you want to create a range that excludes the last value, use the until keyword
    instead of the .. operator. Additionally, with either style of range, you can
    specify a *step* value to increment the loop variable by some amount other than
    1. Here we use an until range with a step size of 3:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想创建一个不包含最后一个值的范围，可以使用 until 关键字，而不是 .. 运算符。此外，无论使用哪种类型的范围，都可以指定一个 *步长* 值，以便以除
    1 以外的其他增量来递增循环变量。这里我们使用一个步长为 3 的 until 范围：
- en: '[PRE46]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'In this example, the loop variable i begins with a value of 1 and then increases
    by 3 each time through the loop, taking on the values 4 and 7 before the loop
    terminates. The output should look like this:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，循环变量 i 从 1 开始，每次循环递增 3，依次取 4 和 7 的值，直到循环终止。输出应该如下所示：
- en: '[PRE47]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Notice that there’s no output line for when i is 10. This is because we used
    until, which excludes the upper bound of the range.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，当 i 为 10 时没有输出行。这是因为我们使用了 until，它排除了范围的上限。
- en: 'If you need a for loop to iterate in reverse order, create a range with the
    downTo keyword. This keyword allows you to specify a range where the loop variable
    starts at a higher value and counts down to a lower value. Like the .. operator,
    downTo ranges are inclusive. Here’s how it works:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你需要让 for 循环以相反的顺序进行迭代，可以创建一个使用 downTo 关键字的范围。这个关键字允许你指定一个范围，其中循环变量从较高的值开始并递减到较低的值。与
    .. 运算符一样，downTo 范围是包含上限的。下面是它的用法：
- en: '[PRE48]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'This for loop should output the following:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 这个 for 循环应输出如下内容：
- en: '[PRE49]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: Thanks to the downTo keyword, the looping variable i counts down from 4 to 1.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 借助 downTo 关键字，循环变量 i 从 4 递减到 1。
- en: continue and break Statements
  id: totrans-213
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: continue 和 break 语句
- en: 'Kotlin makes it possible to disrupt the flow of a for loop using the continue
    and break keywords. Usually, these keywords work in conjunction with an if statement
    to interrupt the loop when some condition is met. The continue keyword halts the
    current iteration of the loop and immediately skips ahead to the next iteration.
    Here’s an example:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: Kotlin 允许使用 continue 和 break 关键字中断 for 循环的流程。通常，这些关键字与 if 语句结合使用，当满足某个条件时中断循环。continue
    关键字会停止当前迭代并立即跳到下一次迭代。下面是一个示例：
- en: '[PRE50]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'When the loop variable is set to 3, the loop will continue by moving on to
    the next value of the loop variable. As a result, the println() function won’t
    execute when i is 3, yielding the following output:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 当循环变量设置为 3 时，循环将继续，并进入下一个循环变量的值。因此，当 i 为 3 时，println() 函数不会执行，输出如下：
- en: '[PRE51]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'The break keyword, by contrast, completely terminates a for loop, as shown
    here:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 相比之下，break 关键字会完全终止一个 for 循环，如下所示：
- en: '[PRE52]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'This loop will “break” when the loop variable equals 3. As a result, the output
    should look like this:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 当循环变量等于 3 时，这个循环会“中断”。因此，输出应如下所示：
- en: '[PRE53]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: Even though the range had a few values to go, the break keyword ended the loop
    early.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 即使范围内还有一些值，break 关键字也会提前结束循环。
- en: Nested and Named for Loops
  id: totrans-223
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 嵌套和命名的 for 循环
- en: 'It’s common to nest one for loop inside another such that the entire inner
    for loop executes multiple times, as determined by the outer loop. Here’s an example
    of a nested set of for loops that prints a pattern of asterisks in a square shape:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个 for 循环内嵌套另一个 for 循环是很常见的，这样内部的整个 for 循环会根据外部循环的次数多次执行。这里是一个嵌套 for 循环的示例，它打印一个方形的星号模式：
- en: '[PRE54]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'In this example, the outer loop for (i in 1..size) iterates over the rows,
    and the inner loop for (j in 1..size) iterates over the columns within each row.
    The print("* ") statement prints an asterisk followed by a space for each element
    in a row. Unlike println(), the print() function ❶ doesn’t add a newline character
    each time it’s called, so each time through the outer loop, the inner loop will
    print a series of asterisks all together on one line. The empty println() statement
    after the inner loop ❷ moves the cursor to the next line to separate the rows.
    The output of this code, with size set to 4, should look like this:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，外循环`for (i in 1..size)`遍历行，而内循环`for (j in 1..size)`则遍历每一行中的列。`print("*
    ")`语句为每个元素打印一个星号后跟一个空格。与`println()`不同，`print()`函数❶每次调用时不会自动添加换行符，因此每次外循环执行时，内循环会将一系列星号打印在同一行。内循环结束后的空`println()`语句❷将光标移到下一行，以分隔不同的行。假设`size`设为4，代码的输出应该是这样的：
- en: '[PRE55]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'When you have nested loops, it can be helpful—though not strictly necessary—to
    assign each loop a name. The name comes before the for keyword and must be followed
    by an at sign (@). If the loops are named, you can explicitly apply keywords like
    continue and break to one loop or the other by adding the loop’s name after the
    keyword. This gives you more control over when and how the nested loops can be
    disrupted. Here’s an example:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 当你有嵌套循环时，给每个循环分配一个名称可能会很有帮助——虽然不是绝对必要的——名称位于`for`关键字之前，并且必须后跟一个`@`符号。如果循环被命名，你可以通过在关键字后添加循环名称，显式地将`continue`和`break`等关键字应用于某个特定的循环。这让你可以更好地控制嵌套循环何时以及如何被打断。以下是一个示例：
- en: '[PRE56]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'We have two nested for loops, named loop1 and loop2. The loop variables, i
    and j, both vary from 1 to 5 inclusive. Ignoring the conditional logic inside
    loop2 for a moment, this nested loop would iterate for a total of 25 (5 × 5) times,
    printing each (i,j) pair, starting with (1,1) through (1,5) for the first time
    through loop1, then (2,1) through (2,5) for the second, and so on. The output
    would look like this, with the println() after each full cycle of the inner loop
    again ensuring that each group of five pairs is printed on its own line:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有两个嵌套的`for`循环，分别命名为`loop1`和`loop2`。循环变量`i`和`j`的取值范围都从1到5（包括1和5）。暂时忽略`loop2`内部的条件逻辑，这个嵌套循环将会执行总共25次（5
    × 5），打印每一对`(i,j)`，首先是`(1,1)`到`(1,5)`，然后是`(2,1)`到`(2,5)`，以此类推。输出结果如下，每次完整执行内循环后，`println()`确保每组五个对值会被打印在自己的一行：
- en: '[PRE57]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Now consider what the conditional logic in the inner loop does ❶. It applies
    the break keyword specifically to loop2 (using the syntax break@loop2) if i and
    j are equal, halting the inner loop and returning to the outer loop for the call
    to println(). (Notice how the @ symbol follows the loop name when the name is
    being assigned but precedes it when the name is being referenced.) This logic
    prints only the lower-left portion of the grid of (i,j) pairs, up to the main
    diagonal, where i and j are equal:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 现在考虑一下内循环中的条件逻辑❶。当`i`和`j`相等时，它会特别针对`loop2`应用`break`关键字（使用语法`break@loop2`），从而终止内循环并返回到外循环，执行`println()`的调用。（注意，当循环名称被赋值时，`@`符号位于名称之后，但当名称被引用时，`@`符号则位于名称之前。）这个逻辑仅打印(i,j)对的左下部分，直到主对角线，`i`和`j`相等的位置：
- en: '[PRE58]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: In truth, specifying that break applies to loop2 isn’t necessary here, since
    by default, keywords like break and continue apply to the innermost loop that
    contains them—in this case, loop2. Still, including the loop name helps clarify
    the intent behind the code. Furthermore, consider that another way to achieve
    a similar result would be to replace break@loop2 with continue@loop1, in which
    case referencing the loop name becomes necessary. I encourage you to try making
    this change as an exercise—you’ll also need to think about what to do with the
    call to println() to keep the output nicely formatted.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，在这里指定`break`应用于`loop2`并不是必须的，因为默认情况下，像`break`和`continue`这样的关键字应用于它们所在的最内层循环——在这个例子中是`loop2`。尽管如此，包含循环名称有助于明确代码的意图。此外，考虑到另一种实现相似结果的方式是将`break@loop2`替换为`continue@loop1`，在这种情况下，引用循环名称变得是必要的。我建议你尝试做这个修改作为练习——你还需要思考如何处理`println()`的调用，以保持输出格式整齐。
- en: while Loops
  id: totrans-235
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '`while` 循环'
- en: 'A while loop is best employed when you need to repetitively execute a code
    block but you don’t know the exact number of iterations in advance. It keeps looping
    until a termination condition is satisfied. The condition is given in parentheses
    after the while keyword, before the start of the loop body. Here’s an example:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: while 循环最适合在你需要反复执行一个代码块，但又无法预先知道具体循环次数的情况下使用。它会一直循环，直到满足终止条件。条件放在 while 关键字后面的括号中，在循环体开始之前。以下是一个例子：
- en: '[PRE59]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'We initialize the count variable to 0, then create a while loop that will continue
    repeating as long as the condition count < 4 remains true. The loop checks this
    condition *before* each repetition. Inside the loop, we print the current value
    of count and then increase its value by 1 using a unary ++ operator to get ready
    for the next iteration. This should produce the following output:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将 count 变量初始化为 0，然后创建一个 while 循环，只要条件 count < 4 为真，循环就会继续执行。每次重复之前，循环都会检查这个条件。在循环内部，我们打印
    count 的当前值，然后使用一元 ++ 运算符将其值增加 1，为下一次迭代做准备。这样应该会产生以下输出：
- en: '[PRE60]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: At the end of the fourth time through the loop, count increments from 3 to 4.
    Then, when the loop gets ready to start its fifth iteration, it finds that the
    loop condition is no longer true and the loop terminates.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 当循环执行到第四次时，count 从 3 增加到 4。然后，当循环准备开始第五次迭代时，它发现循环条件不再为真，循环终止。
- en: 'Another style of while loop uses the condition while (true). Since true always
    evaluates to true, this theoretically sets up an infinite loop. The real conditional
    logic of halting the loop is instead moved inside the loop body itself. Here’s
    the same while loop as before, implemented in this other style:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种 while 循环的写法是使用条件 while (true)。由于 true 总是计算为真，这理论上会设置一个无限循环。实际的终止循环逻辑则被移到循环体内部。以下是之前的
    while 循环，用这种方式实现的例子：
- en: '[PRE61]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: This time we use an if statement at the end of the loop body to trigger the
    break keyword and terminate the loop when count is greater than or equal to 4.
    Without this conditional, the program would get stuck in an infinite loop, causing
    it to run indefinitely.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 这次我们在循环体的末尾使用 if 语句来触发 break 关键字，当 count 大于或等于 4 时终止循环。如果没有这个条件，程序将陷入无限循环，导致程序一直运行下去。
- en: 'One further variation on the while loop is the do...while loop, which has the
    following syntax:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: while 循环的另一种变体是 do...while 循环，其语法如下：
- en: '[PRE62]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: A do...while loop checks the stopping condition *after* each iteration, rather
    than before. This ensures that the loop will be executed at least once. By contrast,
    if the condition for a regular while loop is already false before the loop begins,
    it won’t execute at all.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: do...while 循环在每次迭代后检查停止条件，而不是在之前检查。这确保了循环至少会执行一次。相比之下，如果常规 while 循环的条件在循环开始前已经为假，它将根本不会执行。
- en: Just like for loops, you can nest multiple while loops and use them with the
    continue keyword as well as with break.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 就像 for 循环一样，你可以嵌套多个 while 循环，并且可以与 continue 关键字和 break 一起使用。
- en: Functions
  id: totrans-248
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 函数
- en: A *function* is a reusable block of code that performs a specific task or computation.
    Functions are a fundamental building block of any Kotlin program and are used
    to encapsulate logic, promote code reusability, and improve code organization.
    Kotlin’s standard library comes with many built-in functions to simplify common
    programming tasks. One example is the println() function we’ve been using throughout
    this chapter to output text to the console; other examples include various mathematical
    functions, some of which we’ll explore shortly. For more specialized tasks particular
    to the application at hand, you’ll have to create your own custom functions. We’ll
    discuss how to do that as well.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: '*函数*是一个可重用的代码块，用于执行特定任务或计算。函数是任何 Kotlin 程序的基本构建块，用于封装逻辑、促进代码重用以及改善代码组织。Kotlin
    的标准库提供了许多内置函数，简化了常见的编程任务。一个例子是我们在本章中一直使用的 println() 函数，用于将文本输出到控制台；其他示例包括各种数学函数，其中一些我们稍后将探讨。对于更专门的任务，你需要创建自己的自定义函数。我们也会讨论如何实现这一点。'
- en: Built-in Mathematical Functions
  id: totrans-250
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 内置数学函数
- en: 'Throughout this book, we’ll leverage a multitude of mathematical functions
    that come prepackaged in the standard Kotlin library. For example, you can effortlessly
    compute the square root of a number with the sqrt() function or raise a value
    to a specific power (exponent) using the pow() function. These functions are part
    of the kotlin.math package and must be *imported* at the start of a program using
    the import keyword. Here’s a simple program that uses these two functions:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书中，我们将利用标准 Kotlin 库中预包装的许多数学函数。例如，你可以轻松地使用 sqrt() 函数计算一个数字的平方根，或者使用 pow()
    函数将一个值提升到特定的幂（指数）。这些函数是 kotlin.math 包的一部分，必须在程序开始时使用 import 关键字进行*导入*。下面是一个使用这两个函数的简单程序：
- en: '[PRE63]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'First, we import the two math functions we need. Then we use them to calculate
    the square root of x (squareRoot) and y to the second power (toThePower2) inside
    the string templates using the ${} syntax discussed in “String Templates” on [page
    15](#pg_15). The code segment should produce the following output:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们导入需要的两个数学函数。然后，我们在字符串模板中使用它们，使用 ${} 语法计算 x 的平方根（squareRoot）和 y 的二次方（toThePower2），该语法在“字符串模板”一节中讨论过，见[第
    15 页](#pg_15)。该代码段应产生以下输出：
- en: '[PRE64]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: In some cases, you may need to use many built-in functions in the same module.
    Technically, it’s possible to import the entire collection by including an asterisk
    (*) in the import statement. For example, import kotlin .math.* would import every
    function in the kotlin.math module. It’s considered good practice to import only
    the functions you need, however. This approach helps avoid *namespace pollution*,
    where your code gets cluttered with unnecessary—or worse, conflicting—identifiers
    like variable and function names. Importing only what you need gives you more
    flexibility to name your own variables and functions without causing conflicts
    with the names of the built-in functions.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，你可能需要在同一个模块中使用许多内置函数。从技术上讲，可以通过在导入语句中包含星号（*）来导入整个集合。例如，`import kotlin.math.*`
    会导入 kotlin.math 模块中的所有函数。然而，通常认为只导入所需的函数是一种好习惯。这种做法有助于避免*命名空间污染*，即你的代码被不必要的—或者更糟糕的是，冲突的—标识符（如变量名和函数名）所杂乱。只导入你需要的内容，可以让你在命名自己的变量和函数时更加灵活，避免与内置函数的名称发生冲突。
- en: The remaining functions in the kotlin.math module handle trigonometry and other
    useful mathematical computations. For a comprehensive list of standard mathematical
    functions available and instructions on how to use them, search for kotlin.math
    in the official Kotlin documentation at [https://kotlinlang.org](https://kotlinlang.org).
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: kotlin.math 模块中的其余函数处理三角学和其他有用的数学计算。有关可用的标准数学函数的完整列表及使用说明，请查阅官方 Kotlin 文档中的
    kotlin.math，网址是[https://kotlinlang.org](https://kotlinlang.org)。
- en: Custom Functions
  id: totrans-257
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 自定义函数
- en: 'When you have some code that accomplishes a particular task in your application—especially
    a task that will be repeated—it’s common to encapsulate that code in a custom
    function. This keeps your code well organized and efficient. Each custom function
    must be *declared*, or defined, before it can be used. Here’s Kotlin’s syntax
    for a function declaration:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 当你的应用程序中有一些代码完成特定任务时，尤其是那些会被重复执行的任务，通常会将这些代码封装成一个自定义函数。这样可以保持代码的组织性和高效性。每个自定义函数必须在使用之前*声明*或定义。下面是
    Kotlin 中函数声明的语法：
- en: '[PRE65]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: The declaration begins with the fun keyword, followed by the function name and
    a set of parentheses. Inside the parentheses, you provide the names of the function’s
    *parameters*, if any, along with their data types. These parameters serve as placeholders
    for values that the function expects to receive when it’s called. They allow you
    to pass data into the function. A function can have many parameters of different
    data types (including parameters that are other functions) or no parameters at
    all, in which case the function name will be followed by a set of empty parentheses.
    When a function is called, specific values, called *arguments*, are provided for
    the parameters. Notice that function parameters are implicitly treated as read-only
    (immutable) variables within the function body. Using val or var on function parameters
    is not allowed.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 声明以`fun`关键字开始，后跟函数名和一对圆括号。在圆括号内，提供函数的*参数*名称（如果有），以及它们的数据类型。这些参数充当占位符，用于接收函数被调用时传递的值。它们允许你将数据传递给函数。一个函数可以有多个不同数据类型的参数（包括其他函数作为参数），或者没有任何参数，在这种情况下，函数名后面会跟着一对空括号。当函数被调用时，会为参数提供特定的值，这些值称为*实参*。请注意，函数参数在函数体内被隐式视为只读（不可变）变量。不能对函数参数使用`val`或`var`。
- en: After the parameter list, the function declaration continues with a colon (:)
    followed by the function’s *return type*. This specifies the data type of the
    value the function will generate and provide to its caller. The built-in sqrt()
    function we discussed in “Built-in Mathematical Functions” on [page 28](#pg_28)
    returns the square root of its parameter as either a Double or a Float, for example.
    If a function returns nothing, you can omit the return type. It will be assumed
    to be Unit, akin to the void type in other languages. A function would return
    nothing if, for example, its purpose is to print output to the console, make changes
    to global variables, make changes to elements of an array or object supplied to
    the function as an argument, or call other functions.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 在参数列表之后，函数声明继续以冒号（:）和函数的*返回类型*。这指定了函数将生成并提供给调用者的值的数据类型。例如，我们在《内建数学函数》一章中讨论的内建`sqrt()`函数返回其参数的平方根，可以是Double或Float。如果一个函数不返回任何值，你可以省略返回类型。它将被视为`Unit`，类似于其他语言中的`void`类型。例如，如果一个函数的目的是将输出打印到控制台、修改全局变量、修改作为参数传递给函数的数组或对象元素，或者调用其他函数，它就不会返回任何值。
- en: Taken together, the function name and the parameter names and types define the
    *signature* of the function. The compiler uses function signatures to determine
    which function to use when multiple functions have the same name but different
    parameters (a practice called *function overloading* that we’ll discuss shortly).
    The return type isn’t part of the function signature, but it’s an important part
    of the function declaration nonetheless.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 综合来看，函数名以及参数名和类型定义了函数的*签名*。编译器使用函数签名来决定在多个具有相同名称但参数不同的函数之间使用哪一个（这种做法称为*函数重载*，我们稍后会讨论）。返回类型不是函数签名的一部分，但它仍然是函数声明的重要部分。
- en: Once the function signature and the return type are specified (when applicable),
    all that remains is to declare the function *body*, which is enclosed in braces.
    This is the block of code that will be executed when the function is called. It
    may include additional variable declarations, conditional statements, loops, and
    expressions—anything necessary for the function to do its work.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦函数签名和返回类型被指定（如适用），剩下的就是声明函数的*主体*，它被花括号包围。这是函数被调用时会执行的代码块。它可能包括额外的变量声明、条件语句、循环和表达式——任何函数完成工作所需的内容。
- en: 'Let’s now examine a real function that performs a simple task: adding two integers
    together and returning the result. Here’s the function’s declaration:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们看一个执行简单任务的实际函数：将两个整数相加并返回结果。以下是该函数的声明：
- en: '[PRE66]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: We declare a function named add() that takes two parameters, x and y, both of
    type Int, and returns a value also of type Int. The function body calculates x
    + y and uses the return keyword to deliver that result to the function caller.
    Note that if the return type implied by the value being returned is different
    from the function’s declared return type, the compiler will generate an error.
    In this case, since both x and y are integers, x + y will be an integer as well.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 我们声明了一个名为add()的函数，它接受两个参数x和y，类型都是Int，并返回一个类型为Int的值。函数体计算x + y，并使用return关键字将结果返回给函数调用者。请注意，如果返回值的类型与函数声明的返回类型不同，编译器将生成错误。在这种情况下，由于x和y都是整数，x
    + y的结果也将是整数。
- en: 'With the add() function declared, we can call it from main() as follows:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 在声明了add()函数后，我们可以在main()中这样调用它：
- en: '[PRE67]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'We declare the a and b variables and initialize them to 3 and 6, respectively.
    Next, we declare sum and assign it the value returned by add(). Running this code
    should yield the following output:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 我们声明了a和b变量，并将它们分别初始化为3和6。接下来，我们声明sum并将其赋值为add()返回的结果。运行这段代码应输出以下内容：
- en: '[PRE68]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: Kotlin enforces strong typing, so the compiler will flag errors for mismatches
    between declared parameter types and the types of the arguments passed to the
    function. The number of arguments should also match the number of parameters,
    unless some parameters are assigned default values.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: Kotlin强制类型检查，因此编译器会标记参数类型与传递给函数的实参类型不匹配的错误。参数的数量也应该与函数声明的参数数量匹配，除非某些参数被赋予了默认值。
- en: Providing Default Parameter Values
  id: totrans-272
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 提供默认参数值
- en: 'If a parameter has the same value most of the time a function is called, it
    can be given a default, preset value when the function is declared. This way,
    you need to provide an argument for that parameter only when you want it to be
    something other than the default. The parameters with default values should be
    listed last in the function declaration. Here’s an example of how to declare a
    default parameter value:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个参数在大多数情况下函数被调用时具有相同的值，可以在函数声明时为该参数设置一个默认的预设值。这样，只有在你希望该参数的值与默认值不同的时候，才需要提供一个参数值。具有默认值的参数应当在函数声明中列在最后。以下是如何声明一个默认参数值的示例：
- en: '[PRE69]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: The greet() function takes two parameters, name and greeting, and combines them
    to print out a customized greeting. A value for name will need to be provided
    each time the function is called, but if no value for greeting is specified, the
    function will use the default value of "Hello". This default value is set in the
    parameter list, after the parameter’s data type.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: greet()函数接受两个参数name和greeting，并将它们结合起来打印出定制的问候语。每次调用该函数时都需要提供name的值，但如果没有指定greeting的值，函数将使用默认值“Hello”。这个默认值是在参数列表中设置的，位于参数的数据类型之后。
- en: 'If we call the function with greet("Nathan"), supplying an argument only for
    the name parameter, it should result in the following output, including the default
    value for greeting:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们使用greet("Nathan")调用该函数，仅为name参数提供一个值，则应得到以下输出，其中包含问候语的默认值：
- en: '[PRE70]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: Consider how you would call this function if you wanted it to instead print
    "Good morning, Nathan!" as a message.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑一下，如果你希望这个函数打印“早上好，Nathan！”作为信息，你会怎么调用它？
- en: Using Named Arguments
  id: totrans-279
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 使用命名参数
- en: When a function has many parameters, keeping track of their order and type can
    be a hassle. Using *named arguments* comes in handy in such situations. This is
    a style of function call where you include the parameter names along with the
    desired argument values. With the names included, the arguments can be given in
    any order.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个函数有很多参数时，跟踪它们的顺序和类型可能会很麻烦。在这种情况下，使用*命名参数*会非常方便。这是一种函数调用方式，你在调用时同时包括参数名和所需的参数值。有了参数名，参数的顺序可以任意排列。
- en: 'Say you’ve declared this function with four parameters:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你声明了一个包含四个参数的函数：
- en: '[PRE71]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'Calling the function using named arguments relieves you from the burden of
    remembering the order in which the parameters were declared:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 使用命名参数调用函数，可以避免记住参数声明顺序的负担：
- en: '[PRE72]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: Here each argument is given in the form parameterName = value. This function
    call will work just fine, even though the parameters are out of order, thanks
    to the use of named arguments. This is allowed as long as you provide names for
    all arguments or the compiler is able to figure out the order of the arguments.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，每个参数都以parameterName = value的形式提供。由于使用了命名参数，即使参数顺序不正确，这个函数调用也能正常工作。只要为所有参数提供了名称，或者编译器能够确定参数的顺序，这都是被允许的。
- en: Overloading a Function
  id: totrans-286
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 重载一个函数
- en: '*Function overloading* in Kotlin allows you to define multiple functions with
    the same name in the same scope but with different parameter lists. Perhaps they
    have a different number of parameters, or the parameters are of different data
    types. Here’s an example of function overloading:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: '*函数重载*在 Kotlin 中允许你在同一作用域内定义多个同名函数，但它们的参数列表不同。它们可能有不同数量的参数，或者参数的数据类型不同。以下是函数重载的一个例子：'
- en: '[PRE73]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'We declare two functions called add() with different parameter lists; one adds
    two integers, and the other adds two floating-point numbers. When the add() function
    is called, the compiler will determine which version of the function to invoke
    by comparing the argument types to the declared function signatures. This is how
    you would call both functions:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 我们声明了两个名为 add() 的函数，参数列表不同；一个用于加法运算两个整数，另一个用于加法运算两个浮点数。当调用 add() 函数时，编译器将通过比较传入的参数类型和已声明的函数签名来确定调用哪个版本的函数。这是你调用这两个函数的方式：
- en: '[PRE74]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: With function overloading, you can use the same function name for operations
    that conceptually do the same thing (in this case, addition) but with different
    parameter types. This makes your code more readable, intuitive, and error resistant.
    In this example, we’ve anticipated that we may want to add floating-point numbers
    as well as integers. Overloading the function gives us the flexibility to do either
    without triggering an error.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 通过函数重载，你可以使用相同的函数名来执行在概念上做相同事情（在此案例中为加法），但使用不同的参数类型。这使得你的代码更具可读性、直观性和抗错误性。在这个例子中，我们预见到可能需要同时对浮点数和整数进行加法运算。重载该函数使我们能够在不触发错误的情况下进行任意一种操作。
- en: Referencing a Function Without Calling It
  id: totrans-292
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 引用一个函数而不调用它
- en: 'In Kotlin, you can use the member reference operator (::) to refer to a function
    by its name without actually invoking it. This is helpful in many situations,
    such as when you need to assign a function reference to a variable. Say you have
    two functions and you’re trying to decide which to use in your code. Perhaps they’re
    both ways of accomplishing the same task and you want to see which is more efficient,
    or perhaps they implement two different operations that would be appropriate in
    different situations. Rather than rewriting all the code to call one function
    or the other, you can assign to a variable a reference to the appropriate function
    and then call the function (whichever one you choose) via the variable, minimizing
    the changes to the code. Here’s an example illustrating how this works:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Kotlin 中，你可以使用成员引用操作符 (::) 来通过函数名引用一个函数，而不实际调用它。这在许多情况下都很有用，例如当你需要将函数引用分配给一个变量时。假设你有两个函数，正在决定在代码中使用哪个。也许它们都是完成同一任务的方式，你想看看哪个更高效，或者它们实现了两种不同的操作，在不同的情况下更合适。与其重写所有代码去调用其中一个函数，不如将适当的函数引用分配给一个变量，然后通过该变量调用函数（无论你选择哪一个），以最小化对代码的修改。以下是一个示例，说明这是如何实现的：
- en: '[PRE75]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'We first declare two functions: add() calculates the sum of x and y, and multiply()
    calculates the product of x and y. We’ll want to use only one of these functions
    in main(). To control which one, we declare a Boolean variable useAdd and set
    it to true. Inside the main() function, we then create another variable named
    selectedFunction and use *conditional expression syntax* to set its value to one
    of the functions ❶. This syntax uses an if...else structure to return a value
    and assign it to a variable based on a condition—in this case, the state of the
    useAdd variable. If useAdd is true, selectedFunction is assigned a reference to
    add(); otherwise, it references multiply(). Notice how we precede each function
    name with the :: operator and don’t include parentheses after the function name,
    since we’re referencing rather than invoking the functions. With the selectedFunction
    variable holding a reference to a function, we can now invoke that function by
    calling selectedFunction() rather than by calling add() or multiply() directly
    ❷. We store the returned value in the result variable and print it to the console.'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先声明了两个函数：add()计算x和y的和，multiply()计算x和y的积。我们只希望在main()中使用其中一个函数。为了控制使用哪个函数，我们声明一个Boolean类型的变量useAdd，并将其设置为true。在main()函数内部，我们创建了另一个名为selectedFunction的变量，并使用*条件表达式语法*来设置它的值为其中一个函数❶。这种语法使用if...else结构根据条件返回一个值并将其赋给变量——在这个例子中，是根据useAdd变量的状态。如果useAdd为true，selectedFunction将被赋值为对add()的引用；否则，它将引用multiply()。请注意，我们在每个函数名称前面都加上了::操作符，并且在函数名称后面没有加上括号，因为我们是在引用函数而不是调用它们。通过selectedFunction变量持有一个函数的引用，我们现在可以通过调用selectedFunction()来调用该函数，而不是直接调用add()或multiply()❷。我们将返回的值存储在result变量中，并将其打印到控制台。
- en: Try changing the value of useAdd from true to false to switch between using
    add() and multiply(). Then consider how convenient this solution is for toggling
    between two functions, especially if you need to use the function in multiple
    places in the code. Instead of updating the function name at each usage, we can
    simply change the value of useAdd and rely on the selectedFunction variable to
    stand in for whichever function we want.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试将useAdd的值从true改为false，切换使用add()和multiply()。然后考虑这种解决方案在切换两个函数之间的便利性，特别是当你需要在代码的多个地方使用函数时。我们无需在每个使用位置更新函数名称，只需更改useAdd的值，并依赖selectedFunction变量来代替我们想要的函数。
- en: 'The :: operator is particularly useful when you need to pass a function reference
    as an argument to another function. Here’s an example:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: ::操作符在需要将函数引用作为参数传递给另一个函数时特别有用。以下是一个示例：
- en: '[PRE76]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'We define a function called printMessage() that takes a string parameter and
    prints it to the console. We also define another function called applyFunction()
    with two parameters: function, which will hold a reference to a function, and
    input, a string. The function parameter’s type needs to match the parameter and
    return types of the function it will reference; (String) -> Unit indicates that
    the function will take a string as a parameter and return nothing. In the body
    of applyFunction(), we call whatever function was passed in, using the input string
    as its argument.'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 我们定义了一个名为printMessage()的函数，它接收一个字符串参数并将其打印到控制台。我们还定义了另一个名为applyFunction()的函数，它有两个参数：function，用于保存对某个函数的引用；input，一个字符串。函数参数的类型需要与它所引用的函数的参数类型和返回类型匹配；（String）->
    Unit表示该函数将接受一个字符串作为参数并且不返回任何值。在applyFunction()的函数体内，我们调用传入的任意函数，使用输入的字符串作为其参数。
- en: 'In main(), we create a reference to printMessage() using :: and pass it to
    applyFunction() along with the string "Hello, Kotlin!" as the second argument.
    This will effectively make applyFunction() call printMessage() with the given
    string and print it to the console. The output should be:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 在main()中，我们使用::创建对printMessage()的引用，并将其与字符串"Hello, Kotlin!"一起作为第二个参数传递给applyFunction()。这将有效地使applyFunction()调用printMessage()，并将给定的字符串打印到控制台。输出应该是：
- en: '[PRE77]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'Of course, you can do more with the :: operator than we’ve discussed here.
    I encourage you to consult the official Kotlin documentation to explore the operator’s
    other use cases.'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，::操作符的用途远不止于我们在这里讨论的内容。我鼓励你参考官方的Kotlin文档，探索该操作符的其他用例。
- en: Scope Functions
  id: totrans-303
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 范围函数
- en: 'In Kotlin, *scope functions* are a set of built-in functions used to manage
    the scope of variables, access properties of objects, and execute a block of code
    in a specific context. The scope functions in Kotlin are run, with, let, also,
    and apply. They’re often used to simplify and improve the readability of code,
    especially when working with objects or managing the flow of operations. Here
    is a simple example of how to use the run function:'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Kotlin 中，*范围函数* 是一组内置函数，用于管理变量的作用域、访问对象的属性并在特定上下文中执行代码块。Kotlin 中的范围函数包括 run、with、let、also
    和 apply。它们常用于简化和提高代码的可读性，特别是在处理对象或管理操作流时。下面是如何使用 run 函数的一个简单示例：
- en: '[PRE78]'
  id: totrans-305
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'We begin by declaring a variable called result. Its value is determined by
    the last expression within a code block executed using the run scope function.
    Inside this block, we define and assign values to two integers, and the final
    expression computes their sum. The resulting value from this final expression
    is returned by the code block and assigned to the result variable. Finally, we
    use println() to print the value of result, which will display Result: 30.'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: '我们首先声明一个名为 result 的变量。其值由使用 run 范围函数执行的代码块中的最后一个表达式决定。在这个代码块内，我们定义并赋值给两个整数，最后一个表达式计算它们的和。最终表达式的结果将由代码块返回并赋值给
    result 变量。最后，我们使用 println() 打印 result 的值，结果会显示 "Result: 30"。'
- en: Lambda Expressions
  id: totrans-307
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Lambda 表达式
- en: '*Lambda expressions*, often referred to simply as *lambdas*, are a way to define
    and pass around blocks of function-like code in a flexible and concise manner.
    They’re essentially anonymous functions, allowing you to create functions on the
    fly without giving them a name. Lambda expressions are a fundamental part of functional
    programming, a programming style or paradigm that uses functions as the main building
    blocks. They make it easier to work with *higher-order functions*, functions that
    can take functions as arguments, return functions as values, or both. Higher-order
    functions can help create reusable and modular code that can be customized with
    different functions.'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: '*Lambda 表达式*，通常简称为 *lambdas*，是一种以灵活简洁的方式定义和传递类似函数代码块的方法。它们本质上是匿名函数，允许你在不指定名称的情况下动态创建函数。Lambda
    表达式是函数式编程的基础，函数式编程是一种以函数为主要构建块的编程风格或范式。它们使得操作 *高阶函数* 变得更加容易，*高阶函数* 是可以接受函数作为参数、将函数作为返回值，或者两者兼有的函数。高阶函数有助于创建可重用和模块化的代码，这些代码可以通过不同的函数进行定制。'
- en: 'Here’s an example of a simple lambda that takes in a name and generates a greeting:'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个简单的 lambda 示例，它接受一个名字并生成一个问候语：
- en: '[PRE79]'
  id: totrans-310
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'The lambda itself is the part of the code enclosed in braces: {name -> "Hello,
    $name!"}. It consists of input parameters (in this case, just one, name) and a
    body ("Hello, $name!"), separated by an arrow (->) symbol. Think of this arrow
    as passing the parameters along to the lambda body. The return keyword is implied
    in the lambda body; if the body consists of a single expression, that expression
    will automatically be returned.'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: lambda 本身是被大括号括起来的代码部分：{name -> "Hello, $name!"}。它由输入参数（在本例中只有一个，name）和一个主体（"Hello,
    $name!"）组成，中间通过箭头（->）符号分隔。可以把这个箭头看作是将参数传递给 lambda 主体。lambda 主体中的 return 关键字是隐含的；如果主体只包含一个表达式，那么该表达式将自动作为返回值。
- en: 'In this example, we assign the lambda to the greet variable. The (String) ->
    String before the assignment operator specifies the lambda’s parameter and return
    types, again using the -> symbol to separate the two. We can also incorporate
    these type declarations into the lambda itself, in which case we’d write the entire
    expression as:'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们将 lambda 赋值给 greet 变量。在赋值运算符前的 (String) -> String 指定了 lambda 的参数类型和返回类型，同样通过
    -> 符号分隔。我们也可以将这些类型声明直接包含在 lambda 中，在这种情况下，我们将整个表达式写作：
- en: '[PRE80]'
  id: totrans-313
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: Here we specify that the name parameter is of the String type from within the
    braces. With this syntax, the return type, like the return keyword itself, is
    implied.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们在大括号内指定了 name 参数的类型为 String。使用这种语法，返回类型和 return 关键字本身是隐含的。
- en: 'Whichever syntax we use, we now have a function that returns a string greeting
    inside the greet variable. We can therefore call the lambda via this variable,
    just like we would call an ordinary function:'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 无论我们使用哪种语法，现在都有一个返回字符串问候语的函数，并且该函数存储在 greet 变量中。因此，我们可以像调用普通函数一样，通过该变量调用 lambda：
- en: '[PRE81]'
  id: totrans-316
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'Lambdas are often used for quick manipulation of data, such as adding two numbers
    or calculating the square of a number:'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: lambda 通常用于快速处理数据，比如加法或计算一个数字的平方：
- en: '[PRE82]'
  id: totrans-318
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'Lambda parameters can be explicitly typed or inferred. For simple lambdas,
    Kotlin can infer types automatically. Also, if a lambda has a single parameter,
    you can omit the parameter declaration and use the implicit it keyword directly
    in the lambda’s body as a stand-in for the parameter. This is what we’ve done
    for the square lambda: {it * it} indicates that the lambda will take a single
    unnamed parameter and multiply it by itself.'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: Lambda参数可以显式指定类型，也可以由Kotlin自动推断类型。对于简单的lambda，Kotlin可以自动推断类型。另外，如果lambda只有一个参数，可以省略参数声明，在lambda体内直接使用隐式的`it`关键字作为参数的代名词。这就是我们为平方lambda所做的：`{it
    * it}`表示该lambda将接受一个未命名的单一参数并将其自身相乘。
- en: Lambdas can span multiple lines to carry out more complex tasks and can be nested
    like for loops. We’ll use multiline, nested lambdas in the next section in relation
    to copying the content of a file.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: Lambda表达式可以跨越多行以执行更复杂的任务，并且可以像for循环一样嵌套。我们将在下一部分中使用多行嵌套的lambda来复制文件内容。
- en: '### Basic Input and Output'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: '### 基本输入和输出'
- en: Most commercial software these days has a graphical user interface (GUI) so
    that you can easily interact with it. You can create a GUI for your Kotlin app
    using third-party tools such as JavaFX or Jetpack Compose, but we won’t cover
    that in this book. Instead, in this section we’ll focus on how to work with text-based
    input and output in Kotlin. This helps you quickly test and debug your code. Text-based
    output is also useful for tasks like scripting, keeping logs, and watching what’s
    happening on networks of computers and devices, which is what system administrators
    often do.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 现在大多数商业软件都有图形用户界面（GUI），使得您可以轻松地与其互动。您可以使用第三方工具（如JavaFX或Jetpack Compose）为Kotlin应用程序创建GUI，但本书不涉及这一部分。相反，在本节中，我们将专注于如何在Kotlin中处理基于文本的输入和输出。这有助于您快速测试和调试代码。基于文本的输出对于脚本编写、记录日志以及监控计算机和设备网络上的活动非常有用，这也是系统管理员经常做的事情。
- en: Console-Based Input and Output
  id: totrans-323
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 基于控制台的输入和输出
- en: 'To get user input from the console in Kotlin, use the readln() function. It
    returns whatever text the user enters into the console or an empty string if the
    user simply presses the ENTER key. Here’s an example:'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 要从控制台获取用户输入，请使用readln()函数。它将返回用户输入的任何文本，或者如果用户仅按下ENTER键，则返回一个空字符串。以下是一个示例：
- en: '[PRE83]'
  id: totrans-325
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: 'Here, the user input (a line of text) is read into the userInput variable and
    then displayed as output to the console using the familiar println() function.
    If the user just presses ENTER, then readln() will return an empty string, and
    the program will end normally after printing the following:'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，用户输入（一行文本）被读取到`userInput`变量中，然后使用熟悉的println()函数将其作为输出显示在控制台上。如果用户只是按下ENTER键，那么readln()将返回一个空字符串，程序将在打印以下内容后正常结束：
- en: '[PRE84]'
  id: totrans-327
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: When reading input from the console in Kotlin, keep in mind that all input is
    initially treated as text, resulting in a String data type. If you require a different
    data type, you must perform type casting, assuming the types are compatible. It’s
    also helpful to inform users about the expected input type by using prompts such
    as Enter your name or Enter an integer.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 在Kotlin中从控制台读取输入时，请记住，所有输入最初都会被处理为文本，导致数据类型为String。如果需要其他数据类型，必须进行类型转换，前提是类型兼容。使用提示语（例如“请输入您的名字”或“请输入一个整数”）向用户说明预期的输入类型也是有帮助的。
- en: 'Even with a clear prompt, though, you shouldn’t automatically assume that the
    input will be valid. The user may input incorrect characters that can’t be successfully
    type-cast into the desired format. To prevent the program from crashing due to
    potential errors, it’s essential to implement error-handling mechanisms when receiving
    input from users. This extra step ensures robustness and a smoother user experience.
    Here’s a complete example of a fail-safe method for reading an integer from the
    console:'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管有清晰的提示，您仍然不应自动假设输入将是有效的。用户可能输入无法成功类型转换为所需格式的错误字符。为了防止程序因潜在的错误而崩溃，接收用户输入时必须实施错误处理机制。这个额外的步骤能确保程序的健壮性，并带来更流畅的用户体验。以下是一个完整的从控制台读取整数的容错方法示例：
- en: '[PRE85]'
  id: totrans-330
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: 'We begin by creating a while loop that continues to run until a valid input
    is provided. Next, we read the user input as a string and assign that to a variable
    called num. We check the validity of the input inside a try...catch construct
    for graceful error handling. This construct consists of two code blocks: a try
    block containing the code you’d like to run and a catch block containing an alternative
    code path or fallback option in case an error occurs during the try block. The
    catch block prevents the entire program from crashing abruptly from an error.
    This mechanism helps with debugging during testing and improves the overall user
    experience in commercial applications.'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先创建一个 while 循环，直到提供有效的输入为止。接下来，我们将用户输入的内容作为字符串读取，并将其赋值给名为 num 的变量。我们在 try...catch
    结构中检查输入的有效性，以优雅地处理错误。该结构由两个代码块组成：一个 try 块，包含你希望运行的代码；一个 catch 块，包含在 try 块出错时的备用代码路径或回退选项。catch
    块防止程序因错误而突然崩溃。这个机制有助于在调试过程中排查问题，并提升商业应用中的整体用户体验。
- en: In this case, the try block attempts to convert the user’s input, stored in
    the variable num, into an integer using toInt(). If this conversion is successful,
    a message containing the integer value is printed.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，try 块尝试使用 toInt() 将存储在变量 num 中的用户输入转换为整数。如果转换成功，则会打印包含整数值的消息。
- en: 'However, if the conversion fails and a NumberFormatException is raised, the
    catch block is activated, printing an error message before the next iteration
    of the while loop begins. Notice the (e: NumberFormatException) immediately after
    the catch keyword. This specifies the particular type of exception that the catch
    block is designed to handle.'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: '然而，如果转换失败并抛出 NumberFormatException 异常，catch 块将被激活，打印错误信息，然后开始下一次循环。注意 catch
    关键字后面的 (e: NumberFormatException)，它指定了 catch 块设计用来处理的具体异常类型。'
- en: '#### Simple File Operations'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: '#### 简单的文件操作'
- en: 'Kotlin provides simple and effective ways to read and write files, a feature
    that’s very helpful when you want to retrieve previously saved data or save the
    data from the current run of a program. For this functionality, Kotlin relies
    on the Java standard library. For example, here’s how to read data from a file
    using Java’s File and Scanner classes:'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: Kotlin 提供了简单有效的方式来读取和写入文件，这在你需要检索之前保存的数据或保存当前程序运行中的数据时非常有用。为了实现这一功能，Kotlin 依赖于
    Java 标准库。例如，下面是如何使用 Java 的 File 和 Scanner 类读取文件中的数据：
- en: '[PRE86]'
  id: totrans-336
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: 'The example shows how to read a text file line by line. After importing the
    File and Scanner classes, we assign a string containing the full pathname of the
    input file to the inputFile variable. We then use this variable to create the
    File object called file ❶, which in turn is used to create a Scanner object called
    sc ❷ that gives us access to the file’s contents. Then, in a while loop, we read
    the content of the file one line at a time using the Scanner object’s nextLine()
    method and print the result to the console. The loop continues until we reach
    the end of the file, indicated when the Scanner object’s hasNextLine() method
    returns false. We place all this code in a try block and use a corresponding catch
    block to handle any errors that arise while trying to access the file—for example,
    if the filename or filepath is wrong. The (e: Exception) indicates the catch block
    can handle any kind of exception, unlike the earlier catch block that was designed
    specifically for exceptions of type NumberFormatException. In this case, the catch
    block prints the default error message associated with the exception, accessible
    as e.message.'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: '示例展示了如何逐行读取文本文件。在导入了 File 和 Scanner 类之后，我们将包含输入文件完整路径的字符串赋值给变量 inputFile。然后，利用该变量创建一个名为
    file ❶ 的 File 对象，该对象用于创建一个名为 sc ❷ 的 Scanner 对象，我们可以通过它访问文件的内容。接着，在 while 循环中，我们使用
    Scanner 对象的 nextLine() 方法逐行读取文件内容，并将结果打印到控制台。循环会持续进行，直到读取到文件末尾，此时 Scanner 对象的
    hasNextLine() 方法返回 false。我们将所有这些代码放入 try 块中，并使用相应的 catch 块来处理访问文件时可能出现的任何错误——例如，如果文件名或文件路径错误。
    (e: Exception) 表示 catch 块可以处理任何类型的异常，这与早期专门处理 NumberFormatException 类型异常的 catch
    块不同。在这种情况下，catch 块打印与异常相关的默认错误信息，信息可以通过 e.message 获取。'
- en: 'My test file at location *inputfile.txt* contained a limerick, and the program
    reproduced it on the console line by line:'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 我的测试文件 *inputfile.txt* 中包含了一首打油诗，程序将其逐行输出到控制台：
- en: '[PRE87]'
  id: totrans-339
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: 'To read from *and* write to a file, you can’t use the Scanner class, since
    it doesn’t support writing output. Instead, you can use the appendText() method
    of the File class. Here’s a simple example:'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 要从文件中读取和写入，不能使用Scanner类，因为它不支持写输出。相反，可以使用File类的appendText()方法。这里有一个简单的例子：
- en: '[PRE88]'
  id: totrans-341
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: This Kotlin code reads all the lines from an input file (*inputfile.txt*) and
    writes them to an output file (*outputfile.txt*). The input file is represented
    using one File object ❶ and the output file with another ❷. We use the File class’s
    readLines() method to read all the lines from the input file and return them as
    a list of strings ❸. (A *list* in Kotlin is a collection of items; in this case
    it’s a collection of strings, one for each line of the file. We’ll discuss lists
    in detail in [Chapter 2](chapter2.xhtml).) We store this list of strings in the
    lines variable. We then use a for loop to iterate over the lines list, with the
    looping variable line standing for one line at a time ❹. For each line, we use
    the appendText() method to add the line to the output file. We also append a newline
    character (\n) to the end of each line to ensure it’s written on its own line
    of the output file. We conclude the code by printing a message to the console,
    indicating that the input file has been copied to the output file.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 这段Kotlin代码从输入文件（*inputfile.txt*）中读取所有行，并将它们写入输出文件（*outputfile.txt*）。输入文件用一个File对象表示❶，输出文件用另一个File对象表示❷。我们使用File类的readLines()方法从输入文件中读取所有行，并将它们作为字符串列表返回❸。
    （在Kotlin中，*list*是一个项目的集合；在本例中，它是一个字符串集合，每行文件一个。我们将在[第二章](chapter2.xhtml)详细讨论列表。）我们将这个字符串列表存储在lines变量中。然后，我们使用for循环遍历lines列表，循环变量line代表一次循环中的一行❹。对于每一行，我们使用appendText()方法将该行添加到输出文件中。我们还在每行的末尾添加一个换行符（\n），以确保它被写入到输出文件的自己的行中。我们通过在控制台打印消息来结束代码，指示输入文件已复制到输出文件中。
- en: Notice that we didn’t use the try...catch block in this example, as the goal
    was to quickly show how to write data to a file. In real-world applications, file
    operations may have to be wrapped in a try...catch block to handle potential exceptions
    or errors, depending on your specific requirements.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，在此示例中我们没有使用try...catch块，因为目标是快速展示如何向文件写入数据。在实际应用程序中，可能需要将文件操作包装在try...catch块中，以处理可能的异常或错误，具体取决于您的特定需求。
- en: You can use many other techniques for reading from and writing to files in Java
    and Kotlin. See the official Kotlin documentation for information about other
    methods.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用许多其他技术来在Java和Kotlin中读取和写入文件。有关其他方法的信息，请参阅官方的Kotlin文档。
- en: 'Project 1: Build a Console-Based Calculator'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 项目1：构建基于控制台的计算器
- en: Now that we’ve explored some of the basic features of Kotlin, let’s put that
    knowledge to work in a real project. We’ll develop an interactive, console-based
    calculator application. The application will take a pair of valid numbers as input,
    ask the reader to choose an arithmetic operation (addition, subtraction, multiplication,
    or division), and then display the result of that operation in the console. We’ll
    also program the application to show helpful error messages when required.
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经探讨了Kotlin的一些基本特性，让我们将这些知识应用到一个真实的项目中。我们将开发一个交互式的基于控制台的计算器应用程序。该应用程序将接受一对有效的数字作为输入，要求读者选择算术操作（加法、减法、乘法或除法），然后在控制台中显示该操作的结果。我们还将编程应用程序在需要时显示有用的错误消息。
- en: At the start of any coding project, it’s crucial to begin by creating a mental
    map of the application’s structure. This involves identifying the necessary variables
    and data structures, as well as pinpointing the essential functionalities that
    the program should include. Once these components are identified, we can move
    forward by generating a list of the key components that need to be implemented,
    followed by the actual coding phase.
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 在任何编码项目开始时，开始创建应用程序结构的心理地图至关重要。这涉及识别必要的变量和数据结构，以及确定程序应包含的基本功能。一旦确定了这些组件，我们就可以继续生成需要实现的关键组件列表，然后进入实际编码阶段。
- en: 'For more complex projects, it can also be beneficial to create a flowchart
    visualizing the application logic or to develop detailed pseudocode offering step-by-step
    instructions for coding the entire project. However, given the relatively straightforward
    nature of the calculator project, we’ll start by listing its key components:'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 对于更复杂的项目，创建一个流程图来可视化应用程序逻辑或开发详细的伪代码以提供编码整个项目的逐步说明也可能会有益。然而，考虑到计算器项目的相对简单性，我们将从列出其关键组件开始：
- en: '1.  Input collection: We’ll gather user input for two numbers and ensure the
    inputs are valid.'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 1.  输入收集：我们将收集用户输入的两个数字，并确保输入有效。
- en: '2.  Operation selection: The user will choose addition, subtraction, multiplication,
    or division.'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 2.  操作选择：用户将选择加法、减法、乘法或除法。
- en: '3.  Calculation: The selected operation will be applied to the input numbers.'
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 3.  计算：将选定的运算应用于输入的数字。
- en: '4.  Result display: The calculated result will be presented to the user via
    the console.'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 4.  结果显示：计算结果将通过控制台呈现给用户。
- en: '5.  Error messages: Throughout steps 1 through 3, we’ll display helpful error
    messages for invalid inputs, such as nonnumerical characters for the number inputs
    or an unrecognized mathematical operation.'
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 5.  错误信息：在第1至第3步中，我们将显示有帮助的错误信息，针对无效输入，如数字输入中的非数字字符或无法识别的数学运算。
- en: We’ll use these five key components to guide the development process as we start
    coding our first mini project.
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用这五个关键组件来指导开发过程，开始编写我们的第一个迷你项目。
- en: The Code
  id: totrans-355
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 代码
- en: We’ll discuss the code from the top down, starting with the main() function,
    which coordinates the program’s actions through a series of helper functions.
    This approach allows us to align the code with the key components we outlined.
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从上到下讨论代码，从main()函数开始，它通过一系列辅助函数协调程序的操作。这种方法使我们能够将代码与我们概述的关键组件对齐。
- en: '[PRE89]'
  id: totrans-357
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: We begin by importing the exitProcess() function from Kotlin’s standard library.
    We’ll use this method to exit the program if the user provides invalid input or
    if the code comes across an invalid operation type (for example, division by zero).
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先从Kotlin标准库中导入exitProcess()函数。如果用户提供了无效输入或代码遇到了无效的操作类型（例如，除以零），我们将使用这个方法退出程序。
- en: 'The main() function itself is divided into four clear steps, each related to
    one of the key project functions. In the first step, we ask the user to provide
    two numbers, which we store in the number1 and number2 variables. To manage and
    verify the input, we use the readDoubleInput() function, declared here:'
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: main()函数本身分为四个明确的步骤，每个步骤与项目的一个关键功能相关。在第一个步骤中，我们要求用户提供两个数字，并将其存储在number1和number2变量中。为了管理和验证输入，我们使用readDoubleInput()函数，如下所示：
- en: '[PRE90]'
  id: totrans-360
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: This function takes a single argument, a string serving as a prompt for user
    input in the console. It returns a numeric value (of type Double) if the user
    provides a valid input. The function displays the prompt using print() rather
    than println() so that the user’s response will go on the same line. Then it reads
    the user’s input with readln() and processes the string input inside a try...catch
    block. When the string is successfully converted into a numeric value of type
    Double, its value is returned. Otherwise, we enter the catch part of the block,
    where an error message is printed, and the program exits with an error code of
    1.
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 该函数接受一个字符串参数，作为控制台中用户输入的提示。如果用户提供有效输入，则返回一个数字值（Double类型）。该函数使用print()而非println()显示提示信息，以便用户的回答出现在同一行。然后，它使用readln()读取用户输入，并在try...catch块内处理字符串输入。当字符串成功转换为Double类型的数字时，返回该值。否则，程序进入catch块，打印错误信息，并以错误代码1退出程序。
- en: NOTE
  id: totrans-362
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 注意
- en: '*When using the* exitProcess() *function, any integer can be used as an error
    code. However, it’s important to first decide on a scheme for error codes based
    on the different types of errors that the application might generate. This will
    allow you to quickly locate the source of the error. In more complex projects,
    creating and maintaining a log or wiki of error codes is recommended.*'
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: '*使用* exitProcess() *函数时，可以使用任何整数作为错误代码。然而，首先根据应用程序可能生成的不同类型错误来决定一个错误代码方案非常重要。这样可以帮助您快速定位错误源。在更复杂的项目中，建议创建和维护错误代码的日志或wiki。*'
- en: 'After the main() function receives two valid numeric values (number1 and number2),
    we move on to step 2, choosing the mathematical operation. For that, we first
    call the showChoices() function, which offers a list of arithmetic operations
    to the user. This function is simply made up of a number of println() calls:'
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 在main()函数接收到两个有效的数字值（number1和number2）后，我们进入第2步，选择数学运算。为此，我们首先调用showChoices()函数，向用户提供一系列算术运算选项。这个函数只是由多个println()调用组成：
- en: '[PRE91]'
  id: totrans-365
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: 'Next, we use the getArithmeticOperation() function to take in a valid operation
    from the user. The result is assigned to the string variable operation in main().
    Here’s what the getArithmeticOperation() function looks like:'
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们使用getArithmeticOperation()函数从用户那里获取有效的运算符。结果被赋值给main()中的字符串变量operation。以下是getArithmeticOperation()函数的样子：
- en: '[PRE92]'
  id: totrans-367
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: Within this function, the user is prompted to select one of the four valid arithmetic
    operators. This choice is captured using the readln() method. Subsequently, we
    use an if statement to verify whether the user input is valid. Specifically, if
    the string "+-*/" does not include the user’s input, an error message is printed,
    indicating that an invalid operator has been provided. The program then terminates
    with an error code of 2.
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个函数中，用户被提示选择四个有效算术运算符之一。此选择通过readln()方法捕获。随后，我们使用if语句验证用户输入是否有效。具体来说，如果字符串"+-*/"不包含用户输入的内容，则打印错误消息，表示提供了无效的运算符。程序然后以错误代码2终止。
- en: 'Back in main(), we can now move to step 3 and call the performCalculation()
    function to carry out the selected arithmetic operation and return the result.
    Here’s that function’s declaration:'
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 回到main()中，我们现在可以进入第3步，调用performCalculation()函数来执行选定的算术运算并返回结果。以下是该函数的声明：
- en: '[PRE93]'
  id: totrans-370
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: 'This function takes in the two input numbers and the string containing the
    desired operation as parameters and returns the result of the calculation as a
    number of type Double. It employs a when statement to execute the desired calculation
    based on the value of operation. By this stage, both the numbers and the operation
    type have been validated. However, one potential source of error remains: division
    by zero. We address this with an if...else block in the "/" case of the when statement,
    which prints an error message and exits the program if number2 is 0.0.'
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 该函数以两个输入数字和包含所需运算符的字符串作为参数，并返回一个Double类型的数字作为计算结果。它使用when语句，根据operation的值执行所需的计算。在这一阶段，数字和运算符类型都已经被验证。然而，还有一个潜在的错误源：除以零。我们通过在when语句中的“/”分支使用if...else块来处理这一点，如果number2为0.0，则打印错误消息并退出程序。
- en: Notice that we also include an else clause for the overall when statement ❶,
    even though no further errors should remain at this point (hence the “Unexpected
    error encountered” message). Having this clause as a fallback is good practice
    in case unexpected issues or compiler bugs lead to unpredictable errors.
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们还为整体的when语句❶添加了一个else子句，尽管此时不应再有其他错误（因此有“遇到意外错误”消息）。添加这个子句作为回退机制是一个好习惯，以防出现意外问题或编译器错误导致不可预测的错误。
- en: With the calculation performed, our main() function moves on to step 4 and displays
    the result using a string template. Looking back at main(), notice how our use
    of custom functions to encapsulate the various individual tasks of the program
    has kept the main() function itself tidy and easy to read. In this way, functions
    help us maintain well-organized applications.
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 进行完计算后，我们的main()函数进入第4步，并使用字符串模板显示结果。回顾main()函数，可以注意到我们使用自定义函数来封装程序中的各个任务，这使得main()函数本身保持简洁且易于阅读。通过这种方式，函数帮助我们保持应用程序的良好结构。
- en: The Result
  id: totrans-374
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 结果
- en: Here’s a sample run of the program to multiply two numbers, 37 and 9\. The user
    input is shown in bold.
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个程序运行的示例，用于乘法运算两个数字，37和9。用户输入以**粗体**显示。
- en: '[PRE94]'
  id: totrans-376
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: Notice that even though the inputs are integers, they get converted to the Double
    type before conducting the multiplication. That is, 37 becomes 37.0 and 9 becomes
    9.0, as shown at the end of the output under Result. Feel free to experiment with
    invalid numbers or operators and observe how the program behaves. We can learn
    a lot from our mistakes!
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，尽管输入的是整数，但在进行乘法计算之前，它们会被转换为Double类型。也就是说，37变成了37.0，9变成了9.0，如输出结果中的“结果”部分所示。可以尝试使用无效的数字或运算符，观察程序的行为。我们可以从错误中学到很多！
- en: Summary
  id: totrans-378
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we covered an array of fundamental elements of the Kotlin language.
    You learned how to use comments to enhance code clarity, variables to store and
    manage data, and operators to manipulate that data. You explored flow control
    structures like conditionals and loops to dictate your program’s behavior, and
    functions to encapsulate and reuse code effectively. With lambda expressions,
    you saw a way to write and use functions on the fly and got a glimpse of the functional
    programming style. You also practiced receiving input and providing output, for
    both console- and file-based interactions. To conclude the chapter, you gained
    hands-on practice bringing these elements together through a project implementing
    a console-based calculator.
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们介绍了 Kotlin 语言的一系列基础元素。你学习了如何使用注释来增强代码的可读性，如何使用变量来存储和管理数据，以及如何通过运算符来操作这些数据。你探索了条件语句和循环等流程控制结构，来决定程序的行为，并且通过函数有效地封装和重用代码。通过
    lambda 表达式，你看到了即时编写和使用函数的方式，并初步了解了函数式编程风格。你还练习了接收输入和提供输出，涵盖了控制台和文件交互的操作。最后，通过一个实现控制台计算器的项目，你获得了将这些元素结合起来的实践经验。
- en: Resource
  id: totrans-380
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 资源
- en: Kotlin. “Kotlin Docs.” (The official Kotlin documentation.) Accessed June 15,
    2024\. *[https://kotlinlang.org/docs/home.xhtml](https://kotlinlang.org/docs/home.xhtml)*.
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: Kotlin. “Kotlin 文档。”（官方 Kotlin 文档。）访问日期：2024年6月15日。 *[https://kotlinlang.org/docs/home.xhtml](https://kotlinlang.org/docs/home.xhtml)*。
