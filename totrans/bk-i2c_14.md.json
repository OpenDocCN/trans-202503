["```\ntypedef struct\n{\n    const uint32_t VERID;\n    const uint32_t PARAM;           // The \"M\" prefix stands\n    const uint32_t unused1;         // for \"Master\" in the\n    const uint32_t unused2;         // following names:\n    volatile uint32_t MCR;          // 010 Control Reg\n    volatile uint32_t MSR;          // 014 Status Reg\n    volatile uint32_t MIER;         // 018 Int Enable Reg\n    volatile uint32_t MDER;         // 01C DMA Enable Reg\n    volatile uint32_t MCFGR0;       // 020 Config Reg 0\n    volatile uint32_t MCFGR1;       // 024 Config Reg 1\n    volatile uint32_t MCFGR2;       // 028 Config Reg 2\n    volatile uint32_t MCFGR3;       // 02C Config Reg 3\n    volatile uint32_t unused3[4];\n    volatile uint32_t MDMR;         // 040 Data Match Reg\n    volatile uint32_t unused4;\n    volatile uint32_t MCCR0;        // 048 Clock Config Reg 0\n    volatile uint32_t unused5;\n    volatile uint32_t MCCR1;        // 050 Clock Config Reg 1\n    volatile uint32_t unused6;\n    volatile uint32_t MFCR;         // 058 FIFO Control Reg\n    volatile uint32_t MFSR;         // 05C FIFO Status Reg\n    volatile uint32_t MTDR;         // 060 Transmit Data Reg\n    volatile uint32_t unused7[3];\n    volatile uint32_t MRDR;         // 070 Receive Data Reg\n    volatile uint32_t unused8[39];\n\n                                    // The \"S\" prefix stands\n                                    // for \"Slave\" in the\n                                    // following names:\n    volatile uint32_t SCR;          // 110 Control Reg\n    volatile uint32_t SSR;          // 114 Status Reg\n    volatile uint32_t SIER;         // 118 Int Enable Reg\n    volatile uint32_t SDER;         // 11C DMA Enable Reg\n volatile uint32_t unused9;\n    volatile uint32_t SCFGR1;       // 124 Config Reg 1\n    volatile uint32_t SCFGR2;       // 128 Config Reg 2\n    volatile uint32_t unused10[5];\n    volatile uint32_t SAMR;         // 140 Address Match Reg\n    volatile uint32_t unused11[3];\n    volatile uint32_t SASR;         // 150 Address Status Reg\n    volatile uint32_t STAR;         // 154 Transmit Ack Reg\n    volatile uint32_t unused13[2];\n    volatile uint32_t STDR;         // 160 Transmit Data Reg\n    volatile uint32_t unused14[3];\n    volatile uint32_t SRDR;         // 170 Receive Data Reg\n} IMXRT_LPI2C_Registers;\n\n// LPI2C2 is not connected to any\n// pins on the Teensy 4.*x*.\n\n#define LPI2C1      (*(IMXRT_LPI2C_Registers *)0x403F0000)\n#define LPI2C2      (*(IMXRT_LPI2C_Registers *)0x403F4000)  \n#define LPI2C3      (*(IMXRT_LPI2C_Registers *)0x403F8000)\n#define LPI2C4      (*(IMXRT_LPI2C_Registers *)0x403FC000)\n```", "```\nI2CDriverWire Wire( Master, Slave );\nI2CDriverWire Wire1( Master1, Slave1 );\nI2CDriverWire Wire2( Master2, Slave2 );\n```", "```\nvoid I2CDriverWire::begin() \n{\n    end();\n    master.begin( master_frequency );\n}\n```", "```\nvoid IMX_RT1060_I2CMaster::begin( uint32_t frequency ) \n{\n    // Make sure master mode is disabled before configuring it:\n\n    stop( port, config.irq );\n\n    // Set up pins and master clock:\n\n    initialise_common( config, pad_control_config );\n\n    // Configure and Enable Master Mode.\n    // Set FIFO watermarks. Determines when the RDF and TDF \n    // interrupts happen:\n\n    port->MFCR = LPI2C_MFCR_RXWATER( 0 ) | LPI2C_MFCR_TXWATER( 0 );\n    set_clock( frequency );\n\n    // Set up interrupt service routine:\n\n    attachInterruptVector( config.irq, isr );\n\n    // Enable all the interrupts you use:\n\n    port->MIER = \n            LPI2C_MIER_RDIE | LPI2C_MIER_SDIE | \n            LPI2C_MIER_NDIE | LPI2C_MIER_ALIE | \n            LPI2C_MIER_FEIE | LPI2C_MIER_PLTIE;\n\n    NVIC_ENABLE_IRQ( config.irq );\n}\n```", "```\nstatic void stop( IMXRT_LPI2C_Registers* port, IRQ_NUMBER_t irq )\n{\n    // Halt and reset Master Mode if it's running:\n\n  ❶ port->MCR = (LPI2C_MCR_RST | LPI2C_MCR_RRF | LPI2C_MCR_RTF);\n    port->MCR = 0;\n\n    // Halt and reset Slave Mode if it's running:\n\n  ❷ port->SCR = (LPI2C_SCR_RST | LPI2C_SCR_RRF | LPI2C_SCR_RTF);\n port->SCR = 0;\n\n    // Disable interrupts:\n\n  ❸ NVIC_DISABLE_IRQ( irq );\n    attachInterruptVector( irq, nullptr );\n}\n```", "```\nstatic void initialise_common\n(\n  ❶ IMX_RT1060_I2CBase::Config hardware,\n    uint32_t pad_control_config\n){\n    // Set LPI2C Clock to 24 MHz. This is required by \n    // slaves as well as masters:\n\n  ❷ CCM_CSCDR2 = (CCM_CSCDR2 & ~CCM_CSCDR2_LPI2C_CLK_PODF( 63 )) | \n                    CCM_CSCDR2_LPI2C_CLK_SEL;\n\n  ❸ hardware.clock_gate_register |= hardware.clock_gate_mask;\n\n    // Set up SDA and SCL pins and registers:\n\n  ❹ initialise_pin( hardware.sda_pin, pad_control_config );\n    initialise_pin( hardware.scl_pin, pad_control_config );\n}\n```", "```\n// Supports 100-kHz, 400-kHz, and 1-MHz modes.\n\nvoid IMX_RT1060_I2CMaster::set_clock( uint32_t frequency )\n{\n    if( frequency < 400000 )\n    {\n        // Use Standard Mode (up to 100 kHz).\n\n        port->MCCR0 = LPI2C_MCCR0_CLKHI( 55 ) | \n                        LPI2C_MCCR0_CLKLO( 59 ) |\n                        LPI2C_MCCR0_DATAVD( 25 ) | \n                        LPI2C_MCCR0_SETHOLD( 40 );\n\n        port->MCFGR1 = LPI2C_MCFGR1_PRESCALE( 1 );\n\n        port->MCFGR2 = LPI2C_MCFGR2_FILTSDA( 5 ) |\n                        LPI2C_MCFGR2_FILTSCL( 5 ) |\n                        LPI2C_MCFGR2_BUSIDLE\n                        (\n                            2 * (59 + 40 + 2)\n                        );\n\n        port->MCFGR3 = \n            LPI2C_MCFGR3_PINLOW\n            (\n                CLOCK_STRETCH_TIMEOUT * 12 / 256 + 1\n            );\n\n    } \n    else if( frequency < 10000000 )\n    {\n        // Use Fast Mode - up to 400 kHz.\n\n      ❶ port->MCCR0 = LPI2C_MCCR0_CLKHI( 26 ) | \n                        LPI2C_MCCR0_CLKLO( 28 ) |\n                        LPI2C_MCCR0_DATAVD( 12 ) | \n                        LPI2C_MCCR0_SETHOLD( 18 );\n\n      ❷ port->MCFGR1 = LPI2C_MCFGR1_PRESCALE( 0 );\n      ❸ port->MCFGR2 = LPI2C_MCFGR2_FILTSDA( 2 ) | \n                        LPI2C_MCFGR2_FILTSCL( 2 ) |\n                        LPI2C_MCFGR2_BUSIDLE\n                        (\n                            2 * (28 + 18 + 2)\n                        );\n\n        port->MCFGR3 = \n            LPI2C_MCFGR3_PINLOW\n            (\n                CLOCK_STRETCH_TIMEOUT * 24 / 256 + 1\n            );\n    } \n else \n    {\n        // Use Fast Mode Plus (up to 1 MHz).\n\n        port->MCCR0 = LPI2C_MCCR0_CLKHI(9) | \n                        LPI2C_MCCR0_CLKLO(10) |\n                        LPI2C_MCCR0_DATAVD(4) | \n                        LPI2C_MCCR0_SETHOLD(7);\n\n        port->MCFGR1 = LPI2C_MCFGR1_PRESCALE(0);\n        port->MCFGR2 = LPI2C_MCFGR2_FILTSDA(1) | \n                        LPI2C_MCFGR2_FILTSCL(1) |\n                        LPI2C_MCFGR2_BUSIDLE\n                        (\n                            2 * (10 + 7 + 2)\n                        ); \n\n        port->MCFGR3 = \n            LPI2C_MCFGR3_PINLOW\n            (\n                CLOCK_STRETCH_TIMEOUT * 24 / 256 + 1\n            );\n    }\n  ❹ port->MCCR1 = port->MCCR0;\n}\n```", "````After setting the clock frequency, the `begin()` function attaches an ISR and enables interrupts. In theory, a nonthreaded system such as Arduino won’t benefit as much from an interrupt-driven I²C device driver; all I²C calls are synchronous, so you still have to enter a busy-waiting loop until the transmission or reception is complete. Nevertheless, using interrupts can be useful if you’re using the Teensy Threading Library, and an interrupt-driven system combined with the FIFOs can improve transmission and reception latency.    Each object gets its own instance of an ISR, which handles errors, nonempty receive FIFOs (meaning data has arrived), and empty transmission FIFOs (meaning you can send more data). Here’s the source code for the ISR (cleaned up for publication):    ``` void IMX_RT1060_I2CMaster::_interrupt_service_routine()   {      uint32_t msr = port->MSR;        // Check for the following errors (prioritized      // in this order):      //      //  NDF-  NAK detection flag.      //  ALF-  Arbitration lost flag.      //  FEF-  FIFO error flag.      //  PLTF- Pin low timeout flag.      ❶ if       (          msr &               (                  LPI2C_MSR_NDF |                   LPI2C_MSR_ALF |                   LPI2C_MSR_FEF |                   LPI2C_MSR_PLTF              )      ){            // If you got a NAK, determine who caused          // the NAK:            if( msr & LPI2C_MSR_NDF )           {              port->MSR = LPI2C_MSR_NDF; // Clear the error              if( state == State::starting )              {                  _error = I2CError::address_nak;              }               else               {                  _error = I2CError::data_nak;              }          }            // If you got an arbitration lost error, that          // takes precedence over NDF:            if( msr & LPI2C_MSR_ALF )           {              port->MSR = LPI2C_MSR_ALF; // Clear the error              _error = I2CError::arbitration_lost;          }   // FIFO empty error takes precedence over          // earlier errors:            if( msr & LPI2C_MSR_FEF )           {              port->MSR = LPI2C_MSR_FEF; // Clear error              if( !has_error() )               {                  _error = I2CError::master_fifo_error;              }                            // else FEF was triggered by another error.               // Ignore it (and keep previous error status).          }            // If pin low timeout, clear error and set          // error return value.            if( msr & LPI2C_MSR_PLTF )           {              port->MSR = LPI2C_MSR_PLTF; // Clear error              _error = I2CError::master_pin_low_timeout;          }            // On any of the above errors, put this in the          // stopping state if it's not already there.                    if( state != State::stopping )           {              state = State::stopping;              abort_transaction_async();          }          // else already trying to end the transaction.      }        // The following are \"normal\" conditions (not errors).      //      // Check for the \"Stop Detected\" flag, indicating end      // of transmission has been received.      ❷ if( msr & LPI2C_MSR_SDF )       {          // You don't want to handle TDF if you can avoid it,          // so disable that interrupt.                    port->MIER &= ~LPI2C_MIER_TDIE;           state = State::stopped;          port->MSR = LPI2C_MSR_SDF; // Clear stop detected      }        // Check the received data flag. This bit gets set      // whenever the number of bytes in the FIFO exceeds      // the \"high water\" mark. Because this code sets      // the HWM to 0, you get an interrupt whenever   // any byte comes along.      ❸ if( msr & LPI2C_MSR_RDF )       {          if( ignore_tdf )          {              // Copy the byte out of the receive              // register into the memory buffer:                if( buff.not_started_reading() )               {                  error = I2CError::ok;                  state = State::transferring;              }              if( state == State::transferring )               {                  buff.write( port->MRDR );              }               else               {                  // Reset the receive FIFO if                  // not expecting data.                    port->MCR |= LPI2C_MCR_RRF;              }              if( buff.finished_reading() )               {                  if( tx_fifo_count() == 1 )                   {                      state = State::stopping;                  }                   else                   {                      state = State::transfer_complete;                  }                                    // Avoids triggering PLTF if                   // you didn't send a STOP.                                    port->MCR &= ~LPI2C_MCR_MEN; // Master disable                                }          }           else           {              // This is a write transaction.               // Code shouldn't have gotten a read.                            state = State::stopping;              abort_transaction_async();          }      }        // Handle writing data to the I2C bus here.   // Is data available (and code is not ignoring it)?      ❹ if( !ignore_tdf && (msr & LPI2C_MSR_TDF) )       {          if( buff.not_started_writing() )           {              _error = I2CError::ok;              state = State::transferring;          }          if( state == State::transferring )           {              // Fill the transmit buffer (FIFO).                            uint32_t fifo_space =                   NUM_FIFOS - tx_fifo_count();                                while              (                       buff.has_data_available()                   &&  fifo_space > 0               ){                  port->MTDR =                       LPI2C_MTDR_CMD_TRANSMIT | buff.read();                  fifo_space--;              }                // If writing is done, disable transmission              // interrupts and clean up.                if              (                       buff.finished_writing()                   &&  tx_fifo_count() == 0               ){                  port->MIER &= ~LPI2C_MIER_TDIE;                  if ( stop_on_completion )                  {                      state = State::stopping;                      port->MTDR = LPI2C_MTDR_CMD_STOP;                  }                   else                   {                      state = State::transfer_complete;                  }                                    // Avoids triggering PLTF if                   // you didn't send a STOP.                                    port->MCR &= ~LPI2C_MCR_MEN;                  }          }          // else ignore it. This flag is frequently           // set in read transfers.      }  } ```    The ISR begins by checking for possible errors ❶ and sets an appropriate error condition based on the type of error, if an error condition exists. If no error exists ❷, then the ISR checks to see if a stop condition has been detected and sets the appropriate stop flag if so. Next, the ISR checks to see if any data has been received ❸, in which case it adds the data to the receive buffer. It then checks to see if it is transmitting any data to the I²C bus ❹, in which case it removes data from the transmit buffer to transmit, cleaning up and terminating the transmission if there is no data left to send in the buffer.    #### 11.1.2.2 The beginTransmission() and endTransmission() Functions    In Arduino I²C programming, the `beginTransmission()` function marks the beginning of a sequence to be transmitted across the I²C bus, while the `endTransmission()` function marks the end of a write operation. These two functions bracket a sequence of write commands (described in the next section). The write commands simply place data in a buffer (initialized by the `beginTransmission()` call), and then the `endTransmission()` function transmits the data in the buffer across the I²C bus.    The `beginTransmission()` function accepts a single argument, which is the I²C device address. Here’s its code:    ``` void I2CDriverWire::beginTransmission( int address )   {      write_address = (uint8_t)address;      tx_next_byte_to_write = 0;  } ```    This function doesn’t accomplish much. It saves the device address into a local (object) field for later use, initializes (to 0) a queue index for storing data to transmit, and then returns. Most of the real work happens in other functions.    Here’s the code for the `endTransmission()` function:    ``` uint8_t I2CDriverWire::endTransmission( int stop )   {      master.write_async      (          write_address,           tx_buffer,           tx_next_byte_to_write,           stop      );      finish();      return toWireResult( master.error() );  } ```    The single parameter is a Boolean flag indicating whether the function transmits a stop condition after it completes transmitting the data in the buffer.    The `write_async()` function within `endTransmission()`, as its name suggests, asynchronously writes the data in the buffer (`tx_buffer`) across the I²C bus. Because it is asynchronous, this function returns before the transmission is complete. Here’s the `write_async()` code:    ``` void IMX_RT1060_I2CMaster::write_async  (      uint8_t address,       uint8_t* buffer,       size_t num_bytes,       bool send_stop  ){    ❶ if( !start( address, MASTER_WRITE )) return;        if( num_bytes == 0 )      {          // The caller is probably probing           // addresses to find slaves.          // Don't try to transmit anything.                    ignore_tdf = true;        ❷ port->MTDR = LPI2C_MTDR_CMD_STOP;          return;      }      ❸ buff.initialise( buffer, num_bytes );      stop_on_completion = send_stop;      port->MIER |= LPI2C_MIER_TDIE;  } ```    The `start()` function call ❶ within `write_async()` puts an I²C start condition on the bus. It returns true if the operation was successful. If it fails, `write_async()` simply returns. If it succeeds, but there are no bytes to send, the `write_async()` function writes the appropriate bit to the MTDR to stop the whole transmission ❷. If `start()` succeeds and there is data to transmit, then `write_async()` initializes a transmission buffer ❸ and enables the transmit data interrupt enable bit.    Here’s the code for the `start()` function within `write_async()`:    ``` bool IMX_RT1060_I2CMaster::start  (      uint8_t address,       uint32_t direction  ){    {    ❶ if( !finished() )       {          // Code hasn't completed the previous transaction yet.            abort_transaction_async();            _error = I2CError::master_not_ready;   state = State::idle;          return false;      }        // Start a new transaction.          ❷ ignore_tdf = direction;      _error = I2CError::ok;      state = State::starting;        // Make sure the FIFOs are empty before you start.            if( tx_fifo_count() > 0 || rx_fifo_count() > 0 )       {          // This should never happen.            error = I2CError::master_fifos_not_empty;          abort_transaction_async();          return false;      }        // Clear status flags.            clear_all_msr_flags();        // Send a START to the slave at ″address.″          ❸ port->MCR |= LPI2C_MCR_MEN;      uint8_t i2c_address = (address & 0x7F) << 1;      port->MTDR =           LPI2C_MTDR_CMD_START | i2c_address | direction;        return true;  } ```    If the system is not finished with a previous transmission ❶, this function will terminate the previous transmission and set the state to idle. Then the `start()` function initializes a new I²C bus transaction ❷ by clearing all FIFOs and status flags. Finally, this function places a start condition on the I²C bus ❸. If this code is successful, it initializes the `state` field with `State::starting`.    The `endTransmission()` function is synchronous and does not return to the caller until the transmission is complete. To match those semantics, this version of the function calls the `finish()` function, which waits until the transmission is complete.    The `finish()` function is a simple little class method:    ``` void finish()   {      elapsedMillis timeout;      while( timeout < timeout_millis )      {          if( master.finished() )           {              return;          }      }  } ```    This function is a short extension of the `master.finished()` function that adds a timeout capability, which looks like this:    ``` inline bool IMX_RT1060_I2CMaster::finished()   {      return state >= State::idle;  } ```    The `state` field is initialized in the call to `start()` within `write_async()` and then set by the ISR. If the state is `transfer_complete` or `stopped`, then the ISR is done transferring data. Otherwise, the ISR is still reading or writing data, and the `endTransmission()` function will wait until the ISR has completed transferring data after the write operation begins.    At the end of `endTransmission()`, the function calls `toWireResult()` to translate the error status bitmap returned by `master.error()` into an Arduino-compatible error code, and the function returns that value to the caller.    #### 11.1.2.3 The write Functions    Between the `beginTransmission()` and `endTransmission()` calls, Arduino code calls the `write()` function to append data to the transmission buffer. There are two variants of the `write()` function: one that writes a single byte and one that writes a buffer.    Here’s the source code for the two `write()` functions:    ``` size_t I2CDriverWire::write( uint8_t data )   {      if( tx_next_byte_to_write < tx_buffer_length )       {          tx_buffer[tx_next_byte_to_write++] = data;          return 1;      }      return 0;  }    size_t I2CDriverWire::write( const uint8_t* data, size_t length )   {      size_t avail = tx_buffer_length - tx_next_byte_to_write;      if( avail >= length )       {          uint8_t* dest = tx_buffer + tx_next_byte_to_write;          memcpy( dest, data, length );          tx_next_byte_to_write += length;          return length;      }      return 0;  } ```    The maximum buffer length (defined in the `I2CDriverWire` class) is 32 bytes. If an application attempts to transmit more than 32 bytes in a single I²C transmission, this code will ignore all bytes beyond the size of the buffer.    #### 11.1.2.4 The requestFrom(), read(), and available() Functions    Reading bytes from the I²C bus is slightly less complex than writing data. There are three functions associated with reading: `requestFrom()`, `read()`, and `available()`. The `requestFrom()` function reads the data from a peripheral device and buffers the data up in memory, while the `read()` function retrieves bytes from the buffer and `available()` returns the number of bytes in the buffer.    Here’s the source code for the `requestFrom()` function:    ``` uint8_t I2CDriverWire::requestFrom  (      int address,       int quantity,    int stop  ){      rx_bytes_available = 0;      rx_next_byte_to_read = 0;      master.read_async      (          (uint8_t)address,           rxBuffer,           min( (size_t)quantity, rx_buffer_length ),          stop      );      finish();      rx_bytes_available = master.get_bytes_transferred();      return rx_bytes_available;  } ```    The first two statements in this function initialize the buffer index and count. The call to `master.read_async()` starts the actual read operation (it primes the system and notifies the ISR to start accepting data). As its name suggests, `master.read_async()` returns immediately, before the actual data is read. As with the `endTransmission()` function, `requestFrom()` calls the `finish()` function to wait until all the data has arrived from the peripheral device. Finally, `requestFrom()` returns the actual number of bytes read from the peripheral.    Here’s the source code to the `read_async()` class function (which is called from `requestFrom()`):    ``` void IMX_RT1060_I2CMaster::read_async  (      uint8_t  address,       uint8_t* buffer,       size_t   num_bytes,       bool     send_stop  ){   ❶ if( num_bytes > MAX_MASTER_READ_LENGTH )      {          error = I2CError::invalid_request;          return;      }      ❷ if( !start( address, MASTER_READ ))      {          return;      }    ❸ if( num_bytes == 0 )      {          // The caller is probably probing addresses           // to find slaves. Don't try to read anything.                  ❹ port->MTDR = LPI2C_MTDR_CMD_STOP;          return;      }        buff.initialise( buffer, num_bytes );   port->MTDR = LPI2C_MTDR_CMD_RECEIVE | (num_bytes - 1);        if( send_stop )       {          port->MTDR = LPI2C_MTDR_CMD_STOP;      }  } ```    The `read_async()` function begins with a quick validity check ❶ of the requested length. If the caller requested too many bytes (more than 32, the size of the internal buffer), the function returns an error.    Next, `read_async()` sends a start condition on the bus, along with the peripheral address and read command ❷. If that transmission is successful, the function checks to see if the caller is requesting 1 or more bytes to read ❸. If the caller specified 0 bytes, the function is done. Reading 0 bytes is a common way application code probes an address to see if there is a device present; `read_async()` will acknowledge the address byte transmission if it’s there. If no device is present at the address, a NAK happens. The `read_async()` function transmits a stop condition ❹ if the caller specified a read of 0 bytes.    If the caller wants to read 1 or more bytes, `read_async()` calls the buffer initialization function to initialize the buffer associated with the calling `IMX_RT1060_I2CMaster` object. Then `read_async()` writes the receive command to the MTDR along with the number of bytes (minus 1) to receive. This particular write (32 bits) inserts the command into an on-chip command FIFO and increments the FIFO pointer. At this point, the on-chip hardware will begin processing this receive data request independently of code execution.    After writing the receive command to the MTDR, `read_async()` checks whether the caller wants to send a stop condition after receiving the data. If the caller does want to send a stop, `read_async()` writes a stop command to the MTDR register (placing it in the command FIFO to execute once the read command finishes).    Once the `read_async()` function returns, the MCU hardware takes over and handles the receive requests. The hardware notifies the software via interrupts as data arrives, and the ISR checks to see if the read request is complete, updating the class’s `state` object as appropriate. The call to finish in the `requestFrom()` function returns once the read completes or a timeout occurs. Of course, this call to `finish()` completes the `requestFrom()` operation.    The `read()` function is straightforward: it just returns a byte from the buffer filled by a call to the `requestFrom()` function (or –1 if no data is available). Here’s its source code:    ``` int I2CDriverWire::read()   {      if( rx_next_byte_to_read < rx_bytes_available )           {          return rxBuffer[rx_next_byte_to_read++];      }      return no_more_bytes;  } ```    Finally, the `available()` function is simple—it just returns the number of bytes available in the read buffer as the function result.    #### 11.1.2.5 Beyond the Arduino Library    Gemmell’s code was specifically written to support Teensyduino programming using the Arduino (“Wiring”) programming paradigm. *Wiring programming* consists of some initialization code (the `setup()` procedure) followed by a main loop (the `loop()` function) that executes repeatedly. Wiring was designed to mimic the typical programming paradigm used for most noninterrupt-driven, non-RTOS embedded systems. Most MCUs that support hardware I²C communication will also support RTOS environments by using interrupts, hardware FIFOs, and DMA. Indeed, Gemmell’s code uses the NXP i.MX RT1062 MCU’s interrupt and FIFO capabilities but returns to the Wiring paradigm via the `finish()` function (which effectively stops the program’s execution until the data transfer is complete).    If you’re running your code under some environment other than Arduino, especially a multithreaded environment, you can dramatically improve the performance of the system by replacing the `finish()` function with a wait-on-event–type API call. Such a call would suspend the thread until the ISR signals it and tells it that the transmission or reception is complete. Rather than burning CPU cycles in a busy-waiting loop, the thread would simply stop, and those CPU cycles would be available for other threads to use. Modifying Gemmell’s code to support this would be easy: you’d simply replace the call to finish with an appropriate wait API call and modify the ISR to signal that thread when the I²C operation is complete.    One issue with this current implementation is that an interrupt consumes CPU cycles every time a character is received or whenever the transmit FIFO empties and the system needs to add more characters in the output FIFO. Using DMA, you could spare the CPU from having to do this work. In a DMA-driven system, the application programs the CPU’s DMA registers with an address and a count. Whenever an I²C transmission needs more data or whenever an I²C reception receives data, the DMA controller accesses memory without intervention of the CPU, saving all the work associated with an interrupt (saving machine state) and processing the interrupt. Although Gemmell’s code does not use DMA, the i.MX RT1062 supports this for I²C. For multithreaded RTOSs, this can make I²C operations even more efficient. See the NXP documentation in “For More Information” for more details.    ## 11.2 ATtiny Controller Programming    This section describes how to use the UART on an ATtiny84 MCU to create an I²C controller device. Chapter 3 originally described a software-based I²C controller on the ATtiny84; I moved that discussion to the online chapters because the code was largely redundant with respect to the Teensy code appearing in Chapter 3\\. See Chapter 17 online at [https://bookofi2c.randallhyde.com](https://bookofi2c.randallhyde.com) for the software-based controller. This chapter describes a more efficient implementation using the universal serial interface hardware on the ATtiny84.    The code in this section is based on Adafruit’s open source TinyWireM package, which is based on the Atmel AVR310 application note and was originally written by BroHogan and jkl (the names given in the source code). For the original code, visit [https://github.com/adafruit/TinyWireM](https://github.com/adafruit/TinyWireM).    The ATtiny84 MCU—the MCU used on the Atto84 board from SparkFun—includes a hardware shift register known as the Universal Serial Interface (USI). You can employ the USI for any arbitrary shifting applications, including I²C, SPI, USB, or generic serial communication. Because the shifting is done in hardware, it is much more efficient than the bit-banging approach used in a software implementation of I²C. However, USI has a few limitations:    *   It can be used for only one interface at a time, so it’s a bit difficult to use if you need to control multiple serial buses concurrently (I²C and SPI, for example). *   It provides no glitch filtering or slew rate limiting, which I²C requires, so it can be a little noisier than hardware implementations. *   Clock generation (that is, SCL) must be done in software. *   It provides no buffering, so software must continuously monitor the shift register to retrieve data (or transmit new data) when the shift register is full or empty.    Generally, ATtiny84 MCUs are employed in low-cost, single-activity applications where they perform a single task, like transmitting or receiving data on the I²C bus. In these cases, their limitations aren’t much of a problem.    The ATtiny84 has a few registers associated with the USI that you’ll use for I²C communication: USDR, USISR, and USICR. USDR is the USI 8-bit data register (output data is written here and input data is read from here).    USISR is the USI status register, which contains information about the USI shift register’s state. See [Table 11-10](#table11-10) for a description of these bits.      Table 11-10: USISR Bit Definitions       | **Bit** | **Description** | | --- | --- | | 0 to 3 | USICNT: 4-bit counter for the shift register. | | 4 | USIDC: Data collision flag. Set to 1 when the data being transmitted to SDA does not match the value actually on the pin. Use this flag to detect lost arbitration. | | 5 | USIPF: Stop condition flag. Set when a stop condition occurs. | | 6 | USIOIF: Counter overflow interrupt flag. Indicates that the 4-bit counter has overflowed. Must write a 1 to this bit position to clear this flag. If the overflow interrupt is enabled, an interrupt occurs on overflow. | | 7 | USISIF: Start condition interrupt flag. Set (and an appropriate interrupt generated, if enabled) when a start condition is found on the I²C bus. Writing a 1 to this bit position clears this flag. |    USICR is the USI control register. Bits written to this port affect the operation of the USI. See [Table 11-11](#table11-11) for a description of these bits.      Table 11-11: USICR Bit Definitions       | **Bit** | **Description** | | --- | --- | | 0 | USITC: Toggle clock pin. Writing a 1 to this bit position toggles the clock pin. | | 1 | USICLK: Strobe clock. Writing a 1 to this bit increments the counter and shifts data in the shift register, but only if USICS0 and USICS1 are 0\\. If USICS1 is 1, then setting this bit to 1 will select the USITC as the clock (this is the state the software uses). See [Table 11-12](#table11-12) for a description of this bit. | | 2 to 3 | USICS0, USICS1: Clock select. See [Table 11-12](#table11-12) for a description of these bits. | | 4 to 5 | USIWM1, USIWM0: Wire mode. These bits control the SDA and SCL operation mode. For normal I²C operation, USIWM0 is 0 and USIWM1 is 1\\. [Table 11-13](#table11-13) lists the meanings of these two bits. | | 6 | Counter overflow interrupt enable. | | 7 | Start condition interrupt enable. |    [Table 11-12](#table11-12) lists the clock source settings for bits 1 to 3 in the USICR register.      Table 11-12: USICR Clock Source Settings       | **USICS1** | **USICS0** | **USICLK** | **Clock source** | 4**-bit counter clock source** | | --- | --- | --- | --- | --- | | 0 | 0 | 0 | No clock | No clock | | 0 | 0 | 1 | Software clock strobe (USICLK) | Software clock strobe (USICLK) | | 0 | 1 | X | Timer/Counter0 Compare Match | Timer/Counter0 Compare Match | | 1 | 0 | 0 | External, positive edge | External, both edges | | 1 | 0 | 1 | External, positive edge | Software clock strobe (USITC) | | 1 | 1 | 0 | External, negative edge | External, both edges | | 1 | 1 | 1 | External, negative edge | Software clock strobe (USITC) |    Bits 4 and 5 in the USICR specify the mode of the USI pins on the ATtiny84\\. [Table 11-13](#table11-13) specifies the various options for these bits.      Table 11-13: Pin Mode Settings       | **USIWM1** | **USIWM0** | **Description** | | --- | --- | --- | | 0 | 0 | Normal I/O pins (not connected to serial shift register). | | 0 | 1 | Three-wire mode. Uses DO, DI, and USCK pins. This is for SPI bus operation. | | 1 | 0 | Two-wire mode. Uses SDA (DI) and SCL (USCK) pins. This is the setting the software in this chapter uses for I²C operation. | | 1 | 1 | Two-wire mode. Uses SDA and SCL pins. Same as two-wire mode above, but the SCL line is held low when a counter overflow occurs and until the Counter Overflow Flag (USIOIF) is cleared. |    In addition to the three USI ports, I²C communication uses the ATtiny84’s PORT A parallel port, on which the SDA and SCL lines appear (SCL on bit 4, SDA on bit 6). Three memory locations are associated with PORT A:    *   PORTA: Output bits are written to this address. *   PINA: Input bits are read from this port. *   DDRA: I/O direction for PORTA is set here.    Because the I²C SDA and SCL lines are bidirectional, the code is constantly setting the data direction bits in the DDRA register.    ### 11.2.1 The Atto84 Triangle Wave Demonstration Program    The Atto84 triangle wave output program in [Listing 11-1](#listing11-1) provides the source code for the triangle wave output program for the Atto84, using the low-level ATtiny84 registers.    The first section of [Listing 11-1](#listing11-1) contains various constant declarations used throughout the code. In particular, it contains port address definitions, timing constants, and various bit patterns the code uses to initialize various registers:    ``` // Listing11-1.ino  //  // Sample triangle wave output  // on an Atto84 board from SparkFun  // utilizing the ATtiny84 USI.                                                                         #include \"Arduino.h\"  #include <inttypes.h>  #include <avr/interrupt.h>  #include <avr/io.h>  #include <util/delay.h>    // From avr/io.h:  //  // PORTA output pins:  //  // PORTA   SFR_IO8(0x02)  // PORTA7  7  // PORTA6  6  // PORTA5  5  // PORTA4  4  // PORTA3  3  // PORTA2  2  // PORTA1  1  // PORTA0  0  //  // USI Control Register:  //  // USICR   SFR_MEM8(0xB8)  // USITC   0    Toggle clock port pin.  // USICLK  1    1 for software clk strobe.  // USICS0  2    0 for clk source select 0.  // USICS1  3    1 for clk source select 1.  // USIWM0  4    1 for I2C mode.  // USIWM1  5    0 for I2C mode.  // USIOIE  6    Cntr overflow int enable.  // USISIE  7    Start cond int enable.  //  // USI Status Register:  //  // USISR   SFR_MEM8(0xB9)  // USICNT0 0    4-bit counter value.  // USICNT1 1    4-bit counter value.  // USICNT2 2    4-bit counter value.  // USICNT3 3    4-bit Counter value.  // USIDC   4    Data output collision.  // USIPF   5    Stop condition flag.  // USIOIF  6    Cntr overflow int flag.  // USISIF  7    Start condition int flag.  //   // #define USIDR    SFR_MEM8(0xBA)  //  // DAC address:    #define DAC_ADRS 0x60 // 0x60 for SparkFun, 0x62 for Adafruit    // PORT A input pins:  //  // #define PINA     SFR_IO8(0x19)  Port A input pins:    #define DDR_USI         DDRA    // Data direction for port A  #define PORT_USI        PORTA   // Output pins on port A  #define PIN_USI         PINA    // Input pins on port A  #define PORT_USI_SDA    PORTA6  // Bit 6 on port A  #define PORT_USI_SCL    PORTA4  // Bit 4 on port A  #define PIN_USI_SDA     PINA6   // Bit 6 on port (pin) A  #define PIN_USI_SCL     PINA4   // Bit 4 on port (pin) A    #define TRUE (1)  #define FALSE (0)    // Time constants to pass to  // delay_us for clock delays:     #define T2_I2C          5 // >4.7 us  #define T4_I2C          4 // >4.0 us    #define I2C_READ_BIT    0  #define I2C_ADR_BITS    1   #define I2C_NAK_BIT     0     #define USI_I2C_NO_ACK_ON_ADDRESS   0x01  #define USI_I2C_NO_ACK_ON_DATA      0x02     static  unsigned char const USISR_8bit =          (1 << USISIF)       |   (1 << USIOIF)       |   (1 << USIPF)       |   (1 << USIDC)      // Clear flags       |   (0x0 << USICNT0); // Shift 8 bits            unsigned char const USISR_1bit =          (1 << USISIF)       |   (1 << USIOIF)      |   (1 << USIPF)       |   (1 << USIDC)      // Clear flags      |   (0xE << USICNT0); // Shift 1 bit              union USI_I2C_state   {    uint8_t allBits;    struct     {      uint8_t addressMode : 1;               uint8_t cntlrWriteDataMode : 1;       uint8_t memReadMode : 1;               uint8_t unused : 5;    };  } USI_I2C_state; ```    Next, the `USI_Initialize()` function, as its name suggests, is responsible for initializing the USI. See the comments in the following code for the particular initializations this function provides:    ``` // Listing11-1.ino (cont.)  //  // USI_Initialize-  //  // Initializes the USI on the Atto84.    void USI_Initialize(void)  {      // Enable pullup on SDA:          PORT_USI |= (1 << PIN_USI_SDA);          // Enable pullup on SCL:        PORT_USI |= (1 << PIN_USI_SCL);         // Enable SCL as output:            DDR_USI |= (1 << PIN_USI_SCL);             // Enable SDA as output:            DDR_USI |= (1 << PIN_USI_SDA);         // Preload data register with \"bus released\" data.            USIDR = 0xFF;             USICR = // Disable all interrupts              (0 << USISIE)           |   (0 << USIOIE)           |   (1 << USIWM1)           |   (0 << USIWM0)                         // Set USI in two-wire mode.                        |   (1 << USICS1)           |   (0 << USICS0)                         // Software strobe as counter clock source.                        |   (1 << USICLK)           |   (0 << USITC);                      USISR =               (1 << USISIF) // Clear flags          |   (1 << USIOIF)           |   (1 << USIPF)           |   (1 << USIDC)                         // Reset counter.                        |   (0x0 << USICNT0);             } // USI_Initialize  ```    The `USI_I2C_Cntlr_Start()` and `USI_I2C_Cntlr_Stop()` functions put the start and stop conditions on the USI. In both functions, the code manually pulls the SCL and SDA lines low, as appropriate, with software-based timing to match the I²C specifications:    ``` // Listing11-1.ino (cont.)  //  // USI_I2C_Cntlr_Start-  //  // Function for generating an I2C start condition.    void USI_I2C_Cntlr_Start( void )   {      // Release SCL to ensure that (repeated) start       // can be performed:        PORT_USI |= (1 << PIN_USI_SCL);        // Verify that (wait until) SCL becomes high:        while( !(PORT_USI & (1 << PIN_USI_SCL)) );        // Delay for 1/2 bit time before generating      // the start condition:            _delay_us( T2_I2C );        // Generate start condition. The SCL line has      // been high for 1/2 bit time, pulling SDA      // low generates the start:            PORT_USI &= ~(1 << PIN_USI_SDA); // Force SDA low            // Leave SDA low for at least 4 us:            _delay_us( T4_I2C );            // Okay, clean up after yourself. Start has      // been generated, so release SDA and pull      // SCL low (start of first bit's clock period):            PORT_USI &= ~(1 << PIN_USI_SCL);      PORT_USI |= (1 << PIN_USI_SDA);        return;  }    // USI_I2C_Cntlr_Stop-  //  // Function for generating an I2C stop condition.   // Used to release the I2C bus.  // Returns true if it was successful.    void USI_I2C_Cntlr_Stop( void )   {      // Stop condition consists of changing SDA from      // low to high while the SCL line is high:            PORT_USI &= ~(1 << PIN_USI_SDA); // Pull SDA low      PORT_USI |= (1 << PIN_USI_SCL);  // Release SCL            // Wait until the SCL line registers a high on      // the SCL input pin:            while( !(PIN_USI & (1 << PIN_USI_SCL)) );        // Minimum setup time is 4 us:            delay_us( T4_I2C );            // Okay, raise the SDA line to signal the      // stop condition:            PORT_USI |= (1 << PIN_USI_SDA); // Release SDA            // Minimum hold time is around 5 us:             delay_us( T2_I2C );        return TRUE;  }  ```    The `USI_I2C_Xcvr()` function is responsible for transmitting and receiving data via the USI:    ``` // Listing11-1.ino (cont.)  //  // USI_I2C_Xcvr-  //  // Transmits and receives data.    uint8_t USI_I2C_Xcvr  (      uint8_t *msg,      uint8_t msgSize  ){      uint8_t *savedMsg;      uint8_t savedMsgSize;        // Caller must clear before calling this function       // so that memReadMode can be specified:            USI_I2C_state.allBits = 0;        // Clear state bits      USI_I2C_state.addressMode = TRUE; // True for first byte                  // Determine if this is a read (1) or write (0) operation      // by looking at the LO bit of the first byte (the address   // byte) in the message.          ❶ if      (          !(                  *msg                 // The LSB in the address                &   (1 << I2C_READ_BIT)  // byte determines if it           )                            // is a cntlr Read or Write      )                                // operation      {          USI_I2C_state.cntlrWriteDataMode = TRUE;      }        // Save buffer pointer for later:            savedMsg = msg;      savedMsgSize = msgSize;                     // Send a start condition.          ❷ USI_I2C_Cntlr_Start();         // Write address and Read/Write data:          do       {          // If cntlrWrite cycle (or initial address transmission):                  ❸ if          (                  USI_I2C_state.addressMode               ||  USI_I2C_state.cntlrWriteDataMode          ){              // Write a byte.              // Pull SCL low.                            PORT_USI &= ~(1 << PIN_USI_SCL);                            // Set up data.                            USIDR = *(msg++);                                                    // Send 8 bits on bus.                            USI_I2C_Cntlr_Transfer( USISR_8bit );                   // Clock and verify (N)ACK from peripheral.  \t                          // Enable SDA as input:                            DDR_USI &= ~(1 << PIN_USI_SDA);                             // If you get a NAK, not an ACK,              // return an error code:                 if(                      USI_I2C_Cntlr_Transfer( USISR_1bit )                   &   (1 << I2C_NAK_BIT)              ){                                if( USI_I2C_state.addressMode )                  {                      return USI_I2C_NO_ACK_ON_ADDRESS;                  }                  return USI_I2C_NO_ACK_ON_DATA;              }                if              (                      (!USI_I2C_state.addressMode)                   &&  USI_I2C_state.memReadMode                )              {                  // Memory start address has been written.                  //                  // Start at peripheral address again:                                    msg = savedMsg;                                    // Set the Read Bit on peripheral address                  // (the first byte of the buffer):                                                       *(msg) |= (TRUE << I2C_READ_BIT);                                                     // Now set up for the Read cycle:                                    USI_I2C_state.addressMode = TRUE;                                     // Set byte count correctly:                                    msgSize = savedMsgSize;                                               // Note that the length should be peripheral                    // adrs byte + number of bytes to read + 1                  // (gets decremented below).                                    USI_I2C_Cntlr_Start();                                }               else               {                  // Only perform address transmission once:                                    USI_I2C_state.addressMode = FALSE;               }          }                    else    // cntlrRead cycle           {   // Enable SDA as input:                          ❹ DDR_USI &= ~(1 << PIN_USI_SDA);                 // Read a data byte:                *(msg++) = USI_I2C_Cntlr_Transfer( USISR_8bit );                // Prepare to generate ACK (or NAK               // in case of End Of Transmission).                if( msgSize == 1 )              {                  // If transmission of last byte was performed,                  // load NAK to confirm End Of Transmission:                                    USIDR = 0xFF;               }               else               {                  // Load ACK.                   // Set data register bit 7 (output for SDA) low:                                    USIDR = 0x00;               }                            // Generate ACK/NAK:                            USI_I2C_Cntlr_Transfer( USISR_1bit );                }      }while( --msgSize ); // Until all data sent/received      // Usually a stop condition is sent here, but caller    // needs to choose whether or not to send it.    //    // Transmission is successfully completed.        return( 0 );  } ```    This code begins by determining if this is a read or write operation and setting the mode appropriately ❶. Then the code puts a start condition on the bus ❷. If this is a write operation or if the code is writing the peripheral address and R/W bit to the bus, the code transmits the appropriate byte via the USI ❸. If this is a read operation, the code switches SDA to become an input pin and reads the appropriate data from the USI ❹.    Next, the `USI_I2C_Cntlr_Transfer()` function is the generic function for reading or writing an array of bytes on the USI:    ``` // Listing11-1.ino (cont.)  //  // USI_I2C_Cntlr_Transfer-  //  // Core function for shifting data in and out from the USI.  // Data to be sent has to be placed into the USIDR before  // calling this function. Data read will be returned   // by the function.  //  // Status:     //     Data to write to the USISR.  //     In this code, this will be   //     USISR_8bit (for data transfers)  //     or USISR_1bit (for ACKs and NAKs).  //                // Returns the data read from the device.    uint8_t USI_I2C_Cntlr_Transfer( uint8_t status )   {      USISR = status;        // Set USISR to status                                uint8_t control =      // Prepare clocking              (0 << USISIE)  // Interrupts disabled          |   (0 << USIOIE)          |   (1 << USIWM1)  // Set USI in two-wire mode          |   (0 << USIWM0)           |   (1 << USICS1)           |   (0 << USICS0)           |   (1 << USICLK)  // Software clock as source          |   (1 << USITC);  // Toggle Clock Port            do       {          // Wait for roughly 1/2 bit time (4.7-5 us):                    _delay_us( T2_I2C );                    // Toggle clock and generate positive SCL edge:                     USICR = control;                    // Wait for SCL to go high:                    while( !(PIN_USI & (1 << PIN_USI_SCL)) );                    // Leave SCL high for at least 4 us:                    _delay_us( T4_I2C );                    // Toggle clock to generate negative SCL edge:                    USICR = control;                    }while( !(USISR & (1 << USIOIF)) ); // Transfer complete?        // Wait for 1/2 bit time so the clock is low for   // a full bit time:            _delay_us( T2_I2C );            uint8_t data = USIDR;          // Read out data      USIDR = 0xFF;                  // Release SDA            // Switch the SDA back to an output pin:            DDR_USI |= (1 << PIN_USI_SDA);         return data; // Return the data read from the USIDR  } ```    The `I2C_rw()` function is responsible for reading or writing an array of bytes on the USI and transmitting a stop condition at the completion of the transmission or reception:    ``` // Listing11-1.ino (cont.)  //  // I2C_rw-  //  // Read or write a sequence of bytes from or to the I2C port.  // LO bit of buf[0] is 0 for write, 1 for read.    uint8_t I2C_rw( uint8_t *buf, size_t len, uint8_t stop )  {      bool xferOK = false;      uint8_t errorCode = USI_I2C_Xcvr( buf, len );             // If there wasn't an error, see if code is      // supposed to send a stop bit and transmit      // it if you are:               if( errorCode == 0 )      {          if( stop )           {              USI_I2C_Cntlr_Stop();          }          return 0;      // No error      }      return errorCode;  // There was an error  } ```    The “main program” (Arduino `loop()` function) is the code that actually transmits a triangle wave to the (Adafruit or SparkFun) DAC:    ``` // Listing11-1.ino (cont.)  //  // Usual Arduino initialization function.    void setup( void )  {      // Initialize the Atto84 I2C port:            USI_Initialize();  }    // Arduino main loop function:    void loop( void )  {        uint8_t writeBuf[3];            // Transmit the rising edge of the triangle wave:            for( uint16_t dac=0; dac<4096; ++dac )      {          // MCP4725 DAC at address DAC_ADRS (bits 1 to 7).          // Create a write operation:                    writeBuf[0] = (DAC_ADRS << 1) | 0; // Write to DAC          writeBuf[1] = (dac >> 8) & 0xff;   // HO byte          writeBuf[2] = dac & 0xff;          // LO byte          I2C_rw( writeBuf, 3, TRUE );      }            // Transmit the falling edge:            for( uint16_t dac=4095; dac>0; --dac )      {          // MCP4725 DAC at address DAC_ADRS (bits 1 to 7).          // Create a write operation:                    writeBuf[0] = (DAC_ADRS << 1) | 0; // Write to DAC_ADRS           writeBuf[1] = (dac >> 8) & 0xff;   // HO byte          writeBuf[2] = dac & 0xff;          // LO byte          I2C_rw( writeBuf, 3, TRUE );      }  } ```    The code in [Listing 11-1](#listing11-1) is relatively efficient, taking approximately 370 µsec per DAC transmission (3 bytes, about 120 µsec per byte). As the expected speed is about 100 µsec per byte (10 bits at 100 kHz), this is actually better than most of the other examples throughout this book, largely because of the streamlined code used to transmit the data. (Most of the other example programs execute considerable extra code between transmissions due to libraries, multitasking, and so on slowing them down.)    [Figure 11-1](#figure11-1) provides the oscilloscope output for the program in [Listing 11-1](#listing11-1).  ![](image_fi/502468c11/f11001.png)    Figure 11-1: Atto84 I²C triangle wave output      [Figure 11-2](#figure11-2) shows the logic analyzer output for this program. As you can see, there is very little delay between bytes written in a single message and only a short delay between values (3 bytes) written to the MCP4725 DAC (at address 0x62).  ![](image_fi/502468c11/f11002.png)    Figure 11-2: Logic analyzer output from Atto84 triangle wave output program      The program in [Listing 11-1](#listing11-1) is very straightforward; it just uses polling for everything (a typical Arduino paradigm). If you needed to do more than output a triangle wave from the Atto84, you would probably want to take advantage of the USI interrupts to allow other work to happen while waiting for I²C transmissions to take place. I’ll demonstrate that ATtiny84 capability when describing bare-metal peripheral programming on the Atto84 later in this book (see section 16.1, “The ATtiny as an I[2]C Peripheral,” in Chapter 16).    ## 11.3 Chapter Summary    This chapter discussed I²C bus controller programming at the hardware level. Because each MCU provides a different mechanism for I²C communication, no general explanation will work with any MCU. Therefore, this chapter presents a couple of specific examples. In particular, it discusses two separate MCUs (the i.MXRT 1602 MCU used by the Teensy 4.*x*) and the ATtiny84 MCU. Each MCU section begins with a discussion of the appropriate MCU registers needed to control the bus, followed by some sample code to program those registers.    The section on the Teensy 4.*x* used an existing library from Richard Gemmell and Paul Stoffregen as the example code. This library is a drop-in replacement for the standard Arduino Wire library. The section on the ATtiny84 used code based on Adafruit’s open source TinyWireM library. Both examples provided the basics for transmitting and receiving data on the I²C bus.````"]