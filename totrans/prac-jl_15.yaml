- en: '**13'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '**13'
- en: SCIENTIFIC MACHINE LEARNING**
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 科学机器学习**
- en: '*The bewilderments of the eyes are of two kinds, and arise from two causes,
    either from coming out of the light or from going into the light.*'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: '*眼睛的困惑有两种类型，源于两种原因，要么是从光中出来，要么是进入光中。*'
- en: —Socrates
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: —苏格拉底
- en: '![Image](../images/common.jpg)'
  id: totrans-4
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/common.jpg)'
- en: The topic of this chapter is a rather new approach to solving scientific problems
    through computation. Much of the recent development in the field of scientific
    machine learning (SciML) has taken place within the Julia ecosystem and has been
    led by researchers using Julia in science. Relatively little has been published
    explaining how to apply the new techniques in a form digestible by those not conversant
    with machine learning jargon. I hope to fill at least part of that gap here through
    the selection of simple but concrete examples that clarify the concepts involved
    so that readers can apply them to a variety of problems.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的主题是通过计算解决科学问题的一种相对较新的方法。科学机器学习（SciML）领域的许多最新发展发生在Julia生态系统内，由使用Julia进行科学研究的研究人员主导。关于如何将这些新技术应用于非机器学习专家能够理解的形式的解释，公开的资料相对较少。我希望通过选择一些简单但具体的例子来填补这一空白，从而澄清其中的概念，让读者能够将其应用于各种问题。
- en: Scientific machine learning is not machine learning. *Machine learning (ML)*
    is a branch of artificial intelligence in which computers train themselves (usually
    guided by human supervision), by practicing on a large corpus of data, to recognize
    patterns and make classifications. ML techniques are applied to such problems
    as detecting fraudulent financial transactions or trying to guess what movie you
    want to watch next. The training replaces the traditional coding of a specific
    model or algorithm.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 科学机器学习并非传统的机器学习。*机器学习（ML）*是人工智能的一个分支，计算机通过练习大量数据（通常在人类监督下）自我训练，识别模式并进行分类。机器学习技术应用于诸如检测欺诈性金融交易或预测你下一个想看什么电影等问题。训练取代了传统的具体模型或算法编程。
- en: '*SciML* extracts several key techniques from ML and applies them to a different
    class of problem. In SciML, we assume that the system we’re studying is described
    by a particular model, often expressed as a set of differential equations. Certain
    parameters or other aspects of the model, however, are unknown. If we have data
    about how the system behaves, SciML techniques allow us to infer the values of
    these unknown parameters efficiently.'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: '*SciML*从机器学习中提取了几个关键技术，并将其应用于不同类别的问题。在SciML中，我们假设我们研究的系统由一个特定的模型描述，通常以一组微分方程表示。然而，模型中的某些参数或其他方面是未知的。如果我们有关于系统行为的数据，SciML技术可以帮助我们高效地推断这些未知参数的值。'
- en: '**Automatic Differentiation in a Physics Problem**'
  id: totrans-8
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**物理问题中的自动微分**'
- en: Along with concepts from statistics and probability theory, SciML borrows *automatic
    differentiation* from ML. This technique is critical to both ML and SciML. Traditionally,
    differentiation is a mathematical procedure from calculus that finds the slope
    of a curve (in one dimension) or a surface (in two or more dimensions). We call
    a derivative of a surface, which involves dealing with several variables, a *gradient*.
    If your kitchen sink is installed correctly, the negative gradient of its surface
    points toward the drain at every point, so that when you pull the plug all the
    water drains out and you’re not left with any puddles.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 结合统计学和概率论的概念，SciML借用了*自动微分*技术，这一点对于机器学习和科学机器学习都至关重要。传统上，微分是微积分中的一个数学过程，用于找到曲线（在一维中）或曲面（在二维或更多维度中）的斜率。我们称曲面的导数为*梯度*，它涉及处理多个变量。如果你的厨房水槽安装得当，那么其表面的负梯度在每个点都指向排水口，这样当你拔掉塞子时，所有的水都会排出去，不会留下任何水坑。
- en: 'Automatic differentiation is the calculation of a derivative or gradient of
    a function expressed in a programming language, rather than in mathematical notation.
    The programmed function can be the direct translation of a mathematical expression.
    Often, when the expression is complicated, its analytic derivative will involve
    many terms and be expensive to calculate in the traditional way. Automatic differentiation
    can be faster. We can even use automatic differentiation to calculate gradients
    that have no analytic form: the function being differentiated can include nearly
    any computation, including those not expressible in mathematical notation. Automatic
    differentiation is not numerical differentiation; it’s not a finite-difference
    calculation. Neither is it symbolic differentiation, as explored in [Chapter 12](ch12.xhtml).
    It applies knowledge of calculus, such as the chain rule for derivatives, with
    knowledge of the derivatives of specific functions and numerical techniques to
    differentiate efficiently and accurately.'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 自动微分是通过编程语言计算函数的导数或梯度，而不是使用数学符号表示。编写的函数可以是数学表达式的直接翻译。通常，当表达式很复杂时，其解析导数会涉及许多项，并且通过传统方式计算会非常昂贵。自动微分可以更快。我们甚至可以使用自动微分计算没有解析形式的梯度：被微分的函数可以包含几乎任何计算，包括那些无法用数学符号表示的计算。自动微分不是数值微分；它不是有限差分计算。它也不是符号微分，正如在[第
    12 章](ch12.xhtml)中探讨的那样。它应用了微积分知识，如链式法则，以及特定函数的导数和数值技术，从而高效、准确地进行微分。
- en: ML uses automatic differentiation to guide its models in the direction of the
    correct solutions, and it’s used within the SciML machinery in a similar way.
    We can also use it explicitly for efficient calculations of derivatives in mathematical
    models, as shown in “Calculating Forces from Potentials” on [page 408](ch13.xhtml#ch13lev1sec2).
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 机器学习（ML）使用自动微分来引导其模型朝着正确的解的方向发展，并且在 SciML 的机制中以类似的方式使用它。我们还可以显式地使用它来高效地计算数学模型中的导数，正如在[第
    408 页](ch13.xhtml#ch13lev1sec2)的“从势能计算力”一节中所示。
- en: '***Differentiating with ForwardDiff***'
  id: totrans-12
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***使用 ForwardDiff 进行微分***'
- en: 'We can meet our automatic differentiation needs in this chapter with the `derivative()`
    function from the `ForwardDiff` package, which I’ll assume has been imported in
    the following examples. Its use is simple: we supply a function and a value, and
    `ForwardDiff.derivative()` returns the derivative of the function evaluated at
    the supplied value:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在本章中通过`ForwardDiff`包中的`derivative()`函数来满足自动微分的需求，我假设以下示例中已导入该包。其使用方法很简单：我们提供一个函数和一个值，`ForwardDiff.derivative()`将返回在提供的值处求得的该函数的导数：
- en: '[PRE0]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The result is correct: the derivative of sin(*x*) is cos(*x*), and cos(0) =
    1.'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 结果是正确的：sin(*x*) 的导数是 cos(*x*)，而 cos(0) = 1。
- en: 'The `ForwardDiff.derivative()` function can also handle functions defined in
    Julia that may contain almost any type of computation:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '`ForwardDiff.derivative()`函数也可以处理在 Julia 中定义的函数，这些函数可能包含几乎任何类型的计算：'
- en: '[PRE1]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The `floor()` and `ceil()` functions round their arguments to the closest smaller
    or larger whole number. The `fdst()` function defined in the example is not something
    that we can look up in a table of derivatives or handle with the familiar techniques
    of calculus, but Julia’s automatic differentiation routine calculates the derivative
    correctly. [Figure 13-1](ch13.xhtml#ch13fig1) shows the result.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '`floor()`和`ceil()`函数将它们的参数四舍五入到最接近的小或大的整数。示例中定义的`fdst()`函数不是我们能在导数表中查找的，也不能使用微积分的常规方法来处理，但
    Julia 的自动微分例程能够正确地计算其导数。[图 13-1](ch13.xhtml#ch13fig1)展示了结果。'
- en: '![Image](../images/ch13fig01.jpg)'
  id: totrans-19
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/ch13fig01.jpg)'
- en: '*Figure 13-1: Automatic differentiation of a strange function*'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 13-1：一个奇怪函数的自动微分*'
- en: In [Figure 13-1](ch13.xhtml#ch13fig1), the legend uses a prime to indicate a
    derivative. The dashed line shows the result of the automatic differentiation
    function, which is not troubled by the existence of discontinuities.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在[图 13-1](ch13.xhtml#ch13fig1)中，图例使用了一个撇号来表示导数。虚线表示自动微分函数的结果，它不受不连续点存在的困扰。
- en: '***Calculating Forces from Potentials***'
  id: totrans-22
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***从势能计算力***'
- en: In physics, the force on a body is the negative gradient of its potential energy.
    If the potential energy depends on only one variable, this is simply the negative
    of its derivative with respect to that variable. Let’s revisit the finite-angle
    pendulum problem from [Chapter 9](ch09.xhtml).
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 13-1](ch13.xhtml#ch13lis1) recapitulates the problem in one place
    for convenience.'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '*Listing 13-1: Revisiting the finite-angle pendulum*'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 13-1](ch13.xhtml#ch13lis1) contains something extra, however: the
    `ppot()` function, which gives the gravitational potential energy of the pendulum
    as a function of height ➊. The `pendulum!()` function now sets up the problem
    using automatic differentiation to calculate the (negative) derivative of the
    potential ➋ to derive the force, rather than using the force function directly.
    A second function, `pendulumF!()`, sets up the problem as before, using the force
    function. We proceed just as we did in [Chapter 9](ch09.xhtml), but we find two
    numerical solutions: once using the potential ➌ and again using the force.'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 13-2](ch13.xhtml#ch13fig2) compares the two methods of solution.'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/ch13fig02.jpg)'
  id: totrans-29
  prefs: []
  type: TYPE_IMG
- en: '*Figure 13-2: The finite-angle pendulum computed two ways*'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
- en: The two solutions agree exactly. Clearly it wasn’t necessary to reach for the
    `ForwardDiff` package to handle this problem, but we did so to verify that it
    works as expected. When applying a new technique, it’s essential to test it on
    a relatively simple problem with a known solution first, to gain confidence in
    our understanding of how to use it, and to confirm that we understand how it works.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
- en: Physicists usually think in terms of potentials rather than forces, so when
    conducting numerical experiments, we’re more likely to try different potentials
    rather than tweak the force function directly. Having a solution program that
    differentiates the potential for us is more convenient than deriving a new force
    field at each iteration. Also, the potential functions we work with have a simpler
    form than the force functions derived from them. This is the case in the next
    example.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
- en: Imagine that we’ve discovered a new particle with a potential that is strongly
    repulsive at short range, has a well at a particular distance, and is weakly repulsive
    at longer ranges. The potential
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/409math.jpg)'
  id: totrans-34
  prefs: []
  type: TYPE_IMG
- en: where *r* is the distance from the particle, has these properties, as shown
    in [Figure 13-3](ch13.xhtml#ch13fig3).
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/ch13fig03.jpg)'
  id: totrans-36
  prefs: []
  type: TYPE_IMG
- en: '*Figure 13-3: The potential of an imaginary particle*'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 13-3](ch13.xhtml#ch13fig3) shows the potential well at *r* ≈ 1.3\.
    This is a location at which an interacting particle can be trapped if it lacks
    the energy to escape.'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
- en: The system will contain two of these particles, fixed at *r* = 0 and *r* = 20\.
    We’ll place a moving particle between them, and use units where its mass is 1\.
    [Figure 13-4](ch13.xhtml#ch13fig4) shows the combined potential of the two fixed
    particles.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/ch13fig04.jpg)'
  id: totrans-40
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/ch13fig04.jpg)'
- en: '*Figure 13-4: The total potential of two imaginary particles*'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 13-4：两个虚拟粒子的总势能*'
- en: We’ll insert the moving particle into the system at *r* = 5*.*0, with an initial
    velocity of 0.2035\. This positive velocity starts the particle moving to the
    right at *t* = 0\. With a zero initial velocity, it would oscillate within the
    shallow well centered on *x* = 10, between *x* = 5 and *x* = 15\. Its particular
    initial velocity gives the particle barely enough energy to surmount the potential
    hill near *x* = 16.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在系统中插入一个移动粒子，位置为*r* = 5*.*0，初速度为0.2035\。这个正向速度使得粒子在*t* = 0时开始向右运动。如果初速度为零，它将在以*x*
    = 10为中心的浅势阱中振荡，范围在*x* = 5和*x* = 15之间。其特定的初速度刚好提供足够的能量让粒子克服位于*x* = 16附近的势能山丘。
- en: In [Listing 13-2](ch13.xhtml#ch13lis2), we proceed as in the revisited pendulum
    problem in [Listing 13-1](ch13.xhtml#ch13lis1).
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在[清单 13-2](ch13.xhtml#ch13lis2)中，我们按照在[清单 13-1](ch13.xhtml#ch13lis1)中重新审视的摆问题的方法进行处理。
- en: '[PRE3]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '*Listing 13-2: Solving for the motion between two imaginary particles*'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 13-2：求解两个虚拟粒子之间的运动*'
- en: We derive the forces by applying automatic differentiation to the potential
    function, which is the sum of the two contributions from the two fixed particles
    ➊, evaluating the derivatives at the distance from each particle. The `p` array
    holds the positions of these two particles ➋, and the `u0` array contains the
    initial position and initial velocity of the moving particle ➌. After establishing
    a time span for the solution, we define the ordinary differential equation (ODE)
    problem and store its solution in `sol` as before.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过对势能函数应用自动微分来推导力，这个势能函数是两个固定粒子贡献的总和 ➊，我们在每个粒子的位置上评估导数。`p`数组保存这两个粒子的位置 ➋，`u0`数组包含移动粒子的初始位置和初速度
    ➌。在确定了解决方案的时间跨度后，我们定义了常微分方程（ODE）问题，并像之前一样将其解保存在`sol`中。
- en: A first attempt at a solution is shown in [Figure 13-5](ch13.xhtml#ch13fig5),
    which shows the position of the moving particle as a function of time.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 第一次尝试的解如[图 13-5](ch13.xhtml#ch13fig5)所示，展示了移动粒子的位置与时间的关系。
- en: '![Image](../images/ch13fig05.jpg)'
  id: totrans-48
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/ch13fig05.jpg)'
- en: '*Figure 13-5: An inaccurate solution*'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 13-5：一个不准确的解*'
- en: We extract the position variable from the solution as explained in [Chapter
    9](ch09.xhtml).
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 我们按照[第 9 章](ch09.xhtml)中解释的方法，从解中提取位置变量。
- en: Scientists should always cast a critical eye over purported numerical solutions
    to differential equations. Our first instinct should be to examine the output
    of the solver in light of everything we know about how the solution should behave.
    In this case, we know that the solution should be periodic, as nothing in the
    definition of the problem can add or remove energy. The result in [Figure 13-5](ch13.xhtml#ch13fig5)
    is clearly not accurately periodic.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 科学家应始终对所谓的数值解进行批判性审视。我们的第一反应应该是根据我们对问题行为的了解，检查求解器的输出。在这种情况下，我们知道解应该是周期性的，因为问题的定义中没有任何因素能增加或移除能量。[图
    13-5](ch13.xhtml#ch13fig5)中的结果显然不是准确的周期性。
- en: The `DifferentialEquations` package provides many options for solution methods
    and exposes several parameters for tweaking the behavior of the solvers. See “Further
    Reading” on [page 427](ch13.xhtml#fur13) for a link to the relevant part of the
    documentation. As the differential equation set up in [Listing 13-2](ch13.xhtml#ch13lis2)
    is not of a difficult type, we can probably stick with the default solver. The
    accuracy issue is most likely caused by the nature of the potential and the initial
    velocity, which, as mentioned, is near a critical value that determines whether
    the particle will surmount a local potential maximum. This suggests that simply
    applying an error bound may be sufficient. The `reltol` parameter, supplied as
    a keyword argument to `solve()`, adjusts the adaptive timestepping as needed to
    limit the local error to the value that we supply, as described in “Parametric
    Instability” on [page 300](ch09.xhtml#ch09lev1sec19). Its default is 0.001, which
    is probably not stringent enough for this problem. Smaller changes in the initial
    velocity have a large effect on the particle’s motion. If we try again using `sol
    = solve(prob; reltol=1e-6)`, we get the solution shown in [Figure 13-6](ch13.xhtml#ch13fig6).
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '`DifferentialEquations`包提供了许多解法选项，并暴露了多个参数以便调整求解器的行为。请参见[第427页](ch13.xhtml#fur13)中的“进一步阅读”部分，了解文档相关部分的链接。由于在[清单13-2](ch13.xhtml#ch13lis2)中设置的微分方程并不复杂，我们可以继续使用默认的求解器。准确性问题很可能是由于势能和初始速度的性质所致，正如前面提到的，初始速度接近一个临界值，这个临界值决定了粒子是否能克服局部势能的最大值。这表明，仅仅应用误差界限可能就足够了。`reltol`参数作为关键字参数传递给`solve()`函数，用于根据需要调整自适应时间步长，以将局部误差限制在我们指定的值内，如[第300页](ch09.xhtml#ch09lev1sec19)中“参数不稳定性”部分所述。其默认值为0.001，这对于此问题来说可能不够严格。初始速度的微小变化对粒子的运动有很大影响。如果我们尝试使用`sol
    = solve(prob; reltol=1e-6)`重新计算，我们将得到[图13-6](ch13.xhtml#ch13fig6)中所示的解。'
- en: '![Image](../images/ch13fig06.jpg)'
  id: totrans-53
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/ch13fig06.jpg)'
- en: '*Figure 13-6: An accurate solution*'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '*图13-6：一个精确的解*'
- en: The new solution appears to be accurately periodic. Furthermore, reducing `reltol`
    further doesn’t change the solution, which supplies some reassurance that it’s
    converged to the right answer.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 新的解似乎是准确的周期性解。此外，进一步减小`reltol`并不会改变解，这为我们提供了一些安慰，证明解已经收敛到正确的答案。
- en: The derivative of U happens to be
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: U的导数恰好是
- en: '![Image](../images/413math.jpg)'
  id: totrans-57
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/413math.jpg)'
- en: which would be somewhat more annoying to work with directly.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 直接处理起来可能会更麻烦一些。
- en: '**Probabilistic Programming**'
  id: totrans-59
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**概率编程**'
- en: This section introduces the `Turing` package through several examples. This
    package allows us to infer likely causes given observed effects. We’ll assume
    some comfort with several of the ideas discussed in [Chapter 10](ch10.xhtml)—in
    particular, probability and probability distributions. We’ll need to be familiar
    with these ideas to understand the output from `Turing` and to interpret its results.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 本节通过多个示例介绍了`Turing`包。这个包可以帮助我们根据观察到的效果推断可能的原因。我们假设读者已经对[第10章](ch10.xhtml)中讨论的几个概念有一定的了解——特别是概率和概率分布。理解这些概念对于理解`Turing`的输出和解释其结果是必要的。
- en: '***Testing for Fairness of a Coin***'
  id: totrans-61
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***硬币公正性测试***'
- en: This simple example introduces the basic concepts and procedures for using `Turing`
    in probabilistic programming.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 这个简单的例子介绍了使用`Turing`进行概率编程的基本概念和程序。
- en: 'Suppose we flip a coin *L* number of times and observe that we get a total
    of *Nheads* heads. We want to assess whether what we observed shows that the coin
    is *fair* or not, where *fair* means that the probability of coming up heads is
    1/2, or very close to it. This is the type of question that probabilistic programming
    claims to be able to answer: given an effect, or a set of observations, what was
    the cause? Here the effect is the proportion of heads, and the cause is the probability
    of heads.'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们抛一枚硬币*L*次，并观察到得到*Nheads*次正面。我们想评估我们观察到的结果是否表明这枚硬币是*公平的*，其中*公平*意味着正面朝上的概率是1/2，或者非常接近1/2。这正是概率编程所声称能够回答的类型的问题：给定一个效果或一组观察结果，原因是什么？在这里，效果是正面朝上的比例，原因是正面朝上的概率。
- en: '**NOTE**'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*I’m cognizant that the foregoing brief analysis may not please everyone, but
    wish to avoid becoming mired in metaphysics. The actual causes of our observations
    will be the physical details of the coin’s construction and the method of tossing.
    The probability of heads represents a summary of the cumulative effect of this
    myriad of unknown details; the description of cause as a probability reflects
    our incomplete knowledge.*'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '*我意识到前述简短分析可能并不令所有人满意，但我希望避免陷入形而上学的讨论。我们观察到的实际原因将是硬币的物理构造细节和投掷方法。正面朝上的概率代表了这些无数未知细节的累积效应的总结；将原因描述为概率反映了我们知识的局限性。*'
- en: The first step in using `Turing` is to construct a probabilistic model describing
    the probability distributions of each of the random variables in the problem.
    For some variables, these distributions are unknown, in which case we need to
    assume something reasonable, such as a uniform or normal distribution that includes
    all possible values, perhaps centered on the value that we think is most likely.
    For others, the description of the problem implies a particular distribution,
    one that is usually parameterized by observations or the values of some of the
    other variables.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`Turing`的第一步是构建一个概率模型，描述问题中每个随机变量的概率分布。对于某些变量，这些分布是未知的，在这种情况下，我们需要假设一个合理的分布，如均匀分布或正态分布，涵盖所有可能的值，可能以我们认为最可能的值为中心。对于其他变量，问题的描述暗示了一种特定的分布，这种分布通常由观察结果或某些其他变量的值来参数化。
- en: In this example we have one unknown random variable, *Pheads*. We’ll assume
    that it can have any value from 0 to 1, uniformly distributed. This assumption
    means that we don’t have any a priori belief about the nature of the coin. If
    we had reason to think that it was almost certainly fair, we could instead assert
    that it was normally distributed with a mean of 1/2 and a small variance.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们有一个未知的随机变量，*Pheads*。我们假设它可以取0到1之间的任何值，且服从均匀分布。这个假设意味着我们对硬币的性质没有任何先验信念。如果我们有理由认为它几乎肯定是公平的，我们可以假设它服从均值为1/2、方差较小的正态分布。
- en: In `Turing` models, we represent assertions about the distributions of random
    variables using the `~` operator. Our assumption about the distribution of the
    probability of heads takes the form `Pheads ~ Uniform(0, 1)`. The `Uniform()`
    function comes from `Distributions.jl`, which `Turing` automatically imports (see
    “Distributions” on [page 321](ch10.xhtml#ch10lev7)).
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在`Turing`模型中，我们使用`~`操作符表示关于随机变量分布的假设。我们对正面朝上的概率分布的假设形式为`Pheads ~ Uniform(0,
    1)`。`Uniform()`函数来自`Distributions.jl`，该包会自动被`Turing`导入（有关“Distributions”的详细信息，请参见[第321页](ch10.xhtml#ch10lev7)）。
- en: '[Listing 13-3](ch13.xhtml#ch13lis3) shows the complete `Turing` model.'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表13-3](ch13.xhtml#ch13lis3)展示了完整的`Turing`模型。'
- en: '[PRE4]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '*Listing 13-3: A simple probabilistic program*'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表13-3：一个简单的概率程序*'
- en: After importing `Turing` and `StatsPlots`, which will be useful for visualizing
    the output, we use the `@model` macro from `Turing` to define the model. We can
    call the function that `@model` acts on anything we want; the macro understands
    the `~` operator and transforms the function into a `Turing` model.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在导入`Turing`和`StatsPlots`（它们对可视化输出非常有用）之后，我们使用`Turing`中的`@model`宏来定义模型。我们可以对`@model`所作用的函数进行任何我们想要的调用；该宏理解`~`操作符，并将该函数转换为`Turing`模型。
- en: The inputs are the observed number of heads and `L`, the total number of flips.
    As mentioned, we assume a uniform distribution for `Pheads`, the quantity that
    we’re trying to infer. The number of heads observed when we flip a coin `L` times
    is a random variable that we know has a binomial distribution parametrized by
    `L` and `Pheads` ➊ (see “Further Reading” on [page 427](ch13.xhtml#fur13) for
    a link to a brief introduction).
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 输入是观察到的正面朝上的次数和`L`，即总共的投掷次数。如前所述，我们假设`Pheads`（我们要推断的量）服从均匀分布。当我们投掷硬币`L`次时，观察到的正面朝上的次数是一个随机变量，我们知道它遵循由`L`和`Pheads`
    ➊ 参数化的二项分布（有关简要介绍，请参见[第427页](ch13.xhtml#fur13)中的“进一步阅读”）。
- en: To understand, in outline, how `Turing` carries out its inductive process to
    infer the unknowns in the model (`Pheads` in this case) from the observations,
    we’ll imagine how we might do it manually. For the simple problem here, we might
    choose a series of `Pheads` values from 0 to 1, either deterministically or randomly,
    perhaps using `rand()`. For each of these values for `Pheads`, we can calculate
    the expectation value, or mean, of `Nheads` from its binomial distribution. The
    expectation value closest to the observed value of `Nheads` is our inferred value
    for `Pheads`.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 为了大致理解`Turing`如何通过归纳过程从观测值推断模型中的未知数（在本例中是`Pheads`），我们可以设想如何手动进行这一过程。对于这里的简单问题，我们可以从0到1选择一系列`Pheads`值，可以是确定性的，也可以是随机的，可能会使用`rand()`。对于每个`Pheads`值，我们可以计算其二项分布的期望值或均值。最接近观测值`Nheads`的期望值就是我们推断出的`Pheads`值。
- en: This inference procedure would be fairly efficient because we have a simple
    formula for the mean of the binomial distribution. If we were dealing with less
    tractable distributions, including ones depending on many parameters, each with
    its own distribution, the only way to extract the expectation value would be through
    the numerical experiment of sampling from the distribution. As pointed out in
    “Random Numbers in Julia” on [page 307](ch10.xhtml#ch10lev2), the `rand()` function
    allows us to sample directly from a distribution. However, as we’ll see soon,
    a more realistic problem may include thousands of random variables and thousands
    of distributions. Naive sampling from each of them would take a prohibitively
    long time.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 这个推断过程会相当高效，因为我们有一个简单的公式可以计算二项分布的均值。如果我们处理的是不太容易求解的分布，包括那些依赖于多个参数、每个参数有自己分布的情况，那么提取期望值的唯一方法就是通过从分布中采样的数值实验。如《Julia中的随机数》一文中在[第307页](ch10.xhtml#ch10lev2)所指出的，`rand()`函数允许我们直接从分布中采样。然而，正如我们很快会看到的，一个更现实的问题可能涉及成千上万的随机变量和分布。从每个分布中进行简单采样将花费极其漫长的时间。
- en: This is the problem that `Turing` solves. It allows us to do no more than tell
    it what the probability distributions are, then it samples from them efficiently,
    calculates expectation values as needed, and reports the results and their uncertainties
    and error estimates. We won’t go into the details of how `Turing` accomplishes
    this feat, except to say that it implements the technology of Markov chain Monte
    Carlo (MCMC) sampling, a starting point for readers who are interested in investigating
    the theoretical background.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是`Turing`所解决的问题。它允许我们只需告诉它概率分布是什么，然后它高效地从中采样，根据需要计算期望值，并报告结果以及它们的不确定性和误差估计。我们不会深入探讨`Turing`是如何实现这一壮举的，只是提到它实现了马尔可夫链蒙特卡洛（MCMC）采样技术，想要研究理论背景的读者可以以此为起点。
- en: 'To tell `Turing` to generate a report about its inferences, we issue one command
    using its `sample()` function:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让`Turing`生成关于其推断的报告，我们可以使用它的`sample()`函数发出一个命令：
- en: '[PRE5]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Here `coin()` is the model function from [Listing 13-3](ch13.xhtml#ch13lis3).
    Its arguments are the number of heads and the total number of flips—in this case
    60 heads out of 100 coin tosses. The next argument selects a sampling strategy
    from among the handful supplied by the `Turing` package. The initials `SMC` stand
    for sequential Monte Carlo, which performs well on simple problems. The choice
    of sampler can be a matter of trial and error; different samplers are best suited
    to different problems. (See “Further Reading” on [page 427](ch13.xhtml#fur13)
    for links to some documentation for `Turing`’s samplers.) The final argument,
    `1000`, is the number of sampling experiments to conduct. Each one produces an
    estimate for `Pheads`, and `Turing` reports the mean of these estimates, which
    is its most likely value, as shown in [Listing 13-4](ch13.xhtml#ch13lis4).
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的`coin()`是[清单13-3](ch13.xhtml#ch13lis3)中的模型函数。它的参数包括正面朝上的次数和投掷的总次数——在这个例子中是100次投掷中的60次正面朝上。下一个参数从`Turing`包中提供的几种采样策略中选择一个。`SMC`的首字母代表顺序蒙特卡洛（Sequential
    Monte Carlo），它在简单问题上表现良好。选择哪种采样器可能需要通过反复试验来决定；不同的采样器适用于不同的问题。（有关`Turing`采样器文档的链接，请参见[第427页](ch13.xhtml#fur13)的“进一步阅读”。）最后一个参数`1000`是进行采样实验的次数。每次实验都会生成一个`Pheads`的估计值，而`Turing`会报告这些估计值的均值，即最可能的值，如[清单13-4](ch13.xhtml#ch13lis4)所示。
- en: '[PRE6]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '*Listing 13-4: The report from* Turing'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单13-4：来自* Turing的报告'
- en: 'The report, which appears after 12.73 seconds on my laptop, contains a lot
    of information, but only a few numbers are essential for us. Under `Summary Statistics`,
    the `Symbol`s are the random variables whose inferred values we want: in this
    case, only `Pheads`. The best guess that `Turing` has for `Pheads` is 0.6024\.
    Another number to keep an eye on is `rhat`, which is 1.0002 in this example. If
    this number is far from 1.0, the sampling process did not converge properly, and
    we need to try a different sampler or alter the controls passed to the sampler,
    if it’s one that accepts parameters.'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 该报告在我笔记本电脑上经过12.73秒后生成，包含了大量信息，但只有少数几个数字对我们至关重要。在`Summary Statistics`下，`Symbol`是我们想要推断值的随机变量：在这个例子中，只有`Pheads`。`Turing`对`Pheads`的最佳猜测是0.6024。另一个需要注意的数字是`rhat`，在这个例子中为1.0002。如果这个数字远离1.0，则抽样过程未能正确收敛，我们需要尝试不同的抽样器或更改传递给抽样器的控制参数（如果抽样器接受参数的话）。
- en: 'Now we can think about addressing the question implied in the title of this
    section: is the coin fair? We can gain some insight by looking at the distribution
    of the 1,000 inferences for `Pheads` resulting from the sampling procedure. The
    `histogram()` function (see “Distributions” on [page 321](ch10.xhtml#ch10lev7))
    gains the power to plot this with a simple call to `histogram(flips; normalize=true)`
    courtesy of the `Turing` and `StatsPlots` packages. We’ll plot the histogram with
    a normal distribution curve on the same graph with the following:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以考虑解决本节标题中暗示的问题：硬币是否公平？我们可以通过查看从抽样过程中得出的1,000个`Pheads`推断值的分布来获得一些见解。`histogram()`函数（请参见[第321页](ch10.xhtml#ch10lev7)的“分布”）通过简单调用`histogram(flips;
    normalize=true)`，借助`Turing`和`StatsPlots`包，获得了绘制此分布的能力。我们将在同一图表上绘制直方图，并叠加一个正态分布曲线，使用如下代码：
- en: '[PRE7]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The parameters in the normal distribution, plotted in the second line, are the
    mean and standard deviation taken from the report in [Listing 13-4](ch13.xhtml#ch13lis4).
    [Figure 13-7](ch13.xhtml#ch13fig7) shows the result, where we can see that the
    sampling distribution from `Turing` is quite a good approximation to the normal
    distribution with the parameters that it reports.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 正态分布中的参数，如第二行所示，是从[列表 13-4](ch13.xhtml#ch13lis4)中的报告中提取的均值和标准差。[图 13-7](ch13.xhtml#ch13fig7)展示了结果，我们可以看到，从`Turing`获得的抽样分布是对正态分布的良好近似，并且与其报告的参数相符。
- en: '![Image](../images/ch13fig07.jpg)'
  id: totrans-86
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/ch13fig07.jpg)'
- en: '*Figure 13-7: The distribution of inferences for* Pheads'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 13-7：Pheads推断的分布*'
- en: Why should the distribution of the mean values of `Pheads` be normal? After
    all, we set `Pheads` up with a uniform distribution in the model. The answer is
    that the distribution in [Figure 13-7](ch13.xhtml#ch13fig7) is the distribution
    of *mean values* of the random variable `Pheads`. As demonstrated in “The Normal
    Distribution” on [page 323](ch10.xhtml#ch10lev1sec3) (using the same uniform distribution),
    the distribution of the means will be normal (Gaussian). This will be true regardless
    of the underlying distribution of the variable itself, which is an important theorem
    in probability theory and the fundamental reason for the ubiquity of the normal
    distribution.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么`Pheads`的均值分布应该是正态分布？毕竟，我们在模型中将`Pheads`设置为均匀分布。答案是，[图 13-7](ch13.xhtml#ch13fig7)中的分布是随机变量`Pheads`的*均值*分布。正如在[第323页](ch10.xhtml#ch10lev1sec3)的“正态分布”中所展示的（使用相同的均匀分布），均值的分布将是正态分布（高斯分布）。无论变量本身的底层分布是什么，这都成立，这是概率论中的一个重要定理，也是正态分布普遍存在的根本原因。
- en: 'We can apply any criterion we choose to decide whether this coin is fair after
    examining the sampling results. Although the most likely value for the probability
    of heads is very close to 0.6, strongly suggesting that we have a biased coin,
    it’s *possible* that the coin is fair. We can estimate the probability that `Pheads`
    is 1/2 directly from the normalized histogram. The two bars surrounding 0.5 on
    the horizontal axis have an area of about (0.52 - 0.48) × 0.8 = 0.32, yielding
    a probability of 3.2 percent that the coin is fair. The value of 0.8 comes from
    visually estimating the average height of the two relevant bins. We can also calculate
    this from the normal distribution:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在检查了抽样结果之后，我们可以应用任何标准来决定硬币是否公平。尽管硬币正面朝上的概率最可能值非常接近0.6，这强烈暗示我们有一枚偏的硬币，但*也有可能*这枚硬币是公平的。我们可以直接从归一化的直方图中估算`Pheads`为1/2的概率。横轴上围绕0.5的两个条形的面积大约是(0.52
    - 0.48) × 0.8 = 0.32，这意味着硬币公平的概率为3.2%。0.8的值是通过目测估计这两个相关区间的平均高度得到的。我们还可以从正态分布中计算出这一点：
- en: '[PRE8]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The `cdf()` function, which stands for *cumulative density function*, returns
    the integral of the distribution supplied in the first argument from negative
    infinity to the value supplied in the second argument. Therefore, to extract the
    probability that a random variable governed by the distribution lies between two
    values, we need merely to subtract the results from two calls to `cdf()`. The
    value of 3.3 percent agrees pretty well with our estimate for the same interval
    from the histogram.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '`cdf()`函数，表示*累积分布函数*，返回从负无穷大到第二个参数指定值的第一个参数所提供分布的积分。因此，要提取一个随机变量在分布控制下位于两个值之间的概率，我们只需从两次调用`cdf()`的结果中相减即可。3.3%的值与我们从直方图中得到的同一区间的估计结果非常一致。'
- en: This coin has only a 3.3 percent chance of being fair. Is that strong enough
    evidence to convict it of bias? That’s up to us.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 这枚硬币公平的概率只有3.3%。这是否足够强的证据来证明它存在偏差？那由我们来决定。
- en: Flipping the coin 100 times provides pretty strong evidence of its shady character.
    Intuitively, we understand that if we had flipped it only 10 times, and happened
    to observe six heads, that wouldn’t be strong evidence of any non-fairness in
    the coin. Similarly, an observation of 600 heads after tossing the coin 1,000
    times would be pretty conclusive.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 将硬币投掷100次为它的不公平特性提供了相当强的证据。直观上我们理解，如果我们只投掷了10次，并且恰好观察到6次正面朝上，那并不足以作为硬币不公平的有力证据。同样，若在投掷1,000次硬币后观察到600次正面朝上，那就是一个相当具有说服力的结论。
- en: 'We can see the results of these two scenarios by calling `sample()` twice and
    passing the result directly to `histogram()`:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过调用`sample()`两次，并将结果直接传递给`histogram()`来查看这两种情况的结果：
- en: '[PRE9]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: This is a quick way to compare the distributions when we’re not interested in
    the detailed report.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个快速比较分布的方法，当我们不关心详细报告时，可以使用这个方法。
- en: '**NOTE**'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*Because the results returned by* sample() *are generated partly through random
    sampling, the details will be different every time. Everyone running the code
    samples in this section will observe slightly different distributions and means,
    although the over-all conclusions should be invariant. In an important problem,
    a good practice would be to run more than one sampling experiment, try different
    samplers, and perhaps vary some of the details in the model concerning assumed
    distributions.*'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '*因为* sample() *返回的结果部分通过随机采样生成，所以每次的细节都会有所不同。运行本节代码的每个人都将观察到略有不同的分布和均值，尽管总体结论应该保持不变。在一个重要的问题中，一个好的做法是进行多次采样实验，尝试不同的采样器，并可能在模型中某些关于假设分布的细节上做些许变化。*'
- en: '[Figure 13-8](ch13.xhtml#ch13fig8) shows the result.'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 13-8](ch13.xhtml#ch13fig8)展示了结果。'
- en: '![Image](../images/ch13fig08.jpg)'
  id: totrans-100
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/ch13fig08.jpg)'
- en: '*Figure 13-8: Weak and strong evidence*'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 13-8：弱证据与强证据*'
- en: 'The lighter histogram, showing the inferences from 10 flips, clearly indicates
    that we have no evidence for bias in the coin. It’s about as likely that `Pheads`
    is 1/2 as it is 6/10\. However, the observation using 1,000 flips is unambiguous:
    600 heads in that experiment makes it nearly impossible for the coin to be fair.
    The darker gray overlay of the second histogram shows a narrow distribution around
    `Pheads` = 0.6.'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 更浅的直方图，显示了10次投掷的推断结果，明显表明我们没有证据表明硬币存在偏差。`Pheads`为1/2的可能性和为6/10的可能性几乎相等。然而，使用1,000次投掷的观察结果则没有歧义：在那次实验中，600次正面朝上使得硬币公平的可能性几乎为零。第二个直方图上较深的灰色覆盖层显示了围绕`Pheads`
    = 0.6的窄分布。
- en: '***Inferring Model Parameters from Series Observations***'
  id: totrans-103
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***从系列观察推断模型参数***'
- en: In most applications of probabilistic programming, scientists are interested
    in inferring the causes of a series of observations taken over time, rather than
    merely a single number. We can extend the approach in the previous section to
    handle time series by considering the data gathered at each point in time to be
    a separate measurement with a distribution around some predicted value. The values
    can be predictions from nearly any type of model, as long as we can express it
    as a Julia function.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数概率编程的应用中，科学家们关注的是推断一系列随时间变化的观察结果背后的原因，而不仅仅是一个单一的数字。我们可以通过将前一部分的方法扩展到处理时间序列，将每个时刻收集的数据视为围绕某个预测值的独立测量，并考虑每个时刻的分布。只要我们能够将其表达为Julia函数，这些值可以是几乎任何类型模型的预测结果。
- en: '**A Simple Mathematical Model**'
  id: totrans-105
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**一个简单的数学模型**'
- en: To demonstrate the approach, we’ll first consider the problem of fitting a pair
    of parameters in a simple expression that we assume to be the cause of a series
    of observations. The model is a sine function and the two unknown parameters are
    its amplitude `A` and its frequency `f`, as shown in [Listing 13-5](ch13.xhtml#ch13lis5).
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 为了展示这种方法，我们首先考虑拟合一对参数的问题，这一参数对我们假设为一系列观测的原因。模型是一个正弦函数，两个未知参数分别是其振幅 `A` 和频率 `f`，如[Listing
    13-5](ch13.xhtml#ch13lis5)所示。
- en: '[PRE10]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '*Listing 13-5: The sine function with unknown frequency and amplitude as a
    model*'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '*Listing 13-5：作为模型的未知频率和振幅的正弦函数*'
- en: After defining a series of times, we pick values for the `A` (amplitude) and
    `f` (frequency) parameters. We use these to generate some simulated observations,
    containing normally distributed errors, that we store in `data`. Our plan is to
    pretend we don’t know the values of `A` and `f` and to use the data, along with
    the assumed sinewave dependence, to infer their values.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在定义一系列时间后，我们为 `A`（振幅）和 `f`（频率）参数选择值。我们使用这些值生成一些包含正态分布误差的模拟观测数据，并将其存储在 `data`
    中。我们的计划是假装我们不知道 `A` 和 `f` 的值，并使用数据以及假设的正弦波依赖关系来推断它们的值。
- en: In the model, we assert a priori uniform distributions for the frequency and
    amplitude that establish limits for their possible values. For each possible set
    of values, we have a prediction ➊ for the time series that would result. We consider
    the data passed to the model to be a set of physical measurements, so we assume
    that the observation at each time is normally distributed around the “true” (predicted)
    value at that time, with a standard deviation of 0.5 ➋.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在模型中，我们预先假设频率和振幅的分布是均匀的，这些分布为它们的可能值设定了限制。对于每一组可能的值，我们有一个预测 ➊，即由此得到的时间序列。我们认为传递给模型的数据是一组物理测量值，因此我们假设每个时间点的观测值是围绕该时刻的“真实”（预测）值正态分布的，标准差为
    0.5 ➋。
- en: The inference through sampling proceeds as in the previous section. However,
    the `SMC` sampler seems to work poorly for this class of problems. The `MH` sampler
    (for Metropolis-Hastings) works far more reliably, and it’s quite fast as well,
    but is a poor performer in other problems. (As mentioned earlier, we may need
    to experiment with a variety of sampling algorithms and their input parameters.)
    [Listing 13-6](ch13.xhtml#ch13lis6) shows the sampling command and its truncated
    output.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 通过采样进行推断的过程与前一节相同。然而，`SMC` 采样器似乎在这一类问题上效果不佳。`MH` 采样器（即梅特罗波利斯-海斯廷斯采样器）在此类问题上表现得更加可靠，而且速度也相当快，但在其他问题中表现较差。（如前所述，我们可能需要尝试多种采样算法及其输入参数。）[Listing
    13-6](ch13.xhtml#ch13lis6)显示了采样命令及其截断输出。
- en: '[PRE11]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '*Listing 13-6: Inferring the values of parameters*'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '*Listing 13-6：推断参数值*'
- en: The sampler returns reasonable results in less than one second. This is impressive,
    considering that the algorithm is sampling two parameters 1,000 times and using
    200 data points, each with its own distribution, to infer the final distributions
    of `A` and `f` and their expectation values.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 采样器在不到一秒的时间内返回了合理的结果。这一点令人印象深刻，因为算法在采样两个参数 1,000 次并使用 200 个数据点（每个数据点都有其自身的分布）时，能够推断出
    `A` 和 `f` 的最终分布及其期望值。
- en: 'Let’s visualize the inferred solution using the returned means of `A` and `f`
    superimposed on the simulated data and what we know is the true solution:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过将返回的 `A` 和 `f` 的均值与模拟数据以及我们知道的真实解进行叠加，来可视化推断出的解：
- en: '[PRE12]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: In the first two lines, we plot the model with a thick line and the noisy data
    with a thinner line. The final plot command plots a sinewave using the inferences
    for `A` and `f` as a dotted line. [Figure 13-9](ch13.xhtml#ch13fig9) shows the
    combined plot.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在前两行中，我们用粗线绘制了模型，细线绘制了带噪声的数据。最后的绘图命令使用 `A` 和 `f` 的推断值绘制了一个正弦波，线条为虚线。[Figure
    13-9](ch13.xhtml#ch13fig9) 显示了合并后的图表。
- en: '![Image](../images/ch13fig09.jpg)'
  id: totrans-118
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/ch13fig09.jpg)'
- en: '*Figure 13-9: Model parameters recovered from noisy data*'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '*Figure 13-9：从带噪声的数据中恢复的模型参数*'
- en: '[Figure 13-9](ch13.xhtml#ch13fig9) shows how the correct signal was recovered
    from the noisy observations. The periodic nature of the model means that the slight
    error in the inferred frequency will cause the curves to diverge further at later
    times.'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '[Figure 13-9](ch13.xhtml#ch13fig9) 显示了如何从噪声观测中恢复正确的信号。模型的周期性特征意味着，推断的频率中的微小误差会导致曲线在后续时间进一步发散。'
- en: '**An ODE Model**'
  id: totrans-121
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**常微分方程模型**'
- en: The model used for generating the prediction need not be a known function; it
    can be a set of differential equations. This is possible because `Turing` and
    `DifferentialEquations` are composable, another benefit of Julia’s type system.
    The combination is immensely powerful, and opens up new arenas for research. In
    science our models often take the form of differential equations that encode,
    in general terms, our hypotheses about how the system works. Some of the details
    of the system may remain as parameters with unknown, or partially known, values.
    Probabilistic programming, using the general procedure outlined in “Inferring
    Model Parameters from Series Observations” on [page 419](ch13.xhtml#ch13lev1sec4),
    allows us to infer the most likely values of these parameters and then check,
    quantitatively, how well our purported model performs.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 用于生成预测的模型不必是已知的函数；它可以是一组微分方程。这是可能的，因为`Turing`和`DifferentialEquations`是可组合的，这是Julia类型系统的另一个优势。两者的结合极其强大，为研究开辟了新的领域。在科学中，我们的模型通常以微分方程的形式出现，这些方程大致编码了我们关于系统如何运作的假设。系统的某些细节可能仍然作为参数存在，其值可能是未知的，或者部分已知的。使用“从系列观察中推断模型参数”中概述的一般程序，进行概率编程（见[第419页](ch13.xhtml#ch13lev1sec4)），允许我们推断这些参数最可能的值，并定量检查我们假定的模型表现如何。
- en: For example, we may measure the trajectory of a cannonball and think we know
    that its path is governed by Newton’s laws of motion and the forces of gravity
    and air resistance. But we might not know the correct value of the gravitational
    acceleration on our planet or the coefficient of drag for the cannonball in its
    atmosphere. Assuming our differential equations are correct, we can use `Turing`
    and `DifferentialEquations` to infer the values of those two numbers from the
    observed trajectory, and then plug them back into the model to see whether we
    can reproduce the data. This approach eliminates a huge amount of trial and error,
    and it lets us iterate fluidly over variations in our models.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们可能测量了一颗炮弹的轨迹，并认为其轨迹受牛顿运动定律、重力和空气阻力的作用。但我们可能不知道地球上的重力加速度或炮弹在大气中的阻力系数。假设我们的微分方程是正确的，我们可以使用`Turing`和`DifferentialEquations`从观察到的轨迹中推断出这两个数值的值，然后将它们代回模型中，看看我们是否能够重现数据。这种方法消除了大量的试错过程，并且使我们能够在模型的变体之间流畅地迭代。
- en: 'Returning to the parametric instability problem from [Chapter 9](ch09.xhtml),
    let’s go backward: assume that we know we have a pendulum in a gravitational field,
    with a varying string length, and that we know the values for gravity, the pendulum
    mass, and the mean length of the string, but that the frequency and amplitude
    of the oscillation in the string’s length are unknown. We will, however, assume
    that the function defining that oscillation is a sin(*t*), where, as before, *t*
    is time.'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 回到[第9章](ch09.xhtml)中的参数不稳定性问题，我们来反向推理：假设我们知道有一个钟摆处于重力场中，且绳长在变化，我们知道重力、钟摆质量和绳子的平均长度，但频率和振幅是未知的。我们假设定义这种振荡的函数是sin(*t*)，其中，像之前一样，*t*表示时间。
- en: This example will show how we can work backward from data about the pendulum’s
    behavior to an estimate of the driving frequency and amplitude, using the assumption
    of the underlying physical model behind the data. Naively, we might approach this
    problem by solving the differential equation, using the techniques from [Chapter
    9](ch09.xhtml), multiple times, with various values of the unknown parameters,
    until we hit upon a solution that is close enough to the data. But this process
    will be computationally expensive and may not provide systematic knowledge of
    the uncertainty in the final result.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子将展示如何通过反向推理从关于钟摆行为的数据出发，估算驱动频率和振幅，前提是我们假设数据背后有一个基础的物理模型。天真地，我们可能通过多次求解微分方程，使用[第9章](ch09.xhtml)中的技术，并尝试不同的未知参数值，直到找到一个足够接近数据的解。但这个过程在计算上非常昂贵，并且可能无法系统地了解最终结果的不确定性。
- en: '[Listing 13-7](ch13.xhtml#ch13lis7) shows the problem set up for solution by
    the `Differential` `Equations` package, assembled here for convenience from [Listings
    9-8](ch09.xhtml#ch9lis8) and [9-9](ch09.xhtml#ch9lis8).'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '[清单13-7](ch13.xhtml#ch13lis7)展示了通过`Differential` `Equations`包求解的问题设置，便于参考，这里组合自[清单9-8](ch09.xhtml#ch9lis8)和[9-9](ch09.xhtml#ch9lis8)。'
- en: '[PRE13]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '*Listing 13-7: The parametrically driven pendulum*'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单13-7：参数驱动的钟摆*'
- en: In this example, the driving frequency is set to 3 percent smaller than the
    parametric resonance frequency ➊.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，驱动频率被设定为比参数共振频率小3个百分点➊。
- en: 'Before we proceed to apply `Turing` to this problem, let’s take a look at how
    varying the `f` and `A` values affects the results. First, we’ll plot the solution
    at resonance and slightly “detuned,” at 0.95 resonance:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们继续使用`Turing`处理这个问题之前，先来看一下变化`f`和`A`值如何影响结果。首先，我们将绘制在共振状态和稍微“失谐”的0.95共振频率下的解：
- en: '[PRE14]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '[Figure 13-10](ch13.xhtml#ch13fig10) shows the two solutions.'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '[图13-10](ch13.xhtml#ch13fig10)展示了这两个解。'
- en: '![Image](../images/ch13fig10.jpg)'
  id: totrans-133
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/ch13fig10.jpg)'
- en: '*Figure 13-10: The parametrically driven pendulum at two driving frequencies*'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '*图13-10：在两个驱动频率下的参数驱动摆*'
- en: As [Figure 13-10](ch13.xhtml#ch13fig10) makes clear, the solution is quite sensitive
    to the driving frequency.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 如[图13-10](ch13.xhtml#ch13fig10)所示，解对驱动频率非常敏感。
- en: Changing the driving amplitude also has a strong effect on the solution. [Figure
    13-11](ch13.xhtml#ch13fig11) shows the effect of two different forcing amplitudes
    at the same frequency.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 改变驱动振幅也会对解产生较大的影响。[图13-11](ch13.xhtml#ch13fig11)展示了在相同频率下，两个不同驱动振幅的效果。
- en: '![Image](../images/ch13fig11.jpg)'
  id: totrans-137
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/ch13fig11.jpg)'
- en: '*Figure 13-11: The parametrically driven pendulum at two driving amplitudes*'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '*图13-11：在两个驱动振幅下的参数驱动摆*'
- en: Changing the forcing amplitude alone changes the envelope amplitude, the envelope
    timescale, and the frequency of the response.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 仅仅改变驱动振幅就会改变包络振幅、包络时间尺度和响应频率。
- en: 'When we compare these solutions, we can see that amplitude and frequency are
    interdependent. It’s not a simple matter to infer either driving parameter from
    the response. Let’s see how well probabilistic programming with `Turing` does
    with this problem. First we’ll define a model with `A` and `f` uniformly distributed
    within reasonable intervals:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们比较这些解时，可以看到振幅和频率是相互依赖的。从响应中推断任一驱动参数并非一件简单的事。让我们看看使用`Turing`的概率编程能在这个问题上做得怎样。首先，我们将定义一个模型，其中`A`和`f`在合理区间内均匀分布：
- en: '[PRE15]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'As in the simple sinewave model, we’ll generate some noisy simulated data from
    the solution returned by `DifferentialEquations` for given values of `A` and `f`,
    and then use the `Turing` model to try to infer those numbers from the data. The
    program in the following listing goes through this procedure for a small set of
    values for `A` and `f` and plots the inferred numbers with the known values:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 如同简单的正弦波模型一样，我们将根据给定的`A`和`f`值，从`DifferentialEquations`返回的解中生成一些带噪声的模拟数据，然后使用`Turing`模型尝试从数据中推断出这些数值。以下列出的程序展示了这个过程，针对一小组`A`和`f`的值进行计算，并绘制推断的数值与已知值的对比图：
- en: '[PRE16]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: For each `A,f` pair, the program defines a forcing function ➊ and generates
    a solution ➋ from the differential equation. We tell the solver to save solution
    points at regular intervals using the `saveat` keyword argument and scale the
    simulated noise to the amplitude of the solution. The purpose of the solution
    is to generate the simulated noisy observations, which we then feed to the sampler
    ➌. The next command places a mark on the `A`-`f` plane of the plot corresponding
    to the true values of `A` and `f`. Then we place a mark for the inferred values,
    with error bars taken from the standard deviations of the distributions returned
    by `sample()`.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 对于每一对`A,f`值，程序定义了一个驱动力函数➊，并从微分方程中生成了解➋。我们告诉求解器在定期的间隔点保存解的结果，使用`saveat`关键字参数，并将模拟噪声的幅度调整到解的幅度。这个解的目的是生成模拟的带噪声观察数据，然后我们将这些数据提供给采样器➌。接下来的命令将在图中的`A`-`f`平面上标出对应真实`A`和`f`值的标记。然后，我们会为推断出的值加上误差条，误差条的值取自`sample()`返回的分布的标准差。
- en: We can access the sampling results for individual parameters using indexing
    on the name of the parameter as a symbol, so `psamples[:A]` is an array of all
    3,000 values for `A` in the distribution generated by the sampler. The mean of
    this array is its expectation value (and the value printed in the report printed
    in the REPL). The `std()` function calculates the standard deviation of an array,
    returning the same number as in the report under `std`.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过索引参数名称来访问单独参数的采样结果，`psamples[:A]`是采样器生成的分布中所有3,000个`A`值的数组。这个数组的均值就是其期望值（也是在REPL中打印的报告中的值）。`std()`函数计算数组的标准差，返回的数值与报告中`std`下的数值一致。
- en: '[Figure 13-12](ch13.xhtml#ch13fig12) shows the result.'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '[图13-12](ch13.xhtml#ch13fig12)展示了结果。'
- en: '![Image](../images/ch13fig12.jpg)'
  id: totrans-147
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/ch13fig12.jpg)'
- en: '*Figure 13-12: Inference of forcing parameters in the parametric pendulum*'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '*图13-12：在参数摆中的强迫参数推断*'
- en: The experiment works well using 3,000 samples; however, the same program run
    with 1,000 samples performs distinctly worse. [Figure 13-12](ch13.xhtml#ch13fig12)
    shows that each inferred value is correct within its reported standard deviation,
    and most of those spreads are small. Despite the complexity and sensitivity of
    this problem, `Turing` and `DifferentialEquations` were able to work together
    to confirm the faithfulness of the model and accurately induce the correct model
    parameters. Doubtless with further tuning of the sampling method, we could improve
    the results even further.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 使用3,000个样本时，实验运行得很顺利；然而，使用1,000个样本时，同一程序的表现明显较差。[图13-12](ch13.xhtml#ch13fig12)显示，每个推断值都在其报告的标准偏差范围内是正确的，而且这些误差大部分都很小。尽管这个问题复杂且敏感，`Turing`和`DifferentialEquations`还是能够协同工作，验证模型的忠实性并准确地推导出正确的模型参数。毫无疑问，经过进一步调整采样方法，我们可以进一步改善结果。
- en: '**Conclusion**'
  id: totrans-150
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**结论**'
- en: The field of scientific machine learning is making impressive strides and expanding
    rapidly as I write this. Julia users are perfectly positioned to take advantage
    of recent research in this field, as it finds application in the packages of the
    SciML ecosystem. Scientific machine learning selects some of the technologies
    developed in ML that can be fruitfully applied to science and engineering concerns.
    A survey of the entire field would be a book in itself. In this chapter we’ve
    explored a few central ideas and applied them to problems that, while interesting
    in themselves, are simple enough not to obscure the working of the SciML machinery
    with too much incidental detail. These ideas and techniques can be applied to
    all areas of quantitative science. This is an exciting field to follow. Wherever
    it goes, it will inevitably become a pillar of computational science.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 科学机器学习领域正在快速发展，并取得令人瞩目的进展。正如我所写的，Julia 用户完全可以利用该领域的最新研究，因为这些研究已在SciML生态系统的软件包中得到了应用。科学机器学习选取了机器学习中一些可以有效应用于科学和工程问题的技术。对整个领域的概述本身就是一本书。在本章中，我们探讨了一些核心思想，并将其应用于一些尽管本身具有趣味性，但足够简单的问题，以免过多的附带细节掩盖SciML机制的工作。这些思想和技术可以应用于所有定量科学领域。这是一个值得关注的激动人心的领域。无论它走向何方，都会不可避免地成为计算科学的支柱。
- en: '**FURTHER READING**'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: '**进一步阅读**'
- en: 'See “The Essential Tools of Scientific Machine Learning (Scientific ML)” by
    Christopher Rackauckas for an introduction to existing open source tools: [*http://www.stochasticlifestyle.com/the-essential-tools-of-scientific-machine-learning-scientific-ml/*](http://www.stochasticlifestyle.com/the-essential-tools-of-scientific-machine-learning-scientific-ml/).'
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 请参阅Christopher Rackauckas的《科学机器学习（Scientific ML）的基本工具》一书，了解现有开源工具的介绍：[*http://www.stochasticlifestyle.com/the-essential-tools-of-scientific-machine-learning-scientific-ml/*](http://www.stochasticlifestyle.com/the-essential-tools-of-scientific-machine-learning-scientific-ml/)。
- en: A solid mathematical introduction to automatic differentiation is available
    at [*http://www.ams.org/publicoutreach/feature-column/fc-2017-12*](http://www.ams.org/publicoutreach/feature-column/fc-2017-12).
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 关于自动微分的扎实数学介绍可以在[*http://www.ams.org/publicoutreach/feature-column/fc-2017-12*](http://www.ams.org/publicoutreach/feature-column/fc-2017-12)找到。
- en: 'Here is a hub for Julia’s SciML documentation: [*https://docs.sciml.ai/*](https://docs.sciml.ai/).'
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这里是Julia SciML文档的汇总：[*https://docs.sciml.ai/*](https://docs.sciml.ai/)。
- en: For a description of the various solver options for the `Differential` `Equations.jl`
    package, visit [*https://docs.sciml.ai/DiffEqDocs/stable/basics/common_solver_opts/*](https://docs.sciml.ai/DiffEqDocs/stable/basics/common_solver_opts/).
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要了解`Differential` `Equations.jl`包的各种求解器选项，请访问[*https://docs.sciml.ai/DiffEqDocs/stable/basics/common_solver_opts/*](https://docs.sciml.ai/DiffEqDocs/stable/basics/common_solver_opts/)。
- en: Details on the binomial distribution can be found at [*https://www.itl.nist.gov/div898/handbook/eda/section3/eda366i.htm*](https://www.itl.nist.gov/div898/handbook/eda/section3/eda366i.htm).
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 关于二项分布的详细信息可以在[*https://www.itl.nist.gov/div898/handbook/eda/section3/eda366i.htm*](https://www.itl.nist.gov/div898/handbook/eda/section3/eda366i.htm)找到。
- en: Documentation for the `Turing` package resides at [*https://turinglang.org/dev/docs/using-turing/get-started*](https://turinglang.org/dev/docs/using-turing/get-started).
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Turing`包的文档可以在[*https://turinglang.org/dev/docs/using-turing/get-started*](https://turinglang.org/dev/docs/using-turing/get-started)找到。'
- en: For a tutorial on the use of `Turing`, visit [*https://turinglang.org/dev/docs/using-turing/guide*](https://turinglang.org/dev/docs/using-turing/guide).
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要了解如何使用`Turing`，请访问[*https://turinglang.org/dev/docs/using-turing/guide*](https://turinglang.org/dev/docs/using-turing/guide)。
