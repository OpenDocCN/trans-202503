- en: <hgroup>
  prefs: []
  type: TYPE_NORMAL
- en: 21 EFFICIENT TEMPLATE DESIGN WITH TWIG
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: </hgroup>
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/opener.jpg)'
  prefs: []
  type: TYPE_IMG
- en: This chapter introduces the free, open source Twig templating library, a third-party
    package that applies object-oriented principles such as inheritance to page display
    templates. This mix of templating with OOP streamlines the process of designing
    web applications. We’ll explore the basics of using Twig, then use it to progressively
    build a multipage website.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter also offers a first look at how the object-oriented style of programming
    influences the web application architecture we arrived at in [Part III](part3.xhtml).
    For example, rather than writing functions that implement the logic of a front
    controller, we’ll create object-oriented classes containing front-controller methods.
    We’ll refine our approach to object-oriented application development in [Chapter
    22](chapter22.xhtml) as we further develop this chapter’s multipage site.
  prefs: []
  type: TYPE_NORMAL
- en: '### The Twig Templating Library'
  prefs: []
  type: TYPE_NORMAL
- en: Web templating systems like the Twig library (which can be found at *[https://twig.symfony.com](https://twig.symfony.com)*)
    manage the duplication that’s common in web application outputs by distinguishing
    between unchanging content and content that may change upon each request. This
    makes developing the view element of a web application’s MVC architecture much
    more efficient. As we’ve discussed in previous chapters, a lot of basic HTML is
    often duplicated across the template scripts for each page of a website, since
    the multiple pages typically share elements such as a header and a navigation
    bar. When we created a three-page website in [Chapter 13](chapter13.xhtml), for
    example, most of the code in the template file for each page was redundant HTML;
    barely any code was unique to the page at hand.
  prefs: []
  type: TYPE_NORMAL
- en: Duplicating so much HTML across multiple templates causes two issues. First,
    if you need to change an aspect of the website design (for example, the look and
    feel of the navigation bar, or a special header or footer), you’d have to edit
    *every* page template, which for a large website could be tens, hundreds, or even
    thousands of files. Second, when editing the content or behavior of a page template,
    spotting the content that’s specific to the current page can be difficult when
    it’s hidden within a bunch of generic code. You want to be able to focus on just
    the content for the particular page you’re editing.
  prefs: []
  type: TYPE_NORMAL
- en: One solution is to separate the common parts of a page into sub-templates for
    the header, navigation, footer, and so on. This is what we did in [Chapter 15](chapter15.xhtml),
    for example, when we created a *templates/_header.php* file containing header
    elements common to all the pages in our shopping cart website. A more elegant
    solution, however, is to use a dedicated PHP templating library, especially one
    such as Twig that supports template inheritance. As you’ll see, a key advantage
    of template inheritance is that after we’ve declared that a template for a particular
    page inherits from a parent template, the only content in the child page is that
    for the child page itself; we don’t have to write require statements for standard
    page headers, footers, navigation bars, and so on. This way, each child template
    contains fewer distractions away from the page it represents.
  prefs: []
  type: TYPE_NORMAL
- en: Another advantage of templating libraries is that they limit the behavior that
    can be encoded into a page template by removing any PHP code from the template
    itself. If you’re working on a website as part of a team, these limitations mean
    you can safely have other members of the team (such as a marketing department)
    edit the page templates to refine the website’s look and feel, secure in the knowledge
    that they can’t accidentally copy in PHP code that would break the website or
    create a security vulnerability. After all, template files are the view component
    of an MVC architecture, so they should only be “decorating” provided data with
    tags in a markup language like HTML.
  prefs: []
  type: TYPE_NORMAL
- en: '#### How Twig Works'
  prefs: []
  type: TYPE_NORMAL
- en: Before we create anything with Twig, let’s explore the basic files, objects,
    and methods involved when working with Twig templates. When using Twig in our
    code, we work with an object of the Twig\Environment class. This object is responsible
    for generating the HTML for a web page, based on a template file and any data
    needed to customize the contents of the page. It does this through its render()
    method. Usually, you store a reference to the Twig\Environment object in a variable
    called twig, which is itself a property of a general Application class that encapsulates
    all the high-level logic for the web application.
  prefs: []
  type: TYPE_NORMAL
- en: The render() method requires two parameters. The first is a string containing
    the path to the desired template file. This string is typically stored in a variable
    called $template. The second parameter is an array of variables that need to be
    provided to the template to customize the page’s content. This array is typically
    stored in a variable called $args, since the array is essentially providing arguments
    to the template. The string keys in the array should correspond to the names of
    any variables used in the Twig template. If no values need to be provided to the
    template, $args will be an empty array.
  prefs: []
  type: TYPE_NORMAL
- en: To illustrate, say you wanted to display a page showing the items in a shopping
    cart. The template for this page would be in a file that is called *shoppingCart.xhtml.twig*
    (by convention, Twig template files that output HTML are named in the form *<pageName>.xhtml.twig*),
    and it would have a products variable standing in for whatever products are in
    the user’s cart (variables in Twig templates don’t start with dollar signs).
  prefs: []
  type: TYPE_NORMAL
- en: You would pass the template filepath as the first argument to the Twig\Environment
    class’s render() method. The second argument would be an $args array containing
    a 'products' key (the same name as the variable in the template) whose value is
    an array of Product objects. The render() method would then return a string containing
    the HTML for a web page listing all the products as a nice shopping cart, with
    subtotals, the grand total, links to remove items or change their quantities,
    and so on. This string could then be printed to the output buffer that would become
    the body of the HTTP response being returned to the web client.
  prefs: []
  type: TYPE_NORMAL
- en: If a web application uses Twig templating, every method that returns HTML response
    text will contain something similar to the code shown in [Listing 21-1](#lis21-1).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 21-1: The typical code to create and print HTML from a Twig template'
  prefs: []
  type: TYPE_NORMAL
- en: We store the path to a template in the $template variable, then build up the
    $args array with the required template variables. We pass these variables to the
    render() method. Remember, we typically store a reference to the Twig\Environment
    object that owns the render() method in the twig property of an overarching Application
    class. This is why the call to the method is written as $this->twig->render()
    rather than $twig->render(). We store the resulting string in $html, which we
    print. Soon you’ll see this code pattern in context as we use Twig to create a
    basic web page.
  prefs: []
  type: TYPE_NORMAL
- en: A Simple Example
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In this section, we’ll use Twig to create a simple “Hello, world!” web page
    that displays a greeting. Thanks to Twig, we’ll be able to customize the greeting
    by filling in a name for the person being greeted, based on the value of a PHP
    variable. In addition to illustrating the basics of working with Twig, this project
    will also offer a first glimpse at how an object-oriented web application is structured.
  prefs: []
  type: TYPE_NORMAL
- en: To create our basic greeting page, we’ll start by setting up Twig. Then we’ll
    write a Twig template featuring a name variable, as well as the PHP scripts needed
    to make the template work.
  prefs: []
  type: TYPE_NORMAL
- en: Adding Twig to the Project
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'The easiest way to add Twig to a project is to use Composer. Create a new empty
    folder for the project and then enter the following at the command line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: This command triggers Composer to install the latest version of the Twig package
    into the project’s *vendor* folder (the folder will be created, since the project
    doesn’t already have one). The command also installs any additional dependencies
    that Twig requires, such as symfony/polyfill -mbstring and symfony/polyfill-ctype.
    If you look at the contents of the *vendor* folder after installation has finished,
    you should see that folders for these packages have been created. You can even
    look in each package’s *src* folder and examine each class and configuration file
    in the package.
  prefs: []
  type: TYPE_NORMAL
- en: Now that the Twig package has been copied into our project folder, we can add
    use statements in our classes to create and exploit the features of the library
    in our project.
  prefs: []
  type: TYPE_NORMAL
- en: Writing the Twig Template
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: By convention, Twig template files are stored in a *templates* folder, just
    like the PHP template files we’ve written in earlier chapters. Add this folder
    to your project directory, then create a *hello.xhtml.twig* template in that folder
    and enter the contents of [Listing 21-2](#lis21-2).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 21-2: The hello.xhtml.twig template to create an HTML greeting around
    the name variable'
  prefs: []
  type: TYPE_NORMAL
- en: Like many web templating languages, Twig templates use double curly brackets
    to indicate a value that should be filled in, such as {{name}} in this template
    ❶. This declares that the value of a Twig variable called name is to be inserted
    here when the render() method generates its HTML output string. In the PHP script
    invoking this template, we’ll need to pass Twig a value for the variable in the
    $args array, under a key of the same name. For example, if we declared the $args
    array as ['name' => 'Matt'], the render() method would produce the HTML shown
    in [Listing 21-3](#lis21-3), with Matt (shown here in bold) inserted in place
    of the name variable.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 21-3: The HTML rendered by the Twig template when name contains ''Matt'''
  prefs: []
  type: TYPE_NORMAL
- en: We see Matt has been inserted into the line saying hello in the HTML text output
    ❶.
  prefs: []
  type: TYPE_NORMAL
- en: Twig’s double curly brackets are similar to the PHP <?= short echo tag, in that
    both set off expressions that evaluate to strings and will be inserted into the
    output HTML. (Just as with PHP, Twig has other tags for setting off logic, such
    as loops and conditionals, rather than string output statements.) However, since
    Twig templates can’t contain PHP statements, using Twig double curly brackets
    instead of PHP short echo tags protects a website from PHP security vulnerabilities
    in the site’s templates.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the Application Class
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Let’s now write an Application class for our greeting page. It will set up the
    Twig\Environment object in its constructor method and have a run() method to set
    variables and generate the page’s HTML via Twig. All object-oriented MVC web applications
    have something like this Application class to perform any setup and initializations
    required, and then to execute the main logic for handling requests to the application.
  prefs: []
  type: TYPE_NORMAL
- en: For now, the class will always output the same HTML, but later in the chapter,
    we’ll see some logic in the class’s run() method to output different HTML content
    depending on variables received in the request to the server. To declare the class,
    create *src/Application.php* containing the code in [Listing 21-4](#lis21-4).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 21-4: The class src/Application.php to create a Twig object and a method
    to output HTML'
  prefs: []
  type: TYPE_NORMAL
- en: We declare the Application class as part of the Mattsmithdev namespace and include
    two use statements, since we’ll need to create objects of classes from the Twig
    namespace in the constructor. Then we declare a constant named PATH_TO_TEMPLATES
    holding the path to the base *templates* directory where all the templates are
    saved. We also declare a private twig property, which will be a reference to a
    Twig\Environment object.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we declare the class’s constructor method. Within it, we create two Twig-related
    objects, FilesystemLoader and Environment. The latter holds the all-important
    render() method, while the former helps the Environment object access the template
    files. The FilesystemLoader object is created only temporarily, since its reference,
    stored in the $loader variable, exists only within the scope of the constructor.
    When we create the Environment object (using $loader), we store a reference to
    it in the Application object’s twig property ❶, which all our Application methods
    can access when $this->twig is written.
  prefs: []
  type: TYPE_NORMAL
- en: 'Notice that when we create the FilesystemLoader object by using the PATH_TO_TEMPLATES
    constant, we must add self:: before the constant identifier. As we’ll discuss
    in [Chapter 25](chapter25.xhtml), this prefix is necessary when referencing a
    constant declared in the same class. This is because PHP doesn’t create a copy
    of the constant for each object of the class. Instead, there’s just one constant
    for all objects of the class, so writing $this->PATH_TO_TEMPLATES isn’t valid.'
  prefs: []
  type: TYPE_NORMAL
- en: We next declare the Application class’s run() method. In it, we define the $name
    variable containing the name of the person we want to greet. Then we create the
    $template variable, which holds the name of our template file (*hello.xhtml.twig*),
    and the $args variable, an array with a single element holding the value of the
    $name variable under the 'name' key. As we’ve discussed, this key corresponds
    to the Twig variable enclosed in double curly brackets in our template file. Still
    within the run() method, we then invoke the render() method of our Twig object,
    storing the string it returns in the $html variable ❷. Finally, we print the content
    of $html, which becomes the HTML body of the response returned to the web client.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the Autoloader
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Let’s now get Composer to create the autoloader for Mattsmithdev namespaced
    classes located in the *src* directory (such as our Application class). To do
    this, we need to add an "autoload" property to *composer.json* in the top-level
    directory for the project. This file was created automatically when we used Composer
    to add the Twig package to the project, and it should already contain a "require"
    property with information about Twig. Update the file as shown in [Listing 21-5](#lis21-5).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 21-5: Updating composer.json for class autoloading'
  prefs: []
  type: TYPE_NORMAL
- en: We add an "autoload" property, declaring that Mattsmithdev namespaced classes
    are PSR-4 compliant and can be found in the *src* directory. Don’t forget the
    comma after the closing curly bracket ❶; you’ll get a JSON syntax error if this
    comma is missing.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once you’ve updated *composer.json*, enter the following at the command line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: This instructs Composer to generate the necessary autoload scripts in the *vendor*
    folder.
  prefs: []
  type: TYPE_NORMAL
- en: Adding the Index Script
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: The final step required to get our greeting page up and running is to create
    a simple index script that will read in the autoloader, create an Application
    object, and invoke its run() method. All our object-oriented web applications
    will have a simple index script like this, since all the work is being performed
    by the Application object. Create *public/index.php* as shown in [Listing 21-6](#lis21-6).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 21-6: The index.php script'
  prefs: []
  type: TYPE_NORMAL
- en: We first read in and execute the generated autoloader script. Note that the
    autoloader created by Composer will load any class declared in the Mattsmithdev
    namespace, as well as any classes in third-party libraries that Composer has added
    to the project (such as Twig). Next, we add a use statement so we can refer to
    the Application class without specifying the namespace each time. Then we create
    an Application object and invoke its run() method.
  prefs: []
  type: TYPE_NORMAL
- en: If you run the PHP web server and visit the project home page, you should see
    something like [Figure 21-1](#fig21-1). Also shown in the figure is the HTML source
    of the response that the web client receives. Notice that the HTML and the resulting
    web page both have the name *Matt* filled in at the location of the Twig {{name}}
    variable.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/figure21-1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 21-1: The web output, with HTML source, for our basic Twig project'
  prefs: []
  type: TYPE_NORMAL
- en: This might have seemed like *a lot* of work for a simple “Hello, world!” website,
    but we’ve now created all the structure required for any project that uses the
    powerful Twig templating system. Before we apply that structure to a more substantial
    website, let’s explore a few more useful features of the Twig package.
  prefs: []
  type: TYPE_NORMAL
- en: Manipulating Objects and Arrays in Twig Templates
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In addition to simple data types like strings, Twig templates can work with
    PHP objects, arrays, and so on. However, the notation is a bit different from
    what we’re used to in PHP, since Twig uses *dot notation* to access a property
    or method of an object, or an element in an array. For example, while you’d write
    $product->price in PHP to access the price property of a Product object, you’d
    use {{product.price}} to do the same in a Twig template. Conveniently, this works
    whether the property is public or private, provided that if it’s private, the
    property has a public getter method that follows the usual getPropertyName() or
    isBooleanPropertyName() naming convention. For example, {{product.price}} would
    still successfully access an object’s private price property as long as the object
    has a public getPrice() method. You don’t need to reference the getPrice() method
    explicitly in the Twig template, since Twig calls the method for you.
  prefs: []
  type: TYPE_NORMAL
- en: To illustrate how Twig templates work with these more complex data types, we’ll
    update our “Hello, world!” web page to display information obtained from a PHP
    object and array. First, we’ll need to write a class so we can create an object
    and pass it to the Twig template. [Listing 21-7](#lis21-7) shows a simple Product
    class that we can use as an example. Create *src/Product.php* and enter the contents
    of the listing.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 21-7: A simple Product class to use in the Twig demo'
  prefs: []
  type: TYPE_NORMAL
- en: 'The class has two private properties: description and price. The code also
    has public getter and setter methods for each of these properties, as well as
    a __toString() method that generates a string summary of the object.'
  prefs: []
  type: TYPE_NORMAL
- en: Next, we’ll modify the run() method of our Application class. The new method
    will create an array and a Product object and pass them along to the Twig template,
    along with the original name variable. Update *src/Application.php* to match the
    contents of [Listing 21-8](#lis21-8).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 21-8: The updated Application class passing an object and an array
    to the template'
  prefs: []
  type: TYPE_NORMAL
- en: 'We create a $meals array with the keys ''breakfast'', ''lunch'', and ''dinner'',
    along with a Product object with the description ''bag of nails'' and the price
    10.99. Then we declare the $template and $args variables required for the render()
    method. In $args, we pass values for three variables in the Twig template: name,
    meals, and product. This time we declare the value for the ''name'' key directly
    in the array rather than as a separate variable.'
  prefs: []
  type: TYPE_NORMAL
- en: Notice that we declare the Twig template to be *demo.xhtml.twig* rather than
    the *hello.xhtml.twig* template we created earlier ❶. We’ll create that new template
    now and design it to show off some of the ways Twig interacts with objects and
    arrays. Make a copy of *hello.xhtml.twig*, rename it *demo.xhtml.twig*, and update
    this new file to match [Listing 21-9](#lis21-9).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 21-9: The demo.xhtml.twig template'
  prefs: []
  type: TYPE_NORMAL
- en: In the body of the template, we first print the value of the Twig name variable
    ❶. Then we print the value inside the meals array variable under the dinner key
    ❷. The Twig dot notation of {{meals.dinner}} here corresponds to the PHP expression
    $meals['dinner'].
  prefs: []
  type: TYPE_NORMAL
- en: Next, we print the value returned from the getDescription() method of the product
    object variable ❸. In this case, the Twig dot notation of {{product.getDescription()}}
    corresponds to the PHP expression $product ->getDescription(). We also print the
    value of the object’s price property ❹. When Twig tries to access this price property,
    it will see that the property is private, so it will automatically attempt to
    invoke the object’s getPrice() accessor method instead. The Twig dot notation
    of {{product.price}} therefore corresponds to the PHP expression $product->getPrice().
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we place the Twig product variable inside double curly brackets without
    any dot notation ❺. When Twig sees that product is an object, it will automatically
    attempt to invoke its __toString() method. This is similar to PHP automatically
    invoking an object’s __toString() method when a reference to that object is used
    in a context where a string is expected. Essentially, {{product}} in Twig corresponds
    to print $product in PHP, which in turn corresponds to $product->__toString().
    [Figure 21-2](#fig21-2) shows how the HTML rendered from this template will appear
    in the browser.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/figure21-2.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 21-2: A browser rendering of the HTML from the Twig demo template'
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, Twig has successfully filled in all the information from the
    object and array passed to the template. The annotations in the figure summarize
    the Twig notation used to access each piece of information, and the equivalent
    expressions in PHP.
  prefs: []
  type: TYPE_NORMAL
- en: Twig Control Structures
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Beyond printing individual values, the Twig templating language also offers
    several control structures, including if and for statements, allowing you to add
    conditional logic and looping to your Twig templates. This greatly expands the
    templates’ ability to adapt to whatever data they receive in the $args array.
  prefs: []
  type: TYPE_NORMAL
- en: Twig control statements are written within single curly brackets and percent
    characters, such as {% if condition %} or {% for ... %}, and each control structure
    must conclude with a closing tag, such as {% endif %} or {% endfor %}.
  prefs: []
  type: TYPE_NORMAL
- en: Twig can loop through all the values in an array with {% for value in array
    %}, much like a foreach loop in PHP. If you want the key and value for each array
    item, you could write {% for key, value in array %}. Let’s try that now by creating
    a Twig template that will loop through the items in the PHP $meals array we created
    in the preceding section. Update the Twig template *demo.xhtml.twig* as shown
    in [Listing 21-10](#lis21-10).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 21-10: Looping through and outputting meals as an HTML list'
  prefs: []
  type: TYPE_NORMAL
- en: 'We declare a Twig for loop to iterate through the elements of the meals array
    ❶. The key and value of each element in the array will become part of a list item
    in an HTML unordered list and will be output as HTML in the form <li>meal: lunch
    = salad</li> ❷. Instead of having to write separate HTML for each item in the
    list, we simply write one item using the Twig variables key and value, and the
    for loop will generate all the items for us. The loop also includes a Twig else
    statement ❸, which is executed if the given array is empty. In that case, we output
    a message stating that no meals are in the list. The loop concludes with the closing
    endfor tag ❹. [Figure 21-3](#fig21-3) shows the web page that’s rendered when
    you serve this code with the web server.'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/figure21-3.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 21-3: The web page and HTML source generated by the Twig for loop'
  prefs: []
  type: TYPE_NORMAL
- en: The Twig for loop has successfully generated an HTML list by using the keys
    and values from the $meals array.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a Multipage Website with Twig
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'For the rest of this chapter, we’ll harness Twig templating to create a multipage
    website. In addition to demonstrating the value of Twig templating, building this
    site will illustrate how the front-controller structure we’ve used in previous
    chapters translates to an object-oriented web application. [Figure 21-4](#fig21-4)
    shows the site we’ll progressively develop: a simplified two-page version of the
    website we created in [Chapter 16](chapter16.xhtml), with the login page removed.'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/figure21-4.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 21-4: A two-page website created with Twig templating'
  prefs: []
  type: TYPE_NORMAL
- en: Our site will have a home page and a Contact Us page, with the same header and
    navigation links shared by the two pages. All the common HTML will be declared
    in a *base template* from which the page-specific content templates will inherit.
  prefs: []
  type: TYPE_NORMAL
- en: This means that each *page (child) template* will contain only the special content
    for that page. It also means that every page in the website can be changed simply
    by updating the base template (for example, if we wanted to add or change the
    navigation links, change the logo, or make the website background turn green for
    St. Patrick’s Day).
  prefs: []
  type: TYPE_NORMAL
- en: The File Structure and Dependencies
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Let’s first establish the file structure for the application. Create a new
    project folder. Inside it, we’ll build the following directories and files:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/pg409.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Two files are exactly the same as the examples shown earlier in this chapter:
    *public/index.php* and *composer.json*. As you saw in [Listing 21-6](#lis21-6),
    the *index.php* script simply reads in the autoloader, creates an object of the
    Application class, and calls the class’s run() method. The *composer.json* file
    (Listing 21-5) provides information for the autoloader and about the project’s
    namespace (Mattsmithdev) as well as third-party library requirements (Twig). Copy
    these two files into the folder created for the project.'
  prefs: []
  type: TYPE_NORMAL
- en: Also copy the *public/images/logo.png* image provided in the files accompanying
    this book at *[https://github.com/dr-matt-smith/php-crash-course](https://github.com/dr-matt-smith/php-crash-course)*
    (or use your own logo image). Finally, since we’ll be using the same namespace
    and Twig library as before, you can also copy the *vendor* folder to get the same
    autoloader and library files.
  prefs: []
  type: TYPE_NORMAL
- en: The Application Class
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The Application class for our project plays the role of a front controller:
    it determines which page of the website to display based on the URL-encoded navigation
    action. If the URL has no action variable, Application will display the home page.
    If Application finds an action variable with the value contact, it will display
    the Contact Us page.'
  prefs: []
  type: TYPE_NORMAL
- en: The Application class is also responsible for creating a Twig\Environment object
    to manage the Twig templates, and for this reason the first several lines of the
    Application class declaration are the same as they were for our “Hello, world!”
    project earlier in the chapter. Copy *src/Application.php* from the previous project
    and update it to match [Listing 21-11](#lis21-11).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 21-11: The Application class for the two-page website'
  prefs: []
  type: TYPE_NORMAL
- en: We first declare the run() method ❶, which takes the place of the front-controller
    code we’ve previously written in an *index.php* script. The method attempts to
    find a URL-encoded variable named action, then feeds its value to a typical front-controller
    switch statement. If the value is 'contact', the contactUs() method is invoked.
    Otherwise, the homepage() method is invoked.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we declare the homepage() method ❷. It prints the result of running the
    render() method of the twig property (which contains a reference to the Twig\Environment
    object). When we call render(), we pass in $template, which has a value of 'homepage.xhtml.twig',
    and pass in the $args array, which provides the Twig pageTitle variable with the
    value 'Home Page'.
  prefs: []
  type: TYPE_NORMAL
- en: We also declare the contactUs() method for displaying the Contact Us page ❸.
    This method similarly calls render() and prints the result, this time passing
    in $template with a value of 'contactUs.xhtml.twig' and $args providing the Twig
    pageTitle variable with the 'Contact Us Page' value.
  prefs: []
  type: TYPE_NORMAL
- en: These two methods, homepage() and contactUs(), replace stand-alone helper functions
    that we earlier would have written in a *functions.php* file. In this way, our
    object-oriented application encapsulates all the display logic within the Application
    class.
  prefs: []
  type: TYPE_NORMAL
- en: The Twig Templates
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Now all we have to do to complete our site is write the Twig template files
    for the two pages. We’ll start with the home page. Create *templates/homepage.xhtml.twig*
    containing the code in [Listing 21-12](#lis21-12).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 21-12: The homepage.xhtml.twig template'
  prefs: []
  type: TYPE_NORMAL
- en: We declare the HTML title, outputting MGW followed by the contents of the Twig
    pageTitle variable ❶. Then we display the site logo image ❷. We next present a
    simple navigation list with links to the home page ❸ and the Contact Us page ❹.
    Then we use a <blockquote> element to present the website’s tagline and greeting
    ❺, followed by a level 1 heading that again uses the Twig pageTitle variable ❻.
    Finally, we declare the page-specific content; for this home page, it’s just a
    sentence in a paragraph ❼.
  prefs: []
  type: TYPE_NORMAL
- en: Listing 21-13 shows the parts of the page that are different for the Contact
    Us Twig template. Copy *homepage.xhtml.twig*, name the copy *contactUs.xhtml.twig*,
    and edit this file to match this listing.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 21-13: The contactUs.xhtml.twig template'
  prefs: []
  type: TYPE_NORMAL
- en: The only content of this template that differs from the home page is the paragraph
    and definition list at the end of the HTML body ❶. Thanks to the use of the Twig
    pageTitle variable, the rest of the template is identical. Twig will fill in the
    variable with Home Page or Contact Us Page as appropriate.
  prefs: []
  type: TYPE_NORMAL
- en: At this point, the website has everything we need to display and navigate the
    two pages. If you run the project, you’ll see something like [Figure 21-5](#fig21-5).
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/figure21-5.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 21-5: A simple two-page site built with Twig'
  prefs: []
  type: TYPE_NORMAL
- en: Notice that Twig has correctly filled in the value of the pageTitle variable
    for each page.
  prefs: []
  type: TYPE_NORMAL
- en: Twig Features to Improve Efficiency
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Our two-page website now works as expected, but a lot of duplicated code remains
    in the two Twig template files. In this section, we’ll explore techniques for
    improving the efficiency of our templates, such as include statements and template
    inheritance. Features like these make Twig particularly useful for developing
    multipage web applications.
  prefs: []
  type: TYPE_NORMAL
- en: '##### include Statements'
  prefs: []
  type: TYPE_NORMAL
- en: As you’ve seen, pages in a website typically share much of the same HTML code.
    Twig include statements make it possible to create partial templates containing
    that shared code and add the rendered output from those partial templates to the
    actual page templates that need it. These include statements take the form {{include(templateName)}}.
  prefs: []
  type: TYPE_NORMAL
- en: To demonstrate, we’ll take all the shared content at the top of each of our
    two page templates and put it in a common *_header.xhtml.twig* file. (Remember,
    it’s common to prefix partial templates like this with an underscore.) Then we’ll
    use include statements to add the partial template to the top of our page template
    files, which we’ll be able to shorten to contain just the content unique to each
    page.
  prefs: []
  type: TYPE_NORMAL
- en: Create *templates/_header.xhtml.twig* and copy in the code from the top of one
    of the page template files, as shown in [Listing 21-14](#lis21-14).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 21-14: The partial _header.xhtml.twig template'
  prefs: []
  type: TYPE_NORMAL
- en: Everything up to and including the level 1 heading (again, using the Twig pageTitle
    variable) has been moved into this *_header.xhtml.twig* partial template. With
    that, we can greatly reduce the content in the home page and Contact Us templates.
    [Listing 21-15](#lis21-15) shows the updated home page Twig template, replacing
    all the duplicated content with a simple Twig include statement. Update *templates/homepage.xhtml.twig*
    to match the contents of this listing.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 21-15: The simplified homepage.xhtml.twig template'
  prefs: []
  type: TYPE_NORMAL
- en: We begin with a the Twig include statement, {{include('_header.xhtml.twig')}},
    telling Twig to read in the partial template file *_header.xhtml.twig*. All that
    remains in the template is the page-specific content.
  prefs: []
  type: TYPE_NORMAL
- en: We can similarly remove the duplicated content from our Contact Us template.
    Update *templates/contactUs.xhtml.twig* as shown in [Listing 21-16](#lis21-16).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 21-16: The simplified contactUs.xhtml.twig template'
  prefs: []
  type: TYPE_NORMAL
- en: Once again, we’ve removed the duplicated content and replaced it with a Twig
    include statement. The page-specific content follows.
  prefs: []
  type: TYPE_NORMAL
- en: 'Using Twig include statements, we’ve drastically simplified our individual
    page templates. However, notice that we still have the final </body> and </html>
    tags shared by both templates. In theory, we could relocate these to a partial
    *_footer.xhtml.twig* template. For a simple website, this could be a reasonable
    approach, but for more complex pages and larger websites, Twig offers an even
    more powerful feature for consolidating redundant content than include statements:
    template inheritance.'
  prefs: []
  type: TYPE_NORMAL
- en: Template Inheritance
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '*Template inheritance* involves creating a *base template* with all the content
    shared by a group of web pages, then creating individual *child templates* that
    extend the base template by filling in or overriding just the content unique to
    a particular page. It’s much like the OOP technique of creating subclasses that
    inherit from, extend, and override certain behaviors of a superclass.'
  prefs: []
  type: TYPE_NORMAL
- en: The base template ensures that all website pages have all the required valid,
    well-formed HTML, including ending tags, freeing up the child templates to focus
    on their own page-specific content. As you’ll see, this inheritance approach is
    much neater than using include statements to incorporate partial templates.
  prefs: []
  type: TYPE_NORMAL
- en: To use template inheritance, we’ll first convert our *templates/_header.xhtml.twig*
    file into a base template that the other templates can inherit from and extend.
    Rename *_header.xhtml.twig* to *base.xhtml.twig* and edit it to match [Listing
    21-17](#lis21-17).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 21-17: The base.xhtml.twig template'
  prefs: []
  type: TYPE_NORMAL
- en: The key to template inheritance is to use Twig statements in the base template
    to delineate blocks of code that will be filled in or overridden in each child
    page template. In this example, we define a block called main. This is where the
    unique content for each page will go. In our base template itself, however, the
    block is empty, so nothing is between the block and endblock statements. Twig
    blocks have names (in this case, main) so that child templates can specify which
    blocks (if any) are to be overridden with page-specific content.
  prefs: []
  type: TYPE_NORMAL
- en: Notice that in this inheritance approach, we have a full web page in the base
    template; that is, it isn’t a partial template. In particular, the base template
    includes closing </body> and </html> tags. A Twig base template is a complete
    HTML page in its own right, although it may have default or empty blocks meant
    to be overridden in the child templates.
  prefs: []
  type: TYPE_NORMAL
- en: We can now update our home page and Contact Us templates to inherit from the
    base template and override the main block with individual page content. First,
    update *templates/homepage.xhtml.twig* to match [Listing 21-18](#lis21-18).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 21-18: The homepage.xhtml.twig template, inheriting from the base template'
  prefs: []
  type: TYPE_NORMAL
- en: We declare that this template extends (inherits from) *base.xhtml.twig*. Then
    we embed the page-specific paragraph inside the main block, overriding the empty
    contents of this block in the base template. We finish with an endblock statement
    so that Twig knows where the overriding content ends. These endblock statements
    are particularly important because in more complex pages we may be overriding
    two or more blocks in a child page template. Notice that we no longer have the
    closing HTML tags at the end of the file, since these have moved to the base template.
  prefs: []
  type: TYPE_NORMAL
- en: We next need to make the same changes to the Contact Us page. Update *templates/contactUs.xhtml.twig*
    to match [Listing 21-19](#lis21-19).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 21-19: The contactUs.xhtml.twig template, inheriting from the base
    template'
  prefs: []
  type: TYPE_NORMAL
- en: Once again, we use extends so that this template will inherit from *base.xhtml.twig*,
    and we override the main block with the page-specific content. As before, we close
    out the main block with an endblock statement.
  prefs: []
  type: TYPE_NORMAL
- en: Blocks Instead of Variables
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: For this simple, static, two-page website, we shouldn’t need to pass any variables
    to the Twig templates through the $args array when we call the render() method.
    At present, our controller methods are passing the page title as a Twig variable
    named pageTitle. However, we could instead make the page title a block in the
    base template and override the block with the appropriate text in each child template.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s remove the pageTitle variable being passed by the controller methods in
    our Application class. Update *src/Application.php* to match [Listing 21-20](#lis21-20).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 21-20: Passing an empty $args array in the Application class'
  prefs: []
  type: TYPE_NORMAL
- en: We declare $args as an empty array in the homepage() and contactUs() methods.
    While we could just pass an empty array as the second argument to render(), first
    declaring the array as a variable clarifies whether any variables are being passed
    to the Twig template.
  prefs: []
  type: TYPE_NORMAL
- en: We must now update the base template to declare a block for the page title,
    rather than printing the contents of a Twig variable. Update *templates/base.xhtml.twig*
    as shown in [Listing 21-21](#lis21-21).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 21-21: Adding a page title block to the base.xhtml.twig template'
  prefs: []
  type: TYPE_NORMAL
- en: We declare a new pageTitle Twig block whose contents will become part of the
    HTML <title> element. We also need to repeat the contents of this block later
    as a level 1 heading ❶. We aren’t permitted to declare a second block with the
    same name, however. Instead, we print the contents of the block by using Twig’s
    block() function, which takes an argument indicating the name of the block whose
    contents should be output. We need to enclose this function call in double curly
    brackets, just like other Twig expressions.
  prefs: []
  type: TYPE_NORMAL
- en: All that remains is to update each child page to declare a pageTitle block containing
    an appropriate page name, overriding the default empty pageTitle block in the
    base template. Update *templates/homepage.xhtml.twig* to match [Listing 21-22](#lis21-22).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 21-22: Declaring a page title block in the homepage.xhtml.twig template'
  prefs: []
  type: TYPE_NORMAL
- en: We declare the pageTitle block with the Home Page content. This one declaration
    is enough to fill in the page title at both locations in the base template. Update
    *templates/contactUs.xhtml.twig* in the same way, declaring the pageTitle block
    with the Contact Us Page content.
  prefs: []
  type: TYPE_NORMAL
- en: When you now load the website, you should see that nothing has changed. However,
    our use of template inheritance has made the code much more efficient.
  prefs: []
  type: TYPE_NORMAL
- en: Improved Page Styling with CSS
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Our website is working, and the template code is efficient and well organized,
    but the pages themselves don’t look very appealing. We’ll round out the website
    by introducing some CSS to give it a more polished design. With all the common
    content for the site confined to the single *base.xhtml.twig* template file, you’ll
    see that Twig makes this process of updating the site’s appearance quite straightforward.
  prefs: []
  type: TYPE_NORMAL
- en: Highlighting the Current Navigation Link
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Highlighting the current page’s navigation bar link is a common way to inform
    the user which page they’re viewing. In [Chapter 16](chapter16.xhtml), we did
    this with PHP variables. Now you’ll see how Twig template inheritance makes the
    process even easier. In the base template, we’ll declare a uniquely named Twig
    block for the content of the class attribute for each link element in the navigation
    list. Then, in the child templates, we’ll override the appropriate Twig block
    to set the current page link’s class attribute to active. We’ll use CSS to style
    the active link a different color from others.
  prefs: []
  type: TYPE_NORMAL
- en: To begin, update *base.xhtml.twig* to match [Listing 21-23](#lis21-23).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 21-23: The base.xhtml.twig template with blocks for the navigation
    links'
  prefs: []
  type: TYPE_NORMAL
- en: We add a style import declaration so that all pages of the site will be able
    to use the CSS styles declared in *public/css/style.css* (which we’ll create shortly).
    Then we declare a homeLink Twig block as the content for a class attribute for
    the link to the home page. The block is empty, so if it isn’t overridden, the
    link won’t be assigned to a class. We similarly declare a contactLink Twig block
    as the content for a class attribute for the Contact Us link.
  prefs: []
  type: TYPE_NORMAL
- en: We now need to make the child templates override these blocks. Update the *homepage.xhtml.twig*
    template file as shown in [Listing 21-24](#lis21-24).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 21-24: Declaring a homeLink block in homepage.xhtml.twig'
  prefs: []
  type: TYPE_NORMAL
- en: We declare the homeLink block to have active content, thereby assigning it to
    a CSS class that will highlight the page link in a different color from the default
    navigation links. [Listing 21-25](#lis21-25) shows how to update the *contactUs.xhtml.twig*
    template file in the same way.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 21-25: Declaring a contactLink block in contactUs.xhtml.twig'
  prefs: []
  type: TYPE_NORMAL
- en: We declare the contactLink block with active content, which again will highlight
    the page’s link when the user visits it.
  prefs: []
  type: TYPE_NORMAL
- en: To finish, we need to declare some simple CSS rules. We’ll give the page header
    (containing the navigation list) a dark background color and define default and
    active colors for the links. Create a new *public/css* folder for the project,
    then create *style.css* within it and enter the contents of [Listing 21-26](#lis21-26).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 21-26: The style.css stylesheet'
  prefs: []
  type: TYPE_NORMAL
- en: We set the default color of all <a> elements to be gray ❶, while any <a> elements
    with a class attribute of active will be white instead ❷. Finally, we declare
    the unordered list in the header element to display inline-block ❸ so our navigation
    items appear in the same row as the logo image in the header. [Figure 21-6](#fig21-6)
    shows the updated home page for our site, as well as the page’s HTML source code.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/figure21-6.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 21-6: The home page and corresponding active CSS class for the page’s
    link in the HTML source'
  prefs: []
  type: TYPE_NORMAL
- en: In the HTML, notice that the active content from the homeLink block appears
    in the class element for the Home link in the navigation bar. As a result, the
    Home link appears white to indicate it’s the page currently being viewed.
  prefs: []
  type: TYPE_NORMAL
- en: Polishing the Website with Bootstrap
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Rather than hacking together our own CSS for a more professional-looking and
    responsive page layout, we can once again let the powerful Bootstrap CSS framework
    do most of the work for us. Twig makes incorporating Bootstrap styling easy. All
    we need to do is make a few changes to the base template, and those changes will
    affect every page of the website. We don’t need to change the child page templates
    at all.
  prefs: []
  type: TYPE_NORMAL
- en: We’ll let Bootstrap style our navigation links, and we’ll use predefined colors
    that Bootstrap provides, so we can delete the folder and file *css/style.css*
    altogether. Then we just need to modify the base template of the site. Edit *base.xhtml.twig*
    to match the contents of [Listing 21-27](#lis21-27).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 21-27: Updating the base.xhtml.twig template with Bootstrap'
  prefs: []
  type: TYPE_NORMAL
- en: We add a meta element to prevent the page content from appearing too small when
    viewed on mobile devices ❶. Then we load in the Bootstrap stylesheet ❷ and entire
    HTML page body as a Bootstrap container ❸. This adds basic spacing to the left
    and right margins of the page after Bootstrap has determined the appropriate maximum
    width for page content for the web client viewport dimensions.
  prefs: []
  type: TYPE_NORMAL
- en: We assign the header element containing the logo and navigation bar several
    Bootstrap classes to render the element as a navigation bar in dark mode with
    the predefined bg-dark background color ❹. The unordered list containing the navigation
    links receives the navbar-nav style ❺ for professional-looking links. We style
    each link’s list item as a nav-item and its anchor link element as a nav-link.
    Notice that the Twig homeLink and contactLink blocks still appear as part of the
    links’ class attributes, alongside the nav-link class. This way, the currently
    displayed page’s link element will have both the nav-link and active styles applied,
    and Bootstrap will highlight the link accordingly.
  prefs: []
  type: TYPE_NORMAL
- en: The background color, spacing, and multicolumn layout of the header are achieved
    using a combination of Bootstrap utility classes. We replace the header’s old
    <blockquote> element with a <div> ❻ styled as a row with a light background (bg-light),
    lots of padding on all four sides (p-5), and a medium-spaced bottom margin (mb-4).
    The header <div> contains a <div> for the main heading and tagline styled as a
    column (col display-6), which will appear to the left of another <div> for the
    site’s greeting.
  prefs: []
  type: TYPE_NORMAL
- en: With the addition of Bootstrap styling, our website now has the professional
    look and feel shown previously in [Figure 21-4](#fig21-4). We achieved this styling
    simply by changing the base template file, without having to touch any of the
    child page templates.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned the basics of the Twig templating package, which
    greatly simplifies the process of creating general HTML templates that can be
    customized with page-specific content. Using Twig, we created a multipage website,
    driven by the run() method of an Application class, which performs the function
    of a front controller. The only part of our web application that isn’t object-oriented
    is the code in the *public/index.php* script, which reads in and executes the
    Composer autoloader, creates an Application object, and calls its run() method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Thanks to Twig, we can safely hand over responsibility for creating and modifying
    page templates to team members who need no knowledge of PHP programming. Through
    the use of Twig inheritance and overridable blocks, the templates for each page
    are small and focus on content specific to that individual page. We leveraged
    Twig’s powerful inheritance feature, enabling us to add features such as professional
    Bootstrap styling and active link highlighting, all through declarations in the
    top-level base template. Overall, using a templating system such as Twig means
    we’re strongly separating the view component of our web application from its controllers
    and model: Twig templates have the single responsibility of decorating provided
    data with HTML to create the body of responses to be returned to the requesting
    web client.'
  prefs: []
  type: TYPE_NORMAL
- en: '### Exercises'
  prefs: []
  type: TYPE_NORMAL
- en: '1.   Create a project with a single script, *public/index.php*, that returns
    a complete, well-formed HTML page body containing a paragraph saying Hello name,
    where name is a URL-encoded variable. Then progressively refactor the project
    in the following sequence:'
  prefs: []
  type: TYPE_NORMAL
- en: a.   Move the HTML into *templates/hello.php*, and write front-controller PHP
    code in *public/index.php* to display this template.
  prefs: []
  type: TYPE_NORMAL
- en: b.   Move your front-controller logic into a run() method in a namespaced Application
    class. The run() method should extract the name URL-encoded variable and pass
    it to a hello() method that displays the *templates/hello.php* template. You’ll
    also need to create a *composer.json* file for your class’s namespace, generate
    the Composer autoloader, and update *public/index.php* to read in the autoloader,
    create an Application object, and call the run() method.
  prefs: []
  type: TYPE_NORMAL
- en: c.   Convert your *templates/hello.php* file into a Twig template called *templates/hello.xhtml.twig*,
    and update your Application class to create a twig property in its constructor.
    Use this property in the hello() method to create and then print an $html variable
    for the body of the request to be returned to the web client.
  prefs: []
  type: TYPE_NORMAL
- en: '2.   Copy the project from Exercise 1 and progressively turn it into a two-page
    website by doing the following:'
  prefs: []
  type: TYPE_NORMAL
- en: a.   Separate the core of the HTML structure into a *base.xhtml.twig* template,
    and then refactor *hello.xhtml.twig* to extend this base template and override
    its body block with the “hello” message.
  prefs: []
  type: TYPE_NORMAL
- en: b.   Create a second page template, *privacy.xhtml.twig*, that also extends
    the base template and displays the sentence *This website stores zero cookies
    and so does not affect your browsing privacy in any way.*
  prefs: []
  type: TYPE_NORMAL
- en: c.   Add a footer to the *hello.xhtml.twig* template containing the text Privacy
    Policy and linking to URL */?action=privacy.*
  prefs: []
  type: TYPE_NORMAL
- en: d.   Add a privacy() method to the Application class. This method should display
    the *privacy.xhtml.twig* template.
  prefs: []
  type: TYPE_NORMAL
- en: e.   Update the logic in the run() method of the Application class so that the
    value of the URL-encoded action variable (if found) is stored in the $action variable.
    Then add a switch statement that invokes the privacy() method if the value of
    $action is privacy, or otherwise invokes the hello() method.
  prefs: []
  type: TYPE_NORMAL
- en: 3.   Create an object-oriented, inheritance-based, Twig-templated, three-page
    website, with a home page, a staff details page, and a privacy policy page. Include
    Bootstrap CSS and a three-item navigation bar, where the navigation bar item for
    the page being displayed is highlighted using the active CSS class. The staff
    details page should use a Twig for loop to display an HTML table of three staff
    members, from a provided array of Staff objects. The Staff class should have name
    and jobTitle properties.
  prefs: []
  type: TYPE_NORMAL
