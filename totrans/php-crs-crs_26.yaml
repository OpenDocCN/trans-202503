- en: <hgroup>
  id: totrans-0
  prefs: []
  type: TYPE_NORMAL
  zh: <hgroup>
- en: 21 EFFICIENT TEMPLATE DESIGN WITH TWIG
  id: totrans-1
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 21 使用 Twig 进行高效模板设计
- en: </hgroup>
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: </hgroup>
- en: '![](../images/opener.jpg)'
  id: totrans-3
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/opener.jpg)'
- en: This chapter introduces the free, open source Twig templating library, a third-party
    package that applies object-oriented principles such as inheritance to page display
    templates. This mix of templating with OOP streamlines the process of designing
    web applications. We’ll explore the basics of using Twig, then use it to progressively
    build a multipage website.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章介绍了免费的开源 Twig 模板库，这是一个应用面向对象原则（如继承）来处理页面展示模板的第三方软件包。模板与面向对象编程（OOP）的结合简化了 Web
    应用程序的设计过程。我们将首先学习使用 Twig 的基础知识，然后利用它逐步构建一个多页面的网站。
- en: This chapter also offers a first look at how the object-oriented style of programming
    influences the web application architecture we arrived at in [Part III](part3.xhtml).
    For example, rather than writing functions that implement the logic of a front
    controller, we’ll create object-oriented classes containing front-controller methods.
    We’ll refine our approach to object-oriented application development in [Chapter
    22](chapter22.xhtml) as we further develop this chapter’s multipage site.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 本章还首次展示了面向对象编程风格如何影响我们在[第三部分](part3.xhtml)中得到的 Web 应用架构。例如，我们不再编写实现前端控制器逻辑的函数，而是创建包含前端控制器方法的面向对象类。随着我们进一步开发本章的多页面网站，面向对象的应用开发方法将在[第
    22 章](chapter22.xhtml)中得到进一步完善。
- en: '### The Twig Templating Library'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: '### Twig 模板库'
- en: Web templating systems like the Twig library (which can be found at *[https://twig.symfony.com](https://twig.symfony.com)*)
    manage the duplication that’s common in web application outputs by distinguishing
    between unchanging content and content that may change upon each request. This
    makes developing the view element of a web application’s MVC architecture much
    more efficient. As we’ve discussed in previous chapters, a lot of basic HTML is
    often duplicated across the template scripts for each page of a website, since
    the multiple pages typically share elements such as a header and a navigation
    bar. When we created a three-page website in [Chapter 13](chapter13.xhtml), for
    example, most of the code in the template file for each page was redundant HTML;
    barely any code was unique to the page at hand.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 类似 Twig 库这样的 Web 模板系统（可以在 *[https://twig.symfony.com](https://twig.symfony.com)*
    找到）通过区分不变内容和可能在每次请求时发生变化的内容，管理了 Web 应用程序输出中常见的重复内容。这使得开发 Web 应用程序的 MVC 架构中的视图部分变得更加高效。正如我们在前几章中讨论的那样，许多基础的
    HTML 往往会在每个页面的模板脚本中重复，因为多个页面通常共享如页眉和导航栏等元素。例如，在[第 13 章](chapter13.xhtml)中创建的三页网站中，每个页面模板文件中的大部分代码都是重复的
    HTML；几乎没有任何代码是特定于当前页面的。
- en: Duplicating so much HTML across multiple templates causes two issues. First,
    if you need to change an aspect of the website design (for example, the look and
    feel of the navigation bar, or a special header or footer), you’d have to edit
    *every* page template, which for a large website could be tens, hundreds, or even
    thousands of files. Second, when editing the content or behavior of a page template,
    spotting the content that’s specific to the current page can be difficult when
    it’s hidden within a bunch of generic code. You want to be able to focus on just
    the content for the particular page you’re editing.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在多个模板中复制大量 HTML 会导致两个问题。首先，如果需要更改网站设计的某个方面（例如导航栏的外观和感觉，或者特殊的页眉或页脚），你必须编辑*每一个*页面模板，对于一个大型网站来说，这可能涉及到几十、几百甚至几千个文件。其次，在编辑页面模板的内容或行为时，当内容被隐藏在大量通用代码中时，识别出当前页面特有的内容会变得非常困难。你希望能够专注于编辑特定页面的内容。
- en: One solution is to separate the common parts of a page into sub-templates for
    the header, navigation, footer, and so on. This is what we did in [Chapter 15](chapter15.xhtml),
    for example, when we created a *templates/_header.php* file containing header
    elements common to all the pages in our shopping cart website. A more elegant
    solution, however, is to use a dedicated PHP templating library, especially one
    such as Twig that supports template inheritance. As you’ll see, a key advantage
    of template inheritance is that after we’ve declared that a template for a particular
    page inherits from a parent template, the only content in the child page is that
    for the child page itself; we don’t have to write require statements for standard
    page headers, footers, navigation bars, and so on. This way, each child template
    contains fewer distractions away from the page it represents.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 一种解决方案是将网页的公共部分分离成子模板，例如头部、导航、页脚等。例如，在[第 15 章](chapter15.xhtml)中，我们创建了一个 *templates/_header.php*
    文件，其中包含了我们购物车网站中所有页面共有的头部元素。然而，一个更优雅的解决方案是使用专门的 PHP 模板库，特别是像 Twig 这样的支持模板继承的库。正如你所看到的，模板继承的一个关键优势是，在我们声明某个页面的模板继承自父模板之后，子页面中唯一的内容就是该页面本身的内容；我们不需要为标准的页面头部、页脚、导航栏等编写
    require 语句。这样，每个子模板就能专注于其代表的页面，避免了多余的干扰。
- en: Another advantage of templating libraries is that they limit the behavior that
    can be encoded into a page template by removing any PHP code from the template
    itself. If you’re working on a website as part of a team, these limitations mean
    you can safely have other members of the team (such as a marketing department)
    edit the page templates to refine the website’s look and feel, secure in the knowledge
    that they can’t accidentally copy in PHP code that would break the website or
    create a security vulnerability. After all, template files are the view component
    of an MVC architecture, so they should only be “decorating” provided data with
    tags in a markup language like HTML.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 模板库的另一个优势是，它们通过将 PHP 代码从模板中移除，限制了可以在页面模板中编码的行为。如果你在一个团队中工作，这些限制意味着你可以安全地让团队中的其他成员（比如营销部门）编辑页面模板，以完善网站的外观和感觉，且可以放心他们不会不小心插入可能导致网站崩溃或产生安全漏洞的
    PHP 代码。毕竟，模板文件是 MVC 架构中的视图组件，因此它们只应使用类似 HTML 这样的标记语言，通过标签来“装饰”提供的数据。
- en: '#### How Twig Works'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: '#### Twig 工作原理'
- en: Before we create anything with Twig, let’s explore the basic files, objects,
    and methods involved when working with Twig templates. When using Twig in our
    code, we work with an object of the Twig\Environment class. This object is responsible
    for generating the HTML for a web page, based on a template file and any data
    needed to customize the contents of the page. It does this through its render()
    method. Usually, you store a reference to the Twig\Environment object in a variable
    called twig, which is itself a property of a general Application class that encapsulates
    all the high-level logic for the web application.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们使用 Twig 创建任何内容之前，让我们先了解在使用 Twig 模板时涉及的基本文件、对象和方法。当在代码中使用 Twig 时，我们会操作一个 Twig\Environment
    类的对象。这个对象负责根据模板文件和任何需要的数据显示来生成网页的 HTML 内容。它通过其 render() 方法来实现这一点。通常，你会将 Twig\Environment
    对象的引用存储在一个名为 twig 的变量中，而这个变量本身是一个通用应用程序类的属性，该类封装了所有与网页应用程序相关的高级逻辑。
- en: The render() method requires two parameters. The first is a string containing
    the path to the desired template file. This string is typically stored in a variable
    called $template. The second parameter is an array of variables that need to be
    provided to the template to customize the page’s content. This array is typically
    stored in a variable called $args, since the array is essentially providing arguments
    to the template. The string keys in the array should correspond to the names of
    any variables used in the Twig template. If no values need to be provided to the
    template, $args will be an empty array.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: render() 方法需要两个参数。第一个是一个包含所需模板文件路径的字符串。这个字符串通常存储在一个名为 $template 的变量中。第二个参数是一个数组，包含需要提供给模板的变量，用以定制页面的内容。这个数组通常存储在一个名为
    $args 的变量中，因为该数组本质上是在向模板提供参数。数组中的字符串键应该对应于 Twig 模板中使用的任何变量的名称。如果模板不需要任何值，$args
    将是一个空数组。
- en: To illustrate, say you wanted to display a page showing the items in a shopping
    cart. The template for this page would be in a file that is called *shoppingCart.xhtml.twig*
    (by convention, Twig template files that output HTML are named in the form *<pageName>.xhtml.twig*),
    and it would have a products variable standing in for whatever products are in
    the user’s cart (variables in Twig templates don’t start with dollar signs).
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 举个例子，假设你想显示一个显示购物车中商品的页面。这个页面的模板文件叫做*shoppingCart.xhtml.twig*（按照约定，输出HTML的Twig模板文件的命名形式为*<pageName>.xhtml.twig*），模板中会有一个products变量，代表用户购物车中的所有商品（Twig模板中的变量不以美元符号开头）。
- en: You would pass the template filepath as the first argument to the Twig\Environment
    class’s render() method. The second argument would be an $args array containing
    a 'products' key (the same name as the variable in the template) whose value is
    an array of Product objects. The render() method would then return a string containing
    the HTML for a web page listing all the products as a nice shopping cart, with
    subtotals, the grand total, links to remove items or change their quantities,
    and so on. This string could then be printed to the output buffer that would become
    the body of the HTTP response being returned to the web client.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要将模板文件路径作为第一个参数传递给Twig\Environment类的render()方法。第二个参数将是一个包含'products'键（与模板中变量的名称相同）的$arg数组，该键的值是一个Product对象的数组。然后，render()方法将返回一个包含网页HTML的字符串，网页上列出了所有产品，呈现为一个漂亮的购物车，带有小计、总计、删除商品或更改数量的链接等等。这个字符串可以被打印到输出缓冲区，作为返回给Web客户端的HTTP响应体的一部分。
- en: If a web application uses Twig templating, every method that returns HTML response
    text will contain something similar to the code shown in [Listing 21-1](#lis21-1).
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个Web应用程序使用Twig模板，每个返回HTML响应文本的方法都会包含类似[示例21-1](#lis21-1)中的代码。
- en: '[PRE0]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Listing 21-1: The typical code to create and print HTML from a Twig template'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 示例21-1：从Twig模板创建并打印HTML的典型代码
- en: We store the path to a template in the $template variable, then build up the
    $args array with the required template variables. We pass these variables to the
    render() method. Remember, we typically store a reference to the Twig\Environment
    object that owns the render() method in the twig property of an overarching Application
    class. This is why the call to the method is written as $this->twig->render()
    rather than $twig->render(). We store the resulting string in $html, which we
    print. Soon you’ll see this code pattern in context as we use Twig to create a
    basic web page.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将模板路径存储在$template变量中，然后使用所需的模板变量构建$args数组。我们将这些变量传递给render()方法。记住，通常我们会在一个顶层的Application类中存储对拥有render()方法的Twig\Environment对象的引用，这就是为什么调用该方法时写作$this->twig->render()而不是$twig->render()。我们将返回的字符串存储在$html中，然后打印它。很快，你会在实际应用中看到这种代码模式，因为我们使用Twig创建一个基本的网页。
- en: A Simple Example
  id: totrans-20
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 一个简单的示例
- en: In this section, we’ll use Twig to create a simple “Hello, world!” web page
    that displays a greeting. Thanks to Twig, we’ll be able to customize the greeting
    by filling in a name for the person being greeted, based on the value of a PHP
    variable. In addition to illustrating the basics of working with Twig, this project
    will also offer a first glimpse at how an object-oriented web application is structured.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将使用Twig创建一个简单的“Hello, world！”网页，显示一个问候信息。通过Twig，我们将能够根据PHP变量的值定制问候语，填入被问候的人的名字。除了演示使用Twig的基本操作，这个项目还将首次展示一个面向对象的Web应用程序是如何结构化的。
- en: To create our basic greeting page, we’ll start by setting up Twig. Then we’ll
    write a Twig template featuring a name variable, as well as the PHP scripts needed
    to make the template work.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 为了创建我们的基本问候页面，我们首先要设置Twig。接着，我们将编写一个包含姓名变量的Twig模板，并编写必要的PHP脚本使模板能够正常工作。
- en: Adding Twig to the Project
  id: totrans-23
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 将Twig添加到项目中
- en: 'The easiest way to add Twig to a project is to use Composer. Create a new empty
    folder for the project and then enter the following at the command line:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 将Twig添加到项目中最简单的方法是使用Composer。为项目创建一个新的空文件夹，然后在命令行中输入以下内容：
- en: '[PRE1]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: This command triggers Composer to install the latest version of the Twig package
    into the project’s *vendor* folder (the folder will be created, since the project
    doesn’t already have one). The command also installs any additional dependencies
    that Twig requires, such as symfony/polyfill -mbstring and symfony/polyfill-ctype.
    If you look at the contents of the *vendor* folder after installation has finished,
    you should see that folders for these packages have been created. You can even
    look in each package’s *src* folder and examine each class and configuration file
    in the package.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令触发 Composer 将 Twig 包的最新版本安装到项目的*vendor*文件夹中（该文件夹将被创建，因为项目尚未包含此文件夹）。该命令还会安装
    Twig 所需的任何额外依赖项，如 symfony/polyfill-mbstring 和 symfony/polyfill-ctype。如果你查看安装完成后的*vendor*文件夹内容，你应该能看到这些包的文件夹已经被创建。你甚至可以查看每个包的*src*文件夹，检查包中的每个类和配置文件。
- en: Now that the Twig package has been copied into our project folder, we can add
    use statements in our classes to create and exploit the features of the library
    in our project.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 现在 Twig 包已经被复制到我们的项目文件夹中，我们可以在类中添加 use 语句，以便在项目中创建并利用该库的功能。
- en: Writing the Twig Template
  id: totrans-28
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 编写 Twig 模板
- en: By convention, Twig template files are stored in a *templates* folder, just
    like the PHP template files we’ve written in earlier chapters. Add this folder
    to your project directory, then create a *hello.xhtml.twig* template in that folder
    and enter the contents of [Listing 21-2](#lis21-2).
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 根据约定，Twig 模板文件存储在*templates*文件夹中，就像我们在前面的章节中编写的 PHP 模板文件一样。将此文件夹添加到项目目录中，然后在该文件夹中创建一个*hello.xhtml.twig*模板，并输入[Listing
    21-2](#lis21-2)的内容。
- en: '[PRE2]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Listing 21-2: The hello.xhtml.twig template to create an HTML greeting around
    the name variable'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: Listing 21-2：创建围绕 name 变量的 HTML 问候语的 hello.xhtml.twig 模板
- en: Like many web templating languages, Twig templates use double curly brackets
    to indicate a value that should be filled in, such as {{name}} in this template
    ❶. This declares that the value of a Twig variable called name is to be inserted
    here when the render() method generates its HTML output string. In the PHP script
    invoking this template, we’ll need to pass Twig a value for the variable in the
    $args array, under a key of the same name. For example, if we declared the $args
    array as ['name' => 'Matt'], the render() method would produce the HTML shown
    in [Listing 21-3](#lis21-3), with Matt (shown here in bold) inserted in place
    of the name variable.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 和许多网页模板语言一样，Twig 模板使用双大括号来表示应该填写的值，例如此模板中的 {{name}} ❶。这声明了一个名为 name 的 Twig 变量的值将在
    render() 方法生成 HTML 输出字符串时插入到此处。在调用此模板的 PHP 脚本中，我们需要通过 $args 数组为该变量传递一个值，并使用相同名称的键。例如，如果我们将
    $args 数组声明为 ['name' => 'Matt']，则 render() 方法会生成[Listing 21-3](#lis21-3)中显示的 HTML，将
    Matt（这里以粗体显示）插入 name 变量的位置。
- en: '[PRE3]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Listing 21-3: The HTML rendered by the Twig template when name contains ''Matt'''
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: Listing 21-3：当 name 包含 'Matt' 时，Twig 模板渲染的 HTML
- en: We see Matt has been inserted into the line saying hello in the HTML text output
    ❶.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 我们看到 Matt 已经被插入到 HTML 文本输出中说 hello 的那一行 ❶。
- en: Twig’s double curly brackets are similar to the PHP <?= short echo tag, in that
    both set off expressions that evaluate to strings and will be inserted into the
    output HTML. (Just as with PHP, Twig has other tags for setting off logic, such
    as loops and conditionals, rather than string output statements.) However, since
    Twig templates can’t contain PHP statements, using Twig double curly brackets
    instead of PHP short echo tags protects a website from PHP security vulnerabilities
    in the site’s templates.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: Twig 的双大括号类似于 PHP 的 <?= 短 echo 标签，因为它们都标识了需要插入到输出 HTML 中的字符串表达式。（就像 PHP 一样，Twig
    还有其他标签用于标识逻辑代码，如循环和条件语句，而不是字符串输出语句。）然而，由于 Twig 模板不能包含 PHP 语句，使用 Twig 的双大括号而非 PHP
    短 echo 标签，可以保护网站的模板免受 PHP 安全漏洞的影响。
- en: Creating the Application Class
  id: totrans-37
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 创建应用程序类
- en: Let’s now write an Application class for our greeting page. It will set up the
    Twig\Environment object in its constructor method and have a run() method to set
    variables and generate the page’s HTML via Twig. All object-oriented MVC web applications
    have something like this Application class to perform any setup and initializations
    required, and then to execute the main logic for handling requests to the application.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们为问候页面编写一个 Application 类。它将在构造方法中设置 Twig\Environment 对象，并拥有一个 run() 方法，用于设置变量并通过
    Twig 生成页面的 HTML。所有面向对象的 MVC 网页应用程序都有类似的 Application 类来执行任何所需的设置和初始化，然后执行处理应用程序请求的主要逻辑。
- en: For now, the class will always output the same HTML, but later in the chapter,
    we’ll see some logic in the class’s run() method to output different HTML content
    depending on variables received in the request to the server. To declare the class,
    create *src/Application.php* containing the code in [Listing 21-4](#lis21-4).
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，类始终输出相同的HTML，但在本章稍后，我们将在类的run()方法中看到一些逻辑，以根据请求中接收到的变量输出不同的HTML内容。要声明该类，请创建*src/Application.php*，其中包含[示例21-4](#lis21-4)中的代码。
- en: '[PRE4]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Listing 21-4: The class src/Application.php to create a Twig object and a method
    to output HTML'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 示例21-4：类src/Application.php，用于创建一个Twig对象并输出HTML的方法
- en: We declare the Application class as part of the Mattsmithdev namespace and include
    two use statements, since we’ll need to create objects of classes from the Twig
    namespace in the constructor. Then we declare a constant named PATH_TO_TEMPLATES
    holding the path to the base *templates* directory where all the templates are
    saved. We also declare a private twig property, which will be a reference to a
    Twig\Environment object.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将Application类声明为Mattsmithdev命名空间的一部分，并包含两个use语句，因为我们需要在构造方法中创建来自Twig命名空间的类的对象。接着，我们声明一个名为PATH_TO_TEMPLATES的常量，它保存着所有模板文件所在的基础*templates*目录的路径。我们还声明了一个私有的twig属性，它将是指向Twig\Environment对象的引用。
- en: Next, we declare the class’s constructor method. Within it, we create two Twig-related
    objects, FilesystemLoader and Environment. The latter holds the all-important
    render() method, while the former helps the Environment object access the template
    files. The FilesystemLoader object is created only temporarily, since its reference,
    stored in the $loader variable, exists only within the scope of the constructor.
    When we create the Environment object (using $loader), we store a reference to
    it in the Application object’s twig property ❶, which all our Application methods
    can access when $this->twig is written.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们声明类的构造方法。在构造方法中，我们创建了两个与Twig相关的对象，FilesystemLoader和Environment。后者包含了至关重要的render()方法，而前者则帮助Environment对象访问模板文件。FilesystemLoader对象只在临时作用域内创建，因为它的引用存储在$loader变量中，只在构造方法的作用域内有效。当我们创建Environment对象（使用$loader时），我们将其引用存储在Application对象的twig属性中
    ❶，以便所有Application方法都能通过写入$this->twig来访问它。
- en: 'Notice that when we create the FilesystemLoader object by using the PATH_TO_TEMPLATES
    constant, we must add self:: before the constant identifier. As we’ll discuss
    in [Chapter 25](chapter25.xhtml), this prefix is necessary when referencing a
    constant declared in the same class. This is because PHP doesn’t create a copy
    of the constant for each object of the class. Instead, there’s just one constant
    for all objects of the class, so writing $this->PATH_TO_TEMPLATES isn’t valid.'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，当我们通过使用PATH_TO_TEMPLATES常量来创建FilesystemLoader对象时，必须在常量标识符前加上self::。正如我们将在[第25章](chapter25.xhtml)中讨论的那样，在引用同一类中声明的常量时，这个前缀是必要的。这是因为PHP并不会为每个类的对象创建常量的副本。相反，所有类的对象共享一个常量，因此写$
    this->PATH_TO_TEMPLATES是不合法的。
- en: We next declare the Application class’s run() method. In it, we define the $name
    variable containing the name of the person we want to greet. Then we create the
    $template variable, which holds the name of our template file (*hello.xhtml.twig*),
    and the $args variable, an array with a single element holding the value of the
    $name variable under the 'name' key. As we’ve discussed, this key corresponds
    to the Twig variable enclosed in double curly brackets in our template file. Still
    within the run() method, we then invoke the render() method of our Twig object,
    storing the string it returns in the $html variable ❷. Finally, we print the content
    of $html, which becomes the HTML body of the response returned to the web client.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们声明Application类的run()方法。在该方法中，我们定义了一个$name变量，用来保存我们想要问候的人的名字。然后我们创建了一个$template变量，它保存了我们的模板文件的名字（*hello.xhtml.twig*），以及一个$args变量，它是一个数组，包含一个元素，该元素在'name'键下保存了$name变量的值。正如我们所讨论的，这个键对应着模板文件中被双大括号包围的Twig变量。在run()方法中，我们接着调用了Twig对象的render()方法，将返回的字符串存储在$html变量中
    ❷。最后，我们打印出$html的内容，它将作为响应的HTML主体返回给Web客户端。
- en: Creating the Autoloader
  id: totrans-46
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 创建自动加载器
- en: Let’s now get Composer to create the autoloader for Mattsmithdev namespaced
    classes located in the *src* directory (such as our Application class). To do
    this, we need to add an "autoload" property to *composer.json* in the top-level
    directory for the project. This file was created automatically when we used Composer
    to add the Twig package to the project, and it should already contain a "require"
    property with information about Twig. Update the file as shown in [Listing 21-5](#lis21-5).
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们让 Composer 为位于 *src* 目录中的 Mattsmithdev 命名空间类（例如我们的 Application 类）创建自动加载器。为此，我们需要在项目的顶级目录中的
    *composer.json* 文件中添加一个 "autoload" 属性。当我们使用 Composer 将 Twig 包添加到项目中时，这个文件会自动创建，并且它应该已经包含有关
    Twig 的 "require" 属性。按照 [Listing 21-5](#lis21-5) 中的内容更新此文件。
- en: '[PRE5]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Listing 21-5: Updating composer.json for class autoloading'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: Listing 21-5：更新 composer.json 以支持类的自动加载
- en: We add an "autoload" property, declaring that Mattsmithdev namespaced classes
    are PSR-4 compliant and can be found in the *src* directory. Don’t forget the
    comma after the closing curly bracket ❶; you’ll get a JSON syntax error if this
    comma is missing.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 我们添加了一个 "autoload" 属性，声明 Mattsmithdev 命名空间的类符合 PSR-4 规范，并可以在 *src* 目录中找到。别忘了在关闭的大括号后加上逗号
    ❶；如果缺少这个逗号，你将会遇到 JSON 语法错误。
- en: 'Once you’ve updated *composer.json*, enter the following at the command line:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你更新了 *composer.json*，在命令行中输入以下内容：
- en: '[PRE6]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: This instructs Composer to generate the necessary autoload scripts in the *vendor*
    folder.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 这指示 Composer 在 *vendor* 文件夹中生成必要的自动加载脚本。
- en: Adding the Index Script
  id: totrans-54
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 添加索引脚本
- en: The final step required to get our greeting page up and running is to create
    a simple index script that will read in the autoloader, create an Application
    object, and invoke its run() method. All our object-oriented web applications
    will have a simple index script like this, since all the work is being performed
    by the Application object. Create *public/index.php* as shown in [Listing 21-6](#lis21-6).
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 启动我们的问候页面的最后一步是创建一个简单的索引脚本，它将加载自动加载器，创建一个 Application 对象，并调用其 run() 方法。我们所有面向对象的
    Web 应用程序都会有一个像这样的简单索引脚本，因为所有的工作都由 Application 对象执行。创建 *public/index.php*，如 [Listing
    21-6](#lis21-6) 所示。
- en: '[PRE7]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Listing 21-6: The index.php script'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: Listing 21-6：index.php 脚本
- en: We first read in and execute the generated autoloader script. Note that the
    autoloader created by Composer will load any class declared in the Mattsmithdev
    namespace, as well as any classes in third-party libraries that Composer has added
    to the project (such as Twig). Next, we add a use statement so we can refer to
    the Application class without specifying the namespace each time. Then we create
    an Application object and invoke its run() method.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先读取并执行生成的自动加载脚本。注意，Composer 创建的自动加载器将加载 Mattsmithdev 命名空间中声明的任何类，以及 Composer
    添加到项目中的第三方库中的任何类（例如 Twig）。接下来，我们添加一个 use 语句，以便我们可以在不每次指定命名空间的情况下引用 Application
    类。然后，我们创建一个 Application 对象并调用其 run() 方法。
- en: If you run the PHP web server and visit the project home page, you should see
    something like [Figure 21-1](#fig21-1). Also shown in the figure is the HTML source
    of the response that the web client receives. Notice that the HTML and the resulting
    web page both have the name *Matt* filled in at the location of the Twig {{name}}
    variable.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你运行 PHP Web 服务器并访问项目主页，你应该看到类似于 [Figure 21-1](#fig21-1) 的内容。图中还显示了 Web 客户端收到的响应的
    HTML 源代码。注意，HTML 和生成的网页中，Twig {{name}} 变量的位置都填充了 *Matt*。
- en: '![](../images/figure21-1.jpg)'
  id: totrans-60
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/figure21-1.jpg)'
- en: 'Figure 21-1: The web output, with HTML source, for our basic Twig project'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 图 21-1：我们的基本 Twig 项目的 Web 输出，包含 HTML 源代码
- en: This might have seemed like *a lot* of work for a simple “Hello, world!” website,
    but we’ve now created all the structure required for any project that uses the
    powerful Twig templating system. Before we apply that structure to a more substantial
    website, let’s explore a few more useful features of the Twig package.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能看起来对于一个简单的“Hello, world!”网站来说是 *很多* 工作，但我们现在已经创建了任何使用强大 Twig 模板系统的项目所需的所有结构。在将这些结构应用到一个更大的网站之前，让我们先探索一些
    Twig 包的其他有用功能。
- en: Manipulating Objects and Arrays in Twig Templates
  id: totrans-63
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在 Twig 模板中操作对象和数组
- en: In addition to simple data types like strings, Twig templates can work with
    PHP objects, arrays, and so on. However, the notation is a bit different from
    what we’re used to in PHP, since Twig uses *dot notation* to access a property
    or method of an object, or an element in an array. For example, while you’d write
    $product->price in PHP to access the price property of a Product object, you’d
    use {{product.price}} to do the same in a Twig template. Conveniently, this works
    whether the property is public or private, provided that if it’s private, the
    property has a public getter method that follows the usual getPropertyName() or
    isBooleanPropertyName() naming convention. For example, {{product.price}} would
    still successfully access an object’s private price property as long as the object
    has a public getPrice() method. You don’t need to reference the getPrice() method
    explicitly in the Twig template, since Twig calls the method for you.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 除了像字符串这样的简单数据类型，Twig 模板还可以与 PHP 对象、数组等一起使用。然而，语法与我们在 PHP 中习惯的有所不同，因为 Twig 使用*点表示法*来访问对象的属性或方法，或者访问数组中的元素。例如，在
    PHP 中，你会写 `$product->price` 来访问 Product 对象的 price 属性，而在 Twig 模板中，你需要写 {{product.price}}
    来实现相同的操作。方便的是，无论属性是公共的还是私有的，这种方式都有效，前提是如果属性是私有的，必须有一个公共的 getter 方法，且该方法遵循通常的命名规则，如
    getPropertyName() 或 isBooleanPropertyName()。例如，{{product.price}} 仍然可以成功访问对象的私有
    price 属性，只要该对象有一个公共的 getPrice() 方法。你不需要在 Twig 模板中显式引用 getPrice() 方法，因为 Twig 会自动调用该方法。
- en: To illustrate how Twig templates work with these more complex data types, we’ll
    update our “Hello, world!” web page to display information obtained from a PHP
    object and array. First, we’ll need to write a class so we can create an object
    and pass it to the Twig template. [Listing 21-7](#lis21-7) shows a simple Product
    class that we can use as an example. Create *src/Product.php* and enter the contents
    of the listing.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 为了说明 Twig 模板如何与这些更复杂的数据类型一起工作，我们将更新我们的 "Hello, world!" 网页，以展示从 PHP 对象和数组中获取的信息。首先，我们需要编写一个类，以便可以创建一个对象并将其传递给
    Twig 模板。[列表 21-7](#lis21-7) 显示了一个简单的 Product 类，我们可以将其用作示例。创建 *src/Product.php*
    并输入列表中的内容。
- en: '[PRE8]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Listing 21-7: A simple Product class to use in the Twig demo'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 21-7：在 Twig 演示中使用的简单 Product 类
- en: 'The class has two private properties: description and price. The code also
    has public getter and setter methods for each of these properties, as well as
    a __toString() method that generates a string summary of the object.'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 该类有两个私有属性：description 和 price。代码还为这些属性提供了公共的 getter 和 setter 方法，以及一个 __toString()
    方法，用于生成对象的字符串摘要。
- en: Next, we’ll modify the run() method of our Application class. The new method
    will create an array and a Product object and pass them along to the Twig template,
    along with the original name variable. Update *src/Application.php* to match the
    contents of [Listing 21-8](#lis21-8).
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将修改 Application 类的 run() 方法。新的方法将创建一个数组和一个 Product 对象，并将它们连同原始的 name 变量一起传递给
    Twig 模板。更新 *src/Application.php* 以匹配[列表 21-8](#lis21-8)中的内容。
- en: '[PRE9]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Listing 21-8: The updated Application class passing an object and an array
    to the template'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 21-8：更新后的 Application 类，将对象和数组传递给模板
- en: 'We create a $meals array with the keys ''breakfast'', ''lunch'', and ''dinner'',
    along with a Product object with the description ''bag of nails'' and the price
    10.99. Then we declare the $template and $args variables required for the render()
    method. In $args, we pass values for three variables in the Twig template: name,
    meals, and product. This time we declare the value for the ''name'' key directly
    in the array rather than as a separate variable.'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了一个包含键 'breakfast'、'lunch' 和 'dinner' 的 $meals 数组，以及一个描述为 'bag of nails'
    且价格为 10.99 的 Product 对象。接着我们声明了 render() 方法所需的 $template 和 $args 变量。在 $args 中，我们为
    Twig 模板中的三个变量：name、meals 和 product 传递了值。这次我们直接在数组中声明 'name' 键的值，而不是将其作为单独的变量声明。
- en: Notice that we declare the Twig template to be *demo.xhtml.twig* rather than
    the *hello.xhtml.twig* template we created earlier ❶. We’ll create that new template
    now and design it to show off some of the ways Twig interacts with objects and
    arrays. Make a copy of *hello.xhtml.twig*, rename it *demo.xhtml.twig*, and update
    this new file to match [Listing 21-9](#lis21-9).
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们声明 Twig 模板为 *demo.xhtml.twig*，而不是之前创建的 *hello.xhtml.twig* 模板 ❶。我们现在将创建这个新模板，并设计它来展示
    Twig 如何与对象和数组进行交互。复制 *hello.xhtml.twig*，将其重命名为 *demo.xhtml.twig*，并更新该新文件以匹配[列表
    21-9](#lis21-9)。
- en: '[PRE10]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Listing 21-9: The demo.xhtml.twig template'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 21-9：demo.xhtml.twig 模板
- en: In the body of the template, we first print the value of the Twig name variable
    ❶. Then we print the value inside the meals array variable under the dinner key
    ❷. The Twig dot notation of {{meals.dinner}} here corresponds to the PHP expression
    $meals['dinner'].
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在模板的主体部分，我们首先打印Twig变量name的值 ❶。然后，我们打印meals数组变量中dinner键的值 ❷。这里的Twig点表示法{{meals.dinner}}对应PHP表达式$meals['dinner']。
- en: Next, we print the value returned from the getDescription() method of the product
    object variable ❸. In this case, the Twig dot notation of {{product.getDescription()}}
    corresponds to the PHP expression $product ->getDescription(). We also print the
    value of the object’s price property ❹. When Twig tries to access this price property,
    it will see that the property is private, so it will automatically attempt to
    invoke the object’s getPrice() accessor method instead. The Twig dot notation
    of {{product.price}} therefore corresponds to the PHP expression $product->getPrice().
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们打印产品对象变量 ❸的getDescription()方法返回的值。在这个例子中，Twig的点表示法{{product.getDescription()}}对应PHP表达式$product->getDescription()。我们还打印对象的price属性值
    ❹。当Twig尝试访问这个price属性时，它会发现该属性是私有的，因此它会自动尝试调用对象的getPrice()访问器方法。Twig的点表示法{{product.price}}因此对应PHP表达式$product->getPrice()。
- en: Finally, we place the Twig product variable inside double curly brackets without
    any dot notation ❺. When Twig sees that product is an object, it will automatically
    attempt to invoke its __toString() method. This is similar to PHP automatically
    invoking an object’s __toString() method when a reference to that object is used
    in a context where a string is expected. Essentially, {{product}} in Twig corresponds
    to print $product in PHP, which in turn corresponds to $product->__toString().
    [Figure 21-2](#fig21-2) shows how the HTML rendered from this template will appear
    in the browser.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将Twig产品变量放入双大括号中，不使用任何点表示法 ❺。当Twig看到product是一个对象时，它会自动尝试调用它的__toString()方法。这类似于PHP在预期字符串的上下文中使用对象引用时自动调用该对象的__toString()方法。本质上，Twig中的{{product}}对应于PHP中的print
    $product，进而对应于$product->__toString()。[图21-2](#fig21-2)展示了从这个模板渲染出的HTML在浏览器中的显示效果。
- en: '![](../images/figure21-2.jpg)'
  id: totrans-79
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/figure21-2.jpg)'
- en: 'Figure 21-2: A browser rendering of the HTML from the Twig demo template'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 图21-2：浏览器呈现的来自Twig演示模板的HTML
- en: As you can see, Twig has successfully filled in all the information from the
    object and array passed to the template. The annotations in the figure summarize
    the Twig notation used to access each piece of information, and the equivalent
    expressions in PHP.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，Twig成功地填充了所有从对象和数组传递到模板中的信息。图中的注释总结了用于访问每个信息的Twig表示法，以及在PHP中等效的表达式。
- en: Twig Control Structures
  id: totrans-82
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Twig控制结构
- en: Beyond printing individual values, the Twig templating language also offers
    several control structures, including if and for statements, allowing you to add
    conditional logic and looping to your Twig templates. This greatly expands the
    templates’ ability to adapt to whatever data they receive in the $args array.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 除了打印单个值，Twig模板语言还提供了若干控制结构，包括if和for语句，允许你向Twig模板添加条件逻辑和循环。这大大扩展了模板根据它们接收到的$args数组中的数据进行适应的能力。
- en: Twig control statements are written within single curly brackets and percent
    characters, such as {% if condition %} or {% for ... %}, and each control structure
    must conclude with a closing tag, such as {% endif %} or {% endfor %}.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: Twig控制语句是写在单个大括号和百分号字符内的，例如{% if condition %}或{% for ... %}，每个控制结构必须以结束标签结尾，例如{%
    endif %}或{% endfor %}。
- en: Twig can loop through all the values in an array with {% for value in array
    %}, much like a foreach loop in PHP. If you want the key and value for each array
    item, you could write {% for key, value in array %}. Let’s try that now by creating
    a Twig template that will loop through the items in the PHP $meals array we created
    in the preceding section. Update the Twig template *demo.xhtml.twig* as shown
    in [Listing 21-10](#lis21-10).
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: Twig可以使用{% for value in array %}来循环遍历数组中的所有值，类似于PHP中的foreach循环。如果你需要每个数组项的键和值，可以写成{%
    for key, value in array %}。现在，让我们尝试通过创建一个Twig模板，来遍历前面章节中创建的PHP $meals数组中的项。按照[列表21-10](#lis21-10)中的示例更新Twig模板*demo.xhtml.twig*。
- en: '[PRE11]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Listing 21-10: Looping through and outputting meals as an HTML list'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 列表21-10：循环输出meals作为HTML列表
- en: 'We declare a Twig for loop to iterate through the elements of the meals array
    ❶. The key and value of each element in the array will become part of a list item
    in an HTML unordered list and will be output as HTML in the form <li>meal: lunch
    = salad</li> ❷. Instead of having to write separate HTML for each item in the
    list, we simply write one item using the Twig variables key and value, and the
    for loop will generate all the items for us. The loop also includes a Twig else
    statement ❸, which is executed if the given array is empty. In that case, we output
    a message stating that no meals are in the list. The loop concludes with the closing
    endfor tag ❹. [Figure 21-3](#fig21-3) shows the web page that’s rendered when
    you serve this code with the web server.'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '我们声明一个Twig for循环来迭代餐点数组中的元素❶。数组中每个元素的键和值将成为HTML无序列表中的一个列表项，并以HTML形式输出，格式为<li>meal:
    lunch = salad</li>❷。我们无需为列表中的每一项编写单独的HTML代码，只需使用Twig变量的键和值编写一个项，for循环将为我们生成所有项。循环还包括一个Twig
    else语句❸，如果给定数组为空，则会执行该语句。在这种情况下，我们输出一条消息，说明列表中没有餐点。循环以闭合的endfor标签❹结束。[图21-3](#fig21-3)展示了当你使用Web服务器提供此代码时呈现的网页。'
- en: '![](../images/figure21-3.jpg)'
  id: totrans-89
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/figure21-3.jpg)'
- en: 'Figure 21-3: The web page and HTML source generated by the Twig for loop'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 图21-3：Twig for 循环生成的网页和HTML源代码
- en: The Twig for loop has successfully generated an HTML list by using the keys
    and values from the $meals array.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: Twig的for循环成功地使用$meals数组中的键和值生成了一个HTML列表。
- en: Creating a Multipage Website with Twig
  id: totrans-92
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用Twig创建多页面网站
- en: 'For the rest of this chapter, we’ll harness Twig templating to create a multipage
    website. In addition to demonstrating the value of Twig templating, building this
    site will illustrate how the front-controller structure we’ve used in previous
    chapters translates to an object-oriented web application. [Figure 21-4](#fig21-4)
    shows the site we’ll progressively develop: a simplified two-page version of the
    website we created in [Chapter 16](chapter16.xhtml), with the login page removed.'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的其余部分，我们将利用Twig模板引擎创建一个多页面网站。除了展示Twig模板引擎的价值外，构建这个网站还将展示我们在前几章使用的前端控制器结构是如何转化为面向对象的Web应用程序的。[图21-4](#fig21-4)展示了我们将逐步开发的网站：这是我们在[第16章](chapter16.xhtml)中创建的简化版两页网站，登录页面已被删除。
- en: '![](../images/figure21-4.jpg)'
  id: totrans-94
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/figure21-4.jpg)'
- en: 'Figure 21-4: A two-page website created with Twig templating'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 图21-4：使用Twig模板引擎创建的两页网站
- en: Our site will have a home page and a Contact Us page, with the same header and
    navigation links shared by the two pages. All the common HTML will be declared
    in a *base template* from which the page-specific content templates will inherit.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的网站将包括一个主页和一个联系我们页面，两个页面共享相同的头部和导航链接。所有公共的HTML都将在一个*基础模板*中声明，页面特定的内容模板将继承该模板。
- en: This means that each *page (child) template* will contain only the special content
    for that page. It also means that every page in the website can be changed simply
    by updating the base template (for example, if we wanted to add or change the
    navigation links, change the logo, or make the website background turn green for
    St. Patrick’s Day).
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着每个*页面（子）模板*将只包含该页面的特定内容。这还意味着网站中的每个页面都可以通过简单地更新基础模板来进行修改（例如，如果我们想要添加或更改导航链接、更改标志，或者在圣帕特里克节时将网站背景改为绿色）。
- en: The File Structure and Dependencies
  id: totrans-98
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 文件结构和依赖关系
- en: 'Let’s first establish the file structure for the application. Create a new
    project folder. Inside it, we’ll build the following directories and files:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们来建立应用程序的文件结构。创建一个新的项目文件夹。在其中，我们将构建以下目录和文件：
- en: '![](../images/pg409.jpg)'
  id: totrans-100
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/pg409.jpg)'
- en: 'Two files are exactly the same as the examples shown earlier in this chapter:
    *public/index.php* and *composer.json*. As you saw in [Listing 21-6](#lis21-6),
    the *index.php* script simply reads in the autoloader, creates an object of the
    Application class, and calls the class’s run() method. The *composer.json* file
    (Listing 21-5) provides information for the autoloader and about the project’s
    namespace (Mattsmithdev) as well as third-party library requirements (Twig). Copy
    these two files into the folder created for the project.'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 有两个文件与本章之前示例中的文件完全相同：*public/index.php*和*composer.json*。正如你在[清单21-6](#lis21-6)中看到的，*index.php*脚本仅仅读取自动加载器，创建一个Application类的对象，并调用该类的run()方法。*composer.json*文件（清单21-5）提供了自动加载器的信息以及项目的命名空间（Mattsmithdev）和第三方库要求（Twig）。将这两个文件复制到为项目创建的文件夹中。
- en: Also copy the *public/images/logo.png* image provided in the files accompanying
    this book at *[https://github.com/dr-matt-smith/php-crash-course](https://github.com/dr-matt-smith/php-crash-course)*
    (or use your own logo image). Finally, since we’ll be using the same namespace
    and Twig library as before, you can also copy the *vendor* folder to get the same
    autoloader and library files.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 同时，复制本书随附文件中的*public/images/logo.png*图片，位于*[https://github.com/dr-matt-smith/php-crash-course](https://github.com/dr-matt-smith/php-crash-course)*（或者使用你自己的logo图片）。最后，由于我们将使用与之前相同的命名空间和Twig库，你也可以复制*vendor*文件夹，以获得相同的自动加载器和库文件。
- en: The Application Class
  id: totrans-103
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: Application类
- en: 'The Application class for our project plays the role of a front controller:
    it determines which page of the website to display based on the URL-encoded navigation
    action. If the URL has no action variable, Application will display the home page.
    If Application finds an action variable with the value contact, it will display
    the Contact Us page.'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 我们项目中的Application类充当了前端控制器的角色：它根据URL编码的导航动作来决定显示网站的哪个页面。如果URL没有action变量，Application将显示主页。如果Application找到一个值为contact的action变量，它将显示“联系我们”页面。
- en: The Application class is also responsible for creating a Twig\Environment object
    to manage the Twig templates, and for this reason the first several lines of the
    Application class declaration are the same as they were for our “Hello, world!”
    project earlier in the chapter. Copy *src/Application.php* from the previous project
    and update it to match [Listing 21-11](#lis21-11).
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: Application类还负责创建一个Twig\Environment对象来管理Twig模板，因此，Application类声明的前几行与我们之前在本章“Hello,
    world！”项目中使用的相同。从之前的项目中复制*src/Application.php*文件，并更新它以匹配[清单21-11](#lis21-11)。
- en: '[PRE12]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Listing 21-11: The Application class for the two-page website'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 清单21-11：两页网站的Application类
- en: We first declare the run() method ❶, which takes the place of the front-controller
    code we’ve previously written in an *index.php* script. The method attempts to
    find a URL-encoded variable named action, then feeds its value to a typical front-controller
    switch statement. If the value is 'contact', the contactUs() method is invoked.
    Otherwise, the homepage() method is invoked.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先声明run()方法❶，它替代了我们之前在*index.php*脚本中编写的前端控制器代码。该方法尝试找到名为action的URL编码变量，然后将其值传递给一个典型的前端控制器switch语句。如果值为'contact'，则调用contactUs()方法。否则，调用homepage()方法。
- en: Next, we declare the homepage() method ❷. It prints the result of running the
    render() method of the twig property (which contains a reference to the Twig\Environment
    object). When we call render(), we pass in $template, which has a value of 'homepage.xhtml.twig',
    and pass in the $args array, which provides the Twig pageTitle variable with the
    value 'Home Page'.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们声明homepage()方法❷。它输出运行twig属性（其中包含Twig\Environment对象的引用）中的render()方法的结果。当我们调用render()时，我们传入$template，值为
    'homepage.xhtml.twig'，并传入$args数组，提供Twig的pageTitle变量，值为 'Home Page'。
- en: We also declare the contactUs() method for displaying the Contact Us page ❸.
    This method similarly calls render() and prints the result, this time passing
    in $template with a value of 'contactUs.xhtml.twig' and $args providing the Twig
    pageTitle variable with the 'Contact Us Page' value.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还声明了contactUs()方法，用于显示“联系我们”页面❸。该方法类似地调用render()并输出结果，这次传入$template，值为 'contactUs.xhtml.twig'，并传入$args，提供Twig的pageTitle变量，值为
    'Contact Us Page'。
- en: These two methods, homepage() and contactUs(), replace stand-alone helper functions
    that we earlier would have written in a *functions.php* file. In this way, our
    object-oriented application encapsulates all the display logic within the Application
    class.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个方法，homepage()和contactUs()，替代了我们之前在*functions.php*文件中编写的独立帮助函数。通过这种方式，我们的面向对象应用程序将所有显示逻辑封装在Application类中。
- en: The Twig Templates
  id: totrans-112
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: Twig模板
- en: Now all we have to do to complete our site is write the Twig template files
    for the two pages. We’ll start with the home page. Create *templates/homepage.xhtml.twig*
    containing the code in [Listing 21-12](#lis21-12).
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，完成我们网站的唯一任务就是为这两页编写Twig模板文件。我们从主页开始。创建*templates/homepage.xhtml.twig*，并在其中编写[清单21-12](#lis21-12)中的代码。
- en: '[PRE13]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Listing 21-12: The homepage.xhtml.twig template'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 清单21-12：homepage.xhtml.twig模板
- en: We declare the HTML title, outputting MGW followed by the contents of the Twig
    pageTitle variable ❶. Then we display the site logo image ❷. We next present a
    simple navigation list with links to the home page ❸ and the Contact Us page ❹.
    Then we use a <blockquote> element to present the website’s tagline and greeting
    ❺, followed by a level 1 heading that again uses the Twig pageTitle variable ❻.
    Finally, we declare the page-specific content; for this home page, it’s just a
    sentence in a paragraph ❼.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 我们声明 HTML 标题，输出 MGW，然后是 Twig pageTitle 变量的内容 ❶。接着显示站点 logo 图像 ❷。然后呈现一个简单的导航列表，包含链接到主页
    ❸ 和联系我们页面 ❹。接着使用 <blockquote> 元素展示网站的标语和问候语 ❺，随后是一个一级标题，重新使用 Twig pageTitle 变量
    ❻。最后，声明特定于页面的内容；对于这个主页，它只是一个段落中的一句话 ❼。
- en: Listing 21-13 shows the parts of the page that are different for the Contact
    Us Twig template. Copy *homepage.xhtml.twig*, name the copy *contactUs.xhtml.twig*,
    and edit this file to match this listing.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: Listing 21-13 显示了 Contact Us Twig 模板中不同的页面部分。复制 *homepage.xhtml.twig*，将副本命名为
    *contactUs.xhtml.twig*，并编辑此文件以匹配该列表。
- en: '[PRE14]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Listing 21-13: The contactUs.xhtml.twig template'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 'Listing 21-13: contactUs.xhtml.twig 模板'
- en: The only content of this template that differs from the home page is the paragraph
    and definition list at the end of the HTML body ❶. Thanks to the use of the Twig
    pageTitle variable, the rest of the template is identical. Twig will fill in the
    variable with Home Page or Contact Us Page as appropriate.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 这个模板唯一与主页不同的内容是在 HTML body 末尾的段落和定义列表 ❶。由于使用了 Twig 的 pageTitle 变量，其它部分模板完全相同。Twig
    会根据需要填充变量，主页或联系我们页面。
- en: At this point, the website has everything we need to display and navigate the
    two pages. If you run the project, you’ll see something like [Figure 21-5](#fig21-5).
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，网站已经具备了显示和导航这两页的所有内容。如果你运行项目，你会看到类似 [Figure 21-5](#fig21-5) 的内容。
- en: '![](../images/figure21-5.jpg)'
  id: totrans-122
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/figure21-5.jpg)'
- en: 'Figure 21-5: A simple two-page site built with Twig'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 'Figure 21-5: 使用 Twig 构建的简单两页网站'
- en: Notice that Twig has correctly filled in the value of the pageTitle variable
    for each page.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，Twig 已正确填写了每个页面的 pageTitle 变量的值。
- en: Twig Features to Improve Efficiency
  id: totrans-125
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: Twig 特性以提高效率
- en: Our two-page website now works as expected, but a lot of duplicated code remains
    in the two Twig template files. In this section, we’ll explore techniques for
    improving the efficiency of our templates, such as include statements and template
    inheritance. Features like these make Twig particularly useful for developing
    multipage web applications.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的两页网站现在按照预期工作，但两个 Twig 模板文件中仍然有很多重复的代码。在本节中，我们将探索提高模板效率的技术，例如 include 语句和模板继承。这些特性使得
    Twig 在开发多页 web 应用程序时特别有用。
- en: '##### include Statements'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '##### include 语句'
- en: As you’ve seen, pages in a website typically share much of the same HTML code.
    Twig include statements make it possible to create partial templates containing
    that shared code and add the rendered output from those partial templates to the
    actual page templates that need it. These include statements take the form {{include(templateName)}}.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，网站中的页面通常共享大部分相同的 HTML 代码。Twig 的 include 语句使得创建包含共享代码的部分模板成为可能，并将这些部分模板的渲染输出添加到需要它们的实际页面模板中。这些
    include 语句的格式是 {{include(templateName)}}。
- en: To demonstrate, we’ll take all the shared content at the top of each of our
    two page templates and put it in a common *_header.xhtml.twig* file. (Remember,
    it’s common to prefix partial templates like this with an underscore.) Then we’ll
    use include statements to add the partial template to the top of our page template
    files, which we’ll be able to shorten to contain just the content unique to each
    page.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 为了演示，我们将把每个页面模板顶部的所有共享内容放入一个公共的 *_header.xhtml.twig* 文件中。（记住，像这样的部分模板通常以下划线为前缀。）然后，我们将使用
    include 语句将这个部分模板添加到页面模板文件的顶部，这样我们就可以简化模板，只包含每个页面独有的内容。
- en: Create *templates/_header.xhtml.twig* and copy in the code from the top of one
    of the page template files, as shown in [Listing 21-14](#lis21-14).
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 创建 *templates/_header.xhtml.twig* 并将页面模板文件顶部的代码复制进去，如 [Listing 21-14](#lis21-14)
    所示。
- en: '[PRE15]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Listing 21-14: The partial _header.xhtml.twig template'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 'Listing 21-14: 部分 _header.xhtml.twig 模板'
- en: Everything up to and including the level 1 heading (again, using the Twig pageTitle
    variable) has been moved into this *_header.xhtml.twig* partial template. With
    that, we can greatly reduce the content in the home page and Contact Us templates.
    [Listing 21-15](#lis21-15) shows the updated home page Twig template, replacing
    all the duplicated content with a simple Twig include statement. Update *templates/homepage.xhtml.twig*
    to match the contents of this listing.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 从页面的第一级标题开始（同样使用 Twig 的 pageTitle 变量），所有内容都已被移入这个*header.xhtml.twig* 部分模板。这样，我们可以大大减少首页和“联系我们”模板中的内容。[列表
    21-15](#lis21-15) 显示了更新后的首页 Twig 模板，将所有重复的内容替换为简单的 Twig include 语句。按此列出的内容更新 *templates/homepage.xhtml.twig*。
- en: '[PRE16]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Listing 21-15: The simplified homepage.xhtml.twig template'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 21-15：简化版首页模板 homepage.xhtml.twig
- en: We begin with a the Twig include statement, {{include('_header.xhtml.twig')}},
    telling Twig to read in the partial template file *_header.xhtml.twig*. All that
    remains in the template is the page-specific content.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从 Twig include 语句 {{include('_header.xhtml.twig')}} 开始，告诉 Twig 读取部分模板文件 *_header.xhtml.twig*。模板中剩下的只是页面特定的内容。
- en: We can similarly remove the duplicated content from our Contact Us template.
    Update *templates/contactUs.xhtml.twig* as shown in [Listing 21-16](#lis21-16).
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以类似地从“联系我们”模板中移除重复内容。按[列表 21-16](#lis21-16)所示更新*templates/contactUs.xhtml.twig*。
- en: '[PRE17]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Listing 21-16: The simplified contactUs.xhtml.twig template'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 21-16：简化版联系我们模板 contactUs.xhtml.twig
- en: Once again, we’ve removed the duplicated content and replaced it with a Twig
    include statement. The page-specific content follows.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，我们移除了重复的内容，并将其替换为 Twig include 语句。接下来是页面特定的内容。
- en: 'Using Twig include statements, we’ve drastically simplified our individual
    page templates. However, notice that we still have the final </body> and </html>
    tags shared by both templates. In theory, we could relocate these to a partial
    *_footer.xhtml.twig* template. For a simple website, this could be a reasonable
    approach, but for more complex pages and larger websites, Twig offers an even
    more powerful feature for consolidating redundant content than include statements:
    template inheritance.'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Twig include 语句，我们已经大大简化了各个页面模板。然而，注意到我们仍然保留了在两个模板中共享的最终 </body> 和 </html>
    标签。理论上，我们可以将这些标签移动到一个部分模板 *_footer.xhtml.twig* 中。对于一个简单的网站，这可能是一个合理的做法，但对于更复杂的页面和大型网站，Twig
    提供了一个比 include 语句更强大的功能来合并冗余内容：模板继承。
- en: Template Inheritance
  id: totrans-142
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 模板继承
- en: '*Template inheritance* involves creating a *base template* with all the content
    shared by a group of web pages, then creating individual *child templates* that
    extend the base template by filling in or overriding just the content unique to
    a particular page. It’s much like the OOP technique of creating subclasses that
    inherit from, extend, and override certain behaviors of a superclass.'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '*模板继承* 是指创建一个*基础模板*，其中包含一组网页共享的所有内容，然后创建单独的*子模板*，通过填充或覆盖特定页面独有的内容来扩展基础模板。这就像面向对象编程中创建子类，继承、扩展并重写父类的某些行为。'
- en: The base template ensures that all website pages have all the required valid,
    well-formed HTML, including ending tags, freeing up the child templates to focus
    on their own page-specific content. As you’ll see, this inheritance approach is
    much neater than using include statements to incorporate partial templates.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 基础模板确保所有网站页面都具备所需的有效、格式正确的 HTML，包括结束标签，从而使子模板能够专注于其特定页面内容。如你所见，这种继承方法比使用 include
    语句来合并部分模板要简洁得多。
- en: To use template inheritance, we’ll first convert our *templates/_header.xhtml.twig*
    file into a base template that the other templates can inherit from and extend.
    Rename *_header.xhtml.twig* to *base.xhtml.twig* and edit it to match [Listing
    21-17](#lis21-17).
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使用模板继承，我们首先将 *templates/_header.xhtml.twig* 文件转换为其他模板可以继承并扩展的基础模板。将 *_header.xhtml.twig*
    重命名为 *base.xhtml.twig*，并按[列表 21-17](#lis21-17)所示进行编辑。
- en: '[PRE18]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Listing 21-17: The base.xhtml.twig template'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 21-17：基础模板 base.xhtml.twig
- en: The key to template inheritance is to use Twig statements in the base template
    to delineate blocks of code that will be filled in or overridden in each child
    page template. In this example, we define a block called main. This is where the
    unique content for each page will go. In our base template itself, however, the
    block is empty, so nothing is between the block and endblock statements. Twig
    blocks have names (in this case, main) so that child templates can specify which
    blocks (if any) are to be overridden with page-specific content.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 模板继承的关键在于在基础模板中使用 Twig 语句来划定代码块，这些代码块将在每个子页面模板中被填充或覆盖。在这个例子中，我们定义了一个名为 main
    的代码块。这就是每个页面的独特内容将要放置的位置。然而，在我们的基础模板中，这个代码块是空的，因此 `block` 和 `endblock` 语句之间没有内容。Twig
    的代码块有名字（在本例中是 main），这样子模板就可以指定哪些代码块（如果有的话）需要用页面特定的内容进行覆盖。
- en: Notice that in this inheritance approach, we have a full web page in the base
    template; that is, it isn’t a partial template. In particular, the base template
    includes closing </body> and </html> tags. A Twig base template is a complete
    HTML page in its own right, although it may have default or empty blocks meant
    to be overridden in the child templates.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，在这种继承方式中，我们的基础模板包含了一个完整的网页；也就是说，它不是一个部分模板。特别是，基础模板包含了闭合的 `</body>` 和 `</html>`
    标签。一个 Twig 基础模板本身就是一个完整的 HTML 页面，尽管它可能有一些默认或空的代码块，旨在被子模板覆盖。
- en: We can now update our home page and Contact Us templates to inherit from the
    base template and override the main block with individual page content. First,
    update *templates/homepage.xhtml.twig* to match [Listing 21-18](#lis21-18).
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以更新我们的首页和联系我们模板，让它们继承自基础模板，并用各自的页面内容覆盖 main 块。首先，更新 *templates/homepage.xhtml.twig*
    以匹配 [列表 21-18](#lis21-18)。
- en: '[PRE19]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Listing 21-18: The homepage.xhtml.twig template, inheriting from the base template'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: '列表 21-18: `homepage.xhtml.twig` 模板，继承自基础模板'
- en: We declare that this template extends (inherits from) *base.xhtml.twig*. Then
    we embed the page-specific paragraph inside the main block, overriding the empty
    contents of this block in the base template. We finish with an endblock statement
    so that Twig knows where the overriding content ends. These endblock statements
    are particularly important because in more complex pages we may be overriding
    two or more blocks in a child page template. Notice that we no longer have the
    closing HTML tags at the end of the file, since these have moved to the base template.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 我们声明这个模板继承自（即从...继承） *base.xhtml.twig*。然后我们在 main 块内嵌入页面特定的段落，覆盖基础模板中该块的空内容。最后，我们使用
    `endblock` 语句结束，以便 Twig 知道覆盖内容何时结束。`endblock` 语句非常重要，因为在更复杂的页面中，我们可能会在子页面模板中覆盖两个或更多的代码块。注意，在文件末尾我们不再有闭合的
    HTML 标签，因为这些标签已转移到基础模板中。
- en: We next need to make the same changes to the Contact Us page. Update *templates/contactUs.xhtml.twig*
    to match [Listing 21-19](#lis21-19).
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要对联系我们页面做相同的修改。更新 *templates/contactUs.xhtml.twig* 以匹配 [列表 21-19](#lis21-19)。
- en: '[PRE20]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Listing 21-19: The contactUs.xhtml.twig template, inheriting from the base
    template'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: '列表 21-19: `contactUs.xhtml.twig` 模板，继承自基础模板'
- en: Once again, we use extends so that this template will inherit from *base.xhtml.twig*,
    and we override the main block with the page-specific content. As before, we close
    out the main block with an endblock statement.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 再次使用 `extends`，这样该模板将继承自 *base.xhtml.twig*，并用页面特定的内容覆盖 main 块。和之前一样，我们用 `endblock`
    语句结束 main 块。
- en: Blocks Instead of Variables
  id: totrans-158
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 使用代码块代替变量
- en: For this simple, static, two-page website, we shouldn’t need to pass any variables
    to the Twig templates through the $args array when we call the render() method.
    At present, our controller methods are passing the page title as a Twig variable
    named pageTitle. However, we could instead make the page title a block in the
    base template and override the block with the appropriate text in each child template.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个简单的静态两页网站，我们不应该需要通过 `$args` 数组向 Twig 模板传递任何变量。当我们调用 `render()` 方法时，目前我们的控制器方法将页面标题作为一个名为
    `pageTitle` 的 Twig 变量传递。然而，我们可以将页面标题设置为基础模板中的一个代码块，并在每个子模板中覆盖该块，使用适当的文本。
- en: Let’s remove the pageTitle variable being passed by the controller methods in
    our Application class. Update *src/Application.php* to match [Listing 21-20](#lis21-20).
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们移除在我们的 `Application` 类中由控制器方法传递的 `pageTitle` 变量。更新 *src/Application.php*
    以匹配 [列表 21-20](#lis21-20)。
- en: '[PRE21]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Listing 21-20: Passing an empty $args array in the Application class'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: '列表 21-20: 在 `Application` 类中传递一个空的 `$args` 数组'
- en: We declare $args as an empty array in the homepage() and contactUs() methods.
    While we could just pass an empty array as the second argument to render(), first
    declaring the array as a variable clarifies whether any variables are being passed
    to the Twig template.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在 homepage() 和 contactUs() 方法中将 $args 声明为空数组。虽然我们可以直接将空数组作为 render() 的第二个参数传递，但首先将数组声明为变量有助于澄清是否有任何变量被传递给
    Twig 模板。
- en: We must now update the base template to declare a block for the page title,
    rather than printing the contents of a Twig variable. Update *templates/base.xhtml.twig*
    as shown in [Listing 21-21](#lis21-21).
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在必须更新基础模板，声明一个页面标题块，而不是直接输出 Twig 变量的内容。更新 *templates/base.xhtml.twig* 文件，参见[列表
    21-21](#lis21-21)。
- en: '[PRE22]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Listing 21-21: Adding a page title block to the base.xhtml.twig template'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 21-21：向 base.xhtml.twig 模板添加页面标题块
- en: We declare a new pageTitle Twig block whose contents will become part of the
    HTML <title> element. We also need to repeat the contents of this block later
    as a level 1 heading ❶. We aren’t permitted to declare a second block with the
    same name, however. Instead, we print the contents of the block by using Twig’s
    block() function, which takes an argument indicating the name of the block whose
    contents should be output. We need to enclose this function call in double curly
    brackets, just like other Twig expressions.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 我们声明一个新的 pageTitle Twig 块，其内容将成为 HTML <title> 元素的一部分。我们还需要稍后重复这个块的内容，作为一级标题
    ❶。然而，我们不允许声明第二个同名的块。相反，我们通过使用 Twig 的 block() 函数来输出该块的内容，block() 函数接受一个参数，指示要输出的块的名称。我们需要将此函数调用括在双大括号中，就像其他
    Twig 表达式一样。
- en: All that remains is to update each child page to declare a pageTitle block containing
    an appropriate page name, overriding the default empty pageTitle block in the
    base template. Update *templates/homepage.xhtml.twig* to match [Listing 21-22](#lis21-22).
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 剩下的工作是更新每个子页面，声明一个包含适当页面名称的 pageTitle 块，覆盖基础模板中的默认空 pageTitle 块。更新 *templates/homepage.xhtml.twig*
    文件，以匹配[列表 21-22](#lis21-22)。
- en: '[PRE23]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Listing 21-22: Declaring a page title block in the homepage.xhtml.twig template'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 21-22：在 homepage.xhtml.twig 模板中声明页面标题块
- en: We declare the pageTitle block with the Home Page content. This one declaration
    is enough to fill in the page title at both locations in the base template. Update
    *templates/contactUs.xhtml.twig* in the same way, declaring the pageTitle block
    with the Contact Us Page content.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 我们声明一个包含主页内容的 pageTitle 块。仅此一条声明便足以填充 base 模板中两个位置的页面标题。以同样的方式更新 *templates/contactUs.xhtml.twig*
    文件，声明一个包含联系我们页面内容的 pageTitle 块。
- en: When you now load the website, you should see that nothing has changed. However,
    our use of template inheritance has made the code much more efficient.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 当您现在加载网站时，应该会发现页面没有任何变化。然而，我们通过使用模板继承使代码变得更加高效。
- en: Improved Page Styling with CSS
  id: totrans-173
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 使用 CSS 改进页面样式
- en: Our website is working, and the template code is efficient and well organized,
    but the pages themselves don’t look very appealing. We’ll round out the website
    by introducing some CSS to give it a more polished design. With all the common
    content for the site confined to the single *base.xhtml.twig* template file, you’ll
    see that Twig makes this process of updating the site’s appearance quite straightforward.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的网站已经可以正常工作，模板代码高效且结构清晰，但页面本身看起来并不吸引人。我们将通过引入一些 CSS 来完善网站的设计，使其看起来更加精致。由于所有网站的通用内容都被限制在单一的
    *base.xhtml.twig* 模板文件中，您会发现，Twig 使得更新网站外观的过程变得非常简单。
- en: Highlighting the Current Navigation Link
  id: totrans-175
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 高亮当前导航链接
- en: Highlighting the current page’s navigation bar link is a common way to inform
    the user which page they’re viewing. In [Chapter 16](chapter16.xhtml), we did
    this with PHP variables. Now you’ll see how Twig template inheritance makes the
    process even easier. In the base template, we’ll declare a uniquely named Twig
    block for the content of the class attribute for each link element in the navigation
    list. Then, in the child templates, we’ll override the appropriate Twig block
    to set the current page link’s class attribute to active. We’ll use CSS to style
    the active link a different color from others.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 高亮当前页面的导航栏链接是一种常见的方式，用来告知用户他们正在查看哪个页面。在[第 16 章](chapter16.xhtml)中，我们使用了 PHP
    变量来实现这一点。现在您将看到，Twig 模板继承使得这个过程变得更简单。在基础模板中，我们将为导航列表中每个链接元素的 class 属性内容声明一个独特名称的
    Twig 块。然后，在子模板中，我们将重写相应的 Twig 块，将当前页面链接的 class 属性设置为 active。我们将使用 CSS 将激活的链接与其他链接区分开，使用不同的颜色进行样式化。
- en: To begin, update *base.xhtml.twig* to match [Listing 21-23](#lis21-23).
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，更新 *base.xhtml.twig* 文件，以匹配[列表 21-23](#lis21-23)。
- en: '[PRE24]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Listing 21-23: The base.xhtml.twig template with blocks for the navigation
    links'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 21-23：带有导航链接块的 base.xhtml.twig 模板
- en: We add a style import declaration so that all pages of the site will be able
    to use the CSS styles declared in *public/css/style.css* (which we’ll create shortly).
    Then we declare a homeLink Twig block as the content for a class attribute for
    the link to the home page. The block is empty, so if it isn’t overridden, the
    link won’t be assigned to a class. We similarly declare a contactLink Twig block
    as the content for a class attribute for the Contact Us link.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 我们添加一个样式导入声明，以便网站的所有页面都能使用 *public/css/style.css* 中声明的 CSS 样式（我们稍后会创建该文件）。然后，我们声明一个
    homeLink Twig 块作为主页链接的类属性内容。该块为空，因此如果没有被覆盖，链接将不会分配任何类。同样，我们声明一个 contactLink Twig
    块，作为“联系我们”链接的类属性内容。
- en: We now need to make the child templates override these blocks. Update the *homepage.xhtml.twig*
    template file as shown in [Listing 21-24](#lis21-24).
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们需要让子模板覆盖这些块。按照 [列表 21-24](#lis21-24) 所示更新 *homepage.xhtml.twig* 模板文件。
- en: '[PRE25]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Listing 21-24: Declaring a homeLink block in homepage.xhtml.twig'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 21-24：在 homepage.xhtml.twig 中声明一个 homeLink 块
- en: We declare the homeLink block to have active content, thereby assigning it to
    a CSS class that will highlight the page link in a different color from the default
    navigation links. [Listing 21-25](#lis21-25) shows how to update the *contactUs.xhtml.twig*
    template file in the same way.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 我们声明 homeLink 块具有活动内容，从而将其分配给一个 CSS 类，以便将该页面的链接高亮显示为与默认导航链接不同的颜色。[列表 21-25](#lis21-25)
    展示了如何以相同的方式更新 *contactUs.xhtml.twig* 模板文件。
- en: '[PRE26]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Listing 21-25: Declaring a contactLink block in contactUs.xhtml.twig'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 21-25：在 contactUs.xhtml.twig 中声明一个 contactLink 块
- en: We declare the contactLink block with active content, which again will highlight
    the page’s link when the user visits it.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 我们声明 contactLink 块并赋予其活动内容，这样当用户访问页面时，它将再次突出显示页面的链接。
- en: To finish, we need to declare some simple CSS rules. We’ll give the page header
    (containing the navigation list) a dark background color and define default and
    active colors for the links. Create a new *public/css* folder for the project,
    then create *style.css* within it and enter the contents of [Listing 21-26](#lis21-26).
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们需要声明一些简单的 CSS 规则。我们将页面头部（包含导航列表）设置为深色背景，并定义链接的默认颜色和活动颜色。为项目创建一个新的 *public/css*
    文件夹，然后在其中创建 *style.css* 文件，并输入 [列表 21-26](#lis21-26) 的内容。
- en: '[PRE27]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Listing 21-26: The style.css stylesheet'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 21-26：style.css 样式表
- en: We set the default color of all <a> elements to be gray ❶, while any <a> elements
    with a class attribute of active will be white instead ❷. Finally, we declare
    the unordered list in the header element to display inline-block ❸ so our navigation
    items appear in the same row as the logo image in the header. [Figure 21-6](#fig21-6)
    shows the updated home page for our site, as well as the page’s HTML source code.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将所有 <a> 元素的默认颜色设置为灰色 ❶，而任何具有 active 类属性的 <a> 元素则会显示为白色 ❷。最后，我们在头部元素中声明无序列表显示为
    inline-block ❸，这样导航项就会与头部的 logo 图像在同一行显示。[图 21-6](#fig21-6) 展示了我们网站更新后的主页，以及该页面的
    HTML 源代码。
- en: '![](../images/figure21-6.jpg)'
  id: totrans-192
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/figure21-6.jpg)'
- en: 'Figure 21-6: The home page and corresponding active CSS class for the page’s
    link in the HTML source'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 图 21-6：主页及其在 HTML 源代码中对应的活动 CSS 类
- en: In the HTML, notice that the active content from the homeLink block appears
    in the class element for the Home link in the navigation bar. As a result, the
    Home link appears white to indicate it’s the page currently being viewed.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 在 HTML 中，可以注意到 homeLink 块中的活动内容出现在导航栏的主页链接的类元素中。因此，主页链接显示为白色，以指示这是当前正在查看的页面。
- en: Polishing the Website with Bootstrap
  id: totrans-195
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 使用 Bootstrap 美化网站
- en: Rather than hacking together our own CSS for a more professional-looking and
    responsive page layout, we can once again let the powerful Bootstrap CSS framework
    do most of the work for us. Twig makes incorporating Bootstrap styling easy. All
    we need to do is make a few changes to the base template, and those changes will
    affect every page of the website. We don’t need to change the child page templates
    at all.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 与其自己编写 CSS 来实现更专业且响应式的页面布局，不如再次利用强大的 Bootstrap CSS 框架来为我们完成大部分工作。Twig 使得集成 Bootstrap
    样式变得简单。我们所需要做的只是对基础模板进行一些修改，这些修改将影响网站的每个页面。我们不需要修改任何子页面模板。
- en: We’ll let Bootstrap style our navigation links, and we’ll use predefined colors
    that Bootstrap provides, so we can delete the folder and file *css/style.css*
    altogether. Then we just need to modify the base template of the site. Edit *base.xhtml.twig*
    to match the contents of [Listing 21-27](#lis21-27).
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将让 Bootstrap 来样式化我们的导航链接，并使用 Bootstrap 提供的预定义颜色，因此可以完全删除文件夹和文件 *css/style.css*。接着，我们只需修改网站的基础模板。编辑
    *base.xhtml.twig* 以匹配[清单 21-27](#lis21-27)的内容。
- en: '[PRE28]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Listing 21-27: Updating the base.xhtml.twig template with Bootstrap'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 21-27：使用 Bootstrap 更新 base.xhtml.twig 模板
- en: We add a meta element to prevent the page content from appearing too small when
    viewed on mobile devices ❶. Then we load in the Bootstrap stylesheet ❷ and entire
    HTML page body as a Bootstrap container ❸. This adds basic spacing to the left
    and right margins of the page after Bootstrap has determined the appropriate maximum
    width for page content for the web client viewport dimensions.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 我们添加了一个 meta 元素，以防页面内容在移动设备上查看时显示得过小 ❶。接着，我们加载了 Bootstrap 样式表 ❷，并将整个 HTML 页面主体作为
    Bootstrap 容器 ❸。这样，在 Bootstrap 确定了页面内容的最大宽度后，它会在页面的左右边距添加基本的间距，以适应 Web 客户端视口的尺寸。
- en: We assign the header element containing the logo and navigation bar several
    Bootstrap classes to render the element as a navigation bar in dark mode with
    the predefined bg-dark background color ❹. The unordered list containing the navigation
    links receives the navbar-nav style ❺ for professional-looking links. We style
    each link’s list item as a nav-item and its anchor link element as a nav-link.
    Notice that the Twig homeLink and contactLink blocks still appear as part of the
    links’ class attributes, alongside the nav-link class. This way, the currently
    displayed page’s link element will have both the nav-link and active styles applied,
    and Bootstrap will highlight the link accordingly.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 我们为包含 logo 和导航栏的 header 元素分配了几个 Bootstrap 类，以将该元素渲染为暗模式下的导航栏，并使用预定义的 bg-dark
    背景色 ❹。包含导航链接的无序列表则应用了 navbar-nav 样式 ❺，使链接看起来更加专业。我们将每个链接的列表项样式化为 nav-item，将其锚链接元素样式化为
    nav-link。请注意，Twig 中的 homeLink 和 contactLink 块仍然作为链接类属性的一部分，和 nav-link 类一起出现。这样，当前显示页面的链接元素将同时应用
    nav-link 和 active 样式，Bootstrap 会相应地高亮该链接。
- en: The background color, spacing, and multicolumn layout of the header are achieved
    using a combination of Bootstrap utility classes. We replace the header’s old
    <blockquote> element with a <div> ❻ styled as a row with a light background (bg-light),
    lots of padding on all four sides (p-5), and a medium-spaced bottom margin (mb-4).
    The header <div> contains a <div> for the main heading and tagline styled as a
    column (col display-6), which will appear to the left of another <div> for the
    site’s greeting.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 通过结合使用 Bootstrap 工具类，我们实现了 header 的背景色、间距和多列布局。我们用一个样式化为具有浅色背景（bg-light）、四个边都有大量填充（p-5）且底部有中等间距（mb-4）的行（row）的
    <div> 元素替换了 header 中原有的 <blockquote> 元素 ❻。该 header <div> 包含一个作为列（col display-6）样式化的
    <div>，用于显示主标题和标语，这将出现在另一个 <div> 的左侧，该 <div> 用于显示站点的问候语。
- en: With the addition of Bootstrap styling, our website now has the professional
    look and feel shown previously in [Figure 21-4](#fig21-4). We achieved this styling
    simply by changing the base template file, without having to touch any of the
    child page templates.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 通过添加 Bootstrap 样式，我们的网站现在拥有了如之前在[图 21-4](#fig21-4)所示的专业外观和感觉。我们只需更改基础模板文件，就能实现这种样式，而无需触及任何子页面模板。
- en: Summary
  id: totrans-204
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, you learned the basics of the Twig templating package, which
    greatly simplifies the process of creating general HTML templates that can be
    customized with page-specific content. Using Twig, we created a multipage website,
    driven by the run() method of an Application class, which performs the function
    of a front controller. The only part of our web application that isn’t object-oriented
    is the code in the *public/index.php* script, which reads in and executes the
    Composer autoloader, creates an Application object, and calls its run() method.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你学习了 Twig 模板包的基础知识，它极大简化了创建通用 HTML 模板的过程，这些模板可以通过页面特定的内容进行自定义。使用 Twig，我们创建了一个多页面网站，由一个应用类的
    run() 方法驱动，充当前端控制器。我们的网站应用程序中唯一不是面向对象的部分是 *public/index.php* 脚本中的代码，它读取并执行 Composer
    自动加载器，创建一个 Application 对象，并调用它的 run() 方法。
- en: 'Thanks to Twig, we can safely hand over responsibility for creating and modifying
    page templates to team members who need no knowledge of PHP programming. Through
    the use of Twig inheritance and overridable blocks, the templates for each page
    are small and focus on content specific to that individual page. We leveraged
    Twig’s powerful inheritance feature, enabling us to add features such as professional
    Bootstrap styling and active link highlighting, all through declarations in the
    top-level base template. Overall, using a templating system such as Twig means
    we’re strongly separating the view component of our web application from its controllers
    and model: Twig templates have the single responsibility of decorating provided
    data with HTML to create the body of responses to be returned to the requesting
    web client.'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 多亏了Twig，我们可以安全地将创建和修改页面模板的责任交给无需了解PHP编程的团队成员。通过使用Twig的继承和可覆盖区块功能，每个页面的模板都很小，并专注于该页面特定的内容。我们利用了Twig强大的继承功能，使我们能够通过在顶级基本模板中的声明，添加诸如专业的Bootstrap样式和活动链接高亮等功能。总体来说，使用像Twig这样的模板系统意味着我们强烈地将Web应用程序的视图组件与其控制器和模型分离：Twig模板仅负责装饰提供的数据，使用HTML创建响应正文，以返回给请求的Web客户端。
- en: '### Exercises'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: '### 练习'
- en: '1.   Create a project with a single script, *public/index.php*, that returns
    a complete, well-formed HTML page body containing a paragraph saying Hello name,
    where name is a URL-encoded variable. Then progressively refactor the project
    in the following sequence:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 1.   创建一个项目，包含一个脚本*public/index.php*，该脚本返回一个完整且结构良好的HTML页面正文，正文包含一个段落，内容为“Hello
    name”，其中name是一个URL编码的变量。然后按照以下顺序逐步重构项目：
- en: a.   Move the HTML into *templates/hello.php*, and write front-controller PHP
    code in *public/index.php* to display this template.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: a.   将HTML移到*templates/hello.php*，并在*public/index.php*中编写前端控制器PHP代码来显示此模板。
- en: b.   Move your front-controller logic into a run() method in a namespaced Application
    class. The run() method should extract the name URL-encoded variable and pass
    it to a hello() method that displays the *templates/hello.php* template. You’ll
    also need to create a *composer.json* file for your class’s namespace, generate
    the Composer autoloader, and update *public/index.php* to read in the autoloader,
    create an Application object, and call the run() method.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: b.   将前端控制器逻辑移动到一个命名空间为“Application”的类中的run()方法。run()方法应提取URL编码的name变量，并将其传递给hello()方法，后者显示*templates/hello.php*模板。你还需要为类的命名空间创建一个*composer.json*文件，生成Composer自动加载器，并更新*public/index.php*来加载自动加载器，创建一个Application对象，并调用run()方法。
- en: c.   Convert your *templates/hello.php* file into a Twig template called *templates/hello.xhtml.twig*,
    and update your Application class to create a twig property in its constructor.
    Use this property in the hello() method to create and then print an $html variable
    for the body of the request to be returned to the web client.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: c.   将*templates/hello.php*文件转换为一个名为*templates/hello.xhtml.twig*的Twig模板，并更新Application类，在其构造函数中创建一个twig属性。在hello()方法中使用此属性来创建并打印一个$html变量，用于返回给Web客户端的请求正文。
- en: '2.   Copy the project from Exercise 1 and progressively turn it into a two-page
    website by doing the following:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 2.   复制练习1中的项目，并通过以下步骤逐步将其转变为一个两页的网站：
- en: a.   Separate the core of the HTML structure into a *base.xhtml.twig* template,
    and then refactor *hello.xhtml.twig* to extend this base template and override
    its body block with the “hello” message.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: a.   将HTML结构的核心部分分离到*base.xhtml.twig*模板中，然后重构*hello.xhtml.twig*，使其扩展此基本模板，并用“hello”消息覆盖其主体区块。
- en: b.   Create a second page template, *privacy.xhtml.twig*, that also extends
    the base template and displays the sentence *This website stores zero cookies
    and so does not affect your browsing privacy in any way.*
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: b.   创建第二个页面模板*privacy.xhtml.twig*，该模板同样扩展基本模板，并显示以下句子：*该网站不存储任何Cookies，因此不会以任何方式影响您的浏览隐私。*
- en: c.   Add a footer to the *hello.xhtml.twig* template containing the text Privacy
    Policy and linking to URL */?action=privacy.*
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: c.   在*hello.xhtml.twig*模板中添加一个页脚，内容为“隐私政策”，并链接到URL*/?action=privacy*。
- en: d.   Add a privacy() method to the Application class. This method should display
    the *privacy.xhtml.twig* template.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: d.   向Application类添加一个privacy()方法。该方法应显示*privacy.xhtml.twig*模板。
- en: e.   Update the logic in the run() method of the Application class so that the
    value of the URL-encoded action variable (if found) is stored in the $action variable.
    Then add a switch statement that invokes the privacy() method if the value of
    $action is privacy, or otherwise invokes the hello() method.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 更新 Application 类的 run() 方法中的逻辑，以便 URL 编码的 action 变量的值（如果找到）存储在 $action 变量中。然后，添加一个
    switch 语句，如果 $action 的值为 privacy，则调用 privacy() 方法；否则，调用 hello() 方法。
- en: 3.   Create an object-oriented, inheritance-based, Twig-templated, three-page
    website, with a home page, a staff details page, and a privacy policy page. Include
    Bootstrap CSS and a three-item navigation bar, where the navigation bar item for
    the page being displayed is highlighted using the active CSS class. The staff
    details page should use a Twig for loop to display an HTML table of three staff
    members, from a provided array of Staff objects. The Staff class should have name
    and jobTitle properties.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个面向对象、基于继承、使用 Twig 模板的三页网站，包括主页、员工详情页和隐私政策页。页面应包含 Bootstrap CSS 和一个三项导航栏，其中正在显示的页面的导航栏项应通过使用
    active CSS 类来高亮显示。员工详情页应使用 Twig 的 for 循环来显示一个包含三名员工的 HTML 表格，数据来源于提供的 Staff 对象数组。Staff
    类应具有 name 和 jobTitle 属性。
