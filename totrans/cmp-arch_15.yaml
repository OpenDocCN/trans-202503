- en: '**12**'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '**12**'
- en: '**EMBEDDED ARCHITECTURES**'
  id: totrans-1
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '**嵌入式架构**'
- en: '![Image](../images/f0281-01.jpg)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/f0281-01.jpg)'
- en: Computers are now common inside cars, robots, factories, art galleries, and
    domestic appliances. These environments bring particular constraints and challenges
    to computation, and architectures designed for them are known as *embedded systems*.
    The vast majority of manufactured processors—about 98 percent of them—go to embedded
    systems. This is a huge market, with a value of around $250 billion in the early
    2020s, so it’s worth your time to study these systems.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 计算机现在在汽车、机器人、工厂、艺术画廊和家用电器中非常常见。这些环境给计算带来了特定的约束和挑战，而为这些环境设计的架构被称为*嵌入式系统*。绝大多数生产的处理器—约98%的处理器—都用于嵌入式系统。这是一个巨大的市场，在2020年代初期，其价值约为2500亿美元，因此，花时间研究这些系统是值得的。
- en: This chapter will give you the understanding of embedded systems needed to build
    your own robots, home automation hacks, electronic musical instruments, or art
    installations, as well as industrial applications. We’ll begin by examining key
    differences between general-purpose computers and embedded systems, including
    the structure of typical microcontrollers and their I/O features. We’ll then turn
    to Arduino, the most common embedded system used by computer scientists, and show
    how to program it in simulation and for real at the assembly language level, where
    its architecture is clearest to see. Finally, we’ll explore some alternatives
    to Arduino, including Arduinoless AVR, PIC, DSPs, and PLCs.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将帮助你理解嵌入式系统，从而能够构建你自己的机器人、家居自动化黑客、电子音乐乐器或艺术装置，以及工业应用。我们将从比较通用计算机和嵌入式系统的主要区别开始，包括典型微控制器的结构及其I/O功能。然后，我们将介绍Arduino，这是计算机科学家最常用的嵌入式系统，并展示如何在仿真和实际中用汇编语言编程，在那里它的架构最为清晰。最后，我们将探索一些Arduino的替代品，包括没有Arduino的AVR、PIC、DSP和PLC。
- en: Design Principles
  id: totrans-5
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 设计原则
- en: There are several well-known design principles that distinguish embedded systems
    from other architectures. Let’s walk through them now.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 有几个众所周知的设计原则，将嵌入式系统与其他架构区分开来。让我们现在来逐一讲解。
- en: '*Single Purpose*'
  id: totrans-7
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*单一用途*'
- en: Unlike PCs, embedded systems are usually purchased and used for a single purpose.
    An embedded system controls your robot or your washing machine by running a single
    program, meaning you don’t need an operating system to switch between programs,
    and you don’t often—or ever—need to change the program. As a result, embedded
    devices can be difficult to upgrade. You can occasionally try asking all your
    users to upgrade the firmware on their TV or music player, but it would be very
    expensive to promote and explain the concept widely enough for many users to actually
    do it. Instead, it’s common for most users to throw away such devices and buy
    new ones. Depending on your point of view, this can be a huge waste of Earth’s
    resources or a highly profitable business model.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 与PC不同，嵌入式系统通常是为了单一目的购买和使用的。一个嵌入式系统通过运行一个程序来控制你的机器人或洗衣机，这意味着你不需要操作系统来切换程序，而且你不常—甚至永远—需要更改程序。因此，嵌入式设备可能很难升级。你可以偶尔尝试要求所有用户升级他们电视或音乐播放器上的固件，但要广泛地推广并解释这个概念以使许多用户实际操作，会非常昂贵。相反，大多数用户通常会将这些设备丢弃并购买新的。根据你的角度来看，这可能是对地球资源的巨大浪费，或者是一个高利润的商业模式。
- en: '*Reliability*'
  id: totrans-9
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*可靠性*'
- en: Reliability is often much more of an issue for embedded systems than for general-purpose
    computing—it can literally be life or death. Consider a heart pacemaker and its
    embedded systems, which are put inside a human being during surgery. You have
    to be very sure that it works correctly, as you really don’t want to have to open
    the person up again to fix a bug or turn the device off and on again. Other embedded
    systems control heavy machinery in factories, signaling systems for public transportation,
    and nuclear missile launches, all of which have a similarly low tolerance for
    errors.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 对于嵌入式系统来说，可靠性通常比通用计算更为重要—它甚至可能关乎生死。考虑一下心脏起搏器及其嵌入式系统，这些系统会在手术过程中被植入人体内。你必须非常确定它能正常工作，因为你真的不希望为了修复一个
    bug 而重新打开病人，或者将设备关掉再打开。其他嵌入式系统控制着工厂中的重型机械、公共交通信号系统以及核导弹发射，这些系统同样对错误的容忍度非常低。
- en: '*Mobility and Power*'
  id: totrans-11
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*移动性与功率*'
- en: 'Embedded systems are usually designed as the computational parts of physical
    machines, which constrain their physical shape more heavily than for general-purpose
    computers. It’s common for the physical machine to be designed first, and for
    the embedded system to be designed to fit into whatever space is left. Some embedded
    systems have mobility concerns, too: if the embedded system has to go on a person,
    for example, it has to be small and light enough to carry around (and it wouldn’t
    hurt to look good, too).'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 嵌入式系统通常被设计为物理机器的计算部分，这比通用计算机更严格地限制了其物理形态。通常会先设计物理机器，然后根据剩余空间来设计嵌入式系统。有些嵌入式系统也涉及到移动性问题：如果嵌入式系统必须随身携带，比如穿戴设备，它必须足够小巧轻便（并且最好看起来也不错）。
- en: There are considerations of electricity, especially if the host machine runs
    on a battery instead of plugging into the wall. Designers have to consider how
    much power to draw and for how long, and how large the battery has to be. A lot
    of effort goes into designing embedded processors to use as little energy as possible.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 还有电力方面的考虑，尤其是当主机运行在电池上，而不是插入电源时。设计人员必须考虑消耗多少电力以及持续多久，电池需要多大。设计嵌入式处理器时需要尽量减少能量消耗，往往需要付出大量的努力。
- en: '*Encapsulation*'
  id: totrans-14
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*封装*'
- en: Because they’re intended for a single purpose, embedded systems typically don’t
    need to expose the user to most or any of their functionality, a concept known
    as *encapsulation*. Instead, the user might get a simple interface, with just
    a few buttons and some LEDs, or none at all if the system is intended to work
    without human intervention. Often, the user won’t even realize that there’s a
    computer present in their machine.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 由于它们是为单一目的而设计的，嵌入式系统通常不需要将大部分或任何功能暴露给用户，这个概念被称为*封装*。相反，用户可能会得到一个简单的界面，只有几个按钮和一些LED灯，或者根本没有界面，如果系统设计为无需人工干预工作的话。通常，用户甚至不会意识到他们的设备里有一台计算机。
- en: '*Careful Debugging*'
  id: totrans-16
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*仔细调试*'
- en: While finished embedded systems are often designed to be very robust, safety-critical,
    and fault-tolerant, you’ll find as a computer scientist that they can feel very
    brittle during development work. We’re used to working with systems that can be
    quickly and safely hacked around; if something doesn’t work, we fix it and run
    it again until it does. But when you work with embedded systems, a failure can
    physically destroy a component that may be difficult, expensive, or time-consuming
    to replace, so you often have to be more careful and organized about how to plan
    tests.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管完成的嵌入式系统通常被设计得非常坚固、安全且容错性强，但作为计算机科学家，你会发现，在开发过程中，它们可能会显得非常脆弱。我们习惯于处理可以快速、安全地进行“黑客攻击”的系统；如果某个功能不起作用，我们会修复它并重新运行，直到它正常工作。但在嵌入式系统的开发中，一次故障可能会物理性地损坏一个组件，这个组件可能难以、更换昂贵，或者耗时，所以你通常需要更加小心和有组织地规划测试。
- en: Microcontrollers
  id: totrans-18
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 微控制器
- en: A *microcontroller* (aka a *microcontroller unit*, *MCU*, or *µC*) is a chip
    including a CPU that’s designed and marketed for embedded applications. A microcontroller
    may look like the one in [Figure 12-1](ch12.xhtml#ch12fig1).
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '*微控制器*（又称为*微控制单元*，*MCU*，或*µC*）是一种包含CPU的芯片，专为嵌入式应用而设计和销售。微控制器可能看起来像[图12-1](ch12.xhtml#ch12fig1)中的那种。'
- en: '![Image](../images/f0283-01.jpg)'
  id: totrans-20
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/f0283-01.jpg)'
- en: '*Figure 12-1: An Atmel ATmega328P microcontroller chip*'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '*图12-1：一款Atmel ATmega328P微控制器芯片*'
- en: In the next few sections, we’ll walk through some common features of microcontrollers.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的几个章节中，我们将介绍一些微控制器的常见特性。
- en: '*CPU*'
  id: totrans-23
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*CPU*'
- en: Microcontrollers are based around a CPU. The CPU is usually much lower power
    than a desktop’s, in terms of both computational power and energy consumption.
    They’re often 8-bit, behaving quite similarly to retro 8-bit architectures, and
    they often don’t have floating point—as with retro machines, you need to work
    in either integers or fixed point.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 微控制器围绕CPU构建。与桌面计算机相比，这些CPU的计算能力和能耗通常要低得多。它们通常是8位的，行为与复古的8位架构非常相似，而且通常没有浮点运算——与复古计算机一样，你需要使用整数或定点数进行工作。
- en: Microcontrollers usually also include memory and I/O components on the same
    silicon as the CPU. This arrangement removes the need for external buses and reduces
    the number of pins on the microcontroller. It’s easier to build a physical system
    from a single MCU chip than to require separate chips and bus wiring.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 微控制器通常还将内存和输入输出（I/O）组件与CPU集成在同一块硅片上。这种布局消除了对外部总线的需求，并减少了微控制器上的引脚数量。相比需要分开芯片和总线布线的方式，使用单一的MCU芯片构建物理系统更为简单。
- en: '*Memory*'
  id: totrans-26
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*内存*'
- en: Because they’re intended to run a single, fixed program, microcontrollers typically
    use a Harvard architecture, with the program stored as firmware in ROM, and RAM
    used only as working memory for the program’s data. Using ROM in this way enables
    the program to remain in memory when the system is powered off, and to be immediately
    available when powered on again. Like all CPUs, microcontrollers are designed
    to fetch from a hardwired initial address on power-on, and the first instruction
    will be placed in ROM at that address.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 由于微控制器通常用于运行单一、固定的程序，它们通常使用哈佛架构，将程序存储为ROM中的固件，而RAM仅用于程序数据的工作内存。以这种方式使用ROM使得程序在系统断电时仍能保留在内存中，并在重新开机时立即可用。像所有CPU一样，微控制器设计时会从上电时的硬件初始化地址获取数据，第一条指令将被放置在ROM的这个地址处。
- en: Because it has to fit on the single chip, microcontroller memory is much smaller
    than in desktop PCs.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 由于需要适应单芯片的限制，微控制器的内存远小于桌面PC。
- en: '*Timers and Counters*'
  id: totrans-29
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*定时器和计数器*'
- en: As many real-world control tasks need to operate based on time and events in
    the real world, it’s common for timers and counters to be included in microcontrollers.
    They usually appear as extra simple machines, with their own dedicated registers
    and instructions, in the microcontroller’s CPU.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 由于许多现实世界的控制任务需要基于时间和现实世界中的事件进行操作，因此微控制器中常常包含定时器和计数器。它们通常作为额外的简单机器出现在微控制器的CPU中，拥有自己的专用寄存器和指令。
- en: You saw how to make counters from digital logic in [Chapter 6](ch06.xhtml).
    If you connect a wire from the outside world to a counter, you can use the counter
    to count the number of occurrences of some physical event, such as the number
    of presses of a button.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经在[第6章](ch06.xhtml)中学会了如何使用数字逻辑构建计数器。如果你将外部世界的一个线连接到计数器上，你可以使用该计数器来计数某些物理事件的发生次数，比如按钮按下的次数。
- en: A *timer* measures the amount of real time that has elapsed since it was initialized.
    Real-world time is often called “wall-clock” time in this context, as in the time
    difference that would be reported by a human looking at a physical clock on the
    wall. A timer can be made by connecting the electronic clock, as used to control
    the CPU’s cycle, to a counter.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '*定时器*测量自初始化以来经过的实际时间。在此上下文中，实际时间通常被称为“挂钟时间”，指的是人类观察墙上的物理时钟所报告的时间差。定时器可以通过将电子时钟（用于控制CPU的周期）连接到计数器来实现。'
- en: A *watchdog* is a special timer that automatically resets the microcontroller
    in the case of failure. This is used in systems that have to be reliable in the
    real world. If something goes wrong, you need a way to reset the system without
    needing to touch the machine (think of the pacemaker example). The reset is done
    at the digital logic level and isn’t part of the CPU’s program.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '*看门狗*是一种特殊的定时器，在发生故障时会自动重置微控制器。这在需要在现实世界中保持可靠性的系统中使用。如果发生故障，你需要一种无需触碰机器的方式来重置系统（想想起搏器的例子）。重置是在数字逻辑层面完成的，不是CPU程序的一部分。'
- en: Embedded I/O
  id: totrans-34
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 嵌入式输入输出
- en: Embedded systems exist to control physical devices, so I/O is particularly important.
    We often find I/O modules, ports, and some very basic, slow serial communication
    built into the chip itself. As microcontrollers don’t expose their bus on their
    external pins, the scarce resource of pin real estate can instead be used to expose
    I/O connections. Some microcontrollers forgo I/O modules and use direct I/O instructions
    to talk to these pins—similar to what you saw for the Commodore 64 6510.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 嵌入式系统存在的目的是控制物理设备，因此输入输出（I/O）尤为重要。我们通常会发现I/O模块、端口和一些非常基础、缓慢的串行通信被集成到芯片本身。由于微控制器不在外部引脚上暴露它们的总线，有限的引脚空间资源可以用来暴露I/O连接。一些微控制器放弃了I/O模块，而是使用直接I/O指令与这些引脚进行通信——类似于你在Commodore
    64 6510中看到的那样。
- en: 'I/O isn’t only important for real-time execution; it also provides a way to
    upload programs to embedded systems. Unlike with PCs, it’s usually not possible
    to do the development work on an embedded device, as this would require graphics,
    a keyboard, an operating system, and a compiler to all run on the low-power device.
    Instead, we do development work on a desktop, and perhaps test our programs there
    too using simulation or emulation, before transferring the final binary executable
    to the embedded device. Microcontrollers have special modes for doing this: usually
    they can be connected to a desktop via USB, serial port, or other means, then
    put into “firmware upgrade” mode to copy the executable into their non-volatile
    program memory via this connection and a software device driver on the desktop
    machine.'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 输入输出不仅对实时执行很重要；它还提供了一种将程序上传到嵌入式系统的方法。与PC不同，通常无法在嵌入式设备上进行开发工作，因为这需要图形界面、键盘、操作系统和编译器都在低功耗设备上运行。相反，我们通常在台式机上进行开发工作，可能还会在台式机上使用仿真或模拟进行测试，然后再将最终的二进制可执行文件传输到嵌入式设备。微控制器有专门的模式来进行此操作：通常它们可以通过USB、串口或其他方式连接到台式机，然后进入“固件升级”模式，通过这种连接和台式机上的软件设备驱动程序将可执行文件复制到它们的非易失性程序存储器中。
- en: '*Analog-Digital Conversion*'
  id: totrans-37
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*模拟-数字转换*'
- en: Many microcontrollers need to handle incoming and outgoing analog signals, but
    inside the controller signals must be digital; this requires conversion at both
    ends. The necessary converters may be found outside the microcontroller, connected
    to its pins, or in some cases on the microcontroller silicon itself.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 许多微控制器需要处理进出模拟信号，但在控制器内部，信号必须是数字信号；这需要在两端进行转换。所需的转换器可以位于微控制器外部，通过其引脚连接，或者在某些情况下位于微控制器的芯片上。
- en: The classic case of analog-digital conversion (ADC) is audio processing. An
    analog signal from a microphone is sent to a digital processor, which adds effects
    to the audio before sending the processed analog signal back out to the speakers.
    This is done by taking a continuous analog signal wave and quantizing it, turning
    it into a digital signal by sampling it at regular time intervals, as shown in
    [Figure 12-2](ch12.xhtml#ch12fig2). You can do this at different resolutions by
    taking samples more or less frequently.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 模拟-数字转换（ADC）的经典案例是音频处理。来自麦克风的模拟信号被发送到数字处理器，数字处理器对音频进行特效处理后，再将处理过的模拟信号传送回扬声器。这是通过将连续的模拟信号波形量化来完成的，转换为数字信号的过程是通过在固定时间间隔内采样来实现的，如[图12-2](ch12.xhtml#ch12fig2)所示。你可以通过更频繁或更不频繁地采样来在不同的分辨率下进行此操作。
- en: '![Image](../images/f0285-01.jpg)'
  id: totrans-40
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/f0285-01.jpg)'
- en: '*Figure 12-2: Quantizing an analog signal to digital*'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '*图12-2：将模拟信号量化为数字信号*'
- en: When converting the other way, digital-analog conversion (DAC), some devices
    (like the Arduino Due) do true conversion of digital integers to analog voltages.
    Cheaper ones (such as the Arduino Uno) approximate the conversion with pulse-width
    modulation (PWM). Here, the output is only ever 0 V or 5 V. If 3 V is asked for,
    the output oscillates rapidly between 0 V and 5 V, spending three-fifths of its
    time at 5 V and two-fifths at 0 V, to give a temporal average of 3 V. For some
    applications this creates no noticeable difference, but for others it can play
    havoc with the output.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在进行反向转换时，即数字-模拟转换（DAC），一些设备（如Arduino Due）可以将数字整数真正转换为模拟电压。较便宜的设备（如Arduino Uno）则通过脉冲宽度调制（PWM）来近似完成转换。在这种情况下，输出信号只有0
    V或5 V。如果需要3 V，输出会在0 V和5 V之间迅速振荡，其中三分之五的时间为5 V，二分之五的时间为0 V，从而给出一个时间平均值为3 V。对于一些应用，这不会造成明显的差异，但对于其他应用，它可能会破坏输出结果。
- en: '*Embedded Serial Ports*'
  id: totrans-43
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*嵌入式串口*'
- en: The serial ports seen in the previous chapter continue to be used heavily today
    in embedded systems, due to their simplicity and stability. In the projects you
    do here, you’re more likely to see this convention in a virtualized form, as you
    don’t often see a physical serial port on a modern computer these days. Instead,
    you can use something like USB to emulate the old-fashioned serial port protocols.
    Similarly, the *Zigbee* wireless protocol acts as a virtual serial port running
    over a specific radio frequency; it’s used by embedded devices such as programmable
    light bulbs and transportation and agriculture sensor networks.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 前一章中提到的串行端口由于其简单性和稳定性，今天仍在嵌入式系统中广泛使用。在这里做的项目中，你更可能看到这种协议的虚拟化形式，因为如今现代计算机上不常见物理串行端口。相反，你可以使用类似USB的方式来模拟传统的串行端口协议。类似地，*Zigbee*无线协议作为一个虚拟串行端口，在特定的无线频率上运行；它被嵌入式设备如可编程灯泡、交通和农业传感器网络使用。
- en: '*Inter-Integrated Circuit Bus*'
  id: totrans-45
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*互集成电路总线*'
- en: The *Inter-Integrated Circuit bus*, pronounced “eye-two-see” (written as I²C
    and sometimes pronounced “eye-squared-see”), is a standard for connecting chips
    together. It’s very common in robotics. The standard is owned and licensed by
    NXP (formerly Phillips).
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '*互集成电路总线*，读作“eye-two-see”（写作I²C，有时读作“eye-squared-see”），是连接芯片的标准。它在机器人技术中非常常见。该标准由NXP（前身为菲利普斯）拥有并授权。'
- en: 'I²C communication is done on just two wires: data (SDA) and clock (SDL), as
    shown in [Figure 12-3](ch12.xhtml#ch12fig3).'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: I²C通信仅通过两根线进行：数据（SDA）和时钟（SCL），如[图12-3](ch12.xhtml#ch12fig3)所示。
- en: '![Image](../images/f0286-01.jpg)'
  id: totrans-48
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/f0286-01.jpg)'
- en: '*Figure 12-3: The I²C architecture*'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '*图12-3：I²C架构*'
- en: I²C can use 5 V or 3.3 V as its high voltage, and runs in various speed modes,
    from 100Kbps to 3Mbps. There may be multiple devices on the bus, each having a
    7-bit licensed device address. One node must take on the role of manager by generating
    the clock and initiating communications. The other nodes are workers, which reply
    to the manager. Basic message collision avoidance is implemented by the rule “only
    talk if the bus is free.”
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: I²C可以使用5V或3.3V作为高电压，并且在多种速度模式下运行，从100Kbps到3Mbps不等。总线上可能有多个设备，每个设备都有一个7位的许可设备地址。一个节点必须承担管理者角色，生成时钟并发起通信。其他节点则是工作节点，回复管理者。基本的消息碰撞避免是通过规则“只有在总线空闲时才说话”来实现的。
- en: In practice, I²C devices can be accessed via a standard FTDI (Future Technology
    Devices International Ltd) chip, which provides a hardware and software interface
    to it, usually via a serial connection (which itself is usually via a USB port).
    Examples of an I²C device (an inertial measurement unit sensor) and an FTDI for
    interfacing to it are shown in [Figure 12-4](ch12.xhtml#ch12fig4).
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，I²C设备可以通过标准的FTDI（未来技术设备国际有限公司）芯片访问，FTDI提供硬件和软件接口，通常通过串行连接（通常是通过USB端口）。I²C设备（惯性测量单元传感器）与用于接口的FTDI的例子如[图12-4](ch12.xhtml#ch12fig4)所示。
- en: '![Image](../images/f0287-01.jpg)'
  id: totrans-52
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/f0287-01.jpg)'
- en: '*Figure 12-4: An I²C device (left) and FTDI interface (right)*'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '*图12-4：I²C设备（左）与FTDI接口（右）*'
- en: No extra device drivers are needed for transport—the FTDI behaves as a serial
    port to the user.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 不需要额外的设备驱动程序，FTDI设备对用户来说表现得像一个串行端口。
- en: '*Controller Area Network Bus*'
  id: totrans-55
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*控制器局域网总线*'
- en: A *vehicle bus* is a specialized internal communications network that interconnects
    components inside a vehicle such as an automobile, train, ship, aircraft, or robot.
    A *controller area network (CAN)* bus is a type of vehicle bus that has a single
    public serial channel shared by all devices. CAN has no standard connector, as
    it isn’t intended for use by consumers, but rather for the internals of vehicles.
    Usually its wires are soldered directly into the printed circuit boards (PCBs)
    of the many devices in the vehicle. If you remove the plastic covering in front
    of the passenger seat in a car, you’ll usually find a wiring loom, which will
    include accessible CAN wires. Check your vehicle’s service documents to locate
    and connect to them.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '*车载总线*是一个专门的内部通信网络，连接车辆内部的各个组件，如汽车、火车、船舶、飞机或机器人。*控制器局域网(CAN)*总线是一种车载总线，具有所有设备共享的单一公共串行通道。CAN没有标准连接器，因为它并非面向消费者，而是用于车辆的内部。通常，它的线路直接焊接在车辆中许多设备的印刷电路板(PCB)上。如果你移开汽车副驾驶座前的塑料盖，通常会发现一个布线束，其中包含可接入的CAN线路。请查阅你的车辆维修手册以定位和连接这些线路。'
- en: CAN usually has four internal wires, which use differential voltages to protect
    against the strong external electromagnetic fields expected in vehicles, especially
    around electric motors and engines.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: CAN 通常有四根内部线，这些线使用差分电压来抵御车辆中预计会出现的强外部电磁场，特别是在电动机和发动机周围。
- en: CAN security is a current concern. Because it’s a bus, all devices can read
    and write to it. This may create problems when safety-critical devices, such as
    antilock brakes, are connected to the same bus as non-critical devices, such as
    media players. The concern is that security in media and similar devices is typically
    less rigorous than in the safety equipment. A hacker could take control of a non-critical
    device and use it to send malicious commands to critical devices, or deny service
    to them by filling the bus with junk messages. For autonomous vehicles where steering
    and acceleration are also managed via the CAN bus, the consequences could be particularly
    severe.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: CAN 安全是当前的一个关注点。由于它是一个总线，所有设备都可以读取和写入数据。当安全关键设备，如防抱死刹车，和非关键设备，如媒体播放器，连接到同一总线上时，这可能会导致问题。担忧的地方在于，媒体和类似设备的安全性通常不如安全设备严格。黑客可能会控制一个非关键设备，并利用它向关键设备发送恶意指令，或通过填充总线垃圾消息来拒绝服务。对于自动驾驶车辆而言，转向和加速也通过
    CAN 总线管理，其后果可能特别严重。
- en: Now that you’ve seen the general concepts that go into an embedded system, let’s
    explore how they show up in practice in the best-known example, the Arduino.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经了解了嵌入式系统的一般概念，接下来让我们探讨这些概念在实际应用中的体现，最著名的例子就是 Arduino。
- en: Arduino
  id: totrans-60
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Arduino
- en: '*Arduino*, shown in [Figure 12-5](ch12.xhtml#ch12fig5), is the standard embedded
    system for hackers, makers, and robotics researchers because it packages a microcontroller
    onto a PCB together with all the power management and I/O that you need to program
    it from a PC—you can just connect it to your desktop via USB and start programming
    it, without having to worry about analog power supplies or setting up its USB
    I/O system by yourself.'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '*Arduino*，如[图 12-5](ch12.xhtml#ch12fig5)所示，是黑客、创客和机器人研究人员的标准嵌入式系统，因为它将微控制器与所有需要的电源管理和输入输出功能封装在一个
    PCB 上，你可以通过 USB 直接将其连接到桌面计算机并开始编程，而无需担心模拟电源或自行设置其 USB 输入输出系统。'
- en: '![Image](../images/f0288-01.jpg)'
  id: totrans-62
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/f0288-01.jpg)'
- en: '*Figure 12-5: An Arduino board. The ATmega328P microcontroller is the large
    chip near the bottom right.*'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 12-5：一个 Arduino 开发板。ATmega328P 微控制器是位于右下角的大芯片。*'
- en: The Arduino PCB is an open source hardware design based around a microcontroller
    from the closed source Atmel AVR family, usually the ATmega328 model. The microcontroller
    is surrounded by additional hardware that makes powering and interfacing with
    it both easy and standard. These components were the traditional barrier to computer
    scientists programming microcontrollers, as they have to be made up on breadboards
    or PCBs for every project, requiring analog electronics skills. The cleverness
    of the Arduino design was to select and standardize a single set of these components
    that are generally useful for many applications, and to manufacture them cheaply
    in bulk so that end users don’t have to worry about them anymore. Arduino comes
    with open source software to easily assemble and transfer programs via USB into
    its firmware. (There’s also a C-like language and compiler, but as this book is
    about the architectural level, we’ll here study only Arduino’s assembly-level
    programming.)
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: Arduino PCB 是一个基于闭源 Atmel AVR 系列微控制器（通常是 ATmega328 型号）的开源硬件设计。微控制器周围是一些额外的硬件，这些硬件使得给其供电和与之接口变得既简单又标准化。这些组件曾是计算机科学家编程微控制器的传统障碍，因为它们需要在每个项目中通过面包板或
    PCB 来搭建，需要模拟电子学技能。Arduino 设计的巧妙之处在于选择并标准化了一套通常适用于多种应用的组件，并将其大规模低价生产，这样最终用户就不再需要为此担心。Arduino
    提供了开源软件，允许用户通过 USB 轻松地将程序传输到固件中。（这里还有类似 C 的语言和编译器，但由于本书侧重于架构层次，我们这里只研究 Arduino
    的汇编级编程。）
- en: You can program Arduino by itself—for example, to read numbers sent to it over
    USB from your desktop, do arithmetic on them, and send the results to your desktop.
    However, Arduino is usually used to interface with other electronic sensors and
    actuators, starting with LEDs and switches. Typically you lay these out on a breadboard,
    then connect wires from the breadboard to your Arduino, as in [Figure 12-6](ch12.xhtml#ch12fig6).
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以单独编程Arduino——例如，读取从桌面通过USB发送给它的数字，对其进行算术运算，并将结果发送回桌面。然而，Arduino通常用于与其他电子传感器和执行器接口，最初是LED和开关。通常你将这些组件布局在面包板上，然后将电线从面包板连接到Arduino，如[图12-6](ch12.xhtml#ch12fig6)所示。
- en: '![Image](../images/f0289-01.jpg)'
  id: totrans-66
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/f0289-01.jpg)'
- en: '*Figure 12-6: An I/O circuit connecting an LED and button to an Arduino using
    a breadboard and wires*'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '*图12-6：一个连接LED和按钮到Arduino的I/O电路，使用面包板和电线*'
- en: No soldering is required, as components and wires can be pushed into place in
    both the breadboard and the Arduino’s connectors.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 无需焊接，因为组件和电线可以直接插入面包板和Arduino的连接器中。
- en: '*The ATmega328 Microcontroller*'
  id: totrans-69
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*ATmega328微控制器*'
- en: The classic Arduino microcontroller, the Atmel AVR ATmega328, shown in [Figure
    12-1](ch12.xhtml#ch12fig1), behaves somewhat like an old-style 8-bit system such
    as a 6502\. There are 32 8-bit user registers (more than the three of the 6502).
    There’s an arithmetic logic unit (ALU) that includes integer multiplication and
    division, but no floating point. Similar to the 6502, there’s an 8-bit status
    register, containing bits telling you the result of arithmetic calculations to
    allow branching. The instruction set architecture (ISA) includes indirect addressing
    and a hardware stack. It’s usually clocked around 20 MHz.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 经典的Arduino微控制器——Atmel AVR ATmega328，如[图12-1](ch12.xhtml#ch12fig1)所示，表现得有些像旧式的8位系统，如6502。它有32个8位用户寄存器（比6502的三个要多）。它有一个算术逻辑单元（ALU），包括整数乘法和除法，但没有浮点运算。类似于6502，它有一个8位状态寄存器，包含告诉你算术计算结果的标志位，以便进行分支。指令集架构（ISA）包括间接寻址和硬件栈。它的时钟频率通常约为20
    MHz。
- en: The pinout, shown in [Figure 12-7](ch12.xhtml#ch12fig7), is different from a
    typical CPU, as there’s no external bus.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 引脚分配，如[图12-7](ch12.xhtml#ch12fig7)所示，与典型的CPU不同，因为它没有外部总线。
- en: '![Image](../images/f0289-02.jpg)'
  id: totrans-72
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/f0289-02.jpg)'
- en: '*Figure 12-7: The pinout of the ATmega328 (note the lack of A and D bus pins)*'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '*图12-7：ATmega328的引脚分配（注意没有A和D总线引脚）*'
- en: Instead of an external bus, 14 I/O pins are directly exposed. Pins increase
    the size of the chip’s package, so they’re a scarce resource. The I/O pins are
    each configurable to function as either input or output. Their configuration is
    set and stored using dedicated data direction registers (DDRs).
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 不同于外部总线，14个I/O引脚被直接暴露。引脚会增加芯片封装的尺寸，因此它们是一种稀缺资源。每个I/O引脚都可以配置为输入或输出。它们的配置通过专用的数据方向寄存器（DDR）设置并存储。
- en: The die shot ([Figure 12-8](ch12.xhtml#ch12fig8)) reveals that the microcontroller
    contains more than just a CPU.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 芯片照片（[图12-8](ch12.xhtml#ch12fig8)）显示该微控制器不仅仅包含一个CPU。
- en: '![Image](../images/f0290-01.jpg)'
  id: totrans-76
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/f0290-01.jpg)'
- en: '*Figure 12-8: A die shot of the ATmega328*'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '*图12-8：ATmega328的芯片照片*'
- en: In addition to a CPU, the chip has 2 k[2]B of SRAM, 32 k[2]B of flash memory,
    and a 1 k[2]B EEPROM, all on the silicon. In this sense, the chip is really more
    comparable to an entire retro computer than to only a CPU.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 除了CPU外，该芯片还拥有2 k[2]B的SRAM、32 k[2]B的闪存和1 k[2]B的EEPROM，所有这些都集成在硅芯片上。从这个意义上来说，这颗芯片更像是一台完整的复古计算机，而不仅仅是一个CPU。
- en: 'The Arduino uses a Harvard architecture. The program you send to the board
    is programmed into the flash memory using software on your host PC, while the
    RAM is used for data. (The EEPROM is user-writable, and is provided for applications
    where small configuration-style data needs to be stored during power-off.) The
    Harvard architecture uses two separate buses: an 8-bit bus for data and a 16-bit
    bus for programs. There’s no external memory or bus; the memory is all on the
    chip.'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: Arduino采用哈佛架构。你发送到板上的程序通过主机PC上的软件写入闪存，而RAM则用于数据存储。（EEPROM是用户可写的，提供给需要在断电时存储小型配置数据的应用。）哈佛架构使用两条独立的总线：一条8位数据总线和一条16位程序总线。没有外部内存或总线；所有内存都在芯片上。
- en: The microcontroller contains serial port pins and I/O modules. On power-on,
    the microcontroller first runs a small internal ROM program that checks its serial
    port. If there’s data waiting on the serial port, it’s assumed to be a new user
    program, which is then loaded into flash. The program counter is set to start
    the user program.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 微控制器包含串口引脚和 I/O 模块。在上电时，微控制器首先运行一个小的内部 ROM 程序，检查它的串口。如果串口上有等待的数据，则认为这是一个新的用户程序，并将其加载到闪存中。程序计数器被设置为启动用户程序。
- en: '*The Rest of the Arduino Board*'
  id: totrans-81
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*Arduino 板的其他部分*'
- en: While it’s possible to program the ATmega directly from its serial port pins,
    most desktop machines don’t have physical serial ports anymore, so it’s easier
    for users to use a virtual serial port running over USB. The Arduino board includes
    a USB connector and a dedicated chip (actually another, smaller microcontroller)
    that reads the USB wires and translates them into serial port signals to pass
    to the ATmega’s pins.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管可以直接从 ATmega 的串口引脚编程，但大多数桌面计算机现在没有物理串口了，因此用户使用通过 USB 运行的虚拟串口会更方便。Arduino 板包含一个
    USB 连接器和一个专用芯片（实际上是另一个较小的微控制器），它读取 USB 线并将其转换为串口信号，传递到 ATmega 的引脚。
- en: Most of the analog electronics on the board are used for power management. The
    microcontroller requires only a simple 5 V power supply. If a single, stable 5
    V is provided, then no further electronics would be needed. However, Arduino is
    designed to work in several different use cases. In particular, it can be powered
    by a battery or can take power via a USB cable. The extra components regulate
    these supplies, protecting the board from peaks and dips, and enabling it to switch
    between them. (It could otherwise be very bad to allow current from elsewhere
    to travel back up the USB cable into the connected desktop computer.)
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 板上的大多数模拟电子元件用于电源管理。微控制器只需要一个简单的 5 V 电源。如果提供一个稳定的 5 V 电源，那么就不需要其他电子元件。然而，Arduino
    设计时考虑了多种不同的使用场景。特别是，它可以通过电池供电，也可以通过 USB 电缆获取电源。额外的组件调节这些电源，保护板免受电压波动的影响，并使它能够在它们之间切换。（否则，如果让来自其他地方的电流返回
    USB 电缆进入连接的桌面计算机，那会非常糟糕。）
- en: An I²C bus enables extra extensions to plug into the Arduino. You can get other
    physical boards (“shields”) that plug into ports on the I²C bus, in a nice, physically
    stackable way.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: I²C 总线使得可以为 Arduino 插入额外的扩展模块。你可以获取其他物理板（“扩展板”），它们可以以一种整齐、可堆叠的方式插入到 I²C 总线的端口中。
- en: As it’s an open source platform, Arduino has been modified by many designers.
    For example, Ruggeduino is a hardened (and thus more expensive) version that includes
    extra safeguards to prevent you from blowing it up in stupid ways. There are also
    official variants from the Arduino team. The Due is a version with real DACs replacing
    PWM, the Mega and Giga have larger PCBs to enable more connections, and the Nano
    has a smaller footprint. Some variants use different microcontrollers, providing
    more computing power and different instruction sets for those who need or prefer
    them.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 由于它是一个开源平台，Arduino 已经被许多设计师修改过。例如，Ruggeduino 是一个强化版（因此也更贵），它包含了额外的保护措施，以防止你以愚蠢的方式损坏它。Arduino
    团队也有官方的变种。Due 是一个用真实 DAC 替代 PWM 的版本，Mega 和 Giga 有更大的 PCB，以支持更多连接，而 Nano 则有更小的尺寸。一些变种使用不同的微控制器，为需要或偏好这些功能的人提供更多的计算能力和不同的指令集。
- en: '*Programming Arduino*'
  id: totrans-86
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*编程 Arduino*'
- en: 'Like all CPUs, Atmel AVRs execute machine code from an instruction set, which
    you can program by assembling from a human-readable assembly language. The Arduino
    assembler isn’t very different from the other assemblers we’ve seen so far. You
    can write, edit, and assemble this assembly code on your desktop PC. The classic
    “Hello, world!” program for Arduino is to turn on its built-in LED on pin 13:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 像所有的 CPU 一样，Atmel AVRs 执行来自指令集的机器码，你可以通过从人类可读的汇编语言中汇编程序来进行编程。Arduino 的汇编器与我们迄今为止看到的其他汇编器没有太大区别。你可以在桌面
    PC 上编写、编辑并汇编这些汇编代码。Arduino 的经典 "Hello, world!" 程序是打开其内建的 13 号引脚上的 LED：
- en: '[PRE0]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The global `main` label gets called automatically when the Arduino is powered
    on. The `ldi` instruction is “load immediate,” and it loads a constant into a
    register. This particular constant contains 8 bits, one for each of the AVR’s
    eight digital I/O pins (labeled PB0 through PB7 in [Figure 12-7](ch12.xhtml#ch12fig7)).
    They’re all set to 0, except for pin PB5 (counting right to left, from PB0, along
    the binary digits), which is set to 1\. The AVR’s PB5 pin is wired to the Arduino
    PCB’s pin 13 and thus to the LED. The first `out` instruction copies the bits
    from r16 to 0x04, the data direction register, to configure the pins for I/O.
    This sets PB5 to act as an output and the other seven pins to act as inputs. The
    second `out` writes the same bits from r16 to 0x05, the “PortB” register, which
    sets values to output on the eight PB pins. This writes the 1 to PB5 and thus
    sends a high voltage to turn on the LED on Arduino pin 13.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 全局`main`标签在Arduino开机时会自动调用。`ldi`指令是“加载立即数”，它将一个常数加载到寄存器中。这个特定的常数包含8位，每一位对应AVR的一个数字I/O引脚（在[图12-7](ch12.xhtml#ch12fig7)中标记为PB0到PB7）。它们的初始值都设为0，除了PB5引脚（从右到左数，从PB0开始，沿着二进制位），它被设为1。AVR的PB5引脚接到Arduino
    PCB的13号引脚，进而连接到LED。第一个`out`指令将r16中的位复制到0x04，即数据方向寄存器，用来配置引脚为I/O模式。这会将PB5设置为输出，其他七个引脚设置为输入。第二个`out`指令将相同的位从r16写入0x05，即“PortB”寄存器，从而设置8个PB引脚的输出值。这会将1写入PB5，引发高电压点亮Arduino
    13号引脚上的LED。
- en: Unlike many CPU programs, the `loop` label and jump are important because they
    keep the program running forever. Without these, the LED would light only for
    a fraction of a second, then go off as the program ends. Embedded programs usually
    need to run forever like this.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 与许多CPU程序不同，`loop`标签和跳转指令很重要，因为它们让程序永远运行下去。如果没有这些，LED灯只会亮几分之一秒，然后在程序结束时熄灭。嵌入式程序通常需要像这样永远运行。
- en: 'A more complex version of the program makes the LED blink on and off:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 程序的一个更复杂版本使LED灯闪烁：
- en: '[PRE1]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: To make the code easier to read, I have here defined DDRB and PINB to represent
    the data direction register and PortB register. One millisecond is about 16,000
    cycles at 16 MHz. The inner loop takes four cycles, so we repeat it 3,000 times.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让代码更易读，我在这里定义了DDRB和PINB，分别表示数据方向寄存器和PortB寄存器。以16 MHz的频率，1毫秒大约是16,000个周期。内循环需要四个周期，因此我们重复执行3000次。
- en: '**NOTE**'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*The AVR also has some 16-bit instructions that operate on pairs of 8-bit registers
    together, as in the 6502.*'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '*AVR也有一些16位指令，像6502一样，它们操作一对8位寄存器。*'
- en: Other CPU-Based Embedded Systems
  id: totrans-96
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 其他基于CPU的嵌入式系统
- en: Arduino isn’t the only CPU-based embedded system in town. Let’s look at some
    alternatives that you might encounter.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: Arduino并不是唯一的基于CPU的嵌入式系统。让我们来看看你可能遇到的其他替代方案。
- en: '*Atmel AVR Without the Arduino*'
  id: totrans-98
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*没有Arduino的Atmel AVR*'
- en: Arduino is designed for computer scientists, not engineers. You wouldn’t normally
    sell a product based on a full Arduino board. Rather, you would create a custom
    PCB containing the AVR chip plus only the electronics that are needed, both from
    the Arduino board and from your own design.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: Arduino是为计算机科学家设计的，而非工程师。你通常不会将一个完整的Arduino板做为产品出售。相反，你会创建一个包含AVR芯片以及仅所需电子元件的定制PCB，这些电子元件既包括Arduino板上的组件，也包括你自己设计的部分。
- en: As an intermediate step, you can use a breadboard without the Arduino to mount
    the AVR and other electronics, as in [Figure 12-9](ch12.xhtml#ch12fig9).
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一个中间步骤，你可以使用没有Arduino的面包板来安装AVR和其他电子元件，如[图12-9](ch12.xhtml#ch12fig9)所示。
- en: '![Image](../images/f0293-01.jpg)'
  id: totrans-101
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/f0293-01.jpg)'
- en: '*Figure 12-9: A breadboard implementation using an AVR microcontroller*'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '*图12-9：使用AVR微控制器的面包板实现*'
- en: Once you’re happy that your design is working, you turn it into a PCB design
    using a program such as *KiCAD*, submit it to a PCB manufacturing company using
    their website, and receive your PCB in a few days through the mail. You don’t
    have to solder things yourself nowadays, the PCB manufacturing companies have
    robots that do it for you.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你确认设计工作正常，就可以使用像*KiCAD*这样的程序将其转换为PCB设计，提交给PCB制造公司，并通过他们的网站获得PCB，几天后通过邮寄收到。现在你不需要自己焊接了，PCB制造公司有机器人会帮你完成这个工作。
- en: '*PIC Microcontrollers*'
  id: totrans-104
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*PIC 微控制器*'
- en: '*PIC* is another series of microcontrollers, similar to but different from
    the AVR series. As with Arduinoless AVR, PICs require breadboards, PCB design,
    and serial ports.'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '*PIC*是另一系列微控制器，类似于但又不同于AVR系列。与没有Arduino的AVR一样，PIC微控制器也需要面包板、PCB设计和串口。'
- en: PICs are designed by the American company Microchip, who bought out their competitor
    Atmel in 2016\. PICs are found in many consumer and industrial embedded systems.
    There are a number of PICs to choose from; you decide which to buy based on your
    needs in terms of speed, power, cost, and physical size. Because of the wide range
    of options, PICs are more popular than Arduino/AVR in production engineering.
    The flexibility allows a selected PIC version to be closely matched to its application
    needs.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: PIC（可编程接口控制器）由美国公司Microchip设计，该公司在2016年收购了其竞争对手Atmel。PIC广泛应用于许多消费类和工业嵌入式系统中。市场上有多种PIC可供选择；你可以根据需求（如速度、功耗、成本和物理尺寸）来决定购买哪一款。由于有广泛的选择，PIC在生产工程中比Arduino/AVR更受欢迎。这种灵活性使得选择的PIC版本可以与其应用需求紧密匹配。
- en: '*Digital Signal Processors*'
  id: totrans-107
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*数字信号处理器*'
- en: '*Digital signal processors (DSPs)* are a specialized class of microcontroller
    designed for handling real-time signals, such as audio. Embedded systems working
    with such signals have particular requirements, as they’re fundamentally working
    with long—effectively endless—real-time streams of identically formatted data
    that have to be processed repeatedly in identical ways. This means there isn’t
    much branching; instead, the data flows through a smooth pipeline from one stage
    to the next, always being processed in the same way.'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '*数字信号处理器（DSP）* 是一种专门的微控制器，设计用于处理实时信号，如音频。处理此类信号的嵌入式系统有特定的要求，因为它们基本上处理的是长时间——实际上是无限的——实时数据流，这些数据格式相同且需要以相同方式反复处理。这意味着不会有太多分支；相反，数据会顺畅地流过每个阶段，始终以相同方式处理。'
- en: For example, guitarists often buy and use digital effects boxes that connect
    between their guitar and amplifier to modify the sound (by adding compression,
    distortion, delay, or reverb, for example). These boxes are embedded systems containing
    one or more DSPs, such as the chip shown in [Figure 12-10](ch12.xhtml#ch12fig10).
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，吉他手通常购买并使用数字效果盒，它们连接在吉他和放大器之间，用于修改声音（例如，通过添加压缩、失真、延迟或混响）。这些盒子是嵌入式系统，包含一个或多个DSP，例如[图12-10](ch12.xhtml#ch12fig10)所示的芯片。
- en: '![Image](../images/f0294-01.jpg)'
  id: totrans-110
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/f0294-01.jpg)'
- en: '*Figure 12-10: A DSP chip inside a guitar digital effects unit*'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '*图12-10：吉他数字效果单元中的DSP芯片*'
- en: DSPs aren’t only for audio signals, though. There are many other types of signals
    with similar properties, such as video, radar, and data streams from all kinds
    of medical and scientific monitoring instruments. With sound and sound-like data,
    you can often mostly get away with representing directly quantized sound waves
    from the ADC. With video, however, the data is usually so huge that it needs to
    be compressed during storage and transmission, which means many DSP units are
    used primarily to perform compression and decompression.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，DSP不仅仅用于音频信号。还有许多其他类型的信号具有类似的特性，如视频、雷达以及来自各种医疗和科学监测仪器的数据流。在音频和类似音频的数据中，你通常可以通过直接量化的声波表示从ADC获取的声音。然而，在视频处理中，数据通常非常庞大，需要在存储和传输过程中进行压缩，这意味着许多DSP单元主要用于执行压缩和解压缩。
- en: DSPs often use fixed-point number representation (as discussed in [Chapter 2](ch02.xhtml))
    rather than integers or floating point. This is because most signals have clear,
    fixed upper and lower bounds that can be rescaled to +1.0 and –1.0\. For example,
    musical audio is usually recorded in this way, with any signal outside these bounds
    being clipped. Fixed point is cheaper and simpler to implement than floating point,
    but can give similar quality results for these kinds of signals.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: DSP（数字信号处理器）通常使用定点数表示法（如[第2章](ch02.xhtml)中讨论的），而不是整数或浮点数。这是因为大多数信号具有明确的、固定的上下限，可以重新缩放到+1.0和-1.0。例如，音乐音频通常以这种方式录制，任何超出这些范围的信号都会被剪切。定点数比浮点数更便宜、实现更简单，但对于这些类型的信号，能够给出相似的质量结果。
- en: DSPs use their available silicon to provide additional instructions dedicated
    to signal processing. (Recall from [Chapter 8](ch08.xhtml) that adding extra domain-specific
    instructions like this is often considered to be the CISC philosophy.) For example,
    special instructions for fast Fourier transforms and convolution are found in
    DSPs designed for embedded audio use, as these operations form the basis of many
    standard audio processing algorithms. These usually operate in fixed point. As
    DSPs are designed to process large streams of data, they sometimes include additional
    instructions that load and store chunks of data larger than single words. Such
    instructions may trigger a sequence of transfers over the bus from a series of
    neighboring memory locations to a group of registers. Similarly, I/O instructions
    may trigger a series of ADCs to and from these groups of registers.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: DSP使用其可用的硅片提供额外的指令，专门用于信号处理。（回想一下[第8章](ch08.xhtml)，增加这种额外的特定领域指令通常被认为是CISC哲学的一部分。）例如，针对快速傅里叶变换和卷积的特殊指令出现在为嵌入式音频设计的DSP中，因为这些操作构成了许多标准音频处理算法的基础。它们通常在定点模式下操作。由于DSP设计用于处理大量数据流，它们有时会包含额外的指令，加载和存储比单个字更大的数据块。这些指令可能会触发从一系列相邻内存位置到一组寄存器的传输序列。同样，I/O指令可能会触发一系列的ADC与这些寄存器组之间的数据交换。
- en: As with standard microcontrollers, DSPs use a Harvard architecture, so that
    firmware can be placed in ROM during manufacture, then left alone to run forever.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 与标准的微控制器类似，DSP（数字信号处理器）采用哈佛架构，因此固件可以在制造时存储在ROM中，然后永远运行。
- en: Embedded Systems with No CPU
  id: totrans-116
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 没有CPU的嵌入式系统
- en: The embedded systems we’ve seen so far have been microcontroller-based, meaning
    they’re still based around a CPU that executes programs of machine code instructions.
    But there are also other, simpler styles of embedded systems where there’s no
    CPU, no program, and no instruction set. There’s only hardware that you lay out
    to compute what you want to be computed, using digital logic circuits. These systems
    include PLCs and FPGAs.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 迄今为止我们看到的嵌入式系统都是基于微控制器的，这意味着它们仍然依赖于一个执行机器代码指令的CPU。但也存在其他更简单的嵌入式系统，它们没有CPU、没有程序、没有指令集。只有通过数字逻辑电路布局的硬件，用于计算你需要计算的内容。这些系统包括PLC和FPGA。
- en: '*Programmable Logic Controllers*'
  id: totrans-118
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*可编程逻辑控制器*'
- en: '*Programmable logic controllers (PLCs)* are a type of embedded system designed
    to perform simple computations to control machinery in industrial environments,
    with very high reliability. They’re usually found in factories with dust, chemicals,
    bits of food, high and low temperatures, and other extreme conditions that make
    life hard for normal chips. The idea is to install something durable that can
    operate continuously for 20 years, without ever going down. Systems have to be
    almost indestructible, utterly reliable, and as simple as possible to avoid any
    kind of bugs slipping in. In this context of industrial automation, embedded systems
    are sometimes known as *supervisory control and data acquisition (SCADA)* systems.'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '*可编程逻辑控制器（PLCs）* 是一种嵌入式系统，旨在执行简单的计算以控制工业环境中的机械设备，具有非常高的可靠性。它们通常出现在充满灰尘、化学品、食物碎片、高低温以及其他极端条件的工厂环境中，这些条件使得普通芯片难以生存。其设计理念是安装一种耐用的设备，能够持续运行20年，永不宕机。系统必须几乎不可摧毁，绝对可靠，并且尽可能简化，以避免任何错误的潜入。在这种工业自动化的背景下，嵌入式系统有时被称为*监控控制与数据采集（SCADA）*系统。'
- en: You’ll see PLCs in these kinds of environments, usually packaged in what are
    called DIN modules and mounted on standard DIN rails, as in [Figure 12-11](ch12.xhtml#ch12fig11).
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 你会在这些环境中看到PLC，通常它们被打包成所谓的DIN模块，并安装在标准的DIN轨道上，如[图12-11](ch12.xhtml#ch12fig11)所示。
- en: In your house—often in a basement or under the stairs—you might have a DIN-style
    module that acts as a fuse box or circuit breaker (aka a residual current device,
    or RCD) for your whole house. Again, it’s robust engineering that’s designed not
    to fail under any normal operating circumstances. The DIN design was standardized
    in the 1970s and is still with us today.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的家里——通常是在地下室或楼梯下——你可能会有一个DIN风格的模块，它充当整个房屋的熔断器或断路器（也称为剩余电流装置，RCD）。同样，它是经过坚固设计的，旨在在任何正常操作情况下都不会失败。DIN设计在1970年代标准化，至今仍然在使用。
- en: '![Image](../images/f0296-01.jpg)'
  id: totrans-122
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/f0296-01.jpg)'
- en: '*Figure 12-11: DIN modules mounted on a DIN rail*'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '*图12-11：安装在DIN轨道上的DIN模块*'
- en: A PLC doesn’t run a program in the sense of a series of instructions; instead,
    its function is usually specified using a visual system called *ladder logic*,
    as shown in [Figure 12-12](ch12.xhtml#ch12fig12).
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: PLC不像运行一系列指令的程序那样运行；相反，它的功能通常是通过一种名为*梯形逻辑*的可视化系统来指定的，如[图12-12](ch12.xhtml#ch12fig12)所示。
- en: '![Image](../images/f0296-02.jpg)'
  id: totrans-125
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/f0296-02.jpg)'
- en: '*Figure 12-12: An example of a ladder logic configuration for an embedded device*'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '*图12-12：嵌入式设备的梯形逻辑配置示例*'
- en: In essence, ladder logic is a set of if-then rules that say that if one input
    is high, then connect a wire to another wire. There’s no program starting at the
    top and working through a list of instructions; each unit follows the logic of
    the rules around it. It’s derived from the old days where you’d make computers
    from physical electromechanical relays.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 从本质上讲，梯形逻辑是一组“如果-那么”规则，它表示如果一个输入为高电平，则连接一根线到另一根线。没有程序从顶部开始并通过指令列表进行工作；每个单元都按照周围规则的逻辑运行。它来源于早期通过物理机电继电器构建计算机的时代。
- en: Ladder logic is so simple that even engineers can do it. But the simplicity
    also means that both formal methods and intuitive inspection can be used to verify
    that systems do exactly what they’re supposed to do. You wouldn’t want all the
    complexity of an operating system and modern programming languages and compilers
    when even tiny bugs in any of that could cause your nuclear fuel rods to move
    to the wrong place; everything has to be absolutely reliable and understandable.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 梯形逻辑如此简单，甚至工程师都能使用。但这种简易性也意味着既可以使用正式方法，也可以通过直观检查来验证系统是否确切地做了它们应该做的事。如果在一个操作系统和现代编程语言及编译器中有任何微小的错误，可能导致核燃料棒移到错误的位置，那么你肯定不希望系统那么复杂；一切都必须是绝对可靠和可理解的。
- en: PLCs are simple, completely transparent, and verifiable. It may surprise you
    to learn that the engineers programming this equipment often make more than most
    computer scientist programmers, but they’re also getting paid to take responsibility
    for safety. The program might exist as part of a nuclear power station where,
    even if the program is very simple, it has to be very correct. You don’t have
    to design PLCs by directly configuring the ladder logic anymore; there are now
    compilers and assemblers that will turn C code into these configurations for you.
    Doing this, of course, requires trusting the compiler and assembler programs,
    as well as your own code.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: PLC（可编程逻辑控制器）简单、完全透明且可验证。你可能会惊讶地发现，编写这些设备程序的工程师往往赚得比大多数计算机科学程序员还多，但他们也承担着安全责任。这个程序可能存在于一个核电站中，即使程序非常简单，也必须确保它的正确性。你不再需要通过直接配置梯形逻辑来设计PLC；现在有编译器和汇编器可以将C代码转换为这些配置。当然，做到这一点需要信任编译器和汇编器程序，以及你自己的代码。
- en: '**EMBEDDED SECURITY**'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '**嵌入式安全**'
- en: SCADA systems should never be connected to the public internet. A famous leading
    question used in security audits asks SCADA managers, “How would you connect to
    the system in an emergency, when all the staff are away working at home and they
    need to take over control remotely before the nuclear fuel rod goes critical?”
    A worrying number of managers will then proudly explain that they do in fact have
    such a connection, which of course can be exploited by hackers.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: SCADA系统绝不应该连接到公共互联网。在安全审计中，有一个著名的引导性问题，问SCADA管理员：“在紧急情况下，当所有工作人员都不在现场，正在家中工作时，你如何远程接入系统，接管控制，以防核燃料棒临界？”令人担忧的是，很多管理员会自豪地解释他们确实有这样的连接，而这些连接当然会被黑客利用。
- en: Even when there’s no internet connection and the system is separated from the
    network by an “air gap,” it is possible to gain access. The 2010 Stuxnet worm
    was distributed on USB sticks left around international academic conferences.
    It replicated itself from USB stick to USB stick around the world until it reached
    the Iranian nuclear weapons fuel enrichment centrifuge embedded systems. Stuxnet
    then affected only their specific model and configuration of PLC, altering its
    behavior very subtly and almost undetectably to change the timing of the centrifuges,
    destroying them and preventing enrichment of the fuel.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 即使没有互联网连接，系统通过“气隙”与网络隔离，仍然有可能被访问。2010年的Stuxnet蠕虫就是通过在国际学术会议上散发的USB闪存驱动器传播的。它通过USB闪存驱动器在全球范围内自我复制，直到到达伊朗核武器燃料浓缩离心机的嵌入式系统。Stuxnet然后只影响它们特定型号和配置的PLC，微妙且几乎不可察觉地改变离心机的定时，从而摧毁它们并防止燃料浓缩。
- en: '*Embedded FPGAs*'
  id: totrans-133
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*嵌入式FPGAs*'
- en: The FPGA (field programmable gate array) chips discussed in [Chapter 5](ch05.xhtml)
    can be used to actualize any digital logic designs—not only those intended for
    use in or with CPUs. This can include PLC-like structures and many other digital
    logic network designs.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '[第5章](ch05.xhtml)中讨论的FPGA（现场可编程门阵列）芯片可以用于实现任何数字逻辑设计——不仅限于那些用于或与CPU配合使用的设计。这可以包括类似PLC的结构和许多其他数字逻辑网络设计。'
- en: As embedded systems perform single functions, a CPU design capable of running
    arbitrary programs of instructions may be both overkill and inefficient. Instead,
    the particular sequence of arithmetic or other transformations can be implemented
    directly as a sequence of simple machines, pipelined together in an FPGA. This
    can include, for example, placing multiple adders and multipliers connected in
    the specific sequence needed to implement your signal processing algorithm. In
    addition to reducing the CPU-style paraphernalia needed, this can also make systems
    run very fast, as all these arithmetic operations can happen in parallel.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 由于嵌入式系统执行单一功能，能够运行任意指令程序的CPU设计可能既过于复杂又低效。相反，特定的算术或其他变换序列可以直接作为一系列简单机器实现，并在FPGA中通过流水线连接。例如，可以通过将多个加法器和乘法器按照实现信号处理算法所需的特定顺序连接在一起。此外，这种方式不仅减少了所需的CPU风格硬件，还能使系统运行得非常快，因为所有这些算术操作可以并行执行。
- en: Hardware description languages can be especially useful for creating such designs.
    For example, they enable the arithmetic steps to be expressed in a C-like language
    before being automatically compiled to the appropriate digital logic.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 硬件描述语言在创建此类设计时尤其有用。例如，它们可以将算术步骤用类似C语言的语言表达，然后自动编译成适当的数字逻辑。
- en: '**UBIQUITOUS VS. MINDFUL COMPUTING**'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '**普适计算与有意识计算**'
- en: '*Ubicomp*, or Ubiquitous Computing, is an embedded design philosophy founded
    by Marc Wiser in the 1980s Xerox PARC (the same place where the mouse and graphical
    desktop were invented). Its core idea, as outlined by Marc Weiser, is that “the
    purpose of a computer is to help you do something else. The best computer is a
    quiet, invisible servant. The more you can do by intuition the smarter you are;
    the computer should extend your unconscious. Technology should create calm.”'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '*普适计算*（Ubicomp），即普及计算，是由马克·韦瑟（Marc Weiser）在1980年代的施乐帕洛阿尔托研究中心（Xerox PARC）创立的一种嵌入式设计哲学（同一地方发明了鼠标和图形桌面）。马克·韦瑟概述的核心理念是：“计算机的目的是帮助你做其他事情。最好的计算机是一个安静、隐形的仆人。你通过直觉做得越多，你就越聪明；计算机应该扩展你的无意识。技术应该带来宁静。”'
- en: Ubicomp shows up in products such as Amazon’s Alexa. It sits invisibly in your
    house, and when you want something, you say it out loud and it gets done for you.
    There’s no need for you to sit down at a computer and think about how to do it.
    Ubicomp ideas have also returned in recent fields such as “pervasive computing”
    and the Internet of Things.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 普适计算体现在像亚马逊的Alexa等产品中。它隐形地存在于你的家中，当你想要什么时，你大声说出来，它就为你完成。你无需坐在计算机前思考如何做。普适计算的理念也在近年来的“普遍计算”和物联网等领域重新出现。
- en: There has recently been a counter-movement against Ubicomp, which we might call
    *mindful computing*. Its adherents have decided that users don’t want decisions
    made for them by an uncertain, non-understood corporate cloud. They’re freaked
    out about losing control to these machines. Mindful computing therefore does the
    opposite, deliberately drawing attention to the technology and forcing users to
    think about and understand the machines they’re using.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 最近出现了一种反对普适计算的运动，我们可以称之为*有意识计算*。它的支持者认为，用户不希望被不确定的、无法理解的公司云端做决定。他们对失去对这些机器的控制感到恐慌。因此，有意识计算做了相反的事情，故意将注意力集中在技术上，迫使用户思考并理解他们正在使用的机器。
- en: According to a Ubicomp philosophy, light switches might disappear as machines
    automatically predict when the lights should turn themselves on and off without
    your input. According to mindful computing, the light switches should remain,
    and the user should devote their full conscious attention to becoming at one with
    the light switch as they touch it.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 根据一种普适计算的哲学，灯光开关可能会消失，因为机器可以自动预测何时应该打开或关闭灯光，而无需用户输入。根据有意识计算的理念，灯光开关应当保留，用户应当在触摸开关时，专注地将自己的意识与开关融为一体。
- en: Summary
  id: totrans-142
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 摘要
- en: Embedded architectures form the vast bulk of the world’s computers, yet by their
    nature they’re often invisible to most users. Their applications exist at the
    border between computing and engineering, but their architectures can be quite
    similar to those of retro computers, and they provide an interesting place for
    fans of that style of computing to work today. Most embedded systems are based
    on microcontrollers, which are chips that combine a low-power CPU with onboard
    memory, I/O, and other useful features. Arduino is a standard embedded platform
    that wraps most of the engineering needed for computer scientists to get started
    interfacing to hardware such as robots, factories, cars, and art installations.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 嵌入式架构构成了世界上大多数计算机的核心，但由于其本质，它们通常对大多数用户来说是隐形的。它们的应用存在于计算与工程之间的交界处，但它们的架构与复古计算机的架构非常相似，而且它们为喜欢这种计算风格的粉丝提供了一个有趣的工作领域。大多数嵌入式系统基于微控制器，这些芯片将低功耗的CPU与板载内存、I/O及其他有用功能结合在一起。Arduino是一个标准的嵌入式平台，它封装了计算机科学家与硬件（如机器人、工厂、汽车和艺术装置）进行接口所需的大部分工程工作。
- en: Exercises
  id: totrans-144
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 练习
- en: '**Simulated Arduino Programming**'
  id: totrans-145
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**模拟Arduino编程**'
- en: Use the open source Wokwi Arduino emulator to run the example Arduino programs
    shown in this chapter. To use the assembler, go to the blink.S tab at *[https://wokwi.com/arduino/projects/290348681199092237](https://wokwi.com/arduino/projects/290348681199092237)*,
    or find the offline version at *[https://github.com/arcostasi/avr8js-electron-playground](https://github.com/arcostasi/avr8js-electron-playground)*.
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用开源的Wokwi Arduino仿真器运行本章中展示的示例Arduino程序。要使用汇编器，请访问* [https://wokwi.com/arduino/projects/290348681199092237](https://wokwi.com/arduino/projects/290348681199092237)
    *中的blink.S标签，或在* [https://github.com/arcostasi/avr8js-electron-playground](https://github.com/arcostasi/avr8js-electron-playground)
    *找到离线版本。
- en: Remember that Arduino’s I/O pins are each configurable to act as inputs or outputs.
    If a pin isn’t reading or writing as expected, check that you’ve put it into the
    right mode first.
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 记住，Arduino的I/O引脚可以配置为输入或输出。如果引脚的读写行为不如预期，请首先检查它是否被设置为正确的模式。
- en: Instead of the nested delay loops used in the LED blinking program, a prettier
    and more energy-efficient way to program blinking lights is to use the AVR’s built-in
    timer. Research what registers and commands are needed to do it this way, and
    implement this alternative version.
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 与LED闪烁程序中使用的嵌套延迟循环相比，使用AVR内建的定时器编写闪烁灯光程序是一种更漂亮且更节能的方式。研究实现这种方式所需的寄存器和命令，并实现这种替代版本。
- en: '**Challenging**'
  id: totrans-149
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**具有挑战性**'
- en: There are many affordable Arduino starter kits available; obtain one and try
    to run the example programs on the real hardware. When working with real LEDs,
    remember that as diodes they’re directional and must be connected the right way
    around and always in parallel with a resistor; otherwise, they’ll explode!
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 有许多价格实惠的Arduino入门套件；购买一个并尝试在真实硬件上运行示例程序。当使用真实的LED时，记住它们是二极管，有方向性，必须正确连接，并且始终与电阻并联；否则，它们会爆炸！
- en: Most kits come with some additional sample programs written in Arduino C; try
    to reproduce their functionality using your own handwritten AVR assembly. (If
    stuck, try compiling the Arduino C into assembly and inspecting that to get ideas.)
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 大多数套件都附带一些用Arduino C编写的示例程序；尝试用你自己手写的AVR汇编代码来复现它们的功能。（如果遇到困难，可以尝试将Arduino C编译成汇编代码，并检查它以获取灵感。）
- en: If you prefer command line tools to the Arduino IDE, AVRA is the AVR assembler,
    and AVRDUDE is the AVR downloader/uploader.
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你更喜欢命令行工具而非Arduino IDE，AVRA是AVR汇编器，而AVRDUDE是AVR下载/上传工具。
- en: Further Reading
  id: totrans-153
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: For a famous parable about engineers’ and computer scientists’ differing opinions
    on embedded design, see Do-While Jones, “The Breakfast Food Cooker.” Various versions
    can be found around the internet, dating from 1990.
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有关工程师和计算机科学家在嵌入式设计方面的不同观点的著名寓言，请参见Do-While Jones的《早餐食品烹饪器》。网络上可以找到多个版本，最早的版本可追溯到1990年。
- en: For a full reference for the AVR instruction set, see Atmel, “AVR-Instruction-Set-Manual,”
    2016, *[https://ww1.microchip.com/downloads/en/DeviceDoc/Atmel-0856-AVR-Instruction-Set-Manual.pdf](https://ww1.microchip.com/downloads/en/DeviceDoc/Atmel-0856-AVR-Instruction-Set-Manual.pdf)*.
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有关AVR指令集的完整参考资料，请参阅Atmel的《AVR指令集手册》，2016年，* [https://ww1.microchip.com/downloads/en/DeviceDoc/Atmel-0856-AVR-Instruction-Set-Manual.pdf](https://ww1.microchip.com/downloads/en/DeviceDoc/Atmel-0856-AVR-Instruction-Set-Manual.pdf)
    *。
- en: For an Arduino PCB design explanation and CAD files, see the “Arduino from Scratch”
    series, *[https://rheingoldheavy.com/arduino-from-scratch-series](https://rheingoldheavy.com/arduino-from-scratch-series)*.
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有关 Arduino PCB 设计的说明和 CAD 文件，请参见“从零开始的 Arduino”系列，* [https://rheingoldheavy.com/arduino-from-scratch-series](https://rheingoldheavy.com/arduino-from-scratch-series)
    *。
- en: For information on programming PIC microcontrollers, see “PIC Programming in
    Assembly,” *[https://groups.csail.mit.edu/lbr/stack/pic/pic-prog-assembly.pdf](https://groups.csail.mit.edu/lbr/stack/pic/pic-prog-assembly.pdf)*.
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有关 PIC 单片机编程的信息，请参见《PIC 汇编编程》，* [https://groups.csail.mit.edu/lbr/stack/pic/pic-prog-assembly.pdf](https://groups.csail.mit.edu/lbr/stack/pic/pic-prog-assembly.pdf)
    *。
- en: To get your hands dirty with a CAN bus, see Jared Reabow, “How to Hack and Upgrade
    Your Car Using CAN Bus and Arduino,” *[https://www.instructables.com/How-to-Hack-and-Upgrade-Your-Car-Using-CAN-Bus/](https://www.instructables.com/How-to-Hack-and-Upgrade-Your-Car-Using-CAN-Bus/)*.
    The tutorial includes instructions for making a *Back to the Future*–style date
    and time display.
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要动手实践 CAN 总线，请参见 Jared Reabow 的《如何利用 CAN 总线和 Arduino 改装和升级你的汽车》，* [https://www.instructables.com/How-to-Hack-and-Upgrade-Your-Car-Using-CAN-Bus/](https://www.instructables.com/How-to-Hack-and-Upgrade-Your-Car-Using-CAN-Bus/)
    *。本教程包括制作 *回到未来* 风格日期和时间显示的说明。
- en: Hackaday (*[https://www.hackaday.com](https://www.hackaday.com)*) is a well-known
    website for embedded project ideas.
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Hackaday (*[https://www.hackaday.com](https://www.hackaday.com)*) 是一个著名的嵌入式项目创意网站。
