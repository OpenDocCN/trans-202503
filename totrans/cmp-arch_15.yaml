- en: '**12**'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '**12**'
- en: '**EMBEDDED ARCHITECTURES**'
  id: totrans-1
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '**嵌入式架构**'
- en: '![Image](../images/f0281-01.jpg)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/f0281-01.jpg)'
- en: Computers are now common inside cars, robots, factories, art galleries, and
    domestic appliances. These environments bring particular constraints and challenges
    to computation, and architectures designed for them are known as *embedded systems*.
    The vast majority of manufactured processors—about 98 percent of them—go to embedded
    systems. This is a huge market, with a value of around $250 billion in the early
    2020s, so it’s worth your time to study these systems.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 计算机现在在汽车、机器人、工厂、艺术画廊和家用电器中非常常见。这些环境给计算带来了特定的约束和挑战，而为这些环境设计的架构被称为*嵌入式系统*。绝大多数生产的处理器—约98%的处理器—都用于嵌入式系统。这是一个巨大的市场，在2020年代初期，其价值约为2500亿美元，因此，花时间研究这些系统是值得的。
- en: This chapter will give you the understanding of embedded systems needed to build
    your own robots, home automation hacks, electronic musical instruments, or art
    installations, as well as industrial applications. We’ll begin by examining key
    differences between general-purpose computers and embedded systems, including
    the structure of typical microcontrollers and their I/O features. We’ll then turn
    to Arduino, the most common embedded system used by computer scientists, and show
    how to program it in simulation and for real at the assembly language level, where
    its architecture is clearest to see. Finally, we’ll explore some alternatives
    to Arduino, including Arduinoless AVR, PIC, DSPs, and PLCs.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将帮助你理解嵌入式系统，从而能够构建你自己的机器人、家居自动化黑客、电子音乐乐器或艺术装置，以及工业应用。我们将从比较通用计算机和嵌入式系统的主要区别开始，包括典型微控制器的结构及其I/O功能。然后，我们将介绍Arduino，这是计算机科学家最常用的嵌入式系统，并展示如何在仿真和实际中用汇编语言编程，在那里它的架构最为清晰。最后，我们将探索一些Arduino的替代品，包括没有Arduino的AVR、PIC、DSP和PLC。
- en: Design Principles
  id: totrans-5
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 设计原则
- en: There are several well-known design principles that distinguish embedded systems
    from other architectures. Let’s walk through them now.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 有几个众所周知的设计原则，将嵌入式系统与其他架构区分开来。让我们现在来逐一讲解。
- en: '*Single Purpose*'
  id: totrans-7
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*单一用途*'
- en: Unlike PCs, embedded systems are usually purchased and used for a single purpose.
    An embedded system controls your robot or your washing machine by running a single
    program, meaning you don’t need an operating system to switch between programs,
    and you don’t often—or ever—need to change the program. As a result, embedded
    devices can be difficult to upgrade. You can occasionally try asking all your
    users to upgrade the firmware on their TV or music player, but it would be very
    expensive to promote and explain the concept widely enough for many users to actually
    do it. Instead, it’s common for most users to throw away such devices and buy
    new ones. Depending on your point of view, this can be a huge waste of Earth’s
    resources or a highly profitable business model.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 与PC不同，嵌入式系统通常是为了单一目的购买和使用的。一个嵌入式系统通过运行一个程序来控制你的机器人或洗衣机，这意味着你不需要操作系统来切换程序，而且你不常—甚至永远—需要更改程序。因此，嵌入式设备可能很难升级。你可以偶尔尝试要求所有用户升级他们电视或音乐播放器上的固件，但要广泛地推广并解释这个概念以使许多用户实际操作，会非常昂贵。相反，大多数用户通常会将这些设备丢弃并购买新的。根据你的角度来看，这可能是对地球资源的巨大浪费，或者是一个高利润的商业模式。
- en: '*Reliability*'
  id: totrans-9
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*可靠性*'
- en: Reliability is often much more of an issue for embedded systems than for general-purpose
    computing—it can literally be life or death. Consider a heart pacemaker and its
    embedded systems, which are put inside a human being during surgery. You have
    to be very sure that it works correctly, as you really don’t want to have to open
    the person up again to fix a bug or turn the device off and on again. Other embedded
    systems control heavy machinery in factories, signaling systems for public transportation,
    and nuclear missile launches, all of which have a similarly low tolerance for
    errors.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 对于嵌入式系统来说，可靠性通常比通用计算更为重要—它甚至可能关乎生死。考虑一下心脏起搏器及其嵌入式系统，这些系统会在手术过程中被植入人体内。你必须非常确定它能正常工作，因为你真的不希望为了修复一个
    bug 而重新打开病人，或者将设备关掉再打开。其他嵌入式系统控制着工厂中的重型机械、公共交通信号系统以及核导弹发射，这些系统同样对错误的容忍度非常低。
- en: '*Mobility and Power*'
  id: totrans-11
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*移动性与功率*'
- en: 'Embedded systems are usually designed as the computational parts of physical
    machines, which constrain their physical shape more heavily than for general-purpose
    computers. It’s common for the physical machine to be designed first, and for
    the embedded system to be designed to fit into whatever space is left. Some embedded
    systems have mobility concerns, too: if the embedded system has to go on a person,
    for example, it has to be small and light enough to carry around (and it wouldn’t
    hurt to look good, too).'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 嵌入式系统通常被设计为物理机器的计算部分，这比通用计算机更严格地限制了其物理形态。通常会先设计物理机器，然后根据剩余空间来设计嵌入式系统。有些嵌入式系统也涉及到移动性问题：如果嵌入式系统必须随身携带，比如穿戴设备，它必须足够小巧轻便（并且最好看起来也不错）。
- en: There are considerations of electricity, especially if the host machine runs
    on a battery instead of plugging into the wall. Designers have to consider how
    much power to draw and for how long, and how large the battery has to be. A lot
    of effort goes into designing embedded processors to use as little energy as possible.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 还有电力方面的考虑，尤其是当主机运行在电池上，而不是插入电源时。设计人员必须考虑消耗多少电力以及持续多久，电池需要多大。设计嵌入式处理器时需要尽量减少能量消耗，往往需要付出大量的努力。
- en: '*Encapsulation*'
  id: totrans-14
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*封装*'
- en: Because they’re intended for a single purpose, embedded systems typically don’t
    need to expose the user to most or any of their functionality, a concept known
    as *encapsulation*. Instead, the user might get a simple interface, with just
    a few buttons and some LEDs, or none at all if the system is intended to work
    without human intervention. Often, the user won’t even realize that there’s a
    computer present in their machine.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 由于它们是为单一目的而设计的，嵌入式系统通常不需要将大部分或任何功能暴露给用户，这个概念被称为*封装*。相反，用户可能会得到一个简单的界面，只有几个按钮和一些LED灯，或者根本没有界面，如果系统设计为无需人工干预工作的话。通常，用户甚至不会意识到他们的设备里有一台计算机。
- en: '*Careful Debugging*'
  id: totrans-16
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*仔细调试*'
- en: While finished embedded systems are often designed to be very robust, safety-critical,
    and fault-tolerant, you’ll find as a computer scientist that they can feel very
    brittle during development work. We’re used to working with systems that can be
    quickly and safely hacked around; if something doesn’t work, we fix it and run
    it again until it does. But when you work with embedded systems, a failure can
    physically destroy a component that may be difficult, expensive, or time-consuming
    to replace, so you often have to be more careful and organized about how to plan
    tests.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管完成的嵌入式系统通常被设计得非常坚固、安全且容错性强，但作为计算机科学家，你会发现，在开发过程中，它们可能会显得非常脆弱。我们习惯于处理可以快速、安全地进行“黑客攻击”的系统；如果某个功能不起作用，我们会修复它并重新运行，直到它正常工作。但在嵌入式系统的开发中，一次故障可能会物理性地损坏一个组件，这个组件可能难以、更换昂贵，或者耗时，所以你通常需要更加小心和有组织地规划测试。
- en: Microcontrollers
  id: totrans-18
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 微控制器
- en: A *microcontroller* (aka a *microcontroller unit*, *MCU*, or *µC*) is a chip
    including a CPU that’s designed and marketed for embedded applications. A microcontroller
    may look like the one in [Figure 12-1](ch12.xhtml#ch12fig1).
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '*微控制器*（又称为*微控制单元*，*MCU*，或*µC*）是一种包含CPU的芯片，专为嵌入式应用而设计和销售。微控制器可能看起来像[图12-1](ch12.xhtml#ch12fig1)中的那种。'
- en: '![Image](../images/f0283-01.jpg)'
  id: totrans-20
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/f0283-01.jpg)'
- en: '*Figure 12-1: An Atmel ATmega328P microcontroller chip*'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '*图12-1：一款Atmel ATmega328P微控制器芯片*'
- en: In the next few sections, we’ll walk through some common features of microcontrollers.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的几个章节中，我们将介绍一些微控制器的常见特性。
- en: '*CPU*'
  id: totrans-23
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*CPU*'
- en: Microcontrollers are based around a CPU. The CPU is usually much lower power
    than a desktop’s, in terms of both computational power and energy consumption.
    They’re often 8-bit, behaving quite similarly to retro 8-bit architectures, and
    they often don’t have floating point—as with retro machines, you need to work
    in either integers or fixed point.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 微控制器围绕CPU构建。与桌面计算机相比，这些CPU的计算能力和能耗通常要低得多。它们通常是8位的，行为与复古的8位架构非常相似，而且通常没有浮点运算——与复古计算机一样，你需要使用整数或定点数进行工作。
- en: Microcontrollers usually also include memory and I/O components on the same
    silicon as the CPU. This arrangement removes the need for external buses and reduces
    the number of pins on the microcontroller. It’s easier to build a physical system
    from a single MCU chip than to require separate chips and bus wiring.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 微控制器通常还将内存和输入输出（I/O）组件与CPU集成在同一块硅片上。这种布局消除了对外部总线的需求，并减少了微控制器上的引脚数量。相比需要分开芯片和总线布线的方式，使用单一的MCU芯片构建物理系统更为简单。
- en: '*Memory*'
  id: totrans-26
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*内存*'
- en: Because they’re intended to run a single, fixed program, microcontrollers typically
    use a Harvard architecture, with the program stored as firmware in ROM, and RAM
    used only as working memory for the program’s data. Using ROM in this way enables
    the program to remain in memory when the system is powered off, and to be immediately
    available when powered on again. Like all CPUs, microcontrollers are designed
    to fetch from a hardwired initial address on power-on, and the first instruction
    will be placed in ROM at that address.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
- en: Because it has to fit on the single chip, microcontroller memory is much smaller
    than in desktop PCs.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
- en: '*Timers and Counters*'
  id: totrans-29
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: As many real-world control tasks need to operate based on time and events in
    the real world, it’s common for timers and counters to be included in microcontrollers.
    They usually appear as extra simple machines, with their own dedicated registers
    and instructions, in the microcontroller’s CPU.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
- en: You saw how to make counters from digital logic in [Chapter 6](ch06.xhtml).
    If you connect a wire from the outside world to a counter, you can use the counter
    to count the number of occurrences of some physical event, such as the number
    of presses of a button.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
- en: A *timer* measures the amount of real time that has elapsed since it was initialized.
    Real-world time is often called “wall-clock” time in this context, as in the time
    difference that would be reported by a human looking at a physical clock on the
    wall. A timer can be made by connecting the electronic clock, as used to control
    the CPU’s cycle, to a counter.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
- en: A *watchdog* is a special timer that automatically resets the microcontroller
    in the case of failure. This is used in systems that have to be reliable in the
    real world. If something goes wrong, you need a way to reset the system without
    needing to touch the machine (think of the pacemaker example). The reset is done
    at the digital logic level and isn’t part of the CPU’s program.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
- en: Embedded I/O
  id: totrans-34
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Embedded systems exist to control physical devices, so I/O is particularly important.
    We often find I/O modules, ports, and some very basic, slow serial communication
    built into the chip itself. As microcontrollers don’t expose their bus on their
    external pins, the scarce resource of pin real estate can instead be used to expose
    I/O connections. Some microcontrollers forgo I/O modules and use direct I/O instructions
    to talk to these pins—similar to what you saw for the Commodore 64 6510.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
- en: 'I/O isn’t only important for real-time execution; it also provides a way to
    upload programs to embedded systems. Unlike with PCs, it’s usually not possible
    to do the development work on an embedded device, as this would require graphics,
    a keyboard, an operating system, and a compiler to all run on the low-power device.
    Instead, we do development work on a desktop, and perhaps test our programs there
    too using simulation or emulation, before transferring the final binary executable
    to the embedded device. Microcontrollers have special modes for doing this: usually
    they can be connected to a desktop via USB, serial port, or other means, then
    put into “firmware upgrade” mode to copy the executable into their non-volatile
    program memory via this connection and a software device driver on the desktop
    machine.'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 输入输出不仅对实时执行很重要；它还提供了一种将程序上传到嵌入式系统的方法。与PC不同，通常无法在嵌入式设备上进行开发工作，因为这需要图形界面、键盘、操作系统和编译器都在低功耗设备上运行。相反，我们通常在台式机上进行开发工作，可能还会在台式机上使用仿真或模拟进行测试，然后再将最终的二进制可执行文件传输到嵌入式设备。微控制器有专门的模式来进行此操作：通常它们可以通过USB、串口或其他方式连接到台式机，然后进入“固件升级”模式，通过这种连接和台式机上的软件设备驱动程序将可执行文件复制到它们的非易失性程序存储器中。
- en: '*Analog-Digital Conversion*'
  id: totrans-37
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*模拟-数字转换*'
- en: Many microcontrollers need to handle incoming and outgoing analog signals, but
    inside the controller signals must be digital; this requires conversion at both
    ends. The necessary converters may be found outside the microcontroller, connected
    to its pins, or in some cases on the microcontroller silicon itself.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 许多微控制器需要处理进出模拟信号，但在控制器内部，信号必须是数字信号；这需要在两端进行转换。所需的转换器可以位于微控制器外部，通过其引脚连接，或者在某些情况下位于微控制器的芯片上。
- en: The classic case of analog-digital conversion (ADC) is audio processing. An
    analog signal from a microphone is sent to a digital processor, which adds effects
    to the audio before sending the processed analog signal back out to the speakers.
    This is done by taking a continuous analog signal wave and quantizing it, turning
    it into a digital signal by sampling it at regular time intervals, as shown in
    [Figure 12-2](ch12.xhtml#ch12fig2). You can do this at different resolutions by
    taking samples more or less frequently.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 模拟-数字转换（ADC）的经典案例是音频处理。来自麦克风的模拟信号被发送到数字处理器，数字处理器对音频进行特效处理后，再将处理过的模拟信号传送回扬声器。这是通过将连续的模拟信号波形量化来完成的，转换为数字信号的过程是通过在固定时间间隔内采样来实现的，如[图12-2](ch12.xhtml#ch12fig2)所示。你可以通过更频繁或更不频繁地采样来在不同的分辨率下进行此操作。
- en: '![Image](../images/f0285-01.jpg)'
  id: totrans-40
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/f0285-01.jpg)'
- en: '*Figure 12-2: Quantizing an analog signal to digital*'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '*图12-2：将模拟信号量化为数字信号*'
- en: When converting the other way, digital-analog conversion (DAC), some devices
    (like the Arduino Due) do true conversion of digital integers to analog voltages.
    Cheaper ones (such as the Arduino Uno) approximate the conversion with pulse-width
    modulation (PWM). Here, the output is only ever 0 V or 5 V. If 3 V is asked for,
    the output oscillates rapidly between 0 V and 5 V, spending three-fifths of its
    time at 5 V and two-fifths at 0 V, to give a temporal average of 3 V. For some
    applications this creates no noticeable difference, but for others it can play
    havoc with the output.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在进行反向转换时，即数字-模拟转换（DAC），一些设备（如Arduino Due）可以将数字整数真正转换为模拟电压。较便宜的设备（如Arduino Uno）则通过脉冲宽度调制（PWM）来近似完成转换。在这种情况下，输出信号只有0
    V或5 V。如果需要3 V，输出会在0 V和5 V之间迅速振荡，其中三分之五的时间为5 V，二分之五的时间为0 V，从而给出一个时间平均值为3 V。对于一些应用，这不会造成明显的差异，但对于其他应用，它可能会破坏输出结果。
- en: '*Embedded Serial Ports*'
  id: totrans-43
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*嵌入式串口*'
- en: The serial ports seen in the previous chapter continue to be used heavily today
    in embedded systems, due to their simplicity and stability. In the projects you
    do here, you’re more likely to see this convention in a virtualized form, as you
    don’t often see a physical serial port on a modern computer these days. Instead,
    you can use something like USB to emulate the old-fashioned serial port protocols.
    Similarly, the *Zigbee* wireless protocol acts as a virtual serial port running
    over a specific radio frequency; it’s used by embedded devices such as programmable
    light bulbs and transportation and agriculture sensor networks.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
- en: '*Inter-Integrated Circuit Bus*'
  id: totrans-45
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The *Inter-Integrated Circuit bus*, pronounced “eye-two-see” (written as I²C
    and sometimes pronounced “eye-squared-see”), is a standard for connecting chips
    together. It’s very common in robotics. The standard is owned and licensed by
    NXP (formerly Phillips).
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
- en: 'I²C communication is done on just two wires: data (SDA) and clock (SDL), as
    shown in [Figure 12-3](ch12.xhtml#ch12fig3).'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/f0286-01.jpg)'
  id: totrans-48
  prefs: []
  type: TYPE_IMG
- en: '*Figure 12-3: The I²C architecture*'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
- en: I²C can use 5 V or 3.3 V as its high voltage, and runs in various speed modes,
    from 100Kbps to 3Mbps. There may be multiple devices on the bus, each having a
    7-bit licensed device address. One node must take on the role of manager by generating
    the clock and initiating communications. The other nodes are workers, which reply
    to the manager. Basic message collision avoidance is implemented by the rule “only
    talk if the bus is free.”
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
- en: In practice, I²C devices can be accessed via a standard FTDI (Future Technology
    Devices International Ltd) chip, which provides a hardware and software interface
    to it, usually via a serial connection (which itself is usually via a USB port).
    Examples of an I²C device (an inertial measurement unit sensor) and an FTDI for
    interfacing to it are shown in [Figure 12-4](ch12.xhtml#ch12fig4).
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/f0287-01.jpg)'
  id: totrans-52
  prefs: []
  type: TYPE_IMG
- en: '*Figure 12-4: An I²C device (left) and FTDI interface (right)*'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
- en: No extra device drivers are needed for transport—the FTDI behaves as a serial
    port to the user.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
- en: '*Controller Area Network Bus*'
  id: totrans-55
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: A *vehicle bus* is a specialized internal communications network that interconnects
    components inside a vehicle such as an automobile, train, ship, aircraft, or robot.
    A *controller area network (CAN)* bus is a type of vehicle bus that has a single
    public serial channel shared by all devices. CAN has no standard connector, as
    it isn’t intended for use by consumers, but rather for the internals of vehicles.
    Usually its wires are soldered directly into the printed circuit boards (PCBs)
    of the many devices in the vehicle. If you remove the plastic covering in front
    of the passenger seat in a car, you’ll usually find a wiring loom, which will
    include accessible CAN wires. Check your vehicle’s service documents to locate
    and connect to them.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
- en: CAN usually has four internal wires, which use differential voltages to protect
    against the strong external electromagnetic fields expected in vehicles, especially
    around electric motors and engines.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: CAN 通常有四根内部线，这些线使用差分电压来抵御车辆中预计会出现的强外部电磁场，特别是在电动机和发动机周围。
- en: CAN security is a current concern. Because it’s a bus, all devices can read
    and write to it. This may create problems when safety-critical devices, such as
    antilock brakes, are connected to the same bus as non-critical devices, such as
    media players. The concern is that security in media and similar devices is typically
    less rigorous than in the safety equipment. A hacker could take control of a non-critical
    device and use it to send malicious commands to critical devices, or deny service
    to them by filling the bus with junk messages. For autonomous vehicles where steering
    and acceleration are also managed via the CAN bus, the consequences could be particularly
    severe.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: CAN 安全是当前的一个关注点。由于它是一个总线，所有设备都可以读取和写入数据。当安全关键设备，如防抱死刹车，和非关键设备，如媒体播放器，连接到同一总线上时，这可能会导致问题。担忧的地方在于，媒体和类似设备的安全性通常不如安全设备严格。黑客可能会控制一个非关键设备，并利用它向关键设备发送恶意指令，或通过填充总线垃圾消息来拒绝服务。对于自动驾驶车辆而言，转向和加速也通过
    CAN 总线管理，其后果可能特别严重。
- en: Now that you’ve seen the general concepts that go into an embedded system, let’s
    explore how they show up in practice in the best-known example, the Arduino.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经了解了嵌入式系统的一般概念，接下来让我们探讨这些概念在实际应用中的体现，最著名的例子就是 Arduino。
- en: Arduino
  id: totrans-60
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Arduino
- en: '*Arduino*, shown in [Figure 12-5](ch12.xhtml#ch12fig5), is the standard embedded
    system for hackers, makers, and robotics researchers because it packages a microcontroller
    onto a PCB together with all the power management and I/O that you need to program
    it from a PC—you can just connect it to your desktop via USB and start programming
    it, without having to worry about analog power supplies or setting up its USB
    I/O system by yourself.'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '*Arduino*，如[图 12-5](ch12.xhtml#ch12fig5)所示，是黑客、创客和机器人研究人员的标准嵌入式系统，因为它将微控制器与所有需要的电源管理和输入输出功能封装在一个
    PCB 上，你可以通过 USB 直接将其连接到桌面计算机并开始编程，而无需担心模拟电源或自行设置其 USB 输入输出系统。'
- en: '![Image](../images/f0288-01.jpg)'
  id: totrans-62
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/f0288-01.jpg)'
- en: '*Figure 12-5: An Arduino board. The ATmega328P microcontroller is the large
    chip near the bottom right.*'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 12-5：一个 Arduino 开发板。ATmega328P 微控制器是位于右下角的大芯片。*'
- en: The Arduino PCB is an open source hardware design based around a microcontroller
    from the closed source Atmel AVR family, usually the ATmega328 model. The microcontroller
    is surrounded by additional hardware that makes powering and interfacing with
    it both easy and standard. These components were the traditional barrier to computer
    scientists programming microcontrollers, as they have to be made up on breadboards
    or PCBs for every project, requiring analog electronics skills. The cleverness
    of the Arduino design was to select and standardize a single set of these components
    that are generally useful for many applications, and to manufacture them cheaply
    in bulk so that end users don’t have to worry about them anymore. Arduino comes
    with open source software to easily assemble and transfer programs via USB into
    its firmware. (There’s also a C-like language and compiler, but as this book is
    about the architectural level, we’ll here study only Arduino’s assembly-level
    programming.)
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: Arduino PCB 是一个基于闭源 Atmel AVR 系列微控制器（通常是 ATmega328 型号）的开源硬件设计。微控制器周围是一些额外的硬件，这些硬件使得给其供电和与之接口变得既简单又标准化。这些组件曾是计算机科学家编程微控制器的传统障碍，因为它们需要在每个项目中通过面包板或
    PCB 来搭建，需要模拟电子学技能。Arduino 设计的巧妙之处在于选择并标准化了一套通常适用于多种应用的组件，并将其大规模低价生产，这样最终用户就不再需要为此担心。Arduino
    提供了开源软件，允许用户通过 USB 轻松地将程序传输到固件中。（这里还有类似 C 的语言和编译器，但由于本书侧重于架构层次，我们这里只研究 Arduino
    的汇编级编程。）
- en: You can program Arduino by itself—for example, to read numbers sent to it over
    USB from your desktop, do arithmetic on them, and send the results to your desktop.
    However, Arduino is usually used to interface with other electronic sensors and
    actuators, starting with LEDs and switches. Typically you lay these out on a breadboard,
    then connect wires from the breadboard to your Arduino, as in [Figure 12-6](ch12.xhtml#ch12fig6).
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/f0289-01.jpg)'
  id: totrans-66
  prefs: []
  type: TYPE_IMG
- en: '*Figure 12-6: An I/O circuit connecting an LED and button to an Arduino using
    a breadboard and wires*'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
- en: No soldering is required, as components and wires can be pushed into place in
    both the breadboard and the Arduino’s connectors.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
- en: '*The ATmega328 Microcontroller*'
  id: totrans-69
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The classic Arduino microcontroller, the Atmel AVR ATmega328, shown in [Figure
    12-1](ch12.xhtml#ch12fig1), behaves somewhat like an old-style 8-bit system such
    as a 6502\. There are 32 8-bit user registers (more than the three of the 6502).
    There’s an arithmetic logic unit (ALU) that includes integer multiplication and
    division, but no floating point. Similar to the 6502, there’s an 8-bit status
    register, containing bits telling you the result of arithmetic calculations to
    allow branching. The instruction set architecture (ISA) includes indirect addressing
    and a hardware stack. It’s usually clocked around 20 MHz.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
- en: The pinout, shown in [Figure 12-7](ch12.xhtml#ch12fig7), is different from a
    typical CPU, as there’s no external bus.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/f0289-02.jpg)'
  id: totrans-72
  prefs: []
  type: TYPE_IMG
- en: '*Figure 12-7: The pinout of the ATmega328 (note the lack of A and D bus pins)*'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
- en: Instead of an external bus, 14 I/O pins are directly exposed. Pins increase
    the size of the chip’s package, so they’re a scarce resource. The I/O pins are
    each configurable to function as either input or output. Their configuration is
    set and stored using dedicated data direction registers (DDRs).
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
- en: The die shot ([Figure 12-8](ch12.xhtml#ch12fig8)) reveals that the microcontroller
    contains more than just a CPU.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/f0290-01.jpg)'
  id: totrans-76
  prefs: []
  type: TYPE_IMG
- en: '*Figure 12-8: A die shot of the ATmega328*'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
- en: In addition to a CPU, the chip has 2 k[2]B of SRAM, 32 k[2]B of flash memory,
    and a 1 k[2]B EEPROM, all on the silicon. In this sense, the chip is really more
    comparable to an entire retro computer than to only a CPU.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
- en: 'The Arduino uses a Harvard architecture. The program you send to the board
    is programmed into the flash memory using software on your host PC, while the
    RAM is used for data. (The EEPROM is user-writable, and is provided for applications
    where small configuration-style data needs to be stored during power-off.) The
    Harvard architecture uses two separate buses: an 8-bit bus for data and a 16-bit
    bus for programs. There’s no external memory or bus; the memory is all on the
    chip.'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
- en: The microcontroller contains serial port pins and I/O modules. On power-on,
    the microcontroller first runs a small internal ROM program that checks its serial
    port. If there’s data waiting on the serial port, it’s assumed to be a new user
    program, which is then loaded into flash. The program counter is set to start
    the user program.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 微控制器包含串口引脚和 I/O 模块。在上电时，微控制器首先运行一个小的内部 ROM 程序，检查它的串口。如果串口上有等待的数据，则认为这是一个新的用户程序，并将其加载到闪存中。程序计数器被设置为启动用户程序。
- en: '*The Rest of the Arduino Board*'
  id: totrans-81
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*Arduino 板的其他部分*'
- en: While it’s possible to program the ATmega directly from its serial port pins,
    most desktop machines don’t have physical serial ports anymore, so it’s easier
    for users to use a virtual serial port running over USB. The Arduino board includes
    a USB connector and a dedicated chip (actually another, smaller microcontroller)
    that reads the USB wires and translates them into serial port signals to pass
    to the ATmega’s pins.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管可以直接从 ATmega 的串口引脚编程，但大多数桌面计算机现在没有物理串口了，因此用户使用通过 USB 运行的虚拟串口会更方便。Arduino 板包含一个
    USB 连接器和一个专用芯片（实际上是另一个较小的微控制器），它读取 USB 线并将其转换为串口信号，传递到 ATmega 的引脚。
- en: Most of the analog electronics on the board are used for power management. The
    microcontroller requires only a simple 5 V power supply. If a single, stable 5
    V is provided, then no further electronics would be needed. However, Arduino is
    designed to work in several different use cases. In particular, it can be powered
    by a battery or can take power via a USB cable. The extra components regulate
    these supplies, protecting the board from peaks and dips, and enabling it to switch
    between them. (It could otherwise be very bad to allow current from elsewhere
    to travel back up the USB cable into the connected desktop computer.)
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 板上的大多数模拟电子元件用于电源管理。微控制器只需要一个简单的 5 V 电源。如果提供一个稳定的 5 V 电源，那么就不需要其他电子元件。然而，Arduino
    设计时考虑了多种不同的使用场景。特别是，它可以通过电池供电，也可以通过 USB 电缆获取电源。额外的组件调节这些电源，保护板免受电压波动的影响，并使它能够在它们之间切换。（否则，如果让来自其他地方的电流返回
    USB 电缆进入连接的桌面计算机，那会非常糟糕。）
- en: An I²C bus enables extra extensions to plug into the Arduino. You can get other
    physical boards (“shields”) that plug into ports on the I²C bus, in a nice, physically
    stackable way.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: I²C 总线使得可以为 Arduino 插入额外的扩展模块。你可以获取其他物理板（“扩展板”），它们可以以一种整齐、可堆叠的方式插入到 I²C 总线的端口中。
- en: As it’s an open source platform, Arduino has been modified by many designers.
    For example, Ruggeduino is a hardened (and thus more expensive) version that includes
    extra safeguards to prevent you from blowing it up in stupid ways. There are also
    official variants from the Arduino team. The Due is a version with real DACs replacing
    PWM, the Mega and Giga have larger PCBs to enable more connections, and the Nano
    has a smaller footprint. Some variants use different microcontrollers, providing
    more computing power and different instruction sets for those who need or prefer
    them.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 由于它是一个开源平台，Arduino 已经被许多设计师修改过。例如，Ruggeduino 是一个强化版（因此也更贵），它包含了额外的保护措施，以防止你以愚蠢的方式损坏它。Arduino
    团队也有官方的变种。Due 是一个用真实 DAC 替代 PWM 的版本，Mega 和 Giga 有更大的 PCB，以支持更多连接，而 Nano 则有更小的尺寸。一些变种使用不同的微控制器，为需要或偏好这些功能的人提供更多的计算能力和不同的指令集。
- en: '*Programming Arduino*'
  id: totrans-86
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*编程 Arduino*'
- en: 'Like all CPUs, Atmel AVRs execute machine code from an instruction set, which
    you can program by assembling from a human-readable assembly language. The Arduino
    assembler isn’t very different from the other assemblers we’ve seen so far. You
    can write, edit, and assemble this assembly code on your desktop PC. The classic
    “Hello, world!” program for Arduino is to turn on its built-in LED on pin 13:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 像所有的 CPU 一样，Atmel AVRs 执行来自指令集的机器码，你可以通过从人类可读的汇编语言中汇编程序来进行编程。Arduino 的汇编器与我们迄今为止看到的其他汇编器没有太大区别。你可以在桌面
    PC 上编写、编辑并汇编这些汇编代码。Arduino 的经典 "Hello, world!" 程序是打开其内建的 13 号引脚上的 LED：
- en: '[PRE0]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The global `main` label gets called automatically when the Arduino is powered
    on. The `ldi` instruction is “load immediate,” and it loads a constant into a
    register. This particular constant contains 8 bits, one for each of the AVR’s
    eight digital I/O pins (labeled PB0 through PB7 in [Figure 12-7](ch12.xhtml#ch12fig7)).
    They’re all set to 0, except for pin PB5 (counting right to left, from PB0, along
    the binary digits), which is set to 1\. The AVR’s PB5 pin is wired to the Arduino
    PCB’s pin 13 and thus to the LED. The first `out` instruction copies the bits
    from r16 to 0x04, the data direction register, to configure the pins for I/O.
    This sets PB5 to act as an output and the other seven pins to act as inputs. The
    second `out` writes the same bits from r16 to 0x05, the “PortB” register, which
    sets values to output on the eight PB pins. This writes the 1 to PB5 and thus
    sends a high voltage to turn on the LED on Arduino pin 13.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
- en: Unlike many CPU programs, the `loop` label and jump are important because they
    keep the program running forever. Without these, the LED would light only for
    a fraction of a second, then go off as the program ends. Embedded programs usually
    need to run forever like this.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
- en: 'A more complex version of the program makes the LED blink on and off:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: To make the code easier to read, I have here defined DDRB and PINB to represent
    the data direction register and PortB register. One millisecond is about 16,000
    cycles at 16 MHz. The inner loop takes four cycles, so we repeat it 3,000 times.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
- en: '*The AVR also has some 16-bit instructions that operate on pairs of 8-bit registers
    together, as in the 6502.*'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
- en: Other CPU-Based Embedded Systems
  id: totrans-96
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Arduino isn’t the only CPU-based embedded system in town. Let’s look at some
    alternatives that you might encounter.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
- en: '*Atmel AVR Without the Arduino*'
  id: totrans-98
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Arduino is designed for computer scientists, not engineers. You wouldn’t normally
    sell a product based on a full Arduino board. Rather, you would create a custom
    PCB containing the AVR chip plus only the electronics that are needed, both from
    the Arduino board and from your own design.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
- en: As an intermediate step, you can use a breadboard without the Arduino to mount
    the AVR and other electronics, as in [Figure 12-9](ch12.xhtml#ch12fig9).
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/f0293-01.jpg)'
  id: totrans-101
  prefs: []
  type: TYPE_IMG
- en: '*Figure 12-9: A breadboard implementation using an AVR microcontroller*'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
- en: Once you’re happy that your design is working, you turn it into a PCB design
    using a program such as *KiCAD*, submit it to a PCB manufacturing company using
    their website, and receive your PCB in a few days through the mail. You don’t
    have to solder things yourself nowadays, the PCB manufacturing companies have
    robots that do it for you.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
- en: '*PIC Microcontrollers*'
  id: totrans-104
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '*PIC* is another series of microcontrollers, similar to but different from
    the AVR series. As with Arduinoless AVR, PICs require breadboards, PCB design,
    and serial ports.'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
- en: PICs are designed by the American company Microchip, who bought out their competitor
    Atmel in 2016\. PICs are found in many consumer and industrial embedded systems.
    There are a number of PICs to choose from; you decide which to buy based on your
    needs in terms of speed, power, cost, and physical size. Because of the wide range
    of options, PICs are more popular than Arduino/AVR in production engineering.
    The flexibility allows a selected PIC version to be closely matched to its application
    needs.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
- en: '*Digital Signal Processors*'
  id: totrans-107
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '*Digital signal processors (DSPs)* are a specialized class of microcontroller
    designed for handling real-time signals, such as audio. Embedded systems working
    with such signals have particular requirements, as they’re fundamentally working
    with long—effectively endless—real-time streams of identically formatted data
    that have to be processed repeatedly in identical ways. This means there isn’t
    much branching; instead, the data flows through a smooth pipeline from one stage
    to the next, always being processed in the same way.'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
- en: For example, guitarists often buy and use digital effects boxes that connect
    between their guitar and amplifier to modify the sound (by adding compression,
    distortion, delay, or reverb, for example). These boxes are embedded systems containing
    one or more DSPs, such as the chip shown in [Figure 12-10](ch12.xhtml#ch12fig10).
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/f0294-01.jpg)'
  id: totrans-110
  prefs: []
  type: TYPE_IMG
- en: '*Figure 12-10: A DSP chip inside a guitar digital effects unit*'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
- en: DSPs aren’t only for audio signals, though. There are many other types of signals
    with similar properties, such as video, radar, and data streams from all kinds
    of medical and scientific monitoring instruments. With sound and sound-like data,
    you can often mostly get away with representing directly quantized sound waves
    from the ADC. With video, however, the data is usually so huge that it needs to
    be compressed during storage and transmission, which means many DSP units are
    used primarily to perform compression and decompression.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
- en: DSPs often use fixed-point number representation (as discussed in [Chapter 2](ch02.xhtml))
    rather than integers or floating point. This is because most signals have clear,
    fixed upper and lower bounds that can be rescaled to +1.0 and –1.0\. For example,
    musical audio is usually recorded in this way, with any signal outside these bounds
    being clipped. Fixed point is cheaper and simpler to implement than floating point,
    but can give similar quality results for these kinds of signals.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
- en: DSPs use their available silicon to provide additional instructions dedicated
    to signal processing. (Recall from [Chapter 8](ch08.xhtml) that adding extra domain-specific
    instructions like this is often considered to be the CISC philosophy.) For example,
    special instructions for fast Fourier transforms and convolution are found in
    DSPs designed for embedded audio use, as these operations form the basis of many
    standard audio processing algorithms. These usually operate in fixed point. As
    DSPs are designed to process large streams of data, they sometimes include additional
    instructions that load and store chunks of data larger than single words. Such
    instructions may trigger a sequence of transfers over the bus from a series of
    neighboring memory locations to a group of registers. Similarly, I/O instructions
    may trigger a series of ADCs to and from these groups of registers.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
- en: As with standard microcontrollers, DSPs use a Harvard architecture, so that
    firmware can be placed in ROM during manufacture, then left alone to run forever.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
- en: Embedded Systems with No CPU
  id: totrans-116
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The embedded systems we’ve seen so far have been microcontroller-based, meaning
    they’re still based around a CPU that executes programs of machine code instructions.
    But there are also other, simpler styles of embedded systems where there’s no
    CPU, no program, and no instruction set. There’s only hardware that you lay out
    to compute what you want to be computed, using digital logic circuits. These systems
    include PLCs and FPGAs.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
- en: '*Programmable Logic Controllers*'
  id: totrans-118
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '*Programmable logic controllers (PLCs)* are a type of embedded system designed
    to perform simple computations to control machinery in industrial environments,
    with very high reliability. They’re usually found in factories with dust, chemicals,
    bits of food, high and low temperatures, and other extreme conditions that make
    life hard for normal chips. The idea is to install something durable that can
    operate continuously for 20 years, without ever going down. Systems have to be
    almost indestructible, utterly reliable, and as simple as possible to avoid any
    kind of bugs slipping in. In this context of industrial automation, embedded systems
    are sometimes known as *supervisory control and data acquisition (SCADA)* systems.'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
- en: You’ll see PLCs in these kinds of environments, usually packaged in what are
    called DIN modules and mounted on standard DIN rails, as in [Figure 12-11](ch12.xhtml#ch12fig11).
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
- en: In your house—often in a basement or under the stairs—you might have a DIN-style
    module that acts as a fuse box or circuit breaker (aka a residual current device,
    or RCD) for your whole house. Again, it’s robust engineering that’s designed not
    to fail under any normal operating circumstances. The DIN design was standardized
    in the 1970s and is still with us today.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/f0296-01.jpg)'
  id: totrans-122
  prefs: []
  type: TYPE_IMG
- en: '*Figure 12-11: DIN modules mounted on a DIN rail*'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
- en: A PLC doesn’t run a program in the sense of a series of instructions; instead,
    its function is usually specified using a visual system called *ladder logic*,
    as shown in [Figure 12-12](ch12.xhtml#ch12fig12).
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/f0296-02.jpg)'
  id: totrans-125
  prefs: []
  type: TYPE_IMG
- en: '*Figure 12-12: An example of a ladder logic configuration for an embedded device*'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
- en: In essence, ladder logic is a set of if-then rules that say that if one input
    is high, then connect a wire to another wire. There’s no program starting at the
    top and working through a list of instructions; each unit follows the logic of
    the rules around it. It’s derived from the old days where you’d make computers
    from physical electromechanical relays.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
- en: Ladder logic is so simple that even engineers can do it. But the simplicity
    also means that both formal methods and intuitive inspection can be used to verify
    that systems do exactly what they’re supposed to do. You wouldn’t want all the
    complexity of an operating system and modern programming languages and compilers
    when even tiny bugs in any of that could cause your nuclear fuel rods to move
    to the wrong place; everything has to be absolutely reliable and understandable.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
- en: PLCs are simple, completely transparent, and verifiable. It may surprise you
    to learn that the engineers programming this equipment often make more than most
    computer scientist programmers, but they’re also getting paid to take responsibility
    for safety. The program might exist as part of a nuclear power station where,
    even if the program is very simple, it has to be very correct. You don’t have
    to design PLCs by directly configuring the ladder logic anymore; there are now
    compilers and assemblers that will turn C code into these configurations for you.
    Doing this, of course, requires trusting the compiler and assembler programs,
    as well as your own code.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
- en: '**EMBEDDED SECURITY**'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
- en: SCADA systems should never be connected to the public internet. A famous leading
    question used in security audits asks SCADA managers, “How would you connect to
    the system in an emergency, when all the staff are away working at home and they
    need to take over control remotely before the nuclear fuel rod goes critical?”
    A worrying number of managers will then proudly explain that they do in fact have
    such a connection, which of course can be exploited by hackers.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
- en: Even when there’s no internet connection and the system is separated from the
    network by an “air gap,” it is possible to gain access. The 2010 Stuxnet worm
    was distributed on USB sticks left around international academic conferences.
    It replicated itself from USB stick to USB stick around the world until it reached
    the Iranian nuclear weapons fuel enrichment centrifuge embedded systems. Stuxnet
    then affected only their specific model and configuration of PLC, altering its
    behavior very subtly and almost undetectably to change the timing of the centrifuges,
    destroying them and preventing enrichment of the fuel.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
- en: '*Embedded FPGAs*'
  id: totrans-133
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The FPGA (field programmable gate array) chips discussed in [Chapter 5](ch05.xhtml)
    can be used to actualize any digital logic designs—not only those intended for
    use in or with CPUs. This can include PLC-like structures and many other digital
    logic network designs.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
- en: As embedded systems perform single functions, a CPU design capable of running
    arbitrary programs of instructions may be both overkill and inefficient. Instead,
    the particular sequence of arithmetic or other transformations can be implemented
    directly as a sequence of simple machines, pipelined together in an FPGA. This
    can include, for example, placing multiple adders and multipliers connected in
    the specific sequence needed to implement your signal processing algorithm. In
    addition to reducing the CPU-style paraphernalia needed, this can also make systems
    run very fast, as all these arithmetic operations can happen in parallel.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
- en: Hardware description languages can be especially useful for creating such designs.
    For example, they enable the arithmetic steps to be expressed in a C-like language
    before being automatically compiled to the appropriate digital logic.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
- en: '**UBIQUITOUS VS. MINDFUL COMPUTING**'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
- en: '*Ubicomp*, or Ubiquitous Computing, is an embedded design philosophy founded
    by Marc Wiser in the 1980s Xerox PARC (the same place where the mouse and graphical
    desktop were invented). Its core idea, as outlined by Marc Weiser, is that “the
    purpose of a computer is to help you do something else. The best computer is a
    quiet, invisible servant. The more you can do by intuition the smarter you are;
    the computer should extend your unconscious. Technology should create calm.”'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
- en: Ubicomp shows up in products such as Amazon’s Alexa. It sits invisibly in your
    house, and when you want something, you say it out loud and it gets done for you.
    There’s no need for you to sit down at a computer and think about how to do it.
    Ubicomp ideas have also returned in recent fields such as “pervasive computing”
    and the Internet of Things.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
- en: There has recently been a counter-movement against Ubicomp, which we might call
    *mindful computing*. Its adherents have decided that users don’t want decisions
    made for them by an uncertain, non-understood corporate cloud. They’re freaked
    out about losing control to these machines. Mindful computing therefore does the
    opposite, deliberately drawing attention to the technology and forcing users to
    think about and understand the machines they’re using.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
- en: According to a Ubicomp philosophy, light switches might disappear as machines
    automatically predict when the lights should turn themselves on and off without
    your input. According to mindful computing, the light switches should remain,
    and the user should devote their full conscious attention to becoming at one with
    the light switch as they touch it.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-142
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Embedded architectures form the vast bulk of the world’s computers, yet by their
    nature they’re often invisible to most users. Their applications exist at the
    border between computing and engineering, but their architectures can be quite
    similar to those of retro computers, and they provide an interesting place for
    fans of that style of computing to work today. Most embedded systems are based
    on microcontrollers, which are chips that combine a low-power CPU with onboard
    memory, I/O, and other useful features. Arduino is a standard embedded platform
    that wraps most of the engineering needed for computer scientists to get started
    interfacing to hardware such as robots, factories, cars, and art installations.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
- en: Exercises
  id: totrans-144
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Simulated Arduino Programming**'
  id: totrans-145
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Use the open source Wokwi Arduino emulator to run the example Arduino programs
    shown in this chapter. To use the assembler, go to the blink.S tab at *[https://wokwi.com/arduino/projects/290348681199092237](https://wokwi.com/arduino/projects/290348681199092237)*,
    or find the offline version at *[https://github.com/arcostasi/avr8js-electron-playground](https://github.com/arcostasi/avr8js-electron-playground)*.
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Remember that Arduino’s I/O pins are each configurable to act as inputs or outputs.
    If a pin isn’t reading or writing as expected, check that you’ve put it into the
    right mode first.
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Instead of the nested delay loops used in the LED blinking program, a prettier
    and more energy-efficient way to program blinking lights is to use the AVR’s built-in
    timer. Research what registers and commands are needed to do it this way, and
    implement this alternative version.
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Challenging**'
  id: totrans-149
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: There are many affordable Arduino starter kits available; obtain one and try
    to run the example programs on the real hardware. When working with real LEDs,
    remember that as diodes they’re directional and must be connected the right way
    around and always in parallel with a resistor; otherwise, they’ll explode!
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Most kits come with some additional sample programs written in Arduino C; try
    to reproduce their functionality using your own handwritten AVR assembly. (If
    stuck, try compiling the Arduino C into assembly and inspecting that to get ideas.)
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If you prefer command line tools to the Arduino IDE, AVRA is the AVR assembler,
    and AVRDUDE is the AVR downloader/uploader.
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Further Reading
  id: totrans-153
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: For a famous parable about engineers’ and computer scientists’ differing opinions
    on embedded design, see Do-While Jones, “The Breakfast Food Cooker.” Various versions
    can be found around the internet, dating from 1990.
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For a full reference for the AVR instruction set, see Atmel, “AVR-Instruction-Set-Manual,”
    2016, *[https://ww1.microchip.com/downloads/en/DeviceDoc/Atmel-0856-AVR-Instruction-Set-Manual.pdf](https://ww1.microchip.com/downloads/en/DeviceDoc/Atmel-0856-AVR-Instruction-Set-Manual.pdf)*.
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For an Arduino PCB design explanation and CAD files, see the “Arduino from Scratch”
    series, *[https://rheingoldheavy.com/arduino-from-scratch-series](https://rheingoldheavy.com/arduino-from-scratch-series)*.
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For information on programming PIC microcontrollers, see “PIC Programming in
    Assembly,” *[https://groups.csail.mit.edu/lbr/stack/pic/pic-prog-assembly.pdf](https://groups.csail.mit.edu/lbr/stack/pic/pic-prog-assembly.pdf)*.
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To get your hands dirty with a CAN bus, see Jared Reabow, “How to Hack and Upgrade
    Your Car Using CAN Bus and Arduino,” *[https://www.instructables.com/How-to-Hack-and-Upgrade-Your-Car-Using-CAN-Bus/](https://www.instructables.com/How-to-Hack-and-Upgrade-Your-Car-Using-CAN-Bus/)*.
    The tutorial includes instructions for making a *Back to the Future*–style date
    and time display.
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Hackaday (*[https://www.hackaday.com](https://www.hackaday.com)*) is a well-known
    website for embedded project ideas.
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
