- en: '**11**'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '**11**'
- en: '**RECORD, UNION, AND CLASS DATA TYPES**'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '**记录、联合体和类数据类型**'
- en: '![image](../images/common01.jpg)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/common01.jpg)'
- en: 'Records, unions, and classes are popular composite data types found in many
    modern programming languages. Incorrectly used, these data types can have a very
    negative impact on the performance of your software. Correctly used, however,
    they can actually improve the performance of your applications (compared with
    using alternative data structures). In this chapter we’ll explore how you can
    make the most of these data types to maximize the efficiency of your programs.
    The topics this chapter covers include:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 记录、联合体和类是许多现代编程语言中常见的复合数据类型。使用不当时，这些数据类型可能对软件性能产生非常负面的影响。然而，正确使用时，它们实际上可以提高应用程序的性能（与使用替代数据结构相比）。在本章中，我们将探讨如何充分利用这些数据类型，以最大化程序的效率。本章涵盖的主题包括：
- en: Definitions for the record, union, and class data types
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 记录、联合体和类数据类型的定义
- en: Declaration syntax for records, unions, and classes in various languages
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 各种语言中记录、联合体和类的声明语法
- en: Record variables and instantiation
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 记录变量和实例化
- en: Compile-time initialization of records
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 记录的编译时初始化
- en: Memory representation of record, union, and class data
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 记录、联合体和类数据的内存表示
- en: Using records to improve runtime memory performance
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用记录来提高运行时内存性能
- en: Dynamic record types
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 动态记录类型
- en: Namespaces
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 命名空间
- en: Variant data types and their implementation as a union
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 变体数据类型及其作为联合体的实现
- en: Virtual method tables for classes and their implementation
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类的虚方法表及其实现
- en: Inheritance and polymorphism in classes
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类中的继承与多态
- en: The performance cost associated with classes and objects
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类和对象相关的性能开销
- en: Before we get into the details of how you can implement these data types to
    produce code that is more efficient, easier to read, and easier to maintain, let’s
    begin with some definitions.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们深入探讨如何实现这些数据类型以生成更高效、更易读和更易维护的代码之前，先从一些定义开始。
- en: '**11.1 Records**'
  id: totrans-17
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**11.1 记录**'
- en: The Pascal *record* and the C/C++ *structure* are terms used to describe comparable
    composite data structures. Language design textbooks sometimes refer to these
    types as *Cartesian products* or *tuples*. The Pascal terminology is probably
    best, because it avoids confusion with the term *data structure*, so we’ll use
    *record* here. Regardless of what you call them, records are a great tool for
    organizing your application data, and a good understanding of how languages implement
    them will help you write more efficient code.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: Pascal中的*记录*和C/C++中的*结构*是用于描述可比的复合数据结构的术语。语言设计教材有时将这些类型称为*笛卡尔积*或*元组*。Pascal的术语可能是最好的，因为它避免了与*数据结构*一词的混淆，因此我们在这里使用*记录*。无论你称其为何种名称，记录都是组织应用程序数据的一个极好工具，对语言如何实现它们有良好的理解将帮助你编写更高效的代码。
- en: An array is *homogeneous*, meaning that its elements are all of the same type.
    A record, on the other hand, is *heterogeneous*—its elements can have differing
    types. The purpose of a record is to let you encapsulate logically related values
    into a single object.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 数组是*同质的*，意味着其元素都是相同类型的。另一方面，记录是*异质的*——其元素可以具有不同类型。记录的目的是将逻辑相关的值封装为一个对象。
- en: Arrays let you select a particular element via an integer index. With records,
    you must select an element, known as a *field*, by the field’s name. Each of the
    field names within the record must be unique; that is, you can’t use the same
    name more than once in the same record. However, all field names are local to
    their record, so you may reuse those names elsewhere in the program.^([1](footnotes.xhtml#ch11fn1))
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 数组让你通过整数索引选择特定元素。使用记录时，你必须通过字段的名称选择一个元素，该元素称为*字段*。记录中的每个字段名称必须唯一；也就是说，不能在同一个记录中使用相同的名称多次。然而，所有字段名称仅限于其记录，因此你可以在程序中的其他地方重复使用这些名称。^([1](footnotes.xhtml#ch11fn1))
- en: '**11.1.1 Declaring Records in Various Languages**'
  id: totrans-21
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**11.1.1 在各种语言中声明记录**'
- en: Before discussing how various languages implement record data types, we’ll take
    a quick look at the declaration syntax for some of them, including Pascal, C/C++/C#,
    Swift, and HLA.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在讨论各种语言如何实现记录数据类型之前，我们将快速查看其中一些语言的声明语法，包括Pascal、C/C++/C#、Swift和HLA。
- en: '**11.1.1.1 Record Declarations in Pascal/Delphi**'
  id: totrans-23
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**11.1.1.1 Pascal/Delphi中的记录声明**'
- en: 'Here’s a typical record declaration for a `student` data type in Pascal/Delphi:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 这是Pascal/Delphi中`student`数据类型的典型记录声明：
- en: '[PRE0]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: A record declaration consists of the keyword `record`, followed by a sequence
    of *field declarations*, and ending with the keyword `end`. The field declarations
    are syntactically identical to variable declarations in the Pascal language.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 记录声明由关键字 `record` 开始，后跟一系列 *字段声明*，并以关键字 `end` 结束。字段声明的语法与 Pascal 语言中的变量声明完全相同。
- en: Many Pascal compilers allocate all of the fields in contiguous memory locations.
    This means that Pascal will reserve the first 65 bytes for the name,^([2](footnotes.xhtml#ch11fn2))
    the next 2 bytes hold the major code, the next 12 bytes the Social Security number,
    and so on.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 许多 Pascal 编译器将所有字段分配到连续的内存位置。这意味着 Pascal 会为名字预留前 65 字节，接下来的 2 字节存储主代码，接下来的 12
    字节存储社会安全号码，依此类推。
- en: '**11.1.1.2 Record Declarations in C/C++**'
  id: totrans-28
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**11.1.1.2 C/C++ 中的记录声明**'
- en: 'Here’s the same declaration in C/C++:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 这是 C/C++ 中相同的声明：
- en: '[PRE1]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Record (structure) declarations in C/C++ begin with the keyword `typedef` followed
    by the `struct` keyword, a set of *field declarations* enclosed by a pair of braces,
    and a structure name. As with Pascal, most C/C++ compilers assign memory offsets
    to the fields in the order of their declaration in the record.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: C/C++ 中的记录（结构体）声明以关键字 `typedef` 开头，接着是 `struct` 关键字，一对大括号括起来的 *字段声明*，以及结构体名称。与
    Pascal 类似，大多数 C/C++ 编译器按照字段在记录中的声明顺序为字段分配内存偏移量。
- en: '**11.1.1.3 Record Declarations in C#**'
  id: totrans-32
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**11.1.1.3 C# 中的记录声明**'
- en: 'C# structure declarations are very similar to C/C++:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: C# 结构体声明与 C/C++ 非常相似：
- en: '[PRE2]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Record (structure) declarations in C# begin with the keyword `struct`, a structure
    name, and a set of *field declarations* enclosed by a pair of braces. As with
    Pascal, most C# compilers assign memory offsets to the fields in the order of
    their declaration in the record.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: C# 中的记录（结构体）声明以关键字 `struct` 开头，结构体名称，后跟一对大括号括起来的 *字段声明*。与 Pascal 类似，大多数 C# 编译器按照字段在记录中的声明顺序为字段分配内存偏移量。
- en: This example defines the `Name` and `SSN` fields as arrays of characters in
    order to match the other record declaration examples in this chapter. In an actual
    C# program you’d probably want to use the `string` data type rather than an array
    of characters for these fields. However, keep in mind that C# uses dynamically
    allocated arrays; thus, the memory layout for the C# structure will differ from
    those for C/C++, Pascal, and HLA.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子将 `Name` 和 `SSN` 字段定义为字符数组，以匹配本章中的其他记录声明示例。在实际的 C# 程序中，你可能会想要使用 `string`
    数据类型，而不是字符数组来表示这些字段。然而，请记住，C# 使用动态分配的数组；因此，C# 结构体的内存布局与 C/C++、Pascal 和 HLA 的布局有所不同。
- en: '**11.1.1.4 Record Declarations in Java**'
  id: totrans-37
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**11.1.1.4 Java 中的记录声明**'
- en: Java doesn’t support a pure record, but class declarations with only data members
    serve the same purpose (see the section “Class Declarations in C# and Java” on
    [page 366](ch11.xhtml#page_366)).
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: Java 不支持纯粹的记录类型，但仅包含数据成员的类声明具有相同的作用（请参见 [第366页](ch11.xhtml#page_366) 中的“C# 和
    Java 中的类声明”部分）。
- en: '**11.1.1.5 Record Declarations in HLA**'
  id: totrans-39
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**11.1.1.5 HLA 中的记录声明**'
- en: 'In HLA, you can create record types using the `record`/`endrecord` declaration.
    You would encode the record from the previous sections as follows:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在 HLA 中，你可以使用 `record`/`endrecord` 声明来创建记录类型。你可以像下面这样编码前面章节中的记录：
- en: '[PRE3]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: As you can see, the HLA declaration is very similar to the Pascal declaration.
    Note that, to stay consistent with the Pascal declaration, this example uses character
    arrays rather than strings for the `sName` and `SSN` (Social Security number)
    fields. In a typical HLA record declaration, you’d probably use a `string` type
    for at least the `sName` field (keeping in mind that a string variable is only
    a 4-byte pointer).
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，HLA 声明与 Pascal 声明非常相似。请注意，为了与 Pascal 声明保持一致，这个例子使用字符数组，而不是字符串，来表示 `sName`
    和 `SSN`（社会安全号码）字段。在典型的 HLA 记录声明中，你可能会使用 `string` 类型，至少对于 `sName` 字段（记住，字符串变量只是一个
    4 字节的指针）。
- en: '**11.1.1.6 Record (Tuple) Declarations in Swift**'
  id: totrans-43
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**11.1.1.6 Swift 中的记录（元组）声明**'
- en: Although Swift does not support the concept of a record, you can simulate one
    using a Swift *tuple*. Tuples are a useful construct for creating a composite/aggregate
    data type without the overhead of a class. (Note, however, that Swift does not
    store record/tuple elements in memory in the same manner as other programming
    languages.)
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 Swift 不支持记录的概念，但你可以使用 Swift 的 *元组* 来模拟记录。元组是一种创建复合/聚合数据类型的有用结构，不需要像类那样的开销。（不过请注意，Swift
    不以与其他编程语言相同的方式在内存中存储记录/元组元素。）
- en: 'A Swift tuple is simply a list of values. Syntactically, a tuple takes the
    following form:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: Swift元组仅仅是一个值的列表。从语法上讲，元组具有以下形式：
- en: '[PRE4]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The types of the values within the tuple don’t have to be identical.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 元组中的值类型不必完全相同。
- en: 'Swift typically uses tuples to return multiple values from functions. Consider
    the following short Swift code fragment:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: Swift通常使用元组从函数返回多个值。考虑以下简短的Swift代码片段：
- en: '[PRE5]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The `returns3Ints` function returns three values (`1`, `2`, and `3`). The statement
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '`returns3Ints`函数返回三个值（`1`，`2`，和`3`）。该语句'
- en: '[PRE6]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: stores those three integer values into `r1`, `r2`, and `r3`, respectively.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 将这三个整数值分别存储到`r1`、`r2`和`r3`中。
- en: 'You can also assign tuples to a single variable and access “fields” of the
    tuple using integer indexes as the field names:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以将元组赋值给一个变量，并使用整数索引作为字段名称来访问元组的“字段”：
- en: '[PRE7]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Using field names like `.0` is inadvisable, as it results in hard-to-maintain
    code. You can create records out of tuples, but referring to the fields using
    integer indices is rarely suitable in real-world programs.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 使用像`.0`这样的字段名称是不推荐的，因为它会导致难以维护的代码。你可以通过元组创建记录，但在现实世界的程序中，使用整数索引引用字段通常不合适。
- en: 'Fortunately, Swift allows you to assign labels to tuple fields and refer to
    those fields by the label name rather than an integer index, via the `typealias`
    keyword:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，Swift允许你为元组字段分配标签，并通过标签名称而不是整数索引来引用这些字段，可以通过`typealias`关键字实现：
- en: '[PRE8]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Keep in mind that the storage of the tuple in memory might not map to the same
    layout as a record or structure in other languages. Like arrays in Swift, tuples
    are an opaque type, without a guaranteed definition of how Swift will store them
    in memory.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，元组在内存中的存储方式可能与其他语言中的记录或结构布局不完全相同。就像Swift中的数组一样，元组是一个不透明类型，没有保证Swift如何在内存中存储它们的定义。
- en: '**11.1.2 Instantiating a Record**'
  id: totrans-59
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**11.1.2 实例化记录**'
- en: Generally, a record declaration does not reserve storage for a record object;
    instead, it specifies a data type that you can use as a template when declaring
    record variables. *Instantiation* refers to this process of using a record template,
    or type, to create a record variable.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，记录声明并不会为记录对象保留存储空间；相反，它指定了一个数据类型，作为声明记录变量时的模板。*实例化*指的是使用记录模板或类型来创建记录变量的过程。
- en: 'Consider the HLA type declaration for `student` from the previous section.
    This type declaration doesn’t allocate any storage for a record variable; it simply
    provides the structure for the record object to use. To create an actual `student`
    variable, you must set aside some storage for the record variable, either at compile
    time or at runtime. In HLA, you can set aside storage for a `student` object at
    compile time by using variable declarations such as:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑前一节中`student`的HLA类型声明。这个类型声明并没有为记录变量分配任何存储空间；它仅仅提供了记录对象使用的结构。要创建一个实际的`student`变量，你必须为记录变量预留一些存储空间，无论是在编译时还是运行时。在HLA中，你可以通过使用如下的变量声明在编译时为`student`对象预留存储空间：
- en: '[PRE9]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The `var` declaration tells HLA to reserve sufficient storage for a `student`
    object in the current activation record when the program enters the current procedure.
    The `static` statement tells HLA to reserve sufficient storage for a `student`
    object in the static data section; this is done at compilation time.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '`var`声明告诉HLA在程序进入当前过程时，为当前激活记录中的`student`对象保留足够的存储空间。`static`语句告诉HLA在静态数据区保留足够的存储空间给`student`对象；这在编译时完成。'
- en: 'You can also allocate storage for a record object dynamically using memory
    allocation functions. For example, in the C language you can use `malloc()`to
    allocate storage for a `student` object like so:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以使用内存分配函数动态分配记录对象的存储空间。例如，在C语言中，你可以使用`malloc()`像这样为`student`对象分配存储空间：
- en: '[PRE10]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'A record is simply a collection of (otherwise) unrelated variables. So why
    not just create separate variables? In C, for example, why not just write:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 记录只是（否则）不相关变量的集合。那么为什么不创建单独的变量呢？例如，在C语言中，为什么不直接写：
- en: '[PRE11]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: There are several reasons why this approach isn’t ideal. On the software engineering
    side of things, there are maintenance issues to consider. For example, what happens
    if you create several sets of `student` variables and then decide you want to
    add a field? Now you’ve got to go back and edit every set of declarations you’ve
    created—not a pretty sight. With structure/record declarations, however, you only
    need to make one change to the type declaration, and all the variable declarations
    automatically get the new field. Also, consider what happens if you want to create
    an array of `student` objects.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法并不理想的原因有几个。在软件工程方面，需要考虑维护问题。例如，如果你创建了多个`student`变量集，然后决定要添加一个字段，怎么办？现在你得回去编辑你创建的每一组声明——这可不是什么好事。然而，使用结构/记录声明时，你只需对类型声明进行一次更改，所有变量声明都会自动获得新字段。此外，考虑一下如果你想创建一个`student`对象的数组会发生什么。
- en: 'Software engineering issues aside, collecting disparate fields into a record
    is a good idea for efficiency reasons. Many compilers allow you to treat a whole
    record as a single object for the purposes of assignment, parameter passing, and
    so on. In Pascal, for example, if you have two variables, `s1` and `s2`, of type
    `student`, you can assign all the values of one `student` object to the other
    with a single assignment statement like this:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 撇开软件工程问题不谈，将不同的字段收集到一个记录中对于提高效率是一个好主意。许多编译器允许你将整个记录视为一个单一对象，用于赋值、参数传递等。例如，在Pascal中，如果你有两个`student`类型的变量`s1`和`s2`，你可以使用一个赋值语句将一个`student`对象的所有值赋给另一个对象，像这样：
- en: '[PRE12]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Not only is this more convenient than assigning the individual fields, but
    the compiler can often generate better code by using a block move operation. Consider
    the following C++ code and the associated x86 assembly language output:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 这不仅比分配单个字段更方便，而且编译器通常可以通过使用块移动操作生成更好的代码。考虑以下C++代码及其相关的x86汇编语言输出：
- en: '[PRE13]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Here’s the relevant portion of the x86-64 assembly code that Microsoft’s Visual
    C++ compiler produces (with the `/O2` optimization option):'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是微软Visual C++编译器生成的x86-64汇编代码的相关部分（使用`/O2`优化选项）：
- en: '[PRE14]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The important thing to note in this example is that the Visual C++ compiler
    emits a sequence of `movaps` and `movups` instructions whenever you assign whole
    structures. However, it may degenerate to a sequence of individual `mov` instructions
    for each of the fields when you do a field-by-field assignment of two structures.
    Likewise, if you had not encapsulated all the fields into a structure, then assigning
    the variables associated with your “structure” via a block copy operation wouldn’t
    have been possible.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子中需要注意的一个重要点是，Visual C++编译器在你分配整个结构时会发出一系列`movaps`和`movups`指令。然而，当你进行逐字段分配两个结构时，它可能会退化为针对每个字段的单独`mov`指令序列。同样，如果你没有将所有字段封装到一个结构中，那么通过块复制操作分配与你的“结构”关联的变量就不可能了。
- en: 'Combining fields together into a record has many advantages, including:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 将多个字段组合成一个记录有许多优点，包括：
- en: It is much easier to maintain the record structure (that is, add, remove, rename,
    and change fields).
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 维护记录结构要容易得多（即添加、删除、重命名和更改字段）。
- en: Compilers can do additional type and semantic checking on records, thereby helping
    catch logic errors in your programs when you use a record improperly.
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编译器可以对记录进行额外的类型和语义检查，从而帮助在你错误使用记录时捕捉程序中的逻辑错误。
- en: Compilers can treat records as monolithic objects, generating more efficient
    code (for example, `movsd` and `movaps` instructions) than they can when working
    with individual field variables.
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编译器可以将记录视为一个整体对象，从而生成比处理单个字段变量时更高效的代码（例如，`movsd`和`movaps`指令）。
- en: Most compilers respect the order of declaration in a record, allocating successive
    fields to consecutive memory locations. This is important when interfacing data
    structures from two different languages. There is no guarantee for the organization
    of separate variables in memory in most languages.
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 大多数编译器会遵循记录中声明的顺序，将连续的字段分配到连续的内存位置。这在从两种不同语言接口数据结构时尤为重要。在大多数语言中，无法保证单独变量在内存中的组织方式。
- en: You can use records to improve cache memory performance and reduce virtual memory
    thrashing (as you’ll soon see).
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以使用记录来提高缓存内存性能并减少虚拟内存抖动（正如你很快就会看到的那样）。
- en: Records can contain pointer fields that contain the address of other (like-typed)
    record objects. This isn’t possible when you use bulk variables in memory.
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 记录可以包含指针字段，这些字段存储其他（相同类型）记录对象的地址。而当你使用内存中的大规模变量时，这是不可能的。
- en: You’ll see some other advantages of records in the following sections.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的章节中，你将看到记录的一些其他优势。
- en: '**11.1.3 Initializing Record Data at Compile Time**'
  id: totrans-84
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**11.1.3 在编译时初始化记录数据**'
- en: 'Some languages—for example, C/C++ and HLA—allow you to initialize record variables
    at compile time. For static objects, this spares your application the code and
    time needed to manually initialize each field of a record. For example, consider
    the following C code, which provides initializers for both static and automatic
    structure variables:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 一些语言——例如C/C++和HLA——允许你在编译时初始化记录变量。对于静态对象，这可以节省应用程序手动初始化每个记录字段所需的代码和时间。例如，考虑以下C代码，它为静态和自动结构变量提供了初始化器：
- en: '[PRE15]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'When compiled with Visual C++ using the `/O2` and `/Fa` command-line options,
    this example emits the following x86-64 machine code (edited manually to eliminate
    irrelevant output):'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用Visual C++并使用`/O2`和`/Fa`命令行选项编译时，此示例会生成以下x86-64机器代码（手动编辑以去除不相关的输出）：
- en: '[PRE16]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Look carefully at the machine code the compiler emits for the initialization
    of the `autoStruct` variable. In contrast to static initialization, the compiler
    cannot initialize memory at compile time because it doesn’t know the addresses
    of the various fields of the automatic record that the system allocates at runtime.
    Unfortunately, this particular compiler generates a field-by-field sequence of
    assignments to initialize the fields of the structure. While this is relatively
    fast, it can consume quite a bit of memory, especially if you’ve got a large structure.
    If you want to reduce the size of the automatic structure variable initialization,
    one possibility is to create an initialized static structure and assign it to
    the automatic variable upon each entry into the function in which you’ve declared
    the automatic variable. Consider the following C++ and 80x86 assembly code:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 仔细观察编译器为初始化`autoStruct`变量所生成的机器代码。与静态初始化不同，编译器无法在编译时初始化内存，因为它不知道系统在运行时为自动记录分配的各个字段的地址。不幸的是，这个特定的编译器生成了逐字段赋值的初始化序列来初始化结构的字段。虽然这样做相对较快，但可能会消耗相当多的内存，尤其是当结构很大时。如果你希望减少自动结构变量初始化的大小，一种可能的做法是创建一个初始化的静态结构，并在每次进入声明了自动变量的函数时将其赋值给自动变量。考虑以下的C++和80x86汇编代码：
- en: '[PRE17]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Here’s the corresponding x86-64 assembly code that Visual C++ emits:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 这是Visual C++生成的相应x86-64汇编代码：
- en: '[PRE18]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: As you can see in this assembly code, it takes only a four-instruction sequence
    to copy the data from the statically initialized record into the automatically
    allocated record. This code is quite a bit shorter. Note, however, that it isn’t
    necessarily faster. Copying data from one structure to another involves memory-to-memory
    moves, which can be quite slow if all the memory locations are not currently cached.
    Moving immediate constants directly to the individual fields is often faster,
    though it may take many instructions to accomplish this.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 如你在这段汇编代码中看到的，将静态初始化的记录数据复制到自动分配的记录中只需要四条指令。这个代码简洁很多。然而，值得注意的是，它不一定更快。从一个结构复制数据到另一个结构涉及内存到内存的移动，如果所有的内存位置都没有被缓存，可能会非常慢。将常数直接移动到各个字段通常更快，尽管可能需要多条指令来完成。
- en: This example should remind you that if you attach an initializer to an automatic
    variable, the compiler will have to emit some code to handle that initialization
    at runtime. Unless your variables need to be reinitialized on each entry to your
    function, consider using static record objects instead.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 这个示例应该提醒你，如果你给一个自动变量附加了一个初始化器，编译器将不得不生成一些代码，以便在运行时处理该初始化。除非你的变量需要在每次进入函数时重新初始化，否则考虑使用静态记录对象。
- en: '**11.1.4 Storing Records in Memory**'
  id: totrans-95
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**11.1.4 在内存中存储记录**'
- en: 'The following Pascal example demonstrates a typical `student` record variable
    declaration:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 以下Pascal示例演示了一个典型的`student`记录变量声明：
- en: '[PRE19]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Given the earlier declaration for the Pascal `student` data type, this allocates
    81 bytes of storage laid out in memory as shown in [Figure 11-1](ch11.xhtml#ch11fig1).
    If the label `John` corresponds to the *base address* of this record, then the
    `Name` field is at offset `John+0`, the `Major` field is at offset `John+65`,
    the `SSN` field is at offset `John+67`, and so on.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 根据之前对 Pascal `student` 数据类型的声明，这会分配 81 字节的存储，并按 [图 11-1](ch11.xhtml#ch11fig1)
    所示的方式在内存中布局。如果标签 `John` 对应于该记录的*基地址*，则 `Name` 字段位于偏移量 `John+0`，`Major` 字段位于偏移量
    `John+65`，`SSN` 字段位于偏移量 `John+67`，依此类推。
- en: '![Image](../images/11fig01.jpg)'
  id: totrans-99
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/11fig01.jpg)'
- en: '*Figure 11-1: Student data structure storage in memory*'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 11-1：学生数据结构在内存中的存储*'
- en: 'Most programming languages let you refer to a record field by its name rather
    than by its numeric offset into the record (indeed, only a few low-end assemblers
    require that you reference fields by numeric offset; it’s safe to say that such
    assemblers don’t really support records). The typical syntax for a field access
    uses the *dot operator* to select a field from a record variable. Given the variable
    `John` from the previous example, here’s how you could access various fields in
    this record:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数编程语言允许你通过字段名称而非记录中字段的数字偏移量来引用记录字段（实际上，只有少数低端汇编器要求你通过数字偏移量来引用字段；可以说，这样的汇编器并不真正支持记录）。字段访问的典型语法使用*点操作符*从记录变量中选择字段。假设变量
    `John` 来自前面的示例，以下是如何访问该记录中的不同字段：
- en: '[PRE20]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '[Figure 11-1](ch11.xhtml#ch11fig1) suggests that all fields of a record appear
    in memory in the order of their declaration, and this is usually the case (although
    in theory, a compiler can freely place the fields anywhere in memory that it chooses).
    The first field usually appears at the lowest address in the record, the second
    field appears at the next-highest address, the third field follows the second
    field in memory, and so on.'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 11-1](ch11.xhtml#ch11fig1) 表明记录的所有字段在内存中按声明顺序排列，通常情况也是如此（尽管从理论上讲，编译器可以自由地将字段放置在内存中的任何位置）。第一个字段通常位于记录中的最低地址，第二个字段位于下一个较高地址，第三个字段跟随第二个字段依次排列，依此类推。'
- en: '[Figure 11-1](ch11.xhtml#ch11fig1) also suggests that compilers pack the fields
    into adjacent memory locations with no gaps between the fields. While this is
    true for many languages, it’s certainly not the most common memory organization
    for a record. For performance reasons, most compilers align the fields of a record
    on appropriate memory boundaries. The exact details vary by language, compiler
    implementation, and CPU, but a typical compiler places fields at an offset within
    the record’s storage area that is “natural” for that particular field’s data type.
    On the 80x86, for example, compilers that follow the Intel ABI (application binary
    interface) allocate single-byte objects at any offset within the record, words
    only at even offsets, and double word or larger objects on double word boundaries.
    Although not all 80x86 compilers support the Intel ABI, most do, which allows
    records to be shared among functions and procedures written in different languages
    on the 80x86\. Other CPU manufacturers provide their own ABI for their processors,
    and programs that adhere to an ABI can share binary data at runtime with other
    programs that adhere to the same ABI.'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 11-1](ch11.xhtml#ch11fig1) 还表明编译器将字段打包到相邻的内存位置中，字段之间没有空隙。虽然这对许多语言来说是正确的，但这肯定不是记录的最常见内存组织方式。出于性能考虑，大多数编译器将记录的字段对齐到适当的内存边界。具体细节因语言、编译器实现和
    CPU 而异，但典型的编译器会将字段放置在记录存储区域内一个对该特定字段数据类型“自然”的偏移量上。例如，在 80x86 上，遵循 Intel ABI（应用程序二进制接口）的编译器将单字节对象分配到记录中的任何偏移量，字（word）仅分配在偶数偏移量上，而双字或更大的对象则放置在双字边界上。虽然并非所有
    80x86 编译器都支持 Intel ABI，但大多数都支持，这使得记录能够在用不同语言编写的函数和过程之间共享。其他 CPU 制造商为其处理器提供了自己的
    ABI，遵循 ABI 的程序可以在运行时与其他遵循相同 ABI 的程序共享二进制数据。'
- en: In addition to aligning the fields of a record at reasonable offset boundaries,
    most compilers also ensure that the length of the entire record is a multiple
    of 2, 4, 8, or 16 bytes. As you’ve seen in previous chapters, they accomplish
    this by adding padding bytes at the end of the record to fill out the record’s
    size. This ensures that the record’s length is a multiple of the largest scalar
    (nonarray/nonrecord) object in the record.^([3](footnotes.xhtml#ch11fn3)) For
    example, if a record has fields whose lengths are 1, 2, 4, and 8 bytes long, then
    an 80x86 compiler will generally pad the record’s length so that it is a multiple
    of 8\. This allows you to create an array of records and be assured that each
    record in the array starts at a reasonable address in memory.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 除了将记录的字段对齐到合理的偏移量边界，大多数编译器还确保整个记录的长度是2、4、8或16字节的倍数。正如你在前几章中看到的，它们通过在记录末尾添加填充字节来实现这一点，从而填满记录的大小。这确保了记录的长度是记录中最大标量（非数组/非记录）对象的倍数。例如，如果一个记录的字段长度分别为1、2、4和8字节，那么80x86编译器通常会填充记录的长度，使其成为8的倍数。这样，你可以创建一个记录数组，并确保数组中的每个记录都从内存中的合理地址开始。
- en: Although some CPUs don’t allow access to objects in memory at misaligned addresses,
    many compilers allow you to disable the automatic alignment of fields within a
    record. Generally, the compiler will have an option you can use to globally disable
    this feature. Many of these compilers also provide a `pragma`, `alignas`, or `packed`
    keyword that lets you turn off field alignment on a record-by-record basis. Disabling
    the automatic field alignment feature may allow you to save some memory by eliminating
    the padding bytes between the fields (and at the end of the record)—again, provided
    that field misalignment is acceptable on your CPU. The cost, of course, is that
    the program may run a little more slowly when it needs to access misaligned values
    in memory.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管一些CPU不允许访问内存中不对齐地址的对象，许多编译器仍然允许你禁用记录字段的自动对齐。通常，编译器会提供一个选项，允许你全局禁用此功能。这些编译器中的许多还提供`pragma`、`alignas`或`packed`关键字，让你可以在每个记录的基础上禁用字段对齐。禁用自动字段对齐功能可能会通过消除字段之间（以及记录末尾）的填充字节来节省一些内存——当然，前提是你的CPU可以接受字段的不对齐。代价当然是，当程序需要访问内存中不对齐的值时，运行速度可能会稍微变慢。
- en: 'One reason to use a packed record is to gain manual control over the alignment
    of the record’s fields. For example, suppose you have a couple of functions written
    in two different languages, and both of these functions need to access some data
    in a record. Further, suppose that the two compilers for these functions do not
    use the same field alignment algorithm. A record declaration like the following
    (in Pascal) may not be compatible with the way both functions access the record
    data:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 使用打包记录的一个原因是为了手动控制记录字段的对齐。例如，假设你有几个用两种不同语言编写的函数，并且这两个函数都需要访问记录中的某些数据。进一步假设这两个函数的编译器使用不同的字段对齐算法。像以下这样的记录声明（在Pascal中）可能与这两个函数访问记录数据的方式不兼容：
- en: '[PRE21]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The problem here is that the first compiler could use the offsets 0, 2, and
    4 for the `bField`, `wField`, and `dField` fields, respectively, while the second
    compiler might use offsets 0, 4, and 8.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的问题是，第一个编译器可能使用偏移量0、2和4分别为`bField`、`wField`和`dField`字段，而第二个编译器可能使用偏移量0、4和8。
- en: 'Suppose, however, that the first compiler allows you to specify the `packed`
    keyword before the `record` keyword, causing the compiler to store each field
    immediately following the previous one. Although using the `packed` keyword doesn’t
    make the records compatible with both functions, it does allow you to manually
    add padding fields to the record declaration, as follows:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，假设第一个编译器允许你在`record`关键字之前指定`packed`关键字，这将导致编译器将每个字段紧接着前一个字段存储。尽管使用`packed`关键字并不能使记录与两种函数兼容，但它确实允许你手动向记录声明中添加填充字段，具体如下：
- en: '[PRE22]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Manually adding padding can make maintaining your code a real chore. However,
    if incompatible compilers need to share data, it’s a trick worth knowing. For
    the exact details on packed records, consult your language’s reference manual.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 手动添加填充可能会使代码维护变得非常繁琐。然而，如果不兼容的编译器需要共享数据，这是一个值得了解的技巧。有关打包记录的具体细节，请参考你所使用语言的参考手册。
- en: '**11.1.5 Using Records to Improve Memory Performance**'
  id: totrans-113
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**11.1.5 使用记录来提高内存性能**'
- en: 'For someone who wants to write great code, records provide an important benefit:
    the ability to control variable placement in memory. This capability enables you
    to better control cache usage by those variables, which in turn can help you write
    code that executes much faster.'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 对于那些想写出高质量代码的人来说，记录提供了一个重要的好处：能够控制变量在内存中的位置。这一能力让你可以更好地控制这些变量的缓存使用，从而帮助你编写执行速度更快的代码。
- en: 'Consider, for a moment, the following C global/static variable declarations:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 想一想以下的 C 全局/静态变量声明：
- en: '[PRE23]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'You might think that the compiler would allocate storage for these variables
    in consecutive memory locations. However, few (if any) languages guarantee this.
    C certainly doesn’t and, in fact, C compilers like Microsoft’s Visual C++ compiler
    don’t allocate these variables in sequential memory locations. Consider the Visual
    C++ assembly language output for the preceding variable declarations:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会认为编译器会将这些变量存储在连续的内存位置。然而，很少（如果有的话）有编程语言能保证这一点。C 语言显然没有，并且事实上，像 Microsoft
    的 Visual C++ 编译器这样的 C 编译器并不会将这些变量分配在连续的内存位置。考虑一下 Visual C++ 汇编语言输出的前述变量声明：
- en: '[PRE24]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Even if you don’t understand the purpose of all the directives here, it’s clear
    that Visual C++ has rearranged all the variable declarations in memory. Therefore,
    you cannot count on adjacent declarations in your source file yielding adjacent
    storage cells in memory. Indeed, there is nothing to stop the compiler from allocating
    one or more variables in a machine register.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 即使你不理解这里所有指令的用途，也可以明显看出 Visual C++ 已经重新排列了内存中的所有变量声明。因此，你不能指望源文件中的相邻声明会在内存中产生相邻的存储单元。实际上，没有任何东西能够阻止编译器将一个或多个变量分配到机器寄存器中。
- en: You might be wondering why you’d be concerned about the placement of variables
    in memory. After all, one of the main reasons for using named variables as an
    abstraction for memory is to avoid having to think about low-level memory allocation
    strategies. There are times, however, when being able to control variable placement
    in memory is important. For example, if you want to maximize program performance,
    you should try to place sets of variables that you access together in adjacent
    memory locations. This way, those variables will tend to sit in the same cache
    line, and you won’t pay a heavy latency cost for accessing variables not currently
    held in the cache. Furthermore, by placing variables you use together adjacent
    to one another in memory, you’ll use fewer cache lines and, therefore, have less
    thrashing.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会想，为什么你需要关注变量在内存中的位置。毕竟，使用命名变量作为内存抽象的主要原因之一，就是避免考虑低级的内存分配策略。然而，有时候，能够控制变量在内存中的位置是很重要的。例如，如果你想最大化程序的性能，你应该尽量将一起访问的变量放置在相邻的内存位置。这样，这些变量会倾向于位于同一缓存行中，访问不在缓存中的变量时，你就不会付出过高的延迟代价。此外，通过将一起使用的变量放置在相邻的内存位置，你将使用更少的缓存行，从而减少缓存抖动。
- en: Universally, programming languages that support the traditional notion of records
    maintain the fields of their records in adjacent memory locations; therefore,
    if you have some reason to keep different variables in adjacent memory locations
    (so that they share cache lines as much as possible), putting your variables into
    a record is a reasonable approach. However, the key word here is *traditional*—if
    your language uses a dynamic record type, you’ll need a different approach.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 通常情况下，支持传统记录概念的编程语言会将记录的字段存储在相邻的内存位置；因此，如果你有某种理由将不同的变量放置在相邻的内存位置（以便它们尽可能共享缓存行），将变量放入记录中是一种合理的方法。然而，这里关键的词是*传统*——如果你的语言使用动态记录类型，你就需要采用不同的方法。
- en: '**11.1.6 Working with Dynamic Record Types and Databases**'
  id: totrans-122
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**11.1.6 使用动态记录类型和数据库**'
- en: Some dynamic languages employ a dynamic type system, and object types can change
    at runtime. We’ll explore dynamic types a little later in this chapter, but suffice
    it to say that if your language uses a dynamic type record structure, then all
    bets are off concerning the placement of fields in memory. Chances are pretty
    good that the fields will not be sitting in adjacent memory locations. Then again,
    if you’re using a dynamic language, the fact that you’re sacrificing a little
    performance because you’re not getting maximal benefit from your cache will be
    the least of your worries.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 一些动态语言采用动态类型系统，且对象类型可以在运行时发生变化。我们将在本章稍后讨论动态类型，但可以简单地说，如果你的语言使用动态类型的记录结构，那么关于字段在内存中的位置就无法确定了。很有可能这些字段不会位于相邻的内存位置。再者，如果你使用的是动态语言，因未能最大化缓存的利用率而牺牲了些许性能，反倒是你最不需要担心的问题。
- en: A classic example of a dynamic record is the data you read from a database engine.
    The engine itself has no preconceived (that is, compile time) notion of what structure
    the database records will take. Instead, the database itself provides metadata
    that tells the database the record structure. The database engine reads this metadata
    from the database, uses it to organize the field data into a single record, and
    then returns this data to the database application. In a dynamic language, the
    actual field data is typically spread out across memory, and the database application
    references that data indirectly.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 动态记录的经典例子是你从数据库引擎中读取的数据。引擎本身没有任何预设（即编译时）的观念来定义数据库记录的结构。相反，数据库本身提供元数据，告诉数据库记录的结构。数据库引擎从数据库中读取这些元数据，利用它来将字段数据组织成一个单一的记录，然后将这些数据返回给数据库应用程序。在动态语言中，实际的字段数据通常分布在内存的不同位置，数据库应用程序间接引用这些数据。
- en: Of course, if you’re using a dynamic language, you have much greater concerns
    about performance than the placement or organization of your record fields in
    memory. Dynamic languages, such as database engines, execute many instructions
    processing the metadata (or otherwise determining the type of their data operands),
    so losing a few cycles to cache thrashing here and there is unlikely to matter
    much. For more information about the overhead associated with a dynamic typing
    system, see “Variant Types” on [page 356](ch11.xhtml#page_356).
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，如果你使用的是动态语言，那么你对性能的关注远远大于记录字段在内存中的位置或组织方式。动态语言，如数据库引擎，会执行许多指令来处理元数据（或以其他方式确定数据操作数的类型），因此，在这里丢失几个周期导致缓存抖动不会产生太大影响。有关与动态类型系统相关的开销的更多信息，请参见[第356页](ch11.xhtml#page_356)的“变体类型”。
- en: '**11.2 Discriminant Unions**'
  id: totrans-126
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**11.2 判别联合**'
- en: A discriminant union (or just union) is very similar to a record. A *discriminant*
    is something that distinguishes or separates items in a quantity. In the case
    of a discriminant union, it means that different field names are used to distinguish
    the various ways that a given memory location’s data type can be interpreted.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 判别联合（或简称联合）与记录非常相似。*判别*是用来区分或分隔数量中各项的东西。在判别联合的情况下，它意味着使用不同的字段名来区分给定内存位置的数据类型的不同解释方式。
- en: Like records, unions in typical languages that support them have fields that
    you access using dot notation. In fact, in many languages, about the only syntactical
    difference between records and unions is the use of the keyword `union` rather
    than `record` or `struct`. Semantically, however, there’s a big difference between
    a record and a union. In a record, each field has its own offset from the base
    address of the record, and the fields do not overlap. In a union, however, all
    fields have the same offset, 0, and all the fields of the union overlap. As a
    result, the size of a record is the sum of the sizes of all the fields (plus,
    possibly, some padding bytes), whereas a union’s size is the size of its largest
    field (plus, possibly, some padding bytes at the end).
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 像记录一样，支持联合的典型语言中，联合也有字段，你可以使用点符号来访问。事实上，在许多语言中，记录和联合之间唯一的语法差异就是使用关键字`union`而不是`record`或`struct`。然而，在语义上，记录和联合之间有很大的区别。在记录中，每个字段相对于记录的基地址都有自己的偏移量，且字段不会重叠。然而，在联合中，所有字段都共享相同的偏移量0，所有联合的字段都重叠。因此，记录的大小是所有字段大小的总和（可能还包括一些填充字节），而联合的大小是其最大字段的大小（可能还包括一些末尾的填充字节）。
- en: Because the fields of a union overlap, changing the value of one field changes
    the values of all the other fields as well. This typically means that the use
    of a union’s field is mutually exclusive—that is, you can use only one field at
    any given time. As a result, unions aren’t as generally applicable as records,
    but they still have many uses. As you’ll see later in this chapter, you can use
    unions to save memory by reusing memory for different values, to coerce data types,
    and to create variant data types. For the most part, though, programs use unions
    to share memory between different variable objects whose use never overlaps (that
    is, the variables’ use is mutually exclusive).
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 由于联合的字段是重叠的，修改一个字段的值会改变其他所有字段的值。这通常意味着联合字段的使用是互斥的——也就是说，你只能在任何给定时间使用一个字段。因此，联合不像记录那样具有广泛的适用性，但它仍然有许多用途。正如你在本章后面将看到的，你可以使用联合通过重用内存来节省内存，强制数据类型转换，以及创建变体数据类型。大多数情况下，程序使用联合在不同的变量对象之间共享内存，而这些对象的使用永远不会重叠（也就是说，变量的使用是互斥的）。
- en: For example, imagine that you have a 32-bit double word variable, and you find
    yourself constantly extracting out the LO or the HO 16-bit word. In most HLLs,
    this would require a 32-bit read and then an AND operation to mask out the unwanted
    word. If that wasn’t enough, if you want the HO word, you have to then shift the
    result to the right 16 bits. With a union, you can overlay the 32-bit double word
    and a two-element 16-bit word array and access the words directly. You’ll see
    how to do this in “Using Unions in Other Ways” on [page 355](ch11.xhtml#page_355).
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设你有一个 32 位的双字变量，并且你发现自己不断地提取出 LO 或 HO 的 16 位字。在大多数高级语言中，这将需要先进行一次 32 位读取，然后执行与操作以屏蔽掉不需要的字。如果这还不够，如果你需要
    HO 字，你还需要将结果右移 16 位。使用联合时，你可以将 32 位双字与一个包含两个元素的 16 位字数组叠加，并直接访问这些字。你将在《以其他方式使用联合》一节中看到如何操作，[请参阅第
    355 页](ch11.xhtml#page_355)。
- en: '**11.2.1 Declaring Unions in Various Languages**'
  id: totrans-131
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**11.2.1 在各种语言中声明联合**'
- en: The C/C++, Pascal, and HLA languages provide discriminant union type declarations.
    The Java language doesn’t provide the equivalent of a union. Swift has a special
    version of the `Enum` declaration that provides variant record capabilities, but
    it does not store members of such declarations at the same address in memory.
    So, for the purposes of this discussion, we’ll assume Swift doesn’t provide union
    declarations.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: C/C++、Pascal 和 HLA 语言提供了判别联合类型声明。Java 语言则没有提供等效的联合类型。Swift 有一种特殊版本的 `Enum` 声明，提供变体记录功能，但它并不会将这些声明的成员存储在内存的同一地址上。因此，在本讨论中，我们假设
    Swift 不提供联合声明。
- en: '**11.2.1.1 Union Declarations in C/C++**'
  id: totrans-133
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**11.2.1.1 C/C++ 中的联合声明**'
- en: 'Here’s an example of a union declaration in C/C++:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 这是 C/C++ 中联合声明的示例：
- en: '[PRE25]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Assuming the C/C++ compiler in use allocates 4 bytes for unsigned integers,
    the size of a `unionType` object will be 4 bytes (because all three fields are
    4-byte objects).
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 假设正在使用的 C/C++ 编译器为无符号整数分配了 4 个字节，那么 `unionType` 对象的大小将为 4 个字节（因为所有三个字段都是 4 字节对象）。
- en: '**11.2.1.2 Union Declarations in Pascal/Delphi**'
  id: totrans-137
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**11.2.1.2 Pascal/Delphi 中的联合声明**'
- en: 'Pascal and Delphi use *case-variant records* to create a discriminant union.
    The syntax for a case-variant record is as follows:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: Pascal 和 Delphi 使用 *case-variant 记录* 来创建判别联合。case-variant 记录的语法如下：
- en: '[PRE26]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: The tag item can be either a type identifier (such as `boolean`, `char`, or
    some user-defined type), or it can be a field declaration of the form `identifier`:type.
    If it takes the latter form, then identifier becomes another field of the record
    (and not a member of the variant section) and has the specified type. In addition,
    the Pascal compiler could generate code that raises an exception whenever the
    application attempts to access any of the variant fields except the one allowed
    by the value of the tag field. In practice, almost no Pascal compilers do this
    check. Still, keep in mind that the Pascal language standard suggests that compilers
    *should* do it, so some compilers might.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 标签项可以是一个类型标识符（例如 `boolean`、`char` 或某个用户定义的类型），也可以是形式为 `identifier:type` 的字段声明。如果它采用后者形式，则标识符将成为记录的另一个字段（而不是变体部分的成员），并具有指定的类型。此外，Pascal
    编译器可以生成代码，在应用程序尝试访问任何变体字段（除了标签字段值允许的字段）时引发异常。实际上，几乎没有 Pascal 编译器会进行此检查。尽管如此，请记住，Pascal
    语言标准建议编译器 *应该* 执行此检查，因此某些编译器可能会执行。
- en: 'Here’s an example of two different case-variant record declarations in Pascal:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 这是 Pascal 中两种不同 case-variant 记录声明的示例：
- en: '[PRE27]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: As you can see in the `hasTagRecord` union, a Pascal case-variant record does
    not require any normal record fields. This is true even if you do not have a tag
    field.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你在`hasTagRecord`联合体中看到的，Pascal风格的变体记录不需要任何常规记录字段。即使没有标签字段，这也是成立的。
- en: '**11.2.1.3 Union Declarations in HLA**'
  id: totrans-144
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**11.2.1.3 HLA中的联合体声明**'
- en: 'HLA supports unions as well. Here’s a typical union declaration in HLA:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: HLA同样支持联合体。以下是HLA中的典型联合体声明：
- en: '[PRE28]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '**11.2.2 Storing Unions in Memory**'
  id: totrans-147
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**11.2.2 将联合体存储在内存中**'
- en: 'Remember that the big difference between a union and a record is the fact that
    records allocate storage for each field at different offsets, whereas unions overlay
    each of the fields at the same offset in memory. For example, consider the following
    HLA record and union declarations:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，联合体和记录体之间的一个重要区别是：记录体为每个字段分配不同偏移位置的存储，而联合体则将每个字段叠加在内存中的相同偏移位置。例如，考虑以下HLA的记录和联合体声明：
- en: '[PRE29]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: If you declare a variable, say `n`, of type `numericRec`, you access the fields
    as `n.i`, `n.u`, and `n.r`, exactly as though you had declared the `n` variable
    to be type `numericUnion`. However, the size of a `numericRec` object is 16 bytes,
    because the record contains two double word fields and a quad word (`real64`)
    field. The size of a `numericUnion` variable, however, is 8 bytes. [Figure 11-2](ch11.xhtml#ch11fig2)
    shows the memory arrangement of the `i`, `u`, and `r` fields in both the record
    and union.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你声明一个变量，例如`n`，类型为`numericRec`，你可以像访问`numericUnion`类型一样，访问字段`n.i`、`n.u`和`n.r`。然而，`numericRec`对象的大小为16字节，因为记录包含两个双字字段和一个四字字段（`real64`）。然而，`numericUnion`变量的大小只有8字节。[图11-2](ch11.xhtml#ch11fig2)显示了记录和联合体中`i`、`u`和`r`字段的内存排列。
- en: '![Image](../images/11fig02.jpg)'
  id: totrans-151
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/11fig02.jpg)'
- en: '*Figure 11-2: Layout of a union versus a record variable*'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: '*图11-2：联合体与记录变量的布局*'
- en: '**11.2.3 Using Unions in Other Ways**'
  id: totrans-153
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**11.2.3 以其他方式使用联合体**'
- en: 'In addition to conserving memory, programmers often use unions to create aliases
    in their code. An *alias* is a different name for the same memory object. Although
    aliases are often a source of confusion in a program and should be used sparingly,
    sometimes using them is convenient. For example, in some section of your program
    you might need to constantly use type coercion to refer to a particular object.
    To avoid this, you could use a union variable with each field representing one
    of the different types you want to use for the object. Consider the following
    HLA code fragment:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 除了节省内存，程序员还经常使用联合体在代码中创建别名。*别名*是同一内存对象的不同名称。尽管别名往往会引起程序中的困惑，应当谨慎使用，但有时使用它们是方便的。例如，在程序的某些部分，你可能需要不断地使用类型强制转换来引用某个特定对象。为了避免这种情况，你可以使用一个联合体变量，其中每个字段代表你想要为该对象使用的不同类型。考虑以下HLA代码片段：
- en: '[PRE30]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'With a declaration like this one, you can manipulate an `uns32` object by accessing
    `v.u`. If, at some point, you need to treat the LO byte of this `uns32` variable
    as a character, you can do so by simply accessing the `v.c` variable, as follows:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这样的声明，你可以通过访问`v.u`来操作`uns32`对象。如果在某个时刻，你需要将此`uns32`变量的低字节视为字符，只需访问`v.c`变量，如下所示：
- en: '[PRE31]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Another common practice is to use unions to disassemble a larger object into
    its constituent bytes. Consider the following C/C++ code fragment:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个常见的做法是使用联合体将一个较大的对象拆解为其组成字节。考虑以下C/C++代码片段：
- en: '[PRE32]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Although composing and decomposing data types this way is a useful trick to
    employ every now and then, keep in mind that this code isn’t portable. The HO
    and LO bytes of a multibyte object appear at different addresses on big endian
    versus little endian machines. As a result, this code fragment works fine on little
    endian machines, but fails to display the correct bytes on big endian CPUs. Any
    time you use unions to decompose larger objects, you should be aware of this limitation.
    Still, this trick is usually much more efficient than using shift lefts, shift
    rights, and AND operations, so you’ll see it used quite a bit.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管这样组合和拆解数据类型是一个有时非常有用的技巧，但请记住，这段代码并不具有可移植性。多字节对象的高字节（HO）和低字节（LO）在大端和小端机器上的地址是不同的。因此，这段代码在小端机器上可以正常工作，但在大端CPU上则无法正确显示字节。每次使用联合体来拆解更大的对象时，你都应该意识到这个限制。不过，这个技巧通常比使用左移、右移和与操作要高效得多，所以你会经常看到它的使用。
- en: '**11.3 Variant Types**'
  id: totrans-161
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**11.3 变体类型**'
- en: A variant object has a *dynamic* type—that is, the object’s type can vary at
    runtime. This spares the programmer from having to decide on a data type when
    designing the program and allows the end user to enter whatever data they like
    as the program operates. Programs written in a dynamically typed language are
    typically far more compact than languages written in a traditional statically
    typed language. This makes dynamically typed languages very popular for rapid
    prototyping, interpretive, and very high-level languages. A few mainstream languages
    (including Visual Basic and Delphi) also support variant types. In this section,
    we’ll look at how compilers implement variant types and discuss the efficiency
    costs associated with them.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 变体对象具有*动态*类型——即，对象的类型可以在运行时变化。这使得程序员在设计程序时不必决定数据类型，并且允许最终用户在程序运行时输入任何他们喜欢的数据。用动态类型语言编写的程序通常比用传统静态类型语言编写的程序更加紧凑。这使得动态类型语言在快速原型开发、解释型语言和高级语言中非常受欢迎。一些主流语言（包括Visual
    Basic和Delphi）也支持变体类型。在本节中，我们将讨论编译器如何实现变体类型，并讨论与之相关的效率成本。
- en: To implement a variant type, most languages use a union to reserve storage for
    all the different types the variant object supports. This means that a variant
    object will consume at least as much space as the largest primitive data type
    it supports. In addition to the storage required to keep its value, the variant
    object will also need storage to keep track of its current type. If the language
    allows variants to assume an array type, even more storage may be necessary to
    specify how many elements are in the array (or the bounds on each dimension, if
    the language allows multidimensional variant arrays). The bottom line is that
    a variant consumes a fair amount of memory, even if the actual data consumes only
    a single byte.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现一个变体类型，大多数语言使用联合体来为变体对象支持的所有不同类型预留存储空间。这意味着变体对象将至少消耗它所支持的最大原始数据类型的空间。除了保存其值所需的存储空间外，变体对象还需要存储空间来跟踪其当前类型。如果语言允许变体假定数组类型，可能还需要更多存储空间来指定数组中有多少个元素（或者如果语言支持多维变体数组，则指定每个维度的边界）。最重要的是，变体消耗了相当多的内存，即使实际数据只占一个字节。
- en: 'Perhaps the best way to illustrate how a variant data type works is to implement
    one manually. Consider the following Delphi case-variant record declaration:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 也许最好的方式来说明变体数据类型是如何工作的，就是手动实现一个。考虑以下Delphi的case-variant记录声明：
- en: '[PRE33]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: In this record, elements will contain the number of elements in the array if
    the object is a single-dimensional array (this particular data structure does
    not support multidimensional arrays). If, on the other hand, the object is a scalar
    variable, then the elements value will be irrelevant. The `theType` field specifies
    the current type of the object. If this field contains one of the enumerated constants
    `vBoolean`, `vChar`, `vInteger`, `vReal`, or `vString`, the object is a scalar
    variable; if it contains one of the constants `paBoolean`, `paChar`, `paInteger`,
    `paReal`, or `paString`, then the object is a single-dimensional array of the
    specified type.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个记录中，当对象是一个一维数组时，元素将包含数组中元素的数量（此数据结构不支持多维数组）。另一方面，如果对象是标量变量，则元素值将不相关。`theType`字段指定对象的当前类型。如果该字段包含枚举常量之一`vBoolean`、`vChar`、`vInteger`、`vReal`或`vString`，则对象是标量变量；如果它包含常量`paBoolean`、`paChar`、`paInteger`、`paReal`或`paString`之一，则对象是指定类型的一维数组。
- en: The fields in the case-variant section of the Pascal record hold the variant’s
    value if it is a scalar object, or they hold a pointer to an array of objects
    if the variant is an array object. Technically, Pascal requires that you specify
    the bounds of the array in its declaration. But fortunately, Delphi lets you turn
    off bounds checking (as well as allowing you to allocate memory for an array of
    arbitrary size), hence the dummy array bounds in this example.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: Pascal记录中的case-variant部分的字段保存变体的值（如果它是标量对象），或者如果变体是数组对象，则保存指向对象数组的指针。从技术上讲，Pascal要求你在声明中指定数组的边界。但幸运的是，Delphi允许你关闭边界检查（并且还允许你为任意大小的数组分配内存），因此在这个例子中有虚拟的数组边界。
- en: 'Manipulating two variant objects that have the same type is easy. For example,
    suppose you want to add two variant values together. First, you’d determine the
    current type of both objects and whether the addition operation even makes sense
    for the data types.^([4](footnotes.xhtml#ch11fn4)) Once you’ve decided that the
    addition operation is reasonable, it’s easy enough to use a `case` (or `switch`)
    statement based on the tag field of the two variant types:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 操作两个具有相同类型的变体对象是很容易的。例如，假设你想将两个变体值相加。首先，你需要确定这两个对象的当前类型，以及加法操作是否对这些数据类型有意义。^([4](footnotes.xhtml#ch11fn4))
    一旦你决定加法操作是合理的，就可以很容易地使用基于两个变体类型标签字段的`case`（或`switch`）语句：
- en: '[PRE34]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'If the left and right operands are not the same type, then the operation is
    a bit more complex. Some mixed-type operations are legal. For example, adding
    an integer operand and a real operand together is reasonable (it produces a real
    type result in most languages). Other operations may be legal only if the values
    of the operands can be added. For example, it’s reasonable to add a string and
    an integer together if the string happens to contain a string of digits that could
    be converted to an integer prior to the addition (likewise for string and real
    operands). What is needed here is a two-dimensional `case`/`switch` statement.
    Unfortunately, outside of assembly language, you won’t find such a creature.^([5](footnotes.xhtml#ch11fn5))
    However, you can simulate one easily enough by nesting `case`/`switch` statements:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 如果左右操作数类型不同，那么操作会变得稍微复杂一些。一些混合类型操作是合法的。例如，将整数操作数和实数操作数相加是合理的（在大多数语言中，它会产生实数类型的结果）。其他操作可能只有在操作数的值可以相加时才是合法的。例如，如果字符串恰好包含一串可以在加法之前转换为整数的数字字符，那么将字符串和整数相加是合理的（对于字符串和实数操作数也一样）。这里需要的是一个二维的`case`/`switch`语句。不幸的是，除了汇编语言外，你不会找到这种结构。^([5](footnotes.xhtml#ch11fn5))
    但是，你可以通过嵌套`case`/`switch`语句来轻松模拟这种结构：
- en: '[PRE35]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Once you expand all the code alluded to in these comments, you’ll have quite
    a few statements. And this is just for one operator! Obviously, it takes considerable
    work to implement all the basic arithmetic, string, character, and Boolean operations—and
    expanding this code inline whenever you need to add two variant values together
    is out of the question. Generally, you’d write a function like `vAdd()` that would
    accept two variant parameters and produce a variant result (or raise some sort
    of exception if the addition of the operands is illegal).
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你扩展了这些注释中提到的所有代码，你将会有相当多的语句。这只是为了一个运算符！显然，实施所有基本的算术、字符串、字符和布尔操作需要相当多的工作——并且在每次需要将两个变体值相加时，在线展开这段代码是不可行的。通常，你会写一个像`vAdd()`这样的函数，接受两个变体参数并返回一个变体结果（如果操作数相加不合法，则引发某种异常）。
- en: The takeaway here is not that the code to do variant addition is long—the real
    problem is performance. It’s not at all unreasonable to expect a variant addition
    operation to require dozens, if not hundreds, of machine instructions to accomplish.
    By contrast, it takes only two or three machine instructions to add two integer
    or floating-point values together. Therefore, you can expect operations involving
    variant objects to run approximately one to two orders of magnitude slower than
    the standard operations. This, in fact, is one of the major reasons why “typeless”
    languages (usually very high-level languages) are so slow. When you truly need
    a variant type, the performance is often just as good (or even better) than the
    alternative code you’d have to write to get around using one. However, if you’re
    using variant objects to hold values whose type you know when you first write
    the program, you’ll pay a heavy performance penalty for not using typed objects.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的要点不是变体加法的代码很长——真正的问题是性能。期望一个变体加法操作需要几十甚至上百条机器指令来完成，这一点一点也不不合理。相比之下，两个整数或浮点数值相加只需要两到三条机器指令。因此，你可以预计涉及变体对象的操作将比标准操作慢大约一个到两个数量级。事实上，这正是“无类型”语言（通常是非常高级的语言）运行缓慢的主要原因之一。当你真正需要变体类型时，它的性能往往与你为避免使用它所写的替代代码一样好（甚至更好）。然而，如果你使用变体对象来存储那些在编写程序时就知道类型的值，那么由于没有使用类型化对象，你将付出沉重的性能代价。
- en: 'In object-oriented languages such as C++, Java, Swift, and Delphi (Object Pascal),
    there’s a better solution for variant calculations: inheritance and polymorphism.
    A big problem with the `union`/`switch` statement version is that it can be a
    major pain to extend the variant type by adding a new type to it. For example,
    suppose you want to add a new complex data type supporting complex numbers. You’d
    have to locate every function you’ve written (typically one for each operator)
    and add a new `case` to the `switch` statement. This can be a maintenance nightmare
    (especially if you don’t have access to the original source code). However, by
    using objects, you can create a new class (such as `ComplexNumber`) that overrides
    the existing base class (perhaps `Numeric`) without having to modify any of the
    existing code (for other numeric types and operations). For more information on
    this method, see *Write Great Code, Volume 4: Designing Great Code*.'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: '在面向对象的语言如 C++、Java、Swift 和 Delphi（Object Pascal）中，有一个更好的变体计算解决方案：继承和多态。使用 `union`/`switch`
    语句版本的一个大问题是，扩展变体类型时需要添加新类型，这可能非常麻烦。例如，假设你想添加一个新的复合数据类型来支持复数。你必须找到你写的每个函数（通常每个运算符一个），并在
    `switch` 语句中添加一个新的 `case`。这可能会导致维护上的噩梦（尤其是当你无法访问原始源代码时）。然而，使用对象时，你可以创建一个新的类（比如
    `ComplexNumber`），它重写现有的基类（可能是 `Numeric`），而无需修改任何现有的代码（对于其他数字类型和运算）。有关此方法的更多信息，请参见
    *Write Great Code, Volume 4: Designing Great Code*。'
- en: '**11.4 Namespaces**'
  id: totrans-175
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**11.4 命名空间**'
- en: As your programs become larger, and particularly as these large programs use
    third-party software libraries to reduce development time, it becomes increasingly
    likely that name conflicts will arise in your source files. A name conflict occurs
    when you want to use a specific identifier at one point in your program, but that
    name is already in use elsewhere (for example, in a library you’re using). At
    some point in a very large project, you may dream up a new name to resolve a naming
    conflict only to discover that the new name is also already in use. Software engineers
    call this *namespace pollution*. Like environmental pollution, the problem is
    easy to live with when it’s small and localized. As your programs get larger,
    however, dealing with the fact that “all the good identifiers are already used
    up” is a real challenge.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 随着你的程序变得越来越大，特别是当这些大型程序使用第三方软件库来减少开发时间时，源文件中出现名称冲突的可能性也会越来越高。名称冲突发生在你想在程序的某一部分使用一个特定的标识符时，但该名称已经在其他地方被使用（例如，在你使用的一个库中）。在一个非常大的项目中，你可能会想出一个新的名称来解决命名冲突，结果却发现新名称也已经被使用。软件工程师称这种情况为
    *命名空间污染*。就像环境污染一样，当污染小而局部时，问题容易忽视。然而，随着程序变得越来越大，处理“所有好的标识符都已经被占用”的问题变得越来越具有挑战性。
- en: 'At first blush, it might seem that this problem is exaggerated; after all,
    a programmer can always think of a different name. However, programmers who write
    great code often adhere to certain naming conventions so that their source code
    is consistent and easy to read (I’ll come back to this subject in *Write Great
    Code, Volume 5: Great Coding*). Constantly devising new names, even if they aren’t
    all that bad, tends to produce inconsistencies in the source code that make programs
    harder to read. It would be nice to choose whatever name you like for your identifiers
    and not have to worry about conflicts with other code or libraries. Enter namespaces.'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: '初看起来，这个问题可能显得有些夸大；毕竟，程序员总能想到一个不同的名称。然而，编写优质代码的程序员往往会遵循某些命名约定，以确保他们的源代码一致且易于阅读（我将在
    *Write Great Code, Volume 5: Great Coding* 中回到这个话题）。不断想出新的名称，即使它们并不那么糟糕，往往会导致源代码中的不一致性，使程序更难阅读。如果你能够随心所欲地为标识符选择名称，而不必担心与其他代码或库冲突，那将是多么美好。命名空间应运而生。'
- en: 'A *namespace* is a mechanism by which you can associate a set of identifiers
    with a namespace identifier. In many respects, a namespace is like a record declaration.
    Indeed, you can use a `record` (or `struct`) declaration as a poor man’s namespace
    in languages that don’t support namespaces directly (with a few major restrictions).
    For example, consider the following Pascal variable declarations:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: '*命名空间* 是一种机制，允许你将一组标识符与命名空间标识符关联。在许多方面，命名空间就像是记录声明。事实上，在不直接支持命名空间的语言中，你可以使用
    `record`（或 `struct`）声明作为一种简单的命名空间（有一些主要的限制）。例如，考虑以下 Pascal 变量声明：'
- en: '[PRE36]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'As you can see, the `i` and `j` fields in these two records are distinct variables.
    There will never be a naming conflict because the program must qualify these two
    field names with the record variable name. That is, you refer to these variables
    using the following names:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，这两个记录中的 `i` 和 `j` 字段是不同的变量。由于程序必须使用记录变量名来限定这两个字段名称，因此永远不会发生命名冲突。也就是说，你使用以下名称来引用这些变量：
- en: '[PRE37]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: The record variable that prefixes the fields uniquely identifies each of these
    field names. This is clear to anyone who has ever written code that uses a record
    or structure. Therefore, in languages that don’t support namespaces, you can use
    records (or classes) in their place.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 作为字段前缀的记录变量唯一标识了这些字段名称中的每一个。对于曾经编写过使用记录或结构体代码的人来说，这是显而易见的。因此，在不支持命名空间的语言中，你可以使用记录（或类）来代替它们。
- en: 'There is one major problem with creating namespaces by using records or structures,
    though: many languages let you declare only variables within a record. Namespace
    declarations (like those available in C++ and HLA) specifically allow you to include
    other types of objects as well. In HLA, for example, a namespace declaration takes
    the following form:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，使用记录或结构体创建命名空间有一个主要问题：许多语言只允许在记录中声明变量。命名空间声明（如 C++ 和 HLA 中可用的那种）专门允许你包含其他类型的对象。例如，在
    HLA 中，命名空间声明具有以下形式：
- en: '[PRE38]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: A class declaration (if available in your chosen language) can overcome some
    of these problems. At the very least, most languages allow procedure or function
    declarations within a class, but many allow constant and type declarations as
    well.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 类声明（如果在你选择的语言中可用）可以克服一些这些问题。至少，大多数语言允许在类中声明过程或函数，但许多语言也允许常量和类型声明。
- en: Namespaces are a declaration section unto themselves. In particular, they do
    not have to go in a `var` or `static` (or any other) section. You can create constants,
    types, variables, static objects, procedures, and so on, all within a namespace.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 命名空间本身就是一个声明部分。特别地，它们不必放在 `var` 或 `static`（或任何其他）部分中。你可以在命名空间内创建常量、类型、变量、静态对象、过程等。
- en: To access namespace objects in HLA, you use the familiar dot notation that records,
    classes, and unions use. To access a name in a C++ namespace, you use the `::`
    operator.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 在 HLA 中访问命名空间对象时，使用记录、类和联合体所使用的熟悉的点符号。如果要访问 C++ 命名空间中的名称，则使用 `::` 操作符。
- en: As long as the namespace identifier is unique and all the fields within the
    namespace are unique to that namespace, you won’t have any problems. By carefully
    partitioning a project into various namespaces, you can easily avoid most of the
    problems that occur because of namespace pollution.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 只要命名空间标识符是唯一的，并且命名空间内的所有字段都是该命名空间唯一的，你就不会遇到任何问题。通过仔细将项目划分为不同的命名空间，你可以轻松避免由于命名空间污染而发生的大部分问题。
- en: 'Another interesting aspect to namespaces is that they are extensible. For example,
    consider the following declarations in C++:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 命名空间的另一个有趣的方面是它们是可扩展的。例如，考虑以下 C++ 中的声明：
- en: '[PRE39]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'This example code is perfectly legal. The second declaration of `aNS` does
    not conflict with the first: it extends the `aNS` namespace to include identifier
    `aNS::k` as well as `aNS::i` and `aNS::j`. This feature is very handy when, for
    example, you want to extend a set of library routines and header files without
    modifying the original header files for that library (assuming the library names
    all appear within a namespace).'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 这个示例代码是完全合法的。`aNS` 的第二个声明与第一个声明不冲突：它扩展了 `aNS` 命名空间，包含了标识符 `aNS::k` 以及 `aNS::i`
    和 `aNS::j`。这个特性在你想扩展一组库例程和头文件时非常有用，而无需修改原始库的头文件（假设库的名称都出现在命名空间中）。
- en: From an implementation point of view, there’s really no difference between a
    namespace and a set of declarations appearing outside a namespace. The compiler
    typically deals with both types of declarations in a nearly identical fashion,
    with the only difference being that the program prefixes all objects located within
    the namespace with the namespace’s identifier.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 从实现的角度来看，命名空间和出现在命名空间外的声明集之间真的没有区别。编译器通常以几乎相同的方式处理这两种类型的声明，唯一的区别是程序会使用命名空间的标识符来为命名空间内的所有对象加上前缀。
- en: '**11.5 Classes and Objects**'
  id: totrans-193
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**11.5 类和对象**'
- en: The *class* data type is the bedrock of modern object-oriented programming (OOP).
    In most OOP languages, the class is closely related to the record or structure.
    However, unlike records (which have a surprisingly uniform implementation across
    most languages), class implementations tend to vary. Nevertheless, many contemporary
    OOP languages achieve their results using similar approaches, so this section
    demonstrates a few concrete examples from C++, Java, Swift, HLA, and Delphi (Object
    Pascal). Users of other languages will find their languages work similarly.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: '*类* 数据类型是现代面向对象编程（OOP）的基石。在大多数 OOP 语言中，类与记录或结构密切相关。然而，与记录（在大多数语言中具有惊人一致的实现）不同，类的实现往往有所不同。然而，许多现代
    OOP 语言通过类似的方式实现其结果，因此本节展示了来自 C++、Java、Swift、HLA 和 Delphi（Object Pascal）的一些具体示例。其他语言的用户将发现他们的语言也有类似的工作方式。'
- en: '**11.5.1 Classes vs. Objects**'
  id: totrans-195
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**11.5.1 类与对象**'
- en: Many programmers confuse the terms *class* and *object*. A class is a data type;
    it is a template for how the compiler organizes memory with respect to the class’s
    fields. An object is an instantiation of a class—that is, an object is a variable
    of some class type that has memory allocated to hold the data associated with
    the class’s fields. For a given class, there is only one class definition. You
    may, however, have several objects (variables) of that class type.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 许多程序员混淆了*类*和*对象*这两个术语。类是一种数据类型；它是编译器根据类的字段组织内存的模板。对象是类的实例化——也就是说，对象是某个类类型的变量，内存已分配用于存储与类字段相关的数据。对于给定的类，只有一个类定义。然而，您可以有该类类型的多个对象（变量）。
- en: '**11.5.2 Simple Class Declarations in C++**'
  id: totrans-197
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**11.5.2 C++ 中的简单类声明**'
- en: 'Classes and structures are syntactically and semantically similar in C++. Indeed,
    there is only one syntactical difference between them: the use of the `class`
    keyword versus the `struct` keyword. Consider the following two valid type declarations
    in C++:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 在 C++ 中，类和结构在语法和语义上是相似的。实际上，它们之间只有一个语法上的区别：使用 `class` 关键字和使用 `struct` 关键字。考虑以下两个在
    C++ 中有效的类型声明：
- en: '[PRE40]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Although these two data structures contain the same fields, and you would access
    those fields the same way, their memory implementation is slightly different.
    A typical memory layout for the structure appears in [Figure 11-3](ch11.xhtml#ch11fig3),
    which can be compared with the memory layout for the class shown in [Figure 11-4](ch11.xhtml#ch11fig4).
    ([Figure 11-3](ch11.xhtml#ch11fig3) is the same as [Figure 11-1](ch11.xhtml#ch11fig1),
    but appears here for easy comparison with [Figure 11-4](ch11.xhtml#ch11fig4).)
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管这两种数据结构包含相同的字段，且你将以相同的方式访问这些字段，但它们的内存实现略有不同。结构体的典型内存布局出现在 [图 11-3](ch11.xhtml#ch11fig3)
    中，可以与类的内存布局（见 [图 11-4](ch11.xhtml#ch11fig4)）进行比较。（[图 11-3](ch11.xhtml#ch11fig3)
    与 [图 11-1](ch11.xhtml#ch11fig1) 相同，但此处为了方便与 [图 11-4](ch11.xhtml#ch11fig4) 进行比较而再次出现。）
- en: '![Image](../images/11fig03.jpg)'
  id: totrans-201
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/11fig03.jpg)'
- en: '*Figure 11-3: The student structure storage in memory*'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 11-3：学生结构体在内存中的存储*'
- en: '![Image](../images/11fig04.jpg)'
  id: totrans-203
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/11fig04.jpg)'
- en: '*Figure 11-4: The student class storage in memory*'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 11-4：学生类在内存中的存储*'
- en: The *VMT pointer* is a field that appears if the class contains any class member
    functions (aka *methods*). Some C++ compilers do not emit a VMT pointer field
    if there are no member functions, in which case the `class` and `struct` objects
    will have the same layout in memory.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: '*VMT 指针* 是一个字段，如果类包含任何类成员函数（即 *方法*），该字段会出现。某些 C++ 编译器如果没有成员函数，则不会生成 VMT 指针字段，这种情况下，`class`
    和 `struct` 对象在内存中的布局是相同的。'
- en: '**NOTE**'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: VMT *stands for* virtual method table *and will be discussed further in the
    section “Virtual Method Tables” on [page 367](ch11.xhtml#page_367).*
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: VMT *代表* 虚拟方法表，*将在“虚拟方法表”一节中进一步讨论，见 [第 367 页](ch11.xhtml#page_367)。*
- en: 'Although a C++ class declaration could contain only data fields, classes generally
    contain member function definitions as well as data members. In the `myClass`
    example, you might have the following member functions:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 C++ 类声明可能仅包含数据字段，但类通常还包含成员函数定义以及数据成员。在 `myClass` 示例中，可能有以下成员函数：
- en: '[PRE41]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: The `computeGrade()` function might compute the total grade in the course (based
    on relative weights attached to the midterms, final, homework, and project scores).
    The `testAverage()` function might return the average of all the test scores.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: '`computeGrade()` 函数可能计算课程的总成绩（基于期中考试、期末考试、作业和项目分数的相对权重）。`testAverage()` 函数可能返回所有测试分数的平均值。'
- en: '**11.5.3 Class Declarations in C# and Java**'
  id: totrans-211
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**11.5.3 C# 和 Java 中的类声明**'
- en: 'C# and Java classes look very similar to C/C++ class declarations. Here’s a
    sample C# class declaration (which also works for Java):'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: C# 和 Java 类与 C/C++ 类声明非常相似。以下是一个 C# 类声明示例（也适用于 Java）：
- en: '[PRE42]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: '**11.5.4 Class Declarations in Delphi (Object Pascal)**'
  id: totrans-214
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**11.5.4 Delphi (Object Pascal) 中的类声明**'
- en: Delphi (Object Pascal) classes look very similar to Pascal records. Classes
    use the `class` keyword instead of `record`, and you can include function prototype
    declarations in the class.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: Delphi (Object Pascal) 类看起来与 Pascal 记录非常相似。类使用 `class` 关键字，而不是 `record`，并且你可以在类中包含函数原型声明。
- en: '[PRE43]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: '**11.5.5 Class Declarations in HLA**'
  id: totrans-217
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**11.5.5 HLA 中的类声明**'
- en: HLA classes look very similar to HLA records. Classes use the `class` keyword
    instead of `record`, and you can include function (method) prototype declarations
    in the class.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: HLA 类看起来与 HLA 记录非常相似。类使用 `class` 关键字，而不是 `record`，并且你可以在类中包含函数（方法）原型声明。
- en: '[PRE44]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: '**11.5.6 Virtual Method Tables**'
  id: totrans-220
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**11.5.6 虚拟方法表**'
- en: As you saw in [Figures 11-3](ch11.xhtml#ch11fig3) and [11-4](ch11.xhtml#ch11fig4),
    the difference between the class definition and the structure definition is that
    the former contains a VMT field. VMT, which stands for *virtual method table*,
    is an array of pointers to all the member functions, or *methods*, within an object’s
    class. Virtual methods (*virtual member functions* in C++) are special class-related
    functions that you declare as fields in the class. In the current student example,
    the class doesn’t actually have any virtual methods, so most C++ compilers would
    eliminate the VMT field, but some OOP languages will still allocate storage for
    the VMT pointer within the class.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 如你在[图 11-3](ch11.xhtml#ch11fig3)和[11-4](ch11.xhtml#ch11fig4)中看到的，类定义与结构定义的区别在于前者包含了
    VMT 字段。VMT，代表*虚拟方法表*，是指向对象类中所有成员函数或*方法*的指针数组。虚拟方法（在 C++ 中是*虚拟成员函数*）是你在类中声明为字段的特殊类相关函数。在当前的学生示例中，类实际上没有任何虚拟方法，因此大多数
    C++ 编译器会去除 VMT 字段，但一些面向对象编程语言仍会在类中为 VMT 指针分配存储。
- en: 'Here’s a little C++ class that actually has a virtual member function and,
    therefore, also has a VMT:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个实际具有虚拟成员函数的小型 C++ 类，因此它也具有 VMT：
- en: '[PRE45]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: When C++ calls a standard function, it directly calls that function. Virtual
    member functions are another story, as you can see in [Figure 11-5](ch11.xhtml#ch11fig5).
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 当 C++ 调用标准函数时，它直接调用该函数。虚拟成员函数则另当别论，正如你在[图 11-5](ch11.xhtml#ch11fig5)中看到的那样。
- en: '![Image](../images/11fig05.jpg)'
  id: totrans-225
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/11fig05.jpg)'
- en: '*Figure 11-5: A virtual method table in C++*'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 11-5：C++ 中的虚拟方法表*'
- en: 'Calling a virtual member function requires *two* indirect accesses. First,
    the program has to fetch the VMT pointer from the class object and use that to
    indirectly fetch a particular virtual function address from the VMT. Then the
    program has to make an indirect call to the virtual member function via the pointer
    it retrieved from the VMT. As an example, consider the following C++ function:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 调用虚拟成员函数需要*两个*间接访问。首先，程序需要从类对象中获取 VMT 指针，并利用该指针间接获取 VMT 中特定虚拟函数的地址。然后，程序必须通过从
    VMT 检索到的指针，间接调用虚拟成员函数。作为例子，请考虑以下 C++ 函数：
- en: '[PRE46]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Here’s the corresponding x86-64 assembly code that Visual C++ generates:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 这是 Visual C++ 生成的相应 x86-64 汇编代码：
- en: '[PRE47]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'This example amply demonstrates why object-oriented programs generally run
    a little more slowly than standard procedural programs: extra indirection when
    calling virtual methods. C++ attempts to address this inefficiency by providing
    *static member functions*, but they lose many of the benefits of virtual member
    functions that make object-oriented programming possible.'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子充分展示了为什么面向对象程序通常比标准的过程式程序运行稍慢：调用虚拟方法时的额外间接访问。C++ 尝试通过提供*静态成员函数*来解决这一效率问题，但它们失去了虚拟成员函数带来的许多面向对象编程的好处。
- en: '**11.5.7 Abstract Methods**'
  id: totrans-232
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**11.5.7 抽象方法**'
- en: 'Some languages (such as C++) allow you to declare *abstract methods* within
    a class. An abstract method declaration tells the compiler that you will not be
    supplying the actual code for that method. Instead, you’re promising that some
    derived class will provide the method’s implementation. Here’s a version of `myclass`
    that has an abstract method:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 一些语言（例如 C++）允许在类中声明*抽象方法*。抽象方法声明告诉编译器，你不会提供该方法的实际代码。相反，你承诺某个派生类会提供该方法的实现。以下是具有抽象方法的`myclass`版本：
- en: '[PRE48]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Why the strange syntax? It doesn’t really make sense to assign `0` to a virtual
    function. Why not just use an `abstract` keyword (rather than `virtual`) like
    most other languages do? These are good questions. The answer probably has a lot
    to do with the fact that a `0` (`NULL` pointer) was being placed in the VMT entry
    for the abstract function. In modern versions of C++, compiler implementers typically
    place the address of some function that generates an appropriate runtime message
    (like `cannot call an abstract method`) here, rather than a `NULL` pointer. The
    following code snippet shows the Visual C++ VMT for this version of `myclass`:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么会有这种奇怪的语法？将 `0` 赋值给虚函数似乎没有太大意义。为什么不直接使用像大多数其他语言那样的 `abstract` 关键字（而不是 `virtual`）呢？这些问题很有价值。答案可能与
    `0`（`NULL` 指针）被放置在抽象函数的 VMT 条目中有很大关系。在现代版本的 C++ 中，编译器实现者通常将某个函数的地址放在这里，该函数会生成一个合适的运行时消息（例如
    `不能调用抽象方法`），而不是放置 `NULL` 指针。以下代码片段展示了 Visual C++ 中该版本 `myclass` 的 VMT：
- en: '[PRE49]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: The `_purecall` entry corresponds to the abstract function `h()`. This is the
    name of the subroutine that handles illegal calls to abstract functions. When
    you override an abstract function, the C++ compiler replaces the pointer in the
    VMT to the `_purecall` function with the address of the overriding function (just
    as it would replace the address of any overridden function).
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: '`_purecall` 条目对应于抽象函数 `h()`。这是处理非法调用抽象函数的子程序的名称。当你重写一个抽象函数时，C++ 编译器会将 VMT 中指向
    `_purecall` 函数的指针替换为重写函数的地址（就像它会替换任何被重写函数的地址一样）。'
- en: '**11.5.8 Sharing VMTs**'
  id: totrans-238
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**11.5.8 共享 VMT**'
- en: For a given class there is only one copy of the VMT in memory. This is a static
    object, so all objects of a given class type share the same VMT. This is reasonable,
    because all objects of the same class type have exactly the same member functions
    (see [Figure 11-6](ch11.xhtml#ch11fig6)).
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 对于一个给定的类，内存中只有一份 VMT 副本。它是一个静态对象，因此所有该类类型的对象共享相同的 VMT。这是合理的，因为所有同类类型的对象具有完全相同的成员函数（参见
    [图 11-6](ch11.xhtml#ch11fig6)）。
- en: '![Image](../images/11fig06.jpg)'
  id: totrans-240
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/11fig06.jpg)'
- en: '*Figure 11-6: Objects sharing the same VMT (note that objects are all the same
    class type)*'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 11-6：共享相同 VMT 的对象（注意对象都是相同的类类型）*'
- en: Because the addresses in a VMT never change during program execution, most languages
    place the VMT in a constant (write-protected) section in memory. In the previous
    example, the compiler places the `myclass` VMT in the `CONST` segment.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 VMT 中的地址在程序执行过程中永远不会改变，大多数语言将 VMT 放置在内存中的常量（只读保护）部分。在前面的例子中，编译器将 `myclass`
    的 VMT 放置在 `CONST` 段。
- en: '**11.5.9 Inheritance in Classes**'
  id: totrans-243
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**11.5.9 类中的继承**'
- en: 'Inheritance is one of the fundamental concepts behind object-oriented programming.
    The basic idea is that a class inherits, or copies, all the fields from some existing
    class and then possibly expands the number of fields in the new class data type.
    For example, suppose you created a data type point that describes a point in the
    planar (two-dimensional) space. The class for this point might look like the following:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 继承是面向对象编程的基本概念之一。基本思想是一个类继承或复制某个已有类的所有字段，然后可能会扩展新类数据类型中的字段数量。例如，假设你创建了一个描述平面（二维）空间中点的数据类型
    `point`。该点的类可能如下所示：
- en: '[PRE50]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: The `distance()` member function would probably compute the distance from the
    origin (0,0) to the coordinate specified by the (`x`,`y`) fields of the object.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: '`distance()` 成员函数可能会计算从原点（0,0）到由对象的 (`x`,`y`) 字段指定的坐标的距离。'
- en: 'Here’s a typical implementation of this member function:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 这是该成员函数的典型实现：
- en: '[PRE51]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Inheritance allows you to extend an existing class by adding new fields or
    replacing existing fields. For example, suppose you want to extend the two-dimensional
    point definition to a third spatial dimension. You can easily do this with the
    following C++ class definition:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 继承允许你通过添加新的字段或替换现有字段来扩展一个已有的类。例如，假设你想将二维点的定义扩展到第三个空间维度。你可以通过以下 C++ 类定义轻松实现这一点：
- en: '[PRE52]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: The `point3D` class inherits the `x` and `y` fields, as well as the `distance()`
    member function. (Of course, `distance()` does not compute the proper result for
    a point in three-dimensional space, but I’ll address that in a moment.) By “inherits,”
    I mean that `point3D` objects locate their `x` and `y` fields at exactly the same
    offsets as `point` objects do (see [Figure 11-7](ch11.xhtml#ch11fig7)).
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: '`point3D` 类继承了 `x` 和 `y` 字段，以及 `distance()` 成员函数。（当然，`distance()` 并没有计算三维空间中点的正确结果，不过稍后我会讨论这个问题。）我所说的“继承”是指，`point3D`
    对象将它们的 `x` 和 `y` 字段定位在与 `point` 对象相同的偏移位置（见 [图11-7](ch11.xhtml#ch11fig7)）。'
- en: '![Image](../images/11fig07.jpg)'
  id: totrans-252
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/11fig07.jpg)'
- en: '*Figure 11-7: Inheritance in classes*'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: '*图11-7：类中的继承*'
- en: As you might have noticed, there were actually two items added to the `point3D`
    class—a new data field, `z`, and a new member function, `rotate()`. In [Figure
    11-7](ch11.xhtml#ch11fig7), you can see that adding the `rotate()` virtual member
    function has had no impact at all on the layout of a `point3D` object. This is
    because virtual member functions’ addresses appear in the VMT, not in the object
    itself. Although both `point` and `point3D` contain a field named `VMT`, these
    fields do not point at the same table in memory. Every class has its own unique
    VMT, which, as previously defined, consists of an array of pointers to all of
    the member functions (inherited or explicitly declared) for the class (see [Figure
    11-8](ch11.xhtml#ch11fig8)).
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你可能注意到的，`point3D` 类实际上添加了两个项——一个新的数据字段 `z` 和一个新的成员函数 `rotate()`。在 [图11-7](ch11.xhtml#ch11fig7)
    中，你可以看到添加 `rotate()` 虚拟成员函数并没有对 `point3D` 对象的布局产生任何影响。这是因为虚拟成员函数的地址出现在 VMT 中，而不是对象本身中。虽然
    `point` 和 `point3D` 都包含一个名为 `VMT` 的字段，但这些字段并不指向内存中的同一表格。每个类都有其独特的 VMT，该 VMT 如前所述，由指向类的所有成员函数（包括继承或显式声明的）的指针数组组成（见
    [图11-8](ch11.xhtml#ch11fig8)）。
- en: '![Image](../images/11fig08.jpg)'
  id: totrans-255
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/11fig08.jpg)'
- en: '*Figure 11-8: VMTs for inherited classes (assuming 32-bit pointers)*'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: '*图11-8：继承类的 VMT（假设为 32 位指针）*'
- en: All the objects for a given class share the same VMT, but this is not true for
    objects of different classes. Because `point` and `point3D` are different classes,
    their objects’ VMT fields will point at different VMTs in memory. (See [Figure
    11-9](ch11.xhtml#ch11fig9).)
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 对于给定的类，所有对象共享相同的 VMT，但对于不同类的对象则不成立。由于 `point` 和 `point3D` 是不同的类，它们的对象的 VMT 字段将在内存中指向不同的
    VMT。（见 [图11-9](ch11.xhtml#ch11fig9)）。
- en: '![Image](../images/11fig09.jpg)'
  id: totrans-258
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/11fig09.jpg)'
- en: '*Figure 11-9: VMT access*'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: '*图11-9：VMT访问*'
- en: 'One problem with the `point3D` definition given thus far is that it inherits
    the `distance()` function from the `point` class. By default, if a class inherits
    member functions from some other class, the entries in the VMT corresponding to
    those inherited functions will point at the functions associated with the base
    class. If you have an object pointer variable of type `point3D`, let’s say `p3D`,
    and you invoke the member function `p3D->distance()`, you will not get a correct
    result. Because `point3D` inherits the `distance()` function from class `point`,
    `p3->distance()` will compute the distance to the projection of (`x,y,z`) onto
    the two-dimensional plane rather than the correct value on the three-dimensional
    plane. In C++ you can overcome this problem by *overloading* the inherited function
    and writing a new, `point3D`-specific member function like so:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，`point3D` 定义的一个问题是，它从 `point` 类继承了 `distance()` 函数。默认情况下，如果一个类从另一个类继承了成员函数，则对应于这些继承函数的
    VMT 条目将指向基类相关函数的地址。如果你有一个 `point3D` 类型的对象指针变量，比如 `p3D`，并调用成员函数 `p3D->distance()`，你将得不到正确的结果。因为
    `point3D` 从 `point` 类继承了 `distance()` 函数，`p3->distance()` 会计算到 (`x,y,z`) 在二维平面上的投影的距离，而不是正确的三维平面上的值。在
    C++ 中，你可以通过*重载*继承的函数，并编写一个新的、特定于 `point3D` 的成员函数来解决这个问题，代码如下：
- en: '[PRE53]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: Creating an overloaded member function does not change the layout of the class’s
    data or the layout of the `point3D` VMT. The only change this function evokes
    is that the C++ compiler initializes the `distance()` entry in the `point3D` VMT
    with the address of the `point3D::distance()` function rather than the address
    of the `point::distance()` function.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个重载的成员函数不会改变类的数据布局或`point3D` VMT的布局。这个函数引发的唯一变化是，C++ 编译器将 `distance()` 条目的地址初始化为
    `point3D::distance()` 函数的地址，而不是 `point::distance()` 函数的地址。
- en: '**11.5.10 Polymorphism in Classes**'
  id: totrans-263
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**11.5.10 类中的多态性**'
- en: In addition to inheritance and overloading, *polymorphism* is the other anchor
    upon which object-oriented programming is based. Polymorphism, which literally
    means “many-faced” (or, translated a little better, “many forms” or “many shapes”),
    describes how a single instance of a function call in your program, such as `x->distance()`,
    could wind up calling different functions (in the examples from the previous section,
    this could be the `point::distance()` or `point3D::distance()` function). What
    makes this possible is the fact that C++ relaxes its type-checking facilities
    a bit when dealing with derived (inherited) classes.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 除了继承和重载外，*多态性*是面向对象编程的另一个基石。多态性，字面意思是“多面性”（或者翻译得更好一点是“多种形式”或“多种形状”），描述的是在你的程序中，像`x->distance()`这样的单一函数调用如何最终调用不同的函数（在上一节的例子中，这可能是`point::distance()`或者`point3D::distance()`函数）。之所以能够实现这一点，是因为C++在处理派生类（继承类）时，会在一定程度上放宽类型检查。
- en: 'Let’s look at an example. Normally, a C++ compiler will generate an error if
    you try to do the following:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 我们来看一个例子。通常情况下，如果你尝试执行以下操作，C++编译器会报错：
- en: '[PRE54]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'C++ does not allow you to assign the address of some object to a pointer whose
    base type doesn’t exactly match the object’s type—with one major exception. C++
    relaxes this restriction so you can assign the address of some object to a pointer
    as long as the pointer’s base type either matches *or is an ancestor of* the object’s
    type (an ancestor class is one from which some other class type is derived, directly
    or indirectly, via inheritance). That means the following code is legal:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: C++不允许将某个对象的地址赋值给基类型与对象类型完全不匹配的指针——但有一个主要的例外。C++放宽了这一限制，只要指针的基类型与对象的类型匹配*或是对象类型的祖先*（祖先类是通过继承直接或间接派生出其他类类型的类），那么就可以将某个对象的地址赋值给指针。这意味着以下代码是合法的：
- en: '[PRE55]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: If you’re wondering how this could be legitimate, take another look at [Figure
    11-7](ch11.xhtml#ch11fig7). If `generic`’s base type is `point`, then the C++
    compiler will allow access to a VMT at offset 0 in the object, an `x` field at
    offset 4 (8 on 64-bit machines) in the object, and a `y` field at offset 8 (16)
    in the object. Similarly, any attempt to invoke the `distance()` member function
    will access the function pointer at offset 0 into the VMT pointed at by the object’s
    VMT field. If `generic` points at an object of type `point`, all of these requirements
    are satisfied. This is also true if `generic` points at any derived class of `point`
    (that is, any class that inherits the fields from `point`). None of the extra
    fields in the derived class (`point3D`) will be accessible via the generic pointer,
    but that’s to be expected because `generic`’s base class is `point`.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在想这如何可能是合法的，可以再看看[图 11-7](ch11.xhtml#ch11fig7)。如果`generic`的基类型是`point`，那么C++编译器将允许访问对象中偏移量为0的VMT，偏移量为4（在64位机器上为8）的`x`字段，以及偏移量为8（16）的`y`字段。同样，任何尝试调用`distance()`成员函数的操作都会访问指向对象VMT字段的VMT中的函数指针。如果`generic`指向`point`类型的对象，那么所有这些要求都得到满足。如果`generic`指向`point`的任何派生类（即，任何继承自`point`字段的类），也是如此。派生类中（`point3D`）的额外字段无法通过`generic`指针访问，但这是预期的，因为`generic`的基类是`point`。
- en: A crucial thing to note, however, is that when you invoke the `distance()` member
    function, you’re calling the one pointed at by the `point3D` VMT, not the one
    pointed at by the `point` VMT. This fact is the basis for polymorphism in an OOP
    language such as C++. The code a compiler emits is exactly the same code it would
    emit if `generic` contained the address of an object of type `point`. All of the
    “magic” occurs because the compiler allows the programmer to load the address
    of a `point3D` object into `generic`.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，需要注意的一个关键点是，当你调用`distance()`成员函数时，实际上是调用了由`point3D` VMT指向的函数，而不是由`point`
    VMT指向的函数。这一事实是C++等面向对象编程语言多态性的基础。编译器生成的代码与`generic`包含`point`类型对象地址时生成的代码完全相同。所有的“魔法”发生的原因是，编译器允许程序员将`point3D`对象的地址加载到`generic`中。
- en: '**11.5.11 Multiple Inheritance (in C++)**'
  id: totrans-271
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**11.5.11 多重继承（在C++中）**'
- en: 'C++ is one of the few modern programming languages that support *multiple inheritance*,
    whereby a class can inherit the data and member functions from multiple classes.
    Consider the following C++ code fragment:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: C++是为数不多的支持*多重继承*的现代编程语言之一，允许一个类从多个类继承数据和成员函数。考虑以下C++代码片段：
- en: '[PRE56]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: In this example, class `c` inherits all the information from classes `a` and
    `b`. In memory, a typical C++ compiler will create an object like that shown in
    [Figure 11-10](ch11.xhtml#ch11fig10).
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，`c` 类继承了 `a` 和 `b` 类的所有信息。在内存中，典型的 C++ 编译器会创建如[图 11-10](ch11.xhtml#ch11fig10)所示的对象。
- en: '![Image](../images/11fig10.jpg)'
  id: totrans-275
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/11fig10.jpg)'
- en: '*Figure 11-10: Multiple inheritance memory layout*'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 11-10：多重继承内存布局*'
- en: The VMT pointer entry points at a typical VMT containing the addresses of the
    `setI()`, `setJ()`, and `setK()` methods, as shown in [Figure 11-11](ch11.xhtml#ch11fig11).
    If you call the `setI()` method, the compiler will generate code that loads the
    `this` pointer with the address of the VMT pointer entry in the object (the base
    address of the `c` object in [Figure 11-10](ch11.xhtml#ch11fig10)). Upon entry
    into `setI()`, the system believes that `this` is pointing at an object of type
    `a`. In particular, the `this`.`VMT` field points at a VMT whose first (and, as
    far as type `a` is concerned, only) entry is the address of the `setI()` method.
    Likewise, at offset (`this+8`) in memory (as the VMT pointer is 8 bytes, assuming
    64-bit pointers), the `setI()` method will find the `i` data value. As far as
    `setI()` is concerned, `this` is pointing at a class type `a` object (even though
    it’s actually pointing at a type `c` object).
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: VMT 指针条目指向一个典型的 VMT，包含了 `setI()`、`setJ()` 和 `setK()` 方法的地址，如[图 11-11](ch11.xhtml#ch11fig11)所示。如果你调用
    `setI()` 方法，编译器将生成代码，将 `this` 指针加载为对象中 VMT 指针条目的地址（如[图 11-10](ch11.xhtml#ch11fig10)所示的
    `c` 对象的基地址）。进入 `setI()` 方法时，系统认为 `this` 指向的是一个类型为 `a` 的对象。特别地，`this`.`VMT` 字段指向一个
    VMT，其第一个（对于类型 `a` 来说是唯一的）条目是 `setI()` 方法的地址。同样地，在内存中偏移量为 (`this+8`) 的位置（由于 VMT
    指针为 8 字节，假设使用 64 位指针），`setI()` 方法将找到 `i` 数据值。对于 `setI()` 来说，`this` 指向的是一个类型为 `a`
    的类对象（尽管它实际上指向的是一个类型为 `c` 的对象）。
- en: '![Image](../images/11fig11.jpg)'
  id: totrans-278
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/11fig11.jpg)'
- en: '*Figure 11-11: Multiple inheritance this values*'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 11-11：多重继承中的 `this` 值*'
- en: When you call the `setK()` method, the system also passes the base address of
    the `c` object. Of course, `setK()` is expecting a type `c` object and `this`
    is pointing at a type `c` object, so all the offsets into the object are exactly
    as `setK()` expects. Note that objects of type `c` (and methods in the `c` class)
    will normally ignore the `VMT2` pointer field in the `c` object.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 当你调用 `setK()` 方法时，系统也会传递 `c` 对象的基地址。当然，`setK()` 方法期望的是一个类型为 `c` 的对象，并且 `this`
    正指向一个类型为 `c` 的对象，因此对象中的所有偏移量都正如 `setK()` 所期望的那样。请注意，`c` 类型的对象（以及 `c` 类中的方法）通常会忽略
    `c` 对象中的 `VMT2` 指针字段。
- en: The problem occurs when the program attempts to call the `setJ()` method. Because
    `setJ()` belongs to class `b`, it expects `this` to hold the address of a VMT
    pointer pointing at a VMT for class `b`. It also expects to find data field `j`
    at offset (`this+8`). Were we to pass the `c` object’s `this` pointer to `setJ()`,
    accessing (`this+8`) would reference the `i` data field, not `j`. Furthermore,
    were a class `b` method to make a call to another method in class `b` (such as
    `setJ()` making a recursive call to itself), the VMT pointer would be wrong—it
    points at a VMT with a pointer to `setI()` at offset 0, whereas class `b` expects
    it to point at a VMT with a pointer to `setJ()` at offset 0\. To resolve this
    issue, a typical C++ compiler will insert an extra VMT pointer into the `c` object
    immediately prior to the `j` data field. It will initialize this second VMT field
    to point into the `c` VMT at the location where the class `b` method pointers
    begin (see [Figure 11-11](ch11.xhtml#ch11fig11)). When calling a method in class
    `b`, the compiler will emit code that initializes the `this` pointer with the
    address of this second VMT pointer (rather than pointing at the beginning of `c`-type
    object in memory). Now, upon entry to a class `b` method—such as `setJ()`—`this`
    will point at a legitimate VMT pointer for class `b`, and the `j` data field will
    appear at the offset (`this+8`) that class `b` methods expect.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 问题出现在程序尝试调用`setJ()`方法时。因为`setJ()`属于类`b`，它期望`this`指针指向一个VMT指针，该指针指向类`b`的VMT。它还期望在偏移量（`this+8`）处找到数据字段`j`。如果我们将`c`对象的`this`指针传递给`setJ()`，访问（`this+8`）将引用数据字段`i`，而不是`j`。此外，如果类`b`的方法调用了类`b`中的另一个方法（例如`setJ()`递归调用自身），那么VMT指针将不正确——它指向一个VMT，其中`setI()`的指针在偏移量0，而类`b`期望它指向一个VMT，其中`setJ()`的指针在偏移量0。为了解决这个问题，典型的C++编译器会在`c`对象中的`j`数据字段之前插入一个额外的VMT指针。它会初始化这个第二个VMT字段，指向`c`
    VMT中类`b`方法指针开始的位置（见[图11-11](ch11.xhtml#ch11fig11)）。当调用类`b`中的方法时，编译器会生成代码，用这个第二个VMT指针的地址初始化`this`指针（而不是指向内存中`c`类型对象的开头）。现在，当进入类`b`的方法——比如`setJ()`时——`this`将指向类`b`的一个合法VMT指针，而`j`数据字段将在偏移量（`this+8`）处出现，这是类`b`方法所期望的。
- en: '**11.6 Protocols and Interfaces**'
  id: totrans-282
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**11.6 协议和接口**'
- en: Java and Swift don’t support multiple inheritance, because it has some logical
    problems. The classic example is the “diamond lattice” data structure. This occurs
    when two classes (say, `b` and `c`) both inherit information from the same class
    (say, `a`), and then a fourth class (say, `d`) inherits from both `b` and `c`.
    As a result, `d` inherits the data from `a` twice—once through `b` and once through
    `c`. This can create some consistency problems.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: Java和Swift不支持多重继承，因为它存在一些逻辑问题。经典的例子是“钻石格”数据结构。这种情况发生在两个类（比如`b`和`c`）都从同一个类（比如`a`）继承信息，然后第四个类（比如`d`）从`b`和`c`继承。结果，`d`从`a`继承了两次数据——一次通过`b`，一次通过`c`。这可能会导致一些一致性问题。
- en: Although multiple inheritance can lead to some weird problems like this, there’s
    no question that being able to inherit from multiple locations is often useful.
    Thus, the solution in languages like Java and Swift is to allow a class to inherit
    methods/functions from multiple parents but allow inheritance from only a single
    ancestor class. This avoids most of the problems with multiple inheritance (specifically,
    an ambiguous choice of inherited data fields) while allowing programmers to include
    methods from various sources. Java calls such extensions *interfaces*, and Swift
    calls them *protocols*.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管多重继承可能会导致像这样的一些奇怪问题，但毫无疑问，从多个位置继承通常是非常有用的。因此，像Java和Swift这样的语言的解决方案是允许类从多个父类继承方法/函数，但只允许从一个祖先类继承。这避免了大多数多重继承的问题（特别是继承数据字段的模糊选择），同时允许程序员从不同来源包含方法。Java称这种扩展为*接口*，而Swift称之为*协议*。
- en: 'Here’s an example of a couple Swift protocol declarations and a class supporting
    that protocol:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是几个Swift协议声明的示例，以及一个支持该协议的类：
- en: '[PRE57]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: Swift protocols don’t supply any functions. Instead, a class that supports a
    protocol promises to provide an implementation of the functions the protocol(s)
    specify. In the preceding example, the `supportsProtocols` class is responsible
    for supplying all functions required by the protocols it supports. Effectively,
    protocols are like abstract classes containing only abstract methods—the inheriting
    class must provide actual implementations for all the abstract methods.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: Swift协议不提供任何函数。相反，一个支持协议的类承诺提供协议中指定的函数的实现。在前面的示例中，`supportsProtocols`类负责提供它所支持的协议所要求的所有函数。实际上，协议就像只包含抽象方法的抽象类——继承的类必须为所有抽象方法提供实际的实现。
- en: 'Here’s the previous example coded in Java and demonstrating its comparable
    mechanism, the interface:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是前面的示例，用Java编写并演示其相应机制，即接口：
- en: '[PRE58]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'Interfaces/protocols behave somewhat like base class types in Java and Swift.
    If you instantiate a class object and assign that instance to a variable that
    is an interface/protocol type, you can execute the supported member functions
    for that interface/protocol. Consider the following Java example:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 接口/协议在行为上有点类似于Java和Swift中的基类类型。如果你实例化一个类对象并将该实例赋值给一个接口/协议类型的变量，那么你可以执行该接口/协议所支持的成员函数。考虑以下Java示例：
- en: '[PRE59]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'Here’s a comparable example in Swift:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一个Swift中的相似示例：
- en: '[PRE60]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'The implementation of a protocol or interface is quite simple—it’s just a pointer
    to a VMT that contains the addresses of the functions declared in that protocol/interface.
    So, the data structure for the Swift `g` class in the previous example would have
    three VMT pointers in it: one for protocol `a`, one for protocol `d`, and one
    for the class `g` (holding a pointer to the `local()` function). [Figure 11-12](ch11.xhtml#ch11fig12)
    shows the class and VMT layout.'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 协议或接口的实现非常简单——它只是一个指向VMT的指针，VMT包含在该协议/接口中声明的函数地址。因此，前面示例中Swift `g`类的数据结构将包含三个VMT指针：一个指向协议`a`，一个指向协议`d`，一个指向类`g`（其中包含指向`local()`函数的指针）。[图
    11-12](ch11.xhtml#ch11fig12)显示了类和VMT布局。
- en: '![Image](../images/11fig12.jpg)'
  id: totrans-295
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/11fig12.jpg)'
- en: '*Figure 11-12: Multiple inheritance memory layout*'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 11-12：多重继承内存布局*'
- en: In [Figure 11-12](ch11.xhtml#ch11fig12) the VMT pointer for class `g` contains
    the address of the entire VMT. There are two entries in the class that contain
    pointers to the VMTs for protocol `a` and protocol `d`. As the VMT for class `g`
    also contains pointers to the functions belonging to these protocols, there’s
    no need to create a separate VMT for these two protocols; instead, the `aPtr`
    and `dPtr` fields can point to the corresponding entries within class `g`’s VMT.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 在[图 11-12](ch11.xhtml#ch11fig12)中，类`g`的VMT指针包含整个VMT的地址。该类中有两个条目，分别包含指向协议`a`和协议`d`的VMT的指针。由于类`g`的VMT也包含指向这些协议所属函数的指针，因此无需为这两个协议单独创建VMT；相反，`aPtr`和`dPtr`字段可以指向类`g`的VMT中的相应条目。
- en: When the assignment `var x:a = g()` occurs in the previous example, the Swift
    code will load variable `x` with the `aPtr` pointer held in the `g` object. Therefore,
    the calls to `x.b()` and `x.c()` work just like a normal method call—the system
    uses the pointer held in `x` to reference the VMT and then it calls `b` or `c`
    by indexing the appropriate amount into the VMT. Had `x` been of type `d` rather
    than `a`, then the assignment `var x:d = g()` would have loaded `x` with the address
    of the `d` protocol VMT (pointed at by `dPtr`). Calls to `d` and `e` would happen
    at offsets 0 and 8 (64-bit pointers) into the `d` VMT.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 当在前面的示例中发生赋值`var x:a = g()`时，Swift代码会用`g`对象中持有的`aPtr`指针加载变量`x`。因此，对`x.b()`和`x.c()`的调用就像正常的函数调用一样——系统使用`x`中持有的指针引用VMT，然后通过索引适当的位置来调用`b`或`c`。如果`x`的类型是`d`而不是`a`，那么赋值`var
    x:d = g()`将会加载`x`为`d`协议VMT的地址（由`dPtr`指向）。对`d`和`e`的调用将发生在`d` VMT的偏移量0和8（64位指针）处。
- en: '**11.7 Classes, Objects, and Performance**'
  id: totrans-299
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**11.7 类、对象和性能**'
- en: As you’ve seen in this chapter, the direct cost associated with object-oriented
    programming isn’t terribly significant. Calls to member functions (methods) are
    a bit more expensive because of double indirection; however, that’s a small price
    to pay for the flexibility OOP gives you. The extra instructions and memory accesses
    will probably cost only about 10 percent of your application’s total performance.
    Some languages, such as C++ and HLA, support the notion of a *static member function*
    that allows direct calls to member functions when polymorphism is unnecessary.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你在本章中看到的，与面向对象编程相关的直接成本并不特别显著。调用成员函数（方法）因为有双重间接引用，会稍微贵一些；然而，对于OOP所带来的灵活性来说，这只是一个小代价。额外的指令和内存访问大约只会占应用程序总性能的10%左右。一些语言，例如C++和HLA，支持*静态成员函数*的概念，当多态性不必要时，允许直接调用成员函数。
- en: The big problem that object-oriented programmers sometimes face is taking things
    to an extreme. Rather than directly accessing the fields of an object, they write
    accessor functions to read and write those field values. Unless the compiler does
    a very good job of inlining such accessor functions, the cost of accessing the
    object’s fields increases by about an order of magnitude. In other words, application
    performance can actually suffer when OOP paradigms are overused. There may be
    good reasons for doing things the “object-oriented way” (such as using accessor
    functions to access all fields of an object), but keep in mind that these costs
    add up rather quickly. Unless you absolutely need the facilities provided by OOP
    techniques, your programs may wind up running considerably slower (and taking
    up a whole lot more space) than necessary.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 面向对象程序员有时面临的一个大问题是过度应用面向对象原则。与其直接访问对象的字段，他们编写访问器函数来读取和写入这些字段值。除非编译器非常出色地内联这些访问器函数，否则访问对象字段的成本大约会增加一个数量级。换句话说，当过度使用OOP范式时，应用程序的性能可能会受到影响。采用“面向对象方式”做事（比如使用访问器函数访问对象的所有字段）可能有合理的原因，但要记住，这些成本会迅速累积。除非你绝对需要OOP技术提供的功能，否则你的程序可能会比必要时运行得更慢（并占用更多空间）。
- en: Swift is a good example of object-oriented programming taken to an extreme.
    Anyone who has compared the performance of compiled Swift code against an equivalent
    C++ program knows that Swift is much slower. Largely, this is because Swift makes
    objects out of everything (and constantly checks their types and bounds at runtime).
    The result is that it can take hundreds of machine instructions in Swift to do
    the same task as a half-dozen machine instructions produced by an optimizing C++
    compiler.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: Swift 是面向对象编程极致应用的一个很好的例子。任何将编译后的Swift代码与等效的C++程序性能进行比较的人都知道，Swift要慢得多。主要原因是Swift将一切都视作对象（并在运行时不断检查它们的类型和边界）。结果是，在Swift中执行同一任务可能需要数百条机器指令，而优化后的C++编译器只需要半打机器指令。
- en: Another common problem with many object-oriented programs is overgeneralization.
    This can occur when a programmer uses a lot of class libraries, extending classes
    through inheritance in order to solve some problem with as little programming
    effort as possible. While saving programming effort is generally a good idea,
    extending class libraries can lead to situations where you need some minor task
    done and you call a library routine that does everything you want. The problem
    is that in object-oriented systems, library routines tend to be highly layered.
    That is, you need some work done, so you invoke some member function from a class
    you’ve inherited. That function probably does a little bit of work on the data
    you pass it and then it calls a member function in a class that it inherits. And
    then that function massages the data a bit and calls a member function it inherits,
    and so on down the line. Before too long, the CPU spends more time calling and
    returning from functions than it does doing any useful work. While this same situation
    could occur in standard (non-OOP) libraries, it’s far more common in object-oriented
    applications.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 许多面向对象程序的另一个常见问题是过度泛化。这种情况发生在程序员使用大量类库，通过继承扩展类以尽量减少编程工作量时。虽然节省编程工作通常是个好主意，但扩展类库可能会导致你需要完成一个小任务时，却调用了一个执行所有功能的库例程。问题在于，在面向对象系统中，库例程往往是高度层次化的。也就是说，你需要完成一些工作时，就调用你继承的某个类中的成员函数。该函数可能会对你传递的数据做一些处理，然后调用它继承的类中的成员函数。接着该函数再对数据进行一些处理，然后调用它继承的成员函数，以此类推。没过多久，CPU花在调用和返回函数上的时间比实际做有用工作的时间还要多。虽然在标准（非面向对象）库中也可能发生这种情况，但在面向对象应用中，这种情况更加常见。
- en: Carefully designed object-oriented programs needn’t run significantly slower
    than comparable procedural programs. Just be careful not to make a lot of expensive
    function calls to do trivial tasks.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 精心设计的面向对象程序的运行速度不必比同等的过程式程序显著慢。只需小心不要为了做一些琐碎的任务而调用过多的昂贵函数。
- en: '**11.8 For More Information**'
  id: totrans-305
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**11.8 了解更多信息**'
- en: 'Dershem, Herbert, and Michael Jipping. *Programming Languages, Structures and
    Models*. Belmont, CA: Wadsworth, 1990.'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 'Dershem, Herbert 和 Michael Jipping. *程序设计语言，结构与模型*. 加利福尼亚州贝尔蒙特: Wadsworth出版社,
    1990年。'
- en: 'Duntemann, Jeff. *Assembly Language Step-by-Step*. 3rd ed. Indianapolis: Wiley,
    2009.'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 'Duntemann, Jeff. *汇编语言一步步学习*. 第3版. 印第安纳波利斯: Wiley出版社, 2009年。'
- en: 'Ghezzi, Carlo, and Jehdi Jazayeri. *Programming Language Concepts*. 3rd ed.
    New York: Wiley, 2008.'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 'Ghezzi, Carlo 和 Jehdi Jazayeri. *程序设计语言的概念*. 第3版. 纽约: Wiley出版社, 2008年。'
- en: 'Hyde, Randall. *The Art of Assembly Language*. 2nd ed. San Francisco: No Starch
    Press, 2010.'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 'Hyde, Randall. *汇编语言的艺术*. 第2版. 旧金山: No Starch Press出版社, 2010年。'
- en: 'Knuth, Donald. *The Art of Computer Programming, Volume I: Fundamental Algorithms.*
    3rd ed. Boston: Addison-Wesley Professional, 1997.'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 'Knuth, Donald. *计算机程序设计的艺术，第一卷：基本算法*. 第3版. 波士顿: Addison-Wesley Professional出版社,
    1997年。'
- en: 'Ledgard, Henry, and Michael Marcotty. *The Programming Language Landscape*.
    Chicago: SRA, 1986.'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 'Ledgard, Henry 和 Michael Marcotty. *编程语言的全景*. 芝加哥: SRA出版社, 1986年。'
- en: 'Louden, Kenneth C., and Kenneth A. Lambert. *Programming Languages, Principles
    and Practice*. 3rd ed. Boston: Course Technology, 2012.'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 'Louden, Kenneth C. 和 Kenneth A. Lambert. *程序设计语言，原理与实践*. 第3版. 波士顿: Course Technology出版社,
    2012年。'
- en: 'Pratt, Terrence W., and Marvin V. Zelkowitz. *Programming Languages, Design
    and Implementation*. 4th ed. Upper Saddle River, NJ: Prentice Hall, 2001.'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 'Pratt, Terrence W. 和 Marvin V. Zelkowitz. *程序设计语言，设计与实现*. 第4版. 新泽西州上萨德尔河: 普伦蒂斯霍尔出版社,
    2001年。'
- en: 'Sebesta, Robert. *Concepts of Programming Languages*. 11th ed. Boston: Pearson,
    2016.'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 'Sebesta, Robert. *程序设计语言的概念*. 第11版. 波士顿: Pearson出版社, 2016年。'
