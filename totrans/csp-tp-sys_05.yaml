- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">5</samp> <samp class="SANS_Dogma_OT_Bold_B_11">TYPES
    OF EQUALITY</samp>
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">5</samp> <samp class="SANS_Dogma_OT_Bold_B_11">相等性类型</samp>
- en: '![](../images/opener-img.png)'
  id: totrans-1
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/opener-img.png)'
- en: Programs frequently compare variables to see if their values are equal, although
    this operation is often overlooked because it’s done implicitly. Every type inherits
    the <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp> method from the
    <samp class="SANS_TheSansMonoCd_W5Regular_11">object</samp> base class, so given
    any two values <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp> and <samp
    class="SANS_TheSansMonoCd_W5Regular_11">y</samp>, the expression <samp class="SANS_TheSansMonoCd_W5Regular_11">x.Equals(y)</samp>
    is always valid.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 程序经常比较变量以查看它们的值是否相等，尽管这种操作通常被忽视，因为它是隐式完成的。每个类型都会从 <samp class="SANS_TheSansMonoCd_W5Regular_11">object</samp>
    基类继承 <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp> 方法，因此，给定任意两个值
    <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp> 和 <samp class="SANS_TheSansMonoCd_W5Regular_11">y</samp>，表达式
    <samp class="SANS_TheSansMonoCd_W5Regular_11">x.Equals(y)</samp> 始终有效。
- en: C# also provides <samp class="SANS_TheSansMonoCd_W5Regular_11">==</samp>, or
    the *equals-equals* operator, for explicitly checking equality of two values.
    Using <samp class="SANS_TheSansMonoCd_W5Regular_11">==</samp> for comparisons
    differs from using the <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp>
    method in multiple ways. In this chapter, we’ll look at why C# supports two techniques
    for equality comparison and how each is affected by the differences between types.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: C# 还提供了 <samp class="SANS_TheSansMonoCd_W5Regular_11">==</samp>，或者称为 *等号运算符*，用于显式检查两个值是否相等。使用
    <samp class="SANS_TheSansMonoCd_W5Regular_11">==</samp> 进行比较与使用 <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp>
    方法在多个方面不同。在本章中，我们将探讨为什么 C# 支持两种相等性比较技巧，以及每种方法如何受到类型差异的影响。
- en: 'We’ll explore the following:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将探讨以下内容：
- en: How the differences between comparisons using the <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp>
    method versus <samp class="SANS_TheSansMonoCd_W5Regular_11">==</samp> affect our
    programs
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp>方法与 <samp class="SANS_TheSansMonoCd_W5Regular_11">==</samp>
    运算符在比较中的差异如何影响我们的程序
- en: What support the compiler provides for comparisons, and what we must provide
    ourselves
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编译器为比较提供了哪些支持，我们自己需要提供什么
- en: Why equality comparisons and hash codes are so closely related
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为什么相等性比较与哈希码如此紧密相关
- en: When we need to customize equality comparisons for our own types
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当我们需要为自定义类型定制相等性比较时
- en: How a variable’s type affects equality behavior
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 变量的类型如何影响相等性行为
- en: We’ll take a forensic approach to see how the compiler treats equality for different
    types and explore why there’s more to the topic of equality than just <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">==</samp>. Having more than
    one way to compare values underscores just how important this most basic comparison
    is. First, let’s look at how equality works for the built-in types.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将采用法医学的方法，看看编译器如何处理不同类型的相等性，并探讨为什么相等性话题远不止 <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp>
    和 <samp class="SANS_TheSansMonoCd_W5Regular_11">==</samp>。拥有不止一种比较值的方式，凸显了这种最基本的比较有多么重要。首先，让我们看看内置类型的相等性是如何工作的。
- en: <samp class="SANS_Futura_Std_Bold_B_11">Built-in Equality</samp>
  id: totrans-11
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">内置相等性</samp>
- en: In this section, we’ll look at the basics of equality comparisons between C#’s
    built-in types—including integers and floating-point numbers, reference variables,
    and arrays—and how some built-in types override the default behavior of equality.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将查看 C# 内置类型之间的相等性比较基础知识——包括整数和浮动点数、引用变量以及数组——以及一些内置类型如何重写默认的相等性行为。
- en: <samp class="SANS_Dogma_OT_Bold_B_21">NOTE</samp>
  id: totrans-13
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: <samp class="SANS_Dogma_OT_Bold_B_21">注意</samp>
- en: '*The convention* equals-equals*, or* double-equals *as it’s sometimes known,
    is used by several languages to distinguish the comparison for equality from the
    assignment operator* <samp class="SANS_TheSansMonoCd_W5Regular_11">=</samp>*,
    which is just* equals*. JavaScript has a third variation,* equals-equals-equals*,
    to check that two variables have the same type* and *value.*'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '*惯例* 等号运算符*，或有时称为*双等号*，由多种语言使用，以区分相等性比较与赋值运算符 <samp class="SANS_TheSansMonoCd_W5Regular_11">=</samp>，后者只是*等号*。JavaScript
    有一个第三种变体，*等号等号等号*，用于检查两个变量是否具有相同的类型*和*值。 '
- en: Because every type in C# inherits the <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp>
    method from <samp class="SANS_TheSansMonoCd_W5Regular_11">object</samp>, we can
    compare any two variables with that method. However, using <samp class="SANS_TheSansMonoCd_W5Regular_11">==</samp>
    to compare variables of the built-in types is more efficient and may even result
    in different behavior than using <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp>,
    as you’ll soon see.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 因为C#中的每个类型都继承了<samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp>方法自<samp
    class="SANS_TheSansMonoCd_W5Regular_11">object</samp>类，我们可以用该方法比较任意两个变量。然而，使用<samp
    class="SANS_TheSansMonoCd_W5Regular_11">==</samp>来比较内建类型的变量效率更高，并且与使用<samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp>方法比较时可能会表现出不同的行为，正如你将很快看到的。
- en: Equality comparisons using <samp class="SANS_TheSansMonoCd_W5Regular_11">==</samp>
    are baked into the CLR for all the intrinsic types—that is, all the numeric types
    except <samp class="SANS_TheSansMonoCd_W5Regular_11">decimal</samp> (which has
    built-in compiler support but isn’t a native CLR type), the <samp class="SANS_TheSansMonoCd_W5Regular_11">char</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">bool</samp> types, and references.
    The CLR has a built-in instruction to compare two intrinsic values, so we can
    always compare those values with <samp class="SANS_TheSansMonoCd_W5Regular_11">==</samp>,
    and it’s as efficient as it could possibly be.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 使用<samp class="SANS_TheSansMonoCd_W5Regular_11">==</samp>进行相等比较是CLR为所有基本类型内建的——即，所有数字类型（除了<samp
    class="SANS_TheSansMonoCd_W5Regular_11">decimal</samp>，该类型有内建的编译器支持，但不是原生CLR类型）、<samp
    class="SANS_TheSansMonoCd_W5Regular_11">char</samp>和<samp class="SANS_TheSansMonoCd_W5Regular_11">bool</samp>类型，以及引用类型。CLR有一条内建指令用于比较两个基本类型的值，因此我们可以始终使用<samp
    class="SANS_TheSansMonoCd_W5Regular_11">==</samp>来比较这些值，而且效率是可能达到的最优。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Whole Numbers</samp>
  id: totrans-17
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">整数</samp>
- en: The built-in *integral* types—<samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">short</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">long</samp>,
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">byte</samp>—represent whole
    numbers, and the <samp class="SANS_TheSansMonoCd_W5Regular_11">char</samp> type
    represents UTF-16 characters. They all have the same behavior for the purposes
    of equality comparison. Values of <samp class="SANS_TheSansMonoCd_W5Regular_11">bool</samp>
    type, while not strictly speaking numeric values, are compared the same way too.
    [Listing 5-1](#list5-1) compares two integer values by using the <samp class="SANS_TheSansMonoCd_W5Regular_11">==</samp>
    operator.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 内建的*整数*类型——<samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>、<samp class="SANS_TheSansMonoCd_W5Regular_11">short</samp>、<samp
    class="SANS_TheSansMonoCd_W5Regular_11">long</samp>和<samp class="SANS_TheSansMonoCd_W5Regular_11">byte</samp>——表示整数，而<samp
    class="SANS_TheSansMonoCd_W5Regular_11">char</samp>类型表示UTF-16字符。它们在进行相等比较时表现相同。<samp
    class="SANS_TheSansMonoCd_W5Regular_11">bool</samp>类型的值，虽然严格来说不是数字值，但也按相同方式进行比较。[示例
    5-1](#list5-1)使用<samp class="SANS_TheSansMonoCd_W5Regular_11">==</samp>运算符比较两个整数值。
- en: '[PRE0]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 5-1: Built-in numeric
    comparison</samp>'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">示例 5-1: 内建的数字比较</samp>'
- en: 'Here, we copy the value of <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp>
    and assign it to <samp class="SANS_TheSansMonoCd_W5Regular_11">y</samp> so that
    the two variables have identical values. The result is that they compare equal.
    If we look at the CIL generated by the compiler, we see how these built-in types
    get special support at run time:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将<samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp>的值复制并赋给<samp class="SANS_TheSansMonoCd_W5Regular_11">y</samp>，使得这两个变量的值相同。结果是它们会被认为相等。如果我们查看编译器生成的CIL代码，就会看到这些内建类型在运行时如何得到特别的支持：
- en: '[PRE1]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: CIL instructions all follow a similar low-level format. Each line has a label
    in the format <samp class="SANS_TheSansMonoCd_W5Regular_11">L_</samp><samp class="SANS_TheSansMonoCd_W5Regular_11">0</samp><samp
    class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">XXX</samp>, followed by the instruction
    itself and any arguments it needs. The first instruction, <samp class="SANS_TheSansMonoCd_W5Regular_11">ldc.i4.s</samp>,
    pushes its argument, the value <samp class="SANS_TheSansMonoCd_W5Regular_11">10</samp>,
    onto the evaluation stack ❶. The next instruction, <samp class="SANS_TheSansMonoCd_W5Regular_11">stloc.0</samp>,
    has no arguments but pops the value at the top of the evaluation stack into the
    variable at location <samp class="SANS_TheSansMonoCd_W5Regular_11">0</samp>, which,
    as the decompiler helpfully tells us in a comment, is the <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp>
    variable. The outcome of these first two lines is that the <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp>
    variable is assigned the value <samp class="SANS_TheSansMonoCd_W5Regular_11">10</samp>.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 所有CIL指令都遵循类似的低级格式。每行都有一个格式为<samp class="SANS_TheSansMonoCd_W5Regular_11">L_</samp><samp
    class="SANS_TheSansMonoCd_W5Regular_11">0</samp><samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">XXX</samp>的标签，后跟指令本身及其所需的任何参数。第一条指令<samp
    class="SANS_TheSansMonoCd_W5Regular_11">ldc.i4.s</samp>将其参数值<samp class="SANS_TheSansMonoCd_W5Regular_11">10</samp>推送到评估栈
    ❶。接下来的指令<samp class="SANS_TheSansMonoCd_W5Regular_11">stloc.0</samp>没有参数，但会将评估栈顶部的值弹出，并存储到位置<samp
    class="SANS_TheSansMonoCd_W5Regular_11">0</samp>的变量中，正如反编译器在注释中帮助我们指出的那样，该位置对应的是<samp
    class="SANS_TheSansMonoCd_W5Regular_11">x</samp>变量。这两行的结果是将值<samp class="SANS_TheSansMonoCd_W5Regular_11">10</samp>赋给了<samp
    class="SANS_TheSansMonoCd_W5Regular_11">x</samp>变量。
- en: Next, the previously stored value of <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp>
    is loaded and then stored in <samp class="SANS_TheSansMonoCd_W5Regular_11">y</samp>
    ❷. Then, the values of both <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">y</samp> are pushed back onto
    the evaluation stack so they can be interpreted by the next instruction ❸. Lastly,
    the built-in instruction <samp class="SANS_TheSansMonoCd_W5Regular_11">ceq</samp>
    compares the two values on the top of the evaluation stack for equality ❹. The
    <samp class="SANS_TheSansMonoCd_W5Regular_11">ceq</samp> instruction corresponds
    directly with the <samp class="SANS_TheSansMonoCd_W5Regular_11">==</samp> comparison
    between two built-in values.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，先前存储的值<samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp>被加载，并存储到<samp
    class="SANS_TheSansMonoCd_W5Regular_11">y</samp>中 ❷。然后，<samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp>和<samp
    class="SANS_TheSansMonoCd_W5Regular_11">y</samp>的值被推回到评估栈中，以便下一条指令进行解释 ❸。最后，内置指令<samp
    class="SANS_TheSansMonoCd_W5Regular_11">ceq</samp>对评估栈顶部的两个值进行相等性比较 ❹。<samp class="SANS_TheSansMonoCd_W5Regular_11">ceq</samp>指令直接对应于两个内置值之间的<samp
    class="SANS_TheSansMonoCd_W5Regular_11">==</samp>比较。
- en: The way the comparison using <samp class="SANS_TheSansMonoCd_W5Regular_11">ceq</samp>
    is performed is up to the JIT compiler, which translates CIL to machine code at
    run time, but we can think of it as a bitwise comparison between two numeric values.
    If they compare equal, the integer <samp class="SANS_TheSansMonoCd_W5Regular_11">1</samp>,
    interpreted as the Boolean value <samp class="SANS_TheSansMonoCd_W5Regular_11">true</samp>,
    is pushed onto the evaluation stack; otherwise, a <samp class="SANS_TheSansMonoCd_W5Regular_11">0</samp>
    is pushed and interpreted as <samp class="SANS_TheSansMonoCd_W5Regular_11">false</samp>.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 使用<samp class="SANS_TheSansMonoCd_W5Regular_11">ceq</samp>进行比较的方式取决于JIT编译器，JIT编译器在运行时将CIL翻译为机器码，但我们可以将其看作是对两个数值的逐位比较。如果它们相等，则整数<samp
    class="SANS_TheSansMonoCd_W5Regular_11">1</samp>（被解释为布尔值<samp class="SANS_TheSansMonoCd_W5Regular_11">true</samp>）被推送到评估栈中；否则，<samp
    class="SANS_TheSansMonoCd_W5Regular_11">0</samp>会被推送并解释为<samp class="SANS_TheSansMonoCd_W5Regular_11">false</samp>。
- en: The Boolean result is passed as the first argument to the <samp class="SANS_TheSansMonoCd_W5Regular_11">Assert.That</samp>
    method (not shown in the CIL listing). The test passes because <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">y</samp> have the same numeric
    value.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 布尔结果作为第一个参数传递给<samp class="SANS_TheSansMonoCd_W5Regular_11">Assert.That</samp>方法（在CIL列表中未显示）。测试通过，因为<samp
    class="SANS_TheSansMonoCd_W5Regular_11">x</samp>和<samp class="SANS_TheSansMonoCd_W5Regular_11">y</samp>具有相同的数值。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Floating-Point Values</samp>
  id: totrans-27
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">浮点值</samp>
- en: The same <samp class="SANS_TheSansMonoCd_W5Regular_11">ceq</samp> instruction
    is used when we compare <samp class="SANS_TheSansMonoCd_W5Regular_11">float</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp> values with the
    <samp class="SANS_TheSansMonoCd_W5Regular_11">==</samp> operator. However, for
    floating-point numbers, this method of comparison doesn’t necessarily behave as
    we might expect. In C#, <samp class="SANS_TheSansMonoCd_W5Regular_11">float</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp> values are represented
    in a binary format defined by the Standard for Floating-Point Arithmetic published
    by the Institute of Electrical and Electronics Engineers (IEEE). The IEEE-754
    standard specifies a fixed precision for those types, with the result that many
    numbers can’t be represented exactly.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们使用`==`运算符比较<samp class="SANS_TheSansMonoCd_W5Regular_11">float</samp>和<samp
    class="SANS_TheSansMonoCd_W5Regular_11">double</samp>值时，会使用相同的<samp class="SANS_TheSansMonoCd_W5Regular_11">ceq</samp>指令。然而，对于浮点数，这种比较方法并不一定像我们预期的那样工作。在C#中，<samp
    class="SANS_TheSansMonoCd_W5Regular_11">float</samp>和<samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp>值是以由电气和电子工程师协会（IEEE）发布的浮点数算术标准定义的二进制格式表示的。IEEE-754标准为这些类型规定了固定精度，导致许多数字无法精确表示。
- en: When a number has no exact representation, it’s rounded to the nearest number
    that can be exactly represented. The next nearest representable number may be
    relatively larger or smaller than the original value. The difference between two
    neighboring exact representations is proportional to the magnitude of those numbers,
    so the rounding difference of a very large number will generally be much greater
    than that for a very small number. Calculations with multiple numbers that have
    been rounded will compound the resulting rounding error, a problem that isn’t
    restricted to either very large or very small numbers. [Listing 5-2](#list5-2)
    compares two <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp> values
    that we might intuitively expect to be equal.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个数字无法精确表示时，它会被四舍五入为最接近的可表示数字。下一个最接近的可表示数字可能比原始值大或小。两个相邻的精确表示之间的差异与这些数字的大小成比例，因此一个非常大的数字的舍入差异通常会远大于一个非常小的数字的舍入差异。多个经过舍入的数字进行计算时，舍入误差会积累，这个问题并不仅限于非常大或非常小的数字。[列表
    5-2](#list5-2)比较了我们直觉上可能认为相等的两个<samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp>值。
- en: '[PRE2]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 5-2: A simple floating-point
    calculation</samp>'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">列表 5-2：一个简单的浮点计算</samp>
- en: This test fails because none of the constant values can be represented exactly
    in the format of a <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp>.
    The values given to <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp> and
    <samp class="SANS_TheSansMonoCd_W5Regular_11">y</samp> will be rounded to the
    nearest representable value. On top of that, the result of the addition has an
    inexact representation and so is rounded again, producing a value that differs
    from the value assigned to <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp>.
    The test for equality between <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">y</samp> fails because the values
    differ in their least significant digits.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 该测试失败，因为常量值在<samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp>格式中无法精确表示。赋给<samp
    class="SANS_TheSansMonoCd_W5Regular_11">x</samp>和<samp class="SANS_TheSansMonoCd_W5Regular_11">y</samp>的值会被四舍五入为最接近的可表示值。更进一步，加法的结果是一个不精确的表示，因此又会被四舍五入，产生一个与赋给<samp
    class="SANS_TheSansMonoCd_W5Regular_11">x</samp>的值不同的结果。对<samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp>和<samp
    class="SANS_TheSansMonoCd_W5Regular_11">y</samp>的相等性测试失败，因为它们的最不重要数字存在差异。
- en: 'Subtracting one floating-point number from another can also produce unexpected
    results: if the two numbers are nearly equal, the result will have values only
    in those least significant places, which is exactly where rounding will be noticeable.
    The consequence is that some or all of the significant digits in the result may
    be lost, a problem sometimes called *cancellation*.'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 从一个浮点数中减去另一个浮点数也可能会产生意外结果：如果两个数字几乎相等，结果将只在那些最不重要的位置上有值，而这些位置正是舍入误差会明显表现出来的地方。结果是，结果中的一些或所有有效数字可能会丢失，这个问题有时称为*取消*。
- en: Rounding and cancellation issues are inherent in the IEEE-754 representation
    of floating-point values and not specific to C#. It’s possible to alleviate some
    of the problems that arise from them, however, depending on exactly what we want
    to achieve.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 四舍五入和取消问题是IEEE-754浮点值表示法的固有问题，并非C#特有。然而，根据我们想要达到的具体目标，还是有可能缓解其中一些问题。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Mitigating the Limitations
    of Rounding and Cancellation</samp>
  id: totrans-35
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">缓解四舍五入和取消的限制</samp>
- en: The magnitude of rounding is predictable, as it’s directly related to the precision
    of the binary representation. *Precision* here means the number of binary digits
    that can be stored in the type. Importantly, that means any number without an
    exact representation in a given type will always round the same way for the same
    type.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 四舍五入的幅度是可以预测的，因为它与二进制表示的精度直接相关。这里的*精度*指的是类型中可以存储的二进制位数。重要的是，这意味着任何在给定类型中没有精确表示的数字，对于相同类型，总是会以相同的方式进行四舍五入。
- en: The compounded error caused by repeated calculations is harder to predict, and
    the order of operations in a calculation can significantly affect the result.
    Performing the same sequence of operations twice might even produce different
    results, depending on factors such as optimization and the location of the result
    being stored. A complete analysis of the different approaches to comparing floating-point
    numbers is far too large a topic to cover here, but in essence, rather than comparing
    floating-point numbers for exact equality, we can provide an implementation that
    determines whether two numbers are approximately equal.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 重复计算所引起的累积误差更难预测，计算中的运算顺序会显著影响结果。相同的操作顺序执行两次，可能会产生不同的结果，这取决于优化和结果存储位置等因素。全面分析不同的浮点数比较方法是一个非常庞大的话题，在这里无法完全展开，但本质上，我们可以提供一种实现方法，而不是直接比较浮点数是否完全相等，而是判断两个数是否大致相等。
- en: One approach is to compare whether two numbers are equal within a certain number
    of decimal places, as shown in [Listing 5-3](#list5-3).
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 一种方法是比较两个数是否在某个小数位数内相等，如[清单5-3](#list5-3)所示。
- en: '[PRE3]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 5-3: A simple approximate
    comparison of floating-point numbers</samp>'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">清单5-3：浮点数的简单近似比较</samp>
- en: We use the <samp class="SANS_TheSansMonoCd_W5Regular_11">Math.Round</samp> method
    to determine whether two values are equal within an absolute number of decimal
    places—seven digits, in this example. We might also consider passing the number
    of required decimal places as a parameter rather than relying on a hard-coded
    constant. Either way, this is a quick and simple method for comparing floating-point
    values. The disadvantage is that it’s insensitive to differences smaller than
    the number of decimal places we’ve specified and inaccurate when comparing very
    large numbers.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用<samp class="SANS_TheSansMonoCd_W5Regular_11">Math.Round</samp>方法来判断两个值是否在指定的小数位数范围内相等——例如七位数字。我们也可以考虑将所需的小数位数作为参数传递，而不是依赖硬编码的常量。无论哪种方式，这都是比较浮点值的快速简便方法。缺点是它对小于我们指定的小数位数的差异不敏感，并且在比较非常大的数字时不准确。
- en: 'A second approach is to find out whether the difference between two numbers
    is smaller than a certain tolerance, like this:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 第二种方法是确定两个数的差值是否小于某个公差，例如：
- en: '[PRE4]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: This <samp class="SANS_TheSansMonoCd_W5Regular_11">ApproximatelyEqual</samp>
    method returns <samp class="SANS_TheSansMonoCd_W5Regular_11">true</samp> if the
    absolute difference between two floating-point numbers is smaller than a predefined
    tolerance, but we need to define a sensible value for the <samp class="SANS_TheSansMonoCd_W5Regular_11">Tolerance</samp>.
    Doing so isn’t straightforward, because the difference between two floating-point
    values can vary according to their magnitude. [Listing 5-4](#list5-4) uses a value
    for tolerance that is weighted according to the magnitude of the smaller of the
    numbers being compared.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 这个<samp class="SANS_TheSansMonoCd_W5Regular_11">ApproximatelyEqual</samp>方法会在两个浮点数的绝对差值小于预定义的公差时返回<samp
    class="SANS_TheSansMonoCd_W5Regular_11">true</samp>，但我们需要为<samp class="SANS_TheSansMonoCd_W5Regular_11">Tolerance</samp>定义一个合理的值。这样做并不简单，因为两个浮点值之间的差异可能会根据它们的大小而有所不同。[清单5-4](#list5-4)使用了一个根据比较的较小数值大小加权的公差值。
- en: '[PRE5]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 5-4: Approximate comparison
    using a weighted tolerance</samp>'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">清单5-4：使用加权容差进行近似比较</samp>
- en: We’ve added a <samp class="SANS_TheSansMonoCd_W5Regular_11">Tolerance</samp>
    constant to represent how sensitive we want our comparison to be, although we
    don’t use its unqualified value in the comparison. The rounding error for very
    large values has a far greater magnitude than the error for very small numbers,
    and our tolerance needs to be sensitive to that. Instead, we scale the tolerance
    according to the numbers being compared. We use the smaller of the two values
    for scaling because that’s probably where we’re most sensitive to the rounding
    error. As a compromise to avoid multiplying by 0, if the smallest value is smaller
    than <samp class="SANS_TheSansMonoCd_W5Regular_11">Tolerance</samp>, we scale
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Tolerance</samp> by itself, which
    might cost us some precision in comparing tiny values.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 我们添加了一个<Tolerance>常量，用来表示我们希望比较的敏感度，尽管我们并未在比较中使用其未经修正的值。对于非常大的值，四舍五入误差的幅度远大于非常小数值的误差，我们的容差需要对这一点敏感。相反，我们会根据被比较的数值来调整容差。我们使用两个值中较小的一个来进行缩放，因为那可能是我们最敏感的四舍五入误差位置。为了避免与0相乘作为折衷，如果最小值小于<Tolerance>，我们会将<Tolerance>按自身进行缩放，这可能会影响我们在比较小数值时的精度。
- en: The value chosen for <samp class="SANS_TheSansMonoCd_W5Regular_11">Tolerance</samp>
    here is sensitive enough to be able to distinguish differences within around 25
    decimal places when the values are close to 0\. When the values are closer to
    1.0, the scaling means that differences can be detected within 15 or 16 decimal
    places, and the sensitivity decreases as the size of the values increases. This
    approach to determining equality between floating-point numbers isn’t universally
    suitable, and specific applications may require a much more refined implementation.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 这里选择的<Tolerance>值足够敏感，当数值接近0时，可以区分大约25位小数的差异。当数值接近1.0时，由于缩放，差异可以在15或16位小数内被检测到，且随着数值的增大，灵敏度会减小。采用这种方法来判断浮点数之间的相等性并不适用于所有情况，特定的应用可能需要更加精细的实现。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Using Alternative Number Representations</samp>
  id: totrans-49
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">使用替代数值表示法</samp>
- en: We must always keep in mind that floating-point numbers aren’t real numbers
    in the mathematical sense, inasmuch as many real numbers can’t be expressed as
    a floating-point value. Real numbers have infinite precision, but computer memory
    is finite, so the fixed and limited precision of <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">float</samp> values is a compromise.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须始终记住，浮点数在数学意义上并不是真正的数，因为许多实数不能表示为浮点值。实数具有无限精度，但计算机内存是有限的，因此<samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp>和<samp
    class="SANS_TheSansMonoCd_W5Regular_11">float</samp>值的固定和有限精度是一种折衷。
- en: 'Whether the imprecision of floating-point values matters will depend on our
    objective. One alternative is to use a different representation, such as the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">decimal</samp> type that’s represented
    in *decimal* rather than binary and has a greater precision than a <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp>.
    In practice, a <samp class="SANS_TheSansMonoCd_W5Regular_11">decimal</samp> can
    represent more real numbers exactly, because it has a greater number of significant
    digits with which to represent them. This means <samp class="SANS_TheSansMonoCd_W5Regular_11">decimal</samp>
    values are less prone to rounding. However, each type has its own trade-offs,
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">decimal</samp> isn’t a general-purpose
    type: it’s intended for calculations that are most naturally represented in decimal,
    such as financial calculations. The representation of a <samp class="SANS_TheSansMonoCd_W5Regular_11">decimal</samp>
    has a smaller range than either <samp class="SANS_TheSansMonoCd_W5Regular_11">float</samp>
    or <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp>, so the largest
    positive and negative values are smaller than either <samp class="SANS_TheSansMonoCd_W5Regular_11">float</samp>
    or <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp> can represent.
    Another consideration is that a <samp class="SANS_TheSansMonoCd_W5Regular_11">decimal</samp>
    value requires more memory than a <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp>.'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 浮点数值的不精确性是否重要取决于我们的目标。一种替代方案是使用不同的表示方法，比如以 *十进制* 而非二进制表示的 <samp class="SANS_TheSansMonoCd_W5Regular_11">decimal</samp>
    类型，它的精度比 <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp> 更高。在实践中，<samp
    class="SANS_TheSansMonoCd_W5Regular_11">decimal</samp> 可以更准确地表示更多的实数，因为它具有更多的有效数字来表示这些数字。这意味着
    <samp class="SANS_TheSansMonoCd_W5Regular_11">decimal</samp> 值不太容易发生舍入误差。然而，每种类型都有其取舍，<samp
    class="SANS_TheSansMonoCd_W5Regular_11">decimal</samp> 并不是一个通用类型：它专门用于最自然地用十进制表示的计算，例如金融计算。<samp
    class="SANS_TheSansMonoCd_W5Regular_11">decimal</samp> 的表示范围比 <samp class="SANS_TheSansMonoCd_W5Regular_11">float</samp>
    或 <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp> 都要小，因此它能表示的最大正负值都比
    <samp class="SANS_TheSansMonoCd_W5Regular_11">float</samp> 或 <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp>
    所能表示的要小。另一个考虑因素是，<samp class="SANS_TheSansMonoCd_W5Regular_11">decimal</samp>
    值需要比 <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp> 更多的内存。
- en: As an example of the practical implications of choosing between <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">decimal</samp>, consider the
    trigonometry methods in the <samp class="SANS_TheSansMonoCd_W5Regular_11">Math</samp>
    class, such as <samp class="SANS_TheSansMonoCd_W5Regular_11">Sin</samp> and <samp
    class="SANS_TheSansMonoCd_W5Regular_11">Cos</samp>, which take <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp>
    as their parameter and don’t provide overloads taking <samp class="SANS_TheSansMonoCd_W5Regular_11">decimal</samp>
    values. If our code uses these methods, we can’t substitute <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp>
    for <samp class="SANS_TheSansMonoCd_W5Regular_11">decimal</samp>, because the
    <samp class="SANS_TheSansMonoCd_W5Regular_11">decimal</samp> type is specifically
    designed for monetary values and thus can’t represent the results of trigonometric
    operations.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 作为选择 <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp> 和 <samp class="SANS_TheSansMonoCd_W5Regular_11">decimal</samp>
    之间的实际应用示例，考虑一下 <samp class="SANS_TheSansMonoCd_W5Regular_11">Math</samp> 类中的三角函数方法，如
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Sin</samp> 和 <samp class="SANS_TheSansMonoCd_W5Regular_11">Cos</samp>，这些方法接受
    <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp> 类型作为参数，并且没有提供接收 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">decimal</samp> 类型值的重载。如果我们的代码使用了这些方法，我们不能将
    <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp> 替换为 <samp class="SANS_TheSansMonoCd_W5Regular_11">decimal</samp>，因为
    <samp class="SANS_TheSansMonoCd_W5Regular_11">decimal</samp> 类型是专门为货币值设计的，因此不能表示三角运算的结果。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Handling Invalid Numbers</samp>
  id: totrans-53
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">处理无效数字</samp>
- en: 'Another consequence of working with <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">float</samp> values is that
    some operations can produce a <samp class="SANS_TheSansMonoCd_W5Regular_11">NaN</samp>
    (not a number) result, which has *no* numerical representation. When we’re using
    <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp> or <samp class="SANS_TheSansMonoCd_W5Regular_11">float</samp>
    values, we need to make sure we correctly identify when the result of a calculation
    is <samp class="SANS_TheSansMonoCd_W5Regular_11">NaN</samp>, because <samp class="SANS_TheSansMonoCd_W5Regular_11">NaN</samp>
    is viral: any calculation involving <samp class="SANS_TheSansMonoCd_W5Regular_11">NaN</samp>
    produces <samp class="SANS_TheSansMonoCd_W5Regular_11">NaN</samp> as its result.
    We would get a <samp class="SANS_TheSansMonoCd_W5Regular_11">NaN</samp>, for example,
    if we tried to divide 0.0 by 0.0.'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp> 和 <samp class="SANS_TheSansMonoCd_W5Regular_11">float</samp>
    值的另一个后果是，某些操作可能会产生 <samp class="SANS_TheSansMonoCd_W5Regular_11">NaN</samp>（非数字）结果，它没有*数值表示*。当我们使用
    <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp> 或 <samp class="SANS_TheSansMonoCd_W5Regular_11">float</samp>
    值时，我们需要确保正确识别计算结果是否为 <samp class="SANS_TheSansMonoCd_W5Regular_11">NaN</samp>，因为
    <samp class="SANS_TheSansMonoCd_W5Regular_11">NaN</samp> 是传染性的：任何涉及 <samp class="SANS_TheSansMonoCd_W5Regular_11">NaN</samp>
    的计算都会产生 <samp class="SANS_TheSansMonoCd_W5Regular_11">NaN</samp> 作为其结果。例如，如果我们尝试将
    0.0 除以 0.0，我们会得到一个 <samp class="SANS_TheSansMonoCd_W5Regular_11">NaN</samp>。
- en: We might expect that we could identify a <samp class="SANS_TheSansMonoCd_W5Regular_11">NaN</samp>
    with a direct comparison using <samp class="SANS_TheSansMonoCd_W5Regular_11">==</samp>,
    as in [Listing 5-5](#list5-5).
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可能会期望通过使用 <samp class="SANS_TheSansMonoCd_W5Regular_11">==</samp> 直接比较来识别
    <samp class="SANS_TheSansMonoCd_W5Regular_11">NaN</samp>，如 [示例 5-5](#list5-5)
    中所示。
- en: '[PRE6]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 5-5: Comparing NaNs</samp>'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">示例 5-5：比较 NaN</samp>
- en: 'Dividing 0.0 by 0.0 certainly produces a <samp class="SANS_TheSansMonoCd_W5Regular_11">NaN</samp>,
    so many programmers would expect this equality test with <samp class="SANS_TheSansMonoCd_W5Regular_11">NaN</samp>
    to pass, but it doesn’t. The IEEE-754 standard states that two <samp class="SANS_TheSansMonoCd_W5Regular_11">NaN</samp>
    values don’t compare equal, so this test’s failure is correct behavior. Instead,
    C# provides the <samp class="SANS_TheSansMonoCd_W5Regular_11">IsNaN</samp> static
    method, which we use like this:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 将 0.0 除以 0.0 确实会产生 <samp class="SANS_TheSansMonoCd_W5Regular_11">NaN</samp>，因此许多程序员会期望这个与
    <samp class="SANS_TheSansMonoCd_W5Regular_11">NaN</samp> 的相等测试通过，但事实并非如此。IEEE-754
    标准规定，两个 <samp class="SANS_TheSansMonoCd_W5Regular_11">NaN</samp> 值不会比较相等，因此这个测试失败是正确的行为。相反，C#
    提供了 <samp class="SANS_TheSansMonoCd_W5Regular_11">IsNaN</samp> 静态方法，我们可以像这样使用它：
- en: '[PRE7]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'As of C# v8.0, we can use a constant pattern to make the comparison more naturally:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 从 C# v8.0 开始，我们可以使用常量模式使比较更加自然：
- en: '[PRE8]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The compiler translates the pattern expression into <samp class="SANS_TheSansMonoCd_W5Regular_11">double.IsNaN(x)</samp>,
    so there’s no comparison using either <samp class="SANS_TheSansMonoCd_W5Regular_11">==</samp>
    or <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp>. The <samp class="SANS_TheSansMonoCd_W5Regular_11">IsNaN</samp>
    method will always give us the correct result. It also highlights one important
    difference between comparing floating-point values with <samp class="SANS_TheSansMonoCd_W5Regular_11">==</samp>
    and using the <samp class="SANS_TheSansMonoCd_W5Regular_11">double.Equals</samp>
    method: the <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp> method
    compares floating-point values with <samp class="SANS_TheSansMonoCd_W5Regular_11">ceq</samp>,
    but, unlike the <samp class="SANS_TheSansMonoCd_W5Regular_11">==</samp> operator,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp> also calls <samp class="SANS_TheSansMonoCd_W5Regular_11">IsNaN</samp>
    when the values are *not* equal. Consider the following test, where we compare
    two <samp class="SANS_TheSansMonoCd_W5Regular_11">NaN</samp> values by using the
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp> method:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 编译器将模式表达式转换为 <samp class="SANS_TheSansMonoCd_W5Regular_11">double.IsNaN(x)</samp>，因此不会使用
    <samp class="SANS_TheSansMonoCd_W5Regular_11">==</samp> 或 <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp>
    进行比较。<samp class="SANS_TheSansMonoCd_W5Regular_11">IsNaN</samp> 方法将始终为我们提供正确的结果。它还突出了使用
    <samp class="SANS_TheSansMonoCd_W5Regular_11">==</samp> 比较浮动点数值与使用 <samp class="SANS_TheSansMonoCd_W5Regular_11">double.Equals</samp>
    方法之间的一个重要区别：<samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp> 方法通过 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">ceq</samp> 比较浮动点数值，但与 <samp class="SANS_TheSansMonoCd_W5Regular_11">==</samp>
    运算符不同，<samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp> 在数值“不相等”时还会调用
    <samp class="SANS_TheSansMonoCd_W5Regular_11">IsNaN</samp>。考虑以下测试，在这个测试中，我们使用
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp> 方法比较两个 <samp class="SANS_TheSansMonoCd_W5Regular_11">NaN</samp>
    值：
- en: '[PRE9]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: This test passes because, according to the <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp>
    method, <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp> and <samp
    class="SANS_TheSansMonoCd_W5Regular_11">float</samp> values compare equal when
    the values are exactly equal or are both <samp class="SANS_TheSansMonoCd_W5Regular_11">NaN</samp>.
    The result of <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp> for
    floating-point numbers may therefore differ from the result of using <samp class="SANS_TheSansMonoCd_W5Regular_11">==</samp>,
    which doesn’t compare the results of <samp class="SANS_TheSansMonoCd_W5Regular_11">IsNaN</samp>.
    Both <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">==</samp>
    ultimately make a strict comparison of <samp class="SANS_TheSansMonoCd_W5Regular_11">float</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp> values using <samp
    class="SANS_TheSansMonoCd_W5Regular_11">ceq</samp>, so we shouldn’t rely on using
    either approach to compare floating-point numbers, because the result might not
    be what we expect.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 该测试通过，因为根据 <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp> 方法，当数值完全相等或都为
    <samp class="SANS_TheSansMonoCd_W5Regular_11">NaN</samp> 时，<samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp>
    和 <samp class="SANS_TheSansMonoCd_W5Regular_11">float</samp> 值被认为是相等的。因此，对于浮动点数值，<samp
    class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp> 方法的结果可能与使用 <samp class="SANS_TheSansMonoCd_W5Regular_11">==</samp>
    的结果不同，因为后者不比较 <samp class="SANS_TheSansMonoCd_W5Regular_11">IsNaN</samp> 的结果。因此，<samp
    class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp> 和 <samp class="SANS_TheSansMonoCd_W5Regular_11">==</samp>
    最终都通过 <samp class="SANS_TheSansMonoCd_W5Regular_11">ceq</samp> 对 <samp class="SANS_TheSansMonoCd_W5Regular_11">float</samp>
    和 <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp> 值进行严格比较，因此我们不应依赖这两种方法来比较浮动点数值，因为结果可能与预期不符。
- en: <samp class="SANS_Dogma_OT_Bold_B_21">NOTE</samp>
  id: totrans-65
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: <samp class="SANS_Dogma_OT_Bold_B_21">注意</samp>
- en: '*Some calculations can result in positive or negative* infinity*, represented
    as double.PositiveInfinity and double.NegativeInfinity, respectively. While either
    value may be an incorrect result, infinite values aren’t usually considered* invalid
    *in the same way as NaN. We can compare a value with double.PositiveInfinity or
    double.NegativeInfinity in a constant pattern by using the is keyword, but values
    can also be directly compared using* <samp class="SANS_TheSansMonoCd_W5Regular_11">==</samp>
    *with either kind of infinity.*'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '*某些计算可能会导致正无穷或负无穷*，分别表示为 double.PositiveInfinity 和 double.NegativeInfinity。虽然这两种值可能是错误的结果，但无限值通常不像
    NaN 那样被认为是*无效的*。我们可以使用 is 关键字在常量模式下将一个值与 double.PositiveInfinity 或 double.NegativeInfinity
    进行比较，但也可以直接使用* <samp class="SANS_TheSansMonoCd_W5Regular_11">==</samp> *进行比较两种无限值。*'
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Reference Equality</samp>
  id: totrans-67
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">引用相等性</samp>
- en: As [Chapter 2](chapter2.xhtml) explained, a reference is either <samp class="SANS_TheSansMonoCd_W5Regular_11">null</samp>
    or an opaque handle to an object on the heap. An object can have several references
    to it, and two references to the same object compare equal. Every object instance
    has a unique identity, and the value of a non-<samp class="SANS_TheSansMonoCd_W5Regular_11">null</samp>
    reference is the identity of the object to which it refers. To tell whether two
    references refer to the same object or different instances, then, we use an identity
    comparison.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 如[第 2 章](chapter2.xhtml)所述，一个引用要么是 <samp class="SANS_TheSansMonoCd_W5Regular_11">null</samp>，要么是指向堆上对象的一个不透明句柄。一个对象可以有多个引用指向它，两个指向同一对象的引用是相等的。每个对象实例都有一个唯一的身份标识，非
    <samp class="SANS_TheSansMonoCd_W5Regular_11">null</samp> 引用的值是它所指向对象的身份标识。为了判断两个引用是否指向相同的对象或不同的实例，我们使用身份比较。
- en: We might also be interested in whether a reference is <samp class="SANS_TheSansMonoCd_W5Regular_11">null</samp>,
    so let’s look at the mechanics of comparing one reference with either another
    reference or the <samp class="SANS_TheSansMonoCd_W5Regular_11">null</samp> reference.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可能还会关心一个引用是否为 <samp class="SANS_TheSansMonoCd_W5Regular_11">null</samp>，因此让我们来看一下如何比较一个引用与另一个引用或
    <samp class="SANS_TheSansMonoCd_W5Regular_11">null</samp> 引用的机制。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Comparing Two References</samp>
  id: totrans-70
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">比较两个引用</samp>
- en: If <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">y</samp>
    are both references to the same object, they have the same identity and so compare
    equal via either <samp class="SANS_TheSansMonoCd_W5Regular_11">==</samp> or <samp
    class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp>. If they refer to different
    objects, even if those objects have the same state, <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">y</samp> won’t compare equal.
    In [Listing 5-6](#list5-6) we use <samp class="SANS_TheSansMonoCd_W5Regular_11">==</samp>
    to compare two reference variables.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp> 和 <samp class="SANS_TheSansMonoCd_W5Regular_11">y</samp>
    都是指向同一个对象的引用，它们具有相同的身份，因此可以通过 <samp class="SANS_TheSansMonoCd_W5Regular_11">==</samp>
    或 <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp> 进行比较。如果它们指向不同的对象，即使这些对象的状态相同，<samp
    class="SANS_TheSansMonoCd_W5Regular_11">x</samp> 和 <samp class="SANS_TheSansMonoCd_W5Regular_11">y</samp>
    也不会相等。在[示例 5-6](#list5-6)中，我们使用 <samp class="SANS_TheSansMonoCd_W5Regular_11">==</samp>
    来比较两个引用变量。
- en: '[PRE10]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 5-6: Comparing references</samp>'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">示例 5-6：比较引用</samp>
- en: 'These <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">y</samp>
    reference variables aren’t equal because they refer to different objects, even
    though both objects have the same state. Rather than assigning constant values
    to two variables as we did in [Listing 5-1](#list5-1), we’re creating new objects
    on the heap, and the variables are references to those objects. When we examine
    the generated CIL, on the last line we can see that the two references are compared
    for equality by using the same <samp class="SANS_TheSansMonoCd_W5Regular_11">ceq</samp>
    instruction as in [Listing 5-1](#list5-1):'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个 <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp> 和 <samp class="SANS_TheSansMonoCd_W5Regular_11">y</samp>
    引用变量不相等，因为它们指向的是不同的对象，尽管这两个对象的状态相同。与我们在[示例 5-1](#list5-1)中所做的为两个变量赋予常量值不同，我们现在是在堆上创建新对象，并且这些变量是指向这些对象的引用。当我们检查生成的
    CIL 代码时，可以看到在最后一行，我们使用与[示例 5-1](#list5-1)相同的 <samp class="SANS_TheSansMonoCd_W5Regular_11">ceq</samp>
    指令来比较这两个引用是否相等：
- en: '[PRE11]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">newobj</samp> instruction
    creates a new instance of a type and stores a reference to it on the evaluation
    stack. We create two instances of <samp class="SANS_TheSansMonoCd_W5Regular_11">MusicTrack</samp>
    on the heap, since <samp class="SANS_TheSansMonoCd_W5Regular_11">MusicTrack</samp>
    is a class, and store references to them in the <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">y</samp> variables, respectively.
    Since <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">y</samp>
    refer to different instances, the variables have different *values* and thus aren’t
    equal when compared using <samp class="SANS_TheSansMonoCd_W5Regular_11">ceq</samp>.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">newobj</samp>指令创建一个类型的新实例，并将其引用存储在评估栈上。我们在堆上创建了两个<samp
    class="SANS_TheSansMonoCd_W5Regular_11">MusicTrack</samp>实例，因为<samp class="SANS_TheSansMonoCd_W5Regular_11">MusicTrack</samp>是一个类，并将它们的引用分别存储在<samp
    class="SANS_TheSansMonoCd_W5Regular_11">x</samp>和<samp class="SANS_TheSansMonoCd_W5Regular_11">y</samp>变量中。由于<samp
    class="SANS_TheSansMonoCd_W5Regular_11">x</samp>和<samp class="SANS_TheSansMonoCd_W5Regular_11">y</samp>指向不同的实例，变量具有不同的*值*，因此在使用<samp
    class="SANS_TheSansMonoCd_W5Regular_11">ceq</samp>进行比较时不相等。
- en: As far as the <samp class="SANS_TheSansMonoCd_W5Regular_11">ceq</samp> instruction
    is concerned, at run time a reference is just a sequence of bits, in much the
    same way as a number is represented as a sequence of bits. The <samp class="SANS_TheSansMonoCd_W5Regular_11">ceq</samp>
    instruction merely compares two bit patterns to determine whether they match.
    Two references to different object instances on the heap have different bit patterns,
    so they don’t compare equal.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 就<samp class="SANS_TheSansMonoCd_W5Regular_11">ceq</samp>指令而言，在运行时，引用仅仅是一个比特序列，类似于数字是如何以比特序列表示的。<samp
    class="SANS_TheSansMonoCd_W5Regular_11">ceq</samp>指令仅仅是比较两个比特模式，以确定它们是否匹配。指向堆上不同对象实例的两个引用具有不同的比特模式，因此它们在比较时不相等。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Comparing with the null Reference</samp>
  id: totrans-78
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">与null引用进行比较</samp>
- en: The value of a reference variable is either a reference to an object on the
    heap or <samp class="SANS_TheSansMonoCd_W5Regular_11">null</samp>. We can use
    <samp class="SANS_TheSansMonoCd_W5Regular_11">==</samp> to compare any reference
    with <samp class="SANS_TheSansMonoCd_W5Regular_11">null</samp> to determine whether
    it refers to an object. If the reference refers to an object, as in [Listing 5-7](#list5-7),
    the reference isn’t equal to <samp class="SANS_TheSansMonoCd_W5Regular_11">null</samp>.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 引用变量的值要么是指向堆上对象的引用，要么是<samp class="SANS_TheSansMonoCd_W5Regular_11">null</samp>。我们可以使用<samp
    class="SANS_TheSansMonoCd_W5Regular_11">==</samp>来将任何引用与<samp class="SANS_TheSansMonoCd_W5Regular_11">null</samp>进行比较，以确定它是否指向一个对象。如果引用指向一个对象，如[示例
    5-7](#list5-7)所示，那么该引用与<samp class="SANS_TheSansMonoCd_W5Regular_11">null</samp>不相等。
- en: '[PRE12]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 5-7: Comparing a reference
    with null</samp>'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">示例 5-7：将引用与null进行比较</samp>
- en: 'This comparison also uses the built-in <samp class="SANS_TheSansMonoCd_W5Regular_11">ceq</samp>
    instruction:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 这个比较也使用了内置的<samp class="SANS_TheSansMonoCd_W5Regular_11">ceq</samp>指令：
- en: '[PRE13]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">null</samp> reference is a
    constant value pushed onto the evaluation stack by the <samp class="SANS_TheSansMonoCd_W5Regular_11">ldnull</samp>
    instruction; <samp class="SANS_TheSansMonoCd_W5Regular_11">null</samp> doesn’t
    have a type of its own but can be implicitly converted to *any* reference type.
    When we assign <samp class="SANS_TheSansMonoCd_W5Regular_11">null</samp> to a
    reference variable or pass it as an argument to a method, it’s converted automatically
    to the type of the target variable. Here we can compare <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp>
    with <samp class="SANS_TheSansMonoCd_W5Regular_11">null</samp> because the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">null</samp> reference is compatible with
    the <samp class="SANS_TheSansMonoCd_W5Regular_11">MusicTrack</samp> reference
    type.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">null</samp>引用是一个常量值，由<samp class="SANS_TheSansMonoCd_W5Regular_11">ldnull</samp>指令压入评估栈；<samp
    class="SANS_TheSansMonoCd_W5Regular_11">null</samp>没有自己的类型，但可以隐式地转换为*任何*引用类型。当我们将<samp
    class="SANS_TheSansMonoCd_W5Regular_11">null</samp>赋值给引用变量或将其作为参数传递给方法时，它会自动转换为目标变量的类型。在这里，我们可以将<samp
    class="SANS_TheSansMonoCd_W5Regular_11">x</samp>与<samp class="SANS_TheSansMonoCd_W5Regular_11">null</samp>进行比较，因为<samp
    class="SANS_TheSansMonoCd_W5Regular_11">null</samp>引用与<samp class="SANS_TheSansMonoCd_W5Regular_11">MusicTrack</samp>引用类型兼容。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Comparing Array Variables</samp>
  id: totrans-85
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">比较数组变量</samp>
- en: C# arrays are always reference types, so comparing array variables works the
    same way as comparing references. C# arrays are the built-in syntax for declaring
    and using a sequence of elements that are always allocated on the heap. An array
    variable is a reference to the elements of the array. In [Listing 5-8](#list5-8),
    we create two arrays with identical elements and use <samp class="SANS_TheSansMonoCd_W5Regular_11">==</samp>
    to compare them.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: C# 数组始终是引用类型，因此比较数组变量的方式与比较引用相同。C# 数组是声明和使用元素序列的内置语法，这些元素始终分配在堆上。数组变量是对数组元素的引用。在
    [示例 5-8](#list5-8) 中，我们创建了两个元素相同的数组，并使用 <samp class="SANS_TheSansMonoCd_W5Regular_11">==</samp>
    进行比较。
- en: '[PRE14]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 5-8: Implicitly initializing
    and comparing two arrays</samp>'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">示例 5-8：隐式初始化和比较两个数组</samp>
- en: The compiler deduces the size of each array based on the values we use to initialize
    them. The two arrays have identical elements but compare unequal because comparing
    two arrays with <samp class="SANS_TheSansMonoCd_W5Regular_11">==</samp> performs
    a reference comparison using the intrinsic <samp class="SANS_TheSansMonoCd_W5Regular_11">ceq</samp>
    instruction. The <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp> and <samp
    class="SANS_TheSansMonoCd_W5Regular_11">y</samp> variables in [Listing 5-8](#list5-8)
    are references to different arrays and thus don’t compare equal, so the test passes.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 编译器根据我们用来初始化数组的值推导出每个数组的大小。两个数组具有相同的元素，但比较结果为不相等，因为使用 <samp class="SANS_TheSansMonoCd_W5Regular_11">==</samp>
    比较数组时会执行引用比较，并使用内置的 <samp class="SANS_TheSansMonoCd_W5Regular_11">ceq</samp> 指令。示例
    [5-8](#list5-8) 中的 <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp> 和 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">y</samp> 变量是不同数组的引用，因此它们不会相等，所以测试通过。
- en: When we compare two array variables, the comparison doesn’t consider the array
    elements; it uses only the identity of the two array variables, so two array references
    compare equal only if they refer to the *same* array instance. To check whether
    two arrays have the same elements, we must manually compare each individual element
    or use a library facility such as <samp class="SANS_TheSansMonoCd_W5Regular_11">System.Enumerable.SequenceEqual</samp>.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们比较两个数组变量时，比较并不考虑数组元素，而仅仅使用两个数组变量的标识。因此，只有当它们指向 *相同* 的数组实例时，两个数组引用才会相等。要检查两个数组是否具有相同的元素，我们必须手动逐个比较每个元素，或者使用像
    <samp class="SANS_TheSansMonoCd_W5Regular_11">System.Enumerable.SequenceEqual</samp>
    这样的库功能。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Strings and Value
    Equality</samp>
  id: totrans-91
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">字符串和值的相等性</samp>
- en: Although <samp class="SANS_TheSansMonoCd_W5Regular_11">string</samp> variables
    are references, when we compare them we’re usually more concerned with whether
    their contents are the same rather than whether they refer to the same <samp class="SANS_TheSansMonoCd_W5Regular_11">string</samp>
    instance.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管 <samp class="SANS_TheSansMonoCd_W5Regular_11">string</samp> 变量是引用类型，但在比较时，我们通常更关注它们的内容是否相同，而不是它们是否引用同一个
    <samp class="SANS_TheSansMonoCd_W5Regular_11">string</samp> 实例。
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">string</samp> class overloads
    the default behavior of <samp class="SANS_TheSansMonoCd_W5Regular_11">==</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp> to give strings
    value-like semantics. Comparing strings with either <samp class="SANS_TheSansMonoCd_W5Regular_11">==</samp>
    or <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp> performs a value-based
    rather than reference-based comparison. It’s possible to have more than one reference
    to a single <samp class="SANS_TheSansMonoCd_W5Regular_11">string</samp> instance
    on the heap, and those references will still compare equal. However, it’s also
    possible to have two independent <samp class="SANS_TheSansMonoCd_W5Regular_11">string</samp>
    instances that have the same content, and those instances also compare equal.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">string</samp> 类重载了默认的 <samp class="SANS_TheSansMonoCd_W5Regular_11">==</samp>
    和 <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp> 方法，以便为字符串提供类似值的语义。使用
    <samp class="SANS_TheSansMonoCd_W5Regular_11">==</samp> 或 <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp>
    比较字符串时，执行的是基于值的比较，而不是基于引用的比较。虽然堆上可能存在多个对同一个 <samp class="SANS_TheSansMonoCd_W5Regular_11">string</samp>
    实例的引用，但这些引用依然会比较相等。然而，也可能存在两个内容相同的独立 <samp class="SANS_TheSansMonoCd_W5Regular_11">string</samp>
    实例，它们的比较结果也会是相等的。
- en: For example, in [Listing 5-9](#list5-9), the <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">y</samp> variables don’t refer
    to the same <samp class="SANS_TheSansMonoCd_W5Regular_11">string</samp> instance
    but do have the same *value* at run time.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在[列表 5-9](#list5-9)中，<samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp>
    和 <samp class="SANS_TheSansMonoCd_W5Regular_11">y</samp> 变量并不指向同一个 <samp class="SANS_TheSansMonoCd_W5Regular_11">string</samp>
    实例，但在运行时它们具有相同的*值*。
- en: '[PRE15]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 5-9: Comparing string
    values</samp>'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">列表 5-9：比较字符串值</samp>
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">string</samp> class customizes
    the behavior of both <samp class="SANS_TheSansMonoCd_W5Regular_11">==</samp> and
    the <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp> method, so the
    <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">y</samp>
    variables compare equal because they both have the same content, although they’re
    references to distinct instances. Since <samp class="SANS_TheSansMonoCd_W5Regular_11">string</samp>
    overrides the behavior of <samp class="SANS_TheSansMonoCd_W5Regular_11">==</samp>,
    we use the <samp class="SANS_TheSansMonoCd_W5Regular_11">ReferenceEquals</samp>
    method here to perform a reference comparison. <samp class="SANS_TheSansMonoCd_W5Regular_11">ReferenceEquals</samp>
    is a static method defined on <samp class="SANS_TheSansMonoCd_W5Regular_11">object</samp>
    and performs an identity comparison between any two reference type variables.
    In this example, <samp class="SANS_TheSansMonoCd_W5Regular_11">ReferenceEquals</samp>
    returns <samp class="SANS_TheSansMonoCd_W5Regular_11">false</samp> because its
    arguments are references to different objects on the heap.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">string</samp> 类自定义了 <samp class="SANS_TheSansMonoCd_W5Regular_11">==</samp>
    和 <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp> 方法的行为，因此 <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp>
    和 <samp class="SANS_TheSansMonoCd_W5Regular_11">y</samp> 变量被认为相等，因为它们具有相同的内容，尽管它们是指向不同实例的引用。由于
    <samp class="SANS_TheSansMonoCd_W5Regular_11">string</samp> 重写了 <samp class="SANS_TheSansMonoCd_W5Regular_11">==</samp>
    的行为，我们在这里使用 <samp class="SANS_TheSansMonoCd_W5Regular_11">ReferenceEquals</samp>
    方法来进行引用比较。<samp class="SANS_TheSansMonoCd_W5Regular_11">ReferenceEquals</samp>
    是一个定义在 <samp class="SANS_TheSansMonoCd_W5Regular_11">object</samp> 上的静态方法，它在任何两个引用类型变量之间执行身份比较。在这个例子中，<samp
    class="SANS_TheSansMonoCd_W5Regular_11">ReferenceEquals</samp> 返回 <samp class="SANS_TheSansMonoCd_W5Regular_11">false</samp>，因为它的参数是指向堆上不同对象的引用。
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">y</samp>
    variables in [Listing 5-9](#list5-9) both use string interpolation to insert the
    values of named variables within the string, ensuring that <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">y</samp> really are distinct
    instances—at least in debug mode. If we use two simple string literals, as we
    do in [Listing 5-10](#list5-10), <samp class="SANS_TheSansMonoCd_W5Regular_11">ReferenceEquals</samp>
    gives us a different result.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在[列表 5-9](#list5-9)中的 <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp>
    和 <samp class="SANS_TheSansMonoCd_W5Regular_11">y</samp> 变量都使用了字符串插值将命名变量的值插入到字符串中，从而确保
    <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp> 和 <samp class="SANS_TheSansMonoCd_W5Regular_11">y</samp>
    确实是不同的实例——至少在调试模式下是这样。如果我们像在[列表 5-10](#list5-10)中那样使用两个简单的字符串字面量，<samp class="SANS_TheSansMonoCd_W5Regular_11">ReferenceEquals</samp>
    会给出不同的结果。
- en: '[PRE16]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 5-10: Comparing string
    literal values</samp>'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">列表 5-10：比较字符串字面量值</samp>
- en: This test shows that <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">y</samp> really are the same
    instance in memory, even though they were independently assigned to two apparently
    separate strings. The reason for the different behavior is that the compiler conserves
    memory by using *string interning*, whereby it maintains an *intern pool* containing
    a single instance of each unique string literal used in a program. This way, even
    if the same string literal appears more than once in the code, only one instance
    is in memory. Strings are immutable, so having multiple references to one instance
    can never cause aliasing issues.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 这个测试表明，尽管 <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp> 和 <samp class="SANS_TheSansMonoCd_W5Regular_11">y</samp>
    分别独立地被赋值为两个看似独立的字符串，它们在内存中实际上是同一个实例。不同表现的原因在于编译器通过使用*字符串驻留*来节省内存，这种方法维护了一个*驻留池*，其中包含程序中每个唯一字符串字面量的单一实例。这样，即使同一个字符串字面量在代码中出现多次，内存中也只会存在一个实例。字符串是不可变的，因此多个引用指向同一个实例永远不会引起别名问题。
- en: We can use the intern pool ourselves at run time, although we have other memory
    considerations to take into account. We might save memory on individual string
    values, but the intern pool itself isn’t routinely garbage collected and will
    most likely stay in memory until the program terminates.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在运行时自己使用 intern 池，尽管我们还需要考虑其他内存方面的因素。我们可能会在单个字符串值上节省内存，但 intern 池本身不会常规地进行垃圾回收，并且很可能会一直保留在内存中，直到程序终止。
- en: We can determine whether two <samp class="SANS_TheSansMonoCd_W5Regular_11">string</samp>
    variables refer to separate instances with <samp class="SANS_TheSansMonoCd_W5Regular_11">ReferenceEquals</samp>
    or another method, but it rarely matters. Whether two <samp class="SANS_TheSansMonoCd_W5Regular_11">string</samp>
    variables are references to one <samp class="SANS_TheSansMonoCd_W5Regular_11">string</samp>
    instance or two separate instances with the same contents, they still compare
    equal.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过 <samp class="SANS_TheSansMonoCd_W5Regular_11">ReferenceEquals</samp>
    或其他方法来判断两个 <samp class="SANS_TheSansMonoCd_W5Regular_11">string</samp> 变量是否引用不同的实例，但通常这并不重要。无论两个
    <samp class="SANS_TheSansMonoCd_W5Regular_11">string</samp> 变量是否引用同一个 <samp class="SANS_TheSansMonoCd_W5Regular_11">string</samp>
    实例，或者是两个具有相同内容的独立实例，它们仍然被认为是相等的。
- en: <samp class="SANS_Futura_Std_Bold_B_11">Custom Equality for Classes</samp>
  id: totrans-104
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">自定义类的相等性</samp>
- en: If we want value-based rather than reference-based equality for our own class
    types, we override the <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp>
    method and define <samp class="SANS_TheSansMonoCd_W5Regular_11">operator==</samp>
    for the class to customize the behavior of equality comparisons. There are several
    aspects to a complete implementation of equality comparisons in a class, so we’ll
    build it up in stages and implement each part in turn so you can better understand
    how all the components fit together.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们希望为自定义类类型实现基于值而非基于引用的相等性，我们需要重写 <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp>
    方法，并为该类定义 <samp class="SANS_TheSansMonoCd_W5Regular_11">operator==</samp> 来自定义相等性比较的行为。类中完整实现相等性比较有几个方面，因此我们将分阶段构建，并逐步实现每个部分，以便更好地理解所有组件是如何组合在一起的。
- en: Our first task is to customize the virtual <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp>
    method for the class. The <samp class="SANS_TheSansMonoCd_W5Regular_11">MusicTrack</samp>
    class in [Listing 5-11](#list5-11) has two <samp class="SANS_TheSansMonoCd_W5Regular_11">string</samp>
    properties, and we define <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp>
    so that two instances of <samp class="SANS_TheSansMonoCd_W5Regular_11">MusicTrack</samp>
    compare equal if the values for both fields compare equal.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的第一个任务是为类自定义虚方法 <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp>。[列表
    5-11](#list5-11) 中的 <samp class="SANS_TheSansMonoCd_W5Regular_11">MusicTrack</samp>
    类有两个 <samp class="SANS_TheSansMonoCd_W5Regular_11">string</samp> 属性，我们定义 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp> 方法，使得当两个 <samp class="SANS_TheSansMonoCd_W5Regular_11">MusicTrack</samp>
    实例的两个字段的值相等时，它们也被认为是相等的。
- en: '[PRE17]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 5-11: Overriding the
    Equals method</samp>'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">列表 5-11：重写 Equals 方法</samp>
- en: Because we’re customizing the implementation of an inherited virtual method,
    we use the <samp class="SANS_TheSansMonoCd_W5Regular_11">override</samp> keyword,
    and the method’s signature must match the signature of the base class method being
    overridden. Note that compiling this code will issue a warning that we haven’t
    overridden <samp class="SANS_TheSansMonoCd_W5Regular_11">GetHashCode</samp>. We’ll
    address that shortly.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 因为我们正在自定义继承自虚方法的实现，所以使用 <samp class="SANS_TheSansMonoCd_W5Regular_11">override</samp>
    关键字，并且该方法的签名必须与被重写的基类方法的签名匹配。请注意，编译这段代码时会发出警告，提醒我们没有重写 <samp class="SANS_TheSansMonoCd_W5Regular_11">GetHashCode</samp>。我们稍后会处理这个问题。
- en: The virtual <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp> method
    takes a single nullable <samp class="SANS_TheSansMonoCd_W5Regular_11">object</samp>
    reference, which we need to cast to our implementing type in order to compare
    it with the current instance. Here we use a *declaration pattern* to declare the
    <samp class="SANS_TheSansMonoCd_W5Regular_11">other</samp> variable if the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">obj</samp> parameter is non-<samp class="SANS_TheSansMonoCd_W5Regular_11">null</samp>
    and there’s an identity conversion or implicit reference conversion from the type
    of <samp class="SANS_TheSansMonoCd_W5Regular_11">obj</samp> to <samp class="SANS_TheSansMonoCd_W5Regular_11">MusicTrack</samp>.
    An *identity conversion* simply means a type can be converted to itself. An *implicit
    reference conversion* can take several forms, but for simplicity here it means
    that <samp class="SANS_TheSansMonoCd_W5Regular_11">MusicTrack</samp> is a base
    type of the run-time type of <samp class="SANS_TheSansMonoCd_W5Regular_11">obj</samp>.
    In this example, since <samp class="SANS_TheSansMonoCd_W5Regular_11">MusicTrack</samp>
    is a sealed class, the type will match exactly (an identity conversion) or not
    match at all.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 虚拟的 <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp> 方法接受一个单一的可空
    <samp class="SANS_TheSansMonoCd_W5Regular_11">object</samp> 引用，我们需要将其转换为我们实现的类型，以便与当前实例进行比较。在这里，如果
    <samp class="SANS_TheSansMonoCd_W5Regular_11">obj</samp> 参数非 <samp class="SANS_TheSansMonoCd_W5Regular_11">null</samp>
    且从 <samp class="SANS_TheSansMonoCd_W5Regular_11">obj</samp> 类型到 <samp class="SANS_TheSansMonoCd_W5Regular_11">MusicTrack</samp>
    类型存在身份转换或隐式引用转换，我们使用 *声明模式* 来声明 <samp class="SANS_TheSansMonoCd_W5Regular_11">other</samp>
    变量。*身份转换* 只是意味着某个类型可以转换为自身。*隐式引用转换* 可以有多种形式，但在这里为了简单起见，它意味着 <samp class="SANS_TheSansMonoCd_W5Regular_11">MusicTrack</samp>
    是 <samp class="SANS_TheSansMonoCd_W5Regular_11">obj</samp> 运行时类型的基类。在这个例子中，由于
    <samp class="SANS_TheSansMonoCd_W5Regular_11">MusicTrack</samp> 是一个密封类，因此类型要么完全匹配（身份转换），要么根本不匹配。
- en: If the <samp class="SANS_TheSansMonoCd_W5Regular_11">obj</samp> variable’s type
    matches the pattern, <samp class="SANS_TheSansMonoCd_W5Regular_11">obj</samp>
    is cast to the specified type and assigned to the <samp class="SANS_TheSansMonoCd_W5Regular_11">other</samp>
    variable. The <samp class="SANS_TheSansMonoCd_W5Regular_11">other</samp> variable
    is therefore a <samp class="SANS_TheSansMonoCd_W5Regular_11">MusicTrack</samp>
    reference, and we use it to compare its properties with those of the current instance
    to see if they’re equal.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 <samp class="SANS_TheSansMonoCd_W5Regular_11">obj</samp> 变量的类型与模式匹配，<samp
    class="SANS_TheSansMonoCd_W5Regular_11">obj</samp> 将被转换为指定类型并赋值给 <samp class="SANS_TheSansMonoCd_W5Regular_11">other</samp>
    变量。因此，<samp class="SANS_TheSansMonoCd_W5Regular_11">other</samp> 变量是一个 <samp class="SANS_TheSansMonoCd_W5Regular_11">MusicTrack</samp>
    引用，我们使用它来比较其属性与当前实例的属性，看看它们是否相等。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Defining Equality
    Operators</samp>
  id: totrans-112
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">定义相等操作符</samp>
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp> method is seldom
    used directly, because most programmers find using <samp class="SANS_TheSansMonoCd_W5Regular_11">==</samp>
    more natural than calling <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp>.
    It’s generally desirable that <samp class="SANS_TheSansMonoCd_W5Regular_11">==</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp> have identical
    behavior, and we achieve that most simply by implementing <samp class="SANS_TheSansMonoCd_W5Regular_11">operator==</samp>
    for the <samp class="SANS_TheSansMonoCd_W5Regular_11">MusicTrack</samp> class
    to call the <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp> method
    we’ve already defined.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp> 方法很少直接使用，因为大多数程序员发现使用
    <samp class="SANS_TheSansMonoCd_W5Regular_11">==</samp> 比调用 <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp>
    更自然。一般来说，<samp class="SANS_TheSansMonoCd_W5Regular_11">==</samp> 和 <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp>
    的行为应当一致，我们通过为 <samp class="SANS_TheSansMonoCd_W5Regular_11">MusicTrack</samp>
    类实现 <samp class="SANS_TheSansMonoCd_W5Regular_11">operator==</samp> 来简便地调用我们已定义的
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp> 方法，从而实现这一点。
- en: Operator definitions such as <samp class="SANS_TheSansMonoCd_W5Regular_11">operator==</samp>
    are static methods. The <samp class="SANS_TheSansMonoCd_W5Regular_11">operator==</samp>
    definition takes two parameters, at least one of which must be of the type implementing
    the operator. The return type is most often <samp class="SANS_TheSansMonoCd_W5Regular_11">bool</samp>,
    although that’s not a strict requirement. The usual implementation has both parameters
    of the same type, allowing us to use <samp class="SANS_TheSansMonoCd_W5Regular_11">==</samp>
    to compare two instances, as shown in [Listing 5-12](#list5-12).
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 操作符定义如<samp class="SANS_TheSansMonoCd_W5Regular_11">operator==</samp>是静态方法。<samp
    class="SANS_TheSansMonoCd_W5Regular_11">operator==</samp>的定义需要两个参数，其中至少一个必须是实现该操作符的类型。返回类型通常是<samp
    class="SANS_TheSansMonoCd_W5Regular_11">bool</samp>，尽管这不是严格要求。通常的实现中，两个参数是相同类型的，这使得我们可以使用<samp
    class="SANS_TheSansMonoCd_W5Regular_11">==</samp>来比较两个实例，如[列表 5-12](#list5-12)所示。
- en: '[PRE18]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 5-12: Defining operator</samp>==
    <samp class="SANS_Futura_Std_Book_Oblique_I_11">for the MusicTrack class</samp>'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">列表 5-12：为 MusicTrack 类定义操作符</samp>== '
- en: If we provide <samp class="SANS_TheSansMonoCd_W5Regular_11">operator==</samp>,
    we must also implement a matching <samp class="SANS_TheSansMonoCd_W5Regular_11">operator</samp><samp
    class="SANS_TheSansMonoCd_W5Regular_11">!</samp><samp class="SANS_TheSansMonoCd_W5Regular_11">=</samp>,
    which we do simply by inverting the result of calling the <samp class="SANS_TheSansMonoCd_W5Regular_11">==</samp>
    operator method.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们提供了<samp class="SANS_TheSansMonoCd_W5Regular_11">operator==</samp>，我们还必须实现一个匹配的<samp
    class="SANS_TheSansMonoCd_W5Regular_11">operator</samp><samp class="SANS_TheSansMonoCd_W5Regular_11">!</samp><samp
    class="SANS_TheSansMonoCd_W5Regular_11">=</samp>，我们通过简单地反转调用<samp class="SANS_TheSansMonoCd_W5Regular_11">==</samp>操作符方法的结果来实现。
- en: Since <samp class="SANS_TheSansMonoCd_W5Regular_11">MusicTrack</samp> is a class,
    either or both of the arguments to the operators could be <samp class="SANS_TheSansMonoCd_W5Regular_11">null</samp>,
    so we make that expectation explicit by using the nullable reference syntax for
    the parameters. If both arguments are <samp class="SANS_TheSansMonoCd_W5Regular_11">null</samp>,
    they compare equal. If <samp class="SANS_TheSansMonoCd_W5Regular_11">left</samp>
    is non-<samp class="SANS_TheSansMonoCd_W5Regular_11">null</samp>, we call the
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp> method, passing <samp
    class="SANS_TheSansMonoCd_W5Regular_11">right</samp> as the argument even where
    <samp class="SANS_TheSansMonoCd_W5Regular_11">right</samp> is a <samp class="SANS_TheSansMonoCd_W5Regular_11">null</samp>
    reference. Our implementation of <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp>
    already handles <samp class="SANS_TheSansMonoCd_W5Regular_11">null</samp> being
    passed to its parameter.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 由于<samp class="SANS_TheSansMonoCd_W5Regular_11">MusicTrack</samp>是一个类，因此操作符的一个或两个参数可能是<samp
    class="SANS_TheSansMonoCd_W5Regular_11">null</samp>，所以我们通过为参数使用可空引用语法来明确这一预期。如果两个参数都是<samp
    class="SANS_TheSansMonoCd_W5Regular_11">null</samp>，它们会被认为相等。如果<samp class="SANS_TheSansMonoCd_W5Regular_11">left</samp>不是<samp
    class="SANS_TheSansMonoCd_W5Regular_11">null</samp>，我们会调用<samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp>方法，将<samp
    class="SANS_TheSansMonoCd_W5Regular_11">right</samp>作为参数，即使<samp class="SANS_TheSansMonoCd_W5Regular_11">right</samp>是<samp
    class="SANS_TheSansMonoCd_W5Regular_11">null</samp>引用。我们对<samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp>的实现已经处理了将<samp
    class="SANS_TheSansMonoCd_W5Regular_11">null</samp>传递给其参数的情况。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Handling Comparisons
    with null</samp>
  id: totrans-119
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">处理与 null 的比较</samp>
- en: In [Listing 5-12](#list5-12), we used the constant pattern and the <samp class="SANS_TheSansMonoCd_W5Regular_11">is</samp>
    keyword to compare the <samp class="SANS_TheSansMonoCd_W5Regular_11">left</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">right</samp> parameters with
    <samp class="SANS_TheSansMonoCd_W5Regular_11">null</samp>. If we compared them
    with <samp class="SANS_TheSansMonoCd_W5Regular_11">==</samp> instead, <samp class="SANS_TheSansMonoCd_W5Regular_11">operator==</samp>
    would call itself recursively because <samp class="SANS_TheSansMonoCd_W5Regular_11">null</samp>
    is implicitly converted to <samp class="SANS_TheSansMonoCd_W5Regular_11">MusicTrack</samp>
    in those comparisons. Applying the constant pattern here avoids that pitfall because
    the <samp class="SANS_TheSansMonoCd_W5Regular_11">is null</samp> expression never
    calls a user-defined <samp class="SANS_TheSansMonoCd_W5Regular_11">operator==</samp>
    implementation. The compiler translates all such comparisons to use the intrinsic
    <samp class="SANS_TheSansMonoCd_W5Regular_11">ceq</samp> instruction.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [Listing 5-12](#list5-12) 中，我们使用了常量模式和 `<samp class="SANS_TheSansMonoCd_W5Regular_11">is</samp>`
    关键字来比较 `<samp class="SANS_TheSansMonoCd_W5Regular_11">left</samp>` 和 `<samp class="SANS_TheSansMonoCd_W5Regular_11">right</samp>`
    参数与 `<samp class="SANS_TheSansMonoCd_W5Regular_11">null</samp>`。如果我们改为使用 `<samp
    class="SANS_TheSansMonoCd_W5Regular_11">==</samp>` 进行比较，`<samp class="SANS_TheSansMonoCd_W5Regular_11">operator==</samp>`
    将会递归调用自身，因为在这些比较中，`<samp class="SANS_TheSansMonoCd_W5Regular_11">null</samp>`
    会被隐式转换为 `<samp class="SANS_TheSansMonoCd_W5Regular_11">MusicTrack</samp>`。在此处应用常量模式避免了这一陷阱，因为
    `<samp class="SANS_TheSansMonoCd_W5Regular_11">is null</samp>` 表达式从不调用用户定义的 `<samp
    class="SANS_TheSansMonoCd_W5Regular_11">operator==</samp>` 实现。编译器将所有这些比较转化为使用本地的
    `<samp class="SANS_TheSansMonoCd_W5Regular_11">ceq</samp>` 指令。
- en: Since the contents of the <samp class="SANS_TheSansMonoCd_W5Regular_11">if</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">else</samp> blocks are simple
    expressions, we make the implementation of <samp class="SANS_TheSansMonoCd_W5Regular_11">operator==</samp>
    more compact in [Listing 5-13](#list5-13) by using the ternary operator, which
    has the form <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">expression</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">?</samp> <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">result
    if true</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">:</samp> <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">result
    if false</samp>.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 `<samp class="SANS_TheSansMonoCd_W5Regular_11">if</samp>` 和 `<samp class="SANS_TheSansMonoCd_W5Regular_11">else</samp>`
    块的内容是简单表达式，我们通过使用三元运算符使得 [Listing 5-13](#list5-13) 中的 `<samp class="SANS_TheSansMonoCd_W5Regular_11">operator==</samp>`
    实现更加简洁，三元运算符的形式为：<samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">expression</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">?</samp> <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">true时的结果</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">:</samp> <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">false时的结果</samp>。
- en: '[PRE19]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 5-13: A more compact
    implementation of operator</samp>=='
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 5-13: operator== 的更简洁实现</samp>'
- en: 'We can further simplify the code for <samp class="SANS_TheSansMonoCd_W5Regular_11">operator==</samp>
    by employing the null-conditional operator <samp class="SANS_TheSansMonoCd_W5Regular_11">?.</samp>,
    which invokes an instance method only if the variable used to make the call is
    non-<samp class="SANS_TheSansMonoCd_W5Regular_11">null</samp>. In the expression
    <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">x</samp><samp class="SANS_TheSansMonoCd_W5Regular_11">?</samp><samp
    class="SANS_TheSansMonoCd_W5Regular_11">.</samp><samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">y</samp>,
    if <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">x</samp> is <samp class="SANS_TheSansMonoCd_W5Regular_11">null</samp>,
    the result of the whole expression is <samp class="SANS_TheSansMonoCd_W5Regular_11">null</samp>;
    otherwise, the result is <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">x</samp><samp
    class="SANS_TheSansMonoCd_W5Regular_11">.</samp><samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">y</samp>.
    Using the null-conditional operator to implement <samp class="SANS_TheSansMonoCd_W5Regular_11">operator==</samp>
    makes the implementation much more compact, especially if we also make the operator
    an expression-bodied method, like so:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过使用空条件运算符<samp class="SANS_TheSansMonoCd_W5Regular_11">?.</samp>进一步简化<code>operator==</code>的代码，空条件运算符只有在用于调用的变量非<samp
    class="SANS_TheSansMonoCd_W5Regular_11">null</samp>时才会调用实例方法。在表达式<samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">x</samp><samp
    class="SANS_TheSansMonoCd_W5Regular_11">?</samp><samp class="SANS_TheSansMonoCd_W5Regular_11">.</samp><samp
    class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">y</samp>中，如果<samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">x</samp>为<samp
    class="SANS_TheSansMonoCd_W5Regular_11">null</samp>，则整个表达式的结果为<samp class="SANS_TheSansMonoCd_W5Regular_11">null</samp>；否则，结果为<samp
    class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">x</samp><samp class="SANS_TheSansMonoCd_W5Regular_11">.</samp><samp
    class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">y</samp>。使用空条件运算符来实现<code>operator==</code>使得实现变得更加紧凑，特别是如果我们还将该运算符设置为表达式主体的方法，如下所示：
- en: '[PRE20]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Here, the <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp> method
    is called only if the <samp class="SANS_TheSansMonoCd_W5Regular_11">left</samp>
    parameter is not <samp class="SANS_TheSansMonoCd_W5Regular_11">null</samp>, since
    we’ve used the null-conditional operator on the <samp class="SANS_TheSansMonoCd_W5Regular_11">left</samp>
    variable. We combine the null-conditional operator with the null-coalescing operator
    <samp class="SANS_TheSansMonoCd_W5Regular_11">??</samp>, which evaluates its right-hand
    expression only if the whole left expression is <samp class="SANS_TheSansMonoCd_W5Regular_11">null</samp>.
    If <samp class="SANS_TheSansMonoCd_W5Regular_11">left</samp> is <samp class="SANS_TheSansMonoCd_W5Regular_11">null</samp>,
    then <samp class="SANS_TheSansMonoCd_W5Regular_11">left</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">right</samp>
    are equal if <samp class="SANS_TheSansMonoCd_W5Regular_11">right</samp> is also
    <samp class="SANS_TheSansMonoCd_W5Regular_11">null</samp>.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，只有在<samp class="SANS_TheSansMonoCd_W5Regular_11">left</samp>参数非<samp class="SANS_TheSansMonoCd_W5Regular_11">null</samp>时，<samp
    class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp>方法才会被调用，因为我们在<samp class="SANS_TheSansMonoCd_W5Regular_11">left</samp>变量上使用了空条件运算符。我们将空条件运算符与空合并运算符<samp
    class="SANS_TheSansMonoCd_W5Regular_11">??</samp>结合使用，空合并运算符只有在整个左侧表达式为<samp class="SANS_TheSansMonoCd_W5Regular_11">null</samp>时才会计算右侧表达式。如果<samp
    class="SANS_TheSansMonoCd_W5Regular_11">left</samp>为<samp class="SANS_TheSansMonoCd_W5Regular_11">null</samp>，那么只有在<samp
    class="SANS_TheSansMonoCd_W5Regular_11">right</samp>也为<samp class="SANS_TheSansMonoCd_W5Regular_11">null</samp>时，<samp
    class="SANS_TheSansMonoCd_W5Regular_11">left</samp>和<samp class="SANS_TheSansMonoCd_W5Regular_11">right</samp>才相等。
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">null</samp> constant pattern,
    the null-conditional operator, and the null-coalescing operator are all different
    ways of testing whether a reference is equal to <samp class="SANS_TheSansMonoCd_W5Regular_11">null</samp>
    without invoking an <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp>
    method or ever calling a user-defined <samp class="SANS_TheSansMonoCd_W5Regular_11">operator==</samp>
    implementation. While we can customize both <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">operator==</samp>, we can’t
    change the behavior of comparisons made with the <samp class="SANS_TheSansMonoCd_W5Regular_11">is</samp>
    keyword or the null-conditional and null-coalescing operators.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">null</samp> 常量模式、null 条件运算符和空合并运算符是测试引用是否等于
    <samp class="SANS_TheSansMonoCd_W5Regular_11">null</samp> 的不同方式，而无需调用 <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp>
    方法或任何用户定义的 <samp class="SANS_TheSansMonoCd_W5Regular_11">operator==</samp> 实现。尽管我们可以自定义
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp> 和 <samp class="SANS_TheSansMonoCd_W5Regular_11">operator==</samp>，但我们无法更改使用
    <samp class="SANS_TheSansMonoCd_W5Regular_11">is</samp> 关键字或 null 条件与空合并运算符进行比较时的行为。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Making Type-Safe
    Comparisons</samp>
  id: totrans-128
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">进行类型安全的比较</samp>
- en: When we compare values for equality, we’re most commonly comparing two values
    of the same type, which is why the usual implementation of <samp class="SANS_TheSansMonoCd_W5Regular_11">operator==</samp>
    has two matching parameters. Our <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp>
    method, however, takes an <samp class="SANS_TheSansMonoCd_W5Regular_11">object</samp>
    parameter, which must be cast back to <samp class="SANS_TheSansMonoCd_W5Regular_11">MusicTrack</samp>
    so we can compare its individual property values. We can avoid this cast by writing
    an overload of <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp> that
    takes a <samp class="SANS_TheSansMonoCd_W5Regular_11">MusicTrack</samp> parameter,
    shown in [Listing 5-14](#list5-14).
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们比较两个值是否相等时，通常比较的是同类型的两个值，这就是为什么常规实现的 <samp class="SANS_TheSansMonoCd_W5Regular_11">operator==</samp>
    具有两个匹配参数的原因。然而，我们的 <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp>
    方法接受一个 <samp class="SANS_TheSansMonoCd_W5Regular_11">object</samp> 参数，该参数必须被强制转换回
    <samp class="SANS_TheSansMonoCd_W5Regular_11">MusicTrack</samp>，以便我们可以比较其各个属性值。我们可以通过编写一个接受
    <samp class="SANS_TheSansMonoCd_W5Regular_11">MusicTrack</samp> 参数的 <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp>
    重载来避免这种强制转换，见 [列表 5-14](#list5-14)。
- en: '[PRE21]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 5-14: A type-safe Equals
    method</samp>'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">列表 5-14：类型安全的 Equals 方法</samp>
- en: 'We still need to compare the argument with <samp class="SANS_TheSansMonoCd_W5Regular_11">null</samp>,
    and, as we did for <samp class="SANS_TheSansMonoCd_W5Regular_11">operator==</samp>,
    we use the constant pattern to make that comparison as efficient as possible.
    To avoid duplicating the code for comparing the property values, we alter the
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals(object?)</samp> method to
    call the type-safe overload like this:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 我们仍然需要将参数与 <samp class="SANS_TheSansMonoCd_W5Regular_11">null</samp> 进行比较，正如我们对
    <samp class="SANS_TheSansMonoCd_W5Regular_11">operator==</samp> 所做的那样，我们使用常量模式来尽可能高效地进行比较。为了避免重复比较属性值的代码，我们将
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals(object?)</samp> 方法修改为调用类型安全的重载，如下所示：
- en: '[PRE22]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Although we’re employing a run-time cast using the <samp class="SANS_TheSansMonoCd_W5Regular_11">as</samp>
    keyword, [Listing 5-14](#list5-14)’s overload of <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp>
    taking a <samp class="SANS_TheSansMonoCd_W5Regular_11">MusicTrack?</samp> parameter
    is much more likely to be called than this overridden method with an <samp class="SANS_TheSansMonoCd_W5Regular_11">object?</samp>
    parameter. In particular, our implementation of <samp class="SANS_TheSansMonoCd_W5Regular_11">operator==</samp>
    will always call the type-specific overload because the parameters to the operator
    are both <samp class="SANS_TheSansMonoCd_W5Regular_11">MusicTrack</samp> variables.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我们使用 <samp class="SANS_TheSansMonoCd_W5Regular_11">as</samp> 关键字进行运行时类型转换，但
    [列表 5-14](#list5-14) 中重载的 <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp>
    方法，它接收一个 <samp class="SANS_TheSansMonoCd_W5Regular_11">MusicTrack?</samp> 参数，比重载接收
    <samp class="SANS_TheSansMonoCd_W5Regular_11">object?</samp> 参数的方法更可能被调用。特别是，我们对
    <samp class="SANS_TheSansMonoCd_W5Regular_11">operator==</samp> 的实现将始终调用特定类型的重载，因为该运算符的两个参数都是
    <samp class="SANS_TheSansMonoCd_W5Regular_11">MusicTrack</samp> 变量。
- en: Since we’ve overridden <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp>
    for the <samp class="SANS_TheSansMonoCd_W5Regular_11">MusicTrack</samp> class,
    the compiler will warn us that we should override <samp class="SANS_TheSansMonoCd_W5Regular_11">GetHashCode</samp>
    too.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们已经重写了 <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp> 方法用于 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">MusicTrack</samp> 类，编译器会警告我们，应该也重写 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">GetHashCode</samp> 方法。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Working with Hash
    Codes</samp>
  id: totrans-136
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">处理哈希值</samp>
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">GetHashCode</samp>
    methods are closely associated. Like <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">GetHashCode</samp> is defined on
    <samp class="SANS_TheSansMonoCd_W5Regular_11">object</samp> and is virtual. The
    <samp class="SANS_TheSansMonoCd_W5Regular_11">GetHashCode</samp> method is used
    by collection types like <samp class="SANS_TheSansMonoCd_W5Regular_11">Dictionary</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">HashSet</samp> to efficiently
    store and look up keys. Essentially, a data structure such as a hash table uses
    an object’s *hash code* to identify its location within the data structure. When
    we add a new key or try to locate an existing one, the lookup algorithm quickly
    identifies the correct place in the table by using a hash code.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp> 和 <samp class="SANS_TheSansMonoCd_W5Regular_11">GetHashCode</samp>
    方法是紧密关联的。就像 <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp> 一样，<samp
    class="SANS_TheSansMonoCd_W5Regular_11">GetHashCode</samp> 是在 <samp class="SANS_TheSansMonoCd_W5Regular_11">object</samp>
    上定义的，并且是虚拟的。<samp class="SANS_TheSansMonoCd_W5Regular_11">GetHashCode</samp> 方法被字典类如
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Dictionary</samp> 和 <samp class="SANS_TheSansMonoCd_W5Regular_11">HashSet</samp>
    用来高效地存储和查找键。实际上，像哈希表这样的数据结构通过使用对象的 *哈希值* 来确定其在数据结构中的位置。当我们添加一个新键或尝试定位一个现有键时，查找算法会通过哈希值快速识别表中的正确位置。
- en: However, a particular hash code in the table may identify several different
    keys, because although the items in a hash table are usually unique, hash codes
    don’t have to be. When we add a new item to a hash table and the item’s hash code
    already exists in the table—a scenario known as a *collision*—the <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp>
    method is used on each key with a matching hash code to verify whether the table
    already contains the new item. This is why <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">GetHashCode</samp> are so closely
    related.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，表中的某个特定哈希值可能会标识多个不同的键，因为尽管哈希表中的项目通常是唯一的，哈希值不必是唯一的。当我们将一个新项添加到哈希表中，而该项的哈希值已经存在于表中——这种情况称为
    *冲突*——则会对每个具有相同哈希值的键使用 <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp>
    方法来验证表中是否已经包含新项。这就是为什么 <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp>
    和 <samp class="SANS_TheSansMonoCd_W5Regular_11">GetHashCode</samp> 是如此紧密相关的原因。
- en: 'A key can be any object, as long as these two rules are followed:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 键可以是任何对象，只要遵循以下两个规则：
- en: Objects that are equal according to <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp>
    have the same hash code.
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 根据 <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp> 判断相等的对象具有相同的哈希值。
- en: The hash code for an object being used as a key doesn’t change.
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 作为键使用的对象的哈希值不会改变。
- en: Ideally, each unique hash code will identify a single key—meaning we avoid the
    need to compare several objects via <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp>—and
    so searching for a key is much faster. When we search for a key in the table,
    if the hash code is matched by only a single key, it *must* be the required key
    as long as the two rules have been followed. Ensuring that hash codes are widely
    distributed is recommended to increase the likelihood that each hash code uniquely
    identifies one key.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 理想情况下，每个唯一的哈希值会标识一个唯一的键——这意味着我们避免通过 <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp>
    比较多个对象——因此查找键的速度要更快。当我们在表中查找键时，如果哈希值只与一个键匹配，那么只要遵循了这两个规则，它 *必须* 是所需的键。建议确保哈希值广泛分布，以增加每个哈希值唯一标识一个键的可能性。
- en: For class types, the default implementation of <samp class="SANS_TheSansMonoCd_W5Regular_11">GetHashCode</samp>
    uses an object’s identity rather than its value to create a hash code, just as
    the default implementation of <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp>
    compares object identities, not their state. If two references are equal, they
    must also have the same hash value, because they refer to the same *instance*.
    The default hash code for an instance also never changes. However, if we accept
    the default behavior of <samp class="SANS_TheSansMonoCd_W5Regular_11">GetHashCode</samp>
    for classes, we must take extra care when using class types as keys.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 对于类类型，<samp class="SANS_TheSansMonoCd_W5Regular_11">GetHashCode</samp>的默认实现使用对象的标识而不是其值来创建哈希码，就像<
    samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp>的默认实现比较对象标识，而不是它们的状态。如果两个引用相等，它们必须具有相同的哈希值，因为它们引用的是相同的*实例*。实例的默认哈希码也永远不会改变。然而，如果我们接受类的<
    samp class="SANS_TheSansMonoCd_W5Regular_11">GetHashCode</samp>的默认行为，就必须在使用类类型作为键时特别小心。
- en: We can safely use any class type that doesn’t override the <samp class="SANS_TheSansMonoCd_W5Regular_11">GetHashCode</samp>
    method as a key, but when we search for an object in a hashing collection like
    a <samp class="SANS_TheSansMonoCd_W5Regular_11">Dictionary</samp> or <samp class="SANS_TheSansMonoCd_W5Regular_11">HashSet</samp>,
    we must make sure to use the exact same instance of the object that was originally
    inserted. If we try to look up an item with a different instance, the item won’t
    be found. To demonstrate, consider [Listing 5-15](#list5-15), where we use a new
    object instance to find a key in a <samp class="SANS_TheSansMonoCd_W5Regular_11">HashSet</samp>.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以安全地使用任何没有重写< samp class="SANS_TheSansMonoCd_W5Regular_11">GetHashCode</samp>方法的类类型作为键，但当我们在像<
    samp class="SANS_TheSansMonoCd_W5Regular_11">Dictionary</samp>或< samp class="SANS_TheSansMonoCd_W5Regular_11">HashSet</samp>这样的哈希集合中查找对象时，我们必须确保使用的是最初插入的相同实例。如果我们尝试用一个不同的实例来查找项，则该项将无法找到。为了演示，请参见[列表
    5-15](#list5-15)，在其中我们使用一个新的对象实例在< samp class="SANS_TheSansMonoCd_W5Regular_11">HashSet</samp>中查找键。
- en: '[PRE23]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 5-15: Using a Character
    class identity as a key</samp>'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">列表 5-15：使用字符类标识作为键</samp>
- en: The test in this example fails because we’re searching for a different instance
    of the <samp class="SANS_TheSansMonoCd_W5Regular_11">Character</samp> class than
    was added to the <samp class="SANS_TheSansMonoCd_W5Regular_11">HashSet</samp>.
    Since <samp class="SANS_TheSansMonoCd_W5Regular_11">Character</samp> doesn’t override
    the <samp class="SANS_TheSansMonoCd_W5Regular_11">GetHashCode</samp> method, the
    instance being looked up has a different hash code than the item contained in
    the <samp class="SANS_TheSansMonoCd_W5Regular_11">HashSet</samp>, even though
    both instances have the same state.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子中的测试失败了，因为我们在查找与最初添加到< samp class="SANS_TheSansMonoCd_W5Regular_11">HashSet</samp>中的<
    samp class="SANS_TheSansMonoCd_W5Regular_11">Character</samp>类的不同实例。由于< samp class="SANS_TheSansMonoCd_W5Regular_11">Character</samp>没有重写<
    samp class="SANS_TheSansMonoCd_W5Regular_11">GetHashCode</samp>方法，因此查找的实例的哈希码与<
    samp class="SANS_TheSansMonoCd_W5Regular_11">HashSet</samp>中包含的项的哈希码不同，即使这两个实例具有相同的状态。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Creating a Suitable Key</samp>
  id: totrans-148
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">创建合适的键</samp>
- en: Failing to find a key in a collection has important consequences. Elements in
    a <samp class="SANS_TheSansMonoCd_W5Regular_11">HashSet</samp> and keys in a <samp
    class="SANS_TheSansMonoCd_W5Regular_11">Dictionary</samp> should be *unique*.
    When we attempt to insert a new key, it should be added only if it isn’t already
    in the collection. However, if the key exists but can’t be found, we’ll get a
    *duplicated* key. The new object will be erroneously added to the table, effectively
    corrupting the collection.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 在集合中找不到键会产生重要后果。< samp class="SANS_TheSansMonoCd_W5Regular_11">HashSet</samp>中的元素和<
    samp class="SANS_TheSansMonoCd_W5Regular_11">Dictionary</samp>中的键应该是*唯一*的。当我们尝试插入一个新键时，它应该只在集合中不存在时才会被添加。然而，如果键已经存在但无法找到，我们将得到一个*重复的*键。新的对象将错误地添加到表中，从而有效地破坏集合。
- en: Needing to rely on using a single object instance to both insert and search
    for any particular key in a hashing collection is usually overly restrictive.
    If, for example, the collection is populated from a file or user input, the original
    instances frequently aren’t immediately at hand when we come to search for a specific
    item. It’s much more convenient for objects used as keys to generate their hash
    codes according to their state, not their identity. That way, we can use any key
    with the same state to identify an object in the table.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 需要依赖单个对象实例同时插入和查找哈希集合中的特定键通常过于严格。例如，如果集合是从文件或用户输入中填充的，原始实例在我们需要查找特定项时往往并不立即可用。对于作为键的对象来说，根据其状态而不是身份生成哈希码要方便得多。这样，我们就可以使用任何具有相同状态的键来识别表中的对象。
- en: As things stand, the <samp class="SANS_TheSansMonoCd_W5Regular_11">MusicTrack</samp>
    class we defined in [Listing 5-11](#list5-11) isn’t suitable as a key for a <samp
    class="SANS_TheSansMonoCd_W5Regular_11">HashSet</samp> or <samp class="SANS_TheSansMonoCd_W5Regular_11">Dictionary</samp>
    because it breaks the first of the two cardinal rules—that equal objects produce
    identical hash codes—because we’ve customized equality to compare the objects’
    state. To make <samp class="SANS_TheSansMonoCd_W5Regular_11">MusicTrack</samp>
    behave correctly, we must also override <samp class="SANS_TheSansMonoCd_W5Regular_11">GetHashCode</samp>
    and ensure that two instances of <samp class="SANS_TheSansMonoCd_W5Regular_11">MusicTrack</samp>
    that compare equal according to our customized <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp>
    method produce identical hash codes. To do that, we’ll generate a hash code using
    the same properties that determine whether two instances are equal. [Listing 5-16](#list5-16)
    shows one way to implement <samp class="SANS_TheSansMonoCd_W5Regular_11">GetHashCode</samp>
    for the <samp class="SANS_TheSansMonoCd_W5Regular_11">MusicTrack</samp> class.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 如今，我们在[清单 5-11](#list5-11)中定义的 <samp class="SANS_TheSansMonoCd_W5Regular_11">MusicTrack</samp>
    类不适合作为 <samp class="SANS_TheSansMonoCd_W5Regular_11">HashSet</samp> 或 <samp class="SANS_TheSansMonoCd_W5Regular_11">Dictionary</samp>
    的键，因为它违反了两个基本规则中的第一个——相等的对象应产生相同的哈希码——因为我们自定义了相等性来比较对象的状态。为了让 <samp class="SANS_TheSansMonoCd_W5Regular_11">MusicTrack</samp>
    正常工作，我们还必须重写 <samp class="SANS_TheSansMonoCd_W5Regular_11">GetHashCode</samp>
    并确保根据我们自定义的 <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp> 方法比较相等的两个
    <samp class="SANS_TheSansMonoCd_W5Regular_11">MusicTrack</samp> 实例生成相同的哈希码。为此，我们将使用决定两个实例是否相等的相同属性来生成哈希码。[清单
    5-16](#list5-16) 展示了一种为 <samp class="SANS_TheSansMonoCd_W5Regular_11">MusicTrack</samp>
    类实现 <samp class="SANS_TheSansMonoCd_W5Regular_11">GetHashCode</samp> 的方式。
- en: '[PRE24]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 5-16: Overriding GetHashCode</samp>'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">清单 5-16：重写 GetHashCode</samp>
- en: We use the <samp class="SANS_TheSansMonoCd_W5Regular_11">HashCode</samp> static
    class from the Standard Library, which combines multiple arguments to create reasonably
    well-distributed hash codes. Our implementation of <samp class="SANS_TheSansMonoCd_W5Regular_11">GetHashCode</samp>
    uses the same properties of <samp class="SANS_TheSansMonoCd_W5Regular_11">MusicTrack</samp>
    as the <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp> method in [Listing
    5-14](#list5-14), so two objects that compare equal will always generate identical
    hash codes.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用了来自标准库的 <samp class="SANS_TheSansMonoCd_W5Regular_11">HashCode</samp> 静态类，它结合了多个参数以创建合理分布的哈希码。我们对
    <samp class="SANS_TheSansMonoCd_W5Regular_11">GetHashCode</samp> 的实现使用了与 [清单 5-14](#list5-14)
    中 <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp> 方法相同的 <samp class="SANS_TheSansMonoCd_W5Regular_11">MusicTrack</samp>
    属性，因此比较相等的两个对象始终会生成相同的哈希码。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Using Floating-Point Numbers
    as Keys</samp>
  id: totrans-155
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">使用浮动点数作为键</samp>
- en: Using a floating-point number as the key in a hash table can result in keys
    being lost, in much the same way as relying on the default <samp class="SANS_TheSansMonoCd_W5Regular_11">object</samp>
    implementation of <samp class="SANS_TheSansMonoCd_W5Regular_11">GetHashCode</samp>
    for class types. As you saw earlier, comparing floating-point numbers for strict
    equality isn’t reliable. In [Listing 5-17](#list5-17), we try to identify whether
    the collection has a specific <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp>
    value.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 在哈希表中使用浮点数作为键可能会导致键丢失，这与依赖类类型的默认 <samp class="SANS_TheSansMonoCd_W5Regular_11">object</samp>
    实现的 <samp class="SANS_TheSansMonoCd_W5Regular_11">GetHashCode</samp> 相似。如前所述，严格比较浮点数是否相等并不可靠。在[列表
    5-17](#list5-17)中，我们尝试识别集合中是否有特定的 <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp>
    值。
- en: '[PRE25]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 5-17: Using floating-point
    numbers as keys</samp>'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">列表 5-17：使用浮点数作为键</samp>
- en: This test fails because the value <samp class="SANS_TheSansMonoCd_W5Regular_11">0.3</samp>
    doesn’t exactly match the representation of <samp class="SANS_TheSansMonoCd_W5Regular_11">0.1</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">+</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">0.2</samp>.
    Because calculations using <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp>
    values are imprecise, they’re generally a bad choice as keys in a hashed collection.
    By extension, the same reasoning applies to user-defined types that have floating-point
    field values; comparing objects of such a type for equality necessarily means
    comparing any floating-point fields, with the same potential for errors.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 这个测试失败是因为值 <samp class="SANS_TheSansMonoCd_W5Regular_11">0.3</samp> 与 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">0.1</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">+</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">0.2</samp> 的表示不完全匹配。由于使用 <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp>
    值的计算不精确，因此通常不建议将它们作为哈希集合中的键。通过扩展，这一逻辑也适用于具有浮点字段值的用户自定义类型；比较此类类型的对象是否相等时，必须比较其中的浮点字段，这样就存在错误的潜在风险。
- en: 'In a type with floating-point fields, we might be tempted to override its <samp
    class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp> method by using an approach
    similar to the <samp class="SANS_TheSansMonoCd_W5Regular_11">ApproximatelyEqual</samp>
    implementations from [Listings 5-3](#list5-3) and [5-4](#list5-4), but doing so
    would introduce two problems. First, equality is a transitive relationship between
    values: for three values <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">y</samp>, and <samp class="SANS_TheSansMonoCd_W5Regular_11">z</samp>,
    if <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp> is equal to <samp class="SANS_TheSansMonoCd_W5Regular_11">y</samp>,
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">y</samp> is equal to <samp class="SANS_TheSansMonoCd_W5Regular_11">z</samp>,
    then <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp> must be equal to <samp
    class="SANS_TheSansMonoCd_W5Regular_11">z</samp>. Implementing <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp>
    to mean *approximately* equal means the transitive relationship wouldn’t necessarily
    hold, because the difference between <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">z</samp> could be larger than
    any tolerance we define, even when <samp class="SANS_TheSansMonoCd_W5Regular_11">x.Equals(y)</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">y.Equals(z)</samp> are both
    <samp class="SANS_TheSansMonoCd_W5Regular_11">true</samp>.'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个包含浮点字段的类型中，我们可能会倾向于通过使用类似于[列表 5-3](#list5-3) 和 [5-4](#list5-4) 中的 <samp class="SANS_TheSansMonoCd_W5Regular_11">ApproximatelyEqual</samp>
    实现的方法来重写其 <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp> 方法，但这样做会引入两个问题。首先，等同性是值之间的传递关系：对于三个值
    <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp>、<samp class="SANS_TheSansMonoCd_W5Regular_11">y</samp>
    和 <samp class="SANS_TheSansMonoCd_W5Regular_11">z</samp>，如果 <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp>
    等于 <samp class="SANS_TheSansMonoCd_W5Regular_11">y</samp>，并且 <samp class="SANS_TheSansMonoCd_W5Regular_11">y</samp>
    等于 <samp class="SANS_TheSansMonoCd_W5Regular_11">z</samp>，那么 <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp>
    必须等于 <samp class="SANS_TheSansMonoCd_W5Regular_11">z</samp>。如果将 <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp>
    实现为*大致相等*，那么传递关系就不一定成立，因为 <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp>
    和 <samp class="SANS_TheSansMonoCd_W5Regular_11">z</samp> 之间的差异可能会大于我们定义的任何容差，即便
    <samp class="SANS_TheSansMonoCd_W5Regular_11">x.Equals(y)</samp> 和 <samp class="SANS_TheSansMonoCd_W5Regular_11">y.Equals(z)</samp>
    都是 <samp class="SANS_TheSansMonoCd_W5Regular_11">true</samp>。
- en: The second issue is directly related to hash codes. Recall that objects that
    compare equal should have the same hash code. Using <samp class="SANS_TheSansMonoCd_W5Regular_11">ApproximatelyEqual</samp>
    to implement <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp> could
    easily break that rule, because two *almost* equal values will still produce different
    hash codes. We could implement <samp class="SANS_TheSansMonoCd_W5Regular_11">GetHashCode</samp>
    to ignore any floating-point fields, but doing so would compromise how well our
    objects’ hash codes are distributed. It also raises the question of what to do
    about types that have only a single field that’s a floating-point value, such
    as the <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">Angle</samp>
    types we developed in [Chapter 1](chapter1.xhtml).
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个问题与哈希码直接相关。回想一下，比较相等的对象应该具有相同的哈希码。使用<samp class="SANS_TheSansMonoCd_W5Regular_11">ApproximatelyEqual</samp>来实现<samp
    class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp>可能会轻易打破这个规则，因为两个*几乎*相等的值仍然会生成不同的哈希码。我们可以实现<samp
    class="SANS_TheSansMonoCd_W5Regular_11">GetHashCode</samp>来忽略任何浮点字段，但这样做会影响我们对象的哈希码分布效果。这也引出了一个问题，即对于只有一个浮点字段的类型该怎么办，比如我们在[第1章](chapter1.xhtml)中开发的<samp
    class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp>和<samp class="SANS_TheSansMonoCd_W5Regular_11">Angle</samp>类型。
- en: Floating-point numbers and types containing floating-point values, then, don’t
    make good keys for hash tables, dictionaries, and other data structures that depend
    on the implementation of <samp class="SANS_TheSansMonoCd_W5Regular_11">GetHashCode</samp>.
    Unfortunately, C# doesn’t allow us to prevent a particular type from being used
    as a key in a hash table or similar data structure, because <samp class="SANS_TheSansMonoCd_W5Regular_11">GetHashCode</samp>
    is defined on <samp class="SANS_TheSansMonoCd_W5Regular_11">object</samp> and
    can’t be hidden. It’s up to us to make sure that the keys we use are suitable
    for that purpose.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 浮点数和包含浮点值的类型因此不适合作为哈希表、字典和其他依赖于<samp class="SANS_TheSansMonoCd_W5Regular_11">GetHashCode</samp>实现的数据结构的键。不幸的是，C#不允许我们阻止某个特定类型作为哈希表或类似数据结构中的键使用，因为<samp
    class="SANS_TheSansMonoCd_W5Regular_11">GetHashCode</samp>是定义在<samp class="SANS_TheSansMonoCd_W5Regular_11">object</samp>上的，且不能被隐藏。确保我们使用的键适合该目的完全取决于我们自己。
- en: Strings make excellent keys for hash tables, because the <samp class="SANS_TheSansMonoCd_W5Regular_11">string</samp>
    class overrides <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp> and
    <samp class="SANS_TheSansMonoCd_W5Regular_11">GetHashCode</samp> to compare the
    string contents. This is the same behavior the compiler adds for us in record
    and record struct types. Both the <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp>
    method and <samp class="SANS_TheSansMonoCd_W5Regular_11">GetHashCode</samp> are
    synthesized by the compiler, so record and record struct instances use their *value*
    for equality comparisons and for generating their hash codes. Although records
    are reference types, like strings they work very well as keys, subject to the
    caveats we’ve just discussed regarding floating-point fields.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 字符串是哈希表的绝佳键，因为<samp class="SANS_TheSansMonoCd_W5Regular_11">string</samp>类重写了<samp
    class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp>和<samp class="SANS_TheSansMonoCd_W5Regular_11">GetHashCode</samp>以比较字符串内容。这与编译器在记录（record）和记录结构（record
    struct）类型中为我们添加的行为相同。<samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp>方法和<samp
    class="SANS_TheSansMonoCd_W5Regular_11">GetHashCode</samp>是由编译器合成的，因此记录和记录结构的实例使用它们的*值*进行相等比较和生成哈希码。尽管记录是引用类型，但像字符串一样，它们作为键的表现也非常好，但仍需注意我们刚刚讨论的关于浮点字段的警告。
- en: The compiler also generates <samp class="SANS_TheSansMonoCd_W5Regular_11">operator==</samp>
    and its companion <samp class="SANS_TheSansMonoCd_W5Regular_11">operator</samp><samp
    class="SANS_TheSansMonoCd_W5Regular_11">!</samp><samp class="SANS_TheSansMonoCd_W5Regular_11">=</samp>
    for records and record structs. They follow the same general pattern we’ve used
    for <samp class="SANS_TheSansMonoCd_W5Regular_11">MusicTrack</samp>, where <samp
    class="SANS_TheSansMonoCd_W5Regular_11">operator==</samp> uses the <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp>
    method, and <samp class="SANS_TheSansMonoCd_W5Regular_11">operator</samp><samp
    class="SANS_TheSansMonoCd_W5Regular_11">!</samp><samp class="SANS_TheSansMonoCd_W5Regular_11">=</samp>
    returns the inverse of the result of <samp class="SANS_TheSansMonoCd_W5Regular_11">operator==</samp>.
    The compiler does *not* generate any of these methods for ordinary structs, which
    instead rely on the <samp class="SANS_TheSansMonoCd_W5Regular_11">ValueType</samp>
    base class common to all struct types.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 编译器还为记录类型和记录结构体生成了 <samp class="SANS_TheSansMonoCd_W5Regular_11">operator==</samp>
    及其伴随的 <samp class="SANS_TheSansMonoCd_W5Regular_11">operator</samp><samp class="SANS_TheSansMonoCd_W5Regular_11">!</samp><samp
    class="SANS_TheSansMonoCd_W5Regular_11">=</samp>。它们遵循我们为 <samp class="SANS_TheSansMonoCd_W5Regular_11">MusicTrack</samp>
    使用的相同模式，其中 <samp class="SANS_TheSansMonoCd_W5Regular_11">operator==</samp> 使用
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp> 方法，而 <samp class="SANS_TheSansMonoCd_W5Regular_11">operator</samp><samp
    class="SANS_TheSansMonoCd_W5Regular_11">!</samp><samp class="SANS_TheSansMonoCd_W5Regular_11">=</samp>
    返回 <samp class="SANS_TheSansMonoCd_W5Regular_11">operator==</samp> 结果的相反值。编译器
    *不* 为普通结构体生成这些方法，普通结构体依赖于所有结构体类型共享的 <samp class="SANS_TheSansMonoCd_W5Regular_11">ValueType</samp>
    基类。
- en: <samp class="SANS_Futura_Std_Bold_B_11">Structs and Equality</samp>
  id: totrans-165
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">结构体与相等性</samp>
- en: Since value type instances are copied by value, every value type variable is
    a distinct instance of the type, so two instances can never compare equal according
    to their identity. We need to compare their values, meaning that we compare their
    state instead. This usually involves comparing each field of one instance with
    the corresponding field of another.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 由于值类型实例是按值复制的，因此每个值类型变量都是该类型的一个独立实例，因此两个实例不能根据它们的身份相等。我们需要比较它们的值，也就是说，我们比较它们的状态。这通常涉及将一个实例的每个字段与另一个实例的相应字段进行比较。
- en: Structs implicitly inherit from the <samp class="SANS_TheSansMonoCd_W5Regular_11">System.ValueType</samp>
    class, which provides the value-based equality required for value types. By default,
    calling <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp> on a struct
    will use the <samp class="SANS_TheSansMonoCd_W5Regular_11">ValueType</samp> implementation,
    because <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp> is a virtual
    method. As [Chapter 2](chapter2.xhtml) explained, for its implementation, the
    <samp class="SANS_TheSansMonoCd_W5Regular_11">ValueType.Equals</samp> method relies
    on reflection, which provides the correct behavior for any possible struct type
    at the expense of performance. While it might not be the most efficient comparison,
    the <samp class="SANS_TheSansMonoCd_W5Regular_11">ValueType.Equals</samp> method
    uses each field’s <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp>
    method to compare the field with its companion, so it has the behavior we require.
    Similarly, <samp class="SANS_TheSansMonoCd_W5Regular_11">ValueType</samp> also
    overrides <samp class="SANS_TheSansMonoCd_W5Regular_11">GetHashCode</samp> to
    create hash codes based on a struct’s fields, ensuring that any two struct instances
    that are equal according to <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp>
    also generate identical hash codes.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 结构体隐式地继承自 <samp class="SANS_TheSansMonoCd_W5Regular_11">System.ValueType</samp>
    类，该类提供了值类型所需的基于值的相等性。默认情况下，调用结构体上的 <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp>
    将使用 <samp class="SANS_TheSansMonoCd_W5Regular_11">ValueType</samp> 的实现，因为 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp> 是一个虚方法。正如[第2章](chapter2.xhtml)所解释的，<samp
    class="SANS_TheSansMonoCd_W5Regular_11">ValueType.Equals</samp> 方法依赖于反射，这为任何可能的结构体类型提供正确的行为，尽管它牺牲了性能。虽然它可能不是最有效的比较方法，但
    <samp class="SANS_TheSansMonoCd_W5Regular_11">ValueType.Equals</samp> 方法使用每个字段的
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp> 方法将该字段与其伴随字段进行比较，因此它具有我们所需的行为。同样，<samp
    class="SANS_TheSansMonoCd_W5Regular_11">ValueType</samp> 也重写了 <samp class="SANS_TheSansMonoCd_W5Regular_11">GetHashCode</samp>，以根据结构体的字段生成哈希码，确保任何两个根据
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp> 相等的结构体实例也生成相同的哈希码。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Overriding Equals
    for Structs</samp>
  id: totrans-168
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">重写结构体的 Equals 方法</samp>
- en: Overriding the default <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">GetHashCode</samp> methods for
    struct types is common in order to address that the <samp class="SANS_TheSansMonoCd_W5Regular_11">ValueType</samp>
    implementations of those methods may not be optimal. Implementing efficient equality
    for structs follows a similar pattern as for classes, as shown in [Listing 5-18](#list5-18),
    where we create a struct to represent color values.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 对结构体类型重写默认的 <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp> 和 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">GetHashCode</samp> 方法是常见做法，因为 <samp class="SANS_TheSansMonoCd_W5Regular_11">ValueType</samp>
    实现的这些方法可能并不理想。为结构体实现高效的相等性检查遵循与类相似的模式，如[清单 5-18](#list5-18)所示，在其中我们创建一个结构体来表示颜色值。
- en: '[PRE26]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 5-18: Overriding equality
    for a Color struct</samp>'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">清单 5-18：重写 Color 结构体的相等性</samp>
- en: As we did with <samp class="SANS_TheSansMonoCd_W5Regular_11">MusicTrack</samp>
    in the previous section, we override the base class <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp>
    method and add a type-specific overload taking a <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp>
    parameter. There are subtle differences, related to <samp class="SANS_TheSansMonoCd_W5Regular_11">null</samp>,
    from the <samp class="SANS_TheSansMonoCd_W5Regular_11">MusicTrack</samp> implementations
    of those methods. As a struct type, <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp>
    instances can’t be <samp class="SANS_TheSansMonoCd_W5Regular_11">null</samp>,
    so the type-safe <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp> method
    takes its <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp> parameters
    by value rather than nullable references, and we don’t check for <samp class="SANS_TheSansMonoCd_W5Regular_11">null</samp>
    in the implementation of <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals(Color)</samp>.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在前一节中对 <samp class="SANS_TheSansMonoCd_W5Regular_11">MusicTrack</samp> 所做的那样，我们重写了基类的
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp> 方法，并添加了一个特定类型的重载方法，接受
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp> 参数。与 <samp class="SANS_TheSansMonoCd_W5Regular_11">MusicTrack</samp>
    实现方法相关的微妙差异，主要涉及 <samp class="SANS_TheSansMonoCd_W5Regular_11">null</samp>。作为一个结构体类型，<samp
    class="SANS_TheSansMonoCd_W5Regular_11">Color</samp> 实例不能为 <samp class="SANS_TheSansMonoCd_W5Regular_11">null</samp>，因此类型安全的
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp> 方法通过值而不是可空引用来传递其 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">Color</samp> 参数，并且我们不会在 <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals(Color)</samp>
    的实现中检查 <samp class="SANS_TheSansMonoCd_W5Regular_11">null</samp>。
- en: In the <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals(object?)</samp>
    override, we use a declaration pattern to cast the <samp class="SANS_TheSansMonoCd_W5Regular_11">obj</samp>
    variable to the correct type. We used a declaration pattern in [Listing 5-11](#list5-11)
    for <samp class="SANS_TheSansMonoCd_W5Regular_11">MusicTrack</samp> but later
    switched it for the simpler <samp class="SANS_TheSansMonoCd_W5Regular_11">as</samp>
    run-time cast. We can’t use <samp class="SANS_TheSansMonoCd_W5Regular_11">as</samp>
    in our struct implementation because if the cast fails, the result is <samp class="SANS_TheSansMonoCd_W5Regular_11">null</samp>,
    which can’t be assigned to a struct variable. As noted in [Chapter 2](chapter2.xhtml),
    we *can* use <samp class="SANS_TheSansMonoCd_W5Regular_11">as</samp> to cast to
    a nullable <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp>, but in
    that case the argument would match the <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp>
    method with an <samp class="SANS_TheSansMonoCd_W5Regular_11">object?</samp> parameter
    instead of our type-safe overload, making the method recursive. Applying the declaration
    pattern here avoids that issue.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 在 <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals(object?)</samp> 重写方法中，我们使用声明模式将
    <samp class="SANS_TheSansMonoCd_W5Regular_11">obj</samp> 变量转换为正确的类型。我们在[清单 5-11](#list5-11)中为
    <samp class="SANS_TheSansMonoCd_W5Regular_11">MusicTrack</samp> 使用了声明模式，但后来改用了更简单的
    <samp class="SANS_TheSansMonoCd_W5Regular_11">as</samp> 运行时转换。由于如果转换失败，结果会是 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">null</samp>，而结构体变量无法赋值为 <samp class="SANS_TheSansMonoCd_W5Regular_11">null</samp>，我们在结构体实现中不能使用
    <samp class="SANS_TheSansMonoCd_W5Regular_11">as</samp>。正如在[第2章](chapter2.xhtml)中提到的，我们*可以*使用
    <samp class="SANS_TheSansMonoCd_W5Regular_11">as</samp> 将值转换为可空的 <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp>，但在这种情况下，参数将匹配带有
    <samp class="SANS_TheSansMonoCd_W5Regular_11">object?</samp> 参数的 <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp>
    方法，而不是我们的类型安全重载，这会导致方法递归。应用声明模式可以避免这个问题。
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">GetHashCode</samp> implementation
    is identical in principle to the <samp class="SANS_TheSansMonoCd_W5Regular_11">MusicTrack</samp>
    implementation from [Listing 5-16](#list5-16).
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">GetHashCode</samp> 的实现原则上与 [Listing
    5-16](#list5-16) 中的 <samp class="SANS_TheSansMonoCd_W5Regular_11">MusicTrack</samp>
    实现相同。
- en: 'Struct types don’t allow comparison with <samp class="SANS_TheSansMonoCd_W5Regular_11">==</samp>
    by default. If we want to support such comparisons, we must define our own <samp
    class="SANS_TheSansMonoCd_W5Regular_11">operator==</samp> for the type. The equality
    operator is straightforward to implement in terms of our <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp>
    method, as shown here:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 结构体类型默认不允许使用 <samp class="SANS_TheSansMonoCd_W5Regular_11">==</samp> 进行比较。如果我们想支持这种比较，必须为该类型定义我们自己的
    <samp class="SANS_TheSansMonoCd_W5Regular_11">operator==</samp>。如下面所示，等于操作符可以通过我们的
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp> 方法轻松实现：
- en: '[PRE27]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: While <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp> is a virtual
    instance method and is overridden by <samp class="SANS_TheSansMonoCd_W5Regular_11">ValueType</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">operator==</samp> is a static method
    and therefore *can’t* be virtual. Static methods are never inherited, so these
    operators couldn’t usefully be implemented by the <samp class="SANS_TheSansMonoCd_W5Regular_11">ValueType</samp>
    class.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp> 是一个虚拟实例方法，并且被
    <samp class="SANS_TheSansMonoCd_W5Regular_11">ValueType</samp> 重写，<samp class="SANS_TheSansMonoCd_W5Regular_11">operator==</samp>
    是一个静态方法，因此 *不能* 是虚拟的。静态方法从不被继承，所以这些操作符无法由 <samp class="SANS_TheSansMonoCd_W5Regular_11">ValueType</samp>
    类有效实现。
- en: Since a <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp> variable
    can’t be <samp class="SANS_TheSansMonoCd_W5Regular_11">null</samp>, we can simply
    use the <samp class="SANS_TheSansMonoCd_W5Regular_11">left</samp> variable to
    call <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp>, passing <samp
    class="SANS_TheSansMonoCd_W5Regular_11">right</samp> as the argument to invoke
    our type-safe implementation that takes a <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp>
    parameter by value. The equality operators are therefore simpler than their equivalents
    for a class, and, more significantly, the <samp class="SANS_TheSansMonoCd_W5Regular_11">left</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">right</samp> variables won’t
    be boxed when calling <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp>.
    Notice that rather than inverting the result of <samp class="SANS_TheSansMonoCd_W5Regular_11">==</samp>,
    we invert the result of calling <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp>.
    The effect is identical in both cases, but this version of <samp class="SANS_TheSansMonoCd_W5Regular_11">!</samp><samp
    class="SANS_TheSansMonoCd_W5Regular_11">=</samp> avoids the extra indirection
    of also calling <samp class="SANS_TheSansMonoCd_W5Regular_11">operator==</samp>
    and the additional copies of the arguments it would involve.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp> 变量不能为 <samp class="SANS_TheSansMonoCd_W5Regular_11">null</samp>，我们可以简单地使用
    <samp class="SANS_TheSansMonoCd_W5Regular_11">left</samp> 变量调用 <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp>，并将
    <samp class="SANS_TheSansMonoCd_W5Regular_11">right</samp> 作为参数传递，以调用我们类型安全的实现，该实现按值传递
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp> 参数。因此，等于操作符比类的等于操作符更简单，而且，更重要的是，调用
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp> 时，<samp class="SANS_TheSansMonoCd_W5Regular_11">left</samp>
    和 <samp class="SANS_TheSansMonoCd_W5Regular_11">right</samp> 变量不会被装箱。请注意，与其反转
    <samp class="SANS_TheSansMonoCd_W5Regular_11">==</samp> 的结果，我们反转了调用 <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp>
    的结果。两种情况下效果相同，但这种版本的 <samp class="SANS_TheSansMonoCd_W5Regular_11">!</samp><samp
    class="SANS_TheSansMonoCd_W5Regular_11">=</samp> 避免了额外的间接调用，也避免了调用 <samp class="SANS_TheSansMonoCd_W5Regular_11">operator==</samp>
    及其涉及的额外参数复制。
- en: Another reason a default implementation for structs provided by <samp class="SANS_TheSansMonoCd_W5Regular_11">ValueType</samp>
    would be useless is that, as discussed earlier, an operator overload requires
    the type of at least one of its parameters to match the implementing type. We
    can’t, for instance, define our own <samp class="SANS_TheSansMonoCd_W5Regular_11">operator==</samp>
    to compare two <samp class="SANS_TheSansMonoCd_W5Regular_11">object</samp> variables
    because that would hijack the default behavior of <samp class="SANS_TheSansMonoCd_W5Regular_11">==</samp>
    for <samp class="SANS_TheSansMonoCd_W5Regular_11">object</samp> variables. Comparing
    two <samp class="SANS_TheSansMonoCd_W5Regular_11">object</samp> variables with
    <samp class="SANS_TheSansMonoCd_W5Regular_11">==</samp> *always* compares identities,
    since those variables are references. This has important consequences when an
    <samp class="SANS_TheSansMonoCd_W5Regular_11">object</samp> variable refers to
    an instance of a value type like <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp>
    that’s been boxed.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个原因是，正如前面讨论的那样，<samp class="SANS_TheSansMonoCd_W5Regular_11">ValueType</samp>为结构体提供的默认实现是无用的，因为操作符重载要求至少一个参数的类型与实现类型匹配。例如，我们不能定义自己的<samp
    class="SANS_TheSansMonoCd_W5Regular_11">operator==</samp>来比较两个<samp class="SANS_TheSansMonoCd_W5Regular_11">object</samp>变量，因为那样会劫持<samp
    class="SANS_TheSansMonoCd_W5Regular_11">==</samp>对<samp class="SANS_TheSansMonoCd_W5Regular_11">object</samp>变量的默认行为。使用<samp
    class="SANS_TheSansMonoCd_W5Regular_11">==</samp>比较两个<samp class="SANS_TheSansMonoCd_W5Regular_11">object</samp>变量时，*总是*比较标识符，因为这些变量是引用。当<samp
    class="SANS_TheSansMonoCd_W5Regular_11">object</samp>变量引用了一个被装箱的值类型实例（例如<samp
    class="SANS_TheSansMonoCd_W5Regular_11">Color</samp>）时，这一点具有重要影响。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Boxing Values and
    Comparing by Identity</samp>
  id: totrans-180
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">装箱值与通过标识符比较</samp>
- en: Values are implicitly boxed anytime we use a reference type variable to refer
    to a value type instance. Because value types have value-based equality and reference
    type variables have reference-based equality, boxing has implications for object
    identity and equality. We went to some effort to ensure that <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">==</samp> have identical behavior
    when comparing <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp> instances,
    but when we compare <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp>
    values that have been boxed, <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">==</samp> behave differently.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们使用引用类型变量来引用值类型实例时，值会隐式地被装箱。因为值类型具有基于值的相等性，而引用类型变量具有基于引用的相等性，所以装箱对对象的标识和相等性有影响。我们已经花了一些功夫，确保在比较<samp
    class="SANS_TheSansMonoCd_W5Regular_11">Color</samp>实例时，<samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp>和<samp
    class="SANS_TheSansMonoCd_W5Regular_11">==</samp>具有相同的行为，但当我们比较已装箱的<samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp>值时，<samp
    class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp>和<samp class="SANS_TheSansMonoCd_W5Regular_11">==</samp>的行为则不同。
- en: To illustrate how boxing affects equality, [Listing 5-19](#list5-19) creates
    two instances of the <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp>
    struct, but instead of having the compiler deduce the variable types as <samp
    class="SANS_TheSansMonoCd_W5Regular_11">Color</samp>, we explicitly declare them
    as <samp class="SANS_TheSansMonoCd_W5Regular_11">object</samp>, causing the values
    to be boxed. The variables aren’t equal when we use <samp class="SANS_TheSansMonoCd_W5Regular_11">==</samp>
    to compare them.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 为了说明装箱如何影响相等性，[列表 5-19](#list5-19)创建了两个<samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp>结构体实例，但不是让编译器推导变量类型为<samp
    class="SANS_TheSansMonoCd_W5Regular_11">Color</samp>，我们显式地将它们声明为<samp class="SANS_TheSansMonoCd_W5Regular_11">object</samp>，从而导致这些值被装箱。当我们用<samp
    class="SANS_TheSansMonoCd_W5Regular_11">==</samp>比较它们时，这些变量不相等。
- en: '[PRE28]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 5-19: Explicitly boxing
    values</samp>'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">列表 5-19：显式装箱值</samp>
- en: This test passes because reference variables are compared by their identity.
    These <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">y</samp>
    variables are references to different boxed <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp>
    values on the heap, approximately as shown in [Figure 5-1](#fig5-1).
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 这个测试通过了，因为引用变量是通过它们的标识符进行比较的。这些<samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp>和<samp
    class="SANS_TheSansMonoCd_W5Regular_11">y</samp>变量是指向堆上不同装箱的<samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp>值的引用，近似如[图
    5-1](#fig5-1)所示。
- en: '![](../images/Figure5-1.png)'
  id: totrans-186
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure5-1.png)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 5-1: Boxed values in
    memory</samp>'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图 5-1：内存中的框值</samp>
- en: The boxes for the two <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp>
    instances in [Figure 5-1](#fig5-1) could be anywhere on the heap; the way that
    memory is allocated is determined by the CLR. When we use <samp class="SANS_TheSansMonoCd_W5Regular_11">==</samp>
    to compare the <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp> and <samp
    class="SANS_TheSansMonoCd_W5Regular_11">y</samp> variables, the instance values
    aren’t considered. Even though <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp>
    has an overload of <samp class="SANS_TheSansMonoCd_W5Regular_11">operator==</samp>
    to allow comparisons using <samp class="SANS_TheSansMonoCd_W5Regular_11">==</samp>
    between two <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp> values,
    that custom equality implementation isn’t invoked when we compare the two <samp
    class="SANS_TheSansMonoCd_W5Regular_11">object</samp> references. This is because
    <samp class="SANS_TheSansMonoCd_W5Regular_11">operator==</samp> is a *static*
    method that requires two <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp>
    arguments, not two <samp class="SANS_TheSansMonoCd_W5Regular_11">object</samp>
    arguments. The comparison with <samp class="SANS_TheSansMonoCd_W5Regular_11">==</samp>
    therefore correctly returns <samp class="SANS_TheSansMonoCd_W5Regular_11">false</samp>,
    because the two <samp class="SANS_TheSansMonoCd_W5Regular_11">object</samp> variables
    refer to independent instances.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 在[图 5-1](#fig5-1)中，两个<samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp>实例的框可能位于堆的任何位置；内存分配的方式由CLR决定。当我们使用<samp
    class="SANS_TheSansMonoCd_W5Regular_11">==</samp>来比较<samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp>和<samp
    class="SANS_TheSansMonoCd_W5Regular_11">y</samp>变量时，实例值并不会被考虑。即使<samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp>重载了<samp
    class="SANS_TheSansMonoCd_W5Regular_11">operator==</samp>以允许使用<samp class="SANS_TheSansMonoCd_W5Regular_11">==</samp>比较两个<samp
    class="SANS_TheSansMonoCd_W5Regular_11">Color</samp>值，当我们比较两个<samp class="SANS_TheSansMonoCd_W5Regular_11">对象</samp>引用时，这个自定义的相等性实现并不会被调用。这是因为<samp
    class="SANS_TheSansMonoCd_W5Regular_11">operator==</samp>是一个*静态*方法，它需要两个<samp
    class="SANS_TheSansMonoCd_W5Regular_11">Color</samp>类型的参数，而不是两个<samp class="SANS_TheSansMonoCd_W5Regular_11">对象</samp>类型的参数。因此，使用<samp
    class="SANS_TheSansMonoCd_W5Regular_11">==</samp>的比较结果正确地返回<samp class="SANS_TheSansMonoCd_W5Regular_11">false</samp>，因为这两个<samp
    class="SANS_TheSansMonoCd_W5Regular_11">对象</samp>变量指向的是独立的实例。
- en: 'If we make the comparison using the <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp>
    method instead, the variables compare equal because the <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp>
    method is virtual:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们改为使用<samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp>方法进行比较，变量将被认为相等，因为<samp
    class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp>方法是虚拟的：
- en: '[PRE29]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp> variable used to
    invoke <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp> is an <samp
    class="SANS_TheSansMonoCd_W5Regular_11">object</samp> reference but still refers
    to an instance of <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp>,
    so here it’s our override of <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp>
    that’s called. If <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp> didn’t
    override <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp>, the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">ValueType</samp> implementation would
    be called instead. In either case, <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp>
    returns <samp class="SANS_TheSansMonoCd_W5Regular_11">true</samp> because the
    two instances of <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp> have
    exactly the same state.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 用于调用<samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp>的方法变量<samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp>是一个<samp
    class="SANS_TheSansMonoCd_W5Regular_11">对象</samp>引用，但它仍然指向一个<samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp>实例，因此这里调用的是我们重写的<samp
    class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp>方法。如果<samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp>没有重写<samp
    class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp>，那么将调用<samp class="SANS_TheSansMonoCd_W5Regular_11">ValueType</samp>的实现。无论哪种情况，<samp
    class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp>都会返回<samp class="SANS_TheSansMonoCd_W5Regular_11">true</samp>，因为这两个<samp
    class="SANS_TheSansMonoCd_W5Regular_11">Color</samp>实例具有完全相同的状态。
- en: We can think of a boxed value as an instance of a simple reference type on the
    heap that contains a copy of the value in a field with the same type as the original
    value. Since the box is on the heap, it can be referenced by more than one reference
    variable, as shown in [Listing 5-20](#list5-20).
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将装箱的值看作是堆上一个简单引用类型的实例，该实例包含一个与原始值类型相同的字段中的值副本。由于盒子位于堆上，因此可以通过多个引用变量引用它，如在[列表
    5-20](#list5-20)所示。
- en: '[PRE30]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 5-20: Two references
    to one boxed value</samp>'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">列表 5-20：两个引用指向一个装箱值</samp>
- en: In this example, <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp> is a
    reference to a boxed value, and <samp class="SANS_TheSansMonoCd_W5Regular_11">y</samp>
    is a different reference to the *same box*, illustrated in [Figure 5-2](#fig5-2).
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，<samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp> 是对装箱值的引用，而 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">y</samp> 是对 *同一个盒子* 的另一个引用，如[图 5-2](#fig5-2)所示。
- en: '![](../images/Figure5-2.png)'
  id: totrans-196
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure5-2.png)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 5-2: Adding a reference
    to an existing box</samp>'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图 5-2：向现有盒子添加引用</samp>
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">y</samp>
    variables compare equal with <samp class="SANS_TheSansMonoCd_W5Regular_11">==</samp>
    because both <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp> and <samp
    class="SANS_TheSansMonoCd_W5Regular_11">y</samp> are references to a single instance.
    The comparison with the virtual call to <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp>
    also returns <samp class="SANS_TheSansMonoCd_W5Regular_11">true</samp> because
    an instance will always compare equal with itself.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp> 和 <samp class="SANS_TheSansMonoCd_W5Regular_11">y</samp>
    变量通过 <samp class="SANS_TheSansMonoCd_W5Regular_11">==</samp> 比较相等，因为 <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp>
    和 <samp class="SANS_TheSansMonoCd_W5Regular_11">y</samp> 都是指向同一实例的引用。与虚拟调用 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp> 进行比较时，结果也会返回 <samp class="SANS_TheSansMonoCd_W5Regular_11">true</samp>，因为实例总是与自身相等。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Boxed Method Parameters</samp>
  id: totrans-199
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">装箱方法参数</samp>
- en: A value will be automatically boxed when we pass it to a method that takes an
    <samp class="SANS_TheSansMonoCd_W5Regular_11">object</samp> or other reference
    type parameter. The effects are the same as assigning directly to an <samp class="SANS_TheSansMonoCd_W5Regular_11">object</samp>
    variable, as we did in [Listing 5-19](#list5-19), but the box is less obvious
    in our code.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们将值传递给一个接受 <samp class="SANS_TheSansMonoCd_W5Regular_11">object</samp> 或其他引用类型参数的方法时，值会自动被装箱。其效果与直接将值赋给
    <samp class="SANS_TheSansMonoCd_W5Regular_11">object</samp> 变量相同，就像我们在[列表 5-19](#list5-19)中做的那样，但装箱在我们的代码中不那么显眼。
- en: Consider [Listing 5-21](#list5-21), where we pass the same value twice to the
    <samp class="SANS_TheSansMonoCd_W5Regular_11">object.ReferenceEquals</samp> method,
    which takes two <samp class="SANS_TheSansMonoCd_W5Regular_11">object</samp> parameters
    and compares them for identity equality.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑[列表 5-21](#list5-21)，在这里我们将相同的值两次传递给 <samp class="SANS_TheSansMonoCd_W5Regular_11">object.ReferenceEquals</samp>
    方法，该方法接受两个 <samp class="SANS_TheSansMonoCd_W5Regular_11">object</samp> 参数并比较它们的身份相等性。
- en: '[PRE31]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 5-21: Passing values
    as boxed arguments</samp>'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">列表 5-21：将值作为装箱参数传递</samp>
- en: This test asserts that the two arguments to <samp class="SANS_TheSansMonoCd_W5Regular_11">ReferenceEquals</samp>
    are *not* equal. Should the test pass?
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 这个测试断言传递给 <samp class="SANS_TheSansMonoCd_W5Regular_11">ReferenceEquals</samp>
    的两个参数 *不* 相等。这个测试应该通过吗？
- en: 'Yes, it should. The arguments to <samp class="SANS_TheSansMonoCd_W5Regular_11">ReferenceEquals</samp>
    are different <samp class="SANS_TheSansMonoCd_W5Regular_11">object</samp> variables.
    Passing a value type as an argument to an <samp class="SANS_TheSansMonoCd_W5Regular_11">object</samp>
    parameter boxes the value. Even though the same value is passed to both parameters,
    each argument is boxed separately, resulting in two independent boxes. The outcome
    is identical to explicitly boxing the same value into separate <samp class="SANS_TheSansMonoCd_W5Regular_11">object</samp>
    variables, like this:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 是的，应该是的。传递给 <samp class="SANS_TheSansMonoCd_W5Regular_11">ReferenceEquals</samp>
    的参数是不同的 <samp class="SANS_TheSansMonoCd_W5Regular_11">object</samp> 变量。将值类型作为参数传递给
    <samp class="SANS_TheSansMonoCd_W5Regular_11">object</samp> 参数会对该值进行装箱。即使将相同的值传递给两个参数，每个参数都会单独进行装箱，导致两个独立的盒子。其结果与显式地将相同的值装箱到不同的
    <samp class="SANS_TheSansMonoCd_W5Regular_11">object</samp> 变量中的情况相同，如下所示：
- en: '[PRE32]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: The value of <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp> is explicitly
    boxed into two separate <samp class="SANS_TheSansMonoCd_W5Regular_11">object</samp>
    references. The call to <samp class="SANS_TheSansMonoCd_W5Regular_11">ReferenceEquals</samp>
    is equivalent to <samp class="SANS_TheSansMonoCd_W5Regular_11">a</samp> <samp
    class="SANS_TheSansMonoCd_W5Regular_11">==</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">b</samp>,
    and they do *not* compare equal because they’re different objects.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp> 的值被显式装箱为两个独立的 <samp class="SANS_TheSansMonoCd_W5Regular_11">object</samp>
    引用。对 <samp class="SANS_TheSansMonoCd_W5Regular_11">ReferenceEquals</samp> 的调用等价于
    <samp class="SANS_TheSansMonoCd_W5Regular_11">a</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">==</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">b</samp>，它们*不*相等，因为它们是不同的对象。
- en: 'Compare [Listing 5-21](#list5-21) with the following, where we explicitly box
    the value to an <samp class="SANS_TheSansMonoCd_W5Regular_11">object</samp> variable
    *before* calling <samp class="SANS_TheSansMonoCd_W5Regular_11">ReferenceEquals</samp>:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 将 [清单 5-21](#list5-21) 与以下内容进行对比，其中我们在调用 <samp class="SANS_TheSansMonoCd_W5Regular_11">ReferenceEquals</samp>
    之前，显式地将值装箱为一个 <samp class="SANS_TheSansMonoCd_W5Regular_11">object</samp> 变量：
- en: '[PRE33]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: We pass the same reference for both arguments to <samp class="SANS_TheSansMonoCd_W5Regular_11">ReferenceEquals</samp>,
    so they compare equal. The call to <samp class="SANS_TheSansMonoCd_W5Regular_11">ReferenceEquals</samp>
    in this instance is identical to the expression <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">==</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp>,
    and the <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp> variable is a reference
    to a boxed <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp>, as shown
    in [Figure 5-3](#fig5-3).
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将相同的引用传递给 <samp class="SANS_TheSansMonoCd_W5Regular_11">ReferenceEquals</samp>
    的两个参数，因此它们会被比较为相等。在这种情况下，对 <samp class="SANS_TheSansMonoCd_W5Regular_11">ReferenceEquals</samp>
    的调用与表达式 <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">==</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp> 相同，且 <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp>
    变量是指向一个装箱后的 <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp> 类型的引用，如
    [图 5-3](#fig5-3) 所示。
- en: '![](../images/Figure5-3.png)'
  id: totrans-211
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure5-3.png)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 5-3: Passing an already-boxed
    value to a method</samp>'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图 5-3：将已装箱的值传递给方法</samp>
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">ReferenceEquals</samp> method
    receives two arguments, but they’re references to the same boxed value on the
    heap.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">ReferenceEquals</samp> 方法接收两个参数，但它们是指向堆上相同装箱值的引用。
- en: Quite apart from testing variables for equality, we need to be sure we understand
    where values are being boxed and whether our own code is using a boxed value.
    Boxing affects what *identity* means for a value—and while this is most apparent
    when we’re comparing two values, it also has wider implications, such as whether
    we need to be concerned about aliasing or side effects.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 除了测试变量是否相等之外，我们还需要确保理解值是在哪里被装箱的，以及我们的代码是否使用了装箱的值。装箱会影响值的*身份*，而这在我们比较两个值时最为明显，它也有更广泛的影响，例如我们是否需要关心别名化或副作用的问题。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Interface Boxes</samp>
  id: totrans-215
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">接口装箱</samp>
- en: We can refer to an object via any of the interfaces implemented by the type.
    To demonstrate, in [Listing 5-22](#list5-22) the <samp class="SANS_TheSansMonoCd_W5Regular_11">Angle</samp>
    value type implements <samp class="SANS_TheSansMonoCd_W5Regular_11">IFormattable</samp>,
    one of the common system interfaces provided by the Standard Library. In this
    code snippet, we use the interface name to refer to two instances of <samp class="SANS_TheSansMonoCd_W5Regular_11">Angle</samp>.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过类型实现的任何接口来引用一个对象。为了演示，在 [清单 5-22](#list5-22) 中，<samp class="SANS_TheSansMonoCd_W5Regular_11">Angle</samp>
    值类型实现了 <samp class="SANS_TheSansMonoCd_W5Regular_11">IFormattable</samp> 接口，这是标准库提供的常见系统接口之一。在这段代码中，我们使用接口名称引用两个
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Angle</samp> 实例。
- en: '[PRE34]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 5-22: Referring to
    a value via interface name</samp>'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">清单 5-22：通过接口名称引用一个值</samp>
- en: An *interface type* is a reference type that defines the public operations guaranteed
    to be available for a type that implements it. Variables of interface type are
    always references, regardless of the implementing type. Referring to value type
    instances via interface variables must therefore box the value, with the result
    that the comparison in [Listing 5-22](#list5-22) is effectively the same as when
    the values were boxed into <samp class="SANS_TheSansMonoCd_W5Regular_11">object</samp>
    variables in [Listing 5-19](#list5-19).
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: '*接口类型*是一个引用类型，定义了类型实现时保证可用的公共操作。接口类型的变量始终是引用类型，无论实现类型如何。因此，通过接口变量引用值类型实例时，必须将值装箱，这样在[清单
    5-22](#list5-22)中的比较实际上与[清单 5-19](#list5-19)中将值装箱到<samp class="SANS_TheSansMonoCd_W5Regular_11">object</samp>变量时的比较相同。'
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">==</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">y</samp> expression in this example,
    then, performs a reference check for equality that will compare object identities.
    The values returned from each of the <samp class="SANS_TheSansMonoCd_W5Regular_11">new
    Angle</samp> expressions will be boxed so that the references <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">y</samp> can refer to them,
    and each will refer to different boxes. The <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">y</samp> variables will compare
    equal if we use <samp class="SANS_TheSansMonoCd_W5Regular_11">x.Equals(y)</samp>,
    owing to the virtual nature of the <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp>
    method.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，<samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">==</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">y</samp>表达式执行的是引用相等性检查，将比较对象标识。每个<samp
    class="SANS_TheSansMonoCd_W5Regular_11">new Angle</samp>表达式返回的值将被装箱，以便引用<samp
    class="SANS_TheSansMonoCd_W5Regular_11">x</samp>和<samp class="SANS_TheSansMonoCd_W5Regular_11">y</samp>的变量能够引用它们，并且每个变量将引用不同的装箱对象。如果我们使用<samp
    class="SANS_TheSansMonoCd_W5Regular_11">x.Equals(y)</samp>进行比较，由于<samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp>方法的虚拟特性，<samp
    class="SANS_TheSansMonoCd_W5Regular_11">x</samp>和<samp class="SANS_TheSansMonoCd_W5Regular_11">y</samp>变量将被认为相等。
- en: <samp class="SANS_Futura_Std_Bold_B_11">Comparing Generic Variables</samp>
  id: totrans-221
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">比较泛型变量</samp>
- en: We use a generic type or method to implement functionality that works for a
    range of other types, often for both reference types and value types transparently.
    In the context of a generic type or a generic method, a given variable might represent
    either a value or a reference at different times during a program’s execution.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用泛型类型或方法实现适用于多种其他类型的功能，通常透明地适用于引用类型和值类型。在泛型类型或泛型方法的上下文中，给定的变量在程序执行的不同阶段可能表示值或引用。
- en: This poses an issue for equality comparisons of generic variables; in particular,
    using <samp class="SANS_TheSansMonoCd_W5Regular_11">==</samp> to compare variables
    typed by a generic parameter will never invoke a user-defined <samp class="SANS_TheSansMonoCd_W5Regular_11">operator==</samp>
    implementation. If a generic parameter is unconstrained, we can’t even use <samp
    class="SANS_TheSansMonoCd_W5Regular_11">==</samp> to compare two variables of
    the same generic type.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 这为泛型变量的相等性比较带来了问题；特别是，使用<samp class="SANS_TheSansMonoCd_W5Regular_11">==</samp>比较由泛型参数指定类型的变量时，永远不会调用用户定义的<samp
    class="SANS_TheSansMonoCd_W5Regular_11">operator==</samp>实现。如果泛型参数没有约束，我们甚至不能使用<samp
    class="SANS_TheSansMonoCd_W5Regular_11">==</samp>比较两个相同泛型类型的变量。
- en: <samp class="SANS_Dogma_OT_Bold_B_21">NOTE</samp>
  id: totrans-224
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: <samp class="SANS_Dogma_OT_Bold_B_21">注意</samp>
- en: '*C# v11.0 introduces a preview feature named* static abstract interface members
    *that enables you to use user-defined operators, including operator*<samp class="SANS_TheSansMonoCd_W5Regular_11">==</samp>*,
    in generic code. For more information on this feature, see* [https://learn.microsoft.com/en-us/dotnet/csharp/whats-new/tutorials/static-virtual-interface-members*.*](https://learn.microsoft.com/en-us/dotnet/csharp/whats-new/tutorials/static-virtual-interface-members)'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: '*C# v11.0引入了一个名为*静态抽象接口成员*的预览功能，它使你能够在泛型代码中使用用户定义的运算符，包括运算符*<samp class="SANS_TheSansMonoCd_W5Regular_11">==</samp>*。有关此功能的更多信息，请参见*
    [https://learn.microsoft.com/en-us/dotnet/csharp/whats-new/tutorials/static-virtual-interface-members*.*](https://learn.microsoft.com/en-us/dotnet/csharp/whats-new/tutorials/static-virtual-interface-members)'
- en: Consider the simple generic class in [Listing 5-23](#list5-23), which uses <samp
    class="SANS_TheSansMonoCd_W5Regular_11">==</samp> to compare two variables declared
    using the generic type parameter <samp class="SANS_TheSansMonoCd_W5Regular_11">T</samp>.
    As it stands, this class won’t compile.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑[清单 5-23](#list5-23)中的简单通用类，该类使用<samp class="SANS_TheSansMonoCd_W5Regular_11">==</samp>来比较使用通用类型参数<samp
    class="SANS_TheSansMonoCd_W5Regular_11">T</samp>声明的两个变量。按原样，这个类无法编译。
- en: '[PRE35]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 5-23: Generic type
    parameter comparison</samp>'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">清单 5-23：通用类型参数比较</samp>
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">Playlist</samp> is a generic class
    with a type parameter that by convention is named <samp class="SANS_TheSansMonoCd_W5Regular_11">T</samp>.
    We’d generally refer to this class as a *Playlist of T*.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">播放列表</samp>是一个具有类型参数的通用类，按照约定，类型参数通常命名为<samp
    class="SANS_TheSansMonoCd_W5Regular_11">T</samp>。我们通常将这个类称为*类型 T 的播放列表*。
- en: We can’t use <samp class="SANS_TheSansMonoCd_W5Regular_11">==</samp> to compare
    the <samp class="SANS_TheSansMonoCd_W5Regular_11">item</samp> parameter with the
    field <samp class="SANS_TheSansMonoCd_W5Regular_11">current</samp> because when
    <samp class="SANS_TheSansMonoCd_W5Regular_11">T</samp> is an unconstrained type
    parameter like this, the <samp class="SANS_TheSansMonoCd_W5Regular_11">==</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">!</samp><samp class="SANS_TheSansMonoCd_W5Regular_11">=</samp>
    operators can be used only to check instances of <samp class="SANS_TheSansMonoCd_W5Regular_11">T</samp>
    for equality or inequality with <samp class="SANS_TheSansMonoCd_W5Regular_11">null</samp>.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不能使用<samp class="SANS_TheSansMonoCd_W5Regular_11">==</samp>来比较<scode class="SANS_TheSansMonoCd_W5Regular_11">item</samp>参数和字段<samp
    class="SANS_TheSansMonoCd_W5Regular_11">current</samp>，因为当<samp class="SANS_TheSansMonoCd_W5Regular_11">T</samp>是一个没有约束的类型参数时，<samp
    class="SANS_TheSansMonoCd_W5Regular_11">==</samp>和<samp class="SANS_TheSansMonoCd_W5Regular_11">!=</samp>运算符只能用于检查<T></code>实例是否等于或不等于<samp
    class="SANS_TheSansMonoCd_W5Regular_11">null</samp>。
- en: If we add a general class constraint, or a specific base class or interface
    type constraint for <samp class="SANS_TheSansMonoCd_W5Regular_11">T</samp>, the
    comparison <samp class="SANS_TheSansMonoCd_W5Regular_11">item</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">==</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">current</samp> will compile, but
    it will always represent a reference comparison. C# has no generic constraint
    we can add for <samp class="SANS_TheSansMonoCd_W5Regular_11">T</samp> to allow
    the expression <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">==</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">y</samp> to invoke an overloaded
    <samp class="SANS_TheSansMonoCd_W5Regular_11">operator==</samp>, where <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp>
    or <samp class="SANS_TheSansMonoCd_W5Regular_11">y</samp> is typed by a generic
    parameter.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们为<samp class="SANS_TheSansMonoCd_W5Regular_11">T</samp>添加了一个通用类约束，或者为其指定了基类或接口类型约束，<samp
    class="SANS_TheSansMonoCd_W5Regular_11">item</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">==</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">current</samp>将可以编译，但它将始终表示引用比较。C#没有可以为<samp
    class="SANS_TheSansMonoCd_W5Regular_11">T</samp>添加的通用约束，使得表达式<samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">==</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">y</samp>调用一个重载的<samp
    class="SANS_TheSansMonoCd_W5Regular_11">operator==</samp>，其中<samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp>或<samp
    class="SANS_TheSansMonoCd_W5Regular_11">y</samp>由通用参数类型化。
- en: We *can* invoke the <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp>
    method, which will call an overridden implementation if one exists on whatever
    type <samp class="SANS_TheSansMonoCd_W5Regular_11">T</samp> represents at run
    time. The <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp> method is
    defined on the <samp class="SANS_TheSansMonoCd_W5Regular_11">object</samp> base
    class and so is available to any variable, regardless of its actual type. However,
    when the type of <samp class="SANS_TheSansMonoCd_W5Regular_11">T</samp> is a value
    type, the argument may be boxed by calling the <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp>
    method that takes <samp class="SANS_TheSansMonoCd_W5Regular_11">object?</samp>
    as its parameter.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 我们*可以*调用 <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp> 方法，如果存在重写的实现，它将在运行时根据
    <samp class="SANS_TheSansMonoCd_W5Regular_11">T</samp> 所代表的类型被调用。<samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp>
    方法定义在 <samp class="SANS_TheSansMonoCd_W5Regular_11">object</samp> 基类中，因此对于任何变量都可用，无论其实际类型如何。然而，当
    <samp class="SANS_TheSansMonoCd_W5Regular_11">T</samp> 的类型是值类型时，调用接受 <samp class="SANS_TheSansMonoCd_W5Regular_11">object?</samp>
    参数的 <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp> 方法时，参数可能会被装箱。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Generic Code and
    the Equals Method</samp>
  id: totrans-233
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">泛型代码与 Equals 方法</samp>
- en: In [Listing 5-11](#list5-11), we implemented equality for our <samp class="SANS_TheSansMonoCd_W5Regular_11">MusicTrack</samp>
    type so that instances of them compare by value rather than by identity. In [Listing
    5-18](#list5-18), we did the same for the <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp>
    struct to override the <samp class="SANS_TheSansMonoCd_W5Regular_11">ValueType.Equals</samp>
    method. To make the comparison more efficient, we added a type-safe overload of
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp> for both types by
    taking the parameter as <samp class="SANS_TheSansMonoCd_W5Regular_11">MusicTrack</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp>, respectively,
    rather than <samp class="SANS_TheSansMonoCd_W5Regular_11">object</samp>, thereby
    preventing the argument from being boxed.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [清单 5-11](#list5-11) 中，我们为 <samp class="SANS_TheSansMonoCd_W5Regular_11">MusicTrack</samp>
    类型实现了相等比较，使得它们的实例通过值而非标识进行比较。在 [清单 5-18](#list5-18) 中，我们为 <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp>
    结构体做了同样的事情，重写了 <samp class="SANS_TheSansMonoCd_W5Regular_11">ValueType.Equals</samp>
    方法。为了提高比较效率，我们为这两种类型分别添加了类型安全的 <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp>
    重载，参数类型为 <samp class="SANS_TheSansMonoCd_W5Regular_11">MusicTrack</samp> 和 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">Color</samp>，而不是 <samp class="SANS_TheSansMonoCd_W5Regular_11">object</samp>，从而避免了装箱。
- en: In the current implementations of <samp class="SANS_TheSansMonoCd_W5Regular_11">MusicTrack</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp>, however, their
    type-safe overloads of <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp>
    won’t be used if called using a generic type parameter variable. When <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp>
    is called using a generic variable, the virtual method with an <samp class="SANS_TheSansMonoCd_W5Regular_11">object?</samp>
    parameter is called by default. For the <samp class="SANS_TheSansMonoCd_W5Regular_11">MusicTrack</samp>
    class, that merely results in an extra run-time cast, but for the <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp>
    struct, the parameter will be boxed to <samp class="SANS_TheSansMonoCd_W5Regular_11">object</samp>
    and then unboxed again to compare <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp>’s
    properties.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在当前的 <samp class="SANS_TheSansMonoCd_W5Regular_11">MusicTrack</samp> 和 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">Color</samp> 实现中，如果使用泛型类型参数变量调用 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp>，其类型安全的重载将不会被使用。当使用泛型变量调用
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp> 时，默认会调用带有 <samp class="SANS_TheSansMonoCd_W5Regular_11">object?</samp>
    参数的虚拟方法。对于 <samp class="SANS_TheSansMonoCd_W5Regular_11">MusicTrack</samp> 类，这只会导致额外的运行时类型转换，但对于
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp> 结构体，参数会被装箱成 <samp class="SANS_TheSansMonoCd_W5Regular_11">object</samp>，然后再拆箱以比较
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp> 的属性。
- en: To demonstrate, [Listing 5-24](#list5-24) uses <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp>
    as a type argument for the generic <samp class="SANS_TheSansMonoCd_W5Regular_11">HashSet</samp>
    collection type. The <samp class="SANS_TheSansMonoCd_W5Regular_11">HashSet< T
    >.Contains</samp> method uses a combination of <samp class="SANS_TheSansMonoCd_W5Regular_11">GetHashCode</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp> to determine whether
    any item in the collection matches the <samp class="SANS_TheSansMonoCd_W5Regular_11">orange</samp>
    argument.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 为了演示，[列表 5-24](#list5-24)将<samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp>作为泛型<samp
    class="SANS_TheSansMonoCd_W5Regular_11">HashSet</samp>集合类型的类型参数。<samp class="SANS_TheSansMonoCd_W5Regular_11">HashSet<
    T >.Contains</samp>方法使用<samp class="SANS_TheSansMonoCd_W5Regular_11">GetHashCode</samp>和<samp
    class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp>的组合来确定集合中是否有任何项与<samp class="SANS_TheSansMonoCd_W5Regular_11">orange</samp>参数匹配。
- en: '[PRE36]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 5-24: Searching a collection
    of Color values</samp>'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">列表 5-24: 搜索Color值集合</samp>'
- en: The test passes, but the <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals(object?)</samp>
    method will be used, because the <samp class="SANS_TheSansMonoCd_W5Regular_11">HashSet.Contains</samp>
    implementation has no way of knowing that <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp>
    implements a type-safe overload of <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp>
    that takes a <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp> parameter
    directly. This matters for <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp>
    because it’s a struct, and so every comparison will box the argument to an <samp
    class="SANS_TheSansMonoCd_W5Regular_11">object</samp> reference. If the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">HashSet</samp> contains a large number
    of elements, that boxing could well represent many unnecessary copies of <samp
    class="SANS_TheSansMonoCd_W5Regular_11">Color</samp>.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 测试通过，但将使用<samp class="SANS_TheSansMonoCd_W5Regular_11">Equals(object?)</samp>方法，因为<samp
    class="SANS_TheSansMonoCd_W5Regular_11">HashSet.Contains</samp>的实现无法知道<samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp>实现了一个类型安全的<samp
    class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp>重载，该重载直接接受一个<samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp>参数。这对于<samp
    class="SANS_TheSansMonoCd_W5Regular_11">Color</samp>很重要，因为它是一个结构体，因此每次比较都会将参数装箱为一个<samp
    class="SANS_TheSansMonoCd_W5Regular_11">object</samp>引用。如果<samp class="SANS_TheSansMonoCd_W5Regular_11">HashSet</samp>包含大量元素，那么这种装箱可能会导致许多不必要的<samp
    class="SANS_TheSansMonoCd_W5Regular_11">Color</samp>副本。
- en: The same would be true of a <samp class="SANS_TheSansMonoCd_W5Regular_11">HashSet</samp>
    containing <samp class="SANS_TheSansMonoCd_W5Regular_11">MusicTrack</samp> elements,
    and although the impact is a little less costly, it’s still an unnecessary inefficiency.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 对于包含<samp class="SANS_TheSansMonoCd_W5Regular_11">MusicTrack</samp>元素的<samp
    class="SANS_TheSansMonoCd_W5Regular_11">HashSet</samp>也是如此，尽管影响稍微小一些，但仍然是一种不必要的低效。
- en: To have generic code prefer our type-safe <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp>
    over the more general implementation inherited from <samp class="SANS_TheSansMonoCd_W5Regular_11">object</samp>,
    our types must implement the <samp class="SANS_TheSansMonoCd_W5Regular_11">IEquatable<
    T ></samp> interface.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让泛型代码优先选择我们类型安全的<samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp>而不是继承自<samp
    class="SANS_TheSansMonoCd_W5Regular_11">object</samp>的更通用实现，我们的类型必须实现<samp class="SANS_TheSansMonoCd_W5Regular_11">IEquatable<
    T ></samp>接口。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">The IEquatable<T>
    Interface</samp>
  id: totrans-242
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">IEquatable<T>接口</samp>
- en: When we implement the <samp class="SANS_TheSansMonoCd_W5Regular_11">IEquatable<
    T ></samp> interface on any class or struct, we’re signaling to generic code that
    the type has a public type-safe implementation of <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp>.
    The <samp class="SANS_TheSansMonoCd_W5Regular_11">IEquatable< T ></samp> interface
    specifies that the type represented by <samp class="SANS_TheSansMonoCd_W5Regular_11">T</samp>
    contains an implementation of <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp>
    taking a <samp class="SANS_TheSansMonoCd_W5Regular_11">T</samp> as its parameter.
    Generic code such as <samp class="SANS_TheSansMonoCd_W5Regular_11">HashSet< T
    ></samp> can detect that a generic type implements <samp class="SANS_TheSansMonoCd_W5Regular_11">IEquatable<
    T ></samp> and will use the type-specific overload of <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp>
    if it’s available. [Listing 5-25](#list5-25) shows how our <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp>
    struct would implement the <samp class="SANS_TheSansMonoCd_W5Regular_11">IEquatable<
    T ></samp> interface.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 5-25: The IEquatable</samp><
    T > <samp class="SANS_Futura_Std_Book_Oblique_I_11">interface</samp>'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
- en: This <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp> method is identical
    to the original type-safe method from [Listing 5-18](#list5-18); the difference
    is that <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp> indicates the
    presence of that overload by explicitly implementing <samp class="SANS_TheSansMonoCd_W5Regular_11">IEquatable<
    Color></samp>. Now when we use a <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp>
    as the element type for a <samp class="SANS_TheSansMonoCd_W5Regular_11">HashSet</samp>
    or other generic collection, any comparison using <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp>
    will use our type-safe implementation and avoid the need to box the argument.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
- en: This works because generic collections like <samp class="SANS_TheSansMonoCd_W5Regular_11">HashSet</samp>
    don’t invoke <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp> directly;
    instead, they defer the comparison to a helper class named <samp class="SANS_TheSansMonoCd_W5Regular_11">EqualityComparer<
    T ></samp>, which internally selects a type-specific <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp>
    method if <samp class="SANS_TheSansMonoCd_W5Regular_11">T</samp> implements the
    <samp class="SANS_TheSansMonoCd_W5Regular_11">IEquatable< T ></samp> interface.
    If <samp class="SANS_TheSansMonoCd_W5Regular_11">T</samp> doesn’t implement the
    interface, the virtual <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals(object?)</samp>
    is used instead.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
- en: We can use the <samp class="SANS_TheSansMonoCd_W5Regular_11">EqualityComparer</samp>
    class in our own generic code to automatically select the best available implementation
    of the <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp> method for
    a generic parameter type variable. [Listing 5-26](#list5-26) shows the usual pattern
    for checking equality via an <samp class="SANS_TheSansMonoCd_W5Regular_11">EqualityComparer</samp>
    object.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 5-26: Equality using
    the EqualityComparer</samp>< T > <samp class="SANS_Futura_Std_Book_Oblique_I_11">class</samp>'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">EqualityComparer< T >.Default</samp>
    static property returns an implementation of the standard <samp class="SANS_TheSansMonoCd_W5Regular_11">IEqualityComparer<
    T ></samp> interface with the appropriate behavior for the <samp class="SANS_TheSansMonoCd_W5Regular_11">T</samp>
    type parameter. When <samp class="SANS_TheSansMonoCd_W5Regular_11">T</samp> implements
    <samp class="SANS_TheSansMonoCd_W5Regular_11">IEquatable< T ></samp>, the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">Default</samp> property returns an implementation
    of <samp class="SANS_TheSansMonoCd_W5Regular_11">IEqualityComparer< T ></samp>
    that uses the type-specific overload of the <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp>
    method.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
- en: Besides <samp class="SANS_TheSansMonoCd_W5Regular_11">HashSet</samp>, the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">Dictionary</samp> collection and some
    LINQ algorithms use <samp class="SANS_TheSansMonoCd_W5Regular_11">IEqualityComparer<
    T ></samp> to define equality between elements. They can all be given a specific
    <samp class="SANS_TheSansMonoCd_W5Regular_11">IEqualityComparer< T ></samp> implementation,
    so we can provide our own implementation of it to customize that behavior. We’ll
    use this technique in [Chapter 8](chapter8.xhtml) to modify the behavior of the
    <samp class="SANS_TheSansMonoCd_W5Regular_11">SequenceEqual</samp> method.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">EqualityComparer< T ></samp>
    class is designed for generic code but can be useful when equality comparisons
    need to be made in the most general and efficient manner possible. One such situation
    is in code generated by the compiler.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Compiler-Generated Equality</samp>
  id: totrans-254
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The compiler itself is capable of synthesizing a correct and complete implementation
    of equality for some types. The code generated by the compiler uses the same techniques
    we’ve been exploring. In this section, we’ll look at examples to better appreciate
    what the compiler is prepared to generate on our behalf, even for something as
    fundamental as equality comparison of variables.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Records and Record
    Structs</samp>
  id: totrans-256
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Records and record structs give us a compact way of creating a type that has
    value semantics built in. Records are syntactically different from both classes
    and structs, but in the CIL they’re just classes with some compiler-generated
    features, including overrides of the <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">GetHashCode</samp> methods.
    Similarly, record structs are structs in the compiled code and have most of the
    same compiler-provided features as records.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
- en: The notable exception is that the compiler implements a <samp class="SANS_TheSansMonoCd_W5Regular_11">Clone</samp>
    method for records, but not for record structs. <samp class="SANS_TheSansMonoCd_W5Regular_11">Clone</samp>
    emulates copying a record instance by value to support non-destructive mutation,
    which we examined in [Chapter 4](chapter4.xhtml). Since record structs are natively
    copied by value, they have no need for a <samp class="SANS_TheSansMonoCd_W5Regular_11">Clone</samp>
    method.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
- en: Both records and record structs implement <samp class="SANS_TheSansMonoCd_W5Regular_11">IEquatable<
    T ></samp>, and the compiler-generated type-specific overload of the <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp>
    method compares each field of the type, exactly as we did earlier in <samp class="SANS_TheSansMonoCd_W5Regular_11">MusicTrack</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp>. The <samp class="SANS_TheSansMonoCd_W5Regular_11">GetHashCode</samp>
    method implementation uses all the fields to provide well-distributed hash codes.
    All this is in contrast to plain structs, where the default value-based equality
    behavior is provided by a common base class, <samp class="SANS_TheSansMonoCd_W5Regular_11">ValueType</samp>.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
- en: 'This simple <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp> type
    is implemented as a positional record and demonstrates admirably how compact a
    record definition can be:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: This positional syntax for a record causes the compiler to create three properties
    for <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp>, each with the
    same name and type as the respective positional parameters defined for the type.
    The compiler also provides a public constructor with those three parameters to
    initialize the three property values. This positional syntax can be used for records
    and record structs.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Inside Record Equality</samp>
  id: totrans-263
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: All records are classes, but they have value-based equality semantics, courtesy
    of the implementation of the <samp class="SANS_TheSansMonoCd_W5Regular_11">IEquatable<
    T ></samp> interface provided automatically by the compiler. The <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp>
    methods shown in [Listing 5-27](#list5-27) are almost—but not quite—the same as
    those generated for the <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp>
    record by the compiler.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 5-27: Equality implementation
    generated for a record</samp>'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
- en: The compiler-generated type-safe <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp>
    method can *directly* access the backing fields for the <samp class="SANS_TheSansMonoCd_W5Regular_11">Red</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Green</samp>, and <samp class="SANS_TheSansMonoCd_W5Regular_11">Blue</samp>
    properties and thus avoids the extra method calls shown here for reading the property
    values. Note how the <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp>
    method uses the <samp class="SANS_TheSansMonoCd_W5Regular_11">EqualityComparer<
    T ></samp> class to compare each value, so if the type of any property implements
    <samp class="SANS_TheSansMonoCd_W5Regular_11">IEquatable< T ></samp>, the type-safe
    implementation of <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp>
    will be used.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
- en: Records can, by default, inherit from other records, so equality isn’t quite
    as simple as comparing each object’s fields. The <samp class="SANS_TheSansMonoCd_W5Regular_11">other</samp>
    parameter for <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp> could
    in that case refer to an instance of a more derived record. Checking for equality
    of objects that could have different run-time types requires extra care. In most
    cases, objects of different types aren’t equal, which is why we use <samp class="SANS_TheSansMonoCd_W5Regular_11">GetType</samp>
    on the second line of the <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals(Color?)</samp>
    method in [Listing 5-27](#list5-27).
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
- en: Our <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp> record is sealed
    and doesn’t inherit from another record. Therefore, checking the type is redundant
    because the <samp class="SANS_TheSansMonoCd_W5Regular_11">other</samp> parameter
    can’t refer to anything other than an instance of <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp>.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
- en: Since the <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp> record
    is sealed and has no base types, we should consider making it a record struct.
    Record structs compile down to struct definitions, which can’t be inherited or
    have <samp class="SANS_TheSansMonoCd_W5Regular_11">null</samp> values, making
    their internals simpler. The type-safe <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp>
    method for a record struct type doesn’t check for <samp class="SANS_TheSansMonoCd_W5Regular_11">null</samp>
    or whether the types match but is otherwise the same as for a record.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
- en: In addition to implementations of the <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">GetHashCode</samp> methods,
    the compiler generates <samp class="SANS_TheSansMonoCd_W5Regular_11">operator==</samp>
    and a corresponding <samp class="SANS_TheSansMonoCd_W5Regular_11">operator</samp><samp
    class="SANS_TheSansMonoCd_W5Regular_11">!</samp><samp class="SANS_TheSansMonoCd_W5Regular_11">=</samp>
    for records and record structs. The implementation of <samp class="SANS_TheSansMonoCd_W5Regular_11">operator==</samp>
    invokes the <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp> method,
    so record variables exhibit value-based equality when they’re compared with <samp
    class="SANS_TheSansMonoCd_W5Regular_11">==</samp>, rather than the default identity-based
    comparison that classes have. We confirm this behavior for our <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp>
    record in [Listing 5-28](#list5-28).
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 除了<samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp>和<samp class="SANS_TheSansMonoCd_W5Regular_11">GetHashCode</samp>方法的实现外，编译器还会为记录和记录结构生成<samp
    class="SANS_TheSansMonoCd_W5Regular_11">operator==</samp>和相应的<samp class="SANS_TheSansMonoCd_W5Regular_11">operator</samp><samp
    class="SANS_TheSansMonoCd_W5Regular_11">!</samp><samp class="SANS_TheSansMonoCd_W5Regular_11">=</samp>。<samp
    class="SANS_TheSansMonoCd_W5Regular_11">operator==</samp>的实现会调用<samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp>方法，因此，当记录变量使用<samp
    class="SANS_TheSansMonoCd_W5Regular_11">==</samp>进行比较时，它们会表现出基于值的相等性，而不是类的默认基于标识的比较。我们在[示例
    5-28](#list5-28)中验证了这一行为对于<Color>记录的表现。
- en: '[PRE41]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 5-28: Comparing records
    with</samp> =='
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">示例 5-28：使用</samp> == <samp class="SANS_Futura_Std_Book_Oblique_I_11">比较记录</samp>
- en: Here we see that two <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp>
    variables compare equal, because even though they’re definitely not two references
    to a single instance, the state of the instances is the same.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们看到两个<samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp>变量比较相等，因为尽管它们显然不是对同一个实例的两个引用，但实例的状态是相同的。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Custom Implementations for
    Record Equality</samp>
  id: totrans-275
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">记录相等性自定义实现</samp>
- en: 'The compiler will normally generate at least two versions of <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp>
    for a record or a record struct: one taking an <samp class="SANS_TheSansMonoCd_W5Regular_11">object</samp>
    parameter (or <samp class="SANS_TheSansMonoCd_W5Regular_11">object?</samp> within
    a nullable context) and the other implementing the <samp class="SANS_TheSansMonoCd_W5Regular_11">IEquatable<
    T ></samp> interface, which performs the comparison of each instance’s fields.
    The version taking an <samp class="SANS_TheSansMonoCd_W5Regular_11">object</samp>
    parameter casts its argument to the required type and invokes the type-specific
    overload if the cast is successful, as we did for the <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp>
    record in [Listing 5-27](#list5-27). We can provide our own implementation of
    the type-safe <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp> method
    for a record or record struct type, in which case the compiler uses our implementation
    instead of generating one. If we do so, we should implement our own <samp class="SANS_TheSansMonoCd_W5Regular_11">GetHashCode</samp>
    to match, which will also replace the compiler-generated implementation.'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 编译器通常会为记录或记录结构生成至少两个版本的<samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp>方法：一个接受<samp
    class="SANS_TheSansMonoCd_W5Regular_11">object</samp>参数（或在可为空的上下文中为<samp class="SANS_TheSansMonoCd_W5Regular_11">object?</samp>），另一个实现<samp
    class="SANS_TheSansMonoCd_W5Regular_11">IEquatable< T ></samp>接口，用于比较每个实例的字段。接受<samp
    class="SANS_TheSansMonoCd_W5Regular_11">object</samp>参数的版本将其参数转换为所需类型，并在转换成功时调用类型特定的重载方法，正如我们在[示例
    5-27](#list5-27)中对<Color>记录所做的那样。如果我们提供了自己类型安全的<samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp>方法实现，编译器将使用我们的实现而不是生成一个。如果这样做，我们还应该实现自己的<samp
    class="SANS_TheSansMonoCd_W5Regular_11">GetHashCode</samp>方法，以确保与之匹配，这将替代编译器生成的实现。
- en: 'However, we can’t provide our own implementation of <samp class="SANS_TheSansMonoCd_W5Regular_11">operator==</samp>
    or <samp class="SANS_TheSansMonoCd_W5Regular_11">operator</samp><samp class="SANS_TheSansMonoCd_W5Regular_11">!</samp><samp
    class="SANS_TheSansMonoCd_W5Regular_11">=</samp> for comparing two record or record
    struct instances. If we attempt to do so, the compiler gives us an error:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">op_Equality</samp> is the name
    of the static method to which the compiler translates <samp class="SANS_TheSansMonoCd_W5Regular_11">operator==</samp>.
    The name for <samp class="SANS_TheSansMonoCd_W5Regular_11">operator</samp><samp
    class="SANS_TheSansMonoCd_W5Regular_11">!</samp><samp class="SANS_TheSansMonoCd_W5Regular_11">=</samp>
    is <samp class="SANS_TheSansMonoCd_W5Regular_11">op_Inequality</samp>, and the
    compiler always provides both methods, preventing us from defining our own.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
- en: 'We should almost always accept the default implementation of equality for records
    and record structs, as the compiler-generated code is both correct and efficient.
    However, if we need to customize the behavior of equality for a record or record
    struct, we need only override the type-safe <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp>
    method. Each of the other equality methods, including the overridden <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp>
    method taking an <samp class="SANS_TheSansMonoCd_W5Regular_11">object</samp> parameter,
    ultimately calls the type-specific overload to perform the actual comparison.
    The compiler’s implementation of the <samp class="SANS_TheSansMonoCd_W5Regular_11">==</samp>
    operator is identical to that shown here for <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp>,
    so if we alter the behavior of the <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp>
    method, that behavior is also reflected in the implementations of <samp class="SANS_TheSansMonoCd_W5Regular_11">operator==</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">operator</samp><samp class="SANS_TheSansMonoCd_W5Regular_11">!</samp><samp
    class="SANS_TheSansMonoCd_W5Regular_11">=</samp> provided by the compiler:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: When we define a positional record or positional record struct, the compiler
    synthesizes a complete type, along with methods to support equality comparisons.
    The compiler generates code to support equality for nullable value types, too,
    although in a very different way.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Equality for Nullable
    Values</samp>
  id: totrans-283
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We denote a nullable value type by using the special <samp class="SANS_TheSansMonoCd_W5Regular_11">?</samp>
    notation on a value type variable. The compiler translates a nullable value type
    to an instance of the system type <samp class="SANS_TheSansMonoCd_W5Regular_11">Nullable<
    T ></samp>, where <samp class="SANS_TheSansMonoCd_W5Regular_11">T</samp> is the
    declared type for the variable. <samp class="SANS_TheSansMonoCd_W5Regular_11">Nullable<
    T ></samp> is a struct, instances of which may have a value of type <samp class="SANS_TheSansMonoCd_W5Regular_11">T</samp>
    or no value (represented by <samp class="SANS_TheSansMonoCd_W5Regular_11">null</samp>).
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
- en: Comparing nullable value type variables differs from comparing references, which
    may be <samp class="SANS_TheSansMonoCd_W5Regular_11">null</samp>, because for
    two nullable value type variables, we must always compare each underlying value
    if one exists. To illustrate, consider [Listing 5-29](#list5-29), where we compare
    two nullable value type variables, one with a value and the other <samp class="SANS_TheSansMonoCd_W5Regular_11">null</samp>.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 5-29: Comparing nullable
    values</samp>'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
- en: Both <samp class="SANS_TheSansMonoCd_W5Regular_11">fg</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">bg</samp>
    in this example are nullable, but while <samp class="SANS_TheSansMonoCd_W5Regular_11">fg</samp>
    has a <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp> value, <samp
    class="SANS_TheSansMonoCd_W5Regular_11">bg</samp> is <samp class="SANS_TheSansMonoCd_W5Regular_11">null</samp>.
    The test passes because the values aren’t equal. Two nullable value type variables
    are equal if both have no value, or if both have a value and those values are
    themselves equal. What’s interesting about this example is that while <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp>
    has a custom <samp class="SANS_TheSansMonoCd_W5Regular_11">operator==</samp> to
    compare two <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp> values,
    it accepts two *non*-nullable <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp>
    parameters. Since <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp> is
    a struct, <samp class="SANS_TheSansMonoCd_W5Regular_11">null</samp> isn’t a valid
    value for it, although <samp class="SANS_TheSansMonoCd_W5Regular_11">null</samp>
    is a valid value for a *nullable* <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp>.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">Nullable< T ></samp> struct
    doesn’t have an overloaded <samp class="SANS_TheSansMonoCd_W5Regular_11">operator==</samp>
    of its own. When the compiler encounters code comparing two nullable value types,
    or a nullable value type and a normal value type instance, it rewrites the comparison
    by inserting the implementation from the corresponding operator definition for
    the underlying—non-nullable—value type. This process is known as *lifting* the
    operator. Since one or both of those arguments may have *no* value, the lifted
    operation makes the additional checks for the existence of a value before finally
    comparing those values by using the original, non-nullable comparison.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
- en: For this reason, if <samp class="SANS_TheSansMonoCd_W5Regular_11">T</samp> has
    no <samp class="SANS_TheSansMonoCd_W5Regular_11">operator==</samp> defined, the
    comparison of two <samp class="SANS_TheSansMonoCd_W5Regular_11">T?</samp> variables
    fails to compile, because the compiler has no operator implementation to lift.
    The <samp class="SANS_TheSansMonoCd_W5Regular_11">lifted_op_Equality</samp> method
    in [Listing 5-30](#list5-30) is fictional but demonstrates the basic algorithm
    for the lifted equality comparison operation.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 5-30: The lifted equality
    operator</samp>'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
- en: 'The compiler doesn’t generate a new method for this algorithm but simply inserts
    logic inline in our code, replacing the original comparison using <samp class="SANS_TheSansMonoCd_W5Regular_11">==</samp>
    in [Listing 5-29](#list5-29) with the equivalent of the following:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: The logic of this code is essentially identical to that in [Listing 5-30](#list5-30),
    but it’s a single expression and thus easier for the compiler to inline. The reason
    for using <samp class="SANS_TheSansMonoCd_W5Regular_11">GetValueOrDefault</samp>
    instead of the <samp class="SANS_TheSansMonoCd_W5Regular_11">Value</samp> property
    is that the latter needs to check that a valid value exists and will throw an
    exception if it doesn’t. <samp class="SANS_TheSansMonoCd_W5Regular_11">GetValueOrDefault</samp>
    is therefore slightly more efficient.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
- en: Although nullable value types are instances of the special system type <samp
    class="SANS_TheSansMonoCd_W5Regular_11">Nullable< T ></samp>, the same functionality
    couldn’t be implemented by <samp class="SANS_TheSansMonoCd_W5Regular_11">Nullable<
    T ></samp> simply having its own <samp class="SANS_TheSansMonoCd_W5Regular_11">operator==</samp>
    to perform the comparison. The purpose of lifting the underlying type’s <samp
    class="SANS_TheSansMonoCd_W5Regular_11">operator==</samp> is to ensure that when
    both variables have a value, they’re compared exactly as if they were non-nullable
    types—that is, direct instances of the original value type. An <samp class="SANS_TheSansMonoCd_W5Regular_11">operator==</samp>
    implementation for <samp class="SANS_TheSansMonoCd_W5Regular_11">Nullable< T ></samp>
    would need to use <samp class="SANS_TheSansMonoCd_W5Regular_11">==</samp> to compare
    two instances of the generic type <samp class="SANS_TheSansMonoCd_W5Regular_11">T</samp>,
    which, as we know, isn’t allowed.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
- en: By lifting the underlying type’s <samp class="SANS_TheSansMonoCd_W5Regular_11">operator==</samp>,
    the compiler ensures that the correct behavior is maintained and that values compare
    the same way whether or not they’re nullable types.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
- en: The compiler also generates code inline to support comparisons of value tuple
    variables, introduced in C# v7.0, although the process for value tuples is a little
    different.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Value Tuples and
    Equality</samp>
  id: totrans-299
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*Tuples* are a common feature of many modern programming languages to gather
    several related values together into a single lightweight data structure. A tuple
    in C# is similar to a struct with all public fields and no member methods, although
    the syntax for declaring and using a tuple is different from doing so for such
    a struct.'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
- en: Compiler support for tuple types supersedes the <samp class="SANS_TheSansMonoCd_W5Regular_11">System.Tuple</samp>
    class introduced in .NET v4.0\. The more modern feature, available since C# v7.0,
    is known as a *value tuple*. Value tuples are underpinned by a system type named
    <samp class="SANS_TheSansMonoCd_W5Regular_11">ValueTuple</samp>, but that type
    isn’t intended to be used directly. Instead, when we want to relate several fields
    together without the overhead of adding a full user-defined class or struct, we
    use the value tuple syntax.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
- en: Value tuples enjoy sophisticated support from the compiler, both in how variables
    are declared and in how they can be used. [Listing 5-31](#list5-31) shows an example
    of comparing value tuple variables for equality.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  id: totrans-303
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 5-31: Comparing value
    tuple variables for equality</samp>'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
- en: We’re declaring two tuple variables, <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">y</samp>, by surrounding multiple
    values with parentheses; this syntax is common in several languages with tuple
    support and probably familiar to many programmers. However, although the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">x</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">y</samp>
    variables have the same *values*, they look distinctly different from each other
    in their declarations. In particular, <samp class="SANS_TheSansMonoCd_W5Regular_11">y</samp>
    gives names to its component parts, whereas <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp>
    doesn’t. The test determines that <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">y</samp> are equal and passes.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Dogma_OT_Bold_B_21">NOTE</samp>
  id: totrans-306
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*Support for using* <samp class="SANS_TheSansMonoCd_W5Regular_11">==</samp>
    *to compare value tuples was introduced in C# v7.3, shortly after value tuples
    were introduced.*'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
- en: When we compare value tuple variables with <samp class="SANS_TheSansMonoCd_W5Regular_11">==</samp>,
    the compiler generates code to compare each element of the value tuple with the
    corresponding element in the other value tuple. The elements of a value tuple
    are public fields, not properties, meaning that reading or writing a value accesses
    the field directly. As with nullable values, the compiler rewrites our comparison
    expression by inserting the code to compare the fields of <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">y</samp> directly.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
- en: The CIL extract in [Listing 5-32](#list5-32) shows just the comparison of the
    tuples’ first component in [Listing 5-31](#list5-31).
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  id: totrans-310
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 5-32: New-style value
    tuple comparison CIL</samp>'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
- en: The compiler directly loads the fields by using the <samp class="SANS_TheSansMonoCd_W5Regular_11">ldfld</samp>
    instruction and then compares those values by using the <samp class="SANS_TheSansMonoCd_W5Regular_11">bne</samp>
    instruction, which stands for *break if not equal*. The <samp class="SANS_TheSansMonoCd_W5Regular_11">bne</samp>
    instruction is a companion to the <samp class="SANS_TheSansMonoCd_W5Regular_11">ceq</samp>
    instruction we encountered in [Listing 5-1](#list5-1). Whereas <samp class="SANS_TheSansMonoCd_W5Regular_11">ceq</samp>
    pushes its result onto the evaluation stack, <samp class="SANS_TheSansMonoCd_W5Regular_11">bne</samp>
    jumps to the specified label (<samp class="SANS_TheSansMonoCd_W5Regular_11">IL_0042</samp>
    in this example) if the values being compared are *not* equal; otherwise, processing
    continues from the next instruction following <samp class="SANS_TheSansMonoCd_W5Regular_11">bne</samp>.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
- en: The fact that we’re attempting to compare a simple tuple with a tuple that has
    named elements is irrelevant. The generated code doesn’t attempt to use the names
    we’ve given the fields. It’s comparing only their values, so the result of <samp
    class="SANS_TheSansMonoCd_W5Regular_11">x</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">==</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">y</samp> is <samp class="SANS_TheSansMonoCd_W5Regular_11">true</samp>.
    We could compare <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp> with a
    tuple using different names with the same result; only the types and values of
    the fields matter.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
- en: The names we give the tuple components are a purely compile-time construct for
    *our* convenience. In fact, the names we give the <samp class="SANS_TheSansMonoCd_W5Regular_11">y</samp>
    variable’s components never even make it into the compiled code.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
- en: As with the generated code for comparing <samp class="SANS_TheSansMonoCd_W5Regular_11">Nullable<
    T ></samp> values, the compiler will inject code to call a user-defined <samp
    class="SANS_TheSansMonoCd_W5Regular_11">operator==</samp> if needed. You can see
    this in [Listing 5-33](#list5-33), which shows the CIL for the comparison of the
    second component of our tuples, a <samp class="SANS_TheSansMonoCd_W5Regular_11">string</samp>
    field.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  id: totrans-316
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 5-33: The call to a
    user-defined equality operator inserted by the compiler</samp>'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
- en: Instead of the <samp class="SANS_TheSansMonoCd_W5Regular_11">bne</samp> instruction
    used for the <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp> field, the
    compiler has synthesized a call to <samp class="SANS_TheSansMonoCd_W5Regular_11">op_Equality</samp>,
    exactly as if we’d handwritten the code. Fields of a value tuple are compared
    in the order in which they appear, so the first field of one is compared with
    the first field of the corresponding variable, and so on.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
- en: This approach differs from records, which use the <samp class="SANS_TheSansMonoCd_W5Regular_11">EqualityComparer</samp>
    protocol instead of <samp class="SANS_TheSansMonoCd_W5Regular_11">==</samp> to
    compare their fields. For records, the compiler generates the right methods on
    the underlying class or struct type to implement equality. When we compare two
    records with <samp class="SANS_TheSansMonoCd_W5Regular_11">==</samp>, we’re invoking
    the <samp class="SANS_TheSansMonoCd_W5Regular_11">op_Equality</samp> method generated
    for the record type. That method compares each field of the record in turn by
    using its <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp> method.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
- en: For value tuples, as with nullable value types, the compiler generates the comparison
    code *inline*, effectively replacing the comparison of two tuples with a direct
    comparison of the component fields of each tuple type. If a component field of
    the tuple has an <samp class="SANS_TheSansMonoCd_W5Regular_11">operator==</samp>
    defined for it, that implementation is used, but like <samp class="SANS_TheSansMonoCd_W5Regular_11">Nullable<
    T ></samp>, the <samp class="SANS_TheSansMonoCd_W5Regular_11">ValueTuple</samp>
    type used to implement value tuples has no <samp class="SANS_TheSansMonoCd_W5Regular_11">operator==</samp>
    of its own.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
- en: If the fields can’t be compared using either <samp class="SANS_TheSansMonoCd_W5Regular_11">ceq</samp>
    or <samp class="SANS_TheSansMonoCd_W5Regular_11">operator==</samp>, our code using
    <samp class="SANS_TheSansMonoCd_W5Regular_11">==</samp> to compare the value tuple
    fails to compile. The <samp class="SANS_TheSansMonoCd_W5Regular_11">ValueTuple</samp>
    type does override the <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp>
    method and also implements the <samp class="SANS_TheSansMonoCd_W5Regular_11">IEquatable<
    T ></samp> interface. Therefore, if a field has no <samp class="SANS_TheSansMonoCd_W5Regular_11">operator==</samp>,
    we can still compare value tuple variables with <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp>,
    which in turn will call each field’s <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp>
    method, safe in the knowledge that <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp>
    is always there, whatever type we’re using.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Summary</samp>
  id: totrans-322
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*All animals are equal, but some animals are more equal than others.*'
  id: totrans-323
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  id: totrans-324
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: —George Orwell, *Animal Farm*
  id: totrans-325
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: For such a simple expression, comparing two variables for equality can represent
    a wide variety of behavior, from using a simple built-in equality check with <samp
    class="SANS_TheSansMonoCd_W5Regular_11">ceq</samp> in the compiled code all the
    way up to the compiler automatically generating the correct code to perform a
    comparison. We’ve looked at how references are compared, how overriding the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp> method and <samp class="SANS_TheSansMonoCd_W5Regular_11">==</samp>
    operator can affect behavior, and how the compiler can generate code to make sure
    the “right thing” happens.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
- en: For many programmers, using <samp class="SANS_TheSansMonoCd_W5Regular_11">==</samp>
    to compare variables comes more naturally than calling the <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp>
    method. For the built-in numeric types, using <samp class="SANS_TheSansMonoCd_W5Regular_11">==</samp>
    is always more efficient, although with the binary floating-point types <samp
    class="SANS_TheSansMonoCd_W5Regular_11">float</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp>,
    we have to be cautious of using either approach. Notwithstanding that, the cost
    of calling a method is very small, but it can never be as fast as the intrinsic
    <samp class="SANS_TheSansMonoCd_W5Regular_11">ceq</samp> instruction.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
- en: The purpose of examining these effects in such intricate detail is to demonstrate
    that we can’t necessarily take for granted what such a simple expression does
    when a program runs. The run-time complexity of any expression may be hidden from
    view, perhaps masked by the compiler choosing an unexpected method overload or
    override instead of a direct comparison between two variables. Certainly the performance
    costs in such examples are small, but they might be significant in “hot” paths
    through a program.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
- en: Boxing value type instances can have a significant effect on performance, not
    only because boxing generates copies of the value, but also because those copies
    are put on the heap and add pressure to the garbage collector. The standard <samp
    class="SANS_TheSansMonoCd_W5Regular_11">IEquatable< T ></samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">EqualityComparer<
    T ></samp> types help us avoid many cases where boxing would otherwise be required,
    especially in generic code.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
- en: We should always be aware of those circumstances where the compiler generates
    code on our behalf, but in the case of equality comparisons, the compiler goes
    to quite a lot of trouble to make sure that code is as efficient as possible.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
