- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">5</samp> <samp class="SANS_Dogma_OT_Bold_B_11">TYPES
    OF EQUALITY</samp>
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '![](../images/opener-img.png)'
  prefs: []
  type: TYPE_IMG
- en: Programs frequently compare variables to see if their values are equal, although
    this operation is often overlooked because it’s done implicitly. Every type inherits
    the <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp> method from the
    <samp class="SANS_TheSansMonoCd_W5Regular_11">object</samp> base class, so given
    any two values <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp> and <samp
    class="SANS_TheSansMonoCd_W5Regular_11">y</samp>, the expression <samp class="SANS_TheSansMonoCd_W5Regular_11">x.Equals(y)</samp>
    is always valid.
  prefs: []
  type: TYPE_NORMAL
- en: C# also provides <samp class="SANS_TheSansMonoCd_W5Regular_11">==</samp>, or
    the *equals-equals* operator, for explicitly checking equality of two values.
    Using <samp class="SANS_TheSansMonoCd_W5Regular_11">==</samp> for comparisons
    differs from using the <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp>
    method in multiple ways. In this chapter, we’ll look at why C# supports two techniques
    for equality comparison and how each is affected by the differences between types.
  prefs: []
  type: TYPE_NORMAL
- en: 'We’ll explore the following:'
  prefs: []
  type: TYPE_NORMAL
- en: How the differences between comparisons using the <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp>
    method versus <samp class="SANS_TheSansMonoCd_W5Regular_11">==</samp> affect our
    programs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What support the compiler provides for comparisons, and what we must provide
    ourselves
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Why equality comparisons and hash codes are so closely related
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When we need to customize equality comparisons for our own types
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How a variable’s type affects equality behavior
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We’ll take a forensic approach to see how the compiler treats equality for different
    types and explore why there’s more to the topic of equality than just <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">==</samp>. Having more than
    one way to compare values underscores just how important this most basic comparison
    is. First, let’s look at how equality works for the built-in types.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Built-in Equality</samp>
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this section, we’ll look at the basics of equality comparisons between C#’s
    built-in types—including integers and floating-point numbers, reference variables,
    and arrays—and how some built-in types override the default behavior of equality.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Dogma_OT_Bold_B_21">NOTE</samp>
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*The convention* equals-equals*, or* double-equals *as it’s sometimes known,
    is used by several languages to distinguish the comparison for equality from the
    assignment operator* <samp class="SANS_TheSansMonoCd_W5Regular_11">=</samp>*,
    which is just* equals*. JavaScript has a third variation,* equals-equals-equals*,
    to check that two variables have the same type* and *value.*'
  prefs: []
  type: TYPE_NORMAL
- en: Because every type in C# inherits the <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp>
    method from <samp class="SANS_TheSansMonoCd_W5Regular_11">object</samp>, we can
    compare any two variables with that method. However, using <samp class="SANS_TheSansMonoCd_W5Regular_11">==</samp>
    to compare variables of the built-in types is more efficient and may even result
    in different behavior than using <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp>,
    as you’ll soon see.
  prefs: []
  type: TYPE_NORMAL
- en: Equality comparisons using <samp class="SANS_TheSansMonoCd_W5Regular_11">==</samp>
    are baked into the CLR for all the intrinsic types—that is, all the numeric types
    except <samp class="SANS_TheSansMonoCd_W5Regular_11">decimal</samp> (which has
    built-in compiler support but isn’t a native CLR type), the <samp class="SANS_TheSansMonoCd_W5Regular_11">char</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">bool</samp> types, and references.
    The CLR has a built-in instruction to compare two intrinsic values, so we can
    always compare those values with <samp class="SANS_TheSansMonoCd_W5Regular_11">==</samp>,
    and it’s as efficient as it could possibly be.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Whole Numbers</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The built-in *integral* types—<samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">short</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">long</samp>,
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">byte</samp>—represent whole
    numbers, and the <samp class="SANS_TheSansMonoCd_W5Regular_11">char</samp> type
    represents UTF-16 characters. They all have the same behavior for the purposes
    of equality comparison. Values of <samp class="SANS_TheSansMonoCd_W5Regular_11">bool</samp>
    type, while not strictly speaking numeric values, are compared the same way too.
    [Listing 5-1](#list5-1) compares two integer values by using the <samp class="SANS_TheSansMonoCd_W5Regular_11">==</samp>
    operator.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 5-1: Built-in numeric
    comparison</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here, we copy the value of <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp>
    and assign it to <samp class="SANS_TheSansMonoCd_W5Regular_11">y</samp> so that
    the two variables have identical values. The result is that they compare equal.
    If we look at the CIL generated by the compiler, we see how these built-in types
    get special support at run time:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: CIL instructions all follow a similar low-level format. Each line has a label
    in the format <samp class="SANS_TheSansMonoCd_W5Regular_11">L_</samp><samp class="SANS_TheSansMonoCd_W5Regular_11">0</samp><samp
    class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">XXX</samp>, followed by the instruction
    itself and any arguments it needs. The first instruction, <samp class="SANS_TheSansMonoCd_W5Regular_11">ldc.i4.s</samp>,
    pushes its argument, the value <samp class="SANS_TheSansMonoCd_W5Regular_11">10</samp>,
    onto the evaluation stack ❶. The next instruction, <samp class="SANS_TheSansMonoCd_W5Regular_11">stloc.0</samp>,
    has no arguments but pops the value at the top of the evaluation stack into the
    variable at location <samp class="SANS_TheSansMonoCd_W5Regular_11">0</samp>, which,
    as the decompiler helpfully tells us in a comment, is the <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp>
    variable. The outcome of these first two lines is that the <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp>
    variable is assigned the value <samp class="SANS_TheSansMonoCd_W5Regular_11">10</samp>.
  prefs: []
  type: TYPE_NORMAL
- en: Next, the previously stored value of <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp>
    is loaded and then stored in <samp class="SANS_TheSansMonoCd_W5Regular_11">y</samp>
    ❷. Then, the values of both <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">y</samp> are pushed back onto
    the evaluation stack so they can be interpreted by the next instruction ❸. Lastly,
    the built-in instruction <samp class="SANS_TheSansMonoCd_W5Regular_11">ceq</samp>
    compares the two values on the top of the evaluation stack for equality ❹. The
    <samp class="SANS_TheSansMonoCd_W5Regular_11">ceq</samp> instruction corresponds
    directly with the <samp class="SANS_TheSansMonoCd_W5Regular_11">==</samp> comparison
    between two built-in values.
  prefs: []
  type: TYPE_NORMAL
- en: The way the comparison using <samp class="SANS_TheSansMonoCd_W5Regular_11">ceq</samp>
    is performed is up to the JIT compiler, which translates CIL to machine code at
    run time, but we can think of it as a bitwise comparison between two numeric values.
    If they compare equal, the integer <samp class="SANS_TheSansMonoCd_W5Regular_11">1</samp>,
    interpreted as the Boolean value <samp class="SANS_TheSansMonoCd_W5Regular_11">true</samp>,
    is pushed onto the evaluation stack; otherwise, a <samp class="SANS_TheSansMonoCd_W5Regular_11">0</samp>
    is pushed and interpreted as <samp class="SANS_TheSansMonoCd_W5Regular_11">false</samp>.
  prefs: []
  type: TYPE_NORMAL
- en: The Boolean result is passed as the first argument to the <samp class="SANS_TheSansMonoCd_W5Regular_11">Assert.That</samp>
    method (not shown in the CIL listing). The test passes because <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">y</samp> have the same numeric
    value.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Floating-Point Values</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The same <samp class="SANS_TheSansMonoCd_W5Regular_11">ceq</samp> instruction
    is used when we compare <samp class="SANS_TheSansMonoCd_W5Regular_11">float</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp> values with the
    <samp class="SANS_TheSansMonoCd_W5Regular_11">==</samp> operator. However, for
    floating-point numbers, this method of comparison doesn’t necessarily behave as
    we might expect. In C#, <samp class="SANS_TheSansMonoCd_W5Regular_11">float</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp> values are represented
    in a binary format defined by the Standard for Floating-Point Arithmetic published
    by the Institute of Electrical and Electronics Engineers (IEEE). The IEEE-754
    standard specifies a fixed precision for those types, with the result that many
    numbers can’t be represented exactly.
  prefs: []
  type: TYPE_NORMAL
- en: When a number has no exact representation, it’s rounded to the nearest number
    that can be exactly represented. The next nearest representable number may be
    relatively larger or smaller than the original value. The difference between two
    neighboring exact representations is proportional to the magnitude of those numbers,
    so the rounding difference of a very large number will generally be much greater
    than that for a very small number. Calculations with multiple numbers that have
    been rounded will compound the resulting rounding error, a problem that isn’t
    restricted to either very large or very small numbers. [Listing 5-2](#list5-2)
    compares two <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp> values
    that we might intuitively expect to be equal.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 5-2: A simple floating-point
    calculation</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: This test fails because none of the constant values can be represented exactly
    in the format of a <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp>.
    The values given to <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp> and
    <samp class="SANS_TheSansMonoCd_W5Regular_11">y</samp> will be rounded to the
    nearest representable value. On top of that, the result of the addition has an
    inexact representation and so is rounded again, producing a value that differs
    from the value assigned to <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp>.
    The test for equality between <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">y</samp> fails because the values
    differ in their least significant digits.
  prefs: []
  type: TYPE_NORMAL
- en: 'Subtracting one floating-point number from another can also produce unexpected
    results: if the two numbers are nearly equal, the result will have values only
    in those least significant places, which is exactly where rounding will be noticeable.
    The consequence is that some or all of the significant digits in the result may
    be lost, a problem sometimes called *cancellation*.'
  prefs: []
  type: TYPE_NORMAL
- en: Rounding and cancellation issues are inherent in the IEEE-754 representation
    of floating-point values and not specific to C#. It’s possible to alleviate some
    of the problems that arise from them, however, depending on exactly what we want
    to achieve.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Mitigating the Limitations
    of Rounding and Cancellation</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The magnitude of rounding is predictable, as it’s directly related to the precision
    of the binary representation. *Precision* here means the number of binary digits
    that can be stored in the type. Importantly, that means any number without an
    exact representation in a given type will always round the same way for the same
    type.
  prefs: []
  type: TYPE_NORMAL
- en: The compounded error caused by repeated calculations is harder to predict, and
    the order of operations in a calculation can significantly affect the result.
    Performing the same sequence of operations twice might even produce different
    results, depending on factors such as optimization and the location of the result
    being stored. A complete analysis of the different approaches to comparing floating-point
    numbers is far too large a topic to cover here, but in essence, rather than comparing
    floating-point numbers for exact equality, we can provide an implementation that
    determines whether two numbers are approximately equal.
  prefs: []
  type: TYPE_NORMAL
- en: One approach is to compare whether two numbers are equal within a certain number
    of decimal places, as shown in [Listing 5-3](#list5-3).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 5-3: A simple approximate
    comparison of floating-point numbers</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: We use the <samp class="SANS_TheSansMonoCd_W5Regular_11">Math.Round</samp> method
    to determine whether two values are equal within an absolute number of decimal
    places—seven digits, in this example. We might also consider passing the number
    of required decimal places as a parameter rather than relying on a hard-coded
    constant. Either way, this is a quick and simple method for comparing floating-point
    values. The disadvantage is that it’s insensitive to differences smaller than
    the number of decimal places we’ve specified and inaccurate when comparing very
    large numbers.
  prefs: []
  type: TYPE_NORMAL
- en: 'A second approach is to find out whether the difference between two numbers
    is smaller than a certain tolerance, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: This <samp class="SANS_TheSansMonoCd_W5Regular_11">ApproximatelyEqual</samp>
    method returns <samp class="SANS_TheSansMonoCd_W5Regular_11">true</samp> if the
    absolute difference between two floating-point numbers is smaller than a predefined
    tolerance, but we need to define a sensible value for the <samp class="SANS_TheSansMonoCd_W5Regular_11">Tolerance</samp>.
    Doing so isn’t straightforward, because the difference between two floating-point
    values can vary according to their magnitude. [Listing 5-4](#list5-4) uses a value
    for tolerance that is weighted according to the magnitude of the smaller of the
    numbers being compared.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 5-4: Approximate comparison
    using a weighted tolerance</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: We’ve added a <samp class="SANS_TheSansMonoCd_W5Regular_11">Tolerance</samp>
    constant to represent how sensitive we want our comparison to be, although we
    don’t use its unqualified value in the comparison. The rounding error for very
    large values has a far greater magnitude than the error for very small numbers,
    and our tolerance needs to be sensitive to that. Instead, we scale the tolerance
    according to the numbers being compared. We use the smaller of the two values
    for scaling because that’s probably where we’re most sensitive to the rounding
    error. As a compromise to avoid multiplying by 0, if the smallest value is smaller
    than <samp class="SANS_TheSansMonoCd_W5Regular_11">Tolerance</samp>, we scale
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Tolerance</samp> by itself, which
    might cost us some precision in comparing tiny values.
  prefs: []
  type: TYPE_NORMAL
- en: The value chosen for <samp class="SANS_TheSansMonoCd_W5Regular_11">Tolerance</samp>
    here is sensitive enough to be able to distinguish differences within around 25
    decimal places when the values are close to 0\. When the values are closer to
    1.0, the scaling means that differences can be detected within 15 or 16 decimal
    places, and the sensitivity decreases as the size of the values increases. This
    approach to determining equality between floating-point numbers isn’t universally
    suitable, and specific applications may require a much more refined implementation.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Using Alternative Number Representations</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: We must always keep in mind that floating-point numbers aren’t real numbers
    in the mathematical sense, inasmuch as many real numbers can’t be expressed as
    a floating-point value. Real numbers have infinite precision, but computer memory
    is finite, so the fixed and limited precision of <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">float</samp> values is a compromise.
  prefs: []
  type: TYPE_NORMAL
- en: 'Whether the imprecision of floating-point values matters will depend on our
    objective. One alternative is to use a different representation, such as the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">decimal</samp> type that’s represented
    in *decimal* rather than binary and has a greater precision than a <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp>.
    In practice, a <samp class="SANS_TheSansMonoCd_W5Regular_11">decimal</samp> can
    represent more real numbers exactly, because it has a greater number of significant
    digits with which to represent them. This means <samp class="SANS_TheSansMonoCd_W5Regular_11">decimal</samp>
    values are less prone to rounding. However, each type has its own trade-offs,
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">decimal</samp> isn’t a general-purpose
    type: it’s intended for calculations that are most naturally represented in decimal,
    such as financial calculations. The representation of a <samp class="SANS_TheSansMonoCd_W5Regular_11">decimal</samp>
    has a smaller range than either <samp class="SANS_TheSansMonoCd_W5Regular_11">float</samp>
    or <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp>, so the largest
    positive and negative values are smaller than either <samp class="SANS_TheSansMonoCd_W5Regular_11">float</samp>
    or <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp> can represent.
    Another consideration is that a <samp class="SANS_TheSansMonoCd_W5Regular_11">decimal</samp>
    value requires more memory than a <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp>.'
  prefs: []
  type: TYPE_NORMAL
- en: As an example of the practical implications of choosing between <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">decimal</samp>, consider the
    trigonometry methods in the <samp class="SANS_TheSansMonoCd_W5Regular_11">Math</samp>
    class, such as <samp class="SANS_TheSansMonoCd_W5Regular_11">Sin</samp> and <samp
    class="SANS_TheSansMonoCd_W5Regular_11">Cos</samp>, which take <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp>
    as their parameter and don’t provide overloads taking <samp class="SANS_TheSansMonoCd_W5Regular_11">decimal</samp>
    values. If our code uses these methods, we can’t substitute <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp>
    for <samp class="SANS_TheSansMonoCd_W5Regular_11">decimal</samp>, because the
    <samp class="SANS_TheSansMonoCd_W5Regular_11">decimal</samp> type is specifically
    designed for monetary values and thus can’t represent the results of trigonometric
    operations.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Handling Invalid Numbers</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Another consequence of working with <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">float</samp> values is that
    some operations can produce a <samp class="SANS_TheSansMonoCd_W5Regular_11">NaN</samp>
    (not a number) result, which has *no* numerical representation. When we’re using
    <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp> or <samp class="SANS_TheSansMonoCd_W5Regular_11">float</samp>
    values, we need to make sure we correctly identify when the result of a calculation
    is <samp class="SANS_TheSansMonoCd_W5Regular_11">NaN</samp>, because <samp class="SANS_TheSansMonoCd_W5Regular_11">NaN</samp>
    is viral: any calculation involving <samp class="SANS_TheSansMonoCd_W5Regular_11">NaN</samp>
    produces <samp class="SANS_TheSansMonoCd_W5Regular_11">NaN</samp> as its result.
    We would get a <samp class="SANS_TheSansMonoCd_W5Regular_11">NaN</samp>, for example,
    if we tried to divide 0.0 by 0.0.'
  prefs: []
  type: TYPE_NORMAL
- en: We might expect that we could identify a <samp class="SANS_TheSansMonoCd_W5Regular_11">NaN</samp>
    with a direct comparison using <samp class="SANS_TheSansMonoCd_W5Regular_11">==</samp>,
    as in [Listing 5-5](#list5-5).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 5-5: Comparing NaNs</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: 'Dividing 0.0 by 0.0 certainly produces a <samp class="SANS_TheSansMonoCd_W5Regular_11">NaN</samp>,
    so many programmers would expect this equality test with <samp class="SANS_TheSansMonoCd_W5Regular_11">NaN</samp>
    to pass, but it doesn’t. The IEEE-754 standard states that two <samp class="SANS_TheSansMonoCd_W5Regular_11">NaN</samp>
    values don’t compare equal, so this test’s failure is correct behavior. Instead,
    C# provides the <samp class="SANS_TheSansMonoCd_W5Regular_11">IsNaN</samp> static
    method, which we use like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'As of C# v8.0, we can use a constant pattern to make the comparison more naturally:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'The compiler translates the pattern expression into <samp class="SANS_TheSansMonoCd_W5Regular_11">double.IsNaN(x)</samp>,
    so there’s no comparison using either <samp class="SANS_TheSansMonoCd_W5Regular_11">==</samp>
    or <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp>. The <samp class="SANS_TheSansMonoCd_W5Regular_11">IsNaN</samp>
    method will always give us the correct result. It also highlights one important
    difference between comparing floating-point values with <samp class="SANS_TheSansMonoCd_W5Regular_11">==</samp>
    and using the <samp class="SANS_TheSansMonoCd_W5Regular_11">double.Equals</samp>
    method: the <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp> method
    compares floating-point values with <samp class="SANS_TheSansMonoCd_W5Regular_11">ceq</samp>,
    but, unlike the <samp class="SANS_TheSansMonoCd_W5Regular_11">==</samp> operator,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp> also calls <samp class="SANS_TheSansMonoCd_W5Regular_11">IsNaN</samp>
    when the values are *not* equal. Consider the following test, where we compare
    two <samp class="SANS_TheSansMonoCd_W5Regular_11">NaN</samp> values by using the
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp> method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: This test passes because, according to the <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp>
    method, <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp> and <samp
    class="SANS_TheSansMonoCd_W5Regular_11">float</samp> values compare equal when
    the values are exactly equal or are both <samp class="SANS_TheSansMonoCd_W5Regular_11">NaN</samp>.
    The result of <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp> for
    floating-point numbers may therefore differ from the result of using <samp class="SANS_TheSansMonoCd_W5Regular_11">==</samp>,
    which doesn’t compare the results of <samp class="SANS_TheSansMonoCd_W5Regular_11">IsNaN</samp>.
    Both <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">==</samp>
    ultimately make a strict comparison of <samp class="SANS_TheSansMonoCd_W5Regular_11">float</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp> values using <samp
    class="SANS_TheSansMonoCd_W5Regular_11">ceq</samp>, so we shouldn’t rely on using
    either approach to compare floating-point numbers, because the result might not
    be what we expect.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Dogma_OT_Bold_B_21">NOTE</samp>
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*Some calculations can result in positive or negative* infinity*, represented
    as double.PositiveInfinity and double.NegativeInfinity, respectively. While either
    value may be an incorrect result, infinite values aren’t usually considered* invalid
    *in the same way as NaN. We can compare a value with double.PositiveInfinity or
    double.NegativeInfinity in a constant pattern by using the is keyword, but values
    can also be directly compared using* <samp class="SANS_TheSansMonoCd_W5Regular_11">==</samp>
    *with either kind of infinity.*'
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Reference Equality</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As [Chapter 2](chapter2.xhtml) explained, a reference is either <samp class="SANS_TheSansMonoCd_W5Regular_11">null</samp>
    or an opaque handle to an object on the heap. An object can have several references
    to it, and two references to the same object compare equal. Every object instance
    has a unique identity, and the value of a non-<samp class="SANS_TheSansMonoCd_W5Regular_11">null</samp>
    reference is the identity of the object to which it refers. To tell whether two
    references refer to the same object or different instances, then, we use an identity
    comparison.
  prefs: []
  type: TYPE_NORMAL
- en: We might also be interested in whether a reference is <samp class="SANS_TheSansMonoCd_W5Regular_11">null</samp>,
    so let’s look at the mechanics of comparing one reference with either another
    reference or the <samp class="SANS_TheSansMonoCd_W5Regular_11">null</samp> reference.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Comparing Two References</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: If <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">y</samp>
    are both references to the same object, they have the same identity and so compare
    equal via either <samp class="SANS_TheSansMonoCd_W5Regular_11">==</samp> or <samp
    class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp>. If they refer to different
    objects, even if those objects have the same state, <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">y</samp> won’t compare equal.
    In [Listing 5-6](#list5-6) we use <samp class="SANS_TheSansMonoCd_W5Regular_11">==</samp>
    to compare two reference variables.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 5-6: Comparing references</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: 'These <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">y</samp>
    reference variables aren’t equal because they refer to different objects, even
    though both objects have the same state. Rather than assigning constant values
    to two variables as we did in [Listing 5-1](#list5-1), we’re creating new objects
    on the heap, and the variables are references to those objects. When we examine
    the generated CIL, on the last line we can see that the two references are compared
    for equality by using the same <samp class="SANS_TheSansMonoCd_W5Regular_11">ceq</samp>
    instruction as in [Listing 5-1](#list5-1):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">newobj</samp> instruction
    creates a new instance of a type and stores a reference to it on the evaluation
    stack. We create two instances of <samp class="SANS_TheSansMonoCd_W5Regular_11">MusicTrack</samp>
    on the heap, since <samp class="SANS_TheSansMonoCd_W5Regular_11">MusicTrack</samp>
    is a class, and store references to them in the <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">y</samp> variables, respectively.
    Since <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">y</samp>
    refer to different instances, the variables have different *values* and thus aren’t
    equal when compared using <samp class="SANS_TheSansMonoCd_W5Regular_11">ceq</samp>.
  prefs: []
  type: TYPE_NORMAL
- en: As far as the <samp class="SANS_TheSansMonoCd_W5Regular_11">ceq</samp> instruction
    is concerned, at run time a reference is just a sequence of bits, in much the
    same way as a number is represented as a sequence of bits. The <samp class="SANS_TheSansMonoCd_W5Regular_11">ceq</samp>
    instruction merely compares two bit patterns to determine whether they match.
    Two references to different object instances on the heap have different bit patterns,
    so they don’t compare equal.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Comparing with the null Reference</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The value of a reference variable is either a reference to an object on the
    heap or <samp class="SANS_TheSansMonoCd_W5Regular_11">null</samp>. We can use
    <samp class="SANS_TheSansMonoCd_W5Regular_11">==</samp> to compare any reference
    with <samp class="SANS_TheSansMonoCd_W5Regular_11">null</samp> to determine whether
    it refers to an object. If the reference refers to an object, as in [Listing 5-7](#list5-7),
    the reference isn’t equal to <samp class="SANS_TheSansMonoCd_W5Regular_11">null</samp>.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 5-7: Comparing a reference
    with null</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: 'This comparison also uses the built-in <samp class="SANS_TheSansMonoCd_W5Regular_11">ceq</samp>
    instruction:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">null</samp> reference is a
    constant value pushed onto the evaluation stack by the <samp class="SANS_TheSansMonoCd_W5Regular_11">ldnull</samp>
    instruction; <samp class="SANS_TheSansMonoCd_W5Regular_11">null</samp> doesn’t
    have a type of its own but can be implicitly converted to *any* reference type.
    When we assign <samp class="SANS_TheSansMonoCd_W5Regular_11">null</samp> to a
    reference variable or pass it as an argument to a method, it’s converted automatically
    to the type of the target variable. Here we can compare <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp>
    with <samp class="SANS_TheSansMonoCd_W5Regular_11">null</samp> because the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">null</samp> reference is compatible with
    the <samp class="SANS_TheSansMonoCd_W5Regular_11">MusicTrack</samp> reference
    type.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Comparing Array Variables</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: C# arrays are always reference types, so comparing array variables works the
    same way as comparing references. C# arrays are the built-in syntax for declaring
    and using a sequence of elements that are always allocated on the heap. An array
    variable is a reference to the elements of the array. In [Listing 5-8](#list5-8),
    we create two arrays with identical elements and use <samp class="SANS_TheSansMonoCd_W5Regular_11">==</samp>
    to compare them.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 5-8: Implicitly initializing
    and comparing two arrays</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: The compiler deduces the size of each array based on the values we use to initialize
    them. The two arrays have identical elements but compare unequal because comparing
    two arrays with <samp class="SANS_TheSansMonoCd_W5Regular_11">==</samp> performs
    a reference comparison using the intrinsic <samp class="SANS_TheSansMonoCd_W5Regular_11">ceq</samp>
    instruction. The <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp> and <samp
    class="SANS_TheSansMonoCd_W5Regular_11">y</samp> variables in [Listing 5-8](#list5-8)
    are references to different arrays and thus don’t compare equal, so the test passes.
  prefs: []
  type: TYPE_NORMAL
- en: When we compare two array variables, the comparison doesn’t consider the array
    elements; it uses only the identity of the two array variables, so two array references
    compare equal only if they refer to the *same* array instance. To check whether
    two arrays have the same elements, we must manually compare each individual element
    or use a library facility such as <samp class="SANS_TheSansMonoCd_W5Regular_11">System.Enumerable.SequenceEqual</samp>.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Strings and Value
    Equality</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Although <samp class="SANS_TheSansMonoCd_W5Regular_11">string</samp> variables
    are references, when we compare them we’re usually more concerned with whether
    their contents are the same rather than whether they refer to the same <samp class="SANS_TheSansMonoCd_W5Regular_11">string</samp>
    instance.
  prefs: []
  type: TYPE_NORMAL
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">string</samp> class overloads
    the default behavior of <samp class="SANS_TheSansMonoCd_W5Regular_11">==</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp> to give strings
    value-like semantics. Comparing strings with either <samp class="SANS_TheSansMonoCd_W5Regular_11">==</samp>
    or <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp> performs a value-based
    rather than reference-based comparison. It’s possible to have more than one reference
    to a single <samp class="SANS_TheSansMonoCd_W5Regular_11">string</samp> instance
    on the heap, and those references will still compare equal. However, it’s also
    possible to have two independent <samp class="SANS_TheSansMonoCd_W5Regular_11">string</samp>
    instances that have the same content, and those instances also compare equal.
  prefs: []
  type: TYPE_NORMAL
- en: For example, in [Listing 5-9](#list5-9), the <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">y</samp> variables don’t refer
    to the same <samp class="SANS_TheSansMonoCd_W5Regular_11">string</samp> instance
    but do have the same *value* at run time.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 5-9: Comparing string
    values</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">string</samp> class customizes
    the behavior of both <samp class="SANS_TheSansMonoCd_W5Regular_11">==</samp> and
    the <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp> method, so the
    <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">y</samp>
    variables compare equal because they both have the same content, although they’re
    references to distinct instances. Since <samp class="SANS_TheSansMonoCd_W5Regular_11">string</samp>
    overrides the behavior of <samp class="SANS_TheSansMonoCd_W5Regular_11">==</samp>,
    we use the <samp class="SANS_TheSansMonoCd_W5Regular_11">ReferenceEquals</samp>
    method here to perform a reference comparison. <samp class="SANS_TheSansMonoCd_W5Regular_11">ReferenceEquals</samp>
    is a static method defined on <samp class="SANS_TheSansMonoCd_W5Regular_11">object</samp>
    and performs an identity comparison between any two reference type variables.
    In this example, <samp class="SANS_TheSansMonoCd_W5Regular_11">ReferenceEquals</samp>
    returns <samp class="SANS_TheSansMonoCd_W5Regular_11">false</samp> because its
    arguments are references to different objects on the heap.
  prefs: []
  type: TYPE_NORMAL
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">y</samp>
    variables in [Listing 5-9](#list5-9) both use string interpolation to insert the
    values of named variables within the string, ensuring that <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">y</samp> really are distinct
    instances—at least in debug mode. If we use two simple string literals, as we
    do in [Listing 5-10](#list5-10), <samp class="SANS_TheSansMonoCd_W5Regular_11">ReferenceEquals</samp>
    gives us a different result.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 5-10: Comparing string
    literal values</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: This test shows that <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">y</samp> really are the same
    instance in memory, even though they were independently assigned to two apparently
    separate strings. The reason for the different behavior is that the compiler conserves
    memory by using *string interning*, whereby it maintains an *intern pool* containing
    a single instance of each unique string literal used in a program. This way, even
    if the same string literal appears more than once in the code, only one instance
    is in memory. Strings are immutable, so having multiple references to one instance
    can never cause aliasing issues.
  prefs: []
  type: TYPE_NORMAL
- en: We can use the intern pool ourselves at run time, although we have other memory
    considerations to take into account. We might save memory on individual string
    values, but the intern pool itself isn’t routinely garbage collected and will
    most likely stay in memory until the program terminates.
  prefs: []
  type: TYPE_NORMAL
- en: We can determine whether two <samp class="SANS_TheSansMonoCd_W5Regular_11">string</samp>
    variables refer to separate instances with <samp class="SANS_TheSansMonoCd_W5Regular_11">ReferenceEquals</samp>
    or another method, but it rarely matters. Whether two <samp class="SANS_TheSansMonoCd_W5Regular_11">string</samp>
    variables are references to one <samp class="SANS_TheSansMonoCd_W5Regular_11">string</samp>
    instance or two separate instances with the same contents, they still compare
    equal.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Custom Equality for Classes</samp>
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If we want value-based rather than reference-based equality for our own class
    types, we override the <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp>
    method and define <samp class="SANS_TheSansMonoCd_W5Regular_11">operator==</samp>
    for the class to customize the behavior of equality comparisons. There are several
    aspects to a complete implementation of equality comparisons in a class, so we’ll
    build it up in stages and implement each part in turn so you can better understand
    how all the components fit together.
  prefs: []
  type: TYPE_NORMAL
- en: Our first task is to customize the virtual <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp>
    method for the class. The <samp class="SANS_TheSansMonoCd_W5Regular_11">MusicTrack</samp>
    class in [Listing 5-11](#list5-11) has two <samp class="SANS_TheSansMonoCd_W5Regular_11">string</samp>
    properties, and we define <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp>
    so that two instances of <samp class="SANS_TheSansMonoCd_W5Regular_11">MusicTrack</samp>
    compare equal if the values for both fields compare equal.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 5-11: Overriding the
    Equals method</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: Because we’re customizing the implementation of an inherited virtual method,
    we use the <samp class="SANS_TheSansMonoCd_W5Regular_11">override</samp> keyword,
    and the method’s signature must match the signature of the base class method being
    overridden. Note that compiling this code will issue a warning that we haven’t
    overridden <samp class="SANS_TheSansMonoCd_W5Regular_11">GetHashCode</samp>. We’ll
    address that shortly.
  prefs: []
  type: TYPE_NORMAL
- en: The virtual <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp> method
    takes a single nullable <samp class="SANS_TheSansMonoCd_W5Regular_11">object</samp>
    reference, which we need to cast to our implementing type in order to compare
    it with the current instance. Here we use a *declaration pattern* to declare the
    <samp class="SANS_TheSansMonoCd_W5Regular_11">other</samp> variable if the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">obj</samp> parameter is non-<samp class="SANS_TheSansMonoCd_W5Regular_11">null</samp>
    and there’s an identity conversion or implicit reference conversion from the type
    of <samp class="SANS_TheSansMonoCd_W5Regular_11">obj</samp> to <samp class="SANS_TheSansMonoCd_W5Regular_11">MusicTrack</samp>.
    An *identity conversion* simply means a type can be converted to itself. An *implicit
    reference conversion* can take several forms, but for simplicity here it means
    that <samp class="SANS_TheSansMonoCd_W5Regular_11">MusicTrack</samp> is a base
    type of the run-time type of <samp class="SANS_TheSansMonoCd_W5Regular_11">obj</samp>.
    In this example, since <samp class="SANS_TheSansMonoCd_W5Regular_11">MusicTrack</samp>
    is a sealed class, the type will match exactly (an identity conversion) or not
    match at all.
  prefs: []
  type: TYPE_NORMAL
- en: If the <samp class="SANS_TheSansMonoCd_W5Regular_11">obj</samp> variable’s type
    matches the pattern, <samp class="SANS_TheSansMonoCd_W5Regular_11">obj</samp>
    is cast to the specified type and assigned to the <samp class="SANS_TheSansMonoCd_W5Regular_11">other</samp>
    variable. The <samp class="SANS_TheSansMonoCd_W5Regular_11">other</samp> variable
    is therefore a <samp class="SANS_TheSansMonoCd_W5Regular_11">MusicTrack</samp>
    reference, and we use it to compare its properties with those of the current instance
    to see if they’re equal.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Defining Equality
    Operators</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp> method is seldom
    used directly, because most programmers find using <samp class="SANS_TheSansMonoCd_W5Regular_11">==</samp>
    more natural than calling <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp>.
    It’s generally desirable that <samp class="SANS_TheSansMonoCd_W5Regular_11">==</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp> have identical
    behavior, and we achieve that most simply by implementing <samp class="SANS_TheSansMonoCd_W5Regular_11">operator==</samp>
    for the <samp class="SANS_TheSansMonoCd_W5Regular_11">MusicTrack</samp> class
    to call the <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp> method
    we’ve already defined.
  prefs: []
  type: TYPE_NORMAL
- en: Operator definitions such as <samp class="SANS_TheSansMonoCd_W5Regular_11">operator==</samp>
    are static methods. The <samp class="SANS_TheSansMonoCd_W5Regular_11">operator==</samp>
    definition takes two parameters, at least one of which must be of the type implementing
    the operator. The return type is most often <samp class="SANS_TheSansMonoCd_W5Regular_11">bool</samp>,
    although that’s not a strict requirement. The usual implementation has both parameters
    of the same type, allowing us to use <samp class="SANS_TheSansMonoCd_W5Regular_11">==</samp>
    to compare two instances, as shown in [Listing 5-12](#list5-12).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 5-12: Defining operator</samp>==
    <samp class="SANS_Futura_Std_Book_Oblique_I_11">for the MusicTrack class</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: If we provide <samp class="SANS_TheSansMonoCd_W5Regular_11">operator==</samp>,
    we must also implement a matching <samp class="SANS_TheSansMonoCd_W5Regular_11">operator</samp><samp
    class="SANS_TheSansMonoCd_W5Regular_11">!</samp><samp class="SANS_TheSansMonoCd_W5Regular_11">=</samp>,
    which we do simply by inverting the result of calling the <samp class="SANS_TheSansMonoCd_W5Regular_11">==</samp>
    operator method.
  prefs: []
  type: TYPE_NORMAL
- en: Since <samp class="SANS_TheSansMonoCd_W5Regular_11">MusicTrack</samp> is a class,
    either or both of the arguments to the operators could be <samp class="SANS_TheSansMonoCd_W5Regular_11">null</samp>,
    so we make that expectation explicit by using the nullable reference syntax for
    the parameters. If both arguments are <samp class="SANS_TheSansMonoCd_W5Regular_11">null</samp>,
    they compare equal. If <samp class="SANS_TheSansMonoCd_W5Regular_11">left</samp>
    is non-<samp class="SANS_TheSansMonoCd_W5Regular_11">null</samp>, we call the
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp> method, passing <samp
    class="SANS_TheSansMonoCd_W5Regular_11">right</samp> as the argument even where
    <samp class="SANS_TheSansMonoCd_W5Regular_11">right</samp> is a <samp class="SANS_TheSansMonoCd_W5Regular_11">null</samp>
    reference. Our implementation of <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp>
    already handles <samp class="SANS_TheSansMonoCd_W5Regular_11">null</samp> being
    passed to its parameter.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Handling Comparisons
    with null</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In [Listing 5-12](#list5-12), we used the constant pattern and the <samp class="SANS_TheSansMonoCd_W5Regular_11">is</samp>
    keyword to compare the <samp class="SANS_TheSansMonoCd_W5Regular_11">left</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">right</samp> parameters with
    <samp class="SANS_TheSansMonoCd_W5Regular_11">null</samp>. If we compared them
    with <samp class="SANS_TheSansMonoCd_W5Regular_11">==</samp> instead, <samp class="SANS_TheSansMonoCd_W5Regular_11">operator==</samp>
    would call itself recursively because <samp class="SANS_TheSansMonoCd_W5Regular_11">null</samp>
    is implicitly converted to <samp class="SANS_TheSansMonoCd_W5Regular_11">MusicTrack</samp>
    in those comparisons. Applying the constant pattern here avoids that pitfall because
    the <samp class="SANS_TheSansMonoCd_W5Regular_11">is null</samp> expression never
    calls a user-defined <samp class="SANS_TheSansMonoCd_W5Regular_11">operator==</samp>
    implementation. The compiler translates all such comparisons to use the intrinsic
    <samp class="SANS_TheSansMonoCd_W5Regular_11">ceq</samp> instruction.
  prefs: []
  type: TYPE_NORMAL
- en: Since the contents of the <samp class="SANS_TheSansMonoCd_W5Regular_11">if</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">else</samp> blocks are simple
    expressions, we make the implementation of <samp class="SANS_TheSansMonoCd_W5Regular_11">operator==</samp>
    more compact in [Listing 5-13](#list5-13) by using the ternary operator, which
    has the form <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">expression</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">?</samp> <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">result
    if true</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">:</samp> <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">result
    if false</samp>.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 5-13: A more compact
    implementation of operator</samp>=='
  prefs: []
  type: TYPE_NORMAL
- en: 'We can further simplify the code for <samp class="SANS_TheSansMonoCd_W5Regular_11">operator==</samp>
    by employing the null-conditional operator <samp class="SANS_TheSansMonoCd_W5Regular_11">?.</samp>,
    which invokes an instance method only if the variable used to make the call is
    non-<samp class="SANS_TheSansMonoCd_W5Regular_11">null</samp>. In the expression
    <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">x</samp><samp class="SANS_TheSansMonoCd_W5Regular_11">?</samp><samp
    class="SANS_TheSansMonoCd_W5Regular_11">.</samp><samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">y</samp>,
    if <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">x</samp> is <samp class="SANS_TheSansMonoCd_W5Regular_11">null</samp>,
    the result of the whole expression is <samp class="SANS_TheSansMonoCd_W5Regular_11">null</samp>;
    otherwise, the result is <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">x</samp><samp
    class="SANS_TheSansMonoCd_W5Regular_11">.</samp><samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">y</samp>.
    Using the null-conditional operator to implement <samp class="SANS_TheSansMonoCd_W5Regular_11">operator==</samp>
    makes the implementation much more compact, especially if we also make the operator
    an expression-bodied method, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Here, the <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp> method
    is called only if the <samp class="SANS_TheSansMonoCd_W5Regular_11">left</samp>
    parameter is not <samp class="SANS_TheSansMonoCd_W5Regular_11">null</samp>, since
    we’ve used the null-conditional operator on the <samp class="SANS_TheSansMonoCd_W5Regular_11">left</samp>
    variable. We combine the null-conditional operator with the null-coalescing operator
    <samp class="SANS_TheSansMonoCd_W5Regular_11">??</samp>, which evaluates its right-hand
    expression only if the whole left expression is <samp class="SANS_TheSansMonoCd_W5Regular_11">null</samp>.
    If <samp class="SANS_TheSansMonoCd_W5Regular_11">left</samp> is <samp class="SANS_TheSansMonoCd_W5Regular_11">null</samp>,
    then <samp class="SANS_TheSansMonoCd_W5Regular_11">left</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">right</samp>
    are equal if <samp class="SANS_TheSansMonoCd_W5Regular_11">right</samp> is also
    <samp class="SANS_TheSansMonoCd_W5Regular_11">null</samp>.
  prefs: []
  type: TYPE_NORMAL
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">null</samp> constant pattern,
    the null-conditional operator, and the null-coalescing operator are all different
    ways of testing whether a reference is equal to <samp class="SANS_TheSansMonoCd_W5Regular_11">null</samp>
    without invoking an <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp>
    method or ever calling a user-defined <samp class="SANS_TheSansMonoCd_W5Regular_11">operator==</samp>
    implementation. While we can customize both <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">operator==</samp>, we can’t
    change the behavior of comparisons made with the <samp class="SANS_TheSansMonoCd_W5Regular_11">is</samp>
    keyword or the null-conditional and null-coalescing operators.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Making Type-Safe
    Comparisons</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When we compare values for equality, we’re most commonly comparing two values
    of the same type, which is why the usual implementation of <samp class="SANS_TheSansMonoCd_W5Regular_11">operator==</samp>
    has two matching parameters. Our <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp>
    method, however, takes an <samp class="SANS_TheSansMonoCd_W5Regular_11">object</samp>
    parameter, which must be cast back to <samp class="SANS_TheSansMonoCd_W5Regular_11">MusicTrack</samp>
    so we can compare its individual property values. We can avoid this cast by writing
    an overload of <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp> that
    takes a <samp class="SANS_TheSansMonoCd_W5Regular_11">MusicTrack</samp> parameter,
    shown in [Listing 5-14](#list5-14).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 5-14: A type-safe Equals
    method</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: 'We still need to compare the argument with <samp class="SANS_TheSansMonoCd_W5Regular_11">null</samp>,
    and, as we did for <samp class="SANS_TheSansMonoCd_W5Regular_11">operator==</samp>,
    we use the constant pattern to make that comparison as efficient as possible.
    To avoid duplicating the code for comparing the property values, we alter the
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals(object?)</samp> method to
    call the type-safe overload like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Although we’re employing a run-time cast using the <samp class="SANS_TheSansMonoCd_W5Regular_11">as</samp>
    keyword, [Listing 5-14](#list5-14)’s overload of <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp>
    taking a <samp class="SANS_TheSansMonoCd_W5Regular_11">MusicTrack?</samp> parameter
    is much more likely to be called than this overridden method with an <samp class="SANS_TheSansMonoCd_W5Regular_11">object?</samp>
    parameter. In particular, our implementation of <samp class="SANS_TheSansMonoCd_W5Regular_11">operator==</samp>
    will always call the type-specific overload because the parameters to the operator
    are both <samp class="SANS_TheSansMonoCd_W5Regular_11">MusicTrack</samp> variables.
  prefs: []
  type: TYPE_NORMAL
- en: Since we’ve overridden <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp>
    for the <samp class="SANS_TheSansMonoCd_W5Regular_11">MusicTrack</samp> class,
    the compiler will warn us that we should override <samp class="SANS_TheSansMonoCd_W5Regular_11">GetHashCode</samp>
    too.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Working with Hash
    Codes</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">GetHashCode</samp>
    methods are closely associated. Like <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">GetHashCode</samp> is defined on
    <samp class="SANS_TheSansMonoCd_W5Regular_11">object</samp> and is virtual. The
    <samp class="SANS_TheSansMonoCd_W5Regular_11">GetHashCode</samp> method is used
    by collection types like <samp class="SANS_TheSansMonoCd_W5Regular_11">Dictionary</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">HashSet</samp> to efficiently
    store and look up keys. Essentially, a data structure such as a hash table uses
    an object’s *hash code* to identify its location within the data structure. When
    we add a new key or try to locate an existing one, the lookup algorithm quickly
    identifies the correct place in the table by using a hash code.
  prefs: []
  type: TYPE_NORMAL
- en: However, a particular hash code in the table may identify several different
    keys, because although the items in a hash table are usually unique, hash codes
    don’t have to be. When we add a new item to a hash table and the item’s hash code
    already exists in the table—a scenario known as a *collision*—the <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp>
    method is used on each key with a matching hash code to verify whether the table
    already contains the new item. This is why <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">GetHashCode</samp> are so closely
    related.
  prefs: []
  type: TYPE_NORMAL
- en: 'A key can be any object, as long as these two rules are followed:'
  prefs: []
  type: TYPE_NORMAL
- en: Objects that are equal according to <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp>
    have the same hash code.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The hash code for an object being used as a key doesn’t change.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ideally, each unique hash code will identify a single key—meaning we avoid the
    need to compare several objects via <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp>—and
    so searching for a key is much faster. When we search for a key in the table,
    if the hash code is matched by only a single key, it *must* be the required key
    as long as the two rules have been followed. Ensuring that hash codes are widely
    distributed is recommended to increase the likelihood that each hash code uniquely
    identifies one key.
  prefs: []
  type: TYPE_NORMAL
- en: For class types, the default implementation of <samp class="SANS_TheSansMonoCd_W5Regular_11">GetHashCode</samp>
    uses an object’s identity rather than its value to create a hash code, just as
    the default implementation of <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp>
    compares object identities, not their state. If two references are equal, they
    must also have the same hash value, because they refer to the same *instance*.
    The default hash code for an instance also never changes. However, if we accept
    the default behavior of <samp class="SANS_TheSansMonoCd_W5Regular_11">GetHashCode</samp>
    for classes, we must take extra care when using class types as keys.
  prefs: []
  type: TYPE_NORMAL
- en: We can safely use any class type that doesn’t override the <samp class="SANS_TheSansMonoCd_W5Regular_11">GetHashCode</samp>
    method as a key, but when we search for an object in a hashing collection like
    a <samp class="SANS_TheSansMonoCd_W5Regular_11">Dictionary</samp> or <samp class="SANS_TheSansMonoCd_W5Regular_11">HashSet</samp>,
    we must make sure to use the exact same instance of the object that was originally
    inserted. If we try to look up an item with a different instance, the item won’t
    be found. To demonstrate, consider [Listing 5-15](#list5-15), where we use a new
    object instance to find a key in a <samp class="SANS_TheSansMonoCd_W5Regular_11">HashSet</samp>.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 5-15: Using a Character
    class identity as a key</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: The test in this example fails because we’re searching for a different instance
    of the <samp class="SANS_TheSansMonoCd_W5Regular_11">Character</samp> class than
    was added to the <samp class="SANS_TheSansMonoCd_W5Regular_11">HashSet</samp>.
    Since <samp class="SANS_TheSansMonoCd_W5Regular_11">Character</samp> doesn’t override
    the <samp class="SANS_TheSansMonoCd_W5Regular_11">GetHashCode</samp> method, the
    instance being looked up has a different hash code than the item contained in
    the <samp class="SANS_TheSansMonoCd_W5Regular_11">HashSet</samp>, even though
    both instances have the same state.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Creating a Suitable Key</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Failing to find a key in a collection has important consequences. Elements in
    a <samp class="SANS_TheSansMonoCd_W5Regular_11">HashSet</samp> and keys in a <samp
    class="SANS_TheSansMonoCd_W5Regular_11">Dictionary</samp> should be *unique*.
    When we attempt to insert a new key, it should be added only if it isn’t already
    in the collection. However, if the key exists but can’t be found, we’ll get a
    *duplicated* key. The new object will be erroneously added to the table, effectively
    corrupting the collection.
  prefs: []
  type: TYPE_NORMAL
- en: Needing to rely on using a single object instance to both insert and search
    for any particular key in a hashing collection is usually overly restrictive.
    If, for example, the collection is populated from a file or user input, the original
    instances frequently aren’t immediately at hand when we come to search for a specific
    item. It’s much more convenient for objects used as keys to generate their hash
    codes according to their state, not their identity. That way, we can use any key
    with the same state to identify an object in the table.
  prefs: []
  type: TYPE_NORMAL
- en: As things stand, the <samp class="SANS_TheSansMonoCd_W5Regular_11">MusicTrack</samp>
    class we defined in [Listing 5-11](#list5-11) isn’t suitable as a key for a <samp
    class="SANS_TheSansMonoCd_W5Regular_11">HashSet</samp> or <samp class="SANS_TheSansMonoCd_W5Regular_11">Dictionary</samp>
    because it breaks the first of the two cardinal rules—that equal objects produce
    identical hash codes—because we’ve customized equality to compare the objects’
    state. To make <samp class="SANS_TheSansMonoCd_W5Regular_11">MusicTrack</samp>
    behave correctly, we must also override <samp class="SANS_TheSansMonoCd_W5Regular_11">GetHashCode</samp>
    and ensure that two instances of <samp class="SANS_TheSansMonoCd_W5Regular_11">MusicTrack</samp>
    that compare equal according to our customized <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp>
    method produce identical hash codes. To do that, we’ll generate a hash code using
    the same properties that determine whether two instances are equal. [Listing 5-16](#list5-16)
    shows one way to implement <samp class="SANS_TheSansMonoCd_W5Regular_11">GetHashCode</samp>
    for the <samp class="SANS_TheSansMonoCd_W5Regular_11">MusicTrack</samp> class.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 5-16: Overriding GetHashCode</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: We use the <samp class="SANS_TheSansMonoCd_W5Regular_11">HashCode</samp> static
    class from the Standard Library, which combines multiple arguments to create reasonably
    well-distributed hash codes. Our implementation of <samp class="SANS_TheSansMonoCd_W5Regular_11">GetHashCode</samp>
    uses the same properties of <samp class="SANS_TheSansMonoCd_W5Regular_11">MusicTrack</samp>
    as the <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp> method in [Listing
    5-14](#list5-14), so two objects that compare equal will always generate identical
    hash codes.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Using Floating-Point Numbers
    as Keys</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Using a floating-point number as the key in a hash table can result in keys
    being lost, in much the same way as relying on the default <samp class="SANS_TheSansMonoCd_W5Regular_11">object</samp>
    implementation of <samp class="SANS_TheSansMonoCd_W5Regular_11">GetHashCode</samp>
    for class types. As you saw earlier, comparing floating-point numbers for strict
    equality isn’t reliable. In [Listing 5-17](#list5-17), we try to identify whether
    the collection has a specific <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp>
    value.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 5-17: Using floating-point
    numbers as keys</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: This test fails because the value <samp class="SANS_TheSansMonoCd_W5Regular_11">0.3</samp>
    doesn’t exactly match the representation of <samp class="SANS_TheSansMonoCd_W5Regular_11">0.1</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">+</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">0.2</samp>.
    Because calculations using <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp>
    values are imprecise, they’re generally a bad choice as keys in a hashed collection.
    By extension, the same reasoning applies to user-defined types that have floating-point
    field values; comparing objects of such a type for equality necessarily means
    comparing any floating-point fields, with the same potential for errors.
  prefs: []
  type: TYPE_NORMAL
- en: 'In a type with floating-point fields, we might be tempted to override its <samp
    class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp> method by using an approach
    similar to the <samp class="SANS_TheSansMonoCd_W5Regular_11">ApproximatelyEqual</samp>
    implementations from [Listings 5-3](#list5-3) and [5-4](#list5-4), but doing so
    would introduce two problems. First, equality is a transitive relationship between
    values: for three values <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">y</samp>, and <samp class="SANS_TheSansMonoCd_W5Regular_11">z</samp>,
    if <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp> is equal to <samp class="SANS_TheSansMonoCd_W5Regular_11">y</samp>,
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">y</samp> is equal to <samp class="SANS_TheSansMonoCd_W5Regular_11">z</samp>,
    then <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp> must be equal to <samp
    class="SANS_TheSansMonoCd_W5Regular_11">z</samp>. Implementing <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp>
    to mean *approximately* equal means the transitive relationship wouldn’t necessarily
    hold, because the difference between <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">z</samp> could be larger than
    any tolerance we define, even when <samp class="SANS_TheSansMonoCd_W5Regular_11">x.Equals(y)</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">y.Equals(z)</samp> are both
    <samp class="SANS_TheSansMonoCd_W5Regular_11">true</samp>.'
  prefs: []
  type: TYPE_NORMAL
- en: The second issue is directly related to hash codes. Recall that objects that
    compare equal should have the same hash code. Using <samp class="SANS_TheSansMonoCd_W5Regular_11">ApproximatelyEqual</samp>
    to implement <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp> could
    easily break that rule, because two *almost* equal values will still produce different
    hash codes. We could implement <samp class="SANS_TheSansMonoCd_W5Regular_11">GetHashCode</samp>
    to ignore any floating-point fields, but doing so would compromise how well our
    objects’ hash codes are distributed. It also raises the question of what to do
    about types that have only a single field that’s a floating-point value, such
    as the <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">Angle</samp>
    types we developed in [Chapter 1](chapter1.xhtml).
  prefs: []
  type: TYPE_NORMAL
- en: Floating-point numbers and types containing floating-point values, then, don’t
    make good keys for hash tables, dictionaries, and other data structures that depend
    on the implementation of <samp class="SANS_TheSansMonoCd_W5Regular_11">GetHashCode</samp>.
    Unfortunately, C# doesn’t allow us to prevent a particular type from being used
    as a key in a hash table or similar data structure, because <samp class="SANS_TheSansMonoCd_W5Regular_11">GetHashCode</samp>
    is defined on <samp class="SANS_TheSansMonoCd_W5Regular_11">object</samp> and
    can’t be hidden. It’s up to us to make sure that the keys we use are suitable
    for that purpose.
  prefs: []
  type: TYPE_NORMAL
- en: Strings make excellent keys for hash tables, because the <samp class="SANS_TheSansMonoCd_W5Regular_11">string</samp>
    class overrides <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp> and
    <samp class="SANS_TheSansMonoCd_W5Regular_11">GetHashCode</samp> to compare the
    string contents. This is the same behavior the compiler adds for us in record
    and record struct types. Both the <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp>
    method and <samp class="SANS_TheSansMonoCd_W5Regular_11">GetHashCode</samp> are
    synthesized by the compiler, so record and record struct instances use their *value*
    for equality comparisons and for generating their hash codes. Although records
    are reference types, like strings they work very well as keys, subject to the
    caveats we’ve just discussed regarding floating-point fields.
  prefs: []
  type: TYPE_NORMAL
- en: The compiler also generates <samp class="SANS_TheSansMonoCd_W5Regular_11">operator==</samp>
    and its companion <samp class="SANS_TheSansMonoCd_W5Regular_11">operator</samp><samp
    class="SANS_TheSansMonoCd_W5Regular_11">!</samp><samp class="SANS_TheSansMonoCd_W5Regular_11">=</samp>
    for records and record structs. They follow the same general pattern we’ve used
    for <samp class="SANS_TheSansMonoCd_W5Regular_11">MusicTrack</samp>, where <samp
    class="SANS_TheSansMonoCd_W5Regular_11">operator==</samp> uses the <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp>
    method, and <samp class="SANS_TheSansMonoCd_W5Regular_11">operator</samp><samp
    class="SANS_TheSansMonoCd_W5Regular_11">!</samp><samp class="SANS_TheSansMonoCd_W5Regular_11">=</samp>
    returns the inverse of the result of <samp class="SANS_TheSansMonoCd_W5Regular_11">operator==</samp>.
    The compiler does *not* generate any of these methods for ordinary structs, which
    instead rely on the <samp class="SANS_TheSansMonoCd_W5Regular_11">ValueType</samp>
    base class common to all struct types.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Structs and Equality</samp>
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Since value type instances are copied by value, every value type variable is
    a distinct instance of the type, so two instances can never compare equal according
    to their identity. We need to compare their values, meaning that we compare their
    state instead. This usually involves comparing each field of one instance with
    the corresponding field of another.
  prefs: []
  type: TYPE_NORMAL
- en: Structs implicitly inherit from the <samp class="SANS_TheSansMonoCd_W5Regular_11">System.ValueType</samp>
    class, which provides the value-based equality required for value types. By default,
    calling <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp> on a struct
    will use the <samp class="SANS_TheSansMonoCd_W5Regular_11">ValueType</samp> implementation,
    because <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp> is a virtual
    method. As [Chapter 2](chapter2.xhtml) explained, for its implementation, the
    <samp class="SANS_TheSansMonoCd_W5Regular_11">ValueType.Equals</samp> method relies
    on reflection, which provides the correct behavior for any possible struct type
    at the expense of performance. While it might not be the most efficient comparison,
    the <samp class="SANS_TheSansMonoCd_W5Regular_11">ValueType.Equals</samp> method
    uses each field’s <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp>
    method to compare the field with its companion, so it has the behavior we require.
    Similarly, <samp class="SANS_TheSansMonoCd_W5Regular_11">ValueType</samp> also
    overrides <samp class="SANS_TheSansMonoCd_W5Regular_11">GetHashCode</samp> to
    create hash codes based on a struct’s fields, ensuring that any two struct instances
    that are equal according to <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp>
    also generate identical hash codes.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Overriding Equals
    for Structs</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Overriding the default <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">GetHashCode</samp> methods for
    struct types is common in order to address that the <samp class="SANS_TheSansMonoCd_W5Regular_11">ValueType</samp>
    implementations of those methods may not be optimal. Implementing efficient equality
    for structs follows a similar pattern as for classes, as shown in [Listing 5-18](#list5-18),
    where we create a struct to represent color values.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 5-18: Overriding equality
    for a Color struct</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: As we did with <samp class="SANS_TheSansMonoCd_W5Regular_11">MusicTrack</samp>
    in the previous section, we override the base class <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp>
    method and add a type-specific overload taking a <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp>
    parameter. There are subtle differences, related to <samp class="SANS_TheSansMonoCd_W5Regular_11">null</samp>,
    from the <samp class="SANS_TheSansMonoCd_W5Regular_11">MusicTrack</samp> implementations
    of those methods. As a struct type, <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp>
    instances can’t be <samp class="SANS_TheSansMonoCd_W5Regular_11">null</samp>,
    so the type-safe <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp> method
    takes its <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp> parameters
    by value rather than nullable references, and we don’t check for <samp class="SANS_TheSansMonoCd_W5Regular_11">null</samp>
    in the implementation of <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals(Color)</samp>.
  prefs: []
  type: TYPE_NORMAL
- en: In the <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals(object?)</samp>
    override, we use a declaration pattern to cast the <samp class="SANS_TheSansMonoCd_W5Regular_11">obj</samp>
    variable to the correct type. We used a declaration pattern in [Listing 5-11](#list5-11)
    for <samp class="SANS_TheSansMonoCd_W5Regular_11">MusicTrack</samp> but later
    switched it for the simpler <samp class="SANS_TheSansMonoCd_W5Regular_11">as</samp>
    run-time cast. We can’t use <samp class="SANS_TheSansMonoCd_W5Regular_11">as</samp>
    in our struct implementation because if the cast fails, the result is <samp class="SANS_TheSansMonoCd_W5Regular_11">null</samp>,
    which can’t be assigned to a struct variable. As noted in [Chapter 2](chapter2.xhtml),
    we *can* use <samp class="SANS_TheSansMonoCd_W5Regular_11">as</samp> to cast to
    a nullable <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp>, but in
    that case the argument would match the <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp>
    method with an <samp class="SANS_TheSansMonoCd_W5Regular_11">object?</samp> parameter
    instead of our type-safe overload, making the method recursive. Applying the declaration
    pattern here avoids that issue.
  prefs: []
  type: TYPE_NORMAL
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">GetHashCode</samp> implementation
    is identical in principle to the <samp class="SANS_TheSansMonoCd_W5Regular_11">MusicTrack</samp>
    implementation from [Listing 5-16](#list5-16).
  prefs: []
  type: TYPE_NORMAL
- en: 'Struct types don’t allow comparison with <samp class="SANS_TheSansMonoCd_W5Regular_11">==</samp>
    by default. If we want to support such comparisons, we must define our own <samp
    class="SANS_TheSansMonoCd_W5Regular_11">operator==</samp> for the type. The equality
    operator is straightforward to implement in terms of our <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp>
    method, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: While <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp> is a virtual
    instance method and is overridden by <samp class="SANS_TheSansMonoCd_W5Regular_11">ValueType</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">operator==</samp> is a static method
    and therefore *can’t* be virtual. Static methods are never inherited, so these
    operators couldn’t usefully be implemented by the <samp class="SANS_TheSansMonoCd_W5Regular_11">ValueType</samp>
    class.
  prefs: []
  type: TYPE_NORMAL
- en: Since a <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp> variable
    can’t be <samp class="SANS_TheSansMonoCd_W5Regular_11">null</samp>, we can simply
    use the <samp class="SANS_TheSansMonoCd_W5Regular_11">left</samp> variable to
    call <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp>, passing <samp
    class="SANS_TheSansMonoCd_W5Regular_11">right</samp> as the argument to invoke
    our type-safe implementation that takes a <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp>
    parameter by value. The equality operators are therefore simpler than their equivalents
    for a class, and, more significantly, the <samp class="SANS_TheSansMonoCd_W5Regular_11">left</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">right</samp> variables won’t
    be boxed when calling <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp>.
    Notice that rather than inverting the result of <samp class="SANS_TheSansMonoCd_W5Regular_11">==</samp>,
    we invert the result of calling <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp>.
    The effect is identical in both cases, but this version of <samp class="SANS_TheSansMonoCd_W5Regular_11">!</samp><samp
    class="SANS_TheSansMonoCd_W5Regular_11">=</samp> avoids the extra indirection
    of also calling <samp class="SANS_TheSansMonoCd_W5Regular_11">operator==</samp>
    and the additional copies of the arguments it would involve.
  prefs: []
  type: TYPE_NORMAL
- en: Another reason a default implementation for structs provided by <samp class="SANS_TheSansMonoCd_W5Regular_11">ValueType</samp>
    would be useless is that, as discussed earlier, an operator overload requires
    the type of at least one of its parameters to match the implementing type. We
    can’t, for instance, define our own <samp class="SANS_TheSansMonoCd_W5Regular_11">operator==</samp>
    to compare two <samp class="SANS_TheSansMonoCd_W5Regular_11">object</samp> variables
    because that would hijack the default behavior of <samp class="SANS_TheSansMonoCd_W5Regular_11">==</samp>
    for <samp class="SANS_TheSansMonoCd_W5Regular_11">object</samp> variables. Comparing
    two <samp class="SANS_TheSansMonoCd_W5Regular_11">object</samp> variables with
    <samp class="SANS_TheSansMonoCd_W5Regular_11">==</samp> *always* compares identities,
    since those variables are references. This has important consequences when an
    <samp class="SANS_TheSansMonoCd_W5Regular_11">object</samp> variable refers to
    an instance of a value type like <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp>
    that’s been boxed.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Boxing Values and
    Comparing by Identity</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Values are implicitly boxed anytime we use a reference type variable to refer
    to a value type instance. Because value types have value-based equality and reference
    type variables have reference-based equality, boxing has implications for object
    identity and equality. We went to some effort to ensure that <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">==</samp> have identical behavior
    when comparing <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp> instances,
    but when we compare <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp>
    values that have been boxed, <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">==</samp> behave differently.
  prefs: []
  type: TYPE_NORMAL
- en: To illustrate how boxing affects equality, [Listing 5-19](#list5-19) creates
    two instances of the <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp>
    struct, but instead of having the compiler deduce the variable types as <samp
    class="SANS_TheSansMonoCd_W5Regular_11">Color</samp>, we explicitly declare them
    as <samp class="SANS_TheSansMonoCd_W5Regular_11">object</samp>, causing the values
    to be boxed. The variables aren’t equal when we use <samp class="SANS_TheSansMonoCd_W5Regular_11">==</samp>
    to compare them.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 5-19: Explicitly boxing
    values</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: This test passes because reference variables are compared by their identity.
    These <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">y</samp>
    variables are references to different boxed <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp>
    values on the heap, approximately as shown in [Figure 5-1](#fig5-1).
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Figure5-1.png)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 5-1: Boxed values in
    memory</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: The boxes for the two <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp>
    instances in [Figure 5-1](#fig5-1) could be anywhere on the heap; the way that
    memory is allocated is determined by the CLR. When we use <samp class="SANS_TheSansMonoCd_W5Regular_11">==</samp>
    to compare the <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp> and <samp
    class="SANS_TheSansMonoCd_W5Regular_11">y</samp> variables, the instance values
    aren’t considered. Even though <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp>
    has an overload of <samp class="SANS_TheSansMonoCd_W5Regular_11">operator==</samp>
    to allow comparisons using <samp class="SANS_TheSansMonoCd_W5Regular_11">==</samp>
    between two <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp> values,
    that custom equality implementation isn’t invoked when we compare the two <samp
    class="SANS_TheSansMonoCd_W5Regular_11">object</samp> references. This is because
    <samp class="SANS_TheSansMonoCd_W5Regular_11">operator==</samp> is a *static*
    method that requires two <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp>
    arguments, not two <samp class="SANS_TheSansMonoCd_W5Regular_11">object</samp>
    arguments. The comparison with <samp class="SANS_TheSansMonoCd_W5Regular_11">==</samp>
    therefore correctly returns <samp class="SANS_TheSansMonoCd_W5Regular_11">false</samp>,
    because the two <samp class="SANS_TheSansMonoCd_W5Regular_11">object</samp> variables
    refer to independent instances.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we make the comparison using the <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp>
    method instead, the variables compare equal because the <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp>
    method is virtual:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp> variable used to
    invoke <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp> is an <samp
    class="SANS_TheSansMonoCd_W5Regular_11">object</samp> reference but still refers
    to an instance of <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp>,
    so here it’s our override of <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp>
    that’s called. If <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp> didn’t
    override <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp>, the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">ValueType</samp> implementation would
    be called instead. In either case, <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp>
    returns <samp class="SANS_TheSansMonoCd_W5Regular_11">true</samp> because the
    two instances of <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp> have
    exactly the same state.
  prefs: []
  type: TYPE_NORMAL
- en: We can think of a boxed value as an instance of a simple reference type on the
    heap that contains a copy of the value in a field with the same type as the original
    value. Since the box is on the heap, it can be referenced by more than one reference
    variable, as shown in [Listing 5-20](#list5-20).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 5-20: Two references
    to one boxed value</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: In this example, <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp> is a
    reference to a boxed value, and <samp class="SANS_TheSansMonoCd_W5Regular_11">y</samp>
    is a different reference to the *same box*, illustrated in [Figure 5-2](#fig5-2).
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Figure5-2.png)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 5-2: Adding a reference
    to an existing box</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">y</samp>
    variables compare equal with <samp class="SANS_TheSansMonoCd_W5Regular_11">==</samp>
    because both <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp> and <samp
    class="SANS_TheSansMonoCd_W5Regular_11">y</samp> are references to a single instance.
    The comparison with the virtual call to <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp>
    also returns <samp class="SANS_TheSansMonoCd_W5Regular_11">true</samp> because
    an instance will always compare equal with itself.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Boxed Method Parameters</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: A value will be automatically boxed when we pass it to a method that takes an
    <samp class="SANS_TheSansMonoCd_W5Regular_11">object</samp> or other reference
    type parameter. The effects are the same as assigning directly to an <samp class="SANS_TheSansMonoCd_W5Regular_11">object</samp>
    variable, as we did in [Listing 5-19](#list5-19), but the box is less obvious
    in our code.
  prefs: []
  type: TYPE_NORMAL
- en: Consider [Listing 5-21](#list5-21), where we pass the same value twice to the
    <samp class="SANS_TheSansMonoCd_W5Regular_11">object.ReferenceEquals</samp> method,
    which takes two <samp class="SANS_TheSansMonoCd_W5Regular_11">object</samp> parameters
    and compares them for identity equality.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 5-21: Passing values
    as boxed arguments</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: This test asserts that the two arguments to <samp class="SANS_TheSansMonoCd_W5Regular_11">ReferenceEquals</samp>
    are *not* equal. Should the test pass?
  prefs: []
  type: TYPE_NORMAL
- en: 'Yes, it should. The arguments to <samp class="SANS_TheSansMonoCd_W5Regular_11">ReferenceEquals</samp>
    are different <samp class="SANS_TheSansMonoCd_W5Regular_11">object</samp> variables.
    Passing a value type as an argument to an <samp class="SANS_TheSansMonoCd_W5Regular_11">object</samp>
    parameter boxes the value. Even though the same value is passed to both parameters,
    each argument is boxed separately, resulting in two independent boxes. The outcome
    is identical to explicitly boxing the same value into separate <samp class="SANS_TheSansMonoCd_W5Regular_11">object</samp>
    variables, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: The value of <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp> is explicitly
    boxed into two separate <samp class="SANS_TheSansMonoCd_W5Regular_11">object</samp>
    references. The call to <samp class="SANS_TheSansMonoCd_W5Regular_11">ReferenceEquals</samp>
    is equivalent to <samp class="SANS_TheSansMonoCd_W5Regular_11">a</samp> <samp
    class="SANS_TheSansMonoCd_W5Regular_11">==</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">b</samp>,
    and they do *not* compare equal because they’re different objects.
  prefs: []
  type: TYPE_NORMAL
- en: 'Compare [Listing 5-21](#list5-21) with the following, where we explicitly box
    the value to an <samp class="SANS_TheSansMonoCd_W5Regular_11">object</samp> variable
    *before* calling <samp class="SANS_TheSansMonoCd_W5Regular_11">ReferenceEquals</samp>:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: We pass the same reference for both arguments to <samp class="SANS_TheSansMonoCd_W5Regular_11">ReferenceEquals</samp>,
    so they compare equal. The call to <samp class="SANS_TheSansMonoCd_W5Regular_11">ReferenceEquals</samp>
    in this instance is identical to the expression <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">==</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp>,
    and the <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp> variable is a reference
    to a boxed <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp>, as shown
    in [Figure 5-3](#fig5-3).
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Figure5-3.png)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 5-3: Passing an already-boxed
    value to a method</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">ReferenceEquals</samp> method
    receives two arguments, but they’re references to the same boxed value on the
    heap.
  prefs: []
  type: TYPE_NORMAL
- en: Quite apart from testing variables for equality, we need to be sure we understand
    where values are being boxed and whether our own code is using a boxed value.
    Boxing affects what *identity* means for a value—and while this is most apparent
    when we’re comparing two values, it also has wider implications, such as whether
    we need to be concerned about aliasing or side effects.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Interface Boxes</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: We can refer to an object via any of the interfaces implemented by the type.
    To demonstrate, in [Listing 5-22](#list5-22) the <samp class="SANS_TheSansMonoCd_W5Regular_11">Angle</samp>
    value type implements <samp class="SANS_TheSansMonoCd_W5Regular_11">IFormattable</samp>,
    one of the common system interfaces provided by the Standard Library. In this
    code snippet, we use the interface name to refer to two instances of <samp class="SANS_TheSansMonoCd_W5Regular_11">Angle</samp>.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 5-22: Referring to
    a value via interface name</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: An *interface type* is a reference type that defines the public operations guaranteed
    to be available for a type that implements it. Variables of interface type are
    always references, regardless of the implementing type. Referring to value type
    instances via interface variables must therefore box the value, with the result
    that the comparison in [Listing 5-22](#list5-22) is effectively the same as when
    the values were boxed into <samp class="SANS_TheSansMonoCd_W5Regular_11">object</samp>
    variables in [Listing 5-19](#list5-19).
  prefs: []
  type: TYPE_NORMAL
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">==</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">y</samp> expression in this example,
    then, performs a reference check for equality that will compare object identities.
    The values returned from each of the <samp class="SANS_TheSansMonoCd_W5Regular_11">new
    Angle</samp> expressions will be boxed so that the references <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">y</samp> can refer to them,
    and each will refer to different boxes. The <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">y</samp> variables will compare
    equal if we use <samp class="SANS_TheSansMonoCd_W5Regular_11">x.Equals(y)</samp>,
    owing to the virtual nature of the <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp>
    method.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Comparing Generic Variables</samp>
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We use a generic type or method to implement functionality that works for a
    range of other types, often for both reference types and value types transparently.
    In the context of a generic type or a generic method, a given variable might represent
    either a value or a reference at different times during a program’s execution.
  prefs: []
  type: TYPE_NORMAL
- en: This poses an issue for equality comparisons of generic variables; in particular,
    using <samp class="SANS_TheSansMonoCd_W5Regular_11">==</samp> to compare variables
    typed by a generic parameter will never invoke a user-defined <samp class="SANS_TheSansMonoCd_W5Regular_11">operator==</samp>
    implementation. If a generic parameter is unconstrained, we can’t even use <samp
    class="SANS_TheSansMonoCd_W5Regular_11">==</samp> to compare two variables of
    the same generic type.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Dogma_OT_Bold_B_21">NOTE</samp>
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*C# v11.0 introduces a preview feature named* static abstract interface members
    *that enables you to use user-defined operators, including operator*<samp class="SANS_TheSansMonoCd_W5Regular_11">==</samp>*,
    in generic code. For more information on this feature, see* [https://learn.microsoft.com/en-us/dotnet/csharp/whats-new/tutorials/static-virtual-interface-members*.*](https://learn.microsoft.com/en-us/dotnet/csharp/whats-new/tutorials/static-virtual-interface-members)'
  prefs: []
  type: TYPE_NORMAL
- en: Consider the simple generic class in [Listing 5-23](#list5-23), which uses <samp
    class="SANS_TheSansMonoCd_W5Regular_11">==</samp> to compare two variables declared
    using the generic type parameter <samp class="SANS_TheSansMonoCd_W5Regular_11">T</samp>.
    As it stands, this class won’t compile.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 5-23: Generic type
    parameter comparison</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">Playlist</samp> is a generic class
    with a type parameter that by convention is named <samp class="SANS_TheSansMonoCd_W5Regular_11">T</samp>.
    We’d generally refer to this class as a *Playlist of T*.
  prefs: []
  type: TYPE_NORMAL
- en: We can’t use <samp class="SANS_TheSansMonoCd_W5Regular_11">==</samp> to compare
    the <samp class="SANS_TheSansMonoCd_W5Regular_11">item</samp> parameter with the
    field <samp class="SANS_TheSansMonoCd_W5Regular_11">current</samp> because when
    <samp class="SANS_TheSansMonoCd_W5Regular_11">T</samp> is an unconstrained type
    parameter like this, the <samp class="SANS_TheSansMonoCd_W5Regular_11">==</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">!</samp><samp class="SANS_TheSansMonoCd_W5Regular_11">=</samp>
    operators can be used only to check instances of <samp class="SANS_TheSansMonoCd_W5Regular_11">T</samp>
    for equality or inequality with <samp class="SANS_TheSansMonoCd_W5Regular_11">null</samp>.
  prefs: []
  type: TYPE_NORMAL
- en: If we add a general class constraint, or a specific base class or interface
    type constraint for <samp class="SANS_TheSansMonoCd_W5Regular_11">T</samp>, the
    comparison <samp class="SANS_TheSansMonoCd_W5Regular_11">item</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">==</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">current</samp> will compile, but
    it will always represent a reference comparison. C# has no generic constraint
    we can add for <samp class="SANS_TheSansMonoCd_W5Regular_11">T</samp> to allow
    the expression <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">==</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">y</samp> to invoke an overloaded
    <samp class="SANS_TheSansMonoCd_W5Regular_11">operator==</samp>, where <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp>
    or <samp class="SANS_TheSansMonoCd_W5Regular_11">y</samp> is typed by a generic
    parameter.
  prefs: []
  type: TYPE_NORMAL
- en: We *can* invoke the <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp>
    method, which will call an overridden implementation if one exists on whatever
    type <samp class="SANS_TheSansMonoCd_W5Regular_11">T</samp> represents at run
    time. The <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp> method is
    defined on the <samp class="SANS_TheSansMonoCd_W5Regular_11">object</samp> base
    class and so is available to any variable, regardless of its actual type. However,
    when the type of <samp class="SANS_TheSansMonoCd_W5Regular_11">T</samp> is a value
    type, the argument may be boxed by calling the <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp>
    method that takes <samp class="SANS_TheSansMonoCd_W5Regular_11">object?</samp>
    as its parameter.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Generic Code and
    the Equals Method</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In [Listing 5-11](#list5-11), we implemented equality for our <samp class="SANS_TheSansMonoCd_W5Regular_11">MusicTrack</samp>
    type so that instances of them compare by value rather than by identity. In [Listing
    5-18](#list5-18), we did the same for the <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp>
    struct to override the <samp class="SANS_TheSansMonoCd_W5Regular_11">ValueType.Equals</samp>
    method. To make the comparison more efficient, we added a type-safe overload of
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp> for both types by
    taking the parameter as <samp class="SANS_TheSansMonoCd_W5Regular_11">MusicTrack</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp>, respectively,
    rather than <samp class="SANS_TheSansMonoCd_W5Regular_11">object</samp>, thereby
    preventing the argument from being boxed.
  prefs: []
  type: TYPE_NORMAL
- en: In the current implementations of <samp class="SANS_TheSansMonoCd_W5Regular_11">MusicTrack</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp>, however, their
    type-safe overloads of <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp>
    won’t be used if called using a generic type parameter variable. When <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp>
    is called using a generic variable, the virtual method with an <samp class="SANS_TheSansMonoCd_W5Regular_11">object?</samp>
    parameter is called by default. For the <samp class="SANS_TheSansMonoCd_W5Regular_11">MusicTrack</samp>
    class, that merely results in an extra run-time cast, but for the <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp>
    struct, the parameter will be boxed to <samp class="SANS_TheSansMonoCd_W5Regular_11">object</samp>
    and then unboxed again to compare <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp>’s
    properties.
  prefs: []
  type: TYPE_NORMAL
- en: To demonstrate, [Listing 5-24](#list5-24) uses <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp>
    as a type argument for the generic <samp class="SANS_TheSansMonoCd_W5Regular_11">HashSet</samp>
    collection type. The <samp class="SANS_TheSansMonoCd_W5Regular_11">HashSet< T
    >.Contains</samp> method uses a combination of <samp class="SANS_TheSansMonoCd_W5Regular_11">GetHashCode</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp> to determine whether
    any item in the collection matches the <samp class="SANS_TheSansMonoCd_W5Regular_11">orange</samp>
    argument.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 5-24: Searching a collection
    of Color values</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: The test passes, but the <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals(object?)</samp>
    method will be used, because the <samp class="SANS_TheSansMonoCd_W5Regular_11">HashSet.Contains</samp>
    implementation has no way of knowing that <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp>
    implements a type-safe overload of <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp>
    that takes a <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp> parameter
    directly. This matters for <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp>
    because it’s a struct, and so every comparison will box the argument to an <samp
    class="SANS_TheSansMonoCd_W5Regular_11">object</samp> reference. If the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">HashSet</samp> contains a large number
    of elements, that boxing could well represent many unnecessary copies of <samp
    class="SANS_TheSansMonoCd_W5Regular_11">Color</samp>.
  prefs: []
  type: TYPE_NORMAL
- en: The same would be true of a <samp class="SANS_TheSansMonoCd_W5Regular_11">HashSet</samp>
    containing <samp class="SANS_TheSansMonoCd_W5Regular_11">MusicTrack</samp> elements,
    and although the impact is a little less costly, it’s still an unnecessary inefficiency.
  prefs: []
  type: TYPE_NORMAL
- en: To have generic code prefer our type-safe <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp>
    over the more general implementation inherited from <samp class="SANS_TheSansMonoCd_W5Regular_11">object</samp>,
    our types must implement the <samp class="SANS_TheSansMonoCd_W5Regular_11">IEquatable<
    T ></samp> interface.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">The IEquatable<T>
    Interface</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When we implement the <samp class="SANS_TheSansMonoCd_W5Regular_11">IEquatable<
    T ></samp> interface on any class or struct, we’re signaling to generic code that
    the type has a public type-safe implementation of <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp>.
    The <samp class="SANS_TheSansMonoCd_W5Regular_11">IEquatable< T ></samp> interface
    specifies that the type represented by <samp class="SANS_TheSansMonoCd_W5Regular_11">T</samp>
    contains an implementation of <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp>
    taking a <samp class="SANS_TheSansMonoCd_W5Regular_11">T</samp> as its parameter.
    Generic code such as <samp class="SANS_TheSansMonoCd_W5Regular_11">HashSet< T
    ></samp> can detect that a generic type implements <samp class="SANS_TheSansMonoCd_W5Regular_11">IEquatable<
    T ></samp> and will use the type-specific overload of <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp>
    if it’s available. [Listing 5-25](#list5-25) shows how our <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp>
    struct would implement the <samp class="SANS_TheSansMonoCd_W5Regular_11">IEquatable<
    T ></samp> interface.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 5-25: The IEquatable</samp><
    T > <samp class="SANS_Futura_Std_Book_Oblique_I_11">interface</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: This <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp> method is identical
    to the original type-safe method from [Listing 5-18](#list5-18); the difference
    is that <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp> indicates the
    presence of that overload by explicitly implementing <samp class="SANS_TheSansMonoCd_W5Regular_11">IEquatable<
    Color></samp>. Now when we use a <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp>
    as the element type for a <samp class="SANS_TheSansMonoCd_W5Regular_11">HashSet</samp>
    or other generic collection, any comparison using <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp>
    will use our type-safe implementation and avoid the need to box the argument.
  prefs: []
  type: TYPE_NORMAL
- en: This works because generic collections like <samp class="SANS_TheSansMonoCd_W5Regular_11">HashSet</samp>
    don’t invoke <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp> directly;
    instead, they defer the comparison to a helper class named <samp class="SANS_TheSansMonoCd_W5Regular_11">EqualityComparer<
    T ></samp>, which internally selects a type-specific <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp>
    method if <samp class="SANS_TheSansMonoCd_W5Regular_11">T</samp> implements the
    <samp class="SANS_TheSansMonoCd_W5Regular_11">IEquatable< T ></samp> interface.
    If <samp class="SANS_TheSansMonoCd_W5Regular_11">T</samp> doesn’t implement the
    interface, the virtual <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals(object?)</samp>
    is used instead.
  prefs: []
  type: TYPE_NORMAL
- en: We can use the <samp class="SANS_TheSansMonoCd_W5Regular_11">EqualityComparer</samp>
    class in our own generic code to automatically select the best available implementation
    of the <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp> method for
    a generic parameter type variable. [Listing 5-26](#list5-26) shows the usual pattern
    for checking equality via an <samp class="SANS_TheSansMonoCd_W5Regular_11">EqualityComparer</samp>
    object.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 5-26: Equality using
    the EqualityComparer</samp>< T > <samp class="SANS_Futura_Std_Book_Oblique_I_11">class</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">EqualityComparer< T >.Default</samp>
    static property returns an implementation of the standard <samp class="SANS_TheSansMonoCd_W5Regular_11">IEqualityComparer<
    T ></samp> interface with the appropriate behavior for the <samp class="SANS_TheSansMonoCd_W5Regular_11">T</samp>
    type parameter. When <samp class="SANS_TheSansMonoCd_W5Regular_11">T</samp> implements
    <samp class="SANS_TheSansMonoCd_W5Regular_11">IEquatable< T ></samp>, the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">Default</samp> property returns an implementation
    of <samp class="SANS_TheSansMonoCd_W5Regular_11">IEqualityComparer< T ></samp>
    that uses the type-specific overload of the <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp>
    method.
  prefs: []
  type: TYPE_NORMAL
- en: Besides <samp class="SANS_TheSansMonoCd_W5Regular_11">HashSet</samp>, the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">Dictionary</samp> collection and some
    LINQ algorithms use <samp class="SANS_TheSansMonoCd_W5Regular_11">IEqualityComparer<
    T ></samp> to define equality between elements. They can all be given a specific
    <samp class="SANS_TheSansMonoCd_W5Regular_11">IEqualityComparer< T ></samp> implementation,
    so we can provide our own implementation of it to customize that behavior. We’ll
    use this technique in [Chapter 8](chapter8.xhtml) to modify the behavior of the
    <samp class="SANS_TheSansMonoCd_W5Regular_11">SequenceEqual</samp> method.
  prefs: []
  type: TYPE_NORMAL
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">EqualityComparer< T ></samp>
    class is designed for generic code but can be useful when equality comparisons
    need to be made in the most general and efficient manner possible. One such situation
    is in code generated by the compiler.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Compiler-Generated Equality</samp>
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The compiler itself is capable of synthesizing a correct and complete implementation
    of equality for some types. The code generated by the compiler uses the same techniques
    we’ve been exploring. In this section, we’ll look at examples to better appreciate
    what the compiler is prepared to generate on our behalf, even for something as
    fundamental as equality comparison of variables.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Records and Record
    Structs</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Records and record structs give us a compact way of creating a type that has
    value semantics built in. Records are syntactically different from both classes
    and structs, but in the CIL they’re just classes with some compiler-generated
    features, including overrides of the <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">GetHashCode</samp> methods.
    Similarly, record structs are structs in the compiled code and have most of the
    same compiler-provided features as records.
  prefs: []
  type: TYPE_NORMAL
- en: The notable exception is that the compiler implements a <samp class="SANS_TheSansMonoCd_W5Regular_11">Clone</samp>
    method for records, but not for record structs. <samp class="SANS_TheSansMonoCd_W5Regular_11">Clone</samp>
    emulates copying a record instance by value to support non-destructive mutation,
    which we examined in [Chapter 4](chapter4.xhtml). Since record structs are natively
    copied by value, they have no need for a <samp class="SANS_TheSansMonoCd_W5Regular_11">Clone</samp>
    method.
  prefs: []
  type: TYPE_NORMAL
- en: Both records and record structs implement <samp class="SANS_TheSansMonoCd_W5Regular_11">IEquatable<
    T ></samp>, and the compiler-generated type-specific overload of the <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp>
    method compares each field of the type, exactly as we did earlier in <samp class="SANS_TheSansMonoCd_W5Regular_11">MusicTrack</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp>. The <samp class="SANS_TheSansMonoCd_W5Regular_11">GetHashCode</samp>
    method implementation uses all the fields to provide well-distributed hash codes.
    All this is in contrast to plain structs, where the default value-based equality
    behavior is provided by a common base class, <samp class="SANS_TheSansMonoCd_W5Regular_11">ValueType</samp>.
  prefs: []
  type: TYPE_NORMAL
- en: 'This simple <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp> type
    is implemented as a positional record and demonstrates admirably how compact a
    record definition can be:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: This positional syntax for a record causes the compiler to create three properties
    for <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp>, each with the
    same name and type as the respective positional parameters defined for the type.
    The compiler also provides a public constructor with those three parameters to
    initialize the three property values. This positional syntax can be used for records
    and record structs.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Inside Record Equality</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: All records are classes, but they have value-based equality semantics, courtesy
    of the implementation of the <samp class="SANS_TheSansMonoCd_W5Regular_11">IEquatable<
    T ></samp> interface provided automatically by the compiler. The <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp>
    methods shown in [Listing 5-27](#list5-27) are almost—but not quite—the same as
    those generated for the <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp>
    record by the compiler.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 5-27: Equality implementation
    generated for a record</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: The compiler-generated type-safe <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp>
    method can *directly* access the backing fields for the <samp class="SANS_TheSansMonoCd_W5Regular_11">Red</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Green</samp>, and <samp class="SANS_TheSansMonoCd_W5Regular_11">Blue</samp>
    properties and thus avoids the extra method calls shown here for reading the property
    values. Note how the <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp>
    method uses the <samp class="SANS_TheSansMonoCd_W5Regular_11">EqualityComparer<
    T ></samp> class to compare each value, so if the type of any property implements
    <samp class="SANS_TheSansMonoCd_W5Regular_11">IEquatable< T ></samp>, the type-safe
    implementation of <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp>
    will be used.
  prefs: []
  type: TYPE_NORMAL
- en: Records can, by default, inherit from other records, so equality isn’t quite
    as simple as comparing each object’s fields. The <samp class="SANS_TheSansMonoCd_W5Regular_11">other</samp>
    parameter for <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp> could
    in that case refer to an instance of a more derived record. Checking for equality
    of objects that could have different run-time types requires extra care. In most
    cases, objects of different types aren’t equal, which is why we use <samp class="SANS_TheSansMonoCd_W5Regular_11">GetType</samp>
    on the second line of the <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals(Color?)</samp>
    method in [Listing 5-27](#list5-27).
  prefs: []
  type: TYPE_NORMAL
- en: Our <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp> record is sealed
    and doesn’t inherit from another record. Therefore, checking the type is redundant
    because the <samp class="SANS_TheSansMonoCd_W5Regular_11">other</samp> parameter
    can’t refer to anything other than an instance of <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp>.
  prefs: []
  type: TYPE_NORMAL
- en: Since the <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp> record
    is sealed and has no base types, we should consider making it a record struct.
    Record structs compile down to struct definitions, which can’t be inherited or
    have <samp class="SANS_TheSansMonoCd_W5Regular_11">null</samp> values, making
    their internals simpler. The type-safe <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp>
    method for a record struct type doesn’t check for <samp class="SANS_TheSansMonoCd_W5Regular_11">null</samp>
    or whether the types match but is otherwise the same as for a record.
  prefs: []
  type: TYPE_NORMAL
- en: In addition to implementations of the <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">GetHashCode</samp> methods,
    the compiler generates <samp class="SANS_TheSansMonoCd_W5Regular_11">operator==</samp>
    and a corresponding <samp class="SANS_TheSansMonoCd_W5Regular_11">operator</samp><samp
    class="SANS_TheSansMonoCd_W5Regular_11">!</samp><samp class="SANS_TheSansMonoCd_W5Regular_11">=</samp>
    for records and record structs. The implementation of <samp class="SANS_TheSansMonoCd_W5Regular_11">operator==</samp>
    invokes the <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp> method,
    so record variables exhibit value-based equality when they’re compared with <samp
    class="SANS_TheSansMonoCd_W5Regular_11">==</samp>, rather than the default identity-based
    comparison that classes have. We confirm this behavior for our <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp>
    record in [Listing 5-28](#list5-28).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 5-28: Comparing records
    with</samp> =='
  prefs: []
  type: TYPE_NORMAL
- en: Here we see that two <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp>
    variables compare equal, because even though they’re definitely not two references
    to a single instance, the state of the instances is the same.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Custom Implementations for
    Record Equality</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The compiler will normally generate at least two versions of <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp>
    for a record or a record struct: one taking an <samp class="SANS_TheSansMonoCd_W5Regular_11">object</samp>
    parameter (or <samp class="SANS_TheSansMonoCd_W5Regular_11">object?</samp> within
    a nullable context) and the other implementing the <samp class="SANS_TheSansMonoCd_W5Regular_11">IEquatable<
    T ></samp> interface, which performs the comparison of each instance’s fields.
    The version taking an <samp class="SANS_TheSansMonoCd_W5Regular_11">object</samp>
    parameter casts its argument to the required type and invokes the type-specific
    overload if the cast is successful, as we did for the <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp>
    record in [Listing 5-27](#list5-27). We can provide our own implementation of
    the type-safe <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp> method
    for a record or record struct type, in which case the compiler uses our implementation
    instead of generating one. If we do so, we should implement our own <samp class="SANS_TheSansMonoCd_W5Regular_11">GetHashCode</samp>
    to match, which will also replace the compiler-generated implementation.'
  prefs: []
  type: TYPE_NORMAL
- en: 'However, we can’t provide our own implementation of <samp class="SANS_TheSansMonoCd_W5Regular_11">operator==</samp>
    or <samp class="SANS_TheSansMonoCd_W5Regular_11">operator</samp><samp class="SANS_TheSansMonoCd_W5Regular_11">!</samp><samp
    class="SANS_TheSansMonoCd_W5Regular_11">=</samp> for comparing two record or record
    struct instances. If we attempt to do so, the compiler gives us an error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">op_Equality</samp> is the name
    of the static method to which the compiler translates <samp class="SANS_TheSansMonoCd_W5Regular_11">operator==</samp>.
    The name for <samp class="SANS_TheSansMonoCd_W5Regular_11">operator</samp><samp
    class="SANS_TheSansMonoCd_W5Regular_11">!</samp><samp class="SANS_TheSansMonoCd_W5Regular_11">=</samp>
    is <samp class="SANS_TheSansMonoCd_W5Regular_11">op_Inequality</samp>, and the
    compiler always provides both methods, preventing us from defining our own.
  prefs: []
  type: TYPE_NORMAL
- en: 'We should almost always accept the default implementation of equality for records
    and record structs, as the compiler-generated code is both correct and efficient.
    However, if we need to customize the behavior of equality for a record or record
    struct, we need only override the type-safe <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp>
    method. Each of the other equality methods, including the overridden <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp>
    method taking an <samp class="SANS_TheSansMonoCd_W5Regular_11">object</samp> parameter,
    ultimately calls the type-specific overload to perform the actual comparison.
    The compiler’s implementation of the <samp class="SANS_TheSansMonoCd_W5Regular_11">==</samp>
    operator is identical to that shown here for <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp>,
    so if we alter the behavior of the <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp>
    method, that behavior is also reflected in the implementations of <samp class="SANS_TheSansMonoCd_W5Regular_11">operator==</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">operator</samp><samp class="SANS_TheSansMonoCd_W5Regular_11">!</samp><samp
    class="SANS_TheSansMonoCd_W5Regular_11">=</samp> provided by the compiler:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: When we define a positional record or positional record struct, the compiler
    synthesizes a complete type, along with methods to support equality comparisons.
    The compiler generates code to support equality for nullable value types, too,
    although in a very different way.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Equality for Nullable
    Values</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We denote a nullable value type by using the special <samp class="SANS_TheSansMonoCd_W5Regular_11">?</samp>
    notation on a value type variable. The compiler translates a nullable value type
    to an instance of the system type <samp class="SANS_TheSansMonoCd_W5Regular_11">Nullable<
    T ></samp>, where <samp class="SANS_TheSansMonoCd_W5Regular_11">T</samp> is the
    declared type for the variable. <samp class="SANS_TheSansMonoCd_W5Regular_11">Nullable<
    T ></samp> is a struct, instances of which may have a value of type <samp class="SANS_TheSansMonoCd_W5Regular_11">T</samp>
    or no value (represented by <samp class="SANS_TheSansMonoCd_W5Regular_11">null</samp>).
  prefs: []
  type: TYPE_NORMAL
- en: Comparing nullable value type variables differs from comparing references, which
    may be <samp class="SANS_TheSansMonoCd_W5Regular_11">null</samp>, because for
    two nullable value type variables, we must always compare each underlying value
    if one exists. To illustrate, consider [Listing 5-29](#list5-29), where we compare
    two nullable value type variables, one with a value and the other <samp class="SANS_TheSansMonoCd_W5Regular_11">null</samp>.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 5-29: Comparing nullable
    values</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: Both <samp class="SANS_TheSansMonoCd_W5Regular_11">fg</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">bg</samp>
    in this example are nullable, but while <samp class="SANS_TheSansMonoCd_W5Regular_11">fg</samp>
    has a <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp> value, <samp
    class="SANS_TheSansMonoCd_W5Regular_11">bg</samp> is <samp class="SANS_TheSansMonoCd_W5Regular_11">null</samp>.
    The test passes because the values aren’t equal. Two nullable value type variables
    are equal if both have no value, or if both have a value and those values are
    themselves equal. What’s interesting about this example is that while <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp>
    has a custom <samp class="SANS_TheSansMonoCd_W5Regular_11">operator==</samp> to
    compare two <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp> values,
    it accepts two *non*-nullable <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp>
    parameters. Since <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp> is
    a struct, <samp class="SANS_TheSansMonoCd_W5Regular_11">null</samp> isn’t a valid
    value for it, although <samp class="SANS_TheSansMonoCd_W5Regular_11">null</samp>
    is a valid value for a *nullable* <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp>.
  prefs: []
  type: TYPE_NORMAL
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">Nullable< T ></samp> struct
    doesn’t have an overloaded <samp class="SANS_TheSansMonoCd_W5Regular_11">operator==</samp>
    of its own. When the compiler encounters code comparing two nullable value types,
    or a nullable value type and a normal value type instance, it rewrites the comparison
    by inserting the implementation from the corresponding operator definition for
    the underlying—non-nullable—value type. This process is known as *lifting* the
    operator. Since one or both of those arguments may have *no* value, the lifted
    operation makes the additional checks for the existence of a value before finally
    comparing those values by using the original, non-nullable comparison.
  prefs: []
  type: TYPE_NORMAL
- en: For this reason, if <samp class="SANS_TheSansMonoCd_W5Regular_11">T</samp> has
    no <samp class="SANS_TheSansMonoCd_W5Regular_11">operator==</samp> defined, the
    comparison of two <samp class="SANS_TheSansMonoCd_W5Regular_11">T?</samp> variables
    fails to compile, because the compiler has no operator implementation to lift.
    The <samp class="SANS_TheSansMonoCd_W5Regular_11">lifted_op_Equality</samp> method
    in [Listing 5-30](#list5-30) is fictional but demonstrates the basic algorithm
    for the lifted equality comparison operation.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 5-30: The lifted equality
    operator</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: 'The compiler doesn’t generate a new method for this algorithm but simply inserts
    logic inline in our code, replacing the original comparison using <samp class="SANS_TheSansMonoCd_W5Regular_11">==</samp>
    in [Listing 5-29](#list5-29) with the equivalent of the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: The logic of this code is essentially identical to that in [Listing 5-30](#list5-30),
    but it’s a single expression and thus easier for the compiler to inline. The reason
    for using <samp class="SANS_TheSansMonoCd_W5Regular_11">GetValueOrDefault</samp>
    instead of the <samp class="SANS_TheSansMonoCd_W5Regular_11">Value</samp> property
    is that the latter needs to check that a valid value exists and will throw an
    exception if it doesn’t. <samp class="SANS_TheSansMonoCd_W5Regular_11">GetValueOrDefault</samp>
    is therefore slightly more efficient.
  prefs: []
  type: TYPE_NORMAL
- en: Although nullable value types are instances of the special system type <samp
    class="SANS_TheSansMonoCd_W5Regular_11">Nullable< T ></samp>, the same functionality
    couldn’t be implemented by <samp class="SANS_TheSansMonoCd_W5Regular_11">Nullable<
    T ></samp> simply having its own <samp class="SANS_TheSansMonoCd_W5Regular_11">operator==</samp>
    to perform the comparison. The purpose of lifting the underlying type’s <samp
    class="SANS_TheSansMonoCd_W5Regular_11">operator==</samp> is to ensure that when
    both variables have a value, they’re compared exactly as if they were non-nullable
    types—that is, direct instances of the original value type. An <samp class="SANS_TheSansMonoCd_W5Regular_11">operator==</samp>
    implementation for <samp class="SANS_TheSansMonoCd_W5Regular_11">Nullable< T ></samp>
    would need to use <samp class="SANS_TheSansMonoCd_W5Regular_11">==</samp> to compare
    two instances of the generic type <samp class="SANS_TheSansMonoCd_W5Regular_11">T</samp>,
    which, as we know, isn’t allowed.
  prefs: []
  type: TYPE_NORMAL
- en: By lifting the underlying type’s <samp class="SANS_TheSansMonoCd_W5Regular_11">operator==</samp>,
    the compiler ensures that the correct behavior is maintained and that values compare
    the same way whether or not they’re nullable types.
  prefs: []
  type: TYPE_NORMAL
- en: The compiler also generates code inline to support comparisons of value tuple
    variables, introduced in C# v7.0, although the process for value tuples is a little
    different.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Value Tuples and
    Equality</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*Tuples* are a common feature of many modern programming languages to gather
    several related values together into a single lightweight data structure. A tuple
    in C# is similar to a struct with all public fields and no member methods, although
    the syntax for declaring and using a tuple is different from doing so for such
    a struct.'
  prefs: []
  type: TYPE_NORMAL
- en: Compiler support for tuple types supersedes the <samp class="SANS_TheSansMonoCd_W5Regular_11">System.Tuple</samp>
    class introduced in .NET v4.0\. The more modern feature, available since C# v7.0,
    is known as a *value tuple*. Value tuples are underpinned by a system type named
    <samp class="SANS_TheSansMonoCd_W5Regular_11">ValueTuple</samp>, but that type
    isn’t intended to be used directly. Instead, when we want to relate several fields
    together without the overhead of adding a full user-defined class or struct, we
    use the value tuple syntax.
  prefs: []
  type: TYPE_NORMAL
- en: Value tuples enjoy sophisticated support from the compiler, both in how variables
    are declared and in how they can be used. [Listing 5-31](#list5-31) shows an example
    of comparing value tuple variables for equality.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 5-31: Comparing value
    tuple variables for equality</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: We’re declaring two tuple variables, <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">y</samp>, by surrounding multiple
    values with parentheses; this syntax is common in several languages with tuple
    support and probably familiar to many programmers. However, although the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">x</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">y</samp>
    variables have the same *values*, they look distinctly different from each other
    in their declarations. In particular, <samp class="SANS_TheSansMonoCd_W5Regular_11">y</samp>
    gives names to its component parts, whereas <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp>
    doesn’t. The test determines that <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">y</samp> are equal and passes.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Dogma_OT_Bold_B_21">NOTE</samp>
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*Support for using* <samp class="SANS_TheSansMonoCd_W5Regular_11">==</samp>
    *to compare value tuples was introduced in C# v7.3, shortly after value tuples
    were introduced.*'
  prefs: []
  type: TYPE_NORMAL
- en: When we compare value tuple variables with <samp class="SANS_TheSansMonoCd_W5Regular_11">==</samp>,
    the compiler generates code to compare each element of the value tuple with the
    corresponding element in the other value tuple. The elements of a value tuple
    are public fields, not properties, meaning that reading or writing a value accesses
    the field directly. As with nullable values, the compiler rewrites our comparison
    expression by inserting the code to compare the fields of <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">y</samp> directly.
  prefs: []
  type: TYPE_NORMAL
- en: The CIL extract in [Listing 5-32](#list5-32) shows just the comparison of the
    tuples’ first component in [Listing 5-31](#list5-31).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 5-32: New-style value
    tuple comparison CIL</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: The compiler directly loads the fields by using the <samp class="SANS_TheSansMonoCd_W5Regular_11">ldfld</samp>
    instruction and then compares those values by using the <samp class="SANS_TheSansMonoCd_W5Regular_11">bne</samp>
    instruction, which stands for *break if not equal*. The <samp class="SANS_TheSansMonoCd_W5Regular_11">bne</samp>
    instruction is a companion to the <samp class="SANS_TheSansMonoCd_W5Regular_11">ceq</samp>
    instruction we encountered in [Listing 5-1](#list5-1). Whereas <samp class="SANS_TheSansMonoCd_W5Regular_11">ceq</samp>
    pushes its result onto the evaluation stack, <samp class="SANS_TheSansMonoCd_W5Regular_11">bne</samp>
    jumps to the specified label (<samp class="SANS_TheSansMonoCd_W5Regular_11">IL_0042</samp>
    in this example) if the values being compared are *not* equal; otherwise, processing
    continues from the next instruction following <samp class="SANS_TheSansMonoCd_W5Regular_11">bne</samp>.
  prefs: []
  type: TYPE_NORMAL
- en: The fact that we’re attempting to compare a simple tuple with a tuple that has
    named elements is irrelevant. The generated code doesn’t attempt to use the names
    we’ve given the fields. It’s comparing only their values, so the result of <samp
    class="SANS_TheSansMonoCd_W5Regular_11">x</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">==</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">y</samp> is <samp class="SANS_TheSansMonoCd_W5Regular_11">true</samp>.
    We could compare <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp> with a
    tuple using different names with the same result; only the types and values of
    the fields matter.
  prefs: []
  type: TYPE_NORMAL
- en: The names we give the tuple components are a purely compile-time construct for
    *our* convenience. In fact, the names we give the <samp class="SANS_TheSansMonoCd_W5Regular_11">y</samp>
    variable’s components never even make it into the compiled code.
  prefs: []
  type: TYPE_NORMAL
- en: As with the generated code for comparing <samp class="SANS_TheSansMonoCd_W5Regular_11">Nullable<
    T ></samp> values, the compiler will inject code to call a user-defined <samp
    class="SANS_TheSansMonoCd_W5Regular_11">operator==</samp> if needed. You can see
    this in [Listing 5-33](#list5-33), which shows the CIL for the comparison of the
    second component of our tuples, a <samp class="SANS_TheSansMonoCd_W5Regular_11">string</samp>
    field.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 5-33: The call to a
    user-defined equality operator inserted by the compiler</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: Instead of the <samp class="SANS_TheSansMonoCd_W5Regular_11">bne</samp> instruction
    used for the <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp> field, the
    compiler has synthesized a call to <samp class="SANS_TheSansMonoCd_W5Regular_11">op_Equality</samp>,
    exactly as if we’d handwritten the code. Fields of a value tuple are compared
    in the order in which they appear, so the first field of one is compared with
    the first field of the corresponding variable, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: This approach differs from records, which use the <samp class="SANS_TheSansMonoCd_W5Regular_11">EqualityComparer</samp>
    protocol instead of <samp class="SANS_TheSansMonoCd_W5Regular_11">==</samp> to
    compare their fields. For records, the compiler generates the right methods on
    the underlying class or struct type to implement equality. When we compare two
    records with <samp class="SANS_TheSansMonoCd_W5Regular_11">==</samp>, we’re invoking
    the <samp class="SANS_TheSansMonoCd_W5Regular_11">op_Equality</samp> method generated
    for the record type. That method compares each field of the record in turn by
    using its <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp> method.
  prefs: []
  type: TYPE_NORMAL
- en: For value tuples, as with nullable value types, the compiler generates the comparison
    code *inline*, effectively replacing the comparison of two tuples with a direct
    comparison of the component fields of each tuple type. If a component field of
    the tuple has an <samp class="SANS_TheSansMonoCd_W5Regular_11">operator==</samp>
    defined for it, that implementation is used, but like <samp class="SANS_TheSansMonoCd_W5Regular_11">Nullable<
    T ></samp>, the <samp class="SANS_TheSansMonoCd_W5Regular_11">ValueTuple</samp>
    type used to implement value tuples has no <samp class="SANS_TheSansMonoCd_W5Regular_11">operator==</samp>
    of its own.
  prefs: []
  type: TYPE_NORMAL
- en: If the fields can’t be compared using either <samp class="SANS_TheSansMonoCd_W5Regular_11">ceq</samp>
    or <samp class="SANS_TheSansMonoCd_W5Regular_11">operator==</samp>, our code using
    <samp class="SANS_TheSansMonoCd_W5Regular_11">==</samp> to compare the value tuple
    fails to compile. The <samp class="SANS_TheSansMonoCd_W5Regular_11">ValueTuple</samp>
    type does override the <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp>
    method and also implements the <samp class="SANS_TheSansMonoCd_W5Regular_11">IEquatable<
    T ></samp> interface. Therefore, if a field has no <samp class="SANS_TheSansMonoCd_W5Regular_11">operator==</samp>,
    we can still compare value tuple variables with <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp>,
    which in turn will call each field’s <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp>
    method, safe in the knowledge that <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp>
    is always there, whatever type we’re using.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Summary</samp>
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*All animals are equal, but some animals are more equal than others.*'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: —George Orwell, *Animal Farm*
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: For such a simple expression, comparing two variables for equality can represent
    a wide variety of behavior, from using a simple built-in equality check with <samp
    class="SANS_TheSansMonoCd_W5Regular_11">ceq</samp> in the compiled code all the
    way up to the compiler automatically generating the correct code to perform a
    comparison. We’ve looked at how references are compared, how overriding the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp> method and <samp class="SANS_TheSansMonoCd_W5Regular_11">==</samp>
    operator can affect behavior, and how the compiler can generate code to make sure
    the “right thing” happens.
  prefs: []
  type: TYPE_NORMAL
- en: For many programmers, using <samp class="SANS_TheSansMonoCd_W5Regular_11">==</samp>
    to compare variables comes more naturally than calling the <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp>
    method. For the built-in numeric types, using <samp class="SANS_TheSansMonoCd_W5Regular_11">==</samp>
    is always more efficient, although with the binary floating-point types <samp
    class="SANS_TheSansMonoCd_W5Regular_11">float</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp>,
    we have to be cautious of using either approach. Notwithstanding that, the cost
    of calling a method is very small, but it can never be as fast as the intrinsic
    <samp class="SANS_TheSansMonoCd_W5Regular_11">ceq</samp> instruction.
  prefs: []
  type: TYPE_NORMAL
- en: The purpose of examining these effects in such intricate detail is to demonstrate
    that we can’t necessarily take for granted what such a simple expression does
    when a program runs. The run-time complexity of any expression may be hidden from
    view, perhaps masked by the compiler choosing an unexpected method overload or
    override instead of a direct comparison between two variables. Certainly the performance
    costs in such examples are small, but they might be significant in “hot” paths
    through a program.
  prefs: []
  type: TYPE_NORMAL
- en: Boxing value type instances can have a significant effect on performance, not
    only because boxing generates copies of the value, but also because those copies
    are put on the heap and add pressure to the garbage collector. The standard <samp
    class="SANS_TheSansMonoCd_W5Regular_11">IEquatable< T ></samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">EqualityComparer<
    T ></samp> types help us avoid many cases where boxing would otherwise be required,
    especially in generic code.
  prefs: []
  type: TYPE_NORMAL
- en: We should always be aware of those circumstances where the compiler generates
    code on our behalf, but in the case of equality comparisons, the compiler goes
    to quite a lot of trouble to make sure that code is as efficient as possible.
  prefs: []
  type: TYPE_NORMAL
