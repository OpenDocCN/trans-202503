- en: Chapter 12. Performance
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '第 12 章 性能  '
- en: The relative performance of Ruby on Rails compared to other languages and web
    frameworks is still a topic of debate. A quick Google search reveals that many
    people feel Ruby on Rails is slow.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 'Ruby on Rails 相对于其他语言和 Web 框架的性能仍然是一个争议话题。通过快速 Google 搜索可以发现，许多人认为 Ruby on
    Rails 很慢。  '
- en: Newer versions of the Ruby interpreter have made great strides where performance
    is concerned. Ruby 2.0 included garbage collection optimizations and other improvements
    that made it much faster than older versions. Ruby 2.1 introduced a generational
    garbage collector that was even faster still.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 'Ruby 解释器的更新版本在性能方面取得了显著进展。Ruby 2.0 包括了垃圾回收优化和其他改进，使其比旧版本更快。Ruby 2.1 引入了一个代际垃圾收集器，性能更为出色。  '
- en: As the Ruby language has improved, so has Ruby on Rails. The Rails framework
    now includes several features designed specifically to improve application performance.
    This chapter starts with discussions of two of those built-in features and then
    moves on to cover some things you can do to improve performance. Finally, I’ll
    talk about the caching techniques supported by Rails.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: '随着 Ruby 语言的进步，Ruby on Rails 也在不断改进。Rails 框架现在包括了几项专门用于提升应用程序性能的功能。本章首先讨论其中的两项内建功能，然后介绍一些你可以做的事情来提高性能。最后，我将讨论
    Rails 支持的缓存技术。  '
- en: Built-in Optimization Features
  id: totrans-4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '内建优化功能  '
- en: The asset pipeline and turbolinks are two built-in Rails performance optimizations
    you’ve been using since creating your original blog. Both of these features are
    enabled by default on new Rails applications, and we’ll explore how they work
    here.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: '资源管道和 Turbolinks 是你在创建原始博客时就已经使用的两个内建的 Rails 性能优化功能。这两项功能在新的 Rails 应用程序中默认启用，我们将在这里探索它们是如何工作的。  '
- en: Asset Pipeline
  id: totrans-6
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '资源管道  '
- en: The *asset pipeline* is a Rails feature that combines all of the individual
    JavaScript and CSS files used by your application into one JavaScript and one
    CSS file, reducing the number of requests a browser makes to render a web page
    because your application uses more than one file of each type. Web browsers are
    limited in the number of requests they can make in parallel, so fewer requests
    should result in faster loading pages.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: '*资源管道* 是 Rails 的一项功能，它将你应用程序中使用的所有单独的 JavaScript 和 CSS 文件合并成一个 JavaScript 文件和一个
    CSS 文件，从而减少浏览器为了渲染网页所发出的请求数量，因为你的应用程序使用了多个同类型的文件。浏览器并行请求的数量是有限的，因此较少的请求应该能使页面加载速度更快。  '
- en: The asset pipeline also *minifies*, or compresses, JavaScript and CSS files
    by removing whitespace and comments. Smaller files load faster, so your web pages
    load faster.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: '资源管道还会 *压缩*，或者说是压缩 JavaScript 和 CSS 文件，通过移除空白字符和注释。文件更小，加载更快，因此你的网页加载速度也更快。  '
- en: Finally, the asset pipeline preprocessor also enables you to use higher-level
    languages such as CoffeeScript instead of JavaScript and Sass instead of plain
    CSS. Files in these higher-level languages are precompiled to plain JavaScript
    and CSS using their respective compilers before being served so web browsers can
    understand them.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: '最后，资源管道预处理器还使你能够使用更高级的语言，如 CoffeeScript 代替 JavaScript，以及 Sass 代替普通的 CSS。这些高级语言的文件会在被服务之前，通过各自的编译器预编译成普通的
    JavaScript 和 CSS，以便浏览器能够理解。  '
- en: Manifests
  id: totrans-10
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '清单  '
- en: As you generate controllers for your application, Rails also generates a corresponding
    JavaScript and CSS file in the *app/assets/javascripts* and *app/assets/stylesheets*
    directories. Rather than link to each of these files separately in your application,
    Rails uses a manifest file. As mentioned in [Chapter 5](ch05.html "Chapter 5. Views"),
    a manifest file is a list of other files needed by your application.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 当你为应用程序生成控制器时，Rails 还会在 *app/assets/javascripts* 和 *app/assets/stylesheets*
    目录中生成相应的 JavaScript 和 CSS 文件。Rails 使用清单文件，而不是单独链接到这些文件。正如在 [第 5 章](ch05.html "第
    5 章 视图")中提到的，清单文件是应用程序所需的其他文件的列表。
- en: Manifest files use *directives*, instructions specifying other files to include,
    in order to build a single file for use in the production environment. The `require`
    directive includes a single file in the manifest. The `require_tree` directive
    includes all files in a directory. The `require_self` directive includes the contents
    of the manifest file.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: '清单文件使用 *指令*，这些指令指定要包含的其他文件，以便生成一个用于生产环境的单一文件。`require` 指令包含清单中的单一文件。`require_tree`
    指令包含一个目录中的所有文件。`require_self` 指令包含清单文件的内容。  '
- en: 'To see an example, open the default CSS manifest at *app/assets/stylesheets/application.css*:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '要查看示例，请打开默认的 CSS 清单文件 *app/assets/stylesheets/application.css*：  '
- en: '[PRE0]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This file first uses the `require_tree .` directive ➊ to include all CSS files
    in the current directory. It then includes the Bootstrap stylesheets using the
    `require bootstrap` directive ➋ you added in [Chapter 9](ch09.html "Chapter 9. Authentication").
    Finally, the `require_self` directive ➌ includes the contents of this file below
    the comment block. Currently, nothing appears below the comment block.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 这个文件首先使用`require_tree .`指令 ➊来包含当前目录下的所有 CSS 文件。接着，它使用你在[第9章](ch09.html "第9章.
    身份验证")中添加的`require bootstrap`指令包含了 Bootstrap 样式表。最后，`require_self`指令 ➌将这个文件的内容包括在注释块下面。目前，注释块下方没有任何内容。
- en: 'The asset pipeline searches for assets in three different locations by default.
    You know about one of them already: The *app/assets* directory is used for CSS,
    JavaScript, and image files owned by your application.'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 资源管道默认在三个不同的位置搜索资源。你已经知道其中一个位置：*app/assets*目录用于存放你应用程序的 CSS、JavaScript 和图片文件。
- en: The *lib/assets* directory is for assets needed by libraries you have written.
    Because you haven’t written any libraries yet, this directory is currently empty.
    The *vendor/assets* directory is for assets created by third parties, such as
    code for JavaScript plug-ins and CSS frameworks.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '*lib/assets*目录用于存放你编写的库所需的资源。由于你还没有编写任何库，这个目录目前是空的。*vendor/assets*目录用于存放第三方创建的资源，如
    JavaScript 插件和 CSS 框架的代码。'
- en: 'Ruby gems can add their own directories to the list of locations that the asset
    pipeline searches. You can see this in the JavaScript manifest at *app/assets/javascripts/application.js*:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: Ruby gems 可以将它们自己的目录添加到资源管道搜索的路径列表中。你可以在 JavaScript 清单文件*app/assets/javascripts/application.js*中看到这一点：
- en: '[PRE1]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: This file uses the `require` directive ➊ to include the jQuery, jQuery UJS,
    and Turbolinks libraries that are part of the jquery-rails and turbolinks gems
    included in your application’s *Gemfile*.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 这个文件使用`require`指令 ➊来引入 jQuery、jQuery UJS 和 Turbolinks 库，这些库是你应用程序的*Gemfile*中包含的
    jquery-rails 和 turbolinks gems 的一部分。
- en: It then uses `require_tree` ➋ to include all JavaScript files in the current
    directory. Finally, it requires the JavaScript files ➌ needed by the Bootstrap
    CSS framework.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 它接着使用`require_tree` ➋来包含当前目录下的所有 JavaScript 文件。最后，它要求 Bootstrap CSS 框架所需的 JavaScript
    文件 ➌。
- en: You won’t find *jquery*, *jquery_ujs*, *turbolinks*, or *bootstrap* in the *vendor/assets/javascripts*
    directory. Instead, the gems that provide these files have updated the asset pipeline
    search path to include their own directories.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 你不会在*vendor/assets/javascripts*目录中找到*jquery*、*jquery_ujs*、*turbolinks*或*bootstrap*。相反，提供这些文件的
    gems 已经更新了资源管道搜索路径，将它们自己的目录添加到路径中。
- en: You can see the complete list of asset pipeline search paths by entering `Rails.application.config.assets.paths`
    in the Rails console. This statement returns an array of paths. In this list,
    you should find paths such as *jquery-rails-3.1.0/vendor/assets/javascript*, *turbolinks-2.2.2/lib/assets/javascripts*,
    and *bootstrap-sass-3.1.1.0/vendor/assets/javascripts*.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过在 Rails 控制台中输入`Rails.application.config.assets.paths`来查看资源管道搜索路径的完整列表。这条语句将返回一个路径数组。在这个列表中，你应该能找到像*jquery-rails-3.1.0/vendor/assets/javascript*、*turbolinks-2.2.2/lib/assets/javascripts*和*bootstrap-sass-3.1.1.0/vendor/assets/javascripts*这样的路径。
- en: Debug Mode
  id: totrans-24
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 调试模式
- en: As you’ve seen, CSS and JavaScript files are served as separate, uncompressed
    files in the development environment. Your social media application is serving
    31 separate CSS and JavaScript files according to the server output. An asset
    pipeline configuration called *debug mode* controls how assets are handled in
    each environment.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，在开发环境中，CSS 和 JavaScript 文件作为单独的、未压缩的文件提供。根据服务器输出，你的社交媒体应用程序提供了31个单独的 CSS
    和 JavaScript 文件。一个名为*调试模式*的资源管道配置控制着每个环境中资源的处理方式。
- en: In the development environment, debug mode is turned on. That means the files
    referred to in the CSS and JavaScript files are served separately, which is useful
    if you need to debug an issue with a file using your browser’s development tools.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在开发环境中，调试模式已开启。这意味着 CSS 和 JavaScript 文件中引用的文件将单独提供，如果你需要使用浏览器的开发工具调试文件中的问题，这样做非常有用。
- en: 'If you want to force assets to be combined and preprocessed so you can see
    how they are served in the production environment, you can turn off debug mode.
    Just change the value of `config.assets.debug` near the bottom of the development
    environment configuration file *config/environments/development.rb*:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想强制将资源合并并预处理，以便查看它们在生产环境中如何提供，你可以关闭调试模式。只需在开发环境配置文件*config/environments/development.rb*的底部修改`config.assets.debug`的值即可：
- en: '[PRE2]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'When debug mode is off, Rails concatenates and runs preprocessors, such as
    the CoffeeScript or Sass compiler, on all files before serving them. Restart the
    Rails server after modifying this file, and then check the server output in your
    terminal to see the difference:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 当调试模式关闭时，Rails会将所有文件合并并运行预处理器（如CoffeeScript或Sass编译器），然后再提供它们。修改此文件后，重新启动Rails服务器，然后检查终端中的服务器输出，看看有什么不同：
- en: '[PRE3]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Only two files (➊ and ➋) are served now—the CSS and JavaScript manifest files.
    This setting can actually slow down page loads in development because the files
    are combined for every request, so change `config.assets.debug` back to `true`
    before continuing.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 现在只会提供两个文件（➊和➋）——CSS和JavaScript清单文件。这个设置在开发模式下可能会减慢页面加载速度，因为每个请求都会将文件合并，因此在继续之前，请将`config.assets.debug`设置为`true`。
- en: Asset Precompilation
  id: totrans-32
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 资源预编译
- en: In the production environment, you should precompile your application’s assets
    and serve them as static files by your web server. You can precom-pile assets
    in several ways. When you deployed your blog to Heroku in [Chapter 6](ch06.html
    "Chapter 6. Deployment"), you precompiled assets during deployment. Rails also
    includes a `rake` task to precompile assets.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在生产环境中，你应该预编译应用程序的资源，并通过你的Web服务器将它们作为静态文件提供。你可以通过几种方式预编译资源。当你在[第6章](ch06.html
    "第6章。部署")中将博客部署到Heroku时，你在部署过程中预编译了资源。Rails还包括一个`rake`任务来预编译资源。
- en: 'The `rake` task compiles all files from your CSS and JavaScript manifests and
    writes them to the *public/assets* directory. You can precompile assets for the
    production environment with the following command:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '`rake`任务会从你的CSS和JavaScript清单中编译所有文件，并将它们写入*public/assets*目录。你可以使用以下命令为生产环境预编译资源：'
- en: '[PRE4]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: During precompilation, an MD5 hash is generated from the contents of the compiled
    files and inserted into the filenames as the files are saved. Because the filename
    is based on the contents of the file, you can be sure the correct version of the
    file is served if you update a file.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在预编译过程中，会根据编译文件的内容生成一个MD5哈希，并将其插入到文件名中。当文件被保存时，文件名会基于文件内容，因此，如果你更新了文件，你可以确保提供的是正确版本的文件。
- en: 'For example, after precompilation, the file *app/assets/stylesheets/application.css*
    might be named *public/assets/application-d5ac076c28e38393c3059d7167501 838.css*.
    Rails view helpers use the correct name automatically in production. You don’t
    need the compiled assets for development, so when you’re finished looking at them,
    remove them using the `assets:clobber rake` task:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，预编译后，文件*app/assets/stylesheets/application.css*可能会被命名为*public/assets/application-d5ac076c28e38393c3059d7167501838.css*。Rails视图助手会在生产环境中自动使用正确的文件名。开发环境中不需要编译过的资源，因此，当你看完它们后，可以使用`assets:clobber
    rake`任务将其删除：
- en: '[PRE5]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: This command deletes the *public/assets* directory and all of its contents.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 这个命令会删除*public/assets*目录及其所有内容。
- en: In [Chapter 15](ch15.html "Chapter 15. Custom Deployment"), you’ll learn how
    to deploy your application to your own server using a program called Capistrano.
    You can configure Capistrano to precompile assets automatically during deployment
    just as you did when you deployed the blog to Heroku.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第15章](ch15.html "第15章。自定义部署")中，你将学习如何使用一个名为Capistrano的程序将你的应用程序部署到自己的服务器。你可以配置Capistrano，在部署过程中自动预编译资源，就像你在将博客部署到Heroku时所做的那样。
- en: Turbolinks
  id: totrans-41
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Turbolinks
- en: The asset pipeline reduces the number of requests the web browser makes for
    assets, but the browser still needs to parse and recompile the CSS and JavaScript
    for every page. Depending on the amount of CSS and JavaScript your application
    includes, this could take a significant amount of time.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 资源管道减少了浏览器请求资源的次数，但浏览器仍然需要为每个页面解析并重新编译CSS和JavaScript。根据你的应用程序中包含的CSS和JavaScript的数量，这可能会消耗相当多的时间。
- en: '*Turbolinks* is a Rails feature that speeds up the process of following links
    in your application by replacing the contents of the current page’s `body` and
    the `title` with the data for the new page instead of loading an entirely new
    page. With turbolinks, CSS and JavaScript files are not even downloaded when a
    link is clicked.'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '*Turbolinks*是Rails的一个功能，它通过替换当前页面`body`和`title`的内容为新页面的数据，而不是加载整个新页面，从而加速了在你的应用程序中跟随链接的过程。使用Turbolinks时，点击链接时甚至不会下载CSS和JavaScript文件。'
- en: Turbolinks in Action
  id: totrans-44
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Turbolinks的实际应用
- en: 'Turbolinks is on by default in new Rails applications. You’ve been using it
    without even knowing since you built your first application in [Chapter 2](ch02.html
    "Chapter 2. Rails Fundamentals"). You can see it working by watching the output
    from the Rails server. Go to *http://localhost:3000/* in your browser and check
    the output in your terminal:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在新的 Rails 应用程序中，Turbolinks 默认启用。从你在[第 2 章](ch02.html "第 2 章. Rails 基础")构建第一个应用程序开始，你就一直在使用它。你可以通过查看
    Rails 服务器的输出看到它在工作。打开浏览器，访问*http://localhost:3000/*，并检查终端中的输出：
- en: '[PRE6]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'After the `GET` request for the posts index page, the browser fetches all of
    the CSS and JavaScript files needed by your application. Now click a link such
    as New Text Post on the index page and check the output again:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在对帖子索引页发出 `GET` 请求后，浏览器会获取应用程序所需的所有 CSS 和 JavaScript 文件。现在点击索引页上的一个链接，比如“新建文本帖子”，再次检查输出：
- en: '[PRE7]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The browser only makes a `GET` request for the New Text Post page. It does not
    fetch the CSS and JavaScript files because they are already loaded in memory.
    Finally, click the Back button in your browser.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 浏览器只会发出对新文本帖子的 `GET` 请求。它不会重新加载 CSS 和 JavaScript 文件，因为这些文件已经被加载到内存中。最后，点击浏览器中的返回按钮。
- en: This time there is no output in the terminal window. The index page was cached
    in the browser and no requests were sent to the server. Turbolinks caches ten
    pages by default.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 这次终端窗口中没有输出。索引页已在浏览器中缓存，没有请求发送到服务器。Turbolinks 默认会缓存十个页面。
- en: JavaScript Events
  id: totrans-51
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: JavaScript 事件
- en: If your application includes JavaScript code that uses jQuery’s `ready` function
    to attach event handlers or trigger other code, the JavaScript needs to be modified
    to work with turbolinks. Because turbolinks doesn’t reload the entire page when
    a link is clicked, the `ready` function is not called.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的应用程序包含使用 jQuery 的 `ready` 函数来附加事件处理程序或触发其他代码的 JavaScript 代码，那么需要修改这些 JavaScript
    代码，使其与 turbolinks 配合工作。因为 turbolinks 在点击链接时不会重新加载整个页面，所以 `ready` 函数不会被调用。
- en: 'Instead, the `page:load` event is fired at the end of the loading process.
    You can see this in action by adding the following CoffeeScript code to *app/assets/javascripts/posts.js.coffee*:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，`page:load` 事件会在加载过程结束时触发。你可以通过将以下 CoffeeScript 代码添加到 *app/assets/javascripts/posts.js.coffee*
    来看到这个过程：
- en: '[PRE8]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Unfortunately, CoffeeScript is beyond the scope of this book, but you might
    recognize what this code snippet does if you’re already familiar with JavaScript.
    It prints “Document Ready” ➊ in your browser’s JavaScript console when the page
    first loads, and “Page Load” ➋ when you click a link that uses turbolinks.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，CoffeeScript 超出了本书的范围，但如果你已经熟悉 JavaScript，可能会认识到这段代码的作用。它会在页面首次加载时在浏览器的
    JavaScript 控制台打印“Document Ready” ➊，而当你点击一个使用 turbolinks 的链接时，打印“Page Load” ➋。
- en: Because you aren’t currently using `$(document).ready()` to trigger any JavaScript
    code, you don’t need to worry about this right now. But you should revisit this
    section if you ever start using the `ready` function.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 因为你当前没有使用 `$(document).ready()` 来触发任何 JavaScript 代码，所以你现在不需要担心这个问题。但如果你以后开始使用
    `ready` 函数，应该重新查看这一部分内容。
- en: Code Optimizations
  id: totrans-57
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 代码优化
- en: Now that you’ve seen a few of the built-in optimizations provided by Rails,
    let’s look at extra things you can do to improve performance. I’ll cover some
    techniques you can use to reduce the number of database queries your application
    makes and improve the performance of slow queries.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经看过了 Rails 提供的一些内建优化，我们来看看你可以做哪些额外的事情来提高性能。我将介绍一些你可以用来减少应用程序数据库查询次数并提升慢查询性能的技巧。
- en: Reducing Database Queries
  id: totrans-59
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 减少数据库查询
- en: Rails models make accessing data so easy that you might forget you’re actually
    querying a database. Luckily, the Rails server shows SQL statements in the terminal.
    Look at this output as you navigate your application to spot possible inefficiencies.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: Rails 模型让访问数据变得如此简单，以至于你可能会忘记你实际上是在查询数据库。幸运的是，Rails 服务器会在终端显示 SQL 语句。当你浏览应用程序时，查看这些输出，找出可能的低效之处。
- en: Examining SQL Output
  id: totrans-61
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 检查 SQL 输出
- en: 'Make sure your server is running, and keep an eye on your terminal output as
    I walk you through a few examples. Be sure you are logged out of the application
    before you start. First, browse to the login page at *http://localhost:3000/login*
    and check the server output:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 确保你的服务器正在运行，并且在我带你通过几个示例时密切关注终端输出。在开始之前，确保你已经登出了应用程序。首先，浏览到登录页面 *http://localhost:3000/login*，并检查服务器输出：
- en: '[PRE9]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: This page doesn’t produce any SQL queries.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 这个页面不会生成任何 SQL 查询。
- en: 'Now log in to the application:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 现在登录到应用程序：
- en: '[PRE10]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: This page produces one SQL query ➊ as Rails loads the user matching the email
    address you entered on the previous page. The `create` method in `SessionsController`
    uses this record to authenticate the password you entered.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 该页面生成了一条 SQL 查询 ➊，因为 Rails 加载了与你在前一页面输入的电子邮件地址匹配的用户记录。`SessionsController` 中的
    `create` 方法使用该记录来验证你输入的密码。
- en: 'After you log in to the application, you should be redirected to the posts
    index page. Your server output for that page should look something like this:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 登录到应用后，你应该会被重定向到帖子索引页面。该页面的服务器输出应该类似于下面这样：
- en: '[PRE11]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: This page produces six queries. It first finds the user with id 1 ➊; this query
    looks up the `current_user` inside the `authenticate_user!` call in `PostController.`
    Next, the page finds the ids ➋ of the users the current user is following in the
    call to `current_user.timeline_user_ids`. It then finds posts ➌ where the `user_id`
    matches the `id` of the `current_user` or one of his or her followers.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 该页面生成了六条查询。首先，它查找了 id 为 1 的用户 ➊；该查询在 `PostController` 中的 `authenticate_user!`
    调用中查找 `current_user`。接下来，页面通过 `current_user.timeline_user_ids` 查找当前用户所关注的用户的 id
    ➋。然后，它查找帖子 ➌，这些帖子的 `user_id` 与 `current_user` 或其关注者的 `id` 匹配。
- en: 'Finally, the page queries for a user ➍ matching an `id` with `SELECT "users".*
    FROM "users"` three times in a row. That looks a little strange to me. My index
    page has three posts, but there are three extra queries. Let’s look at the `index`
    action in *app/controllers/posts_controller.rb* and see what’s happening:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，页面会进行三次连续的查询 ➍，通过 `SELECT "users".* FROM "users"` 查找与 `id` 匹配的用户。这看起来有点奇怪。我的索引页面上有三篇帖子，但多出了三条查询。我们来看一下
    *app/controllers/posts_controller.rb* 中的 `index` 动作，看看发生了什么：
- en: '[PRE12]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: This code calls authenticate_user! ➊ before each action. The index action finds
    the user_ids ➋ that current_user wants to see and then finds the posts ➌ matching
    those users. You’ve already accounted for those queries in the previous server
    output. Since the index action isn’t creating the three user queries, they must
    be coming from the view.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码在每个动作之前调用了 authenticate_user! ➊。`index` 动作找到当前用户希望查看的 `user_ids` ➋，然后查找匹配这些用户的帖子
    ➌。你已经在之前的服务器输出中考虑了这些查询。由于 `index` 动作没有创建三条用户查询，这些查询一定是来自视图。
- en: 'The `index` view renders the collection of posts. That means the source of
    these queries must be in the `TextPost` partial in *app/views/text_posts/_text_post.html.erb*:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '`index` 视图呈现帖子集合。这意味着这些查询的源头必须在 *app/views/text_posts/_text_post.html.erb*
    中的 `TextPost` 部分：'
- en: '[PRE13]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Here’s the problem. The name ➊ of the user who created each post is displayed
    by calling text_post.user.name. If you check the ImagePost partial, you can verify
    it does the same thing. For every post displayed, an extra query is generated,
    which explains the three extra queries you saw in the SQL output.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是问题所在。每篇帖子创建者的名字 ➊ 是通过调用 `text_post.user.name` 来显示的。如果你检查 ImagePost 部分，你可以验证它也做了同样的事情。每显示一篇帖子，就会生成一条额外的查询，这就解释了你在
    SQL 输出中看到的三条额外查询。
- en: N + 1 Queries
  id: totrans-77
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: N + 1 查询
- en: Code that creates an extra database query for each record in a collection falls
    into a category of problems called *N + 1 Queries*. These problems are common
    in Rails applications, and they occur when associations on a collection are referenced
    without first loading the associated models.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 创建每个记录的额外数据库查询的代码属于 *N + 1 查询* 问题类别。这些问题在 Rails 应用中很常见，当集合上的关联被引用时，如果没有先加载关联的模型，就会发生这种情况。
- en: In this case, I loaded a collection of posts into `@posts`. I then referenced
    the `name` for the `user` who created each post. Because I didn’t load all of
    those users in advance, Rails fetches them one at a time from the database as
    the page is rendered. These extra queries meant the three posts on the index page
    resulted in four queries. The number of queries is always one more than the number
    of items in the collection.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我将一组帖子加载到 `@posts` 中。然后我引用了每个帖子创建者的 `name`。因为我没有提前加载这些用户，Rails 会在渲染页面时逐个从数据库中获取它们。这些额外的查询意味着索引页面上的三条帖子导致了四条查询。查询的数量总是比集合中的项数多一个。
- en: Luckily, this problem is easy to fix. In Rails, you can specify in advance all
    associations that are going to be needed with the `includes` method. This technique
    is called *eager loading*.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，这个问题很容易修复。在 Rails 中，你可以提前使用 `includes` 方法指定所有需要的关联。这个技巧被称为 *预加载*。
- en: 'Let’s update the `index` action in `PostsController` to use eager loading now:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们更新 `PostsController` 中的 `index` 动作，使用预加载：
- en: '[PRE14]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Here, I chain the includes(:user) method ➊ to the query that sets @posts. The
    symbol passed to includes must match the name of an association on the model.
    In this case, post belongs_to :user.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我将`includes(:user)`方法 ➊ 链接到设置`@posts`的查询中。传递给`includes`的符号必须与模型中的关联名称匹配。在这个例子中，`post`属于`:user`。
- en: 'With the `includes` method, Rails ensures that the specified associations are
    loaded using the minimum number of queries. After you save this file, refresh
    the index page in your browser and check the SQL output in your terminal:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`includes`方法，Rails确保使用最少的查询加载指定的关联。在保存此文件后，刷新浏览器中的索引页面，并查看终端中的SQL输出：
- en: '[PRE15]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The three queries to find each user have been replaced with ➊ a single query
    that finds all users at once.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 查找每个用户的三个查询已被 ➊ 替换为一个查询，一次性查找所有用户。
- en: Watch out for extra queries as you build applications. Look for calls like `text_post.user.name`
    in the view. Notice the two dots in that call. The two dots mean you’re accessing
    data in an associated model, which can introduce an N + 1 Queries problem, so
    you should preload the association before the view is rendered.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在构建应用程序时，要注意额外的查询。检查视图中类似`text_post.user.name`的调用。注意这个调用中的两个点。两个点意味着你正在访问一个关联模型中的数据，这可能会引入N
    + 1查询问题，因此你应该在视图渲染之前预加载该关联。
- en: Pagination
  id: totrans-88
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 分页
- en: You’ve reduced the number of database queries needed to load posts for the index
    page, but think about what happens when you have thousands of posts. The index
    page tries to show them all, increasing your application’s load time by a lot.
    You can use *pagination*, the process of splitting a collection of records into
    multiple pages, to alleviate this problem.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经减少了加载索引页面帖子所需的数据库查询次数，但想想当你有成千上万条帖子时会发生什么。索引页面会尝试显示所有这些帖子，显著增加应用程序的加载时间。你可以使用*分页*，即将记录集合分割成多个页面的过程，来缓解这个问题。
- en: 'The will_paginate gem can do all the pagination for you. First, add `will_paginate`
    to your application’s *Gemfile*:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '`will_paginate` gem可以为你处理所有分页。首先，将`will_paginate`添加到你的应用程序的*Gemfile*中：'
- en: '[PRE16]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Remember to always update installed gems after changing the *Gemfile*:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 记得在更改*Gemfile*后始终更新已安装的gem：
- en: '[PRE17]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Next, update the `index` action in *app/controllers/posts_controller.rb* to
    add a call to the `paginate` method:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，更新*app/controllers/posts_controller.rb*中的`index`操作，添加对`paginate`方法的调用：
- en: '[PRE18]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The `paginate` method is chained with the other methods that set the instance
    variable `@posts` ➊. The will_paginate gem adds `params[:page]` automatically.
    I specified `per_page: 5` so you can see the pagination working with only 6 posts
    in your database. The default is 30 records per page.'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '`paginate`方法与其他设置实例变量`@posts` ➊ 的方法链式调用。`will_paginate` gem 会自动添加`params[:page]`。我指定了`per_page:
    5`，这样你可以在数据库中只有6个帖子时看到分页效果。默认每页30条记录。'
- en: The `paginate` method adds the correct `limit` and `offset` calls to the database
    query automatically so the minimum number of records are selected.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '`paginate`方法自动将正确的`limit`和`offset`调用添加到数据库查询中，从而选择最少的记录。'
- en: 'Finally, open the `index` view at *app/views/posts/index.html.erb* and add
    a call to `will_paginate` at the end of the page:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，打开`index`视图（位于*app/views/posts/index.html.erb*），并在页面的末尾添加对`will_paginate`的调用：
- en: '[PRE19]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The `will_paginate` view helper ➊ accepts a collection of records, in this case
    `@posts`, and renders the correct links to navigate through the pages of this
    collection.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '`will_paginate`视图助手 ➊ 接受一个记录集合，这里是`@posts`，并渲染正确的链接以便在该集合的各页之间导航。'
- en: To see this working, you need to restart your Rails server since you added a
    new gem. Then create new posts until you have at least six, and browse to a user
    page. If you click through to the second page, as in [Figure 12-1](ch12.html#pagination_links
    "Figure 12-1. Pagination links"), you should see the new links.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 为了查看此功能，你需要重新启动你的Rails服务器，因为你添加了一个新的gem。然后创建新的帖子，直到至少有六个，并浏览到用户页面。如果你点击第二页，如[图12-1](ch12.html#pagination_links
    "图12-1. 分页链接")所示，你应该能看到新的链接。
- en: '![Pagination links](httpatomoreillycomsourcenostarchimages2169106.png.jpg)'
  id: totrans-102
  prefs: []
  type: TYPE_IMG
  zh: '![分页链接](httpatomoreillycomsourcenostarchimages2169106.png.jpg)'
- en: Figure 12-1. Pagination links
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 图12-1. 分页链接
- en: The `will_paginate` view helper added links to *Previous* and *1*, which you
    can click to go back to the first page from the second.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '`will_paginate`视图助手添加了*上一页*和*1*的链接，点击这些链接可以从第二页返回到第一页。'
- en: 'Check the server output again to see the query used to retrieve posts from
    the database:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 再次检查服务器输出，查看用于从数据库检索帖子时的查询：
- en: '[PRE20]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The query for page two ➊ now includes `LIMIT 5 OFFSET 5` as expected. This query
    only fetches posts that are needed to render the page.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 第二页的查询 ➊ 现在如预期包含了 `LIMIT 5 OFFSET 5`。这个查询只会获取渲染该页面所需的帖子。
- en: Caching
  id: totrans-108
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 缓存
- en: In programming, *caching* is the process of storing frequently used data so
    additional requests for the same data will be faster. Rails calls the place where
    data is stored a *cache store*. Rails applications commonly use two types of caching.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在编程中，*缓存*是存储频繁使用的数据的过程，以便对相同数据的后续请求能够更快地返回。Rails 将存储数据的地方称为 *缓存存储*。Rails 应用程序通常使用两种类型的缓存。
- en: '*Low-level caching* stores the result of time-consuming calculations in the
    cache—useful for values that are frequently read, but rarely change. *Fragment
    caching* stores parts of a view in the cache to speed up page rendering. Rendering
    a large collection of models can be time consuming. If the data rarely changes,
    fragment caching can increase your application’s page load speed.'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '*低级缓存*将耗时计算的结果存储在缓存中——这对那些经常读取但很少变化的值非常有用。*片段缓存*将视图的一部分存储在缓存中，以加速页面渲染。渲染大量模型集合可能会很耗时。如果数据很少变化，片段缓存可以提高应用程序的页面加载速度。'
- en: Caching is disabled, by default, in the development environment, so before you
    can start learning about it, you need to enable it. Leaving the cache disabled
    in development is a good idea because you always want to work with the latest
    version of data while in development. For example, if you store a value in the
    cache, then change the code that calculates that value, your application could
    return the cached value instead of the value calculated by the new code.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 缓存在开发环境中默认是禁用的，因此在开始学习之前，你需要启用它。在开发过程中保持缓存禁用是一个好主意，因为你总是希望在开发时使用最新版本的数据。例如，如果你将一个值存储在缓存中，然后修改计算该值的代码，那么应用程序可能会返回缓存中的值，而不是由新代码计算出来的值。
- en: 'You’ll enable caching in development for this chapter, so you can see how it
    works and learn about the types of caching used in Rails applications. Open *config/environments/development.rb*
    and change the value of `config.action_controller.perform_caching` to `true`:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章节中，你将启用开发环境中的缓存，以便了解它是如何工作的，并学习 Rails 应用程序中使用的缓存类型。打开 *config/environments/development.rb*
    并将 `config.action_controller.perform_caching` 的值更改为 `true`：
- en: '[PRE21]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Once you’re finished with this chapter, change this value back to `false` to
    disable caching in the development environment.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 完成本章内容后，将此值更改回 `false`，以禁用开发环境中的缓存。
- en: 'Rails supports several different cache stores. The default, `ActiveSupport::
    Cache::FileStore`, stores cached data on the filesystem. A popular choice for
    production applications is `ActiveSupport::Cache::MemCacheStore`, which uses the
    memcached server to store data. The memcached server is a high-performance cache
    store that supports distributed caching across several computers.'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: Rails 支持几种不同的缓存存储。默认的 `ActiveSupport::Cache::FileStore` 会将缓存数据存储在文件系统中。一个流行的生产环境缓存选择是
    `ActiveSupport::Cache::MemCacheStore`，它使用 memcached 服务器来存储数据。memcached 服务器是一个高性能的缓存存储，支持在多台计算机之间进行分布式缓存。
- en: 'Now that you’ve enabled caching, let’s specify a cache store for your application
    to use. Rather than install memcached on your computer, you can use the `ActiveSupport::Cache::MemoryStore`
    to demonstrate caching. This option also stores cached objects in your computer’s
    memory, but doesn’t require the installation of additional software. Add this
    line to *config/environments/development.rb* under the line you just changed:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经启用了缓存，让我们为你的应用程序指定一个缓存存储。你无需在电脑上安装 memcached，可以使用 `ActiveSupport::Cache::MemoryStore`
    来演示缓存。这个选项也将缓存对象存储在计算机的内存中，但无需安装额外的软件。在你刚刚修改的行下面，向 *config/environments/development.rb*
    添加这一行：
- en: '[PRE22]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Storing the cache in memory is faster than storing it on disk. The memory store
    allocates 32MB of memory, by default. When the amount of cached data exceeds this
    amount, the memory store runs a cleanup process that removes the least recently
    used objects, so you never need to worry about manually removing objects from
    the cache.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 将缓存存储在内存中比存储在磁盘上更快。内存存储默认分配 32MB 的内存。当缓存数据超过此量时，内存存储会执行清理过程，移除最少使用的对象，因此你无需担心手动从缓存中删除对象。
- en: Restart the Rails server for these changes to take effect.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 重启 Rails 服务器以使这些更改生效。
- en: Cache Keys
  id: totrans-120
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 缓存键
- en: Everything in the cache is referenced by cache key. A *cache key* is a unique
    string that identifies a particular object or other piece of data.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 缓存中的所有内容都通过缓存键进行引用。*缓存键*是一个唯一的字符串，用于标识特定的对象或其他数据。
- en: 'Active Record models include the `cache_key` method for generating a key automatically.
    You can try it in the Rails console by calling `cache_key` on an instance of a
    model:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: Active Record 模型包含 `cache_key` 方法，用于自动生成一个缓存键。你可以通过在模型实例上调用 `cache_key` 在 Rails
    控制台中尝试它：
- en: '[PRE23]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The cache key for this post is the pluralized version of the class name, followed
    by a slash, then the post `id`, a dash, and finally the `updated_at` date as a
    string ➊.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 该帖子的缓存键是类名的复数形式，后跟一个斜杠，然后是帖子的 `id`，再加上一个破折号，最后是 `updated_at` 日期作为字符串 ➊。
- en: Using the `updated_at` date as part of the key solves the cache invalidation
    problem. When the post is modified, the `updated_at` date changes, so its `cache_key`
    also changes. This way you don’t have to worry about getting out of date data
    from the cache.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `updated_at` 日期作为键的一部分解决了缓存失效的问题。当帖子被修改时，`updated_at` 日期会变化，因此其 `cache_key`
    也会发生变化。这样你就不必担心从缓存中获取过时的数据。
- en: Low-Level Caching
  id: totrans-126
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 低级缓存
- en: Low-level caching is useful when you need to perform a time-consuming calculation
    or database operation. It is frequently used with API requests that might take
    a while to return. Low-level caching in Rails uses the `Rails.cache.fetch` method.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 低级缓存在你需要执行一个耗时的计算或数据库操作时非常有用。它常用于可能需要较长时间才能返回的 API 请求。Rails 中的低级缓存使用 `Rails.cache.fetch`
    方法。
- en: The `fetch` method takes a cache key and attempts to read a matching value from
    the cache. The `fetch` method also takes a block. When given a block of Ruby code,
    if the value is not already in the cache, the method evaluates the block, writes
    the result to the cache, and returns the result.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '`fetch` 方法接受一个缓存键并尝试从缓存中读取匹配的值。`fetch` 方法还接受一个块。如果提供了 Ruby 代码块，当值不在缓存中时，该方法会执行块，计算结果并将其写入缓存，然后返回结果。'
- en: 'To demonstrate low-level caching, let’s show the number of comments for each
    post on the index page. To do this, first edit *app/views/text_posts/_text_post.html.erb*
    and add the comment count below the `text_post.body`:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 为了演示低级缓存，我们在索引页面上显示每个帖子的评论数。首先编辑 *app/views/text_posts/_text_post.html.erb*，并在
    `text_post.body` 下方添加评论计数：
- en: '[PRE24]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: This new line of code uses the `pluralize` helper method to pluralize the word
    “Comment” correctly based on the number of comments. For example, if the post
    has no comments, it prints “0 Comments”. Make a similar change to *app/views/image_posts/_image_post.html.erb*,
    replacing `text_post` with `image_post`.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 这行新代码使用了 `pluralize` 辅助方法，根据评论的数量正确地将“Comment”这个词变为复数。例如，如果帖子没有评论，它会显示“0 Comments”。对
    *app/views/image_posts/_image_post.html.erb* 进行类似的修改，将 `text_post` 替换为 `image_post`。
- en: 'Now refresh the posts index page in your browser and look at the server output:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 现在在浏览器中刷新帖子索引页面，查看服务器输出：
- en: '[PRE25]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: This change adds five new queries ➊ to count the number of comments for each
    post. Those extra queries take up valuable loading time, but you can improve performance
    by getting rid of them. One way to remove such queries is by caching the values
    you need (in this case, the number of comments per post) using `Rails.cache.fetch`.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 这个更改添加了五个新的查询 ➊ 用来统计每个帖子的评论数。这些额外的查询占用了宝贵的加载时间，但你可以通过消除它们来提高性能。消除这些查询的一种方法是通过使用
    `Rails.cache.fetch` 缓存你需要的值（在这种情况下是每个帖子的评论数）。
- en: 'You can perform the caching by adding a method to the `Post` model. Edit *app/models/post.rb*
    and add the `cached_comment_count` method, as shown here:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过向 `Post` 模型添加一个方法来执行缓存。编辑 *app/models/post.rb*，并添加 `cached_comment_count`
    方法，如下所示：
- en: '[PRE26]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: This method passes the array `[self, "comment_count"]` ➊ to the `Rails.cache.fetch`
    method. Here, `self` represents the current post. The `fetch` method combines
    these values into a single cache key. The block still calls `comments.size` as
    before.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 这个方法将数组 `[self, "comment_count"]` ➊ 传递给 `Rails.cache.fetch` 方法。在这里，`self` 代表当前的帖子。`fetch`
    方法将这些值组合成一个单一的缓存键。块仍然像以前一样调用 `comments.size`。
- en: 'Now update the `TextPost` and `ImagePost` views to use this new method:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 现在更新 `TextPost` 和 `ImagePost` 视图，使用这个新方法：
- en: '[PRE27]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: When you refresh the index page in your browser, the six comment count queries
    are executed one more time and the values are cached. Refresh the page again,
    watch the server output, and note the queries are no longer executed.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在浏览器中刷新索引页面时，六个评论计数查询将再次执行，并且这些值会被缓存。再次刷新页面，查看服务器输出，注意查询不再被执行。
- en: This caching solution has one small problem. The Rails `cache_key` method uses
    the post `id` and `updated_at` date to create the cache key, but adding a comment
    to a post does not change the post `updated_at` date. What you need is a way to
    update the post when a comment is added.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 这个缓存方案有一个小问题。Rails 的 `cache_key` 方法使用帖子的 `id` 和 `updated_at` 日期来创建缓存键，但向帖子添加评论不会改变帖子的
    `updated_at` 日期。你需要的是在添加评论时更新帖子。
- en: 'Rails provides the `touch` option to associations just for this purpose. When
    you specify `touch: true` on an association, Rails automatically sets the `updated_at`
    value of the parent model to the current time when any part of the association
    changes. This happens when a model is added or removed from the association or
    when one of the associated models is changed.'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 'Rails 提供了 `touch` 选项用于关联关系，正是为了这个目的。当你在关联关系上指定 `touch: true` 时，Rails 会在关联的任何部分发生变化时，自动将父模型的
    `updated_at` 值设置为当前时间。无论是当一个模型被添加或移除，还是当关联的某个模型发生更改时，这种情况都会发生。'
- en: 'Open *app/models/comment.rb* and add `touch: true` to the `belongs_to` association,
    as shown here:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '打开 *app/models/comment.rb* 并向 `belongs_to` 关联中添加 `touch: true`，如下所示：'
- en: '[PRE28]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Now the `updated_at` value on the post changes whenever one of its comments
    is updated or deleted or when a new comment is created for it. If you add a comment
    to a post, then reload the index page, the comment count query is executed for
    this post again and the new count is cached.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，帖子上的 `updated_at` 值会在其评论被更新、删除或为其创建新评论时发生变化。如果你向一个帖子添加评论，然后重新加载索引页面，该帖子的评论计数查询将再次执行，并且新的计数会被缓存。
- en: Note
  id: totrans-146
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '*You can also solve this problem using a Rails counter cache. With a counter
    cache, Rails keeps track of the number of comments associated with each post automatically.
    Enable this feature by adding a column named `comments_count` to the `Post` model
    and adding `counter_cache: true` to the `belongs_to :post` declaration inside
    the `Comment` model.*'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '*你也可以使用 Rails 的计数器缓存来解决这个问题。通过计数器缓存，Rails 会自动跟踪每个帖子关联的评论数量。通过向 `Post` 模型添加名为
    `comments_count` 的列，并在 `Comment` 模型中的 `belongs_to :post` 声明中添加 `counter_cache:
    true` 来启用此功能。*'
- en: Fragment Caching
  id: totrans-148
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 片段缓存
- en: Besides low-level caching of values, you can also use a Rails feature called
    *fragment caching* to cache parts of a view. Caching the view decreases your application’s
    page load time by storing the rendered view data in the cache. Fragment caching
    is usually done inside a partial.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 除了低级别的值缓存外，你还可以使用 Rails 的一个功能，叫做 *片段缓存*，来缓存视图的部分内容。缓存视图通过将渲染后的视图数据存储在缓存中，减少了应用程序的页面加载时间。片段缓存通常是在部分视图中进行的。
- en: To demonstrate fragment caching effectively, I need a slow page. Using a slow
    page makes the impact of fragment caching obvious. Let’s use the Ruby `sleep`
    method to render posts more slowly. Obviously, you would never do this in a real
    application—this is only for demonstration.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 为了有效演示片段缓存，我需要一个慢速页面。使用慢速页面可以让片段缓存的影响更加明显。让我们使用 Ruby 的 `sleep` 方法让帖子渲染得更慢。显然，你永远不会在真实应用中这么做——这只是为了演示。
- en: 'Open the *app/views/text_posts/_text_post.html.erb* partial and add the call
    to `sleep` on the first line as shown here:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 打开 *app/views/text_posts/_text_post.html.erb* 部分，在第一行添加 `sleep` 调用，如下所示：
- en: '[PRE29]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: This call to `sleep` ➊ tells Ruby to pause for 1 second. Make the same change
    to the `ImagePost` partial at *app/views/image_posts/_image_post.html.erb*.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 这个 `sleep` 调用 ➊ 告诉 Ruby 暂停 1 秒。对 *app/views/image_posts/_image_post.html.erb*
    中的 `ImagePost` 部分视图做同样的修改。
- en: 'Now when you refresh the index page, it should take much longer to display.
    Check the server output for the exact time:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当你刷新索引页面时，显示的时间应该会更长。检查服务器输出以获取确切的时间：
- en: '[PRE30]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Rendering those five posts took more than five seconds ➊, which makes sense
    with those five `sleep` calls.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 渲染这五个帖子花费了超过五秒钟 ➊，考虑到这五个 `sleep` 调用，这是可以理解的。
- en: 'Now let’s add fragment caching to the partials. Edit *app/views/text_posts/_text_post.html.erb*
    again and add the `cache` method call and block, as shown here:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们在部分视图中添加片段缓存。再次编辑 *app/views/text_posts/_text_post.html.erb*，并添加 `cache`
    方法调用和块，如下所示：
- en: '[PRE31]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: The `cache` method ➊ calls `cache_key` on the `text_post` automatically. I also
    indented all of the code inside the block. Make the same change to the `ImagePost`
    partial.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: '`cache` 方法 ➊ 会自动调用 `cache_key` 来处理 `text_post`。我还将所有的代码都缩进到了块内。对 `ImagePost`
    部分视图做同样的修改。'
- en: 'Now when you refresh the page in your browser, you should see some new output
    from the Rails server:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当你在浏览器中刷新页面时，你应该能看到来自 Rails 服务器的一些新输出：
- en: '[PRE32]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Rendering the index page now generates several lines of output about the cache.
    First, a digest is generated ➊ for the partial. This digest is the same every
    time this partial is rendered. Next, Rails reads the cache ➋ to see if this partial
    is already there. Finally, since the partial was not found in the cache, it is
    rendered and then written to the cache ➌.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 渲染索引页面现在会生成关于缓存的几行输出。首先，为部分生成一个摘要 ➊。这个摘要每次渲染该部分时都相同。接下来，Rails 读取缓存 ➋ 来查看这个部分是否已经存在。如果没有找到缓存中的部分，那么该部分会被渲染并写入缓存
    ➌。
- en: 'Refreshing the page again should read all of the partials from the cache, rendering
    the page much more quickly. Check the server output to be sure:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 刷新页面应该会从缓存中读取所有部分，页面渲染速度也会更快。检查服务器输出以确保：
- en: '[PRE33]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: You only see cache reads ➊ now, and the collection renders very quickly ➋, in
    a fraction of the time it took after you added the `sleep` calls. Caching can
    obviously result in dramatic performance improvements.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你只看到缓存读取 ➊，并且集合渲染非常快速 ➋，在你添加了 `sleep` 调用后，渲染所需的时间大大减少。显然，缓存可以显著提高性能。
- en: You should remove the calls to `sleep` from the `TextPost` and `ImagePost` partials
    now, but leave the caching in place in the views.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在应该从 `TextPost` 和 `ImagePost` 部分中移除 `sleep` 调用，但保留视图中的缓存。
- en: Issues
  id: totrans-167
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: Caching is a great way to make your application faster, but it can also cause
    some issues. Unless the cache key for a code block or view fragment includes a
    user id, then the same cached data is sent to every user.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 缓存是加速应用程序的好方法，但也可能引发一些问题。除非代码块或视图片段的缓存键包含用户 ID，否则相同的缓存数据会被发送给每个用户。
- en: For example, the `TextPost` and `ImagePost` partials both contain code that
    checks to see if the post belongs to the current user. If so, it displays a button
    linked to the `edit` action.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，`TextPost` 和 `ImagePost` 部分都包含检查帖子是否属于当前用户的代码。如果是，它会显示一个链接到 `edit` 动作的按钮。
- en: '[PRE34]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: The conditional statement in the `TextPost` partial at *app/views/test_posts/_text_post.html.erb*
    shows the Edit button if the post belongs to `current_user` ➊. The owner of a
    post is probably going to be the first user to view the post. After the owner
    views the post, the view fragment is cached with the Edit button. When another
    user views the same post, the fragment is read from the cache and the other user
    also sees the Edit button.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: '`TextPost` 部分中的条件语句在 *app/views/test_posts/_text_post.html.erb* 文件中，如果帖子属于
    `current_user` ➊，则显示编辑按钮。帖子的所有者可能是第一个查看该帖子的用户。在所有者查看帖子后，视图片段会被缓存，并且包含了编辑按钮。当其他用户查看同一个帖子时，视图片段会从缓存中读取，其他用户也能看到编辑按钮。'
- en: 'You can correct this issue in a couple of ways. You could include the user
    id in the cache key, but that would create a separate copy of the post in the
    cache for each user and remove the benefit of caching for many users. A simpler
    solution is to move the button outside the fragment being cached, as shown here:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过几种方式来解决这个问题。你可以在缓存键中包含用户 ID，但那样会为每个用户在缓存中创建一个单独的帖子副本，从而失去缓存对多个用户的好处。一个更简单的解决方案是将按钮移动到被缓存的片段之外，如下所示：
- en: '[PRE35]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Once the Edit button is moved outside the cache block, the conditional is evaluated
    for every user viewing the post and the Edit button is shown only if the current
    user is the owner of the post. Make the same change to the `ImagePost` partial
    at *app/views/image_posts/_image_post.html.erb*.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦编辑按钮被移到缓存块之外，条件语句就会为每个查看帖子用户进行评估，只有当当前用户是帖子的所有者时，编辑按钮才会显示。对`ImagePost`部分做相同的更改，文件位置是
    *app/views/image_posts/_image_post.html.erb*。
- en: Remember to edit *config/environments/development.rb,* as shown at the beginning
    of this section, and disable caching in the development environment after you
    complete the exercises at the end of this chapter.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 记得像本节开始时所示的那样编辑 *config/environments/development.rb*，并在完成本章最后的练习后，禁用开发环境中的缓存。
- en: Summary
  id: totrans-176
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: No one likes slow web applications! This chapter covered techniques for speeding
    up your application, from Rails built-in features like the asset pipeline and
    turbolinks to database query optimization, pagination, and caching. Now try the
    following exercises, and make your application even faster.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 没有人喜欢慢速的 web 应用程序！本章介绍了加速应用程序的技巧，从 Rails 内置特性，如资产管道和 Turbolinks，到数据库查询优化、分页和缓存。现在尝试以下练习，让你的应用程序更快。
- en: When you’ve completed the exercises, change `config.action_controller.perform_caching`
    back to `false` in *config/environments/development.rb*. Leave caching turned
    off during development. Otherwise you’ll need to remember to clear the cache any
    time you make a change to a cached view partial.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
- en: The next chapter covers debugging strategies you can use to track elusive problems
    with your application. You’ll look through server output and logs for clues and
    finally dive into a running application to see exactly what’s happening.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
- en: Exercises
  id: totrans-180
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '| Q: | 1\. So far your performance optimizations have focused on the post index
    page. Open the show page for an individual post, such as *http://localhost:3000/posts/1*.
    Make sure the post has several comments and then examine the server output. Use
    eager loading in the `PostsController` at *app/controllers/posts_controller.rb*
    to reduce the number of queries this page makes. |'
  id: totrans-181
  prefs: []
  type: TYPE_TB
- en: '| Q: | 2\. The post show page renders a collection of comments. Add fragment
    caching to the `comment` partial at *app/views/comments/_comment.html.erb*. You
    only want the Destroy button to appear if `@can_moderate` is `true`. In this case,
    include the value of `@can_moderate` in the cache key by passing the array `[comment,
    @can_moderate]` to the cache method. |'
  id: totrans-182
  prefs: []
  type: TYPE_TB
- en: '| Q: | 3\. You can cache the entire comments collection by wrapping the `render
    @post.comments` call in the show page in a `cache` block. Open the show page at
    *app/views/posts/show.html.erb* and add the `cache` block. Pass the array `[@post,
    ''comments'', @can_moderate]` to the `cache` method, ensuring the Destroy button
    is only shown to users who can moderate comments as mentioned in Exercise 2\.
    The technique of wrapping a cached collection inside another cache block is sometimes
    called *Russian-Doll* caching because multiple cached fragments are nested inside
    each other. When an object is added to the collection, only the outer cache needs
    to be re-created. The cached data for the other objects can be reused and only
    the new object needs to be rendered. |'
  id: totrans-183
  prefs: []
  type: TYPE_TB
