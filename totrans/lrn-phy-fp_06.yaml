- en: '5'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: WORKING WITH LISTS
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Images/common.jpg)'
  prefs: []
  type: TYPE_IMG
- en: People naturally make lists. Whether it’s a bucket list, shopping list, or list
    of top ten favorite books, an ordered sequence of items that share something in
    common sits easy on the brain. The history of functional programming is entwined
    with that of lists. The early functional language Lisp even has a name that is
    short for “list processor.” In Haskell, lists are just as important because the
    way we think about iteration in functional programming is often in terms of constructing
    a list and then using it to produce the result we want.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we’ll learn about lists and the functions that work with them.
    We’ll start off with list basics, such as how to construct a list, how to select
    a particular element of a list, and how to concatenate lists. We’ll then see how
    to give a type to a list. Lists of numbers have a special role to play. There
    is special syntax for arithmetic sequences, and there are multiple Prelude functions
    for working with lists of numbers. After that, we’ll introduce the idea of type
    variables. We’ll take a short diversion to talk about type conversion before introducing
    list comprehension, a very useful way to form new lists from old. We’ll end the
    chapter with pattern matching, identifying the data constructors for the list
    type.
  prefs: []
  type: TYPE_NORMAL
- en: List Basics
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'A *list* in Haskell is an ordered sequence of data, all with the same type.
    Here is an example of a list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The type `[String]` indicates that `physicists` is a list of `String`s.
  prefs: []
  type: TYPE_NORMAL
- en: Square brackets around the type indicate a list. A list with type `[String]`
    can have any number of items (including zero), but each item must have type `String`.
    In the second line, we define physicists by enclosing its elements in square brackets
    and separating the elements by commas. The empty list is denoted as [].
  prefs: []
  type: TYPE_NORMAL
- en: Using the type synonym
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'here is a list of real numbers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Selecting an Element from a List
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The list element operator !! can be used to learn the value of an individual
    element of a list. We use the operator between the list and the place, or *index*,
    of the element we want. The first element of a list is considered to be element
    number 0.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The first command loads the file *Lists.hs*, which contains the code in this
    chapter. This file, along with code files for other chapters, is available at
    [https://lpfp.io](https://lpfp.io). After the file is loaded, we can make reference
    to velocities, a name that would be unknown to GHCi before we loaded the file.
  prefs: []
  type: TYPE_NORMAL
- en: Concatenating Lists
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Lists of the same type can be concatenated with the ++ operator shown in [Table
    1-2](ch01.xhtml#ch1tab2). For example, if we have another list that has type `[R]`,
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'we can concatenate `velocities` with this list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Notice that the concatenation has the same type that each component list has,
    in this case `[R]`.
  prefs: []
  type: TYPE_NORMAL
- en: Attempting to concatenate lists with different underlying types produces an
    error. For example, `physicists ++ velocities` gives an error.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: This sort of error is called a *type error*. While `physicists` has a well-defined
    type, namely `[String]`, and `velocities` has a well-defined type, namely `[R]`,
    the expression `physicists ++ velocities` cannot be given a well-defined type.
    A type error results when we attempt to apply a function (in this case, the function
    is the concatenation operator `++`) that expects input of one type to a value
    that actually has a different type. The concatenation operator expects its second
    argument to have type `[String]` because `physicists` has type `[String]`. However,
    we gave a second argument of `velocities`, which has type `[R]` and thus does
    not match `[String]`. In [Chapter 6](ch06.xhtml), we will discuss the type of
    the concatenation operator.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s try to understand the error message. The word “interactive” ➊ indicates
    that the error occurred at the GHCi prompt, rather than in a source code file.
    The numbers ➊ are the line number and column number where the error occurred.
    This is useful information for an error in a source code file, but it is not really
    needed for an error at the GHCi prompt. The text “Couldn’t match type” ➋ indicates
    a type error. The types that don’t match are `Double` and `[Char]` ➋. Since `R`
    is a type synonym for `Double` and `String` is a type synonym for `[Char]`, as
    we will see later in the chapter, the compiler tells us that `R` and `String`
    do not match.
  prefs: []
  type: TYPE_NORMAL
- en: Next, the compiler tells us that a function expected an expression with type
    `[String]` (the “Expected type”) ➌ but was actually given an expression with type
    `[R]` (the “Actual type”) ➍. The error message then tells us that the location
    of this discrepancy is the second argument of the `++` operator ➎. It’s useful
    to be able to read type errors like this. There is no shame in making such an
    error. The compiler is helping us by checking that what we say makes sense. In
    physics, we can use Haskell’s type system to great advantage by assigning different
    types to different conceptual entities. We know, for example, that it makes no
    sense to add a number to a vector. By giving numbers and vectors different types,
    we engage Haskell’s type system to help us ensure that the code we write does
    not attempt to add a number to a vector.
  prefs: []
  type: TYPE_NORMAL
- en: Any number of lists of the same type can be concatenated with the `concat` function.
    If we define a list of strings,
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'then we can make the following concatenation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Arithmetic Sequences
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'An *arithmetic sequence* is a list formed with two dots (..), like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The list ns contains the integers from 0 to 10\. I chose the name ns because
    it looks like the plural of the name n, which seems like a good name for an integer.
    It is a common style in Haskell programs to use names that end in s for lists,
    but it is by no means necessary.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we enter a list into GHCi, GHCi will evaluate each element and return the
    list of evaluated elements:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'If we give GHCi an arithmetic sequence, GHCi will expand the sequence for us:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'A second form of arithmetic sequence allows us to increment from one term to
    the next with a value that is different from 1:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'In this second form, we specify the first, second, and last entries of the
    desired list. We can even do a decreasing list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: List Types
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '*List types* are a second way to form a new type from an existing type (the
    first way being function types, as we saw in “Function Types” in [Chapter 3](ch03.xhtml)).
    Given any type `a` (`Int`, `Integer`, `Double`, and so on), there is a type `[a]`
    for lists with elements of type `a`.'
  prefs: []
  type: TYPE_NORMAL
- en: You can, for example, make a list of functions. Recall the square function we
    defined in [Chapter 2](ch02.xhtml).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'We can define the following list, where cos and sin are functions defined in
    the Haskell Prelude:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Why would we want a list of functions? One reason will show up in [Chapter 11](ch11.xhtml)
    when we meet a function that takes a list of functions and plots them all on the
    same set of axes. A second reason appears in [Chapter 14](ch14.xhtml) when the
    forces that act on an object are functions of time or velocity. Our function for
    solving Newton’s second law will take a list of these force functions to describe
    the forces that act on the object.
  prefs: []
  type: TYPE_NORMAL
- en: Functions for Lists of Numbers
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Haskell has a few Prelude functions that work with lists of numbers. The first
    two are `sum` and `product`, shown in [Table 5-1](ch05.xhtml#ch5tab1). As you
    might expect from its name, `sum` returns the sum of the items in a list, returning
    `0` for the empty list. The function `product` returns the product of the items
    in a list, returning `1` for the empty list. The functions `maximum` and `minimum`
    return the largest and smallest items in a list, respectively, producing errors
    if you give them the empty list.
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 5-1:** Functions for Lists of Numbers'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Expression** |  | **Evaluates to** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `sum [3,4,5]` | ⇝ | `12` |'
  prefs: []
  type: TYPE_TB
- en: '| `sum []` | ⇝ | `0` |'
  prefs: []
  type: TYPE_TB
- en: '| `product [3,4,5]` | ⇝ | `60` |'
  prefs: []
  type: TYPE_TB
- en: '| `product []` | ⇝ | `1` |'
  prefs: []
  type: TYPE_TB
- en: '| `maximum [4,5,-2,1]` | ⇝ | `5` |'
  prefs: []
  type: TYPE_TB
- en: '| `minimum [4,5,-2,1]` | ⇝ | `-2` |'
  prefs: []
  type: TYPE_TB
- en: When Not to Use a List
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: There will be times when you want to “bundle together” expressions of different
    types. For example, we may wish to form pairs composed of a person’s name (a `String`)
    and age (an `Int`). A list is not the right structure to use for this job. All
    elements of a list must have the same type. In [Chapter 9](ch09.xhtml), we’ll
    learn about *tuples*, which are a good way to bundle together items of different
    types.
  prefs: []
  type: TYPE_NORMAL
- en: Type Variables
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In the previous section, we saw how the list element operator `!!` returns a
    specified element of a list. The list element operator doesn’t care what type
    of elements the list contains. We would write `physicists !! 2` to get the number-two
    element of `physicists` in the same way that we would write `velocities !! 2`
    to get the number-two element of velocities, even though the former list has type
    `[String]` while the latter list has type `[R]`.
  prefs: []
  type: TYPE_NORMAL
- en: There are other functions that also don’t care what element type a list has.
    [Table 5-2](ch05.xhtml#ch5tab2) shows several such functions from the Prelude.
    The types of these functions are expressed in terms of a *type variable* (`a`
    in this case). A type variable must start with a lowercase letter and can stand
    for any type.
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 5-2:** Some Prelude Functions for Working with Lists'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Function** |  | **Type** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `head` | `::` | `[a] -> a` | Returns first item of list |'
  prefs: []
  type: TYPE_TB
- en: '| `tail` | `::` | `[a] -> [a]` | Returns all but first item of list |'
  prefs: []
  type: TYPE_TB
- en: '| `last` | `::` | `[a] -> a` | Returns last item of list |'
  prefs: []
  type: TYPE_TB
- en: '| `init` | `::` | `[a] -> [a]` | Returns all but last item of list |'
  prefs: []
  type: TYPE_TB
- en: '| `reverse` | `::` | `[a] -> [a]` | Reverses order of list |'
  prefs: []
  type: TYPE_TB
- en: '| `repeat` | `::` | `a` `-> [a]` | Infinite list of a single item |'
  prefs: []
  type: TYPE_TB
- en: '| `cycle` | `::` | `[a] -> [a]` | Infinite list repeating given list |'
  prefs: []
  type: TYPE_TB
- en: The function head returns the first element of a list. You can see some uses
    of head, as well as the other list functions, in [Table 5-3](ch05.xhtml#ch5tab3).
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 5-3:** Use of List Functions'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Expression** |  | **Evaluates to** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `head ["Gal","Jo","Isaac","Mike"]` | ⇝ | `"Gal"` |'
  prefs: []
  type: TYPE_TB
- en: '| `head [1, 2, 4, 8, 16]` | ⇝ | `1` |'
  prefs: []
  type: TYPE_TB
- en: '| `tail ["Gal","Jo","Isaac","Mike"]` | ⇝ | `["Jo","Isaac","Mike"]` |'
  prefs: []
  type: TYPE_TB
- en: '| `tail [1, 2, 4, 8, 16]` | ⇝ | `[2,4,8,16]` |'
  prefs: []
  type: TYPE_TB
- en: '| `last ["Gal","Jo","Isaac","Mike"]` | ⇝ | `"Mike"` |'
  prefs: []
  type: TYPE_TB
- en: '| `last [1, 2, 4, 8, 16]` | ⇝ | `16` |'
  prefs: []
  type: TYPE_TB
- en: '| `init ["Gal","Jo","Isaac","Mike"]` | ⇝ | `["Gal","Jo","Isaac"]` |'
  prefs: []
  type: TYPE_TB
- en: '| `init [1, 2, 4, 8, 16]` | ⇝ | `[1,2,4,8]` |'
  prefs: []
  type: TYPE_TB
- en: '| `length ["Gal","Jo","Isaac","Mike"]` | ⇝ | `4` |'
  prefs: []
  type: TYPE_TB
- en: '| `length [1, 2, 4, 8, 16]` | ⇝ | `5` |'
  prefs: []
  type: TYPE_TB
- en: The function head can accept a list of type `[Double]`, a list of type `[Char]`,
    or a list of type `[Int]`. Because `head` doesn’t care about the type of the payload,
    the best way of expressing the type of input `head` takes is by using a type variable
    `a` to say that `head` accepts an input of type `[a]`. The same type variable
    `a` appears also in the output; the return type of `head` is `a`.
  prefs: []
  type: TYPE_NORMAL
- en: You can see a type variable if you ask GHCi for the type of the empty list.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Let’s look at a few more of the functions from [Table 5-2](ch05.xhtml#ch5tab2).
    The tail function returns everything but the first element of a list. The function
    last returns the last element of a list. The function init returns everything
    except the last element. The book *Learn You a Haskell for Great Good!* has a
    cute picture of a caterpillar ([http://learnyouahaskell.com/starting-out#an-intro-to-lists](http://learnyouahaskell.com/starting-out#an-intro-to-lists))
    that visually explains these list functions. [Table 5-2](ch05.xhtml#ch5tab2) gives
    the types of these functions, and [Table 5-3](ch05.xhtml#ch5tab3) shows some examples
    of how to use them.
  prefs: []
  type: TYPE_NORMAL
- en: Having introduced type variables, we are in a good position to take a short
    diversion into type conversion.
  prefs: []
  type: TYPE_NORMAL
- en: Type Conversion
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'GHCi appears to allow a `Double` to be divided by an `Int`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: However, that is not what is happening here. The number `0.4` can be a `Float`
    or a `Double`. The number `4` can be an `Int`, `Integer`, `Float`, or `Double`.
    The division operator demands that the types of the two numbers being divided
    are the same. In this case, both must be interpreted as `Float` or both as `Double`.
    Addition, subtraction, multiplication, and division require that the two expressions
    being combined have the same type. In terms of the type variables we introduced
    earlier, addition, subtraction, multiplication, and division all have type `a
    -> a -> a`, meaning that each of the two numbers being combined must have the
    same type `a`, and then the result of the operation will also have type `a`. (The
    full story of the types of arithmetic operations like addition is more complex.
    You can’t add two `String`s, but a function with type `a -> a -> a` must be able
    to accept two `String`s as input and produce a `String` as output. The missing
    piece involves the idea of type classes, which we’ll discuss in [Chapter 8](ch08.xhtml).)
  prefs: []
  type: TYPE_NORMAL
- en: The Haskell compiler will refuse to divide a `Double` by an `Int`. If we give
    explicit types to some numbers,
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'we can see the error the compiler produces:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: This is another example of a type error. The first input to the division is
    a `Double`, so the “expected type” for the second argument of division is also
    `Double`. The “actual type” we supplied is `Int`, which doesn’t match. The compiler
    will similarly refuse to add a `Float` to a `Double`.
  prefs: []
  type: TYPE_NORMAL
- en: The fact that division can occur only between numbers with the same type can
    be irritating, especially if we expect the compiler to automatically convert one
    type into another. The solution is to use a type-conversion function to convert,
    say, an `Int` to a `Double`.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two important type-conversion functions you may need to use from
    time to time. The first is `fromIntegral`, which converts an `Int` or `Integer`
    to some other kind of number. The compiler can usually figure out which type to
    convert to, but it demands your explicit permission through the use of this function.
    The second conversion function is `realToFrac`, which converts a `Float` to a
    `Double` or a `Double` to a `Float`. Again, you do not usually need to explicitly
    specify the type to convert to; you just need to give permission for the conversion
    to be done. Here is an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: The rationale behind the requirement for conversion is that, in Haskell, most
    errors are type errors. Type errors often indicate that we haven’t completely
    thought through the code we’ve written. It could be that dividing a `Double` by
    an `Int` is not what we intended and we are grateful to the type checker for producing
    an error rather than quietly converting the `Int` to a `Double`.
  prefs: []
  type: TYPE_NORMAL
- en: This concludes our diversion into type conversion. We can now return to our
    regularly scheduled program, namely lists.
  prefs: []
  type: TYPE_NORMAL
- en: The Length of Lists
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The Prelude provides a function length that returns the number of items in a
    list.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: In the early days of Haskell, length was a simple function with a simple type.
    The type of length was `[a] -> Int`, meaning you could give length a list of anything,
    and it would give you back an integer. That was nice and simple. If we ask GHCi
    today for the type of length,
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'we see a more complex type. This type involves the idea of a *type class*,
    which we’ll explore in [Chapter 8](ch08.xhtml). But for now, we can make our own
    length function with the simple type `[a] -> Int`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: If we look at the type of `len` in GHCi,
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: we see the simple type that we want.
  prefs: []
  type: TYPE_NORMAL
- en: There is no great advantage to defining our own length function because we are
    free to use `length` even though it has a complicated type, but understanding
    the types of the functions we use gives us real insight into what we are doing.
    We want to understand the types of the functions we write and use, and we want
    them to be as simple as they can be. There will, of course, be trade-offs between
    simplicity and power. The decision of the Haskell designers to give the `length`
    function a more complicated type means that it can be used in a wider variety
    of situations. In this case, the designers made a decision favoring power over
    simplicity. We will often favor simplicity over power.
  prefs: []
  type: TYPE_NORMAL
- en: A String Is a List of Characters
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Now that I have introduced lists, I can tell you that a string in Haskell is
    nothing but a list of characters. In other words, the type `String` is exactly
    the same as the type `[Char]`; in fact, `String` is defined in the Haskell Prelude
    to be a type synonym for `[Char]` in exactly the same way that we defined `R`
    to be a type synonym for `Double`. Haskell provides some special syntax for strings,
    namely the ability to enclose a sequence of characters in double quotes to form
    a `String`. This is obviously more pleasant than requiring an explicit list of
    characters, such as `[''W'',''h'',''y'',''?'']`. You can ask GHCi whether this
    is the same as "Why?":'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: GHCi responds with True, indicating that it regards these two expressions as
    identical.
  prefs: []
  type: TYPE_NORMAL
- en: The identity of the types `String` and `[Char]` also means that a string can
    be used in any function that expects a list of something. For example, we can
    use the function length on a string to tell us how many characters it has.
  prefs: []
  type: TYPE_NORMAL
- en: Readers who have some experience with programming may worry about the efficiency
    implications of representing strings as lists of characters. Rest assured that
    Haskell has some other options that are more efficient for programmers who need
    to process a lot of strings. However, for our purposes, we will not need to process
    a lot of strings, so the basic `String` type is just fine for us.
  prefs: []
  type: TYPE_NORMAL
- en: List Comprehensions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Haskell offers a powerful way to make new lists out of old lists. Suppose you
    have a list of times (in seconds),
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'and you want to have a list of positions for a rock that you threw up in the
    air at 30 m/s, with each position corresponding to one of the times in the time
    list. In Exercise 2.2, you wrote a function `yRock30` to produce the position
    of the rock when given the time. Perhaps your function looked something like the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'The code below produces the desired list of positions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'The definition of `xs` is an example of a *list comprehension*. The syntax
    for a list comprehension consists of square brackets, a vertical bar, and a left
    arrow, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[ function of *item* | *item* >- *list* ]'
  prefs: []
  type: TYPE_NORMAL
- en: This means that, given a function and a list, Haskell will compute that function
    for each item in the list and then form a list of the resulting values. In our
    example above, for each `t` in `ts`, Haskell will compute `yRock30 t` and form
    a list of these values. The list `xs` of positions will be the same length as
    the original list `ts` of times.
  prefs: []
  type: TYPE_NORMAL
- en: List comprehensions, in conjunction with the `sum` and `product` functions,
    allow us to write elegant Haskell expressions that mimic the sigma and pi notation
    in mathematics for sums and products. [Table 5-4](ch05.xhtml#ch5tab4) shows the
    correspondence between mathematical and Haskell notations.
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 5-4:** Sum and Product Notation in Haskell'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Mathematical notation** | **Haskell notation** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| ![Image](Images/061equ01.jpg) | `sum [f(i) &#124; i <- [m..n]]` |'
  prefs: []
  type: TYPE_TB
- en: '| ![Image](Images/061equ02.jpg) | `product [f(i) &#124; i <- [m..n]]` |'
  prefs: []
  type: TYPE_TB
- en: Infinite Lists
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Haskell is a lazy language, meaning that it does not always evaluate everything
    in the order you might expect. Instead, it waits to see if values are needed before
    doing any actual work. Haskell’s laziness allows for the possibility of infinite
    lists. Of course, Haskell never actually creates an infinite list, but you can
    think of the list as infinite because Haskell is willing to continue down the
    list as far as it needs to. The list [1..] is an example of an infinite list.
    If you ask GHCi to show you this list, it will go on indefinitely. You can enter
    CTRL-C or something similar to stop the endless printing of numbers.
  prefs: []
  type: TYPE_NORMAL
- en: An infinite list can be convenient when you don’t know in advance exactly how
    much of a list you will want or need. For example, we might want to compute a
    list of positions of a particle at 0.01 s time increments. We may not know in
    advance the length of time over which we want this information. If we write our
    function so that it returns an infinite list of positions, the function will be
    simpler because it doesn’t need to know the total number of positions to calculate.
  prefs: []
  type: TYPE_NORMAL
- en: 'A good way to view the first several elements of an infinite list is with the
    `take` function. Try the following in GHCi:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: GHCi shows you the first 10 elements of the infinite list [3..].
  prefs: []
  type: TYPE_NORMAL
- en: Two Prelude functions from [Table 5-2](ch05.xhtml#ch5tab2) create infinite lists.
    The function repeat takes a single expression and returns an infinite list with
    the expression repeated an infinite number of times. By itself, this function
    doesn’t seem very useful, but in combination with other functions and techniques
    we’ll learn about later, it can be useful.
  prefs: []
  type: TYPE_NORMAL
- en: 'The Prelude function cycle takes a (finite) list and returns the infinite list
    formed by cycling through the elements of the finite list over and over again.
    You can get an idea of what cycle does by asking GHCi to show you the first several
    elements of such a list, like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: List Constructors and Pattern Matching
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The colon (`:`) operator (called *cons* for historical reasons having to do
    with the early functional programming language Lisp) from [Table 1-2](ch01.xhtml#ch1tab2)
    can be used to attach a single item of type `a` to a list with type `[a]`. For
    example, 3:[[4](bib.xhtml#bib4),[5](bib.xhtml#bib5)] is the same as [[3](bib.xhtml#bib3),[4](bib.xhtml#bib4),[5](bib.xhtml#bib5)],
    and 3:[] is the same as [[3](bib.xhtml#bib3)].
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 3](ch03.xhtml), we saw how we could use pattern matching on the
    `Bool` type. The `Bool` type has two patterns, `False` and `True`. The list type
    also has two patterns. A list is either the empty list [] or the cons x:xs of
    an item x with a list xs. Every list is exactly one of these two mutually exclusive
    and exhaustive possibilities. In fact, Haskell internally regards lists as being
    formed out of the two *constructors* (also called *data constructors*,) [] and
    :. Each type in Haskell has one or more data constructors that are used to form
    expressions of that type. Therefore, a data constructor is a way of making an
    expression of a particular type. When we define our own types in [Chapter 10](ch10.xhtml),
    we will see that data constructors are an essential part of the definition for
    the type.
  prefs: []
  type: TYPE_NORMAL
- en: The list we think of as [[13](bib.xhtml#bib13),[6](bib.xhtml#bib6),[4](bib.xhtml#bib4)]
    is represented internally as 13:6:4:[], which means 13:(6:(4:[])) when we allow
    for the right associativity of :. [Table 5-5](ch05.xhtml#ch5tab5) shows the data
    constructors for the Boolean and list types.
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 5-5:** Data Constructors for the Boolean and List Types'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Type** | **Data constructors** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `Bool` | `False`, `True` |'
  prefs: []
  type: TYPE_TB
- en: '| `[a]` | `[]`, `:` |'
  prefs: []
  type: TYPE_TB
- en: The fundamental mechanism for pattern matching in Haskell is the `case`-`of`
    construction. If we are pattern matching on a `Bool`, there will be two cases
    corresponding to the two data constructors `False` and `True` from which all values
    of type `Bool` are constructed. If we are pattern matching on a list, there will
    be two cases corresponding to the two data constructors `[]` and `:` from which
    all lists are constructed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s look at an example of defining a function on lists using pattern matching.
    Let’s define a function sndItem that returns the second element of a list, or
    gives an error if the list has fewer than two elements. The idea is that sndItem
    [[8](bib.xhtml#bib8),[6](bib.xhtml#bib6),[7](bib.xhtml#bib7),[5](bib.xhtml#bib5)]
    should return 6\. Our first definition uses the `case-of` construction:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: In the case where `ys` is the empty list, we use the error function, which has
    type `[Char] -> a`, meaning that it takes a string as input and can serve as any
    type. The error function halts execution and returns the given string as a message.
  prefs: []
  type: TYPE_NORMAL
- en: In the case where the input is the cons of an item and a list, the notation
    `(x:xs)` indicates that the item will be assigned the name `x` and the list will
    be assigned the name `xs` for use in the body of the definition (the body is the
    expression to the right of the arrow). For example, if `ys` is the list `[1879,3,14]`,
    then `x` will be assigned the value `1879` and `xs` will be assigned the value
    `[3,14]`. This assignment of the names `x` and `xs` is *local*, meaning that it
    only holds in the body of the definition. Outside of the definition body, the
    names `x` and `xs` may have another meaning or no meaning at all.
  prefs: []
  type: TYPE_NORMAL
- en: The expression `null xs` returns `True` if `xs` is empty and `False` otherwise.
    If `xs` is empty, the original list `x:xs` had only one element, so we give the
    one-element error. If `xs` is not empty, its first element (its `head`) is the
    second element of the original list, and hence the value we should return.
  prefs: []
  type: TYPE_NORMAL
- en: If the value we are pattern matching (`ys` from earlier) is also an input to
    a function, we can do pattern matching directly on the input rather than using
    the `case-of` construction.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Notice that we no longer need the local variable `ys` in `sndItem2`.
  prefs: []
  type: TYPE_NORMAL
- en: In pattern matching on the input, the definition is expressed in parts, with
    one part for each data constructor of the input type. In this case, the input
    type is a list, and the data constructors for a list are the empty list and cons,
    so part 1 of the definition defines `sndItem2` for the empty list and part 2 of
    the definition defines the function for the cons of an item with a list.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can make an even nicer function definition by going one step further and
    using additional pattern matching on the xs list in sndItem. Let’s define a function
    `sndItem3` that does the same thing as `sndItem` but uses even more pattern matching:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Case 1 of `sndItem` remains unchanged. Case 2 of `sndItem` splits into two subcases,
    depending on whether the `xs` in `sndItem` is the empty list or the cons of an
    item with a list.
  prefs: []
  type: TYPE_NORMAL
- en: Notice the underscore character (`_`) in the last line. Names that begin with
    an underscore in Haskell are names that we never intend to refer to. We could
    have written (x:z:zs) in place of `(x:z:_)`. The underscore means that we can’t
    be bothered to give the list a real name because we have no intention of using
    it or referring to it again. We make no reference to this list in the definition
    body, so there is no motivation to give it a proper name. Sometimes it is helpful
    to the code reader (who might be you) to give a name to something that never gets
    used. If you want to give something a name *and* signal that it never gets used,
    you can use a name that begins with an underscore, such as `_zs`. Note finally
    that the cons operator (:) is right associative, so the expression `x:z:_` is
    read as `x:(z:_)`.
  prefs: []
  type: TYPE_NORMAL
- en: Because the value we are pattern matching is the input to our function, we can
    do pattern matching on the input rather than use the `case-of` construction.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Summary
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'This chapter introduced lists. Each member of a list must have the same type.
    Square brackets serve two roles for lists. A type enclosed in square brackets
    is a list type, and a sequence of items enclosed in square brackets and separated
    by commas forms a list. A type variable serves as a placeholder for any type.
    Several list functions have types with type variables because they don’t care
    about the underlying type of a list. Since addition, subtraction, multiplication,
    and division only work between numbers with the same type in Haskell, we introduced
    two type-conversion functions for situations in which conversion is necessary.
    A list comprehension is a method to form a new list from an existing list. Haskell
    allows for infinite lists because it is a lazy language. Lists are formed from
    two constructors: the empty list and the cons operator. Pattern matching can be
    used to define a function that takes a list as input. There are two patterns that
    a list may have: either it is the empty list or it is the cons of an element and
    another list.'
  prefs: []
  type: TYPE_NORMAL
- en: Exercises
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Exercise 5.1.** Give an abbreviation for the following list using the double
    dot (`..`) notation. Use GHCi to check that your expression does the right thing.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: '**Exercise 5.2.** Write a function `sndItem0 :: [a] -> a` that does the same
    thing as sndItem but does not use any pattern matching.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Exercise 5.3.** What is the type of the following expression?'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: What is the value of the expression?
  prefs: []
  type: TYPE_NORMAL
- en: '**Exercise 5.4.** Write a function with type `Int -> [Int]` and describe in
    words what it does.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Exercise 5.5.** Write a function `null''` that does the same thing as the
    Prelude function null. Use the Prelude function length in your definition of `null''`
    but do not use the function null.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Exercise 5.6.** Write a function `last''` that does the same thing as the
    Prelude function last. Use the Prelude functions head and reverse in your definition
    of `last''` but do not use the function last.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Exercise 5.7.** Write a function `palindrome :: String -> Bool` that returns
    True if the input string is a palindrome (a word like *radar* that is spelled
    the same backward as it is forward) and False otherwise.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Exercise 5.8.** What are the first five elements of the infinite list [9,1..]?'
  prefs: []
  type: TYPE_NORMAL
- en: '**Exercise 5.9.** Write a function `cycle''` that does the same thing as the
    Prelude function cycle. Use the Prelude functions repeat and concat in your definition
    of `cycle''` but do not use the function cycle.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Exercise 5.10.** Which of the following are valid Haskell expressions? If
    an expression is valid, give its type. If an expression is not valid, say what
    is wrong with it.'
  prefs: []
  type: TYPE_NORMAL
- en: (a) `["hello",42]`
  prefs: []
  type: TYPE_NORMAL
- en: (b) `['h',"ello"]`
  prefs: []
  type: TYPE_NORMAL
- en: (c) `['a','b','c']`
  prefs: []
  type: TYPE_NORMAL
- en: (d) `length ['w','h','o']`
  prefs: []
  type: TYPE_NORMAL
- en: (e) `length "hello"`
  prefs: []
  type: TYPE_NORMAL
- en: '(f) `reverse` (Hint: this is a valid Haskell expression, and it has a well-defined
    type, even though GHCi cannot print the expression.)'
  prefs: []
  type: TYPE_NORMAL
- en: '**Exercise 5.11.** In an arithmetic sequence, if the specified last element
    does not occur in the sequence,'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: the result seems to depend on whether you are using whole numbers. Explore this
    and try to find a general rule for where an arithmetic sequence will end.
  prefs: []
  type: TYPE_NORMAL
- en: '**Exercise 5.12.** In the 1730s, Leonhard Euler showed that'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Images/065equ01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Write a Haskell expression to evaluate
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Images/066equ01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**Exercise 5.13.** The number *n*!, called “*n* factorial,” is the product
    of the positive integers less than or equal to *n*:'
  prefs: []
  type: TYPE_NORMAL
- en: '*n*! = *n*(*n* – 1) . . . 1'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s an example:'
  prefs: []
  type: TYPE_NORMAL
- en: 5! = 5 × 4 × 3 × 2 × 1 = 120
  prefs: []
  type: TYPE_NORMAL
- en: Using the `product` function, write a factorial function.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: '**Exercise 5.14.** The exponential function is equal to the following limit:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Images/066equ02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Write a function
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'that takes a real number *x* as input and produces an infinite list of successive
    approximations to exp(*x*):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Images/066equ03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: How big does *n* need to be to get within 1 percent of the correct value for
    *x* = 1? How big does *n* need to be to get within 1 percent of the correct value
    for *x* = 10?
  prefs: []
  type: TYPE_NORMAL
- en: '**Exercise 5.15.** The exponential function is equal to the following infinite
    series:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Images/066equ04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Write a function
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'that takes a real number *x* as input and produces an infinite list of successive
    approximations to exp(*x*):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Images/067equ01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: How big does *n* need to be for
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Images/067equ02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: to be within 1 percent of the correct value for *x* = 1? How big does *n* need
    to be to get within 1 percent of the correct value for *x* = 10? You may want
    to use the function `fromIntegral` here.
  prefs: []
  type: TYPE_NORMAL
