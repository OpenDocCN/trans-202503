- en: '**11**'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**LEGACY ISSUES AND BAGGAGE FROM C**'
  prefs: []
  type: TYPE_NORMAL
- en: Objective-C and Cocoa help mitigate many security problems that you might run
    into with C or C++. Objective-C is, however, still a flavor of C, which fundamentally
    isn’t a “safe” language, and some Cocoa APIs are still vulnerable to the types
    of data theft or code execution attacks you might expect in C programs. C and
    C++ can also be intermingled freely with Objective-C. Many iOS applications use
    large amounts of C and C++ code, whether because developers want to use a familiar
    library or are trying to keep code as portable as possible between platforms.
    There are some mitigations in place to prevent code execution attacks, as discussed
    in [Chapter 1](ch01.html#ch01), but these can be bypassed by more skilled attackers.
    As such, it’s a good idea to familiarize yourself with these bugs and attacks.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, you’ll learn about some of the types of attacks to look out
    for, the places where C bugs creep into Objective-C, and how to fix these issues.
    The topic of native C code issues is broad, so this chapter is a “greatest hits”
    of these issues to give you the basic foundation for understanding the theory
    behind these flaws and the attacks that exploit them.
  prefs: []
  type: TYPE_NORMAL
- en: '**Format Strings**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Format string attacks^([1](footnote.html#fn100)) leverage a misuse of APIs
    that expect a *format string*, or a string that defines the data types of which
    the string will be composed. In C, the most commonly used functions that accept
    format strings are in the `printf` family; there are a number of other functions,
    such as `syslog`, that accept them as well. In Objective-C, these methods usually
    have suffixes like `WithFormat` or `AppendingFormat`, though there are several
    exceptions. Here are examples of all three:'
  prefs: []
  type: TYPE_NORMAL
- en: • `[NSString *WithFormat]`
  prefs: []
  type: TYPE_NORMAL
- en: • `[NSString stringByAppendingFormat]`
  prefs: []
  type: TYPE_NORMAL
- en: • `[NSMutableString appendFormat]`
  prefs: []
  type: TYPE_NORMAL
- en: • `[NSAlert alertWithMessageText]`
  prefs: []
  type: TYPE_NORMAL
- en: • `[NSException raise:format:]`
  prefs: []
  type: TYPE_NORMAL
- en: • `NSLog()`
  prefs: []
  type: TYPE_NORMAL
- en: 'Attackers commonly exploit format string vulnerabilities to do two things:
    execute arbitrary code and read process memory. These vulnerabilities generally
    stem from two age-old C format string operators: `%n` and `%x`. The rarely used
    `%n` operator is meant to store the value of the characters printed so far in
    an integer on the stack. It can, however, be leveraged to overwrite portions of
    memory. The `%x` operator is meant to print values as hexadecimal, but when no
    value is passed in to be printed, it reads values from the stack.'
  prefs: []
  type: TYPE_NORMAL
- en: Unfortunately for us bug hunters, Apple has disabled `%n` in Cocoa classes that
    accept format strings. But the `%n` format string *is* allowed in regular C code,
    so code execution format string attacks are still possible.^([2](footnote.html#fn101))
    The reason that `%n` can result in code execution is because it writes to the
    stack, and the format string is also stored on the stack. Exploitation varies
    depending on the specific bug, but the main upshot is that by crafting a format
    string that contains `%n` and also a memory address to write to, you can get arbitrary
    integers written to specific parts of memory. In combination with some shell code,
    this can be exploited similarly to a buffer overflow attack.^([3](footnote.html#fn102))
  prefs: []
  type: TYPE_NORMAL
- en: The `%x` operator, on the other hand, is alive and well in both Objective-C
    methods and C functions. If an attacker can pass `%x` to an input that lacks a
    format string specifier, the input will be interpreted as a format string, and
    the contents of a stack will be written in hexadecimal where the expected string
    should appear. If attackers can then view this output, they can collect potentially
    sensitive information from the process’s memory, such as user-names, passwords,
    or other personal data.
  prefs: []
  type: TYPE_NORMAL
- en: Of course, both of these vulnerabilities rely on a program not controlling user
    input properly. Let’s take a look at how an attacker might misuse format strings
    in such a situation and how applications can prevent that from happening.
  prefs: []
  type: TYPE_NORMAL
- en: '***Preventing Classic C Format String Attacks***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The typical example of a format string vulnerability is when a program passes
    a variable directly to `printf`, without manually specifying a format string.
    If this variable’s contents are supplied by external input that an attacker can
    control, then the attacker could execute code on a device or steal data from its
    memory. You can test some contrived vulnerable code like this in Xcode:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'This code simply supplies a string containing a bunch of `%x` specifiers to
    the `printf` function. In a real-world program, these values could come from any
    number of places, such as a user input field or DNS query result. When the code
    executes, you should see a string of hexadecimal output written to your console.
    This output contains the hexadecimal values of variables stored on the stack.
    If an application has stored a password or encryption key as a value on the stack
    and parses some attacker-supplied data, an attacker could cause this information
    to leak to somewhere they can then read. If you change the previous example to
    contain `%n` specifiers, the behavior is different. Here’s how that would look:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Running this example in Xcode should cause Xcode to drop to `lldb` with the
    error `EXC_BAD_ACCESS`. Whenever you see that message, your program is trying
    to read or write to some memory it shouldn’t. In a carefully crafted attack, you
    won’t see such errors, of course; the code will simply execute.
  prefs: []
  type: TYPE_NORMAL
- en: 'But you can prevent attackers from hijacking strings pretty easily by controlling
    user input. In this case, just change that `printf` to specify its own format
    string, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Run this in Xcode, and you should see the literal `%n%n%n%n%n` written harmlessly
    to the console. These examples, of course, are plain old C, but knowing how they
    work will help you explore format string attacks with an Objective-C twist.
  prefs: []
  type: TYPE_NORMAL
- en: '***Preventing Objective-C Format String Attacks***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Similar to plain C, you can pass in any of the `printf` format operators to
    a number of different Objective-C APIs. You can test this easily in Xcode by passing
    a bogus format string to `NSLog`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Much like the previous `%x` example, this will spit out memory contents in hexadecimal
    to the console. One format string vulnerability I’ve come across in real iOS applications
    is code that passes user-supplied input to a “formatting” function, which does
    some processing and returns an `NSString` object, as shown in [Listing 11-1](ch11.html#ch11ex1).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 11-1: Totally the wrong way to pass in data to a format string*'
  prefs: []
  type: TYPE_NORMAL
- en: This example just assumes that the resulting `NSString` stored in `myStuff`
    at ➊ is safe; after all, the contents of *unformattedStuff.text* were “formatted.”
    But unless the `formatStuff` method has some special way of sanitizing that input
    file, the resulting string could contain format string specifiers. If that happens,
    you still have a format string issue, and the resulting string will contain values
    from the stack.
  prefs: []
  type: TYPE_NORMAL
- en: '`NSString` objects aren’t magically safe from format string attacks. The correct
    way to output an `NSString` passed to a method requiring a format string is to
    use the `%@` specifier, as shown in [Listing 11-2](ch11.html#ch11ex2).'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 11-2: The correct way to use a method expecting a format string*'
  prefs: []
  type: TYPE_NORMAL
- en: With the `%@` specifier in front, no matter how many `%x` and `%n` operators
    *unformattedStuff.text* might contain, `myStuff` should come out as a harmless
    string.
  prefs: []
  type: TYPE_NORMAL
- en: The `%x` and `%n` specifiers are the most useful ones to attackers, but even
    in their absence, attackers can still cause undesirable behavior, such as crashes,
    when trying to read inaccessible memory, even using basic `%s` specifiers. Now
    that I’ve covered how format string attacks work and how to prevent them, I’ll
    show you some other methods of executing malicious code.
  prefs: []
  type: TYPE_NORMAL
- en: '**Buffer Overflows and the Stack**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Buffer overflows have long haunted the world of C, allowing crafted input from
    untrusted sources to crash programs or execute third-party code within the process
    of a vulnerable program. While buffer overflows have been known since the 1970s,
    the first prominent example of their exploitation was the Morris worm, which included
    a buffer overflow exploit of the UNIX `finger` daemon.
  prefs: []
  type: TYPE_NORMAL
- en: Buffer overflows start by overwriting portions of memory. The basic memory layout
    of a process consists of the program code, any data the program needs to run,
    the stack, and the heap, as shown in [Figure 11-1](ch11.html#ch11fig1).
  prefs: []
  type: TYPE_NORMAL
- en: '![image](graphics/f11-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 11-1: Arrangement of process memory*'
  prefs: []
  type: TYPE_NORMAL
- en: The *code* segment (often referred to as the *text* segment) is where the program’s
    actual executable is loaded into memory. The *data* segment contains the program’s
    global variables and static local variables. The *heap* is where the bulk of nonexecutable
    program data will reside, in memory dynamically allocated by the program. The
    *stack* is where local variables are stored, as well as addresses of functions
    and, importantly, a pointer to the address that contains the next instructions
    that the program is to execute.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two basic types of overflows: those that overwrite portions of a
    program’s stack and those that overwrite portions of the heap. Let’s look at a
    buffer overflow vulnerability now.'
  prefs: []
  type: TYPE_NORMAL
- en: '***A strcpy Buffer Overflow***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: A classic example of a stack-based buffer overflow is shown in [Listing 11-3](ch11.html#ch11ex3).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 11-3: Code vulnerable to an overflow*'
  prefs: []
  type: TYPE_NORMAL
- en: Both `username` and `password` have been allocated 32 bytes. Under most circumstances,
    this program should function normally and compare the user-supplied password to
    the stored password since usernames and passwords tend to be less than 32 characters.
    However, when either value is supplied with an input that exceeds 32 characters,
    the additional characters start overwriting the memory adjacent to the variable
    on the stack, as illustrated in [Figure 11-2](ch11.html#ch11fig2). This means
    that an attacker can overwrite the return address of the function, specifying
    that the next thing to be executed is a blob of malicious code the attacker has
    placed in the current input or elsewhere in memory.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](graphics/f11-02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 11-2: Memory layout before and after an overflow*'
  prefs: []
  type: TYPE_NORMAL
- en: Since this example hardcodes a character limit and doesn’t check that the input
    is within the limit, attacker-controlled input can be longer than the receiving
    data structure allows. Data will overflow the bounds of that buffer and overwrite
    portions of memory that could allow for code execution.
  prefs: []
  type: TYPE_NORMAL
- en: '***Preventing Buffer Overflows***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: There are a few ways to prevent buffer overflows, and most of them are pretty
    simple.
  prefs: []
  type: TYPE_NORMAL
- en: '**Checking Input Size Before Using It**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'The easiest fix is to sanity check any input before loading it into a data
    structure. For example, vulnerable programs like the one in [Listing 11-3](ch11.html#ch11ex3)
    often defend against buffer overflows by calculating the size of incoming data
    themselves, rather than trusting an externally supplied size to be the right length.
    This fix can be as simple as replacing the `strcpy` functions in [Listing 11-3](ch11.html#ch11ex3)
    with `if` statements like this one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Checking the size of the provided password with `sizeof` should ensure that
    any data exceeding the size of the buffer is rejected. Ideally of course, you
    wouldn’t be using statically sized buffers at all—higher level classes like `NSString`
    or `std::string` and their associated methods should take care of these kinds
    of issues for you.
  prefs: []
  type: TYPE_NORMAL
- en: '**Using Safer String APIs**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Another coding best practice that can protect you from buffer overflows is
    avoiding “known bad” APIs, such as the `strcpy` and `strcat` families. These copy
    data into a destination buffer without checking whether the destination can actually
    handle that much data, which is why adding a size check was so important in the
    previous section. [Listing 11-3](ch11.html#ch11ex3) showed one bad use of `strcpy`;
    here’s an even simpler one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: In this simple and obvious kind of buffer overflow vulnerability, the `buf`
    buffer is only 32 bytes long, and the argument `things` is copied into it. But
    this code never checks the size of the `things` buffer before attempting to copy
    it into `buf`. If any call this function passes in a buffer is larger than 32
    bytes, the result will be a buffer overflow.
  prefs: []
  type: TYPE_NORMAL
- en: 'The safer way to copy and concatenate strings is to use the `strlcpy` and `strlcat`
    functions,^([4](footnote.html#fn103)) which take the size of the destination buffer
    as an argument, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Here, the `strlcpy` function will copy only 31 bytes of the source string, plus
    a null terminator. This may result in the string being truncated, but at least
    it won’t overflow the statically sized buffer. The `strl` family is not available
    on all platforms but is available on BSD-based systems, including iOS.
  prefs: []
  type: TYPE_NORMAL
- en: In addition to these types of overflows, errors can also be made when performing
    integer operations, which can lead to a denial of service or code execution.
  prefs: []
  type: TYPE_NORMAL
- en: '**Integer Overflows and the Heap**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*Integer overflows* result from performing a calculation that gives a value
    larger than the maximum size of an integer on a platform. As you likely know,
    there are two types of integers in C (and therefore, in Objective-C): signed and
    unsigned. Signed integers can be positive or negative, and unsigned integers are
    always positive. If you attempt to perform a calculation that overflows the value
    of either type of integers, badness occurs. An unsigned integer will wrap around
    past the maximum value of an integer, starting over at zero. If the integer is
    signed, it will start at a negative number, the minimum value of an unsigned integer.
    Here’s an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: This starts with a signed integer `foo`, using the maximum size of a signed
    integer on iOS. When the number is incremented, the output on the console should
    wrap around to a negative number, `-9223372036854775808`.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you were to use an unsigned integer as shown in the following example, you’d
    see the integer overflow, and the output on the console would be `0`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: While buffer overflows overwrite the stack, integer overflows give attackers
    access to the heap, and I’ll show you how that works next.
  prefs: []
  type: TYPE_NORMAL
- en: '***A malloc Integer Overflow***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'An integer overflow most often causes issues when it occurs while calculating
    the necessary space to pass to a `malloc()` call, making the space allocated far
    too small to contain the value to store. When data is loaded into the newly allocated
    space, the data that won’t fit is written beyond the end of the allocated space,
    into the heap. This puts you in a heap overflow situation: if the attacker provides
    maliciously crafted data to `malloc()` and overwrites the right pointer in the
    heap, code execution can occur.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Integer overflow vulnerabilities tend to take the following form:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: This code creates an object of type `Goat`, as well as the `ReadGoats` function,
    which accepts a socket and the number of goats to read from that socket. At ➊,
    the `ReadInt` function reads the number of goats that will be processed from the
    socket itself.
  prefs: []
  type: TYPE_NORMAL
- en: If that number is sufficiently large, the `malloc()` operation at ➋ will result
    in a size so large that the integer wraps around to negative numbers. With the
    right value of `count`, an attacker could make the `malloc()` attempt to allocate
    zero bytes, or a very small number. When the loop at ➌ executes, it will read
    the number of goats from the socket that corresponds to the very large value of
    `count`. Because `goats` is small, this can overflow the allocated memory, allowing
    data to be written to the heap.
  prefs: []
  type: TYPE_NORMAL
- en: '***Preventing Integer Overflows***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'There are several approaches to preventing integer overflows, but the basic
    idea is to check the values of integers before you operate on them. I suggest
    adopting the basic structure from Apple’s coding guide.^([5](footnote.html#fn104))
    Here’s one example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Before calculating the value of `bytes`, this `if` statement checks that `n`
    and `m` are greater than 0 and divides one factor by a maximum size to make sure
    that the result is larger than the other factor. If both conditions are true,
    then you know that `bytes` will fit into an integer, and it should be safe to
    use it to allocate memory.
  prefs: []
  type: TYPE_NORMAL
- en: '**Closing Thoughts**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The list of C coding flaws in this chapter is far from exhaustive, but knowing
    some of these flaws should help you start spotting C-related issues in iOS applications.
    There are also many other resources that can help you hone your C security skills.
    If you’re interested in learning more about the intricacies of C and how it can
    go wrong, I recommend getting a copy of Peter van der Linden’s *Expert C Programming:
    Deep C Secrets* (Prentice Hall, 1994).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that I’ve aired some of the dirty laundry of C, let’s head back to Cocoa
    land and look at modern attacks derived largely from the field of web application
    security: injection attacks.'
  prefs: []
  type: TYPE_NORMAL
