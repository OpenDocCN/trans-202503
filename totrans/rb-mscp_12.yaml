- en: Chapter 12. Garbage Collection in MRI, JRuby, and Rubinius
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第12章。MRI、JRuby和Rubinius中的垃圾回收
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages1853819.png.jpg)'
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_IMG
  zh: '![没有标题的图片](httpatomoreillycomsourcenostarchimages1853819.png.jpg)'
- en: ''
  id: totrans-2
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*The garbage collector is where Ruby objects are born and where they die.*'
  id: totrans-3
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*垃圾回收器是Ruby对象的诞生地，也是它们的死亡地。*'
- en: '*Garbage collection (GC)* is the process high-level languages like Ruby use
    to manage memory for you. Where do your Ruby objects live while you’re using them?
    How does Ruby clean up objects your program no longer uses? Ruby’s GC system solves
    these problems.'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: '*垃圾回收（GC）*是Ruby等高级语言用来为你管理内存的过程。你的Ruby对象在使用时存活在哪里？Ruby如何清理你程序不再使用的对象？Ruby的GC系统解决了这些问题。'
- en: Garbage collection is not unique to Ruby. The first implementation of garbage
    collection was in the Lisp programming language, invented by John McCarthy around
    1960\. Like Ruby, Lisp manages memory for you automatically using garbage collection.
    Since its invention, garbage collection has been the subject of decades of computer
    science research and has become an important feature of numerous computer languages,
    including Java, C#, and, of course, Ruby.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 垃圾回收并不是Ruby所独有的。垃圾回收的第一个实现出现在Lisp编程语言中，由约翰·麦卡锡（John McCarthy）在大约1960年发明。与Ruby一样，Lisp也通过垃圾回收自动为你管理内存。自其发明以来，垃圾回收一直是计算机科学研究的课题，且已成为许多计算机语言的重要特性，包括Java、C#，当然还有Ruby。
- en: 'Computer scientists have invented many different algorithms for performing
    garbage collection. As it turns out, MRI uses the same GC algorithm John McCarthy
    invented over 50 years ago: *mark-and-sweep garbage collection*. JRuby and Rubinius,
    on the other hand, use a different algorithm, invented just a few years later
    in 1963: *copying garbage collection*. They also employ another innovation called
    *generational garbage collection* and can even perform GC tasks in a separate
    thread while your application continues to run using *concurrent garbage collection*.
    In this chapter we’ll touch on the basic ideas behind these complex GC algorithms.
    The MRI, JRuby, and Rubinius garbage collectors use more complex versions of these
    algorithms, but the same fundamental principles apply.'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 计算机科学家发明了许多不同的算法来执行垃圾回收。事实证明，MRI使用的是约翰·麦卡锡（John McCarthy）50多年前发明的相同垃圾回收算法：*标记-扫描垃圾回收*。而JRuby和Rubinius则使用另一种算法，它是在1963年发明的：*复制垃圾回收*。它们还采用了另一种创新方法，称为*代际垃圾回收*，并且可以在应用程序继续运行的同时，通过*并发垃圾回收*在单独的线程中执行GC任务。在本章中，我们将介绍这些复杂的垃圾回收算法背后的基本思想。MRI、JRuby和Rubinius的垃圾回收器使用这些算法的更复杂版本，但相同的基本原则依然适用。
- en: Roadmap
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 路线图
- en: '[Garbage Collectors Solve Three Problems](ch12.html#garbage_collectors_solve_three_problems
    "Garbage Collectors Solve Three Problems")'
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[垃圾回收器解决的三个问题](ch12.html#garbage_collectors_solve_three_problems "垃圾回收器解决的三个问题")'
- en: '[Garbage Collection in MRI: Mark and Sweep](ch12.html#garbage_collection_in_mri_mark_and_sweep
    "Garbage Collection in MRI: Mark and Sweep")'
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[MRI中的垃圾回收：标记与扫描](ch12.html#garbage_collection_in_mri_mark_and_sweep "MRI中的垃圾回收：标记与扫描")'
- en: '[The Free List](ch12.html#free_list "The Free List")'
  id: totrans-10
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[空闲列表](ch12.html#free_list "空闲列表")'
- en: '[MRI’S Use of Multiple Free Lists](ch12.html#mriapostrophes_use_of_multiple_free_list
    "MRI’S Use of Multiple Free Lists")'
  id: totrans-11
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[MRI使用多个空闲列表](ch12.html#mriapostrophes_use_of_multiple_free_list "MRI使用多个空闲列表")'
- en: '[Marking](ch12.html#marking "Marking")'
  id: totrans-12
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[标记](ch12.html#marking "标记")'
- en: '[How Does MRI Mark Live Objects?](ch12.html#how_does_mri_mark_live_objectsquestion_m
    "How Does MRI Mark Live Objects?")'
  id: totrans-13
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[MRI如何标记活跃对象？](ch12.html#how_does_mri_mark_live_objectsquestion_m "MRI如何标记活跃对象？")'
- en: '[Sweeping](ch12.html#sweeping "Sweeping")'
  id: totrans-14
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[扫描](ch12.html#sweeping "扫描")'
- en: '[Lazy Sweeping](ch12.html#lazy_sweeping "Lazy Sweeping")'
  id: totrans-15
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[懒惰扫描](ch12.html#lazy_sweeping "懒惰扫描")'
- en: '[The RVALUE Structure](ch12.html#rvalue_structure "The RVALUE Structure")'
  id: totrans-16
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[RVALUE结构](ch12.html#rvalue_structure "RVALUE结构")'
- en: '[Disadvantages of Mark and Sweep](ch12.html#disadvantages_of_mark_and_sweep
    "Disadvantages of Mark and Sweep")'
  id: totrans-17
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[标记与扫描的缺点](ch12.html#disadvantages_of_mark_and_sweep "标记与扫描的缺点")'
- en: '**[Experiment 12-1: Seeing MRI Garbage Collection in Action](ch12.html#experiment_12-1_seeing_mri_garbage_colle
    "Experiment 12-1: Seeing MRI Garbage Collection in Action")**'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**[实验12-1：观察MRI垃圾回收的实际应用](ch12.html#experiment_12-1_seeing_mri_garbage_colle
    "实验12-1：观察MRI垃圾回收的实际应用")**'
- en: '[Seeing MRI Perform a Lazy Sweep](ch12.html#seeing_mri_perform_a_lazy_sweep
    "Seeing MRI Perform a Lazy Sweep")'
  id: totrans-19
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[查看MRI执行懒惰扫描](ch12.html#seeing_mri_perform_a_lazy_sweep "查看MRI执行懒惰扫描")'
- en: '[Seeing MRI Perform a Full Collection](ch12.html#seeing_mri_perform_a_full_collection
    "Seeing MRI Perform a Full Collection")'
  id: totrans-20
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[看到 MRI 执行完整的回收过程](ch12.html#seeing_mri_perform_a_full_collection "看到 MRI 执行完整的回收过程")'
- en: '[Interpreting a GC Profile Report](ch12.html#interpreting_a_gc_profile_report
    "Interpreting a GC Profile Report")'
  id: totrans-21
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[解读 GC 配置文件报告](ch12.html#interpreting_a_gc_profile_report "解读 GC 配置文件报告")'
- en: '[Garbage Collection in JRuby and Rubinius](ch12.html#garbage_collection_in_jruby_and_rubinius
    "Garbage Collection in JRuby and Rubinius")'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[JRuby 和 Rubinius 中的垃圾回收](ch12.html#garbage_collection_in_jruby_and_rubinius
    "JRuby 和 Rubinius 中的垃圾回收")'
- en: '[Copying Garbage Collection](ch12.html#copying_garbage_collection "Copying
    Garbage Collection")'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[复制垃圾回收](ch12.html#copying_garbage_collection "复制垃圾回收")'
- en: '[Bump Allocation](ch12.html#bump_allocation "Bump Allocation")'
  id: totrans-24
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[Bump 分配](ch12.html#bump_allocation "Bump 分配")'
- en: '[The Semi-Space Algorithm](ch12.html#semi-space_algorithm "The Semi-Space Algorithm")'
  id: totrans-25
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[半空间算法](ch12.html#semi-space_algorithm "半空间算法")'
- en: '[The Eden Heap](ch12.html#eden_heap "The Eden Heap")'
  id: totrans-26
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[伊甸堆](ch12.html#eden_heap "伊甸堆")'
- en: '[Generational Garbage Collection](ch12.html#generational_garbage_collection
    "Generational Garbage Collection")'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[代际垃圾回收](ch12.html#generational_garbage_collection "代际垃圾回收")'
- en: '[The Weak Generational Hypothesis](ch12.html#weak_generational_hypothesis "The
    Weak Generational Hypothesis")'
  id: totrans-28
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[弱代际假设](ch12.html#weak_generational_hypothesis "弱代际假设")'
- en: '[Using the Semi-Space Algorithm for Young Objects](ch12.html#using_the_semi-space_algorithm_for_young
    "Using the Semi-Space Algorithm for Young Objects")'
  id: totrans-29
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[为年轻对象使用半空间算法](ch12.html#using_the_semi-space_algorithm_for_young "为年轻对象使用半空间算法")'
- en: '[Promoting Objects](ch12.html#promoting_objects "Promoting Objects")'
  id: totrans-30
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[提升对象](ch12.html#promoting_objects "提升对象")'
- en: '[Garbage Collection for Mature Objects](ch12.html#garbage_collection_for_mature_objects
    "Garbage Collection for Mature Objects")'
  id: totrans-31
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[成熟对象的垃圾回收](ch12.html#garbage_collection_for_mature_objects "成熟对象的垃圾回收")'
- en: '[References Between Generations](ch12.html#references_between_generations "References
    Between Generations")'
  id: totrans-32
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[代际间的引用](ch12.html#references_between_generations "代际间的引用")'
- en: '[Concurrent Garbage Collection](ch12.html#concurrent_garbage_collection "Concurrent
    Garbage Collection")'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[并发垃圾回收](ch12.html#concurrent_garbage_collection "并发垃圾回收")'
- en: '[Marking While the Object Graph Changes](ch12.html#marking_while_the_object_graph_changes
    "Marking While the Object Graph Changes")'
  id: totrans-34
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[在对象图变化时标记](ch12.html#marking_while_the_object_graph_changes "在对象图变化时标记")'
- en: '[Tricolor Marking](ch12.html#tricolor_marking "Tricolor Marking")'
  id: totrans-35
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[三色标记](ch12.html#tricolor_marking "三色标记")'
- en: '[Three Garbage Collectors in the JVM](ch12.html#three_garbage_collectors_in_the_jvm
    "Three Garbage Collectors in the JVM")'
  id: totrans-36
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[JVM 中的三个垃圾回收器](ch12.html#three_garbage_collectors_in_the_jvm "JVM 中的三个垃圾回收器")'
- en: '**[Experiment 12-2: Using Verbose GC Mode in JRuby](ch12.html#experiment_12-2_using_verbose_gc_mode_in
    "Experiment 12-2: Using Verbose GC Mode in JRuby")**'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**[实验 12-2：在 JRuby 中使用详细 GC 模式](ch12.html#experiment_12-2_using_verbose_gc_mode_in
    "实验 12-2：在 JRuby 中使用详细 GC 模式")**'
- en: '[Triggering Major Collections](ch12.html#triggering_major_collections "Triggering
    Major Collections")'
  id: totrans-38
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[触发主要回收过程](ch12.html#triggering_major_collections "触发主要回收过程")'
- en: '[Further Reading](ch12.html#further_reading "Further Reading")'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[进一步阅读](ch12.html#further_reading "进一步阅读")'
- en: '[Summary](ch12.html#summary-id00048 "Summary")'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[总结](ch12.html#summary-id00048 "总结")'
- en: Garbage Collectors Solve Three Problems
  id: totrans-41
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 垃圾回收器解决了三个问题
- en: 'Despite its name, garbage collection is not only the process of cleaning up
    garbage objects. Garbage collectors, in fact, solve three problems:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管名称为“垃圾回收”，但它不仅仅是清理垃圾对象的过程。垃圾回收器实际上解决了三个问题：
- en: They *allocate* memory for use by new objects.
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们*分配*内存供新对象使用。
- en: They *identify* which objects your program is no longer using.
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们*识别*程序不再使用的对象。
- en: They *reclaim* memory from unused objects.
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们*回收*来自未使用对象的内存。
- en: Ruby’s GC system is no different. When you create a new Ruby object, the garbage
    collector allocates memory for that object. Later, Ruby’s garbage collector determines
    when your program has stopped using the object so it can reuse that memory to
    create new Ruby objects. Allocating memory and reclaiming memory are two sides
    of the same coin; it makes sense for Ruby’s garbage collector to perform both
    tasks.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: Ruby 的 GC 系统也不例外。当你创建一个新的 Ruby 对象时，垃圾回收器会为该对象分配内存。稍后，Ruby 的垃圾回收器会判断你的程序何时不再使用该对象，从而可以重用该内存来创建新的
    Ruby 对象。分配内存和回收内存是同一枚硬币的两面；因此，Ruby 的垃圾回收器执行这两项任务是合乎逻辑的。
- en: 'Garbage Collection in MRI: Mark and Sweep'
  id: totrans-47
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: MRI 中的垃圾回收：标记和清扫
- en: A great place to start learning about garbage collection is MRI’s relatively
    simple GC algorithm, which is similar to the one used by John McCarthy in 1960
    with his groundbreaking work on Lisp. Once we understand how the algorithm works,
    we’ll look at the more complex garbage collection in JRuby and Rubinius and explore
    how MRI is adopting some of their techniques.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 学习垃圾回收的一个好地方是MRI相对简单的GC算法，它类似于约翰·麦卡锡在1960年通过其开创性工作Lisp所使用的算法。一旦我们理解了该算法的工作原理，我们将进一步探讨JRuby和Rubinius中更复杂的垃圾回收机制，并研究MRI是如何采纳它们的一些技术的。
- en: MRI’s *mark-and-sweep* algorithm hands your program memory for new objects until
    the available memory, or *heap*, is exhausted, at which point MRI stops your program
    and *marks* the objects that variables or other objects in your code still hold
    a reference to as *live objects*. Ruby then *sweeps* up the remaining objects,
    called *garbage objects*, allowing their memory to be reused. Once this process
    is complete, Ruby allows your program to continue again.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: MRI的*标记-清除*算法会为你的程序分配新的对象内存，直到可用内存（或*堆*）耗尽，此时MRI会暂停程序并*标记*你代码中仍然持有引用的对象作为*活跃对象*。然后Ruby会*清除*剩余的对象，这些对象称为*垃圾对象*，并允许其内存被重新利用。一旦这个过程完成，Ruby允许你的程序继续执行。
- en: The Free List
  id: totrans-50
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 空闲列表
- en: Standard MRI Ruby uses McCarthy’s original allocation solution, which is called
    the *free list*. [Figure 12-1](ch12.html#conceptual_view_of_the_free_list_insid
    "Figure 12-1. A conceptual view of the free list inside MRI") shows what a free
    list looks like conceptually.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 标准MRI Ruby使用麦卡锡最初的内存分配解决方案，称为*空闲列表*。[图12-1](ch12.html#conceptual_view_of_the_free_list_insid
    "图12-1。MRI内部空闲列表的概念图")展示了空闲列表的概念图。
- en: '![A conceptual view of the free list inside MRI](httpatomoreillycomsourcenostarchimages1854349.png)'
  id: totrans-52
  prefs: []
  type: TYPE_IMG
  zh: '![MRI内部空闲列表的概念图](httpatomoreillycomsourcenostarchimages1854349.png)'
- en: Figure 12-1. A conceptual view of the free list inside MRI
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 图12-1。MRI内部空闲列表的概念图
- en: Each white square in the diagram represents a small piece of memory that is
    available for creating new objects. Think of this diagram as a linked list of
    unused Ruby objects. When you create a new Ruby object, MRI pulls a free memory
    block from the head of the list and uses it to create a new Ruby object, as shown
    in [Figure 12-2](ch12.html#ruby_has_taken_the_first_memory_block_fr "Figure 12-2. Ruby
    has taken the first memory block from the free list and used it to create a new
    Ruby object.").
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 图中的每一个白色方块代表一个可用于创建新对象的小块内存。可以把这个图看作是一个未使用的Ruby对象链表。当你创建一个新的Ruby对象时，MRI从列表的头部取出一个空闲内存块，并用它来创建一个新的Ruby对象，如[图12-2](ch12.html#ruby_has_taken_the_first_memory_block_fr
    "图12-2。Ruby从空闲列表中取出了第一个内存块，并用它创建了一个新的Ruby对象。")所示。
- en: '![Ruby has taken the first memory block from the free list and used it to create
    a new Ruby object.](httpatomoreillycomsourcenostarchimages1854351.png)'
  id: totrans-55
  prefs: []
  type: TYPE_IMG
  zh: '![Ruby从空闲列表中取出了第一个内存块，并用它创建了一个新的Ruby对象。](httpatomoreillycomsourcenostarchimages1854351.png)'
- en: Figure 12-2. Ruby has taken the first memory block from the free list and used
    it to create a new Ruby object.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 图12-2。Ruby从空闲列表中取出了第一个内存块，并用它创建了一个新的Ruby对象。
- en: The gray box in this figure is an allocated, live object. The remaining white
    boxes are still available. Internally all Ruby objects are represented by a C
    structure called `RVALUE`. MRI uses a C *union* inside `RVALUE` to encompass all
    of the C structures we’ve seen so far in MRI, such as `RArray`, `RString`, `RRegexp`,
    and so on. In other words, each square could be any kind of Ruby object or an
    instance of a custom Ruby class (via `RObject`). The contents of each object,
    such as the characters in a string, are often stored in a separate memory location.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 该图中的灰色框表示一个已分配的、活跃的对象。其余的白色框仍然是可用的。在内部，所有Ruby对象都由一个C结构体`RVALUE`表示。MRI在`RVALUE`内部使用一个C
    *联合体*来包含我们目前在MRI中看到的所有C结构体，例如`RArray`、`RString`、`RRegexp`等。换句话说，每个方块都可以是任何类型的Ruby对象，或是一个自定义Ruby类的实例（通过`RObject`）。每个对象的内容，如字符串中的字符，通常存储在一个单独的内存位置。
- en: As your program starts to allocate more new objects, MRI takes more new `RVALUE`
    structures from the free list, and the list of unused values shrinks, as shown
    in [Figure 12-3](ch12.html#as_your_program_creates_more_objectscomm "Figure 12-3. As
    your program creates more objects, MRI starts to use up the free list.").
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 随着你的程序开始分配更多新对象，MRI从空闲列表中取出更多新的`RVALUE`结构，未使用的值列表逐渐缩小，如[图12-3](ch12.html#as_your_program_creates_more_objectscomm
    "图12-3。随着程序创建更多对象，MRI开始耗尽空闲列表。")所示。
- en: '![As your program creates more objects, MRI starts to use up the free list.](httpatomoreillycomsourcenostarchimages1854353.png)'
  id: totrans-59
  prefs: []
  type: TYPE_IMG
  zh: '![当你的程序创建更多对象时，MRI开始使用空闲列表。](httpatomoreillycomsourcenostarchimages1854353.png)'
- en: Figure 12-3. As your program creates more objects, MRI starts to use up the
    free list.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 图12-3. 当你的程序创建更多对象时，MRI开始使用空闲列表。
- en: MRI’S Use of Multiple Free Lists
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: MRI的多空闲列表使用
- en: When MRI starts to execute a Ruby script, it allocates memory for use in the
    free list. It sets the length of the initial free list to about 10,000 `RVALUE`
    structures, which means that MRI can create 10,000 Ruby objects without allocating
    more memory. As more objects are needed, MRI allocates more memory, placing more
    empty RVALUEs onto the free list.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 当MRI开始执行一个Ruby脚本时，它会为空闲列表分配内存。它将初始空闲列表的长度设置为约10,000个`RVALUE`结构体，这意味着MRI可以在不分配更多内存的情况下创建10,000个Ruby对象。当需要更多对象时，MRI会分配更多内存，将更多空的RVALUE结构体放到空闲列表中。
- en: Rather than create a single, long linked list with 10,000 elements, Ruby divides
    the allocated memory into subsections known as *heaps* in the MRI source code,
    each about 16k in size. It then creates a free list for each of these heaps, initially
    creating 24 lists of 407 objects each, using some of the remaining memory for
    other internal data structures.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: Ruby不是创建一个包含10,000个元素的单一长链表，而是将分配的内存划分为多个子区块，在MRI源代码中称为*堆*，每个堆约16k大小。然后，它为每个堆创建一个空闲列表，最初创建24个列表，每个列表包含407个对象，剩余的内存则用于其他内部数据结构。
- en: Because there are multiple free lists, MRI repeatedly returns `RVALUE` structures
    from one free list until it’s empty and then steps to another free list, returning
    more structures from that second list. In this way, MRI iterates over the available
    free lists until they are all empty.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 由于存在多个空闲列表，MRI会不断从一个空闲列表中返回`RVALUE`结构体，直到该列表为空，然后跳到另一个空闲列表，从第二个列表中返回更多结构体。通过这种方式，MRI会遍历所有可用的空闲列表，直到它们全部为空。
- en: Marking
  id: totrans-65
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 标记
- en: As your program runs, it creates new objects, and eventually MRI uses up all
    remaining objects on the free list. At that point, the GC system stops your program,
    identifies objects that your code is no longer using, and reclaims their memory
    for allocation to new objects. If no unused objects are found, Ruby asks the operating
    system for more memory; if there is none to be had, Ruby throws an out-of-memory
    exception and stops.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 当你的程序运行时，它会创建新对象，最终MRI会用完空闲列表上所有剩余的对象。此时，GC系统会停止你的程序，识别出你的代码不再使用的对象，并回收它们的内存，以便分配给新对象。如果没有找到未使用的对象，Ruby会向操作系统请求更多内存；如果没有可用内存，Ruby会抛出内存不足的异常并停止。
- en: Objects that your program allocated but that are no longer being used are known
    as *garbage objects*. To identify garbage objects, MRI traverses pointers in your
    objects’ C structures, following references from one to another in order to find
    all active objects (see [Figure 12-4](ch12.html#ruby_follows_pointerscomma_or_references
    "Figure 12-4. Ruby follows pointers, or references, from one object to another,
    starting with a root object on the left.")). MRI knows your code is no longer
    using an object if it finds no references to them.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 你的程序分配但不再使用的对象被称为*垃圾对象*。为了识别垃圾对象，MRI会遍历你对象的C结构体中的指针，跟随引用从一个对象到另一个对象，找到所有活跃对象（参见[图12-4](ch12.html#ruby_follows_pointerscomma_or_references
    "图12-4. Ruby从左边的根对象开始，沿着指针或引用从一个对象到另一个对象。")）。如果MRI没有找到对某个对象的引用，它就知道你的代码不再使用该对象。
- en: '![Ruby follows pointers, or references, from one object to another, starting
    with a root object on the left.](httpatomoreillycomsourcenostarchimages1854355.png.jpg)'
  id: totrans-68
  prefs: []
  type: TYPE_IMG
  zh: '![Ruby从左边的根对象开始，沿着指针或引用从一个对象到另一个对象。](httpatomoreillycomsourcenostarchimages1854355.png.jpg)'
- en: Figure 12-4. Ruby follows pointers, or references, from one object to another,
    starting with a root object on the left.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 图12-4. Ruby从左边的根对象开始，沿着指针或引用从一个对象到另一个对象。
- en: The gray box on the left is a *root object*, a global variable that you create
    or an internal object that Ruby knows your application must be using. There are
    typically many root objects at any given time. The arrows represent references
    from this root object to other objects, which in turn may contain references to
    other objects. This network of objects and references is known as the *object
    graph*. MRI marks each Ruby object that it finds as it traverses the object graph,
    stopping your program during the marking process in order to insure that no new
    object references are created.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 左侧的灰色框是*根对象*，这是你创建的全局变量或Ruby知道你的应用程序必须使用的内部对象。通常，在任何给定时刻都会有许多根对象。箭头表示从该根对象到其他对象的引用，这些对象可能包含对其他对象的引用。这种对象及其引用的网络被称为*对象图*。MRI在遍历对象图时标记每个找到的Ruby对象，在标记过程中暂停你的程序，以确保不会创建新的对象引用。
- en: Once the marking process completes, the heap contains a series of objects, both
    marked and unmarked, as shown in [Figure 12-5](ch12.html#mri_has_marked_five_active_objects_left
    "Figure 12-5. MRI has marked five active objects (gray) with five garbage objects
    remaining in the heap (white)."). The marked objects are *live*, which means your
    code is actively using them. The unmarked objects are garbage, meaning Ruby can
    release or reclaim their memory. Your code is still using the marked objects,
    so their memory must be preserved.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦标记过程完成，堆中包含一系列对象，既有标记的也有未标记的，如[图12-5](ch12.html#mri_has_marked_five_active_objects_left
    "图12-5. MRI已标记五个活跃对象（灰色），并在堆中剩余五个垃圾对象（白色）。")所示。标记的对象是*活跃的*，意味着你的代码正在使用它们。未标记的对象是垃圾，意味着Ruby可以释放或回收它们的内存。由于你的代码仍在使用这些标记的对象，因此它们的内存必须被保留。
- en: '![MRI has marked five active objects (gray) with five garbage objects remaining
    in the heap (white).](httpatomoreillycomsourcenostarchimages1854357.png.jpg)'
  id: totrans-72
  prefs: []
  type: TYPE_IMG
  zh: '![MRI已标记五个活跃对象（灰色），并在堆中剩余五个垃圾对象（白色）。](httpatomoreillycomsourcenostarchimages1854357.png.jpg)'
- en: Figure 12-5. MRI has marked five active objects (gray) with five garbage objects
    remaining in the heap (white).
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 图12-5. MRI已标记五个活跃对象（灰色），并在堆中剩余五个垃圾对象（白色）。
- en: How Does MRI Mark Live Objects?
  id: totrans-74
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: MRI如何标记活跃对象？
- en: MRI saves the information about marked and unmarked objects using a technique
    known as *bitmap marking*. Bitmap marking refers to the technique of saving the
    live object marks as a series of bits in a data structure known as the *free bitmap*
    (see [Figure 12-6](ch12.html#mri_saves_the_gc_mark_flags_in_a_separat "Figure 12-6. MRI
    saves the GC mark flags in a separate data structure known as the free bitmap.")).
    MRI uses a separate memory structure to hold the free bitmap and doesn’t save
    the marks near the objects.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: MRI使用一种称为*位图标记*的技术来保存标记和未标记对象的信息。位图标记是指将活跃对象的标记作为一系列位保存在一种名为*空闲位图*的数据结构中（参见[图12-6](ch12.html#mri_saves_the_gc_mark_flags_in_a_separat
    "图12-6. MRI将GC标记标志保存在一个名为空闲位图的单独数据结构中。")）。MRI使用一个单独的内存结构来存储空闲位图，而不是将标记保存在对象附近。
- en: '![MRI saves the GC mark flags in a separate data structure known as the free
    bitmap.](httpatomoreillycomsourcenostarchimages1854359.png)'
  id: totrans-76
  prefs: []
  type: TYPE_IMG
  zh: '![MRI将GC标记标志保存在一个名为空闲位图的单独数据结构中。](httpatomoreillycomsourcenostarchimages1854359.png)'
- en: Figure 12-6. MRI saves the GC mark flags in a separate data structure known
    as the *free bitmap*.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 图12-6. MRI将GC标记标志保存在一个名为*空闲位图*的单独数据结构中。
- en: The reason to use a separate memory structure for the mark bits has to do with
    a Unix memory optimization technique called *copy-on-write* (see [Copy-on-Write](ch10.html#copy-on-write
    "Copy-on-Write")). Similar to how Ruby shares memory between different strings
    that contain the same letters, copy-on-write allows Unix processes to share memory
    that contains the same values. By saving the mark bits separately, MRI maximizes
    the amount of memory that will contain the same values across processes. (In Ruby
    1.9 and earlier, the mark bits were saved inside each `RVALUE` structure, causing
    the garbage collector to modify almost all of Ruby’s shared memory while marking
    live objects and rendering the copy-on-write optimization ineffective.)
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 使用一个单独的内存结构来存储标记位的原因与一种称为*写时复制*的Unix内存优化技术有关（参见[写时复制](ch10.html#copy-on-write
    "写时复制")）。类似于Ruby如何在包含相同字母的不同字符串之间共享内存，写时复制允许Unix进程共享包含相同值的内存。通过将标记位单独保存，MRI最大化了内存中相同值的共享数量。（在Ruby
    1.9及更早版本中，标记位保存在每个`RVALUE`结构内部，这导致垃圾回收器在标记活跃对象时修改几乎所有Ruby的共享内存，从而使写时复制优化失效。）
- en: Sweeping
  id: totrans-79
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 扫描
- en: Having identified garbage objects, it’s time to reclaim them. Ruby’s GC algorithm
    places the unmarked objects back on the free list, as shown in [Figure 12-7](ch12.html#while_sweepingcomma_mri_places_unused_rv
    "Figure 12-7. While sweeping, MRI places unused RVALUE structures back on the
    free list.").
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在识别到垃圾对象后，接下来是回收它们。Ruby的GC算法将未标记的对象重新放回空闲链表，如[图12-7](ch12.html#while_sweepingcomma_mri_places_unused_rv
    "图12-7. 在清扫过程中，MRI将未使用的RVALUE结构重新放回空闲链表。")所示。
- en: '![While sweeping, MRI places unused RVALUE structures back on the free list.](httpatomoreillycomsourcenostarchimages1854361.png)'
  id: totrans-81
  prefs: []
  type: TYPE_IMG
  zh: '![在清扫过程中，MRI将未使用的RVALUE结构重新放回空闲链表。](httpatomoreillycomsourcenostarchimages1854361.png)'
- en: Figure 12-7. While sweeping, MRI places unused `RVALUE` structures back on the
    free list.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 图12-7. 在清扫过程中，MRI将未使用的`RVALUE`结构重新放回空闲链表。
- en: The process of moving unused objects back onto the free list is referred to
    as *sweeping* the objects. Normally this process runs very quickly because MRI
    doesn’t actually copy objects; it simply adjusts the pointers in each `RVALUE`
    to create the free linked list (the solid arrows in [Figure 12-7](ch12.html#while_sweepingcomma_mri_places_unused_rv
    "Figure 12-7. While sweeping, MRI places unused RVALUE structures back on the
    free list.")).
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 将未使用的对象移回空闲链表的过程称为*清扫*这些对象。通常，这个过程运行得非常快，因为MRI并不会真正复制对象；它只是调整每个`RVALUE`中的指针，以创建空闲链表（[图12-7](ch12.html#while_sweepingcomma_mri_places_unused_rv
    "图12-7. 在清扫过程中，MRI将未使用的RVALUE结构重新放回空闲链表。")中的实线箭头所示）。
- en: Lazy Sweeping
  id: totrans-84
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 懒惰清扫
- en: Beginning with version 1.9.3, MRI introduced an optimization known as *lazy
    sweeping*. The lazy sweep algorithm reduces the amount of time a program is stopped
    by the garbage collector. (Remember, during the normal mark and sweep, MRI stops
    executing your code.)
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 从版本1.9.3开始，MRI引入了一种名为*懒惰清扫*的优化。懒惰清扫算法减少了程序在垃圾回收器停顿时的时间。（记住，在正常的标记清扫过程中，MRI会停止执行你的代码。）
- en: 'Lazy sweeping sweeps only enough garbage objects back to the free list to create
    a few new Ruby objects and to allow your program to continue, thus reducing the
    amount of time required to sweep. Ruby sweeps all of the garbage `RVALUE` objects
    found in only one of MRI’s internal heap structures back to that heap’s free list.
    If no garbage objects are found in the current heap, Ruby tries a lazy sweep on
    the next heap and works its way through the remaining heaps. (We’ll see this algorithm
    at work in [Experiment 12-1: Seeing MRI Garbage Collection in Action](ch12.html#experiment_12-1_seeing_mri_garbage_colle
    "Experiment 12-1: Seeing MRI Garbage Collection in Action").)'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 懒惰清扫仅将足够的垃圾对象回收到空闲链表中，以便创建一些新的Ruby对象，并让程序继续运行，从而减少了清扫所需的时间。Ruby只会将MRI的一个内部堆结构中找到的所有垃圾`RVALUE`对象清扫回该堆的空闲链表。如果当前堆中没有找到垃圾对象，Ruby会尝试对下一个堆进行懒惰清扫，并继续遍历剩余的堆。（我们将在[实验12-1：观察MRI垃圾回收的实际操作](ch12.html#experiment_12-1_seeing_mri_garbage_colle
    "实验12-1：观察MRI垃圾回收的实际操作")中看到这个算法的运作。）
- en: Lazy sweeping can reduce the amount of time your program is paused waiting for
    garbage collection; however, it doesn’t reduce the overall amount of garbage collection
    work to do. Lazy sweeping amortizes the same total amount of sweeping work over
    multiple GC pauses.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 懒惰清扫可以减少程序在等待垃圾回收时的暂停时间；然而，它并不会减少垃圾回收工作的总体量。懒惰清扫将相同的清扫工作量分摊到多个GC暂停中。
- en: The RVALUE Structure
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: RVALUE结构
- en: You can find the definition of the `RVALUE` C structure in the *gc.c* MRI source
    code file, which contains the implementation of MRI’s garbage collector. [Example 12-1](ch12.html#part_of_the_rvalue_definition_from_gcdot
    "Example 12-1. Part of the RVALUE definition from gc.c") shows part of the `RVALUE`
    definition.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在MRI的*gc.c*源代码文件中找到`RVALUE` C结构的定义，该文件包含了MRI垃圾回收器的实现。[示例12-1](ch12.html#part_of_the_rvalue_definition_from_gcdot
    "示例12-1. 来自gc.c的RVALUE定义的一部分")展示了`RVALUE`定义的一部分。
- en: Example 12-1. *Part of the `RVALUE` definition* from gc.c
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 示例12-1. *`RVALUE`定义的一部分* 来自gc.c
- en: '[PRE0]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Notice at ![](httpatomoreillycomsourcenostarchimages1853843.png.jpg) that `RVALUE`
    uses a union to hold one of many different types of values internally. The first
    possible value is the `free` structure, defined at ![](httpatomoreillycomsourcenostarchimages1853845.png.jpg),
    which represents `RVALUE`s still on the free list. MRI includes every other possible
    type of Ruby object in the union starting at ![](httpatomoreillycomsourcenostarchimages1853847.png.jpg):
    `RObject`, `RString`, and so forth.'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意在 ![](httpatomoreillycomsourcenostarchimages1853843.png.jpg) 处，`RVALUE` 使用联合体来内部存储多种不同类型的值。第一个可能的值是
    `free` 结构，定义在 ![](httpatomoreillycomsourcenostarchimages1853845.png.jpg) 处，表示仍在空闲列表中的
    `RVALUE`。MRI 在联合体中包括所有可能类型的 Ruby 对象，起始位置在 ![](httpatomoreillycomsourcenostarchimages1853847.png.jpg)
    处：`RObject`、`RString` 等等。
- en: Disadvantages of Mark and Sweep
  id: totrans-93
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 标记清除的缺点
- en: The chief disadvantage of mark and sweep is that it requires your program to
    stop and wait while the marking and sweeping processes take place. Beginning with
    version 1.9.3, however, MRI’s lazy sweeping technique shortens the GC pauses somewhat.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 标记清除的主要缺点是，它要求程序暂停并等待标记和清除过程的完成。然而，从 1.9.3 版本开始，MRI 的懒清除技术在一定程度上缩短了 GC 暂停的时间。
- en: Another disadvantage is that the time required to perform a mark-and-sweep garbage
    collection is proportional to the total size of the heap. During the marking phase,
    Ruby needs to visit every active object in your program. During the sweeping phase,
    Ruby needs to iterate over all of the unused garbage objects left in the heap.
    As the number of objects created by your program and the total heap size grows,
    both tasks become more time intensive.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个缺点是，执行标记清除垃圾回收所需的时间与堆的总大小成正比。在标记阶段，Ruby 需要访问程序中的每一个活动对象。在清除阶段，Ruby 需要遍历堆中所有未使用的垃圾对象。随着程序创建的对象数量和堆的总大小的增加，这两个任务都会变得更加耗时。
- en: The final issue with mark and sweep is that all of the free list elements—all
    of the unused objects available for your program to use—must be the same size.
    MRI doesn’t know ahead of time when you allocate a new object whether it will
    be a string, an array, or a simple number. This is why the `RVALUE` structure
    MRI uses in the free list must encompass any possible type of Ruby object.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 标记清除的最后一个问题是，所有空闲列表中的元素——所有未使用的、可供程序使用的对象——必须具有相同的大小。MRI 在你分配新对象时并不知道它是字符串、数组还是一个简单的数字。这就是为什么
    MRI 在空闲列表中使用的 `RVALUE` 结构必须能够包含任何可能类型的 Ruby 对象。
- en: 'Experiment 12-1: Seeing MRI Garbage Collection in Action'
  id: totrans-97
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实验 12-1：观察 MRI 垃圾回收的实际运行
- en: You’ve learned how the MRI GC algorithm works at a theoretical level. Let’s
    switch gears now to see how MRI performs actual garbage collection. The script
    in [Example 12-2](ch12.html#creating_10_ruby_objects_using_objectdot "Example 12-2. Creating
    10 Ruby objects using Object.new") creates 10 Ruby objects.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经了解了 MRI 垃圾回收算法的理论原理。现在，让我们换个角度，看看 MRI 如何执行实际的垃圾回收。在[示例 12-2](ch12.html#creating_10_ruby_objects_using_objectdot
    "示例 12-2. 使用 Object.new 创建 10 个 Ruby 对象")中，创建了 10 个 Ruby 对象。
- en: Example 12-2. Creating 10 Ruby objects using `Object.new`
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 12-2. 使用 `Object.new` 创建 10 个 Ruby 对象
- en: '[PRE1]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: If it’s true that MRI assigns unused space from the free list to new objects,
    Ruby should remove 10 `RVALUE` structures from the free list and assign them to
    these 10 new objects when we run [Example 12-2](ch12.html#creating_10_ruby_objects_using_objectdot
    "Example 12-2. Creating 10 Ruby objects using Object.new"). To see this in action,
    we use the `ObjectSpace#count_objects` method, as shown in [Example 12-3](ch12.html#using_objectspacehashcountunderscoreobje
    "Example 12-3. Using ObjectSpace#count_objects to display information about MRI’s
    heap").
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 MRI 确实从空闲列表中分配未使用的空间给新对象，那么在我们运行 [示例 12-2](ch12.html#creating_10_ruby_objects_using_objectdot
    "示例 12-2. 使用 Object.new 创建 10 个 Ruby 对象") 时，Ruby 应该从空闲列表中移除 10 个 `RVALUE` 结构，并将它们分配给这
    10 个新对象。为了查看这一过程的实际效果，我们使用 `ObjectSpace#count_objects` 方法，如 [示例 12-3](ch12.html#using_objectspacehashcountunderscoreobje
    "示例 12-3. 使用 ObjectSpace#count_objects 显示 MRI 堆的信息") 所示。
- en: Example 12-3. Using `ObjectSpace#count_objects` to display information about
    MRI’s heap
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 12-3. 使用 `ObjectSpace#count_objects` 显示 MRI 堆的信息
- en: '[PRE2]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Now we call `display_count` at ![](httpatomoreillycomsourcenostarchimages1853847.png.jpg)
    each time around the loop. `display_count` uses `ObjectSpace#count_objects` at
    ![](httpatomoreillycomsourcenostarchimages1853843.png.jpg) to display information
    at ![](httpatomoreillycomsourcenostarchimages1853845.png.jpg) about the total
    number of objects, the number of free objects, and the number of `RObject` structures
    active each time around the loop.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们每次在循环中调用 `display_count`。`display_count` 使用 `ObjectSpace#count_objects`
    来显示关于总对象数量、空闲对象数量以及每次循环中活动的 `RObject` 结构的相关信息。
- en: Running [Example 12-3](ch12.html#using_objectspacehashcountunderscoreobje "Example 12-3. Using
    ObjectSpace#count_objects to display information about MRI’s heap") gives the
    output shown in [Example 12-4](ch12.html#output_produced_by_listing_12-3 "Example 12-4. The
    output produced by Example 12-3").
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 运行 [示例 12-3](ch12.html#using_objectspacehashcountunderscoreobje "示例 12-3. 使用
    ObjectSpace#count_objects 显示 MRI 堆的相关信息") 会产生 [示例 12-4](ch12.html#output_produced_by_listing_12-3
    "示例 12-4. 示例 12-3 产生的输出") 中显示的结果。
- en: Example 12-4. The output produced by [Example 12-3](ch12.html#using_objectspacehashcountunderscoreobje
    "Example 12-3. Using ObjectSpace#count_objects to display information about MRI’s
    heap")
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 12-4. [示例 12-3](ch12.html#using_objectspacehashcountunderscoreobje "示例 12-3.
    使用 ObjectSpace#count_objects 显示 MRI 堆的相关信息") 产生的输出
- en: '[PRE3]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The `Total:` field displays the value that MRI returns for `ObjectSpace.count_objects[:TOTAL]`.
    This value (17491) is the total number of objects currently active inside Ruby.
    It includes objects we create; objects Ruby creates internally while parsing,
    compiling, and executing our program; and objects on the free list. This number
    does not change when we create new objects because it already includes the entire
    free list.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '`Total:` 字段显示 MRI 返回的 `ObjectSpace.count_objects[:TOTAL]` 的值。该值（17491）表示当前
    Ruby 中所有活动对象的总数。它包括我们创建的对象；Ruby 在解析、编译和执行程序时内部创建的对象；以及空闲列表中的对象。这个数字在我们创建新对象时不会改变，因为它已经包括了整个空闲列表中的对象。'
- en: The `Free:` field displays the value returned by `ObjectSpace.count_objects[:FREE]`
    for the length of the free list. Notice that the value drops by about 7 each time
    around the loop. We create only one object per iteration, but Ruby creates 6 other
    objects each time around the loop while running the code in the `display_count`
    method.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '`Free:` 字段显示 `ObjectSpace.count_objects[:FREE]` 返回的空闲列表长度值。请注意，每次循环时，该值都会减少约
    7。我们每次迭代只创建一个对象，但 Ruby 在执行 `display_count` 方法中的代码时，每次循环都会创建 6 个其他对象。'
- en: The `Object:` field displays the count of `RObject` structures currently active
    in Ruby. Notice that this value increases by 1 each time around the loop, even
    though we don’t keep an active reference to the new objects. That is, we don’t
    save the value returned by `Object.new` anywhere. The `RObject` count includes
    active and garbage objects.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '`Object:` 字段显示当前在 Ruby 中活动的 `RObject` 结构的数量。请注意，每次循环时，这个值都会增加 1，即使我们没有保持对新对象的活动引用。也就是说，我们没有将
    `Object.new` 返回的值保存到任何地方。`RObject` 的计数包括活动对象和垃圾对象。'
- en: Seeing MRI Perform a Lazy Sweep
  id: totrans-111
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 查看 MRI 执行懒散清理
- en: Now if we increase the number of iterations from 10 to 30 and rerun [Example 12-3](ch12.html#using_objectspacehashcountunderscoreobje
    "Example 12-3. Using ObjectSpace#count_objects to display information about MRI’s
    heap"), we see the following output in [Example 12-5](ch12.html#running_listing_12-3_with_30_iterations
    "Example 12-5. Running Example 12-3 with 30 iterations instead of 10").
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果我们将迭代次数从 10 增加到 30，并重新运行 [示例 12-3](ch12.html#using_objectspacehashcountunderscoreobje
    "示例 12-3. 使用 ObjectSpace#count_objects 显示 MRI 堆的相关信息")，我们将在 [示例 12-5](ch12.html#running_listing_12-3_with_30_iterations
    "示例 12-5. 将示例 12-3 的迭代次数从 10 改为 30") 中看到以下输出。
- en: Example 12-5. Running [Example 12-3](ch12.html#using_objectspacehashcountunderscoreobje
    "Example 12-3. Using ObjectSpace#count_objects to display information about MRI’s
    heap") with 30 iterations instead of 10
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 12-5. 运行 [示例 12-3](ch12.html#using_objectspacehashcountunderscoreobje "示例
    12-3. 使用 ObjectSpace#count_objects 显示 MRI 堆的相关信息")，将迭代次数从 10 改为 30
- en: '[PRE4]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: This time the free list count drops to 8 at ![](httpatomoreillycomsourcenostarchimages1853843.png.jpg).
    Then at ![](httpatomoreillycomsourcenostarchimages1853845.png.jpg) the free count
    increases to 246, but the object count remains at 104\. This must be a full garbage
    collection. But it’s not! If Ruby had collected all available garbage objects,
    it would have reduced the `RObject` count when it increased the free count because
    all of our objects become garbage immediately. What’s going on here?
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 这时，空闲列表计数下降至 8，在 ![](httpatomoreillycomsourcenostarchimages1853843.png.jpg)
    处。然后在 ![](httpatomoreillycomsourcenostarchimages1853845.png.jpg) 处，空闲计数增加到 246，但对象计数保持在
    104。 这看起来像是一次完整的垃圾回收。但是实际上并不是！如果 Ruby 已经回收了所有可用的垃圾对象，当空闲计数增加时，`RObject` 的计数应该会减少，因为我们的所有对象会立即成为垃圾。这里到底发生了什么？
- en: 'This was a lazy sweep. Ruby first marked all active objects, indirectly identifying
    the garbage ones. Instead of moving all the garbage objects to the free list,
    however, it swept only a portion of them: the garbage objects it found in one
    of its internal heap structures. The free count increased, but the `RObject` count
    remained the same because MRI reused an `RObject` structure created by one of
    the previous iterations in order to create the new object.'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一种懒惰清理。Ruby 首先标记所有活动对象，间接识别出垃圾对象。然而，Ruby 并没有将所有垃圾对象移动到空闲列表，而是只清理了其中一部分：它从某个内部堆结构中找到了垃圾对象。空闲计数增加了，但
    `RObject` 的计数保持不变，因为 MRI 重用了一个先前迭代中创建的 `RObject` 结构来创建新对象。
- en: Seeing MRI Perform a Full Collection
  id: totrans-117
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 查看 MRI 执行完整的垃圾回收
- en: We can see the effect of a full garbage collection by triggering one manually
    with the `GC.start` method (see [Example 12-6](ch12.html#triggering_a_full_garbage_collection
    "Example 12-6. Triggering a full garbage collection")).
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过手动触发完整垃圾回收来观察其效果，方法是使用 `GC.start`（见 [示例 12-6](ch12.html#triggering_a_full_garbage_collection
    "示例 12-6. 触发完整垃圾回收")）。
- en: Example 12-6. Triggering a full garbage collection
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 12-6. 触发完整的垃圾回收
- en: '[PRE5]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Here, we again iterate 30 times, creating new objects and calling `display_count`.
    Then, we call `GC.start` at ![](httpatomoreillycomsourcenostarchimages1853843.png.jpg),
    which triggers MRI to run a full garbage collection. Finally, at ![](httpatomoreillycomsourcenostarchimages1853845.png.jpg)
    we call `display_count` again to display the same technical information. [Example 12-7](ch12.html#output_generated_by_listing_12-6
    "Example 12-7. The output generated by Example 12-6") shows the new output.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们再次迭代 30 次，创建新对象并调用 `display_count`。然后，在 ![](httpatomoreillycomsourcenostarchimages1853843.png.jpg)
    处，我们调用 `GC.start`，这会触发 MRI 执行完整的垃圾回收。最后，在 ![](httpatomoreillycomsourcenostarchimages1853845.png.jpg)
    处，我们再次调用 `display_count` 来显示相同的技术信息。[示例 12-7](ch12.html#output_generated_by_listing_12-6
    "示例 12-7. 示例 12-6 生成的输出") 显示了新的输出。
- en: Example 12-7. The output generated by [Example 12-6](ch12.html#triggering_a_full_garbage_collection
    "Example 12-6. Triggering a full garbage collection")
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 12-7. [示例 12-6](ch12.html#triggering_a_full_garbage_collection "示例 12-6.
    触发完整垃圾回收") 生成的输出
- en: '[PRE6]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Most of [Example 12-7](ch12.html#output_generated_by_listing_12-6 "Example 12-7. The
    output generated by Example 12-6") shows output similar to [Example 12-5](ch12.html#running_listing_12-3_with_30_iterations
    "Example 12-5. Running Example 12-3 with 30 iterations instead of 10"). The total
    remains the same, while the free count gradually decreases. At ![](httpatomoreillycomsourcenostarchimages1853843.png.jpg)
    we see the lazy sweep occur again, increasing the free count to 251\. But at ![](httpatomoreillycomsourcenostarchimages1853845.png.jpg)
    we see a dramatic change. The total number of objects remains at 17491, but the
    free count jumps to 9527 and the number of objects reduces dramatically to 43!
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 12-7](ch12.html#output_generated_by_listing_12-6 "示例 12-7. 示例 12-6 生成的输出")
    的大部分内容与 [示例 12-5](ch12.html#running_listing_12-3_with_30_iterations "示例 12-5.
    运行示例 12-3，进行 30 次迭代而非 10 次") 的输出相似。总数保持不变，而空闲计数逐渐减少。在 ![](httpatomoreillycomsourcenostarchimages1853843.png.jpg)
    处，我们看到懒惰清理再次发生，空闲计数增加至 251。然而，在 ![](httpatomoreillycomsourcenostarchimages1853845.png.jpg)
    处，我们看到一个显著变化。对象的总数保持在 17491，但空闲计数跃升至 9527，且对象数剧烈减少至 43！'
- en: 'From this observation, we know the following:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 从这个观察中，我们可以得出以下结论：
- en: The free count increased dramatically at ![](httpatomoreillycomsourcenostarchimages1853845.png.jpg)
    because Ruby swept all of the garbage objects onto the free list in one large
    operation. This garbage included the objects our code created in previous iterations
    as well as objects that Ruby created internally during the parsing and compilation
    phases.
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 ![](httpatomoreillycomsourcenostarchimages1853845.png.jpg) 处，free计数显著增加，因为Ruby通过一次大规模操作将所有垃圾对象移动到了空闲列表中。这些垃圾对象包括我们代码在之前迭代中创建的对象，以及Ruby在解析和编译阶段内部创建的对象。
- en: The `RObject` count reduced to 43 because all of the objects created in previous
    iterations were garbage (because we didn’t save them anywhere). The 43 count includes
    only objects Ruby created internally and none of the objects our code created.
    If we had saved our new objects somewhere, the `RObject` count would have remained
    the same. (We’ll try this next.)
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`RObject`的数量减少到43，因为之前迭代中创建的所有对象都是垃圾（因为我们没有将它们保存在任何地方）。这个43的数量仅包括Ruby内部创建的对象，而不包括我们代码创建的对象。如果我们将新对象保存到某个地方，`RObject`的数量将保持不变。（我们接下来会尝试这样做。）'
- en: Interpreting a GC Profile Report
  id: totrans-128
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解读GC性能分析报告
- en: So far in this experiment we’ve allocated just a few objects from the free list.
    Of course, your Ruby programs will typically create many more than 30 objects.
    How does MRI’s garbage collector behave when we create thousands or even millions
    of objects? How can you find out how much time is being taken by the garbage collector
    in a complex Ruby application?
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个实验中，我们只从空闲列表中分配了少量对象。当然，您的Ruby程序通常会创建更多的对象，远超30个。当我们创建数千个甚至数百万个对象时，MRI的垃圾回收器会如何表现？如何得知在复杂的Ruby应用程序中垃圾回收器占用了多少时间？
- en: The answer is to use the `GC::Profiler` class. If you enable it, MRI’s internal
    GC code will collect statistics about each GC run. [Example 12-8](ch12.html#displaying_a_gc_usage_profile_using_gcpr
    "Example 12-8. Displaying a GC usage profile using GC::Profiler (gc-profile.rb)")
    shows how to use `GC::Profiler`.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 答案是使用`GC::Profiler`类。如果启用它，MRI的内部GC代码将收集关于每次GC运行的统计数据。[示例 12-8](ch12.html#displaying_a_gc_usage_profile_using_gcpr
    "示例 12-8. 使用 GC::Profiler 显示 GC 使用情况")展示了如何使用`GC::Profiler`。
- en: Example 12-8. Displaying a GC usage profile using `GC::Profiler` *(gc-profile.rb)*
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 12-8. 使用`GC::Profiler`显示GC使用情况*(gc-profile.rb)*
- en: '[PRE7]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: We first enable the profiler at ![](httpatomoreillycomsourcenostarchimages1853843.png.jpg)
    by calling `GC::Profiler.enable`. The following code creates 10 million Ruby objects.
    At ![](httpatomoreillycomsourcenostarchimages1853845.png.jpg) we display the GC
    profile report by calling `GC::Profiler.report`. [Example 12-9](ch12.html#portion_of_the_gc_profile_report_gener
    "Example 12-9. A portion of the GC profile report generated in Example 12-8")
    shows the report generated in [Example 12-8](ch12.html#displaying_a_gc_usage_profile_using_gcpr
    "Example 12-8. Displaying a GC usage profile using GC::Profiler (gc-profile.rb)").
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先在 ![](httpatomoreillycomsourcenostarchimages1853843.png.jpg) 处通过调用`GC::Profiler.enable`启用性能分析器。以下代码创建了1000万个Ruby对象。在
    ![](httpatomoreillycomsourcenostarchimages1853845.png.jpg) 处，我们通过调用`GC::Profiler.report`显示GC性能分析报告。[示例
    12-9](ch12.html#portion_of_the_gc_profile_report_gener "示例 12-9. 从示例 12-8 生成的GC性能分析报告的一部分")显示了在[示例
    12-8](ch12.html#displaying_a_gc_usage_profile_using_gcpr "示例 12-8. 使用 GC::Profiler
    显示 GC 使用情况")中生成的报告。
- en: Example 12-9. A portion of the GC profile report generated in [Example 12-8](ch12.html#displaying_a_gc_usage_profile_using_gcpr
    "Example 12-8. Displaying a GC usage profile using GC::Profiler (gc-profile.rb)")
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 12-9. 从[示例 12-8](ch12.html#displaying_a_gc_usage_profile_using_gcpr "示例 12-8.
    使用 GC::Profiler 显示 GC 使用情况")生成的GC性能分析报告的一部分
- en: '[PRE8]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'To save space, I’ve removed the first column from the report, a simple counter.
    Here’s what the other columns mean:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 为了节省空间，我已从报告中移除了第一列——一个简单的计数器。以下是其他列的含义：
- en: '*Invoke time* shows when the garbage collection occurred, measured as seconds
    after the Ruby script started to run.'
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*调用时间* 显示垃圾回收发生的时间，单位是Ruby脚本开始运行后的秒数。'
- en: '*Use size* shows how much heap memory is used by all live Ruby objects after
    each collection is finished.'
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*使用的大小* 显示每次垃圾回收完成后，所有存活的Ruby对象占用的堆内存大小。'
- en: '*Total size* shows the total size of the heap after collection—in other words,
    the memory taken by live objects plus the size of the free list.'
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*总大小* 显示回收后堆的总大小——换句话说，就是存活对象占用的内存加上空闲列表的大小。'
- en: '*Total object* shows the total number of Ruby objects, either live or on the
    free list.'
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*总对象* 显示Ruby对象的总数，包括存活对象和空闲列表中的对象。'
- en: Finally, *GC time* shows the amount of time each collection took.
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，*GC时间* 显示每次垃圾回收所用的时间。
- en: Notice in this experiment that, aside from *invoke time*, none of the values
    change. The amount of memory used by live Ruby objects, the total size of the
    heap, and the total number of objects all remain the same. This is because we
    don’t save the new Ruby objects anywhere. They all immediately become garbage.
    The *GC time* value fluctuates somewhat but more or less remains the same. The
    amount of time required by the collector to sweep all of the new objects back
    to the free list remains about the same because the collector sweeps about the
    same number of objects each time.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 在此实验中，注意到除了 *调用时间* 之外，没有任何值发生变化。活跃 Ruby 对象所使用的内存量、堆的总大小和对象的总数量都保持不变。这是因为我们没有将新
    Ruby 对象保存到任何地方。它们立即变成垃圾。*GC 时间*值有所波动，但大致保持不变。垃圾回收器清扫所有新对象并将其移回空闲列表所需的时间保持大致相同，因为每次回收器清扫的对象数量大致相同。
- en: However, if we save all of the new objects in an array, they will remain live
    and not become garbage. [Example 12-10](ch12.html#saving_10_million_ruby_objects_in_an_arr
    "Example 12-10. Saving 10 million Ruby objects in an array (gc-profile-array.rb)")
    shows code that saves each object into a single, large array.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果我们将所有新对象保存在一个数组中，它们将保持活跃并且不会变成垃圾。[示例 12-10](ch12.html#saving_10_million_ruby_objects_in_an_arr
    "示例 12-10. 在数组中保存 1000 万个 Ruby 对象 (gc-profile-array.rb)") 展示了将每个对象保存到一个单一的大数组中的代码。
- en: Example 12-10. Saving 10 million Ruby objects in an array *(gc-profile-array.rb)*
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 12-10. 在数组中保存 1000 万个 Ruby 对象 *(gc-profile-array.rb)*
- en: '[PRE9]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Here, we create an empty array at ![](httpatomoreillycomsourcenostarchimages1853843.png.jpg)
    and save each of the new objects in it at ![](httpatomoreillycomsourcenostarchimages1853845.png.jpg).
    Because the array holds a reference to all of the new objects, they remain active.
    The garbage collector can’t reclaim memory from any of them. [Example 12-11](ch12.html#ruby_has_to_increase_the_heap_size_to_ac
    "Example 12-11. Ruby has to increase the heap size to accommodate all the new,
    live objects.") shows the GC profile report produced by [Example 12-10](ch12.html#saving_10_million_ruby_objects_in_an_arr
    "Example 12-10. Saving 10 million Ruby objects in an array (gc-profile-array.rb)").
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们在 ![](httpatomoreillycomsourcenostarchimages1853843.png.jpg) 创建了一个空数组，并在
    ![](httpatomoreillycomsourcenostarchimages1853845.png.jpg) 中保存了每个新对象。由于数组持有所有新对象的引用，它们保持活跃。垃圾回收器无法回收任何这些对象的内存。[示例
    12-11](ch12.html#ruby_has_to_increase_the_heap_size_to_ac "示例 12-11. Ruby 必须增加堆的大小以容纳所有新的活跃对象")
    显示了由 [示例 12-10](ch12.html#saving_10_million_ruby_objects_in_an_arr "示例 12-10.
    在数组中保存 1000 万个 Ruby 对象 (gc-profile-array.rb)") 生成的 GC 性能分析报告。
- en: Example 12-11. Ruby has to increase the heap size to accommodate all the new,
    live objects.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 12-11. Ruby 必须增加堆的大小以容纳所有新的活跃对象。
- en: '[PRE10]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: This time the profile report is very different! The garbage collector can’t
    free any of the new objects because they remain active in the array. This means
    Ruby has no choice but to repeatedly allocate more memory to hold them. When you
    read [Example 12-11](ch12.html#ruby_has_to_increase_the_heap_size_to_ac "Example 12-11. Ruby
    has to increase the heap size to accommodate all the new, live objects."), notice
    that all three important values—*use size*, *total size*, and *total object*—increase
    exponentially. This increase is why at ![](httpatomoreillycomsourcenostarchimages1853843.png.jpg)
    we see the garbage collector was called only 17 times. (Ruby also ran a few collections
    before we called `GC::Profiler.enable` as it parsed and compiled our script.)
    Each time the collector more or less doubled the size of the heap, allowing the
    script to continue to run for longer and longer periods of time. Instead of running
    many collections quickly, as we saw in [Example 12-9](ch12.html#portion_of_the_gc_profile_report_gener
    "Example 12-9. A portion of the GC profile report generated in Example 12-8"),
    Ruby ran just a few slow collections.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 这次的性能分析报告非常不同！垃圾回收器无法释放任何新对象，因为它们仍然活跃在数组中。这意味着 Ruby 则不得不反复分配更多内存来容纳它们。当你阅读 [示例
    12-11](ch12.html#ruby_has_to_increase_the_heap_size_to_ac "示例 12-11. Ruby 必须增加堆的大小以容纳所有新的活跃对象")
    时，注意到三个重要的值——*使用大小*、*总大小*和*对象总数*——都呈指数增长。这种增长就是为什么在 ![](httpatomoreillycomsourcenostarchimages1853843.png.jpg)
    我们看到垃圾回收器只被调用了 17 次。（在调用 `GC::Profiler.enable` 之前，Ruby 也运行了几次垃圾回收，因为它解析并编译了我们的脚本。）每次垃圾回收器都会或多或少地将堆的大小加倍，从而使脚本能够持续运行更长时间。与我们在
    [示例 12-9](ch12.html#portion_of_the_gc_profile_report_gener "示例 12-9. 从示例 12-8
    生成的 GC 性能分析报告的一部分") 中看到的快速多次垃圾回收不同，Ruby 只运行了几次较慢的垃圾回收。
- en: If we draw a graph of the time required for each collection (*GC Time*) against
    the total size of the heap (*Total Heap Size*), as shown in [Figure 12-8](ch12.html#time_required_to_perform_mark_and_sw
    "Figure 12-8. The time required to perform mark and sweep increases linearly with
    the heap size."), we can draw another interesting conclusion.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们绘制每次回收所需时间（*GC 时间*）与堆的总大小（*总堆大小*）的图表，如 [图 12-8](ch12.html#time_required_to_perform_mark_and_sw
    "图 12-8. 执行标记和清除所需的时间随着堆大小线性增加") 所示，我们可以得出另一个有趣的结论。
- en: '![The time required to perform mark and sweep increases linearly with the heap
    size.](httpatomoreillycomsourcenostarchimages1854363.png.jpg)'
  id: totrans-151
  prefs: []
  type: TYPE_IMG
  zh: '![执行标记和清除所需的时间随着堆大小线性增加。](httpatomoreillycomsourcenostarchimages1854363.png.jpg)'
- en: Figure 12-8. The time required to perform mark and sweep increases linearly
    with the heap size.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12-8. 执行标记和清除所需的时间随着堆大小线性增加。
- en: '[Figure 12-8](ch12.html#time_required_to_perform_mark_and_sw "Figure 12-8. The
    time required to perform mark and sweep increases linearly with the heap size.")
    uses a logarithmic scale for both the x-axis (*Total Heap Size*) and the y-axis
    (*GC Time*). Because Ruby doubled the heap size during each collection, the data
    points are more or less evenly spaced across the logarithmic x-axis scale. They
    are also evenly spaced along the logarithmic y-axis because the time increases
    exponentially.'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 12-8](ch12.html#time_required_to_perform_mark_and_sw "图 12-8. 执行标记和清除所需的时间随着堆大小线性增加")使用对数刻度表示横轴（*总堆大小*）和纵轴（*GC
    时间*）。因为 Ruby 在每次回收时都会将堆大小翻倍，所以数据点在对数横轴上大致均匀分布。由于时间是指数级增加的，数据点在对数纵轴上也大致均匀分布。'
- en: 'Most importantly, note the data points form a straight line: This straight
    line means the time required to perform a garbage collection increases linearly
    as a function of the total heap size. As you create more Ruby objects, it takes
    longer to mark them. Sweeping also takes longer when there are more garbage objects;
    however, in this example, we don’t see any sweep time because all our objects
    remain live.'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 最重要的是，注意数据点形成了一条直线：这条直线意味着执行垃圾回收所需的时间随着总堆大小线性增加。随着你创建更多的 Ruby 对象，标记它们的时间也会更长。当垃圾对象增多时，清理过程也需要更多时间；然而，在这个例子中，我们没有看到清理时间，因为所有对象都保持活跃。
- en: Garbage Collection in JRuby and Rubinius
  id: totrans-155
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: JRuby 和 Rubinius 的垃圾回收
- en: 'Because JRuby uses the Java Virtual Machine (JVM) to implement Ruby, it’s able
    to use the JVM’s sophisticated GC system to manage memory for Ruby objects. In
    fact, garbage collection is one of the primary benefits of using the JVM platform:
    The JVM garbage collector has been refined over many years.'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 JRuby 使用 Java 虚拟机（JVM）来实现 Ruby，它能够利用 JVM 的高级垃圾回收系统来管理 Ruby 对象的内存。事实上，垃圾回收是使用
    JVM 平台的主要优点之一：JVM 的垃圾回收器已经经过多年的优化。
- en: The Rubinius C++ virtual machine also includes a sophisticated, efficient garbage
    collector that uses some of the same underlying algorithms as the JVM. One of
    the benefits of choosing Rubinius as your Ruby platform is its sophisticated GC
    system.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: Rubinius 的 C++ 虚拟机还包含一个复杂高效的垃圾回收器，使用了与 JVM 相同的一些底层算法。选择 Rubinius 作为你的 Ruby 平台的一个好处就是它的先进垃圾回收系统。
- en: 'The garbage collectors used by JRuby and Rubinius differ from MRI’s garbage
    collector in three ways:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: JRuby 和 Rubinius 使用的垃圾回收器与 MRI 的垃圾回收器在三个方面有所不同：
- en: Instead of using a free list, they allocate memory for new objects and reclaim
    memory from garbage objects using an algorithm called *copying garbage collection*.
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们并没有使用空闲列表，而是为新对象分配内存，并通过一种叫做*复制垃圾回收*的算法回收垃圾对象的内存。
- en: They handle old and young Ruby objects differently using *generational garbage
    collection*.
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们通过*代际垃圾回收*以不同的方式处理旧的和新的 Ruby 对象。
- en: They use *concurrent garbage collection* to perform some GC tasks at the same
    time that your application code is running.
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们使用*并发垃圾回收*在应用程序代码运行时执行一些垃圾回收任务。
- en: Note
  id: totrans-162
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '*Although the GC systems used by JRuby and Rubinius are dramatically different
    from MRI’s mark-and-sweep garbage collector, MRI has begun to incorporate some
    of these ideas as well. Specifically, the GC system in Ruby 2.1 has begun to use
    generational and concurrent garbage collection.*'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: '*尽管 JRuby 和 Rubinius 使用的垃圾回收系统与 MRI 的标记-清除垃圾回收器有很大不同，但 MRI 已经开始引入一些这些概念。具体来说，Ruby
    2.1 中的垃圾回收系统已经开始使用代际和并发垃圾回收。*'
- en: In the following sections, we’ll explore the basic algorithms underpinning copying,
    generational, and concurrent garbage collection, as we learn more about how garbage
    collection works in Rubinius and JRuby.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的章节中，我们将探讨支撑复制、分代和并发垃圾回收的基本算法，同时了解Rubinius和JRuby中垃圾回收是如何工作的。
- en: Copying Garbage Collection
  id: totrans-165
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 复制垃圾回收
- en: In 1963, three years after John McCarthy built the first Lisp garbage collector,
    Marvin Minsky developed a different way of allocating and reclaiming memory known
    as *copying garbage collection*. (Minsky’s research was also originally used for
    Lisp. The algorithm was later refined by Fenichel and Yochelson in 1969 and by
    Baker in 1978.) Instead of using a free list to track available objects, copying
    garbage collectors allocate memory for new objects from a single large heap or
    memory segment. When that memory segment is used up, these collectors *copy* only
    the live objects over to a second memory segment, leaving the garbage objects
    behind. The two segments are then swapped, immediately reclaiming all of the memory
    from the garbage objects. (Rubinius and the JVM both use complex algorithms based
    on this original idea.)
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 1963年，在约翰·麦卡锡（John McCarthy）构建了第一个Lisp垃圾回收器三年后，马文·明斯基（Marvin Minsky）开发了一种不同的内存分配和回收方式，称为*复制垃圾回收*。（明斯基的研究最初也用于Lisp。该算法后来在1969年由Fenichel和Yochelson以及在1978年由Baker进行了改进。）与使用空闲列表跟踪可用对象的方式不同，复制垃圾回收器从一个大的堆或内存段中为新对象分配内存。当这个内存段用完时，这些回收器*复制*所有活跃对象到第二个内存段，并将垃圾对象遗留在原地。然后，交换这两个内存段，立即回收垃圾对象所占用的所有内存。（Rubinius和JVM都使用基于这个原始思想的复杂算法。）
- en: Bump Allocation
  id: totrans-167
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 增量分配
- en: When you allocate memory for a new object using a copying garbage collector,
    such as the collectors in the JVM and Rubinius, the garbage collector uses an
    algorithm called *bump allocation*. Bump allocation allocates adjacent memory
    segments from a large, continuous heap by *bumping*, or incrementing, a pointer
    to keep track of where the next allocation will occur. [Figure 12-9](ch12.html#allocating_three_objects_using_bump_allo
    "Figure 12-9. Allocating three objects using bump allocation") shows how this
    process works for three repeated allocations. (The large rectangle represents
    the Rubinius or JVM heap.)
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 当你使用复制垃圾回收器（例如JVM和Rubinius中的回收器）为新对象分配内存时，垃圾回收器使用一种称为*增量分配*的算法。增量分配通过*增进*或递增一个指针来分配来自大而连续堆的相邻内存段，以跟踪下一个分配的位置。[图12-9](ch12.html#allocating_three_objects_using_bump_allo
    "图12-9。使用增量分配分配三个对象")展示了这个过程如何在三次重复分配中工作。（大矩形表示Rubinius或JVM的堆。）
- en: '![Allocating three objects using bump allocation](httpatomoreillycomsourcenostarchimages1854365.png)'
  id: totrans-169
  prefs: []
  type: TYPE_IMG
  zh: '![使用增量分配分配三个对象](httpatomoreillycomsourcenostarchimages1854365.png)'
- en: Figure 12-9. Allocating three objects using bump allocation
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 图12-9。使用增量分配分配三个对象
- en: A copying collector keeps a pointer that tracks where in the heap the next allocation
    will occur. Each time the collector allocates memory for a new object, it returns
    some memory from the heap and moves this pointer to the right. As more objects
    are created, the memory allocated from the heap also moves to the right. Notice,
    too, that the new objects are not all the same size; each object uses a different
    number of bytes. As a result, the objects are not spaced evenly across the heap.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 复制回收器保持一个指针，用于跟踪下一个分配将在堆中的哪里发生。每次回收器为新对象分配内存时，它都会从堆中取出一些内存，并将指针向右移动。随着更多对象的创建，从堆中分配的内存也向右移动。还要注意的是，新对象的大小并不相同；每个对象使用的字节数不同。因此，这些对象在堆中并不均匀分布。
- en: The advantages of this technique are that it’s very fast and simple to implement
    and it provides good *locality of reference*, meaning that related values in your
    program should be located near each other in memory. Locality is important because
    if your code repeatedly accesses the same area of memory, your CPU can cache that
    memory and access it much more quickly. If your program often accesses very different
    areas of memory, the CPU must continually reload the memory cache, slowing down
    your program’s performance.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 这种技术的优点是它非常快速且实现简单，并且提供了良好的*引用局部性*，意味着程序中相关的值应该在内存中相互靠近。局部性很重要，因为如果你的代码反复访问相同的内存区域，CPU可以缓存这些内存并更快速地访问它。如果程序经常访问非常不同的内存区域，CPU必须不断重新加载内存缓存，从而减慢程序的性能。
- en: Another benefit of copying garbage collection is the ability to create objects
    of different sizes. Unlike the `RVALUE` structure in MRI, JRuby and Rubinius can
    allocate new objects of any size.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 复制垃圾回收的另一个好处是能够创建不同大小的对象。与MRI中的`RVALUE`结构不同，JRuby和Rubinius可以分配任意大小的新对象。
- en: The Semi-Space Algorithm
  id: totrans-174
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 半空间算法
- en: The real benefit and elegance of copying garbage collectors becomes evident
    when the initial heap is used up and a garbage collection occurs. Copying garbage
    collectors identify live and garbage objects the way that mark-and-sweep collectors
    do—by traversing the object graph following object references or pointers. Once
    the garbage objects have been identified, however, copying garbage collectors
    work very differently.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 当初始堆用尽并发生垃圾回收时，复制垃圾回收器的真正优势和优雅之处显现出来。复制垃圾回收器以与标记清除（mark-and-sweep）回收器相同的方式识别存活对象和垃圾对象——通过遍历对象图，跟随对象引用或指针。然而，一旦垃圾对象被识别出来，复制垃圾回收器的工作方式就非常不同了。
- en: 'Copying garbage collectors actually use two heaps: one to create new objects
    with bump allocation and a second, empty one, as shown in [Figure 12-10](ch12.html#semi-space_algorithm_uses_two_heapsc
    "Figure 12-10. The semi-space algorithm uses two heaps, one initially empty.").'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 复制垃圾回收器实际上使用两个堆：一个用来通过增量分配（bump allocation）创建新对象，另一个为空的堆，如[图12-10](ch12.html#semi-space_algorithm_uses_two_heapsc
    "图12-10。半空间算法使用两个堆，其中一个最初为空。")所示。
- en: '![The semi-space algorithm uses two heaps, one initially empty.](httpatomoreillycomsourcenostarchimages1854367.png)'
  id: totrans-177
  prefs: []
  type: TYPE_IMG
  zh: '![半空间算法使用两个堆，其中一个最初为空。](httpatomoreillycomsourcenostarchimages1854367.png)'
- en: Figure 12-10. The semi-space algorithm uses two heaps, one initially empty.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 图12-10。半空间算法使用两个堆，其中一个最初为空。
- en: The heap at the top contains the objects already created and is known as the
    *from-space*. Note that the objects in the from-space were already marked as live
    (gray with an *M*) or garbage (white). The lower heap is the *to-space*, and it’s
    initially empty. The algorithm I’m about to describe is known as the *semi-space*
    algorithm because the total available memory is divided between the from-space
    and the to-space.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 上方的堆包含已经创建的对象，称为*来自空间*（from-space）。请注意，来自空间中的对象已经被标记为存活（灰色并带有*M*标记）或垃圾（白色）。下方的堆是*目标空间*（to-space），最初为空。接下来我将描述的算法被称为*半空间*算法，因为总的可用内存被分为来自空间和目标空间。
- en: When the from-space becomes completely full, copying garbage collectors copy
    all of the live objects down into the to-space, leaving the garbage objects behind.
    [Figure 12-11](ch12.html#semi-space_algorithm_copies_only_liv "Figure 12-11. The
    semi-space algorithm copies only live objects to the second heap.") shows the
    copying process.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 当来自空间（from-space）完全填满时，复制垃圾回收器将所有存活的对象复制到目标空间（to-space），并将垃圾对象留在原地。[图12-11](ch12.html#semi-space_algorithm_copies_only_liv
    "图12-11。半空间算法仅将存活的对象复制到第二个堆中。")展示了复制过程。
- en: '![The semi-space algorithm copies only live objects to the second heap.](httpatomoreillycomsourcenostarchimages1854369.png)'
  id: totrans-181
  prefs: []
  type: TYPE_IMG
  zh: '![半空间算法仅将存活的对象复制到第二个堆中。](httpatomoreillycomsourcenostarchimages1854369.png)'
- en: Figure 12-11. The semi-space algorithm copies only live objects to the second
    heap.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 图12-11。半空间算法仅将存活的对象复制到第二个堆中。
- en: The from-space again appears at the top of the diagram and the to-space below.
    Notice how the live objects are copied down into the to-space. The arrows pointing
    down indicate this copying process. A pointer similar to the one used for bump
    allocation keeps track of where the next live object should be copied to.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 来自空间（from-space）再次出现在图表的顶部，而目标空间（to-space）位于下方。注意存活的对象是如何被复制到目标空间中的。指向下方的箭头表示这一复制过程。类似于增量分配中使用的指针，会跟踪下一个存活对象应该复制到哪里。
- en: Once the copying process is finished, the semi-space algorithm swaps heaps,
    as shown in [Figure 12-12](ch12.html#after_copying_the_live_objectscomma_the "Figure 12-12. After
    copying the live objects, the semi-space algorithm switches heaps.").
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦复制过程完成，半空间算法会交换堆，如[图12-12](ch12.html#after_copying_the_live_objectscomma_the
    "图12-12。复制存活对象后，半空间算法交换堆。")所示。
- en: '![After copying the live objects, the semi-space algorithm switches heaps.](httpatomoreillycomsourcenostarchimages1854371.png.jpg)'
  id: totrans-185
  prefs: []
  type: TYPE_IMG
  zh: '![复制存活对象后，半空间算法交换堆。](httpatomoreillycomsourcenostarchimages1854371.png.jpg)'
- en: Figure 12-12. After copying the live objects, the semi-space algorithm switches
    heaps.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 图12-12。复制存活对象后，半空间算法交换堆。
- en: In [Figure 12-12](ch12.html#after_copying_the_live_objectscomma_the "Figure 12-12. After
    copying the live objects, the semi-space algorithm switches heaps."), the to-space
    has become the new from-space and is now ready to allocate more memory for new
    objects using bump allocation. You might expect the algorithm to be slow because
    so much copying is involved, but it’s not, because only active, live objects are
    copied. Garbage objects are left in place and then reclaimed.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 在[图12-12](ch12.html#after_copying_the_live_objectscomma_the "图12-12. 复制活跃对象后，半空间算法切换堆。")中，to-space已经变成了新的from-space，并且现在准备通过提升分配来为新对象分配更多内存。你可能会认为这个算法会很慢，因为涉及了大量的复制操作，但其实并不慢，因为只有活跃的、存活的对象才会被复制，垃圾对象会被留下并最终回收。
- en: Note
  id: totrans-188
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '*All of the live objects were copied to the left side of the heap; this allows
    the garbage collector to allocate the remaining unused memory most efficiently.
    This compaction of the heap is a natural result of the semi-space algorithm.*'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: '*所有活跃对象都被复制到堆的左侧；这使得垃圾回收器能够最有效地分配剩余未使用的内存。堆的压缩是半空间算法的自然结果。*'
- en: While the semi-space algorithm is an elegant way to manage memory, it is somewhat
    memory inefficient. It requires the collector to allocate twice as much memory
    as it actually uses because all of your objects might remain active and could
    be copied into the second heap. The algorithm is also somewhat difficult to implement
    because when the collector moves live objects, it also has to update references
    and pointers to them internally.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然半空间算法是一种优雅的内存管理方式，但它在某种程度上存在内存低效的问题。它要求回收器分配的内存是实际使用内存的两倍，因为所有对象可能都保持活跃状态，并可能被复制到第二个堆中。这个算法也比较难以实现，因为当回收器移动活跃对象时，它还必须更新对这些对象的引用和指针。
- en: The Eden Heap
  id: totrans-191
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 伊甸堆
- en: As it turns out, both Rubinius and the JVM use a variation of the semi-space
    algorithm with a third heap structure for allocating new objects called the *Garden
    of Eden*, or *Eden heap*. [Figure 12-13](ch12.html#eden_heap_is_for_allocating_memory_f
    "Figure 12-13. The Eden heap is for allocating memory for brand-new objects.")
    shows the three memory structures.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 事实证明，Rubinius 和 JVM 都使用一种变体的半空间算法，并采用一种称为*伊甸园*（Garden of Eden）或*伊甸堆*（Eden heap）的第三种堆结构来分配新对象的内存。[图12-13](ch12.html#eden_heap_is_for_allocating_memory_f
    "图12-13. 伊甸堆用于分配全新对象的内存。")展示了这三种内存结构。
- en: '![The Eden heap is for allocating memory for brand-new objects.](httpatomoreillycomsourcenostarchimages1854373.png)'
  id: totrans-193
  prefs: []
  type: TYPE_IMG
  zh: '![伊甸堆用于分配全新对象的内存。](httpatomoreillycomsourcenostarchimages1854373.png)'
- en: Figure 12-13. The Eden heap is for allocating memory for brand-new objects.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 图12-13. 伊甸堆用于分配全新对象的内存。
- en: The Eden heap is where the JVM and Rubinius allocate memory for new objects;
    the from-space contains all of the live objects copied in the previous garbage
    collection process; and the to-space remains empty until the next garbage collection
    runs. Each time the garbage collection process runs, the collector copies your
    objects from both the Eden heap and from-space into the to-space, thereby allowing
    more memory to be available for new objects because the Eden heap will always
    be empty after each semi-space copy operation.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 伊甸堆是JVM和Rubinius为新对象分配内存的地方；from-space包含了在上一次垃圾回收过程中复制过来的所有活跃对象；to-space在下一次垃圾回收运行之前保持为空。每次垃圾回收过程运行时，回收器将你的对象从伊甸堆和from-space复制到to-space，从而为新对象提供更多的内存，因为每次半空间复制操作后，伊甸堆都会保持为空。
- en: Generational Garbage Collection
  id: totrans-196
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 世代垃圾回收
- en: Many modern garbage collectors, including the collectors in the JVM and the
    Rubinius VM, use *generational GC* algorithms, a technique that treats new objects
    differently than older ones. A new, or *young*, object is one that your program
    has just created, while an old, or *mature*, object is one that your program is
    continuing to use. The time that an object has to remain active for in order for
    it to be considered mature is usually measured by the number of times the garbage
    collection system has run.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 包括JVM和Rubinius虚拟机在内的许多现代垃圾回收器使用*世代GC*算法，这是一种将新对象与旧对象区别对待的技术。新对象，或*年轻对象*，是你的程序刚刚创建的对象，而旧对象，或*成熟对象*，是你的程序正在继续使用的对象。一个对象被认为是成熟对象的标准通常是它在垃圾回收系统运行的次数。
- en: The Weak Generational Hypothesis
  id: totrans-198
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 弱世代假设
- en: The reason objects are categorized as either young or mature is based on the
    assumption that most young objects will have a short lifetime while mature objects
    are likely to continue to live for a long time. This assumption is known as the
    *weak generational hypothesis*. In simple terms, new objects are likely to die
    young. Because young and mature objects have different life expectancies, different
    GC algorithms are appropriate for each category, or *generation*.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 将对象分类为年轻对象或成熟对象的原因基于这样的假设：大多数年轻对象的生命周期较短，而成熟对象可能会持续很长时间。这一假设被称为*弱代际假设*。简单来说，新对象通常会“早逝”。由于年轻对象和成熟对象的生命周期不同，因此每个类别或*代*需要采用不同的垃圾收集算法。
- en: For example, consider a Ruby on Rails website. To generate a web page for each
    client request, a Rails application creates many new Ruby objects. However, once
    a web page has been generated and returned to the client, all of those Ruby objects
    are no longer needed and the GC system can reclaim their memory. At the same time,
    the application might also create a few Ruby objects that live between requests,
    such as ones that represent a controller, some configuration data, or a user session.
    These few mature objects would have a longer lifetime.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，考虑一个Ruby on Rails网站。为了生成每个客户端请求的网页，Rails应用会创建许多新的Ruby对象。然而，一旦网页生成并返回给客户端，所有这些Ruby对象就不再需要，垃圾收集系统可以回收它们的内存。同时，应用可能还会创建一些在请求之间存活的Ruby对象，比如表示控制器、一些配置数据或用户会话的对象。这些成熟对象会有更长的生命周期。
- en: Using the Semi-Space Algorithm for Young Objects
  id: totrans-201
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用半空间算法处理年轻对象
- en: 'According to the weak generational hypothesis, young objects are created continually
    by your program but also become garbage quite frequently. Because of this, both
    the JVM and Rubinius run the GC process more frequently for young objects than
    for mature ones (you’ll see just how much more frequently in [Experiment 12-2:
    Using Verbose GC Mode in JRuby](ch12.html#experiment_12-2_using_verbose_gc_mode_in
    "Experiment 12-2: Using Verbose GC Mode in JRuby")). The semi-space algorithm
    is ideal for young objects because it copies only live objects. When the Eden
    heap fills up with new objects, the garbage collector identifies most of them
    as garbage because new objects usually die young. Because there are fewer live
    objects, the collector has less copying to do. The JVM refers to these objects
    as *survivors* and calls the from-space and the to-space *survivor spaces*.'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 根据弱代际假设，年轻对象是程序不断创建的，但也经常变成垃圾。因此，JVM和Rubinius对于年轻对象运行垃圾收集过程的频率远高于成熟对象（你将在[实验12-2：在JRuby中使用详细GC模式](ch12.html#experiment_12-2_using_verbose_gc_mode_in
    "实验12-2：在JRuby中使用详细GC模式")中看到详细数据）。半空间算法非常适合处理年轻对象，因为它只复制存活的对象。当伊甸园堆（Eden heap）充满新对象时，垃圾收集器会将其中大部分标记为垃圾，因为新对象通常早逝。由于存活的对象较少，垃圾收集器的复制工作量也较小。JVM将这些对象称为*幸存者*，并将from-space和to-space称为*幸存者空间*。
- en: Promoting Objects
  id: totrans-203
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 提升对象
- en: When a new object becomes old (that is, when it has survived a certain number
    of runs of the GC system), it is *promoted*, or copied, into the mature generation
    heap during the semi-space copy process, as shown in [Figure 12-14](ch12.html#generational_garbage_collectors_promote
    "Figure 12-14. Generational garbage collectors promote old objects from the young
    heap to the mature one.").
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个新对象变成旧对象（即它经历了垃圾收集系统的若干次运行后），它会在半空间复制过程中被*提升*，即被复制到成熟代堆中，如[图12-14](ch12.html#generational_garbage_collectors_promote
    "图12-14. 代际垃圾收集器将旧对象从年轻堆提升到成熟堆中.")所示。
- en: '![Generational garbage collectors promote old objects from the young heap to
    the mature one.](httpatomoreillycomsourcenostarchimages1854375.png)'
  id: totrans-205
  prefs: []
  type: TYPE_IMG
  zh: '![代际垃圾收集器将旧对象从年轻堆提升到成熟堆中。](httpatomoreillycomsourcenostarchimages1854375.png)'
- en: Figure 12-14. Generational garbage collectors promote old objects from the young
    heap to the mature one.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 图12-14. 代际垃圾收集器将旧对象从年轻堆提升到成熟堆中。
- en: Notice that the from-space contains five active objects, shown as gray rectangles.
    Two of these are copied down to the to-space by the semi-space algorithm, but
    the other three are promoted. Their age has exceeded the *new object lifetime*
    because they have remained active for a certain number of GC runs.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，from-space包含五个活动对象，显示为灰色矩形。通过半空间算法，其中两个对象被复制到to-space，而其他三个对象则被提升。它们的年龄已经超过了*新对象生命周期*，因为它们在若干次垃圾收集运行中保持活跃。
- en: In Rubinius, the new object lifetime is set to 2 by default, meaning that a
    young object becomes mature once the GC system has run twice with your code still
    holding a reference to that object. (This means that Rubinius will copy a live
    object twice between the from- and to-space, using the semi-space algorithm.)
    Over time, Rubinius adjusts the object lifetime value, based on various statistics,
    to optimize garbage collection as much as possible.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
- en: The JVM’s garbage collector internally calculates the new object lifetime, attempting
    to keep the from- and to-space heaps about half full. If these heaps start to
    fill up, the new object lifetime will decrease, and objects will be promoted more
    quickly. If the spaces are mostly empty, the JVM will increase the new object
    lifetime, allowing new objects to remain there longer.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
- en: Garbage Collection for Mature Objects
  id: totrans-210
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Once your objects are promoted into the mature collection, they will likely
    live on for a long time due to the weak generational hypothesis. As a result,
    both the JVM and Rubinius need to run garbage collection on the mature generation
    much less frequently. Garbage collection on the mature generation runs once the
    heap allocated for mature objects fills up. Because most new objects don’t live
    past the new object lifetime, the mature collection fills up slowly.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
- en: 'The JVM offers many command-line options that allow you to configure the relative
    or absolute sizes of young and mature generation heaps (the JVM documentation
    refers to the mature generation as the *tenured generation*). The JVM also maintains
    a third generation for internal objects created by the JVM itself: the *permanent
    generation*. Garbage collection on the young generation is called a *minor collection*,
    and on the tenured generation, it’s a *major collection*.'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
- en: Rubinius uses a sophisticated GC algorithm called *Immix* for the mature generation
    of objects. Immix attempts to reduce the amount of total memory used and the amount
    of heap fragmentation by collecting active objects into continuous regions. Rubinius
    also uses a third generation for very large objects and collects them using a
    standard mark-and-sweep process.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-214
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*MRI Ruby version 2.1 implements a generational GC algorithm for standard Ruby
    like the one the JVM and Rubinius have used for years. Its primary challenge is
    also detecting which mature objects reference young ones (see [References Between
    Generations](ch12.html#references_between_generations "References Between Generations")).
    MRI solves this problem by using write barriers to track each time a mature object
    references a young one, though implementing write barriers in MRI is complex because
    existing C extensions won’t contain them.*'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
- en: References Between Generations
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
- en: 'In addition to the new object lifetime, generational garbage collectors have
    to track another important detail: young objects that are active because of a
    reference from an old object. Because collections on the young generation will
    not mark mature objects, the collector might assume that certain young objects
    are garbage when they are not. [Figure 12-15](ch12.html#generational_garbage_collectors_need_to
    "Figure 12-15. Generational garbage collectors need to find mature objects that
    reference young objects.") shows an example of the problem.'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
- en: '![Generational garbage collectors need to find mature objects that reference
    young objects.](httpatomoreillycomsourcenostarchimages1854377.png.jpg)'
  id: totrans-218
  prefs: []
  type: TYPE_IMG
- en: Figure 12-15. Generational garbage collectors need to find mature objects that
    reference young objects.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
- en: 'The young collection contains several live objects (gray) and garbage objects
    (white). During the young object marking phase, the generational garbage collector
    follows only references from young objects in order to speed up the process, which
    occurs frequently. Notice, however, the center object marked with a question mark:
    Is it live or garbage? There are no references to it from other young objects,
    but there is a reference to it from a mature object. If Rubinius or the JVM were
    to run the semi-space algorithm on the young objects at left after marking them,
    the center object would be incorrectly considered garbage and its contents overwritten!'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
- en: '**Write Barriers**'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
- en: Generational garbage collectors can solve this problem using *write barriers*.
    These are bits of code that keep track of when your program adds a reference from
    a mature object to a young one. When the garbage collector encounters such a reference,
    it considers that one mature object to be another root for use in marking young
    objects, thereby allowing the object in question to be considered live and to
    be copied properly by the semi-space algorithm.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
- en: Concurrent Garbage Collection
  id: totrans-223
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Both Rubinius and the JVM use another sophisticated technique to reduce the
    amount of time your application spends waiting for garbage collection: *concurrent
    garbage collection*. When using concurrent garbage collection, the garbage collector
    runs at the same time as your application code. This eliminates, or at least reduces,
    pauses in your program due to garbage collection because your application doesn’t
    have to stop and wait while the garbage collector runs.'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
- en: Concurrent garbage collectors run in a separate thread from the primary application.
    Although in theory this could mean that your application will slow a bit because
    part of the CPU’s time has to be spent running the GC thread, most computers today
    contain microprocessors with multiple cores, which allow different threads to
    run in parallel. This means one of the cores can be dedicated to running the GC
    thread, leaving the other cores to run the primary application. (In practice,
    this still might slow down your application because fewer cores are available.)
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-226
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*MRI Ruby 2.1 also supports a form of concurrent garbage collection by performing
    the sweep portion of the mark-and-sweep algorithm in parallel while your Ruby
    code continues to run. This helps to reduce the amount of time your application
    is paused while garbage collection runs.*'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
- en: Marking While the Object Graph Changes
  id: totrans-228
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Marking objects while your application is running presents one large obstacle
    for concurrent garbage collectors: What if your application changes the object
    graph while the collector is marking it? To better understand this problem, see
    the example object graph in [Figure 12-16](ch12.html#garbage_collector_marking_an_object_gr
    "Figure 12-16. A garbage collector marking an object graph").'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
- en: This figure shows a small set of objects being marked by a concurrent garbage
    collector. On the left is a root object, and to the right are various child objects
    referenced by the root object. All of the live objects are marked with *M* and
    shown in gray. The garbage collector, indicated by the large arrow, has already
    marked the live objects and is now processing the objects near the bottom. The
    collector is about to mark the two remaining white objects at the bottom right.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
- en: '![A garbage collector marking an object graph](httpatomoreillycomsourcenostarchimages1854379.png.jpg)'
  id: totrans-231
  prefs: []
  type: TYPE_IMG
- en: Figure 12-16. A garbage collector marking an object graph
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
- en: Now suppose your application, which is also running while the marking process
    is underway, creates a new object and adds it as a child of one of the previously
    marked objects. [Figure 12-17](ch12.html#your_application_creates_a_new_object_wh
    "Figure 12-17. Your application creates a new object while the marking process
    is underway.") shows the new situation.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
- en: '![Your application creates a new object while the marking process is underway.](httpatomoreillycomsourcenostarchimages1854381.png.jpg)'
  id: totrans-234
  prefs: []
  type: TYPE_IMG
- en: Figure 12-17. Your application creates a new object while the marking process
    is underway.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
- en: Notice that one of the live, marked objects points to a new object that hasn’t
    been marked yet.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
- en: Now suppose the garbage collector finishes marking the object graph. It has
    marked all of the live objects, meaning that any remaining objects are assumed
    to be garbage. [Figure 12-18](ch12.html#collector_incorrectly_considers_the "Figure 12-18. The
    collector incorrectly considers the new live object to be garbage.") shows how
    the object graph appears at the end of the marking process.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
- en: '![The collector incorrectly considers the new live object to be garbage.](httpatomoreillycomsourcenostarchimages1854383.png.jpg)'
  id: totrans-238
  prefs: []
  type: TYPE_IMG
- en: Figure 12-18. The collector incorrectly considers the new live object to be
    garbage.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
- en: The garbage collector has finished marking all live objects, but it missed the
    new object. The collector will now reclaim its memory, but the application will
    have lost valid data or will have garbage data added to one of its objects!
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
- en: Tricolor Marking
  id: totrans-241
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The solution to this problem is to maintain a *mark stack*, or a list of objects
    that still need to be examined by the marking process, as shown in [Figure 12-19](ch12.html#marking_process_works_through_the_ob
    "Figure 12-19. The marking process works through the objects in the mark stack.").
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
- en: '![The marking process works through the objects in the mark stack.](httpatomoreillycomsourcenostarchimages1854385.png.jpg)'
  id: totrans-243
  prefs: []
  type: TYPE_IMG
- en: Figure 12-19. The marking process works through the objects in the mark stack.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
- en: Initially all of the root objects are placed on the mark stack. As the garbage
    collector marks objects, it moves them from the mark stack to the list of marked
    objects on the left, and it adds any child objects it finds to the mark stack.
    When the mark stack is exhausted, the garbage collector is finished; it has identified
    all live objects and any remaining objects on the right are assumed to be garbage.
    But with this scheme, if the application modifies one of the objects during marking,
    the collector can move the modified object back to the mark stack, even if it
    was previously marked, as shown in [Figure 12-20](ch12.html#collector_moves_a_marked_object_back
    "Figure 12-20. The collector moves a marked object back to the mark stack because
    the application modified it.").
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
- en: '![The collector moves a marked object back to the mark stack because the application
    modified it.](httpatomoreillycomsourcenostarchimages1854387.png)'
  id: totrans-246
  prefs: []
  type: TYPE_IMG
- en: Figure 12-20. The collector moves a marked object back to the mark stack because
    the application modified it.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
- en: The application has added a new object to the system, as shown at right in the
    figure’s remaining objects list. This time, however, the collector notices that
    an existing object was modified because it now contains a reference to the new
    object and it moves the modified object to the mark stack in the center. As a
    result, the collector will eventually find and mark the new object as it works
    through the mark stack.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
- en: 'This modified marking algorithm is known as *tricolor marking*: Objects already
    processed are considered “black”; objects on the mark stack, “gray”; and the remaining
    objects, “white,” as shown in [Figure 12-19](ch12.html#marking_process_works_through_the_ob
    "Figure 12-19. The marking process works through the objects in the mark stack.")
    and [Figure 12-20](ch12.html#collector_moves_a_marked_object_back "Figure 12-20. The
    collector moves a marked object back to the mark stack because the application
    modified it.").'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-250
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*Concurrent garbage collectors can use write barriers to detect when an application
    changes the object graph. Write barriers are used by both generational and concurrent
    garbage collectors.*'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
- en: Three Garbage Collectors in the JVM
  id: totrans-252
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In order to support different types of applications and server hardware, the
    JVM includes three separate garbage collectors that implement concurrent garbage
    collection differently. You can use command-line parameters to choose which collector
    to run in your JRuby program. The three collectors are as follows:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
- en: '****Serial****. This collector stops your application and performs garbage
    collection while your application is waiting. It doesn’t use concurrent garbage
    collection at all.'
  id: totrans-254
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '****Parallel****. This collector performs many GC tasks, including minor collections,
    in a separate thread while your application is running.'
  id: totrans-255
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '****Concurrent****. This collector performs most GC tasks in parallel with
    your application. It’s optimized to reduce GC pauses as much as possible, but
    its use may slow down your application’s overall throughput.'
  id: totrans-256
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  id: totrans-257
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*In addition to these three, a variety of new, experimental garbage collectors
    are also available for the JVM. One of these is the garbage-first (G1) collector,
    and another is the continuously concurrent compacting (C4) collector.*'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
- en: Unless you direct it to do otherwise, the JVM automatically selects one of these
    garbage collectors, depending on the type of hardware being used. For most computers,
    the JVM uses the parallel collector by default; for server-class machines, it
    uses the concurrent collector instead. You can change the JVM’s default garbage
    collection choice by using command-line options when you start your JRuby program.
    See the article “Java SE 6 HotSpot Virtual Machine Garbage Collection Tuning”
    (*[http://www.oracle.com/technetwork/java/javase/gc-tuning-6-140523.html](http://www.oracle.com/technetwork/java/javase/gc-tuning-6-140523.html)*)
    for more details.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
- en: The ability to choose from these different GC algorithms and to further tune
    the behavior of the collector using many other configuration options is one of
    the great benefits of using JRuby. The effectiveness and performance of a garbage
    collector depends on your application’s behavior as well as the underlying algorithms
    used.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
- en: 'To help make sense of the myriad GC-related options provided by the JVM, Charles
    Nutter, one of the lead developers behind the JRuby project, suggests using the
    following rules of thumb:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
- en: When in doubt, stick with the JVM’s default settings. These settings work well
    in most cases.
  id: totrans-262
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you have a lot of data that need to be collected frequently or periodically,
    the concurrent or experimental G1 collectors may do a better job than the parallel
    collector.
  id: totrans-263
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Try to improve your code so it uses less memory before tuning garbage collection.
    Tuning the JVM’s garbage collector when you are allocating too much memory solves
    only half the problem.
  id: totrans-264
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Experiment 12-2: Using Verbose GC Mode in JRuby'
  id: totrans-265
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '[Experiment 12-1: Seeing MRI Garbage Collection in Action](ch12.html#experiment_12-1_seeing_mri_garbage_colle
    "Experiment 12-1: Seeing MRI Garbage Collection in Action") explored garbage collection
    in MRI. In this experiment, we’ll see how garbage collection works in JRuby by
    asking the JVM to display technical information about what the JVM’s garbage collector
    is doing. [Example 12-12](ch12.html#creating_10_ruby_objects_using_o-id00046 "Example 12-12. Creating
    10 Ruby objects using Object.new (jruby-gc.rb)") shows the code from [Experiment
    12-1: Seeing MRI Garbage Collection in Action](ch12.html#experiment_12-1_seeing_mri_garbage_colle
    "Experiment 12-1: Seeing MRI Garbage Collection in Action") that creates 10 Ruby
    objects.'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
- en: Example 12-12. Creating 10 Ruby objects using `Object.new` *(jruby-gc.rb)*
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'When we run this simple program using the `-J-verbose:gc` option, the JVM displays
    internal debugging information about garbage collection. Here’s the command to
    use:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: But this command doesn’t produce any output. Perhaps we aren’t creating enough
    objects to trigger a garbage collection.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
- en: Let’s increase the number of new objects to 10 million, as shown in [Example 12-13](ch12.html#creating_10_million_ruby_objects_using_o
    "Example 12-13. Creating 10 million Ruby objects using Object.new (jruby-gc.rb)").
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
- en: Example 12-13. Creating 10 million Ruby objects using `Object.new` *(jruby-gc.rb)*
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The new output is shown in [Example 12-14](ch12.html#output_produced_by_running_listing_1
    "Example 12-14. The output produced by running Example 12-13 with -J-verbose:gc").
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
- en: Example 12-14. The output produced by running [Example 12-13](ch12.html#creating_10_million_ruby_objects_using_o
    "Example 12-13. Creating 10 million Ruby objects using Object.new (jruby-gc.rb)")
    with `-J-verbose:gc`
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The JVM displays a line of information each time garbage collection occurs
    while running our Ruby program. There are 14 GC events shown here. Each line contains
    the following information:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
- en: '****`[GC...`**** The *GC* prefix means this event was a minor collection. The
    JVM cleaned up only new objects in the Eden heap or young objects in the survivor
    spaces.'
  id: totrans-279
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '****`17024K->1292K`****. These values show the amount of data used by live
    objects before (left of the arrow) and after (right of the arrow) the garbage
    collection. In this example, the amount of space taken up by live objects in the
    young collection dropped from about 17MB or 18MB to about 1.3MB each time.'
  id: totrans-280
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '****`(83008K)`****. The value in parentheses shows the total size of the JVM
    heap for this process. This value has not changed.'
  id: totrans-281
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '****`0.0072491 secs`****. This value shows the amount of time taken to perform
    each garbage collection.'
  id: totrans-282
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Example 12-14](ch12.html#output_produced_by_running_listing_1 "Example 12-14. The
    output produced by running Example 12-13 with -J-verbose:gc") shows that the JVM’s
    young heap repeatedly fills up as we create more Ruby objects. Notice that each
    time the JVM garbage collector usually takes less than 1 millisecond to clean
    up the many thousands of garbage objects.'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
- en: Notice, too, that there were no major garbage collections. Why? Because we don’t
    save our Ruby objects. [Example 12-13](ch12.html#creating_10_million_ruby_objects_using_o
    "Example 12-13. Creating 10 million Ruby objects using Object.new (jruby-gc.rb)")
    creates 10 million objects but doesn’t use them, so the JVM’s garbage collector
    determines that they are all garbage and reclaims their memory immediately before
    they are promoted to become mature objects.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
- en: Triggering Major Collections
  id: totrans-285
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In order to trigger major collections, we need to create some mature objects
    by creating Ruby objects that don’t die young but that live on for some time.
    We can achieve this by saving our new objects in an array, as we did in [Experiment
    12-1: Seeing MRI Garbage Collection in Action](ch12.html#experiment_12-1_seeing_mri_garbage_colle
    "Experiment 12-1: Seeing MRI Garbage Collection in Action"). [Example 12-15](ch12.html#saving_10_million_ruby_objects_i-id00047
    "Example 12-15. Saving 10 million Ruby objects in an array") repeats the same
    script again here for convenience.'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
- en: Example 12-15. Saving 10 million Ruby objects in an array
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Notice at ![](httpatomoreillycomsourcenostarchimages1853843.png.jpg) that we
    create an empty array and then insert all 10 million new objects into it at ![](httpatomoreillycomsourcenostarchimages1853845.png.jpg).
    Because the array contains a reference to all objects, the objects will all remain
    live.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
- en: Now let’s rerun our experiment using the `-J-verbose:gc` command. [Example 12-16](ch12.html#beginning_of_the_output_produced_by
    "Example 12-16. The beginning of the output produced by running Example 12-15
    with -J-verbose:gc") shows the result.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
- en: Example 12-16. The beginning of the output produced by running [Example 12-15](ch12.html#saving_10_million_ruby_objects_i-id00047
    "Example 12-15. Saving 10 million Ruby objects in an array") with `-J-verbose:gc`
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Notice at ![](httpatomoreillycomsourcenostarchimages1853845.png.jpg) that the
    output `[Full GC...]` first appears after 13 young collections. (The output continues
    past what is shown in [Example 12-16](ch12.html#beginning_of_the_output_produced_by
    "Example 12-16. The beginning of the output produced by running Example 12-15
    with -J-verbose:gc").) This tells us that many Ruby objects were promoted, filling
    up the mature generation and forcing a mature collection to run.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
- en: We can draw some other interesting conclusions from this output. First, the
    size of the young collection gradually grew from the first GC run at ![](httpatomoreillycomsourcenostarchimages1853843.png.jpg)
    to the mature collection at ![](httpatomoreillycomsourcenostarchimages1853845.png.jpg).
    This tells us that the JVM was automatically increasing the total heap size as
    more objects were created. Notice that the total heap size value in parentheses
    started at around 83MB and grew to over 200MB, as shown in bold. Also, each young
    collection was still relatively fast at under 0.1 seconds, though much slower
    than the ones we saw in [Example 12-14](ch12.html#output_produced_by_running_listing_1
    "Example 12-14. The output produced by running Example 12-13 with -J-verbose:gc"),
    which took less than 1 millisecond. Remember that the semi-space algorithm copies
    only live objects. This time all of our Ruby objects remained alive, and the JVM
    had to copy them repeatedly. Finally, notice that the mature, or full, collection
    at ![](httpatomoreillycomsourcenostarchimages1853845.png.jpg) took about 0.53
    seconds, which was much longer than any of the young collections.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
- en: Further Reading
  id: totrans-295
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There’s a vast amount of information available on the topic of garbage collection.
    To learn more about John McCarthy’s original free list implementation, see his
    article on Lisp: “Recursive Functions of Symbolic Expressions and Their Computation
    by Machine, Part 1” (*Communications of the ACM*, 1960).'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
- en: 'For a taste of modern GC research, you can read about the Immix algorithm used
    by Rubinius in Stephen M. Blackburn and Kathryn S. McKinley’s “A Mark-Region Garbage
    Collector with Space Efficiency, Fast Collection, and Mutator Performance” (*ACM
    SIGPLAN Notices*, 2008). The following article from Oracle both explains the JVM’s
    overall GC algorithm and serves as a good reference for the many command-line
    options you can use to customize and tune the JVM’s garbage collector’s behavior:
    “Java SE 6 HotSpot Virtual Machine Garbage Collection Tuning” (*[http://www.oracle.com/technetwork/java/javase/gc-tuning-6-140523.html](http://www.oracle.com/technetwork/java/javase/gc-tuning-6-140523.html)*).'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, two definitive sources on GC algorithms in general and how they have
    changed over the years are Jones and Lins’s *Garbage Collection: Algorithms for
    Automatic Dynamic Memory Management* (Wiley, 1996) and Jones, Hosking, and Moss’s,
    *The Garbage Collection Handbook: The Art of Automatic Memory Management* (CRC
    Press, 2012).'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-299
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This chapter has covered one of the most important but least understood areas
    of Ruby internals: garbage collection. We learned that garbage collectors allocate
    memory for new objects and clean up unused garbage objects. We examined the basic
    algorithms used by MRI, Rubinius, and JRuby for garbage collection and discovered
    that MRI allocates and reclaims memory using a free list, while Rubinius and the
    JVM use the semi-space algorithm. We also saw how Rubinius and JRuby employ concurrent
    and generational GC techniques, which MRI starts to use in Ruby 2.1.'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
- en: But we’ve only scratched the surface of garbage collection. Since its invention
    in 1960, many complex GC algorithms have been developed; indeed, garbage collection
    is still an active area of computer science research. The GC implementations in
    MRI, Rubinius, and JRuby are likely to continue to evolve and improve over time.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
