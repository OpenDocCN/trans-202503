- en: '8'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '8'
- en: HEAPS AND SEGMENT TREES
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 堆和线段树
- en: '![Image](../images/common1.jpg)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/common1.jpg)'
- en: Data structures organize our data to make it possible to accelerate certain
    operations. For example, in [Chapter 1](ch01.xhtml), we learned about hash tables,
    which speed up the search for a specified element in a collection.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 数据结构通过组织我们的数据，使得某些操作得以加速。例如，在[第1章](ch01.xhtml)中，我们学习了哈希表，它能加速在集合中查找指定元素的过程。
- en: 'In this chapter, we’ll learn two new data structures: heaps and segment trees.
    A heap is what you want whenever you need the maximum (or minimum) element; a
    segment tree is what you want when you need to perform queries on pieces of an
    array. In our first problem, we’ll see how heaps turn slow maximum computations
    into fast heap operations; in our second and third problems, we’ll see how segment
    trees do similarly for more general array queries.'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将学习两种新的数据结构：堆和线段树。堆是你需要的结构，当你需要找到最大（或最小）元素时；线段树则是你需要的结构，当你需要对数组的片段进行查询时。在我们的第一个问题中，我们将看到堆如何将慢速的最大值计算转化为快速的堆操作；在我们的第二个和第三个问题中，我们将看到线段树如何以类似的方式进行更一般的数组查询。
- en: 'Problem 1: Supermarket Promotion'
  id: totrans-5
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 问题1：超市促销
- en: This is SPOJ problem `PRO`.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 这是SPOJ问题`PRO`。
- en: '*The Problem*'
  id: totrans-7
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*问题*'
- en: In a supermarket, each shopper picks up the items that they want to buy, then
    goes through the checkout to pay for their items. Once a shopper pays, the shopper
    is given a receipt that has the total cost of what they purchased. For example,
    if someone picks up some items and the total is $18, then the cost written on
    their receipt is $18\. We don’t care about the cost of individual items.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在超市中，每位顾客挑选他们想购买的商品，然后通过收银台结账。一旦顾客支付完成，顾客会收到一张收据，上面标明了他们购买商品的总费用。例如，如果某人挑选了一些商品，总费用为18美元，那么他们收据上会写明18美元。我们不关心单个商品的费用。
- en: 'The supermarket is having a promotion that will last *n* days. During the promotion,
    each receipt is placed in a ballot box. At the end of each day, two receipts are
    removed from the ballot box: one of maximum cost *x* and one of minimum cost *y*.
    The shopper who produced the maximum-cost receipt gets a prize worth *x* – *y*
    dollars. (Don’t worry about how the supermarket identifies that shopper based
    on their receipt.) The *x* and *y* receipts are then gone, never to reappear,
    but all other receipts from that day stay in the ballot box (and may be removed
    on some future day).'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 超市正在进行一项持续*n*天的促销活动。在促销期间，每张收据都会放入一个抽奖箱中。在每一天结束时，两个收据将被从抽奖箱中取出：一个最大费用的收据*x*，和一个最小费用的收据*y*。产生最大费用收据的顾客将获得价值*x*
    - *y*美元的奖品。（不必担心超市如何通过收据识别顾客。）这两张收据被移除后将不再出现，但当天的其他收据将继续保留在抽奖箱中（并可能在未来的某天被移除）。
- en: It’s guaranteed that there will be at least two receipts in the ballot box at
    the end of each day.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 保证每天结束时，抽奖箱中至少会有两张收据。
- en: Our task is to compute the total prize money that will be given out by the supermarket
    as part of the promotion.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的任务是计算超市在促销活动中发放的总奖金额。
- en: Input
  id: totrans-12
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 输入
- en: 'The input contains one test case, consisting of the following lines:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 输入包含一个测试用例，由以下几行组成：
- en: A line containing *n*, the duration in days of the promotion. *n* is between
    1 and 5,000.
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一行包含*n*，表示促销活动的持续天数。*n*的范围是1到5000之间。
- en: '*n* lines, one for each day of the promotion. Each such line begins with integer
    *k*, indicating that there are *k* receipts on this day. The line then contains
    *k* integers, representing the cost of each receipt for this day. *k* is between
    0 and 100,000; each receipt cost is a positive number that’s at most 1,000,000.'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*n*行，每行表示促销活动中的一天。每行以整数*k*开始，表示当天有*k*张收据。该行接着包含*k*个整数，表示当天每张收据的费用。*k*的范围是0到100,000；每张收据的费用是一个正数，且不超过1,000,000。'
- en: The total number of receipts produced throughout the entire promotion is at
    most 1,000,000.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 整个促销活动期间产生的收据总数最多为1,000,000张。
- en: Output
  id: totrans-17
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 输出
- en: Output the total prize money given out by the supermarket.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 输出超市发放的总奖金额。
- en: The time limit for solving the test case is 0.6 seconds.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 解决此测试用例的时间限制为0.6秒。
- en: '*Solution 1: Maximum and Minimum in an Array*'
  id: totrans-20
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*解决方案1：数组中的最大值和最小值*'
- en: For many of the problems in this book, it’s a challenge to devise a correct
    algorithm, let alone an efficient one. At least for the current problem, correctness
    doesn’t seem so hard. Determining the prize on each day simply involves searching
    the ballot box for the maximum cost and then searching again for the minimum cost.
    Maybe that will be efficient enough, too?
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 对于本书中的许多问题，设计一个正确的算法已经是一个挑战，更不用说高效的算法了。至少对于当前的问题，正确性似乎并不那么难。确定每天的奖金只需要在选票箱中搜索最大费用，然后再搜索一次最小费用。也许这已经足够高效了？
- en: 'Let’s look at a test case:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一个测试案例：
- en: '[PRE0]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Remember that the first number on each line of receipts tells us the number
    of receipts and is not itself a receipt cost. After the first day and before removing
    any receipts, we have these 16 receipt costs:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，每行收据的第一个数字告诉我们收据的数量，而不是收据费用。在第一天之后，并在移除任何收据之前，我们有这 16 个收据费用：
- en: '[PRE1]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The maximum receipt is 91 and the minimum is 2\. Those two receipts are removed,
    and they contribute 91 – 2 = 89 in prize money. Here’s what’s left after removing
    91 and 2:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 最大收据费用是 91，最小的是 2。那两张收据被移除，它们贡献了 91 – 2 = 89 的奖金。移除 91 和 2 后剩下的收据如下：
- en: '[PRE2]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Now we move on to the second day. We add the 57 to get:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们进入第二天。我们加上 57 得到：
- en: '[PRE3]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The maximum now is 85 and the minimum is 5, so that’s 85 – 5 = 80 added to the
    prize money. The total prize money for this promotion is therefore 89 + 80 = 169.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 现在最大值是 85，最小值是 5，所以奖金是 85 – 5 = 80。这个促销活动的总奖金因此是 89 + 80 = 169。
- en: One implementation idea involves storing the receipts in an array. To remove
    a receipt, we could literally remove it, as we just did. That would involve shifting
    later receipts to the left, to fill the vacated array entry. But it’s simpler
    to keep the receipts where they are and associate a `used` flag with each receipt.
    If `used` is `0`, then the receipt hasn’t been used yet; if it’s `1`, then it
    has been used and is logically removed (so we had better ignore it from here on
    out).
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 一种实现思路是将收据存储在一个数组中。要移除一个收据，我们可以像刚才那样直接移除它。这将涉及将后续的收据向左移动，以填补空缺的数组项。但更简单的做法是保持收据在原位置，并为每个收据关联一个
    `used` 标志。如果 `used` 为 `0`，则表示该收据尚未使用；如果 `used` 为 `1`，则表示它已被使用并且在逻辑上已被移除（因此我们从此以后应该忽略它）。
- en: 'Here are a couple of constants and the `receipt` struct:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些常量和 `receipt` 结构：
- en: '[PRE4]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: We’re going to need helper functions to identify and remove the maximum receipt
    cost and minimum receipt cost, so let’s knock those out now. [Listing 8-1](ch08.xhtml#ch08ex01)
    gives the code.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要一些辅助函数来识别并移除最大和最小的收据费用，所以我们现在就来实现这些函数。[清单 8-1](ch08.xhtml#ch08ex01)提供了代码。
- en: '[PRE5]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '*Listing 8-1: Finding and removing maximum and minimum costs*'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 8-1：查找并移除最大和最小费用*'
- en: The standard term for the operation that removes and returns the maximum value
    is *extract-max*. Likewise, the operation that removes and returns the minimum
    value is called *extract-min*.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 移除并返回最大值的操作通常称为 *extract-max*。同样，移除并返回最小值的操作称为 *extract-min*。
- en: These functions operate very similarly. The `extract_max` function sets `max`
    to `-1` ❶, which is smaller than any receipt cost. When it finds a “real” receipt
    cost, `max` will be set to that cost, and from then on it will track the largest
    cost found so far. Similar reasoning explains why `extract_min` initializes `min`
    with a cost higher than any valid cost ➍. Notice that, in each function, the only
    receipts that are considered are those whose `used` value is `0` ➋ ➎ and that
    each function sets the identified receipt’s `used` value to `1` ➌ ➏.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 这些函数的操作非常相似。`extract_max` 函数将 `max` 设置为 `-1` ❶，这个值小于任何收据费用。当它找到一个“真实的”收据费用时，`max`
    会被设置为该费用，从那时起，它会跟踪到目前为止找到的最大费用。类似的推理可以解释为什么 `extract_min` 用一个比任何有效费用都高的值来初始化 `min`
    ➍。请注意，在每个函数中，只有那些 `used` 值为 `0` ➋ ➎ 的收据会被考虑，并且每个函数都会将识别出的收据的 `used` 值设置为 `1` ➌
    ➏。
- en: 'With those two helper functions in hand, we can write a `main` function to
    read the input and solve the problem. One interesting aspect here is that reading
    input and solving the problem are interleaved: we read a little input (the receipts
    for the first day), calculate the prize for that day, read a little more input
    (the receipts for the second day), calculate the prize for that day, and so on.
    This is implemented in [Listing 8-2](ch08.xhtml#ch08ex02).'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这两个辅助函数后，我们可以编写一个 `main` 函数来读取输入并解决问题。这里有一个有趣的地方是，读取输入和解决问题是交替进行的：我们读取一些输入（第一天的收据），计算那天的奖金，再读取一些输入（第二天的收据），计算那天的奖金，以此类推。这个过程在
    [清单 8-2](ch08.xhtml#ch08ex02) 中得到了实现。
- en: '[PRE6]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '*Listing 8-2: The main function for reading input and solving the problem*'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 8-2：用于读取输入并解决问题的主函数*'
- en: The only gotcha here is the type of the `total_prizes` variable ❶. An integer
    or long integer may not be enough. A typical long integer can hold values up to
    about 4 billion; the total prize money could be up to 5,000 × 1,000,000, which
    is 5 billion. Long long integers can hold integers that are billions, trillions,
    and way beyond that, so we’re certainly safe using a long long integer here.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 唯一需要注意的地方是`total_prizes`变量的类型 ❶。一个整数或长整数可能不足够。一个典型的长整数可以容纳最大约40亿的值；而总奖金金额可能高达5000
    × 1,000,000，即50亿。长长整数可以容纳几十亿、上万亿，甚至更多的整数，所以在这里使用长长整数是完全安全的。
- en: The outer `for` loop runs once for each day, and the inner `for` loop reads
    each receipt for the day. Once each day’s receipts have been read, we extract
    the maximum receipt, extract the minimum receipt, and update the total prize money.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 外层的`for`循环针对每一天运行一次，内层的`for`循环读取当天的每个收据。一旦当天的收据被读取，我们就提取最大收据、提取最小收据，并更新总奖金金额。
- en: This is a complete solution to the problem. It correctly outputs `169` for our
    sample test case, and you should spend some time convincing yourself that it’s
    correct in general.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 这是问题的完整解决方案。它正确地输出了我们的示例测试用例中的`169`，你应该花点时间确保自己相信它在一般情况下是正确的。
- en: Unfortunately, it’s too slow, and you would get a “Time-Limit Exceeded” error
    from the judge.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，这太慢了，你会收到一个“超时”错误。
- en: We can explore the inefficiency by thinking about a worst-case test case. Let’s
    say that the promotion lasts 5,000 days and that on each of the first 10 days
    we get 100,000 receipts. After the tenth day, we’ll have about a million receipts
    in the array. Finding the maximum and minimum involves a linear scan through the
    array. However, since we remove only two receipts per day, we’ll have close to
    a million receipts in there all the way through the promotion. So, we’re looking
    at 5,000 days, almost all of which require about a million steps to find the maximum
    and another million steps to find the minimum. That’s about 5,000 × 2,000,000,
    or 10 billion, steps! There is no chance of solving this, given the stringent
    time limit. If only we could speed up those maximum and minimum computations.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过思考最坏的测试用例来探索这种低效。假设促销活动持续5000天，并且在前10天中每天都会收到100,000个收据。那么在第10天之后，数组中将有大约一百万个收据。找到最大值和最小值需要在数组中进行线性扫描。然而，由于我们每天只删除两个收据，所以促销活动期间数组中几乎一直会有接近一百万个收据。因此，我们需要考虑5000天，几乎每天都需要大约一百万次的操作来找到最大值，再加上另一百万次操作来找到最小值。那就是大约5000
    × 2,000,000，或者100亿次操作！在严格的时间限制下，这是不可能解决的。如果我们能加快最大值和最小值的计算速度就好了。
- en: 'Let’s quickly disarm sorting as a possible improvement here. If we kept the
    receipts array sorted, then finding and removing the maximum would take constant
    time, as the maximum would be at the rightmost index. Finding the minimum would
    take constant time, too, but it would take linear time to remove the minimum since
    we’d have to shift all other elements to the left. Sorting also ruins the efficiency
    of adding a receipt: when we’re not sorting, we can just plunk it at the end of
    the array, but when sorting we have to find its proper position. No, sorting isn’t
    the answer. The answer is heaps.'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们快速排除排序作为可能的改进方法。如果我们保持收据数组有序，那么查找并移除最大值将是常数时间操作，因为最大值会在最右侧的索引。查找最小值也可以是常数时间操作，但移除最小值将是线性时间操作，因为我们需要将其他所有元素向左移动。排序还会破坏添加收据的效率：当我们不排序时，可以直接将其放在数组的末尾，但如果排序了，我们必须找到合适的位置。排序并不是答案，答案是堆。
- en: '#### *Max-Heaps*'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '#### *最大堆*'
- en: We’ll begin by focusing on how to quickly find and extract the maximum element
    from an array. That’s only solving half the problem—we need to be able to do this
    for the minimum, too—but we’ll get to that.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从快速查找并提取数组中的最大元素开始。这只解决了问题的一半——我们还需要能够做同样的事情来处理最小值——但我们会在后面讲到。
- en: Finding the Maximum
  id: totrans-50
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 查找最大值
- en: 'Take a look at the tree in [Figure 8-1](ch08.xhtml#ch08fig01). It has 13 nodes
    corresponding to the following 13 receipts (the first 13 receipts in our sample
    test case): 6, 63, 16, 82, 25, 2, 43, 5, 17, 10, 56, 85, and 38.'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 看看[图8-1](ch08.xhtml#ch08fig01)中的树。它有13个节点，分别对应以下13个收据（我们的示例测试用例中的前13个收据）：6,
    63, 16, 82, 25, 2, 43, 5, 17, 10, 56, 85 和 38。
- en: '![Image](../images/ch08fig01.jpg)'
  id: totrans-52
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/ch08fig01.jpg)'
- en: '*Figure 8-1: A max-heap*'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '*图8-1：一个最大堆*'
- en: Quick—what’s the maximum receipt cost in that tree?
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 快点——在那棵树中，最大收据的成本是多少？
- en: It’s 85, and it’s right there at the root. If you were promised that the maximum
    element of some tree was at its root, then you could just return the element at
    the root and not search or traverse the tree at all.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 它是 85，且位于根节点。如果有人向你承诺某个树的最大元素位于其根节点，那么你只需返回根节点的元素，而无需搜索或遍历整棵树。
- en: 'Our plan is to maintain the tree such that the maximum receipt cost is always
    at the root. We’ll have to be vigilant, because we’re going to be bombarded by
    two kinds of events that can mess up our tree:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的计划是维护这棵树，使最大账单的费用始终位于根节点。我们必须保持警惕，因为我们将会受到两种事件的干扰，它们可能会破坏我们的树：
- en: '**A new receipt comes in.**   We have to figure out how to reorganize the tree
    to incorporate this receipt. The new receipt could even be higher than everything
    else in the tree, in which case we need to get the receipt to the root.'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '**一个新的账单到来了。** 我们需要弄清楚如何重新组织树以纳入这个账单。这个新账单甚至可能比树中的所有元素都要大，在这种情况下，我们需要将账单移动到根节点。'
- en: '**A receipt gets extracted from the tree.**   We have to figure out how to
    reorganize the tree so that the maximum element remaining in the tree is at the
    root.'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '**从树中提取一个账单。** 我们需要弄清楚如何重新组织树，以确保剩下的最大元素位于根节点。'
- en: Of course, we have to do these inserts and extracts quickly. In particular,
    we need to be quicker than linear time, as a linear-time scan through an array
    is what brought us here in the first place!
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，我们必须快速执行这些插入和提取操作。特别是，我们需要比线性时间还要快，因为线性时间扫描数组正是我们陷入困境的原因！
- en: What Is a Max-Heap?
  id: totrans-60
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 什么是最大堆？
- en: '[Figure 8-1](ch08.xhtml#ch08fig01) is an example of a *max-heap*. The “max”
    there means that this tree enables us to quickly find the maximum element.'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 8-1](ch08.xhtml#ch08fig01)是一个*最大堆*的例子。这里的“最大”意味着这棵树让我们能够快速找到最大元素。'
- en: A max-heap has two important properties. First, it’s a *complete* binary tree.
    This means that each level in the tree is full (that is, it has no missing nodes),
    except possibly the bottom level, whose nodes are filled in from left to right.
    In [Figure 8-1](ch08.xhtml#ch08fig01), notice how each level is completely full.
    Well, the bottom level isn’t completely full, but that’s okay because its nodes
    are filled in from the left. (Don’t confuse complete binary trees here with full
    binary trees from [Chapter 2](ch02.xhtml).)
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 最大堆有两个重要性质。首先，它是一个*完全*二叉树。这意味着树中的每一层都是满的（即没有缺失的节点），除了最底层，其节点是从左到右依次填充的。在[图 8-1](ch08.xhtml#ch08fig01)中，注意到每一层都是完全满的。虽然最底层并未完全满，但这没关系，因为它的节点是从左边开始填充的。（不要将这里的完全二叉树与[第
    2 章](ch02.xhtml)中的满二叉树混淆。）
- en: The fact that a max-heap is a complete binary tree doesn’t directly help us
    find the maximum, insert an element, or extract the maximum, but it does lead
    to a lightning-fast implementation of heaps, as we’ll see.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 最大堆是一个完全二叉树这一事实并不会直接帮助我们找到最大元素、插入元素或提取最大元素，但它确实导致了堆的极速实现，正如我们将看到的那样。
- en: Second, the value of a node is greater than or equal to the values of its child
    nodes. (The values in [Figure 8-1](ch08.xhtml#ch08fig01) are all distinct, so
    a parent’s value is strictly greater than those of its children.) This is called
    the *max-heap-order* property.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 其次，一个节点的值大于或等于其子节点的值。（[图 8-1](ch08.xhtml#ch08fig01)中的值都是不同的，因此父节点的值严格大于其子节点的值。）这就是所谓的*最大堆顺序*性质。
- en: Consider the node in [Figure 8-1](ch08.xhtml#ch08fig01) with a value of 56\.
    As promised, 56 is greater than the values of its child nodes (10 and 25). This
    property is true everywhere in the tree, and it’s why the maximum value must be
    at the root. Every other node has a parent node with greater value!
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑[图 8-1](ch08.xhtml#ch08fig01)中一个值为 56 的节点。正如所承诺的，56 的值大于它的子节点（10 和 25）的值。这一性质在整个树中都成立，这就是为什么最大值必须位于根节点的原因。其他每个节点都有一个值更大的父节点！
- en: Inserting into a Max-Heap
  id: totrans-66
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 向最大堆中插入元素
- en: When a new receipt arrives, we’ll insert it into the max-heap, but we have to
    do it carefully so that the max-heap-order property is maintained.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个新账单到达时，我们将其插入到最大堆中，但必须小心操作，以确保最大堆顺序性质得以保持。
- en: 'Starting with [Figure 8-1](ch08.xhtml#ch08fig01), let’s insert 15\. There’s
    only one place we can put it without breaking the complete-tree property: on the
    bottom level, to the right of the 38 (see [Figure 8-2](ch08.xhtml#ch08fig02)).'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 从[图 8-1](ch08.xhtml#ch08fig01)开始，让我们插入 15。只有一个位置可以放入它，而不破坏完全树的性质：在底层，位于 38 的右侧（见[图
    8-2](ch08.xhtml#ch08fig02)）。
- en: '![Image](../images/ch08fig02.jpg)'
  id: totrans-69
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/ch08fig02.jpg)'
- en: '*Figure 8-2: A max-heap with 15 inserted*'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 8-2：插入 15 的最大堆*'
- en: It’s a complete binary tree, for sure, but does the max-heap-order property
    hold? It does! 15’s parent is 16, and 16 is greater than 15, just as we require.
    There’s no additional work to do.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 它确实是一个完整的二叉树，但最大堆序列属性是否仍然成立？是的！15的父节点是16，并且16大于15，正如我们所要求的那样。没有额外的操作需要进行。
- en: Now consider a tougher one. We’ll insert 32 into [Figure 8-2](ch08.xhtml#ch08fig02),
    resulting in [Figure 8-3](ch08.xhtml#ch08fig03).
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 现在考虑一个更复杂的情况。我们将32插入到[图8-2](ch08.xhtml#ch08fig02)，得到[图8-3](ch08.xhtml#ch08fig03)。
- en: '![Image](../images/ch08fig03.jpg)'
  id: totrans-73
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/ch08fig03.jpg)'
- en: '*Figure 8-3: A max-heap with 32 inserted*'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '*图8-3：插入32后的最大堆*'
- en: There’s some trouble here. Inserting 32 has broken the max-heap-order property,
    because its parent 16 is less than 32\. (Here, and in subsequent figures, the
    thick edge shows a max-heap-order violation.) We can fix this problem by swapping
    the 16 and 32, as in [Figure 8-4](ch08.xhtml#ch08fig04).
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有点麻烦。插入32破坏了最大堆顺序属性，因为它的父节点16小于32。（在这里和后续的图中，粗边表示最大堆顺序违规。）我们可以通过交换16和32来修复这个问题，如[图8-4](ch08.xhtml#ch08fig04)所示。
- en: '![Image](../images/ch08fig04.jpg)'
  id: totrans-76
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/ch08fig04.jpg)'
- en: '*Figure 8-4: A max-heap with the max-heap-order violation repaired*'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '*图8-4：修复了最大堆顺序违规的最大堆*'
- en: 'Ahh, order has been restored: 32 must be greater than both of its children
    at this point. It’s greater than its child 16 because that’s why we performed
    the swap, and it’s greater than its other child 15 because 15 used to be a child
    of 16\. In general, performing such a swap is guaranteed to maintain the max-heap-order
    property between the new node and its children.'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 啊，顺序已经恢复：此时32必须大于它的两个子节点。它大于它的子节点16，因为这就是我们进行交换的原因，它也大于另一个子节点15，因为15曾是16的子节点。通常，执行这样的交换可以保证新节点和其子节点之间的最大堆顺序属性得以维持。
- en: We’re back to a max-heap, and it only took us one swap to do it. It could take
    more swaps, though, which I’ll demonstrate now by inserting 91 into [Figure 8-4](ch08.xhtml#ch08fig04).
    See [Figure 8-5](ch08.xhtml#ch08fig05) for the result.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 我们回到了一个最大堆，并且只用了一个交换就解决了问题。不过，可能需要更多的交换，我现在将通过将91插入到[图8-4](ch08.xhtml#ch08fig04)来演示。请参见[图8-5](ch08.xhtml#ch08fig05)查看结果。
- en: '![Image](../images/ch08fig05.jpg)'
  id: totrans-80
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/ch08fig05.jpg)'
- en: '*Figure 8-5: A max-heap with 91 inserted*'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '*图8-5：插入91后的最大堆*'
- en: We had to start a new level at the bottom of the tree, since the previous bottom
    level is full. We can’t keep the 91 as a child of 5, though, because it violates
    the max-heap-order property. A swap will fix it . . . well, sort of. See [Figure
    8-6](ch08.xhtml#ch08fig06).
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不得不在树的底部开始一个新层级，因为之前的底层已满。然而，我们不能将91作为5的子节点，因为它违反了最大堆序列的属性。交换一下就能修复这个问题……嗯，差不多吧。参见[图8-6](ch08.xhtml#ch08fig06)。
- en: '![Image](../images/ch08fig06.jpg)'
  id: totrans-83
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/ch08fig06.jpg)'
- en: '*Figure 8-6: A max-heap with 91 moved up*'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '*图8-6：91向上移动后的最大堆*'
- en: We’ve fixed the problem between 5 and 91, but now we have a new problem between
    17 and 91\. We can fix this one by another swap; see [Figure 8-7](ch08.xhtml#ch08fig07).
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 我们修复了5和91之间的问题，但现在我们又遇到了17和91之间的新问题。我们可以通过另一次交换来解决这个问题；请参见[图8-7](ch08.xhtml#ch08fig07)。
- en: '![Image](../images/ch08fig07.jpg)'
  id: totrans-86
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/ch08fig07.jpg)'
- en: '*Figure 8-7: A max-heap with 91 moved up again*'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '*图8-7：91再次向上移动的最大堆*'
- en: 'We have yet another max-heap-order violation, this time between 63 and 91\.
    However, notice that the violation is moving up the tree, becoming closer and
    closer to the root. At worst, we’ll end up shuttling 91 up to the root of the
    tree. That’s exactly what will happen here, because 91 is the maximum element.
    It takes two more swaps to finish the job: the first is shown in [Figure 8-8](ch08.xhtml#ch08fig08).'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 我们再次遇到了一个最大堆序列违规，这次是在63和91之间。然而，注意到违规正在向树的上方移动，越来越接近根节点。在最坏的情况下，我们将把91上移到树的根节点。正如这里所发生的那样，因为91是最大元素。还需要两次交换才能完成：第一次交换见[图8-8](ch08.xhtml#ch08fig08)。
- en: '![Image](../images/ch08fig08.jpg)'
  id: totrans-89
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/ch08fig08.jpg)'
- en: '*Figure 8-8: A max-heap with 91 moved up yet again*'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '*图8-8：91再次上移后的最大堆*'
- en: And the second swap is shown in [Figure 8-9](ch08.xhtml#ch08fig09).
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 第二次交换见[图8-9](ch08.xhtml#ch08fig09)。
- en: '![Image](../images/ch08fig09.jpg)'
  id: totrans-92
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/ch08fig09.jpg)'
- en: '*Figure 8-9: A max-heap with the heap-order violation repaired*'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '*图8-9：修复了堆序违规的最大堆*'
- en: We’ve got a max-heap again! We only had to perform four swaps to fix the heap
    of 16 elements, and that was for a value that bubbled up all the way to the root.
    As we’ve seen, inserting other values that don’t make it all the way to the root
    will be even faster than that.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 我们再次得到了一个最大堆！我们只需执行四次交换来修复16个元素的堆，而这只是对于一个冒泡到根节点的值。如我们所见，插入其他没有冒泡到根节点的值会比这更快。
- en: Extracting from a Max-Heap
  id: totrans-95
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 从最大堆中提取
- en: At the end of each day of the promotion, we’ll need to extract the maximum receipt
    from the max-heap. As with insertion, we must be careful to fix the tree so that
    it’s a max-heap again. We’ll see that the process mirrors that of insertion, this
    time with a value bubbling down rather than up.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 每次促销结束时，我们都需要从最大堆中提取最大值。与插入一样，我们必须小心地修复树，以确保它再次成为最大堆。我们将看到，这个过程与插入非常相似，只不过这次是一个值向下冒泡，而不是向上冒泡。
- en: 'Let’s start with [Figure 8-1](ch08.xhtml#ch08fig01) and extract the maximum.
    Here is that figure again:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从[图 8-1](ch08.xhtml#ch08fig01)开始，提取最大值。这里是那张图：
- en: '![Image](../images/page_287_01.jpg)'
  id: totrans-98
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/page_287_01.jpg)'
- en: Extracting the maximum removes 85 as the root of the tree, but we need to put
    something else at the root; otherwise, we would no longer have a tree. The only
    node we can use, without breaking the complete-tree property, is the rightmost
    node on the bottom level. That is, we can swap 85 with 38, arriving at [Figure
    8-10](ch08.xhtml#ch08fig10).
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 提取最大值将85移除作为树的根节点，但我们需要在根节点放置其他节点；否则，我们将不再拥有一棵树。我们可以使用的唯一节点是底层最右侧的节点，也就是说，我们可以将85和38交换，得到[图
    8-10](ch08.xhtml#ch08fig10)。
- en: '![Image](../images/ch08fig10.jpg)'
  id: totrans-100
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/ch08fig10.jpg)'
- en: '*Figure 8-10: A max-heap with 85 extracted*'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 8-10：提取85后的最大堆*'
- en: We just took a small value from the bottom of the tree and blasted it up to
    the top. In general, that’s going to break the max-heap-order property. It certainly
    does so here, because 38 is less than both 63 and 82.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚从树的底部取了一个小值并把它顶到顶部。通常情况下，这样做会破坏最大堆顺序属性。这里确实发生了这种情况，因为38小于63和82。
- en: We’ll again fix the max-heap-order property by using swaps. Unlike insertion,
    extraction presents us with a choice. Should we swap 38 and 63, or should we swap
    38 and 82? Swapping 38 and 63 doesn’t solve the problem at the root, because 82
    would end up as a child of 63\. Swapping 38 and 82 is the right move. In general,
    we want to perform the swap with the larger child, so the max-heap-order property
    is fixed between the larger child and its new children. [Figure 8-11](ch08.xhtml#ch08fig11)
    shows the result of swapping 38 and 82.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将通过交换来再次修复最大堆顺序属性。与插入不同，提取给我们提供了一个选择：我们应该交换38和63，还是交换38和82？交换38和63并不能解决根节点的问题，因为82最终会成为63的子节点。交换38和82才是正确的选择。通常情况下，我们要与较大的子节点进行交换，这样就能修复较大子节点及其新子节点之间的最大堆顺序属性。[图
    8-11](ch08.xhtml#ch08fig11)展示了交换38和82后的结果。
- en: '![Image](../images/ch08fig11.jpg)'
  id: totrans-104
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/ch08fig11.jpg)'
- en: '*Figure 8-11: A max-heap with 38 moved down*'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 8-11：38向下移动后的最大堆*'
- en: We’re not out of the woods yet—there’s still a max-heap-order violation between
    38 and 43\. The good news is that the max-heap-order violation is moving down
    the tree. If we keep pushing the violations down, then in the worst case we’ll
    have a max-heap again when 38 hits the bottom of the tree.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还没有完全解决问题——在38和43之间仍然存在一个最大堆顺序违反。好消息是，最大堆顺序违反正在向树的下方移动。如果我们不断地将违反下移，那么在最坏的情况下，当38到达树的底部时，我们将再次得到一个最大堆。
- en: Let’s swap 38 and 43; see [Figure 8-12](ch08.xhtml#ch08fig12).
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们交换38和43；请参见[图 8-12](ch08.xhtml#ch08fig12)。
- en: '![Image](../images/ch08fig12.jpg)'
  id: totrans-108
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/ch08fig12.jpg)'
- en: '*Figure 8-12: A max-heap with 38 moved farther down*'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 8-12：38向下移动后的最大堆*'
- en: The 38 is now fine right where it is, so we’ve restored the max-heap-order property.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 现在38已经放置在合适的位置，我们恢复了最大堆顺序属性。
- en: Height of a Max-Heap
  id: totrans-111
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 最大堆的高度
- en: 'Both insertion and extraction perform at most one swap per level: insertion
    swaps up the tree and extraction swaps down the tree. Are insertion and extraction
    fast? That depends on the height of the max-heap: if the height is small, then
    these operations are fast. Thus we need to understand the relationship between
    the number of elements in a max-heap and the height of the max-heap.'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 插入和提取每层最多执行一次交换：插入将节点向上交换，提取将节点向下交换。插入和提取快吗？这取决于最大堆的高度：如果高度很小，那么这些操作会很快。因此，我们需要理解最大堆中元素数量与最大堆高度之间的关系。
- en: Take a look at [Figure 8-13](ch08.xhtml#ch08fig13), where I’ve drawn the complete
    binary tree of 16 nodes.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 看一下[图 8-13](ch08.xhtml#ch08fig13)，我绘制了一个包含16个节点的完整二叉树。
- en: '![Image](../images/ch08fig13.jpg)'
  id: totrans-114
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/ch08fig13.jpg)'
- en: '*Figure 8-13: A complete binary tree of 16 nodes (numbered from top to bottom
    and left to right)*'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 8-13：一个包含16个节点的完整二叉树（节点编号从上到下，从左到右）*'
- en: 'I’ve numbered the nodes from top to bottom, left to right. That’s why the root
    is 1; its two children are 2 and 3; their children are 4, 5, 6, and 7; and so
    on. We can observe that each new level starts with a number that is a power of
    2: the root is 1, the level below that starts at 2, the level below that starts
    at 4, then 8, then 16\. That is, we need to double the number of nodes to produce
    just one more level in the tree. This is like binary search, where doubling the
    number of elements leads to just one more iteration of the loop. As with binary
    search, then, the height of a complete binary tree, and therefore the height of
    a max-heap, is *O*(log *n*), where *n* is the number of elements in the tree.'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 我已经将节点从上到下、从左到右进行了编号。这就是为什么根节点是1；它的两个子节点是2和3；它们的子节点是4、5、6和7，以此类推。我们可以观察到，每一层的新节点编号都是2的幂：根节点是1，下面一层从2开始，再下面一层从4开始，然后是8，接着是16。也就是说，我们需要将节点数量加倍才能再增加一层。这就像二分查找一样，将元素数量加倍只会导致循环再多进行一次。因此，像二分查找一样，完整二叉树的高度，进而最大堆的高度是*O*(log
    *n*)，其中*n*是树中的元素数量。
- en: We are victorious! Inserting into a max-heap is *O*(log *n*). Extracting from
    a max-heap is *O*(log *n*). We no longer have to be slowed down by *O*(*n*) linear-time
    work.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 我们成功了！插入到最大堆的时间复杂度是*O*(log *n*)。从最大堆中提取的时间复杂度也是*O*(log *n*)。我们再也不需要被*O*(*n*)线性时间的操作拖慢速度了。
- en: Max-Heaps as Arrays
  id: totrans-118
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 最大堆作为数组
- en: A max-heap is just a binary tree, and we know how to implement binary trees.
    While it is possible to implement a max-heap as such, it’s quite challenging to
    do so.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 最大堆其实就是一个二叉树，而我们知道如何实现二叉树。虽然可以这样实现最大堆，但其实相当有挑战性。
- en: 'Think back to when we solved Halloween Haul in [Chapter 2](ch02.xhtml). We
    used a `node` struct with pointers to the left and right children. That would
    be enough for us to be able to bubble a value down a max-heap. However, it would
    not be enough for us to be able to bubble a value up a max-heap, because doing
    so requires access to parent nodes. So we might add a parent pointer:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 回想一下我们在[第2章](ch02.xhtml)中解决的Halloween Haul问题。我们使用了一个带有指向左子节点和右子节点的指针的`node`结构体。这样足以让我们将一个值向下冒泡到最大堆中。然而，这对于将一个值向上冒泡到最大堆中就不够了，因为这样做需要访问父节点。因此，我们可能会添加一个父指针：
- en: '[PRE7]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Even if we added the `parent` like that, we still have direct access only to
    the root of our tree. When inserting a value, how are we supposed to quickly find
    where to insert it? When extracting, how are we supposed to quickly find the rightmost
    node on the bottom level? There is a better way.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 即使我们像那样添加了`parent`，我们仍然只能直接访问树的根节点。在插入一个值时，我们应该如何快速找到插入的位置？在提取时，我们又该如何快速找到最底层的最右节点？其实，有更好的方法。
- en: Let’s again use [Figure 8-13](ch08.xhtml#ch08fig13), where I’ve numbered the
    nodes from top to bottom and left to right. The parent of node number 16 is 8\.
    The parent of node number 12 is 6\. The parent of node number 7 is 3\. What is
    the relationship between the number of a node and the number of its parent?
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们再次使用[图 8-13](ch08.xhtml#ch08fig13)，我已将节点从上到下、从左到右进行了编号。节点16的父节点是8。节点12的父节点是6。节点7的父节点是3。那么，节点编号和父节点编号之间有什么关系呢？
- en: 'The answer is: divide by 2! 16/2 = 8\. 12/2 = 6\. 7/2 = 3\. Well, that last
    one is really 3.5, so just drop the fractional part.'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 答案是：除以2！16/2 = 8。12/2 = 6。7/2 = 3。嗯，最后那个其实是3.5，所以只需要去掉小数部分。
- en: 'We integer-divide by 2 to move up the tree. Let’s see what happens if we reverse
    that process and multiply by two instead. 8 × 2 = 16, so multiplying by 2 takes
    us from 8 to its left child. However, most nodes have two children, and we may
    also want to move from a node to its right child. We can do that, too: we just
    add 1 to the number of the left child. For example, we can move from 6 to its
    left child by 6 × 2 = 12 and move from 6 to its right child by 6 × 2 + 1 = 13\.
    (The relationship between 13/2 and 6 is an example of why it’s safe to drop the
    0.5 to move from a child to its parent.)'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过整数除以 2 来向上移动树形结构。让我们看看如果我们反过来做，改为乘以 2 会发生什么。8 × 2 = 16，因此乘以 2 会将我们从 8 移动到它的左子节点。然而，大多数节点有两个子节点，我们也可能想从一个节点移动到它的右子节点。我们也可以做到这一点：只需在左子节点的编号上加
    1。例如，我们可以通过 6 × 2 = 12 从 6 移动到它的左子节点，也可以通过 6 × 2 + 1 = 13 从 6 移动到它的右子节点。（13/2
    和 6 之间的关系是为什么从子节点到父节点时可以安全地舍弃 0.5 的一个例子。）
- en: These relationships between nodes hold only because max-heaps are complete binary
    trees. In general, binary trees can have more chaotic structure, having a long
    chain of nodes here and a short chain there. We can’t breeze around such a tree
    by multiplying and dividing by 2 unless we inserted placeholder nodes to maintain
    the illusion that the tree is complete. That would waste a huge amount of memory
    if the tree were very unbalanced.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 这些节点之间的关系仅在最大堆是完全二叉树的情况下才成立。一般来说，二叉树的结构可能更为混乱，可能在某些地方有长链节点，而在其他地方有短链节点。除非我们插入占位符节点来维持树的“完全性”，否则我们不能仅通过乘以和除以
    2 来轻松遍历这样的树。如果树非常不平衡，这将浪费大量内存。
- en: 'If we store a max-heap in an array—first the root, then its children, then
    their children, and so on—then the index of a node in the array corresponds to
    its node number. We’ll have to start indexing at 1, not 0, to match the numbering
    in [Figure 8-13](ch08.xhtml#ch08fig13). (It’s possible to start at index 0, but
    that would result in slightly messier relationships between nodes: the parent
    of the node at index *i* would be at (*i* – 1)/2, and the children would be at
    indices 2*i* + 1 and 2*i* + 2.)'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们将最大堆存储在数组中——首先是根节点，然后是它的子节点，再是它们的子节点，依此类推——那么数组中节点的索引对应于它的节点编号。为了与[图 8-13](ch08.xhtml#ch08fig13)中的编号匹配，我们必须从
    1 开始索引，而不是 0。（虽然可以从索引 0 开始，但那样会导致节点之间的关系稍显复杂：索引 *i* 处节点的父节点位于 (*i* – 1)/2 处，子节点则位于索引
    2*i* + 1 和 2*i* + 2 处。）
- en: 'Here again is [Figure 8-1](ch08.xhtml#ch08fig01), the heap of 13 receipt costs:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 这里再次是[图 8-1](ch08.xhtml#ch08fig01)，13 个收据费用的堆：
- en: '![Image](../images/page_291_01.jpg)'
  id: totrans-129
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/page_291_01.jpg)'
- en: 'Here is the corresponding array:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 这是相应的数组：
- en: '![Image](../images/pg291-01.jpg)'
  id: totrans-131
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/pg291-01.jpg)'
- en: 'Index 6 in the array has a value of 43\. What is 43’s left child? To answer
    that, just look up index 6 × 2 = 12 in the array: it’s 2\. What is 43’s right
    child? Look up index 6 × 2 + 1 = 13: it’s 38\. What is 43’s parent? Check index
    6/2 = 3: it’s 82\. No matter which node we’re currently focused on in the tree,
    we can use the array to move to a child or the parent with just a tiny bit of
    math.'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 数组中的索引 6 对应的值是 43。43 的左子节点是多少？为了回答这个问题，只需查找索引 6 × 2 = 12 的数组值：是 2。43 的右子节点是多少？查找索引
    6 × 2 + 1 = 13：是 38。43 的父节点是多少？查找索引 6/2 = 3：是 82。不管我们当前关注的是树中的哪个节点，我们都可以通过数组和一点数学运算来轻松找到其子节点或父节点。
- en: Implementing a Max-Heap
  id: totrans-133
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 实现最大堆
- en: Each element of our heaps will hold both a receipt index and a receipt cost.
    These are the two pieces of information that we’ll want to know about a receipt
    when we extract it.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 我们堆中的每个元素将同时包含一个收据索引和一个收据费用。这是我们在提取收据时需要了解的两条信息。
- en: 'Here’s the struct:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 这是结构体：
- en: '[PRE8]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Now we’re ready to implement a max-heap. The two key operations are inserting
    into the heap and extracting the maximum from the heap. Let’s start with inserting
    into the heap; see [Listing 8-3](ch08.xhtml#ch08ex03).
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们准备实现一个最大堆。两个关键操作是插入堆和从堆中提取最大值。让我们从插入堆开始；请参见[清单 8-3](ch08.xhtml#ch08ex03)。
- en: '[PRE9]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '*Listing 8-3: Inserting into max-heap*'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 8-3：插入最大堆*'
- en: 'The `max_heap_insert` function takes four parameters. The first two are for
    the heap: `heap` is the array that holds the max-heap, and `num_heap` is a pointer
    to the number of elements in the heap. The reason why `num_heap` is a pointer
    is because we’ll need to increase the number of elements in the heap by one and
    make the caller aware of that increase. The latter two parameters are for the
    new receipt: `receipt_index` is the index of the receipt that we’re inserting,
    and `cost` is its associated cost.'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '`max_heap_insert`函数接受四个参数。前两个是堆的相关信息：`heap`是存储最大堆的数组，`num_heap`是指向堆中元素数量的指针。之所以使用指针，是因为我们需要将堆中的元素数量增加1，并让调用者知晓这一变化。后两个参数是针对新接收的元素：`receipt_index`是我们要插入的接收元素的索引，`cost`是它的关联成本。'
- en: We begin by increasing the number of elements in the heap by one ❶ and then
    storing the new receipt in the new heap slot ➋. Variable `i` tracks the index
    in the heap of the newly inserted element ➌.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先通过增加堆中的元素数量来进行初始化 ❶，然后将新的接收元素存储在新的堆槽中 ➋。变量`i`跟踪新插入元素在堆中的索引 ➌。
- en: We have no guarantee that we still have a max-heap. What we just inserted may
    be larger than its parent, so we need to perform the required swaps. That’s the
    point of the `while` loop ➍.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 我们无法保证仍然拥有一个最大堆。我们刚刚插入的元素可能比它的父节点更大，因此我们需要执行必要的交换操作。这就是`while`循环的作用 ➍。
- en: There are two conditions required for the `while` loop to continue. First, we
    need `i > 1`, because otherwise `i` is 1 and has no parent. (Remember that the
    heap starts at index 1, not 0.) Second, we need the node’s receipt cost to be
    greater than that of its parent. The body of the `while` loop performs the swap,
    then it moves us from the current node to its parent ➎. Ahh, again, we have that
    divide-by-2 scheme to move up the tree. Such spare, pleasing, and correct code
    is the best kind.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '`while`循环继续的条件有两个。首先，我们需要`i > 1`，因为如果`i`等于1，就没有父节点。（记住，堆的索引从1开始，而不是从0开始。）第二，我们需要该节点的接收成本大于其父节点的接收成本。`while`循环的主体执行交换操作，然后将我们从当前节点移动到其父节点
    ➎。啊，没错，我们又用了通过除以2的方式来向上移动树结构。这种简洁、优雅且正确的代码是最好的类型。'
- en: Now let’s turn to extracting from the max-heap. [Listing 8-4](ch08.xhtml#ch08ex04)
    provides the code.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们来看看从最大堆中提取的过程。[示例 8-4](ch08.xhtml#ch08ex04)提供了相关代码。
- en: '[PRE10]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '*Listing 8-4: Extracting the maximum from max-heap*'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '*示例 8-4：从最大堆中提取最大值*'
- en: We begin by saving the receipt that we’re about to extract, which is at the
    root of the heap ❶. We then replace the root with the bottom-most, right-most
    node ➋ and decrease the number of elements in the heap by one ➌. That new root
    element might not meet the max-heap-order property, so we use variable `i` to
    track its position in the heap ➍. Then, just as in [Listing 8-3](ch08.xhtml#ch08ex03),
    we have a `while` loop that will perform the necessary swaps. This time, the `while`
    loop condition ➎ says that the left child of Node `i` is in the heap; if it’s
    not, then Node `i` has no children and a max-heap-order violation cannot exist.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从堆的根节点开始，保存即将提取的接收元素 ❶。然后，我们用最底层、最右侧的节点替换根节点 ➋，并将堆中的元素数量减少1 ➌。新的根元素可能不满足最大堆顺序，因此我们使用变量`i`来跟踪它在堆中的位置
    ➍。接下来，就像在[示例 8-3](ch08.xhtml#ch08ex03)中一样，我们使用`while`循环来执行必要的交换操作。这次，`while`循环的条件
    ➎表示节点`i`的左子节点在堆中；如果没有左子节点，那么节点`i`就没有子节点，也就不会发生堆顺序违规。
- en: Inside the loop, `child` is set to the left child ➏. Then, if the right child
    exists, we check whether its cost is higher than that of the left child. If it
    is, then we set `child` to be that right child ❼. Now `child` is the biggest child,
    so we check whether it is involved in a max-heap-order violation ❽. If it is,
    then we perform the swap. Finally, we move down the tree ❾ so that we’re ready
    to check for another max-heap-order violation.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 在循环内部，`child`被设置为左子节点 ➏。然后，如果右子节点存在，我们会检查它的成本是否比左子节点更高。如果是，我们将`child`设置为右子节点
    ❼。此时，`child`是最大的子节点，我们检查它是否涉及堆排序违规 ❽。如果是，我们就执行交换操作。最后，我们向下移动树结构 ❾，准备检查是否有其他堆排序违规。
- en: 'Notice what happens if the node and its largest child are already correctly
    ordered: we `break` out of the loop, since there can’t be any more violations
    in the tree.'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，如果节点和它的最大子节点已经正确排序，会发生什么：我们会`break`跳出循环，因为树中不会再有堆排序违规。
- en: The last thing the function does is return the maximum-cost receipt. We’ll be
    able to use that to help determine the prize for the day and to make sure that
    we never consider this receipt again. First, however, let’s learn about min-heaps,
    so we can extract minimums in addition to maximums.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 函数的最后一步是返回最大费用的收据。我们可以使用它来帮助确定当天的奖品，并确保我们再也不会考虑这张收据。不过，首先，让我们了解最小堆，这样我们就可以同时提取最小值和最大值。
- en: '*Min-Heaps*'
  id: totrans-151
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*最小堆*'
- en: A *min-heap* allows us to quickly insert a new receipt and extract the minimum-cost
    receipt.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 一个*最小堆*允许我们快速插入新的收据并提取最小费用的收据。
- en: '##### Definition and Operations'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '##### 定义与操作'
- en: Guess what? You know almost everything you need to know about min-heaps, because
    they are almost identical to max-heaps.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 猜猜看？你几乎已经掌握了关于最小堆的一切，因为它们与最大堆几乎完全相同。
- en: A min-heap is a complete binary tree. It will have height *O*(log *n*), where
    *n* is the number of elements in the heap. We’ll be able to store it in an array
    just as we did a max-heap. To find the parent of a node, divide by 2; to find
    the left child, multiply by 2; to find the right child, multiply by 2 and add
    1\. There is nothing new here.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 最小堆是一个完全二叉树。它的高度为*O*(log *n*)，其中*n*是堆中元素的数量。我们可以像存储最大堆一样，将其存储在数组中。要查找节点的父节点，将其下标除以2；要查找左子节点，将其下标乘以2；要查找右子节点，将其下标乘以2并加1。这里没有新东西。
- en: 'The only new thing is the *min-heap-order* property: the value of a node is
    less than or equal to the values of its child nodes. This results in the smallest
    value, not the largest value, at the root. That’s exactly where we want it to
    make minimum-extractions fast.'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 唯一的新概念是*最小堆顺序*属性：一个节点的值小于或等于其子节点的值。这导致根节点处的值是最小值，而不是最大值。正是这个特性使得我们能够快速执行最小值提取操作。
- en: 'Let’s again consider the following 13 receipt costs: 6, 63, 16, 82, 25, 2,
    43, 5, 17, 10, 56, 85, and 38\. [Figure 8-14](ch08.xhtml#ch08fig014) shows a min-heap
    for these costs.'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们再次考虑以下13个收据费用：6, 63, 16, 82, 25, 2, 43, 5, 17, 10, 56, 85和38。 [图 8-14](ch08.xhtml#ch08fig014)展示了这些费用的最小堆。
- en: '![Image](../images/ch08fig14.jpg)'
  id: totrans-158
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/ch08fig14.jpg)'
- en: '*Figure 8-14: A min-heap*'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 8-14：一个最小堆*'
- en: Inserting into a min-heap and extracting the minimum from a min-heap are analogous
    to the corresponding max-heap operations.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 向最小堆插入数据和从最小堆中提取最小值的操作类似于相应的最大堆操作。
- en: To insert, add the new node to the right of all nodes on the bottom level, or
    start a new level if the bottom level is full. Then swap the node up until it
    becomes the root or is greater than or equal to its parent.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 插入时，将新节点添加到底层所有节点的右侧，或者如果底层已满，则开始一个新的一层。然后将该节点向上交换，直到它成为根节点或大于等于其父节点。
- en: To extract the minimum, replace the root by the bottom-most, rightmost value,
    and then swap it down the tree until it becomes a leaf or is less than or equal
    to its children.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 为了提取最小值，将根节点替换为最底层最右边的值，然后将该值向下交换，直到它成为叶节点或小于等于其子节点的值。
- en: Implementing a Min-Heap
  id: totrans-163
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 实现最小堆
- en: Implementing a min-heap is a copy-and-paste job using our max-heap code. Just
    change the function names and change the comparisons from `>` to `<`. That’s it.
    See [Listing 8-5](ch08.xhtml#ch08ex05) for the insertion code.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 实现最小堆就是用最大堆的代码进行复制和粘贴。只需要更改函数名，并将比较符号从`>`改为`<`。就这么简单。请参见[清单 8-5](ch08.xhtml#ch08ex05)了解插入代码。
- en: '[PRE11]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '*Listing 8-5: Inserting into min-heap*'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 8-5：向最小堆插入数据*'
- en: '[Listing 8-6](ch08.xhtml#ch08ex06) gives the minimum-extraction code.'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: '[清单 8-6](ch08.xhtml#ch08ex06)给出了最小值提取的代码。'
- en: '[PRE12]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '*Listing 8-6: Extracting a minimum from min-heap*'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 8-6：从最小堆中提取最小值*'
- en: There is big-time code duplication here! In practice, what you’d do is write
    more general `heap_insert` and `heap_extract` functions that take a comparison
    function as a parameter (much like `qsort` does). It’s simpler, though, to understand
    the code without that, so let’s keep it as is.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有大量的代码重复！实际上，你可以编写更通用的`heap_insert`和`heap_extract`函数，并将比较函数作为参数传递（就像`qsort`一样）。不过，为了简化理解，我们暂时不考虑这个，保持代码原样。
- en: '*Solution 2: Heaps*'
  id: totrans-171
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*解决方案 2：堆*'
- en: Now that we’ve got max-heaps and min-heaps, we’re ready for round 2 with this
    problem.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了最大堆和最小堆，准备好迎接这个问题的第二轮挑战。
- en: All we need is a `main` function that reads the input and uses heaps to quickly
    insert and extract receipts. See [Listing 8-7](ch08.xhtml#ch08ex07) for the code.
    As you read through it, you’ll come across two `while` loops. What on earth are
    those doing?
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只需要一个`main`函数，它读取输入并利用堆快速插入和提取收据。参见[清单 8-7](ch08.xhtml#ch08ex07)了解代码。当你阅读时，会遇到两个`while`循环。究竟它们在做什么呢？
- en: '[PRE13]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '*Listing 8-7: The main function for solving the problem using heaps*'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 8-7：使用堆解决问题的主函数*'
- en: We have a `used` array ❶ that will store for each receipt a `1` if it has been
    used and a `0` if not. The max-heap ➋ and min-heap are one element larger than
    the `used` array; this accounts for us not using index 0 in the heaps.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有一个`used`数组 ❶，它将为每个收据存储一个`1`，如果它已经被使用过，存储`0`，如果未使用。最大堆 ➋和最小堆比`used`数组多一个元素；这就是我们在堆中不使用索引0的原因。
- en: For a given day, we insert the index of each receipt into both the max-heap
    ➌ and min-heap ➍. We then extract a receipt from the max-heap ➎ and extract a
    receipt from the min-heap ➏. This is where those two `while` loops come in, looping
    until we get a receipt that hasn’t yet been used. Let me explain what’s going
    on.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 对于给定的一天，我们将每个收据的索引插入到最大堆 ➌ 和最小堆 ➍ 中。然后，我们从最大堆 ➎ 中提取一个收据，并从最小堆 ➏ 中提取一个收据。这就是那两个`while`循环发挥作用的地方，循环直到我们得到一个尚未使用的收据。让我解释一下发生了什么。
- en: When we extract a receipt from the max-heap, it would be nice to also extract
    it from the min-heap so that the two heaps always contain exactly the same receipts.
    Notice, though, that we don’t actually extract that same receipt from the min-heap.
    Why? Because we have no idea where that receipt *is* in the min-heap! At some
    later time, that receipt might be extracted from the min-heap—but it has already
    been used, so we want to throw it away and not process it again.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们从最大堆中提取一个收据时，最好也能从最小堆中提取它，这样两个堆总是包含完全相同的收据。注意，实际上我们并没有从最小堆中提取那个相同的收据。为什么？因为我们根本不知道这个收据在最小堆中的位置！稍后的某个时刻，这个收据可能会从最小堆中提取出来——但是它已经被使用过了，所以我们想丢弃它，而不是再次处理它。
- en: The opposite can happen, too, because we extract a receipt from the min-heap
    and leave it in the max-heap. At some later time, that used receipt might come
    out of the max-heap. We need to ignore it and extract from the max-heap again.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 相反的情况也可能发生，因为我们从最小堆中提取一个收据并将其留在最大堆中。稍后，这个已使用的收据可能会从最大堆中提取出来。我们需要忽略它，并再次从最大堆中提取。
- en: 'So that’s what the `while` loops do: ignore receipts that have already been
    processed by one of the heaps.'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 所以这就是`while`循环的作用：忽略已经被其中一个堆处理过的收据。
- en: 'A new test case may help. Here it is:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 可能需要一个新的测试用例。它是：
- en: '[PRE14]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The prize money here is 7 – 6 = 1 from the first day and 10 – 9 = 1 from the
    second day, so the total prize money is 2.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的奖金是7 – 6 = 1来自第一天，10 – 9 = 1来自第二天，所以总奖金是2。
- en: 'After reading the two receipts on the first day, each heap holds the two receipts.
    For the max-heap, we have:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 在阅读完第一天的两个收据后，每个堆都保存着这两个收据。对于最大堆，我们有：
- en: '| receipt_index | cost |'
  id: totrans-185
  prefs: []
  type: TYPE_TB
  zh: '| receipt_index | cost |'
- en: '| --- | --- |'
  id: totrans-186
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| 1 | 7 |'
  id: totrans-187
  prefs: []
  type: TYPE_TB
  zh: '| 1 | 7 |'
- en: '| 0 | 6 |'
  id: totrans-188
  prefs: []
  type: TYPE_TB
  zh: '| 0 | 6 |'
- en: 'For the min-heap, we have:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 对于最小堆，我们有：
- en: '| receipt_index | cost |'
  id: totrans-190
  prefs: []
  type: TYPE_TB
  zh: '| receipt_index | cost |'
- en: '| --- | --- |'
  id: totrans-191
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| 0 | 6 |'
  id: totrans-192
  prefs: []
  type: TYPE_TB
  zh: '| 0 | 6 |'
- en: '| 1 | 7 |'
  id: totrans-193
  prefs: []
  type: TYPE_TB
  zh: '| 1 | 7 |'
- en: 'We then do the heap extractions, removing one receipt from each heap. Here’s
    what’s left for the max-heap:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们进行堆提取，从每个堆中移除一个收据。这里是最大堆剩下的内容：
- en: '| receipt_index | cost |'
  id: totrans-195
  prefs: []
  type: TYPE_TB
  zh: '| receipt_index | cost |'
- en: '| --- | --- |'
  id: totrans-196
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| 0 | 6 |'
  id: totrans-197
  prefs: []
  type: TYPE_TB
  zh: '| 0 | 6 |'
- en: 'Here’s what’s left for the min-heap:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是最小堆剩下的内容：
- en: '| receipt_index | cost |'
  id: totrans-199
  prefs: []
  type: TYPE_TB
  zh: '| receipt_index | cost |'
- en: '| --- | --- |'
  id: totrans-200
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| 1 | 7 |'
  id: totrans-201
  prefs: []
  type: TYPE_TB
  zh: '| 1 | 7 |'
- en: Receipt 0 is still in the max-heap, and Receipt 1 is still in the min-heap.
    However, they have been used, so we’d better not use them again.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 收据0仍然在最大堆中，收据1仍然在最小堆中。然而，它们已经被使用了，所以我们最好不要再使用它们。
- en: 'Now consider the second day. Receipts 2 and 3 get added to each heap, so for
    the max-heap, we have:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 现在考虑第二天。收据2和3被添加到每个堆中，所以对于最大堆，我们有：
- en: '| receipt_index | cost |'
  id: totrans-204
  prefs: []
  type: TYPE_TB
  zh: '| receipt_index | cost |'
- en: '| --- | --- |'
  id: totrans-205
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| 3 | 10 |'
  id: totrans-206
  prefs: []
  type: TYPE_TB
  zh: '| 3 | 10 |'
- en: '| 0 | 6 |'
  id: totrans-207
  prefs: []
  type: TYPE_TB
  zh: '| 0 | 6 |'
- en: '| 2 | 9 |'
  id: totrans-208
  prefs: []
  type: TYPE_TB
  zh: '| 2 | 9 |'
- en: 'For the min-heap, we have:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 对于最小堆，我们有：
- en: '| receipt_index | cost |'
  id: totrans-210
  prefs: []
  type: TYPE_TB
  zh: '| receipt_index | cost |'
- en: '| --- | --- |'
  id: totrans-211
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| 1 | 7 |'
  id: totrans-212
  prefs: []
  type: TYPE_TB
  zh: '| 1 | 7 |'
- en: '| 2 | 9 |'
  id: totrans-213
  prefs: []
  type: TYPE_TB
  zh: '| 2 | 9 |'
- en: '| 3 | 10 |'
  id: totrans-214
  prefs: []
  type: TYPE_TB
  zh: '| 3 | 10 |'
- en: When we extract from the max-heap, we get Receipt 3\. That’s great. However,
    when we extract from the min-heap, we get Receipt 1\. Without the `while` loop
    to throw it away, this would be big trouble, because Receipt 1 has already been
    used.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们从最大堆中提取时，得到的是收据3。太好了。但是，当我们从最小堆中提取时，得到的是收据1。没有`while`循环来丢弃它，这会是个大麻烦，因为收据1已经被使用过了。
- en: At the end of a given day, one or both of the `while` loops might iterate many
    times. If this kept happening, day after day, then we’d have to be concerned about
    the impact on our program’s efficiency. Notice, though, that a receipt can be
    removed from a heap at most once. If there are *r* receipts in a heap, then there
    can be at most *r* extractions from the heap, whether they are clustered in a
    single day or across many days.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 在一天结束时，一个或两个 `while` 循环可能会迭代多次。如果这种情况持续发生，日复一日，我们就需要关注对程序效率的影响。不过，请注意，收据最多只能从堆中移除一次。如果堆中有
    *r* 个收据，那么最多可以从堆中提取 *r* 次，不论它们是集中在同一天，还是跨越多天。
- en: It is time to submit to the judge. Unlike Solution 1, which frittered away its
    time with slow searches, our heap-based solution should pass all of the test cases
    well within the time limit.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 是时候提交给评审了。与解决方案 1 因为缓慢的搜索而浪费时间不同，我们基于堆的解决方案应该能在时间限制内顺利通过所有测试用例。
- en: Heaps
  id: totrans-218
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 堆
- en: If you have a stream of values coming in and at any given time you may be asked
    to process the maximum or minimum value, then a heap is what you want. A max-heap
    is used to extract and process the maximum; a min-heap is used to extract and
    process the minimum.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你有一个不断输入的值流，并且在任何时刻可能需要处理最大值或最小值，那么你需要使用堆。最大堆用于提取和处理最大值；最小堆用于提取和处理最小值。
- en: A heap can be used to implement a *priority queue*. In a priority queue, each
    element has a priority that determines its importance. In some applications, the
    priorities of important elements are big numbers, in which case a max-heap should
    be used; in others, the priorities of important elements are small numbers, in
    which case a min-heap should be used. Of course, if we need both high- and low-priority
    elements, we can use two heaps as we did when solving the Supermarket Promotion
    problem.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 堆可以用来实现 *优先队列*。在优先队列中，每个元素都有一个优先级，决定了它的重要性。在一些应用中，重要元素的优先级是较大的数字，在这种情况下应该使用最大堆；在其他应用中，重要元素的优先级是较小的数字，这时应使用最小堆。当然，如果我们需要同时处理高优先级和低优先级元素，可以使用两个堆，就像我们在解决超市促销问题时所做的那样。
- en: '*Two More Applications*'
  id: totrans-221
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*另外两个应用*'
- en: I find that min-heaps are used more often than max-heaps. Let’s explore two
    examples where min-heaps can be used.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 我发现最小堆比最大堆使用得更频繁。让我们探讨两个可以使用最小堆的例子。
- en: Heapsort
  id: totrans-223
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 堆排序
- en: There’s a famous sorting algorithm called *heapsort* that we can implement now
    that we understand min-heaps. All we do is insert all of the values into the min-heap
    and then extract the minimum one by one. The extractions pull out the smallest
    value, then the second-smallest value, then the third-smallest value, and so on,
    handing us the values sorted from smallest to largest. It’s literally four lines.
    Check it out in [Listing 8-8](ch08.xhtml#ch08ex08).
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 有一个著名的排序算法叫做 *堆排序*，现在我们理解了最小堆后，可以实现它。我们所要做的就是将所有的值插入到最小堆中，然后逐个提取最小值。这些提取会依次取出最小的值、第二小的值、第三小的值，依此类推，从而得到按从小到大排序的值。这实际上只有四行代码。查看[清单
    8-8](ch08.xhtml#ch08ex08)了解详细内容。
- en: '[PRE15]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '*Listing 8-8: Heapsort*'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 8-8：堆排序*'
- en: We’re inserting integers into the heap here, so you should change `min_heap_insert`
    and `min_heap_extract` to use and compare integers rather than `heap_element`
    structs.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里插入的是整数，因此你应该将 `min_heap_insert` 和 `min_heap_extract` 修改为使用并比较整数，而不是 `heap_element`
    结构体。
- en: Heapsort performs *n* inserts and *n* extracts. A heap implements each of those
    in log *n* time, so heapsort is an *O*(*n* log *n*) algorithm. That’s the same
    worst-case runtime as the fastest possible sorting algorithms. (The `q` in C’s
    `qsort` function probably gets its name from *quicksort*, which is a sorting algorithm
    that is faster than heapsort in practice. We’ll encounter quicksort in [Chapter
    10](ch10.xhtml).)
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 堆排序执行 *n* 次插入和 *n* 次提取。堆实现每一次操作的时间复杂度为对数 *n*，因此堆排序是一个 *O*(*n* log *n*) 算法。这与最快的排序算法的最坏情况运行时间相同。（C
    语言中的 `qsort` 函数中的 `q` 可能源自 *快速排序*，一种在实际中比堆排序更快的排序算法。我们将在[第 10 章](ch10.xhtml)中遇到快速排序。）
- en: Dijkstra’s Algorithm
  id: totrans-229
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: Dijkstra 算法
- en: 'Dijkstra’s algorithm ([Chapter 6](ch06.xhtml)) spends a lot of its time finding
    the next node to process. It does that by searching through node distances, looking
    for the smallest one. To speed up Dijkstra’s algorithm, we can use a min-heap!
    This is demonstrated in “Dijkstra’s Algorithm: Using a Heap” in [Appendix B](app02.xhtml).'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: Dijkstra 算法（[第 6 章](ch06.xhtml)）花费大量时间寻找下一个处理的节点。它通过搜索节点距离来找到最小的那个。为了加速 Dijkstra
    算法，我们可以使用最小堆！这一点在[附录 B](app02.xhtml)的《Dijkstra 算法：使用堆》中有演示。
- en: '#### *Choosing a Data Structure*'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: '#### *选择数据结构*'
- en: A data structure is typically good for only a few different operation types.
    There’s no super data structure that makes everything fast, so it’s up to you
    to choose the appropriate data structure for the problem you’re solving.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 数据结构通常只适用于少数几种操作类型。没有一种万能数据结构可以让所有操作都变快，因此你需要根据所解决的问题选择合适的数据结构。
- en: Think back to [Chapter 1](ch01.xhtml), when we learned about the hash table
    data structure. Could we have used a hash table to solve Supermarket Promotion?
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 回想一下 [第 1 章](ch01.xhtml)，我们学习了哈希表数据结构。我们是否可以用哈希表来解决超市促销问题？
- en: No! A hash table is good for speeding up the search for a specific item that
    we’re searching for. What are the snowflakes that might be similar to snowflake
    *s*? Is word *c* in this word list? Those are the kinds of questions you want
    to ask of a hash table. What is the minimum element in this array? No hashing
    is going to help there. You’d have to search through the hash table, which is
    no faster than searching a regular array. It’s our job to choose a data structure
    specifically designed for the task at hand. For finding the minimum element in
    an array, that data structure is a min-heap.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 不！哈希表适用于加速搜索我们要查找的特定项目。哪些雪花可能与雪花 *s* 相似？单词 *c* 是否在这个单词列表中？这些是你希望从哈希表中查询的问题。数组中最小的元素是什么？哈希技术在这方面没有帮助。你得通过哈希表进行搜索，而这与直接搜索普通数组没有区别。我们的任务是选择一个专门为当前任务设计的数据结构。对于在数组中查找最小元素，那个数据结构就是最小堆。
- en: As with any general-purpose data structure, heaps can be used to solve a surprisingly
    diverse set of problems—but the heap data structure itself remains as is, just
    as you’ve learned it here. So instead of solving another heap problem, let’s proceed
    to a problem where we’ll need a new data structure called a *segment tree*. As
    with heaps, segment trees speed up only a small number of types of operations.
    Even so, it’s impressive how many problems are in the wheelhouse of segment trees,
    where those speedups are exactly what we need.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 与任何通用数据结构一样，堆可以用来解决意想不到的多种问题——但堆的数据结构本身保持不变，就像你在这里学到的一样。所以，虽然我们不再解决另一个堆问题，但接下来我们将遇到一个需要新数据结构——*线段树*——的问题。与堆一样，线段树仅能加速少数几种操作类型。即便如此，线段树在处理问题时的加速效果仍然令人印象深刻，正是这些加速正是我们所需要的。
- en: 'Problem 2: Building Treaps'
  id: totrans-236
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 问题 2：构建 Treaps
- en: In this problem, we’ll produce a representation of a *treap*. A treap is a flexible
    data structure that can solve a variety of search problems, and I encourage you
    to learn more about treaps if you’re interested. Here we’re concerned only with
    building a treap, not using it. Of course, I’ll provide all you need to know about
    treaps for our purposes.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个问题中，我们将构建一个 *treap* 的表示。Treap 是一种灵活的数据结构，可以解决多种搜索问题，如果你感兴趣，我鼓励你深入了解 treap。这里我们只关心构建一个
    treap，而不是使用它。当然，为了我们的目的，我会提供关于 treap 的所有必要信息。
- en: This is POJ problem `1785`.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 这是 POJ 问题 `1785`。
- en: '*The Problem*'
  id: totrans-239
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*问题*'
- en: A treap is a binary tree where each node has both a label and a priority. [Figure
    8-15](ch08.xhtml#ch08fig015) shows an example treap, in which the uppercase letters
    are the labels and the positive integers are the priorities. I’ve separated the
    label and priority for each node by a slash. For example, the root node has label
    C and priority 58.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: Treap 是一种二叉树，每个节点都有一个标签和一个优先级。[图 8-15](ch08.xhtml#ch08fig015) 显示了一个示例 treap，其中大写字母是标签，正整数是优先级。我已经通过斜杠将每个节点的标签和优先级分开。例如，根节点的标签是
    C，优先级是 58。
- en: '![Image](../images/ch08fig15.jpg)'
  id: totrans-241
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/ch08fig15.jpg)'
- en: '*Figure 8-15: A treap*'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 8-15：Treap 示例*'
- en: 'A treap has to satisfy two properties: one on its labels and one on its priorities.'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: Treap 必须满足两个条件：一个是关于其标签的，另一个是关于其优先级的。
- en: First, let’s talk about labels. For any node *x*, the labels in its left subtree
    are all less than the label of *x*, and the labels in its right subtree are all
    greater than the label of *x*. This is called the *binary search tree (BST)* property.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们来谈谈标签。对于任何节点 *x*，其左子树中的标签都小于 *x* 的标签，右子树中的标签都大于 *x* 的标签。这就是 *二叉搜索树（BST）*
    的特性。
- en: You can verify that the treap in [Figure 8-15](ch08.xhtml#ch08fig015) meets
    this label property. For our alphabetic labels, one label is less than another
    if it comes earlier in the alphabet. Take the root node as an example. Its label
    is C. Both labels in its left subtree are less than C, and all labels in its right
    subtree are greater than C. As another example, consider the node with label G.
    All of the labels in its left subtree—D, E, and F—are less than G. What about
    all of the labels in its right subtree? Well, there are none, so there’s nothing
    to check!
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以验证[图 8-15](ch08.xhtml#ch08fig015)中的 treap 是否符合这个标签属性。对于我们的字母标签，如果一个标签在字母表中出现在另一个标签之前，则该标签小于另一个标签。以根节点为例，它的标签是
    C。它左子树中的所有标签都小于 C，而右子树中的所有标签都大于 C。另一个例子是考虑标签为 G 的节点。它左子树中的所有标签——D、E 和 F——都小于 G。那么它右子树中的所有标签呢？嗯，右子树中没有标签，所以不用检查！
- en: Second, let’s talk about priorities. For any node *x*, the priorities of its
    children are less than the priority of *x*. Hey, this is like the max-heap-order
    property!
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 其次，我们来谈谈优先级。对于任何节点 *x*，其子节点的优先级都小于 *x* 的优先级。嘿，这就像最大堆顺序属性一样！
- en: Take a look at the root again. Its priority is 58\. Its children had better
    have lower priorities—and they do, with priorities 54 and 56\. How about that
    G node, with priority 55? We need its child to have a lower priority—and it does,
    with priority 49.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 再次看看根节点。它的优先级是 58。它的孩子最好有更低的优先级——它们的优先级分别是 54 和 56。那么那个优先级为 55 的 G 节点呢？我们需要它的孩子有更低的优先级——它确实如此，优先级是
    49。
- en: 'So that’s a treap: a binary tree whose labels satisfy the BST property and
    whose priorities satisfy the max-heap-order property. Notice that there’s no shape
    requirement: a treap can have any structure whatsoever. There’s certainly no complete
    tree requirement like there is for heaps.'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是一个 treap：一个二叉树，其标签满足二叉搜索树（BST）属性，优先级满足最大堆顺序（max-heap-order）属性。注意，没有形状的要求：treap
    可以具有任何结构。显然，不像堆那样有完整树的要求。
- en: In this problem, we are provided the label/priority of each node. Our task is
    to assemble and output a treap for these nodes.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个问题中，我们提供了每个节点的标签/优先级。我们的任务是为这些节点组装并输出一个 treap。
- en: Input
  id: totrans-250
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 输入
- en: The input contains zero or more test cases. Each line of input begins with an
    integer *n*. Each *n* is between 0 and 50,000\. If *n* is 0, then there are no
    further test cases to process.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 输入包含零个或多个测试用例。每行输入以一个整数 *n* 开头。每个 *n* 的范围是 0 到 50,000。如果 *n* 为 0，则表示没有更多的测试用例需要处理。
- en: If *n* is greater than zero, then it indicates the number of nodes in the test
    case. Following *n* is *n* space-separated tokens, one for each node. Each token
    is of the form `L/P`, where `L` is the label and `P` is the priority for this
    node. Labels are strings of letters; priorities are positive integers. All labels
    are unique, and all priorities are unique.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 *n* 大于零，那么它表示测试用例中节点的数量。紧接着 *n* 是 *n* 个用空格分隔的标记，每个标记对应一个节点。每个标记的形式是 `L/P`，其中
    `L` 是标签，`P` 是该节点的优先级。标签是字母字符串；优先级是正整数。所有标签都是唯一的，所有优先级也是唯一的。
- en: 'Here is possible input that leads to the treap in [Figure 8-15](ch08.xhtml#ch08fig015):'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 这是可能的输入，它生成了[图 8-15](ch08.xhtml#ch08fig015)中的 treap：
- en: '[PRE16]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Output
  id: totrans-255
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 输出
- en: 'For each test case, output the treap on its own line. Here is the required
    format for the treap:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 对于每个测试用例，输出 treap 每行一个。以下是 treap 所需的格式：
- en: '[PRE17]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Here <left_subtreap> is the left subtreap, <L> is the label of the root, <P>
    is the priority of the root, and <right_subtreap> is the right subtreap. The subtreaps
    are output in the same format.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，<left_subtreap> 是左子 treap，<L> 是根节点的标签，<P> 是根节点的优先级，<right_subtreap> 是右子 treap。子
    treap 以相同的格式输出。
- en: 'Here is the output corresponding to the sample input:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 这是与示例输入对应的输出：
- en: '[PRE18]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The time limit for solving the test cases is two seconds.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 解决测试用例的时间限制是两秒钟。
- en: '*Recursively Outputting Treaps*'
  id: totrans-262
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*递归输出 Treaps*'
- en: 'Let’s again consider our sample nodes and reason through how we can produce
    a treap from them. Here are those nodes:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们再次考虑我们的示例节点，并推理如何从这些节点生成一个 treap。以下是这些节点：
- en: '[PRE19]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Remember that treap priorities must obey the max-heap-order property. In particular,
    this means that a node with maximum priority must be the root node. In addition,
    because the input guarantees that all priorities are distinct, there is only one
    node that has the maximum priority. So it’s settled: the root node must be `C/58`.'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，treap 的优先级必须遵守最大堆顺序属性。特别地，这意味着具有最大优先级的节点必须是根节点。此外，由于输入保证所有优先级都是不同的，因此只有一个节点具有最大优先级。所以就这样确定了：根节点必须是
    `C/58`。
- en: 'We now must decide for each other node whether it should go in C’s left subtreap
    or right subtreap. The priorities of these nodes are all less than 58, so priority
    won’t help us make any kind of left–right split—but the BST property will! The
    BST property of treaps tells us that the labels in the left subtreap must be less
    than C and the labels in the right subtreap must be greater than C. We can therefore
    split the remaining nodes into two groups, one for the left subtreap and one for
    the right subtreap, as follows:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们必须为每个其他节点决定它应该进入C的左子堆树还是右子堆树。这些节点的优先级都小于58，因此优先级不能帮助我们做出左–右划分——但二叉搜索树（BST）属性能！堆树的BST属性告诉我们，左子堆树中的标签必须小于C，右子堆树中的标签必须大于C。因此，我们可以将剩余节点分成两组，一组用于左子堆树，一组用于右子堆树，具体如下：
- en: '[PRE20]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: That is, the left subtreap will have Nodes A and B, and the right subtreap will
    have Nodes I, K, E, G, and so on.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 也就是说，左子堆树将包含节点A和B，右子堆树将包含节点I、K、E、G等。
- en: Now, we’re done! We’ve split the original problem into two smaller subproblems
    of exactly the same form. We were asked to produce a treap for 11 nodes. We’ve
    reduced that problem to producing a treap for two nodes and a treap for eight
    nodes. We can do those recursively!
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们完成了！我们将原始问题分解为两个更小的子问题，形式完全相同。我们被要求为11个节点生成一个堆树。我们已经将这个问题简化为为两个节点生成堆树和为八个节点生成堆树。我们可以递归地解决这些问题！
- en: Let’s nail down the specific rules that we’ll use. For the base case, we can
    use a treap of zero nodes, which requires no output at all. For the recursive
    case, we’ll identify the root as the node with highest priority and then split
    the remaining nodes into those with smaller labels and those with larger labels.
    We output an open parenthesis, recursively output the treap for the smaller labels,
    output the root node of the treap, output the treap for the larger labels, and
    finally output a closing parenthesis.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们明确一下我们将使用的具体规则。对于基准情况，我们可以使用一个零节点的堆树，这不需要输出任何内容。对于递归情况，我们将根节点识别为具有最高优先级的节点，然后将剩余的节点分成标签较小的和标签较大的节点。我们输出一个左括号，递归输出较小标签的堆树，输出堆树的根节点，输出较大标签的堆树，最后输出一个右括号。
- en: 'For our sample input, we’ll output an opening parenthesis. Then we’ll output
    the left subtreap:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的示例输入，我们将输出一个左括号。接着我们输出左子堆树：
- en: '[PRE21]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'This is followed by the root node:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 然后是根节点：
- en: '[PRE22]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'then the right subtreap:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 然后是右子堆树：
- en: '[PRE23]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: and finally a closing parenthesis.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 最后是一个右括号。
- en: '*Sorting by Label*'
  id: totrans-278
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*按标签排序*'
- en: I have one other implementation idea before we turn to the code. As I’ve described
    things so far, it seems that we’d need to literally create a new array with small-labeled
    nodes to pass to the first recursive call and a new array with large-labeled nodes
    to pass to the second recursive call. That would result in lots of copying between
    arrays. Fortunately, we can avoid all that by sorting the nodes by label, from
    smallest to largest, at the outset. Then we can just tell each recursive call
    the starting and ending indices of the array that it is responsible for.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始编写代码之前，我还有一个实现思路。到目前为止，我描述的方式似乎需要我们实际创建一个新数组，包含小标签节点，用于传递给第一次递归调用；另一个新数组包含大标签节点，用于传递给第二次递归调用。这将导致数组之间频繁复制。幸运的是，我们可以通过一开始就按标签从小到大排序节点，避免这些操作。然后，我们只需告诉每个递归调用它负责的数组的起始和结束索引。
- en: 'For example, if we sort our sample input by label, we get this:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果我们按标签排序我们的示例输入，结果是：
- en: '[PRE24]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: We can then tell the first recursive call to produce the subtreap for the first
    two nodes and the second recursive call to produce the subtreap for the latter
    eight.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们可以告诉第一次递归调用生成前两个节点的子堆树，第二次递归调用生成后八个节点的子堆树。
- en: '*Solution 1: Recursion*'
  id: totrans-283
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*解决方案1：递归*'
- en: 'Here are some constants and a struct:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些常量和一个结构体：
- en: '[PRE25]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: We don’t know how long the labels are, so we’ll go with an initial size of 16\.
    You’ll see that we call a `read_label` function to read each label; if a length
    of 16 proves insufficient, that function will allocate more memory until the label
    fits. (This is probably overkill, since it looks like the test cases use short
    labels of up to only five letters, but it’s better to be safe than sorry.)
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不知道标签的长度，所以我们将初始大小设置为16。你会看到我们调用一个`read_label`函数来读取每个标签；如果16的长度不足，该函数会分配更多内存，直到标签能够适配。（这可能有点过头，因为测试用例似乎使用的标签最多只有五个字母，但安全起见总比出错好。）
- en: The main Function
  id: totrans-287
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 主函数
- en: Let’s look at the `main` function, as given in [Listing 8-9](ch08.xhtml#ch08ex09).
    It uses some helper functions—`read_label` that we just talked about and `compare`
    for comparing treap nodes—and calls `solve` for actually outputting the treap.
    We’ll discuss those shortly.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一下`main`函数，正如在[示例 8-9](ch08.xhtml#ch08ex09)中给出的那样。它使用了一些辅助函数——我们刚才提到的`read_label`和用于比较treap节点的`compare`——并调用`solve`函数来实际输出treap。我们稍后会讨论这些函数。
- en: '[PRE26]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '*Listing 8-9: The main function for reading input and solving the problem*'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: '*示例 8-9：用于读取输入并解决问题的主函数*'
- en: Be careful with `scanf` in a program that reads a mix of numbers and strings.
    Here, each number from the input is followed by whitespace, and we don’t want
    those space characters prefixing the labels that follow. To read and throw away
    those spaces, we use a space following each `%d scanf` format specifier.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 在读取混合数字和字符串的程序中，要小心使用`scanf`。在这里，每个输入的数字后面都有空白字符，我们不希望这些空格字符出现在后续标签的前面。为了读取并丢弃这些空格，我们在每个`%d
    scanf`格式说明符后面加上一个空格。
- en: Helper Functions
  id: totrans-292
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 辅助函数
- en: We use `scanf` to read the priorities but not the labels. The labels are read
    by the `read_label` function in [Listing 8-10](ch08.xhtml#ch08ex010).
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`scanf`来读取优先级，但不读取标签。标签是通过[示例 8-10](ch08.xhtml#ch08ex010)中的`read_label`函数来读取的。
- en: '[PRE27]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '*Listing 8-10: Reading a label*'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: '*示例 8-10：读取标签*'
- en: We’ve used essentially the same function once before in [Listing 5-15](ch05.xhtml#ch05ex015).
    The only difference this time is that we stop reading at the `/` character that
    separates the label from the priority ❶. As usual, `qsort` needs a comparison
    function, and the one we want, given in [Listing 8-11](ch08.xhtml#ch08ex011),
    compares nodes by label.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在[示例 5-15](ch05.xhtml#ch05ex015)中曾经用过基本相同的函数。唯一的区别是这次我们在`/`字符处停止读取，这个字符将标签与优先级分开❶。像往常一样，`qsort`需要一个比较函数，而我们需要的比较函数在[示例
    8-11](ch08.xhtml#ch08ex011)中给出，它通过标签比较节点。
- en: '[PRE28]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '*Listing 8-11: A comparison function for sorting*'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: '*示例 8-11：排序的比较函数*'
- en: The `strcmp` function works perfectly as a comparison function, because it returns
    a negative integer if the first string is alphabetically less than the second
    string, `0` if the strings are equal, and a positive integer if the first string
    is alphabetically greater than the second string.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: '`strcmp`函数作为比较函数工作得非常好，因为如果第一个字符串按字母顺序小于第二个字符串，它返回负整数；如果两个字符串相等，则返回`0`；如果第一个字符串按字母顺序大于第二个字符串，则返回正整数。'
- en: Outputting the Treap
  id: totrans-300
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 输出Treap
- en: Before we get to the main event—the `solve` function—we need a helper function
    to return the index of the node with maximum priority. This is provided in [Listing
    8-12](ch08.xhtml#ch08ex012). It’s a slow, linear search from index `left` to index
    `right` (and this should worry you!).
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们进入主要部分——`solve`函数之前，我们需要一个辅助函数来返回具有最大优先级的节点的索引。这个函数在[示例 8-12](ch08.xhtml#ch08ex012)中提供。它是从`left`索引到`right`索引的慢速线性搜索（这应该让你感到担忧！）。
- en: '[PRE29]'
  id: totrans-302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '*Listing 8-12: Finding the maximum priority*'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: '*示例 8-12：找到最大优先级*'
- en: Now we’re ready to output the treap! See [Listing 8-13](ch08.xhtml#ch08ex013)
    for the `solve` function.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们准备好输出treap了！请参见[示例 8-13](ch08.xhtml#ch08ex013)中的`solve`函数。
- en: '[PRE30]'
  id: totrans-305
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '*Listing 8-13: Solving the problem*'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: '*示例 8-13：解决问题*'
- en: 'This function takes three parameters: the array of treap nodes and `left` and
    `right` indices determining the range of nodes over which we’d like the treap
    to be built. In order for the treap to be built for all of the nodes, the initial
    call from `main` will pass `0` for `left` and `num_nodes - 1` for `right`.'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 该函数接受三个参数：treap节点的数组和确定我们希望构建treap的节点范围的`left`和`right`索引。为了构建包含所有节点的treap，来自`main`的初始调用将传递`0`作为`left`，`num_nodes
    - 1`作为`right`。
- en: The base case for this recursive function occurs when there are no nodes in
    the treap ❶. In this case, we simply return without outputting anything. With
    no nodes, there is no output.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 这个递归函数的基本情况出现在treap中没有节点时❶。在这种情况下，我们只需返回，而不输出任何内容。没有节点，就没有输出。
- en: 'Otherwise, from nodes with indices between `left` and `right`, we find the
    index of the node with maximum priority ➋. That’s the root of the treap, and it
    splits the problem in two: outputting a treap for those nodes with smaller labels
    and outputting a treap for those nodes with larger labels. We solve each of these
    subproblems with a recursive call ➌ ➍.'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 否则，对于`left`和`right`之间的节点，我们找到具有最大优先级的节点的索引➋。这就是treap的根节点，它将问题分为两部分：输出标签较小节点的treap和输出标签较大节点的treap。我们通过递归调用分别解决这两个子问题➌
    ➍。
- en: 'There we have it: our first solution. It’s quite nice, I’d say. In fact, it
    does two important things right. First, it sorts the nodes, once and for all,
    so that each call of `solve` needs only its `left` and `right` indices. Second,
    it uses recursion to make short work of the otherwise-daunting process of outputting
    a treap.'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样：我们的第一个解决方案。老实说，我觉得它相当不错。实际上，它做对了两件重要的事。首先，它一次性排序所有节点，因此每次调用 `solve` 只需要它的
    `left` 和 `right` 索引。其次，它使用递归轻松处理了本来可能令人头疼的输出 treap 的过程。
- en: However, submit this code to the judge and you’ll see that everything grinds
    to a halt because of that linear search to find the node with maximum priority
    ([Listing 8-12](ch08.xhtml#ch08ex012)). What’s so wrong with it? What kind of
    treap triggers its worst-case performance? We’ll talk about that next.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，将此代码提交给评测系统后，你会发现一切都停滞不前，因为需要进行线性搜索以找到具有最大优先级的节点（[Listing 8-12](ch08.xhtml#ch08ex012)）。它到底有什么问题？什么样的
    treap 会触发其最坏情况下的性能？我们接下来会讨论这个问题。
- en: '*Range Maximum Queries*'
  id: totrans-312
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*范围最大查询（RMQ）*'
- en: In the previous chapter, we talked about solving the range sum query problem.
    That one asked, “Given an array `a`, left index `left`, and right index `right`,
    what is the *sum* of all elements from `a[left]` to `a[right]`?”
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们讨论了解决范围和查询问题。这个问题问的是：“给定一个数组 `a`、左索引 `left` 和右索引 `right`，从 `a[left]`
    到 `a[right]` 的所有元素的 *和* 是多少？”
- en: Here, in Building Treaps, we’re being asked to solve a related problem known
    as the *range maximum query (RMQ)* problem. This asks, “Given an array `a`, left
    index `left`, and right index `right`, what is the index of the *maximum* element
    of all elements from `a[left]` to `a[right]`?” (Rather than the index, for some
    problems it might suffice to get the maximum element itself, but for Building
    Treaps we need the index.)
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 在构建 Treaps 时，我们需要解决一个相关的问题，称为 *范围最大查询（RMQ）* 问题。问题是：“给定一个数组 `a`、左索引 `left` 和右索引
    `right`，从 `a[left]` 到 `a[right]` 的所有元素中，哪个元素的索引最大？”（对于某些问题，可能只需要得到最大元素本身，而不是索引，但在构建
    Treaps 时，我们需要索引。）
- en: 'In Solution 1, we offered an implementation of RMQ in [Listing 8-12](ch08.xhtml#ch08ex012).
    It iterates from `left` to `right`, checking whether we’ve found an index whose
    node has higher priority than what we’ve discovered so far. We call that function
    for each subtreap, and each call involves a linear search through the active segment
    of the array. If most of those linear searches were on small array segments, then
    we might get away with this. However, there are some inputs that cause many of
    the searches to be on huge segments of the array. Here’s such a list of nodes
    that we might read from the input:'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 在解决方案 1 中，我们提供了 [Listing 8-12](ch08.xhtml#ch08ex012) 中的 RMQ 实现。它从 `left` 遍历到
    `right`，检查是否找到了一个节点的索引，其优先级高于我们到目前为止发现的节点。我们对每个子 treap 调用该函数，每次调用都涉及对数组活动区间的线性搜索。如果这些线性搜索大多是在小的数组区间内进行的，那么我们或许可以应付过去。然而，有些输入会导致许多搜索出现在数组的大区间上。以下是我们可能从输入中读取的节点列表：
- en: '[PRE31]'
  id: totrans-316
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'We scan all seven nodes, finding `G/7` as the node with maximum priority. We
    then recursively output the treap for the small-labeled nodes and recursively
    output the treap for the large-labeled nodes. Unfortunately, the first recursive
    call gets all but the `G/7` node, as the second recursive call is on zero nodes.
    The first recursive call gets this:'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 我们扫描所有七个节点，找出 `G/7` 作为具有最大优先级的节点。然后，我们递归输出小标签节点的 treap，并递归输出大标签节点的 treap。不幸的是，第一个递归调用得到的是除了
    `G/7` 节点之外的所有节点，而第二个递归调用则是在零个节点上进行。第一个递归调用得到的是：
- en: '[PRE32]'
  id: totrans-318
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Now we need another scan of these six elements to identify the node with highest
    priority. We’ll identify `F/6` as that node, make it the root of this subtreap,
    and then make two more recursive calls. Again, however, the first recursive call
    is saddled with all remaining nodes, leading to another expensive array scan.
    This pattern of expensive array scans can continue until there are no nodes remaining.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要再扫描这六个元素以识别具有最高优先级的节点。我们将 `F/6` 识别为该节点，将其设为此子 treap 的根节点，然后再进行两个递归调用。然而，第一次递归调用仍然需要处理所有剩余的节点，导致又一次昂贵的数组扫描。这个昂贵的数组扫描模式可能会持续，直到没有节点剩余为止。
- en: Generalizing, we can say that, for *n* nodes, the first RMQ could take *n* steps,
    the second could take *n* – 1 steps, and so on, all the way down to 1 step. That’s
    1 + 2 + 3 + . . .+ *n* steps in all. A closed form for this formula is *n*(*n*
    + 1)/2\. In [Chapter 1](ch01.xhtml), we saw a very similar formula in “Diagnosing
    the Problem” on [page 9](ch01.xhtml#ch01lev1). We can similarly conclude that
    we’re doing *O*(*n*²) (quadratic) work here.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 一般来说，我们可以说，对于*n*个节点，第一个RMQ可能需要*n*步，第二个可能需要*n* – 1步，以此类推，一直到1步。总共是1 + 2 + 3 +
    . . .+ *n*步。这个公式的封闭形式是*n*(*n* + 1)/2。在[第1章](ch01.xhtml)中，我们在“诊断问题”部分的[第9页](ch01.xhtml#ch01lev1)看到过一个非常类似的公式。我们也可以得出类似的结论，我们在这里做的是*O*(*n*²)（二次方）工作。
- en: Here’s another way to see that we’re doing *O*(*n*²) work. Throw away the *n*/2
    smallest terms and focus on only the remaining *n*/2 larger terms. (Let’s assume
    that *n* is even so that *n*/2 is an integer.) This leaves us with *n* + (*n*
    – 1) + (*n* – 2) + . . . + (*n*/2 + 1). There are *n*/2 terms here, each of which
    is larger than *n*/2, so in total they add up to at least (*n*/2)(*n*/2) = *n*²/4\.
    This is quadratic!
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有另一种方式来观察我们正在做*O*(*n*²)的工作。舍弃前*n*/2个最小的项，专注于剩余的*n*/2个较大的项。（假设*n*是偶数，这样*n*/2就是整数。）这将剩下*n*
    + (*n* – 1) + (*n* – 2) + . . . + (*n*/2 + 1)。这里有*n*/2个项，每一个都大于*n*/2，因此它们的和至少为(*n*/2)(*n*/2)
    = *n*²/4。这是二次方的！
- en: Therefore, a linear search to solve the RMQ problem is not satisfactory.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，线性搜索来解决RMQ问题是不理想的。
- en: 'In the previous chapter, we used a prefix array to speed up range sum queries.
    Give that a quick refresher now, because I’m about to ask you a question: Can
    we use that technique to solve the RMQ, too?'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们使用了前缀数组来加速区间和查询。现在回顾一下这个方法，因为我马上要问你一个问题：我们能用这个技术来解决RMQ吗？
- en: 'Unfortunately, no. (Or, fortunately no, because I can teach you one of my favorite
    data structures as a result.) To sum the elements from index 2 to 5, we can look
    up the prefix sum for index 5 and subtract the prefix sum for index 1\. That’s
    because subtraction undoes addition: the prefix sum for index 5 contains the prefix
    sum for index 1, so we can just subtract the latter out of there. Unfortunately,
    we cannot “undo” a maximum computation in the same way. If the maximum for the
    elements up to index 5 is 10, and the maximum for the elements up to index 1 is
    also 10, what is the maximum from index 2 to index 5? Who knows! With that 10
    gone, it could be whatever is at index 2, or 3, or 4, or 5\. A huge, early element
    prevents later elements from making any change at all to the prefix array. When
    that huge element is gone, we lose our bearings. Contrast that to a prefix sum
    array, where every element leaves its mark.'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 很遗憾，不行。（或者幸运的是不行，因为这样我可以教你我最喜欢的数据结构之一。）要从索引2到索引5求和，我们可以查找索引5的前缀和并减去索引1的前缀和。因为减法可以抵消加法：索引5的前缀和包含了索引1的前缀和，所以我们只需把后者从中减去。遗憾的是，我们不能用相同的方式“撤销”最大值计算。如果索引5之前的元素最大值是10，而索引1之前的元素最大值也是10，那么索引2到索引5的最大值是多少？谁知道！当那10被去掉后，它可能是索引2、3、4或5中的任意一个。一个巨大的早期元素阻止了后来的元素对前缀数组的任何更改。当那个巨大的元素消失时，我们就迷失了方向。相比之下，前缀和数组中的每个元素都会留下它的痕迹。
- en: As a last-ditch effort, let’s try a heap. Can we use a max-heap to solve the
    RMQ? No, again. A max-heap gives us the maximum element in the entire heap, with
    no provision for restricting that to a given range.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 作为最后的努力，让我们尝试堆。我们能用最大堆来解决RMQ吗？不，再次不行。最大堆给我们的是整个堆的最大元素，而不能限制它仅仅对某个特定范围有效。
- en: It’s time for something new.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 是时候尝试一些新方法了。
- en: '*Segment Trees*'
  id: totrans-327
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*线段树*'
- en: Shoo, treaps, shoo! We’ll return to treaps later, just as soon as we have a
    better implementation of RMQ.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 走开，treap，走开！我们稍后会回到treap，就在我们有了RMQ更好的实现之后。
- en: A *segment tree* is a full binary tree where each node is associated with a
    particular segment of an underlying array. (In Building Treaps, the underlying
    array is the array of priorities.) Each node stores the answer for the query on
    its segment. For the RMQ, each node stores the index of the maximum element in
    its segment, but segment trees can be used for other queries, too. The segments
    are arranged such that a small number of them can be assembled to answer any query.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: '*线段树*是一个完全二叉树，其中每个节点都与基础数组的某个特定区间相关联。（在构建Treap时，基础数组是优先级数组。）每个节点存储其区间查询的答案。对于RMQ，每个节点存储其区间内最大元素的索引，但线段树也可以用于其他查询。这些区间被排列成这样，少数几个区间可以组合起来回答任何查询。'
- en: The Segments
  id: totrans-330
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 段
- en: 'The root node of a segment tree covers the entire array. So, if we’re ever
    asked for the RMQ on the entire array, we can solve that in one step by just looking
    at the root. For other queries, we’ll have to use other nodes. The root node has
    two children: the left child covers the first half of the array and the right
    child covers the second half. Each of these nodes has two children of its own,
    which subdivide the segments even further, and so on, until we get to segments
    of just one element.'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 线段树的根节点覆盖整个数组。因此，如果我们被要求查询整个数组的RMQ，我们只需看根节点，就能一步解决。对于其他查询，我们需要使用其他节点。根节点有两个子节点：左子节点覆盖数组的前半部分，右子节点覆盖数组的后半部分。这些节点每个都有两个子节点，进一步细分段，依此类推，直到我们得到仅包含一个元素的段。
- en: '[Figure 8-16](ch08.xhtml#ch08fig016) shows a segment tree that supports queries
    on an eight-element array. Each node is labeled with its left and right endpoints.
    There’s no information in the segment tree about the RMQ yet; for now, we’ll just
    focus on the segments themselves.'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 8-16](ch08.xhtml#ch08fig016)展示了一个支持对八元素数组进行查询的线段树。每个节点都标注了它的左右端点。线段树中暂时没有RMQ相关信息；目前我们只关注段本身。'
- en: '![Image](../images/ch08fig16.jpg)'
  id: totrans-333
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/ch08fig16.jpg)'
- en: '*Figure 8-16: A segment tree for an eight-element array*'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 8-16：一个八元素数组的线段树*'
- en: Notice that the sizes of segments are cut in half for each level that we descend
    in the tree. For example, the root segment covers eight elements, each of its
    children covers four elements, each of their children covers two elements, and
    so on. Like a heap, the height of a segment tree is log *n*, where *n* is the
    number of elements in the array. We’ll be able to answer any query by doing a
    constant amount of work per level, so we’ll obtain *O*(log *n*) time per query.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，随着我们在树中每下降一层，段的大小会减半。例如，根节点段覆盖八个元素，每个子节点段覆盖四个元素，它们的子节点段覆盖两个元素，依此类推。像堆一样，线段树的高度是log
    *n*，其中 *n* 是数组中的元素数量。我们可以通过每层做常量量的工作来回答任何查询，因此每次查询的时间复杂度是 *O*(log *n*)。
- en: '[Figure 8-16](ch08.xhtml#ch08fig016) is a complete binary tree. Through our
    study of heaps, we know what to do with these: store them in an array! We can
    then use the same math to find the children of a parent, which we’ll need when
    processing segment trees.'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 8-16](ch08.xhtml#ch08fig016)是一个完整的二叉树。通过我们对堆的学习，我们知道该如何处理这些：将它们存储在数组中！然后，我们可以使用相同的数学方法来找到父节点的子节点，这在处理线段树时会用到。'
- en: Now, I’m going to hit you with another segment tree, one that exposes a bit
    of a surprise. See [Figure 8-17](ch08.xhtml#ch08fig017).
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我将给你展示另一个线段树，它揭示了一些意外的内容。请看[图 8-17](ch08.xhtml#ch08fig017)。
- en: '![Image](../images/ch08fig17.jpg)'
  id: totrans-338
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/ch08fig17.jpg)'
- en: '*Figure 8-17: A segment tree for an 11-element array*'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 8-17：一个11元素数组的线段树*'
- en: That’s not a complete binary tree at all, because the bottom level is not filled
    in from left to right! For example, Node 2-2 has no children, even though 3-4
    does.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 这根本不是一个完整的二叉树，因为底层没有从左到右填满！例如，节点2-2没有子节点，尽管3-4有。
- en: 'Everything’s okay, though. We’ll continue to store a segment tree in an array.
    We’ll continue to multiply a node’s index by 2 to get its left child and to multiply
    by 2 and add 1 to get its right child. All that will happen is a little bit of
    waste in the array. For example, the order of elements in the array for [Figure
    8-17](ch08.xhtml#ch08fig017) is as follows, where `*` is an unused element:'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 不过没关系。我们会继续将线段树存储在数组中。我们将继续通过将节点索引乘以2来获得左子节点，乘以2再加1来获得右子节点。唯一发生的事就是数组会有一些浪费。例如，[图
    8-17](ch08.xhtml#ch08fig017)中数组元素的顺序如下，其中`*`表示未使用的元素：
- en: '[PRE33]'
  id: totrans-342
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: This waste *does* make it a little more difficult to determine the number of
    array elements we need for the segment tree.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 这种浪费*确实*使得确定线段树所需的数组元素个数变得稍微困难一些。
- en: 'If the number of elements, *n*, in the underlying array is a power of 2, then
    we’ll be safe with a segment tree that can hold 2*n* elements. For example, count
    the nodes in [Figure 8-16](ch08.xhtml#ch08fig016): it takes 15 nodes, which is
    less than 8 × 2 = 16\. (2*n* is safe because all powers of 2 less than *n* add
    up to exactly *n* – 1\. For example, 4 + 2 + 1 = 7, which is 1 less than 8.) If
    *n* isn’t a power of 2, then 2*n* isn’t enough. For proof, look no further than
    [Figure 8-17](ch08.xhtml#ch08fig017), which would require an array of 31 elements
    (more than 2 × 11 = 22) to hold it.'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 如果底层数组的元素数 *n* 是 2 的幂，那么我们可以安全地使用一个能够容纳 2*n* 元素的线段树。例如，计算 [图 8-16](ch08.xhtml#ch08fig016)
    中的节点数量：它需要 15 个节点，少于 8 × 2 = 16。（2*n* 是安全的，因为所有小于 *n* 的 2 的幂加起来正好是 *n* – 1。例如，4
    + 2 + 1 = 7，少于 8。）如果 *n* 不是 2 的幂，则 2*n* 不够用。为证明这一点，不妨看看 [图 8-17](ch08.xhtml#ch08fig017)，它需要一个包含
    31 个元素的数组（大于 2 × 11 = 22）才能容纳。
- en: The more elements to cover in the segment tree, the bigger we need to make the
    segment tree array—but how big should it be? Suppose that we have an underlying
    array of *n* elements for which we want to build a segment tree. I’ll argue that
    the segment tree should be allocated an array of 4*n* elements to be safe.
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 覆盖线段树中的更多元素时，我们需要更大容量的线段树数组——那么它应该有多大呢？假设我们有一个包含 *n* 元素的底层数组，想要为其构建一颗线段树。我认为，为了安全起见，线段树应该分配一个包含
    4*n* 元素的数组。
- en: Let *m* be the smallest power of 2 greater than or equal to *n*. For example,
    if *n* is 11, then *m* is 16\. We can store a segment tree for *m* elements in
    an array with 2*m* elements. Since *m* ≥ *n*, an array with 2*m* elements is enough
    to store a segment tree for *n* elements, too.
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 设 *m* 为大于或等于 *n* 的最小 2 的幂。例如，如果 *n* 是 11，则 *m* 是 16。我们可以在一个包含 2*m* 元素的数组中存储
    *m* 个元素的线段树。由于 *m* ≥ *n*，因此一个包含 2*m* 元素的数组足以存储 *n* 个元素的线段树。
- en: 'Fortunately, *m* can’t be that high: it’s at most twice the value of *n*. (The
    worst case occurs for values of *n* that are just above powers of 2\. For example,
    if *n* is 9, then *m* is 16, which is almost twice as large as 9.) Therefore,
    if we need an array of 2*m* elements and *m* is at most 2*n*, then 2*m* is at
    most 2 × 2*n* = 4*n*.'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，*m* 不会太大：它最多是 *n* 的两倍。（最坏的情况发生在 *n* 的值刚好超过 2 的幂时。例如，如果 *n* 是 9，那么 *m* 是
    16，这几乎是 9 的两倍。）因此，如果我们需要一个包含 2*m* 元素的数组，并且 *m* 最多是 2*n*，那么 2*m* 至少是 2 × 2*n* =
    4*n*。
- en: Initializing the Segments
  id: totrans-348
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 初始化区间
- en: 'In each node of the segment tree, we’ll store three things: the left index
    of its segment, the right index of its segment, and the index of the maximum element
    in the range. We’ll initialize the first two of these before moving to the third.'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 在线段树的每个节点中，我们将存储三件事：其区间的左索引、右索引和区间内最大元素的索引。我们将在处理第三项之前初始化前两项。
- en: 'Here’s the struct that we’ll use for a segment tree node:'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们将用于线段树节点的结构体：
- en: '[PRE34]'
  id: totrans-351
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'To initialize the `left` and `right` members for each node, we’ll write the
    body for the following function signature:'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 为了初始化每个节点的`left`和`right`成员，我们将编写以下函数签名的主体：
- en: '[PRE35]'
  id: totrans-353
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'We assume that `segtree` is an array with sufficient space for the segment
    tree. The `node` parameter is the root index of the segment tree; `left` and `right`
    are its segment’s left and right indices, respectively. An initial call of `init_segtree`
    would look like this:'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 我们假设`segtree`是一个具有足够空间来存储线段树的数组。`node`参数是线段树的根索引；`left`和`right`是其区间的左和右索引。`init_segtree`的初始调用如下所示：
- en: '[PRE36]'
  id: totrans-355
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Here `num_elements` is the number of elements in the underlying array (for example,
    the number of nodes in a treap).
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的`num_elements`是底层数组中的元素数量（例如，treap 中的节点数）。
- en: We can use recursion to implement `init_segtree`. If `left` and `right` are
    equal, then we have a one-element segment and there is no subdividing to do. Otherwise,
    we’re in the recursive case and have to split the segment in two. [Listing 8-14](ch08.xhtml#ch08ex014)
    provides the code.
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用递归来实现`init_segtree`。如果`left`和`right`相等，则我们有一个包含一个元素的区间，不需要进行细分。否则，我们进入递归情况，需要将区间分成两部分。[Listing
    8-14](ch08.xhtml#ch08ex014)提供了代码。
- en: '[PRE37]'
  id: totrans-358
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: '*Listing 8-14: Initializing segment tree segments*'
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: '*Listing 8-14: 初始化线段树区间*'
- en: We first store the values of `left` and `right` in the node. Then, we check
    the base case ❶, returning from the function if no children are required.
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先将`left`和`right`的值存储在节点中。然后，我们检查基本情况❶，如果不需要子节点，则从函数返回。
- en: 'If children are required, then we calculate the midpoint of the current range
    ➋. We then need to build the left segment tree for the indices from `left` to
    `mid` and the right segment tree for the indices from `mid + 1` to `right`. This
    is accomplished by two recursive calls: one for the left ➌ and one for the right
    ➍. Notice how we use `node * 2` to move to the left child and `node * 2 + 1` to
    move to the right child.'
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 如果需要子节点，我们计算当前区间的中点➋。然后，我们需要为 `left` 到 `mid` 之间的索引构建左侧段树，为 `mid + 1` 到 `right`
    之间的索引构建右侧段树。这是通过两个递归调用实现的：一个是左侧 ➌，另一个是右侧 ➍。注意，我们如何使用 `node * 2` 移动到左子节点，使用 `node
    * 2 + 1` 移动到右子节点。
- en: Filling the Segment Tree
  id: totrans-362
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 填充段树
- en: With the segment tree initialized, it’s time to add the index of the maximum
    element in its segment to each node. For an example, we’ll need both a segment
    tree and the array on which the segment tree will be based. For the segment tree,
    let’s use [Figure 8-17](ch08.xhtml#ch08fig017), and, for the array, let’s use
    the 11 priorities from “Sorting by Label” on [page 303](ch08.xhtml#sec127). [Figure
    8-18](ch08.xhtml#ch08fig018) shows the filled segment tree. The maximum index
    for each node is given below its segment endpoints.
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 初始化段树后，接下来是将每个节点所在区间内最大元素的索引添加到该节点中。作为示例，我们需要一个段树和一个数组，段树将基于这个数组。对于段树，我们使用[图
    8-17](ch08.xhtml#ch08fig017)，而对于数组，我们使用“按标签排序”中的11个优先级，见[第303页](ch08.xhtml#sec127)。[图
    8-18](ch08.xhtml#ch08fig018)展示了填充后的段树。每个节点的最大索引列在其区间端点下方。
- en: '![Image](../images/ch08fig18.jpg)'
  id: totrans-364
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/ch08fig18.jpg)'
- en: '*Figure 8-18: A segment tree and an array of priorities*'
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 8-18：一个段树和一个优先级数组*'
- en: Let’s perform a couple of quick checks. Consider the 0-0 node on the bottom
    of the tree. That’s a segment of only index 0, so the only choice for the index
    of the maximum element is 0\. This sounds like a base case to me!
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们进行几个快速检查。考虑树底部的 0-0 节点。那是一个只有索引 0 的区间，所以最大元素的索引只能是 0。这听起来像是一个基准情况！
- en: 'Now consider Node 6-10\. The node says that 7 is the index of the maximum element
    from index 6 to index 10\. Index 7 holds 56, and you can verify that this is the
    largest element in the segment. To quickly calculate this, we can use the maximum
    indices stored in 6-10’s child nodes: the left child says that 7 is the desired
    index for the 6-8 segment, and the right child says that 9 is the desired index
    for the 9-10 segment. For 6-10, then, we really have only two choices: index 7
    or index 9, the elements that we get back from these subtrees. This sounds like
    a recursive case to me!'
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 现在考虑节点 6-10。该节点表示 7 是从索引 6 到索引 10 之间最大元素的索引。索引 7 处是 56，您可以验证这是该区间内的最大元素。为了快速计算这一点，我们可以使用存储在
    6-10 的子节点中的最大索引：左子节点表示 7 是 6-8 区间的所需索引，右子节点表示 9 是 9-10 区间的所需索引。那么对于 6-10，我们实际上只有两个选择：索引
    7 或索引 9，这些是从这些子树返回的元素。这听起来像是一个递归情况！
- en: 'That’s right: we’re going to use recursion to fill the tree, much as we did
    to initialize the tree’s segments. [Listing 8-15](ch08.xhtml#ch08ex015) gives
    the code.'
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 没错：我们将使用递归来填充树，就像初始化树的区间时那样。[清单 8-15](ch08.xhtml#ch08ex015)给出了代码。
- en: '[PRE38]'
  id: totrans-369
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: '*Listing 8-15: Adding the maximums*'
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 8-15：添加最大值*'
- en: The `segtree` parameter is the array where the segment tree is stored; we assume
    that it has already been initialized by [Listing 8-14](ch08.xhtml#ch08ex014).
    The `node` parameter is the root index of the segment tree, and `treap_nodes`
    is an array of treap nodes. We need the treap nodes here so we can access their
    priorities, but otherwise this doesn’t have anything to do with treaps. You could
    easily replace the treap nodes with whatever you need for solving a given problem.
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: '`segtree` 参数是存储段树的数组；我们假设它已经通过[清单 8-14](ch08.xhtml#ch08ex014)初始化。`node` 参数是段树的根索引，`treap_nodes`
    是一个包含 treap 节点的数组。我们在这里需要 treap 节点是为了访问它们的优先级，但除此之外，这与 treap 没有关系。你可以轻松地将 treap
    节点替换为任何你需要的东西，以解决给定问题。'
- en: This function returns the index of the maximum element for the root node of
    the segment tree.
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数返回段树根节点的最大元素索引。
- en: 'The code begins with the base case check: that the node spans just a single
    index ❶. If it does, then the maximum index for the node is just its left index
    (or its right—they’re the same, after all). We then return that maximum index
    ➋.'
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 代码首先进行基准情况检查：即节点是否仅覆盖一个索引❶。如果是，那么该节点的最大索引就是它的左索引（或者右索引，它们毕竟是相同的）。然后，我们返回该最大索引➋。
- en: If we’re not in the base case, then we’re looking at a segment that spans more
    than one index. We make a recursive call to the left subtree ➌. That call figures
    out the `max_index` value for each node in that subtree and returns to us the
    `max_index` value of that subtree’s root. We then do the same for the right subtree
    ➍. Then we compare the indices we got back from those recursive calls ➎, choosing
    the one whose priority is higher, and setting this node’s `max_index` accordingly.
    The last thing to do is to return that maximum index ➏.
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们不在基础情况中，那么我们正在查看一个跨越多个索引的区间。我们递归调用左子树 ➌。该调用计算该子树中每个节点的`max_index`值，并返回该子树根节点的`max_index`值。然后，我们对右子树
    ➍ 也做同样的操作。接着，我们比较从这些递归调用中得到的索引 ➎，选择优先级更高的那个，并相应地设置该节点的`max_index`。最后，我们做的事情是返回这个最大索引
    ➏。
- en: 'Filling the tree in this way takes linear time: for each node, we do a constant
    amount of work to find its maximum index.'
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 以这种方式填充树需要线性时间：对于每个节点，我们需要做一个固定量的工作来找到它的最大索引。
- en: Querying the Segment Tree
  id: totrans-376
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 查询线段树
- en: Let’s recap. We were stymied in our attempts to solve Building Treaps because
    we didn’t have a fast way to respond to the range maximum queries. As a result,
    we’ve spent a lot of time developing segment trees, deciding how to choose the
    segments, how big to make the segment tree array, and how to store the index of
    the maximum element for each node.
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回顾一下。我们在尝试解决构建 Treap 的问题时遇到了瓶颈，因为我们没有一个快速的方法来响应区间最大查询。因此，我们花了很多时间来开发线段树，决定如何选择区间，如何设置线段树数组的大小，以及如何为每个节点存储最大元素的索引。
- en: 'Of course, all of this segment tree stuff would be for naught unless it gives
    us fast queries. Finally, then, it’s time for the payoff: getting fast queries
    using a segment tree. It’s go time! Don’t worry—it doesn’t involve much more than
    the kind of recursion we’ve been using on segment trees so far.'
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，所有这些线段树的内容如果不能提供快速查询，就毫无意义。最后，到了回报的时刻：使用线段树来获得快速查询。现在是行动时刻！别担心——它涉及的仅仅是我们至今在使用线段树时已经习惯的递归方式。
- en: 'To get a feel for this, we’ll make some sample queries on [Figure 8-18](ch08.xhtml#ch08fig018).
    Here’s that figure again:'
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 为了理解这一点，我们将对[图 8-18](ch08.xhtml#ch08fig018)进行一些示例查询。这里再次展示该图：
- en: '![Image](../images/page_314_01.jpg)'
  id: totrans-380
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/page_314_01.jpg)'
- en: 'For our first query, let’s do 6-10\. This range covers only some of what the
    root’s 0-10 segment covers, so returning the root’s maximum index wouldn’t be
    justified. Instead, we’ll ask each of the root’s children for the maximum relevant
    index and use those answers to return the maximum index overall. The root’s left
    child covers Segment 0-5, and that has no overlap at all with our 6-10 range.
    The left recursive call tells us nothing. The root’s right child, however, covers
    exactly Segment 6-10\. The recursive call on that right child will return 7, and
    that’s what we should return overall: 7 is the index of the maximum element in
    the 6-10 range.'
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的第一个查询，我们做 6-10。这个范围仅涵盖了根节点 0-10 范围的一部分，因此返回根节点的最大索引并不合适。相反，我们将询问根节点的每个子节点获取最大相关索引，并用这些答案来返回总体的最大索引。根节点的左子节点涵盖了范围
    0-5，而这个范围与我们的 6-10 完全没有重叠。左递归调用对我们没有任何帮助。然而，根节点的右子节点恰好覆盖了 6-10 范围。对右子节点的递归调用将返回
    7，这是我们应返回的结果：7 是 6-10 范围内最大元素的索引。
- en: For our second query, let’s do 3-8\. Again, we’ll ask each of the root’s children
    for the maximum relevant index—except that, this time, both children will have
    something to say, because 3-8 overlaps both 0-5 and 6-10\. The recursive call
    on the left child will return 3, and the recursive call on the right child will
    return 7\. At the root, then, all we do is compare the element at index 3 with
    the element at index 7\. The one at index 7 is higher, so that’s our answer.
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的第二个查询，我们做 3-8。同样，我们将询问根节点的每个子节点获取最大相关索引——不过这次两个子节点都会有返回值，因为 3-8 同时与 0-5
    和 6-10 有重叠。左子节点的递归调用返回 3，而右子节点的递归调用返回 7。在根节点，我们只需要将索引 3 处的元素与索引 7 处的元素进行比较。索引
    7 处的元素较大，所以这是我们的答案。
- en: I don’t normally unwind recursion, but I’ll make an exception here because I
    think it might help. Let’s further dive into the recursive call on the left subtree.
    We’re still querying 3-8, and the range of the node is 0-5\. The left child of
    0-5 is 0-2\. 0-2 doesn’t have any indices in common with our 3-8 query range,
    so it’s out. That leaves the 3-5 node to do the work. Importantly, 3-5 is completely
    contained within our desired 3-8 range, so we stop here and return 3 from the
    3-5 recursive call.
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 我通常不展开递归，但在这里我会破例，因为我认为这可能会有所帮助。让我们进一步深入左子树的递归调用。我们仍然在查询 3-8，节点的区间是 0-5。0-5
    的左子树是 0-2。0-2 与我们的 3-8 查询范围没有任何交集，所以不考虑。剩下的是 3-5 节点来完成工作。重要的是，3-5 完全包含在我们所需的 3-8
    范围内，因此我们在这里停止，并从 3-5 的递归调用中返回 3。
- en: Querying the node of a segment tree falls into one of three cases, and we have
    seen them all in our examples here. Case 1 is when the node has no indices in
    common with the query range, case 2 is when the node’s segment is completely contained
    within the query range, and case 3 is when the node’s segment contains part of
    the query range but also contains indices not in the query range.
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 查询线段树的节点会落入三种情况之一，我们在这里的示例中已经看到过它们。情况 1 是节点与查询范围没有交集，情况 2 是节点的区间完全包含在查询范围内，情况
    3 是节点的区间部分包含在查询范围内，同时也包含不在查询范围内的索引。
- en: 'I recommend pausing here, just before we look at the code, to work a few more
    query examples by hand. In particular, try the query 4-9\. You’ll notice that
    it requires tracing two long paths down the tree. This is the worst-case behavior:
    we split into two nodes near the top of the tree, and then we trace those two
    paths all the way down. Convince yourself through further examples, perhaps on
    larger segment trees, that those paths cannot further subdivide into two long
    paths of their own. So, although querying a segment tree does do a little more
    work than a heap operation—sometimes tracing two paths rather than one—it still
    accesses a small number of nodes per level, giving an *O*(log *n*) runtime.'
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 我建议在查看代码之前先暂停，在手动做几个查询示例。特别是，尝试查询 4-9。你会注意到它需要沿着树向下追踪两条长路径。这是最坏的情况：我们在树的顶部分裂成两个节点，然后沿着这两条路径一直追踪到底。通过更多的示例，尤其是更大的线段树，你可以证明这些路径不会进一步分裂成各自的两条长路径。因此，虽然查询线段树确实比堆操作做了更多的工作——有时是追踪两条路径而不是一条——但它仍然在每一层访问较少的节点，保持了*O*(log
    *n*) 的运行时间。
- en: The code for querying a segment tree is given in [Listing 8-16](ch08.xhtml#ch08ex016).
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 查询线段树的代码见[列表 8-16](ch08.xhtml#ch08ex016)。
- en: '[PRE39]'
  id: totrans-387
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: '*Listing 8-16: Querying the segment tree*'
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 8-16：查询线段树*'
- en: The function parameters are similar to those of [Listing 8-15](ch08.xhtml#ch08ex015),
    except that we’ve added the `left` and `right` indices of our query. The code
    handles each of the three cases in turn.
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 函数参数与[列表 8-15](ch08.xhtml#ch08ex015)类似，唯一不同的是我们添加了查询的`left`和`right`索引。代码依次处理这三种情况。
- en: In case 1, the node has nothing in common with the query. This holds exactly
    when the query range ends before the node’s segment starts or when the query range
    starts after the node’s segment ends ❶. We return `-1` to indicate that this node
    has no maximum index to return.
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 在情况 1 中，节点与查询没有任何交集。这个情况发生在查询范围结束在节点的区间开始之前，或者查询范围开始在节点的区间结束之后 ❶。我们返回`-1`，表示该节点没有最大索引可以返回。
- en: In case 2, the node’s segment is completely within the query range ➋. We therefore
    return the maximum index of this node’s segment.
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 在情况 2 中，节点的区间完全包含在查询范围内 ➋。因此，我们返回该节点区间的最大索引。
- en: 'That leaves case 3, where the node’s segment partially overlaps the query range.
    We make two recursive calls: one to get the maximum index from the left child
    ➌ and one to get the maximum index from the right child ➍. If one of those returns
    `-1`, then we return the other. If they both return valid indices, then we choose
    the index whose element is larger ➎.'
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: 剩下的是情况 3，节点的区间与查询范围部分重叠。我们会进行两次递归调用：一次获取左子树的最大索引 ➌，一次获取右子树的最大索引 ➍。如果其中一个返回`-1`，则返回另一个。如果它们都返回有效索引，则选择元素较大的索引
    ➎。
- en: '*Solution 2: Segment Trees*'
  id: totrans-393
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*解决方案 2：线段树*'
- en: 'Our final order of business is to alter our first solution (specifically the
    `main` function in [Listing 8-9](ch08.xhtml#ch08ex09) and the `solve` function
    in [Listing 8-13](ch08.xhtml#ch08ex013)) to use segment trees. It won’t take much:
    we’ll just make the appropriate calls to the segment tree functions that we’ve
    already written.'
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 我们最终要做的事情是修改我们第一个解决方案（特别是[清单 8-9](ch08.xhtml#ch08ex09)中的`main`函数和[清单 8-13](ch08.xhtml#ch08ex013)中的`solve`函数），以使用线段树。这不需要太多工作：我们只需要调用我们已经编写的线段树函数。
- en: '[Listing 8-17](ch08.xhtml#ch08ex017) contains the new `main` function.'
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: '[清单 8-17](ch08.xhtml#ch08ex017)包含了新的`main`函数。'
- en: '[PRE40]'
  id: totrans-396
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: '*Listing 8-17: The main function with segment trees added*'
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 8-17：添加线段树后的主函数*'
- en: The only additions are the declaration of the segment tree ❶, a call to initialize
    the segment tree’s segments ➋, a call to compute the maximum index for each segment
    tree node ➌, and a new argument to pass the segment tree along to the `solve`
    function ➍.
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: 唯一的新增部分是声明线段树 ❶，调用初始化线段树的段 ➋，调用计算每个线段树节点的最大索引 ➌，以及传递线段树给`solve`函数的新参数 ➍。
- en: The new `solve` function itself is given in [Listing 8-18](ch08.xhtml#ch08ex018).
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: 新的`solve`函数本身见于[清单 8-18](ch08.xhtml#ch08ex018)。
- en: '[PRE41]'
  id: totrans-400
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: '*Listing 8-18: Solving the problem with segment trees added*'
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 8-18：使用线段树解决问题（已添加）*'
- en: 'There’s only one substantive change: the call to `query_segtree` to implement
    the RMQ ❶!'
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 唯一实质性的变化是调用`query_segtree`来实现RMQ ❶！
- en: Phew! We had to work pretty hard there. This segment tree solution should pass
    all of the judge’s test cases within the time limit. In the end, it was worth
    it, though, because segment trees insinuate themselves into fast solutions to
    all kinds of problems.
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: 呼！我们得努力工作了一番。这个线段树的解决方案应该能在时间限制内通过所有评测用例。不过，最终它是值得的，因为线段树能够巧妙地嵌入到各种问题的快速解决方案中。
- en: Segment Trees
  id: totrans-404
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 线段树
- en: Segment trees go by several other names in the wild, including interval trees,
    tournament trees, order-statistic trees, and range query trees. It doesn’t help
    that “segment tree” is also used to refer to an entirely different data structure
    than what we’ve studied here! Perhaps through my chosen terminology I have unknowingly
    aligned myself with some particular segment of the programmer population.
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: 线段树在实际中有几个其他名称，包括区间树、比赛树、顺序统计树和范围查询树。更糟糕的是，“线段树”一词也用于指代与我们在这里学习的完全不同的数据结构！或许通过我所选的术语，我不经意地与某个特定的程序员群体取得了共识。
- en: Whatever you call them, segment trees are must-know structures for those learning
    algorithms and those interested in competitive programming. On an underlying array
    of *n* elements, you can build a segment tree in *O*(*n*) time and query a range
    in *O*(log *n*) time.
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: 无论你称它们为什么，线段树都是学习算法和有意从事竞赛编程的人的必备结构。在一个包含*n*元素的底层数组上，你可以在*O*(n)时间内构建一棵线段树，并在*O*(log
    *n*)时间内查询一个区间。
- en: In Building Treaps, we used segment trees to solve the RMQ, but segment trees
    can be used for other queries, too. If you can answer a query by quickly combining
    answers to two subqueries, then a segment tree is likely the tool of choice. What
    about a minimum range query? With a segment tree, you just take the minimum (not
    the maximum) of the children’s answers. What about a range sum query? With a segment
    tree, you just take the sum of the children’s answers.
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: 在《构建Treaps》中，我们使用线段树解决了RMQ，但线段树也可以用于其他查询。如果你能够通过快速合并两个子查询的答案来回答一个查询，那么线段树很可能是首选工具。那最小值范围查询呢？对于线段树，你只需取子节点答案的最小值（而不是最大值）。那范围求和查询呢？对于线段树，你只需取子节点答案的总和。
- en: 'Perhaps you’re wondering whether segment trees apply only when the elements
    of the underlying array remain constant through the execution of the program.
    In Building Treaps, for example, the treap nodes never changed, so there was no
    way in which our segment tree could ever become out of sync with what was stored
    in the array. Indeed, many segment tree problems share this characteristic: an
    array to be queried, not modified. However, a neat bonus feature of segment trees
    is that they can be used even when the underlying array is allowed to change.
    Problem 3 shows you how this is done, and it also shows us a new type of query
    that we haven’t seen before.'
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: 也许你会想知道，线段树是否只在底层数组元素保持不变时才能应用。例如，在构建 Treaps 中，Treap 节点从不发生变化，因此我们的线段树永远不会与数组中存储的数据不同步。事实上，许多线段树问题都有这个特点：查询一个不修改的数组。然而，线段树的一个巧妙的附加特性是，即使底层数组允许变化，它们也可以继续使用。问题
    3 向你展示了这是如何实现的，并且它还向我们展示了一种我们以前没有见过的新类型查询。
- en: '### Problem 3: Two Sum'
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: '### 问题 3：两数之和'
- en: There is no context this time—this is just a pure problem for segment trees.
    As you’ll see, we’ll need to support updates to the array, and the query we’ll
    need is not the same as the RMQ.
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: 这次没有上下文——这只是一个纯粹的线段树问题。如你所见，我们需要支持对数组的更新，且我们所需要的查询与 RMQ 不同。
- en: This is SPOJ problem `KGSS`.
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: 这是 SPOJ 问题 `KGSS`。
- en: '*The Problem*'
  id: totrans-412
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*问题描述*'
- en: We are given a sequence of integers *a*[1], *a*[2], . . . , *a*[*n*], where
    each integer is at least 0\. (Think of the sequence as an array that starts at
    index 1 rather than 0.)
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: 给定一个整数序列 *a*[1]、*a*[2]、……、*a*[*n*]，其中每个整数至少为 0。（可以把序列看作一个从索引 1 开始的数组，而不是从索引
    0 开始。）
- en: 'We need to support two types of operations on the sequence:'
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要支持对序列进行两种类型的操作：
- en: '**Update**   Given integers *x* and *y*, change *a*[*x*] to *y*.'
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: '**更新**  给定整数 *x* 和 *y*，将 *a*[*x*] 改为 *y*。'
- en: '**Query**   Given integers *x* and *y*, return the maximum sum of two elements
    in the range *a*[*x*] to *a*[*y*].'
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: '**查询**  给定整数 *x* 和 *y*，返回从 *a*[*x*] 到 *a*[*y*] 范围内两个元素的最大和。'
- en: Input
  id: totrans-417
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 输入
- en: 'The input contains one test case, consisting of the following lines:'
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: 输入包含一个测试用例，由以下几行组成：
- en: A line containing *n*, the number of elements in the sequence. *n* is between
    2 and 100,000.
  id: totrans-419
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一行包含 *n*，序列中元素的个数。*n* 的取值范围是 2 到 100,000。
- en: A line containing *n* integers, each giving one element of the sequence in order
    from *a*[1] to *a*[*n*]. Each integer is at least 0.
  id: totrans-420
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一行包含 *n* 个整数，每个整数依次表示从 *a*[1] 到 *a*[*n*] 的序列元素。每个整数至少为 0。
- en: A line containing *q*, the number of operations to be performed on the sequence.
    *q* is between 0 and 100,000.
  id: totrans-421
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一行包含 *q*，表示要在序列上执行的操作数。*q* 的取值范围是 0 到 100,000。
- en: '*q* lines, each giving one update or query operation to be performed on the
    sequence.'
  id: totrans-422
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*q* 行，每行给出一个更新或查询操作，将在序列上执行。'
- en: Here are the operations that can be performed in those *q* lines.
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是可以在 *q* 行中执行的操作。
- en: '**Update**   An update operation is specified as the letter `U`, a space, an
    integer *x*, a space, and an integer *y*. It indicates that *a*[*x*] should be
    changed to *y*. For example, `U 1 4` means that *a*[1] is to be changed from its
    current value to 4\. *x* is between 1 and *n*; *y* is at least 0\. This operation
    does not result in any output.'
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: '**更新**  更新操作由字母 `U`、一个空格、一个整数 *x*、一个空格和一个整数 *y* 组成。它表示 *a*[*x*] 应该被修改为 *y*。例如，`U
    1 4` 表示将 *a*[1] 从当前值更改为 4。*x* 的取值范围是 1 到 *n* 之间，*y* 至少为 0。此操作不产生任何输出。'
- en: '**Query**   A query operation is specified as the letter `Q`, a space, an integer
    *x*, a space, and an integer *y*. It indicates that we should output the maximum
    sum of two elements in the range *a*[*x*] to *a*[*y*]. For example, `Q 1 4` asks
    us for the maximum sum of two elements in the range *a*[1] to *a*[4]. *x* and
    *y* are between 1 and *n*, and *x* is less than *y*.'
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: '**查询**  查询操作由字母 `Q`、一个空格、一个整数 *x*、一个空格和一个整数 *y* 组成。它表示我们需要输出从 *a*[*x*] 到 *a*[*y*]
    范围内两个元素的最大和。例如，`Q 1 4` 要求我们输出从 *a*[1] 到 *a*[4] 范围内的两个元素的最大和。*x* 和 *y* 的取值范围是 1
    到 *n*，且 *x* 小于 *y*。'
- en: Output
  id: totrans-426
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 输出
- en: Output the result of each query operation, one per line.
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: 输出每个查询操作的结果，每行一个结果。
- en: The time limit for solving the test case is one second.
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: 解决该测试用例的时间限制为 1 秒。
- en: '#### *Filling the Segment Tree*'
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: '#### *填充线段树*'
- en: In Building Treaps, we needed the segment tree to give us indices of the underlying
    array, which we used to characterize the recursion and split the treap nodes.
    This time, however, there’s no reason to store indices in the segment tree. All
    we care about is the sum of elements, not the indices of those elements.
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: 在构建 Treap 时，我们需要段树给我们基础数组的索引，用于表征递归和拆分 Treap 节点。然而这次，没有理由在段树中存储索引。我们关心的是元素的和，而不是这些元素的索引。
- en: We’ll initialize the segments of our segment tree just like we did in “Initializing
    the Segments” on [page 310](ch08.xhtml#ch09lev1a). We now need the segments to
    start covering the array at index 1, not index 0, but otherwise there’s nothing
    new here. [Figure 8-19](ch08.xhtml#ch08fig019) shows a segment tree that supports
    a seven-element array. It covers indices 1 to 7, not 0 to 6, to correspond to
    the problem description.
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将像在[第 310 页](ch08.xhtml#ch09lev1a)的“初始化段”中一样初始化段树的段。现在，我们需要让段树从索引 1 开始覆盖数组，而不是从索引
    0 开始，否则没有什么新的地方。[图 8-19](ch08.xhtml#ch08fig019)展示了一个支持七元素数组的段树。它覆盖了索引 1 到 7，而不是
    0 到 6，以符合问题描述。
- en: '![Image](../images/ch08fig19.jpg)'
  id: totrans-432
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/ch08fig19.jpg)'
- en: '*Figure 8-19: A segment tree for a seven-element array*'
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 8-19：一个七元素数组的段树*'
- en: Add the code from [Listing 8-14](ch08.xhtml#ch08ex014) to your program.
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
  zh: 将[清单 8-14](ch08.xhtml#ch08ex014)中的代码添加到你的程序中。
- en: Now let’s think about how to fill each node with the maximum sum of two elements
    in its segment. Suppose that we’ve already found the maximum sum of two elements
    for Node 1-2 and already found the maximum sum of two elements for Node 3-4\.
    We want to find the maximum sum of two elements for Node 1-4\. How do we do this?
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们考虑如何填充每个节点，使其包含其段内两个元素的最大和。假设我们已经找到了节点 1-2 中两个元素的最大和，并且已经找到了节点 3-4 中两个元素的最大和。我们想要找出节点
    1-4 中两个元素的最大和。我们该怎么做呢？
- en: Life was good when we were solving the RMQ, because the maximum for a node is
    just the maximum of its children. For example, if the maximum value in the left
    subtree is 10 and the maximum in the right subtree is 6, then the maximum for
    their parent node is 10\. No surprises there. In contrast, with this “maximum
    sum of two elements” segment tree, something weird happens.
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在解决 RMQ 时，生活是轻松的，因为一个节点的最大值就是其子节点的最大值。例如，如果左子树中的最大值是 10，右子树中的最大值是 6，那么它们的父节点的最大值就是
    10。没有什么意外。相比之下，使用这个“两个元素的最大和”段树时，情况有点奇怪。
- en: 'Suppose we have these four sequence elements: 10, 8, 6, and 15\. The maximum
    sum of two elements in Segment 1-2 is 18, and the maximum sum of two elements
    in Segment 3-4 is 21\. Is 18 the answer for Segment 1-4, or is 21? Neither is
    correct! The answer is 10 + 15 = 25\. We can’t conjure up that 25 if all we know
    is the 18 from the left and 21 from the right. We need the left and right children
    to tell us more about their segment—more than just “Oh hey, here’s my maximum
    sum of two elements.”'
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们有这四个序列元素：10、8、6 和 15。段 1-2 中两个元素的最大和是 18，而段 3-4 中两个元素的最大和是 21。那段 1-4 的答案是
    18 还是 21？都不对！答案是 10 + 15 = 25。如果我们只知道左边的 18 和右边的 21，我们无法推算出 25。我们需要左右子节点告诉我们更多关于它们段的信息——不仅仅是“嘿，这是我两个元素的最大和”。
- en: 'To be clear, sometimes getting back just the maximum sum of two elements from
    each child *is* enough. Consider this sequence: 10, 8, 6, and 4\. The maximum
    sum of two elements for Segment 1-2 is 18, and the maximum sum of two elements
    in Segment 3-4 is 10\. The maximum sum of two elements in 1-4 is 18, which happens
    to be the answer from its child segment 1-2—but that was lucky!'
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
  zh: 需要明确的是，有时候仅仅从每个子节点获取两个元素的最大和*确实*足够了。考虑这个序列：10、8、6 和 4。段 1-2 中两个元素的最大和是 18，而段
    3-4 中两个元素的最大和是 10。段 1-4 中两个元素的最大和是 18，恰好是其子段 1-2 的答案——但那是运气好！
- en: 'There are at most three options for the maximum sum of two elements for a segment.
    (There are fewer than three options if a node’s child doesn’t have a valid maximum
    sum.) Those options are as follows:'
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
  zh: 一个段的两个元素的最大和至多有三种选择。（如果节点的子节点没有有效的最大和，则选项少于三种。）这些选项如下：
- en: '**Option 1**   The maximum sum is in the left child. This is like the lucky
    case that we just did. We get the answer from what the left child tells us.'
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
  zh: '**选项 1**   最大和在左子节点。这就像我们刚才做的幸运情况。我们从左子节点得到答案。'
- en: '**Option 2**   The maximum sum is in the right child. This is another lucky
    case, where the answer is what the right child tells us.'
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
  zh: '**选项 2**   最大和在右子节点。这是另一个幸运的情况，答案就是右子节点给我们的。'
- en: '**Option 3**   The maximum sum includes one element from the left child and
    one element from the right child. This one requires more work, because the answer
    is not one of the maximums of our children. This is where we need more information
    from the children.'
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
  zh: '**选项 3**   最大和包括来自左子节点和右子节点的一个元素。这需要更多的工作，因为答案不是子节点的最大和之一。这正是我们需要从子节点获得更多信息的地方。'
- en: If the maximum sum of two elements for some segment consists of one element
    from the left and one from the right, then it must use the maximum element from
    the left and the maximum element from the right. Let’s return to the sequence
    10, 8, 6, and 15\. The maximum sum here is an example that involves one element
    from the left (10) and one element from the right (15). Notice that these are
    the largest elements in the left and right segments, respectively. There’s no
    way to take an element from each side and do better than this.
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
  zh: 如果某段的最大两元素和由左侧的一个元素和右侧的一个元素组成，那么它必须使用左侧的最大元素和右侧的最大元素。让我们回到序列 10、8、6 和 15。这里的最大和是一个例子，涉及左侧的一个元素（10）和右侧的一个元素（15）。注意，这些分别是左侧和右侧段中的最大元素。没有办法从每一侧取一个元素，比这更好。
- en: Now we see what the segment tree nodes have to tell us. In addition to what
    the outside world cares about—the maximum sum of two elements—we also need the
    maximum element on its own. Combined, these two pieces of information about child
    segments enable us to fill in the information for the parent segment.
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们看到段树节点提供了什么信息。除了外界关心的——两个元素的最大和——我们还需要单独的最大元素。这两部分关于子段的信息结合起来，帮助我们填写父段的信息。
- en: '[Figure 8-20](ch08.xhtml#ch08fig020) shows an example segment tree built for
    an array. Notice that each node contains both maxsum (the maximum sum of two elements)
    and maxelm (the maximum element).'
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 8-20](ch08.xhtml#ch08fig020)展示了为数组构建的一个段树示例。注意，每个节点包含 maxsum（两个元素的最大和）和
    maxelm（最大元素）。'
- en: '![Image](../images/ch08fig20.jpg)'
  id: totrans-446
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/ch08fig20.jpg)'
- en: '*Figure 8-20: A segment tree and its corresponding array*'
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 8-20：段树及其对应的数组*'
- en: 'Computing the maximum element for each node is something that we know how to
    do: it’s just the RMQ problem that we solved in Building Treaps.'
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
  zh: 计算每个节点的最大元素是我们知道如何做的：这正是我们在构建 Treaps 时解决的 RMQ 问题。
- en: That leaves the maximum sum of two elements for each node. To begin, we set
    the maximum sum for the nodes with one-element segments, such as 1-1, 2-2, and
    so on, to the special value –1\. The reason we do this is that there aren’t even
    two elements in these segments to choose from! The –1 alerts us that the parent’s
    maximum sum cannot be the maximum sum of this child.
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
  zh: 这就留下了每个节点的最大两元素和。首先，我们将包含单元素段（如1-1、2-2等）的节点的最大和设置为特殊值 –1。这样做的原因是，这些段中甚至没有两个元素可以选择！–1提醒我们，父节点的最大和不能是这个子节点的最大和。
- en: The maximum sum for each other node is set based on the maximum sums of its
    children. Consider Node 1-7\. There are three options for its maximum sum. We
    could take the maximum sum 25 from the left, or we could take the maximum sum
    12 from the right, or we could take the maximum element 15 from the left and the
    maximum element 9 from the right to get 15 + 9 = 24\. Of these, 25 is the largest
    number, so that’s what we choose.
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
  zh: 每个其他节点的最大和是基于其子节点的最大和来设置的。考虑节点 1-7。它有三个选择来获得最大和。我们可以从左子节点获得最大和 25，或者从右子节点获得最大和
    12，或者从左子节点获得最大元素 15，右子节点获得最大元素 9，然后将两者加起来得到 15 + 9 = 24。在这三者中，25 是最大的数字，所以我们选择它。
- en: We make a special case of the fake –1 maximum sum values to highlight that those
    cannot be taken as options for the maximum sum of the parent node. Look out for
    this in the upcoming code.
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
  zh: 我们特别处理假设的 –1 最大和值，以突出显示这些值不能作为父节点最大和的选项。请留意接下来的代码。
- en: 'We’ll use a struct for the segment tree nodes:'
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用一个结构体来表示段树节点：
- en: '[PRE42]'
  id: totrans-453
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'We’ll use another struct for what we will return from the `fill_segtree` and
    `query_segtree` functions:'
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用另一个结构体来表示我们从 `fill_segtree` 和 `query_segtree` 函数中返回的内容：
- en: '[PRE43]'
  id: totrans-455
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: We need `node_info` because it lets us return both the maximum sum and the maximum
    element; returning one integer, without the struct, would not be sufficient.
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要 `node_info`，因为它允许我们同时返回最大和和最大元素；如果没有结构体，只返回一个整数是远远不够的。
- en: The code for computing the maximum sum and the maximum element for each segment
    is given in [Listing 8-19](ch08.xhtml#ch08ex019).
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
  zh: 用于计算每个段的最大和和最大元素的代码见[列表 8-19](ch08.xhtml#ch08ex019)。
- en: '[PRE44]'
  id: totrans-458
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: '*Listing 8-19: Adding the maximum sum and maximum element*'
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 8-19：添加最大和最大元素*'
- en: When the segment contains just one element, we’re in the base case ❶. We set
    the maximum sum to the special `-1` value, which indicates that there is no valid
    sum of two elements here, and we set the maximum element to the only element in
    the segment. We then return the maximum sum and maximum element ➋.
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
  zh: 当区间仅包含一个元素时，我们进入基准情况 ❶。我们将最大和设置为特殊的`-1`值，这表示此处没有有效的两个元素的和，并且我们将最大元素设置为区间内的唯一元素。然后我们返回最大和和最大元素
    ➋。
- en: Otherwise, we’re in the recursive case. We use `left_info` to hold the information
    for the left segment and `right_info` to hold the information for the right segment.
    Each of those variables is initialized using a recursive call ➌.
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
  zh: 否则，我们进入递归情况。我们使用`left_info`来保存左区间的信息，使用`right_info`来保存右区间的信息。每个变量都通过递归调用进行初始化
    ➌。
- en: As we discussed, the maximum element in a segment is just the maximum of the
    maximum element in the left and the maximum element in the right ➍.
  id: totrans-462
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所讨论的，区间内的最大元素就是左侧区间的最大元素和右侧区间的最大元素中的最大值 ➍。
- en: Now consider the maximum sum of two elements. If neither of the children has
    a maximum sum ➎, then we know that each child’s segment contains just one element.
    This parent therefore has only two elements in its segment, and adding up those
    elements is the only choice for the maximum sum of two elements ➏.
  id: totrans-463
  prefs: []
  type: TYPE_NORMAL
  zh: 现在考虑两个元素的最大和。如果两个子节点都没有最大和 ➎，那么我们知道每个子节点的区间只包含一个元素。此父节点因此只有两个元素在其区间内，将这些元素相加是得到最大和的唯一选择
    ➏。
- en: Next, what do we do if the left child has only one element and the right child
    has more than one element ❼? Well, now we have two options for the maximum sum
    for the parent. The first option is to add the maximum elements from each half.
    The second is to take the maximum sum from the right segment. We use `max` to
    take the best of these two. The case when the right child has only one element
    and left child has more than one element is analogous ❽.
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，如果左子节点只有一个元素而右子节点有多个元素 ❼，我们该怎么做呢？此时我们有两个选择来确定父节点的最大和。第一个选择是将每一半的最大元素相加。第二个选择是取右区间的最大和。我们使用`max`来选择这两者中的最佳方案。当右子节点只有一个元素，而左子节点有多个元素时，情况类似
    ❽。
- en: 'The final case is when both children have more than one element ❾. Now we have
    three options: add the maximum elements from each half, take the maximum sum from
    the left, or take the maximum sum from the right.'
  id: totrans-465
  prefs: []
  type: TYPE_NORMAL
  zh: 最后的情况是当两个子节点都有多个元素 ❾。此时我们有三种选择：从每一半中添加最大元素，取左区间的最大和，或取右区间的最大和。
- en: '*Querying the Segment Tree*'
  id: totrans-466
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*查询区间树*'
- en: The work we just did to fill in the segment information is going to pay off
    again, right now, for the code to query the segment tree. See [Listing 8-20](ch08.xhtml#ch08ex020).
  id: totrans-467
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚做的填充区间信息的工作现在将在查询区间树的代码中再次派上用场。见[清单 8-20](ch08.xhtml#ch08ex020)。
- en: '[PRE45]'
  id: totrans-468
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: '*Listing 8-20: Querying the segment tree*'
  id: totrans-469
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 8-20：查询区间树*'
- en: The structure of this code parallels the RMQ code in [Listing 8-16](ch08.xhtml#ch08ex016).
    If the node’s segment has nothing in common with the query range ❶, we return
    a struct where both the maximum sum and maximum element are `-1`. We can use this
    special value of `-1` for the maximum element to tell us that there is no information
    available from a recursive call.
  id: totrans-470
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码的结构与[清单 8-16](ch08.xhtml#ch08ex016)中的RMQ代码相似。如果节点的区间与查询范围完全没有交集 ❶，我们返回一个结构，其中最大和和最大元素均为`-1`。我们可以使用`-1`作为最大元素的特殊值，告诉我们没有来自递归调用的信息。
- en: If the node’s segment is completely within the query range ➋, then we return
    the maximum sum and maximum element for this node.
  id: totrans-471
  prefs: []
  type: TYPE_NORMAL
  zh: 如果节点的区间完全位于查询范围内 ➋，那么我们返回该节点的最大和和最大元素。
- en: Finally, if the node’s segment partially overlaps the query range, then we follow
    the same logic as when we filled in the segment information in [Listing 8-19](ch08.xhtml#ch08ex019).
  id: totrans-472
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，如果节点的区间与查询范围部分重叠，那么我们遵循与在[清单 8-19](ch08.xhtml#ch08ex019)中填充区间信息时相同的逻辑。
- en: '*Updating the Segment Tree*'
  id: totrans-473
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*更新区间树*'
- en: When an element of the sequence array is updated, we have to adjust the segment
    tree to keep pace. Otherwise, queries on the segment tree would use now-stale
    array elements and may therefore yield results at odds with what’s currently in
    the array.
  id: totrans-474
  prefs: []
  type: TYPE_NORMAL
  zh: 当序列数组的一个元素被更新时，我们必须调整区间树以保持同步。否则，对区间树的查询将使用现在已经过时的数组元素，因此可能会得出与当前数组内容不符的结果。
- en: One option is to start from scratch and ignore whatever segment information
    is already in the tree. We can do that by rerunning [Listing 8-19](ch08.xhtml#ch08ex019)
    each time an array element is updated. That would certainly bring the segment
    tree back up to date, so correctness is not a concern.
  id: totrans-475
  prefs: []
  type: TYPE_NORMAL
  zh: 一种选择是从头开始，忽略树中已有的任何段信息。我们可以通过每次更新数组元素时重新执行[代码清单 8-19](ch08.xhtml#ch08ex019)来实现。这当然可以使段树恢复到最新状态，因此正确性不是问题。
- en: 'Efficiency is a concern, though! Rebuilding the segment tree takes *O*(*n*)
    time. All it would take to tank our performance is a stream of *q* update operations,
    with no query operations at all. That would force *n* work to be done a total
    of *q* times, for *O*(*nq*) performance. That’s especially grim if you think about
    the cost of updates with no segment tree at all: they’re constant-time operations
    on an array! We can’t afford to trade constant time for linear time. However,
    we *can* afford to trade constant time for logarithmic time, because the latter
    is very close to constant time.'
  id: totrans-476
  prefs: []
  type: TYPE_NORMAL
  zh: 效率是一个问题，然而！重建段树需要 *O*(*n*) 时间。若仅有 *q* 次更新操作，没有任何查询操作，就可能大大降低我们的性能。这样，*n* 的工作需要执行
    *q* 次，总的性能复杂度为 *O*(*nq*)。如果你考虑到没有段树时更新的成本，尤其让人沮丧：它们在数组上是常数时间操作！我们无法承受将常数时间换成线性时间。然而，我们
    *可以* 将常数时间换成对数时间，因为后者非常接近常数时间。
- en: The way we escape the linear-time work is to realize that only a small number
    of segment tree nodes need to be updated when an element of the array is updated.
    Dismantling the entire tree for a single update is a gross overreaction.
  id: totrans-477
  prefs: []
  type: TYPE_NORMAL
  zh: 我们逃避线性时间工作的方式是认识到，在更新数组的某个元素时，只需要更新少量的段树节点。拆卸整个树来进行一次更新，实在是过度反应了。
- en: 'Let me explain what I mean by example. Here again is [Figure 8-20](ch08.xhtml#ch08fig020):'
  id: totrans-478
  prefs: []
  type: TYPE_NORMAL
  zh: 让我通过例子来解释我的意思。这里再次展示[图 8-20](ch08.xhtml#ch08fig020)：
- en: '![Image](../images/unch08fig04.jpg)'
  id: totrans-479
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/unch08fig04.jpg)'
- en: Now imagine the next operation is `U 4 1`, which means that index 4 of the sequence
    should be changed to value 1 (as the 15 that was there is gone). The new segment
    tree and array are shown in [Figure 8-21](ch08.xhtml#ch08fig021).
  id: totrans-480
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，假设下一个操作是 `U 4 1`，意味着序列的索引 4 应该被更改为值 1（原本是 15）。新的段树和数组如 [图 8-21](ch08.xhtml#ch08fig021)
    所示。
- en: '![Image](../images/ch08fig21.jpg)'
  id: totrans-481
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/ch08fig21.jpg)'
- en: '*Figure 8-21: A segment tree and its corresponding array following an array
    update*'
  id: totrans-482
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 8-21：段树及其对应的数组，展示数组更新后的状态*'
- en: 'Notice that only three nodes have changed. Node 4-4 has to change, of course,
    because the only element in its segment changed. However, the impact of that change
    can’t ripple too far: the only other nodes that can change are ancestors of 4-4,
    because those are the only other nodes that have an index of 4 in their segments!
    Indeed, in this example, you can confirm that the only other nodes that changed
    are the three ancestors 3-4, 1-4, and 1-7\. At worst, then, we go from a leaf
    of the tree to the root, updating nodes along that path. Since the height of the
    tree is *O*(log *n*), this path has only *O*(log *n*) nodes.'
  id: totrans-483
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，只有三个节点发生了变化。节点 4-4 必须变化，因为它所在段的唯一元素发生了改变。然而，这个变化的影响不能扩展得太远：唯一能够变化的节点是 4-4
    的祖先节点，因为只有它们的段中才包含索引 4！实际上，在这个例子中，你可以确认，发生变化的节点仅为三个祖先节点：3-4、1-4 和 1-7。因此，最糟糕的情况下，我们从树的叶子节点走到根节点，沿路径更新节点。由于树的高度为
    *O*(log *n*)，所以该路径上只有 *O*(log *n*) 个节点。
- en: As long as we don’t waste time on recursion through inoperative parts of the
    segment tree, we will end up with an *O*(log *n*) update procedure. [Listing 8-21](ch08.xhtml#ch08ex021)
    gives the code.
  id: totrans-484
  prefs: []
  type: TYPE_NORMAL
  zh: 只要我们不在段树中对无效部分进行递归浪费时间，最终的更新过程将是 *O*(log *n*)。[代码清单 8-21](ch08.xhtml#ch08ex021)
    给出了相关代码。
- en: '[PRE46]'
  id: totrans-485
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: '*Listing 8-21: Updating the segment tree*'
  id: totrans-486
  prefs: []
  type: TYPE_NORMAL
  zh: '*代码清单 8-21：更新段树*'
- en: This function is designed to be called *after* the array element at the given
    `index` has been updated. Every call of this function is required to ensure that
    `node` is the root of a segment tree whose segment contains `index`.
  id: totrans-487
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数设计为在给定 `index` 位置的数组元素已经更新之后调用。每次调用此函数时，必须确保 `node` 是一个段树的根节点，并且该段树的段包含
    `index`。
- en: 'Our base case is when the segment contains just one element ❶. Since we never
    make a recursive call unless `index` is in the node’s segment, we know this segment
    contains exactly our desired index. We thus update `max_element` of the node to
    whatever is now stored at `seq[index]`. We don’t update `max_sum`: it’s staying
    at `-1`, because this segment still has just one element in it.'
  id: totrans-488
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的基本情况是当线段仅包含一个元素 ❶。由于我们不会进行递归调用，除非`index`在节点的线段内，因此我们知道这个线段正好包含我们所需的索引。因此，我们将节点的`max_element`更新为`seq[index]`中当前存储的值。我们不更新`max_sum`：它保持为`-1`，因为这个线段仍然只有一个元素。
- en: Now suppose we’re not in the base case. We have a node, and we know that exactly
    one of its elements, `index`, has been updated. There’s absolutely no reason,
    then, to make *two* recursive calls, since only one of the node’s children can
    house the updated element. If `index` is in the left child, then we want to make
    a recursive call on the left child to update the left subtree. If `index` is in
    the right child, then we want to make a recursive call on the right child to update
    the right subtree.
  id: totrans-489
  prefs: []
  type: TYPE_NORMAL
  zh: 现在假设我们不在基本情况中。我们有一个节点，并且我们知道其元素之一——`index`——已经被更新。那么，完全没有理由进行*两次*递归调用，因为节点的子节点中只有一个可以包含更新后的元素。如果`index`在左子节点中，那么我们想在左子节点上进行递归调用来更新左子树。如果`index`在右子节点中，那么我们想在右子节点上进行递归调用来更新右子树。
- en: To determine which child `index` is in, we compare it to the rightmost index
    of the left child. If `index` comes before the left child’s segment ends ➋, then
    we need a recursive call on the left; otherwise, we need a recursive call on the
    right.
  id: totrans-490
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确定`index`属于哪个子节点，我们将其与左子节点的最右端索引进行比较。如果`index`在左子节点的段落结束之前 ➋，那么我们需要在左侧进行递归调用；否则，我们需要在右侧进行递归调用。
- en: Let’s talk a little about the case where we make a recursive call on the left
    ➌; the `else` branch, where we make a recursive call on the right, is similar.
    We make the recursive call that updates the left subtree and returns to us the
    information for that updated segment. For the right subtree, we just inherit what
    was there before ➍—there’s no update occurring there, so nothing can change.
  id: totrans-491
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们稍微谈谈在左侧进行递归调用的情况➌；右侧递归调用的`else`分支是类似的。我们进行递归调用来更新左子树，并返回更新后的信息。对于右子树，我们只需继承原来的内容
    ➍——那里没有更新发生，所以不会有变化。
- en: The rest of the code parallels that of [Listing 8-19](ch08.xhtml#ch08ex019).
  id: totrans-492
  prefs: []
  type: TYPE_NORMAL
  zh: 剩下的代码与[清单 8-19](ch08.xhtml#ch08ex019)类似。
- en: '*The main Function*'
  id: totrans-493
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*主要功能*'
- en: We’re now ready to use our souped-up segment tree to solve the problem. The
    code for the `main` function is given in [Listing 8-22](ch08.xhtml#ch08ex022).
  id: totrans-494
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在准备使用我们改进过的线段树来解决问题。`main`函数的代码在[清单 8-22](ch08.xhtml#ch08ex022)中给出。
- en: '[PRE47]'
  id: totrans-495
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: '*Listing 8-22: The main function for reading input and solving the problem*'
  id: totrans-496
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 8-22：用于读取输入并解决问题的主要函数*'
- en: The only thing to highlight here is the logic for processing the operations.
    If the next operation is an update operation ❶, we respond by updating the array
    element and then updating the segment tree. Otherwise, the operation is a query
    operation ➋, and we respond by querying the segment tree.
  id: totrans-497
  prefs: []
  type: TYPE_NORMAL
  zh: 这里唯一需要强调的是处理操作的逻辑。如果下一个操作是更新操作 ❶，我们通过更新数组元素并随后更新线段树来响应。否则，操作是查询操作 ➋，我们通过查询线段树来响应。
- en: It is time to submit the code. The judge should enjoy this fast, segment-tree-based
    solution.
  id: totrans-498
  prefs: []
  type: TYPE_NORMAL
  zh: 是时候提交代码了。评测系统应该会喜欢这个快速、基于线段树的解决方案。
- en: Summary
  id: totrans-499
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we studied how to implement and use heaps and segment trees.
    Like any useful data structure, these data structures support a small number of
    highly efficient operations. It’s not often that a data structure solves a problem
    on its own. More typically, you already have an algorithm whose speed is reasonable,
    and a data structure helps you make it even faster. For example, our implementation
    of Dijkstra’s algorithm in [Chapter 6](ch06.xhtml) already does quite well, but
    add a min-heap and it does even better.
  id: totrans-500
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了如何实现和使用堆和线段树。像所有有用的数据结构一样，这些数据结构支持少数几个高效的操作。通常，数据结构并不会单独解决问题。更典型的是，你已经有了一个速度合理的算法，而数据结构帮助你使其更高效。例如，我们在[第6章](ch06.xhtml)中实现的Dijkstra算法已经做得很好，但如果加上一个最小堆，它会做得更好。
- en: Whenever you’re performing the same kind of operation over and over, you should
    seek out an opportunity to bolster your algorithm with a data structure. Are you
    searching for specified items in an array? Then hash tables are called for. Are
    you trying to find the maximum or minimum? Then heaps will do the trick. Are you
    querying segments of an array? Then employ segment trees. What about deciding
    whether two elements are in the same set? Well now, you’ll have to read the next
    chapter for that one!
  id: totrans-501
  prefs: []
  type: TYPE_NORMAL
  zh: 每当你重复执行相同类型的操作时，你应该寻找机会通过数据结构来增强你的算法。你是在数组中查找指定的元素吗？那么哈希表就是你需要的。你是在寻找最大值或最小值吗？那就用堆吧。你是在查询数组的区间吗？那就使用线段树。那如果你要判断两个元素是否在同一集合中呢？嗯，那你得看下一章了！
- en: Notes
  id: totrans-502
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注释
- en: Supermarket Promotion is originally from the 2000 Polish Olympiad in Informatics,
    Stage 3\. Building Treaps is originally from the 2004 Ulm University Local Contest.
    Two Sum is originally from the 2009 Kurukshetra Online Programming Contest.
  id: totrans-503
  prefs: []
  type: TYPE_NORMAL
  zh: 超市促销问题最初来自2000年波兰信息学奥林匹克竞赛，第三阶段。构建Treap最初来自2004年乌尔姆大学本地竞赛。两数之和最初来自2009年库鲁克舍特拉在线编程竞赛。
- en: For more about segment trees and many other data structures, I recommend Matt
    Fontaine’s *Algorithms Live!* series of videos (see *[http://algorithms-live.blogspot.com](http://algorithms-live.blogspot.com)*).
    Matt’s segment tree video gave me the idea to explicitly store `left` and `right`
    segment indices in each node. (Most of the segment tree code you’ll see out there
    doesn’t do this, instead passing those indices around as additional function parameters
    that I always have trouble keeping straight.)
  id: totrans-504
  prefs: []
  type: TYPE_NORMAL
  zh: 关于线段树和许多其他数据结构的更多内容，我推荐Matt Fontaine的*Algorithms Live!*系列视频（见* [http://algorithms-live.blogspot.com](http://algorithms-live.blogspot.com)
    *）。Matt的线段树视频让我想到了在每个节点中显式地存储`left`和`right`区间索引。（你看到的大部分线段树代码都没有这样做，而是将这些索引作为额外的函数参数传递，这让我总是很难理清楚。）
