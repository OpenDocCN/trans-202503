- en: '8'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: HEAPS AND SEGMENT TREES
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/common1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Data structures organize our data to make it possible to accelerate certain
    operations. For example, in [Chapter 1](ch01.xhtml), we learned about hash tables,
    which speed up the search for a specified element in a collection.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we’ll learn two new data structures: heaps and segment trees.
    A heap is what you want whenever you need the maximum (or minimum) element; a
    segment tree is what you want when you need to perform queries on pieces of an
    array. In our first problem, we’ll see how heaps turn slow maximum computations
    into fast heap operations; in our second and third problems, we’ll see how segment
    trees do similarly for more general array queries.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Problem 1: Supermarket Promotion'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This is SPOJ problem `PRO`.
  prefs: []
  type: TYPE_NORMAL
- en: '*The Problem*'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In a supermarket, each shopper picks up the items that they want to buy, then
    goes through the checkout to pay for their items. Once a shopper pays, the shopper
    is given a receipt that has the total cost of what they purchased. For example,
    if someone picks up some items and the total is $18, then the cost written on
    their receipt is $18\. We don’t care about the cost of individual items.
  prefs: []
  type: TYPE_NORMAL
- en: 'The supermarket is having a promotion that will last *n* days. During the promotion,
    each receipt is placed in a ballot box. At the end of each day, two receipts are
    removed from the ballot box: one of maximum cost *x* and one of minimum cost *y*.
    The shopper who produced the maximum-cost receipt gets a prize worth *x* – *y*
    dollars. (Don’t worry about how the supermarket identifies that shopper based
    on their receipt.) The *x* and *y* receipts are then gone, never to reappear,
    but all other receipts from that day stay in the ballot box (and may be removed
    on some future day).'
  prefs: []
  type: TYPE_NORMAL
- en: It’s guaranteed that there will be at least two receipts in the ballot box at
    the end of each day.
  prefs: []
  type: TYPE_NORMAL
- en: Our task is to compute the total prize money that will be given out by the supermarket
    as part of the promotion.
  prefs: []
  type: TYPE_NORMAL
- en: Input
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'The input contains one test case, consisting of the following lines:'
  prefs: []
  type: TYPE_NORMAL
- en: A line containing *n*, the duration in days of the promotion. *n* is between
    1 and 5,000.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*n* lines, one for each day of the promotion. Each such line begins with integer
    *k*, indicating that there are *k* receipts on this day. The line then contains
    *k* integers, representing the cost of each receipt for this day. *k* is between
    0 and 100,000; each receipt cost is a positive number that’s at most 1,000,000.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The total number of receipts produced throughout the entire promotion is at
    most 1,000,000.
  prefs: []
  type: TYPE_NORMAL
- en: Output
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Output the total prize money given out by the supermarket.
  prefs: []
  type: TYPE_NORMAL
- en: The time limit for solving the test case is 0.6 seconds.
  prefs: []
  type: TYPE_NORMAL
- en: '*Solution 1: Maximum and Minimum in an Array*'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: For many of the problems in this book, it’s a challenge to devise a correct
    algorithm, let alone an efficient one. At least for the current problem, correctness
    doesn’t seem so hard. Determining the prize on each day simply involves searching
    the ballot box for the maximum cost and then searching again for the minimum cost.
    Maybe that will be efficient enough, too?
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s look at a test case:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Remember that the first number on each line of receipts tells us the number
    of receipts and is not itself a receipt cost. After the first day and before removing
    any receipts, we have these 16 receipt costs:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The maximum receipt is 91 and the minimum is 2\. Those two receipts are removed,
    and they contribute 91 – 2 = 89 in prize money. Here’s what’s left after removing
    91 and 2:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we move on to the second day. We add the 57 to get:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The maximum now is 85 and the minimum is 5, so that’s 85 – 5 = 80 added to the
    prize money. The total prize money for this promotion is therefore 89 + 80 = 169.
  prefs: []
  type: TYPE_NORMAL
- en: One implementation idea involves storing the receipts in an array. To remove
    a receipt, we could literally remove it, as we just did. That would involve shifting
    later receipts to the left, to fill the vacated array entry. But it’s simpler
    to keep the receipts where they are and associate a `used` flag with each receipt.
    If `used` is `0`, then the receipt hasn’t been used yet; if it’s `1`, then it
    has been used and is logically removed (so we had better ignore it from here on
    out).
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are a couple of constants and the `receipt` struct:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: We’re going to need helper functions to identify and remove the maximum receipt
    cost and minimum receipt cost, so let’s knock those out now. [Listing 8-1](ch08.xhtml#ch08ex01)
    gives the code.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 8-1: Finding and removing maximum and minimum costs*'
  prefs: []
  type: TYPE_NORMAL
- en: The standard term for the operation that removes and returns the maximum value
    is *extract-max*. Likewise, the operation that removes and returns the minimum
    value is called *extract-min*.
  prefs: []
  type: TYPE_NORMAL
- en: These functions operate very similarly. The `extract_max` function sets `max`
    to `-1` ❶, which is smaller than any receipt cost. When it finds a “real” receipt
    cost, `max` will be set to that cost, and from then on it will track the largest
    cost found so far. Similar reasoning explains why `extract_min` initializes `min`
    with a cost higher than any valid cost ➍. Notice that, in each function, the only
    receipts that are considered are those whose `used` value is `0` ➋ ➎ and that
    each function sets the identified receipt’s `used` value to `1` ➌ ➏.
  prefs: []
  type: TYPE_NORMAL
- en: 'With those two helper functions in hand, we can write a `main` function to
    read the input and solve the problem. One interesting aspect here is that reading
    input and solving the problem are interleaved: we read a little input (the receipts
    for the first day), calculate the prize for that day, read a little more input
    (the receipts for the second day), calculate the prize for that day, and so on.
    This is implemented in [Listing 8-2](ch08.xhtml#ch08ex02).'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 8-2: The main function for reading input and solving the problem*'
  prefs: []
  type: TYPE_NORMAL
- en: The only gotcha here is the type of the `total_prizes` variable ❶. An integer
    or long integer may not be enough. A typical long integer can hold values up to
    about 4 billion; the total prize money could be up to 5,000 × 1,000,000, which
    is 5 billion. Long long integers can hold integers that are billions, trillions,
    and way beyond that, so we’re certainly safe using a long long integer here.
  prefs: []
  type: TYPE_NORMAL
- en: The outer `for` loop runs once for each day, and the inner `for` loop reads
    each receipt for the day. Once each day’s receipts have been read, we extract
    the maximum receipt, extract the minimum receipt, and update the total prize money.
  prefs: []
  type: TYPE_NORMAL
- en: This is a complete solution to the problem. It correctly outputs `169` for our
    sample test case, and you should spend some time convincing yourself that it’s
    correct in general.
  prefs: []
  type: TYPE_NORMAL
- en: Unfortunately, it’s too slow, and you would get a “Time-Limit Exceeded” error
    from the judge.
  prefs: []
  type: TYPE_NORMAL
- en: We can explore the inefficiency by thinking about a worst-case test case. Let’s
    say that the promotion lasts 5,000 days and that on each of the first 10 days
    we get 100,000 receipts. After the tenth day, we’ll have about a million receipts
    in the array. Finding the maximum and minimum involves a linear scan through the
    array. However, since we remove only two receipts per day, we’ll have close to
    a million receipts in there all the way through the promotion. So, we’re looking
    at 5,000 days, almost all of which require about a million steps to find the maximum
    and another million steps to find the minimum. That’s about 5,000 × 2,000,000,
    or 10 billion, steps! There is no chance of solving this, given the stringent
    time limit. If only we could speed up those maximum and minimum computations.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s quickly disarm sorting as a possible improvement here. If we kept the
    receipts array sorted, then finding and removing the maximum would take constant
    time, as the maximum would be at the rightmost index. Finding the minimum would
    take constant time, too, but it would take linear time to remove the minimum since
    we’d have to shift all other elements to the left. Sorting also ruins the efficiency
    of adding a receipt: when we’re not sorting, we can just plunk it at the end of
    the array, but when sorting we have to find its proper position. No, sorting isn’t
    the answer. The answer is heaps.'
  prefs: []
  type: TYPE_NORMAL
- en: '#### *Max-Heaps*'
  prefs: []
  type: TYPE_NORMAL
- en: We’ll begin by focusing on how to quickly find and extract the maximum element
    from an array. That’s only solving half the problem—we need to be able to do this
    for the minimum, too—but we’ll get to that.
  prefs: []
  type: TYPE_NORMAL
- en: Finding the Maximum
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Take a look at the tree in [Figure 8-1](ch08.xhtml#ch08fig01). It has 13 nodes
    corresponding to the following 13 receipts (the first 13 receipts in our sample
    test case): 6, 63, 16, 82, 25, 2, 43, 5, 17, 10, 56, 85, and 38.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/ch08fig01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 8-1: A max-heap*'
  prefs: []
  type: TYPE_NORMAL
- en: Quick—what’s the maximum receipt cost in that tree?
  prefs: []
  type: TYPE_NORMAL
- en: It’s 85, and it’s right there at the root. If you were promised that the maximum
    element of some tree was at its root, then you could just return the element at
    the root and not search or traverse the tree at all.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our plan is to maintain the tree such that the maximum receipt cost is always
    at the root. We’ll have to be vigilant, because we’re going to be bombarded by
    two kinds of events that can mess up our tree:'
  prefs: []
  type: TYPE_NORMAL
- en: '**A new receipt comes in.**   We have to figure out how to reorganize the tree
    to incorporate this receipt. The new receipt could even be higher than everything
    else in the tree, in which case we need to get the receipt to the root.'
  prefs: []
  type: TYPE_NORMAL
- en: '**A receipt gets extracted from the tree.**   We have to figure out how to
    reorganize the tree so that the maximum element remaining in the tree is at the
    root.'
  prefs: []
  type: TYPE_NORMAL
- en: Of course, we have to do these inserts and extracts quickly. In particular,
    we need to be quicker than linear time, as a linear-time scan through an array
    is what brought us here in the first place!
  prefs: []
  type: TYPE_NORMAL
- en: What Is a Max-Heap?
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[Figure 8-1](ch08.xhtml#ch08fig01) is an example of a *max-heap*. The “max”
    there means that this tree enables us to quickly find the maximum element.'
  prefs: []
  type: TYPE_NORMAL
- en: A max-heap has two important properties. First, it’s a *complete* binary tree.
    This means that each level in the tree is full (that is, it has no missing nodes),
    except possibly the bottom level, whose nodes are filled in from left to right.
    In [Figure 8-1](ch08.xhtml#ch08fig01), notice how each level is completely full.
    Well, the bottom level isn’t completely full, but that’s okay because its nodes
    are filled in from the left. (Don’t confuse complete binary trees here with full
    binary trees from [Chapter 2](ch02.xhtml).)
  prefs: []
  type: TYPE_NORMAL
- en: The fact that a max-heap is a complete binary tree doesn’t directly help us
    find the maximum, insert an element, or extract the maximum, but it does lead
    to a lightning-fast implementation of heaps, as we’ll see.
  prefs: []
  type: TYPE_NORMAL
- en: Second, the value of a node is greater than or equal to the values of its child
    nodes. (The values in [Figure 8-1](ch08.xhtml#ch08fig01) are all distinct, so
    a parent’s value is strictly greater than those of its children.) This is called
    the *max-heap-order* property.
  prefs: []
  type: TYPE_NORMAL
- en: Consider the node in [Figure 8-1](ch08.xhtml#ch08fig01) with a value of 56\.
    As promised, 56 is greater than the values of its child nodes (10 and 25). This
    property is true everywhere in the tree, and it’s why the maximum value must be
    at the root. Every other node has a parent node with greater value!
  prefs: []
  type: TYPE_NORMAL
- en: Inserting into a Max-Heap
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: When a new receipt arrives, we’ll insert it into the max-heap, but we have to
    do it carefully so that the max-heap-order property is maintained.
  prefs: []
  type: TYPE_NORMAL
- en: 'Starting with [Figure 8-1](ch08.xhtml#ch08fig01), let’s insert 15\. There’s
    only one place we can put it without breaking the complete-tree property: on the
    bottom level, to the right of the 38 (see [Figure 8-2](ch08.xhtml#ch08fig02)).'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/ch08fig02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 8-2: A max-heap with 15 inserted*'
  prefs: []
  type: TYPE_NORMAL
- en: It’s a complete binary tree, for sure, but does the max-heap-order property
    hold? It does! 15’s parent is 16, and 16 is greater than 15, just as we require.
    There’s no additional work to do.
  prefs: []
  type: TYPE_NORMAL
- en: Now consider a tougher one. We’ll insert 32 into [Figure 8-2](ch08.xhtml#ch08fig02),
    resulting in [Figure 8-3](ch08.xhtml#ch08fig03).
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/ch08fig03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 8-3: A max-heap with 32 inserted*'
  prefs: []
  type: TYPE_NORMAL
- en: There’s some trouble here. Inserting 32 has broken the max-heap-order property,
    because its parent 16 is less than 32\. (Here, and in subsequent figures, the
    thick edge shows a max-heap-order violation.) We can fix this problem by swapping
    the 16 and 32, as in [Figure 8-4](ch08.xhtml#ch08fig04).
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/ch08fig04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 8-4: A max-heap with the max-heap-order violation repaired*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Ahh, order has been restored: 32 must be greater than both of its children
    at this point. It’s greater than its child 16 because that’s why we performed
    the swap, and it’s greater than its other child 15 because 15 used to be a child
    of 16\. In general, performing such a swap is guaranteed to maintain the max-heap-order
    property between the new node and its children.'
  prefs: []
  type: TYPE_NORMAL
- en: We’re back to a max-heap, and it only took us one swap to do it. It could take
    more swaps, though, which I’ll demonstrate now by inserting 91 into [Figure 8-4](ch08.xhtml#ch08fig04).
    See [Figure 8-5](ch08.xhtml#ch08fig05) for the result.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/ch08fig05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 8-5: A max-heap with 91 inserted*'
  prefs: []
  type: TYPE_NORMAL
- en: We had to start a new level at the bottom of the tree, since the previous bottom
    level is full. We can’t keep the 91 as a child of 5, though, because it violates
    the max-heap-order property. A swap will fix it . . . well, sort of. See [Figure
    8-6](ch08.xhtml#ch08fig06).
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/ch08fig06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 8-6: A max-heap with 91 moved up*'
  prefs: []
  type: TYPE_NORMAL
- en: We’ve fixed the problem between 5 and 91, but now we have a new problem between
    17 and 91\. We can fix this one by another swap; see [Figure 8-7](ch08.xhtml#ch08fig07).
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/ch08fig07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 8-7: A max-heap with 91 moved up again*'
  prefs: []
  type: TYPE_NORMAL
- en: 'We have yet another max-heap-order violation, this time between 63 and 91\.
    However, notice that the violation is moving up the tree, becoming closer and
    closer to the root. At worst, we’ll end up shuttling 91 up to the root of the
    tree. That’s exactly what will happen here, because 91 is the maximum element.
    It takes two more swaps to finish the job: the first is shown in [Figure 8-8](ch08.xhtml#ch08fig08).'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/ch08fig08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 8-8: A max-heap with 91 moved up yet again*'
  prefs: []
  type: TYPE_NORMAL
- en: And the second swap is shown in [Figure 8-9](ch08.xhtml#ch08fig09).
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/ch08fig09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 8-9: A max-heap with the heap-order violation repaired*'
  prefs: []
  type: TYPE_NORMAL
- en: We’ve got a max-heap again! We only had to perform four swaps to fix the heap
    of 16 elements, and that was for a value that bubbled up all the way to the root.
    As we’ve seen, inserting other values that don’t make it all the way to the root
    will be even faster than that.
  prefs: []
  type: TYPE_NORMAL
- en: Extracting from a Max-Heap
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: At the end of each day of the promotion, we’ll need to extract the maximum receipt
    from the max-heap. As with insertion, we must be careful to fix the tree so that
    it’s a max-heap again. We’ll see that the process mirrors that of insertion, this
    time with a value bubbling down rather than up.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s start with [Figure 8-1](ch08.xhtml#ch08fig01) and extract the maximum.
    Here is that figure again:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/page_287_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Extracting the maximum removes 85 as the root of the tree, but we need to put
    something else at the root; otherwise, we would no longer have a tree. The only
    node we can use, without breaking the complete-tree property, is the rightmost
    node on the bottom level. That is, we can swap 85 with 38, arriving at [Figure
    8-10](ch08.xhtml#ch08fig10).
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/ch08fig10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 8-10: A max-heap with 85 extracted*'
  prefs: []
  type: TYPE_NORMAL
- en: We just took a small value from the bottom of the tree and blasted it up to
    the top. In general, that’s going to break the max-heap-order property. It certainly
    does so here, because 38 is less than both 63 and 82.
  prefs: []
  type: TYPE_NORMAL
- en: We’ll again fix the max-heap-order property by using swaps. Unlike insertion,
    extraction presents us with a choice. Should we swap 38 and 63, or should we swap
    38 and 82? Swapping 38 and 63 doesn’t solve the problem at the root, because 82
    would end up as a child of 63\. Swapping 38 and 82 is the right move. In general,
    we want to perform the swap with the larger child, so the max-heap-order property
    is fixed between the larger child and its new children. [Figure 8-11](ch08.xhtml#ch08fig11)
    shows the result of swapping 38 and 82.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/ch08fig11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 8-11: A max-heap with 38 moved down*'
  prefs: []
  type: TYPE_NORMAL
- en: We’re not out of the woods yet—there’s still a max-heap-order violation between
    38 and 43\. The good news is that the max-heap-order violation is moving down
    the tree. If we keep pushing the violations down, then in the worst case we’ll
    have a max-heap again when 38 hits the bottom of the tree.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s swap 38 and 43; see [Figure 8-12](ch08.xhtml#ch08fig12).
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/ch08fig12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 8-12: A max-heap with 38 moved farther down*'
  prefs: []
  type: TYPE_NORMAL
- en: The 38 is now fine right where it is, so we’ve restored the max-heap-order property.
  prefs: []
  type: TYPE_NORMAL
- en: Height of a Max-Heap
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Both insertion and extraction perform at most one swap per level: insertion
    swaps up the tree and extraction swaps down the tree. Are insertion and extraction
    fast? That depends on the height of the max-heap: if the height is small, then
    these operations are fast. Thus we need to understand the relationship between
    the number of elements in a max-heap and the height of the max-heap.'
  prefs: []
  type: TYPE_NORMAL
- en: Take a look at [Figure 8-13](ch08.xhtml#ch08fig13), where I’ve drawn the complete
    binary tree of 16 nodes.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/ch08fig13.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 8-13: A complete binary tree of 16 nodes (numbered from top to bottom
    and left to right)*'
  prefs: []
  type: TYPE_NORMAL
- en: 'I’ve numbered the nodes from top to bottom, left to right. That’s why the root
    is 1; its two children are 2 and 3; their children are 4, 5, 6, and 7; and so
    on. We can observe that each new level starts with a number that is a power of
    2: the root is 1, the level below that starts at 2, the level below that starts
    at 4, then 8, then 16\. That is, we need to double the number of nodes to produce
    just one more level in the tree. This is like binary search, where doubling the
    number of elements leads to just one more iteration of the loop. As with binary
    search, then, the height of a complete binary tree, and therefore the height of
    a max-heap, is *O*(log *n*), where *n* is the number of elements in the tree.'
  prefs: []
  type: TYPE_NORMAL
- en: We are victorious! Inserting into a max-heap is *O*(log *n*). Extracting from
    a max-heap is *O*(log *n*). We no longer have to be slowed down by *O*(*n*) linear-time
    work.
  prefs: []
  type: TYPE_NORMAL
- en: Max-Heaps as Arrays
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: A max-heap is just a binary tree, and we know how to implement binary trees.
    While it is possible to implement a max-heap as such, it’s quite challenging to
    do so.
  prefs: []
  type: TYPE_NORMAL
- en: 'Think back to when we solved Halloween Haul in [Chapter 2](ch02.xhtml). We
    used a `node` struct with pointers to the left and right children. That would
    be enough for us to be able to bubble a value down a max-heap. However, it would
    not be enough for us to be able to bubble a value up a max-heap, because doing
    so requires access to parent nodes. So we might add a parent pointer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Even if we added the `parent` like that, we still have direct access only to
    the root of our tree. When inserting a value, how are we supposed to quickly find
    where to insert it? When extracting, how are we supposed to quickly find the rightmost
    node on the bottom level? There is a better way.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s again use [Figure 8-13](ch08.xhtml#ch08fig13), where I’ve numbered the
    nodes from top to bottom and left to right. The parent of node number 16 is 8\.
    The parent of node number 12 is 6\. The parent of node number 7 is 3\. What is
    the relationship between the number of a node and the number of its parent?
  prefs: []
  type: TYPE_NORMAL
- en: 'The answer is: divide by 2! 16/2 = 8\. 12/2 = 6\. 7/2 = 3\. Well, that last
    one is really 3.5, so just drop the fractional part.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We integer-divide by 2 to move up the tree. Let’s see what happens if we reverse
    that process and multiply by two instead. 8 × 2 = 16, so multiplying by 2 takes
    us from 8 to its left child. However, most nodes have two children, and we may
    also want to move from a node to its right child. We can do that, too: we just
    add 1 to the number of the left child. For example, we can move from 6 to its
    left child by 6 × 2 = 12 and move from 6 to its right child by 6 × 2 + 1 = 13\.
    (The relationship between 13/2 and 6 is an example of why it’s safe to drop the
    0.5 to move from a child to its parent.)'
  prefs: []
  type: TYPE_NORMAL
- en: These relationships between nodes hold only because max-heaps are complete binary
    trees. In general, binary trees can have more chaotic structure, having a long
    chain of nodes here and a short chain there. We can’t breeze around such a tree
    by multiplying and dividing by 2 unless we inserted placeholder nodes to maintain
    the illusion that the tree is complete. That would waste a huge amount of memory
    if the tree were very unbalanced.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we store a max-heap in an array—first the root, then its children, then
    their children, and so on—then the index of a node in the array corresponds to
    its node number. We’ll have to start indexing at 1, not 0, to match the numbering
    in [Figure 8-13](ch08.xhtml#ch08fig13). (It’s possible to start at index 0, but
    that would result in slightly messier relationships between nodes: the parent
    of the node at index *i* would be at (*i* – 1)/2, and the children would be at
    indices 2*i* + 1 and 2*i* + 2.)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here again is [Figure 8-1](ch08.xhtml#ch08fig01), the heap of 13 receipt costs:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/page_291_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Here is the corresponding array:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg291-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Index 6 in the array has a value of 43\. What is 43’s left child? To answer
    that, just look up index 6 × 2 = 12 in the array: it’s 2\. What is 43’s right
    child? Look up index 6 × 2 + 1 = 13: it’s 38\. What is 43’s parent? Check index
    6/2 = 3: it’s 82\. No matter which node we’re currently focused on in the tree,
    we can use the array to move to a child or the parent with just a tiny bit of
    math.'
  prefs: []
  type: TYPE_NORMAL
- en: Implementing a Max-Heap
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Each element of our heaps will hold both a receipt index and a receipt cost.
    These are the two pieces of information that we’ll want to know about a receipt
    when we extract it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s the struct:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Now we’re ready to implement a max-heap. The two key operations are inserting
    into the heap and extracting the maximum from the heap. Let’s start with inserting
    into the heap; see [Listing 8-3](ch08.xhtml#ch08ex03).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 8-3: Inserting into max-heap*'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `max_heap_insert` function takes four parameters. The first two are for
    the heap: `heap` is the array that holds the max-heap, and `num_heap` is a pointer
    to the number of elements in the heap. The reason why `num_heap` is a pointer
    is because we’ll need to increase the number of elements in the heap by one and
    make the caller aware of that increase. The latter two parameters are for the
    new receipt: `receipt_index` is the index of the receipt that we’re inserting,
    and `cost` is its associated cost.'
  prefs: []
  type: TYPE_NORMAL
- en: We begin by increasing the number of elements in the heap by one ❶ and then
    storing the new receipt in the new heap slot ➋. Variable `i` tracks the index
    in the heap of the newly inserted element ➌.
  prefs: []
  type: TYPE_NORMAL
- en: We have no guarantee that we still have a max-heap. What we just inserted may
    be larger than its parent, so we need to perform the required swaps. That’s the
    point of the `while` loop ➍.
  prefs: []
  type: TYPE_NORMAL
- en: There are two conditions required for the `while` loop to continue. First, we
    need `i > 1`, because otherwise `i` is 1 and has no parent. (Remember that the
    heap starts at index 1, not 0.) Second, we need the node’s receipt cost to be
    greater than that of its parent. The body of the `while` loop performs the swap,
    then it moves us from the current node to its parent ➎. Ahh, again, we have that
    divide-by-2 scheme to move up the tree. Such spare, pleasing, and correct code
    is the best kind.
  prefs: []
  type: TYPE_NORMAL
- en: Now let’s turn to extracting from the max-heap. [Listing 8-4](ch08.xhtml#ch08ex04)
    provides the code.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 8-4: Extracting the maximum from max-heap*'
  prefs: []
  type: TYPE_NORMAL
- en: We begin by saving the receipt that we’re about to extract, which is at the
    root of the heap ❶. We then replace the root with the bottom-most, right-most
    node ➋ and decrease the number of elements in the heap by one ➌. That new root
    element might not meet the max-heap-order property, so we use variable `i` to
    track its position in the heap ➍. Then, just as in [Listing 8-3](ch08.xhtml#ch08ex03),
    we have a `while` loop that will perform the necessary swaps. This time, the `while`
    loop condition ➎ says that the left child of Node `i` is in the heap; if it’s
    not, then Node `i` has no children and a max-heap-order violation cannot exist.
  prefs: []
  type: TYPE_NORMAL
- en: Inside the loop, `child` is set to the left child ➏. Then, if the right child
    exists, we check whether its cost is higher than that of the left child. If it
    is, then we set `child` to be that right child ❼. Now `child` is the biggest child,
    so we check whether it is involved in a max-heap-order violation ❽. If it is,
    then we perform the swap. Finally, we move down the tree ❾ so that we’re ready
    to check for another max-heap-order violation.
  prefs: []
  type: TYPE_NORMAL
- en: 'Notice what happens if the node and its largest child are already correctly
    ordered: we `break` out of the loop, since there can’t be any more violations
    in the tree.'
  prefs: []
  type: TYPE_NORMAL
- en: The last thing the function does is return the maximum-cost receipt. We’ll be
    able to use that to help determine the prize for the day and to make sure that
    we never consider this receipt again. First, however, let’s learn about min-heaps,
    so we can extract minimums in addition to maximums.
  prefs: []
  type: TYPE_NORMAL
- en: '*Min-Heaps*'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: A *min-heap* allows us to quickly insert a new receipt and extract the minimum-cost
    receipt.
  prefs: []
  type: TYPE_NORMAL
- en: '##### Definition and Operations'
  prefs: []
  type: TYPE_NORMAL
- en: Guess what? You know almost everything you need to know about min-heaps, because
    they are almost identical to max-heaps.
  prefs: []
  type: TYPE_NORMAL
- en: A min-heap is a complete binary tree. It will have height *O*(log *n*), where
    *n* is the number of elements in the heap. We’ll be able to store it in an array
    just as we did a max-heap. To find the parent of a node, divide by 2; to find
    the left child, multiply by 2; to find the right child, multiply by 2 and add
    1\. There is nothing new here.
  prefs: []
  type: TYPE_NORMAL
- en: 'The only new thing is the *min-heap-order* property: the value of a node is
    less than or equal to the values of its child nodes. This results in the smallest
    value, not the largest value, at the root. That’s exactly where we want it to
    make minimum-extractions fast.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s again consider the following 13 receipt costs: 6, 63, 16, 82, 25, 2,
    43, 5, 17, 10, 56, 85, and 38\. [Figure 8-14](ch08.xhtml#ch08fig014) shows a min-heap
    for these costs.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/ch08fig14.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 8-14: A min-heap*'
  prefs: []
  type: TYPE_NORMAL
- en: Inserting into a min-heap and extracting the minimum from a min-heap are analogous
    to the corresponding max-heap operations.
  prefs: []
  type: TYPE_NORMAL
- en: To insert, add the new node to the right of all nodes on the bottom level, or
    start a new level if the bottom level is full. Then swap the node up until it
    becomes the root or is greater than or equal to its parent.
  prefs: []
  type: TYPE_NORMAL
- en: To extract the minimum, replace the root by the bottom-most, rightmost value,
    and then swap it down the tree until it becomes a leaf or is less than or equal
    to its children.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing a Min-Heap
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Implementing a min-heap is a copy-and-paste job using our max-heap code. Just
    change the function names and change the comparisons from `>` to `<`. That’s it.
    See [Listing 8-5](ch08.xhtml#ch08ex05) for the insertion code.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 8-5: Inserting into min-heap*'
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 8-6](ch08.xhtml#ch08ex06) gives the minimum-extraction code.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 8-6: Extracting a minimum from min-heap*'
  prefs: []
  type: TYPE_NORMAL
- en: There is big-time code duplication here! In practice, what you’d do is write
    more general `heap_insert` and `heap_extract` functions that take a comparison
    function as a parameter (much like `qsort` does). It’s simpler, though, to understand
    the code without that, so let’s keep it as is.
  prefs: []
  type: TYPE_NORMAL
- en: '*Solution 2: Heaps*'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Now that we’ve got max-heaps and min-heaps, we’re ready for round 2 with this
    problem.
  prefs: []
  type: TYPE_NORMAL
- en: All we need is a `main` function that reads the input and uses heaps to quickly
    insert and extract receipts. See [Listing 8-7](ch08.xhtml#ch08ex07) for the code.
    As you read through it, you’ll come across two `while` loops. What on earth are
    those doing?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 8-7: The main function for solving the problem using heaps*'
  prefs: []
  type: TYPE_NORMAL
- en: We have a `used` array ❶ that will store for each receipt a `1` if it has been
    used and a `0` if not. The max-heap ➋ and min-heap are one element larger than
    the `used` array; this accounts for us not using index 0 in the heaps.
  prefs: []
  type: TYPE_NORMAL
- en: For a given day, we insert the index of each receipt into both the max-heap
    ➌ and min-heap ➍. We then extract a receipt from the max-heap ➎ and extract a
    receipt from the min-heap ➏. This is where those two `while` loops come in, looping
    until we get a receipt that hasn’t yet been used. Let me explain what’s going
    on.
  prefs: []
  type: TYPE_NORMAL
- en: When we extract a receipt from the max-heap, it would be nice to also extract
    it from the min-heap so that the two heaps always contain exactly the same receipts.
    Notice, though, that we don’t actually extract that same receipt from the min-heap.
    Why? Because we have no idea where that receipt *is* in the min-heap! At some
    later time, that receipt might be extracted from the min-heap—but it has already
    been used, so we want to throw it away and not process it again.
  prefs: []
  type: TYPE_NORMAL
- en: The opposite can happen, too, because we extract a receipt from the min-heap
    and leave it in the max-heap. At some later time, that used receipt might come
    out of the max-heap. We need to ignore it and extract from the max-heap again.
  prefs: []
  type: TYPE_NORMAL
- en: 'So that’s what the `while` loops do: ignore receipts that have already been
    processed by one of the heaps.'
  prefs: []
  type: TYPE_NORMAL
- en: 'A new test case may help. Here it is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: The prize money here is 7 – 6 = 1 from the first day and 10 – 9 = 1 from the
    second day, so the total prize money is 2.
  prefs: []
  type: TYPE_NORMAL
- en: 'After reading the two receipts on the first day, each heap holds the two receipts.
    For the max-heap, we have:'
  prefs: []
  type: TYPE_NORMAL
- en: '| receipt_index | cost |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| 1 | 7 |'
  prefs: []
  type: TYPE_TB
- en: '| 0 | 6 |'
  prefs: []
  type: TYPE_TB
- en: 'For the min-heap, we have:'
  prefs: []
  type: TYPE_NORMAL
- en: '| receipt_index | cost |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| 0 | 6 |'
  prefs: []
  type: TYPE_TB
- en: '| 1 | 7 |'
  prefs: []
  type: TYPE_TB
- en: 'We then do the heap extractions, removing one receipt from each heap. Here’s
    what’s left for the max-heap:'
  prefs: []
  type: TYPE_NORMAL
- en: '| receipt_index | cost |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| 0 | 6 |'
  prefs: []
  type: TYPE_TB
- en: 'Here’s what’s left for the min-heap:'
  prefs: []
  type: TYPE_NORMAL
- en: '| receipt_index | cost |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| 1 | 7 |'
  prefs: []
  type: TYPE_TB
- en: Receipt 0 is still in the max-heap, and Receipt 1 is still in the min-heap.
    However, they have been used, so we’d better not use them again.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now consider the second day. Receipts 2 and 3 get added to each heap, so for
    the max-heap, we have:'
  prefs: []
  type: TYPE_NORMAL
- en: '| receipt_index | cost |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| 3 | 10 |'
  prefs: []
  type: TYPE_TB
- en: '| 0 | 6 |'
  prefs: []
  type: TYPE_TB
- en: '| 2 | 9 |'
  prefs: []
  type: TYPE_TB
- en: 'For the min-heap, we have:'
  prefs: []
  type: TYPE_NORMAL
- en: '| receipt_index | cost |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| 1 | 7 |'
  prefs: []
  type: TYPE_TB
- en: '| 2 | 9 |'
  prefs: []
  type: TYPE_TB
- en: '| 3 | 10 |'
  prefs: []
  type: TYPE_TB
- en: When we extract from the max-heap, we get Receipt 3\. That’s great. However,
    when we extract from the min-heap, we get Receipt 1\. Without the `while` loop
    to throw it away, this would be big trouble, because Receipt 1 has already been
    used.
  prefs: []
  type: TYPE_NORMAL
- en: At the end of a given day, one or both of the `while` loops might iterate many
    times. If this kept happening, day after day, then we’d have to be concerned about
    the impact on our program’s efficiency. Notice, though, that a receipt can be
    removed from a heap at most once. If there are *r* receipts in a heap, then there
    can be at most *r* extractions from the heap, whether they are clustered in a
    single day or across many days.
  prefs: []
  type: TYPE_NORMAL
- en: It is time to submit to the judge. Unlike Solution 1, which frittered away its
    time with slow searches, our heap-based solution should pass all of the test cases
    well within the time limit.
  prefs: []
  type: TYPE_NORMAL
- en: Heaps
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you have a stream of values coming in and at any given time you may be asked
    to process the maximum or minimum value, then a heap is what you want. A max-heap
    is used to extract and process the maximum; a min-heap is used to extract and
    process the minimum.
  prefs: []
  type: TYPE_NORMAL
- en: A heap can be used to implement a *priority queue*. In a priority queue, each
    element has a priority that determines its importance. In some applications, the
    priorities of important elements are big numbers, in which case a max-heap should
    be used; in others, the priorities of important elements are small numbers, in
    which case a min-heap should be used. Of course, if we need both high- and low-priority
    elements, we can use two heaps as we did when solving the Supermarket Promotion
    problem.
  prefs: []
  type: TYPE_NORMAL
- en: '*Two More Applications*'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: I find that min-heaps are used more often than max-heaps. Let’s explore two
    examples where min-heaps can be used.
  prefs: []
  type: TYPE_NORMAL
- en: Heapsort
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: There’s a famous sorting algorithm called *heapsort* that we can implement now
    that we understand min-heaps. All we do is insert all of the values into the min-heap
    and then extract the minimum one by one. The extractions pull out the smallest
    value, then the second-smallest value, then the third-smallest value, and so on,
    handing us the values sorted from smallest to largest. It’s literally four lines.
    Check it out in [Listing 8-8](ch08.xhtml#ch08ex08).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 8-8: Heapsort*'
  prefs: []
  type: TYPE_NORMAL
- en: We’re inserting integers into the heap here, so you should change `min_heap_insert`
    and `min_heap_extract` to use and compare integers rather than `heap_element`
    structs.
  prefs: []
  type: TYPE_NORMAL
- en: Heapsort performs *n* inserts and *n* extracts. A heap implements each of those
    in log *n* time, so heapsort is an *O*(*n* log *n*) algorithm. That’s the same
    worst-case runtime as the fastest possible sorting algorithms. (The `q` in C’s
    `qsort` function probably gets its name from *quicksort*, which is a sorting algorithm
    that is faster than heapsort in practice. We’ll encounter quicksort in [Chapter
    10](ch10.xhtml).)
  prefs: []
  type: TYPE_NORMAL
- en: Dijkstra’s Algorithm
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Dijkstra’s algorithm ([Chapter 6](ch06.xhtml)) spends a lot of its time finding
    the next node to process. It does that by searching through node distances, looking
    for the smallest one. To speed up Dijkstra’s algorithm, we can use a min-heap!
    This is demonstrated in “Dijkstra’s Algorithm: Using a Heap” in [Appendix B](app02.xhtml).'
  prefs: []
  type: TYPE_NORMAL
- en: '#### *Choosing a Data Structure*'
  prefs: []
  type: TYPE_NORMAL
- en: A data structure is typically good for only a few different operation types.
    There’s no super data structure that makes everything fast, so it’s up to you
    to choose the appropriate data structure for the problem you’re solving.
  prefs: []
  type: TYPE_NORMAL
- en: Think back to [Chapter 1](ch01.xhtml), when we learned about the hash table
    data structure. Could we have used a hash table to solve Supermarket Promotion?
  prefs: []
  type: TYPE_NORMAL
- en: No! A hash table is good for speeding up the search for a specific item that
    we’re searching for. What are the snowflakes that might be similar to snowflake
    *s*? Is word *c* in this word list? Those are the kinds of questions you want
    to ask of a hash table. What is the minimum element in this array? No hashing
    is going to help there. You’d have to search through the hash table, which is
    no faster than searching a regular array. It’s our job to choose a data structure
    specifically designed for the task at hand. For finding the minimum element in
    an array, that data structure is a min-heap.
  prefs: []
  type: TYPE_NORMAL
- en: As with any general-purpose data structure, heaps can be used to solve a surprisingly
    diverse set of problems—but the heap data structure itself remains as is, just
    as you’ve learned it here. So instead of solving another heap problem, let’s proceed
    to a problem where we’ll need a new data structure called a *segment tree*. As
    with heaps, segment trees speed up only a small number of types of operations.
    Even so, it’s impressive how many problems are in the wheelhouse of segment trees,
    where those speedups are exactly what we need.
  prefs: []
  type: TYPE_NORMAL
- en: 'Problem 2: Building Treaps'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this problem, we’ll produce a representation of a *treap*. A treap is a flexible
    data structure that can solve a variety of search problems, and I encourage you
    to learn more about treaps if you’re interested. Here we’re concerned only with
    building a treap, not using it. Of course, I’ll provide all you need to know about
    treaps for our purposes.
  prefs: []
  type: TYPE_NORMAL
- en: This is POJ problem `1785`.
  prefs: []
  type: TYPE_NORMAL
- en: '*The Problem*'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: A treap is a binary tree where each node has both a label and a priority. [Figure
    8-15](ch08.xhtml#ch08fig015) shows an example treap, in which the uppercase letters
    are the labels and the positive integers are the priorities. I’ve separated the
    label and priority for each node by a slash. For example, the root node has label
    C and priority 58.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/ch08fig15.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 8-15: A treap*'
  prefs: []
  type: TYPE_NORMAL
- en: 'A treap has to satisfy two properties: one on its labels and one on its priorities.'
  prefs: []
  type: TYPE_NORMAL
- en: First, let’s talk about labels. For any node *x*, the labels in its left subtree
    are all less than the label of *x*, and the labels in its right subtree are all
    greater than the label of *x*. This is called the *binary search tree (BST)* property.
  prefs: []
  type: TYPE_NORMAL
- en: You can verify that the treap in [Figure 8-15](ch08.xhtml#ch08fig015) meets
    this label property. For our alphabetic labels, one label is less than another
    if it comes earlier in the alphabet. Take the root node as an example. Its label
    is C. Both labels in its left subtree are less than C, and all labels in its right
    subtree are greater than C. As another example, consider the node with label G.
    All of the labels in its left subtree—D, E, and F—are less than G. What about
    all of the labels in its right subtree? Well, there are none, so there’s nothing
    to check!
  prefs: []
  type: TYPE_NORMAL
- en: Second, let’s talk about priorities. For any node *x*, the priorities of its
    children are less than the priority of *x*. Hey, this is like the max-heap-order
    property!
  prefs: []
  type: TYPE_NORMAL
- en: Take a look at the root again. Its priority is 58\. Its children had better
    have lower priorities—and they do, with priorities 54 and 56\. How about that
    G node, with priority 55? We need its child to have a lower priority—and it does,
    with priority 49.
  prefs: []
  type: TYPE_NORMAL
- en: 'So that’s a treap: a binary tree whose labels satisfy the BST property and
    whose priorities satisfy the max-heap-order property. Notice that there’s no shape
    requirement: a treap can have any structure whatsoever. There’s certainly no complete
    tree requirement like there is for heaps.'
  prefs: []
  type: TYPE_NORMAL
- en: In this problem, we are provided the label/priority of each node. Our task is
    to assemble and output a treap for these nodes.
  prefs: []
  type: TYPE_NORMAL
- en: Input
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: The input contains zero or more test cases. Each line of input begins with an
    integer *n*. Each *n* is between 0 and 50,000\. If *n* is 0, then there are no
    further test cases to process.
  prefs: []
  type: TYPE_NORMAL
- en: If *n* is greater than zero, then it indicates the number of nodes in the test
    case. Following *n* is *n* space-separated tokens, one for each node. Each token
    is of the form `L/P`, where `L` is the label and `P` is the priority for this
    node. Labels are strings of letters; priorities are positive integers. All labels
    are unique, and all priorities are unique.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is possible input that leads to the treap in [Figure 8-15](ch08.xhtml#ch08fig015):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Output
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'For each test case, output the treap on its own line. Here is the required
    format for the treap:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Here <left_subtreap> is the left subtreap, <L> is the label of the root, <P>
    is the priority of the root, and <right_subtreap> is the right subtreap. The subtreaps
    are output in the same format.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the output corresponding to the sample input:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: The time limit for solving the test cases is two seconds.
  prefs: []
  type: TYPE_NORMAL
- en: '*Recursively Outputting Treaps*'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Let’s again consider our sample nodes and reason through how we can produce
    a treap from them. Here are those nodes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Remember that treap priorities must obey the max-heap-order property. In particular,
    this means that a node with maximum priority must be the root node. In addition,
    because the input guarantees that all priorities are distinct, there is only one
    node that has the maximum priority. So it’s settled: the root node must be `C/58`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We now must decide for each other node whether it should go in C’s left subtreap
    or right subtreap. The priorities of these nodes are all less than 58, so priority
    won’t help us make any kind of left–right split—but the BST property will! The
    BST property of treaps tells us that the labels in the left subtreap must be less
    than C and the labels in the right subtreap must be greater than C. We can therefore
    split the remaining nodes into two groups, one for the left subtreap and one for
    the right subtreap, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: That is, the left subtreap will have Nodes A and B, and the right subtreap will
    have Nodes I, K, E, G, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: Now, we’re done! We’ve split the original problem into two smaller subproblems
    of exactly the same form. We were asked to produce a treap for 11 nodes. We’ve
    reduced that problem to producing a treap for two nodes and a treap for eight
    nodes. We can do those recursively!
  prefs: []
  type: TYPE_NORMAL
- en: Let’s nail down the specific rules that we’ll use. For the base case, we can
    use a treap of zero nodes, which requires no output at all. For the recursive
    case, we’ll identify the root as the node with highest priority and then split
    the remaining nodes into those with smaller labels and those with larger labels.
    We output an open parenthesis, recursively output the treap for the smaller labels,
    output the root node of the treap, output the treap for the larger labels, and
    finally output a closing parenthesis.
  prefs: []
  type: TYPE_NORMAL
- en: 'For our sample input, we’ll output an opening parenthesis. Then we’ll output
    the left subtreap:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'This is followed by the root node:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'then the right subtreap:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: and finally a closing parenthesis.
  prefs: []
  type: TYPE_NORMAL
- en: '*Sorting by Label*'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: I have one other implementation idea before we turn to the code. As I’ve described
    things so far, it seems that we’d need to literally create a new array with small-labeled
    nodes to pass to the first recursive call and a new array with large-labeled nodes
    to pass to the second recursive call. That would result in lots of copying between
    arrays. Fortunately, we can avoid all that by sorting the nodes by label, from
    smallest to largest, at the outset. Then we can just tell each recursive call
    the starting and ending indices of the array that it is responsible for.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, if we sort our sample input by label, we get this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: We can then tell the first recursive call to produce the subtreap for the first
    two nodes and the second recursive call to produce the subtreap for the latter
    eight.
  prefs: []
  type: TYPE_NORMAL
- en: '*Solution 1: Recursion*'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Here are some constants and a struct:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: We don’t know how long the labels are, so we’ll go with an initial size of 16\.
    You’ll see that we call a `read_label` function to read each label; if a length
    of 16 proves insufficient, that function will allocate more memory until the label
    fits. (This is probably overkill, since it looks like the test cases use short
    labels of up to only five letters, but it’s better to be safe than sorry.)
  prefs: []
  type: TYPE_NORMAL
- en: The main Function
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Let’s look at the `main` function, as given in [Listing 8-9](ch08.xhtml#ch08ex09).
    It uses some helper functions—`read_label` that we just talked about and `compare`
    for comparing treap nodes—and calls `solve` for actually outputting the treap.
    We’ll discuss those shortly.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 8-9: The main function for reading input and solving the problem*'
  prefs: []
  type: TYPE_NORMAL
- en: Be careful with `scanf` in a program that reads a mix of numbers and strings.
    Here, each number from the input is followed by whitespace, and we don’t want
    those space characters prefixing the labels that follow. To read and throw away
    those spaces, we use a space following each `%d scanf` format specifier.
  prefs: []
  type: TYPE_NORMAL
- en: Helper Functions
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: We use `scanf` to read the priorities but not the labels. The labels are read
    by the `read_label` function in [Listing 8-10](ch08.xhtml#ch08ex010).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 8-10: Reading a label*'
  prefs: []
  type: TYPE_NORMAL
- en: We’ve used essentially the same function once before in [Listing 5-15](ch05.xhtml#ch05ex015).
    The only difference this time is that we stop reading at the `/` character that
    separates the label from the priority ❶. As usual, `qsort` needs a comparison
    function, and the one we want, given in [Listing 8-11](ch08.xhtml#ch08ex011),
    compares nodes by label.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 8-11: A comparison function for sorting*'
  prefs: []
  type: TYPE_NORMAL
- en: The `strcmp` function works perfectly as a comparison function, because it returns
    a negative integer if the first string is alphabetically less than the second
    string, `0` if the strings are equal, and a positive integer if the first string
    is alphabetically greater than the second string.
  prefs: []
  type: TYPE_NORMAL
- en: Outputting the Treap
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Before we get to the main event—the `solve` function—we need a helper function
    to return the index of the node with maximum priority. This is provided in [Listing
    8-12](ch08.xhtml#ch08ex012). It’s a slow, linear search from index `left` to index
    `right` (and this should worry you!).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 8-12: Finding the maximum priority*'
  prefs: []
  type: TYPE_NORMAL
- en: Now we’re ready to output the treap! See [Listing 8-13](ch08.xhtml#ch08ex013)
    for the `solve` function.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 8-13: Solving the problem*'
  prefs: []
  type: TYPE_NORMAL
- en: 'This function takes three parameters: the array of treap nodes and `left` and
    `right` indices determining the range of nodes over which we’d like the treap
    to be built. In order for the treap to be built for all of the nodes, the initial
    call from `main` will pass `0` for `left` and `num_nodes - 1` for `right`.'
  prefs: []
  type: TYPE_NORMAL
- en: The base case for this recursive function occurs when there are no nodes in
    the treap ❶. In this case, we simply return without outputting anything. With
    no nodes, there is no output.
  prefs: []
  type: TYPE_NORMAL
- en: 'Otherwise, from nodes with indices between `left` and `right`, we find the
    index of the node with maximum priority ➋. That’s the root of the treap, and it
    splits the problem in two: outputting a treap for those nodes with smaller labels
    and outputting a treap for those nodes with larger labels. We solve each of these
    subproblems with a recursive call ➌ ➍.'
  prefs: []
  type: TYPE_NORMAL
- en: 'There we have it: our first solution. It’s quite nice, I’d say. In fact, it
    does two important things right. First, it sorts the nodes, once and for all,
    so that each call of `solve` needs only its `left` and `right` indices. Second,
    it uses recursion to make short work of the otherwise-daunting process of outputting
    a treap.'
  prefs: []
  type: TYPE_NORMAL
- en: However, submit this code to the judge and you’ll see that everything grinds
    to a halt because of that linear search to find the node with maximum priority
    ([Listing 8-12](ch08.xhtml#ch08ex012)). What’s so wrong with it? What kind of
    treap triggers its worst-case performance? We’ll talk about that next.
  prefs: []
  type: TYPE_NORMAL
- en: '*Range Maximum Queries*'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In the previous chapter, we talked about solving the range sum query problem.
    That one asked, “Given an array `a`, left index `left`, and right index `right`,
    what is the *sum* of all elements from `a[left]` to `a[right]`?”
  prefs: []
  type: TYPE_NORMAL
- en: Here, in Building Treaps, we’re being asked to solve a related problem known
    as the *range maximum query (RMQ)* problem. This asks, “Given an array `a`, left
    index `left`, and right index `right`, what is the index of the *maximum* element
    of all elements from `a[left]` to `a[right]`?” (Rather than the index, for some
    problems it might suffice to get the maximum element itself, but for Building
    Treaps we need the index.)
  prefs: []
  type: TYPE_NORMAL
- en: 'In Solution 1, we offered an implementation of RMQ in [Listing 8-12](ch08.xhtml#ch08ex012).
    It iterates from `left` to `right`, checking whether we’ve found an index whose
    node has higher priority than what we’ve discovered so far. We call that function
    for each subtreap, and each call involves a linear search through the active segment
    of the array. If most of those linear searches were on small array segments, then
    we might get away with this. However, there are some inputs that cause many of
    the searches to be on huge segments of the array. Here’s such a list of nodes
    that we might read from the input:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'We scan all seven nodes, finding `G/7` as the node with maximum priority. We
    then recursively output the treap for the small-labeled nodes and recursively
    output the treap for the large-labeled nodes. Unfortunately, the first recursive
    call gets all but the `G/7` node, as the second recursive call is on zero nodes.
    The first recursive call gets this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Now we need another scan of these six elements to identify the node with highest
    priority. We’ll identify `F/6` as that node, make it the root of this subtreap,
    and then make two more recursive calls. Again, however, the first recursive call
    is saddled with all remaining nodes, leading to another expensive array scan.
    This pattern of expensive array scans can continue until there are no nodes remaining.
  prefs: []
  type: TYPE_NORMAL
- en: Generalizing, we can say that, for *n* nodes, the first RMQ could take *n* steps,
    the second could take *n* – 1 steps, and so on, all the way down to 1 step. That’s
    1 + 2 + 3 + . . .+ *n* steps in all. A closed form for this formula is *n*(*n*
    + 1)/2\. In [Chapter 1](ch01.xhtml), we saw a very similar formula in “Diagnosing
    the Problem” on [page 9](ch01.xhtml#ch01lev1). We can similarly conclude that
    we’re doing *O*(*n*²) (quadratic) work here.
  prefs: []
  type: TYPE_NORMAL
- en: Here’s another way to see that we’re doing *O*(*n*²) work. Throw away the *n*/2
    smallest terms and focus on only the remaining *n*/2 larger terms. (Let’s assume
    that *n* is even so that *n*/2 is an integer.) This leaves us with *n* + (*n*
    – 1) + (*n* – 2) + . . . + (*n*/2 + 1). There are *n*/2 terms here, each of which
    is larger than *n*/2, so in total they add up to at least (*n*/2)(*n*/2) = *n*²/4\.
    This is quadratic!
  prefs: []
  type: TYPE_NORMAL
- en: Therefore, a linear search to solve the RMQ problem is not satisfactory.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the previous chapter, we used a prefix array to speed up range sum queries.
    Give that a quick refresher now, because I’m about to ask you a question: Can
    we use that technique to solve the RMQ, too?'
  prefs: []
  type: TYPE_NORMAL
- en: 'Unfortunately, no. (Or, fortunately no, because I can teach you one of my favorite
    data structures as a result.) To sum the elements from index 2 to 5, we can look
    up the prefix sum for index 5 and subtract the prefix sum for index 1\. That’s
    because subtraction undoes addition: the prefix sum for index 5 contains the prefix
    sum for index 1, so we can just subtract the latter out of there. Unfortunately,
    we cannot “undo” a maximum computation in the same way. If the maximum for the
    elements up to index 5 is 10, and the maximum for the elements up to index 1 is
    also 10, what is the maximum from index 2 to index 5? Who knows! With that 10
    gone, it could be whatever is at index 2, or 3, or 4, or 5\. A huge, early element
    prevents later elements from making any change at all to the prefix array. When
    that huge element is gone, we lose our bearings. Contrast that to a prefix sum
    array, where every element leaves its mark.'
  prefs: []
  type: TYPE_NORMAL
- en: As a last-ditch effort, let’s try a heap. Can we use a max-heap to solve the
    RMQ? No, again. A max-heap gives us the maximum element in the entire heap, with
    no provision for restricting that to a given range.
  prefs: []
  type: TYPE_NORMAL
- en: It’s time for something new.
  prefs: []
  type: TYPE_NORMAL
- en: '*Segment Trees*'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Shoo, treaps, shoo! We’ll return to treaps later, just as soon as we have a
    better implementation of RMQ.
  prefs: []
  type: TYPE_NORMAL
- en: A *segment tree* is a full binary tree where each node is associated with a
    particular segment of an underlying array. (In Building Treaps, the underlying
    array is the array of priorities.) Each node stores the answer for the query on
    its segment. For the RMQ, each node stores the index of the maximum element in
    its segment, but segment trees can be used for other queries, too. The segments
    are arranged such that a small number of them can be assembled to answer any query.
  prefs: []
  type: TYPE_NORMAL
- en: The Segments
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'The root node of a segment tree covers the entire array. So, if we’re ever
    asked for the RMQ on the entire array, we can solve that in one step by just looking
    at the root. For other queries, we’ll have to use other nodes. The root node has
    two children: the left child covers the first half of the array and the right
    child covers the second half. Each of these nodes has two children of its own,
    which subdivide the segments even further, and so on, until we get to segments
    of just one element.'
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 8-16](ch08.xhtml#ch08fig016) shows a segment tree that supports queries
    on an eight-element array. Each node is labeled with its left and right endpoints.
    There’s no information in the segment tree about the RMQ yet; for now, we’ll just
    focus on the segments themselves.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/ch08fig16.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 8-16: A segment tree for an eight-element array*'
  prefs: []
  type: TYPE_NORMAL
- en: Notice that the sizes of segments are cut in half for each level that we descend
    in the tree. For example, the root segment covers eight elements, each of its
    children covers four elements, each of their children covers two elements, and
    so on. Like a heap, the height of a segment tree is log *n*, where *n* is the
    number of elements in the array. We’ll be able to answer any query by doing a
    constant amount of work per level, so we’ll obtain *O*(log *n*) time per query.
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 8-16](ch08.xhtml#ch08fig016) is a complete binary tree. Through our
    study of heaps, we know what to do with these: store them in an array! We can
    then use the same math to find the children of a parent, which we’ll need when
    processing segment trees.'
  prefs: []
  type: TYPE_NORMAL
- en: Now, I’m going to hit you with another segment tree, one that exposes a bit
    of a surprise. See [Figure 8-17](ch08.xhtml#ch08fig017).
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/ch08fig17.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 8-17: A segment tree for an 11-element array*'
  prefs: []
  type: TYPE_NORMAL
- en: That’s not a complete binary tree at all, because the bottom level is not filled
    in from left to right! For example, Node 2-2 has no children, even though 3-4
    does.
  prefs: []
  type: TYPE_NORMAL
- en: 'Everything’s okay, though. We’ll continue to store a segment tree in an array.
    We’ll continue to multiply a node’s index by 2 to get its left child and to multiply
    by 2 and add 1 to get its right child. All that will happen is a little bit of
    waste in the array. For example, the order of elements in the array for [Figure
    8-17](ch08.xhtml#ch08fig017) is as follows, where `*` is an unused element:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: This waste *does* make it a little more difficult to determine the number of
    array elements we need for the segment tree.
  prefs: []
  type: TYPE_NORMAL
- en: 'If the number of elements, *n*, in the underlying array is a power of 2, then
    we’ll be safe with a segment tree that can hold 2*n* elements. For example, count
    the nodes in [Figure 8-16](ch08.xhtml#ch08fig016): it takes 15 nodes, which is
    less than 8 × 2 = 16\. (2*n* is safe because all powers of 2 less than *n* add
    up to exactly *n* – 1\. For example, 4 + 2 + 1 = 7, which is 1 less than 8.) If
    *n* isn’t a power of 2, then 2*n* isn’t enough. For proof, look no further than
    [Figure 8-17](ch08.xhtml#ch08fig017), which would require an array of 31 elements
    (more than 2 × 11 = 22) to hold it.'
  prefs: []
  type: TYPE_NORMAL
- en: The more elements to cover in the segment tree, the bigger we need to make the
    segment tree array—but how big should it be? Suppose that we have an underlying
    array of *n* elements for which we want to build a segment tree. I’ll argue that
    the segment tree should be allocated an array of 4*n* elements to be safe.
  prefs: []
  type: TYPE_NORMAL
- en: Let *m* be the smallest power of 2 greater than or equal to *n*. For example,
    if *n* is 11, then *m* is 16\. We can store a segment tree for *m* elements in
    an array with 2*m* elements. Since *m* ≥ *n*, an array with 2*m* elements is enough
    to store a segment tree for *n* elements, too.
  prefs: []
  type: TYPE_NORMAL
- en: 'Fortunately, *m* can’t be that high: it’s at most twice the value of *n*. (The
    worst case occurs for values of *n* that are just above powers of 2\. For example,
    if *n* is 9, then *m* is 16, which is almost twice as large as 9.) Therefore,
    if we need an array of 2*m* elements and *m* is at most 2*n*, then 2*m* is at
    most 2 × 2*n* = 4*n*.'
  prefs: []
  type: TYPE_NORMAL
- en: Initializing the Segments
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'In each node of the segment tree, we’ll store three things: the left index
    of its segment, the right index of its segment, and the index of the maximum element
    in the range. We’ll initialize the first two of these before moving to the third.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s the struct that we’ll use for a segment tree node:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'To initialize the `left` and `right` members for each node, we’ll write the
    body for the following function signature:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'We assume that `segtree` is an array with sufficient space for the segment
    tree. The `node` parameter is the root index of the segment tree; `left` and `right`
    are its segment’s left and right indices, respectively. An initial call of `init_segtree`
    would look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: Here `num_elements` is the number of elements in the underlying array (for example,
    the number of nodes in a treap).
  prefs: []
  type: TYPE_NORMAL
- en: We can use recursion to implement `init_segtree`. If `left` and `right` are
    equal, then we have a one-element segment and there is no subdividing to do. Otherwise,
    we’re in the recursive case and have to split the segment in two. [Listing 8-14](ch08.xhtml#ch08ex014)
    provides the code.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 8-14: Initializing segment tree segments*'
  prefs: []
  type: TYPE_NORMAL
- en: We first store the values of `left` and `right` in the node. Then, we check
    the base case ❶, returning from the function if no children are required.
  prefs: []
  type: TYPE_NORMAL
- en: 'If children are required, then we calculate the midpoint of the current range
    ➋. We then need to build the left segment tree for the indices from `left` to
    `mid` and the right segment tree for the indices from `mid + 1` to `right`. This
    is accomplished by two recursive calls: one for the left ➌ and one for the right
    ➍. Notice how we use `node * 2` to move to the left child and `node * 2 + 1` to
    move to the right child.'
  prefs: []
  type: TYPE_NORMAL
- en: Filling the Segment Tree
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: With the segment tree initialized, it’s time to add the index of the maximum
    element in its segment to each node. For an example, we’ll need both a segment
    tree and the array on which the segment tree will be based. For the segment tree,
    let’s use [Figure 8-17](ch08.xhtml#ch08fig017), and, for the array, let’s use
    the 11 priorities from “Sorting by Label” on [page 303](ch08.xhtml#sec127). [Figure
    8-18](ch08.xhtml#ch08fig018) shows the filled segment tree. The maximum index
    for each node is given below its segment endpoints.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/ch08fig18.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 8-18: A segment tree and an array of priorities*'
  prefs: []
  type: TYPE_NORMAL
- en: Let’s perform a couple of quick checks. Consider the 0-0 node on the bottom
    of the tree. That’s a segment of only index 0, so the only choice for the index
    of the maximum element is 0\. This sounds like a base case to me!
  prefs: []
  type: TYPE_NORMAL
- en: 'Now consider Node 6-10\. The node says that 7 is the index of the maximum element
    from index 6 to index 10\. Index 7 holds 56, and you can verify that this is the
    largest element in the segment. To quickly calculate this, we can use the maximum
    indices stored in 6-10’s child nodes: the left child says that 7 is the desired
    index for the 6-8 segment, and the right child says that 9 is the desired index
    for the 9-10 segment. For 6-10, then, we really have only two choices: index 7
    or index 9, the elements that we get back from these subtrees. This sounds like
    a recursive case to me!'
  prefs: []
  type: TYPE_NORMAL
- en: 'That’s right: we’re going to use recursion to fill the tree, much as we did
    to initialize the tree’s segments. [Listing 8-15](ch08.xhtml#ch08ex015) gives
    the code.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 8-15: Adding the maximums*'
  prefs: []
  type: TYPE_NORMAL
- en: The `segtree` parameter is the array where the segment tree is stored; we assume
    that it has already been initialized by [Listing 8-14](ch08.xhtml#ch08ex014).
    The `node` parameter is the root index of the segment tree, and `treap_nodes`
    is an array of treap nodes. We need the treap nodes here so we can access their
    priorities, but otherwise this doesn’t have anything to do with treaps. You could
    easily replace the treap nodes with whatever you need for solving a given problem.
  prefs: []
  type: TYPE_NORMAL
- en: This function returns the index of the maximum element for the root node of
    the segment tree.
  prefs: []
  type: TYPE_NORMAL
- en: 'The code begins with the base case check: that the node spans just a single
    index ❶. If it does, then the maximum index for the node is just its left index
    (or its right—they’re the same, after all). We then return that maximum index
    ➋.'
  prefs: []
  type: TYPE_NORMAL
- en: If we’re not in the base case, then we’re looking at a segment that spans more
    than one index. We make a recursive call to the left subtree ➌. That call figures
    out the `max_index` value for each node in that subtree and returns to us the
    `max_index` value of that subtree’s root. We then do the same for the right subtree
    ➍. Then we compare the indices we got back from those recursive calls ➎, choosing
    the one whose priority is higher, and setting this node’s `max_index` accordingly.
    The last thing to do is to return that maximum index ➏.
  prefs: []
  type: TYPE_NORMAL
- en: 'Filling the tree in this way takes linear time: for each node, we do a constant
    amount of work to find its maximum index.'
  prefs: []
  type: TYPE_NORMAL
- en: Querying the Segment Tree
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Let’s recap. We were stymied in our attempts to solve Building Treaps because
    we didn’t have a fast way to respond to the range maximum queries. As a result,
    we’ve spent a lot of time developing segment trees, deciding how to choose the
    segments, how big to make the segment tree array, and how to store the index of
    the maximum element for each node.
  prefs: []
  type: TYPE_NORMAL
- en: 'Of course, all of this segment tree stuff would be for naught unless it gives
    us fast queries. Finally, then, it’s time for the payoff: getting fast queries
    using a segment tree. It’s go time! Don’t worry—it doesn’t involve much more than
    the kind of recursion we’ve been using on segment trees so far.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To get a feel for this, we’ll make some sample queries on [Figure 8-18](ch08.xhtml#ch08fig018).
    Here’s that figure again:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/page_314_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'For our first query, let’s do 6-10\. This range covers only some of what the
    root’s 0-10 segment covers, so returning the root’s maximum index wouldn’t be
    justified. Instead, we’ll ask each of the root’s children for the maximum relevant
    index and use those answers to return the maximum index overall. The root’s left
    child covers Segment 0-5, and that has no overlap at all with our 6-10 range.
    The left recursive call tells us nothing. The root’s right child, however, covers
    exactly Segment 6-10\. The recursive call on that right child will return 7, and
    that’s what we should return overall: 7 is the index of the maximum element in
    the 6-10 range.'
  prefs: []
  type: TYPE_NORMAL
- en: For our second query, let’s do 3-8\. Again, we’ll ask each of the root’s children
    for the maximum relevant index—except that, this time, both children will have
    something to say, because 3-8 overlaps both 0-5 and 6-10\. The recursive call
    on the left child will return 3, and the recursive call on the right child will
    return 7\. At the root, then, all we do is compare the element at index 3 with
    the element at index 7\. The one at index 7 is higher, so that’s our answer.
  prefs: []
  type: TYPE_NORMAL
- en: I don’t normally unwind recursion, but I’ll make an exception here because I
    think it might help. Let’s further dive into the recursive call on the left subtree.
    We’re still querying 3-8, and the range of the node is 0-5\. The left child of
    0-5 is 0-2\. 0-2 doesn’t have any indices in common with our 3-8 query range,
    so it’s out. That leaves the 3-5 node to do the work. Importantly, 3-5 is completely
    contained within our desired 3-8 range, so we stop here and return 3 from the
    3-5 recursive call.
  prefs: []
  type: TYPE_NORMAL
- en: Querying the node of a segment tree falls into one of three cases, and we have
    seen them all in our examples here. Case 1 is when the node has no indices in
    common with the query range, case 2 is when the node’s segment is completely contained
    within the query range, and case 3 is when the node’s segment contains part of
    the query range but also contains indices not in the query range.
  prefs: []
  type: TYPE_NORMAL
- en: 'I recommend pausing here, just before we look at the code, to work a few more
    query examples by hand. In particular, try the query 4-9\. You’ll notice that
    it requires tracing two long paths down the tree. This is the worst-case behavior:
    we split into two nodes near the top of the tree, and then we trace those two
    paths all the way down. Convince yourself through further examples, perhaps on
    larger segment trees, that those paths cannot further subdivide into two long
    paths of their own. So, although querying a segment tree does do a little more
    work than a heap operation—sometimes tracing two paths rather than one—it still
    accesses a small number of nodes per level, giving an *O*(log *n*) runtime.'
  prefs: []
  type: TYPE_NORMAL
- en: The code for querying a segment tree is given in [Listing 8-16](ch08.xhtml#ch08ex016).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 8-16: Querying the segment tree*'
  prefs: []
  type: TYPE_NORMAL
- en: The function parameters are similar to those of [Listing 8-15](ch08.xhtml#ch08ex015),
    except that we’ve added the `left` and `right` indices of our query. The code
    handles each of the three cases in turn.
  prefs: []
  type: TYPE_NORMAL
- en: In case 1, the node has nothing in common with the query. This holds exactly
    when the query range ends before the node’s segment starts or when the query range
    starts after the node’s segment ends ❶. We return `-1` to indicate that this node
    has no maximum index to return.
  prefs: []
  type: TYPE_NORMAL
- en: In case 2, the node’s segment is completely within the query range ➋. We therefore
    return the maximum index of this node’s segment.
  prefs: []
  type: TYPE_NORMAL
- en: 'That leaves case 3, where the node’s segment partially overlaps the query range.
    We make two recursive calls: one to get the maximum index from the left child
    ➌ and one to get the maximum index from the right child ➍. If one of those returns
    `-1`, then we return the other. If they both return valid indices, then we choose
    the index whose element is larger ➎.'
  prefs: []
  type: TYPE_NORMAL
- en: '*Solution 2: Segment Trees*'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Our final order of business is to alter our first solution (specifically the
    `main` function in [Listing 8-9](ch08.xhtml#ch08ex09) and the `solve` function
    in [Listing 8-13](ch08.xhtml#ch08ex013)) to use segment trees. It won’t take much:
    we’ll just make the appropriate calls to the segment tree functions that we’ve
    already written.'
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 8-17](ch08.xhtml#ch08ex017) contains the new `main` function.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 8-17: The main function with segment trees added*'
  prefs: []
  type: TYPE_NORMAL
- en: The only additions are the declaration of the segment tree ❶, a call to initialize
    the segment tree’s segments ➋, a call to compute the maximum index for each segment
    tree node ➌, and a new argument to pass the segment tree along to the `solve`
    function ➍.
  prefs: []
  type: TYPE_NORMAL
- en: The new `solve` function itself is given in [Listing 8-18](ch08.xhtml#ch08ex018).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 8-18: Solving the problem with segment trees added*'
  prefs: []
  type: TYPE_NORMAL
- en: 'There’s only one substantive change: the call to `query_segtree` to implement
    the RMQ ❶!'
  prefs: []
  type: TYPE_NORMAL
- en: Phew! We had to work pretty hard there. This segment tree solution should pass
    all of the judge’s test cases within the time limit. In the end, it was worth
    it, though, because segment trees insinuate themselves into fast solutions to
    all kinds of problems.
  prefs: []
  type: TYPE_NORMAL
- en: Segment Trees
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Segment trees go by several other names in the wild, including interval trees,
    tournament trees, order-statistic trees, and range query trees. It doesn’t help
    that “segment tree” is also used to refer to an entirely different data structure
    than what we’ve studied here! Perhaps through my chosen terminology I have unknowingly
    aligned myself with some particular segment of the programmer population.
  prefs: []
  type: TYPE_NORMAL
- en: Whatever you call them, segment trees are must-know structures for those learning
    algorithms and those interested in competitive programming. On an underlying array
    of *n* elements, you can build a segment tree in *O*(*n*) time and query a range
    in *O*(log *n*) time.
  prefs: []
  type: TYPE_NORMAL
- en: In Building Treaps, we used segment trees to solve the RMQ, but segment trees
    can be used for other queries, too. If you can answer a query by quickly combining
    answers to two subqueries, then a segment tree is likely the tool of choice. What
    about a minimum range query? With a segment tree, you just take the minimum (not
    the maximum) of the children’s answers. What about a range sum query? With a segment
    tree, you just take the sum of the children’s answers.
  prefs: []
  type: TYPE_NORMAL
- en: 'Perhaps you’re wondering whether segment trees apply only when the elements
    of the underlying array remain constant through the execution of the program.
    In Building Treaps, for example, the treap nodes never changed, so there was no
    way in which our segment tree could ever become out of sync with what was stored
    in the array. Indeed, many segment tree problems share this characteristic: an
    array to be queried, not modified. However, a neat bonus feature of segment trees
    is that they can be used even when the underlying array is allowed to change.
    Problem 3 shows you how this is done, and it also shows us a new type of query
    that we haven’t seen before.'
  prefs: []
  type: TYPE_NORMAL
- en: '### Problem 3: Two Sum'
  prefs: []
  type: TYPE_NORMAL
- en: There is no context this time—this is just a pure problem for segment trees.
    As you’ll see, we’ll need to support updates to the array, and the query we’ll
    need is not the same as the RMQ.
  prefs: []
  type: TYPE_NORMAL
- en: This is SPOJ problem `KGSS`.
  prefs: []
  type: TYPE_NORMAL
- en: '*The Problem*'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: We are given a sequence of integers *a*[1], *a*[2], . . . , *a*[*n*], where
    each integer is at least 0\. (Think of the sequence as an array that starts at
    index 1 rather than 0.)
  prefs: []
  type: TYPE_NORMAL
- en: 'We need to support two types of operations on the sequence:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Update**   Given integers *x* and *y*, change *a*[*x*] to *y*.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Query**   Given integers *x* and *y*, return the maximum sum of two elements
    in the range *a*[*x*] to *a*[*y*].'
  prefs: []
  type: TYPE_NORMAL
- en: Input
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'The input contains one test case, consisting of the following lines:'
  prefs: []
  type: TYPE_NORMAL
- en: A line containing *n*, the number of elements in the sequence. *n* is between
    2 and 100,000.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A line containing *n* integers, each giving one element of the sequence in order
    from *a*[1] to *a*[*n*]. Each integer is at least 0.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A line containing *q*, the number of operations to be performed on the sequence.
    *q* is between 0 and 100,000.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*q* lines, each giving one update or query operation to be performed on the
    sequence.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Here are the operations that can be performed in those *q* lines.
  prefs: []
  type: TYPE_NORMAL
- en: '**Update**   An update operation is specified as the letter `U`, a space, an
    integer *x*, a space, and an integer *y*. It indicates that *a*[*x*] should be
    changed to *y*. For example, `U 1 4` means that *a*[1] is to be changed from its
    current value to 4\. *x* is between 1 and *n*; *y* is at least 0\. This operation
    does not result in any output.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Query**   A query operation is specified as the letter `Q`, a space, an integer
    *x*, a space, and an integer *y*. It indicates that we should output the maximum
    sum of two elements in the range *a*[*x*] to *a*[*y*]. For example, `Q 1 4` asks
    us for the maximum sum of two elements in the range *a*[1] to *a*[4]. *x* and
    *y* are between 1 and *n*, and *x* is less than *y*.'
  prefs: []
  type: TYPE_NORMAL
- en: Output
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Output the result of each query operation, one per line.
  prefs: []
  type: TYPE_NORMAL
- en: The time limit for solving the test case is one second.
  prefs: []
  type: TYPE_NORMAL
- en: '#### *Filling the Segment Tree*'
  prefs: []
  type: TYPE_NORMAL
- en: In Building Treaps, we needed the segment tree to give us indices of the underlying
    array, which we used to characterize the recursion and split the treap nodes.
    This time, however, there’s no reason to store indices in the segment tree. All
    we care about is the sum of elements, not the indices of those elements.
  prefs: []
  type: TYPE_NORMAL
- en: We’ll initialize the segments of our segment tree just like we did in “Initializing
    the Segments” on [page 310](ch08.xhtml#ch09lev1a). We now need the segments to
    start covering the array at index 1, not index 0, but otherwise there’s nothing
    new here. [Figure 8-19](ch08.xhtml#ch08fig019) shows a segment tree that supports
    a seven-element array. It covers indices 1 to 7, not 0 to 6, to correspond to
    the problem description.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/ch08fig19.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 8-19: A segment tree for a seven-element array*'
  prefs: []
  type: TYPE_NORMAL
- en: Add the code from [Listing 8-14](ch08.xhtml#ch08ex014) to your program.
  prefs: []
  type: TYPE_NORMAL
- en: Now let’s think about how to fill each node with the maximum sum of two elements
    in its segment. Suppose that we’ve already found the maximum sum of two elements
    for Node 1-2 and already found the maximum sum of two elements for Node 3-4\.
    We want to find the maximum sum of two elements for Node 1-4\. How do we do this?
  prefs: []
  type: TYPE_NORMAL
- en: Life was good when we were solving the RMQ, because the maximum for a node is
    just the maximum of its children. For example, if the maximum value in the left
    subtree is 10 and the maximum in the right subtree is 6, then the maximum for
    their parent node is 10\. No surprises there. In contrast, with this “maximum
    sum of two elements” segment tree, something weird happens.
  prefs: []
  type: TYPE_NORMAL
- en: 'Suppose we have these four sequence elements: 10, 8, 6, and 15\. The maximum
    sum of two elements in Segment 1-2 is 18, and the maximum sum of two elements
    in Segment 3-4 is 21\. Is 18 the answer for Segment 1-4, or is 21? Neither is
    correct! The answer is 10 + 15 = 25\. We can’t conjure up that 25 if all we know
    is the 18 from the left and 21 from the right. We need the left and right children
    to tell us more about their segment—more than just “Oh hey, here’s my maximum
    sum of two elements.”'
  prefs: []
  type: TYPE_NORMAL
- en: 'To be clear, sometimes getting back just the maximum sum of two elements from
    each child *is* enough. Consider this sequence: 10, 8, 6, and 4\. The maximum
    sum of two elements for Segment 1-2 is 18, and the maximum sum of two elements
    in Segment 3-4 is 10\. The maximum sum of two elements in 1-4 is 18, which happens
    to be the answer from its child segment 1-2—but that was lucky!'
  prefs: []
  type: TYPE_NORMAL
- en: 'There are at most three options for the maximum sum of two elements for a segment.
    (There are fewer than three options if a node’s child doesn’t have a valid maximum
    sum.) Those options are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Option 1**   The maximum sum is in the left child. This is like the lucky
    case that we just did. We get the answer from what the left child tells us.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Option 2**   The maximum sum is in the right child. This is another lucky
    case, where the answer is what the right child tells us.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Option 3**   The maximum sum includes one element from the left child and
    one element from the right child. This one requires more work, because the answer
    is not one of the maximums of our children. This is where we need more information
    from the children.'
  prefs: []
  type: TYPE_NORMAL
- en: If the maximum sum of two elements for some segment consists of one element
    from the left and one from the right, then it must use the maximum element from
    the left and the maximum element from the right. Let’s return to the sequence
    10, 8, 6, and 15\. The maximum sum here is an example that involves one element
    from the left (10) and one element from the right (15). Notice that these are
    the largest elements in the left and right segments, respectively. There’s no
    way to take an element from each side and do better than this.
  prefs: []
  type: TYPE_NORMAL
- en: Now we see what the segment tree nodes have to tell us. In addition to what
    the outside world cares about—the maximum sum of two elements—we also need the
    maximum element on its own. Combined, these two pieces of information about child
    segments enable us to fill in the information for the parent segment.
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 8-20](ch08.xhtml#ch08fig020) shows an example segment tree built for
    an array. Notice that each node contains both maxsum (the maximum sum of two elements)
    and maxelm (the maximum element).'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/ch08fig20.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 8-20: A segment tree and its corresponding array*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Computing the maximum element for each node is something that we know how to
    do: it’s just the RMQ problem that we solved in Building Treaps.'
  prefs: []
  type: TYPE_NORMAL
- en: That leaves the maximum sum of two elements for each node. To begin, we set
    the maximum sum for the nodes with one-element segments, such as 1-1, 2-2, and
    so on, to the special value –1\. The reason we do this is that there aren’t even
    two elements in these segments to choose from! The –1 alerts us that the parent’s
    maximum sum cannot be the maximum sum of this child.
  prefs: []
  type: TYPE_NORMAL
- en: The maximum sum for each other node is set based on the maximum sums of its
    children. Consider Node 1-7\. There are three options for its maximum sum. We
    could take the maximum sum 25 from the left, or we could take the maximum sum
    12 from the right, or we could take the maximum element 15 from the left and the
    maximum element 9 from the right to get 15 + 9 = 24\. Of these, 25 is the largest
    number, so that’s what we choose.
  prefs: []
  type: TYPE_NORMAL
- en: We make a special case of the fake –1 maximum sum values to highlight that those
    cannot be taken as options for the maximum sum of the parent node. Look out for
    this in the upcoming code.
  prefs: []
  type: TYPE_NORMAL
- en: 'We’ll use a struct for the segment tree nodes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'We’ll use another struct for what we will return from the `fill_segtree` and
    `query_segtree` functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: We need `node_info` because it lets us return both the maximum sum and the maximum
    element; returning one integer, without the struct, would not be sufficient.
  prefs: []
  type: TYPE_NORMAL
- en: The code for computing the maximum sum and the maximum element for each segment
    is given in [Listing 8-19](ch08.xhtml#ch08ex019).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 8-19: Adding the maximum sum and maximum element*'
  prefs: []
  type: TYPE_NORMAL
- en: When the segment contains just one element, we’re in the base case ❶. We set
    the maximum sum to the special `-1` value, which indicates that there is no valid
    sum of two elements here, and we set the maximum element to the only element in
    the segment. We then return the maximum sum and maximum element ➋.
  prefs: []
  type: TYPE_NORMAL
- en: Otherwise, we’re in the recursive case. We use `left_info` to hold the information
    for the left segment and `right_info` to hold the information for the right segment.
    Each of those variables is initialized using a recursive call ➌.
  prefs: []
  type: TYPE_NORMAL
- en: As we discussed, the maximum element in a segment is just the maximum of the
    maximum element in the left and the maximum element in the right ➍.
  prefs: []
  type: TYPE_NORMAL
- en: Now consider the maximum sum of two elements. If neither of the children has
    a maximum sum ➎, then we know that each child’s segment contains just one element.
    This parent therefore has only two elements in its segment, and adding up those
    elements is the only choice for the maximum sum of two elements ➏.
  prefs: []
  type: TYPE_NORMAL
- en: Next, what do we do if the left child has only one element and the right child
    has more than one element ❼? Well, now we have two options for the maximum sum
    for the parent. The first option is to add the maximum elements from each half.
    The second is to take the maximum sum from the right segment. We use `max` to
    take the best of these two. The case when the right child has only one element
    and left child has more than one element is analogous ❽.
  prefs: []
  type: TYPE_NORMAL
- en: 'The final case is when both children have more than one element ❾. Now we have
    three options: add the maximum elements from each half, take the maximum sum from
    the left, or take the maximum sum from the right.'
  prefs: []
  type: TYPE_NORMAL
- en: '*Querying the Segment Tree*'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The work we just did to fill in the segment information is going to pay off
    again, right now, for the code to query the segment tree. See [Listing 8-20](ch08.xhtml#ch08ex020).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 8-20: Querying the segment tree*'
  prefs: []
  type: TYPE_NORMAL
- en: The structure of this code parallels the RMQ code in [Listing 8-16](ch08.xhtml#ch08ex016).
    If the node’s segment has nothing in common with the query range ❶, we return
    a struct where both the maximum sum and maximum element are `-1`. We can use this
    special value of `-1` for the maximum element to tell us that there is no information
    available from a recursive call.
  prefs: []
  type: TYPE_NORMAL
- en: If the node’s segment is completely within the query range ➋, then we return
    the maximum sum and maximum element for this node.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, if the node’s segment partially overlaps the query range, then we follow
    the same logic as when we filled in the segment information in [Listing 8-19](ch08.xhtml#ch08ex019).
  prefs: []
  type: TYPE_NORMAL
- en: '*Updating the Segment Tree*'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: When an element of the sequence array is updated, we have to adjust the segment
    tree to keep pace. Otherwise, queries on the segment tree would use now-stale
    array elements and may therefore yield results at odds with what’s currently in
    the array.
  prefs: []
  type: TYPE_NORMAL
- en: One option is to start from scratch and ignore whatever segment information
    is already in the tree. We can do that by rerunning [Listing 8-19](ch08.xhtml#ch08ex019)
    each time an array element is updated. That would certainly bring the segment
    tree back up to date, so correctness is not a concern.
  prefs: []
  type: TYPE_NORMAL
- en: 'Efficiency is a concern, though! Rebuilding the segment tree takes *O*(*n*)
    time. All it would take to tank our performance is a stream of *q* update operations,
    with no query operations at all. That would force *n* work to be done a total
    of *q* times, for *O*(*nq*) performance. That’s especially grim if you think about
    the cost of updates with no segment tree at all: they’re constant-time operations
    on an array! We can’t afford to trade constant time for linear time. However,
    we *can* afford to trade constant time for logarithmic time, because the latter
    is very close to constant time.'
  prefs: []
  type: TYPE_NORMAL
- en: The way we escape the linear-time work is to realize that only a small number
    of segment tree nodes need to be updated when an element of the array is updated.
    Dismantling the entire tree for a single update is a gross overreaction.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let me explain what I mean by example. Here again is [Figure 8-20](ch08.xhtml#ch08fig020):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/unch08fig04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Now imagine the next operation is `U 4 1`, which means that index 4 of the sequence
    should be changed to value 1 (as the 15 that was there is gone). The new segment
    tree and array are shown in [Figure 8-21](ch08.xhtml#ch08fig021).
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/ch08fig21.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 8-21: A segment tree and its corresponding array following an array
    update*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Notice that only three nodes have changed. Node 4-4 has to change, of course,
    because the only element in its segment changed. However, the impact of that change
    can’t ripple too far: the only other nodes that can change are ancestors of 4-4,
    because those are the only other nodes that have an index of 4 in their segments!
    Indeed, in this example, you can confirm that the only other nodes that changed
    are the three ancestors 3-4, 1-4, and 1-7\. At worst, then, we go from a leaf
    of the tree to the root, updating nodes along that path. Since the height of the
    tree is *O*(log *n*), this path has only *O*(log *n*) nodes.'
  prefs: []
  type: TYPE_NORMAL
- en: As long as we don’t waste time on recursion through inoperative parts of the
    segment tree, we will end up with an *O*(log *n*) update procedure. [Listing 8-21](ch08.xhtml#ch08ex021)
    gives the code.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 8-21: Updating the segment tree*'
  prefs: []
  type: TYPE_NORMAL
- en: This function is designed to be called *after* the array element at the given
    `index` has been updated. Every call of this function is required to ensure that
    `node` is the root of a segment tree whose segment contains `index`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our base case is when the segment contains just one element ❶. Since we never
    make a recursive call unless `index` is in the node’s segment, we know this segment
    contains exactly our desired index. We thus update `max_element` of the node to
    whatever is now stored at `seq[index]`. We don’t update `max_sum`: it’s staying
    at `-1`, because this segment still has just one element in it.'
  prefs: []
  type: TYPE_NORMAL
- en: Now suppose we’re not in the base case. We have a node, and we know that exactly
    one of its elements, `index`, has been updated. There’s absolutely no reason,
    then, to make *two* recursive calls, since only one of the node’s children can
    house the updated element. If `index` is in the left child, then we want to make
    a recursive call on the left child to update the left subtree. If `index` is in
    the right child, then we want to make a recursive call on the right child to update
    the right subtree.
  prefs: []
  type: TYPE_NORMAL
- en: To determine which child `index` is in, we compare it to the rightmost index
    of the left child. If `index` comes before the left child’s segment ends ➋, then
    we need a recursive call on the left; otherwise, we need a recursive call on the
    right.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s talk a little about the case where we make a recursive call on the left
    ➌; the `else` branch, where we make a recursive call on the right, is similar.
    We make the recursive call that updates the left subtree and returns to us the
    information for that updated segment. For the right subtree, we just inherit what
    was there before ➍—there’s no update occurring there, so nothing can change.
  prefs: []
  type: TYPE_NORMAL
- en: The rest of the code parallels that of [Listing 8-19](ch08.xhtml#ch08ex019).
  prefs: []
  type: TYPE_NORMAL
- en: '*The main Function*'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: We’re now ready to use our souped-up segment tree to solve the problem. The
    code for the `main` function is given in [Listing 8-22](ch08.xhtml#ch08ex022).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 8-22: The main function for reading input and solving the problem*'
  prefs: []
  type: TYPE_NORMAL
- en: The only thing to highlight here is the logic for processing the operations.
    If the next operation is an update operation ❶, we respond by updating the array
    element and then updating the segment tree. Otherwise, the operation is a query
    operation ➋, and we respond by querying the segment tree.
  prefs: []
  type: TYPE_NORMAL
- en: It is time to submit the code. The judge should enjoy this fast, segment-tree-based
    solution.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, we studied how to implement and use heaps and segment trees.
    Like any useful data structure, these data structures support a small number of
    highly efficient operations. It’s not often that a data structure solves a problem
    on its own. More typically, you already have an algorithm whose speed is reasonable,
    and a data structure helps you make it even faster. For example, our implementation
    of Dijkstra’s algorithm in [Chapter 6](ch06.xhtml) already does quite well, but
    add a min-heap and it does even better.
  prefs: []
  type: TYPE_NORMAL
- en: Whenever you’re performing the same kind of operation over and over, you should
    seek out an opportunity to bolster your algorithm with a data structure. Are you
    searching for specified items in an array? Then hash tables are called for. Are
    you trying to find the maximum or minimum? Then heaps will do the trick. Are you
    querying segments of an array? Then employ segment trees. What about deciding
    whether two elements are in the same set? Well now, you’ll have to read the next
    chapter for that one!
  prefs: []
  type: TYPE_NORMAL
- en: Notes
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Supermarket Promotion is originally from the 2000 Polish Olympiad in Informatics,
    Stage 3\. Building Treaps is originally from the 2004 Ulm University Local Contest.
    Two Sum is originally from the 2009 Kurukshetra Online Programming Contest.
  prefs: []
  type: TYPE_NORMAL
- en: For more about segment trees and many other data structures, I recommend Matt
    Fontaine’s *Algorithms Live!* series of videos (see *[http://algorithms-live.blogspot.com](http://algorithms-live.blogspot.com)*).
    Matt’s segment tree video gave me the idea to explicitly store `left` and `right`
    segment indices in each node. (Most of the segment tree code you’ll see out there
    doesn’t do this, instead passing those indices around as additional function parameters
    that I always have trouble keeping straight.)
  prefs: []
  type: TYPE_NORMAL
