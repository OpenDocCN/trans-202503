- en: '**14**'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**ITERATIVE CONTROL STRUCTURES**'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/common01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Most programs spend the majority of their time executing machine instructions
    within a loop. Therefore, if you want to improve your applications’ execution
    speed, first you should see if you can improve the performance of the loops in
    your code. This chapter will describe the following varieties of loops:'
  prefs: []
  type: TYPE_NORMAL
- en: '`while` loops'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`repeat..until/do..while` loops'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`forever` (infinite) loops'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`for` (definite) loops'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**14.1 The while Loop**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `while` loop is perhaps the most general-purpose iterative statement that
    HLLs provide, so compilers generally work hard at emitting optimal code for it.
    The `while` loop tests a Boolean expression at the top of the loop body and, if
    the expression evaluates to `true`, executes the loop body. When the loop body
    completes execution, control transfers back to the test and the process repeats.
    When the Boolean control expression evaluates to `false`, the program transfers
    control to the first statement beyond the loop’s body. This means that if the
    Boolean expression evaluates to `false` when the program first encounters the
    `while` statement, the program immediately skips over all statements in the loop
    body without executing any of them. The following example demonstrates a Pascal
    `while` loop:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'You can easily simulate a `while` loop in an HLL by using an `if` statement
    and a `goto` statement. Consider the following C/C++ `while` loop and the semantically
    equivalent code using an `if` and a `goto`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Assume for the sake of this example that `x` is less than `y` when the `if`/`goto`
    combination first executes. This being `true`, the body of the loop (the `then`
    portion of the `if` statement) executes. At the bottom of the loop body, the `goto`
    statement transfers control back to just before the `if` statement. This means
    that the code will test the expression again, just as the `while` loop does. Whenever
    the `if` expression evaluates to `false`, control will transfer to the first statement
    after the `if` (which transfers control beyond the `goto` statement in this code).
  prefs: []
  type: TYPE_NORMAL
- en: 'Although the `if`/`goto` arrangement is semantically identical to the `while`
    loop, that’s not to suggest that the `if`/`goto` scheme presented here is more
    efficient than what a typical compiler would generate. It’s not. The following
    assembly code shows what you’d get from a mediocre compiler for the previous `while`
    loop:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'A decent compiler will improve upon this slightly by using a technique known
    as *code movement* (or *expression rotation*). Consider this slightly more efficient
    implementation of the previous `while` loop:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: This example has exactly the same number of machine instructions as the previous
    example, but the test for loop termination has been moved to the bottom of the
    loop. To preserve the semantics of a `while` loop (so that we don’t execute the
    loop body if the expression evaluates to `false` upon first encountering the loop),
    the first statement in this sequence is a `jmp` statement that transfers control
    down to the code that tests the loop termination expression. If that test evaluates
    to `true`, the program transfers control to the body of the `while` loop (immediately
    after `whlLabel`).
  prefs: []
  type: TYPE_NORMAL
- en: Although this code has the same number of statements as the previous example,
    there’s a subtle difference between the two implementations. In this latter example,
    the initial `jmp` instruction executes only once—the very first time the loop
    executes. For each iteration thereafter, the code skips the execution of this
    statement. In the original example, the corresponding `jmp` statement is at the
    bottom of the loop’s body, and it executes on each iteration of the loop. Therefore,
    if the loop body executes more than once, the second version runs faster (on the
    other hand, if the `while` loop rarely executes the loop body even once, then
    the first version is slightly more efficient). If your compiler does not generate
    the best code for a `while` statement, consider getting a different compiler.
    As [Chapter 13](ch13.xhtml#ch13) discussed, attempting to write optimal code in
    an HLL by using `if` and `goto` statements will produce difficult-to-read spaghetti
    code and, more often than not, `goto` statements in your code will actually impair
    the compiler’s ability to produce decent output.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*When this chapter discusses the repeat..until/do..while loop, you’ll see an
    alternative to the if..goto scheme that will produce more structured code that
    the compiler may be able to handle. Still, if your compiler cannot make a simple
    transformation like this one, chances are the efficiency of the compiled while
    loops is among the least of your problems.*'
  prefs: []
  type: TYPE_NORMAL
- en: Compilers that do a decent job of optimizing `while` loops typically make certain
    assumptions about the loop, the biggest one being that the loop has exactly one
    entry point and one exit point. Many languages provide statements allowing the
    premature exit of a loop (for example, `break`, as discussed in “Restricted Forms
    of the `goto` Statement” on [page 459](ch13.xhtml#page_459)). Of course, many
    languages provide some form of the `goto` statement that will allow you to enter
    or exit the loop at an arbitrary point. However, keep in mind that using such
    statements, while probably legal, may severely affect the compiler’s ability to
    optimize the code. So use them with caution.^([1](footnotes.xhtml#ch14fn1)) The
    `while` loop is one area where you should let the compiler do its job rather than
    trying to optimize the code yourself (actually, this applies for all loops, as
    compilers generally do a good job of optimizing loops).
  prefs: []
  type: TYPE_NORMAL
- en: '**14.1.1 Forcing Complete Boolean Evaluation in a while Loop**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The execution of a `while` statement depends upon the semantics of Boolean expression
    evaluation. As with the `if` statement, sometimes the correct execution of a `while`
    loop depends upon whether the Boolean expression uses complete evaluation or short-circuit
    evaluation. This section describes ways to force a `while` loop to use full Boolean
    evaluation, and the following section will demonstrate ways to force short-circuit
    evaluation.
  prefs: []
  type: TYPE_NORMAL
- en: At first blush, you might guess that forcing complete Boolean evaluation in
    a `while` loop is done the same way as in an `if` statement. However, if you look
    back at the solutions given for the `if` statement (see “Forcing Complete Boolean
    Evaluation in an `if` Statement” on [page 465](ch13.xhtml#page_465)), you’ll realize
    that the approaches we used for the `if` statement (nesting `if`s and temporary
    calculations) won’t work for a `while` statement. We need a different approach.
  prefs: []
  type: TYPE_NORMAL
- en: '**14.1.1.1 Using Functions the Easy but Inefficient Way**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'One easy way to force complete Boolean evaluation is to write a function that
    computes the result of the Boolean expression and use complete Boolean evaluation
    within that function. The following C code implements this idea:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Here’s the code that GCC (x86) emits for this C code (with a little cleanup
    to remove superfluous lines):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: As the assembly code demonstrates, the problem with this approach is that this
    code must make a function call and return (both of which are slow operations)
    in order to compute the value of the expression. For many expressions, the overhead
    of the call and return is more expensive than the actual computation of the expression’s
    value.
  prefs: []
  type: TYPE_NORMAL
- en: '**14.1.1.2 Using Inline Functions**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'The previous approach definitely doesn’t yield the greatest code you could
    obtain, in terms of either space or speed. If your compiler supports inline functions,
    you can produce a much better result by inlining `func()` in this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Here’s the conversion to (32-bit) x86 Gas assembly by the GCC compiler:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: As this example demonstrates, GCC compiles the function directly into the `while`
    loop’s test, sparing this program the overhead associated with the function call
    and return.
  prefs: []
  type: TYPE_NORMAL
- en: '**14.1.1.3 Using Bitwise Logical Operations**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'In the C programming language, which supports Boolean operations on bits (also
    known as *bitwise logical operations*), you can use the same trick employed for
    the `if` statement to force complete Boolean evaluation—just use the bitwise operators.
    In the special case where the left and right operands of the `&&` or *||* operators
    are always `0` or `1`, you can use code like the following to force complete Boolean
    evaluation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Here’s the assembly code that Borland C++ generates for this C source code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: As you can see in this 80x86 output, the compiler generates semantically equivalent
    code when using the bitwise logical operators. Just keep in mind that this code
    is valid only if you use `0` and `1` for the Boolean values `false` and `true`,
    respectively.
  prefs: []
  type: TYPE_NORMAL
- en: '**14.1.1.4 Using Unstructured Code**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'If you don’t have inline function capability or if bitwise logical operators
    aren’t available, you can use unstructured code to force complete Boolean evaluation
    as a last resort. The basic idea is to create an infinite loop and then write
    code to explicitly exit the loop if the condition fails. Generally, you’d use
    a `goto` statement (or a limited form of the `goto` statement like C’s `break`
    or `continue` statements) to control loop termination. Consider the following
    example in C:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'By using an infinite loop with an explicit break, we were able to compute the
    two components of the Boolean expression using separate C statements (hence, forcing
    the compiler to execute both subexpressions). Here’s the code that the MSVC++
    compiler produces:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, this program always evaluates both parts of the original Boolean
    expression (that is, you get complete Boolean evaluation).
  prefs: []
  type: TYPE_NORMAL
- en: You should be careful using unstructured code in this way. Not only is the result
    harder to read, but it’s difficult to coerce the compiler into producing the code
    you want. Furthermore, code sequences that produce good code on one compiler won’t
    produce comparable code on other compilers.
  prefs: []
  type: TYPE_NORMAL
- en: If your particular language doesn’t support a statement like `break`, you can
    always use a `goto` statement to break out of the loop and achieve the same result.
    Although injecting `goto`s into your code isn’t a great idea, in some cases it’s
    your only option.
  prefs: []
  type: TYPE_NORMAL
- en: '**14.1.2 Forcing Short-Circuit Boolean Evaluation in a while Loop**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Sometimes you need to guarantee short-circuit evaluation of the Boolean expression
    in a `while` statement even if the language (such as BASIC or Pascal) doesn’t
    implement that scheme. For the `if` statement, you can force short-circuit evaluation
    by rearranging the way you compute the loop-control expression in your program.
    Unlike in the `if` statement, you can’t use nested `while` statements or preface
    your `while` loop with other statements to force short-circuit evaluation, but
    it’s still possible to do in most programming languages.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the following C code fragment:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: This code could fail if C didn’t guarantee short-circuit evaluation of the Boolean
    expression.
  prefs: []
  type: TYPE_NORMAL
- en: As with forcing complete Boolean evaluation, the easiest approach in a language
    like Pascal is to write a function that computes and returns the Boolean result
    using short-circuit Boolean evaluation. However, this scheme is relatively slow
    because of the high overhead of a function call. Consider the following Pascal
    example:^([2](footnotes.xhtml#ch14fn2))
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'And now consider this 80x86 assembly code produced by Borland’s Delphi compiler
    (and disassembled with IDAPro):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: The `sub_408570` procedure contains the function that will compute the short-circuit
    Boolean evaluation of an expression similar to the one appearing in the earlier
    C code. As you can see, the code that dereferences `thePtr` never executes if
    `thePtr` contains NIL (`0`).
  prefs: []
  type: TYPE_NORMAL
- en: 'If a function call is out of the question, then about the only reasonable solution
    is to use an unstructured approach. The following is a Pascal version of the `while`
    loop in the earlier C code that forces short-circuit Boolean evaluation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Again, producing unstructured code, like the code in this example, is something
    you should do only as a last resort. But if the language (or compiler) you’re
    using doesn’t guarantee short-circuit evaluation and you need those semantics,
    unstructured code or inefficient code (using a function call) might be the only
    solution.
  prefs: []
  type: TYPE_NORMAL
- en: '**14.2 The repeat..until (do..until/do..while) Loop**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Another common loop that appears in most modern programming languages is `repeat..until`.
    This loop tests for its terminating condition at the bottom of the loop. This
    means that the loop’s body always executes at least once, even if the Boolean
    control expression evaluates to `false` on the first iteration of the loop. Although
    the `repeat..until` loop is a little less broadly applicable than the `while`
    loop, and you won’t use it anywhere near as often, there are many situations where
    the `repeat..until` loop is the best choice of control structure for the job.
    Perhaps the classic example is reading input from the user until the user inputs
    a certain value. The following Pascal code fragment is very typical:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: This loop always executes the body once. This, of course, is necessary because
    you must execute the loop’s body to read the user-entered value, which the program
    checks to determine when loop execution is complete.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `repeat..until` loop terminates when its Boolean control expression evaluates
    to `true` (rather than `false`, as for the `while` loop), as implied by the word
    *until*. Note, however, that this is a minor syntactical issue; the C/C++/Java/Swift
    languages (and many languages that share a C heritage) provide a `do..while` loop
    that repeats execution of the loop’s body as long as the loop condition evaluates
    to `true`. From an efficiency point of view, there’s absolutely no difference
    between these two loops, and you can easily convert one loop termination condition
    to the other by using your language’s logical NOT operator. The following examples
    demonstrate the syntax of the Pascal, HLA, and C/C++ `repeat..until` and `do..while`
    loops. Here’s the Pascal `repeat..until` loop example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Now here’s the C/C++ `do..while` version of the same loop:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'And here is the HLA `repeat..until` loop:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Converting the `repeat..until` (or `do..while`) loop into assembly language
    is relatively easy and straightforward. All the compiler needs to do is substitute
    code for the Boolean loop control expression and branch back to the beginning
    of the loop’s body if the expression evaluates affirmative (`false` for `repeat..until`
    or `true` for `do..while`). Here’s the straightforward pure assembly implementation
    of the earlier HLA `repeat..until` loop (compilers for C/C++ and Pascal would
    generate nearly identical code for the other examples):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, the code that a typical compiler generates for a `repeat..until`
    (or `do..while`) loop is usually a bit more efficient than the code you’ll get
    for a regular `while` loop. Thus, you should consider using the `repeat..until`/`do..while`
    form if semantically possible. In many programs, the Boolean control expression
    always evaluates to `true` on the first iteration of some loop constructs. For
    example, it’s not that uncommon to find a loop like the following in an application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'This `while` loop is easily converted to a `do..while` loop as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: This conversion is possible because we know that `i`’s initial value (`0`) is
    less than `100`, so the loop’s body always executes at least once.
  prefs: []
  type: TYPE_NORMAL
- en: As you’ve seen, you can help the compiler generate better code by using the
    more appropriate `repeat..until`/`do..while` loop rather than a regular `while`
    loop. Keep in mind, however, that the efficiency gain is small, so make sure you’re
    not sacrificing readability or maintainability by doing so. Always use the most
    logically appropriate loop construct. If the body of the loop always executes
    at least once, you should use a `repeat..until`/`do..while` loop, even if a `while`
    loop would work equally well.
  prefs: []
  type: TYPE_NORMAL
- en: '**14.2.1 Forcing Complete Boolean Evaluation in a repeat..until Loop**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Because the test for loop termination occurs at the bottom of the loop on a
    `repeat..until` (or `do..while`) loop, you force complete Boolean evaluation for
    it, similarly to how you do for an `if` statement. Consider the following C/C++
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Here’s the GCC output for the PowerPC (using short-circuit evaluation, which
    is standard for C) for the `do..while` loop:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: This program skips over the test for `b > g(y)` to label `L3` if the expression
    `a < f(x)` is `false` (that is, if `a >= f(x)`).
  prefs: []
  type: TYPE_NORMAL
- en: 'To force complete Boolean evaluation in this situation, our C source code needs
    to compute the subcomponents of the Boolean expression just prior to the `while`
    clause (keeping the results of the subexpressions in temporary variables) and
    then test only the results in the `while` clause:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Here’s the conversion to PowerPC code by GCC:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Of course, the actual Boolean expression (`temp1 && temp2`) still uses short-circuit
    evaluation, but only for the temporary variables created. The loop computes both
    of the original subexpressions regardless of the result of the first one.
  prefs: []
  type: TYPE_NORMAL
- en: '**14.2.2 Forcing Short-Circuit Boolean Evaluation in a repeat..until Loop**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'If your programming language provides a facility to break out of a `repeat..until`
    loop, such as C’s `break` statement, then forcing short-circuit evaluation is
    fairly easy. Consider the C `do..while` loop from the previous section that forces
    complete Boolean evaluation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'The following shows one way to convert this code so that it evaluates the termination
    expression using short-circuit Boolean evaluation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Here’s the code that GCC emits for the PowerPC for the `do..while` loop in
    this code sequence:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: If `a` is greater than or equal to the value that `f(x)` returns, this code
    immediately breaks out of the loop (at label `L3`) without testing to see if `b`
    is greater than the value `g(y)` returns. Hence, this code simulates short-circuit
    Boolean evaluation of the C/C++ expression `a < f(x) && b > g(y)`.
  prefs: []
  type: TYPE_NORMAL
- en: 'If the compiler you’re using doesn’t support a statement equivalent to C/C++’s
    `break` statement, you’ll have to use slightly more sophisticated logic. Here’s
    one way to do that:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'And here’s the PowerPC code that GCC produces for this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Although these examples have been using the conjunction operation (logical
    AND), using the disjunction operator (logical OR) is just as easy. To close off
    this section, consider this Pascal sequence and its conversion:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Here’s the conversion to force complete Boolean evaluation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Here’s the code that Borland’s Delphi produces for the two loops (assuming
    you select *complete Boolean evaluation* in the compiler’s options):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'The code that the Delphi compiler generates for this forced short-circuit evaluation
    is nowhere near as good as the code it would generate if you allowed it to do
    this job for you. Here’s the Delphi code with the *complete Boolean evaluation*
    option unselected (that is, instructing Delphi to use short-circuit evaluation):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: While this trick is useful for forcing short-circuit evaluation when the compiler
    does not support it, this latter Delphi example reiterates that you should use
    the compiler’s facilities if at all possible—you’ll generally get better machine
    code.
  prefs: []
  type: TYPE_NORMAL
- en: '**14.3 The forever..endfor Loop**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `while` loop tests for loop termination at the beginning (top) of the loop.
    The `repeat..until` loop tests for loop termination at the end (bottom) of the
    loop. The only place left to test for loop termination is somewhere in the middle
    of the loop’s body. The `forever..endfor` loop, along with some special loop termination
    statements, handles this case.
  prefs: []
  type: TYPE_NORMAL
- en: Most modern programming languages provide a `while` loop and a `repeat..until`
    loop (or their equivalents). Interestingly enough, only a few modern imperative
    programming languages provide an explicit `forever..endfor` loop.^([3](footnotes.xhtml#ch14fn3))
    This is especially surprising because the `forever..endfor` loop (along with a
    loop termination test) is actually the most general of the three forms. You can
    easily synthesize a `while` loop or a `repeat..until` loop from a single `forever..endfor`
    loop.
  prefs: []
  type: TYPE_NORMAL
- en: 'Fortunately, it’s easy to create a simple `forever..endfor` loop in any language
    that provides a `while` loop or a `repeat..until`/`do..while` loop. All you need
    do is supply a Boolean control expression that always evaluates to `false` for
    `repeat..until` or `true` for `do..while`. In Pascal, for example, you could use
    code such as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: The big problem with standard Pascal is that it doesn’t provide a mechanism
    (other than a generic `goto` statement) for explicitly breaking out of a loop.
    Fortunately, many modern Pascals, like Delphi and Free Pascal, provide a statement
    like `break` to immediately exit the current loop.
  prefs: []
  type: TYPE_NORMAL
- en: 'Although the C/C++ language does not provide an explicit statement that creates
    a `forever` loop, the syntactically bizarre `for(;;)` statement has served this
    purpose since the very first C compiler was written. Therefore, C/C++ programmers
    can create a `forever..endfor` loop as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'C/C++ programmers can use C’s `break` statement (along with an `if` statement)
    to place a loop termination condition in the middle of a loop, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'The HLA language provides an explicit (high-level) `forever..endfor` statement
    (along with a `break` and a `breakif` statement) that lets you terminate the loop
    somewhere in the middle. This HLA `forever..endfor` loop tests for loop termination
    in the middle of the loop:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'Converting a `forever..endfor` loop into pure assembly language is trivial—all
    you need is a single `jmp` instruction that can transfer control from the bottom
    of the loop back to the top of the loop. The implementation of the `break` statement
    is just as simple: it’s just a jump (or conditional jump) to the first statement
    following the loop. The following two code fragments demonstrate an HLA `forever..endfor`
    loop (along with a `breakif`) and the corresponding “pure” assembly code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'Of course, you can also rotate this code to create a slightly more efficient
    version:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: If the language you’re using doesn’t support a `forever..endfor` loop, any decent
    compiler will convert a `while(true)` statement into a single jump instruction.
    If your compiler doesn’t do so, then it does a poor job of optimization, and any
    attempts to manually optimize the code are a lost cause. For reasons you’ll soon
    see, you shouldn’t try to create the `forever..endfor` loop using a `goto` statement.
  prefs: []
  type: TYPE_NORMAL
- en: '**14.3.1 Forcing Complete Boolean Evaluation in a forever Loop**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Because you exit from a `forever` loop using an `if` statement, the techniques
    for forcing complete Boolean evaluation when exiting a `forever` loop are the
    same as for an `if` statement. See “Forcing Complete Boolean Evaluation in an
    `if` Statement” on [page 465](ch13.xhtml#page_465) for details.
  prefs: []
  type: TYPE_NORMAL
- en: '**14.3.2 Forcing Short-Circuit Boolean Evaluation in a forever Loop**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Likewise, because you exit from a `forever` loop using an `if` statement, the
    techniques for forcing short-circuit Boolean evaluation when exiting a `forever`
    loop are the same as for a `repeat..until` statement. See “Forcing Short-Circuit
    Boolean Evaluation in a `repeat..until` Loop” on [page 524](ch14.xhtml#page_524)
    for details.
  prefs: []
  type: TYPE_NORMAL
- en: '**14.4 The Definite Loop (for Loops)**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `forever..endfor` loop is an *infinite* loop (assuming you don’t break
    out of it via a `break` statement). The `while` and `repeat..until` loops are
    examples of *indefinite* loops because, in general, the program cannot determine
    how many iterations they will execute when it first encounters them. For a *definite*
    loop, on the other hand, the program can determine exactly how many iterations
    the loop will repeat prior to executing the first statement of the loop’s body.
    A good example of a definite loop in a traditional HLL is Pascal’s `for` loop,
    which uses the following syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: which iterates over the range `expr1..expr2` if expr1 is less than or equal
    to expr2, or
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'which iterates over the range `expr1..expr2` if expr1 is greater than or equal
    to expr2. Here’s a typical example of a Pascal `for` loop:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'This loop always executes exactly 10 times; hence, it’s a definite loop. However,
    this doesn’t imply that a compiler has to be able to determine the number of loop
    iterations at compile time. Definite loops also allow the use of expressions that
    force the program to determine the number of iterations at runtime. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'The Pascal compiler cannot determine the number of iterations this loop will
    execute. In fact, because the number of iterations is dependent upon user input,
    it could vary each time this loop executes in a single execution of the enclosing
    program. However, the program can determine exactly how many iterations the loop
    will execute, indicated by the value in the `cnt` variable, whenever it encounters
    this loop. Note that Pascal (like most languages that support definite loops)
    expressly forbids code such as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: You are not allowed to change the value of the loop control variable during
    the execution of the loop’s body. In this example, should you try to change the
    `for` loop’s control variable, a high-quality Pascal compiler will detect that
    attempt and report an error. Also, a definite loop computes the starting and ending
    values only once. Therefore, if the `for` loop modifies a variable that appears
    as the second expression, it does not reevaluate the expression on each iteration
    of the loop. For example, if the body of the `for` loop in the previous example
    modifies the value of `j`, this will not affect the number of loop iterations.^([4](footnotes.xhtml#ch14fn4))
  prefs: []
  type: TYPE_NORMAL
- en: Definite loops have certain special properties that allow a (good) compiler
    to generate better machine code. In particular, because the compiler can determine
    how many iterations the loop will execute prior to executing the first statement
    of the loop’s body, the compiler can often dispense with complex tests for loop
    termination and simply decrement a register down to `0` to control the number
    of loop iterations. The compiler can also use induction to optimize access to
    the loop control variable in a definite loop (see the description of induction
    in “Optimization of Arithmetic Statements” on [page 397](ch12.xhtml#page_397)).
  prefs: []
  type: TYPE_NORMAL
- en: 'C/C++/Java users should note that the `for` loop in these languages is not
    a true definite loop; rather, it is a special case of the indefinite `while` loop.
    Most good C/C++ compilers will attempt to determine if a `for` loop is a definite
    loop and, if so, they’ll generate decent code. You can help your compiler by following
    these guidelines:'
  prefs: []
  type: TYPE_NORMAL
- en: Your C/C++ `for` loops should use the same semantics as the definite (`for`)
    loops in languages such as Pascal. That is, the `for` loop should initialize a
    single loop control variable, test for loop termination when that value is less
    than or greater than some ending value, and increment or decrement the loop control
    variable by 1.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Your C/C++ `for` loops should not modify the value of the loop control variable
    within the loop.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The test for loop termination remains static over the execution of the loop’s
    body. That is, the loop body should not be able to change the termination condition
    (which, by definition, would make the loop an indefinite loop). For example, if
    the loop termination condition is `i < j`, the loop body should not modify the
    value of `i` or `j`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The loop body does not pass the loop control variable or any variable appearing
    in the loop termination condition by reference to a function if that function
    modifies the actual parameter.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**14.5 For More Information**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: “For More Information” on [page 501](ch13.xhtml#page_501) applies to this chapter
    as well. Please see that section for more details.
  prefs: []
  type: TYPE_NORMAL
