- en: <hgroup>
  prefs: []
  type: TYPE_NORMAL
- en: 11 PARAMETERS AND ARGUMENTS
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: </hgroup>
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/chapter.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In the previous chapter, I demonstrated how a bat file can call both internal
    routines and other bat files, but I didn’t discuss how to pass data back and forth
    between the calling and called logic. By default, all variables set in the calling
    code are exposed to the called code, and vice versa. If the code is closely coupled,
    there’s technically no need to pass arguments and accept parameters, but to make
    that work, both sets of code must agree on and use the same set of variables.
  prefs: []
  type: TYPE_NORMAL
- en: That’s adequate if you’re creating a second bat file simply to break up a large
    project and the called bat file will never be called from elsewhere, but to make
    more generic code that’s reusable by other processes and coders, the act of parameterizing
    the data going in and out of bat files and routines is critical.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, I’ll detail everything you need to know about arguments and
    parameters, including the esoteric syntax unique to Batch. You’ll learn how to
    pass arguments to a bat file or routine and how to accept returned parameters.
    You’ll even learn about the hidden parameter, how and why to shift parameters,
    and how to pass arguments to a bat file with just a few mouse clicks.
  prefs: []
  type: TYPE_NORMAL
- en: Passing Arguments
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To demonstrate how to pass arguments and accept parameters, I’ll write a short
    bat file that builds a simple example of Mad Libs, the game that made long car
    trips tolerable for kids before the ubiquity of handheld electronic devices. The
    bat file accepts three ordered parameters (an adjective, a verb, and a noun) and
    inserts them into the following text before displaying the result to the user:'
  prefs: []
  type: TYPE_NORMAL
- en: Bats are _______ (adjective) mammals. They _______ (verb) around in caves, but
    if you stand under them, you might get hit with _______ (noun).
  prefs: []
  type: TYPE_NORMAL
- en: I’m not sharing the called bat file with you just yet, because I’ll first concentrate
    on how to call *MadLibs.bat* while passing it the three arguments. After all,
    the calling bat file really doesn’t care how the sausage is made; it just wants
    a grinder. The calling bat file needs to know only the arguments to pass and the
    expected results. That’s it. (In the next section, I’ll look at this from the
    perspective of the called bat file, *MadLibs.bat*.)
  prefs: []
  type: TYPE_NORMAL
- en: 'In [Chapter 10](chapter10.xhtml), I demonstrated how the call command invokes
    another bat file. That’s exactly what the next command is doing, but now three
    arguments follow the name of the bat file representing an adjective, a verb, and
    a noun, precisely in that order, all delimited by spaces:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Someone is obviously cheating because the result written to the console makes
    far too much sense for this game:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'More typically, if an 11-year-old boy were to play this game, he might come
    up with the following set of words representing an adjective, verb, and noun:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The result is
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: which somehow still works—at least for a preteen boy.
  prefs: []
  type: TYPE_NORMAL
- en: Argument Delimiters
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The passed arguments in the previous example are delimited from each other
    and the name of the called bat file by spaces. The space is by far the most common
    delimiter, with the comma a definitive second, but the semicolon, equal sign,
    and tab character also work. Consider these two call commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Both commands are functionally equivalent, but the second looks to be an exercise
    in obfuscations.
  prefs: []
  type: TYPE_NORMAL
- en: 'Comma-delimited data is fairly common (for instance, the contents of a *.csv*
    file). Because the comma is in the set of Batch argument delimiters, you can store
    comma-delimited data in a variable and then resolve that variable as part of a
    call command like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The interpreter treats each piece of text separated by a comma as a unique argument
    (assuming other delimiters aren’t in the data). This might look like a single
    argument, but in reality, the command is passing three arguments.
  prefs: []
  type: TYPE_NORMAL
- en: Argument Encasing
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Looking at the list of permissible argument delimiters does raise an interesting
    question: Is it possible to pass spaces and the other delimiters as actual argument
    data? Yes, it’s very possible, but first consider the problem posed by these (three?)
    arguments:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Someone is clearly being very difficult, using two-word versions of the three
    arguments. (And anyone who uses ad hominem as a Mad Libs adjective is being more
    pretentious than difficult. He’s probably a certain guy in the office correcting
    everyone’s use of parameter and argument.) The result is six arguments, not three,
    for the interpreter to handle.
  prefs: []
  type: TYPE_NORMAL
- en: Since a space is one of the characters for delimiting arguments, the interpreter
    considered ad to be the adjective argument, while the verb argument is hominem,
    and the noun argument is took. This results in a nonsensical word salad, even
    by the standard of Mad Libs. The remainder of the command, off ice cream, becomes
    the fourth, fifth, and sixth arguments to a bat file that accepts only three;
    they are duly ignored with no further harm done.
  prefs: []
  type: TYPE_NORMAL
- en: 'The solution to this issue is to encase each argument in double quotes, which
    also provides the side benefit of being far more readable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The called bat file needs to do something to work with arguments that may or
    may not be double quoted, and I’ll get to that shortly.
  prefs: []
  type: TYPE_NORMAL
- en: 'With all of this in place, the output at least makes grammatical sense, mostly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'The encasing double quotes provide another great advantage; they’ll hold the
    place of any missing arguments or those set to spaces. For instance, just to be
    contrarian, someone might refuse to supply the first argument. (After all, dropping
    an adjective will still make grammatical sense, but omitting a noun or verb will
    surely break the sentence structure.) Without the double quotes in the following
    example, the second argument would skew to become the first, and the third would
    become the second. Instead, three arguments are being passed, even if the first
    is null:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'The hop and fudge arguments correctly map to the verb and noun, respectively,
    and there’s no adjective, resulting in the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: The encasing double quotes also allow you to the use commas, semicolons, equal
    signs, and even tab characters as arguments or as part of arguments.
  prefs: []
  type: TYPE_NORMAL
- en: Argument Variables
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Up to this point I’ve shown only hardcoded arguments, but more often than not,
    arguments are variables, and if you can’t be absolutely certain that there are
    no (and never will be) embedded spaces, I suggest adding double quotes to the
    resolved variables:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: When the call command executes, the three argument variables are resolved and
    passed to the called bat file, each encased in double quotes.
  prefs: []
  type: TYPE_NORMAL
- en: '> NOTE'
  prefs: []
  type: TYPE_NORMAL
- en: '*The “parameter versus argument” argument: there’s some debate about the difference
    between these two terms. I’ve seen different definitions, but I’m writing with
    the distinction that* arguments *are passed from the* calling *code, and* parameters
    *are accepted by the* called *code. But there’s a gray area, and it’s commonplace
    to hear coders talking about “passing parameters” and “receiving arguments.” We
    all know what’s meant. I don’t want to be that pedantic jerk in the office correcting
    everyone, but I’ll try to use these words consistently.*'
  prefs: []
  type: TYPE_NORMAL
- en: Accepting Parameters
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Let’s change our perspective by 180 degrees and look at [Listing 11-1](#Lis11-1)
    where the called bat file accepts the three parameters, which means finally sharing
    the entirety of *MadLibs.bat*, which produced multiple rounds of output in the
    previous examples.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 11-1: The MadLibs.bat bat file accepts three parameters and displays
    a Mad Lib.'
  prefs: []
  type: TYPE_NORMAL
- en: Any bat file that accepts parameters should begin in one of two ways. It should
    have remarks detailing the parameters that the bat file accepts, or it should
    define the parameters at the top of the file with set commands using unambiguously
    named variables. For this bat file, I chose the latter approach.
  prefs: []
  type: TYPE_NORMAL
- en: The first parameter is descriptively named adjective, and %~1 is the best syntax
    for resolving the first argument passed into a bat file. Incrementing the integer
    gives us the value of the second argument, %~2, which is assigned to verb. Finally,
    another unambiguously named variable, noun, is assigned to the third argument,
    %~3.
  prefs: []
  type: TYPE_NORMAL
- en: Resolving Parameters with a Tilde
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'This next point is as important as it is subtle; if you remove the tilde from
    the first line of the bat file, %1 resolves to the first parameter exactly as
    it’s received, with or without double quotes. However, %~1 resolves to the first
    parameter with its encasing double quotes removed—and if there are no double quotes
    to remove, the resolved parameter is unchanged, so the tilde causes no harm. The
    same holds for the other parameters: %~2 resolves to the second parameter with
    any double quotes removed, and %2 resolves to that parameter as it was passed.'
  prefs: []
  type: TYPE_NORMAL
- en: The inclusion of the tilde is exactly what I was referring to in the prior section
    when I mentioned that the called bat file would need to do something in order
    to work with arguments that may or may not be encased in double quotes in the
    call command. The *MadLibs.bat* file clearly has the syntax with the tilde allowing
    it to work both ways, thus providing a courtesy to the coder of the calling bat
    file.
  prefs: []
  type: TYPE_NORMAL
- en: 'The *only* time that I wouldn’t use a tilde to resolve a parameter is when
    I explicitly want to maintain the double quotes, and such instances are rare at
    best. Using the tilde gives the calling bat file the flexibility to use double
    quotes or not. Consider these functionally equivalent commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: The calling bat file must use the double quotes for arguments with any embedded
    spaces, such as the third one above; otherwise, the double quotes aren’t required,
    but they won’t hurt. I mentioned that these two commands are functionally equivalent,
    but that wouldn’t be true if *MadLibs.bat* hadn’t used the tildes in the first
    three commands.
  prefs: []
  type: TYPE_NORMAL
- en: If you think the syntax for resolving a parameter looks odd, you aren’t alone.
    Variables are typically resolved with two percent signs, but here a single percent
    sign is followed by a one-digit number (or a tilde and a number) and nothing else.
    Variables named with a leading number can’t be resolved with percent signs, so
    when the interpreter sees a percent sign followed by a number (with maybe a tilde
    between them) a parameter is assumed. Once understood, it does offer a very concise
    syntax for resolving parameters.
  prefs: []
  type: TYPE_NORMAL
- en: Resolving the Entire Parameter List
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You can resolve an entire parameter list, regardless of the number of values,
    simply with a percent sign followed by an asterisk, which is very handy when a
    called bat file wants to call another bat file or a routine passing along the
    same parameter list. Consider this command inside a called bat file, particularly
    the trailing %* characters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'This command is passing an argument list consisting of a simple variable, followed
    by the parameter list coming into the bat file or routine. I’ve encased the first
    argument, the arg0 variable, in double quotes just in case it contains any embedded
    delimiter characters, such as a space; this ensures that the interpreter treats
    the variable as a single argument, not multiple arguments. The rest of the arguments
    are the complete set of parameters passed into the called bat file, regardless
    of how many. Ultimately, the first parameter into the bat file is the second argument
    in the call, and so on. (Spoiler alert: we’ll use this technique extensively when
    we get to object-oriented design in [Chapter 32](chapter32.xhtml).)'
  prefs: []
  type: TYPE_NORMAL
- en: Internal Routine Parameters
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To this point I’ve discussed parameters only in reference to the calling of
    another bat file. Fortunately, there really is no difference when calling a routine
    inside a bat file. We can easily rewrite the complete bat file from [Listing 11-1](#Lis11-1)
    as an internal routine. Notice in [Listing 11-2](#Lis11-2) that the only difference
    is the addition of the label.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 11-2: The :MadLibs routine accepts three parameters and displays a
    Mad Lib.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The call command to invoke the routine has the same arguments, and the double
    quotes are handled the same way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: The only difference is that a label is called instead of another bat file. Everything
    else works exactly the same.
  prefs: []
  type: TYPE_NORMAL
- en: The Hidden Parameter
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Many modern languages treat the incoming parameter list as an array, in particular
    a zero-offset array. Coupling that with the fact that Batch surprisingly uses
    a zero-offset for substringing, many coders have looked for a parameter in %~0
    (yours truly included). The result can be befuddling, as adding the following
    echo command at the top of the routine from [Listing 11-2](#Lis11-2) demonstrates:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'The text written to the console contains the name of the routine being executed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Before I explain what exactly is going on, earlier in the chapter, the Mad
    Libs logic was in an external file and called like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Take the same echo command added to the previous :MadLibs routine, and add
    it to the called bat file from [Listing 11-1](#Lis11-1), and the result is the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: I hesitate to call %0 the first parameter. It’s more of a hidden parameter coming
    just prior to the first parameter. From this example, it’s obvious that the hidden
    parameter is the name of the routine or bat file being executed, but where’s it
    coming from?
  prefs: []
  type: TYPE_NORMAL
- en: A bat file is often the first argument of the call command, and that argument
    is passed into the called bat file itself as %0. In fact, %0 matches the capitalization
    of the path and filename (or label name) in the call command, not the capitalization
    of the actual path and filename. If the path isn’t part of the argument, it isn’t
    part of %0. Furthermore, if the call command has double quotes around the path
    and filename, so will %0. For that reason, it’s usually best to resolve it with
    the tilde, %~0, just like the other parameters.
  prefs: []
  type: TYPE_NORMAL
- en: The hidden parameter is omnipresent in all bat files, not just called bat files
    or called routines. Even a high-level bat file, the one that you may have started
    with a double mouse click, has its path and filename in the hidden parameter.
    We don’t often think about what’s going on when we open a bat file, but it isn’t
    magic. Windows executes a call command, with the bat file as its only argument,
    for you. The result is %0 being resolved to the path and the name of the bat file
    encased in double quotes.
  prefs: []
  type: TYPE_NORMAL
- en: This hidden parameter has many uses. For error handling, it offers an easy means
    of logging the routine in which the error occurred. If the bat file is moved to
    a different directory, computer, or domain, the hidden parameter allows the bat
    file to know its location. When we get to the for command, there’s a relatively
    straightforward means of retrieving just the path from a variable holding a path
    and filename. You can then use it in any number of ways. For instance, you can
    drop output files into a subfolder under the bat file, or the bat file can perform
    different actions based on where it resides. It’s a very useful, and hidden, feature
    of Batch.
  prefs: []
  type: TYPE_NORMAL
- en: Shifting Parameters
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If the first parameter is resolved with %~1 and the ninth parameter is resolved
    with %~9, it might make sense that the 10th parameter would be resolved with %~10.
    Alas no, the interpreter recognizes only parameters 0 through 9, or single-digit
    ordinal numbers. It would be nice if a compiler could gently remind you that %~10
    isn’t a valid parameter, but again no, this is Batch. To demonstrate what can
    go wrong when this parameter is resolved, consider the example of a double-digit
    parameter list shown in [Listing 11-3](#Lis11-3). The first half of the alphabet
    is being passed to a routine that’s attempting to write five selected letters
    to the console.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 11-3: A first pass at the routine :Alphabet to display five parameters'
  prefs: []
  type: TYPE_NORMAL
- en: 'The first three look fine, but parameters 10 and 13 look to be junk:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: When we humans ponder %~13, we see the number 13 and might expect the 13th parameter,
    M, to be resolved. But the interpreter has never been confused with artificial
    intelligence, much less human intelligence. When it encounters %~13, it sees the
    first parameter, %~1, which is resolved to A, followed by the hardcoded value
    3. The result is A3. Similarly, %~10 resolves to the first parameter, but it’s
    appended with a zero, resulting in A0.
  prefs: []
  type: TYPE_NORMAL
- en: 'Batch, however, isn’t limited to only nine parameters. In fact, I’ve seen dozens
    passed as there’s no practical limit (other than the limit of 8,191 characters
    in any command). To access the 10th parameter and beyond, you need the shift command.
    To demonstrate, let’s fix the :Alphabet routine from [Listing 11-3](#Lis11-3):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'The resolutions of parameters 1, 2, and 9 are unchanged before the shift command
    executes, which shifts each parameter one position to the left. The second becomes
    the first, the third becomes the second, and the 10th parameter becomes the ninth.
    It may be counterintuitive, but after a shift command, %~9 resolves to parameter
    10\. Then after three more shift commands, %~9 resolves to M, the 13th parameter,
    producing the desired output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: When introducing the command separator (&) in [Chapter 2](chapter2.xhtml), I
    mentioned you should use it sparingly. In other situations, it can make a mess
    of the code, but shift is such a simple and succinct command, putting three on
    one line actually cleans up the code.
  prefs: []
  type: TYPE_NORMAL
- en: Note that the shift command doesn’t impact the resolution of %*. This funky
    syntax still resolves to the complete and original parameter list regardless of
    how many shift commands execute.
  prefs: []
  type: TYPE_NORMAL
- en: 'Shifting the parameters raises an interesting question. What happens to the
    path and filename resolved with %0 after the shift command executes? The short
    answer is that it gets wiped out and replaced with the first parameter, at least
    by default. But the shift command has a lone option, and that option defines which
    parameter gets dropped with the shift; all parameters prior to it are maintained.
    It’s formatted differently from the options we’ve described to this point. The
    /n option drops the *n*th parameter, so that the following command drops the first
    and preserves %0:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Parameter 0, or the hidden parameter, is unchanged. Parameter 1 is discarded
    while parameter 2 slides over to become parameter 1\. The third parameter becomes
    the second, and so on. With a small change, the following command preserves the
    first four parameters (and the hidden parameter), while discarding the fifth:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Parameter 6 is shifted to parameter 5, and the rest are shifted accordingly.
  prefs: []
  type: TYPE_NORMAL
- en: This option accepts parameters 0 through 8—although there’s no need to use /0
    as that’s the default behavior. For some unknown reason, /9 is invalid. Don’t
    ask.
  prefs: []
  type: TYPE_NORMAL
- en: Returning Parameters
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You now know how to pass arguments to routines and other bat files and write
    the received parameters to the console, but in the real coding world many routines
    accept some parameters and pass others back to the caller. Because Batch variables
    in a called process are globally available, some coders simply set a hardcoded
    variable name in a routine and use it elsewhere. Such Philistines! A far more
    elegant and flexible solution is to allow the caller to define the name of the
    variable returned.
  prefs: []
  type: TYPE_NORMAL
- en: NOTE
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*I’m using* Philistines *as a pejorative, but not without pause. Today the
    term is concise shorthand for brutish individuals indifferent to aesthetics and
    artistry, and that’s exactly how I’m using it. But we wouldn’t slur an entire
    people if they had modern day representation. Even the gypsy moth is being renamed,
    rightly, so as not to offend a group of people, although the moth can still be
    slandered with impunity. I’m sure that there were both good and bad Philistines,
    but because they were completely wiped out over two and half millennia ago and
    viewed unfavorably in the texts of three major world religions, their name is
    taken in vain with little or no remorse. In recent decades even our more distant
    cousin, the Neanderthals, have enjoyed a more rehabilitated image than the Philistines.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following example contains three parameters; the first two are numbers
    to be added and the third is the result of the addition. This routine may be short,
    but due to its complexity, a comment is really needed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: To the right of the equal sign in the set /A command, the first two parameters
    are being resolved and added together. To the left of the equal sign—that is,
    what’s being set—is the cryptic text %~3. A variable name in this area may have
    been expected, but instead the third parameter is being resolved. The set /A command
    is in fact setting a named variable to the sum of the two numbers. Most important,
    that variable name is the third parameter passed into this routine. This technique
    isn’t difficult, but it’s unintuitive, and it isn’t common in other languages.
    I’ve seen it flummox many a coder.
  prefs: []
  type: TYPE_NORMAL
- en: 'An example of a call to the routine should clarify what’s happening. The following
    call command passes two numbers and a variable name, where the double quotes are
    optional:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'After this call, the sum variable contains the value of 15. I can’t stress
    enough that with this technique, the calling code defines the name of the variable
    to be returned. To further make this point, the three calls in this example are
    done to the same :Add routine:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: The first two have hardcoded numbers, returning the sum1 and sum2 variables,
    respectively. Both of those variables are resolved and passed as arguments in
    the third call, returning sum4Nbrs.
  prefs: []
  type: TYPE_NORMAL
- en: 'Notice that sum1 and sum2 don’t have delimiting percent signs in the first
    two calls because the variable name is being passed. But in the third call, I’m
    resolving them because their values are being passed—the same values that were
    assigned during the first two calls. Finally, the echo command writes this to
    the console:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: The same variable used as the output for one call is the input for another,
    but can the variable be used for both purposes in a single call?
  prefs: []
  type: TYPE_NORMAL
- en: One Variable as Input and Output
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'A single variable can simultaneously be an input to and an output of a routine
    or bat file. To set this up, imagine a routine that squares an integer. The first
    parameter is the input, and the second parameter is the output—simply the input
    multiplied by itself:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: The routine doesn’t show much that we haven’t already discussed, although the
    input of %~1 is used twice. The calling code defines the output variable, which
    is resolved as %~2 in the routine.
  prefs: []
  type: TYPE_NORMAL
- en: 'The calling code could use two different variables for the input and output.
    But suppose that you want to replace a variable’s value with its square. To accomplish
    this, you could pass its value as the first argument—notice the percent signs
    encasing it—and pass the name of the variable as the second argument, not encased
    with percent signs:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: If nbr was set to 5 before the call, it’ll be set to 25 afterward. The :Square
    routine offers some real flexibility, usable with two different variables or the
    same one.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s make one more tweak to this code and write a routine with a single parameter
    that’s both the input and output. The parameter is a variable containing a number
    as its value, and the routine replaces that value with its square, which makes
    calling the routine even easier:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: First, notice the new routine (or label) name. More important, notice that the
    routine accepts a single argument, the unresolved variable name of an integer—not
    the integer value.
  prefs: []
  type: TYPE_NORMAL
- en: Comparing :SquareMe to the :Square routine, the set /A command has two critical
    updates. First, instead of multiplying %~1 by itself, !%~1! is now each operand.
    In the prior example, a value was being accepted, but now a variable name is the
    input, so %~1 resolves to the variable name, and with the use of delayed expansion,
    the exclamation marks resolve that name to the integer value. (Have I yet mentioned
    the true awesomeness of delayed expansion? The applications are limited only by
    your imagination.)
  prefs: []
  type: TYPE_NORMAL
- en: The second change is that the product is being assigned to the first parameter,
    %~1, and not the second, %~2. Remember that in :SquareMe the sole parameter is
    now the variable name. The result is that a call to this routine changes the value
    of the variable even though that variable isn’t explicitly mentioned in the routine.
  prefs: []
  type: TYPE_NORMAL
- en: NOTE
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*I’ve demonstrated return parameters with routines, but returning a parameter
    from a called bat file works virtually the same way. Actually, it works exactly
    the same way if the called bat file is* not *limiting scope via the setlocal and
    endlocal commands. If it is limiting scope, there’s a special technique that allows
    one or more variables to survive the endlocal, and I’ll detail it in [Chapter
    16](chapter16.xhtml).*'
  prefs: []
  type: TYPE_NORMAL
- en: Input Parameter Lists of Varying Lengths
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let’s build more of a real-world routine that uses what we’ve learned so far
    in this chapter. The following routine accepts a list of one-to-many numbers (no
    reasonable limit) and returns two variables, one populated with the sum of the
    inputs and the other populated with the product of the inputs:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Since we don’t know how many input parameters to expect for a given call, we
    put those at the end of the parameter list, with the output parameters occupying
    the first two positions. (No one said inputs must come before outputs.) Due to
    its complexity, the :Arithmetic routine includes much needed comments defining
    the parameter list.
  prefs: []
  type: TYPE_NORMAL
- en: The sum, represented as %~1 because it doesn’t yet have an actual variable name,
    is initialized to 0. Likewise, the product, %~2, is initialized to 1. (For my
    fellow math geeks, that’s what we respectively call additive and multiplicative
    unity.) Ignore the second label, :NextParm, for a moment and focus on the two
    set /A commands that follow. The first command sets the first parameter, the sum,
    to itself plus the first input number on the list, %~3, which is the third parameter.
    Similarly, the next command sets the second parameter, the product, to itself
    multiplied by the first number on the list, again %~3.
  prefs: []
  type: TYPE_NORMAL
- en: The shift command that comes next is crucial. The number of input parameters
    is unknown, so we want to discard the just used third parameter and shift the
    parameters that come after it to the left without disturbing the first two, which
    are also the return parameters in this instance. The /3 option accomplishes that
    seamlessly. Next, we look at the newly minted third parameter to see whether it’s
    populated. Keep in mind that this was the second input number on the original
    list or the fourth overall parameter before the shift. If it’s populated, we’ll
    go back to the :NextParm label that we ignored earlier. Now those two set /A commands
    add and multiply the second input parameter to the sum and product, respectively.
  prefs: []
  type: TYPE_NORMAL
- en: This process repeats until the list of numbers, regardless of its length, is
    exhausted, at which point the conditional clause of the if command is false, allowing
    control to fall to the trailing goto :eof command and the routine passes back
    the first two parameters.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code tests the new routine:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'The resulting text is written to the console:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: By the way, if this construct looks familiar, that’s because it’s an example
    of a Batch do...while command from [Chapter 9](chapter9.xhtml). At least one input
    parameter is assumed, and the routine performs the arithmetic as long as, or *while*,
    more parameters exist.
  prefs: []
  type: TYPE_NORMAL
- en: Drag-and-Drop Parameters
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: With a few mouse clicks, you can pass the path and name of any file, or multiple
    files, into a bat file. It’s something that dumbfounded multiple people, including
    me when I was learning Batch. Simply right-click on any file and select **Copy**;
    then right-click on the bat file to execute and select **Paste**. The bat file
    executes, with the sole parameter being the path and filename of the copied file
    (encased in double quotes if the path or filename has embedded spaces). Alternatively,
    you can select the file, drag, and drop it onto the bat file with the same result.
  prefs: []
  type: TYPE_NORMAL
- en: This technique works for any number of files. If you copy *n* files onto your
    bat file, *n* space-delimited parameters are passed—each one being a path and
    filename. The same is true if you drag and drop *n* files onto your bat file,
    and it even works for directories.
  prefs: []
  type: TYPE_NORMAL
- en: At first, the dragging and dropping of files onto a bat file might seem like
    little more than a Batch parlor trick, but its uses are manifold. You can design
    a wrapper bat file that processes a single file. Maybe a program is being executed
    with a file as input; the program might convert the file to a different format
    or add a trailer record. Maybe the Batch code will simply rename the file or add
    an extension to the existing filename. What’s important is that the bat file is
    performing some action on an input file.
  prefs: []
  type: TYPE_NORMAL
- en: 'One possible action is to simply copy the input file to another directory.
    Consider the following two commands that make up the entirety of *BackUpOneFile.bat*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: The first argument to the xcopy command, which is %1, resolves to the bat file’s
    first parameter, which will be the path and filename of any file dragged and dropped
    onto *BackUpOneFile.bat*. The command copies the input file to the desired target
    path, some deep hard to reach folder on the *D:\* drive. (I’m intentionally retaining
    any encasing double quotes with the %1 syntax, instead of %~1, because the xcopy
    command requires the double quotes if the path or filename have any embedded spaces.)
    Finally, the pause command simply holds the window open for the user to see the
    result of the copy.
  prefs: []
  type: TYPE_NORMAL
- en: Ultimately, if you place *BackUpOneFile.bat* on the Windows desktop, you can
    quickly drag and drop any one file onto it, and the bat file will copy the input
    file to the desired directory without your needing to navigate to that directory.
  prefs: []
  type: TYPE_NORMAL
- en: In order to pass an argument to a bat file without this drag-and-drop technique,
    you must enter a call command (into another bat file or at the command prompt)
    with the input file keyed in as the argument. But with this technique, any user,
    even noncoders, can easily run the bat file without any input from the keyboard.
    You can create a Windows shortcut for the bat file located anywhere on the network
    so as to hide the source Batch code, making it more difficult for a user to accidentally
    delete or modify it.
  prefs: []
  type: TYPE_NORMAL
- en: When a path and filename is passed to a bat file as a parameter, Batch offers
    an easy way to get quite a bit of information about the file, such as the last
    modified date and time, size, attributes, path, extension, filename, and more.
    I’ll discuss this in detail after exploring the for command in [Chapter 17](chapter17.xhtml).
    The for command will also unlock loops, so that if we drag and drop *n* files
    onto a bat file, each can be processed sequentially.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This chapter along with [Chapters 8](chapter8.xhtml) through [10](chapter10.xhtml)
    have hopefully opened up your Batch universe to far more than a single routineless
    sequentially executed bat file. In the not-so-distant past, your bat files couldn’t
    call executables or other bat files, and the interpreter executed each command
    just once and in order until it found the end of the bat file. But now you have
    the tools to start building interesting and complex bat files.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, you learned how to pass arguments to bat files and routines
    and receive them as parameters in the called bat file. I detailed how to delimit
    the arguments and even how to pass the delimiters themselves as arguments. You
    also got a glimpse of the hidden parameter, the Yeti of the Batch universe. I
    demonstrated how to pass back caller-defined variables containing a return value.
    You may have even learned how to play Mad Libs.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, I’ll expand that universe even more by introducing various
    outputs, created by both the interpreter and you. I’ll show you how to capture
    the output of Batch commands and how to create files of your own.
  prefs: []
  type: TYPE_NORMAL
