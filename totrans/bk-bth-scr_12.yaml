- en: <hgroup>
  id: totrans-0
  prefs: []
  type: TYPE_NORMAL
  zh: <hgroup>
- en: 11 PARAMETERS AND ARGUMENTS
  id: totrans-1
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 11 参数和参数传递
- en: </hgroup>
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: </hgroup>
- en: '![](../images/chapter.jpg)'
  id: totrans-3
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/chapter.jpg)'
- en: In the previous chapter, I demonstrated how a bat file can call both internal
    routines and other bat files, but I didn’t discuss how to pass data back and forth
    between the calling and called logic. By default, all variables set in the calling
    code are exposed to the called code, and vice versa. If the code is closely coupled,
    there’s technically no need to pass arguments and accept parameters, but to make
    that work, both sets of code must agree on and use the same set of variables.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在前一章中，我演示了如何通过 bat 文件调用内部例程和其他 bat 文件，但我没有讨论如何在调用逻辑和被调用逻辑之间传递数据。默认情况下，所有在调用代码中设置的变量都对被调用代码可见，反之亦然。如果代码紧密耦合，从技术上讲，不需要传递参数和接受参数，但要使其生效，两个代码集必须达成一致并使用相同的变量集。
- en: That’s adequate if you’re creating a second bat file simply to break up a large
    project and the called bat file will never be called from elsewhere, but to make
    more generic code that’s reusable by other processes and coders, the act of parameterizing
    the data going in and out of bat files and routines is critical.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您只是创建一个第二个 bat 文件来拆分一个大型项目，并且被调用的 bat 文件永远不会从其他地方调用，那么这样做是可以接受的。但为了创建更通用的代码，使得其他过程和程序员可以重复使用，参数化传递给
    bat 文件和例程的数据是至关重要的。
- en: In this chapter, I’ll detail everything you need to know about arguments and
    parameters, including the esoteric syntax unique to Batch. You’ll learn how to
    pass arguments to a bat file or routine and how to accept returned parameters.
    You’ll even learn about the hidden parameter, how and why to shift parameters,
    and how to pass arguments to a bat file with just a few mouse clicks.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我将详细介绍您需要了解的所有关于参数和参数传递的知识，包括 Batch 独有的晦涩语法。您将学习如何将参数传递给 bat 文件或例程，以及如何接受返回的参数。您甚至会了解隐藏参数、如何以及为什么要调整参数，以及如何通过几次鼠标点击将参数传递给
    bat 文件。
- en: Passing Arguments
  id: totrans-7
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 传递参数
- en: 'To demonstrate how to pass arguments and accept parameters, I’ll write a short
    bat file that builds a simple example of Mad Libs, the game that made long car
    trips tolerable for kids before the ubiquity of handheld electronic devices. The
    bat file accepts three ordered parameters (an adjective, a verb, and a noun) and
    inserts them into the following text before displaying the result to the user:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 为了演示如何传递参数和接受参数，我将编写一个简短的 bat 文件，构建一个简单的 Mad Libs 示例，这是一个在便携式电子设备普及之前，让孩子们在长时间车程中保持耐心的游戏。这个
    bat 文件接受三个顺序参数（一个形容词，一个动词和一个名词），并将它们插入以下文本中，然后显示结果给用户：
- en: Bats are _______ (adjective) mammals. They _______ (verb) around in caves, but
    if you stand under them, you might get hit with _______ (noun).
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 蝙蝠是 _______（形容词）哺乳动物。它们在洞穴中 _______（动词）飞来飞去，但如果你站在它们下方，你可能会被 _______（名词）砸中。
- en: I’m not sharing the called bat file with you just yet, because I’ll first concentrate
    on how to call *MadLibs.bat* while passing it the three arguments. After all,
    the calling bat file really doesn’t care how the sausage is made; it just wants
    a grinder. The calling bat file needs to know only the arguments to pass and the
    expected results. That’s it. (In the next section, I’ll look at this from the
    perspective of the called bat file, *MadLibs.bat*.)
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 我还不打算与您分享这个调用的 bat 文件，因为我首先会集中讲解如何在传递这三个参数时调用*MadLibs.bat*。毕竟，调用的 bat 文件并不关心香肠是如何做出来的；它只需要一个绞肉机。调用的
    bat 文件只需要知道要传递的参数和预期的结果，仅此而已。（在下一部分，我将从被调用的 bat 文件 *MadLibs.bat* 的角度来分析这个问题。）
- en: 'In [Chapter 10](chapter10.xhtml), I demonstrated how the call command invokes
    another bat file. That’s exactly what the next command is doing, but now three
    arguments follow the name of the bat file representing an adjective, a verb, and
    a noun, precisely in that order, all delimited by spaces:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第10章](chapter10.xhtml)中，我演示了如何使用 call 命令调用另一个 bat 文件。接下来的命令正是如此操作的，不过现在，bat
    文件名后面跟着三个参数，分别是形容词、动词和名词，按照这个顺序，且每个参数之间用空格分隔：
- en: '[PRE0]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Someone is obviously cheating because the result written to the console makes
    far too much sense for this game:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 显然有人在作弊，因为写入控制台的结果对这个游戏来说太合理了：
- en: '[PRE1]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'More typically, if an 11-year-old boy were to play this game, he might come
    up with the following set of words representing an adjective, verb, and noun:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 更典型的情况是，如果一个11岁的男孩玩这个游戏，他可能会想到以下一组代表形容词、动词和名词的词：
- en: '[PRE2]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The result is
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 结果是
- en: '[PRE3]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: which somehow still works—at least for a preteen boy.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方式不知为何仍然有效——至少对于一个青少年男孩来说是这样。
- en: Argument Delimiters
  id: totrans-20
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 参数分隔符
- en: 'The passed arguments in the previous example are delimited from each other
    and the name of the called bat file by spaces. The space is by far the most common
    delimiter, with the comma a definitive second, but the semicolon, equal sign,
    and tab character also work. Consider these two call commands:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，传递的参数通过空格彼此分隔，并且与被调用的批处理文件名分开。空格无疑是最常见的分隔符，逗号是第二常用的分隔符，但分号、等号和制表符也可以作为分隔符。考虑以下两个调用命令：
- en: '[PRE4]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Both commands are functionally equivalent, but the second looks to be an exercise
    in obfuscations.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 两个命令在功能上是等效的，但第二个命令看起来像是故意混淆其意图的练习。
- en: 'Comma-delimited data is fairly common (for instance, the contents of a *.csv*
    file). Because the comma is in the set of Batch argument delimiters, you can store
    comma-delimited data in a variable and then resolve that variable as part of a
    call command like so:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 逗号分隔的数据是相当常见的（例如*.csv*文件的内容）。因为逗号是批处理参数分隔符的一部分，你可以将逗号分隔的数据存储在一个变量中，然后将该变量作为命令的一部分传递，像这样：
- en: '[PRE5]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The interpreter treats each piece of text separated by a comma as a unique argument
    (assuming other delimiters aren’t in the data). This might look like a single
    argument, but in reality, the command is passing three arguments.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 解释器将每一段由逗号分隔的文本视为一个独立的参数（假设数据中没有其他分隔符）。这看起来可能像是一个参数，但实际上命令传递了三个参数。
- en: Argument Encasing
  id: totrans-27
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 参数封装
- en: 'Looking at the list of permissible argument delimiters does raise an interesting
    question: Is it possible to pass spaces and the other delimiters as actual argument
    data? Yes, it’s very possible, but first consider the problem posed by these (three?)
    arguments:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 查看允许的参数分隔符列表会引发一个有趣的问题：是否可以将空格和其他分隔符作为实际的参数数据传递？是的，这完全可能，但首先要考虑以下这些（三个？）参数所带来的问题：
- en: '[PRE6]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Someone is clearly being very difficult, using two-word versions of the three
    arguments. (And anyone who uses ad hominem as a Mad Libs adjective is being more
    pretentious than difficult. He’s probably a certain guy in the office correcting
    everyone’s use of parameter and argument.) The result is six arguments, not three,
    for the interpreter to handle.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 显然有人在故意制造麻烦，使用三个参数的双词版本。（而任何把“ad hominem”作为《疯狂填字游戏》形容词使用的人，其实比制造麻烦还更为做作。他可能是办公室里那个纠正每个人使用“参数”和“论点”错误的人。）结果是，解释器需要处理六个参数，而不是三个。
- en: Since a space is one of the characters for delimiting arguments, the interpreter
    considered ad to be the adjective argument, while the verb argument is hominem,
    and the noun argument is took. This results in a nonsensical word salad, even
    by the standard of Mad Libs. The remainder of the command, off ice cream, becomes
    the fourth, fifth, and sixth arguments to a bat file that accepts only three;
    they are duly ignored with no further harm done.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 由于空格是分隔参数的字符之一，解释器将“ad”视为形容词参数，而动词参数是“hominem”，名词参数是“took”。这导致了一个毫无意义的词组，即便是按照《疯狂填字游戏》的标准来看也显得荒谬。命令的其余部分“off
    ice cream”变成了一个接收最多三个参数的批处理文件的第四、第五和第六个参数；它们被适当忽略，不会造成进一步的影响。
- en: 'The solution to this issue is to encase each argument in double quotes, which
    also provides the side benefit of being far more readable:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 解决这个问题的方法是将每个参数用双引号括起来，这样做还有一个额外的好处，就是可读性大大提高：
- en: '[PRE7]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The called bat file needs to do something to work with arguments that may or
    may not be double quoted, and I’ll get to that shortly.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 被调用的批处理文件需要处理可能被双引号包裹的参数，稍后我会详细讲解。
- en: 'With all of this in place, the output at least makes grammatical sense, mostly:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这些设置，输出至少在语法上是有意义的，大致正确：
- en: '[PRE8]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The encasing double quotes provide another great advantage; they’ll hold the
    place of any missing arguments or those set to spaces. For instance, just to be
    contrarian, someone might refuse to supply the first argument. (After all, dropping
    an adjective will still make grammatical sense, but omitting a noun or verb will
    surely break the sentence structure.) Without the double quotes in the following
    example, the second argument would skew to become the first, and the third would
    become the second. Instead, three arguments are being passed, even if the first
    is null:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 包裹的双引号提供了另一个巨大优势；它们能够占据任何缺失参数或设置为空格的参数的位置。例如，作为一种反向思维，某人可能拒绝提供第一个参数。（毕竟，省略形容词仍然能保持语法正确，但省略名词或动词必定会破坏句子结构。）如果没有双引号，在以下示例中，第二个参数会偏移成为第一个，第三个则变成第二个。相反，即使第一个参数为空，依然传递了三个参数：
- en: '[PRE9]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The hop and fudge arguments correctly map to the verb and noun, respectively,
    and there’s no adjective, resulting in the following output:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: hop 和 fudge 参数正确映射到 verb 和 noun，而没有 adjective，因此输出如下：
- en: '[PRE10]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The encasing double quotes also allow you to the use commas, semicolons, equal
    signs, and even tab characters as arguments or as part of arguments.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 双引号的包围还允许你将逗号、分号、等号甚至制表符作为参数或参数的一部分使用。
- en: Argument Variables
  id: totrans-42
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 参数变量
- en: 'Up to this point I’ve shown only hardcoded arguments, but more often than not,
    arguments are variables, and if you can’t be absolutely certain that there are
    no (and never will be) embedded spaces, I suggest adding double quotes to the
    resolved variables:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我只展示了硬编码的参数，但实际上，参数通常是变量。如果你不能百分百确定没有（并且永远不会有）嵌入的空格，建议你在解析后的变量周围加上双引号：
- en: '[PRE11]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: When the call command executes, the three argument variables are resolved and
    passed to the called bat file, each encased in double quotes.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 当调用命令执行时，三个参数变量会被解析并传递给被调用的 bat 文件，每个参数都被双引号包围。
- en: '> NOTE'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '> 注意'
- en: '*The “parameter versus argument” argument: there’s some debate about the difference
    between these two terms. I’ve seen different definitions, but I’m writing with
    the distinction that* arguments *are passed from the* calling *code, and* parameters
    *are accepted by the* called *code. But there’s a gray area, and it’s commonplace
    to hear coders talking about “passing parameters” and “receiving arguments.” We
    all know what’s meant. I don’t want to be that pedantic jerk in the office correcting
    everyone, but I’ll try to use these words consistently.*'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '*“参数与论据”的争论：关于这两个术语之间的区别有一些争议。我见过不同的定义，但我在写作时使用的是这样一个区分：* 论据 *是从* 调用 *代码传递的，*
    参数 *是被* 被调用 *代码接受的。但也有灰色地带，程序员常常谈论“传递参数”和“接收论据”。我们都知道什么意思。我不想成为那个在办公室里纠正每个人的刻板讨厌家伙，但我会尽量保持这些词的一致使用。*'
- en: Accepting Parameters
  id: totrans-48
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 接受参数
- en: Let’s change our perspective by 180 degrees and look at [Listing 11-1](#Lis11-1)
    where the called bat file accepts the three parameters, which means finally sharing
    the entirety of *MadLibs.bat*, which produced multiple rounds of output in the
    previous examples.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过 180 度转变视角，来看一下[示例 11-1](#Lis11-1)，在这个示例中，被调用的 bat 文件接受三个参数，这意味着最终共享 *MadLibs.bat*
    文件，该文件在前面的示例中生成了多轮输出。
- en: '[PRE12]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Listing 11-1: The MadLibs.bat bat file accepts three parameters and displays
    a Mad Lib.'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 11-1：MadLibs.bat 文件接受三个参数并显示一个 Mad Lib。
- en: Any bat file that accepts parameters should begin in one of two ways. It should
    have remarks detailing the parameters that the bat file accepts, or it should
    define the parameters at the top of the file with set commands using unambiguously
    named variables. For this bat file, I chose the latter approach.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 任何接受参数的 bat 文件应该以两种方式之一开始。它应该包含说明 bat 文件接受哪些参数的注释，或者它应该在文件顶部使用 set 命令定义这些参数，并使用明确命名的变量。对于这个
    bat 文件，我选择了后一种方式。
- en: The first parameter is descriptively named adjective, and %~1 is the best syntax
    for resolving the first argument passed into a bat file. Incrementing the integer
    gives us the value of the second argument, %~2, which is assigned to verb. Finally,
    another unambiguously named variable, noun, is assigned to the third argument,
    %~3.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个参数被描述性地命名为 adjective，而 %~1 是解析传递给 bat 文件的第一个参数的最佳语法。递增该整数可以得到第二个参数的值 %~2，并将其赋值给
    verb。最后，另一个明确命名的变量 noun 被赋值为第三个参数 %~3。
- en: Resolving Parameters with a Tilde
  id: totrans-54
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 解析带波浪号的参数
- en: 'This next point is as important as it is subtle; if you remove the tilde from
    the first line of the bat file, %1 resolves to the first parameter exactly as
    it’s received, with or without double quotes. However, %~1 resolves to the first
    parameter with its encasing double quotes removed—and if there are no double quotes
    to remove, the resolved parameter is unchanged, so the tilde causes no harm. The
    same holds for the other parameters: %~2 resolves to the second parameter with
    any double quotes removed, and %2 resolves to that parameter as it was passed.'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个要点既重要又微妙；如果你从 bat 文件的第一行中去掉波浪号，%1 会解析为接收到的第一个参数，无论是否有双引号。然而，%~1 会解析为去掉双引号的第一个参数——如果没有双引号需要去掉，解析后的参数保持不变，因此波浪号不会带来任何问题。其他参数也一样：%~2
    解析为去掉双引号的第二个参数，%2 则解析为传递的原始参数。
- en: The inclusion of the tilde is exactly what I was referring to in the prior section
    when I mentioned that the called bat file would need to do something in order
    to work with arguments that may or may not be encased in double quotes in the
    call command. The *MadLibs.bat* file clearly has the syntax with the tilde allowing
    it to work both ways, thus providing a courtesy to the coder of the calling bat
    file.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 波浪号的使用正是我在前一节中提到的内容，指的是被调用的批处理文件需要做些什么，以便处理可能被或可能不被双引号括起来的参数。*MadLibs.bat*文件显然使用了波浪号的语法，使它能够同时兼容两种情况，从而给调用批处理文件的开发者提供了便利。
- en: 'The *only* time that I wouldn’t use a tilde to resolve a parameter is when
    I explicitly want to maintain the double quotes, and such instances are rare at
    best. Using the tilde gives the calling bat file the flexibility to use double
    quotes or not. Consider these functionally equivalent commands:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 我*唯一*不会使用波浪号来解析参数的情况是当我明确希望保留双引号时，而这种情况极为罕见。使用波浪号可以让调用的批处理文件灵活地选择是否使用双引号。请考虑以下这两个功能上等价的命令：
- en: '[PRE13]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The calling bat file must use the double quotes for arguments with any embedded
    spaces, such as the third one above; otherwise, the double quotes aren’t required,
    but they won’t hurt. I mentioned that these two commands are functionally equivalent,
    but that wouldn’t be true if *MadLibs.bat* hadn’t used the tildes in the first
    three commands.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 调用的批处理文件必须使用双引号来处理任何包含空格的参数，例如上面提到的第三个参数；否则，双引号不是必需的，但使用它们不会有害。我提到这两个命令在功能上是等价的，但如果*MadLibs.bat*没有在前面三个命令中使用波浪号，那就不成立了。
- en: If you think the syntax for resolving a parameter looks odd, you aren’t alone.
    Variables are typically resolved with two percent signs, but here a single percent
    sign is followed by a one-digit number (or a tilde and a number) and nothing else.
    Variables named with a leading number can’t be resolved with percent signs, so
    when the interpreter sees a percent sign followed by a number (with maybe a tilde
    between them) a parameter is assumed. Once understood, it does offer a very concise
    syntax for resolving parameters.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你觉得解析参数的语法看起来很奇怪，那你并不孤单。变量通常通过两个百分号来解析，但在这里，单个百分号后面跟着一个一位数（或波浪号和数字），别无他物。以数字开头的变量不能通过百分号解析，因此当解释器看到百分号后跟着一个数字（可能中间有一个波浪号）时，就会认为这是一个参数。一旦理解了，它确实提供了一个非常简洁的语法来解析参数。
- en: Resolving the Entire Parameter List
  id: totrans-61
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 解析整个参数列表
- en: 'You can resolve an entire parameter list, regardless of the number of values,
    simply with a percent sign followed by an asterisk, which is very handy when a
    called bat file wants to call another bat file or a routine passing along the
    same parameter list. Consider this command inside a called bat file, particularly
    the trailing %* characters:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过在参数列表前加上百分号和星号，轻松解析整个参数列表，无论值的数量如何，这在被调用的批处理文件需要调用另一个批处理文件或例程并传递相同的参数列表时非常方便。考虑以下命令，特别是末尾的%*字符：
- en: '[PRE14]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'This command is passing an argument list consisting of a simple variable, followed
    by the parameter list coming into the bat file or routine. I’ve encased the first
    argument, the arg0 variable, in double quotes just in case it contains any embedded
    delimiter characters, such as a space; this ensures that the interpreter treats
    the variable as a single argument, not multiple arguments. The rest of the arguments
    are the complete set of parameters passed into the called bat file, regardless
    of how many. Ultimately, the first parameter into the bat file is the second argument
    in the call, and so on. (Spoiler alert: we’ll use this technique extensively when
    we get to object-oriented design in [Chapter 32](chapter32.xhtml).)'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 该命令传递了一个由简单变量组成的参数列表，后面跟着传递到批处理文件或例程的参数列表。我已将第一个参数，即arg0变量，用双引号括起来，以防它包含任何嵌入的分隔符字符，如空格；这确保了解释器将该变量视为单一参数，而不是多个参数。其余的参数是传递到被调用的批处理文件的完整参数集，无论数量如何。最终，传递到批处理文件的第一个参数是调用中的第二个参数，以此类推。（剧透：当我们在[第32章](chapter32.xhtml)讲解面向对象设计时，我们将广泛使用这项技术。）
- en: Internal Routine Parameters
  id: totrans-65
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 内部例程参数
- en: To this point I’ve discussed parameters only in reference to the calling of
    another bat file. Fortunately, there really is no difference when calling a routine
    inside a bat file. We can easily rewrite the complete bat file from [Listing 11-1](#Lis11-1)
    as an internal routine. Notice in [Listing 11-2](#Lis11-2) that the only difference
    is the addition of the label.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我只讨论了与调用另一个 bat 文件相关的参数。幸运的是，在调用 bat 文件内部的例程时，实际上并没有什么不同。我们可以轻松地将[列表 11-1](#Lis11-1)中的完整
    bat 文件重写为一个内部例程。请注意，在[列表 11-2](#Lis11-2)中，唯一的区别是添加了标签。
- en: '[PRE15]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Listing 11-2: The :MadLibs routine accepts three parameters and displays a
    Mad Lib.'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 11-2：`:MadLibs` 例程接受三个参数并显示一个 Mad Lib。
- en: 'The call command to invoke the routine has the same arguments, and the double
    quotes are handled the same way:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 调用例程的 call 命令具有相同的参数，并且双引号的处理方式也相同：
- en: '[PRE16]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The only difference is that a label is called instead of another bat file. Everything
    else works exactly the same.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 唯一的区别是调用了一个标签，而不是另一个 bat 文件。其他一切都完全一样。
- en: The Hidden Parameter
  id: totrans-72
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 隐藏参数
- en: 'Many modern languages treat the incoming parameter list as an array, in particular
    a zero-offset array. Coupling that with the fact that Batch surprisingly uses
    a zero-offset for substringing, many coders have looked for a parameter in %~0
    (yours truly included). The result can be befuddling, as adding the following
    echo command at the top of the routine from [Listing 11-2](#Lis11-2) demonstrates:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 许多现代语言将传入的参数列表视为一个数组，特别是一个零偏移的数组。再加上批处理文件意外地使用零偏移来进行子字符串提取，许多程序员曾经尝试在 %~0 中寻找一个参数（包括我自己）。结果可能让人困惑，正如在[列表
    11-2](#Lis11-2)中展示的，添加以下 echo 命令来说明这一点：
- en: '[PRE17]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The text written to the console contains the name of the routine being executed:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 写入控制台的文本包含正在执行的例程的名称：
- en: '[PRE18]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Before I explain what exactly is going on, earlier in the chapter, the Mad
    Libs logic was in an external file and called like so:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在我解释到底发生了什么之前，章节前面提到过，Mad Libs 的逻辑在一个外部文件中，并像这样被调用：
- en: '[PRE19]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Take the same echo command added to the previous :MadLibs routine, and add
    it to the called bat file from [Listing 11-1](#Lis11-1), and the result is the
    following:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 将之前添加到 :MadLibs 例程中的相同 echo 命令，添加到[列表 11-1](#Lis11-1)中的被调用 bat 文件中，结果如下：
- en: '[PRE20]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: I hesitate to call %0 the first parameter. It’s more of a hidden parameter coming
    just prior to the first parameter. From this example, it’s obvious that the hidden
    parameter is the name of the routine or bat file being executed, but where’s it
    coming from?
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 我不太愿意称 %0 为第一个参数。它更像是一个隐藏参数，位于第一个参数之前。从这个例子来看，很明显隐藏的参数是正在执行的例程或 bat 文件的名称，但它来自哪里呢？
- en: A bat file is often the first argument of the call command, and that argument
    is passed into the called bat file itself as %0. In fact, %0 matches the capitalization
    of the path and filename (or label name) in the call command, not the capitalization
    of the actual path and filename. If the path isn’t part of the argument, it isn’t
    part of %0. Furthermore, if the call command has double quotes around the path
    and filename, so will %0. For that reason, it’s usually best to resolve it with
    the tilde, %~0, just like the other parameters.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 一个 bat 文件通常是 call 命令的第一个参数，并且这个参数会作为 %0 传递给被调用的 bat 文件本身。事实上，%0 匹配的是 call 命令中路径和文件名（或标签名）的大小写，而不是实际路径和文件名的大小写。如果路径不是参数的一部分，那么它就不是
    %0 的一部分。此外，如果 call 命令中路径和文件名被双引号括起来，那么 %0 也会被双引号括起来。因此，通常最好像处理其他参数一样使用波浪符号来解析它，即
    %~0。
- en: The hidden parameter is omnipresent in all bat files, not just called bat files
    or called routines. Even a high-level bat file, the one that you may have started
    with a double mouse click, has its path and filename in the hidden parameter.
    We don’t often think about what’s going on when we open a bat file, but it isn’t
    magic. Windows executes a call command, with the bat file as its only argument,
    for you. The result is %0 being resolved to the path and the name of the bat file
    encased in double quotes.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 隐藏的参数在所有 bat 文件中都无处不在，不仅仅是被调用的 bat 文件或例程。即使是一个高层次的 bat 文件，那个你可能通过双击打开的文件，其路径和文件名也包含在隐藏的参数中。我们通常不会考虑打开
    bat 文件时发生了什么，但这并不是魔法。Windows 执行一个 call 命令，并将 bat 文件作为唯一参数传递给你。结果是 %0 被解析为 bat
    文件的路径和名称，并被双引号括起来。
- en: This hidden parameter has many uses. For error handling, it offers an easy means
    of logging the routine in which the error occurred. If the bat file is moved to
    a different directory, computer, or domain, the hidden parameter allows the bat
    file to know its location. When we get to the for command, there’s a relatively
    straightforward means of retrieving just the path from a variable holding a path
    and filename. You can then use it in any number of ways. For instance, you can
    drop output files into a subfolder under the bat file, or the bat file can perform
    different actions based on where it resides. It’s a very useful, and hidden, feature
    of Batch.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 这个隐藏参数有很多用途。对于错误处理，它提供了一种简单的方式来记录错误发生的例程。如果bat文件被移动到不同的目录、计算机或域中，隐藏参数可以帮助bat文件知道它的位置。当我们介绍到for命令时，有一种相对简单的方法可以从一个包含路径和文件名的变量中仅获取路径。然后，你可以以多种方式使用它。例如，你可以将输出文件放入bat文件所在目录下的子文件夹，或者bat文件可以根据它所处的位置执行不同的操作。它是Batch中一个非常有用且隐藏的特性。
- en: Shifting Parameters
  id: totrans-85
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 移动参数
- en: If the first parameter is resolved with %~1 and the ninth parameter is resolved
    with %~9, it might make sense that the 10th parameter would be resolved with %~10.
    Alas no, the interpreter recognizes only parameters 0 through 9, or single-digit
    ordinal numbers. It would be nice if a compiler could gently remind you that %~10
    isn’t a valid parameter, but again no, this is Batch. To demonstrate what can
    go wrong when this parameter is resolved, consider the example of a double-digit
    parameter list shown in [Listing 11-3](#Lis11-3). The first half of the alphabet
    is being passed to a routine that’s attempting to write five selected letters
    to the console.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 如果第一个参数通过%~1解析，第九个参数通过%~9解析，那么第10个参数通过%~10解析似乎是合理的。但实际上不行，解释器只识别参数0到9，或者单个数字的序数。要是编译器能够温和地提醒你%~10不是有效参数那该多好，但同样的，这就是Batch。为了演示在解析这个参数时可能出现的问题，可以参考[示例11-3](#Lis11-3)中的一个双数字参数列表。例程传递给它的是字母表的前一半，目的是将五个选定的字母写入控制台。
- en: '[PRE21]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Listing 11-3: A first pass at the routine :Alphabet to display five parameters'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 示例11-3：第一次尝试编写例程:Alphabet，以显示五个参数
- en: 'The first three look fine, but parameters 10 and 13 look to be junk:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 前三个看起来没问题，但第10和第13个参数似乎是无效的：
- en: '[PRE22]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: When we humans ponder %~13, we see the number 13 and might expect the 13th parameter,
    M, to be resolved. But the interpreter has never been confused with artificial
    intelligence, much less human intelligence. When it encounters %~13, it sees the
    first parameter, %~1, which is resolved to A, followed by the hardcoded value
    3. The result is A3. Similarly, %~10 resolves to the first parameter, but it’s
    appended with a zero, resulting in A0.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们人类看到%~13时，我们看到的是数字13，可能会期待第13个参数M被解析出来。但解释器从来没有被误认为是人工智能，更不可能是人类智慧。当它遇到%~13时，它看到的是第一个参数%~1，解析为A，后面跟着硬编码的值3，结果是A3。类似地，%~10会解析为第一个参数，但会附加一个零，结果是A0。
- en: 'Batch, however, isn’t limited to only nine parameters. In fact, I’ve seen dozens
    passed as there’s no practical limit (other than the limit of 8,191 characters
    in any command). To access the 10th parameter and beyond, you need the shift command.
    To demonstrate, let’s fix the :Alphabet routine from [Listing 11-3](#Lis11-3):'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，Batch并不限于只有九个参数。事实上，我曾见过传递了几十个参数，因为没有实际的限制（除了任何命令中最大字符数为8,191的限制）。要访问第10个及以后的参数，你需要使用shift命令。为了演示，让我们修正[示例11-3](#Lis11-3)中的:Alphabet例程：
- en: '[PRE23]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The resolutions of parameters 1, 2, and 9 are unchanged before the shift command
    executes, which shifts each parameter one position to the left. The second becomes
    the first, the third becomes the second, and the 10th parameter becomes the ninth.
    It may be counterintuitive, but after a shift command, %~9 resolves to parameter
    10\. Then after three more shift commands, %~9 resolves to M, the 13th parameter,
    producing the desired output:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在shift命令执行之前，第1、2和9号参数的解析结果没有变化，shift命令会将每个参数向左移动一个位置。第二个参数变成第一个，第三个变成第二个，第10个参数变成第九个。虽然这可能直觉上让人不太明白，但在shift命令之后，%~9会解析为第10个参数。再经过三次shift命令，%~9会解析为M，第13个参数，从而产生期望的输出：
- en: '[PRE24]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: When introducing the command separator (&) in [Chapter 2](chapter2.xhtml), I
    mentioned you should use it sparingly. In other situations, it can make a mess
    of the code, but shift is such a simple and succinct command, putting three on
    one line actually cleans up the code.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第2章](chapter2.xhtml)中介绍命令分隔符(&)时，我提到过应该谨慎使用它。在其他情况下，它可能会弄乱代码，但shift是一个非常简单和简洁的命令，将三个命令写在一行实际上可以清理代码。
- en: Note that the shift command doesn’t impact the resolution of %*. This funky
    syntax still resolves to the complete and original parameter list regardless of
    how many shift commands execute.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，shift命令不会影响%*的解析。这种奇怪的语法无论执行了多少个shift命令，仍然会解析为完整且原始的参数列表。
- en: 'Shifting the parameters raises an interesting question. What happens to the
    path and filename resolved with %0 after the shift command executes? The short
    answer is that it gets wiped out and replaced with the first parameter, at least
    by default. But the shift command has a lone option, and that option defines which
    parameter gets dropped with the shift; all parameters prior to it are maintained.
    It’s formatted differently from the options we’ve described to this point. The
    /n option drops the *n*th parameter, so that the following command drops the first
    and preserves %0:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 移动参数引发了一个有趣的问题。在执行shift命令后，使用%0解析的路径和文件名会发生什么？简短的回答是，它会被清除并替换为第一个参数，至少在默认情况下是这样。但是shift命令有一个独立的选项，这个选项定义了在shift时哪个参数会被丢弃；所有在该参数之前的参数都会被保留。它的格式与我们之前描述的选项有所不同。/n选项丢弃第*n*个参数，因此以下命令丢弃第一个参数并保留%0：
- en: '[PRE25]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Parameter 0, or the hidden parameter, is unchanged. Parameter 1 is discarded
    while parameter 2 slides over to become parameter 1\. The third parameter becomes
    the second, and so on. With a small change, the following command preserves the
    first four parameters (and the hidden parameter), while discarding the fifth:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 参数0，或者说隐藏参数，保持不变。参数1被丢弃，而参数2向前滑动成为参数1，第三个参数变成第二个，以此类推。通过一个小改动，以下命令保留了前四个参数（以及隐藏参数），同时丢弃了第五个参数：
- en: '[PRE26]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Parameter 6 is shifted to parameter 5, and the rest are shifted accordingly.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 参数6被移动到参数5，其他参数也相应地移动。
- en: This option accepts parameters 0 through 8—although there’s no need to use /0
    as that’s the default behavior. For some unknown reason, /9 is invalid. Don’t
    ask.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 这个选项接受参数0到8——尽管没有必要使用/0，因为这是默认行为。由于某些未知原因，/9是无效的。别问。
- en: Returning Parameters
  id: totrans-104
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 返回参数
- en: You now know how to pass arguments to routines and other bat files and write
    the received parameters to the console, but in the real coding world many routines
    accept some parameters and pass others back to the caller. Because Batch variables
    in a called process are globally available, some coders simply set a hardcoded
    variable name in a routine and use it elsewhere. Such Philistines! A far more
    elegant and flexible solution is to allow the caller to define the name of the
    variable returned.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在知道如何将参数传递给例程和其他批处理文件，并将接收到的参数写入控制台，但在真实的编码世界中，许多例程接受一些参数并将其他参数传回调用者。由于在被调用进程中的批处理变量是全局可用的，一些程序员干脆在例程中设置一个硬编码的变量名，并在其他地方使用它。真是些**庸俗**的人！一种更优雅、灵活的解决方案是允许调用者定义返回变量的名称。
- en: NOTE
  id: totrans-106
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 注意
- en: '*I’m using* Philistines *as a pejorative, but not without pause. Today the
    term is concise shorthand for brutish individuals indifferent to aesthetics and
    artistry, and that’s exactly how I’m using it. But we wouldn’t slur an entire
    people if they had modern day representation. Even the gypsy moth is being renamed,
    rightly, so as not to offend a group of people, although the moth can still be
    slandered with impunity. I’m sure that there were both good and bad Philistines,
    but because they were completely wiped out over two and half millennia ago and
    viewed unfavorably in the texts of three major world religions, their name is
    taken in vain with little or no remorse. In recent decades even our more distant
    cousin, the Neanderthals, have enjoyed a more rehabilitated image than the Philistines.*'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '*我使用*庸俗*一词作为贬义词，但并非没有犹豫。今天，这个词是指对美学和艺术无感的粗暴个体，而我正是以此含义使用它。但是，如果他们有现代代表性，我们不会诋毁整个民族。甚至连“吉普赛蛾”也正在被重新命名，正确地说是为了不冒犯某一群体，尽管这只蛾仍然可以被肆意诽谤。我相信当时有好有坏的庸俗人，但由于他们在两千五百多年前被完全消灭，并且在三大世界宗教的经文中被视为不祥之物，他们的名字被轻蔑地使用，而几乎没有任何悔意。近几十年来，甚至我们的远亲——尼安德特人，形象的恢复比庸俗人更加正面。*'
- en: 'The following example contains three parameters; the first two are numbers
    to be added and the third is the result of the addition. This routine may be short,
    but due to its complexity, a comment is really needed:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例包含三个参数；前两个是要相加的数字，第三个是加法的结果。这个例程可能很短，但由于其复杂性，确实需要注释：
- en: '[PRE27]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: To the right of the equal sign in the set /A command, the first two parameters
    are being resolved and added together. To the left of the equal sign—that is,
    what’s being set—is the cryptic text %~3. A variable name in this area may have
    been expected, but instead the third parameter is being resolved. The set /A command
    is in fact setting a named variable to the sum of the two numbers. Most important,
    that variable name is the third parameter passed into this routine. This technique
    isn’t difficult, but it’s unintuitive, and it isn’t common in other languages.
    I’ve seen it flummox many a coder.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在set /A命令的等号右侧，前两个参数被解析并相加。等号左侧——即被设置的部分——是神秘的文本%~3。这里本应是一个变量名，但实际上解析的是第三个参数。set
    /A命令实际上是将一个命名变量设置为两个数字的和。最重要的是，这个变量名就是传入此例程的第三个参数。这种技术不难理解，但却不直观，并且在其他语言中并不常见。我见过很多程序员被这个弄得一头雾水。
- en: 'An example of a call to the routine should clarify what’s happening. The following
    call command passes two numbers and a variable name, where the double quotes are
    optional:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 一个对该例程的调用示例可以澄清发生了什么。以下调用命令传递了两个数字和一个变量名，其中双引号是可选的：
- en: '[PRE28]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'After this call, the sum variable contains the value of 15. I can’t stress
    enough that with this technique, the calling code defines the name of the variable
    to be returned. To further make this point, the three calls in this example are
    done to the same :Add routine:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 在此调用之后，sum变量的值为15。我不能过分强调的是，在这种技术中，调用代码定义了要返回的变量名。为了进一步说明这一点，本例中的三个调用都是对同一个:Add例程的调用：
- en: '[PRE29]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: The first two have hardcoded numbers, returning the sum1 and sum2 variables,
    respectively. Both of those variables are resolved and passed as arguments in
    the third call, returning sum4Nbrs.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 前两个调用使用了硬编码的数字，分别返回sum1和sum2变量。这两个变量都被解析并作为参数传递到第三个调用中，返回sum4Nbrs。
- en: 'Notice that sum1 and sum2 don’t have delimiting percent signs in the first
    two calls because the variable name is being passed. But in the third call, I’m
    resolving them because their values are being passed—the same values that were
    assigned during the first two calls. Finally, the echo command writes this to
    the console:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，在前两个调用中，sum1和sum2没有带有分隔符的百分号，因为变量名被传递。但是在第三个调用中，我正在解析它们，因为它们的值被传递了——这些值是在前两个调用中赋值的。最后，echo命令将这些内容写入控制台：
- en: '[PRE30]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: The same variable used as the output for one call is the input for another,
    but can the variable be used for both purposes in a single call?
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 一个调用中的输出使用的同一个变量，在另一个调用中作为输入，但这个变量是否可以在单个调用中同时用于这两种用途呢？
- en: One Variable as Input and Output
  id: totrans-119
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 一个变量作为输入和输出
- en: 'A single variable can simultaneously be an input to and an output of a routine
    or bat file. To set this up, imagine a routine that squares an integer. The first
    parameter is the input, and the second parameter is the output—simply the input
    multiplied by itself:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 一个单独的变量可以同时作为例程或批处理文件的输入和输出。为了设置这个，想象一个求整数平方的例程。第一个参数是输入，第二个参数是输出——简单来说，就是输入乘以它本身：
- en: '[PRE31]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: The routine doesn’t show much that we haven’t already discussed, although the
    input of %~1 is used twice. The calling code defines the output variable, which
    is resolved as %~2 in the routine.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 该例程没有展示我们尚未讨论的内容，尽管%~1的输入被使用了两次。调用代码定义了输出变量，并在例程中将其解析为%~2。
- en: 'The calling code could use two different variables for the input and output.
    But suppose that you want to replace a variable’s value with its square. To accomplish
    this, you could pass its value as the first argument—notice the percent signs
    encasing it—and pass the name of the variable as the second argument, not encased
    with percent signs:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 调用代码可以使用两个不同的变量来作为输入和输出。但是假设你想用一个变量的平方来替换它的值。为了实现这一点，你可以将它的值作为第一个参数传递——请注意，值两侧有百分号——并将变量名作为第二个参数传递，而不加百分号：
- en: '[PRE32]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: If nbr was set to 5 before the call, it’ll be set to 25 afterward. The :Square
    routine offers some real flexibility, usable with two different variables or the
    same one.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在调用之前，nbr被设置为5，那么调用之后它会被设置为25。:Square例程提供了一些真正的灵活性，可以与两个不同的变量或相同的变量一起使用。
- en: 'Let’s make one more tweak to this code and write a routine with a single parameter
    that’s both the input and output. The parameter is a variable containing a number
    as its value, and the routine replaces that value with its square, which makes
    calling the routine even easier:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们再对这段代码做一次小改动，写一个只有一个参数的例程，该参数既是输入也是输出。该参数是一个包含数字值的变量，例程将该值替换为其平方，这使得调用例程变得更加简便：
- en: '[PRE33]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: First, notice the new routine (or label) name. More important, notice that the
    routine accepts a single argument, the unresolved variable name of an integer—not
    the integer value.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，注意到新例程（或标签）的名称。更重要的是，注意到该例程接受一个单一的参数，即整数的未解析变量名——而不是整数值。
- en: Comparing :SquareMe to the :Square routine, the set /A command has two critical
    updates. First, instead of multiplying %~1 by itself, !%~1! is now each operand.
    In the prior example, a value was being accepted, but now a variable name is the
    input, so %~1 resolves to the variable name, and with the use of delayed expansion,
    the exclamation marks resolve that name to the integer value. (Have I yet mentioned
    the true awesomeness of delayed expansion? The applications are limited only by
    your imagination.)
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 将:SquareMe与:Square例程进行比较，set /A命令有两个关键更新。首先，不再将%~1自乘，而是将!%~1!作为每个操作数。在之前的例子中，接受的是一个值，而现在输入的是一个变量名，因此%~1解析为变量名，并且通过延迟扩展，感叹号将该名称解析为整数值。（我是否提到过延迟扩展的真正强大之处？它的应用仅受限于你的想象力。）
- en: The second change is that the product is being assigned to the first parameter,
    %~1, and not the second, %~2. Remember that in :SquareMe the sole parameter is
    now the variable name. The result is that a call to this routine changes the value
    of the variable even though that variable isn’t explicitly mentioned in the routine.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个变化是积被分配给第一个参数%~1，而不是第二个参数%~2。记住，在:SquareMe中，唯一的参数现在是变量名。结果是，调用此例程会更改变量的值，即使该变量在例程中没有明确提到。
- en: NOTE
  id: totrans-131
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 注意
- en: '*I’ve demonstrated return parameters with routines, but returning a parameter
    from a called bat file works virtually the same way. Actually, it works exactly
    the same way if the called bat file is* not *limiting scope via the setlocal and
    endlocal commands. If it is limiting scope, there’s a special technique that allows
    one or more variables to survive the endlocal, and I’ll detail it in [Chapter
    16](chapter16.xhtml).*'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '*我已经通过例程演示了返回参数，但从被调用的bat文件返回参数的方式几乎是一样的。实际上，如果被调用的bat文件*没有*通过setlocal和endlocal命令限制作用域，那么它的工作方式完全相同。如果它限制了作用域，那么有一种特殊技巧可以让一个或多个变量在endlocal之后存活，我将在[第16章](chapter16.xhtml)中详细说明。*'
- en: Input Parameter Lists of Varying Lengths
  id: totrans-133
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 输入参数列表的长度变化
- en: 'Let’s build more of a real-world routine that uses what we’ve learned so far
    in this chapter. The following routine accepts a list of one-to-many numbers (no
    reasonable limit) and returns two variables, one populated with the sum of the
    inputs and the other populated with the product of the inputs:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们构建一个更接近实际的例程，使用我们目前为止在本章中学到的内容。以下例程接受一系列一对多的数字（没有合理的限制），并返回两个变量，一个填充为输入数字的和，另一个填充为输入数字的积：
- en: '[PRE34]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Since we don’t know how many input parameters to expect for a given call, we
    put those at the end of the parameter list, with the output parameters occupying
    the first two positions. (No one said inputs must come before outputs.) Due to
    its complexity, the :Arithmetic routine includes much needed comments defining
    the parameter list.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们不知道在给定调用中会有多少输入参数，因此将这些参数放在参数列表的末尾，输出参数占据前两个位置。（没人说输入必须在输出之前。）由于其复杂性，:Arithmetic例程包含了许多必要的注释，用于定义参数列表。
- en: The sum, represented as %~1 because it doesn’t yet have an actual variable name,
    is initialized to 0. Likewise, the product, %~2, is initialized to 1. (For my
    fellow math geeks, that’s what we respectively call additive and multiplicative
    unity.) Ignore the second label, :NextParm, for a moment and focus on the two
    set /A commands that follow. The first command sets the first parameter, the sum,
    to itself plus the first input number on the list, %~3, which is the third parameter.
    Similarly, the next command sets the second parameter, the product, to itself
    multiplied by the first number on the list, again %~3.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 和，表示为%~1，因为它还没有实际的变量名，初始化为0。同样，积，%~2，初始化为1。（对于我的数学迷朋友们来说，这分别被称为加法和乘法的单位。）暂时忽略第二个标签:NextParm，集中注意力在接下来的两个set
    /A命令上。第一个命令将第一个参数，即和，设置为它本身加上列表中的第一个输入数字%~3，它是第三个参数。类似地，接下来的命令将第二个参数，即积，设置为它本身乘以列表中的第一个数字，同样是%~3。
- en: The shift command that comes next is crucial. The number of input parameters
    is unknown, so we want to discard the just used third parameter and shift the
    parameters that come after it to the left without disturbing the first two, which
    are also the return parameters in this instance. The /3 option accomplishes that
    seamlessly. Next, we look at the newly minted third parameter to see whether it’s
    populated. Keep in mind that this was the second input number on the original
    list or the fourth overall parameter before the shift. If it’s populated, we’ll
    go back to the :NextParm label that we ignored earlier. Now those two set /A commands
    add and multiply the second input parameter to the sum and product, respectively.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的 shift 命令非常关键。输入参数的数量是未知的，所以我们希望丢弃刚刚使用过的第三个参数，并将其后面的参数向左移动，而不干扰前两个参数，这两个参数在本例中也是返回参数。/3
    选项能够无缝地实现这一点。接下来，我们查看新生成的第三个参数，看看它是否已被填充。请记住，这个参数在原始列表中是第二个输入数字，或者说在 shift 之前是第四个总体参数。如果它已经被填充，我们将返回之前忽略过的
    :NextParm 标签。现在，这两个 set /A 命令分别将第二个输入参数加到和中，并乘到积中。
- en: This process repeats until the list of numbers, regardless of its length, is
    exhausted, at which point the conditional clause of the if command is false, allowing
    control to fall to the trailing goto :eof command and the routine passes back
    the first two parameters.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 这个过程会一直重复，直到数字列表（无论其长度如何）用完为止，此时 if 命令的条件语句为假，控制权将转移到后续的 goto :eof 命令，例程将返回前两个参数。
- en: 'The following code tests the new routine:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码测试了这个新例程：
- en: '[PRE35]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'The resulting text is written to the console:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 结果文本将写入控制台：
- en: '[PRE36]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: By the way, if this construct looks familiar, that’s because it’s an example
    of a Batch do...while command from [Chapter 9](chapter9.xhtml). At least one input
    parameter is assumed, and the routine performs the arithmetic as long as, or *while*,
    more parameters exist.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 顺便说一下，如果这个结构看起来很熟悉，那是因为它是来自[第9章](chapter9.xhtml)的 Batch do...while 命令的示例。至少假设有一个输入参数，并且只要存在更多的参数，例程就会执行算术运算，或者说是
    *只要*。
- en: Drag-and-Drop Parameters
  id: totrans-145
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 拖放参数
- en: With a few mouse clicks, you can pass the path and name of any file, or multiple
    files, into a bat file. It’s something that dumbfounded multiple people, including
    me when I was learning Batch. Simply right-click on any file and select **Copy**;
    then right-click on the bat file to execute and select **Paste**. The bat file
    executes, with the sole parameter being the path and filename of the copied file
    (encased in double quotes if the path or filename has embedded spaces). Alternatively,
    you can select the file, drag, and drop it onto the bat file with the same result.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 通过几个鼠标点击，你可以将任何文件的路径和名称，或者多个文件，传递给 bat 文件。这是当我学习 Batch 时让我和其他许多人都感到惊讶的事情。只需右键单击任何文件并选择
    **复制**；然后右键单击 bat 文件进行执行并选择 **粘贴**。bat 文件执行时，唯一的参数是复制文件的路径和文件名（如果路径或文件名包含空格，则会用双引号括起来）。另外，你还可以选择文件，拖动并将其放到
    bat 文件上，结果是一样的。
- en: This technique works for any number of files. If you copy *n* files onto your
    bat file, *n* space-delimited parameters are passed—each one being a path and
    filename. The same is true if you drag and drop *n* files onto your bat file,
    and it even works for directories.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 这种技术适用于任何数量的文件。如果你将 *n* 个文件复制到 bat 文件上，*n* 个以空格分隔的参数将被传递——每个参数都是一个路径和文件名。如果你将
    *n* 个文件拖放到 bat 文件上，情况也是一样，甚至适用于目录。
- en: At first, the dragging and dropping of files onto a bat file might seem like
    little more than a Batch parlor trick, but its uses are manifold. You can design
    a wrapper bat file that processes a single file. Maybe a program is being executed
    with a file as input; the program might convert the file to a different format
    or add a trailer record. Maybe the Batch code will simply rename the file or add
    an extension to the existing filename. What’s important is that the bat file is
    performing some action on an input file.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 起初，将文件拖放到 bat 文件上可能看起来像是一个简单的 Batch 小把戏，但它的用途非常广泛。你可以设计一个包装的 bat 文件来处理单个文件。也许一个程序正在执行，并以一个文件作为输入；该程序可能会将文件转换为不同的格式或添加尾部记录。也许
    Batch 代码只是简单地重命名文件或给现有的文件名添加扩展名。重要的是，bat 文件正在对输入文件执行某些操作。
- en: 'One possible action is to simply copy the input file to another directory.
    Consider the following two commands that make up the entirety of *BackUpOneFile.bat*:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 一种可能的操作是简单地将输入文件复制到另一个目录。考虑以下两个命令，它们构成了 *BackUpOneFile.bat* 的全部内容：
- en: '[PRE37]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: The first argument to the xcopy command, which is %1, resolves to the bat file’s
    first parameter, which will be the path and filename of any file dragged and dropped
    onto *BackUpOneFile.bat*. The command copies the input file to the desired target
    path, some deep hard to reach folder on the *D:\* drive. (I’m intentionally retaining
    any encasing double quotes with the %1 syntax, instead of %~1, because the xcopy
    command requires the double quotes if the path or filename have any embedded spaces.)
    Finally, the pause command simply holds the window open for the user to see the
    result of the copy.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: xcopy 命令的第一个参数 %1 解析为 bat 文件的第一个参数，该参数将是任何拖放到 *BackUpOneFile.bat* 上的文件的路径和文件名。该命令将输入文件复制到目标路径，即
    *D:\* 驱动器中的一个深层、难以触及的文件夹。（我故意保留了 %1 语法中的双引号，而不是 %~1，因为如果路径或文件名包含空格，xcopy 命令需要双引号。）最后，pause
    命令仅仅是让窗口保持打开状态，以便用户查看复制结果。
- en: Ultimately, if you place *BackUpOneFile.bat* on the Windows desktop, you can
    quickly drag and drop any one file onto it, and the bat file will copy the input
    file to the desired directory without your needing to navigate to that directory.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 最终，如果你将 *BackUpOneFile.bat* 放在 Windows 桌面上，你可以快速将任何一个文件拖放到它上面，bat 文件将把输入文件复制到所需的目录，而无需你导航到该目录。
- en: In order to pass an argument to a bat file without this drag-and-drop technique,
    you must enter a call command (into another bat file or at the command prompt)
    with the input file keyed in as the argument. But with this technique, any user,
    even noncoders, can easily run the bat file without any input from the keyboard.
    You can create a Windows shortcut for the bat file located anywhere on the network
    so as to hide the source Batch code, making it more difficult for a user to accidentally
    delete or modify it.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在没有这种拖放技术的情况下将参数传递给 bat 文件，你必须输入一个调用命令（到另一个 bat 文件或命令提示符中），并将输入文件作为参数键入。但通过这种技术，任何用户，甚至是非程序员，都可以轻松地运行
    bat 文件，而无需键盘输入。你可以为位于网络上任何位置的 bat 文件创建一个 Windows 快捷方式，从而隐藏源 Batch 代码，使用户更难意外删除或修改它。
- en: When a path and filename is passed to a bat file as a parameter, Batch offers
    an easy way to get quite a bit of information about the file, such as the last
    modified date and time, size, attributes, path, extension, filename, and more.
    I’ll discuss this in detail after exploring the for command in [Chapter 17](chapter17.xhtml).
    The for command will also unlock loops, so that if we drag and drop *n* files
    onto a bat file, each can be processed sequentially.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 当路径和文件名作为参数传递给 bat 文件时，Batch 提供了一种简便的方法来获取关于文件的各种信息，例如最后修改日期和时间、大小、属性、路径、扩展名、文件名等。我将在探索
    [第 17 章](chapter17.xhtml) 中的 for 命令后详细讨论这一点。for 命令还将解锁循环功能，这样如果我们将 *n* 个文件拖放到
    bat 文件中，系统就可以依次处理每个文件。
- en: Summary
  id: totrans-155
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 总结
- en: This chapter along with [Chapters 8](chapter8.xhtml) through [10](chapter10.xhtml)
    have hopefully opened up your Batch universe to far more than a single routineless
    sequentially executed bat file. In the not-so-distant past, your bat files couldn’t
    call executables or other bat files, and the interpreter executed each command
    just once and in order until it found the end of the bat file. But now you have
    the tools to start building interesting and complex bat files.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 本章以及 [第 8 章](chapter8.xhtml) 到 [第 10 章](chapter10.xhtml) 希望能够让你对 Batch 的理解超越单一的无规律顺序执行的
    bat 文件。在不久的过去，你的 bat 文件无法调用可执行文件或其他 bat 文件，解释器只会按顺序执行每个命令，直到遇到 bat 文件的结尾。但是现在，你有了开始构建有趣且复杂的
    bat 文件的工具。
- en: In this chapter, you learned how to pass arguments to bat files and routines
    and receive them as parameters in the called bat file. I detailed how to delimit
    the arguments and even how to pass the delimiters themselves as arguments. You
    also got a glimpse of the hidden parameter, the Yeti of the Batch universe. I
    demonstrated how to pass back caller-defined variables containing a return value.
    You may have even learned how to play Mad Libs.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你学习了如何将参数传递给 bat 文件和程序，并在调用的 bat 文件中接收它们作为参数。我详细介绍了如何分隔参数，甚至如何将分隔符本身作为参数传递。你还初步了解了隐藏参数——Batch
    世界中的“雪人”。我展示了如何传递回调用者定义的变量，其中包含返回值。你甚至可能学会了如何玩疯狂填字游戏。
- en: In the next chapter, I’ll expand that universe even more by introducing various
    outputs, created by both the interpreter and you. I’ll show you how to capture
    the output of Batch commands and how to create files of your own.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章，我将通过介绍各种由解释器和你自己创建的输出，进一步拓展这一领域。我将向你展示如何捕获 Batch 命令的输出，以及如何创建自己的文件。
