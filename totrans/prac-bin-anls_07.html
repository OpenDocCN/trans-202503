<html><head></head><body><div id="sbo-rt-content"><h2 class="h2a" id="ch05"><span epub:type="pagebreak" id="page_89"/><span class="big">5</span><br/>BASIC BINARY ANALYSIS IN LINUX</h2>&#13;
<p class="noindent">Even in the most complex binary analysis, you can accomplish surprisingly advanced feats by combining a set of basic tools in the right way. This can save you hours of work implementing equivalent functionality on your own. In this chapter, you’ll learn the fundamental tools you’ll need to perform binary analysis on Linux.</p>&#13;
<p class="indent">Instead of simply showing you a list of tools and explaining what they do, I’ll use a <em>Capture the Flag (CTF)</em> challenge to illustrate how they work. In computer security and hacking, CTF challenges are often played as contests, where the goal is typically to analyze or exploit a given binary (or a running process or server) until you manage to capture a flag hidden in the binary. The flag is usually a hexadecimal string, which you can use to prove that you completed the challenge as well as unlock new challenges.</p>&#13;
<p class="indent">In this CTF, you start with a mysterious file called <em>payload</em>, which you can find on the VM in the directory for this chapter. The goal is to figure out how to extract the hidden flag from <em>payload</em>. In the process of analyzing <em>payload</em> and looking for the flag, you’ll learn to use a wide range of basic binary analysis tools that are available on virtually any Linux-based system (most of them as part of GNU <span class="literal">coreutils</span> or <span class="literal">binutils</span>). I encourage you to follow along.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_90"/>Most of the tools you’ll see have a number of useful options, but there are far too many to cover exhaustively in this chapter. Thus, it’s a good idea to check out the man page for every tool using the command <span class="literal">man</span> <em>tool</em> on the VM. At the end of the chapter, you’ll use the recovered flag to unlock a new challenge, which you can complete on your own!</p>&#13;
<h3 class="h3" id="ch05_1">5.1 Resolving Identity Crises Using file</h3>&#13;
<p class="noindent">Because you received absolutely no hints about the contents of <em>payload</em>, you have no idea what to do with this file. When this happens (for instance, in reverse engineering or forensics scenarios), a good first step is to figure out what you can about the file type and its contents. The <span class="literal">file</span> utility was designed for this purpose; it takes a number of files as input and then tells you what type each file is. You may remember it from <a href="ch02.xhtml#ch02">Chapter 2</a>, where I used <span class="literal">file</span> to find out the type of an ELF file.</p>&#13;
<p class="indent">The nice thing about <span class="literal">file</span> is that it isn’t fooled by extensions. Instead, it searches for other telltale patterns in the file, such as magic bytes like the <span class="literal">0x7f ELF</span> sequence at the start of ELF files, to find out the file type. This is perfect here because the <em>payload</em> file doesn’t have an extension. Here’s what <span class="literal">file</span> tells you about <em>payload</em>:</p>&#13;
<p class="programs">$ <span class="codestrong1">file payload</span><br/>payload: ASCII text</p>&#13;
<p class="indent">As you can see, <em>payload</em> contains ASCII text. To examine the text in detail, you can use the <span class="literal">head</span> utility, which dumps the first few lines (10 by default) of a text file to <span class="literal">stdout</span>. There’s also an analogous utility called <span class="literal">tail</span>, which shows you the last few lines of a file. Here’s what the <span class="literal">head</span> utility’s output shows:</p>&#13;
<p class="programs">$ <span class="codestrong1">head payload</span><br/>H4sIAKiT61gAA+xaD3RTVZq/Sf9TSKL8aflnn56ioNJJSiktDpqUlL5o0UpbYEVI0zRtI2naSV5K<br/>YV0HTig21jqojH9mnRV35syZPWd35ZzZ00XHxWBHYJydXf4ckRldZRUxBRzxz2CFQvb77ru3ee81<br/>AZdZZ92z+XrS733fu993v/v/vnt/bqmVfNNkBlq0cCFyy6KFZiUHKi1buMhMLAvMi0oXWSzlZYtA<br/>v2hRWRkRzN94ZEChoOQKCAJp8fdcNt2V3v8fpe9X1y7T63Rjsp7cTlCKGq1UtjL9yPUJGyupIHnw<br/>/zoym2SDnKVIZyVWFR9hrjnPZeky4JcJvwq9LFforSo+i6XjXKfgWaoSWFX8mclExQkRxuww1uOz<br/>Ze3x2U0qfpDFcUyvttMzuxFmN8LSc054er26fJns18D0DaxcnNtZOrsiPVLdh1ILPudey/xda1Xx<br/>MpauTGN3L9hlk69PJsZXsPxS1YvA4uect8N3fN7m8rLv+Frm+7z+UM/8nory+eVlJcHOklIak4ml<br/>rbm7kabn9SiwmKcQuQ/g+3n/OJj/byfuqjv09uKVj8889O6TvxXM+G4qSbRbX1TQCZnWPNQVwG86<br/>/F7+4IkHl1a/eebY91bPemngU8OpI58YNjrWD16u3P3wuzaJ3kh4i6vpuhT6g7rkfs6k0DtS6P8l<br/>hf6NFPocfXL9yRTpS0ny+NtJ8vR3p0hfl8J/bgr9Vyn0b6bQkxTl+ixF+p+m0N+qx743k+wWmlT6</p>&#13;
<p class="indent">That definitely doesn’t look human-readable. Taking a closer look at the alphabet used in the file, you can see that it consists of only alphanumeric characters and the characters + and /, organized in neat rows. When you see a file that looks like this, it’s usually safe to assume that it’s a <em>Base64</em> file.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_91"/>Base64 is a widely used method of encoding binary data as ASCII text. Among other things, it’s commonly used in email and on the web to ensure that binary data transmitted over a network isn’t accidentally malformed by services that can handle only text. Conveniently, Linux systems come with a tool called <span class="literal">base64</span> (typically as part of GNU <span class="literal">coreutils</span>) that can encode and decode Base64. By default, <span class="literal">base64</span> will encode any files or <span class="literal">stdin</span> input given to it. But you can use the <span class="literal">-d</span> flag to tell <span class="literal">base64</span> to decode instead. Let’s decode <em>payload</em> to see what you get!</p>&#13;
<p class="programs">$ <span class="codestrong1">base64 -d payload &gt; decoded_payload</span></p>&#13;
<p class="indent">This command decodes <em>payload</em> and then stores the decoded contents in a new file called <span class="literal">decoded_payload</span>. Now that you’ve decoded <em>payload</em>, let’s use <span class="literal">file</span> again to check the type of the decoded file.</p>&#13;
<p class="programs">$ <span class="codestrong1">file decoded_payload</span><br/>decoded_payload: gzip compressed data, last modified: Tue Oct 22 15:46:43 2019, from Unix</p>&#13;
<p class="indent">Now you’re getting somewhere! It turns out that behind the layer of Base64 encoding, the mysterious file is actually just a compressed archive that uses <span class="literal">gzip</span> as the outer compression layer. This is an opportunity to introduce another handy feature of <span class="literal">file</span>: the ability to peek inside zipped files. You can pass the <span class="literal">-z</span> option to <span class="literal">file</span> to see what’s inside the archive without extracting it. Here’s what you should see:</p>&#13;
<p class="programs">$ <span class="codestrong1">file -z decoded_payload</span><br/>decoded_payload: POSIX tar archive (GNU) (gzip compressed data, last modified:<br/>                  Tue Oct 22 19:08:12 2019, from Unix)</p>&#13;
<p class="indent">You can see that you’re dealing with multiple layers that you need to extract, because the outer layer is a <span class="literal">gzip</span> compression layer and inside that is a <span class="literal">tar</span> archive, which typically contains a bundle of files. To reveal the files stored inside, you use <span class="literal">tar</span> to unzip and extract <span class="literal">decoded_payload</span>, like this:</p>&#13;
<p class="programs">$ <span class="codestrong1">tar xvzf decoded_payload</span><br/>ctf<br/>67b8601</p>&#13;
<p class="indent">As shown in the <span class="literal">tar</span> log, there are two files extracted from the archive: <em>ctf</em> and <em>67b8601</em>. Let’s use <span class="literal">file</span> again to see what kinds of files you’re dealing with.</p>&#13;
<p class="programs">$ <span class="codestrong1">file ctf</span> <br/>ctf: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), dynamically linked,<br/>interpreter /lib64/ld-linux-x86-64.so.2, for GNU/Linux 2.6.32,<br/>BuildID[sha1]=29aeb60bcee44b50d1db3a56911bd1de93cd2030, stripped</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_92"/>The first file, <em>ctf</em>, is a dynamically linked 64-bit stripped ELF executable. The second file, called <em>67b8601</em>, is a bitmap (BMP) file of 512 × 512 pixels. Again, you can see this using <span class="literal">file</span> as follows:</p>&#13;
<p class="programs">$ <span class="codestrong1"> file 67b8601</span><br/>67b8601: PC bitmap, Windows 3.x format, 512 x 512 x 24</p>&#13;
<p class="indent">This BMP file depicts a black square, as you can see in <a href="ch05.xhtml#ch05fig1">Figure 5-1a</a>. If you look carefully, you should see some irregularly colored pixels at the bottom of the figure. <a href="ch05.xhtml#ch05fig1">Figure 5-1b</a> shows an enlarged snippet of these pixels.</p>&#13;
<p class="indent">Before exploring what this all means, let’s first take a closer look at <em>ctf</em>, the ELF file you just extracted.</p>&#13;
<div class="image"><a id="ch05fig1"/><img src="Images/f092-01.jpg" alt="image" width="488" height="767"/></div>&#13;
<p class="fig-caption"><em>Figure 5-1: The extracted BMP file, 67b8601</em></p>&#13;
<h3 class="h3" id="ch05_2">5.2 <span epub:type="pagebreak" id="page_93"/>Using ldd to Explore Dependencies</h3>&#13;
<p class="noindent">Although it’s not wise to run unknown binaries, since you’re working in a VM, let’s try running the extracted <em>ctf</em> binary. When you try to run the file, you don’t get far.</p>&#13;
<p class="programs">$ <span class="codestrong1"> ./ctf</span><br/>./ctf: error while loading shared libraries: lib5ae9b7f.so:<br/>       cannot open shared object file: No such file or directory</p>&#13;
<p class="indent">Before any of the application code is even executed, the dynamic linker complains about a missing library called <em>lib5ae9b7f.so</em>. That doesn’t sound like a library you normally find on any system. Before searching for this library, it makes sense to check whether <em>ctf</em> has any more unresolved dependencies.</p>&#13;
<p class="indent">Linux systems come with a program called <span class="literal">ldd</span>, which you can use to find out on which shared objects a binary depends and where (if anywhere) these dependencies are on your system. You can even use <span class="literal">ldd</span> along with the <span class="literal">-v</span> flag to find out which library versions the binary expects, which can be useful for debugging. As mentioned in the <span class="literal">ldd man</span> page, <span class="literal">ldd</span> may run the binary to figure out the dependencies, so it’s not safe to use on untrusted binaries unless you’re running it in a VM or another isolated environment. Here’s the <span class="literal">ldd</span> output for the <em>ctf</em> binary:</p>&#13;
<p class="programs">$ <span class="codestrong1">ldd ctf</span><br/>        linux-vdso.so.1 =&gt; (0x00007fff6edd4000)<br/>        lib5ae9b7f.so =&gt; not found<br/>        libstdc++.so.6 =&gt; /usr/lib/x86_64-linux-gnu/libstdc++.so.6 (0x00007f67c2cbe000)<br/>        libgcc_s.so.1 =&gt; /lib/x86_64-linux-gnu/libgcc_s.so.1 (0x00007f67c2aa7000)<br/>        libc.so.6 =&gt; /lib/x86_64-linux-gnu/libc.so.6 (0x00007f67c26de000)<br/>        libm.so.6 =&gt; /lib/x86_64-linux-gnu/libm.so.6 (0x00007f67c23d5000)<br/>        /lib64/ld-linux-x86-64.so.2 (0x0000561e62fe5000)</p>&#13;
<p class="indent">Luckily, there are no unresolved dependencies besides the missing library identified earlier, <em>lib5ae9b7f.so</em>. Now you can focus on figuring out what this mysterious library is and how you can obtain it in order to capture the flag!</p>&#13;
<p class="indent">Because it’s obvious from the library name that you won’t find it in any standard repository, it must reside somewhere in the files you’ve been given so far. Recall from <a href="ch02.xhtml#ch02">Chapter 2</a> that all ELF binaries and libraries begin with the magic sequence <span class="literal">0x7f ELF</span>. This is a handy string to look for in search of your missing library; as long as the library is not encrypted, you should be able to find the ELF header this way. Let’s try a simple <span class="literal">grep</span> for the string <span class="literal">'ELF'</span>.</p>&#13;
<p class="programs">$ <span class="codestrong1">grep 'ELF' *</span><br/>Binary file 67b8601 matches<br/>Binary file ctf matches</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_94"/>As expected, the string <span class="literal">'ELF'</span> appears in <em>ctf</em>, which is not surprising because you already know it’s an ELF binary. But you can see that this string is also in <em>67b8601</em>, which at first glance appeared to be an innocent bitmap file. Could there be a shared library hidden within the bitmap’s pixel data? It would certainly explain those strangely colored pixels you saw in <a href="ch05.xhtml#ch05fig1">Figure 5-1b</a>! Let’s examine the contents of <em>67b8601</em> in more detail to find out.</p>&#13;
<div class="box">&#13;
<p class="headbox">Quickly Looking Up ASCII Codes</p>&#13;
<p class="noindent">When interpreting raw bytes as ASCII, you’ll often need a table that maps byte values in various representations to ASCII symbols. You can use a special man page called <span class="literal">man ascii</span> for quick access to such a table. Here’s an excerpt of the table from <span class="literal">man ascii</span>:</p>&#13;
<table class="topbot-d">&#13;
<colgroup>&#13;
<col style="width:10%"/>&#13;
<col style="width:10%"/>&#13;
<col style="width:10%"/>&#13;
<col style="width:20%"/>&#13;
<col style="width:10%"/>&#13;
<col style="width:10%"/>&#13;
<col style="width:10%"/>&#13;
<col style="width:10%"/>&#13;
<col style="width:10%"/>&#13;
</colgroup>&#13;
<thead>&#13;
<tr>&#13;
<td style="border-top: solid 0.1em; border-bottom: solid 0.1em;"><span class="literal">Oct</span></td>&#13;
<td style="border-top: solid 0.1em; border-bottom: solid 0.1em;"><span class="literal">Dec</span></td>&#13;
<td style="border-top: solid 0.1em; border-bottom: solid 0.1em;"><span class="literal">Hex</span></td>&#13;
<td style="border-top: solid 0.1em; border-bottom: solid 0.1em;"><span class="literal">Char</span></td>&#13;
<td style="border-top: solid 0.1em; border-bottom: solid 0.1em;"><span class="literal">Oct</span></td>&#13;
<td style="border-top: solid 0.1em; border-bottom: solid 0.1em;"><span class="literal">Dec</span></td>&#13;
<td style="border-top: solid 0.1em; border-bottom: solid 0.1em;"><span class="literal">Hex</span></td>&#13;
<td style="border-top: solid 0.1em; border-bottom: solid 0.1em;"><span class="literal">Char</span></td>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr>&#13;
<td><span class="literal">000</span></td>&#13;
<td><span class="literal">0</span></td>&#13;
<td><span class="literal">00</span></td>&#13;
<td><span class="literal">NUL '\0' (null character)</span></td>&#13;
<td><span class="literal">100</span></td>&#13;
<td><span class="literal">64</span></td>&#13;
<td><span class="literal">40</span></td>&#13;
<td><span class="literal">@</span></td>&#13;
</tr>&#13;
<tr>&#13;
<td><span class="literal">001</span></td>&#13;
<td><span class="literal">1</span></td>&#13;
<td><span class="literal">01</span></td>&#13;
<td><span class="literal">SOH (start of heading)</span></td>&#13;
<td><span class="literal">101</span></td>&#13;
<td><span class="literal">65</span></td>&#13;
<td><span class="literal">41</span></td>&#13;
<td><span class="literal">A</span></td>&#13;
</tr>&#13;
<tr>&#13;
<td><span class="literal">002</span></td>&#13;
<td><span class="literal">2</span></td>&#13;
<td><span class="literal">02</span></td>&#13;
<td><span class="literal">STX (start of text)</span></td>&#13;
<td><span class="literal">102</span></td>&#13;
<td><span class="literal">66</span></td>&#13;
<td><span class="literal">42</span></td>&#13;
<td><span class="literal">B</span></td>&#13;
</tr>&#13;
<tr>&#13;
<td><span class="literal">003</span></td>&#13;
<td><span class="literal">3</span></td>&#13;
<td><span class="literal">03</span></td>&#13;
<td><span class="literal">ETX (end of text)</span></td>&#13;
<td><span class="literal">103</span></td>&#13;
<td><span class="literal">67</span></td>&#13;
<td><span class="literal">43</span></td>&#13;
<td><span class="literal">C</span></td>&#13;
</tr>&#13;
<tr>&#13;
<td><span class="literal">004</span></td>&#13;
<td><span class="literal">4</span></td>&#13;
<td><span class="literal">04</span></td>&#13;
<td><span class="literal">EOT (end of transmission)</span></td>&#13;
<td><span class="literal">104</span></td>&#13;
<td><span class="literal">68</span></td>&#13;
<td><span class="literal">44</span></td>&#13;
<td><span class="literal">D</span></td>&#13;
</tr>&#13;
<tr>&#13;
<td><span class="literal">005</span></td>&#13;
<td><span class="literal">5</span></td>&#13;
<td><span class="literal">05</span></td>&#13;
<td><span class="literal">ENQ (enquiry)</span></td>&#13;
<td><span class="literal">105</span></td>&#13;
<td><span class="literal">69</span></td>&#13;
<td><span class="literal">45</span></td>&#13;
<td><span class="literal">E</span></td>&#13;
</tr>&#13;
<tr>&#13;
<td><span class="literal">006</span></td>&#13;
<td><span class="literal">6</span></td>&#13;
<td><span class="literal">06</span></td>&#13;
<td><span class="literal">ACK (acknowledge)</span></td>&#13;
<td><span class="literal">106</span></td>&#13;
<td><span class="literal">70</span></td>&#13;
<td><span class="literal">46</span></td>&#13;
<td><span class="literal">F</span></td>&#13;
</tr>&#13;
<tr>&#13;
<td><span class="literal">007</span></td>&#13;
<td><span class="literal">7</span></td>&#13;
<td><span class="literal">07</span></td>&#13;
<td><span class="literal">BEL '\a' (bell)</span></td>&#13;
<td><span class="literal">107</span></td>&#13;
<td><span class="literal">71</span></td>&#13;
<td><span class="literal">47</span></td>&#13;
<td><span class="literal">G</span></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="border-bottom: solid 0.1em;"><span class="literal">...</span></td>&#13;
<td style="border-bottom: solid 0.1em;"/>&#13;
<td style="border-bottom: solid 0.1em;"/>&#13;
<td style="border-bottom: solid 0.1em;"/>&#13;
<td style="border-bottom: solid 0.1em;"/>&#13;
<td style="border-bottom: solid 0.1em;"/>&#13;
<td style="border-bottom: solid 0.1em;"/>&#13;
<td style="border-bottom: solid 0.1em;"/>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<p class="indent">As you can see, this is an easy way to look up the mappings from octal, decimal, and hexadecimal encodings to ASCII characters. This is much faster than googling for an ASCII table!</p>&#13;
</div>&#13;
<h3 class="h3" id="ch05_3">5.3 Viewing File Contents with xxd</h3>&#13;
<p class="noindent">To discover exactly what’s in a file without being able to rely on any standard assumptions about the file contents, you’ll have to analyze it at the byte level. To do this, you can use any numeric system to display bits and bytes on the screen. For instance, you could use the binary system, displaying all the ones and zeros individually. But because that makes for some tedious analysis, it’s better to use the <em>hexadecimal system</em>. In the hexadecimal system (also known as <em>base 16</em>, or <em>hex</em> for short), digits range from 0 to 9 (with the usual meaning) and then from <em>a</em> to <em>f</em> (where <em>a</em> represents the value 10 and <em>f</em> represents 15). In addition, because a byte has 256 = 16 × 16 possible values, it fits exactly in two hexadecimal digits, making this a convenient encoding for compactly displaying bytes.</p>&#13;
<p class="indent">To display the bytes of a file in hexadecimal representation, you use a <em>hex-dumping</em> program. A <em>hex editor</em> is a program that can also edit the bytes <span epub:type="pagebreak" id="page_95"/>in the file. I’ll get back to hex editing in <a href="ch07.xhtml#ch07">Chapter 7</a>, but for now let’s use a simple hex-dumping program called <span class="literal">xxd</span>, which is installed on most Linux systems by default.</p>&#13;
<p class="indent">Here are the first 15 lines of output from <span class="literal">xxd</span> for the bitmap file you’re analyzing:</p>&#13;
<p class="programs">$ <span class="codestrong1">xxd 67b8601 | head -n 15</span><br/>00000000: 424d 3800 0c00 0000 0000 3600 0000 2800 BM8.......6...(.<br/>00000010: 0000 0002 0000 0002 0000 0100 1800 0000 ................<br/>00000020: 0000 0200 0c00 c01e 0000 c01e 0000 0000 ................<br/>00000030: 0000 0000 <span class="ent">➊</span>7f45 4c46 0201 0100 0000 0000 .....ELF........<br/>00000040: 0000 0000 0300 3e00 0100 0000 7009 0000 ......&gt;.....p...<br/>00000050: 0000 0000 4000 0000 0000 0000 7821 0000 ....@.......x!..<br/>00000060: 0000 0000 0000 0000 4000 3800 0700 4000 ........@.8...@.<br/>00000070: 1b00 1a00 0100 0000 0500 0000 0000 0000 ................<br/>00000080: 0000 0000 0000 0000 0000 0000 0000 0000 ................<br/>00000090: 0000 0000 f40e 0000 0000 0000 f40e 0000 ................<br/>000000a0: 0000 0000 0000 2000 0000 0000 0100 0000 ...... .........<br/>000000b0: 0600 0000 f01d 0000 0000 0000 f01d 2000 .............. .<br/>000000c0: 0000 0000 f01d 2000 0000 0000 6802 0000 ...... .....h...<br/>000000d0: 0000 0000 7002 0000 0000 0000 0000 2000 ....p......... .<br/>000000e0: 0000 0000 0200 0000 0600 0000 081e 0000 ................</p>&#13;
<p class="indent">As you can see, the first output column shows the offset into the file in hexadecimal format. The next eight columns show hexadecimal representations of the bytes in the file, and on the rightmost side of the output, you can see an ASCII representation of the same bytes.</p>&#13;
<p class="indent">You can change the number of bytes displayed per line using the <span class="literal">xxd</span> program’s <span class="literal">-c</span> option. For instance, <span class="literal">xxd -c 32</span> will display 32 bytes per line. You can also use <span class="literal">-b</span> to display binary instead of hexadecimal, and you can use <span class="literal">-i</span> to output a C-style array containing the bytes, which you can directly include in your C or C++ source. To output only some of the bytes, you can use the <span class="literal">-s</span> (seek) option to specify a file offset at which to start, and you can use the <span class="literal">-l</span> (length) option to specify the number of bytes to dump.</p>&#13;
<p class="indent">In the <span class="literal">xxd</span> output for the bitmap file, the ELF magic bytes appear at offset <span class="literal">0x34</span> <span class="ent">➊</span>, which corresponds to 52 in the decimal system. This tells you where in the file the suspected ELF library begins. Unfortunately, finding out where it ends is not so trivial because there are no magic bytes delimiting the end of an ELF file. Thus, before you try to extract the complete ELF file, begin by extracting only the ELF header instead. This is easier since you know that 64-bit ELF headers contain exactly 64 bytes. You can then examine the ELF header to figure out how large the complete file is.</p>&#13;
<p class="indent">To extract the header, you use <span class="literal">dd</span> to copy 64 bytes from the bitmap file, starting at offset 52, into a new output file called <em>elf_header</em>.</p>&#13;
<p class="programs">$ <span class="codestrong1">dd skip=52 count=64 if=67b8601 of=elf_header bs=1</span><br/>64+0 records in<br/>64+0 records out<br/>64 bytes copied, 0.000404841 s, 158 kB/s</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_96"/>Using <span class="literal">dd</span> is incidental here, so I won’t explain it in detail. However, <span class="literal">dd</span> is an extremely versatile<sup><a id="ch05fn_1a" href="footnote.xhtml#ch05fn_1">1</a></sup> tool, so it’s worth reading its man page if you aren’t already familiar with it.</p>&#13;
<p class="indent">Let’s use <span class="literal">xxd</span> again to see whether it worked.</p>&#13;
<p class="programs">$ <span class="codestrong1">xxd elf_header</span><br/>00000000: <span class="ent">➊</span>7f45 4c46 0201 0100 0000 0000 0000 0000 .ELF............<br/>00000010: 0300 3e00 0100 0000 7009 0000 0000 0000 ..&gt;.....p.......<br/>00000020: 4000 0000 0000 0000 7821 0000 0000 0000 @.......x!......<br/>00000030: 0000 0000 4000 3800 0700 4000 1b00 1a00 ....@.8...@.....</p>&#13;
<p class="indent">That looks like an ELF header! You can clearly see the magic bytes at the start <span class="ent">➊</span>, and you can also see that the <span class="literal">e_ident</span> array and other fields look reasonable (refer to <a href="ch02.xhtml#ch02">Chapter 2</a> for a description of these fields).</p>&#13;
<h3 class="h3" id="ch05_4">5.4 Parsing the Extracted ELF with readelf</h3>&#13;
<p class="noindent">To view the details of the ELF header you just extracted, it would be great if you could use <span class="literal">readelf</span>, like you did in <a href="ch02.xhtml#ch02">Chapter 2</a>. But will <span class="literal">readelf</span> work on a broken ELF file that contains nothing but a header? Let’s find out in <a href="ch05.xhtml#ch05list1">Listing 5-1</a>!</p>&#13;
<p class="listing1" id="ch05list1"><em>Listing 5-1: The</em> <span class="codeitalic">readelf</span> <em>output for the extracted ELF header</em></p>&#13;
<p class="programs"><span class="ent">➊</span>  $ <span class="codestrong1">readelf  -h  elf_header</span><br/>   ELF Header:<br/>     Magic:  7f 45 4c 46 02 01 01 00 00 00 00 00 00 00 00 00<br/>     Class:                            ELF64<br/>     Data:                             2's complement, little endian<br/>     Version:                          1 (current)<br/>     OS/ABI:                           UNIX - System V<br/>     ABI Version:                      0<br/>     Type:                             DYN (Shared object file)<br/>     Machine:                          Advanced Micro Devices X86-64<br/>     Version:                          0x1<br/>     Entry point address:              0x970<br/>     Start of program headers:         64 (bytes into file)<br/><span class="ent">➋</span>   Start of section headers:         8568 (bytes into file)<br/>     Flags:                            0x0<br/>     Size of this header:              64 (bytes)<br/>     Size of program headers:          56 (bytes)<br/>     Number of program headers:        7<br/><span class="ent">➌</span>   Size of section headers:          64 (bytes)<br/><span class="ent">➍</span>   Number of section headers:        27<br/>     Section header string table index: 26<br/>   readelf: Error: Reading 0x6c0 bytes extends past end of file for section headers<br/>   readelf: Error: Reading 0x188 bytes extends past end of file for program headers</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_97"/>The <span class="literal">-h</span> option <span class="ent">➊</span> tells <span class="literal">readelf</span> to print only the executable header. It still complains that the offsets to the section header table and program header table point outside the file, but that’s okay. What matters is that you now have a convenient representation of the extracted ELF header.</p>&#13;
<p class="indent">Now, how can you figure out the size of the complete ELF using nothing but the executable header? In <a href="ch02.xhtml#ch02fig1">Figure 2-1</a> of <a href="ch02.xhtml#ch02">Chapter 2</a>, you learned that the last part of an ELF file is typically the section header table and that the offset to the section header table is given in the executable header <span class="ent">➋</span>. The executable header also tells you the size of each section header <span class="ent">➌</span> and the number of section headers in the table <span class="ent">➍</span>. This means you can calculate the size of the complete ELF library hidden in your bitmap file as follows:</p>&#13;
<div class="image"><img src="Images/f096-01.jpg" alt="image" width="339" height="80"/></div>&#13;
<p class="indent">In this equation, <em>size</em> is the size of the complete library, <em>e</em>_<em>shoff</em> is the offset to the section header table, <em>e</em>_<em>shnum</em> is the number of section headers in the table, and <em>e</em>_<em>shentsize</em> is the size of each section header.</p>&#13;
<p class="indent">Now that you know that the size of the library should be 10,296 bytes, you can use <span class="literal">dd</span> to extract it completely, as follows:</p>&#13;
<p class="programs">$ <span class="codestrong1">dd skip=52 count=10296 if=67b8601 <span class="ent">➊</span>of=lib5ae9b7f.so bs=1</span><br/>10296+0 records in<br/>10296+0 records out<br/>10296 bytes (10 kB, 10 KiB) copied, 0.0287996 s, 358 kB/s</p>&#13;
<p class="indent">The <span class="literal">dd</span> command calls the extracted file <em>lib5ae9b7f.so</em> <span class="ent">➊</span> because that’s the name of the missing library the <em>ctf</em> binary expects. After running this command, you should now have a fully functioning ELF shared object. Let’s use <span class="literal">readelf</span> to see whether all went well, as shown in <a href="ch05.xhtml#ch05list2">Listing 5-2</a>. To keep the output brief, let’s only print the executable header (<span class="literal">-h</span>) and symbol tables (<span class="literal">-s</span>). The latter should give you an idea of the functionality that the library provides.</p>&#13;
<p class="listing1" id="ch05list2"><em>Listing 5-2: The</em> <span class="codeitalic">readelf</span> <em>output for the extracted library,</em> lib5ae9b7f.so</p>&#13;
<p class="programs">    $ readelf -hs lib5ae9b7f.so<br/>    ELF Header:<br/>      Magic:  7f 45 4c 46 02 01 01 00 00 00 00 00 00 00 00 00<br/>      Class:                             ELF64<br/>      Data:                              2's complement, little endian<br/>      Version:                           1 (current)<br/>      OS/ABI:                            UNIX - System V<br/>      ABI Version:                       0<br/>      Type:                              DYN (Shared object file)<br/>      Machine:                           Advanced Micro Devices X86-64<br/>      Version:                           0x1<br/>      Entry point address:               0x970<br/>      Start of program headers:          64 (bytes into file)<br/>      Start of section headers:          8568 (bytes into file)<br/>      Flags:                             0x0<br/>      Size of this header:               64 (bytes)<br/>      Size of program headers:           56 (bytes)<br/>      Number of program headers:         7<br/>      Size of section headers:           64 (bytes)<br/>      Number of section headers:         27<br/>      Section header string table index: 26<br/>    <br/>    Symbol table '.dynsym' contains 22 entries:<br/>      Num:      Value              Size Type      Bind          Vis       Ndx  Name<br/>        0: 0000000000000000           0 NOTYPE    LOCAL      DEFAULT      UND<br/>        1: 00000000000008c0           0 SECTION   LOCAL      DEFAULT        9<br/>        2: 0000000000000000           0 NOTYPE    WEAK       DEFAULT      UND  __gmon_start__<br/>        3: 0000000000000000           0 NOTYPE    WEAK       DEFAULT      UND  _Jv_RegisterClasses<br/>        4: 0000000000000000           0 FUNC      GLOBAL     DEFAULT      UND  _ZNSt7__cxx1112basic_stri@GL(2)<br/>        5: 0000000000000000           0 FUNC      GLOBAL     DEFAULT      UND  malloc@GLIBC_2.2.5 (3)<br/>        6: 0000000000000000           0 NOTYPE    WEAK       DEFAULT      UND  _ITM_deregisterTMCloneTab<br/>        7: 0000000000000000           0 NOTYPE    WEAK       DEFAULT      UND  _ITM_registerTMCloneTable<br/>        8: 0000000000000000           0 FUNC      WEAK       DEFAULT      UND  __cxa_finalize@GLIBC_2.2.5 (3)<br/>        9: 0000000000000000           0 FUNC      GLOBAL     DEFAULT      UND  __stack_chk_fail@GLIBC_2.4 (4)<br/>       10: 0000000000000000           0 FUNC      GLOBAL     DEFAULT      UND  _ZSt19__throw_logic_error@ (5)<br/>       11: 0000000000000000           0 FUNC      GLOBAL     DEFAULT      UND  memcpy@GLIBC_2.14 (6)<br/><span class="ent">➊</span>     12: 0000000000000bc0          149 FUNC     GLOBAL     DEFAULT        12  _Z11rc4_encryptP11rc4_sta<br/><span class="ent">➋</span>     13: 0000000000000cb0          112 FUNC     GLOBAL     DEFAULT        12  _Z8rc4_initP11rc4_state_t<br/>       14: 0000000000202060           0 NOTYPE    GLOBAL     DEFAULT        24  _end<br/>       15: 0000000000202058           0 NOTYPE    GLOBAL     DEFAULT        23  _edata<br/><span class="ent">➌</span>     16: 0000000000000b40          119 FUNC     GLOBAL     DEFAULT        12  _Z11rc4_encryptP11rc4_sta<br/><span class="ent">➍</span>     17: 0000000000000c60            5 FUNC     GLOBAL     DEFAULT        12  _Z11rc4_decryptP11rc4_sta<br/>       18: 0000000000202058            0 NOTYPE   GLOBAL     DEFAULT        24  __bss_start<br/>       19: 00000000000008c0            0 FUNC     GLOBAL     DEFAULT         9  _init<br/><span class="ent">➎</span>     20: 0000000000000c70           59 FUNC     GLOBAL     DEFAULT        12  _Z11rc4_decryptP11rc4_sta<br/>       21: 0000000000000d20            0 FUNC     GLOBAL     DEFAULT        13  _fini</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_98"/>As hoped, the complete library seems to have been extracted correctly. Although it’s stripped, the dynamic symbol table does reveal some interesting exported functions (<span class="ent">➊</span> through <span class="ent">➎</span>). However, there seems to be some gibberish around the names, making them difficult to read. Let’s see if that can be fixed.</p>&#13;
<h3 class="h3" id="ch05_5"><span epub:type="pagebreak" id="page_99"/>5.5 Parsing Symbols with nm</h3>&#13;
<p class="noindent">C++ allows functions to be <em>overloaded</em>, which means there may be multiple functions with the same name, as long as they have different signatures. Unfortunately for the linker, it doesn’t know anything about C++. For example, if there are multiple functions with the name <span class="literal">foo</span>, the linker has no idea how to resolve references to <span class="literal">foo</span>; it simply doesn’t know which version of <span class="literal">foo</span> to use. To eliminate duplicate names, C++ compilers emit <em>mangled</em> function names. A mangled name is essentially a combination of the original function name and an encoding of the function parameters. This way, each version of the function gets a unique name, and the linker has no problems disambiguating the overloaded functions.</p>&#13;
<p class="indent">For binary analysts, mangled function names are a mixed blessing. On the one hand, mangled names are more difficult to read, as you saw in the <span class="literal">readelf</span> output for <em>lib5ae9b7f.so</em> (<a href="ch05.xhtml#ch05list2">Listing 5-2</a>), which is programmed in C++. On the other hand, mangled function names essentially provide free type information by revealing the expected parameters of the function, and this information can be useful when reverse engineering a binary.</p>&#13;
<p class="indent">Fortunately, the benefits of mangled names outweigh the downsides because mangled names are relatively easy to <em>demangle</em>. There are several standard tools you can use to demangle mangled names. One of the best known is <span class="literal">nm</span>, which lists symbols in a given binary, object file, or shared object. When given a binary, <span class="literal">nm</span> by default attempts to parse the static symbol table.</p>&#13;
<p class="programs">$ <span class="codestrong1">nm lib5ae9b7f.so</span><br/>nm: lib5ae9b7f.so: no symbols</p>&#13;
<p class="indent">Unfortunately, as this example shows, you can’t use <span class="literal">nm</span>’s default configuration on <em>lib5ae9b7f.so</em> because it has been stripped. You have to explicitly ask <span class="literal">nm</span> to parse the dynamic symbol table instead, using the <span class="literal">-D</span> switch, as shown in <a href="ch05.xhtml#ch05list3">Listing 5-3</a>. In this listing, “<span class="literal">...</span>” indicates that I’ve truncated a line and continued it on the next line (mangled names can be quite long).</p>&#13;
<p class="listing1" id="ch05list3"><em>Listing 5-3: The</em> <span class="codeitalic">nm</span> <em>output for</em> lib5ae9b7f.so</p>&#13;
<p class="programs">$ <span class="codestrong1">nm -D lib5ae9b7f.so</span><br/>                 w _ITM_deregisterTMCloneTable<br/>                 w _ITM_registerTMCloneTable<br/>                 w _Jv_RegisterClasses<br/>0000000000000c60 T _Z11rc4_decryptP11rc4_state_tPhi<br/>0000000000000c70 T _Z11rc4_decryptP11rc4_state_tRNSt7__cxx1112basic_...<br/>                 ...stringIcSt11char_traitsIcESaIcEEE<br/>0000000000000b40 T _Z11rc4_encryptP11rc4_state_tPhi<br/>0000000000000bc0 T _Z11rc4_encryptP11rc4_state_tRNSt7__cxx1112basic_...<br/>                 ...stringIcSt11char_traitsIcESaIcEEE<br/>0000000000000cb0 T _Z8rc4_initP11rc4_state_tPhi<br/>                 U _ZNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEE9_...<br/>                   ...M_createERmm<br/>                 U _ZSt19__throw_logic_errorPKc<br/>0000000000202058 B __bss_start<br/>                 w __cxa_finalize<br/>                 w __gmon_start__<br/>                 U __stack_chk_fail<br/>0000000000202058 D _edata<br/>0000000000202060 B _end<br/>0000000000000d20 T _fini<br/>00000000000008c0 T _init<br/>                 U malloc<br/>                 U memcpy</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_100"/>This looks better; this time you see some symbols. But the symbol names are still mangled. To demangle them, you have to pass the <span class="literal">--demangle</span> switch to <span class="literal">nm</span>, as shown in <a href="ch05.xhtml#ch05list4">Listing 5-4</a>.</p>&#13;
<p class="listing1" id="ch05list4"><em>Listing 5-4: Demangled</em> <span class="codeitalic">nm</span> <em>output for</em> lib5ae9b7f.so</p>&#13;
<p class="programs">$ <span class="codestrong1">nm -D --demangle  lib5ae9b7f.so</span><br/>                 w  _ITM_deregisterTMCloneTable<br/>                 w  _ITM_registerTMCloneTable<br/>                 w  _Jv_RegisterClasses<br/>0000000000000c60 T  <span class="ent">➊</span>rc4_decrypt(rc4_state_t*, unsigned char*, int)<br/>0000000000000c70 T  <span class="ent">➋</span>rc4_decrypt(rc4_state_t*,<br/>                                 std::__cxx11::basic_string&lt;char, std::char_traits&lt;char&gt;,<br/>                                 std::allocator&lt;char&gt; &gt;&amp;)<br/>0000000000000b40 T  <span class="ent">➌</span>rc4_encrypt(rc4_state_t*, unsigned char*, int)<br/>0000000000000bc0 T  <span class="ent">➍</span>rc4_encrypt(rc4_state_t*,<br/>                                 std::__cxx11::basic_string&lt;char, std::char_traits&lt;char&gt;,<br/>                                 std::allocator&lt;char&gt; &gt;&amp;)<br/>0000000000000cb0 T  <span class="ent">➎</span>rc4_init(rc4_state_t*, unsigned char*, int)<br/>                 U  std::__cxx11::basic_string&lt;char, std::char_traits&lt;char&gt;,<br/>                        std::allocator&lt;char&gt; &gt;::_M_create(unsigned long&amp;, unsigned long)<br/>                 U  std::__throw_logic_error(char const*)<br/>0000000000202058 B  __bss_start<br/>                 w  __cxa_finalize<br/>                 w  __gmon_start__<br/>                 U  __stack_chk_fail<br/>0000000000202058 D  _edata<br/>0000000000202060 B  _end<br/>0000000000000d20 T  _fini<br/>00000000000008c0 T  _init<br/>                 U  malloc<br/>                 U  memcpy</p>&#13;
<p class="indent">Finally, the function names appear human-readable. You can see five interesting functions, which appear to be cryptographic functions <span epub:type="pagebreak" id="page_101"/>implementing the well-known RC4 encryption algorithm.<sup><a id="ch05fn_2a" href="footnote.xhtml#ch05fn_2">2</a></sup> There’s a function called <span class="literal">rc4_init</span>, which takes as input a data structure of type <span class="literal">rc4_state_t</span>, as well as an unsigned character string and an integer <span class="ent">➎</span>. The first parameter is presumably a data structure where the cryptographic state is kept, while the next two are probably a string representing a key and an integer specifying the length of the key, respectively. You can also see several encryption and decryption functions, each of which takes a pointer to the cryptographic state, as well as parameters specifying strings (both C and C++ strings) to encrypt or decrypt (<span class="ent">➊</span> through <span class="ent">➍</span>).</p>&#13;
<p class="indent">As an alternative way of demangling function names, you can use a specialized utility called <span class="literal">c++filt</span>, which takes a mangled name as the input and outputs the demangled equivalent. The advantage of <span class="literal">c++filt</span> is that it supports several mangling formats and automatically detects the correct mangling format for the given input. Here’s an example using <span class="literal">c++filt</span> to demangle the function name <span class="literal">_Z8rc4_initP11rc4_state_tPhi</span>:</p>&#13;
<p class="programs">$ <span class="codestrong1">c++filt _Z8rc4_initP11rc4_state_tPhi</span><br/>rc4_init(rc4_state_t*, unsigned char*, int)</p>&#13;
<p class="indent">At this point, let’s briefly recap the progress so far. You extracted the mysterious payload and found a binary called <em>ctf</em> that depends on a file called <em>lib5ae9b7f.so</em>. You found <em>lib5ae9b7f.so</em> hidden in a bitmap file and successfully extracted it. You also have a rough idea of what it does: it’s a cryptographic library. Now let’s try running <em>ctf</em> again, this time with no missing dependencies.</p>&#13;
<p class="indent">When you run a binary, the linker resolves the binary’s dependencies by searching a number of standard directories for shared libraries, such as <em>/lib</em>. Because you extracted <em>lib5ae9b7f.so</em> to a nonstandard directory, you need to tell the linker to search that directory too by setting an environment variable called <span class="literal">LD_LIBRARY_PATH</span>. Let’s set this variable to contain the current working directory and then try launching <em>ctf</em> again.</p>&#13;
<p class="programs">$ <span class="codestrong1">export LD_LIBRARY_PATH=`pwd`</span><br/>$ <span class="codestrong1">./ctf</span><br/>$ <span class="codestrong1">echo $?</span><br/>1</p>&#13;
<p class="indent">Success! The <em>ctf</em> binary still doesn’t appear to do anything useful, but it runs without complaining about any missing libraries. The exit status of <em>ctf</em> contained in the <span class="literal">$?</span> variable is 1, indicating an error. Now that you have all the required dependencies, you can continue your investigation and see whether you can coax <em>ctf</em> into getting past the error so that you can reach the flag you’re trying to capture.</p>&#13;
<h3 class="h3" id="ch05_6"><span epub:type="pagebreak" id="page_102"/>5.6 Looking for Hints with strings</h3>&#13;
<p class="noindent">To figure out what a binary does and what kinds of inputs it expects, you can check whether the binary contains any helpful strings that can reveal its purpose. For instance, if you see strings containing parts of HTTP requests or URLs, you can safely guess that the binary is doing something web related. When you’re dealing with malware such as a bot, you might be able to find strings containing the commands that the bot accepts, if they’re not obfuscated. You might even find strings left over from debugging that the programmer forgot to remove, which has been known to happen in real-world malware!</p>&#13;
<p class="indent">You can use a utility called <span class="literal">strings</span> to check for strings in a binary (or any other file) on Linux. The <span class="literal">strings</span> utility takes one or more files as input and then prints any printable character strings found in those files. Note that <span class="literal">strings</span> doesn’t check whether the found strings were really intended to be human readable, so when used on binary files, the <span class="literal">strings</span> output may include some bogus strings as a result of binary sequences that just happen to be printable.</p>&#13;
<p class="indent">You can tweak the behavior of <span class="literal">strings</span> using options. For example, you can use the <span class="literal">-d</span> switch with <span class="literal">strings</span> to print only strings found in data sections in a binary instead of printing all sections. By default, <span class="literal">strings</span> prints only strings of four characters or more, but you can specify another minimum string length using the <span class="literal">-n</span> option. For our purposes, the default options will suffice; let’s see what you can find in the <em>ctf</em> binary using <span class="literal">strings</span>, as shown in <a href="ch05.xhtml#ch05list5">Listing 5-5</a>.</p>&#13;
<p class="listing1" id="ch05list5"><em>Listing 5-5: Character strings found in the</em> ctf <em>binary</em></p>&#13;
<p class="programs">   $ <span class="codestrong1">strings ctf</span><br/><span class="ent">➊</span> /lib64/ld-linux-x86-64.so.2<br/>   lib5ae9b7f.so<br/><span class="ent">➋</span> __gmon_start__<br/>   _Jv_RegisterClasses<br/>   _ITM_deregisterTMCloneTable<br/>   _ITM_registerTMCloneTable<br/>   _Z8rc4_initP11rc4_state_tPhi<br/>    ...<br/><span class="ent">➌</span> <span class="gray_mark">DEBUG: argv[1] = %s</span><br/><span class="ent">➍</span> <span class="gray_mark">checking '%s'</span><br/><span class="ent">➎</span> <span class="gray_mark">show_me_the_flag</span><br/>   &gt;CMb<br/>   -v@P<img src="Images/uparrow1.jpg" alt="image" width="7" height="15"/><br/>   flag = %s<br/>   guess again!<br/><span class="ent">➏</span> <span class="gray_mark">It's kinda like Louisiana. Or Dagobah. Dagobah - Where Yoda lives!</span><br/>   ;*3$"<br/>   zPLR<br/>   GCC: (Ubuntu 5.4.0-6ubuntu1~16.04.4) 5.4.0 20160609<br/><span class="ent">➐</span> .shstrtab<br/>   .interp<br/>   .note.ABI-tag<br/>   .note.gnu.build-id<br/>   .gnu.hash<br/>   .dynsym<br/>   .dynstr<br/>   .gnu.version<br/>   .gnu.version_r<br/>   .rela.dyn<br/>   .rela.plt<br/>   .init<br/>   .plt.got<br/>   .text<br/>   .fini<br/>   .rodata<br/>   .eh_frame_hdr<br/>   .eh_frame<br/>   .gcc_except_table<br/>   .init_array<br/>   .fini_array<br/>   .jcr<br/>   .dynamic<br/>   .got.plt<br/>   .data<br/>   .bss<br/>   .comment</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_103"/>Here, you can see some strings that you’ll encounter in most ELF files. For example, there’s the name of the program interpreter <span class="ent">➊</span>, as found in the <span class="literal">.interp</span> section, and some symbolic names found in <span class="literal">.dynstr</span> <span class="ent">➋</span>. At the end of the <span class="literal">strings</span> output, you can see all the section names as found in the <span class="literal">.shstrtab</span> section <span class="ent">➐</span>. But none of these strings is very interesting for the purposes here.</p>&#13;
<p class="indent">Fortunately, there are also some more useful strings. For example, there is what appears to be a debug message, which suggests that the program expects a command line option <span class="ent">➌</span>. There are also checks of some sort, presumably performed on an input string <span class="ent">➍</span>. You don’t yet know what the value of the command line option should be, but you could try some of the other interesting-looking strings, such as <span class="literal">show_me_the_flag</span> <span class="ent">➎</span>, that might work. There’s also a mysterious string <span class="ent">➏</span> that contains a message whose purpose is unclear. You don’t know what the message means at this point, but you do know from your investigation of <em>lib5ae9b7f.so</em> that the binary uses RC4 encryption. Perhaps the message is used as an encryption key?</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_104"/>Now that you know that the binary expects a command line option, let’s see whether adding an arbitrary option gets you any closer to revealing the flag. For lack of a better guess, let’s simply use the string <span class="literal">foobar</span>, like this:</p>&#13;
<p class="programs">$ <span class="codestrong1">./ctf foobar</span><br/>checking 'foobar'<br/>$ <span class="codestrong1">echo $?</span><br/>1</p>&#13;
<p class="indent">The binary now does something new. It tells you that it’s checking the input string you gave it. But the check doesn’t succeed because the binary still exits with an error code after the check. Let’s take a gamble and try one of the other interesting-looking strings that you found, such as the string <span class="literal">show_me_the_flag</span>, which looks promising.</p>&#13;
<p class="programs">$ <span class="codestrong1">./ctf show_me_the_flag</span><br/>checking 'show_me_the_flag'<br/>ok<br/>$ <span class="codestrong1">echo $?</span><br/>1</p>&#13;
<p class="indent">That did it! The check now appears to succeed. Unfortunately, the exit status is still 1, so there must be something else missing. To make things worse, the <span class="literal">strings</span> results don’t provide any more hints. Let’s take a more detailed look at <em>ctf</em> ’s behavior to determine what to do next, starting with the system and library calls <em>ctf</em> makes.</p>&#13;
<h3 class="h3" id="ch05_7">5.7 Tracing System Calls and Library Calls with strace and ltrace</h3>&#13;
<p class="noindent">To make forward progress, let’s investigate the reason that <em>ctf</em> exits with an error code by looking at <em>ctf</em> ’s behavior just before it exits. There are many ways that you could do this, but one way is to use two tools called <span class="literal">strace</span> and <span class="literal">ltrace</span>. These tools show the system calls and library calls, respectively, executed by a binary. Knowing the system and library calls that a binary makes can often give you a good high-level idea of what the program is doing.</p>&#13;
<p class="indent">Let’s start by using <span class="literal">strace</span> to investigate <em>ctf</em> ’s system call behavior. In some cases, you may want to attach <span class="literal">strace</span> to a running process. To do this, you need to use the <span class="literal">-p</span> <em>pid</em> option, where <em>pid</em> is the process ID of the process you want to attach to. However, in this case, it suffices to run <em>ctf</em> with <span class="literal">strace</span> from the start. <a href="ch05.xhtml#ch05list6">Listing 5-6</a> shows the <span class="literal">strace</span> output for the <em>ctf</em> binary (some parts are truncated with “<span class="literal">...</span>”).</p>&#13;
<p class="listing1" id="ch05list6"><em>Listing 5-6: System calls executed by the</em> ctf <em>binary</em></p>&#13;
<p class="programs">   $ <span class="codestrong1">strace ./ctf show_me_the_flag</span><br/><span class="ent">➊</span> execve("./ctf", ["./ctf", "show_me_the_flag"], [/* 73 vars */]) = 0<br/>   brk(NULL)                               = 0x1053000<br/>   <span epub:type="pagebreak" id="page_105"/>access("/etc/ld.so.nohwcap", F_OK)            = -1 ENOENT (No such file or directory)<br/>   mmap(NULL, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0x7f703477e000<br/>   access("/etc/ld.so.preload", R_OK)              = -1 ENOENT (No such file or directory)<br/><span class="ent">➋</span> open("/ch3/tls/x86_64/lib5ae9b7f.so", O_RDONLY|O_CLOEXEC) = -1 ENOENT (No such file or ...)<br/>   stat("/ch3/tls/x86_64", 0x7ffcc6987ab0) = -1 ENOENT (No such file or directory)<br/>   open("/ch3/tls/lib5ae9b7f.so", O_RDONLY|O_CLOEXEC) = -1 ENOENT (No such file or directory)<br/>   stat("/ch3/tls", 0x7ffcc6987ab0) = -1 ENOENT (No such file or directory)<br/>   open("/ch3/x86_64/lib5ae9b7f.so", O_RDONLY|O_CLOEXEC) = -1 ENOENT (No such file or directory)<br/>   stat("/ch3/x86_64", 0x7ffcc6987ab0) = -1 ENOENT (No such file or directory)<br/>   open("/ch3/lib5ae9b7f.so", O_RDONLY|O_CLOEXEC) = 3<br/><span class="ent">➌</span> read(3, "\177ELF\2\1\1\0\0\0\0\0\0\0\0\0\3\0&gt;\0\1\0\0\0p\t\0\0\0\0\0\0"..., 832) = 832<br/>   fstat(3, st_mode=S_IFREG|0775, st_size=10296, ...) = 0<br/>   mmap(NULL, 2105440, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 3, 0) = 0x7f7034358000<br/>   mprotect(0x7f7034359000, 2097152, PROT_NONE) = 0<br/>   mmap(0x7f7034559000, 8192, PROT_READ|PROT_WRITE, ..., 3, 0x1000) = 0x7f7034559000<br/>   close(3)                                = 0<br/>   open("/ch3/libstdc++.so.6", O_RDONLY|O_CLOEXEC) = -1 ENOENT (No such file or directory)<br/>   open("/etc/ld.so.cache", O_RDONLY|O_CLOEXEC) = 3<br/>   fstat(3, st_mode=S_IFREG|0644, st_size=150611, ...) = 0<br/>   mmap(NULL, 150611, PROT_READ, MAP_PRIVATE, 3, 0) = 0x7f7034759000<br/>   close(3)                                = 0<br/>   access("/etc/ld.so.nohwcap", F_OK)      = -1 ENOENT (No such file or directory)<br/><span class="ent">➍</span> open("/usr/lib/x86_64-linux-gnu/libstdc++.so.6", O_RDONLY|O_CLOEXEC) = 3<br/>   read(3, "\177ELF\2\1\1\3\0\0\0\0\0\0\0\0\3\0&gt;\0\1\0\0\0 \235\10\0\0\0\0\0"..., 832) = 832<br/>   fstat(3, st_mode=S_IFREG|0644, st_size=1566440, ...) = 0<br/>   mmap(NULL, 3675136, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 3, 0) = 0x7f7033fd6000<br/>   mprotect(0x7f7034148000, 2097152, PROT_NONE) = 0<br/>   mmap(0x7f7034348000, 49152, PROT_READ|PROT_WRITE, ..., 3, 0x172000) = 0x7f7034348000<br/>   mmap(0x7f7034354000, 13312, PROT_READ|PROT_WRITE, ..., -1, 0) = 0x7f7034354000<br/>   close(3)                                = 0<br/>   open("/ch3/libgcc_s.so.1", O_RDONLY|O_CLOEXEC) = -1 ENOENT (No such file or directory)<br/>   access("/etc/ld.so.nohwcap", F_OK)      = -1 ENOENT (No such file or directory)<br/>   open("/lib/x86_64-linux-gnu/libgcc_s.so.1", O_RDONLY|O_CLOEXEC) = 3<br/>   read(3, "\177ELF\2\1\1\0\0\0\0\0\0\0\0\0\3\0&gt;\0\1\0\0\0p*\0\0\0\0\0\0"..., 832) = 832<br/>   fstat(3, st_mode=S_IFREG|0644, st_size=89696, ...) = 0<br/>   mmap(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0x7f7034758000<br/>   mmap(NULL, 2185488, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 3, 0) = 0x7f7033dc0000<br/>   mprotect(0x7f7033dd6000, 2093056, PROT_NONE) = 0<br/>   mmap(0x7f7033fd5000, 4096, PROT_READ|PROT_WRITE, ..., 3, 0x15000) = 0x7f7033fd5000<br/>   close(3)                                = 0<br/>   open("/ch3/libc.so.6", O_RDONLY|O_CLOEXEC) = -1 ENOENT (No such file or directory)<br/>   access("/etc/ld.so.nohwcap", F_OK)      = -1 ENOENT (No such file or directory)<br/>   open("/lib/x86_64-linux-gnu/libc.so.6", O_RDONLY|O_CLOEXEC) = 3<br/>   read(3, "\177ELF\2\1\1\3\0\0\0\0\0\0\0\0\3\0&gt;\0\1\0\0\0P\t\2\0\0\0\0\0"..., 832) = 832<br/>   fstat(3, st_mode=S_IFREG|0755, st_size=1864888, ...) = 0<br/>   mmap(NULL, 3967392, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 3, 0) = 0x7f70339f7000<br/>   mprotect(0x7f7033bb6000, 2097152, PROT_NONE) = 0<br/>   <span epub:type="pagebreak" id="page_106"/>mmap(0x7f7033db6000, 24576, PROT_READ|PROT_WRITE, ..., 3, 0x1bf000) = 0x7f7033db6000<br/>   mmap(0x7f7033dbc000, 14752, PROT_READ|PROT_WRITE, ..., -1, 0) = 0x7f7033dbc000<br/>   close(3)                                = 0<br/>   open("/ch3/libm.so.6", O_RDONLY|O_CLOEXEC) = -1 ENOENT (No such file or directory)<br/>   access("/etc/ld.so.nohwcap", F_OK)      = -1 ENOENT (No such file or directory)<br/>   open("/lib/x86_64-linux-gnu/libm.so.6", O_RDONLY|O_CLOEXEC) = 3<br/>   read(3, "\177ELF\2\1\1\3\0\0\0\0\0\0\0\0\3\0&gt;\0\1\0\0\0\0V\0\0\0\0\0\0"..., 832) = 832<br/>   fstat(3, st_mode=S_IFREG|0644, st_size=1088952, ...) = 0<br/>   mmap(NULL, 3178744, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 3, 0) = 0x7f70336ee000<br/>   mprotect(0x7f70337f6000, 2093056, PROT_NONE) = 0<br/>   mmap(0x7f70339f5000, 8192, PROT_READ|PROT_WRITE, ..., 3, 0x107000) = 0x7f70339f5000<br/>   close(3)                                = 0<br/>   mmap(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0x7f7034757000<br/>   mmap(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0x7f7034756000<br/>   mmap(NULL, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0x7f7034754000<br/>   arch_prctl(ARCH_SET_FS, 0x7f7034754740) = 0<br/>   mprotect(0x7f7033db6000, 16384, PROT_READ) = 0<br/>   mprotect(0x7f70339f5000, 4096, PROT_READ) = 0<br/>   mmap(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0x7f7034753000<br/>   mprotect(0x7f7034348000, 40960, PROT_READ) = 0<br/>   mprotect(0x7f7034559000, 4096, PROT_READ) = 0<br/>   mprotect(0x601000, 4096, PROT_READ)     = 0<br/>   mprotect(0x7f7034780000, 4096, PROT_READ) = 0<br/>   munmap(0x7f7034759000, 150611)          = 0<br/>   brk(NULL)                               = 0x1053000<br/>   brk(0x1085000)                          = 0x1085000<br/>   fstat(1, st_mode=S_IFCHR|0620, st_rdev=makedev(136, 1), ...) = 0<br/><span class="ent">➎</span> write(1, "checking 'show_me_the_flag'\n", 28checking 'show_me_the_flag'<br/>   ) = 28<br/><span class="ent">➏</span> write(1, "ok\n", 3ok<br/>   ) = 3<br/><span class="ent">➐</span> exit_group(1) = ?<br/>   +++ exited with 1 +++</p>&#13;
<p class="indent">When tracing a program from the start, <span class="literal">strace</span> includes all the system calls used by the program interpreter to set up the process, making the output quite verbose. The first system call in the output is <span class="literal">execve</span>, which is called by your shell to launch the program <span class="ent">➊</span>. After that, the program interpreter takes over and starts setting up the execution environment. This involves setting up memory regions and setting the correct memory access permissions using <span class="literal">mprotect</span>. Additionally, you can see the system calls used to look up and load the required dynamic libraries.</p>&#13;
<p class="indent">Recall that in <a href="ch05.xhtml#ch05_5">Section 5.5</a>, you set the <span class="literal">LD_LIBRARY_PATH</span> environment variable to tell the dynamic linker to add your current working directory to its search path. This is why you can see the dynamic linker searching for the <em>lib5ae9b7f.so</em> library in a number of standard subfolders in your current working directory, until it finally finds the library in the root of your working <span epub:type="pagebreak" id="page_107"/>directory <span class="ent">➋</span>. When the library is found, the dynamic linker reads it and maps it into memory <span class="ent">➌</span>. The setup process is repeated for other required libraries, such as <em>libstdc++.so.6</em> <span class="ent">➍</span>, and it accounts for the vast majority of the <span class="literal">strace</span> output.</p>&#13;
<p class="indent">It isn’t until the last three system calls that you finally see application-specific behavior. The first system call used by <em>ctf</em> itself is <span class="literal">write</span>, which is used to print <span class="literal">checking 'show_me_the_flag'</span> to the screen <span class="ent">➎</span>. You see another <span class="literal">write</span> call to print the string <span class="literal">ok</span> <span class="ent">➏</span>, and finally, there’s a call to <span class="literal">exit_group</span>, which leads to the exit with status code 1 <span class="ent">➐</span>.</p>&#13;
<p class="indent">That’s all interesting, but how does it help you figure out how to extract the flag from <em>ctf</em> ? The answer is that it doesn’t! In this case, <span class="literal">strace</span> didn’t reveal anything helpful, but I still wanted to show you how it works because it can be useful for understanding a program’s behavior. For instance, observing the system calls executed by a program is useful not only for binary analysis but also for debugging.</p>&#13;
<p class="indent">Looking at <em>ctf</em> ’s system call behavior didn’t help much, so let’s try library calls. To view the library calls executed by <em>ctf</em>, you use <span class="literal">ltrace</span>. Because <span class="literal">ltrace</span> is a close relative of <span class="literal">strace</span>, it takes many of the same command line options, including <span class="literal">-p</span> to attach to an existing process. Here, let’s use the <span class="literal">-i</span> option to print the instruction pointer at every library call (this will be useful later). We’ll use <span class="literal">-C</span> to automatically demangle C++ function names. Let’s run <em>ctf</em> with <span class="literal">ltrace</span> from the start, as shown in <a href="ch05.xhtml#ch05list7">Listing 5-7</a>.</p>&#13;
<p class="listing1" id="ch05list7"><em>Listing 5-7: Library calls made by the</em> ctf <em>binary</em></p>&#13;
<p class="programs">   $ <span class="codestrong1">ltrace -i -C ./ctf show_me_the_flag</span><br/><span class="ent">➊</span> [0x400fe9] <span class="gray_mark">__libc_start_main</span> (0x400bc0, 2, 0x7ffc22f441e8, 0x4010c0 &lt;unfinished ...&gt;<br/><span class="ent">➋</span> [0x400c44] <span class="gray_mark">__printf_chk</span> (1, 0x401158, 0x7ffc22f4447f, 160checking 'show_me_the_flag') = 28<br/><span class="ent">➌</span> [0x400c51] <span class="gray_mark">strcmp</span> ("show_me_the_flag", "show_me_the_flag") = 0<br/><span class="ent">➍</span> [0x400cf0] <span class="gray_mark">puts</span> ("ok"ok) = 3<br/><span class="ent">➎</span> [0x400d07] <span class="gray_mark">rc4_init</span> (rc4_state_t*, unsigned char*, int)<br/>               (0x7ffc22f43fb0, 0x4011c0, 66, 0x7fe979b0d6e0) = 0<br/><span class="ent">➏</span> [0x400d14] std::__cxx11::basic_string&lt;char, std::char_traits&lt;char&gt;,<br/>               std::allocator&lt;char&gt; &gt;:: <span class="gray_mark">assign</span> (char const*)<br/>               (0x7ffc22f43ef0, 0x40117b, 58, 3) = 0x7ffc22f43ef0<br/><span class="ent">➐</span> [0x400d29] <span class="gray_mark">rc4_decrypt</span> (rc4_state_t*, std::__cxx11::basic_string&lt;char,<br/>               std::char_traits&lt;char&gt;, std::allocator&lt;char&gt; &gt;&amp;)<br/>               (0x7ffc22f43f50, 0x7ffc22f43fb0, 0x7ffc22f43ef0, 0x7e889f91) = 0x7ffc22f43f50<br/><span class="ent">➑</span> [0x400d36] std::__cxx11::basic_string&lt;char, std::char_traits&lt;char&gt;,<br/>               std::allocator&lt;char&gt; &gt;:: <span class="gray_mark">_M_assign</span> (std::__cxx11::basic_string&lt;char,<br/>               std::char_traits&lt;char&gt;, std::allocator&lt;char&gt; &gt; const&amp;)<br/>               (0x7ffc22f43ef0, 0x7ffc22f43f50, 0x7ffc22f43f60, 0) = 0<br/><span class="ent">➒</span> [0x400d53] <span class="gray_mark">getenv</span> ("GUESSME") = nil<br/>   [0xffffffffffffffff] +++ exited (status 1) +++</p>&#13;
<p class="indent">As you can see, this output from <span class="literal">ltrace</span> is a lot more readable than the <span class="literal">strace</span> output because it isn’t polluted by all the process setup code. <span epub:type="pagebreak" id="page_108"/>The first library call is <span class="literal">__libc_start_main</span> <span class="ent">➊</span>, which is called from the <span class="literal">_start</span> function to transfer control to the program’s <span class="literal">main</span> function. Once <span class="literal">main</span> is started, its first library call prints the now familiar <span class="literal">checking ...</span> string to the screen <span class="ent">➋</span>. The actual check turns out to be a string comparison, which is implemented using <span class="literal">strcmp</span>, and verifies that the argument given to <em>ctf</em> is equal to <span class="literal">show_me_the_flag</span> <span class="ent">➌</span>. If this is the case, <span class="literal">ok</span> is printed to the screen <span class="ent">➍</span>.</p>&#13;
<p class="indent">So far, this is mostly behavior you’ve seen before. But now you see something new: the RC4 cryptography is initialized through a call to <span class="literal">rc4_init</span>, which is located in the library you extracted earlier <span class="ent">➎</span>. After that, you see an <span class="literal">assign</span> to a C++ string, presumably initializing it with an encrypted message <span class="ent">➏</span>. This message is then decrypted with a call to <span class="literal">rc4_decrypt</span> <span class="ent">➐</span>, and the decrypted message is assigned to a new C++ string <span class="ent">➑</span>.</p>&#13;
<p class="indent">Finally, there’s a call to <span class="literal">getenv</span>, which is a standard library function used to look up environment variables <span class="ent">➒</span>. You can see that <em>ctf</em> expects an environment variable called <span class="literal">GUESSME</span>! The name of this variable may well be the string that was decrypted earlier. Let’s see whether <em>ctf</em> ’s behavior changes when you set a dummy value for the <span class="literal">GUESSME</span> environment variable as follows:</p>&#13;
<p class="programs">$ <span class="codestrong1">GUESSME='foobar' ./ctf show_me_the_flag</span><br/>checking 'show_me_the_flag'<br/>ok<br/>guess again!</p>&#13;
<p class="indent">Setting <span class="literal">GUESSME</span> results in an additional line of output that says <span class="literal">guess again!</span>. It seems that <em>ctf</em> expects <span class="literal">GUESSME</span> to be set to another specific value. Perhaps another <span class="literal">ltrace</span> run, as shown in <a href="ch05.xhtml#ch05list8">Listing 5-8</a>, will reveal what the expected value is.</p>&#13;
<p class="listing1" id="ch05list8"><em>Listing 5-8: Library calls made by the</em> ctf <em>binary after setting the</em> <span class="codeitalic">GUESSME</span> <em>environment variable</em></p>&#13;
<p class="programs">   $ <span class="codestrong1">GUESSME='foobar' ltrace -i -C ./ctf show_me_the_flag</span><br/>   ...<br/>   [0x400d53] <span class="gray_mark">getenv</span> ("GUESSME") = "foobar"<br/><span class="ent">➊</span> [0x400d6e] std::__cxx11::basic_string&lt;char, std::char_traits&lt;char&gt;,<br/>                std::allocator&lt;char&gt; &gt;:: <span class="gray_mark">assign</span> (char const*)<br/>                (0x7fffc7af2b00, 0x401183, 5, 3) = 0x7fffc7af2b00<br/><span class="ent">➋</span> [0x400d88] <span class="gray_mark">rc4_decrypt</span> (rc4_state_t*, std::__cxx11::basic_string&lt;char,<br/>                std::char_traits&lt;char&gt;, std::allocator&lt;char&gt; &gt;&amp;)<br/>                (0x7fffc7af2b60, 0x7fffc7af2ba0, 0x7fffc7af2b00, 0x401183) = 0x7fffc7af2b60<br/>   [0x400d9a] std::__cxx11::basic_string&lt;char, std::char_traits&lt;char&gt;,<br/>                std::allocator&lt;char&gt; &gt;:: <span class="gray_mark">_M_assign</span> (std::__cxx11::basic_string&lt;char,<br/>                std::char_traits&lt;char&gt;, std::allocator&lt;char&gt; &gt; const&amp;)<br/>                (0x7fffc7af2b00, 0x7fffc7af2b60, 0x7700a0, 0) = 0<br/>   [0x400db4] operator <span class="gray_mark">delete</span> (void*)(0x7700a0, 0x7700a0, 21, 0) = 0<br/><span class="ent">➌</span> [0x400dd7] <span class="gray_mark">puts</span> ("guess again!"guess again!) = 13<br/>   [0x400c8d] operator <span class="gray_mark">delete</span> (void*)(0x770050, 0x76fc20, 0x7f70f99b3780, 0x7f70f96e46e0) = 0<br/>   [0xffffffffffffffff] +++ exited (status 1) +++</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_109"/>After the call to <span class="literal">getenv</span>, <em>ctf</em> goes on to assign <span class="ent">➊</span> and decrypt <span class="ent">➋</span> another C++ string. Unfortunately, between the decryption and the moment that <span class="literal">guess again</span> is printed to the screen <span class="ent">➌</span>, you don’t see any hints regarding the expected value of <span class="literal">GUESSME</span>. This tells you that the comparison of <span class="literal">GUESSME</span> to its expected value is implemented without the use of any library functions. You’ll need to take another approach.</p>&#13;
<h3 class="h3" id="ch05_8">5.8 Examining Instruction-Level Behavior Using objdump</h3>&#13;
<p class="noindent">Because you know that the value of the <span class="literal">GUESSME</span> environment variable is checked without using any well-known library functions, a logical next step is to use <span class="literal">objdump</span> to examine <em>ctf</em> at the instruction level to find out what’s going on.<sup><a id="ch05fn_3a" href="footnote.xhtml#ch05fn_3">3</a></sup></p>&#13;
<p class="indent">From the <span class="literal">ltrace</span> output in <a href="ch05.xhtml#ch05list8">Listing 5-8</a>, you know that the <span class="literal">guess again</span> string is printed to the screen by a call to <span class="literal">puts</span> at address <span class="literal">0x400dd7</span>. Let’s focus the <span class="literal">objdump</span> investigation around this address. It will also help to know the address of the string to find the first instruction that loads it. To find this address, you can look at the <span class="literal">.rodata</span> section of the <em>ctf</em> binary using <span class="literal">objdump -s</span> to print the full section contents, as shown in <a href="ch05.xhtml#ch05list9">Listing 5-9</a>.</p>&#13;
<p class="listing1" id="ch05list9"><em>Listing 5-9: The contents of</em> ctf<em>’s</em> <span class="codeitalic">.rodata</span> <em>section as shown by</em> <span class="codeitalic">objdump</span></p>&#13;
<p class="programs">$ <span class="codestrong1">objdump -s --section .rodata ctf</span><br/><br/>ctf:      file format elf64-x86-64<br/><br/>Contents of section .rodata:<br/> 401140  01000200  44454255  473a2061  7267765b    ....DEBUG: argv[<br/> 401150  315d203d  20257300  63686563  6b696e67    1] = %s.checking<br/> 401160  20272573  270a0073  686f775f  6d655f74     '%s'..show_me_t<br/> 401170  68655f66  6c616700  6f6b004f  89df919f    he_flag.ok.O....<br/> 401180  887e009a  5b38babe  27ac0e3e  434d6285    .~..[8..'..&gt;CMb.<br/> 401190  55868954  3848a34d  00192d76  40505e3a    U..T8H.M..-v@P^:<br/> 4011a0  00726200  666c6167  203d2025  730a00<span class="ent">➊</span><span class="gray_mark">67</span>   .rb.flag = %s..g<br/> 4011b0  <span class="gray_mark">75657373  20616761  696e21</span>00  00000000    <span class="gray_mark">uess again!</span>.....<br/> 4011c0  49742773  206b696e  6461206c  696b6520    It's kinda like<br/> 4011d0  4c6f7569  7369616e  612e204f  72204461    Louisiana. Or Da<br/> 4011e0  676f6261  682e2044  61676f62  6168202d    gobah. Dagobah -<br/> 4011f0  20576865  72652059  6f646120  6c697665    Where Yoda live<br/> 401200  73210000  00000000                       s!......</p>&#13;
<p class="indent">Using <span class="literal">objdump</span> to examine <em>ctf</em> ’s <span class="literal">.rodata</span> section, you can see the <span class="literal">guess again</span> string at address <span class="literal">0x4011af</span> <span class="ent">➊</span>. Now let’s take a look at <a href="ch05.xhtml#ch05list10">Listing 5-10</a>, which <span epub:type="pagebreak" id="page_110"/>shows the instructions around the <span class="literal">puts</span> call, to find out what input <em>ctf</em> expects for the <span class="literal">GUESSME</span> environment variable.</p>&#13;
<p class="listing1" id="ch05list10"><em>Listing 5-10: Instructions checking the value of</em> <span class="codeitalic">GUESSME</span></p>&#13;
<p class="programs">   $ <span class="codestrong1">objdump   -d ctf</span><br/>   ...<br/><span class="ent">➊</span>   400dc0: 0f b6 14 03         movzx      edx,BYTE PTR [rbx+rax*1]<br/>     400dc4: 84 d2               test       dl,dl<br/><span class="ent">➋</span>   400dc6: 74 05               je         400dcd &lt;_Unwind_Resume@plt+0x22d&gt;<br/><span class="ent">➌</span>   400dc8: 3a 14 01            cmp        dl,BYTE PTR [rcx+rax*1]<br/>     400dcb: 74 13               je         400de0 &lt;_Unwind_Resume@plt+0x240&gt;<br/><span class="ent">➍</span>   400dcd: bf af 11 40 00      mov        edi,0x4011af<br/><span class="ent">➎</span>   400dd2: e8 d9 fc ff ff      call       400ab0 &lt;puts@plt&gt;<br/>     400dd7: e9 84 fe ff ff      jmp        400c60 &lt;_Unwind_Resume@plt+0xc0&gt;<br/>     400ddc: 0f 1f 40 00         nop        DWORD PTR [rax+0x0]<br/><span class="ent">➏</span>   400de0: 48 83 c0 01         add        rax,0x1<br/><span class="ent">➐</span>   400de4: 48 83 f8 15         cmp        rax,0x15<br/><span class="ent">➑</span>   400de8: 75 d6               jne        400dc0 &lt;_Unwind_Resume@plt+0x220&gt;<br/>    ...</p>&#13;
<p class="indent">The <span class="literal">guess again</span> string is loaded by the instruction at <span class="literal">0x400dcd</span> <span class="ent">➍</span> and is then printed using <span class="literal">puts</span> <span class="ent">➎</span>. This is the failure case; let’s work our way backward from here.</p>&#13;
<p class="indent">The failure case is reached from a loop that starts at address <span class="literal">0x400dc0</span>. In each iteration of the loop, it loads a byte from an array (probably a string) into <span class="literal">edx</span> <span class="ent">➊</span>. The <span class="literal">rbx</span> register points to the base of this array, while <span class="literal">rax</span> indexes it. If the loaded byte turns out to be <span class="literal">NULL</span>, then the <span class="literal">je</span> instruction at <span class="literal">0x400dc6</span> jumps to the failure case <span class="ent">➋</span>. This comparison to <span class="literal">NULL</span> is a check for the end of the string. If the end of the string is reached here, then it’s too short to be a match. If the byte is not <span class="literal">NULL</span>, the <span class="literal">je</span> falls through to the next instruction, at address <span class="literal">0x400dc8</span>, which compares the byte in <span class="literal">edx</span> against a byte in another string, based at <span class="literal">rcx</span> and indexed by <span class="literal">rax</span> <span class="ent">➌</span>.</p>&#13;
<p class="indent">If the two compared bytes match up, then the program jumps to address <span class="literal">0x400de0</span>, where it increases the string index <span class="ent">➏</span>, and checks whether the string index is equal to <span class="literal">0x15</span>, the length of the string <span class="ent">➐</span>. If it is, then the string comparison is complete; if not, the program jumps into another iteration of the loop <span class="ent">➑</span>.</p>&#13;
<p class="indent">From this analysis, you now know that the string based at the <span class="literal">rcx</span> register is used as a ground truth. The program compares the environment string taken from the <span class="literal">GUESSME</span> variable against this ground truth. This means that if you can dump the ground truth string, you can find the expected value for <span class="literal">GUESSME</span>! Because the string is decrypted at runtime and isn’t available statically, you’ll need to use dynamic analysis to recover it instead of using <span class="literal">objdump</span>.</p>&#13;
<h3 class="h3" id="ch05_9"><span epub:type="pagebreak" id="page_111"/>5.9 Dumping a Dynamic String Buffer Using gdb</h3>&#13;
<p class="noindent">Probably the most used dynamic analysis tool on GNU/Linux is <span class="literal">gdb</span>, or the GNU Debugger. As the name suggests, <span class="literal">gdb</span> is mainly for debugging, but it can be used for a variety of dynamic analysis purposes. In fact, it’s an extremely versatile tool, and there’s no way to cover all of its functionality in this chapter. However, I’ll go over some of the most-used features of <span class="literal">gdb</span> you can use to recover the expected value of <span class="literal">GUESSME</span>. The best place to look up information on <span class="literal">gdb</span> is not the man page but <em><a href="http://www.gnu.org/software/gdb/documentation/">http://www.gnu.org/software/gdb/documentation/</a></em>, where you’ll find an extensive manual covering all the supported <span class="literal">gdb</span> commands.</p>&#13;
<p class="indent">Like <span class="literal">strace</span> and <span class="literal">ltrace</span>, <span class="literal">gdb</span> has the ability to attach to a running process. However, because <em>ctf</em> is not a long-running process, you can simply run it with <span class="literal">gdb</span> from the start. Because <span class="literal">gdb</span> is an interactive tool, when you start a binary under <span class="literal">gdb</span>, it’s not immediately executed. After printing a startup message with some usage instructions, <span class="literal">gdb</span> pauses and waits for a command. You can tell that <span class="literal">gdb</span> is waiting for a command by the command prompt: <span class="literal">(gdb)</span>.</p>&#13;
<p class="indent"><a href="ch05.xhtml#ch05list11">Listing 5-11</a> shows the sequence of <span class="literal">gdb</span> commands needed to find the expected value of the <span class="literal">GUESSME</span> environment variable. I’ll explain each of these commands as I discuss the listing.</p>&#13;
<p class="listing1" id="ch05list11"><em>Listing 5-11: Finding the expected value of</em> <span class="codeitalic">GUESSME</span> <em>using</em> <span class="codeitalic">gdb</span></p>&#13;
<p class="programs">   $ <span class="codestrong1">gdb ./ctf</span><br/>   GNU gdb (Ubuntu 7.11.1-0ubuntu1~16.04) 7.11.1<br/>   Copyright (C) 2016 Free Software Foundation, Inc.<br/>   License GPLv3+: GNU GPL version 3 or later &lt;http://gnu.org/licenses/gpl.html&gt;<br/>   This is free software: you are free to change and redistribute it.<br/>   There is NO WARRANTY, to the extent permitted by law. Type "show copying"<br/>   and "show warranty" for details.<br/>   This GDB was configured as "x86_64-linux-gnu".<br/>   Type "show configuration" for configuration details.<br/>   For bug reporting instructions, please see:<br/>   &lt;http://www.gnu.org/software/gdb/bugs/&gt;.<br/>   Find the GDB manual and other documentation resources online at:<br/>   &lt;http://www.gnu.org/software/gdb/documentation/&gt;.<br/>   For help, type "help".<br/>   Type "apropos word" to search for commands related to "word"...<br/>   Reading symbols from ./ctf...(no debugging symbols found)...done.<br/><span class="ent">➊</span> (gdb) <span class="codestrong1">b *0x400dc8</span><br/>   Breakpoint 1 at 0x400dc8<br/><span class="ent">➋</span> (gdb) <span class="codestrong1">set env GUESSME=foobar</span><br/><span class="ent">➌</span> (gdb) <span class="codestrong1">run show_me_the_flag</span><br/>   Starting program: /home/binary/code/chapter3/ctf show_me_the_flag<br/>   checking 'show_me_the_flag'<br/>   ok<br/><span epub:type="pagebreak" id="page_112"/>&#13;
<span class="ent">➍</span> Breakpoint 1, 0x0000000000400dc8 in ?? ()<br/><span class="ent">➎</span> (gdb) <span class="codestrong1">display/i $pc</span><br/>   1: x/i $pc<br/>   =&gt; 0x400dc8:    cmp    (%rcx,%rax,1),%dl<br/><span class="ent">➏</span> (gdb) <span class="codestrong1">info registers rcx</span><br/>   rcx            0x615050 6377552<br/><span class="ent">➐</span> (gdb) <span class="codestrong1">info registers rax</span><br/>   rax            0x0      0<br/><span class="ent">➑</span> (gdb) <span class="codestrong1">x/s 0x615050</span><br/>   0x615050:       "Crackers Don't Matter"<br/><span class="ent">➒</span> (gdb) <span class="codestrong1">quit</span></p>&#13;
<p class="indent">One of the most basic functions of any debugger is setting a <em>breakpoint</em>, which is simply an address or a function name at which the debugger will “break” execution. Whenever the debugger reaches a breakpoint, it pauses execution and returns control to the user, waiting for a command. To dump the “magic” string against which the <span class="literal">GUESSME</span> environment variable is compared, you set a breakpoint at address <span class="literal">0x400dc8</span> <span class="ent">➊</span> where the comparison happens. In <span class="literal">gdb</span>, the command for setting a breakpoint at an address is <span class="literal">b</span> <em>*address</em> (<span class="literal">b</span> is a short version of the command <span class="literal">break</span>). If symbols are available (they aren’t in this case), you can set a breakpoint at the entry point of a function using the function’s name. For instance, to set a breakpoint at the start of <span class="literal">main</span>, you would use the command <span class="literal">b main</span>.</p>&#13;
<p class="indent">After setting the breakpoint, you need to do one more thing before you can start the execution of <em>ctf</em> . You still need to set a value for the <span class="literal">GUESSME</span> environment variable to prevent <em>ctf</em> from exiting prematurely. In <span class="literal">gdb</span>, you can set the <span class="literal">GUESSME</span> environment variable using the command <span class="literal">set env GUESSME=foobar</span> <span class="ent">➋</span>. Now, you can begin the execution of <em>ctf</em> by issuing the command <span class="literal">run show_me_the_flag</span> <span class="ent">➌</span>. As you can see, you can pass arguments to the <span class="literal">run</span> command, which it then automatically passes on to the binary you’re analyzing (in this case, <em>ctf</em> ). Now, <em>ctf</em> begins executing normally, and it should continue doing so until it hits your breakpoint.</p>&#13;
<p class="indent">When <em>ctf</em> hits the breakpoint, <span class="literal">gdb</span> halts the execution of <em>ctf</em> and returns control to you, informing you that a breakpoint was hit <span class="ent">➍</span>. At this point, you can use the <span class="literal">display/i $pc</span> command to display the instruction at the current program counter (<span class="literal">$pc</span>), just to make sure you’re at the expected instruction <span class="ent">➎</span>. As expected, <span class="literal">gdb</span> informs you that the next instruction to be executed is <span class="literal">cmp (%rcx,%rax,1),%dl</span>, which is indeed the comparison instruction you’re interested in (in AT&amp;T format).</p>&#13;
<p class="indent">Now that you’ve reached the point in <em>ctf</em> ’s execution where <span class="literal">GUESSME</span> is compared against the expected string, you need to find out the base address of the string so that you can dump it. To view the base address contained in the <span class="literal">rcx</span> register, use the command <span class="literal">info registers rcx</span><span class="ent">➏</span>. You can also view the contents of <span class="literal">rax</span>, just to ensure that the loop counter is zero, as expected <span class="ent">➐</span>. It’s also possible to use the command <span class="literal">info registers</span> without specifying any register name. In that case, <span class="literal">gdb</span> will show the contents of all general-purpose registers.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_113"/>You now know the base address of the string you want to dump; it starts at address <span class="literal">0x615050</span>. The only thing left to do is to dump the string at that address. The command to dump memory in <span class="literal">gdb</span> is <span class="literal">x</span>, which is capable of dumping memory in many granularities and encodings. For instance, <span class="literal">x/d</span> dumps a single byte in decimal representation, <span class="literal">x/x</span> dumps a byte in hexadecimal representation, and <span class="literal">x/4xw</span> dumps four hexadecimal words (which are 4-byte integers). In this case, the most useful version of the command is <span class="literal">x/s</span>, which dumps a C-style string, continuing until it encounters a <span class="literal">NULL</span> byte. When you issue the command <span class="literal">x/s 0x615050</span> to dump the string you’re interested in <span class="ent">➑</span>, you can see that the expected value of <span class="literal">GUESSME</span> is <span class="literal">Crackers Don't Matter</span>. Let’s exit <span class="literal">gdb</span> using the <span class="literal">quit</span> command <span class="ent">➒</span> to try it!</p>&#13;
<p class="programs">$ <span class="codestrong1">GUESSME="Crackers Don't Matter" ./ctf show_me_the_flag</span><br/>checking 'show_me_the_flag'<br/>ok<br/>flag = 84b34c124b2ba5ca224af8e33b077e9e</p>&#13;
<p class="indent">As this listing shows, you’ve finally completed all the necessary steps to coax <em>ctf</em> into giving you the secret flag! On the VM in the directory for this chapter, you’ll find a program called <em>oracle</em>. Go ahead and feed the flag to <em>oracle</em>, like this: <span class="literal">./oracle 84b34c124b2ba5ca224af8e33b077e9e</span>. You’ve now unlocked the next challenge, which you can complete on your own using your new skills.</p>&#13;
<h3 class="h3" id="ch05_10">5.10 Summary</h3>&#13;
<p class="noindent">In this chapter, I introduced you to all the essential Linux binary analysis tools you need to be an effective binary analyst. While most of these tools are simple enough, you can combine them to implement powerful binary analyses in no time! In the next chapter, you’ll explore some of the major disassembly tools and other, more advanced analysis techniques.</p>&#13;
<div class="box">&#13;
<p class="headbox" id="ch05_11">Exercise</p>&#13;
<p class="boxhead1">1. A New CTF Challenge</p>&#13;
<p class="noindent">Complete the new CTF challenge unlocked by the <em>oracle</em> program! You can complete the entire challenge using only the tools discussed in this chapter and what you learned in <a href="ch02.xhtml#ch02">Chapter 2</a>. After completing the challenge, don’t forget to give the flag you found to the oracle to unlock the next challenge.<span epub:type="pagebreak" id="page_114"/></p>&#13;
</div>&#13;
</div></body></html>