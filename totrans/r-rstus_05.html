<html><head></head><body>
<div id="sbo-rt-content" class="calibre1"><section aria-labelledby="ch4" epub:type="chapter" role="doc-chapter">
<hgroup>
<h2 class="title" id="ch4">
<span class="tpt"><span aria-label=" Page 61. " epub:type="pagebreak" id="pg_61" role="doc-pagebreak" class="calibre2"/><span class="sans_dogma_ot_bold_b_">4</span></span>
<span class="ct"><span class="sans_dogma_ot_bold_b_">MAPS AND GEOSPATIAL DATA</span></span>
</h2>
</hgroup>
<figure class="opener"><img alt="" class="opener1" height="407" src="../images/chapter.jpg" width="407"/>
</figure>
<p class="cos">When I first started learning R, I considered it a tool for working with numbers, not shapes, so I was surprised when I saw people using it to make maps. For example, developer Abdoul Madjid used R to make a map that visualizes rates of COVID-19 in the United States in 2021.</p>
<p class="tx">You might think you need specialized mapmaking software like ArcGIS to make maps, but it’s an expensive tool. And while Excel has added support for mapmaking in recent years, its features are limited (for example, you can’t use it to make maps based on street addresses). Even QGIS, an open source tool similar to ArcGIS, still requires learning new skills.</p>
<p class="tx">Using R for mapmaking is more flexible than using Excel, less expensive than using ArcGIS, and based on syntax you already know. It also lets you perform all of your data manipulation tasks with one tool and apply the principles of high-quality data visualization discussed in <span class="xref"><a href="chapter2.xhtml" class="calibre3">Chapter 2</a></span>. In this chapter, you’ll work with simple features of geospatial data and examine Madjid’s code to understand how he created this map. You’ll also learn where to find geospatial data and how to use it to make your own maps.</p>
<section aria-labelledby="sec1" epub:type="division">
<h3 class="h1" id="sec1"><span id="h1-26"/><span aria-label=" Page 62. " epub:type="pagebreak" id="pg_62" role="doc-pagebreak"/><span class="sans_dogma_ot_bold_b_1">A Brief Primer on Geospatial Data</span></h3>
<p class="tni">You don’t need to be a GIS expert to make maps, but you do need to understand a few things about how geospatial data works, starting with its two main types: vector and raster. <i class="calibre4">Vector</i> data uses points, lines, and polygons to represent the world. <i class="calibre4">Raster</i> data, which often comes from digital photographs, ties each pixel in an image to a specific geographic location. Vector data tends to be easier to work with, and you’ll be using it exclusively in this chapter.</p>
<p class="tx">In the past, working with geospatial data meant mastering competing standards, each of which required learning a different approach. Today, though, most people use the <i class="calibre4">simple features</i> model (often abbreviated as <i class="calibre4">sf</i>) for working with vector geospatial data, which is easier to understand. For example, to import simple features data about the state of Wyoming, enter the following:</p>
<pre id="pre-62" class="calibre10"><code class="calibre11"><b class="calibre9">library(sf)</b>

<b class="calibre9">wyoming &lt;- read_sf("https://data.rfortherestofus.com/wyoming.geojson")</b>
</code></pre>
<p class="tx">And then you can look at the data like so:</p>
<pre id="pre-63" class="calibre10"><code class="calibre11">&gt; <b class="calibre9">wyoming</b>
#&gt; Simple feature collection with 1 feature and 1 field
#&gt; Geometry type: POLYGON
#&gt; Dimension:     XY
#&gt; Bounding box:  xmin: -111.0546 ymin: 40.99477 xmax: -104.0522 ymax: 45.00582
#&gt; Geodetic CRS:  WGS 84
#&gt;   NAME    geometry
#&gt; 1 Wyoming POLYGON ((-111.0449 43.3157...
</code></pre>
<p class="tx">The output has two columns, one for the state name (<span class="sans_thesansmonocd_w5regular_">NAME</span>) and another called <span class="sans_thesansmonocd_w5regular_">geometry</span>. This data looks like the data frames you’ve seen before, aside from two major differences.</p>
<p class="tx">First, there are five lines of metadata above the data frame. At the top is a line stating that the data contains one feature and one field. A <i class="calibre4">feature</i> is a row of data, and a <i class="calibre4">field</i> is any column containing nonspatial data. Second, the simple features data contains geographical data in a variable called <span class="sans_thesansmonocd_w5regular_">geometry</span>. Because the <span class="sans_thesansmonocd_w5regular_">geometry</span> column must be present for a data frame to be geospatial data, it isn’t counted as a field. Let’s look at each part of this simple features data.</p>
<section aria-labelledby="sec2" epub:type="division">
<h4 class="h2" id="sec2"><span id="h2-28"/><span class="sans_futura_std_heavy_oblique_bi_">The Geometry Type</span></h4>
<p class="tni">The <i class="calibre4">geometry type</i> represents the shape of the geospatial data you’re working with and is typically shown in all caps. In this case, the relatively simple <span class="sans_thesansmonocd_w5regular_">POLYGON</span> type represents a single polygon. You can use ggplot to display this data by calling <span class="sans_thesansmonocd_w5regular_">geom_sf()</span>, a special geom designed to work with simple features data:</p>
<pre id="pre-64" class="calibre10"><code class="calibre11"><span aria-label=" Page 63. " epub:type="pagebreak" id="pg_63" role="doc-pagebreak"/>library(tidyverse)

wyoming %&gt;%
  ggplot() +
  <b class="calibre9">geom_sf()</b>
</code></pre>
<p class="tx"><a href="chapter4.xhtml#fig4-1" class="calibre3">Figure 4-1</a> shows the resulting map of Wyoming. It may not look like much, but I wasn’t the one who made Wyoming a nearly perfect rectangle!</p>
<figure class="img"><img alt="" class="img2" height="662" id="fig4-1" src="../images/fig4-1.jpg" width="888"/>
<figcaption><p class="cap"><span class="sans_futura_std_book_oblique_i_">Figure 4-1: A map of Wyoming generated using POLYGON simple features data</span></p></figcaption>
</figure>
<p class="tx">Other geometry types used in simple features data include <span class="sans_thesansmonocd_w5regular_">POINT</span>, to display elements such as a pin on a map that represents a single location. For example, the map in <a href="chapter4.xhtml#fig4-2" class="calibre3">Figure 4-2</a> uses <span class="sans_thesansmonocd_w5regular_">POINT</span> data to show a single electric vehicle charging station in Wyoming.</p>
<figure class="img"><img alt="" class="img2" height="667" id="fig4-2" src="../images/fig4-2.jpg" width="888"/>
<figcaption><p class="cap"><span class="sans_futura_std_book_oblique_i_">Figure 4-2: A map of Wyoming containing POINT simple features data</span></p></figcaption>
</figure>
<p class="tx"><span aria-label=" Page 64. " epub:type="pagebreak" id="pg_64" role="doc-pagebreak"/>The <span class="sans_thesansmonocd_w5regular_">LINESTRING</span> geometry type is for a set of points that can be connected with lines and is often used to represent roads. <a href="chapter4.xhtml#fig4-3" class="calibre3">Figure 4-3</a> shows a map that uses <span class="sans_thesansmonocd_w5regular_">LINESTRING</span> data to represent a section of US Highway 30 that runs through Wyoming.</p>
<figure class="img"><img alt="" class="img2" height="662" id="fig4-3" src="../images/fig4-3.jpg" width="888"/>
<figcaption><p class="cap"><span class="sans_futura_std_book_oblique_i_">Figure 4-3: A road represented using LINESTRING simple features data</span></p></figcaption>
</figure>
<p class="tx">Each of these geometry types has a <span class="sans_thesansmonocd_w5regular_">MULTI</span> variation (<span class="sans_thesansmonocd_w5regular_">MULTIPOINT</span>, <span class="sans_thesansmonocd_w5regular_">MULTI LINESTRING</span>, and <span class="sans_thesansmonocd_w5regular_">MULTIPOLYGON</span>) that combines multiple instances of the type in one row of data. For example, <a href="chapter4.xhtml#fig4-4" class="calibre3">Figure 4-4</a> uses <span class="sans_thesansmonocd_w5regular_">MULTIPOINT</span> data to show all electric vehicle charging stations in Wyoming.</p>
<figure class="img"><img alt="" class="img2" height="664" id="fig4-4" src="../images/fig4-4.jpg" width="888"/>
<figcaption><p class="cap"><span class="sans_futura_std_book_oblique_i_">Figure 4-4: Using MULTIPOINT data to represent multiple electric vehicle charging stations</span></p></figcaption>
</figure>
<p class="tx"><span aria-label=" Page 65. " epub:type="pagebreak" id="pg_65" role="doc-pagebreak"/>Likewise, you can use <span class="sans_thesansmonocd_w5regular_">MULTILINESTRING</span> data to show not just one road but all major roads in Wyoming (<a href="chapter4.xhtml#fig4-5" class="calibre3">Figure 4-5</a>).</p>
<figure class="img"><img alt="" class="img2" height="668" id="fig4-5" src="../images/fig4-5.jpg" width="888"/>
<figcaption><p class="cap"><span class="sans_futura_std_book_oblique_i_">Figure 4-5: Using MULTILINESTRING data to represent several roads</span></p></figcaption>
</figure>
<p class="tx">Finally, you could use <span class="sans_thesansmonocd_w5regular_">MULTIPOLYGON</span> data, for example, to depict a state made up of multiple polygons. The following data represents the 23 counties in the state of Wyoming:</p>
<pre id="pre-65" class="calibre10"><code class="calibre11">#&gt; Simple feature collection with 23 features and 1 field
#&gt; Geometry type: MULTIPOLYGON
#&gt; Dimension:     XY
#&gt; Bounding box:  xmin: -111.0546 ymin: 40.99477 xmax: -104.0522 ymax: 45.00582
#&gt; Geodetic CRS:  WGS 84
#&gt; First 10 features:
#&gt;          NAME        geometry
#&gt; 34       Lincoln     MULTIPOLYGON (((-111.0472 4...
#&gt; 104      Fremont     MULTIPOLYGON (((-109.4582 4...
#&gt; 121      Uinta       MULTIPOLYGON (((-110.6068 4...
#&gt; 527      Big Horn    MULTIPOLYGON (((-108.5923 4...
#&gt; 551      Hot Springs MULTIPOLYGON (((-109.1714 4...
#&gt; 601      Washakie    MULTIPOLYGON (((-107.6335 4...
#&gt; 769      Converse    MULTIPOLYGON (((-105.6985 4...
#&gt; 970      Sweetwater  MULTIPOLYGON (((-110.0489 4...
#&gt; 977      Crook       MULTIPOLYGON (((-105.0856 4...
#&gt; 1097     Carbon      MULTIPOLYGON (((-106.9129 4...
</code></pre>
<p class="tx">As you can see on the second line, the geometry type of this data is <span class="sans_thesansmonocd_w5regular_">MULTIPOLYGON</span>. In addition, the repeated <span class="sans_thesansmonocd_w5regular_">MULTIPOLYGON</span> text in the <span class="sans_thesansmonocd_w5regular_">geometry</span> column indicates that each row contains a shape of type <span class="sans_thesansmonocd_w5regular_">MULTIPOLYGON</span>. <a href="chapter4.xhtml#fig4-6" class="calibre3">Figure 4-6</a> shows a map made with this data.<span aria-label=" Page 66. " epub:type="pagebreak" id="pg_66" role="doc-pagebreak"/></p>
<figure class="img"><img alt="" class="img2" height="662" id="fig4-6" src="../images/fig4-6.jpg" width="875"/>
<figcaption><p class="cap"><span class="sans_futura_std_book_oblique_i_">Figure 4-6: A map of Wyoming counties</span></p></figcaption>
</figure>
<p class="tx">Notice that the map is made up entirely of polygons.</p>
</section>
<section aria-labelledby="sec3" epub:type="division">
<h4 class="h2" id="sec3"><span id="h2-29"/><span class="sans_futura_std_heavy_oblique_bi_">The Dimensions</span></h4>
<p class="tni">Next, the geospatial data frame contains the data’s <i class="calibre4">dimensions</i>, or the type of geospatial data you’re working with. In the Wyoming example, it looks like <span class="sans_thesansmonocd_w5regular_">Dimension: XY</span>, meaning the data is two-dimensional, as in the case of all the geospatial data used in this chapter. There are two other dimensions (<span class="sans_thesansmonocd_w5regular_">Z</span> and <span class="sans_thesansmonocd_w5regular_">M</span>) that you’ll see much more rarely. I’ll leave them for you to investigate further.</p>
</section>
<section aria-labelledby="sec4" epub:type="division">
<h4 class="h2" id="sec4"><span id="h2-30"/><span class="sans_futura_std_heavy_oblique_bi_">The Bounding Box</span></h4>
<p class="tni">The penultimate element in the metadata is the <i class="calibre4">bounding box</i>, which represents the smallest area in which you can fit all of your geospatial data. For the <span class="sans_thesansmonocd_w5regular_">wyoming</span> object, it looks like this:</p>
<pre id="pre-66" class="calibre10"><code class="calibre11">Bounding box:  xmin: -111.0569 ymin: 40.99475 xmax: -104.0522 ymax: 45.0059
</code></pre>
<p class="tx">The <span class="sans_thesansmonocd_w5regular_">ymin</span> value of <span class="sans_thesansmonocd_w5regular_">40.99475</span> and <span class="sans_thesansmonocd_w5regular_">ymax</span> value of <span class="sans_thesansmonocd_w5regular_">45.0059</span> represent the lowest and highest latitudes, respectively, that the state’s polygon can fit into. The x-values do the same for the longitude. Bounding boxes are calculated automatically, and typically you don’t have to worry about altering them.</p>
</section>
<section aria-labelledby="sec5" epub:type="division">
<h4 class="h2" id="sec5"><span id="h2-31"/><span class="sans_futura_std_heavy_oblique_bi_">The Coordinate Reference System</span></h4>
<p class="tni">The last piece of metadata specifies the <i class="calibre4">coordinate reference system</i> used to project the data when it’s plotted. The challenge with representing any geospatial data is that you’re displaying information about the three-dimensional Earth on a two-dimensional map. Doing so requires choosing a coordinate reference system that determines what type of correspondence, or <i class="calibre4">projection</i>, to use when making the map.</p>
<p class="tx"><span aria-label=" Page 67. " epub:type="pagebreak" id="pg_67" role="doc-pagebreak"/>The data for the Wyoming counties map includes the line <span class="sans_thesansmonocd_w5regular_">Geodetic CRS: WGS 84</span>, indicating the use of a coordinate reference system known as <i class="calibre4">WGS84</i>. To see a different projection, check out the same map using the <i class="calibre4">Albers equal-area conic convenience projection</i>. While Wyoming looked perfectly horizontal in <a href="chapter4.xhtml#fig4-6" class="calibre3">Figure 4-6</a>, the version in <a href="chapter4.xhtml#fig4-7" class="calibre3">Figure 4-7</a> appears to be tilted.</p>
<figure class="img"><img alt="" class="img2" height="697" id="fig4-7" src="../images/fig4-7.jpg" width="880"/>
<figcaption><p class="cap"><span class="sans_futura_std_book_oblique_i_">Figure 4-7: A map of Wyoming counties using the Albers equal-area conic convenience projection</span></p></figcaption>
</figure>
<p class="tx">If you’re wondering how to change projections when making maps of your own, fear not: you’ll see how to do this when we look at Madjid’s map in the next section. And if you want to know how to choose appropriate projections for your maps, check out <span class="xref">“Using Appropriate Projections” on <a href="#pg_81" class="calibre3">page 81</a></span>.</p>
</section>
<section aria-labelledby="sec6" epub:type="division">
<h4 class="h2" id="sec6"><span id="h2-32"/><span class="sans_futura_std_heavy_oblique_bi_">The geometry Column</span></h4>
<p class="tni">In addition to the metadata, simple features data differs from traditional data frames in another respect: its <span class="sans_thesansmonocd_w5regular_">geometry</span> column. As you might have guessed from the name, this column holds the data needed to draw the maps.</p>
<p class="tx">To understand how this works, consider the connect-the-dots drawings you probably completed as a kid. As you added lines to connect one point to the next, the subject of your drawing became clearer. The <span class="sans_thesansmonocd_w5regular_">geometry</span> column is similar. It has a set of numbers, each of which corresponds to a point. If you’re using <span class="sans_thesansmonocd_w5regular_">LINESTRING</span>/<span class="sans_thesansmonocd_w5regular_">MULTILINESTRING</span> or <span class="sans_thesansmonocd_w5regular_">POLYGON</span>/<span class="sans_thesansmonocd_w5regular_">MULTIPOLYGON</span> simple features data, ggplot uses the numbers in the <span class="sans_thesansmonocd_w5regular_">geometry</span> column to draw each point and then adds lines to connect the points. If you’re using <span class="sans_thesansmonocd_w5regular_">POINT</span>/<span class="sans_thesansmonocd_w5regular_">MULTIPOINT</span> data, it draws the points but doesn’t connect them.</p>
<p class="tx">Once again, thanks to R, you never have to worry about these details or look in any depth at the <span class="sans_thesansmonocd_w5regular_">geometry</span> column.</p>
</section>
</section>
<section aria-labelledby="sec7" epub:type="division">
<h3 class="h1" id="sec7"><span id="h1-27"/><span aria-label=" Page 68. " epub:type="pagebreak" id="pg_68" role="doc-pagebreak"/><span class="sans_dogma_ot_bold_b_1">Re-creating the COVID-19 Map</span></h3>
<p class="tni">Now that you understand the basics of geospatial data, let’s walk through the code Madjid used to make his COVID-19 map. Shown in <a href="chapter4.xhtml#fig4-8" class="calibre3">Figure 4-8</a>, it makes use of the geometry types, dimensions, bounding boxes, projections, and the <span class="sans_thesansmonocd_w5regular_">geometry</span> column just discussed.</p>
<figure class="img"><img alt="" class="img1" height="1285" id="fig4-8" src="../images/fig4-8.jpg" width="1285"/>
<figcaption><p class="cap"><span class="sans_futura_std_book_oblique_i_">Figure 4-8: Abdoul Madjid’s map of COVID-19 in the United States in 2021</span></p></figcaption>
</figure>
<p class="tx">I’ve made some small modifications to the code to make the final map fit on the page. You’ll begin by loading a few packages:</p>
<pre id="pre-67" class="calibre10"><code class="calibre11"><b class="calibre9">library(tidyverse)</b>
<b class="calibre9">library(albersusa)</b>
<b class="calibre9">library(sf)</b>
<b class="calibre9">library(zoo)</b>
<b class="calibre9">library(colorspace)</b>
</code></pre>
<p class="tx">The <span class="sans_thesansmonocd_w5regular_">albersusa</span> package will give you access to geospatial data. Install it as follows:</p>
<pre id="pre-68" class="calibre10"><code class="calibre11"><b class="calibre9">remotes::install_github("hrbrmstr/albersusa")</b>
</code></pre>
<p class="tx"><span aria-label=" Page 69. " epub:type="pagebreak" id="pg_69" role="doc-pagebreak"/>You can install all of the other packages using the standard <span class="sans_thesansmonocd_w5regular_">install .packages()</span> code. You’ll use the <span class="sans_thesansmonocd_w5regular_">tidyverse</span> to import data, manipulate it, and plot it with ggplot. The <span class="sans_thesansmonocd_w5regular_">sf</span> package will enable you to change the coordinate reference system and use an appropriate projection for the data. The <span class="sans_thesansmonocd_w5regular_">zoo</span> package has functions for calculating rolling averages, and the <span class="sans_thesansmonocd_w5regular_">colorspace</span> package gives you a color scale that highlights the data well.</p>
<section aria-labelledby="sec8" epub:type="division">
<h4 class="h2" id="sec8"><span id="h2-33"/><span class="sans_futura_std_heavy_oblique_bi_">Importing the Data</span></h4>
<p class="tni">Next, you’ll import the data you need: COVID-19 rates by state over time, state populations, and geospatial information. Madjid imported each of these pieces of data separately and then merged them, and you’ll do the same.</p>
<p class="tx">The COVID-19 data comes directly from the <i class="calibre4">New York Times</i>, which publishes daily case rates by state as a CSV file on its GitHub account. To import it, enter the following:</p>
<pre id="pre-69" class="calibre10"><code class="calibre11"><b class="calibre9">covid_data &lt;- read_csv("https://data.rfortherestofus.com/covid-us-states.csv") %&gt;%</b>
<b class="calibre9">  select(-fips)</b>
</code></pre>
<p class="tx">Federal Information Processing Standards (FIPS) are numeric codes used to represent states, but you’ll reference states by their names instead, so the line <span class="sans_thesansmonocd_w5regular_">select(-fips)</span> drops the <span class="sans_thesansmonocd_w5regular_">fips</span> variable.</p>
<p class="tx">Looking at this data, you can see the arrival of the first COVID-19 cases in the United States in January 2020:</p>
<pre id="pre-70" class="calibre10"><code class="calibre11">#&gt; # A tibble: 56,006 × 4
#&gt;    date       state      cases deaths
#&gt;    &lt;date&gt;     &lt;chr&gt;      &lt;dbl&gt;  &lt;dbl&gt;
#&gt;  1 2020-01-21 Washington     1      0
#&gt;  2 2020-01-22 Washington     1      0
#&gt;  3 2020-01-23 Washington     1      0
#&gt;  4 2020-01-24 Illinois       1      0
#&gt;  5 2020-01-24 Washington     1      0
#&gt;  6 2020-01-25 California     1      0
#&gt;  7 2020-01-25 Illinois       1      0
#&gt;  8 2020-01-25 Washington     1      0
#&gt;  9 2020-01-26 Arizona        1      0
#&gt; 10 2020-01-26 California     2      0
<var class="calibre14">--snip--</var>
</code></pre>
<p class="tx">Madjid’s map shows per capita rates (the rates per 100,000 people) rather than absolute rates (the rates without consideration for a state’s population). So, to re-create his maps, you also need to obtain data on each state’s population. Download this data as a CSV as follows:</p>
<pre id="pre-71" class="calibre10"><code class="calibre11"><b class="calibre9">usa_states &lt;- read_csv("https://data.rfortherestofus.com/population-by-state.csv") %&gt;%</b>
<b class="calibre9">  select(State, Pop)</b>
</code></pre>
<p class="tx"><span aria-label=" Page 70. " epub:type="pagebreak" id="pg_70" role="doc-pagebreak"/>This code imports the data, keeps the <span class="sans_thesansmonocd_w5regular_">State</span> and <span class="sans_thesansmonocd_w5regular_">Pop</span> (population) variables, and saves the data as an object called <span class="sans_thesansmonocd_w5regular_">usa_states</span>. Here’s what <span class="sans_thesansmonocd_w5regular_">usa_states</span> looks like:</p>
<pre id="pre-72" class="calibre10"><code class="calibre11">#&gt; # A tibble: 52 × 2
#&gt;    State          Pop
#&gt;    &lt;chr&gt;          &lt;dbl&gt;
#&gt;  1 California     39613493
#&gt;  2 Texas          29730311
#&gt;  3 Florida        21944577
#&gt;  4 New York       19299981
#&gt;  5 Pennsylvania   12804123
#&gt;  6 Illinois       12569321
#&gt;  7 Ohio           11714618
#&gt;  8 Georgia        10830007
#&gt;  9 North Carolina 10701022
#&gt; 10 Michigan        9992427
<var class="calibre14">--snip--</var>
</code></pre>
<p class="tx">Finally, import the geospatial data and save it as an object called <span class="sans_thesansmonocd_w5regular_">usa_states_geom</span> like so:</p>
<pre id="pre-73" class="calibre10"><code class="calibre11"><b class="calibre9">usa_states_geom &lt;- usa_sf() %&gt;%</b>
<b class="calibre9">  select(name) %&gt;%</b>
<b class="calibre9">  st_transform(us_laea_proj)</b>
</code></pre>
<p class="tx">The <span class="sans_thesansmonocd_w5regular_">usa_sf()</span> function from the <span class="sans_thesansmonocd_w5regular_">albersusa</span> package gives you simple features data for all US states. Conveniently, it places Alaska and Hawaii at a position and scale that make them easy to see. This data includes multiple variables, but because you need only the state names, this code keeps just the <span class="sans_thesansmonocd_w5regular_">name</span> variable.</p>
<p class="tx">The <span class="sans_thesansmonocd_w5regular_">st_transform()</span> function from the <span class="sans_thesansmonocd_w5regular_">sf</span> package changes the coordinate reference system. The one used here comes from the <span class="sans_thesansmonocd_w5regular_">us_laea_proj</span> object in the <span class="sans_thesansmonocd_w5regular_">albersusa</span> package. This is the Albers equal-area conic convenience projection you used earlier to change the appearance of the Wyoming counties map.</p>
</section>
<section aria-labelledby="sec9" epub:type="division">
<h4 class="h2" id="sec9"><span id="h2-34"/><span class="sans_futura_std_heavy_oblique_bi_">Calculating Daily COVID-19 Cases</span></h4>
<p class="tni">The <span class="sans_thesansmonocd_w5regular_">covid_data</span> data frame lists cumulative COVID-19 cases by state, but not the number of cases per day, so the next step is to calculate that number:</p>
<pre id="pre-74" class="calibre10"><code class="calibre11">covid_cases &lt;- covid_data %&gt;%
  group_by(state) %&gt;%
  mutate(
  <span aria-label="annotation1" class="code_codeannotation">❶</span> pd_cases = lag(cases)
  ) %&gt;%
<span aria-label="annotation2" class="code_codeannotation">❷</span> replace_na(list(pd_cases = 0)) %&gt;%
  mutate(
  <span aria-label="annotation3" class="code_codeannotation">❸</span> daily_cases = case_when(
      cases &gt; pd_cases ~ cases - pd_cases,
<span aria-label=" Page 71. " epub:type="pagebreak" id="pg_71" role="doc-pagebreak"/>      TRUE ~ 0
    )
) %&gt;%
<span aria-label="annotation4" class="code_codeannotation">❹</span> ungroup() %&gt;%
  arrange(state, date)
</code></pre>
<p class="tx">The <span class="sans_thesansmonocd_w5regular_">group_by()</span> function calculates totals for each state, then creates a new variable called <span class="sans_thesansmonocd_w5regular_">pd_cases</span>, which represents the number of cases in the previous day (the <span class="sans_thesansmonocd_w5regular_">lag()</span> function is used to assign data to this variable) <span aria-label="annotation1" class="codeannotation">❶</span>. Some days don’t have case counts for the previous day, so set this value to <span class="sans_thesansmonocd_w5regular_">0</span> using the <span class="sans_thesansmonocd_w5regular_">replace_na()</span> function <span aria-label="annotation2" class="codeannotation">❷</span>.</p>
<p class="tx">Next, this code creates a new variable called <span class="sans_thesansmonocd_w5regular_">daily_cases</span> <span aria-label="annotation3" class="codeannotation">❸</span>. To set the value of this variable, use the <span class="sans_thesansmonocd_w5regular_">case_when()</span> function to create a condition: if the <span class="sans_thesansmonocd_w5regular_">cases</span> variable (which holds the cases on that day) is greater than the <span class="sans_thesansmonocd_w5regular_">pd_cases</span> variable (which holds cases from one day prior), then <span class="sans_thesansmonocd_w5regular_">daily_cases</span> is equal to <span class="sans_thesansmonocd_w5regular_">cases</span> minus <span class="sans_thesansmonocd_w5regular_">pd_cases</span>. Otherwise, you set <span class="sans_thesansmonocd_w5regular_">daily_cases</span> to be equal to <span class="sans_thesansmonocd_w5regular_">0</span>.</p>
<p class="tx">Finally, because you grouped the data by state at the beginning of the code, now you need to remove this grouping using the <span class="sans_thesansmonocd_w5regular_">ungroup()</span> function before arranging the data by state and date <span aria-label="annotation4" class="codeannotation">❹</span>.</p>
<p class="tx">Here’s the resulting <span class="sans_thesansmonocd_w5regular_">covid_cases</span> data frame:</p>
<pre id="pre-75" class="calibre10"><code class="calibre11">#&gt; # A tibble: 56,006 × 6
#&gt;    date       state   cases deaths pd_cases daily_cases
#&gt;    &lt;date&gt;     &lt;chr&gt;   &lt;dbl&gt;  &lt;dbl&gt;    &lt;dbl&gt;       &lt;dbl&gt;
#&gt;  1 2020-03-13 Alabama     6      0        0           6
#&gt;  2 2020-03-14 Alabama    12      0        6           6
#&gt;  3 2020-03-15 Alabama    23      0       12          11
#&gt;  4 2020-03-16 Alabama    29      0       23           6
#&gt;  5 2020-03-17 Alabama    39      0       29          10
#&gt;  6 2020-03-18 Alabama    51      0       39          12
#&gt;  7 2020-03-19 Alabama    78      0       51          27
#&gt;  8 2020-03-20 Alabama   106      0       78          28
#&gt;  9 2020-03-21 Alabama   131      0      106          25
#&gt; 10 2020-03-22 Alabama   157      0      131          26
<var class="calibre14">--snip--</var>
</code></pre>
<p class="tx">In the next step, you’ll make use of the new <span class="sans_thesansmonocd_w5regular_">daily_cases</span> variable.</p>
</section>
<section aria-labelledby="sec10" epub:type="division">
<h4 class="h2" id="sec10"><span id="h2-35"/><span class="sans_futura_std_heavy_oblique_bi_">Calculating Incidence Rates</span></h4>
<p class="tni">You’re not quite done calculating values. The data that Madjid used to make his map didn’t include daily case counts. Instead, it contained a five-day rolling average of cases per 100,000 people. A <i class="calibre4">rolling average</i> is the average case rate in a certain time period. Quirks of reporting (for example, not reporting on weekends but instead rolling Saturday and Sunday cases into Monday) can make the value for any single day less reliable. Using a rolling average smooths out these quirks. Generate this data as follows:</p>
<pre id="pre-76" class="calibre10"><code class="calibre11"><b class="calibre9">covid_cases %&gt;%</b>
<b class="calibre9">  mutate(roll_cases = rollmean(</b>
<b class="calibre9">    daily_cases,</b>
<span aria-label=" Page 72. " epub:type="pagebreak" id="pg_72" role="doc-pagebreak"/><b class="calibre9">    k = 5,</b>
<b class="calibre9">    fill = NA</b>
<b class="calibre9">  ))</b>
</code></pre>
<p class="tx">This code creates a new data frame called <span class="sans_thesansmonocd_w5regular_">covid_cases_rm</span> (where <i class="calibre4">rm</i> stands for rolling mean). The first step in its creation is to use the <span class="sans_thesansmonocd_w5regular_">rollmean()</span> function from the <span class="sans_thesansmonocd_w5regular_">zoo</span> package to create a <span class="sans_thesansmonocd_w5regular_">roll_cases</span> variable, which holds the average number of cases in the five-day period surrounding a single date. The <span class="sans_thesansmonocd_w5regular_">k</span> argument is the number of days for which you want to calculate the rolling average (<span class="sans_thesansmonocd_w5regular_">5</span>, in this case), and the <span class="sans_thesansmonocd_w5regular_">fill</span> argument determines what happens in cases like the first day, where you can’t calculate a five-day rolling mean because there are no days prior to this day (Madjid set these values to <span class="sans_thesansmonocd_w5regular_">NA</span>).</p>
<p class="tx">After calculating <span class="sans_thesansmonocd_w5regular_">roll_cases</span>, you need to calculate per capita case rates. To do this, you need population data, so join the population data from the <span class="sans_thesansmonocd_w5regular_">usa_states</span> data frame with the <span class="sans_thesansmonocd_w5regular_">covid_cases</span> data like so:</p>
<pre id="pre-77" class="calibre10"><code class="calibre11"><b class="calibre9">covid_cases_rm &lt;- covid_cases %&gt;%</b>
  <b class="calibre9">mutate(roll_cases = rollmean(</b>
<b class="calibre9">    daily_cases,</b>
<b class="calibre9">    k = 5,</b>
<b class="calibre9">    fill = NA</b>
<b class="calibre9">    )</b>
<b class="calibre9">  ) %&gt;%</b>
<b class="calibre9">  left_join(usa_states,</b>
<b class="calibre9">            by = c("state" = "State")) %&gt;%</b>
<b class="calibre9">  drop_na(Pop)</b>
</code></pre>
<p class="tx">To drop rows with missing population data, you call the <span class="sans_thesansmonocd_w5regular_">drop_na()</span> function with the <span class="sans_thesansmonocd_w5regular_">Pop</span> variable as an argument. In practice, this removes several US territories (American Samoa, Guam, the Northern Mariana Islands, and the Virgin Islands).</p>
<p class="tx">Next, you create a per capita case rate variable called <span class="sans_thesansmonocd_w5regular_">incidence_rate</span> by multiplying the <span class="sans_thesansmonocd_w5regular_">roll_cases</span> variable by 100,000 and then dividing it by the population of each state:</p>
<pre id="pre-78" class="calibre10"><code class="calibre11"><b class="calibre9">covid_cases_rm &lt;- covid_cases_rm %&gt;%</b>
  <b class="calibre9">mutate(incidence_rate = 10^5 * roll_cases / Pop) %&gt;%</b>
<b class="calibre9">  mutate(</b>
<b class="calibre9">    incidence_rate = cut(</b>
<b class="calibre9">      incidence_rate,</b>
<b class="calibre9">      breaks = c(seq(0, 50, 5), Inf),</b>
<b class="calibre9">      include.lowest = TRUE</b>
<b class="calibre9">    ) %&gt;%</b>
<b class="calibre9">      factor(labels = paste0("&gt;", seq(0, 50, 5)))</b>
<b class="calibre9">  )</b>
</code></pre>
<p class="tx">Rather than keeping raw values (for example, on June 29, 2021, Florida had a rate of 57.77737 cases per 100,000 people), you use the <span class="sans_thesansmonocd_w5regular_">cut()</span> function to convert the values into categories: values of <span class="sans_thesansmonocd_w5regular_">&gt;0</span> (greater than zero), values of <span class="sans_thesansmonocd_w5regular_">&gt;5</span> (greater than five), and values of <span class="sans_thesansmonocd_w5regular_">&gt;50</span> (greater than 50).</p>
<p class="tx"><span aria-label=" Page 73. " epub:type="pagebreak" id="pg_73" role="doc-pagebreak"/>The last step is to filter the data so it includes only 2021 data (the only year depicted in Madjid’s map) and then select just the variables (<span class="sans_thesansmonocd_w5regular_">state</span>, <span class="sans_thesansmonocd_w5regular_">date</span>, and <span class="sans_thesansmonocd_w5regular_">incidence_rate</span>) you’ll need to create the map:</p>
<pre id="pre-79" class="calibre10"><code class="calibre11"><b class="calibre9">covid_cases_rm %&gt;%</b>
<b class="calibre9">  filter(date &gt;= as.Date("2021-01-01")) %&gt;%</b>
<b class="calibre9">  select(state, date, incidence_rate)</b>
</code></pre>
<p class="tx">Here’s the final <span class="sans_thesansmonocd_w5regular_">covid_cases_rm</span> data frame:</p>
<pre id="pre-80" class="calibre10"><code class="calibre11">#&gt; # A tibble: 18,980 × 3
#&gt;    state   date       incidence_rate
#&gt;    &lt;chr&gt;   &lt;date&gt;     &lt;fct&gt;
#&gt;  1 Alabama 2021-01-01 &gt;50
#&gt;  2 Alabama 2021-01-02 &gt;50
#&gt;  3 Alabama 2021-01-03 &gt;50
#&gt;  4 Alabama 2021-01-04 &gt;50
#&gt;  5 Alabama 2021-01-05 &gt;50
#&gt;  6 Alabama 2021-01-06 &gt;50
#&gt;  7 Alabama 2021-01-07 &gt;50
#&gt;  8 Alabama 2021-01-08 &gt;50
#&gt;  9 Alabama 2021-01-09 &gt;50
#&gt; 10 Alabama 2021-01-10 &gt;50
<var class="calibre14">--snip--</var>
</code></pre>
<p class="tx">You now have a data frame that you can combine with your geospatial data.</p>
</section>
<section aria-labelledby="sec11" epub:type="division">
<h4 class="h2" id="sec11"><span id="h2-36"/><span class="sans_futura_std_heavy_oblique_bi_">Adding Geospatial Data</span></h4>
<p class="tni">You’ve used two of the three data sources (COVID-19 case data and state population data) to create the <span class="sans_thesansmonocd_w5regular_">covid_cases_rm</span> data frame you’ll need to make the map. Now it’s time to use the third data source: the geospatial data you saved as <span class="sans_thesansmonocd_w5regular_">usa_states_geom</span>. Simple features data allows you to merge regular data frames and geospatial data (another point in its favor):</p>
<pre id="pre-81" class="calibre10"><code class="calibre11"><b class="calibre9">usa_states_geom %&gt;%</b>
<b class="calibre9">  left_join(covid_cases_rm, by = c("name" = "state"))</b>
</code></pre>
<p class="tx">This code merges the <span class="sans_thesansmonocd_w5regular_">covid_cases_rm</span> data frame into the geospatial data, matching the <span class="sans_thesansmonocd_w5regular_">name</span> variable from <span class="sans_thesansmonocd_w5regular_">usa_states_geom</span> to the <span class="sans_thesansmonocd_w5regular_">state</span> variable in <span class="sans_thesansmonocd_w5regular_">covid_cases_rm</span>.</p>
<p class="tx">Next, you create a new variable called <span class="sans_thesansmonocd_w5regular_">fancy_date</span> to format the date nicely (for example, Jan. 01 instead of 2021-01-01):</p>
<pre id="pre-82" class="calibre10"><code class="calibre11"><b class="calibre9">usa_states_geom_covid &lt;- usa_states_geom %&gt;%</b>
  left_join(covid_cases_rm, by = c("name" = "state")) %&gt;%
  <b class="calibre9">mutate(fancy_date = fct_inorder(format(date, "%b. %d"))) %&gt;%</b>
<b class="calibre9">  relocate(fancy_date, .before = incidence_rate)</b>
</code></pre>
<p class="tx"><span aria-label=" Page 74. " epub:type="pagebreak" id="pg_74" role="doc-pagebreak"/>The <span class="sans_thesansmonocd_w5regular_">format()</span> function does the formatting, while the <span class="sans_thesansmonocd_w5regular_">fct_inorder()</span> function makes the <span class="sans_thesansmonocd_w5regular_">fancy_date</span> variable sort data by date (rather than, say, alphabetically, which would put August before January). Last, the <span class="sans_thesansmonocd_w5regular_">relocate()</span> function puts the <span class="sans_thesansmonocd_w5regular_">fancy_date</span> column next to the <span class="sans_thesansmonocd_w5regular_">date</span> column.</p>
<p class="tx">Save this data frame as <span class="sans_thesansmonocd_w5regular_">usa_states_geom_covid</span> and take a look at the result:</p>
<pre id="pre-83" class="calibre10"><code class="calibre11">#&gt; Simple feature collection with 18615 features and 4 fields
#&gt; Geometry type: MULTIPOLYGON
#&gt; Dimension:     XY
#&gt; Bounding box:  xmin: -2100000 ymin: -2500000 xmax: 2516374 ymax: 732103.3
#&gt; CRS:           +proj=laea +lat_0=45 +lon_0=-100 +x_0=0 +y_0=0 +a=6370997
+b=6370997 +units=m +no_defs
#&gt; First 10 features:
#&gt;    name    date        fancy_date incidence_rate
#&gt; 1  Arizona 2021-01-01  Jan. 01    &gt;50
#&gt; 2  Arizona 2021-01-02  Jan. 02    &gt;50
#&gt; 3  Arizona 2021-01-03  Jan. 03    &gt;50
#&gt; 4  Arizona 2021-01-04  Jan. 04    &gt;50
#&gt; 5  Arizona 2021-01-05  Jan. 05    &gt;50
#&gt; 6  Arizona 2021-01-06  Jan. 06    &gt;50
#&gt; 7  Arizona 2021-01-07  Jan. 07    &gt;50
#&gt; 8  Arizona 2021-01-08  Jan. 08    &gt;50
#&gt; 9  Arizona 2021-01-09  Jan. 09    &gt;50
#&gt; 10 Arizona 2021-01-10  Jan. 10    &gt;50
#&gt;    geometry
#&gt; 1  MULTIPOLYGON (((-1111066 -8...
#&gt; 2  MULTIPOLYGON (((-1111066 -8...
#&gt; 3  MULTIPOLYGON (((-1111066 -8...
#&gt; 4  MULTIPOLYGON (((-1111066 -8...
#&gt; 5  MULTIPOLYGON (((-1111066 -8...
#&gt; 6  MULTIPOLYGON (((-1111066 -8...
#&gt; 7  MULTIPOLYGON (((-1111066 -8...
#&gt; 8  MULTIPOLYGON (((-1111066 -8...
#&gt; 9  MULTIPOLYGON (((-1111066 -8...
#&gt; 10 MULTIPOLYGON (((-1111066 -8...
</code></pre>
<p class="tx">You can see the metadata and <span class="sans_thesansmonocd_w5regular_">geometry</span> columns discussed earlier in the chapter.</p>
</section>
<section aria-labelledby="sec12" epub:type="division">
<h4 class="h2" id="sec12"><span id="h2-37"/><span class="sans_futura_std_heavy_oblique_bi_">Making the Map</span></h4>
<p class="tni">It took a lot of work to end up with the surprisingly simple <span class="sans_thesansmonocd_w5regular_">usa_states_geom_covid</span> data frame. While the data may be simple, the code Madjid used to make his map is quite complex. This section walks you through it in pieces.</p>
<p class="tx">The final map is actually multiple maps, one for each day in 2021. Combining 365 days makes for a large final product, so instead of showing the code for every single day, filter the <span class="sans_thesansmonocd_w5regular_">usa_states_geom_covid</span> to show just the first six days in January:</p>
<pre id="pre-84" class="calibre10"><code class="calibre11"><b class="calibre9">usa_states_geom_covid_six_days &lt;- usa_states_geom_covid %&gt;%</b>
<b class="calibre9">  filter(date &lt;= as.Date("2021-01-06"))</b>
</code></pre>
<p class="tx"><span aria-label=" Page 75. " epub:type="pagebreak" id="pg_75" role="doc-pagebreak"/>Save the result as a data frame called <span class="sans_thesansmonocd_w5regular_">usa_states_geom_covid_six_days</span>. Here’s what this data looks like:</p>
<pre id="pre-85" class="calibre10"><code class="calibre11">#&gt; Simple feature collection with 306 features and 4 fields
#&gt; Geometry type: MULTIPOLYGON
#&gt; Dimension:     XY
#&gt; Bounding box:  xmin: -2100000 ymin: -2500000 xmax: 2516374 ymax: 732103.3
#&gt; CRS:           +proj=laea +lat_0=45 +lon_0=-100 +x_0=0 +y_0=0 +a=6370997 +b=6370997 +unit...
#&gt; First 10 features:
#&gt;     name    date          fancy_date incidence_rate
#&gt; 1   Arizona 2021-01-01    Jan. 01    &gt;50
#&gt; 2   Arizona 2021-01-02    Jan. 02    &gt;50
#&gt; 3   Arizona 2021-01-03    Jan. 03    &gt;50
#&gt; 4   Arizona 2021-01-04    Jan. 04    &gt;50
#&gt; 5   Arizona 2021-01-05    Jan. 05    &gt;50
#&gt; 6   Arizona 2021-01-06    Jan. 06    &gt;50
#&gt; 7  Arkansas 2021-01-01    Jan. 01    &gt;50
#&gt; 8  Arkansas 2021-01-02    Jan. 02    &gt;50
#&gt; 9  Arkansas 2021-01-03    Jan. 03    &gt;50
#&gt; 10 Arkansas 2021-01-04    Jan. 04    &gt;50
#&gt;    geometry
#&gt; 1  MULTIPOLYGON (((-1111066 -8...
#&gt; 2  MULTIPOLYGON (((-1111066 -8...
#&gt; 3  MULTIPOLYGON (((-1111066 -8...
#&gt; 4  MULTIPOLYGON (((-1111066 -8...
#&gt; 5  MULTIPOLYGON (((-1111066 -8...
#&gt; 6  MULTIPOLYGON (((-1111066 -8...
#&gt; 7  MULTIPOLYGON (((557903.1 -1...
#&gt; 8  MULTIPOLYGON (((557903.1 -1...
#&gt; 9  MULTIPOLYGON (((557903.1 -1...
#&gt; 10 MULTIPOLYGON (((557903.1 -1...
</code></pre>
<p class="tx">Madjid’s map is giant, as it includes all 365 days. The size of a few elements have been changed so that they fit in this book.</p>
<section aria-labelledby="sec13" epub:type="division">
<h5 class="h3" id="sec13"><span class="sans_dogma_ot_bold_b_1">Generating the Basic Map</span></h5>
<p class="tni">With your six days of data, you’re ready to make some maps. Madjid’s mapmaking code has two main parts: generating the basic map, then tweaking its appearance. First, you’ll revisit the three lines of code used to make the Wyoming maps, with some adornments to improve the quality of the visualization:</p>
<pre id="pre-86" class="calibre10"><code class="calibre11"><b class="calibre9">usa_states_geom_covid_six_days %&gt;%</b>
<b class="calibre9">  ggplot() +</b>
<b class="calibre9">  geom_sf(</b>
<b class="calibre9">    aes(fill = incidence_rate),</b>
<b class="calibre9">    size = .05,</b>
<b class="calibre9">    color = "grey55"</b>
<b class="calibre9">  ) +</b>
<b class="calibre9">  facet_wrap(</b>
<b class="calibre9">    vars(fancy_date),</b>
<b class="calibre9">    strip.position = "bottom"</b>
<b class="calibre9">  )</b>
</code></pre>
<p class="tx"><span aria-label=" Page 76. " epub:type="pagebreak" id="pg_76" role="doc-pagebreak"/>The <span class="sans_thesansmonocd_w5regular_">geom_sf()</span> function plots the geospatial data, modifying a couple of arguments: <span class="sans_thesansmonocd_w5regular_">size = .05</span> makes the state borders less prominent and <span class="sans_thesansmonocd_w5regular_">color = "grey55"</span> sets them to a medium-gray color. Then, the <span class="sans_thesansmonocd_w5regular_">facet_wrap()</span> function is used for the faceting (that is, to make one map for each day). The <span class="sans_thesansmonocd_w5regular_">vars(fancy_date)</span> code specifies that the <span class="sans_thesansmonocd_w5regular_">fancy_date</span> variable should be used for the faceted maps, and <span class="sans_thesansmonocd_w5regular_">strip.position = "bottom"</span> moves the labels Jan. 01, Jan. 02, and so on to the bottom of the maps. <a href="chapter4.xhtml#fig4-9" class="calibre3">Figure 4-9</a> shows the result.</p>
<figure class="img"><img alt="" class="img2" height="539" id="fig4-9" src="../images/fig4-9.jpg" width="911"/>
<figcaption><p class="cap"><span class="sans_futura_std_book_oblique_i_">Figure 4-9: A map showing the incidence rate of COVID-19 for the first six days of 2021</span></p></figcaption>
</figure>
<p class="tx">Having generated the basic map, now you’ll make it look good.</p>
</section>
<section aria-labelledby="sec14" epub:type="division">
<h5 class="h3" id="sec14"><span class="sans_dogma_ot_bold_b_1">Applying Data Visualization Principles</span></h5>
<p class="tni">From now on, all of the code that Madjid uses is to improve the appearance of the maps. Many of the tweaks shown here should be familiar if you’ve read <span class="xref"><a href="chapter2.xhtml" class="calibre3">Chapter 2</a></span>, highlighting a benefit of making maps with ggplot: you can apply the same data visualization principles you learned about when making charts.</p>
<pre id="pre-87" class="calibre10"><code class="calibre11">usa_states_geom_covid_six_days %&gt;%
  ggplot() +
  geom_sf(
    aes(fill = incidence_rate),
    size = .05,
    color = "transparent"
  ) +
  facet_wrap(
    vars(fancy_date),
    strip.position = "bottom"
  ) +
  scale_fill_discrete_sequential(
    palette = "Rocket",
    name = "COVID-19 INCIDENCE RATE",
    guide = guide_legend(
      title.position = "top",
      title.hjust = .5,
      title.theme = element_text(
        family = "Times New Roman",
        size = rel(9),
<span aria-label=" Page 77. " epub:type="pagebreak" id="pg_77" role="doc-pagebreak"/>        margin = margin(
          b = .1,
          unit = "cm"
        )
      ),
      nrow = 1,
      keyheight = unit(.3, "cm"),
      keywidth = unit(.3, "cm"),
      label.theme = element_text(
        family = "Times New Roman",
        size = rel(6),
        margin = margin(
          r = 5,
          unit = "pt"
        )
      )
    )
  ) +
  labs(
    title = "2021 · A pandemic year",
    caption = "Incidence rates are calculated for 100,000 people in each state.
                  Inspired from a graphic in the DIE ZEIT newspaper of November 18, 2021.
                  Data from NY Times · Tidytuesday Week-1 2022 · Abdoul ISSA BIDA."
  ) +
  theme_minimal() +
  theme(
    text = element_text(
      family = "Times New Roman",
      color = "#111111"
    ),
    plot.title = element_text(
      size = rel(2.5),
      face = "bold",
      hjust = 0.5,
      margin = margin(
        t = .25,
        b = .25,
        unit = "cm"
      )
    ),
    plot.caption = element_text(
      hjust = .5,
      face = "bold",
      margin = margin(
        t = .25,
        b = .25,
        unit = "cm"
      )
    ),
    strip.text = element_text(
      size = rel(0.75),
      face = "bold"
    ),
    legend.position = "top",
<span aria-label=" Page 78. " epub:type="pagebreak" id="pg_78" role="doc-pagebreak"/>    legend.box.spacing = unit(.25, "cm"),
    panel.grid = element_blank(),
    axis.text = element_blank(),
    plot.margin = margin(
      t = .25,
      r = .25,
      b = .25,
      l = .25,
      unit = "cm"
    ),
    plot.background = element_rect(
      fill = "#e5e4e2",
      color = NA
    )
  )
</code></pre>
<p class="tx">The <span class="sans_thesansmonocd_w5regular_">scale_fill_discrete_sequential()</span> function, from the <span class="sans_thesansmonocd_w5regular_">colorspace</span> package, sets the color scale. This code uses the rocket palette (the same palette that C<span class="copyright_accent">é</span>dric Scherer and Georgios Karamanis used in <span class="xref"><a href="chapter2.xhtml" class="calibre3">Chapter 2</a></span>) and changes the legend title to “COVID-19 INCIDENCE RATE.” The <span class="sans_thesansmonocd_w5regular_">guide_legend()</span> function adjusts the position, alignment, and text properties of the title. The code then puts the colored squares in one row, adjusts their height and width, and tweaks the text properties of the labels (<span class="sans_thesansmonocd_w5regular_">&gt;0</span>, <span class="sans_thesansmonocd_w5regular_">&gt;5</span>, and so on).</p>
<p class="tx">Next, the <span class="sans_thesansmonocd_w5regular_">labs()</span> function adds a title and caption. Following <span class="sans_thesansmonocd_w5regular_">theme _minimal()</span>, the <span class="sans_thesansmonocd_w5regular_">theme()</span> function makes some design tweaks, including setting the font and text color; making the title and caption bold; and adjusting their size, alignment, and margins. The code then adjusts the size of the strip text (Jan. 01, Jan. 02, and so on) and makes it bold, puts the legend at the top of the maps, and adds a bit of spacing around it. Grid lines, as well as the longitude and latitude lines, are removed, and then the entire visualization gets a bit of padding and a light gray background.</p>
<p class="tx">There you have it! <a href="chapter4.xhtml#fig4-10" class="calibre3">Figure 4-10</a> shows the re-creation of his COVID-19 map.</p>
<figure class="img"><img alt="" class="img2" height="741" id="fig4-10" src="../images/fig4-10.jpg" width="899"/>
<figcaption><p class="cap"><span class="sans_futura_std_book_oblique_i_">Figure 4-10: The re-creation of Abdoul Madjid’s map</span></p></figcaption>
</figure>
<p class="tx"><span aria-label=" Page 79. " epub:type="pagebreak" id="pg_79" role="doc-pagebreak"/>From data import and data cleaning to analysis and visualization, you’ve seen how Madjid made a beautiful map in R.</p>
</section>
</section>
</section>
<section aria-labelledby="sec15" epub:type="division">
<h3 class="h1" id="sec15"><span id="h1-28"/><span class="sans_dogma_ot_bold_b_1">Making Your Own Maps</span></h3>
<p class="tni">You may now be wondering, <i class="calibre4">Okay, great, but how do I actually make my own maps?</i> In this section you’ll learn where you can find geospatial data, how to choose a projection, and how to prepare the data for mapping.</p>
<p class="tx">There are two ways to access simple features geospatial data. The first is to import raw data, and the second is to access it with R functions.</p>
<section aria-labelledby="sec16" epub:type="division">
<h4 class="h2" id="sec16"><span id="h2-38"/><span class="sans_futura_std_heavy_oblique_bi_">Importing Raw Data</span></h4>
<p class="tni">Geospatial data can come in various formats. While ESRI shapefiles (with the <i class="calibre4">.shp</i> extension) are the most common, you might also encounter GeoJSON files (<i class="calibre4">.geojson</i>) like the ones we used in the Wyoming example at the beginning of this chapter, KML files (<i class="calibre4">.kml</i>), and others. <a href="chapter8.xhtml" class="calibre3">Chapter 8</a> of <i class="calibre4">Geocomputation with R</i> by Robin Lovelace, Jakub Nowosad, and Jannes Muenchow discusses this range of formats.</p>
<p class="tx">The good news is that a single function can read pretty much any type of geospatial data: <span class="sans_thesansmonocd_w5regular_">read_sf()</span> from the <span class="sans_thesansmonocd_w5regular_">sf</span> package. Say you’ve downloaded geospatial data about US state boundaries from the website <i class="calibre4">geojson.xyz</i> in GeoJSON format, then saved it in the <i class="calibre4">data</i> folder as <i class="calibre4">states.geojson</i>. To import this data, use the <span class="sans_thesansmonocd_w5regular_">read_sf()</span> function like so:</p>
<pre id="pre-88" class="calibre10"><code class="calibre11"><b class="calibre9">us_states &lt;- read_sf(dsn = "https://data.rfortherestofus.com/states.geojson")</b>
</code></pre>
<p class="tx">The <span class="sans_thesansmonocd_w5regular_">dsn</span> argument (which stands for <i class="calibre4">data source name</i>) tells <span class="sans_thesansmonocd_w5regular_">read_sf()</span> where to find the file. You save the data as the object <span class="sans_thesansmonocd_w5regular_">us_states</span>.</p>
</section>
<section aria-labelledby="sec17" epub:type="division">
<h4 class="h2" id="sec17"><span id="h2-39"/><span class="sans_futura_std_heavy_oblique_bi_">Accessing Geospatial Data with R Functions</span></h4>
<p class="tni">Sometimes you’ll have to work with raw data in this way, but not always. That’s because certain R packages provide functions for accessing geospatial data. Madjid used the <span class="sans_thesansmonocd_w5regular_">usa_sf()</span> function from the <span class="sans_thesansmonocd_w5regular_">albersusa</span> package to acquire his data. Another package for accessing geospatial data related to the United States, <span class="sans_thesansmonocd_w5regular_">tigris</span>, has a number of well-named functions for different types of data. For example, load the <span class="sans_thesansmonocd_w5regular_">tigris</span> package and run the <span class="sans_thesansmonocd_w5regular_">states()</span> function like so:</p>
<pre id="pre-89" class="calibre10"><code class="calibre11"><b class="calibre9">library(tigris)</b>

<b class="calibre9">states_tigris &lt;- states(</b>
<b class="calibre9">  cb = TRUE,</b>
<b class="calibre9">  resolution = "20m",</b>
<b class="calibre9">  progress_bar = FALSE</b>
<b class="calibre9">)</b>
</code></pre>
<p class="tx"><span aria-label=" Page 80. " epub:type="pagebreak" id="pg_80" role="doc-pagebreak"/>The <span class="sans_thesansmonocd_w5regular_">cb = TRUE</span> argument opts out of using the most detailed shapefile and sets the resolution to a more manageable <span class="sans_thesansmonocd_w5regular_">20m</span> (1:20 million). Without these changes, the resulting shapefile would be large and slow to work with. Setting <span class="sans_thesansmonocd_w5regular_">progress_bar = FALSE</span> hides the messages that <span class="sans_thesansmonocd_w5regular_">tigris</span> generates as it loads data. The result is saved as <span class="sans_thesansmonocd_w5regular_">states_tigris</span>. The <span class="sans_thesansmonocd_w5regular_">tigris</span> package has functions to get geospatial data about counties, census tracts, roads, and more.</p>
<p class="tx">If you’re looking for data outside the United States, the <span class="sans_thesansmonocd_w5regular_">rnaturalearth</span> package provides functions for importing geospatial data from across the world. For example, use <span class="sans_thesansmonocd_w5regular_">ne_countries()</span> to retrieve geospatial data about various countries:</p>
<pre id="pre-90" class="calibre10"><code class="calibre11"><b class="calibre9">library(rnaturalearth)</b>

<b class="calibre9">africa_countries &lt;- ne_countries(</b>
<b class="calibre9">  returnclass = "sf",</b>
<b class="calibre9">  continent = "Africa"</b>
<b class="calibre9">)</b>
</code></pre>
<p class="tx">This code uses two arguments: <span class="sans_thesansmonocd_w5regular_">returnclass = "sf"</span> to get data in simple features format, and <span class="sans_thesansmonocd_w5regular_">continent = "Africa"</span> to get only countries on the African continent. If you save the result to an object called <span class="sans_thesansmonocd_w5regular_">africa_countries</span>, you can plot the data on a map as follows:</p>
<pre id="pre-91" class="calibre10"><code class="calibre11"><b class="calibre9">africa_countries %&gt;%</b>
<b class="calibre9">  ggplot() +</b>
<b class="calibre9">  geom_sf()</b>
</code></pre>
<p class="tx"><a href="chapter4.xhtml#fig4-11" class="calibre3">Figure 4-11</a> shows the resulting map.</p>
<figure class="img"><img alt="" class="img2" height="842" id="fig4-11" src="../images/fig4-11.jpg" width="856"/>
<figcaption><p class="cap"><span class="sans_futura_std_book_oblique_i_">Figure 4-11: A map of Africa made with data from the rnaturalearth package</span></p></figcaption>
</figure>
<p class="tx"><span aria-label=" Page 81. " epub:type="pagebreak" id="pg_81" role="doc-pagebreak"/>If you can’t find an appropriate package, you can always fall back on using <span class="sans_thesansmonocd_w5regular_">read_sf()</span> from the <span class="sans_thesansmonocd_w5regular_">sf</span> package.</p>
</section>
<section aria-labelledby="sec18" epub:type="division">
<h4 class="h2" id="sec18"><span id="h2-40"/><span class="sans_futura_std_heavy_oblique_bi_">Using Appropriate Projections</span></h4>
<p class="tni">Once you have access to geospatial data, you need to decide which projection to use. If you’re looking for a simple answer to this question, you’ll be disappointed. As <i class="calibre4">Geocomputation with R</i> puts it, “The question of <i class="calibre4">which</i> CRS [to use] is tricky, and there is rarely a ‘right’ answer.”</p>
<p class="tx">If you’re overwhelmed by the task of choosing a projection, the <span class="sans_thesansmonocd_w5regular_">crsuggest</span> package from Kyle Walker can give you ideas. Its <span class="sans_thesansmonocd_w5regular_">suggest_top_crs()</span> function returns a coordinate reference system that is well suited for your data. Load <span class="sans_thesansmonocd_w5regular_">crsuggest</span> and try it out on your <span class="sans_thesansmonocd_w5regular_">africa_countries</span> data:</p>
<pre id="pre-92" class="calibre10"><code class="calibre11"><b class="calibre9">library(crsuggest)</b>

<b class="calibre9">africa_countries %&gt;%</b>
<b class="calibre9">  suggest_top_crs()</b>
</code></pre>
<p class="tx">The <span class="sans_thesansmonocd_w5regular_">suggest_top_crs()</span> function should return projection number <span class="sans_thesansmonocd_w5regular_">28232</span>. Pass this value to the <span class="sans_thesansmonocd_w5regular_">st_transform()</span> function to change the projection before you plot:</p>
<pre id="pre-93" class="calibre10"><code class="calibre11">africa_countries %&gt;%
  <b class="calibre9">st_transform(28232) %&gt;%</b>
<b class="calibre9">  ggplot() +</b>
<b class="calibre9">  geom_sf()</b>
</code></pre>
<p class="tx">When run, this code generates the map in <a href="chapter4.xhtml#fig4-12" class="calibre3">Figure 4-12</a>.</p>
<figure class="img"><img alt="" class="img2" height="807" id="fig4-12" src="../images/fig4-12.jpg" width="848"/>
<figcaption><p class="cap"><span class="sans_futura_std_book_oblique_i_">Figure 4-12: A map of Africa made with projection number 28232</span></p></figcaption>
</figure>
<p class="tx"><span aria-label=" Page 82. " epub:type="pagebreak" id="pg_82" role="doc-pagebreak"/>As you can see, you’ve successfully mapped Africa with a different projection.</p>
</section>
<section aria-labelledby="sec19" epub:type="division">
<h4 class="h2" id="sec19"><span id="h2-41"/><span class="sans_futura_std_heavy_oblique_bi_">Wrangling Geospatial Data</span></h4>
<p class="tni">The ability to merge traditional data frames with geospatial data is a huge benefit of working with simple features data. Remember that for his COVID-19 map, Madjid analyzed traditional data frames before merging them with geospatial data. But because simple features data acts just like traditional data frames, you can just as easily apply the data-wrangling and analysis functions from the <span class="sans_thesansmonocd_w5regular_">tidyverse</span> directly to a simple features object. To see how this works, revisit the <span class="sans_thesansmonocd_w5regular_">africa_countries</span> simple features data and select two variables (<span class="sans_thesansmonocd_w5regular_">name</span> and <span class="sans_thesansmonocd_w5regular_">pop_est</span>) to see the name and population of the countries:</p>
<pre id="pre-94" class="calibre10"><code class="calibre11"><b class="calibre9">africa_countries %&gt;%</b>
<b class="calibre9">  select(name, pop_est)</b>
</code></pre>
<p class="tx">The output looks like the following:</p>
<pre id="pre-95" class="calibre10"><code class="calibre11">#&gt; Simple feature collection with 51 features and 2 fields
#&gt; Geometry type: MULTIPOLYGON
#&gt; Dimension:     XY
#&gt; Bounding box:  xmin: -17.62504 ymin: -34.81917 xmax: 51.13387 ymax: 37.34999
#&gt; CRS:           +proj=longlat +datum=WGS84 +no_defs +ellps=WGS84 +towgs84=0,0,0
#&gt; First 10 features:
#&gt;    name                   pop_est
#&gt;  1 Angola                 12799293
#&gt; 11 Burundi                8988091
#&gt; 13 Benin                  8791832
#&gt; 14 Burkina Faso           15746232
#&gt; 25 Botswana               1990876
#&gt; 26 Central African Rep.   4511488
#&gt; 31 Côte d'Ivoire          20617068
#&gt; 32 Cameroon               18879301
#&gt; 33 Dem. Rep. Congo        68692542
#&gt; 34 Congo                  4012809
#&gt;    geometry
#&gt;  1 MULTIPOLYGON (((16.32653 -5...
#&gt; 11 MULTIPOLYGON (((29.34 -4.49...
#&gt; 13 MULTIPOLYGON (((2.691702 6....
#&gt; 14 MULTIPOLYGON (((-2.827496 9...
#&gt; 25 MULTIPOLYGON (((25.64916 -1...
#&gt; 26 MULTIPOLYGON (((15.27946 7....
#&gt; 31 MULTIPOLYGON (((-2.856125 4...
#&gt; 32 MULTIPOLYGON (((13.07582 2....
#&gt; 33 MULTIPOLYGON (((30.83386 3....
#&gt; 34 MULTIPOLYGON (((12.99552 -4...
</code></pre>
<p class="tx">Say you want to make a map showing which African countries have populations larger than 20 million. First, you’ll need to calculate this value for each country. To do so, use the <span class="sans_thesansmonocd_w5regular_">mutate()</span> and <span class="sans_thesansmonocd_w5regular_">if_else()</span> functions, which will <span aria-label=" Page 83. " epub:type="pagebreak" id="pg_83" role="doc-pagebreak"/>return <span class="sans_thesansmonocd_w5regular_">TRUE</span> if a country’s population is over 20 million and <span class="sans_thesansmonocd_w5regular_">FALSE</span> otherwise, and then store the result in a variable called <span class="sans_thesansmonocd_w5regular_">population_above_20_million</span>:</p>
<pre id="pre-96" class="calibre10"><code class="calibre11">africa_countries %&gt;%
  select(name, pop_est) %&gt;%
<b class="calibre9">  mutate(population_above_20_million = if_else(pop_est &gt; 20000000, TRUE, FALSE))</b>
</code></pre>
<p class="tx">You can then take this code and pipe it into ggplot, setting the <span class="sans_thesansmonocd_w5regular_">fill</span> aesthetic property to be equal to <span class="sans_thesansmonocd_w5regular_">population_above_20_million</span>:</p>
<pre id="pre-97" class="calibre10"><code class="calibre11">africa_countries %&gt;%
  select(name, pop_est) %&gt;%
  mutate(population_above_20_million = if_else(pop_est &gt; 20000000, TRUE, FALSE)) %&gt;%
  <b class="calibre9">ggplot(aes(fill = population_above_20_million)) +</b>
<b class="calibre9">  geom_sf()</b>
</code></pre>
<p class="tx">This code generates the map shown in <a href="chapter4.xhtml#fig4-13" class="calibre3">Figure 4-13</a>.</p>
<figure class="img"><img alt="" class="img1" height="800" id="fig4-13" src="../images/fig4-13.jpg" width="1632"/>
<figcaption><p class="cap"><span class="sans_futura_std_book_oblique_i_">Figure 4-13: A map of Africa highlighting countries with populations above 20 million people</span></p></figcaption>
</figure>
<p class="tx">This is a basic example of the data wrangling and analysis you can perform on simple features data. The larger lesson is this: any skill you’ve developed for working with data in R will serve you well when working with geospatial data.</p>
</section>
</section>
<section aria-labelledby="sec20" epub:type="division">
<h3 class="h1" id="sec20"><span id="h1-29"/><span class="sans_dogma_ot_bold_b_1">Summary</span></h3>
<p class="tni">In this short romp through the world of mapmaking in R, you learned the basics of simple features geospatial data, reviewed how Abdoul Madjid applied this knowledge to make his map, explored how to get your own geospatial data, and saw how to project it appropriately to make your own maps.</p>
<p class="tx"><span aria-label=" Page 84. " epub:type="pagebreak" id="pg_84" role="doc-pagebreak"/>R may very well be the best tool for making maps. It also lets you use the skills you’ve developed for working with traditional data frames and the ggplot code to make your visualizations look great. After all, Madjid isn’t a GIS expert, but he combined a basic understanding of geospatial data, fundamental R skills, and knowledge of data visualization principles to make a beautiful map. Now it’s your turn to do the same.</p>
</section>
<section aria-labelledby="sec21" epub:type="division">
<h3 class="h1" id="sec21"><span id="h1-30"/><span class="sans_dogma_ot_bold_b_1">Additional Resources</span></h3>
<ul class="ul">
<li class="listbullet">Kieran Healy, “Draw Maps,” in <i class="calibre4">Data Visualization: A Practical Introduction</i> (Princeton, NJ: Princeton University Press, 2018), <i class="calibre4"><a href="https://socviz.co" class="calibre3">https://socviz.co</a></i>.</li>
<li class="listbullet">Andrew Heiss, “Lessons on Space from Data Visualization: Use R, ggplot2, and the Principles of Graphic Design to Create Beautiful and Truthful Visualizations of Data,” online course, last updated July 11, 2022, <i class="calibre4"><a href="https://datavizs22.classes.andrewheiss.com/content/12-content/" class="calibre3">https://datavizs22.classes.andrewheiss.com/content/12-content/</a></i>.</li>
<li class="listbullet">Robin Lovelace, Jakub Nowosad, and Jannes Muenchow, <i class="calibre4">Geocomputation with R</i> (Boca Raton, FL: CRC Press, 2019), <i class="calibre4"><a href="https://r.geocompx.org" class="calibre3">https://r.geocompx.org</a></i>.</li>
<li class="listbullet">Kyle Walker, <i class="calibre4">Analyzing US Census Data: Methods, Maps, and Models in R</i> (Boca Raton, FL: CRC Press, 2013).</li>
</ul>
</section>
</section>
</div></body></html>