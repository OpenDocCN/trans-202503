<html><head></head><body>
<section epub:type="chapter" role="doc-chapter" aria-labelledby="ch3">&#13;
<hgroup>&#13;
<h1 class="CHAPTER" id="ch3">&#13;
<span class="CN"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_51" aria-label="51"/><span class="SANS_Futura_Std_Bold_Condensed_B_11">3</span></span>&#13;
<span class="CT"><span class="SANS_Dogma_OT_Bold_B_11">SETTING UP A HACKING LAB</span></span>&#13;
</h1>&#13;
</hgroup>&#13;
<figure class="opener"><img class="opener" src="../images/opener.jpg" alt=""/></figure>&#13;
<p class="COS">In this chapter, you’ll set up a lab environment containing hacking tools and an intentionally vulnerable target. You’ll use this lab in chapter exercises, but you can also turn to it whenever you need to write, stage, and test a bash script before running it against real targets.</p>&#13;
<p class="TX">The locally deployed target and its assets mimic the production environment of a mock internet hosting company called ACME Infinity Servers, which has its own fake employees, customers, and data. This fabricated internet hosting company and its customers will provide you with a diverse range of intentionally vulnerable applications, user accounts, and infrastructure that you can practice attacking in later chapters.</p>&#13;
<p class="TX">The lab will be fully contained in a Kali virtual machine. This virtual machine will require the following minimum specifications: at least 4GB of RAM, at least 40GB of storage, and an internet connection.</p>&#13;
<section epub:type="division" aria-labelledby="sec1">&#13;
<h2 class="H1" id="sec1"><span id="h1-19"/><span role="doc-pagebreak" epub:type="pagebreak" id="pg_52" aria-label="52"/><span class="SANS_Futura_Std_Bold_B_11">Security Lab Precautions</span></h2>&#13;
<p class="TNI1">Follow these guidelines to reduce the risks associated with building and operating a hacking lab:</p>&#13;
<ul class="ul">&#13;
<li class="ListBullet">Avoid connecting the lab directly to the internet. Hacking lab environments typically run vulnerable code or outdated software. While these vulnerabilities are great for hands-on learning, they could pose risks to your network, computer, and data if they become accessible from the internet. Instead, we recommend working through the book when connected to local networks that you trust or operating offline after the lab is set up.</li>&#13;
<li class="ListBullet">Deploy the lab in a virtual environment by using a hypervisor. Separating the lab environment from your primary operating system is generally a good idea, as it prevents conflicts that could potentially break other software on your computer. We recommend using a virtualization tool to ensure this separation. In the next section, you’ll install the lab in a Kali virtual machine.</li>&#13;
<li class="ListBullet">Take frequent snapshots of your virtual machine. <i>Snapshots</i> are backups of your virtual machine that allow you to restore it to a previous state. Lab environments often won’t stay stable after you attack them, so take snapshots whenever your lab is in a stable state.</li>&#13;
</ul>&#13;
<p class="TX">With these best practices in mind, let’s get our hands dirty and our lab up and running!</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec2">&#13;
<h2 class="H1" id="sec2"><span id="h1-20"/><span class="SANS_Futura_Std_Bold_B_11">Installing Kali</span></h2>&#13;
<p class="TNI1"><i>Kali</i> is a Linux distribution created for penetration testing. Based on Debian, it was designed by OffSec. We’ll use Kali as our lab’s operating system because it comes bundled with some of the libraries, dependencies, and tools we’ll need.</p>&#13;
<p class="TX">Your Kali machine will play two roles in the lab environment. First, it will act as the host responsible for running the target networks and machines against which you’ll run your scripts. Second, it will serve as the hacking machine from which you’ll perform your attacks.</p>&#13;
<p class="TX">You can find an x64 version of the Kali virtual machine images for the VMware Workstation and Oracle VirtualBox hypervisors at <i><a href="https://www.kali.org/get-kali/#kali-platforms">https://www.kali.org/get-kali/#kali-platforms</a></i>. Pick the hypervisor of your choice and follow the official installation instructions at <i><a href="https://www.kali.org/docs/installation/">https://www.kali.org/docs/installation/</a></i> to install it.</p>&#13;
<p class="TX">After completing the installation process, you should see the Kali login screen shown in <a href="chapter3.xhtml#fig3-1">Figure 3-1</a>. Kali ships with a default user account named <i>kali</i> whose password is <i>kali</i>.</p>&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_53" aria-label="53"/>&#13;
<figure class="IMG"><img id="fig3-1" class="img1" src="../images/pg53.jpg" alt=""/>&#13;
<figcaption><p class="CAP"><span class="SANS_Futura_Std_Book_Oblique_I_11">Figure 3-1: The Kali login screen</span></p></figcaption>&#13;
</figure>&#13;
<p class="TX">After logging in to Kali, you need to make sure it’s up to date. To access the terminal, open the <b>Applications</b> menu, and in the search bar, enter <b>terminal emulator</b>. Click the corresponding application.</p>&#13;
<p class="TX">Let’s use a few commands to update your software repositories and upgrade your installed packages. In the terminal window, enter the following commands:</p>&#13;
<pre><code>$ <b>sudo apt update -y</b>&#13;
$ <b>sudo apt upgrade -y</b>&#13;
$ <b>sudo apt dist-upgrade -y</b>&#13;
</code></pre>&#13;
<p class="TX">When you use <span class="SANS_TheSansMonoCd_W5Regular_11">sudo</span>, Kali will ask for your password. This is the same password you used to log in to the virtual machine, <i>kali</i>.</p>&#13;
<p class="TX">Newer Kali releases use the Z Shell (zsh) by default, so ensure that bash is the default shell for the <i>kali</i> user with this command:</p>&#13;
<pre><code>$ <b>sudo usermod --shell /bin/bash kali</b></code></pre>&#13;
<p class="TX">Next, enable your new default shell by running the following command:</p>&#13;
<pre><code>$ <b>su - kali</b></code></pre>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_54" aria-label="54"/>Moving forward, we’ll use this Kali machine for all tasks we cover in the book. We recommend keeping the terminal window open, as you’ll need it for additional installations very soon.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec3">&#13;
<h2 class="H1" id="sec3"><span id="h1-21"/><span class="SANS_Futura_Std_Bold_B_11">The Target Environment</span></h2>&#13;
<p class="TNI1">Now it’s time to install the machines and networks that will make up the simulated target. You can perform this installation in two ways: manually or with an automated script.</p>&#13;
<p class="TX">We encourage you to set up your lab manually at least once by following the instructions in this section. This will allow you to familiarize yourself with the lab’s core components and practice running commands on the command line. However, if you ever need to redeploy the lab from scratch in a fresh installation of Kali, you can do so by cloning the repository at <i><a href="https://github.com/dolevf/Black-Hat-Bash">https://github.com/dolevf/Black-Hat-Bash</a></i> and running <span class="SANS_TheSansMonoCd_W5Regular_11">make init</span>:</p>&#13;
<pre><code>$ <b>cd ~</b>&#13;
$<b> git clone https://github.com/dolevf/Black-Hat-Bash.git</b>&#13;
$ <b>cd ./Black-Hat-Bash/lab</b>&#13;
$ <b>sudo make init</b>&#13;
</code></pre>&#13;
<p class="TX">This script should install all the lab’s dependencies, containers, and hacking utilities, enabling you to skip the instructions in this section and in <span class="Xref">“Installing Additional Hacking Tools” on <a href="#pg_61">page 61</a></span>. You must execute the script in a Kali virtual machine that meets the system requirements described in the introduction to this chapter.</p>&#13;
<section epub:type="division" aria-labelledby="sec4">&#13;
<h3 class="H2" id="sec4"><span id="h2-38"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Installing Docker and Docker Compose</span></h3>&#13;
<p class="TNI1">We’ll build the lab environment by using <i>Docker</i>, a tool for deploying and managing containers. <i>Containers</i> package code and its dependencies so an application can run reliably in various environments. We’ll also use <i>Docker Compose</i>, a special Docker utility for building and managing multiple Docker containers through a single YAML file known as a <i>Compose file</i>.</p>&#13;
<p class="TX">Let’s first configure our sources to use Debian’s current stable version of Docker’s community edition, <i>docker-ce</i>, using the following commands. We use <span class="SANS_TheSansMonoCd_W5Regular_11">printf</span> to add Docker’s Advanced Package Tool (APT) repository to the APT package-source database file. The <span class="SANS_TheSansMonoCd_W5Regular_11">tee</span> command reads from the standard input stream and writes to a file:</p>&#13;
<pre><code>$ <b>printf '%s\n' "deb https://download.docker.com/linux/debian bullseye stable" |</b>&#13;
<b>sudo tee /etc/apt/sources.list.d/docker-ce.list</b>&#13;
</code></pre>&#13;
<p class="TX">Next, download and import Docker’s keyring to ensure that the repository is validated and all packages installed from that repository are cryptographically verified. Use <span class="SANS_TheSansMonoCd_W7Bold_B_11">curl</span> to download the key and pipe it to the <span class="SANS_TheSansMonoCd_W5Regular_11">gpg</span> command, which will then store it in the required folder:</p>&#13;
<pre><code><span role="doc-pagebreak" epub:type="pagebreak" id="pg_55" aria-label="55"/>$ <b>curl -fsSL https://download.docker.com/linux/debian/gpg | sudo gpg --dearmor -o</b>&#13;
<b>/etc/apt/trusted.gpg.d/docker-ce-archive-keyring.gpg</b>&#13;
</code></pre>&#13;
<p class="TX">Finally, run another update to refresh the repository database and install the Docker components:</p>&#13;
<pre><code>$ <b>sudo apt update -y</b>&#13;
$ <b>sudo apt install docker-ce docker-ce-cli containerd.io -y</b>&#13;
</code></pre>&#13;
<p class="TX">To verify that you have Docker Compose running correctly, use the following:</p>&#13;
<pre><code>$ <b>sudo docker compose --help</b></code></pre>&#13;
<p class="TX">Next, make sure the Docker process will automatically start upon system reboot by running this command:</p>&#13;
<pre><code>$ <b>sudo systemctl enable docker --now</b></code></pre>&#13;
<p class="TX">Docker requires the use of <span class="SANS_TheSansMonoCd_W5Regular_11">sudo</span>, which can get a little inconvenient. If you want to avoid having to enter <span class="SANS_TheSansMonoCd_W5Regular_11">sudo</span> before executing Docker-related commands, add the <i>kali</i> user to the <i>docker</i> Linux group:</p>&#13;
<pre><code>$ <b>sudo usermod -aG docker $USER</b></code></pre>&#13;
<p class="TX">Once you’ve done this, you shouldn’t need <span class="SANS_TheSansMonoCd_W5Regular_11">sudo</span> to run Docker commands. For these changes to take effect, you must log out of and back in to Kali.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec5">&#13;
<h3 class="H2" id="sec5"><span id="h2-39"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Cloning the Book’s Repository</span></h3>&#13;
<p class="TNI1">You can find the lab’s files in the book’s GitHub repository at <i><a href="https://github.com/dolevf/Black-Hat-Bash">https://github.com/dolevf/Black-Hat-Bash</a></i>. This repository contains the Docker configurations needed to build the lab, as well as all the bash scripts mentioned in the later chapters of this book.</p>&#13;
<p class="TX">Kali comes preloaded with Git, which you can use to clone and download the repository. To do so, run the following:</p>&#13;
<pre><code>$ <b>cd ~</b>&#13;
$ <b>git clone https://github.com/dolevf/Black-Hat-Bash.git</b>&#13;
</code></pre>&#13;
<p class="TX">Next, move into the repository’s root directory and take a quick look at its contents:</p>&#13;
<pre><code>$ <b>cd Black-Hat-Bash &amp;&amp; ls -l</b>&#13;
<var>--snip--</var>&#13;
drwxr-xr-x 2 kali kali 4096 Jul 22 23:07 ch01&#13;
drwxr-xr-x 2 kali kali 4096 Jul 22 23:07 ch02&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_56" aria-label="56"/>drwxr-xr-x 2 kali kali 4096 Jul 22 23:07 ch03&#13;
drwxr-xr-x 2 kali kali 4096 Jul 22 23:07 ch04&#13;
drwxr-xr-x 2 kali kali 4096 Jul 22 23:07 ch05&#13;
<var>--snip--</var>&#13;
</code></pre>&#13;
<p class="TX">As you can see in the output, the repository’s contents are organized into directories for each of the book’s chapters. The repository also includes a <i>lab</i> directory, which we’ll use to set up the lab in the next section.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec6">&#13;
<h3 class="H2" id="sec6"><span id="h2-40"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Deploying Docker Containers</span></h3>&#13;
<p class="TNI1">The contents of the <i>lab</i> directory in the book’s repository control all networking infrastructure, machines, and applications used within the lab. This directory includes a <i>Makefile</i> file. By running this script with the <span class="SANS_TheSansMonoCd_W5Regular_11">help</span> argument, you can see that it is used to deploy, tear down, rebuild, clean, and check the status of our environment:</p>&#13;
<pre><code>$ <b>cd lab</b>&#13;
$<b> make help</b>&#13;
&#13;
Usage: make deploy | teardown | cleanup | rebuild | status | init | help&#13;
&#13;
deploy   | build images and start containers&#13;
teardown | stop containers (shut down lab)&#13;
rebuild  | rebuild the lab from scratch (clean up and deploy)&#13;
cleanup  | stop and delete containers and images&#13;
status   | check the status of the lab&#13;
init     | build everything (containers and hacking tools)&#13;
help     | show this help message&#13;
</code></pre>&#13;
<p class="TX">Let’s start by using the <span class="SANS_TheSansMonoCd_W5Regular_11">deploy</span> argument to create the lab. Note that you will need <span class="SANS_TheSansMonoCd_W5Regular_11">sudo</span> permissions to execute the deployment, so you’ll be prompted for your <i>kali</i> user password:</p>&#13;
<pre><code>$ <b>sudo make deploy</b></code></pre>&#13;
<p class="TX">The initial deployment of the lab environment will take a few minutes to complete. To monitor the progress of the installation, you’ll need to open a new terminal session and tail the logfile located under <i>/var/log/lab-install.log</i>, like so:</p>&#13;
<pre><code>$ <b>tail -f /var/log/lab-install.log</b></code></pre>&#13;
<p class="TX">When the <span class="SANS_TheSansMonoCd_W5Regular_11">tail -f</span> (follow) command is used against a file, it provides a live view of any new lines added to the end of the file. This is useful for keeping an eye on logfiles, which frequently have new information written to them.</p>&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_57" aria-label="57"/>&#13;
<blockquote>&#13;
<p class="Note"><span class="SANS_Dogma_OT_Bold_B_15">NOTE</span></p>&#13;
</blockquote>&#13;
<p class="NOTE-TXT"><i>Because the lab setup downloads software such as operating system images and other applications, this deployment could take some time, depending on your network connection and the computer’s resources allocated to the host running the lab.</i></p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec7">&#13;
<h3 class="H2" id="sec7"><span id="h2-41"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Testing and Verifying the Containers</span></h3>&#13;
<p class="TNI1">Once the logfile indicates the process is complete, it should tell you whether the lab was set up correctly. We can also run a few commands to verify this. First, let’s execute a status check by using the <span class="SANS_TheSansMonoCd_W5Regular_11">make</span> command, this time with the <span class="SANS_TheSansMonoCd_W5Regular_11">test</span> argument. If all the checks pass, you should get the following output:</p>&#13;
<pre><code>$ <b>sudo make test</b>&#13;
Lab is up.&#13;
</code></pre>&#13;
<p class="TX">We can also list all our lab’s running Docker containers with the <span class="SANS_TheSansMonoCd_W5Regular_11">docker ps</span> command:</p>&#13;
<pre><code>$ <b>sudo docker ps -–format "{{.Names}}"</b>&#13;
p-web-01&#13;
p-web-02&#13;
p-ftp-01&#13;
c-jumpbox-01&#13;
c-db-01&#13;
c-db-02&#13;
c-backup-01&#13;
c-redis-01&#13;
</code></pre>&#13;
<p class="TX">You should get a similar output, though the containers won’t necessarily be in the same order.</p>&#13;
<blockquote>&#13;
<p class="Note"><span class="SANS_Dogma_OT_Bold_B_15">NOTE</span></p>&#13;
</blockquote>&#13;
<p class="NOTE-TXT"><i>For convenience, you can also use the</i> <span class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">make status</span> <i>command, which is identical to</i> <span class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">make test</span><i>, to check whether the lab is up and running.</i></p>&#13;
</section>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec8">&#13;
<h2 class="H1" id="sec8"><span id="h1-22"/><span class="SANS_Futura_Std_Bold_B_11">The Network Architecture</span></h2>&#13;
<p class="TNI1">The lab consists of eight machines running in Docker containers, as well as two networks. Most of the machines are assigned to one of the two networks, and we’ll use them to facilitate various hacking scenarios in later chapters.</p>&#13;
<p class="TX">The networks within the lab are connected to Kali via Docker’s bridged networking mode. <a href="chapter3.xhtml#fig3-2">Figure 3-2</a> shows the details of this network architecture.</p>&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_58" aria-label="58"/>&#13;
<figure class="IMG"><img id="fig3-2" class="img1" src="../images/pg58.jpg" alt=""/>&#13;
<figcaption><p class="CAP"><span class="SANS_Futura_Std_Book_Oblique_I_11">Figure 3-2: The lab’s network architecture</span></p></figcaption>&#13;
</figure>&#13;
<p class="TX">You can also find this diagram in the book’s repository at <i><a href="https://github.com/dolevf/Black-Hat-Bash/blob/master/lab/lab-network-diagram.png">https://github.com/dolevf/Black-Hat-Bash/blob/master/lab/lab-network-diagram.png</a></i>.</p>&#13;
<section epub:type="division" aria-labelledby="sec9">&#13;
<h3 class="H2" id="sec9"><span id="h2-42"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">The Public Network</span></h3>&#13;
<p class="TNI1">The network on the left side of <a href="chapter3.xhtml#fig3-2">Figure 3-2</a> is the public network, where our fake internet hosting company, ACME Infinity Servers, hosts its customers’ websites and resources. The two company websites you’ll find in this network belong to ACME Impact Alliance and ACME Hyper Branding.</p>&#13;
<p class="TX">The public network has an IP address Classless Inter-Domain Routing (CIDR) range of 172.16.10.0/24 and contains four machines (whose names are prefixed with <i>p-</i>). It is also public facing, meaning we’ll likely test the machines with access to this network before any other, as they constitute possible entry points into the network.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec10">&#13;
<h3 class="H2" id="sec10"><span id="h2-43"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">The Corporate Network</span></h3>&#13;
<p class="TNI1">The second network is the corporate network. ACME Infinity Servers uses this private network to host its supporting infrastructure on the backend. As you can see, the corporate network has an IP address CIDR range of 10.1.0.0/24 and contains four machines (whose names are prefixed with <i>c-</i>).</p>&#13;
<p class="TX">This network is not public facing, meaning the machines in this network don’t have internet connectivity. Therefore, we won’t test them until we’re able to take over one or more of the machines on the public network, which will serve as our launchpad to the corporate network.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec11">&#13;
<h3 class="H2" id="sec11"><span id="h2-44"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Kali Network Interfaces</span></h3>&#13;
<p class="TNI1">Kali has two network interfaces used to facilitate connections to both lab networks. We can use the <i>br_public</i> network interface to access the public network and the <i>br_corporate</i> network interface to access the corporate <span role="doc-pagebreak" epub:type="pagebreak" id="pg_59" aria-label="59"/>network. You can validate that both interfaces are online and configured to use the correct network address by running the following command:</p>&#13;
<pre><code>$ <b>ip addr | grep "br_"</b>&#13;
&#13;
<var>--snip--</var>&#13;
4: br_public: &lt;NO-CARRIER,BROADCAST,MULTICAST,UP&gt; mtu 1500 qdisc noqueue state DOWN group de...&#13;
    link/ether 02:42:ea:5f:96:9b brd ff:ff:ff:ff:ff:ff&#13;
    inet <span class="codewide_CodeAnnotation" aria-label="annotation1">❶</span> 172.16.10.1/24 brd 172.16.10.255 scope global br_public&#13;
5: br_corporate: &lt;NO-CARRIER,BROADCAST,MULTICAST,UP&gt; mtu 1500 qdisc noqueue state DOWN group...&#13;
    link/ether 02:42:67:90:5a:95 brd ff:ff:ff:ff:ff:ff&#13;
    inet <span class="codewide_CodeAnnotation" aria-label="annotation2">❷</span> 10.1.0.1/24 brd 10.1.0.255 scope global br_corporate&#13;
</code></pre>&#13;
<p class="TX">Verify that the IP addresses match those shown at <span class="CodeAnnotation" aria-label="annotation1">❶</span> and <span class="CodeAnnotation" aria-label="annotation2">❷</span> before moving on.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec12">&#13;
<h3 class="H2" id="sec12"><span id="h2-45"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">The Machines</span></h3>&#13;
<p class="TNI1">The eight machines that make up the lab environment follow a simple naming convention. The first character of the name indicates the network that the machine belongs to. For example, if the machine name starts with a <i>p</i>, it belongs to the public network; likewise, if it starts with a <i>c</i>, it belongs to the corporate network. The next word describes the machine’s functions or main technology stack, such as <i>web</i>, <i>ftp</i>, <i>jumpbox</i>, or <i>redis</i>. Finally, a number is used to distinguish similar machines, such as <i>p-web-01</i> and <i>p-web-02</i>.</p>&#13;
<p class="TX">Each machine provides unique applications, services, and user accounts that we can learn about and break into. Later chapters describe these machines in more detail, but <a href="chapter3.xhtml#tab3-1">Table 3-1</a> provides some high-level information about them.</p>&#13;
<p class="TT" id="tab3-1"><span class="Heavy"><span class="SANS_Futura_Std_Heavy_B_11">Table 3-1:</span></span> <span class="SANS_Futura_Std_Book_11">Lab Machine Details</span></p>&#13;
<table class="Basic-Table">&#13;
<thead>&#13;
<tr>&#13;
<th class="TCH" scope="col"><p class="TCH1"><span class="SANS_Futura_Std_Heavy_B_11">Name</span></p></th>&#13;
<th class="TCH" scope="col"><p class="TCH1"><span class="SANS_Futura_Std_Heavy_B_11">Public IP</span></p></th>&#13;
<th class="TCH" scope="col"><p class="TCH1"><span class="SANS_Futura_Std_Heavy_B_11">Corporate IP</span></p></th>&#13;
<th class="TCH" scope="col"><p class="TCH1"><span class="SANS_Futura_Std_Heavy_B_11">Hostname</span></p></th>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr>&#13;
<td class="TBF"><p class="TB1"><span class="SANS_Futura_Std_Book_11">Kali host</span></p></td>&#13;
<td class="TBF"><p class="TB1"><span class="SANS_Futura_Std_Book_11">172.16.10.1</span></p></td>&#13;
<td class="TBF"><p class="TB1"><span class="SANS_Futura_Std_Book_11">10.1.0.1</span></p></td>&#13;
<td class="TBF"><p class="TB1"><span class="SANS_Futura_Std_Book_11">—</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_Oblique_I_11">p-web-01</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">172.16.10.10</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">—</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_Oblique_I_11">p-web-01.acme-infinity-servers.com</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_Oblique_I_11">p-ftp-01</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">172.16.10.11</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">—</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_Oblique_I_11">p-ftp-01.acme-infinity-servers.com</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_Oblique_I_11">p-web-02</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">172.16.10.12</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">10.1.0.11</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_Oblique_I_11">p-web-02.acme-infinity-servers.com</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_Oblique_I_11">c-jumpbox-01</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">172.16.10.13</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">10.1.0.12</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_Oblique_I_11">c-jumpbox-01.acme-infinity-servers.com</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_Oblique_I_11">c-backup-01</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">—</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">10.1.0.13</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_Oblique_I_11">c-backup-01.acme-infinity-servers.com</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_Oblique_I_11">c-redis-01</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">—</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">10.1.0.14</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_Oblique_I_11">c-redis-01.acme-infinity-servers.com</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_Oblique_I_11">c-db-01</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">—</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">10.1.0.15</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_Oblique_I_11">c-db-01.acme-infinity-servers.com</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TBL"><p class="TB1"><span class="SANS_Futura_Std_Book_Oblique_I_11">c-db-02</span></p></td>&#13;
<td class="TBL"><p class="TB1"><span class="SANS_Futura_Std_Book_11">—</span></p></td>&#13;
<td class="TBL"><p class="TB1"><span class="SANS_Futura_Std_Book_11">10.1.0.16</span></p></td>&#13;
<td class="TBL"><p class="TB1"><span class="SANS_Futura_Std_Book_Oblique_I_11">c-db-02.acme-infinity-servers.com</span></p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<p class="TX">When you perform penetration tests from Kali, keep in mind that you may sometimes see Kali’s own IP addresses, 172.16.10.1 and 10.1.0.1, pop up in certain tool results. We won’t be testing those.</p>&#13;
</section>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec13">&#13;
<h2 class="H1" id="sec13"><span id="h1-23"/><span role="doc-pagebreak" epub:type="pagebreak" id="pg_60" aria-label="60"/><span class="SANS_Futura_Std_Bold_B_11">Managing the Lab</span></h2>&#13;
<p class="TNI1">Now that you’ve set up your lab and taken a close look at its components, you’ll learn how to tear it down, start it, and rebuild it if needed.</p>&#13;
<section epub:type="division" aria-labelledby="sec14">&#13;
<h3 class="H2" id="sec14"><span id="h2-46"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Shutting Down</span></h3>&#13;
<p class="TNI1">When you’re not using the lab environment, turning it off is good practice. To shut down all the containers running in the lab, run the following:</p>&#13;
<pre><code>$ <b>sudo make teardown</b></code></pre>&#13;
<p class="TX">You should receive a list of all stopped containers, as well as the removed networks and volumes, as shown here:</p>&#13;
<pre><code>==== Shutdown Started ====&#13;
Stopping p-web-02     ... done&#13;
Stopping c-jumpbox-01 ... done&#13;
<var>--snip--</var>&#13;
Removing volume lab_p_web_02_vol&#13;
OK: lab has shut down.&#13;
</code></pre>&#13;
<p class="TX">To restart your containers, simply rerun the <span class="SANS_TheSansMonoCd_W5Regular_11">deploy</span> command mentioned in <span class="Xref">“Deploying Docker Containers” on <a href="#pg_56">page 56</a></span>.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec15">&#13;
<h3 class="H2" id="sec15"><span id="h2-47"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Removing</span></h3>&#13;
<p class="TNI1">To completely remove the lab environment from your Kali machine, you can run the <span class="SANS_TheSansMonoCd_W5Regular_11">clean</span> command. This will destroy all containers and their images:</p>&#13;
<pre><code>$ <b>sudo make clean</b>&#13;
&#13;
==== Cleanup Started ====&#13;
Shutting down the lab...&#13;
Cleaning up...&#13;
OK: lab environment has been destroyed.&#13;
</code></pre>&#13;
<p class="TX">After running the command, you should receive a confirmation that the lab environment has been destroyed.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec16">&#13;
<h3 class="H2" id="sec16"><span id="h2-48"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Rebuilding</span></h3>&#13;
<p class="TNI1">When we execute a rebuild, the lab will first shut down all running containers, delete volumes, and remove all container images before running a new deployment. To execute the rebuild, run the following command:</p>&#13;
<pre><code>$ <b>sudo make rebuild</b></code></pre>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_61" aria-label="61"/>If you rebuild the lab, you’ll lose any data you saved inside your containers. Rebuilding is useful when something goes wrong during installation. Maybe, halfway through it, you lost your network connection, and the lab reported a failed state. The <span class="SANS_TheSansMonoCd_W5Regular_11">rebuild</span> command allows you to wipe and install the lab environment from scratch.</p>&#13;
</section>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec17">&#13;
<h2 class="H1" id="sec17"><span id="h1-24"/><span class="SANS_Futura_Std_Bold_B_11">Accessing Individual Lab Machines</span></h2>&#13;
<p class="TNI1">As you progress through the book, you’ll compromise the machines in the lab environment. However, obtaining full access to a machine often takes multiple attempts. Sometimes you may need to troubleshoot an issue or reproduce a post-compromise activity, and you won’t want to repeat the steps you performed to obtain access.</p>&#13;
<p class="TX">To gain shell access to any individual lab machine, you can run the following Docker command:</p>&#13;
<pre><code>$ <b>sudo</b> <b>docker exec -it </b><b><var>MACHINE-NAME</var></b><b> bash</b></code></pre>&#13;
<p class="TX"><span class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">MACHINE-NAME</span> represents the name of a lab machine, such as <i>p-web-01</i> or <i>p-jumpstation-01</i> (or any other machine from <a href="chapter3.xhtml#tab3-1">Table 3-1</a> that starts with <i>p-</i> or <i>c-</i>). The Docker command will drop you into a bash shell, at which point you can execute any command you like. To exit, simply enter <span class="SANS_TheSansMonoCd_W7Bold_B_11">exit</span> at the prompt or close the terminal session’s window.</p>&#13;
<p class="TX">We highly recommend you compromise the machines as intended before taking these convenient shortcuts, however.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec18">&#13;
<h2 class="H1" id="sec18"><span id="h1-25"/><span class="SANS_Futura_Std_Bold_B_11">Installing Additional Hacking Tools</span></h2>&#13;
<p class="TNI1">Most of the tools we’ll use in this book come preinstalled in Kali, and we’ll introduce them upon first use. However, we’ll need several tools that aren’t installed by default, so let’s install them here. First, create a new directory for your tools:</p>&#13;
<pre><code>$ <b>cd ~</b>&#13;
$ <b>mkdir tools</b>&#13;
</code></pre>&#13;
<p class="TX">Now use the instructions in the following sections to install each tool.</p>&#13;
<section epub:type="division" aria-labelledby="sec19">&#13;
<h3 class="H2" id="sec19"><span id="h2-49"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">WhatWeb</span></h3>&#13;
<p class="TNI1"><i>WhatWeb</i>, developed by Andrew Horton and Brendan Coles, is a Ruby-based web scanner. Using a plug-in-based system, it’s designed to identify the software running a target website.</p>&#13;
<p class="TX">WhatWeb can fingerprint websites and their application stack by using its database of known application signatures. WhatWeb can also identify <span role="doc-pagebreak" epub:type="pagebreak" id="pg_62" aria-label="62"/>particular content management systems and blogging platforms (such as WordPress), web cameras, web application firewalls, and more. As of this writing, WhatWeb has over 1,800 plug-ins.</p>&#13;
<p class="TX">To install WhatWeb, simply run the following command in the terminal:</p>&#13;
<pre><code>$ <b>sudo apt-get install whatweb -y</b></code></pre>&#13;
<p class="TX">Verify that WhatWeb can operate successfully by running the <span class="SANS_TheSansMonoCd_W5Regular_11">whatweb</span> command with the <span class="SANS_TheSansMonoCd_W5Regular_11">-h</span> (help) argument:</p>&#13;
<pre><code>$ <b>whatweb -h</b>&#13;
&#13;
<var>--snip--</var>&#13;
WhatWeb - Next generation web scanner.&#13;
Developed by Andrew Horton (urbanadventurer) and Brendan Coles (bcoles).&#13;
Homepage: https://www.morningstarsecurity.com/research/whatweb&#13;
</code></pre>&#13;
<p class="TX">We’ll use WhatWeb later in the book when we perform reconnaissance activities.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec20">&#13;
<h3 class="H2" id="sec20"><span id="h2-50"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">RustScan</span></h3>&#13;
<p class="TNI1"><i>RustScan</i> is a lightning-fast port scanner written in the Rust programming language by Autumn (Bee) Skerritt (<span class="LinkTwitter">@bee_sec_san</span>). Some claim that RustScan can scan all 65,000 ports on a target in seconds!</p>&#13;
<p class="TX">We’ll use RustScan’s Docker version. To do this, we first need to pull its image onto the Kali machine:</p>&#13;
<pre><code>$ <b>sudo docker pull rustscan/rustscan:2.1.1</b></code></pre>&#13;
<p class="TX">Once you’ve built RustScan, run a quick test to ensure that it’s working properly:</p>&#13;
<pre><code>$ <b>sudo docker run --network=host -it --rm --name rustscan rustscan/rustscan:2.1.1</b>&#13;
&#13;
Fast Port Scanner built in Rust. WARNING Do not use this program against&#13;
sensitive infrastructure since the specified server may not be able to&#13;
handle this many socket connections at once.&#13;
<var>--snip--</var>&#13;
</code></pre>&#13;
<p class="TX">This command is quite long, as it relies on using Docker to start a dedicated RustScan container. In <span class="Xref">“Assigning Aliases to Hacking Tools” on <a href="#pg_66">page 66</a></span>, we’ll create a shortcut command that will run RustScan for us.</p>&#13;
<p class="TX">We will use RustScan for port scanning purposes in later chapters.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec21">&#13;
<h3 class="H2" id="sec21"><span id="h2-51"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Nuclei</span></h3>&#13;
<p class="TNI1"><i>Nuclei</i> is a vulnerability scanner written in the Go programming language by ProjectDiscovery, a company that builds popular open source hacking <span role="doc-pagebreak" epub:type="pagebreak" id="pg_63" aria-label="63"/>tools. Nuclei works by sending requests to targets defined by a YAML template file. The hacking community has published thousands of Nuclei templates supporting several protocols, including Transmission Control Protocol (TCP), Domain Name System (DNS), HTTP, raw sockets, file, headless, and more. You can find these templates at <i><a href="https://github.com/projectdiscovery/nuclei-templates">https://github.com/projectdiscovery/nuclei-templates</a></i>.</p>&#13;
<p class="TX">Install Nuclei by running the following installation command:</p>&#13;
<pre><code>$ <b>sudo apt install nuclei -y</b></code></pre>&#13;
<p class="TX">To verify that Nuclei is correctly installed, run a help command:</p>&#13;
<pre><code>$ <b>nuclei -h</b>&#13;
&#13;
Nuclei is a fast, template based vulnerability scanner focusing&#13;
on extensive configurability, massive extensibility and ease of use.&#13;
&#13;
Usage:&#13;
  nuclei [flags]&#13;
&#13;
Flags:&#13;
TARGET:&#13;
   -u, -target string[]       target URLs/hosts to scan&#13;
</code></pre>&#13;
<p class="TX">The first time you run Nuclei, it automatically creates a <i>nuclei-templates</i> directory in the user’s home folder and downloads all the publicly available Nuclei templates.</p>&#13;
<p class="TX">We will use Nuclei to find vulnerabilities in the lab, as well as for writing custom vulnerability checks.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec22">&#13;
<h3 class="H2" id="sec22"><span id="h2-52"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">dirsearch</span></h3>&#13;
<p class="TNI1"><i>dirsearch</i> is a multithreaded tool used to find common paths on web servers. dirsearch is available in Kali’s software repositories, so to install it, run the following command:</p>&#13;
<pre><code>$ <b>sudo apt install dirsearch -y</b></code></pre>&#13;
<p class="TX">To verify that dirsearch is correctly installed, run a help command:</p>&#13;
<pre><code>$ <b>dirsearch --help</b></code></pre>&#13;
<p class="TX">We will use dirsearch for information-gathering purposes in later chapters.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec23">&#13;
<h3 class="H2" id="sec23"><span id="h2-53"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Linux Exploit Suggester 2</span></h3>&#13;
<p class="TNI1">The <i>Linux Exploit Suggester 2</i> is a next-generation tool based on the original Linux Exploit Suggester. Written in Perl and developed by Jonathan Donas, <span role="doc-pagebreak" epub:type="pagebreak" id="pg_64" aria-label="64"/>it includes several exploits you can use to potentially compromise vulnerable Linux kernel versions.</p>&#13;
<p class="TX">To install it, first clone the repository to your <i>tools</i> directory:</p>&#13;
<pre><code>$ <b>cd ~/tools</b>&#13;
$<b> git clone https://github.com/jondonas/linux-exploit-suggester-2.git</b>&#13;
</code></pre>&#13;
<p class="TX">To verify that Linux Exploit Suggester 2 is installed correctly, run a help command:</p>&#13;
<pre><code>$<b> cd linux-exploit-suggester-2</b>&#13;
$<b> perl linux-exploit-suggester-2.pl -h</b>&#13;
</code></pre>&#13;
<p class="TX">We will use Linux Exploiter Suggester 2 to enumerate kernel exploits later in the book.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec24">&#13;
<h3 class="H2" id="sec24"><span id="h2-54"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Gitjacker</span></h3>&#13;
<p class="TNI1"><i>Gitjacker</i> is a data-extraction tool that targets web applications whose <i>.git</i> directory has been mistakenly uploaded. Before you can install Gitjacker, you’ll first need to install jq, a command line JSON processor:</p>&#13;
<pre><code>$ <b>sudo apt install jq -y</b></code></pre>&#13;
<p class="TX">Next, download the Gitjacker install script and move the executable to the tools directory:</p>&#13;
<pre><code>$ <b>cd ~</b>&#13;
$ <b>curl -s "https://raw.githubusercontent.com/liamg/gitjacker/master/scripts/install.sh" | bash</b>&#13;
$<b> mv ./bin/gitjacker ~/tools/gitjacker</b>&#13;
$<b> rmdir ./bin</b>&#13;
</code></pre>&#13;
<p class="TX">Finally, verify that Gitjacker is working properly by running the following help command:</p>&#13;
<pre><code>$ <b>~/tools/gitjacker -h</b></code></pre>&#13;
<p class="TX">We will use Gitjacker to identify misconfigured Git repositories later in the book.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec25">&#13;
<h3 class="H2" id="sec25"><span id="h2-55"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">pwncat</span></h3>&#13;
<p class="TNI1"><i>pwncat</i> is a Python-based command-and-control library for capturing and interacting with remote shells, developed by Caleb Stewart and John Hammond. Once pwncat receives a shell connection from a remote compromised host, it acts as an exploitation platform from which commands can be sent and attacks can be launched.</p>&#13;
<p class="TX">To install pwncat, run this command:</p>&#13;
<pre><code>$ <b>pip3 install pwncat-cs</b></code></pre>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_65" aria-label="65"/>To verify that the library was installed correctly, use the following:</p>&#13;
<pre><code>$ <b>pwncat-cs -h</b>&#13;
&#13;
usage: pwncat-cs [-h] [--version] [--download-plugins] [--config CONFIG]&#13;
                 [--ssl] [--ssl-cert SSL_CERT] [--ssl-key SSL_KEY]&#13;
                 [--identity IDENTITY] [--listen] [--platform PLATFORM]&#13;
                 [--port PORT] [--list] [--verbose]&#13;
                 [[protocol://][user[:password]@][host][:port]] [port]&#13;
</code></pre>&#13;
<p class="TX">We will use pwncat for penetration-testing purposes later in the book. In some cases, pwncat-cs may be found under <i>~/.local/bin</i> and can be called directly by its full path: <i>~/.local/bin/pwncat-cs</i>.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec26">&#13;
<h3 class="H2" id="sec26"><span id="h2-56"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">LinEnum</span></h3>&#13;
<p class="TNI1"><i>LinEnum</i> is a bash script written by Owen Shearing for enumerating local information on a Linux host. We can use <span class="SANS_TheSansMonoCd_W5Regular_11">wget</span> to grab the script from its GitHub repository:</p>&#13;
<pre><code>$ <b>cd ~/tools</b>&#13;
$ <b>wget https://raw.githubusercontent.com/rebootuser/LinEnum/master/LinEnum.sh</b>&#13;
</code></pre>&#13;
<p class="TX">To verify that the script is working correctly, make it executable and run the following help command:</p>&#13;
<pre><code>$ <b>chmod u+x LinEnum.sh</b>&#13;
$ <b>./LinEnum.sh -h</b>&#13;
&#13;
#########################################################&#13;
# Local Linux Enumeration &amp; Privilege Escalation Script #&#13;
#########################################################&#13;
# www.rebootuser.com | @rebootuser&#13;
&#13;
# Example: ./LinEnum.sh -k keyword -r report -e /tmp/ -t&#13;
&#13;
OPTIONS:&#13;
-k      Enter keyword&#13;
-e      Enter export location&#13;
-s      Supply user password for sudo checks (INSECURE)&#13;
-t      Include thorough (lengthy) tests&#13;
-r      Enter report name&#13;
-h      Displays this help text&#13;
&#13;
Running with no options = limited scans/no output file&#13;
#########################################################&#13;
</code></pre>&#13;
<p class="TX">We will use LinEnum to enumerate systems for misconfigurations later in the book.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec27">&#13;
<h3 class="H2" id="sec27"><span id="h2-57"/><span role="doc-pagebreak" epub:type="pagebreak" id="pg_66" aria-label="66"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">unix-privesc-check</span></h3>&#13;
<p class="TNI1">The <i>unix-privesc-check</i> shell script, written by pentestmonkey, collects information from a host in an attempt to find misconfigurations and ways to escalate privileges. The script is written to support many flavors of Linux and Unix systems and does not require any dependencies, which makes it convenient to run.</p>&#13;
<p class="TX">By default, the script comes bundled with Kali, and you should find it in <i>/usr/bin/unix-privesc-check</i>:</p>&#13;
<pre><code>$ <b>which unix-privesc-check</b>&#13;
&#13;
/usr/bin/unix-privesc-check&#13;
</code></pre>&#13;
<p class="TX">Optionally, you can create a copy of it in the <i>tools</i> directory for easier access, should you need to copy it later to any of the lab’s machines:</p>&#13;
<pre><code>$ <b>cp /usr/bin/unix-privesc-check ~/tools</b></code></pre>&#13;
<p class="TX">If the script isn’t available on your Kali machine, you can download it directly from APT:</p>&#13;
<pre><code>$ <b>apt-get install unix-privesc-check -y</b></code></pre>&#13;
<p class="TX">Verify that you can run it successfully with the following command:</p>&#13;
<pre><code>$ <b>unix-privesc-check -h</b>&#13;
&#13;
unix-privesc-check (http://pentestmonkey.net/tools/unix-privesc-check)&#13;
&#13;
Usage: unix-privesc-check {standard | detailed}&#13;
&#13;
"standard" mode: Speed-optimised check of lots of security settings.&#13;
<var>--snip--</var>&#13;
</code></pre>&#13;
<p class="TX">We will use <i>unix-privesc-check</i> to identify privilege escalation opportunities later in the book.</p>&#13;
</section>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec28">&#13;
<h2 class="H1" id="sec28"><span id="h1-26"/><span class="SANS_Futura_Std_Bold_B_11">Assigning Aliases to Hacking Tools</span></h2>&#13;
<p class="TNI1">Tools that are installed through third-party repositories such as GitHub sometimes won’t have setup files that make running them easier. We can assign these tools bash aliases as shorthand references so that we won’t need to enter the full directory path every time we run them.</p>&#13;
<p class="TX">Assign custom aliases by using the following commands. These commands will be written to your <i>~/.bashrc</i> file, which will execute when you open a new terminal session:</p>&#13;
<pre><code><span role="doc-pagebreak" epub:type="pagebreak" id="pg_67" aria-label="67"/>$ <b>echo "alias rustscan='docker run --network=host -it --rm --name rustscan rustscan/rustscan:</b>&#13;
<b>2.1.1'" &gt;&gt; "/home/kali/.bashrc"</b>&#13;
&#13;
$ <b>echo "alias gitjacker='/home/kali/tools/gitjacker'" &gt;&gt; ~/.bashrc</b>&#13;
</code></pre>&#13;
<p class="TX">RustScan and Gitjacker now have aliases.</p>&#13;
<p class="TX">At this point, you should have a fully functioning bash hacking lab. Now would be a good time to take a snapshot of your Kali virtual machine so you can restore it to this clean state. Taking snapshots regularly is a good idea, especially whenever you make significant configuration changes or deploy new tools to your virtual lab.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec29">&#13;
<h2 class="H1" id="sec29"><span id="h1-27"/><span class="SANS_Futura_Std_Bold_B_11">Summary</span></h2>&#13;
<p class="TNI1">In this chapter, you built your hacking lab, which consists of a dedicated Kali virtual machine running several intentionally vulnerable Docker containers and hacking utilities. We also discussed managing your lab environment by tearing it down, cleaning it up, and rebuilding it.</p>&#13;
<p class="TX">We’ll use this lab in all hands-on exercises moving forward. If you encounter problems, we encourage you to keep an eye on the book’s GitHub repository (<i><a href="https://github.com/dolevf/Black-Hat-Bash">https://github.com/dolevf/Black-Hat-Bash</a></i>), where we maintain the source code responsible for keeping your lab up to date. In the next chapter, you’ll use these tools to perform reconnaissance and gather information about remote targets.</p>&#13;
</section>&#13;
</section>&#13;
</body></html>