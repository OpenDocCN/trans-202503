<html><head></head><body><div class="chapter" title="Chapter&#xA0;2.&#xA0;Sprite Animation Using jQuery and CSS"><div class="titlepage"><div><div><h1 class="title"><a id="sprite_animation_using_jquery_and_css"/>Chapter 2. Sprite Animation Using jQuery and CSS</h1></div></div></div><p><a id="iddle1052" class="indexterm"/><a id="iddle1200" class="indexterm"/><a id="iddle1205" class="indexterm"/><a id="iddle1463" class="indexterm"/><a id="iddle1471" class="indexterm"/><a id="iddle1654" class="indexterm"/><a id="iddle1663" class="indexterm"/><a id="iddle1695" class="indexterm"/><a id="iddle1707" class="indexterm"/>In this chapter we’ll dive into moving sprites around the screen. Animation is one of the most common tasks in game development, and the principles you’ll learn in animating a simple game apply to most game types.</p><p>Although much of the buzz around HTML5 games focuses on the <code class="literal">canvas</code> element, you can implement many games just as well using more traditional HTML, CSS, and JavaScript techniques, which are the focus of this chapter. They’re useful game development lessons in their own right, and they’ll be advantageous when we look into using the <code class="literal">canvas</code> element later. Games developed using HTML, JavaScript, and CSS techniques, often referred to as <span class="emphasis"><em>DOM-based games</em></span>, also have much wider browser compatibility. Some older browsers still in use have no <code class="literal">canvas</code> support and also are unlikely to support CSS3 transformations and transitions; therefore, we’ll use older CSS features.</p><p><a id="iddle1237" class="indexterm"/><a id="iddle1238" class="indexterm"/><a id="iddle1257" class="indexterm"/><a id="iddle1269" class="indexterm"/><a id="iddle1291" class="indexterm"/><a id="iddle1297" class="indexterm"/><a id="iddle1298" class="indexterm"/><a id="iddle1339" class="indexterm"/><a id="iddle1633" class="indexterm"/><a id="iddle1643" class="indexterm"/><a id="iddle1867" class="indexterm"/><a id="iddle1868" class="indexterm"/><a id="iddle2244" class="indexterm"/><a id="iddle2245" class="indexterm"/><a id="iddle2644" class="indexterm"/><a id="iddle2657" class="indexterm"/>The key mechanic of the <span class="emphasis"><em>Bubble Shooter</em></span> game is, of course, shooting bubbles, and the bubble that the player fires triggers every bubble-popping effect. We’ll start by moving a fired bubble based on user input (a mouse click).</p><p>First, we need a way to move a bubble from a starting point A to an ending point B, and that bubble needs to move in a straight line at a constant velocity. Second, we need to determine exactly where points A and B are located. Because the player always fires bubbles from the same position, the starting coordinates (point A) will be the same for each new bubble. Point B will be the coordinates of the user’s mouse click when they fire the bubble, so we must retrieve those coordinates. To start, we’ll implement that movement from A to B.</p><p>In the final game, the bubble won’t stop when it reaches the click coordinates but rather will continue until it collides with another bubble or moves off the edge of the screen. We’ll deal with collisions later when we more fully develop the game display.</p><p>When we have movement from point to point, we can then extrapolate a bubble’s path past the user’s click and continue to move the bubble forward in the same direction. To find that path, we need to calculate a firing angle based on the relative positions of point A and point B, as shown in <a class="xref" href="ch02.html#moving_the_bubble_along_a_vector" title="Figure 2-1. Moving the bubble along a vector">Figure 2-1</a>.</p><div class="figure"><a id="moving_the_bubble_along_a_vector"/><div class="figure-contents"><div class="mediaobject"><a id="med_id00007"/><img src="httpatomoreillycomsourcenostarchimages2184501.png" alt="Moving the bubble along a vector"/></div></div><p class="title">Figure 2-1. Moving the bubble along a vector</p></div><p><a id="iddle1014" class="indexterm"/><a id="iddle1147" class="indexterm"/><a id="iddle1353" class="indexterm"/><a id="iddle1464" class="indexterm"/><a id="iddle1522" class="indexterm"/><a id="iddle1679" class="indexterm"/><a id="iddle1776" class="indexterm"/><a id="iddle1892" class="indexterm"/><a id="iddle2032" class="indexterm"/><a id="iddle2516" class="indexterm"/><a id="iddle2518" class="indexterm"/><a id="iddle2520" class="indexterm"/>Given that firing angle, we can send a bubble in a particular direction as far as needed. Later, we can calculate how far it needs to move by determining any collisions. For now, we’ll just define <span class="emphasis"><em>as far as needed</em></span> as a point sufficiently far away to move the bubble off the screen.</p><div class="sect1" title="Principles of CSS Sprites"><div class="titlepage"><div><div><h1 class="title"><a id="principles_of_css_sprites"/>Principles of CSS Sprites</h1></div></div></div><p>A <span class="emphasis"><em>sprite</em></span> is a two-dimensional game element that is part of a larger scene but can move around without affecting the background data. At the moment, the bubble at point A is the only sprite.</p><p>At its simplest, in this DOM-based approach, a sprite is an HTML block (often a set of <code class="literal">div</code> tags) with CSS styling applied. Due to the way a browser renders HTML, moving a sprite without altering the rest of the screen is easy to do. An HTML element that is absolutely positioned with CSS is rendered independently of the surrounding HTML elements. The browser paints all the objects to the screen and handles layering and overlaps. If we remove an object, the browser knows it needs to display whatever is underneath. This HTML and CSS sprite manipulation property isn’t free with <code class="literal">canvas</code> development, but as you’ll see when we learn more about the <code class="literal">canvas</code> element in <a class="xref" href="ch06.html" title="Chapter 6. Rendering Canvas Sprites">Chapter 6</a>, it’s one of the features that makes DOM game development an ideal place to start and a great tool for rapidly prototyping games.</p><div class="sect2" title="Creating the Game Board"><div class="titlepage"><div><div><h2 class="title"><a id="creating_the_game_board"/>Creating the Game Board</h2></div></div></div><p>In the <span class="emphasis"><em>Bubble Shooter</em></span> game, the bubbles will all be sprites so we can move them around the screen as self-contained elements. We’ll create the first sprite soon by creating one of the bubbles that will sit in the display. But first we need a container for the game board within the area where all the bubble action happens. We’ll put this container in a <code class="literal">div</code> called <code class="literal">"board"</code>, so add the new <code class="literal">div</code> to <span class="emphasis"><em>index.html</em></span>:</p><p><span class="emphasis"><em>index.html</em></span></p><a id="pro_id00026"/><pre class="programlisting">&lt;div id="game"&gt;
  <span class="strong"><strong>&lt;div id="board"&gt;&lt;/div&gt;</strong></span>
&lt;/div&gt;</pre><p>Next, we’ll position the board with CSS. The game board will be centered within the fixed-width display, so we’ll make a 760-pixel-wide board and position it 120 pixels from the left edge of the <code class="literal">game div</code>, which is positioned to the left of the window. Add the definition for <code class="literal">#board</code> to <span class="emphasis"><em>main.css</em></span> after the definition for <code class="literal">#game</code>:</p><p><span class="emphasis"><em>main.css</em></span></p><a id="pro_id00027"/><pre class="programlisting">body
{
  margin: 0;
}
<span class="emphasis"><em>--snip--</em></span>
#game
{
--snip--
}
<span class="strong"><strong>#board</strong></span>
<span class="strong"><strong>{</strong></span>
  <span class="strong"><strong>position: absolute;</strong></span>
  <span class="strong"><strong>left: 120px;</strong></span>
  <span class="strong"><strong>top: 0;</strong></span>
  <span class="strong"><strong>width: 760px;</strong></span>
  <span class="strong"><strong>height: 620px;</strong></span>
<span class="strong"><strong>}</strong></span></pre><p><a id="iddle1276" class="indexterm"/><a id="iddle1317" class="indexterm"/><a id="iddle1347" class="indexterm"/><a id="iddle1366" class="indexterm"/><a id="iddle2360" class="indexterm"/><a id="iddle2588" class="indexterm"/>We also need some CSS to describe a bubble’s starting position, width, and height. The player’s current bubble will be placed in the bottom center of the play area and will be 50 pixels square. We’ll assign the user’s current ready-to-fire bubble the CSS class of <code class="literal">cur_bubble</code> and define its positioning and appearance in a style sheet. We’ll put game elements in their own CSS file so we can easily distinguish them from the various user interface elements, such as dialog boxes and buttons.</p><p>Create a new file in the <span class="emphasis"><em>_css</em></span> directory, call it <span class="emphasis"><em>game.css</em></span>, and put the following code in it:</p><p><span class="emphasis"><em>game.css</em></span></p><a id="pro_id00028"/><pre class="programlisting">.bubble
{
  position: absolute;
  width: 50px;
  height: 50px;
}
.cur_bubble
{
  left: 360px;
  top: 470px;
}</pre><p>Each bubble will sit inside a 50-pixel square. We could just fill the game area completely with bubbles, but the trick is to provide a large playing board without making the game too long lasting. After some trial and error, I chose to use 16 bubbles, which should fit in the game area width and still leave a bit of border.</p><p>We also need to link <span class="emphasis"><em>game.css</em></span> to the style sheet file in the HTML header, so add that link to <span class="emphasis"><em>index.html</em></span> after the link to <span class="emphasis"><em>main.css</em></span>:</p><p><span class="emphasis"><em>index.html</em></span></p><a id="pro_id00029"/><pre class="programlisting">&lt;head&gt;
  &lt;meta charset="UTF-8" /&gt;
  &lt;title&gt;Bubble Shooter&lt;/title&gt;
  &lt;link href="_css/main.css" rel="stylesheet" /&gt;
  <span class="strong"><strong>&lt;link href="_css/game.css" rel="stylesheet" /&gt;</strong></span></pre><p><a id="iddle1091" class="indexterm"/><a id="iddle1092" class="indexterm"/><a id="iddle1244" class="indexterm"/><a id="iddle1245" class="indexterm"/><a id="iddle1251" class="indexterm"/><a id="iddle1252" class="indexterm"/><a id="iddle1254" class="indexterm"/><a id="iddle1255" class="indexterm"/><a id="iddle1332" class="indexterm"/><a id="iddle1333" class="indexterm"/><a id="iddle1354" class="indexterm"/><a id="iddle1363" class="indexterm"/><a id="iddle1446" class="indexterm"/><a id="iddle1447" class="indexterm"/><a id="iddle1680" class="indexterm"/><a id="iddle1777" class="indexterm"/><a id="iddle1879" class="indexterm"/><a id="iddle2046" class="indexterm"/><a id="iddle2323" class="indexterm"/><a id="iddle2324" class="indexterm"/><a id="iddle2340" class="indexterm"/><a id="iddle2341" class="indexterm"/><a id="iddle2519" class="indexterm"/><a id="iddle2523" class="indexterm"/><a id="iddle2527" class="indexterm"/><a id="iddle2528" class="indexterm"/><a id="iddle2542" class="indexterm"/><a id="iddle2543" class="indexterm"/>The bubble we want to fire doesn’t yet display on the screen, so let’s add an image to the filesystem and then use some CSS to display it.</p></div><div class="sect2" title="Adding Sprites"><div class="titlepage"><div><div><h2 class="title"><a id="adding_sprites"/>Adding Sprites</h2></div></div></div><p><a class="xref" href="ch02.html#our_first_bubble_sprite_graphic" title="Figure 2-2. Our first bubble sprite graphic">Figure 2-2</a> shows how a single bubble will appear (without coloring). The appearance of the bubble will be rendered as a background image within the board <code class="literal">div</code> element.</p><div class="figure"><a id="our_first_bubble_sprite_graphic"/><div class="figure-contents"><div class="mediaobject"><a id="med_id00008"/><img src="httpatomoreillycomsourcenostarchimages2184503.png.jpg" alt="Our first bubble sprite graphic"/></div></div><p class="title">Figure 2-2. Our first bubble sprite graphic</p></div><p>We’ll use four different bubble colors, so let’s make all four colors of bubbles at the same time. Any four colors will do, as long as they’re sufficiently distinct. As with other assets, which are generally images and sound files, we’ll store the colored bubbles in an underscored folder. Let’s call this one <span class="emphasis"><em>_img</em></span>.</p><p>To speed up loading time and keep file management simple, we’ll put the images for all four bubble types into a single PNG file. You can see the complete image in <a class="xref" href="ch02.html#single_image_file_containing_all_animati" title="Figure 2-3. A single image file containing all animation states for four bubble types">Figure 2-3</a>.</p><div class="figure"><a id="single_image_file_containing_all_animati"/><div class="figure-contents"><div class="mediaobject"><a id="med_id00009"/><img src="httpatomoreillycomsourcenostarchimages2184505.png.jpg" alt="A single image file containing all animation states for four bubble types"/></div></div><p class="title">Figure 2-3. A single image file containing all animation states for four bubble types</p></div><p>The PNG file (<span class="emphasis"><em>bubble_sprite_sheet.png</em></span>) contains not only the base state for the four bubbles but also animations of the popping process that we’ll use later. The standard bubble image is shown in the left column; the three popping animation stages are shown in the second, third, and fourth columns. Because we have four different bubbles, we’ll create CSS definitions that let us display whichever color we want by shifting the position of the background image up or down. The ability to use a single image to render multiple sprites is the reason we’re using a CSS background image rather than placing <code class="literal">&lt;img&gt;</code> tags directly into the DOM; as a result, the browser needs <a id="iddle1120" class="indexterm"/><a id="iddle1124" class="indexterm"/><a id="iddle2367" class="indexterm"/><a id="iddle2589" class="indexterm"/>to download only one image file, which speeds up initialization time. Also, the animation frames for popping are preloaded, so we shouldn’t have any nasty pauses while loading images later in the game.</p><p>Although we’re using four bubble colors, the game doesn’t need to know the colors—we might even change the color choices later—but it does need a way to reference them. We’ll number the bubble types from zero to three to represent the four colors.</p><p>We can use the base CSS class of <code class="literal">.bubble</code> for properties that are common to all bubbles and add an additional class to the HTML elements when we need to specify the bubble’s type (which sets its color). Modify <span class="emphasis"><em>game.css</em></span> as follows:</p><p><span class="emphasis"><em>game.css</em></span></p><a id="pro_id00030"/><pre class="programlisting">.bubble
{
  position: absolute;
  width: 50px;
  height: 50px;
  <span class="strong"><strong>background-image: url("../_img/bubble_sprite_sheet.png");</strong></span>
}
.cur_bubble
{
  left: 360px;
  top: 470px;
}
<span class="strong"><strong>.bubble_0</strong></span>
<span class="strong"><strong>{</strong></span>
  <span class="strong"><strong>background-position: 0 0;</strong></span>
<span class="strong"><strong>}</strong></span>
<span class="strong"><strong>.bubble_1</strong></span>
<span class="strong"><strong>{</strong></span>
  <span class="strong"><strong>background-position: 0 -50px;</strong></span>
<span class="strong"><strong>}</strong></span>
<span class="strong"><strong>.bubble_2</strong></span>
<span class="strong"><strong>{</strong></span>
  <span class="strong"><strong>background-position: 0 -100px;</strong></span>
<span class="strong"><strong>}</strong></span>
<span class="strong"><strong>.bubble_3</strong></span>
<span class="strong"><strong>{</strong></span>
  <span class="strong"><strong>background-position: 0 -150px;</strong></span>
<span class="strong"><strong>}</strong></span></pre><p>Now, when we want to render the four bubbles, we can just add the correct classes to a <code class="literal">div</code> element, and the <code class="literal">background-position</code> property should display the appropriate image. If we want to hard-code a bubble of the last type into the DOM, we’d add the following:</p><a id="pro_id00031"/><pre class="programlisting">&lt;div class="bubble bubble_3"&gt;&lt;/div&gt;</pre><p>A bubble of the first type would be</p><a id="pro_id00032"/><pre class="programlisting">&lt;div class="bubble bubble_0"&gt;&lt;/div&gt;</pre><p><a id="iddle1041" class="indexterm"/><a id="iddle1267" class="indexterm"/><a id="iddle1277" class="indexterm"/><a id="iddle1355" class="indexterm"/><a id="iddle1368" class="indexterm"/><a id="iddle1375" class="indexterm"/><a id="iddle1396" class="indexterm"/><a id="iddle1754" class="indexterm"/><a id="iddle1763" class="indexterm"/><a id="iddle1778" class="indexterm"/><a id="iddle2231" class="indexterm"/>Although we currently have a definition for the bubble in CSS, we have no HTML to display it on the screen. Instead of hard-coding the bubbles, we’ll generate them through JavaScript. But before we start animating a bubble, we need to create and render one, which is the focus of the next section.</p></div></div><div class="sect1" title="Animation and the Bubble Class"><div class="titlepage"><div><div><h1 class="title"><a id="animation_and_the_bubble_class"/>Animation and the Bubble Class</h1></div></div></div><p>Because the bubble is one of the main elements of the game, we’ll create a separate JavaScript class for it. We don’t yet know all the properties this class might need, but for every bubble object we need to manipulate in code, an onscreen element will display; therefore, we’ll create a property to reference that. We’ll call it the <code class="literal">sprite</code> property, and it will store a reference to the jQuery object that we use to manipulate the DOM element.</p><p>Put the following in a separate file called <span class="emphasis"><em>bubble.js</em></span> in the <span class="emphasis"><em>_js</em></span> folder, and add the new file to the <code class="literal">Modernizr.load</code> call in <span class="emphasis"><em>index.html</em></span> just after <span class="emphasis"><em>ui.js</em></span>:</p><p><span class="emphasis"><em>bubble.js</em></span></p><a id="pro_id00033"/><pre class="programlisting">  var BubbleShoot = window.BubbleShoot || {};
  BubbleShoot.Bubble = (function($){
    var Bubble = function(sprite){
      var that = this;
➊    this.getSprite = function(){ return sprite;};
    };
➋  Bubble.create = function(){
      var sprite = $(document.createElement("div"));
      sprite.addClass("bubble");
      sprite.addClass("bubble_0");
      var bubble = new Bubble(sprite);
      return bubble;
    };
    return Bubble;
  })(jQuery);</pre><p>We have only one argument to pass into the constructor, which is a reference to the jQuery <code class="literal">sprite</code> object that will be created within a call to the <code class="literal">Bubble.create</code> function ➋. This function currently creates only one type of sprite due to the assigning of the <code class="literal">bubble_0</code> CSS class. Currently, only one method is in the class definition ➊, and it returns the <code class="literal">sprite</code> object. When we want to create a bubble, rather than invoking <code class="literal">BubbleShoot.Bubble</code> directly, we’ll call <code class="literal">BubbleShoot.Bubble.create</code>. As a result, we can ensure that all components of a bubble are instantiated correctly and minimize code duplication.</p><p>Now we can create <code class="literal">Bubble</code> objects, and the document element is created at the same time. However, the bubble still won’t be part of the visible DOM because it hasn’t been inserted into the document. To handle this, we’ll make a function inside <code class="literal">Game</code> to create new bubbles and add the CSS class of <code class="literal">cur_bubble</code> to the newly created DOM element.</p><p><a id="iddle1299" class="indexterm"/><a id="iddle1302" class="indexterm"/><a id="iddle1459" class="indexterm"/><a id="iddle1548" class="indexterm"/><a id="iddle1644" class="indexterm"/><a id="iddle1821" class="indexterm"/><a id="iddle1825" class="indexterm"/><a id="iddle1869" class="indexterm"/><a id="iddle1932" class="indexterm"/><a id="iddle1945" class="indexterm"/><a id="iddle1986" class="indexterm"/><a id="iddle2078" class="indexterm"/><a id="iddle2094" class="indexterm"/><a id="iddle2127" class="indexterm"/><a id="iddle2551" class="indexterm"/><a id="iddle2658" class="indexterm"/>At any time in the game, only a single bubble is on the screen that’s ready for the player to fire, so we’ll keep a reference to it, called <code class="literal">curBubble</code>, in a variable within <code class="literal">Game</code>. To finish this step of bubble creation, add the lines in bold to <span class="emphasis"><em>game.js</em></span>:</p><p><span class="emphasis"><em>game.js</em></span></p><a id="pro_id00034"/><pre class="programlisting">  var BubbleShoot = window.BubbleShoot || {};
  BubbleShoot.Game = (function($){
    var Game = function(){
➊    <span class="strong"><strong>var curBubble;</strong></span>
      this.init = function(){
        $(".but_start_game").bind("click",startGame);
      };
      var startGame = function(){
        $(".but_start_game").unbind("click");
        BubbleShoot.ui.hideDialog();
➋      <span class="strong"><strong>curBubble = getNextBubble();</strong></span>
      };
➌    <span class="strong"><strong>var getNextBubble = function(){</strong></span>
➍      <span class="strong"><strong>var bubble = BubbleShoot.Bubble.create();</strong></span>
➎      <span class="strong"><strong>bubble.getSprite().addClass("cur_bubble");</strong></span>
➏      <span class="strong"><strong>$("#board").append(bubble.getSprite());</strong></span>
        <span class="strong"><strong>return bubble;</strong></span>
      <span class="strong"><strong>};</strong></span>
    };
    return Game;
  })(jQuery);</pre><p>At the top of the <code class="literal">Game</code> definition, we define <code class="literal">curBubble</code> ➊, which will exist only within the scope of the <code class="literal">Game</code> object. This empty variable is declared here and is set when the user clicks the New Game button, which calls <code class="literal">startGame</code>. Here, <code class="literal">curBubble</code> is set to the value returned by <code class="literal">getNextBubble</code> ➋. The function <code class="literal">getNextBubble</code> ➌ calls <code class="literal">BubbleShoot.Bubble.create</code> ➍, which returns an instance of the <code class="literal">Bubble</code> class and then adds the CSS class <code class="literal">cur_bubble</code> ➎ to the DOM element. Finally, the DOM element is appended to the board <code class="literal">div</code> element ➏.</p><p>Reload the page and click <span class="strong"><strong>New Game</strong></span>. At the bottom center of the screen you should see a bubble appear. The bubble can’t move anywhere yet, but we’ll change that in the next section when we add some simple animation.</p><div class="sect2" title="Calculating Angle and Direction"><div class="titlepage"><div><div><h2 class="title"><a id="calculating_angle_and_direction"/>Calculating Angle and Direction</h2></div></div></div><p>To determine which direction to fire the bubble in, we need to find out where the mouse is at the moment the user clicks. We can do this by interrogating the event object that will fire in response to the <code class="literal">click</code> event. The <code class="literal">Game</code> controller needs to know the angle to fire the bubble and what the results of the game display should be. To avoid adding interface code to the controller, the <code class="literal">ui</code> object will handle the movement process, which will follow these steps:</p><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p>Find the coordinates of the mouse click.</p></li><li class="listitem"><p>Calculate a vector from the bubble’s starting point to the click point.</p></li><li class="listitem"><p><a id="iddle1134" class="indexterm"/><a id="iddle1421" class="indexterm"/><a id="iddle1554" class="indexterm"/><a id="iddle1818" class="indexterm"/><a id="iddle1919" class="indexterm"/><a id="iddle2126" class="indexterm"/><a id="iddle2246" class="indexterm"/><a id="iddle2381" class="indexterm"/><a id="iddle2626" class="indexterm"/><a id="iddle2628" class="indexterm"/><a id="iddle2632" class="indexterm"/>Extend that vector by a sufficient length to move the bubble off the game screen.</p></li><li class="listitem"><p>Move the bubble to the end of the vector.</p></li></ol></div><p>An example of a bubble’s trajectory was shown in <a class="xref" href="ch02.html#moving_the_bubble_along_a_vector" title="Figure 2-1. Moving the bubble along a vector">Figure 2-1</a>.</p><p>At this point, the movement process assumes that the bubble won’t collide with anything, which is the feature we’ll tackle first.</p><p>In the <code class="literal">Game</code> function definition, create the <code class="literal">clickGameScreen</code> function (right after the <code class="literal">getNextBubble</code> function) and add an event binding to <code class="literal">startGame</code>, as shown here:</p><p><span class="emphasis"><em>game.js</em></span></p><a id="pro_id00035"/><pre class="programlisting">  var BubbleShoot = window.BubbleShoot || {};
  BubbleShoot.Game = (function($){
    var Game = function(){
      var curBubble;
      --<span class="emphasis"><em>snip</em></span>--
      var startGame = function(){
        $(".but_start_game").unbind("click");
        BubbleShoot.ui.hideDialog();
        curBubble = getNextBubble();
        <span class="strong"><strong>$("#game").bind("click",clickGameScreen);</strong></span>
      };
    <span class="emphasis"><em>--snip--</em></span>
➊    <span class="strong"><strong>var clickGameScreen = function(e){</strong></span>
        <span class="strong"><strong>var angle = BubbleShoot.ui.getBubbleAngle(curBubble.getSprite(),e);</strong></span>
      <span class="strong"><strong>};</strong></span>
    };
    return Game;
  })(jQuery);</pre><p>The function <code class="literal">clickGameScreen</code> ➊ will be called in response to the user clicking the screen. As part of the jQuery event handling, it will receive an event object <code class="literal">e</code> that contains useful data about the clicked object, including the coordinates of the click. This function also has a call to <code class="literal">BubbleShoot.ui.getBubbleAngle</code>, which will calculate a firing angle for the bubble using the event object’s click coordinates. The value returned will be an angle, in radians, either to the left or right of the vertical center line of the bubble. Let’s write that code now.</p><p>In <span class="emphasis"><em>ui.js</em></span>, add the following constant at the top of the <code class="literal">ui</code> object and new methods after <code class="literal">hideDialog</code>:</p><p><span class="emphasis"><em>ui.js</em></span></p><a id="pro_id00036"/><pre class="programlisting">  var BubbleShoot = window.BubbleShoot || {};
  BubbleShoot.ui = (function($){
    var ui = {
➊    <span class="strong"><strong>BUBBLE_DIMS : 44,</strong></span>
      init : function(){
      },
      hideDialog : function (){
        $(".dialog").fadeOut(300);
      },
      <span class="strong"><strong>getMouseCoords : function(e){</strong></span>
➋      <span class="strong"><strong>var coords = {x : e.pageX, y : e.pageY};</strong></span>
          <span class="strong"><strong>return coords;</strong></span>
      <span class="strong"><strong>},</strong></span>
      <span class="strong"><strong>getBubbleCoords : function(bubble){</strong></span>
➌      <span class="strong"><strong>var bubbleCoords = bubble.position();</strong></span>
        <span class="strong"><strong>bubbleCoords.left += ui.BUBBLE_DIMS/2;</strong></span>
        <span class="strong"><strong>bubbleCoords.top += ui.BUBBLE_DIMS/2;</strong></span>
        <span class="strong"><strong>return bubbleCoords;</strong></span>
      <span class="strong"><strong>},</strong></span>
      <span class="strong"><strong>getBubbleAngle : function(bubble,e){</strong></span>
        <span class="strong"><strong>var mouseCoords = ui.getMouseCoords(e);</strong></span>
        <span class="strong"><strong>var bubbleCoords = ui.getBubbleCoords(bubble);</strong></span>
        <span class="strong"><strong>var gameCoords = $("#game").position();</strong></span>
        <span class="strong"><strong>var boardLeft = 120;</strong></span>
➎      <span class="strong"><strong>var angle = Math.atan((</strong></span>➍<span class="strong"><strong>mouseCoords.x - bubbleCoords.left - boardLeft)</strong></span>
          <span class="strong"><strong>/ (</strong></span>➍<span class="strong"><strong>bubbleCoords.top + gameCoords.top - mouseCoords.y));</strong></span>
➏      <span class="strong"><strong>if(mouseCoords.y &gt; bubbleCoords.top + gameCoords.top){</strong></span>
          <span class="strong"><strong>angle += Math.PI;</strong></span>
        <span class="strong"><strong>}</strong></span>
        <span class="strong"><strong>return angle;</strong></span>
      <span class="strong"><strong>}</strong></span>
    };
    return ui;
  })(jQuery);</pre><p><a id="iddle1239" class="indexterm"/><a id="iddle1258" class="indexterm"/><a id="iddle1292" class="indexterm"/><a id="iddle1634" class="indexterm"/><a id="iddle2189" class="indexterm"/><a id="iddle2313" class="indexterm"/><a id="iddle2352" class="indexterm"/><a id="iddle2605" class="indexterm"/><a id="iddle2627" class="indexterm"/><code class="literal">BUBBLE_DIMS</code> ➊ is the width (and height) of a bubble sprite in the DOM. This constant allows us to calculate the offset to the center of the element, which means we can translate to the (top, left) coordinates that CSS uses. In game programming, you’ll often want to work with the center coordinates of an object when you change its position, whereas when rendering, you’ll use the (top, left) coordinates.</p><p>This new code fetches the coordinates of the player’s mouse click ➋ by retrieving two properties that jQuery passes us with the event object <code class="literal">e</code>. We also need the starting bubble’s coordinates, so the next method ➌ will do that job using another jQuery method. When we have the two coordinate pairs, we can calculate the relative <span class="emphasis"><em>x</em></span>/<span class="emphasis"><em>y</em></span> offset between them ➍. Now, we can use the tangent trigonometry function ➎ to calculate the angle based on the <span class="emphasis"><em>x</em></span>/<span class="emphasis"><em>y</em></span> offset. Then, if the click is below the center line of the bubble ➏, we add pi (which is 180 degrees, but JavaScript trigonometry is always in radians) to the angle so we can describe a full circle.</p><p>To calculate the angle, we’ve used some trigonometry, which you’ll become more familiar with as you build games, if you’re not already. The <code class="literal">Math.atan</code> method retrieves angles offset from the vertical with positive numbers to the right and negative numbers to the left of vertical. The returned angle will be a value in radians ranging from negative to positive pi.</p></div><div class="sect2" title="Firing and Animating Bubbles"><div class="titlepage"><div><div><h2 class="title"><a id="firing_and_animating_bubbles"/>Firing and Animating Bubbles</h2></div></div></div><p>Now that we know the angle at which to fire a bubble, we can send it off the screen. Let’s assume we’ll fire it at 1000 pixels—which is enough to move it outside the game area—and then see the results in action.</p><div class="sidebar"><a id="quick_trigonometry_refresher"/><p class="title">A Quick Trigonometry Refresher</p><p><a id="iddle1300" class="indexterm"/><a id="iddle1397" class="indexterm"/><a id="iddle1555" class="indexterm"/><a id="iddle1870" class="indexterm"/><a id="iddle1920" class="indexterm"/><a id="iddle2247" class="indexterm"/><a id="iddle2621" class="indexterm"/><a id="iddle2659" class="indexterm"/>We can calculate the angle we want to fire the bubble with some trigonometry using the inverse tangent function. In <a class="xref" href="ch02.html#calculating_the_firing_angle_manually" title="Figure 2-4. Calculating the firing angle manually">Figure 2-4</a>, we calculate the angle by taking the inverse tangent of the vector’s x and y components.</p><div class="figure"><a id="calculating_the_firing_angle_manually"/><div class="figure-contents"><div class="mediaobject"><a id="med_id00010"/><img src="httpatomoreillycomsourcenostarchimages2184507.png.jpg" alt="Calculating the firing angle manually"/></div></div><p class="title">Figure 2-4. Calculating the firing angle manually</p></div></div><p>Add the following lines of code to <code class="literal">clickGameScreen</code> in <span class="emphasis"><em>game.js</em></span>:</p><p><span class="emphasis"><em>game.js</em></span></p><a id="pro_id00037"/><pre class="programlisting">  var BubbleShoot = window.BubbleShoot || {};
    BubbleShoot.Game = (function($){
    var Game = function(){
      <span class="emphasis"><em>--snip--</em></span>
      var clickGameScreen = function(e){
        var angle = BubbleShoot.ui.getBubbleAngle(curBubble.getSprite(),e);
        <span class="strong"><strong>var duration = 750;</strong></span>
        <span class="strong"><strong>var distance = 1000;</strong></span>
        <span class="strong"><strong>var distX = Math.sin(angle) * distance;</strong></span>
        <span class="strong"><strong>var distY = Math.cos(angle) * distance;</strong></span>
        <span class="strong"><strong>var bubbleCoords = BubbleShoot.ui.getBubbleCoords(curBubble.</strong></span>
          <span class="strong"><strong>getSprite());</strong></span>
        <span class="strong"><strong>var coords = {</strong></span>
          <span class="strong"><strong>x : bubbleCoords.left + distX,</strong></span>
          <span class="strong"><strong>y : bubbleCoords.top - distY</strong></span>
        <span class="strong"><strong>};</strong></span>
➊      <span class="strong"><strong>BubbleShoot.ui.fireBubble(</strong></span>➋<span class="strong"><strong>curBubble,</strong></span>➌<span class="strong"><strong>coords,</strong></span>➍<span class="strong"><strong>duration);</strong></span>
      };
    };
    return Game;
  })(jQuery);</pre><p><a id="iddle1034" class="indexterm"/><a id="iddle1053" class="indexterm"/><a id="iddle1076" class="indexterm"/><a id="iddle1080" class="indexterm"/><a id="iddle1098" class="indexterm"/><a id="iddle1259" class="indexterm"/><a id="iddle1422" class="indexterm"/><a id="iddle1635" class="indexterm"/><a id="iddle1645" class="indexterm"/><a id="iddle1664" class="indexterm"/><a id="iddle1697" class="indexterm"/><a id="iddle1764" class="indexterm"/><a id="iddle1806" class="indexterm"/><a id="iddle2070" class="indexterm"/><a id="iddle2107" class="indexterm"/><a id="iddle2151" class="indexterm"/><a id="iddle2168" class="indexterm"/><a id="iddle2248" class="indexterm"/><a id="iddle2514" class="indexterm"/><a id="iddle2590" class="indexterm"/><a id="iddle2602" class="indexterm"/><a id="iddle2633" class="indexterm"/>The new code sets a duration and total distance, and then calculates the distance along the <span class="emphasis"><em>x</em></span>- and <span class="emphasis"><em>y</em></span>-axes to give coordinates (<code class="literal">coords</code>) that are 1000 pixels from its starting point in the direction of the mouse click.</p><p>Next, we need to write the <code class="literal">fireBubble</code> function ➊ that takes the <code class="literal">bubble</code> object ➋, a coordinate to fire at ➌, and a duration ➍ as arguments. We’ll put that in the <code class="literal">ui</code> class, because it handles just onscreen movement and won’t affect the game state.</p><p>Add a new method right after <code class="literal">getBubbleAngle</code> in <span class="emphasis"><em>ui.js</em></span>:</p><p><span class="emphasis"><em>ui.js</em></span></p><a id="pro_id00038"/><pre class="programlisting">  var BubbleShoot = window.BubbleShoot || {};
  BubbleShoot.ui = (function($){
    var ui = {
      <span class="emphasis"><em>--snip--</em></span>
      getBubbleAngle : function(bubble,e){
        <span class="emphasis"><em>--snip--</em></span>
      },
      <span class="strong"><strong>fireBubble : function(bubble,coords,duration){</strong></span>
➊      <span class="strong"><strong>bubble.getSprite().animate({</strong></span>
➋          <span class="strong"><strong>left : coords.x - ui.BUBBLE_DIMS/2,</strong></span>
            <span class="strong"><strong>top : coords.y - ui.BUBBLE_DIMS/2</strong></span>
          <span class="strong"><strong>},</strong></span>
          <span class="strong"><strong>{</strong></span>
➌          <span class="strong"><strong>duration : duration,</strong></span>
➍          <span class="strong"><strong>easing : "linear"</strong></span>
          <span class="strong"><strong>});</strong></span>
      <span class="strong"><strong>}</strong></span>
    };
    return ui;
  })(jQuery);</pre><p>The <code class="literal">fireBubble</code> method is a jQuery call that moves a bubble with jQuery’s <code class="literal">animate</code> method. The coordinates passed into the function represent the center point of where the bubble needs to stop. To make sure the bubble reaches the correct (top, left) coordinates, <code class="literal">fireBubble</code> first translates the coordinates it receives to the top left of the object ➊, which is how CSS positions elements.</p><p>The simplest form of animation for moving a sprite around the screen requires two steps: ➊ place the sprite at a fixed position and ➋ move it to a new position a short time later. Repeat the second step until the sprite reaches its destination. With DOM manipulation, we just need to change the top and left CSS properties of the element for each movement and can let the browser take it from there.</p><p>We can achieve this animation in two ways. We can use JavaScript animation, which requires us to move the sprite along each step of its path manually, or we can use CSS3 transitions to move the sprite without input from our code each frame. In this chapter, we’re focusing on the JavaScript approach; later we’ll demonstrate a CSS3 implementation.</p><p>As with many of the effects we want to achieve in JavaScript and CSS, we can let jQuery do much of the work for us. The <code class="literal">animate</code> method provides <a id="iddle1015" class="indexterm"/><a id="iddle1046" class="indexterm"/><a id="iddle1056" class="indexterm"/><a id="iddle1061" class="indexterm"/><a id="iddle1067" class="indexterm"/><a id="iddle1721" class="indexterm"/><a id="iddle1789" class="indexterm"/><a id="iddle1795" class="indexterm"/><a id="iddle1808" class="indexterm"/><a id="iddle1881" class="indexterm"/><a id="iddle2118" class="indexterm"/><a id="iddle2576" class="indexterm"/>a way to animate numerical CSS properties, such as left and top coordinates. It calculates the difference between the start and end values, and it changes the property’s values from start to end over a number of steps.</p><div class="note" title="Note"><h3 class="title"><a id="ch02note01"/>Note</h3><p><span class="emphasis"><em>This method doesn’t work with non-numerical CSS properties because the way to get from start to end can’t be calculated easily. For example, you couldn’t use <code class="literal">animate</code> to transition a background color with start and end values that are hexadecimal pairs because interpolating between two colors is not as simple a calculation.</em></span></p></div><p>The <code class="literal">animate</code> method takes a number of arguments, including these:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p title="CSS properties ➋"><span class="title"><strong><span class="strong"><strong>CSS properties ➋</strong></span></strong></span>. Specifies the properties to animate. Most often, these are positioning properties, such as <span class="emphasis"><em>top</em></span> and <span class="emphasis"><em>left</em></span>, but they could be anything that can be defined by a single-integer dimension in pixels, including <code class="literal">font-size</code>, width, height, or even <code class="literal">border-width</code> or <code class="literal">margin-left</code>. (Note that the shorthand definition for margin, such as <code class="literal">margin: 0 10px 20px 10px</code>, contains four different values, so it won’t work with <code class="literal">animate</code> without being split into the four constituent parts of <code class="literal">margin-top</code>, <code class="literal">margin-right</code>, <code class="literal">margin-bottom</code>, and <code class="literal">margin-left</code>.)</p></li><li class="listitem"><p title="Duration ➌"><span class="title"><strong><span class="strong"><strong>Duration ➌</strong></span></strong></span>. Defines the length in milliseconds of the animation duration. The duration here is fixed at 1 second (1000 milliseconds) for a velocity of 1000 pixels per second. The distance the bubble moves will depend on the game state and, specifically, anything the bubble might collide with. But the duration that we have now should be correct for bubbles that are fired off the screen.</p></li><li class="listitem"><p title="Easing ➍"><span class="title"><strong><span class="strong"><strong>Easing ➍</strong></span></strong></span>. Defines how an object transitions from its start state to its end state. Easing is usually used to vary acceleration and deceleration along a movement path. For movement, <code class="literal">linear</code> results in a constant velocity from start to end, whereas <code class="literal">swing</code> adds some starting acceleration and ending deceleration.</p></li></ul></div><p>You can pass other options to <code class="literal">animate</code> as well, and it’s worth referring to the jQuery documentation to get an idea of the full potential of the function. To fire the bubble, we need only the preceding parameters.</p><p>Reload the page and click in a location above the bubble. The bubble should fly off in that direction. This will work only once. You’ll need to refresh the page to see it again, but it’s certainly a start.</p></div></div><div class="sect1" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="summary-id00003"/>Summary</h1></div></div></div><p>In this chapter, you’ve learned how to perform simple animations with jQuery, HTML, and CSS techniques. Now that we have the basic code in place to move a bubble across the screen in response to a mouse click, it’s time to start fleshing out the game.</p><p>In <a class="xref" href="ch03.html" title="Chapter 3. Game Logic">Chapter 3</a>, we’ll focus on drawing the game board, detecting collisions, and popping bubble groups.</p></div><div class="sect1" title="Further Practice"><div class="titlepage"><div><div><h1 class="title"><a id="further_practice-id00004"/>Further Practice</h1></div></div></div><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p>If you click in the game area a second time, the bubble appears back on the screen. How would you disable this click event to prevent it?</p></li><li class="listitem"><p>In the <code class="literal">.animate</code> call, we specify <code class="literal">easing : "linear"</code>. Try using <code class="literal">"swing"</code> and think about why this may not be appropriate for <span class="emphasis"><em>Bubble Shooter</em></span> but may be a better animation method for other games. Then look at more easing settings at <span class="emphasis"><em><a class="ulink" href="http://api.jqueryui.com/easings/">http://api.jqueryui.com/easings/</a></em></span> and see if you can incorporate any of them into the code.</p></li></ol></div></div></div></body></html>