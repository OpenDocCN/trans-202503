<html><head></head><body>
		<h2 class="h2" id="ch09"><span epub:type="pagebreak" id="page_267"/><strong><span class="big">9</span></strong><br/><strong>POINTER DATA TYPES</strong></h2>&#13;
		<div class="image1">&#13;
			<img alt="image" src="../images/common01.jpg"/>&#13;
		</div>&#13;
		<p class="noindent">Pointers are the data type equivalent of a <span class="literal">goto</span> statement. Used carelessly, they can turn a robust and efficient program into a buggy and inefficient junk pile. Unlike <span class="literal">goto</span> statements, however, pointers can be difficult to avoid in many common programming languages. There are no “pointers considered harmful” papers in academic journals like Dijkstra’s “Go To Statement Considered Harmful” letter.<sup><a id="ch9fn_1"/><a href="footnotes.xhtml#ch9fn1">1</a></sup> Many languages, like Java and Swift, attempt to restrict pointers, but several popular languages still use them, so great programmers need to be able to deal with them. To that end, this chapter will discuss:</p>&#13;
		<ul>&#13;
			<li>&#13;
				<p class="noindent">The memory representation of pointers</p>&#13;
				</li>&#13;
			<li>&#13;
				<p class="noindent">How high-level languages implement pointers</p>&#13;
				</li>&#13;
			<li><span epub:type="pagebreak" id="page_268"/>&#13;
			<p class="noindent">Dynamic memory allocation and its relationship to pointers</p>&#13;
			</li>&#13;
			<li>&#13;
				<p class="noindent">Pointer arithmetic</p>&#13;
				</li>&#13;
			<li>&#13;
				<p class="noindent">How memory allocators work</p>&#13;
				</li>&#13;
			<li>&#13;
				<p class="noindent">Garbage collection</p>&#13;
				</li>&#13;
			<li>&#13;
				<p class="noindent">Common pointer problems</p>&#13;
				</li>&#13;
		</ul>&#13;
		<p class="indent">By understanding the low-level implementation and use of pointers, you’ll be able to write high-level code that is more efficient, safer, and more readable. This chapter will provide the information you need to use pointers appropriately and avoid the problems normally associated with them.</p>&#13;
		<h3 class="h3" id="ch00lev1sec72"><strong>9.1 The Definition of a Pointer</strong></h3>&#13;
		<p class="noindent">A pointer is simply a variable whose value refers to some other object. High-level languages like Pascal and C/C++ hide the simplicity of pointers behind a wall of abstraction. HLL programmers generally rely on the high degree of abstraction provided by the language because they don’t want to know what’s going on behind the scenes. They just want a “black box” that produces predictable results. In the case of pointers, though, the abstraction may be <em>too</em> effective; pointers seem intimidating and opaque to many programmers. Well, fear not! Pointers are actually easy to deal with.</p>&#13;
		<p class="indent">To understand how pointers work, I’ll use the array data type as an example. Consider the following array declaration in Pascal:</p>&#13;
		<pre class="programs">M: array [0..1023] of integer;</pre>&#13;
		<p class="indent">Even if you don’t know Pascal, the concept here is easy to understand. <span class="literal">M</span> is an array of 1,024 integers, indexed from <span class="literal">M[0]</span> to <span class="literal">M[1023]</span>. Each array element can hold an independent integer value. In other words, this array gives you 1,024 different integer variables, each of which you access via an array index (the variable’s sequential position within the array) rather than by name.</p>&#13;
		<p class="indent">The statement <span class="literal">M[0] := 100;</span> stores the value <span class="literal">100</span> into the first element of the array <span class="literal">M</span>. Now consider the following two statements:</p>&#13;
		<pre class="programs">&#13;
			i := 0; (* assume "i" is an integer variable *)<br/>M [i] := 100;</pre>&#13;
		<p class="indent">These two statements do the same thing as <span class="literal">M[0] := 100;</span>. In fact, you can use any integer expression producing a value in the range <span class="literal">0..1023</span> as an index into this array. The following statements still perform the same operation as our earlier statements:</p>&#13;
		<pre class="programs">&#13;
			i := 5;         (* assume all variables are integers*)<br/>j := 10;<br/>k := 50;<br/>m [i*j-k] := 100;</pre>&#13;
		<p class="indent"><span epub:type="pagebreak" id="page_269"/>But now look at the following statements:</p>&#13;
		<pre class="programs">&#13;
			M [1] := 0;<br/>M [ M [1] ] := 100;</pre>&#13;
		<p class="indent">At first glance, these statements might seem confusing; however, they perform the same operation as in the previous examples. The first statement stores <span class="literal">0</span> into array element <span class="literal">M[1]</span>. The second statement fetches the value of <span class="literal">M[1]</span>, which is <span class="literal">0</span>, and uses that value to determine where to store the value <span class="literal">100</span>.</p>&#13;
		<p class="indent">If you think this example is reasonable—perhaps bizarre, but usable nonetheless—then you’ll have no problems with pointers, because <span class="literal">M[1]</span> is a pointer! Well, not really, but if you were to change <span class="literal">M</span> to “memory” and treat each element of this array as a separate memory location, then it would meet the definition of a pointer—that is, a memory variable whose value is the address of some other memory object.</p>&#13;
		<h3 class="h3" id="ch00lev1sec73"><strong>9.2 Pointer Implementation in High-Level Languages</strong></h3>&#13;
		<p class="noindent">Although most languages implement pointers using memory addresses, a pointer is actually an abstraction of a memory address. Therefore, a language could define a pointer using any mechanism that maps the value of the pointer to the address of some object in memory. Some implementations of Pascal, for example, use offsets from a fixed memory address as pointer values. Some languages (including dynamic languages like Lisp) might actually implement pointers by using <em>double indirection</em>; that is, the pointer object contains the address of some memory variable whose value is the address of the object to access. This approach may seem somewhat convoluted, but it offers certain advantages in a complex memory management system, making it easier and more efficient to reuse blocks of memory. However, for simplicity’s sake we’ll assume that, as defined earlier, a pointer is a variable whose value is the address of some other object in memory. This is a safe assumption for many of the high-performance HLLs you’re likely to encounter, such as C, C++, and Delphi.</p>&#13;
		<p class="indent">You can indirectly access an object using a pointer with two 80x86 machine instructions, as follows:</p>&#13;
		<pre class="programs">&#13;
			mov( PointerVariable, ebx ); // Load pointer variable into a register.<br/>mov( [ebx], eax );           // Use register-indirect mode to access data.</pre>&#13;
		<p class="indent">Now consider the double-indirect pointer implementation described earlier. Access to data via double indirection is less efficient than the straight pointer implementation because it takes an extra machine instruction to fetch the data from memory. This isn’t obvious even in an HLL like C/C++ or Pascal, where using double indirection is explicit:</p>&#13;
		<pre class="programs">&#13;
			i = **cDblPtr;<br/>i := pDblPtr^^;</pre>&#13;
		<p class="indent"><span epub:type="pagebreak" id="page_270"/>This is syntactically similar to single indirection. In assembly language, however, you’ll see the extra work involved:</p>&#13;
		<pre class="programs">&#13;
			mov( hDblPtr, ebx );  // Get the pointer to a pointer<br/>mov( [ebx], ebx );    // Get the pointer to the value<br/>mov( [ebx], eax );    // Get the value</pre>&#13;
		<p class="indent">Contrast this with the two earlier assembly instructions to access an object using single indirection. Because double indirection requires 50 percent more code (and twice as many slow memory accesses) than single indirection, you can see why many languages implement pointers using single indirection. To verify this, consider the machine code produced by a couple of different compilers when processing the following C code:</p>&#13;
		<pre class="programs">&#13;
			static int i;<br/>static int j;<br/>static int *cSnglPtr;<br/>static int **cDblPtr;<br/><br/>int main( void )<br/>{<br/>        .<br/>        .<br/>        .<br/>    j = *cSnglPtr;<br/>    i = **cDblPtr;<br/>        .<br/>        .<br/>        .</pre>&#13;
		<p class="indent">Here’s the GCC output for the PowerPC processor:</p>&#13;
		<pre class="programs">&#13;
			; j = *cSnglPtr;<br/><br/>        addis r11,r31,ha16(_j-L1$pb)<br/>        la r11,lo16(_j-L1$pb)(r11)<br/>        addis r9,r31,ha16(_cSnglPtr-L1$pb)<br/>        la r9,lo16(_cSnglPtr-L1$pb)(r9)<br/>        lwz r9,0(r9)  // Get the ptr into register R9<br/>        lwz r0,0(r9)  // Get the data at the pointer<br/>        stw r0,0(r11) // Store into j<br/><br/>; i = **cDblPtr;<br/>;<br/>; Begin by getting the address of cDblPtr into R9:<br/><br/>        addis r11,r31,ha16(_i-L1$pb)<br/>        la r11,lo16(_i-L1$pb)(r11)<br/>        addis r9,r31,ha16(_cDblPtr-L1$pb)<br/>        la r9,lo16(_cDblPtr-L1$pb)(r9)<br/><br/>        lwz r9,0(r9)  // Get the dbl ptr into R9<br/>        lwz r9,0(r9)  // Get the ptr into R9<br/><span epub:type="pagebreak" id="page_271"/>        lwz r0,0(r9)  // Get the value into R9<br/>        stw r0,0(r11) // Store value into i</pre>&#13;
		<p class="indent">As you can see in this PowerPC example, fetching the value using double indirection takes one more instruction than it does using single indirection. Of course, the total number of instructions is rather large here, so this extra instruction doesn’t contribute as much to the execution time as it does on the 80x86 where fewer instructions are involved. Consider the following GCC code output for the 32-bit 80x86:</p>&#13;
		<pre class="programs">&#13;
			; j = *cSnglPtr;<br/><br/>        movl    cSnglPtr, %eax<br/>        movl    (%eax), %eax<br/>        movl    %eax, j<br/><br/>; i = **cDblPtr;<br/><br/>        movl    cDblPtr, %eax<br/>        movl    (%eax), %eax<br/>        movl    (%eax), %eax<br/>        movl    %eax, i</pre>&#13;
		<p class="indent">As we saw with the PowerPC code, double indirection requires extra machine instructions, so programs using double indirection will be larger and slower.</p>&#13;
		<p class="indent">Notice that the PowerPC instruction sequences are twice as long as the 80x86 instruction sequences.<sup><a id="ch9fn_2"/><a href="footnotes.xhtml#ch9fn2">2</a></sup> One positive way of viewing this is that double indirection has less of an impact on the execution time of the PowerPC code than it does on the 80x86 code. That is, the extra instruction represents only 13 percent of the total in the PowerPC code, versus 25 percent of the total in the 80x86 code.<sup><a id="ch9fn_3"/><a href="footnotes.xhtml#ch9fn3">3</a></sup> This brief example should demonstrate that execution time and code space are not processor independent. Bad coding practices (such as using double indirection when it’s not required) can have more impact on some processors than others.</p>&#13;
		<h3 class="h3" id="ch00lev1sec74"><strong>9.3 Pointers and Dynamic Memory Allocation</strong></h3>&#13;
		<p class="noindent">Pointers typically reference anonymous variables that you allocate on the heap using memory allocation/deallocation functions like <span class="literal">malloc()</span>/<span class="literal">free()</span>, <span class="literal">new()</span>/<span class="literal">dispose()</span>, and <span class="literal">new()</span>/<span class="literal">delete()</span> (<span class="literal">std::make_unique</span> in C++17). Objects that you allocate on the heap are known as <em>anonymous variables</em> because you refer <span epub:type="pagebreak" id="page_272"/>to them by their address rather than by name. While the pointer variable may have a name, that name applies to the pointer’s data (an address), not the object referenced by this address.</p>&#13;
		<div class="note">&#13;
			<p class="notet"><strong><span class="notes">NOTE</span></strong></p>&#13;
			<p class="notep"><em>The heap, as <a href="ch07.xhtml#ch07">Chapter 7</a> explained, is a region in memory reserved for dynamic storage allocation.</em></p>&#13;
		</div>&#13;
		<p class="indent">Dynamic languages handle memory allocation and deallocation operations in a transparent, automatic fashion. The application simply uses the dynamic data and leaves it up to the runtime system to allocate memory as needed and reuse storage for a different purpose when it is no longer needed. Without the need to explicitly allocate and deallocate memory for pointer variables, applications written in dynamic languages (such as AWK or Perl) are usually much easier to program and often contain far fewer errors. But this comes at the cost of efficiency, as they often run much slower than programs written in other languages. Conversely, traditional languages (such as C/C++) that require programmers to explicitly manage memory often produce more efficient applications, although the memory management code is prone to a higher percentage of defects due to its additional complexity.</p>&#13;
		<h3 class="h3" id="ch00lev1sec75"><strong>9.4 Pointer Operations and Pointer Arithmetic</strong></h3>&#13;
		<p class="noindent">Most HLLs that provide a pointer data type let you assign addresses to pointer variables, compare pointer values for equality or inequality, and indirectly reference an object via a pointer. Some languages also allow additional operations, as you’ll see in this section.</p>&#13;
		<p class="indent">Many programming languages enable you to do limited arithmetic with pointers. At the very least, these languages allow you to add an integer constant to, or subtract one from, a pointer. To understand the purpose of these two arithmetic operations, recall the syntax of the <span class="literal">malloc()</span> function in the C standard library:</p>&#13;
		<pre class="programs">&#13;
			ptrVar = malloc( <span class="codeitalic1">bytes_to_allocate</span> );</pre>&#13;
		<p class="indent">The parameter you pass <span class="literal">malloc()</span> specifies the number of bytes of storage to allocate. A good C programmer generally supplies an expression like <span class="literal">sizeof(int)</span> as this parameter. The <span class="literal">sizeof()</span> function returns the number of bytes needed by its single parameter. Therefore, <span class="literal">sizeof(int)</span> tells <span class="literal">malloc()</span> to allocate at least enough storage for an <span class="literal">int</span> variable. Now consider the following call to <span class="literal">malloc()</span>:</p>&#13;
		<pre class="programs">ptrVar = malloc( sizeof( int ) * 8 ); // An array of 8 integers</pre>&#13;
		<p class="indent">If the size of an integer is 4 bytes, this call to <span class="literal">malloc()</span> will allocate storage for 32 bytes, at consecutive addresses in memory (see <a href="ch09.xhtml#ch9fig1">Figure 9-1</a>).</p>&#13;
		<div class="image" id="ch9fig1">&#13;
			<span epub:type="pagebreak" id="page_273"/>&#13;
			<img alt="Image" src="../images/09fig01.jpg"/>&#13;
		</div>&#13;
		<p class="figcap"><em>Figure 9-1: Memory allocation via <span class="codeitalic">malloc(sizeof(int) * 8 )</span></em></p>&#13;
		<p class="indent">The pointer that <span class="literal">malloc()</span> returns contains the address of the first integer in this set, so the C program can directly access only the very first of these eight integers. To access the individual addresses of the other seven integers, you need to add an integer offset to that <em>base</em> address. On machines that support byte-addressable memory (such as the 80x86), the address of each successive integer in memory is the address of the previous integer plus the integer size. For example, if a call to the C standard library <span class="literal">malloc()</span> routine returns the memory address <span class="literal">$0300_1000</span>, then the eight integers that <span class="literal">malloc()</span> allocates will reside at the memory addresses shown in <a href="ch09.xhtml#ch9tab1">Table 9-1</a>.</p>&#13;
		<p class="tabcap" id="ch9tab1"><strong>Table 9-1:</strong> Integer Addresses Allocated for Base Address <span class="literal">$0300_1000</span></p>&#13;
		<table class="all">&#13;
			<colgroup>&#13;
				<col style="width:20%"/>&#13;
				<col style="width:80%"/>&#13;
			</colgroup>&#13;
			<tbody>&#13;
				<tr>&#13;
					<td class="table-h" style="vertical-align: top;">&#13;
						<p class="table"><strong>Integer</strong></p>&#13;
					</td>&#13;
					<td class="table-h" style="vertical-align: top;">&#13;
						<p class="table"><strong>Memory address</strong></p>&#13;
					</td>&#13;
				</tr>&#13;
				<tr>&#13;
					<td style="vertical-align: top;">&#13;
						<p class="table">First</p>&#13;
					</td>&#13;
					<td style="vertical-align: top;">&#13;
						<p class="table"><span class="literal">$0300_1000..$0300_1003</span></p>&#13;
					</td>&#13;
				</tr>&#13;
				<tr>&#13;
					<td class="table-1b" style="vertical-align: top;">&#13;
						<p class="table">Second</p>&#13;
					</td>&#13;
					<td class="table-1b" style="vertical-align: top;">&#13;
						<p class="table"><span class="literal">$0300_1004..$0300..1007</span></p>&#13;
					</td>&#13;
				</tr>&#13;
				<tr>&#13;
					<td style="vertical-align: top;">&#13;
						<p class="table">Third</p>&#13;
					</td>&#13;
					<td style="vertical-align: top;">&#13;
						<p class="table"><span class="literal">$0300_1008..$0300_100b</span></p>&#13;
					</td>&#13;
				</tr>&#13;
				<tr>&#13;
					<td class="table-1b" style="vertical-align: top;">&#13;
						<p class="table">Fourth</p>&#13;
					</td>&#13;
					<td class="table-1b" style="vertical-align: top;">&#13;
						<p class="table"><span class="literal">$0300_100c..$0300_100f</span></p>&#13;
					</td>&#13;
				</tr>&#13;
				<tr>&#13;
					<td style="vertical-align: top;">&#13;
						<p class="table">Fifth</p>&#13;
					</td>&#13;
					<td style="vertical-align: top;">&#13;
						<p class="table"><span class="literal">$0300_1010..$0300_1013</span></p>&#13;
					</td>&#13;
				</tr>&#13;
				<tr>&#13;
					<td class="table-1b" style="vertical-align: top;">&#13;
						<p class="table">Sixth</p>&#13;
					</td>&#13;
					<td class="table-1b" style="vertical-align: top;">&#13;
						<p class="table"><span class="literal">$0300_1014..$0300..1017</span></p>&#13;
					</td>&#13;
				</tr>&#13;
				<tr>&#13;
					<td style="vertical-align: top;">&#13;
						<p class="table">Seventh</p>&#13;
					</td>&#13;
					<td style="vertical-align: top;">&#13;
						<p class="table"><span class="literal">$0300_1018..$0300_101b</span></p>&#13;
					</td>&#13;
				</tr>&#13;
				<tr>&#13;
					<td class="table-1b" style="vertical-align: top;">&#13;
						<p class="table">Eighth</p>&#13;
					</td>&#13;
					<td class="table-1b" style="vertical-align: top;">&#13;
						<p class="table"><span class="literal">$0300_101c..$0300_101f</span></p>&#13;
					</td>&#13;
				</tr>&#13;
			</tbody>&#13;
		</table>&#13;
		<h4 class="h4" id="ch00lev2sec100"><strong>9.4.1 Adding an Integer to a Pointer</strong></h4>&#13;
		<p class="noindent">Because the eight integers in the previous section are exactly 4 bytes apart, you add 4 to the address of the first integer to obtain the address of the second integer. Likewise, the address of the third integer is the address of the second integer plus 4 bytes, and so on. In assembly language, you could access these eight integers using code like the following:</p>&#13;
		<pre class="programs">&#13;
			// malloc returns storage for eight<br/>//  int32 objects in EAX.<br/><br/>malloc( @size( int32 ) * 8 );<br/><br/>mov( 0, ecx );<br/>mov( ecx, [eax] );     // Zero out the 32 bytes<br/>mov( ecx, [eax+4] );   // (4 bytes at a time).<br/><span epub:type="pagebreak" id="page_274"/>mov( ecx, [eax+8] );<br/>mov( ecx, [eax+12] );<br/>mov( ecx, [eax+16] );<br/>mov( ecx, [eax+20] );<br/>mov( ecx, [eax+24] );<br/>mov( ecx, [eax+28] );</pre>&#13;
		<p class="indent">Notice the use of the 80x86 indexed addressing mode to access the eight integers that <span class="literal">malloc()</span> allocates. The EAX register maintains the base (first) address of the eight integers that this code allocates, and the constant in the addressing mode of the <span class="literal">mov()</span> instruction indicates the offset of the specific integer from this base address.</p>&#13;
		<p class="indent">Most CPUs use byte addresses for memory objects. Therefore, when a program allocates multiple copies of some <em>n</em>-byte object in memory, the objects won’t begin at consecutive memory addresses; instead, they’ll appear in memory at addresses that are <em>n</em> bytes apart. Some machines, however, don’t allow a program to access memory at any arbitrary address; they require it to access data on address boundaries that are a multiple of a word, a double word, or even a quad word. Any attempt to access memory on some other boundary will raise an exception and potentially halt the application. If an HLL supports pointer arithmetic, it must take this fact into consideration and provide a generic pointer arithmetic scheme that’s portable across different CPU architectures. The most common solution that HLLs use when adding an integer offset to a pointer is to multiply that offset by the size of the object that the pointer references. That is, if you have a pointer <span class="literal">p</span> to a 16-byte object in memory, then <span class="literal">p + 1</span> points 16 bytes beyond where <span class="literal">p</span> points. Likewise, <span class="literal">p + 2</span> points 32 bytes beyond the address contained in <span class="literal">p</span>. As long as the size of the data object is a multiple of the required alignment size (which the compiler can enforce by adding padding bytes, if necessary), this scheme avoids problems on architectures that require aligned data access. Consider, for example, the following C/C++ code:</p>&#13;
		<pre class="programs">&#13;
			int *intPtr;<br/>        .<br/>        .<br/>        .<br/>    // Allocate storage for eight integers:<br/><br/>    intPtr = malloc( sizeof( int ) * 8 );<br/><br/>    // Initialize each of these integer values:<br/><br/>    *(intPtr+0) = 0;<br/>    *(intPtr+1) = 1;<br/>    *(intPtr+2) = 2;<br/>    *(intPtr+3) = 3;<br/>    *(intPtr+4) = 4;<br/>    *(intPtr+5) = 5;<br/>    *(intPtr+6) = 6;<br/>    *(intPtr+7) = 7;</pre>&#13;
		<p class="indent"><span epub:type="pagebreak" id="page_275"/>This example demonstrates how C/C++ uses pointer arithmetic to specify an integer-sized offset from the base pointer address.</p>&#13;
		<p class="indent">It’s important to note that the addition operator only makes sense between a pointer and an integer value. For example, in C/C++ you can indirectly access objects in memory using an expression like <span class="literal">*(p + i)</span> (where <span class="literal">p</span> is a pointer to an object and <span class="literal">i</span> is an integer value). It doesn’t make sense to add two pointers together. Similarly, it isn’t logical to add other data types with a pointer—for example, adding a floating-point value to a pointer. (What does it mean to reference the data at some base address plus 1.5612?) Operations on pointers involving strings, characters, and other data types don’t make much sense, either. Integers (signed and unsigned) are the only reasonable values to add to a pointer.</p>&#13;
		<p class="indent">On the other hand, not only can you add an integer to a pointer, but you can also add a pointer to an integer and the result is still a pointer (both <span class="literal">p + i</span> and <span class="literal">i + p</span> are legal). This is because addition is <em>commutative</em>—the order of the operands does not affect the result.</p>&#13;
		<h4 class="h4" id="ch00lev2sec101"><strong>9.4.2 Subtracting an Integer from a Pointer</strong></h4>&#13;
		<p class="noindent">Subtracting an integer from a pointer references a memory location immediately before the base address held in the pointer. However, subtraction is not commutative, and subtracting a pointer from an integer is not a legal operation (<span class="literal">p - i</span> is legal, but <span class="literal">i - p</span> is not).</p>&#13;
		<p class="indent">In C/C++, <span class="literal">*(p - i)</span> accesses the <span class="literal">i</span>th object immediately before the object at which <span class="literal">p</span> points. In 80x86 assembly language, as in assembly on many processors, you can also specify a negative constant offset when using an indexed addressing mode. For example:</p>&#13;
		<pre class="programs">mov( [ebx-4], eax );</pre>&#13;
		<p class="indent">Keep in mind, 80x86 assembly language uses byte offsets, not object offsets (as C/C++ does). Therefore, this statement loads into EAX the double word in memory immediately preceding the memory address in EBX.</p>&#13;
		<h4 class="h4" id="ch00lev2sec102"><strong>9.4.3 Subtracting a Pointer from a Pointer</strong></h4>&#13;
		<p class="noindent">In contrast to addition, it makes sense to subtract the value of one pointer variable from another. Consider the following C/C++ code, which proceeds through a string of characters looking for the first <span class="literal">e</span> character that follows the first <span class="literal">a</span> that it finds (you could use the result of such a calculation, for example, to extract a substring):</p>&#13;
		<pre class="programs">&#13;
			int distance;<br/>char *aPtr;<br/>char *ePtr;<br/>    .<br/>    .<br/>    .<br/>aPtr = someString;  // Get ptr to start of string in aPtr.<br/><span epub:type="pagebreak" id="page_276"/>// While we're not at the end of the string<br/>// and the current char isn't 'a':<br/><br/>while( *aPtr != '\0' &amp;&amp; *aPtr != 'a' )<br/>{<br/>    // Move on to the next character pointed at by aPtr.<br/><br/>    aPtr = aPtr + 1;<br/>}<br/><br/>// while we're not at the end of the string<br/>// and the current character isn't 'e'<br/>//<br/>// Start at the 'a' char (or end of string if no 'a').<br/><br/>ePtr = aPtr;<br/>while( *ePtr != '\0' &amp;&amp; *ePtr != 'e' )<br/>{<br/>    // Move on to the next character pointed at by aPtr.<br/>    ePtr = ePtr + 1;<br/>}<br/><br/>// Now compute the number of characters between<br/>// the 'a' and the 'e' (counting the 'a' but not<br/>// counting the 'e'):<br/><br/>distance = (ePtr - aPtr);</pre>&#13;
		<p class="indent">Subtracting one pointer from the other produces the number of data objects that exist between them (in this case, <span class="literal">ePtr</span> and <span class="literal">aPtr</span> point at characters, so this subtraction produces the number of characters, or bytes if 1-byte characters, between the two pointers).</p>&#13;
		<p class="indent">The subtraction of two pointer values makes sense only if they both reference the same data structure (for example, an array, string, or record) in memory. Although assembly language will allow you to subtract two pointers that point at completely different objects in memory, their difference will probably have very little meaning.</p>&#13;
		<p class="indent">For pointer subtraction in C/C++, the base types of the two pointers must be identical (that is, the two pointers must contain the address of two objects whose types are identical). This restriction exists because pointer subtraction in C/C++ produces the number of objects, not the number of bytes, between the two pointers. Computing the number of objects between a byte in memory and a double word in memory wouldn’t make any sense. The result would be neither a byte count nor a double-word count.</p>&#13;
		<p class="indent">The subtraction of two pointers can return a negative number if the left pointer operand is at a lower memory address than the right pointer operand. Depending on your language and its implementation, you might need to take the absolute value of the result if you’re interested only in the distance between the two pointers and you don’t care which pointer contains the greater address.</p>&#13;
		<h4 class="h4" id="ch00lev2sec103"><span epub:type="pagebreak" id="page_277"/><strong>9.4.4 Comparing Pointers</strong></h4>&#13;
		<p class="noindent">Comparisons are another set of operations that make sense for pointers. Almost every language that supports pointers allows you to compare two pointers to see whether or not they are equal. A pointer comparison tells you whether the pointers reference the same object in memory. Some languages (such as assembly and C/C++) also let you compare two pointers to see if one pointer is less than or greater than the other. Like subtracting two pointers, comparing two pointers makes sense only if they have the same base type and point into the same data structure. If one pointer is less than another, this tells you that the pointer references an object within the data structure that appears before the object whose address the second pointer contains. The converse is true for the greater-than comparison. This short example in C demonstrates pointer comparison:</p>&#13;
		<pre class="programs">&#13;
			#include &lt;stdio.h&gt;<br/><br/>int iArray[256];<br/>int *ltPtr;<br/>int *gtPtr;<br/><br/><br/><br/>int main( int argc, char **argv )<br/>{<br/>    int lt;<br/>    int gt;<br/><br/>    // Put the address of the "argc" element<br/>    // of iArray into ltPtr. This is done<br/>    // so that the optimizer doesn't completely<br/>    // eliminate the following code (as would<br/>    // happen if we just specified a constant<br/>    // index):<br/><br/>    ltPtr = &amp;iArray[argc];<br/><br/>    // Put the address of the eighth array<br/>    // element into gtPtr.<br/><br/>    gtPtr = &amp;iArray[7];<br/><br/>    // Assuming you don't type seven or more<br/>    // command-line parameters when running<br/>    // this program, the following two<br/>    // assignments should set lt and gt to 1.<br/><br/>    lt = ltPtr &lt; gtPtr;<br/>    gt = gtPtr &gt; ltPtr;<br/>    printf( "lt:%d, gt:%d\n", lt, gt );<br/>    return 0;<br/>}</pre>&#13;
		<p class="indent"><span epub:type="pagebreak" id="page_278"/>At the (x86-64) machine language level, addresses are simply 64-bit quantities, so the machine code can compare these pointers as though they’re 64-bit integer values. Here’s the x86-64 assembly code that Visual C++ emits for this example:</p>&#13;
		<pre class="programs">&#13;
			;<br/>; Grab ARGC (passed to the program in rcx), use<br/>; it as an index into iArray (4 bytes per element,<br/>; hence the "*4" in the scaled-index addressing mode),<br/>; compute the address of this array element (using the<br/>; LEA -- load effective address -- instruction), and<br/>; store the resulting address into ltPtr:<br/>; Line 24<br/>        movsxd  rax, ecx ; rax=rcx<br/>; Line 37<br/>        xor     edx, edx ;edx = 0<br/>        mov     r8d, edx ;Initialize boolean result w/false<br/>        lea     rcx, OFFSET FLAT:iArray ;rcx = base address of iArray<br/>        lea     rcx, QWORD PTR [rcx+rax*4] ;rcx = &amp;iArray[argc]<br/><br/>        lea     rax, OFFSET FLAT:iArray+28 ;rax=&amp;iArray[7] (7*4 = 28)<br/>        mov     QWORD PTR ltPtr, rcx ;ltPtr = &amp;iArray[argc]<br/>        cmp     rax, rcx ;carry flag = !(ltPtr &lt; gtPtr)<br/>        mov     QWORD PTR gtPtr, rax ;gtPtr = &amp;iArray[7]<br/>        seta    r8b ;r8b = ltPtr &lt; gtPtr (which is !gtPtr &gt; ltPtr)<br/>        cmp     rcx, rax ;Carry flag = !(gtPtr &gt; ltPtr)<br/>; Line 38<br/>        lea     rcx, OFFSET FLAT:??_C@_0O@KJKFINNE@lt?3?$CFd?0?5gt?3?$CFd?6?$AA@<br/>        setb    dl ;dl = !(ltPtr &lt; gtPtr ) (which is !(gtPtr &gt; ltPtr)<br/>        call    printf<br/>;</pre>&#13;
		<p class="indent">Other than the trickery behind computing <span class="literal">true</span> (<span class="literal">1</span>) or <span class="literal">false</span> (<span class="literal">0</span>) after comparing the two addresses, this code is a very straightforward compilation to machine code.</p>&#13;
		<h4 class="h4" id="ch00lev2sec104"><strong>9.4.5 Using Logical AND/OR Operations with Pointers</strong></h4>&#13;
		<p class="noindent">On byte-addressable machines, it makes sense to logically AND an address with a bit string value, because masking off the low-order (LO) bits in an address is an easy way to align it on a boundary that is a power of 2. For example, if the 32-bit 80x86 EBX register contains an arbitrary address, the following assembly language statement rounds the pointer in EBX down to an address that is a multiple of 4 bytes:</p>&#13;
		<pre class="programs">and( $FFFF_FFFC, ebx );</pre>&#13;
		<p class="indent">This operation is very useful when you want to ensure that memory is accessed on a nice memory boundary. For example, suppose you have a memory allocation function that can return a pointer to a block of memory that begins at an arbitrary byte boundary. To ensure that the data structure <span epub:type="pagebreak" id="page_279"/>the pointer points to begins on a double word (<span class="literal">dword</span>) boundary, you can use assembly code like the following:</p>&#13;
		<pre class="programs">&#13;
			// # of bytes to allocate<br/><br/>mov( nBytes, eax );<br/><br/>// Provide a "cushion" for rounding.<br/><br/>add( 3, eax );<br/><br/>// Allocate the memory (returns pointer in EAX).<br/><br/>malloc( eax );<br/><br/>// Round up to the next higher dword, if not dword-aligned.<br/><br/>add( 3, eax );<br/><br/>// Make the address a multiple of 4.<br/><br/>and( $ffff_fffc, eax );</pre>&#13;
		<p class="indent">This code allocates an extra 3 bytes when calling <span class="literal">malloc()</span> so that it can add 0, 1, 2, or 3 to the address that <span class="literal">malloc()</span> returns in order to align the object on a <span class="literal">dword</span> address. On return from <span class="literal">malloc()</span>, the code adds 3 to the address and, if it wasn’t already a multiple of 4, the address will cross the next <span class="literal">dword</span> boundary. Using the AND instruction reduces the address back to the previous <span class="literal">dword</span> boundary (either the next <span class="literal">dword</span> boundary, or the original address if it was already <span class="literal">dword</span>-aligned).</p>&#13;
		<h4 class="h4" id="ch00lev2sec105"><strong>9.4.6 Using Other Operations with Pointers</strong></h4>&#13;
		<p class="noindent">Beyond addition, subtraction, comparison, and possibly AND or OR operations, very few arithmetic operations make sense with pointer operands. What does it mean to multiply a pointer by some integer value (or another pointer)? What does division of pointers mean? What do you get when you shift a pointer to the left by one bit position? You could make up some sort of definition for these operations, but considering the original arithmetic definitions, these operations just aren’t reasonable for pointers.</p>&#13;
		<p class="indent">Several languages (including C/C++ and Pascal) restrict other pointer operations. There are several good reasons for limiting what a programmer can do with a pointer, such as:</p>&#13;
		<ul>&#13;
			<li>&#13;
				<p class="noindent">Code involving pointers is notoriously difficult to optimize. By limiting the number of pointer operations, the compiler can make assumptions about the code that it could not otherwise. This allows the compiler (in theory) to produce better machine code.</p>&#13;
				</li>&#13;
			<li>&#13;
				<p class="noindent">Code containing pointer manipulations is more likely to be defective. Limiting programmers’ options in this area helps prevent pointer abuse, and leads to more robust code.</p>&#13;
				</li>&#13;
		</ul>&#13;
		<div class="note">&#13;
			<p class="notet"><span epub:type="pagebreak" id="page_280"/><strong><span class="notes">NOTE</span></strong></p>&#13;
			<p class="notep"><em>The section “Common Pointer Problems” on <a href="ch09.xhtml#page_286">page 286</a> describes the most serious of these errors and ways to avoid them in your code.</em></p>&#13;
		</div>&#13;
		<ul>&#13;
			<li>&#13;
				<p class="noindent">Some pointer operations—particularly certain arithmetic operations—are not portable across CPU architectures. For example, on some segmented architectures (such as the original 16-bit 80x86), subtracting the values of two pointers may not produce an expected result.</p>&#13;
				</li>&#13;
			<li>&#13;
				<p class="noindent">The proper use of pointers can help create efficient programs, but the converse is also true: the improper use of pointers can destroy program efficiency. By limiting the number of pointer operations it supports, a language can prevent the kinds of code inefficiencies that often result from the gratuitous use of pointers.</p>&#13;
				</li>&#13;
		</ul>&#13;
		<p class="indent">The major problem with these justifications for limiting pointer operations is that most exist to protect programmers from themselves, and indeed, many programmers (especially beginners) benefit from the discipline these restrictions enforce. However, for careful programmers who do not abuse pointers, these restrictions may eliminate some opportunities for writing great code. Therefore, languages that provide a rich set of pointer operations, like C/C++ and assembly, are popular with advanced programmers who prefer absolute control over the use of pointers in their programs.</p>&#13;
		<h3 class="h3" id="ch00lev1sec76"><strong>9.5 A Simple Memory Allocator Example</strong></h3>&#13;
		<p class="noindent">To demonstrate the performance and memory costs of using dynamically allocated memory and pointers to it, this section presents a simple memory allocation/deallocation system. By considering the operations associated with memory allocation and deallocation, you’ll be more aware of their costs and better equipped to use them in an appropriate way.</p>&#13;
		<p class="indent">An extremely simple (and fast) memory allocation scheme would maintain a single variable that forms a pointer into the heap region of memory. Whenever a memory allocation request comes along, the system makes a copy of this heap pointer to return to the application. The heap management routines add the size of the memory request to the address held in the pointer variable and verify that the memory request won’t try to use more memory than is available in the heap. (Some memory managers return an error indication, like a <span class="literal">NULL</span> pointer, when the memory request is too great; others raise an exception.) The problem with this simple memory management scheme is that it wastes memory because there’s no <em>garbage collection</em> mechanism for the application to free the memory so it can be reused later. Garbage collection is one of the main purposes of a heap management system.</p>&#13;
		<p class="indent">The only catch is that supporting garbage collection requires some overhead. The memory management code will need to be more sophisticated, will take longer to execute, and will require some additional memory to maintain the internal data structures the heap management system uses. Consider an easy implementation of a heap manager that supports garbage collection on a 32-bit system. This simple system maintains a (linked) list of <span epub:type="pagebreak" id="page_281"/>free memory blocks. Each free memory block in the list requires two <span class="literal">dword</span> values: one specifying the size of the free block, and the other containing the address of the next free block in the list (that is, the link); see <a href="ch09.xhtml#ch9fig2">Figure 9-2</a>.</p>&#13;
		<div class="image" id="ch9fig2">&#13;
			<img alt="Image" src="../images/09fig02.jpg"/>&#13;
		</div>&#13;
		<p class="figcap"><em>Figure 9-2: Heap management using a list of free memory blocks</em></p>&#13;
		<p class="indent">The system initializes the heap with a <span class="literal">NULL</span> link pointer, and the size field contains the size of the heap’s entire free space. When a memory allocation request comes along, the heap manager searches through the list to find a free block with enough memory to satisfy the request. This search process is one of the defining characteristics of a heap manager. Some common search algorithms are first-fit search and best-fit search. A <em>first-fit search</em>, as its name suggests, scans the list of blocks until it finds the <em>first</em> block of memory large enough to satisfy the allocation request. A <em>best-fit search</em> scans the entire list and finds the <em>smallest</em> block large enough to satisfy the request. The advantage of the best-fit algorithm is that it tends to preserve larger blocks better than the first-fit algorithm, so the system is still able to satisfy larger subsequent allocation requests when they arrive. The first-fit algorithm, on the other hand, just grabs the first suitably large block it finds, even if there’s a smaller block that would suffice, which may limit the system’s ability to handle future large memory requests.</p>&#13;
		<p class="indent">That said, the first-fit algorithm does have a couple of advantages over the best-fit algorithm. The most obvious is that it is usually faster. The best-fit algorithm has to scan through every block in the free block list in order to find the smallest one large enough to satisfy the allocation request (unless, of course, it finds a perfectly sized block along the way). The first-fit algorithm, on the other hand, can stop once it finds a block large enough to satisfy the request.</p>&#13;
		<p class="indent">Another advantage to the first-fit algorithm is that it tends to suffer less from a degenerate condition known as <em>external fragmentation</em>. Fragmentation occurs after a long sequence of allocation and deallocation requests.</p>&#13;
		<p class="noindent"><span epub:type="pagebreak" id="page_282"/>Remember, when the heap manager satisfies a memory allocation request, it usually creates two blocks of memory: one in-use block for the request, and one free block that contains the remaining bytes from the original block (assuming the request did not exactly match the block size). After operating for a while, the best-fit algorithm may have produced lots of leftover blocks of memory that are too small to satisfy an average memory request, making them effectively unusable. As these small fragments accumulate throughout the heap, they can end up consuming a fair amount of memory. This can lead to a situation where the heap doesn’t have a sufficiently large block to satisfy a memory allocation request even though there is enough total free memory available (spread throughout the heap). See <a href="ch09.xhtml#ch9fig3">Figure 9-3</a> for an example of this condition.</p>&#13;
		<div class="image" id="ch9fig3">&#13;
			<img alt="Image" src="../images/09fig03.jpg"/>&#13;
		</div>&#13;
		<p class="figcap"><em>Figure 9-3: Memory fragmentation</em></p>&#13;
		<p class="indent">There are other memory allocation strategies in addition to the first-fit and best-fit search algorithms. Some of these execute faster, some have less memory overhead, some are easy to understand (and some are very complex), some produce less fragmentation, and some can combine and use noncontiguous blocks of free memory. Memory/heap management is one of the more heavily studied subjects in computer science, and there’s a considerable amount of literature explaining the benefits of one scheme over another. For more information on memory allocation strategies, check out a good book on OS design.</p>&#13;
		<h3 class="h3" id="ch00lev1sec77"><strong>9.6 Garbage Collection</strong></h3>&#13;
		<p class="noindent">Memory allocation is only half of the story. As mentioned earlier, the heap manager also has to provide a call that allows an application to free memory it no longer needs for future reuse—a process known as garbage collection. In C and HLA, for example, an application accomplishes this by calling the <span class="literal">free()</span> function. At first blush, <span class="literal">free()</span> might seem to be a very simple function to write. All it has to do is append the previously allocated and now unused block to the end of the free list, right? The problem with this trivial implementation of <span class="literal">free()</span> is that it almost guarantees that the heap will become fragmented and unusable in very short order. Consider the situation in <a href="ch09.xhtml#ch9fig4">Figure 9-4</a>.</p>&#13;
		<p class="indent">If <span class="literal">free()</span> simply takes the block to be freed and appends it to the free list, the memory organization in <a href="ch09.xhtml#ch9fig4">Figure 9-4</a> produces three free blocks. However, because these three blocks are contiguous, the heap manager should really combine them into a single free block, so that it will be able to satisfy a larger request. Unfortunately, this operation would require it <span epub:type="pagebreak" id="page_283"/>to scan the free block list to determine if there are any free blocks adjacent to the block the system is freeing. While you could come up with a data structure that makes it easier to combine adjacent free blocks, such schemes generally add 8 or more bytes of overhead with each block on the heap. Whether this is a reasonable tradeoff depends on the average size of a memory allocation. If the applications that use the heap manager tend to allocate small objects, the extra overhead for each memory block could wind up consuming a large percentage of the heap space. However, if most allocations are large, the few bytes of overhead won’t matter much.</p>&#13;
		<div class="image" id="ch9fig4">&#13;
			<img alt="Image" src="../images/09fig04.jpg"/>&#13;
		</div>&#13;
		<p class="figcap"><em>Figure 9-4: Freeing a memory block</em></p>&#13;
		<h3 class="h3" id="ch00lev1sec78"><strong>9.7 The OS and Memory Allocation</strong></h3>&#13;
		<p class="noindent">The performance of the algorithms and data structures used by the heap manager is only one piece of the performance puzzle. The heap manager ultimately needs to request blocks of memory from the operating system. At one extreme, the OS handles all memory allocation requests directly. At the other extreme, the heap manager is a runtime library routine that links with your application, first requesting large blocks of memory from the OS and then doling out pieces of them as allocation requests arrive from the application.</p>&#13;
		<p class="indent">The problem with making direct memory allocation requests to the operating system is that OS API calls are often very slow. This is because they generally involve switching between kernel mode and user mode on the CPU (which is not fast). Therefore, a heap manager that the OS implements directly will not perform well if your application makes frequent calls to the memory allocation and deallocation routines.</p>&#13;
		<p class="indent">Because of the high overhead of an OS call, most languages implement their own versions of the <span class="literal">malloc()</span> and <span class="literal">free()</span> functions within their runtime library. On the very first memory allocation, the <span class="literal">malloc()</span> routine requests a large block of memory from the OS, and the application’s <span class="literal">malloc()</span> and <span class="literal">free()</span> routines manage this block of memory themselves. If an allocation request comes along that the <span class="literal">malloc()</span> function cannot fulfill in the block it originally created, <span class="literal">malloc()</span> will request another large block (generally much larger than the request) from the OS and add that block to the end of its free list. Because the application’s <span class="literal">malloc()</span> and <span class="literal">free()</span> routines call the OS only occasionally, the application doesn’t suffer the performance hit associated with frequent OS calls.</p>&#13;
		<p class="indent">However, keep in mind that this procedure is very implementation- and language-specific; it’s dangerous to assume that <span class="literal">malloc()</span> and <span class="literal">free()</span> are relatively efficient when writing software that requires high-performance components. The only portable way to ensure a high-performance heap <span epub:type="pagebreak" id="page_284"/>manager is to develop your own application-specific set of allocation/deallocation routines. Writing such routines is beyond the scope of this book (and most standard heap management functions perform well for a typical program), but you should know you have this option.</p>&#13;
		<h3 class="h3" id="ch00lev1sec79"><strong>9.8 Heap Memory Overhead</strong></h3>&#13;
		<p class="noindent">A heap manager often exhibits two types of overhead: performance (speed) and memory (space). Until now, this discussion has mainly dealt with the performance aspects, but now we’ll turn our attention to memory.</p>&#13;
		<p class="indent">Each block the system allocates requires some amount of overhead beyond the storage the application requests; at the very least, this overhead is a few bytes to keep track of the block’s size. Fancier (higher-performance) schemes may require additional bytes, but typically the overhead is between 8 and 64 bytes. The heap manager can keep this information in a separate internal table, or it can attach the block size and other memory management information directly to the block it allocates.</p>&#13;
		<p class="indent">Saving this information in an internal table has a couple of advantages. First, it is difficult for the application to accidentally overwrite the information stored there; attaching the data to the heap memory blocks themselves doesn’t provide as much protection against this possibility. Second, putting memory management information in an internal data structure allows the memory manager to easily determine if a given pointer is valid (that is, points at some block of memory that the heap manager believes it has allocated).</p>&#13;
		<p class="indent">The advantage of attaching the control information directly to each block that the heap manager allocates is that it’s very easy to locate this information, whereas storing the information in an internal table might require a search operation.</p>&#13;
		<p class="indent">Another issue that affects the overhead associated with the heap manager is the <em>allocation granularity</em>—the minimum number of bytes the heap manager supports. Although most heap managers allow you to request an allocation as small as 1 byte, they may actually allocate some minimum number of bytes greater than 1. Generally, the engineer designing the memory allocation functions chooses a granularity guaranteeing that any object allocated on the heap will begin at a reasonably aligned memory address for that object. Thus, most heap managers allocate memory blocks on a 4-, 8-, or 16-byte boundary. For performance reasons, many heap managers begin each allocation on a cache line boundary, usually 16, 32, or 64 bytes. Whatever the granularity, if the application requests some number of bytes that is less than or not a multiple of the heap manager’s granularity, the heap manager will allocate extra bytes of storage (see <a href="ch09.xhtml#ch9fig5">Figure 9-5</a>). This amount varies by heap manager (and possibly even by version of a specific heap manager), so programmers should never assume that their application has more memory available than they request; if they’re tempted to do so, they should request more memory upfront.</p>&#13;
		<p class="indent">The extra memory the heap manager allocates results in another form of fragmentation called <em>internal fragmentation</em> (also shown in <a href="ch09.xhtml#ch9fig5">Figure 9-5</a>). Like <span epub:type="pagebreak" id="page_285"/>external fragmentation, internal fragmentation produces small amounts of leftover memory throughout the system that cannot satisfy future allocation requests. Assuming random-sized memory allocations, the average amount of internal fragmentation that occurs on each allocation is one-half the granularity size. Fortunately, the granularity size is quite small for most memory managers (typically 16 bytes or less), so after thousands and thousands of memory allocations you’ll lose only a couple dozen or so kilobytes to internal fragmentation.</p>&#13;
		<div class="image" id="ch9fig5">&#13;
			<img alt="Image" src="../images/09fig05.jpg"/>&#13;
		</div>&#13;
		<p class="figcap"><em>Figure 9-5: Allocation granularity and internal fragmentation</em></p>&#13;
		<p class="indent">Between the costs associated with allocation granularity and the memory control information, a typical memory request may require between 8 and 64 bytes plus whatever the application requests. If you’re making large memory allocation requests (hundreds or thousands of bytes), the overhead bytes won’t consume a large percentage of memory on the heap. However, if you allocate lots of small objects, the memory consumed by internal fragmentation and memory control information may represent a significant portion of your heap area. For example, consider a simple memory manager that always allocates blocks of data on 4-byte boundaries and requires a single 4-byte length value that it attaches to each allocation request for memory storage. This means that the minimum amount of storage the heap manager requires for each allocation is 8 bytes. If you make a series of <span class="literal">malloc()</span> calls to allocate a single byte, the application won’t be able to use almost 88 percent of the memory it allocates. Even if you allocate 4-byte values on each allocation request, the heap manager consumes two-thirds of the memory for overhead purposes. However, if your average allocation is a block of 256 bytes, the overhead requires only about 2 percent of the total memory allocation. In short, the larger your allocation request, the less impact the control information and internal fragmentation will have on your heap.</p>&#13;
		<p class="indent">Many software engineering studies in computer science journals have found that memory allocation/deallocation requests cause a significant loss of performance. In such studies, the authors often obtained performance improvements of 100 percent or better by simply implementing their own simplified, application-specific, memory management algorithms rather than calling the standard runtime library or OS kernel memory allocation code. Hopefully, this section has made you aware of this potential problem in your own code.</p>&#13;
		<h3 class="h3" id="ch00lev1sec80"><span epub:type="pagebreak" id="page_286"/><strong>9.9 Common Pointer Problems</strong></h3>&#13;
		<p class="noindent">Programmers make six common mistakes when using pointers. Some of these mistakes immediately stop a program with a diagnostic message. Others are subtler, yielding incorrect results without otherwise reporting an error. Still others simply negatively affect the program’s performance. Great programmers are always aware of the risks of using pointers and avoid these mistakes:</p>&#13;
		<ul>&#13;
			<li>&#13;
				<p class="noindent">Using an uninitialized pointer</p>&#13;
				</li>&#13;
			<li>&#13;
				<p class="noindent">Using a pointer that contains an illegal value such as <span class="literal">NULL</span></p>&#13;
				</li>&#13;
			<li>&#13;
				<p class="noindent">Continuing to use storage after it has been freed</p>&#13;
				</li>&#13;
			<li>&#13;
				<p class="noindent">Failing to free storage once the program is done using it</p>&#13;
				</li>&#13;
			<li>&#13;
				<p class="noindent">Accessing indirect data using the wrong data type</p>&#13;
				</li>&#13;
			<li>&#13;
				<p class="noindent">Performing invalid pointer operations</p>&#13;
				</li>&#13;
		</ul>&#13;
		<h4 class="h4" id="ch00lev2sec106"><strong>9.9.1 Using an Uninitialized Pointer</strong></h4>&#13;
		<p class="noindent">Using a pointer variable before you’ve assigned a valid memory address to the pointer is a very common error. Beginning programmers often don’t realize that declaring a pointer variable reserves storage only for the pointer itself, not for the data that the pointer references. The following short C/C++ program demonstrates this problem:</p>&#13;
		<pre class="programs">&#13;
			int main()<br/>{<br/>    static int *pointer;<br/><br/>    *pointer = 0;<br/>}</pre>&#13;
		<p class="indent">Although static variables you declare are, technically, initialized with <span class="literal">0</span> (that is, <span class="literal">NULL</span>), static initialization doesn’t initialize the pointer with a valid address. Therefore, when this program executes, the variable pointer won’t contain a valid address, and the program will fail. To avoid this problem, ensure that all pointer variables contain a valid address prior to dereferencing those pointers. For example:</p>&#13;
		<pre class="programs">&#13;
			int main()<br/>{<br/>     static int i;<br/><br/>     static int *pointer = &amp;i;<br/><br/>    *pointer = 0;<br/>}</pre>&#13;
		<p class="indent"><span epub:type="pagebreak" id="page_287"/>Of course, there’s no such thing as a truly uninitialized variable on most CPUs. Variables are initialized in two different ways:</p>&#13;
		<ul>&#13;
			<li>&#13;
				<p class="noindent">The programmer explicitly gives them an initial value.</p>&#13;
				</li>&#13;
			<li>&#13;
				<p class="noindent">They inherit whatever bit pattern happens to be in memory when the system binds storage to them.</p>&#13;
				</li>&#13;
		</ul>&#13;
		<p class="indent">Much of the time, garbage bit patterns laying around in memory don’t correspond to a valid memory address. Attempting to <em>dereference</em> such an invalid pointer (that is, to access the data in memory at which it points) raises a Memory Access Violation exception, if your OS is capable of trapping this exception.</p>&#13;
		<p class="indent">Sometimes, however, those random bits in memory just happen to correspond to a valid memory location you can access. In this situation, the CPU accesses the specified memory location without aborting the program. A novice programmer might think that accessing random memory is preferable to aborting a program. However, ignoring the error is far worse because your defective program continues to run without alerting you. If you store data using an uninitialized pointer, you may very well overwrite the values of other important variables in memory. This can produce some problems that are very difficult to locate.</p>&#13;
		<h4 class="h4" id="ch00lev2sec107"><strong>9.9.2 Using a Pointer That Contains an Illegal Value</strong></h4>&#13;
		<p class="noindent">The second common mistake programmers make with pointers is assigning them invalid values (“invalid” in the sense of not containing the address of an actual object in memory). This can be considered a more general case of the first problem; without initialization, the garbage bits in memory supply the invalid address. The effects are the same. If you attempt to dereference a pointer containing an invalid address, you will either get a Memory Access Violation exception or access an unexpected memory location. Take care when dereferencing a pointer variable and make sure that you’ve assigned a valid address to the pointer before using it.</p>&#13;
		<h4 class="h4" id="ch00lev2sec108"><strong>9.9.3 Continuing to Use Storage After It Has Been Freed</strong></h4>&#13;
		<p class="noindent">The third mistake is known as the <em>dangling pointer problem</em>. To understand it, consider the following Pascal code fragment:</p>&#13;
		<pre class="programs">&#13;
			(* Allocate storage for a new object of type p  *)<br/><br/>new( p );<br/><br/>(* Use the pointer *)<br/><br/>p^ := 0;<br/>    .<br/>    . (* Code that uses the storage associated with p *)<br/>    .<br/><span epub:type="pagebreak" id="page_288"/>(* free the storage associated with pointer p *)<br/><br/>dispose( p );<br/><br/>    .<br/>    . (* Code that doesn't reference p *)<br/>    .<br/>(* Dangling pointer                             *)<br/><br/>p^ := 5;</pre>&#13;
		<p class="indent">This program allocates some storage and saves the address of that storage in the <span class="literal">p</span> variable. The code uses the storage for a while and then frees it, returning it to the system for other uses. Note that calling <span class="literal">dispose()</span> doesn’t change any data in the allocated memory. It doesn’t change the value of <span class="literal">p</span> in any way; <span class="literal">p</span> still points at the block of memory allocated earlier by <span class="literal">new()</span>. However, calling <span class="literal">dispose()</span> does tell the system that the program no longer needs this block of memory so that the system can use the memory for other purposes. The <span class="literal">dispose()</span> function cannot enforce the fact that you’ll never access this data again, however. You’re simply promising that you won’t. Of course, this code fragment breaks that promise: the last statement stores the value <span class="literal">5</span> at the address pointed to by <span class="literal">p</span> in memory.</p>&#13;
		<p class="indent">The biggest problem with dangling pointers is that sometimes you can get away with using them, so you won’t immediately know there’s a problem. As long as the system doesn’t reuse the storage you’ve freed, using a dangling pointer produces no ill effects in your program. However, with each additional call to <span class="literal">new()</span>, the system may decide to reuse the memory released by that previous call to <span class="literal">dispose()</span>. When it does reuse the memory, any subsequent attempt to dereference the dangling pointer may produce some unintended consequences. The problems can include reading data that has been overwritten, overwriting the new data, and (in the worst case) overwriting system heap management pointers (which will probably cause your program to crash). The solution is clear: never use a pointer value once you free the storage associated with that pointer.</p>&#13;
		<h4 class="h4" id="ch00lev2sec109"><strong>9.9.4 Failing to Free Storage After Using It</strong></h4>&#13;
		<p class="noindent">Of all these mistakes, failing to free allocated storage probably has the least impact on the proper operation of your program. The following C code fragment demonstrates this problem:</p>&#13;
		<pre class="programs">&#13;
			// Pointer to storage in "ptr" variable.<br/><br/>ptr = malloc( 256 );<br/>    .<br/>    . // Code that doesn't free "ptr"<br/>    .<br/>ptr = malloc( 512 );<br/><br/>// At this point, there is no way to reference the<br/>// original block of 256 bytes allocated by malloc.</pre>&#13;
		<p class="indent"><span epub:type="pagebreak" id="page_289"/>In this example, the program allocates 256 bytes of storage and references this storage using the <span class="literal">ptr</span> variable. Later, the program allocates another block of 512 bytes and overwrites the value in <span class="literal">ptr</span> with the address of this new block. The former address value in <span class="literal">ptr</span> is lost. And because the program has overwritten this former value, there’s no way to pass the address of the first 256 bytes to the <span class="literal">free()</span> function. As a result, these 256 bytes of memory are no longer available to your program.</p>&#13;
		<p class="indent">While making 256 bytes of memory inaccessible to your program might not seem like a big deal, imagine that this code executes within a loop. With each iteration of the loop, the program loses another 256 bytes of memory. After a sufficient number of repetitions, the program exhausts the memory available on the heap. This problem is often called a <em>memory leak</em> because the effect is as if the memory bits were leaking out of your computer during program execution.</p>&#13;
		<p class="indent">Memory leaks are less of a problem than dangling pointers. Indeed, there are only two problems with memory leaks:</p>&#13;
		<ul>&#13;
			<li>&#13;
				<p class="noindent">The danger of running out of heap space (which, ultimately, may cause the program to abort, though this is rare)</p>&#13;
				</li>&#13;
			<li>&#13;
				<p class="noindent">Performance problems due to virtual memory page swapping (<em>thrashing</em>)</p>&#13;
				</li>&#13;
		</ul>&#13;
		<p class="indent">Nevertheless, freeing all of the storage you allocate is a good habit to develop.</p>&#13;
		<div class="note">&#13;
			<p class="notet"><strong><span class="notes">NOTE</span></strong></p>&#13;
			<p class="notep"><em>When your program quits, the OS will reclaim all of the storage, including the data lost via memory leaks. Therefore, memory lost via a leak is lost only to your program, not the whole system.</em></p>&#13;
		</div>&#13;
		<h4 class="h4" id="ch00lev2sec110"><strong>9.9.5 Accessing Indirect Data Using the Wrong Data Type</strong></h4>&#13;
		<p class="noindent">Another problem with pointers is that their lack of type-safe access makes it easy to accidentally use the wrong data type. Some languages, like assembly, cannot and do not enforce pointer type checking. Others, like C/C++, make it very easy to override the type of the object a pointer references. For example, consider the following C/C++ program fragment:</p>&#13;
		<pre class="programs">&#13;
			char *pc;<br/>    .<br/>    .<br/>    .<br/>pc = malloc( sizeof( char ));<br/>    .<br/>    .<br/>    .<br/>// Typecast pc to be a pointer to an integer<br/>// rather than a pointer to a character:<br/><br/>*((int *) pc) = 5000;</pre>&#13;
		<p class="indent"><span epub:type="pagebreak" id="page_290"/>Generally, if you attempt to assign the value <span class="literal">5000</span> to the object pointed to by <span class="literal">pc</span>, the compiler will complain bitterly. The value <span class="literal">5000</span> won’t fit in the amount of storage associated with a character (<span class="literal">char</span>) object, which is 1 byte. This example, however, uses <em>type casting</em> (or <em>coercion</em>) to tell the compiler that <span class="literal">pc</span> really contains a pointer to an integer rather than a pointer to a character. Therefore, the compiler will assume that this assignment is legal.</p>&#13;
		<p class="indent">However, if <span class="literal">pc</span> doesn’t actually point at an integer object, the last statement in this sequence can be disastrous. Characters are 1 byte long, and integers are usually larger. If the integer is larger than 1 byte, this assignment will overwrite some number of bytes beyond the 1 byte of storage that <span class="literal">malloc()</span> allocated. Whether or not this is catastrophic depends upon what data immediately follows the character object in memory.</p>&#13;
		<h4 class="h4" id="ch00lev2sec111"><strong>9.9.6 Performing Illegal Operations on Pointers</strong></h4>&#13;
		<p class="noindent">The last category of common pointer mistakes has to do with operations on the pointers themselves. Arbitrary pointer arithmetic can lead to a pointer that points outside the range of the data originally allocated. By doing some crazy arithmetic, you can even modify a pointer so that it doesn’t point at a correct object. Consider the following (really nasty) C code:</p>&#13;
		<pre class="programs">&#13;
			int  i [4] = {1,2,3,4};<br/>int *p     = &amp;i[0];<br/>      .<br/>      .<br/>      .<br/>    p = (int *)((char *)p + 1);<br/>    *p = 5;</pre>&#13;
		<p class="indent">This example casts <span class="literal">p</span> as a pointer to a <span class="literal">char</span>. Then it adds <span class="literal">1</span> to the value in <span class="literal">p</span>. As the compiler thinks that <span class="literal">p</span> is pointing at a character (because of the cast), it actually adds the value <span class="literal">1</span> to the address held in <span class="literal">p</span>. The last instruction in this sequence stores the value <span class="literal">5</span> into the memory address pointed at by <span class="literal">p</span>, which is now 1 byte into the 4 bytes set aside for the <span class="literal">i[0]</span> element. On some machines, this will cause a fault; on others, it will store a bizarre value into <span class="literal">i[0]</span> and <span class="literal">i[1]</span>.</p>&#13;
		<p class="indent">Comparing two pointers for less than or greater than when the two pointers do not point to the same object (typically an array or struct) is another example of an illegal operation on a pointer, as is casting a pointer as an integer and assigning an integer value to that pointer, which can produce unexpected results.</p>&#13;
		<h3 class="h3" id="ch00lev1sec81"><strong>9.10 Pointers in Modern Languages</strong></h3>&#13;
		<p class="noindent">Because of the problems described in the previous section, modern HLLs (like Java, C#, Swift, and C++11/C++14) try to eliminate manual memory allocation and deallocation. These languages let you create new objects on the heap (typically using a <span class="literal">new()</span> function) but don’t provide any facilities for explicitly deallocating that storage. Instead, the language’s runtime system tracks memory usage and automatically recovers the storage, via <span epub:type="pagebreak" id="page_291"/>garbage collection, once the program is no longer using it. This eliminates most (but not all) of the problems with uninitialized and dangling pointers. It also lowers the likelihood of memory leaks. These new languages dramatically reduce the number of problems related to errant pointer use.</p>&#13;
		<p class="indent">Of course, ceding control over memory allocation and deallocation introduces some problems of its own. In particular, you give up the ability to control the memory allocation lifetime. Now, the runtime system determines when to garbage-collect unused data, so large chunks of data could still be reserved for some time after you’ve finished using them.</p>&#13;
		<h3 class="h3" id="ch00lev1sec82"><strong>9.11 Managed Pointers</strong></h3>&#13;
		<p class="noindent">Some programming languages provide very limited pointer capabilities. For example, standard Pascal allows only a few operations on pointers: assignment (copy), comparison (for equality/inequality), and dereferencing. It does not support pointer arithmetic, meaning many types of mistakes with pointers are impossible.<sup><a id="ch9fn_4"/><a href="footnotes.xhtml#ch9fn4">4</a></sup> At the other extreme is C/C++, which allows different arithmetic operations on pointers that make the language very powerful but introduce the likelihood of defects in the code.</p>&#13;
		<p class="indent">Modern language systems (for example, C# and the Microsoft Common Language Runtime system) introduce <em>managed pointers</em>, which allow various arithmetic operations on pointers, providing greater flexibility than a language like standard Pascal, but with restrictions that help avoid many common pointer pitfalls. For example, in these languages you cannot add an arbitrary integer to an arbitrary pointer (as is possible in C/C++). If you want to add an integer to a pointer and obtain a legal result, the pointer must contain the address of an array object (or other collection of like elements in memory). Furthermore, the integer’s value must be limited to a value that does not exceed the size of the data type (that is, the runtime system enforces array bounds checking).</p>&#13;
		<p class="indent">While using managed pointers won’t eliminate all pointer problems, it does prevent wiping out data outside the range of a data object referenced by a pointer. It also helps prevent security issues in software, such as attempts to break into a system by providing illegal offsets in pointer arithmetic.</p>&#13;
		<h3 class="h3" id="ch00lev1sec83"><strong>9.12 For More Information</strong></h3>&#13;
		<p class="bib">Duntemann, Jeff. <em>Assembly Language Step-by-Step</em>. 3rd ed. Indianapolis: Wiley, 2009.</p>&#13;
		<p class="bib">Hyde, Randall. <em>The Art of Assembly Language</em>. 2nd ed. San Francisco: No Starch Press, 2010.</p>&#13;
		<p class="bib">Oualline, Steve. <em>How Not to Program in C++</em>. San Francisco: No Starch Press, 2003.<span epub:type="pagebreak" id="page_292"/></p>&#13;
	</body></html>