<html xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops" epub:prefix="index: http://www.index.com/" lang="en" xml:lang="en">
<head>
<title>Chapter 11: Graphics</title>
<link href="NSTemplate_v1.css" rel="stylesheet" type="text/css"/>
<meta content="urn:uuid:c2f206e1-36e8-4f89-b533-508263d6ec16" name="Adept.expected.resource"/>
</head>
<body epub:type="bodymatter chapter">
<section>
<header>
<h1 class="chapter">
<span class="ChapterNumber"><span epub:type="pagebreak" id="Page_99" title="99"/>11</span><br/>
<span class="ChapterTitle">Graphics</span></h1>
</header>
<figure class="graphic">
<img alt="g11001" src="image_fi/502680c11/g11001.png"/></figure>

<p class="ChapterIntro"><span class="dropCap">W</span>hen people on the Android team say “graphics,” they may mean vastly different things, because there are many layers of graphics functionality that are implemented by very distinct teams for very different reasons. For example, there are 3D graphics systems using OpenGL ES,<sup class="FootnoteReference"><a href="#c11-footnote-1" id="c11-footnoteref-1">1</a></sup> and more recently, Vulkan, for supporting anything from games to mapping applications to Virtual Reality to Augmented Reality. There are graphics capabilities in the UI toolkit, which is responsible for drawing things like text, shapes, lines, and images, so that application developers can populate their user interfaces with, well, graphics. And then there is the lowest level of graphics on the system which provides the fundamental capability for pixels and windows to appear on the screen.</p>
<p>We’ll start with this lowest level of graphics, which came about through the work of Mathias Agopian, another hire from Be and PalmSource, who started on the Android team in late 2006.</p>
<span epub:type="pagebreak" id="Page_100" title="100"/><figure>
<img alt="" class="" src="image_fi/502680c11/f11001.png"/>
<figcaption><p>A vastly simplified view of Android’s graphics system. Applications call into the Canvas API to draw things. The Canvas API is implemented underneath by the Skia rendering engine, which turns things like shapes and text into pixels. SurfaceFlinger provides a buffer, or surface, into which these pixels are drawn. SurfaceFlinger calls into OpenGL ES, a low-level graphics API that renders triangles. OpenGL ES uses PixelFlinger to draw the buffer: Note that PixelFlinger was eventually replaced by a GPU (Graphics Processing Unit) when GPUs became standard in smartphones. Finally, all of the surfaces that need to be drawn onto the screen (including the foreground application as well as the status and navigation bars) are composed together in the Hardware Composer and then displayed on the screen for the user to see.</p></figcaption>
</figure>
<h2 id="h1-502680c11-0001">Mathias Agopian and Android Graphics</h2>
<blockquote class="Epigraph" epub:type="epigraph">
<p class="Epigraph">Software rendering, in my opinion, was going to die.</p>
<p class="EpigraphSource">—Mathias Agopian</p>
</blockquote>
<p class="BodyFirst">Mathias is a calm and quiet person who arrives at the office late, stays very late, and focuses almost exclusively on coding (avoiding email and meetings as much as possible).</p>
<p>In the early days, Mathias had a temper<sup class="FootnoteReference"><a href="#c11-footnote-2" id="c11-footnoteref-2">2</a></sup> that would occasionally surface. Something would upset him and he would storm out, sometimes staying away <span epub:type="pagebreak" id="Page_101" title="101"/>for several days or even weeks. In one episode, Mathias was upset at Brian Swetland. He threw his phone and marched out of the office, only to return a few minutes later to ask for his phone back, since he needed its memory card.<sup class="FootnoteReference"><a href="#c11-footnote-3" id="c11-footnoteref-3">3</a></sup></p>
<p>Mathias spent his childhood learning how to program various computers, from the Armstrad CPC to several Atari computers, to the BeBox. He wrote graphics and audio applications for his Atari Falcon (including a sound tracker app for the Falcon which he sold under the name Crazy Music Machine<sup class="FootnoteReference"><a href="#c11-footnote-4" id="c11-footnoteref-4">4</a></sup>) and he became known<sup class="FootnoteReference"><a href="#c11-footnote-5" id="c11-footnoteref-5">5</a></sup> for programming articles that he wrote for French computer magazines. He also, as a hobby, wrote Epson printer drivers for the Atari and the BeBox, which those companies shipped with their systems. His work on the Be printer drivers resulted in a job; he left France to join Be in 1999.</p>
<p>Mathias stayed at Be until they were acquired by Palm and continued on with the rest of the team at PalmSource, working mostly on graphics software, until he decided he’d had enough of wherever PalmSource was going. He left around the same time as Joe Onorato and joined Google to work on Android in late 2005.</p>
<h2 id="h1-502680c11-0002">The Basics</h2>
<p class="BodyFirst">When Mathias joined Android, he started on system fundamentals. The operating system essentially didn’t exist yet, so everyone who joined at that time helped out with building basic necessities.</p>
<p>For example, the platform didn’t yet have core data structures for C++ (Vector and HashMap). In a desktop or server world, these pieces wouldn’t have been needed, because they come with standard libraries that developers typically use. But on Android, especially at that time, the platform only <span epub:type="pagebreak" id="Page_102" title="102"/>included code and libraries that were absolutely necessary. Adding standard libraries would have pulled in too many unnecessary pieces, taking up storage space that simply wasn’t available. So Mathias wrote versions of these data structures that everyone could use for Android development.</p>
<p>Mathias also worked on optimizing memcpy<sup class="FootnoteReference"><a href="#c11-footnote-6" id="c11-footnoteref-6">6</a></sup> and memset, low-level utilities for manipulating chunks of memory. Memcpy is a critical piece of software used by the entire system,<sup class="FootnoteReference"><a href="#c11-footnote-7" id="c11-footnoteref-7">7</a></sup> and is often a performance bottleneck in memory-intensive situations. Bob Lee commented on this work, “He hand-wrote this assembly language for memcpy, made it insanely fast and had a huge performance improvement. It was brilliant.”</p>
<h2 id="h1-502680c11-0003">PixelFlinger<sup class="FootnoteReference"><a href="#c11-footnote-8" id="c11-footnoteref-8">8</a></sup></h2>
<p class="BodyFirst">Mathias’s main goal for the graphics system was to implement something he called SurfaceFlinger, which was needed to display the buffers (<em>surfaces</em>) full of graphics that were produced by all of the applications on the system. But this system depended on lower-level functionality that did not yet exist, so he started there instead.</p><p>One of Mathias’s assumptions was that SurfaceFlinger would need a GPU<sup class="FootnoteReference"><a href="#c11-footnote-9" id="c11-footnoteref-9">9</a></sup> to do its work; it would use OpenGL ES to perform the low-level operations required to get the graphics data from the application into buffers, and then to display those buffers onto the screen. The problem was, Android <span epub:type="pagebreak" id="Page_103" title="103"/>wasn’t running on a device with a GPU. The device that Android was targeting at that time, and all the way through the launch of the SDK, was Sooner, which had no GPU and therefore no OpenGL ES.</p>
<p>But Mathias saw a future in which GPUs would be standard on smartphones. “Before joining Android, I had a little bit of experience with mobile platforms. And it was really, really obvious to me that in the future we would be rendering using hardware.<sup class="FootnoteReference"><a href="#c11-footnote-10" id="c11-footnoteref-10">10</a></sup> Software rendering, in my opinion, was going to die.</p>
<p>“My idea was: I want everything to be ready for when we get hardware. The problem is, we don’t have hardware. We don’t really know when it’s going to happen. So I thought, I’m in charge of graphics, I’m going to pretend I have a GPU. So I wrote a GPU, essentially. This way, I was able to write SurfaceFlinger using ‘GL.’ It was using real OpenGL ES, but it defaulted to software. And then, little by little, real hardware started to show up.”</p>
<p>When Mathias said that he wrote a GPU, he meant that he wrote a <em>virtual</em> GPU; software that performed the same work as a GPU would, but in software instead of dedicated hardware. A GPU is not magical; the dedicated hardware in a GPU is not doing anything that cannot be done by software running on the CPU instead. It just does that job much faster, since it has hardware that is optimized for graphics operations.<sup class="FootnoteReference"><a href="#c11-footnote-11" id="c11-footnoteref-11">11</a></sup> In writing his fake GPU, Mathias provided a software layer to handle graphics operations normally handled by a GPU, translating those commands to low-level information that the existing Android display system could understand.</p>
<p>The OpenGL ES layer that he wrote issued commands to a lower layer that handled drawing textured triangles,<sup class="FootnoteReference"><a href="#c11-footnote-12" id="c11-footnoteref-12">12</a></sup> called PixelFlinger. This extra layer of abstraction of using OpenGL ES on top of PixelFlinger added work and <span epub:type="pagebreak" id="Page_104" title="104"/>overhead and wouldn’t have made sense if it were the only device Android was targeting. But in a world where Android was aiming at the future, and the future almost certainly included GPU hardware, this meant that SurfaceFlinger had to be written only once, to target OpenGL ES. As soon as the future matched Mathias’s vision and GPUs were available, it would continue working as-is, but faster (using hardware, instead of the software-based PixelFlinger).</p>
<p>Mathias’s approach of writing PixelFlinger’s virtual GPU was an example of the <em>product versus platform</em> approach that Android took in the early days.<sup class="FootnoteReference"><a href="#c11-footnote-13" id="c11-footnoteref-13">13</a></sup> A <em>product</em> approach, where the team simply got the initial phone to work as quickly as possible, wouldn’t have taken as long. But the <em>platform</em> approach that Mathias took, building up layers of software that scaled way beyond that initial release, proved useful to Android in the long run. “It was necessary to go through that step to be ready for when the hardware was there. But also to convince people that that’s what needed to happen.”</p>
<p>This long-term approach to the graphics system, and other parts of the platform, was an element of the team’s approach in those early days. Overall, the team was very scrappy, preferring small, hard-working teams, and making quick, pragmatic decisions as they drove toward 1.0. But several of the decisions that the team made early on, and the extra work those required, happened because they were the right thing for the future of the platform, even though that future wasn’t assured. So although the team was focused on the goal of shipping 1.0, they were trying to do so with a platform that would live beyond that single ship date, into the future that Android eventually achieved.</p>
<p>PixelFlinger had a limited shelf life in terms of Android phones. It was critical for the Sooner device that the team used during early development, but the G1 that shipped with 1.0 already had the GPU capabilities<sup class="FootnoteReference"><a href="#c11-footnote-14" id="c11-footnoteref-14">14</a></sup> that Mathias had wanted and predicted. The importance of PixelFlinger wasn’t in the capabilities that it provided for specific products, but in what it meant for the platform, to build in forward-looking capabilities that drove an architecture and ecosystem into a hardware-accelerated future.<sup class="FootnoteReference"><a href="#c11-footnote-15" id="c11-footnoteref-15">15</a></sup></p>
<h2 id="h1-502680c11-0004"><span epub:type="pagebreak" id="Page_105" title="105"/>SurfaceFlinger</h2>
<p class="BodyFirst">Once PixelFlinger and OpenGL ES were working, Mathias could implement SurfaceFlinger. Applications draw their graphics objects (buttons, text, images—whatever) into a buffer in memory and SurfaceFlinger posts that buffer to the screen, visible to the user. SurfaceFlinger was essentially the glue between the higher-level graphics operations happening in applications and the OpenGL ES layer that he had written previously, responsible for copying buffers around and displaying them to the user. The separation of app rendering from displaying the pixels on the screen was intentional; one of Mathias’s design goals was to enable smooth graphics by ensuring that no app could cause rendering performance problems for any other app (this was related to Android’s overall approach to security on the platform, where there was always a clear separation of applications from each other). So applications would draw into buffers, and SurfaceFlinger would take it from there.</p>
<h2 id="h1-502680c11-0005">Hardware Composer</h2>
<p class="BodyFirst">The other part of the graphics system that Mathias wrote was the Hardware Composer (HWC). SurfaceFlinger handles drawing UI graphics into a window on the screen. But there are several windows that need to be combined together to make up the final pixels on the screen.</p>
<figure>
<img alt="" class="" src="image_fi/502680c11/f11002.png"/>
<figcaption><p>A sample Android screen, showing the typical status bar, navigation bar, and home screen</p></figcaption>
</figure>
<p><span epub:type="pagebreak" id="Page_106" title="106"/>Think about a typical Android screen that the user sees. There is a status bar (where the current time and various status and notification icons show up), a navigation bar (where the back and home buttons reside), and finally the actual foreground application (or the home screen). There may be other windows as well, like popup menus on top of the foreground application.</p>
<p>All of these are separate windows, often running in separate processes. For example, the navigation and status bars are managed by the system process, whereas the application window is owned by the application process. All of these windows need to be displayed together in some sensible way, which is the job of the Hardware Composer.</p>
<p>Mathias’s idea for HWC was to use specialized graphics hardware called hardware overlays,<sup class="FootnoteReference"><a href="#c11-footnote-16" id="c11-footnoteref-16">16</a></sup> which provide display memory dedicated to each application, avoiding the overhead of all applications sharing the same video memory. Using overlay hardware also saved power and provided higher performance for applications. By using dedicated overlay hardware, the system avoided using the power-hungry GPU for these simple and frequent windowing operations. Also, using overlays left the GPU available for use by applications,<sup class="FootnoteReference"><a href="#c11-footnote-17" id="c11-footnoteref-17">17</a></sup> for accelerating games or other graphics-intensive operations.</p>
<p>Rather than drawing each of these windows manually on the screen, or telling the GPU to draw them through OpenGL ES, the HWC would send each of the windows to a different overlay. The display hardware would then compose these overlays together onto the screen to make it all look like one seamless screen of information, rather than the several completely different processes that they actually are.</p>
<p>The problem was that overlays were difficult to use in practice, since every device tended to have different numbers and capabilities of overlays. But given the GPU limitations of the G1, plus relatively good overlay support on that device, Mathias and Jason Sams came up with a novel approach. Instead of trying to handle the infinite variations of overlays directly in HWC, their software would tell the underlying hardware what HWC needed <span epub:type="pagebreak" id="Page_107" title="107"/>and either the hardware could support their requirements or HWC would back off to using OpenGL ES. Over time, hardware vendors saw the benefit of handling these overlay operations directly and it became an area for vendors to offer extra performance on their devices for this critical area of the platform.</p>
<h2 id="h1-502680c11-0006">Mike Reed and Skia</h2>
<p class="BodyFirst">All of Mathias’s work was predicated on having something to display on the screen: graphics content from the applications. The system for applications to draw graphics content for their UIs also needed to be created. For that, Android used a rendering system called Skia that was acquired early on from Mike Reed.</p>
<p>If “serial graphics entrepreneur” is a real thing, that’s what Mike Reed is.</p>
<p>Mike started programming late in life, at least compared to many of the early Android engineers. Mike got college degrees in science and math. But in 1984, the original Macintosh was released and showed up on his campus. “That changed everything. I wanted to do graphics, because that’s what the Mac was really showing off. So I got a math degree, but taught myself programming.”</p>
<p>Mike managed to get hired at Apple after grad school (“I just squeaked into that job”), where he met Cary Clark, future co-founder of Skia.<sup class="FootnoteReference"><a href="#c11-footnote-18" id="c11-footnoteref-18">18</a></sup> After several years at Apple, Mike left and started HeadSpin, creating a game engine used by CD-ROM games. HeadSpin was acquired by Cyan, makers of the game <em>Myst</em>, and Mike left to start a new graphics technology company called AlphaMask. AlphaMask was acquired by Openwave, a company providing browser software for mobile devices. </p>
<p>Mike left Openwave in 2004 and started Skia with Cary, his former Apple colleague, where they created a graphics rendering engine. Skia licensed its engine to various clients, including several in California. For one of Mike’s trips to California, Cary suggested that Mike should meet with a startup called Android, which had been founded by a couple of Cary’s former colleagues at WebTV: Andy Rubin and Chris White.</p>
<p><span epub:type="pagebreak" id="Page_108" title="108"/>In late 2004, Android was quite small, with only the two co-founders plus new employees Brian Swetland and Tracey Cole. Android was in the midst of a pivot from building a camera OS to a phone OS. Nevertheless, Andy knew that they would need a rendering engine to display the UI, so he paid Mike for an evaluation license of Skia and agreed to get back in touch. But Mike didn’t hear back from him: “Andy just fell off the map and he didn’t respond to emails.”</p>
<p>Months later, in the Summer of 2005, Andy finally contacted Mike. “He says, ‘Sorry I dropped out, but I’m emailing you from a new email address.’ And sure enough, it’s something@google.com. He says, ‘Hey I got acquired. We should probably finish that license.’”</p>
<p>But instead of just being another licensee of Skia’s rendering engine, Google acquired Mike’s company. Android was, after all, in hiring mode, and acquisitions can be an effective way (if you have the money) to hire multiple people quickly.</p>
<p>The acquisition was announced on November 9, 2005, and the four engineers from Skia (Mike, Cary, Leon Scroggins, and Patrick Scott) started in December.</p>
<p>One of the points of negotiation was location. Mike and Cary had, years earlier, made the decision to leave California and settle in North Carolina, and they weren’t wild about returning to the Bay Area. Google agreed to leave the team in North Carolina, where they established the new Chapel Hill office.<sup class="FootnoteReference"><a href="#c11-footnote-19" id="c11-footnoteref-19">19</a></sup></p>
<p>After the team started at Google, they got to work making Skia the graphics engine for Android. The underlying rendering software itself was fairly complete; they had full support in C++ for the kinds of 2D drawing operations that Android needed (lines, shapes, text, and images). In fact, the raw graphics functionality of Skia in Android has changed very little since those early years (though major improvements have happened along the way, like hardware acceleration). But given Android’s choice of Java as the main programming language for applications, they needed Skia to be callable from Java, not C++, so the team wrote the Java bindings.<sup class="FootnoteReference"><a href="#c11-footnote-20" id="c11-footnoteref-20">20</a></sup></p>
<p><span epub:type="pagebreak" id="Page_109" title="109"/>Writing bindings for Skia and integrating the engine into the rest of the Android platform wasn’t too difficult, so the Skia team soon picked up a couple other projects. One of the projects, the new UI system, was short-lived. Mike’s team proposed that Android use Skia’s existing system for displaying UI. They had a system working already that developers programmed using a combination of JavaScript and XML. But the move to Java, plus some late-night work from Joe Onorato,<sup class="FootnoteReference"><a href="#c11-footnote-21" id="c11-footnoteref-21">21</a></sup> sent the team down a different path.</p>
</section>
<section class="footnotes">
<aside class="FootnoteEntry"><p><sup class="FootnoteReference"><a href="#c11-footnoteref-1" id="c11-footnote-1">1.</a></sup>  OpenGL is an API for performing graphics operations (typically 3D, used by games, but also 2D). Graphics operations are essentially a combination of shape and image drawing, and OpenGL handles those operations, executing commands on a GPU to do the work. OpenGL ES is a subset of OpenGL that is specifically targeted at embedded devices like smartphones.</p></aside>
<aside class="FootnoteEntry"><p><sup class="FootnoteReference"><a href="#c11-footnoteref-2" id="c11-footnote-2">2.</a></sup>  I haven’t actually seen this in action; it might have been related to the stress of those early days and all of the hours that everyone was putting in to ship the product.</p></aside>
<aside class="FootnoteEntry"><p><sup class="FootnoteReference"><a href="#c11-footnoteref-3" id="c11-footnote-3">3.</a></sup>  Swetland remembered: “To be fair, he threw it past me; there was no need for me to dodge. I was fighting some nasty pre-1.0 ship thing too and said, ‘I don’t have time for this right now,’ that I think was the last straw for him that day.” 
Hiroshi would regularly send devices that had hardware issues back to HTC for evaluation. Swetland remembered putting that thrown device into the next round: “I followed the normal process and left Mathias’s G1, with a shattered display, on Hiroshi’s desk with a post-it describing the suspected issue: ‘Poor anger management.’”</p></aside>
<aside class="FootnoteEntry"><p><sup class="FootnoteReference"><a href="#c11-footnoteref-4" id="c11-footnote-4">4.</a></sup>  Published by Application Systems Paris.</p></aside>
<aside class="FootnoteEntry"><p><sup class="FootnoteReference"><a href="#c11-footnoteref-5" id="c11-footnote-5">5.</a></sup>  Nicolas Roard, a French developer on Android’s browser team in the early days, knew Mathias’s name before he got to Google because of Mathias’s articles Nicolas had read during high school.</p></aside>
<aside class="FootnoteEntry"><p><sup class="FootnoteReference"><a href="#c11-footnoteref-6" id="c11-footnote-6">6.</a></sup>  Unix commands are typically abbreviated and often cryptic. It’s not obvious, especially today, why “memcpy” is more useful than fully spelling it out as “memcopy.” But there were probably multiple reasons for abbreviating things when Unix was created in the early 1970s, including storage space constraints as well as transmission time for characters on teletype machinery. Brian Swetland also attributed it to “just good old fashioned programmer laziness—I recently built a little program to test a radio interface and I called the binary <em>rctl</em> not <em>radio-control</em>—regarding things one expects to type over and over again.” 
Ken Thompson, one of the designers of Unix, in the book <em>The UNIX Programming Environment</em>, replied to a question of whether he’d do anything differently if he were redesigning Unix by saying, “I’d spell <em>creat</em> with an <em>e</em>.”</p></aside>
<aside class="FootnoteEntry"><p><sup class="FootnoteReference"><a href="#c11-footnoteref-7" id="c11-footnote-7">7.</a></sup>  This doesn’t apply to just Android; memcpy is a fundamental piece of every OS, because copying memory around tends to be an important thing in software systems.</p></aside>
<aside class="FootnoteEntry"><p><sup class="FootnoteReference"><a href="#c11-footnoteref-8" id="c11-footnote-8">8.</a></sup>  Mathias chose the name PixelFlinger as an homage to some graphics code called Bitflinger written at Be by Jason Sams, a colleague at Be and Android.</p></aside>
<aside class="FootnoteEntry"><p><sup class="FootnoteReference"><a href="#c11-footnoteref-9" id="c11-footnote-9">9.</a></sup>  GPUs speed up graphics operations. They have been standard in desktop computers since the late 1990s, but were not standard in phone hardware when Mathias was doing this work.</p></aside>
<aside class="FootnoteEntry"><p><sup class="FootnoteReference"><a href="#c11-footnoteref-10" id="c11-footnote-10">10.</a></sup>  To clarify, all rendering happens on the phone’s hardware. But there’s a big difference between CPU rendering (where a general-purpose system computes pixel values) and GPU rendering (where a dedicated graphics processor computes those pixel values). GPUs are much better and faster at that job. That’s what Mathias is referring to as <em>hardware rendering</em>.</p></aside>
<aside class="FootnoteEntry"><p><sup class="FootnoteReference"><a href="#c11-footnoteref-11" id="c11-footnote-11">11.</a></sup>  Specifically, GPUs at that time optimized texture mapping, which draws geometry overlaid with image data. Most graphics that we see on the screen, from complex games to simple 2D buttons, can be boiled down to image data on geometry.</p></aside>
<aside class="FootnoteEntry"><p><sup class="FootnoteReference"><a href="#c11-footnoteref-12" id="c11-footnote-12">12.</a></sup>  GPUs, and therefore underlying rendering engines for OpenGL ES, are essentially triangle renderers; they draw triangles that usually contain some kind of image data (textures), which, when drawn with many other textured-triangles, can create a visually complex scene. There is a lot more to it, of course, but rendered scenes, even complex 3D ones in games or movie effects, are essentially collections of textured triangles. </p></aside>
<aside class="FootnoteEntry"><p><sup class="FootnoteReference"><a href="#c11-footnoteref-13" id="c11-footnote-13">13.</a></sup>  See <span class="xref" itemid="xref_target_Chapter 29">Chapter 29</span> (“Product vs. Platform”) for more on this.</p></aside>
<aside class="FootnoteEntry"><p><sup class="FootnoteReference"><a href="#c11-footnoteref-14" id="c11-footnote-14">14.</a></sup>  The G1’s GPU had a serious limitation, however; only a single process at a time could use it.</p></aside>
<aside class="FootnoteEntry"><p><sup class="FootnoteReference"><a href="#c11-footnoteref-15" id="c11-footnote-15">15.</a></sup>  In fact, PixelFlinger was still used for a long time after 1.0: for the boot animation seen when the phone starts up, for the device upgrade UI, and for the emulator. The emulator, which runs on developers’ computers, had no access to a GPU, so it used Mathias’s virtual GPU for many years.</p></aside>
<aside class="FootnoteEntry"><p><sup class="FootnoteReference"><a href="#c11-footnoteref-16" id="c11-footnote-16">16.</a></sup>  Overlays are specialized display hardware for displaying different windows of graphics, especially windows with fast-moving images, including videos and games.</p></aside>
<aside class="FootnoteEntry"><p><sup class="FootnoteReference"><a href="#c11-footnoteref-17" id="c11-footnote-17">17.</a></sup>  Using overlays was actually a requirement for the G1. Only one process at a time could use the GPU, so if HWC used the GPU, apps could not. Using the overlay hardware was a good workaround for this constraint.</p></aside>
<aside class="FootnoteEntry"><p><sup class="FootnoteReference"><a href="#c11-footnoteref-18" id="c11-footnote-18">18.</a></sup>  Cary was also an engineer on the Skia team at Google for many years.</p></aside>
<aside class="FootnoteEntry"><p><sup class="FootnoteReference"><a href="#c11-footnoteref-19" id="c11-footnote-19">19.</a></sup>  The Chapel Hill office continued to expand over time, as the Skia team grew and took on graphics rendering projects beyond Android.</p></aside>
<aside class="FootnoteEntry"><p><sup class="FootnoteReference"><a href="#c11-footnoteref-20" id="c11-footnote-20">20.</a></sup>  Bindings are functions in Java that wrap underlying C++ functionality. Calling a binding function essentially transfers execution from Java code down into C++ code.</p></aside>
<aside class="FootnoteEntry"><p><sup class="FootnoteReference"><a href="#c11-footnoteref-21" id="c11-footnote-21">21.</a></sup>  We’ll see more about Joe’s efforts in <span class="xref" itemid="xref_target_Chapter 14">Chapter 14</span> (“UI Toolkit”).</p></aside>
</section>
</body>
</html>