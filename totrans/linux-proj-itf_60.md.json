["```\n`sockets/id_echo.h`\n#include \"inet_sockets.h\"       /* Declares our socket functions */\n#include \"tlpi_hdr.h\"\n\n#define SERVICE \"echo\"          /* Name of UDP service */\n\n#define BUF_SIZE 500            /* Maximum size of datagrams that can\n                                   be read by client and server */\n      `sockets/id_echo.h`\n```", "```\n`sockets/id_echo_sv.c`\n#include <syslog.h>\n#include \"id_echo.h\"\n#include \"become_daemon.h\"\n\nint\nmain(int argc, char *argv[])\n{\n    int sfd;\n    ssize_t numRead;\n    socklen_t addrlen, len;\n    struct sockaddr_storage claddr;\n    char buf[BUF_SIZE];\n    char addrStr[IS_ADDR_STR_LEN];\n\n    if (becomeDaemon(0) == -1)\n        errExit(\"becomeDaemon\");\n\n    sfd = inetBind(SERVICE, SOCK_DGRAM, &addrlen);\n    if (sfd == -1) {\n        syslog(LOG_ERR, \"Could not create server socket (%s)\", strerror(errno));\n        exit(EXIT_FAILURE);\n    }\n\n    /* Receive datagrams and return copies to senders */\n\n    for (;;) {\n        len = sizeof(struct sockaddr_storage);\n        numRead = recvfrom(sfd, buf, BUF_SIZE, 0,\n                           (struct sockaddr *) &claddr, &len);\n        if (numRead == -1)\n            errExit(\"recvfrom\");\n\n        if (sendto(sfd, buf, numRead, 0, (struct sockaddr *) &claddr, len)\n                    != numRead)\n            syslog(LOG_WARNING, \"Error echoing response to %s (%s)\",\n                    inetAddressStr((struct sockaddr *) &claddr, len,\n                                   addrStr, IS_ADDR_STR_LEN),\n                    strerror(errno));\n    }\n}\n     `sockets/id_echo_sv.c`\n```", "```\n`sockets/id_echo_cl.c`\n#include \"id_echo.h\"\n\nint\nmain(int argc, char *argv[])\n{\n    int sfd, j;\n    size_t len;\n    ssize_t numRead;\n    char buf[BUF_SIZE];\n\n    if (argc < 2 || strcmp(argv[1], \"--help\") == 0)\n        usageErr(\"%s: host msg...\\n\", argv[0]);\n\n    /* Construct server address from first command-line argument */\n\n    sfd = inetConnect(argv[1], SERVICE, SOCK_DGRAM);\n    if (sfd == -1)\n        fatal(\"Could not connect to server socket\");\n\n    /* Send remaining command-line arguments to server as separate datagrams */\n\n    for (j = 2; j < argc; j++) {\n        len = strlen(argv[j]);\n        if (write(sfd, argv[j], len) != len)\n            fatal(\"partial/failed write\");\n\n        numRead = read(sfd, buf, BUF_SIZE);\n        if (numRead == -1)\n            errExit(\"read\");\n\n        printf(\"[%ld bytes] %.*s\\n\", (long) numRead, (int) numRead, buf);\n    }\n\n    exit(EXIT_SUCCESS);\n}\n     `sockets/id_echo_cl.c`\n```", "```\n$ `su`                                      *Need privilege to bind reserved port*\nPassword:\n# `./id_echo_sv`                            *Server places itself in background*\n# `exit`                                    *Cease to be superuser*\n$ `./id_echo_cl localhost hello world`      *This client sends two datagrams*\n[5 bytes] hello                           *Client prints responses from server*\n[5 bytes] world\n$ `./id_echo_cl localhost goodbye`          *This client sends one datagram*\n[7 bytes] goodbye\n```", "```\n`sockets/is_echo_sv.c`\n#include <signal.h>\n#include <syslog.h>\n#include <sys/wait.h>\n#include \"become_daemon.h\"\n#include \"inet_sockets.h\"       /* Declarations of inet*() socket functions */\n#include \"tlpi_hdr.h\"\n\n#define SERVICE \"echo\"          /* Name of TCP service */\n#define BUF_SIZE 4096\n\nstatic void             /* SIGCHLD handler to reap dead child processes */\ngrimReaper(int sig)\n{\n    int savedErrno;             /* Save 'errno' in case changed here */\n\n    savedErrno = errno;\n    while (waitpid(-1, NULL, WNOHANG) > 0)\n        continue;\n    errno = savedErrno;\n}\n\n/* Handle a client request: copy socket input back to socket */\n\nstatic void\nhandleRequest(int cfd)\n{\n    char buf[BUF_SIZE];\n    ssize_t numRead;\n\n    while ((numRead = read(cfd, buf, BUF_SIZE)) > 0) {\n        if (write(cfd, buf, numRead) != numRead) {\n            syslog(LOG_ERR, \"write() failed: %s\", strerror(errno));\n            exit(EXIT_FAILURE);\n        }\n    }\n\n    if (numRead == -1) {\n        syslog(LOG_ERR, \"Error from read(): %s\", strerror(errno));\n        exit(EXIT_FAILURE);\n    }\n}\n\nint\nmain(int argc, char *argv[])\n{\n    int lfd, cfd;               /* Listening and connected sockets */\n    struct sigaction sa;\n\n    if (becomeDaemon(0) == -1)\n        errExit(\"becomeDaemon\");\n\n    sigemptyset(&sa.sa_mask);\n    sa.sa_flags = SA_RESTART;\n    sa.sa_handler = grimReaper;\n    if (sigaction(SIGCHLD, &sa, NULL) == -1) {\n        syslog(LOG_ERR, \"Error from sigaction(): %s\", strerror(errno));\n        exit(EXIT_FAILURE);\n    }\n\n    lfd = inetListen(SERVICE, 10, NULL);\n    if (lfd == -1) {\n        syslog(LOG_ERR, \"Could not create server socket (%s)\", strerror(errno));\n        exit(EXIT_FAILURE);\n    }\n\n    for (;;) {\n        cfd = accept(lfd, NULL, NULL);  /* Wait for connection */\n        if (cfd == -1) {\n            syslog(LOG_ERR, \"Failure in accept(): %s\", strerror(errno));\n            exit(EXIT_FAILURE);\n        }\n\n        /* Handle each client request in a new child process */\n\n        switch (fork()) {\n        case -1:\n            syslog(LOG_ERR, \"Can't create child (%s)\", strerror(errno));\n            close(cfd);                 /* Give up on this client */\n            break;                      /* May be temporary; try next client */\n\n        case 0:                         /* Child */\n            close(lfd);                 /* Unneeded copy of listening socket */\n            handleRequest(cfd);\n            _exit(EXIT_SUCCESS);\n\n        default:                        /* Parent */\n            close(cfd);                 /* Unneeded copy of connected socket */\n            break;                      /* Loop to accept next connection */\n        }\n    }\n}\n     `sockets/is_echo_sv.c`\n```", "```\n# echo  stream  tcp  nowait  root    internal\n# echo  dgram   udp  wait    root    internal\nftp     stream  tcp  nowait  root    /usr/sbin/tcpd   in.ftpd\ntelnet  stream  tcp  nowait  root    /usr/sbin/tcpd   in.telnetd\nlogin   stream  tcp  nowait  root    /usr/sbin/tcpd   in.rlogind\n```", "```\n# `killall -HUP inetd`\n```", "```\necho stream tcp nowait root /bin/is_echo_inetd_sv is_echo_inetd_sv\n```", "```\n`sockets/is_echo_inetd_sv.c`\n#include <syslog.h>\n#include \"tlpi_hdr.h\"\n\n#define BUF_SIZE 4096\n\nint\nmain(int argc, char *argv[])\n{\n    char buf[BUF_SIZE];\n    ssize_t numRead;\n\n    while ((numRead = read(STDIN_FILENO, buf, BUF_SIZE)) > 0) {\n        if (write(STDOUT_FILENO, buf, numRead) != numRead) {\n            syslog(LOG_ERR, \"write() failed: %s\", strerror(errno));\n            exit(EXIT_FAILURE);\n        }\n    }\n\n    if (numRead == -1) {\n        syslog(LOG_ERR, \"Error from read(): %s\", strerror(errno));\n        exit(EXIT_FAILURE);\n    }\n\n    exit(EXIT_SUCCESS);\n}\n     `sockets/is_echo_inetd_sv.c`\n```"]