<html><head></head><body>
<div id="sbo-rt-content" class="calibre1">
 <div class="chapter" id="ch12">
  <div id="header1201" class="chapter">
   <h1 class="cn">
    <span class="page" id="p248">
    </span>
    <span class="page" id="p249">
    </span>
    <a class="xref" href="nsp-boxall502581-0008.xhtml#rch12">
     12
    </a>
   </h1>
   <h1 class="ctfm">
    AVR and the I
    <sup class="calibre31">
     2
    </sup>
    C Bus
   </h1>
  </div>
  <div class="figure" id="ct12">
   <p class="fig">
    <img alt="" src="images/nsp-boxall502581-ct.jpg" class="calibre9"/>
   </p>
  </div>
  <p class="pf">
   <span>
   </span>
   The
   <i class="calibre5">
    Inter-Integrated Circuit
   </i>
   bus, or
   <i class="calibre5">
    I
   </i>
   <sup class="i2">
    2
   </sup>
   <i class="calibre5">
    C
   </i>
   , is another popular type of data bus. Originally devised by Philips (now NXP), this bus is designed to enable one or many devices to transmit and receive data to and from a host device such as a microcontroller over short distances. This chapter shows you how to set up the I
   <sup class="calibre6">
    2
   </sup>
   C and use it to communicate with external ICs by learning the required functions and hardware and exploring some examples of popular I
   <sup class="calibre6">
    2
   </sup>
   C devices.
  </p>
  <p class="calibre8">
   You’ll learn how to increase the operating speed of AVR microcontrollers, enabling you to implement the I
   <sup class="calibre6">
    2
   </sup>
   C data bus with an AVR. After learning how to control the MCP23017 I
   <sup class="calibre6">
    2
   </sup>
   C 16-bit I/O expander IC and store and retrieve data from an external I
   <sup class="calibre6">
    2
   </sup>
   C EEPROM, you’ll use the DS3231 I
   <sup class="calibre6">
    2
   </sup>
   C real-time clock IC for the first time.
  </p>
  <p class="calibre8">
   <span id="p250">
   </span>
   There are thousands of devices that use the I
   <sup class="calibre6">
    2
   </sup>
   C bus, from display and motor controllers to sensors and more. After working through this chapter, you’ll be prepared to harness these devices to make more complex projects like weather monitoring and display solutions, multiple-servo robots, and projects that require adding more I/O ports to your microcontroller.
  </p>
  <div class="chapter">
   <h2 class="ah" id="ah1401">
    <a class="xref" href="nsp-boxall502581-0008.xhtml#rah1401">
     Increasing AVR Speed
    </a>
   </h2>
   <p class="paft">
    Up until now, your AVR projects have been running with a CPU speed of 1 MHz, using the AVR’s internal oscillator to generate the required clock signal for timing and other operations. This minimized complications and reduced the number of required parts for the circuits. At times, however, you may need to work with parts that require a faster data bus. These parts include those that communicate with microcontrollers using the I
    <sup class="calibre6">
     2
    </sup>
    C bus. In order to use this bus, you’ll need to know how to run your projects with a higher CPU speed to generate faster clock signals.
   </p>
   <p class="calibre8">
    To increase the ATmega328P-PU’s CPU speed, you’ll need to make two modifications: one to the hardware and one to the project’s Makefile. To alter the hardware, you’ll need three more components: two 22 pF ceramic capacitors and one 16 MHz
    <i class="calibre5">
     crystal oscillator
    </i>
    . More commonly known as
    <i class="calibre5">
     crystals
    </i>
    , these oscillators create an electrical signal with an exactly accurate frequency, in this case 16 MHz.
    <a class="url" href="nsp-boxall502581-0022.xhtml#f12001">
     Figure 12-1
    </a>
    shows the crystal we’ll use.
   </p>
   <div class="figure" id="f12001">
    <p class="fig">
     <img alt="Photo of a 16 MHz crystal oscillator" height="675" src="images/nsp-boxall502581-f12001.jpg" width="1200" class="calibre11"/>
    </p>
    <div class="chapter">
     <p class="figh">
      <span class="calibre4">
       Figure 12-1:
      </span>
      A 16 MHz crystal oscillator
     </p>
    </div>
   </div>
   <p class="calibre8">
    Crystals are not polarized. The schematic symbol for our 16 MHz crystal is shown in
    <a class="url" href="nsp-boxall502581-0022.xhtml#f12002">
     Figure 12-2
    </a>
    .
   </p>
   <div class="figure" id="f12002">
    <p class="fig">
     <img alt="Schematic symbol for a 16 MHz crystal oscillator" src="images/nsp-boxall502581-f12002.jpg" class="calibre32"/>
    </p>
    <div class="chapter">
     <p class="figh">
      <span class="calibre4">
       Figure 12-2:
      </span>
      Crystal oscillator schematic symbol
     </p>
    </div>
   </div>
   <p class="calibre8">
    <span id="p251">
    </span>
    The crystal determines the microcontroller’s speed of operation. For example, the circuit we will be assembling runs at 16 MHz, which means it can execute 16 million processor instructions per second. That doesn’t mean it can execute a line of code or function that rapidly, of course, since it takes many processor instructions to execute a single line of code.
   </p>
   <p class="calibre8">
    The schematic in
    <a class="url" href="nsp-boxall502581-0022.xhtml#f12003">
     Figure 12-3
    </a>
    shows the additional circuitry required to connect a crystal to an ATmega328P-PU microcontroller.
   </p>
   <div class="figure" id="f12003">
    <p class="fig">
     <img alt="Schematic for an ATmega328P-PU with an external crystal" height="1200" src="images/nsp-boxall502581-f12003.jpg" width="1020" class="calibre11"/>
    </p>
    <div class="chapter">
     <p class="figh">
      <span class="calibre4">
       Figure 12-3:
      </span>
      ATmega328P-PU with external crystal circuit
     </p>
    </div>
   </div>
   <p class="calibre8">
    Along with the hardware changes mentioned above, you’ll also need to edit the project’s Makefile to tell the toolchain to set the microcontroller to operate at 16 MHz. This will be necessary for all projects using an external crystal. To do this for this chapter’s
    <a class="url" href="nsp-boxall502581-0022.xhtml#pro49">
     first project
    </a>
    , open the Makefile found in the
    <i class="calibre5">
     Project 49
    </i>
    subfolder of the book’s
    <i class="calibre5">
     Chapter 11
    </i>
    folder. Scroll down to line 21, labeled
    <code class="calibre23">
     FUSES
    </code>
    , and update it to match the following line of code (don’t forget to save the file when you’re done):
   </p>
   <pre>
    <p class="cls">
     FUSES      = -U lfuse:w:0xff:m -U hfuse:w:0xde:m -U efuse:w:0x05:m
    </p>
   </pre>
   <p class="pcust">
    <span id="p252">
    </span>
    <span class="ccust">
     Note
    </span>
    It’s a good idea to store different Makefiles separately so you can easily copy them into project folders of your own when required. If you have downloaded the code for this book from the No Starch Press website, the Makefiles are already set up in this way for each project.
   </p>
  </div>
  <div class="chapter">
   <h2 class="ah" id="ah1402">
    <a class="xref" href="nsp-boxall502581-0008.xhtml#rah1402">
     Introducing the I
     <sup class="calibre33">
      2
     </sup>
     C Bus
    </a>
   </h2>
   <p class="paft">
    The I
    <sup class="calibre6">
     2
    </sup>
    C bus works similarly to the SPI bus, in that data is again transmitted and received in serial fashion along one wire to or from the microcontroller (the
    <i class="calibre5">
     serial data line
    </i>
    , usually called
    <i class="calibre5">
     SDA
    </i>
    ), while another wire carries the clock signal (the
    <i class="calibre5">
     serial clock line
    </i>
    , usually called
    <i class="calibre5">
     SCL
    </i>
    or
    <i class="calibre5">
     SCK
    </i>
    ). That signal is synchronized with the data signal for accurate data transmission. The clock signal frequency for our projects is 100 kHz.
   </p>
   <p class="pcust">
    <span class="ccust">
     Note
    </span>
    The I
    <sup class="calibre6">
     2
    </sup>
    C is a bidirectional bus, in that data is transmitted or received along one wire. Because the clock signal is carried on another wire, some suppliers, such as Microchip, call the I
    <sup class="calibre6">
     2
    </sup>
    C the
    <i class="calibre12">
     two-wire serial interface (TWI)
    </i>
    .
   </p>
   <p class="calibre8">
    On the I
    <sup class="calibre6">
     2
    </sup>
    C bus, the microcontroller acts as the
    <i class="calibre5">
     primary
    </i>
    device, and each IC on the bus is a
    <i class="calibre5">
     secondary
    </i>
    . Each secondary has its own address, a 7-bit number that allows the microcontroller to communicate with that device. Each device usually has a range of I
    <sup class="calibre6">
     2
    </sup>
    C bus addresses to choose from, detailed in the manufacturer’s data sheet. If an IC has two or more potential I
    <sup class="calibre6">
     2
    </sup>
    C bus addresses, we determine which address to use by wiring the IC pins in a certain way.
   </p>
   <p class="calibre8">
    <a class="url" href="nsp-boxall502581-0022.xhtml#f12004">
     Figure 12-4
    </a>
    shows an example of the I
    <sup class="calibre6">
     2
    </sup>
    C bus in action as captured using a DSO.
   </p>
   <div class="figure" id="f12004">
    <p class="fig">
     <img alt="Screenshot of a DSO displaying the data and clock lines of an I2C bus with bytes of data traveling in both directions between the primary and secondary devices" height="720" src="images/nsp-boxall502581-f12004.jpg" width="1200" class="calibre11"/>
    </p>
    <div class="chapter">
     <p class="figh">
      <span class="calibre4">
       Figure 12-4:
      </span>
      Data traversing the I
      <sup class="calibre7">
       2
      </sup>
      C bus
     </p>
    </div>
   </div>
   <p class="calibre8">
    <span id="p253">
    </span>
    Once activated, using the I
    <sup class="calibre6">
     2
    </sup>
    C bus follows a simple logical pattern, as shown in
    <a class="url" href="nsp-boxall502581-0022.xhtml#f12004">
     Figure 12-4
    </a>
    . Both lines of the bus are held at high; we connect them to 5 V via pullup resistors. We send a start signal through the primary device (the microcontroller) by setting the data line low and then starting the clock signal on the clock line. Next, we send the 7 bits of the address of the device with which we want to communicate, followed by a 0 (which tells the device we want to write to it) or a 1 (which tells the device we want it to send us data).
   </p>
   <p class="calibre8">
    The secondary device will then either acknowledge that it has received the byte from the primary device by sending an
    <i class="calibre5">
     ACK bit
    </i>
    (a 0) or, if there was an error, send a
    <i class="calibre5">
     NACK bit
    </i>
    (a 1) for “not acknowledged,” indicating that the primary device should stop sending. The secondary may also send a NACK if it has finished sending data back to the primary.
   </p>
   <p class="calibre8">
    You can see this in action in
    <a class="url" href="nsp-boxall502581-0022.xhtml#f12004">
     Figure 12-4
    </a>
    , as the primary starts the I
    <sup class="calibre6">
     2
    </sup>
    C bus, then sends a
    <code class="calibre23">
     0x20+0
    </code>
    to tell the secondary device it is writing data, then sends another two bytes of data to the secondary device. Hexadecimal is the preferred base system used with the I
    <sup class="calibre6">
     2
    </sup>
    C bus in code, but you can use binary or decimal if it’s easier or makes more sense to you. This may seem complex, but after examining the projects in this chapter, you’ll be well on your way to I
    <sup class="calibre6">
     2
    </sup>
    C expertise.
   </p>
   <div class="chapter">
    <h3 class="bh" id="bh1401">
     <a class="xref" href="nsp-boxall502581-0008.xhtml#rbh1401">
      Pin Connections and Voltages
     </a>
    </h3>
    <p class="paft">
     Each I
     <sup class="calibre6">
      2
     </sup>
     C device uses two pins—usually labeled SCL and SDA, as mentioned earlier—to communicate. These pins connect to matching pins on the microcontroller. If you have multiple I
     <sup class="calibre6">
      2
     </sup>
     C devices, they all make the same connections back to the microcontroller. Finally, a pullup resistor is placed between 5 V (the supply voltage) and each of the I
     <sup class="calibre6">
      2
     </sup>
     C lines.
     <a class="url" href="nsp-boxall502581-0022.xhtml#f12005">
      Figure 12-5
     </a>
     shows a simplified example of this.
    </p>
    <div class="figure" id="f12005">
     <p class="fig">
      <img alt="Simplified diagram of I2C bus wiring" height="530" src="images/nsp-boxall502581-f12005.jpg" width="1200" class="calibre11"/>
     </p>
     <div class="chapter">
      <p class="figh">
       <span class="calibre4">
        Figure 12-5:
       </span>
       Simplified example of I
       <sup class="calibre7">
        2
       </sup>
       C bus wiring
      </p>
     </div>
    </div>
    <p class="calibre8">
     As with the SPI bus, your I
     <sup class="calibre6">
      2
     </sup>
     C bus device must operate or tolerate operating at 5 V, since the microcontroller runs on 5 V in our projects. Be sure to check with the seller or manufacturer before use. If you simply must use
     <span id="p254">
     </span>
     an I
     <sup class="calibre6">
      2
     </sup>
     C bus device that operates at a reduced voltage, such as 3.3 V, use an I
     <sup class="calibre6">
      2
     </sup>
     C-compatible level converter like the unit mentioned in
     <a class="url" href="nsp-boxall502581-0021.xhtml#ch11">
      Chapter 11
     </a>
     , PMD Way part number 441079.
    </p>
    <p class="calibre8">
     Again, using these level converters is simple. Use one pair of channels for the I
     <sup class="calibre6">
      2
     </sup>
     C bus, with the 5 V wires on the HV pads and the matching lower-voltage wires on the LV pads, and connect GND on both sides to the board.
    </p>
   </div>
   <div class="chapter">
    <h3 class="bh" id="bh1402">
     <a class="xref" href="nsp-boxall502581-0008.xhtml#rbh1402">
      Writing to I
      <sup class="calibre34">
       2
      </sup>
      C Devices
     </a>
    </h3>
    <p class="paft">
     To show you how to implement the I
     <sup class="calibre6">
      2
     </sup>
     C bus, I’ll first explain how to write data to I
     <sup class="calibre6">
      2
     </sup>
     C devices, then follow with reading data later in the chapter. Writing data to I
     <sup class="calibre6">
      2
     </sup>
     C bus devices requires five functions that don’t exist in our AVR toolchain, so we use the following custom functions to complete the necessary operations. These functions are included in this chapter’s I
     <sup class="calibre6">
      2
     </sup>
     C bus projects.
    </p>
    <div class="chapter">
     <h4 class="ch" id="ch1401">
      Enable the I
      <sup class="calibre6">
       2
      </sup>
      C Bus
     </h4>
     <p class="paft">
      The
      <code class="calibre23">
       I2Cenable()
      </code>
      function converts the two GPIO pins (PC5 and PC4 on the ATmega328P-PU) from normal use to I
      <sup class="calibre6">
       2
      </sup>
      C bus pins (SCL and SDA, respectively):
     </p>
     <pre>
      <p class="clf">
       void I2Cenable()
      </p>
      <p class="cl">
       {
      </p>
      <p class="cl">
       TWBR = 72;           // 100 kHz I2C bus
      </p>
      <p class="cl">
       TWCR |= (1 &lt;&lt; TWEN); // Enable I2C on PORTC4 and 5
      </p>
      <p class="cll">
       }
      </p>
     </pre>
     <p class="calibre8">
      We first set the
      <i class="calibre5">
       TWBR (TWI Bit Rate Register)
      </i>
      , which is used in the formula provided by Microchip to determine the I
      <sup class="calibre6">
       2
      </sup>
      C bus clock speed. Here we use the value 72, which results in the microcontroller dividing the CPU speed down to 100 kHz for our clock. We also set the
      <i class="calibre5">
       TWEN (Two-Wire Enable)
      </i>
      bit in the
      <i class="calibre5">
       TWCR (Two-Wire Control Register)
      </i>
      to 1, which turns the GPIO pins into I
      <sup class="calibre6">
       2
      </sup>
      C bus pins SCL and SDA.
     </p>
    </div>
    <div class="chapter">
     <h4 class="ch" id="ch1402">
      Wait for the I
      <sup class="calibre6">
       2
      </sup>
      C Bus to Complete
     </h4>
     <p class="paft">
      Bus operations are not instantaneous, so we use the
      <code class="calibre23">
       I2Cwait()
      </code>
      function after other I
      <sup class="calibre6">
       2
      </sup>
      C bus commands to allow for data transmission to complete before executing another operation on the bus:
     </p>
     <pre>
      <p class="clf">
       void I2Cwait()
      </p>
      <p class="cl">
       {
      </p>
      <p class="cl">
       while (!(TWCR &amp; (1&lt;&lt;TWINT)));
      </p>
      <p class="cll">
       }
      </p>
     </pre>
     <p class="calibre8">
      We can check if the bus is busy by looking at the
      <i class="calibre5">
       TWINT (Two-Wire Interrupt)
      </i>
      bit of the TWCR register. This code sets the TWINT bit to 1 when the bus is free for another operation, so the code does nothing while TWINT is 0.
     </p>
    </div>
    <div class="chapter">
     <h4 class="ch" id="ch1403">
      <span class="page" id="p255">
      </span>
      Start the I
      <sup class="calibre6">
       2
      </sup>
      C Bus
     </h4>
     <p class="paft">
      The
      <code class="calibre23">
       I2CstartWait()
      </code>
      function starts the process of sending data to a device on the I
      <sup class="calibre6">
       2
      </sup>
      C bus. It sends the secondary address to enable the required device on the bus and awaits that device’s acknowledgment that it is ready for use:
     </p>
     <pre>
      <p class="clf">
       void I2CstartWait(unsigned char address)
      </p>
      <p class="cl">
       {
      </p>
      <p class="cl">
       uint8_t status;
      </p>
      <p class="cl">
       while (1)
      </p>
      <p class="cl">
       {
      </p>
      <p class="cl">
       <!--<ccust1>1</ccust1>-->
       ❶ TWCR = (1&lt;&lt;TWINT) | (1&lt;&lt;TWSTA) | (1&lt;&lt;TWEN);
      </p>
      <p class="cl">
       <!--<ccust1>2</ccust1>-->
       ❷ I2Cwait();
      </p>
      <p class="clf">
       <!--<ccust1>3</ccust1>-->
       ❸ status = TWSR &amp; 0b11111000;
      </p>
      <p class="cl">
       if ((status != 0b00001000) &amp;&amp; (status != 0b00010000)) continue;
      </p>
      <p class="clf">
       <!--<ccust1>4</ccust1>-->
       ❹ TWDR = address;
      </p>
      <p class="cl">
       TWCR = (1&lt;&lt;TWINT) | (1&lt;&lt;TWEN);
      </p>
      <p class="cl">
       I2Cwait();
      </p>
      <p class="clf">
       <!--<ccust1>5</ccust1>-->
       ❺ status = TWSR &amp; 0b11111000;
      </p>
      <p class="cl">
       if ((status == 0b00100000)||(status == 0b01011000))
      </p>
      <p class="cl">
       {
      </p>
      <p class="cl">
       <!--<ccust1>6</ccust1>-->
       ❻ TWCR = (1&lt;&lt;TWINT) | (1&lt;&lt;TWEN) | (1&lt;&lt;TWSTO);
      </p>
      <p class="cl">
       while(TWCR &amp; (1&lt;&lt;TWSTO));
      </p>
      <p class="cl">
       continue;
      </p>
      <p class="cl">
       }
      </p>
      <p class="cl">
       break;
      </p>
      <p class="cl">
       }
      </p>
      <p class="cll">
       }
      </p>
     </pre>
     <p class="calibre8">
      This function first sets a start condition on the bus by setting TWINT in the TWCR register to 1, setting the start condition on with TWSTA (two-wire interface start condition), and activating the bus with TWEN
      <!--<ccust1>1</ccust1>-->
      ❶. We wait for those operations to complete
      <!--<ccust1>2</ccust1>-->
      ❷, then load the value of the TWSR register
      <!--<ccust1>3</ccust1>-->
      ❸ and continue only if the status bits TWS3 and TWS4 are not set to 1. If set to 1, these bits indicate that a start condition or repeated start condition was not successfully sent, so we can’t continue.
     </p>
     <p class="calibre8">
      At this point the bus initialization has been successful, so we now send the secondary address to enable the required device on the bus. We do so by loading the address into the TWDR register
      <!--<ccust1>4</ccust1>-->
      ❹, then sending it off by setting TWINT and TWEN in the TWCR register to 1. This is followed by a short wait to give time for the transmission to complete.
     </p>
     <p class="calibre8">
      Once again we check the status of the I
      <sup class="calibre6">
       2
      </sup>
      C bus by loading the value of the TWSR register
      <!--<ccust1>5</ccust1>-->
      ❺, and we continue only if the secondary device is not busy or if the secondary device didn’t acknowledge the write. If it is busy or didn’t acknowledge, we send an I
      <sup class="calibre6">
       2
      </sup>
      C stop command
      <!--<ccust1>6</ccust1>-->
      ❻ and wait for that instruction to finish.
     </p>
    </div>
    <div class="chapter">
     <h4 class="ch" id="ch1404">
      <span class="page" id="p256">
      </span>
      Write to the I
      <sup class="calibre6">
       2
      </sup>
      C Bus
     </h4>
     <p class="paft">
      This function simply sends a byte of data along the I
      <sup class="calibre6">
       2
      </sup>
      C bus:
     </p>
     <pre>
      <p class="clf">
       void I2Cwrite(uint8_t data)
      </p>
      <p class="cl">
       {
      </p>
      <p class="cl">
       TWDR = data;
      </p>
      <p class="cl">
       TWCR |= (1 &lt;&lt; TWINT)|(1 &lt;&lt; TWEN);
      </p>
      <p class="cl">
       I2Cwait();
      </p>
      <p class="cll">
       }
      </p>
     </pre>
     <p class="calibre8">
      Once I
      <sup class="calibre6">
       2
      </sup>
      C bus communication has been initialized and we’ve started the I
      <sup class="calibre6">
       2
      </sup>
      C bus, we use this function to write a byte of data to the device being addressed. We load the data into the TWDR register, and then send it out using the TWCR register. We then wait a moment for the process to complete. You can call this function two or more times in a row to send multiple bytes of data.
     </p>
    </div>
    <div class="chapter">
     <h4 class="ch" id="ch1405">
      Stop the I
      <sup class="calibre6">
       2
      </sup>
      C Bus
     </h4>
     <p class="paft">
      The
      <code class="calibre23">
       I2Cstop()
      </code>
      function releases the GPIO pins from I
      <sup class="calibre6">
       2
      </sup>
      C bus duty and sets them back to normal duty:
     </p>
     <pre>
      <p class="clf">
       void I2Cstop()
      </p>
      <p class="cl">
       {
      </p>
      <p class="cl">
       TWCR |= (1 &lt;&lt; TWINT)|(1 &lt;&lt; TWEN)|(1 &lt;&lt; TWSTO);
      </p>
      <p class="cll">
       }
      </p>
     </pre>
     <p class="calibre8">
      When your code is finished with the I
      <sup class="calibre6">
       2
      </sup>
      C bus, use this function to stop the bus and release the GPIO pins used for SDA and SCL back to normal duty. The bus is stopped by three bit changes:
     </p>
     <ul class="calibre10">
      <li class="blf">
       • Setting the TWINT bit to 1 tells the microcontroller you’re finished using the bus.
      </li>
      <li class="bl">
       • Setting the TWSTO bit to 1 puts a stop condition on the bus, telling the devices on the bus that the bus is being deactivated.
      </li>
      <li class="bll">
       • Setting the TWEN bit to 1 disables bus operation.
      </li>
     </ul>
     <p class="calibre8">
      Now let’s turn theory into practice by using some interesting devices over the I
      <sup class="calibre6">
       2
      </sup>
      C bus with the ATmega328P-PU. Our first such device will be the Microchip MCP23017, which adds 16 more I/O pins to our microcontroller.
     </p>
     <p class="hd" id="pro49">
      <a class="xref" href="nsp-boxall502581-0008.xhtml#rpro49">
       <span class="ccust1">
        Project 49: Using the MCP23017 16-Bit I/O Expander
       </span>
      </a>
     </p>
     <p class="paft">
      When your AVR-based project doesn’t have enough digital GPIO pins, you can add 16 more at a time with the Microchip MCP23017, shown in
      <a class="url" href="nsp-boxall502581-0022.xhtml#f12006">
       Figure 12-6
      </a>
      . We’ll use the MCP23017 for the first time in this project, which doubles as a demonstration of writing data to the I
      <sup class="calibre6">
       2
      </sup>
      C bus.
     </p>
     <div class="figure" id="f12006">
      <p class="fig">
       <span id="p257">
       </span>
       <img alt="Photo of the MCP23017" height="357" src="images/nsp-boxall502581-f12006.jpg" width="1200" class="calibre11"/>
      </p>
      <div class="chapter">
       <p class="figh">
        <span class="calibre4">
         Figure 12-6:
        </span>
        Microchip MCP23017 16-bit I/O expander
       </p>
      </div>
     </div>
     <p class="calibre8">
      The MCP23017 has eight possible bus addresses, so you can connect a maximum of eight on the same bus, giving you up to 128 GPIO pins. The I/O pins are arranged in two banks of eight, as shown in the schematic symbol in
      <a class="url" href="nsp-boxall502581-0022.xhtml#f12007">
       Figure 12-7
      </a>
      . Each pin can handle up to 20 mA of current, though the entire MCP23017 has a continuous maximum of 125 mA.
     </p>
     <div class="figure" id="f12007">
      <p class="fig">
       <img alt="Schematic symbol for the MCP23017" height="1200" src="images/nsp-boxall502581-f12007.jpg" width="698" class="calibre11"/>
      </p>
      <div class="chapter">
       <p class="figh">
        <span class="calibre4">
         Figure 12-7:
        </span>
        Microchip MCP23017 schematic symbol
       </p>
      </div>
     </div>
     <p class="calibre8">
      To set the I
      <sup class="calibre6">
       2
      </sup>
      C bus address, you need to connect the pins labeled A0 to A2 to combinations of 5 V or GND. If you’re using one MCP23017, you can set the bus address to
      <code class="calibre23">
       0x20
      </code>
      by connecting the three pins to GND. If you’re using two or more MCP23017s, or need to let another device use the
      <code class="calibre23">
       0x20
      </code>
      address, refer to
      <a class="url" href="nsp-boxall502581-0022.xhtml#tab1201">
       Table 12-1
      </a>
      for your configuration.
     </p>
     <table id="tab1201" class="calibre13">
      <thead class="calibre14">
       <tr class="calibre15">
        <th colspan="4" class="calibre16">
         <p class="th1">
          <span id="p258">
          </span>
          <span class="calibre4">
           Table 12-1
          </span>
          : MCP23017 I
          <sup class="calibre6">
           2
          </sup>
          C Bus Address Configuration
         </p>
        </th>
       </tr>
       <tr class="calibre15">
        <th scope="col" class="calibre16">
         <p class="tch">
          Bus address
         </p>
        </th>
        <th scope="col" class="calibre16">
         <p class="tch">
          Pin A2
         </p>
        </th>
        <th scope="col" class="calibre16">
         <p class="tch">
          Pin A1
         </p>
        </th>
        <th scope="col" class="calibre16">
         <p class="tch">
          Pin A0
         </p>
        </th>
       </tr>
      </thead>
      <tbody class="calibre17">
       <tr class="calibre15">
        <td class="calibre18">
         <p class="td">
          <code class="calibre23">
           0x20
          </code>
         </p>
        </td>
        <td class="calibre18">
         <p class="td">
          GND
         </p>
        </td>
        <td class="calibre18">
         <p class="td">
          GND
         </p>
        </td>
        <td class="calibre18">
         <p class="td">
          GND
         </p>
        </td>
       </tr>
       <tr class="calibre15">
        <td class="calibre18">
         <p class="td">
          <code class="calibre23">
           0x21
          </code>
         </p>
        </td>
        <td class="calibre18">
         <p class="td">
          GND
         </p>
        </td>
        <td class="calibre18">
         <p class="td">
          GND
         </p>
        </td>
        <td class="calibre18">
         <p class="td">
          5 V
         </p>
        </td>
       </tr>
       <tr class="calibre15">
        <td class="calibre18">
         <p class="td">
          <code class="calibre23">
           0x22
          </code>
         </p>
        </td>
        <td class="calibre18">
         <p class="td">
          GND
         </p>
        </td>
        <td class="calibre18">
         <p class="td">
          5 V
         </p>
        </td>
        <td class="calibre18">
         <p class="td">
          GND
         </p>
        </td>
       </tr>
       <tr class="calibre15">
        <td class="calibre18">
         <p class="td">
          <code class="calibre23">
           0x23
          </code>
         </p>
        </td>
        <td class="calibre18">
         <p class="td">
          GND
         </p>
        </td>
        <td class="calibre18">
         <p class="td">
          5 V
         </p>
        </td>
        <td class="calibre18">
         <p class="td">
          5 V
         </p>
        </td>
       </tr>
       <tr class="calibre15">
        <td class="calibre18">
         <p class="td">
          <code class="calibre23">
           0x24
          </code>
         </p>
        </td>
        <td class="calibre18">
         <p class="td">
          5 V
         </p>
        </td>
        <td class="calibre18">
         <p class="td">
          GND
         </p>
        </td>
        <td class="calibre18">
         <p class="td">
          GND
         </p>
        </td>
       </tr>
       <tr class="calibre15">
        <td class="calibre18">
         <p class="td">
          <code class="calibre23">
           0x25
          </code>
         </p>
        </td>
        <td class="calibre18">
         <p class="td">
          5 V
         </p>
        </td>
        <td class="calibre18">
         <p class="td">
          GND
         </p>
        </td>
        <td class="calibre18">
         <p class="td">
          5 V
         </p>
        </td>
       </tr>
       <tr class="calibre15">
        <td class="calibre18">
         <p class="td">
          <code class="calibre23">
           0x26
          </code>
         </p>
        </td>
        <td class="calibre18">
         <p class="td">
          5 V
         </p>
        </td>
        <td class="calibre18">
         <p class="td">
          5 V
         </p>
        </td>
        <td class="calibre18">
         <p class="td">
          GND
         </p>
        </td>
       </tr>
       <tr class="calibre15">
        <td class="calibre18">
         <p class="td">
          <code class="calibre23">
           0x27
          </code>
         </p>
        </td>
        <td class="calibre18">
         <p class="td">
          5 V
         </p>
        </td>
        <td class="calibre18">
         <p class="td">
          5 V
         </p>
        </td>
        <td class="calibre18">
         <p class="td">
          5 V
         </p>
        </td>
       </tr>
      </tbody>
     </table>
     <p class="calibre8">
      As mentioned earlier, the bus address is a 7-bit number, which we complete to an 8-bit number by adding a 0 or 1 at the end for writing to the bus or reading the bus, respectively. You can create this 8-bit number by bit-shifting a 1 from the right, using a
      <code class="calibre23">
       &lt;&lt;1
      </code>
      to create the address for writing—
      <code class="calibre23">
       0x20&lt;&lt;1
      </code>
      , for example—or converting the address to the result, which in this example would be
      <code class="calibre23">
       0x40
      </code>
      .
     </p>
     <p class="calibre8">
      Controlling the MCP23017 also involves writing to its configuration registers, each of which has its own address. To use the pins as outputs, we set the I/O direction registers for both banks of eight pins. These are known as the GPIOA and GPIOB registers for banks A and B, whose addresses are
      <code class="calibre23">
       0x12
      </code>
      and
      <code class="calibre23">
       0x13
      </code>
      .
     </p>
     <p class="calibre8">
      Once we’ve addressed these registers, we send a 0 to each to set the pins as outputs. For example, to set the GPIOA register to outputs, we’d send the following sequence of data to the I
      <sup class="calibre6">
       2
      </sup>
      C bus:
      <code class="calibre23">
       0x20&lt;&lt;1
      </code>
      or
      <code class="calibre23">
       0x40
      </code>
      (the MCP23017 I
      <sup class="calibre6">
       2
      </sup>
      C bus address for writing), then
      <code class="calibre23">
       0x12
      </code>
      (the GPIOA register address), then
      <code class="calibre23">
       0x00
      </code>
      (0). Let’s do this now in our project.
     </p>
    </div>
   </div>
   <div class="chapter">
    <h3 class="bh" id="bh1403">
     <a class="xref" href="nsp-boxall502581-0008.xhtml#rbh1403">
      The Hardware
     </a>
    </h3>
    <p class="paft">
     To build your circuit, you’ll need the following hardware:
    </p>
    <ul class="calibre10">
     <li class="blf">
      • USBasp programmer
     </li>
     <li class="bl">
      • Solderless breadboard
     </li>
     <li class="bl">
      • 5 V breadboard power supply
     </li>
     <li class="bl">
      • ATmega328P-PU microcontroller
     </li>
     <li class="bl">
      • MCP23017 16-bit I/O IC
     </li>
     <li class="bl">
      • Up to 16 LEDs (D1–D16)
     </li>
     <li class="bl">
      • Up to 16 560
      <span lang="el" xml:lang="el">
       Ω
      </span>
      resistors (R1–R16)
     </li>
     <li class="bl">
      • Two 4.7
      <span lang="en" xml:lang="en">
       kΩ
      </span>
      resistors (R17–R18)
     </li>
     <li class="bl">
      • Two 22 pF ceramic capacitors
     </li>
     <li class="bl">
      • 16 MHz crystal oscillator
     </li>
     <li class="bll">
      • Jumper wires
     </li>
    </ul>
    <p class="calibre8">
     <span id="p259">
     </span>
     Assemble your circuit as shown in
     <a class="url" href="nsp-boxall502581-0022.xhtml#f12008">
      Figure 12-8
     </a>
     .
    </p>
    <div class="figure" id="f12008">
     <p class="fig">
      <img alt="Schematic diagram for Project 49" height="737" src="images/nsp-boxall502581-f12008.jpg" width="1200" class="calibre11"/>
     </p>
     <div class="chapter">
      <p class="figh">
       <span class="calibre4">
        Figure 12-8:
       </span>
       Schematic for
       <a class="url" href="nsp-boxall502581-0022.xhtml#pro49">
        Project 49
       </a>
      </p>
     </div>
    </div>
   </div>
   <div class="chapter">
    <h3 class="bh" id="bh1404">
     <a class="xref" href="nsp-boxall502581-0008.xhtml#rbh1404">
      The Code
     </a>
    </h3>
    <p class="paft">
     Open a terminal window, navigate to the
     <i class="calibre5">
      Project 49
     </i>
     subfolder of this book’s
     <i class="calibre5">
      Chapter 12
     </i>
     folder, and enter the command
     <code class="b">
      make flash
     </code>
     . After a few moments, each bank of LEDs should repeatedly display the count between 0 and 255 in binary.
    </p>
    <p class="calibre8">
     Let’s examine the code to see how this is done:
    </p>
    <pre>
     <p class="clf">
      // Project 49 - Using the MCP23017 16-Bit I/O Expander
     </p>
     <p class="clf">
      #include &lt;avr/io.h&gt;
     </p>
     <p class="cl">
      #include &lt;util/delay.h&gt;
     </p>
     <p class="clf">
      void I2Cenable()
     </p>
     <p class="cl">
      // Enable the I2C bus
     </p>
     <p class="cl">
      {
     </p>
     <p class="cl">
      TWBR = 72;           // 100 kHz I2C bus
     </p>
     <p class="cl">
      TWCR |= (1 &lt;&lt; TWEN); // Enable I2C on PORTC4 and 5
     </p>
     <p class="cl">
      }
     </p>
     <p class="clf">
      void I2Cwait()
     </p>
     <p class="cl">
      // Wait until I2C finishes an operation
     </p>
     <p class="cl">
      {
     </p>
     <p class="cl">
      // Wait until bit TWINT in TWCR is set to 1
     </p>
     <p class="cl">
      while (!(TWCR &amp; (1&lt;&lt;TWINT)));
     </p>
     <p class="cl">
      }
     </p>
     <p class="clf">
      <span id="p260">
      </span>
      void I2CstartWait(unsigned char address)
     </p>
     <p class="cl">
      {
     </p>
     <p class="cl">
      uint8_t status;
     </p>
     <p class="cl">
      while (1)
     </p>
     <p class="cl">
      {
     </p>
     <p class="cl">
      // Send START condition
     </p>
     <p class="cl">
      TWCR = (1&lt;&lt;TWINT) | (1&lt;&lt;TWSTA) | (1&lt;&lt;TWEN);
     </p>
     <p class="clf">
      // Wait until transmission completes
     </p>
     <p class="cl">
      I2Cwait();
     </p>
     <p class="clf">
      // Check value of TWSR, and mask out status bits
     </p>
     <p class="cl">
      status = TWSR &amp; 0b11111000;
     </p>
     <p class="cl">
      if ((status != 0b00001000) &amp;&amp; (status != 0b00010000)) continue;
     </p>
     <p class="clf">
      // Send device address
     </p>
     <p class="cl">
      TWDR = address;
     </p>
     <p class="cl">
      TWCR = (1&lt;&lt;TWINT) | (1&lt;&lt;TWEN);
     </p>
     <p class="clf">
      // Wait until transmission completes
     </p>
     <p class="cl">
      I2Cwait();
     </p>
     <p class="clf">
      // Check value of TWSR, and mask out status bits
     </p>
     <p class="cl">
      status = TWSR &amp; 0b11111000;
     </p>
     <p class="cl">
      if ((status == 0b00100000 )||(status == 0b01011000))
     </p>
     <p class="cl">
      {
     </p>
     <p class="cl">
      // Secondary device is busy, send stop to terminate write operation
     </p>
     <p class="cl">
      TWCR = (1&lt;&lt;TWINT) | (1&lt;&lt;TWEN) | (1&lt;&lt;TWSTO);
     </p>
     <p class="cl">
      // Wait until stop condition is executed and I2C bus is released
     </p>
     <p class="cl">
      while(TWCR &amp; (1&lt;&lt;TWSTO));
     </p>
     <p class="cl">
      continue;
     </p>
     <p class="cl">
      }
     </p>
     <p class="cl">
      break;
     </p>
     <p class="cl">
      }
     </p>
     <p class="cl">
      }
     </p>
     <p class="clf">
      void I2Cstop()
     </p>
     <p class="cl">
      // Stop I2C bus and release GPIO pins
     </p>
     <p class="cl">
      {
     </p>
     <p class="cl">
      // Clear interrupt, enable I2C, generate stop condition
     </p>
     <p class="cl">
      TWCR |= (1 &lt;&lt; TWINT)|(1 &lt;&lt; TWEN)|(1 &lt;&lt; TWSTO);
     </p>
     <p class="cl">
      }
     </p>
     <p class="clf">
      void I2Cwrite(uint8_t data)
     </p>
     <p class="cl">
      // Send ′data′ to I2C bus
     </p>
     <p class="cl">
      {
     </p>
     <p class="cl">
      TWDR = data;
     </p>
     <p class="cl">
      TWCR |= (1 &lt;&lt; TWINT)|(1 &lt;&lt; TWEN);
     </p>
     <p class="cl">
      I2Cwait();
     </p>
     <p class="cl">
      }
     </p>
     <p class="cl2f">
      <!--<ccust1>1</ccust1>-->
      ❶ void initMCP23017()
     </p>
     <p class="cl">
      // Configure MCP23017 ports for all outputs
     </p>
     <p class="cl">
      {
     </p>
     <p class="cl">
      I2CstartWait(0x20&lt;&lt;1); // 0x20 write mode
     </p>
     <p class="cl">
      <span id="p261">
      </span>
      I2Cwrite(0x00);        // IODIRA register
     </p>
     <p class="cl">
      I2Cwrite(0x00);        // Set all register A to outputs
     </p>
     <p class="cl">
      I2Cstop();
     </p>
     <p class="clf">
      I2CstartWait(0x20&lt;&lt;1); // 0x20 write mode
     </p>
     <p class="cl">
      I2Cwrite(0x01);        // IODIRB register
     </p>
     <p class="cl">
      I2Cwrite(0x00);        // Set all register B to outputs
     </p>
     <p class="cl">
      I2Cstop();
     </p>
     <p class="cl">
      }
     </p>
     <p class="clf">
      int main(void)
     </p>
     <p class="cl">
      {
     </p>
     <p class="cl">
      uint8_t i;
     </p>
     <p class="cl">
      <!--<ccust1>2</ccust1>-->
      ❷ I2Cenable();
     </p>
     <p class="cl">
      initMCP23017();
     </p>
     <p class="cl">
      while (1)
     </p>
     <p class="cl">
      {
     </p>
     <p class="cl">
      for (i = 0; i&lt; 256; i++)
     </p>
     <p class="cl">
      {
     </p>
     <p class="cl">
      <!--<ccust1>3</ccust1>-->
      ❸ I2CstartWait(0x20&lt;&lt;1);
     </p>
     <p class="cl">
      <!--<ccust1>4</ccust1>-->
      ❹ I2Cwrite(0x12);  // Control register A 0x12
     </p>
     <p class="cl">
      <!--<ccust1>5</ccust1>-->
      ❺ I2Cwrite(i);     // Value to send
     </p>
     <p class="cl">
      <!--<ccust1>6</ccust1>-->
      ❻ I2Cstop();
     </p>
     <p class="clf">
      I2CstartWait(0x20&lt;&lt;1);
     </p>
     <p class="cl">
      <!--<ccust1>7</ccust1>-->
      ❼ I2Cwrite(0x13);  // Control register B 0x13
     </p>
     <p class="cl">
      <!--<ccust1>8</ccust1>-->
      ❽ I2Cwrite(i);     // Value to send
     </p>
     <p class="cl">
      <!--<ccust1>9</ccust1>-->
      ❾ I2Cstop();
     </p>
     <p class="cl">
      _delay_ms(100);
     </p>
     <p class="cl">
      }
     </p>
     <p class="cl">
      }
     </p>
     <p class="cll">
      }
     </p>
    </pre>
    <p class="calibre8">
     This code uses the five I
     <sup class="calibre6">
      2
     </sup>
     C functions described in the previous section to simplify data transmission. The initialization function
     <!--<ccust1>1</ccust1>-->
     ❶ facilitates using the MCP23017. This sets up the GPIOA and GPIOB registers to make all the I/O pins outputs.
    </p>
    <p class="calibre8">
     Next, we initialize the I
     <sup class="calibre6">
      2
     </sup>
     C bus
     <!--<ccust1>2</ccust1>-->
     ❷ and address each GPIO bank to control the outputs. We start the I
     <sup class="calibre6">
      2
     </sup>
     C bus
     <!--<ccust1>3</ccust1>-->
     ❸, then address the GPIO registers by sending their addresses
     <!--<ccust1>4</ccust1>-->
     ❹. Then we send the data to control the registers
     <!--<ccust1>5</ccust1>-->
     ❺ and stop the I
     <sup class="calibre6">
      2
     </sup>
     C bus
     <!--<ccust1>6</ccust1>-->
     ❻. Following this, after restarting the I
     <sup class="calibre6">
      2
     </sup>
     C bus, the code selects the second bank of the MCP23017
     <!--<ccust1>7</ccust1>-->
     ❼, sends the data
     <!--<ccust1>8</ccust1>-->
     ❽, and again stops the bus
     <!--<ccust1>9</ccust1>-->
     ❾.
    </p>
    <p class="calibre8">
     As this project is intended to demonstrate all possible output combinations, it sends a decimal number generated by the
     <code class="calibre23">
      for
     </code>
     loop. However, you can also use a binary number if it helps with visualizing which of the output pins to control. For example, if you want to turn on pins 7, 4, and 0 in a bank, you can send
     <code class="calibre23">
      0b10010001
     </code>
     rather than
     <code class="calibre23">
      145
     </code>
     in decimal, and the corresponding outputs will go high. Notice how the physical pin numbers match the ones in the binary number.
    </p>
    <p class="calibre8">
     Now that you know how to harness the MCP23017, let’s move on to reading data from an I
     <sup class="calibre6">
      2
     </sup>
     C device.
    </p>
   </div>
  </div>
  <div class="chapter">
   <h2 class="ah" id="ah1403">
    <span class="page" id="p262">
    </span>
    <a class="xref" href="nsp-boxall502581-0008.xhtml#rah1403">
     Reading Data from I
     <sup class="calibre33">
      2
     </sup>
     C Devices
    </a>
   </h2>
   <p class="paft">
    Now that you can write to an I
    <sup class="calibre6">
     2
    </sup>
    C device, it’s time to learn how to read data—such as sensor data, external memory, and other types of output—from these devices. To read data, after initializing the I
    <sup class="calibre6">
     2
    </sup>
    C bus as normal, we use this function:
   </p>
   <pre>
    <p class="cls">
     I2CstartWait(
     <code class="i1">
      address
     </code>
     );
    </p>
   </pre>
   <p class="calibre8">
    This time we add a 1 at the end of the 7-bit bus address (instead of a 0, for writing). Once the secondary device receives this address byte, it knows to send back one or more bytes of data to the bus for the primary device to receive.
   </p>
   <p class="calibre8">
    To determine the correct bus address to use to read from a device, take the device’s I
    <sup class="calibre6">
     2
    </sup>
    C address and convert it to binary. For example, the address
    <code class="calibre23">
     0x50
    </code>
    converts to
    <code class="calibre23">
     1010000
    </code>
    in binary. Add a 1 at the end so you end up with
    <code class="calibre23">
     10100001
    </code>
    , then convert this back to hexadecimal, which results in
    <code class="calibre23">
     0xA1
    </code>
    .
   </p>
   <p class="pcust">
    <span class="ccust">
     Note
    </span>
    If you don’t have a calculator capable of converting from binary to decimal to hexadecimal and vice versa, a useful website for various mathematical conversions is
    <a class="url-i1" href="https://www.rapidtables.com/convert/number/">
     https://www.rapidtables.com/convert/number/
    </a>
    .
   </p>
   <p class="calibre8">
    Next, we use one of two new functions,
    <code class="calibre23">
     I2Cread()
    </code>
    or
    <code class="calibre23">
     I2CreadACK()
    </code>
    .
    <code class="calibre23">
     I2Cread()
    </code>
    waits for a byte of data to come back from the secondary device (without an acknowledge bit) and places it in a byte variable:
   </p>
   <pre>
    <p class="clf">
     uint8_t I2Cread()
    </p>
    <p class="cl">
     {
    </p>
    <p class="cl">
     TWCR |= (1 &lt;&lt; TWINT)|(1 &lt;&lt; TWEN);
    </p>
    <p class="cl">
     I2Cwait();
    </p>
    <p class="cl">
     // Incoming byte is placed in TWDR register
    </p>
    <p class="cl">
     return TWDR;
    </p>
    <p class="cll">
     }
    </p>
   </pre>
   <p class="calibre8">
    This function enables the primary device to receive a byte of data by first setting TWINT and TWEN to enable the bus and free it for use. After waiting for the operation to complete, the byte of data received from the secondary device is available in the TWDR register, and it’s then passed as the result of the function with
    <code class="calibre23">
     return TWDR;
    </code>
    .
   </p>
   <p class="calibre8">
    Like
    <code class="calibre23">
     I2Cread()
    </code>
    ,
    <code class="calibre23">
     I2CreadACK()
    </code>
    waits for a byte from the secondary device and places it in a byte variable, but it also considers the acknowledge bit from the secondary device:
   </p>
   <pre>
    <p class="clf">
     uint8_t I2CreadACK()
    </p>
    <p class="cl">
     {
    </p>
    <p class="cl">
     TWCR |= (1 &lt;&lt; TWINT)|(1 &lt;&lt; TWEN)|(1 &lt;&lt; TWEA);
    </p>
    <p class="cl">
     I2Cwait();
    </p>
    <p class="cl">
     // Incoming byte is placed in TWDR register
    </p>
    <p class="cl">
     return TWDR;
    </p>
    <p class="cll">
     }
    </p>
   </pre>
   <p class="calibre8">
    <span id="p263">
    </span>
    This time, in addition to setting TWINT and TWEN, we set TWEA in TWCR to 1. This generates the ACK (acknowledge bit) on the bus when the primary device has successfully received the byte of data.
   </p>
   <p class="calibre8">
    We pick which read function to use based on the parameters of the secondary device. Some devices require the ACK bit before sending more data, and some do not.
   </p>
   <p class="calibre8">
    Now that we have the full complement of functions for using the I
    <sup class="calibre6">
     2
    </sup>
    C bus, let’s put them to use in the following projects.
   </p>
   <p class="hd" id="pro50">
    <a class="xref" href="nsp-boxall502581-0008.xhtml#rpro50">
     <span class="ccust1">
      Project 50: Using an External IC EEPROM
     </span>
    </a>
   </p>
   <p class="paft">
    <a class="url" href="nsp-boxall502581-0019.xhtml#pro39">
     Project 39
    </a>
    in
    <a class="url" href="nsp-boxall502581-0019.xhtml#ch09">
     Chapter 9
    </a>
    showed how to use the ATmega328P-PU’s internal EEPROM to store data that you don’t want to delete when you remove the power source. Taking this idea further, you can also use external EEPROM ICs that have more storage space and allow you to build projects with microcontrollers that don’t have their own EEPROMs.
   </p>
   <p class="calibre8">
    For this project, we’ll use the Microchip 24LC512-E/P EEPROM IC, an example of which is shown in
    <a class="url" href="nsp-boxall502581-0022.xhtml#f12009">
     Figure 12-9
    </a>
    .
   </p>
   <div class="figure" id="f12009">
    <p class="fig">
     <img alt="Photo of a 24LC512-E/P EEPROM IC" height="1200" src="images/nsp-boxall502581-f12009.jpg" width="1124" class="calibre11"/>
    </p>
    <div class="chapter">
     <p class="figh">
      <span class="calibre4">
       Figure 12-9:
      </span>
      Microchip 24LC512-E/P external EEPROM IC
     </p>
    </div>
   </div>
   <p class="calibre8">
    <a class="url" href="nsp-boxall502581-0022.xhtml#f12010">
     Figure 12-10
    </a>
    shows the Microchip 24LC512-E/P’s schematic symbol.
   </p>
   <div class="figure" id="f12010">
    <p class="fig">
     <img alt="Schematic symbol for the 24LC512-E/P" height="1200" src="images/nsp-boxall502581-f12010.jpg" width="1185" class="calibre11"/>
    </p>
    <div class="chapter">
     <p class="figh">
      <span class="calibre4">
       Figure 12-10:
      </span>
      Microchip 24LC512-E/P schematic symbol
     </p>
    </div>
   </div>
   <p class="calibre8">
    <span id="p264">
    </span>
    As with most other I
    <sup class="calibre6">
     2
    </sup>
    C devices, you can set this IC’s 7-bit address by connecting the combination of pins A0, A1, and A2 to power or GND. If you’re using one 24LC512-E/P, you can set the bus address to
    <code class="calibre23">
     0x50
    </code>
    by connecting the three A pins to GND. If you’re using two or more, or need to let another secondary device use the
    <code class="calibre23">
     0x50
    </code>
    address; refer to
    <a class="url" href="nsp-boxall502581-0022.xhtml#tab1202">
     Table 12-2
    </a>
    for your configuration.
   </p>
   <table id="tab1202" class="calibre13">
    <thead class="calibre14">
     <tr class="calibre15">
      <th colspan="4" class="calibre16">
       <p class="th1">
        <span class="calibre4">
         Table 12-2
        </span>
        : 24LC512-E/P I
        <sup class="calibre6">
         2
        </sup>
        C Bus Address Configuration
       </p>
      </th>
     </tr>
     <tr class="calibre15">
      <th scope="col" class="calibre16">
       <p class="tch">
        Bus address
       </p>
      </th>
      <th scope="col" class="calibre16">
       <p class="tch">
        Pin A2
       </p>
      </th>
      <th scope="col" class="calibre16">
       <p class="tch">
        Pin A1
       </p>
      </th>
      <th scope="col" class="calibre16">
       <p class="tch">
        Pin A0
       </p>
      </th>
     </tr>
    </thead>
    <tbody class="calibre17">
     <tr class="calibre15">
      <td class="calibre18">
       <p class="td">
        <code class="calibre23">
         0x50
        </code>
       </p>
      </td>
      <td class="calibre18">
       <p class="td">
        GND
       </p>
      </td>
      <td class="calibre18">
       <p class="td">
        GND
       </p>
      </td>
      <td class="calibre18">
       <p class="td">
        GND
       </p>
      </td>
     </tr>
     <tr class="calibre15">
      <td class="calibre18">
       <p class="td">
        <code class="calibre23">
         0x51
        </code>
       </p>
      </td>
      <td class="calibre18">
       <p class="td">
        GND
       </p>
      </td>
      <td class="calibre18">
       <p class="td">
        GND
       </p>
      </td>
      <td class="calibre18">
       <p class="td">
        5 V
       </p>
      </td>
     </tr>
     <tr class="calibre15">
      <td class="calibre18">
       <p class="td">
        <code class="calibre23">
         0x52
        </code>
       </p>
      </td>
      <td class="calibre18">
       <p class="td">
        GND
       </p>
      </td>
      <td class="calibre18">
       <p class="td">
        5 V
       </p>
      </td>
      <td class="calibre18">
       <p class="td">
        GND
       </p>
      </td>
     </tr>
     <tr class="calibre15">
      <td class="calibre18">
       <p class="td">
        <code class="calibre23">
         0x53
        </code>
       </p>
      </td>
      <td class="calibre18">
       <p class="td">
        GND
       </p>
      </td>
      <td class="calibre18">
       <p class="td">
        5 V
       </p>
      </td>
      <td class="calibre18">
       <p class="td">
        5 V
       </p>
      </td>
     </tr>
     <tr class="calibre15">
      <td class="calibre18">
       <p class="td">
        <code class="calibre23">
         0x54
        </code>
       </p>
      </td>
      <td class="calibre18">
       <p class="td">
        5 V
       </p>
      </td>
      <td class="calibre18">
       <p class="td">
        GND
       </p>
      </td>
      <td class="calibre18">
       <p class="td">
        GND
       </p>
      </td>
     </tr>
     <tr class="calibre15">
      <td class="calibre18">
       <p class="td">
        <code class="calibre23">
         0x55
        </code>
       </p>
      </td>
      <td class="calibre18">
       <p class="td">
        5 V
       </p>
      </td>
      <td class="calibre18">
       <p class="td">
        GND
       </p>
      </td>
      <td class="calibre18">
       <p class="td">
        5 V
       </p>
      </td>
     </tr>
     <tr class="calibre15">
      <td class="calibre18">
       <p class="td">
        <code class="calibre23">
         0x56
        </code>
       </p>
      </td>
      <td class="calibre18">
       <p class="td">
        5 V
       </p>
      </td>
      <td class="calibre18">
       <p class="td">
        5 V
       </p>
      </td>
      <td class="calibre18">
       <p class="td">
        GND
       </p>
      </td>
     </tr>
     <tr class="calibre15">
      <td class="calibre18">
       <p class="td">
        <code class="calibre23">
         0x57
        </code>
       </p>
      </td>
      <td class="calibre18">
       <p class="td">
        5 V
       </p>
      </td>
      <td class="calibre18">
       <p class="td">
        5 V
       </p>
      </td>
      <td class="calibre18">
       <p class="td">
        5 V
       </p>
      </td>
     </tr>
    </tbody>
   </table>
   <p class="calibre8">
    The 24LC512-E/P can store up to 512KB of data (or, divided by 8, 64,000 bytes). This project demonstrates how to write and read bytes of data to the EEPROM for integration into other projects.
   </p>
   <div class="chapter">
    <h3 class="bh" id="bh1405">
     <a class="xref" href="nsp-boxall502581-0008.xhtml#rbh1405">
      The Hardware
     </a>
    </h3>
    <p class="paft">
     To build your circuit, you’ll need the following hardware:
    </p>
    <ul class="calibre10">
     <li class="blf">
      • USBasp programmer
     </li>
     <li class="bl">
      • Solderless breadboard
     </li>
     <li class="bl">
      • 5 V breadboard power supply
     </li>
     <li class="bl">
      • ATmega328P-PU microcontroller
     </li>
     <li class="bl">
      • Microchip 24LC512-E/P EEPROM IC
     </li>
     <li class="bl">
      • Two 4.7
      <span lang="en" xml:lang="en">
       kΩ
      </span>
      resistors (R1–R2)
     </li>
     <li class="bl">
      • Two 22 pF ceramic capacitors (C1–C2)
     </li>
     <li class="bl">
      • 470
      <span lang="el" xml:lang="el">
       μF
      </span>
      16 V electrolytic capacitor (C3)
     </li>
     <li class="bl">
      • 16 MHz crystal oscillator
     </li>
     <li class="bl">
      • MAX7219 eight-digit module
     </li>
     <li class="bll">
      • Jumper wires
     </li>
    </ul>
    <p class="calibre8">
     Assemble your circuit as shown in
     <a class="url" href="nsp-boxall502581-0022.xhtml#f12011">
      Figure 12-11
     </a>
     .
    </p>
    <div class="figure" id="f12011">
     <p class="fig">
      <span id="p265">
      </span>
      <img alt="Schematic diagram for Project 50" height="930" src="images/nsp-boxall502581-f12011.jpg" width="1200" class="calibre11"/>
     </p>
     <div class="chapter">
      <p class="figh">
       <span class="calibre4">
        Figure 12-11:
       </span>
       Schematic for
       <a class="url" href="nsp-boxall502581-0022.xhtml#pro50">
        Project 50
       </a>
      </p>
     </div>
    </div>
   </div>
   <div class="chapter">
    <h3 class="bh" id="bh1406">
     <a class="xref" href="nsp-boxall502581-0008.xhtml#rbh1406">
      The Code
     </a>
    </h3>
    <p class="paft">
     Open a terminal window, navigate to the
     <i class="calibre5">
      Project 50
     </i>
     subfolder of this book’s
     <i class="calibre5">
      Chapter 12
     </i>
     folder, and enter the command
     <code class="b">
      make flash
     </code>
     . After a few moments, the MAX7219 display should rapidly display the numbers between 0 and 255, writing these values to the EEPROM. Then it should display these numbers again at a slower pace as it reads them from the EEPROM.
    </p>
    <p class="calibre8">
     Let’s examine the code to see how this is done:
    </p>
    <pre>
     <p class="clf">
      // Project 50 - 24LC512 I2C EEPROM
     </p>
     <p class="clf">
      #include &lt;avr/io.h&gt;
     </p>
     <p class="cl">
      #include &lt;util/delay.h&gt;
     </p>
     <p class="clf">
      void I2Cenable()
     </p>
     <p class="cl">
      // Enable I2C bus
     </p>
     <p class="cl">
      {
     </p>
     <p class="cl">
      TWBR = 72;           // 100 kHz I2C bus
     </p>
     <p class="cl">
      <span id="p266">
      </span>
      TWCR |= (1 &lt;&lt; TWEN); // Enable I2C on PORTC4 and 5
     </p>
     <p class="cl">
      }
     </p>
     <p class="clf">
      void I2Cwait()
     </p>
     <p class="cl">
      // Wait until I2C finishes an operation
     </p>
     <p class="cl">
      {
     </p>
     <p class="cl">
      // Wait until bit TWINT in TWCR is set to 1
     </p>
     <p class="cl">
      while (!(TWCR &amp; (1&lt;&lt;TWINT)));
     </p>
     <p class="cl">
      }
     </p>
     <p class="clf">
      void I2CstartWait(unsigned char address)
     </p>
     <p class="cl">
      {
     </p>
     <p class="cl">
      uint8_t status;
     </p>
     <p class="cl">
      while (1)
     </p>
     <p class="cl">
      {
     </p>
     <p class="cl">
      // Send START condition
     </p>
     <p class="cl">
      TWCR = (1&lt;&lt;TWINT) | (1&lt;&lt;TWSTA) | (1&lt;&lt;TWEN);
     </p>
     <p class="clf">
      // Wait until transmission completes
     </p>
     <p class="cl">
      I2Cwait();
     </p>
     <p class="clf">
      // Check value of TWSR, and mask out status bits
     </p>
     <p class="cl">
      status = TWSR &amp; 0b11111000;
     </p>
     <p class="cl">
      if ((status != 0b00001000) &amp;&amp; (status != 0b00010000)) continue;
     </p>
     <p class="clf">
      // Send device address
     </p>
     <p class="cl">
      TWDR = address;
     </p>
     <p class="cl">
      TWCR = (1&lt;&lt;TWINT) | (1&lt;&lt;TWEN);
     </p>
     <p class="clf">
      // Wait until transmission completes
     </p>
     <p class="cl">
      I2Cwait();
     </p>
     <p class="clf">
      // Check value of TWSR, and mask out status bits
     </p>
     <p class="cl">
      status = TWSR &amp; 0b11111000;
     </p>
     <p class="cl">
      if ((status == 0b00100000 )||(status == 0b01011000))
     </p>
     <p class="cl">
      {   // Secondary device is busy, so send stop condition to terminate
     </p>
     <p class="cl">
      // write operation
     </p>
     <p class="cl">
      TWCR = (1&lt;&lt;TWINT) | (1&lt;&lt;TWEN) | (1&lt;&lt;TWSTO);
     </p>
     <p class="cl">
      // Wait until stop condition is executed and I2C bus released
     </p>
     <p class="cl">
      while(TWCR &amp; (1&lt;&lt;TWSTO));
     </p>
     <p class="cl">
      continue;
     </p>
     <p class="cl">
      }
     </p>
     <p class="cl">
      break;
     </p>
     <p class="cl">
      }
     </p>
     <p class="cl">
      }
     </p>
     <p class="clf">
      void I2Cstop()
     </p>
     <p class="cl">
      // Stop I2C bus and release GPIO pins
     </p>
     <p class="cl">
      {
     </p>
     <p class="cl">
      // Clear interrupt, enable I2C, generate stop condition
     </p>
     <p class="cl">
      TWCR |= (1 &lt;&lt; TWINT)|(1 &lt;&lt; TWEN)|(1 &lt;&lt; TWSTO);
     </p>
     <p class="cl">
      }
     </p>
     <p class="clf">
      void I2Cwrite(uint8_t data)
     </p>
     <p class="cl">
      // Send ′data′ to I2C bus
     </p>
     <p class="cl">
      <span id="p267">
      </span>
      {
     </p>
     <p class="cl">
      TWDR = data;
     </p>
     <p class="cl">
      TWCR |= (1 &lt;&lt; TWINT)|(1 &lt;&lt; TWEN);
     </p>
     <p class="cl">
      I2Cwait();
     </p>
     <p class="cl">
      }
     </p>
     <p class="clf">
      uint8_t I2Cread()
     </p>
     <p class="cl">
      // Read incoming byte of data from I2C bus
     </p>
     <p class="cl">
      {
     </p>
     <p class="cl">
      TWCR |= (1 &lt;&lt; TWINT)|(1 &lt;&lt; TWEN);
     </p>
     <p class="cl">
      I2Cwait();
     </p>
     <p class="cl">
      // Incoming byte is placed in TWDR register
     </p>
     <p class="cl">
      return TWDR;
     </p>
     <p class="cl">
      }
     </p>
     <p class="cl">
      uint8_t I2CreadACK()
     </p>
     <p class="cl">
      // Read incoming byte of data from I2C bus and ACK signal
     </p>
     <p class="cl">
      {
     </p>
     <p class="cl">
      TWCR |= (1 &lt;&lt; TWINT)|(1 &lt;&lt; TWEN)|(1 &lt;&lt; TWEA);
     </p>
     <p class="cl">
      I2Cwait();
     </p>
     <p class="cl">
      // Incoming byte is placed in TWDR register
     </p>
     <p class="cl">
      return TWDR;
     </p>
     <p class="cl">
      }
     </p>
     <p class="clf">
      void writeMAX7219(char hexdata1, char hexdata2)
     </p>
     <p class="cl">
      // Sends two bytes in hexadecimal to MAX7219
     </p>
     <p class="cl">
      {
     </p>
     <p class="cl">
      PORTB &amp;= ~(1 &lt;&lt; PORTB0);    // SS pin LOW
     </p>
     <p class="cl">
      SPDR = hexdata1;            // Send value of hexdata1
     </p>
     <p class="cl">
      while(!(SPSR &amp; (1&lt;&lt;SPIF))); // Wait for SPI transmission to finish
     </p>
     <p class="cl">
      SPDR = hexdata2;            // Send value of hexdata2
     </p>
     <p class="cl">
      while(!(SPSR &amp; (1&lt;&lt;SPIF))); // Wait for SPI transmission to finish
     </p>
     <p class="cl">
      PORTB |= (1 &lt;&lt; PORTB0);     // SS pin HIGH
     </p>
     <p class="cl">
      }
     </p>
     <p class="clf">
      void blankMAX7219()
     </p>
     <p class="cl">
      // Blanks all digits
     </p>
     <p class="cl">
      {
     </p>
     <p class="cl">
      uint8_t i;
     </p>
     <p class="cl">
      for (i=1; i&lt;9; i++)         // Blank all digits
     </p>
     <p class="cl">
      {
     </p>
     <p class="cl">
      writeMAX7219(i,15);
     </p>
     <p class="cl">
      }
     </p>
     <p class="cl">
      }
     </p>
     <p class="clf">
      void initMAX7219()
     </p>
     <p class="cl">
      // Set up MAX7219 for use
     </p>
     <p class="cl">
      {
     </p>
     <p class="cl">
      PORTB |= (1 &lt;&lt; 0);          // SS pin HIGH
     </p>
     <p class="cl">
      SPCR = (1&lt;&lt;SPE)|(1&lt;&lt;MSTR);  // Set up SPI bus for MAX7219
     </p>
     <p class="cl">
      // Mode decode for digits (table 4 page 7 - 0x09 + 0xFF)
     </p>
     <p class="cl">
      writeMAX7219(0x09,0xFF);
     </p>
     <p class="cl">
      writeMAX7219(0x0B,0x07);    // Set scan limit to 8 digits - 0x09 + 0xFF)
     </p>
     <p class="cl">
      writeMAX7219(0x0A,0x01);    // Set intensity to 8 - 0x0A + 0x08)
     </p>
     <p class="cl">
      // Mode display on (table 4 page 7 - 0x09 + 0xFF)
     </p>
     <p class="cl">
      writeMAX7219(0x0C,0x01);
     </p>
     <p class="cl">
      <span id="p268">
      </span>
      blankMAX7219();
     </p>
     <p class="cl">
      }
     </p>
     <p class="clf">
      void dispMAX7219(uint8_t digit, uint8_t number, uint8_t dp)
     </p>
     <p class="cl">
      // Displays "number" in location "digit" with decimal point on/off
     </p>
     <p class="cl">
      // Digit: 1~8 for location 1~8
     </p>
     <p class="cl">
      // Number: 0~15 for 0~9, - E, H, L, P, blank
     </p>
     <p class="cl">
      // dp: 1 on, 0 off
     </p>
     <p class="cl">
      {
     </p>
     <p class="cl">
      if (dp==1)                       // Add decimal point
     </p>
     <p class="cl">
      {
     </p>
     <p class="cl">
      number = number + 128;
     </p>
     <p class="cl">
      }
     </p>
     <p class="cl">
      writeMAX7219(digit, number);
     </p>
     <p class="cl">
      }
     </p>
     <p class="clf">
      void numberMAX7219(uint32_t value)
     </p>
     <p class="cl">
      // Displays a number between 0–99999999 on MAX7219-controlled 8-digit display
     </p>
     <p class="cl">
      {
     </p>
     <p class="cl">
      uint8_t digits[8];
     </p>
     <p class="cl">
      uint8_t i = 1;
     </p>
     <p class="clf">
      for (i=1; i&lt;9; i++)
     </p>
     <p class="cl">
      {
     </p>
     <p class="cl">
      digits[i]=15;
     </p>
     <p class="cl">
      }
     </p>
     <p class="clf">
      i = 1;
     </p>
     <p class="cl">
      while (value &gt; 0)                // Continue until value &gt; 0
     </p>
     <p class="cl">
      {  // Determine and store last digit of number
     </p>
     <p class="cl">
      digits[i] = value % 10;
     </p>
     <p class="cl">
      value = value / 10;           // Divide value by 10
     </p>
     <p class="cl">
      i++;
     </p>
     <p class="cl">
      }
     </p>
     <p class="cl">
      for (i=1; i&lt;9; i++)
     </p>
     <p class="cl">
      {
     </p>
     <p class="cl">
      dispMAX7219(i, digits[i],0);
     </p>
     <p class="cl">
      }
     </p>
     <p class="cl">
      }
     </p>
     <p class="clf">
      int main(void)
     </p>
     <p class="cl">
      {
     </p>
     <p class="cl">
      uint16_t i;
     </p>
     <p class="cl">
      uint16_t j;
     </p>
     <p class="cl">
      DDRB = 0b11111111;               // Set PORTB as outputs
     </p>
     <p class="cl">
      I2Cenable();
     </p>
     <p class="cl">
      initMAX7219();
     </p>
     <p class="cl">
      while (1)
     </p>
     <p class="cl">
      {
     </p>
     <p class="cl">
      dispMAX7219(0,10,0);
     </p>
     <p class="cl">
      for (i = 0; i&lt;256; i++)       // Write loop
     </p>
     <p class="cl">
      {
     </p>
     <p class="cl">
      <!--<ccust1>1</ccust1>-->
      ❶ I2CstartWait(0x50&lt;&lt;1);     // 0x50 &lt;&lt; 1 - 0b10100000
     </p>
     <p class="cl">
      <!--<ccust1>2</ccust1>-->
      ❷ I2Cwrite(i &gt;&gt; 8);
     </p>
     <p class="cl">
      <!--<ccust1>3</ccust1>-->
      ❸ I2Cwrite(i);
     </p>
     <p class="cl">
      <span id="p269">
      </span>
      <!--<ccust1>4</ccust1>-->
      ❹ I2Cwrite(i);
     </p>
     <p class="cl">
      I2Cstop();
     </p>
     <p class="cl">
      numberMAX7219(i);
     </p>
     <p class="cl">
      _delay_ms(1);
     </p>
     <p class="cl">
      }
     </p>
     <p class="clf">
      for (i = 0; i&lt;256; i++)       // Read loop
     </p>
     <p class="cl">
      {
     </p>
     <p class="cl">
      <!--<ccust1>5</ccust1>-->
      ❺ I2CstartWait(0x50&lt;&lt;1);     // Write address
     </p>
     <p class="cl">
      <!--<ccust1>6</ccust1>-->
      ❻ I2Cwrite(i &gt;&gt; 8);
     </p>
     <p class="cl">
      <!--<ccust1>7</ccust1>-->
      ❼ I2Cwrite(i);
     </p>
     <p class="cl">
      <!--<ccust1>8</ccust1>-->
      ❽ I2CstartWait((0x50&lt;&lt;1)+1); // Read address - 0b10100001
     </p>
     <p class="cl">
      <!--<ccust1>9</ccust1>-->
      ❾ j = I2Cread();
     </p>
     <p class="cl">
      <!--<ccust1>0</ccust1>-->
      ⓿ I2Cstop();
     </p>
     <p class="cl">
      numberMAX7219(j);
     </p>
     <p class="cl">
      _delay_ms(5);
     </p>
     <p class="cl">
      }
     </p>
     <p class="cl">
      _delay_ms(100);
     </p>
     <p class="cl">
      }
     </p>
     <p class="cll">
      }
     </p>
    </pre>
    <p class="calibre8">
     This code reuses functions from previous projects, such as the MAX7219 functions from
     <a class="url" href="nsp-boxall502581-0021.xhtml#ch11">
      Chapter 11
     </a>
     and the I
     <sup class="calibre6">
      2
     </sup>
     C bus functions from this chapter’s
     <a class="url" href="nsp-boxall502581-0022.xhtml#pro49">
      Project 49
     </a>
     ; the new code is contained in the main loop. In summary, it writes and retrieves the values 0 through 255 to and from EEPROM locations 0 through 255. This is accomplished in the write and read loops in the main section of the code.
    </p>
    <p class="calibre8">
     To write values to the EEPROM, we first start the bus and wait for acknowledgment
     <!--<ccust1>1</ccust1>-->
     ❶ in our write loop, using the “write” form of the bus address. The EEPROM is now expecting 2 bytes of data, which represent the address (or location) in the EEPROM’s memory to deal with (in this case, write to). It expects 2 bytes of data because there are more than 256 possible locations. Therefore, the code creates the variable
     <code class="calibre23">
      i
     </code>
     in the loop as a 16-bit integer.
    </p>
    <p class="calibre8">
     We send the “high byte” of the address
     <!--<ccust1>2</ccust1>-->
     ❷, which details the part of the address above 255, and follow it with the “low byte,” which details the part of the address equal to or less than 255
     <!--<ccust1>3</ccust1>-->
     ❸. Then we send the value to store to the EEPROM
     <!--<ccust1>4</ccust1>-->
     ❹, and the MAX7219 display shows that value for our reference.
    </p>
    <p class="calibre8">
     To read the values from the EEPROM, we first start the bus and wait for acknowledgment
     <!--<ccust1>5</ccust1>-->
     ❺ in our read loop, again using the “write” form of the bus address, then send the high
     <!--<ccust1>6</ccust1>-->
     ❻ and low
     <!--<ccust1>7</ccust1>-->
     ❼ bytes of the address as we did previously.
    </p>
    <p class="calibre8">
     Next, to retrieve data from the EEPROM, we restart the I
     <sup class="calibre6">
      2
     </sup>
     C bus
     <!--<ccust1>8</ccust1>-->
     ❽ by using the read form of the bus address. We then use our new
     <code class="calibre23">
      I2Cread()
     </code>
     function to take the byte sent from the EEPROM back to the microcontroller and store it in the variable
     <code class="calibre23">
      j
     </code>
     <!--<ccust1>9</ccust1>-->
     ❾. Now that we have the data from the EEPROM, we stop using the I
     <sup class="calibre6">
      2
     </sup>
     C bus
     <!--<ccust1>0</ccust1>-->
     ⓿ and show the values on the MAX7219 display module for reference.
    </p>
    <div class="box">
     <div class="chapter" id="bxheader1201">
      <p class="bxh">
       <span id="p270">
       </span>
       More on the High Byte and Low Byte
      </p>
     </div>
     <p class="bxaft">
      We need to split 16-bit integers into high and low bytes to send them along the I
      <sup class="calibre6">
       2
      </sup>
      C (or SPI) data bus. This involves bit-shifting the whole 16-bit number 8 bits to the right to determine the high byte, then sending the low byte by simply using the 16-bit number in an 8-bit operation, as doing this effectively removes the high byte.
     </p>
     <p class="calibre8">
      For example, consider the number 41,217. That’s greater than 255, so we need 2 bytes of data to represent it in AVR operations. If you convert 41,217 to binary, you’ll see that it uses 16 bits:
     </p>
     <p class="bx1s">
      1010000100000001
     </p>
     <p class="calibre8">
      We create the 8-bit high byte by bit-shifting the entire number 8 bits to the right. For example:
     </p>
     <p class="bx1s">
      <code class="b">
       10100001
      </code>
      00000001 &gt;&gt; 8 =
      <code class="b">
       10100001
      </code>
      // Our high byte
     </p>
     <p class="calibre8">
      We then create the low byte by simply using it in an 8-bit operation. For example:
     </p>
     <p class="bx1s">
      I2Cwrite(
      <code class="b">
       10100001
      </code>
      00000001)
     </p>
     <p class="calibre8">
      This has the same effect as
      <code class="calibre23">
       I2Cwrite(00000001)
      </code>
      .
     </p>
    </div>
    <p class="calibre8">
     This project provided a neat demonstration not only of writing and reading bytes of data to and from an I
     <sup class="calibre6">
      2
     </sup>
     C-based device but also of the framework for storing data in external EEPROM IC. In the
     <a class="url" href="nsp-boxall502581-0022.xhtml#pro51">
      next project
     </a>
     , we’ll move on to our final I
     <sup class="calibre6">
      2
     </sup>
     C bus device, the DS3231—a
     <i class="calibre5">
      real-time clock (RTC)
     </i>
     IC that allows you to add time and date information to your projects.
    </p>
    <p class="hd" id="pro51">
     <a class="xref" href="nsp-boxall502581-0008.xhtml#rpro51">
      <span class="ccust1">
       Project 51: Using the DS3231 Real-Time Clock
      </span>
     </a>
    </p>
    <p class="paft">
     Once set with the current time and date, an RTC provides accurate time and date data on request. RTCs allow you to build a variety of interesting projects, from simple clocks to data-logging devices, alarms, and more. In this project, you’ll create a clock that displays the current date and time in 24-hour format using an RTC and the MAX7219 display module.
    </p>
    <p class="calibre8">
     You’ll find many different RTC ICs on the market, some more accurate than others. In this chapter, we’ll use the Maxim DS3231; it doesn’t require any external circuitry other than a backup battery, it’s incredibly accurate, and it’s quite robust in module form.
    </p>
    <p class="calibre8">
     The DS3231 is available as a breakout board from various retailers, including the version from PMD Way (part number 883422) shown in
     <a class="url" href="nsp-boxall502581-0022.xhtml#f12012">
      Figure 12-12
     </a>
     .
    </p>
    <div class="figure" id="f12012">
     <p class="fig">
      <span id="p271">
      </span>
      <img alt="Photo of PMD Way part number 883422" height="689" src="images/nsp-boxall502581-f12012.jpg" width="1200" class="calibre11"/>
     </p>
     <div class="chapter">
      <p class="figh">
       <span class="calibre4">
        Figure 12-12:
       </span>
       A DS3231 real-time clock IC module
      </p>
     </div>
    </div>
    <p class="calibre8">
     Using a breakout board means you don’t need to worry about support circuitry like pullup resistors for the DS3231, nor connecting a backup battery, as the board takes care of all this for you. All you need to do is insert a CR2032 coin-cell battery for the backup and connect jumper wires to your project.
    </p>
    <p class="calibre8">
     Connecting the breakout board to your project is easy: just use V
     <sub class="calibre28">
      CC
     </sub>
     (for 5 V), GND, SCL, and SDA connections. The DS3231 has a fixed I
     <sup class="calibre6">
      2
     </sup>
     C bus address of
     <code class="calibre23">
      0x68
     </code>
     , which converts to a write address of
     <code class="calibre23">
      0xD0
     </code>
     and a read address of
     <code class="calibre23">
      0xD1
     </code>
     .
    </p>
    <p class="calibre8">
     It has a group of registers it uses to store time and date information, starting at
     <code class="calibre23">
      0x00
     </code>
     and increasing sequentially, as shown in
     <a class="url" href="nsp-boxall502581-0022.xhtml#tab1203">
      Table 12-3
     </a>
     .
    </p>
    <table id="tab1203" class="calibre13">
     <thead class="calibre14">
      <tr class="calibre15">
       <th colspan="2" class="calibre16">
        <p class="th1">
         <span class="calibre4">
          Table 12-3
         </span>
         : DS3231 Data Registers
        </p>
       </th>
      </tr>
      <tr class="calibre15">
       <th scope="col" class="calibre16">
        <p class="tch">
         Address
        </p>
       </th>
       <th scope="col" class="calibre16">
        <p class="tch">
         Function
        </p>
       </th>
      </tr>
     </thead>
     <tbody class="calibre17">
      <tr class="calibre15">
       <td class="calibre18">
        <p class="td">
         <code class="calibre23">
          0x00
         </code>
        </p>
       </td>
       <td class="calibre18">
        <p class="td">
         Seconds
        </p>
       </td>
      </tr>
      <tr class="calibre15">
       <td class="calibre18">
        <p class="td">
         <code class="calibre23">
          0x01
         </code>
        </p>
       </td>
       <td class="calibre18">
        <p class="td">
         Minutes
        </p>
       </td>
      </tr>
      <tr class="calibre15">
       <td class="calibre18">
        <p class="td">
         <code class="calibre23">
          0x02
         </code>
        </p>
       </td>
       <td class="calibre18">
        <p class="td">
         Hours
        </p>
       </td>
      </tr>
      <tr class="calibre15">
       <td class="calibre18">
        <p class="td">
         <code class="calibre23">
          0x03
         </code>
        </p>
       </td>
       <td class="calibre18">
        <p class="td">
         Day of week (1 = Sunday, 7 = Saturday)
        </p>
       </td>
      </tr>
      <tr class="calibre15">
       <td class="calibre18">
        <p class="td">
         <code class="calibre23">
          0x04
         </code>
        </p>
       </td>
       <td class="calibre18">
        <p class="td">
         Day of month
        </p>
       </td>
      </tr>
      <tr class="calibre15">
       <td class="calibre18">
        <p class="td">
         <code class="calibre23">
          0x05
         </code>
        </p>
       </td>
       <td class="calibre18">
        <p class="td">
         Month
        </p>
       </td>
      </tr>
      <tr class="calibre15">
       <td class="calibre18">
        <p class="td">
         <code class="calibre23">
          0x06
         </code>
        </p>
       </td>
       <td class="calibre18">
        <p class="td">
         Year (two-digit)
        </p>
       </td>
      </tr>
     </tbody>
    </table>
    <p class="calibre8">
     In this project, we’ll use only the registers shown in
     <a class="url" href="nsp-boxall502581-0022.xhtml#tab1203">
      Table 12-3
     </a>
     . However, the data sheet details more that you can investigate; it’s available at
     <a class="url-i" href="https://www.maximintegrated.com/en/products/analog/real-time-clocks/DS3231.html">
      https://www.maximintegrated.com/en/products/analog/real-time-clocks/DS3231.html
     </a>
     .
    </p>
    <p class="calibre8">
     Data is stored in the DS3231 registers using
     <i class="calibre5">
      binary-coded decimal (BCD)
     </i>
     format, which assigns a four-digit binary code to each digit in a decimal number. Therefore, we’ll use simple BCD-to-decimal conversions in our code.
    </p>
    <p class="calibre8">
     To set the time and date, we’ll write the bytes of data in order from
     <code class="calibre23">
      0x00
     </code>
     using our I
     <sup class="calibre6">
      2
     </sup>
     C bus write function. To retrieve the data, we can either read from a particular address, as we did with the EEPROM in
     <a class="url" href="nsp-boxall502581-0022.xhtml#pro50">
      Project 50
     </a>
     , or start a read at
     <code class="calibre23">
      0x00
     </code>
     with ACK, causing the DS3231 to send the rest of the data one byte at a time from each sequential register. We’ll use this latter method in our project’s code. But first, let’s assemble the hardware.
    </p>
   </div>
   <div class="chapter">
    <h3 class="bh" id="bh1407">
     <span class="page" id="p272">
     </span>
     <a class="xref" href="nsp-boxall502581-0008.xhtml#rbh1407">
      The Hardware
     </a>
    </h3>
    <p class="paft">
     To build your circuit, you’ll need the following hardware:
    </p>
    <ul class="calibre10">
     <li class="blf">
      • USBasp programmer
     </li>
     <li class="bl">
      • Solderless breadboard
     </li>
     <li class="bl">
      • 5 V breadboard power supply
     </li>
     <li class="bl">
      • ATmega328P-PU microcontroller
     </li>
     <li class="bl">
      • DS3231 RTC module with backup battery
     </li>
     <li class="bl">
      • Two 22 pF ceramic capacitors (C1–C2)
     </li>
     <li class="bl">
      • 470
      <span lang="el" xml:lang="el">
       μF
      </span>
      16 V electrolytic capacitor (C3)
     </li>
     <li class="bl">
      • 16 MHz crystal oscillator
     </li>
     <li class="bl">
      • MAX7219 eight-digit module
     </li>
     <li class="bll">
      • Jumper wires
     </li>
    </ul>
    <p class="calibre8">
     Assemble your circuit as shown in
     <a class="url" href="nsp-boxall502581-0022.xhtml#f12013">
      Figure 12-13
     </a>
     . Don’t forget to connect the MAX7219 and DS3231 boards to 5 V and GND as well.
    </p>
    <div class="figure" id="f12013">
     <p class="fig">
      <img alt="Schematic diagram for Project 51" height="1156" src="images/nsp-boxall502581-f12013.jpg" width="1200" class="calibre11"/>
     </p>
     <div class="chapter">
      <p class="figh">
       <span class="calibre4">
        Figure 12-13:
       </span>
       Schematic for
       <a class="url" href="nsp-boxall502581-0022.xhtml#pro51">
        Project 51
       </a>
      </p>
     </div>
    </div>
   </div>
   <div class="chapter">
    <h3 class="bh" id="bh1408">
     <span class="page" id="p273">
     </span>
     <a class="xref" href="nsp-boxall502581-0008.xhtml#rbh1408">
      The Code
     </a>
    </h3>
    <p class="paft">
     Before uploading the code to the microcontroller as normal, open the
     <i class="calibre5">
      main.c
     </i>
     file found in the
     <i class="calibre5">
      Project 51
     </i>
     subfolder of this book’s
     <i class="calibre5">
      Chapter 12
     </i>
     folder in your text editor and scroll down to line 309. Remove the comment slashes in front of the function
     <code class="calibre23">
      setTimeDS3231()
     </code>
     . Next, update the parameters in that function to match your current date and time. The parameters, in order, are: hours (in 24-hour format), minutes, seconds, day of the week (1 to 7), date (1 to 31), month, year (00 to 99). For example, assuming you consider Sunday the first day of the week—in some areas Monday is considered the first day, so Monday would be 1—if the time is 2:32
     <span class="ac">
      PM
     </span>
     (that is, 14:32) on Tuesday, November 1, 2022, you would change the line to:
    </p>
    <pre>
     <p class="cls">
      setTimeDS3231(14,32,0,3,6,11,22);
     </p>
    </pre>
    <p class="calibre8">
     Now save the file, and execute the
     <code class="b">
      make flash
     </code>
     command as usual from the terminal window. Then reopen the
     <i class="calibre5">
      main.c
     </i>
     file, replace the comment slashes in front of the
     <code class="calibre23">
      setTimeDS3231()
     </code>
     function, save the file, and reflash the code. The first flash sets the time and date, and the second deactivates the setting every time the microcontroller is reset or power-cycled. If you skipped this second flash, the project would set the same time and date after every reset.
    </p>
    <p class="calibre8">
     Once you’ve finished, you should see the current time then date alternately displayed on the MAX7219 module. Congratulations—you’ve made your own digital clock!
    </p>
    <p class="calibre8">
     Now let’s examine the code to see how this works:
    </p>
    <pre>
     <p class="clf">
      // Project 51 - Using the DS3231 I2C Real-Time Clock
     </p>
     <p class="clf">
      #include &lt;avr/io.h&gt;
     </p>
     <p class="cl">
      #include &lt;util/delay.h&gt;
     </p>
     <p class="clf">
      // Variables to store time and date
     </p>
     <p class="cl2">
      <!--<ccust1>1</ccust1>-->
      ❶ uint8_t hours, minutes, seconds, dow, dom, mo, years;
     </p>
     <p class="clf">
      void I2Cenable()
     </p>
     <p class="cl">
      // Enable I2C bus
     </p>
     <p class="cl">
      {
     </p>
     <p class="cl">
      TWBR = 72;           // 100 kHz I2C bus
     </p>
     <p class="cl">
      TWCR |= (1 &lt;&lt; TWEN); // Enable I2C on PORTC4 and 5
     </p>
     <p class="cl">
      }
     </p>
     <p class="clf">
      void I2Cwait()
     </p>
     <p class="cl">
      // Wait until I2C finishes an operation
     </p>
     <p class="cl">
      {
     </p>
     <p class="cl">
      // Wait until bit TWINT in TWCR is set to 1
     </p>
     <p class="cl">
      while (!(TWCR &amp; (1&lt;&lt;TWINT)));
     </p>
     <p class="cl">
      }
     </p>
     <p class="clf">
      void I2CstartWait(unsigned char address)
     </p>
     <p class="cl">
      {
     </p>
     <p class="cl">
      uint8_t status;
     </p>
     <p class="cl">
      while (1)
     </p>
     <p class="cl">
      <span id="p274">
      </span>
      {
     </p>
     <p class="cl">
      // Send START condition
     </p>
     <p class="cl">
      TWCR = (1&lt;&lt;TWINT) | (1&lt;&lt;TWSTA) | (1&lt;&lt;TWEN);
     </p>
     <p class="clf">
      // Wait until transmission completes
     </p>
     <p class="cl">
      I2Cwait();
     </p>
     <p class="clf">
      // Check value of TWSR, and mask out status bits
     </p>
     <p class="cl">
      status = TWSR &amp; 0b11111000;
     </p>
     <p class="cl">
      if ((status != 0b00001000) &amp;&amp; (status != 0b00010000)) continue;
     </p>
     <p class="clf">
      // Send device address
     </p>
     <p class="cl">
      TWDR = address;
     </p>
     <p class="cl">
      TWCR = (1&lt;&lt;TWINT) | (1&lt;&lt;TWEN);
     </p>
     <p class="clf">
      // Wait until transmission completes
     </p>
     <p class="cl">
      I2Cwait();
     </p>
     <p class="clf">
      // Check value of TWSR, and mask out status bits
     </p>
     <p class="cl">
      status = TWSR &amp; 0b11111000;
     </p>
     <p class="cl">
      if ((status == 0b00100000 )||(status == 0b01011000))
     </p>
     <p class="cl">
      {
     </p>
     <p class="cl">
      TWCR = (1&lt;&lt;TWINT) | (1&lt;&lt;TWEN) | (1&lt;&lt;TWSTO);
     </p>
     <p class="clf">
      // Wait until stop condition is executed and I2C bus is released
     </p>
     <p class="cl">
      while(TWCR &amp; (1&lt;&lt;TWSTO));
     </p>
     <p class="cl">
      continue;
     </p>
     <p class="cl">
      }
     </p>
     <p class="cl">
      break;
     </p>
     <p class="cl">
      }
     </p>
     <p class="cl">
      }
     </p>
     <p class="clf">
      void I2Cstop()
     </p>
     <p class="cl">
      // Stop I2C bus and release GPIO pins
     </p>
     <p class="cl">
      {
     </p>
     <p class="cl">
      // Clear interrupt, enable I2C, generate stop condition
     </p>
     <p class="cl">
      TWCR |= (1 &lt;&lt; TWINT)|(1 &lt;&lt; TWEN)|(1 &lt;&lt; TWSTO);
     </p>
     <p class="cl">
      }
     </p>
     <p class="clf">
      void I2Cwrite(uint8_t data)
     </p>
     <p class="cl">
      // Send 'data' to I2C bus
     </p>
     <p class="cl">
      {
     </p>
     <p class="cl">
      TWDR = data;
     </p>
     <p class="cl">
      TWCR |= (1 &lt;&lt; TWINT)|(1 &lt;&lt; TWEN);
     </p>
     <p class="cl">
      I2Cwait();
     </p>
     <p class="cl">
      }
     </p>
     <p class="clf">
      uint8_t I2Cread()
     </p>
     <p class="cl">
      // Read incoming byte of data from I2C bus
     </p>
     <p class="cl">
      {
     </p>
     <p class="cl">
      TWCR |= (1 &lt;&lt; TWINT)|(1 &lt;&lt; TWEN);
     </p>
     <p class="cl">
      I2Cwait();
     </p>
     <p class="cl">
      // Incoming byte is placed in TWDR register
     </p>
     <p class="cl">
      return TWDR;
     </p>
     <p class="cl">
      }
     </p>
     <p class="clf">
      <span id="p275">
      </span>
      uint8_t I2CreadACK()
     </p>
     <p class="cl">
      // Read incoming byte of data from I2C bus and ACK signal
     </p>
     <p class="cl">
      {
     </p>
     <p class="cl">
      TWCR |= (1 &lt;&lt; TWINT)|(1 &lt;&lt; TWEN)|(1 &lt;&lt; TWEA);
     </p>
     <p class="cl">
      I2Cwait();
     </p>
     <p class="cl">
      // Incoming byte is placed in TWDR register
     </p>
     <p class="cl">
      return TWDR;
     </p>
     <p class="cl">
      }
     </p>
     <p class="cl">
      void writeMAX7219(char hexdata1, char hexdata2)
     </p>
     <p class="cl">
      // Sends two bytes in hexadecimal to MAX7219
     </p>
     <p class="cl">
      {
     </p>
     <p class="cl">
      PORTB &amp;= ~(1 &lt;&lt; PORTB0);      // SS pin LOW
     </p>
     <p class="cl">
      SPDR = hexdata1;              // Send value of hexdata1
     </p>
     <p class="cl">
      while(!(SPSR &amp; (1&lt;&lt;SPIF)));   // Wait for SPI transmission to finish
     </p>
     <p class="cl">
      SPDR = hexdata2;              // Send value of hexdata2
     </p>
     <p class="cl">
      while(!(SPSR &amp; (1&lt;&lt;SPIF)));   // Wait for SPI transmission to finish
     </p>
     <p class="cl">
      PORTB |= (1 &lt;&lt; PORTB0);       // SS pin HIGH
     </p>
     <p class="cl">
      }
     </p>
     <p class="clf">
      void blankMAX7219()
     </p>
     <p class="cl">
      // Blanks all digits
     </p>
     <p class="cl">
      {
     </p>
     <p class="cl">
      uint8_t i;
     </p>
     <p class="cl">
      for (i=1; i&lt;9; i++)           // Blank all digits
     </p>
     <p class="cl">
      {
     </p>
     <p class="cl">
      writeMAX7219(i,15);
     </p>
     <p class="cl">
      }
     </p>
     <p class="cl">
      }
     </p>
     <p class="clf">
      void initMAX7219()
     </p>
     <p class="cl">
      // Set up MAX7219 for use
     </p>
     <p class="cl">
      {
     </p>
     <p class="cl">
      PORTB |= (1 &lt;&lt; 0);            // SS pin HIGH (SS)
     </p>
     <p class="cl">
      SPCR = 0b01010000;            // Set up SPI bus for MAX7219
     </p>
     <p class="cl">
      // Mode decode for digits (table 4 page 7 - 0x09 + 0xFF
     </p>
     <p class="cl">
      writeMAX7219(0x09,0xFF);
     </p>
     <p class="cl">
      writeMAX7219(0x0B,0x07);      // Set scan limit to 8 digits - 0x09 + 0xFF)
     </p>
     <p class="cl">
      writeMAX7219(0x0A,0x01);      // Set intensity to 8 - 0x0A + 0x08)
     </p>
     <p class="cl">
      // Mode display on (table 4 page 7 - 0x09 + 0xFF)
     </p>
     <p class="cl">
      writeMAX7219(0x0C,0x01);
     </p>
     <p class="cl">
      blankMAX7219();
     </p>
     <p class="cl">
      }
     </p>
     <p class="clf">
      void dispMAX7219(uint8_t digit, uint8_t number, uint8_t dp)
     </p>
     <p class="cl">
      // Displays "number" in location "digit" with decimal point on/off
     </p>
     <p class="cl">
      // Digit: 1~8 for location 1~8
     </p>
     <p class="cl">
      // Number: 0~15 for 0~9, - E, H, L, P, blank
     </p>
     <p class="cl">
      // dp: 1 on, 0 off
     </p>
     <p class="cl">
      {
     </p>
     <p class="cl">
      if (dp==1)                   // Add decimal point
     </p>
     <p class="cl">
      {
     </p>
     <p class="cl">
      number = number + 128;
     </p>
     <p class="cl">
      }
     </p>
     <p class="cl">
      writeMAX7219(digit, number);
     </p>
     <p class="cl">
      }
     </p>
     <p class="clf">
      <span id="p276">
      </span>
      void numberMAX7219(uint32_t value)
     </p>
     <p class="cl">
      // Displays a number between 0–99999999 on MAX7219-controlled 8-digit display
     </p>
     <p class="cl">
      {
     </p>
     <p class="cl">
      uint8_t digits[8];
     </p>
     <p class="cl">
      uint8_t i = 1;
     </p>
     <p class="clf">
      for (i=1; i&lt;9; i++)
     </p>
     <p class="cl">
      {
     </p>
     <p class="cl">
      digits[i]=15;
     </p>
     <p class="cl">
      }
     </p>
     <p class="clf">
      i = 1;
     </p>
     <p class="cl">
      while (value &gt; 0)            // Continue until value &gt; 0
     </p>
     <p class="cl">
      {
     </p>
     <p class="cl">
      // Determine and store last digit of number
     </p>
     <p class="cl">
      digits[i] = value % 10;
     </p>
     <p class="cl">
      value = value / 10;        // Divide value by 10
     </p>
     <p class="cl">
      i++;
     </p>
     <p class="cl">
      }
     </p>
     <p class="cl">
      for (i=1; i&lt;9; i++)
     </p>
     <p class="cl">
      {
     </p>
     <p class="cl">
      dispMAX7219(i, digits[i],0);
     </p>
     <p class="cl">
      }
     </p>
     <p class="cl">
      }
     </p>
     <p class="cl2f">
      <!--<ccust1>2</ccust1>-->
      ❷ uint8_t decimalToBcd(uint8_t val)
     </p>
     <p class="cl">
      // Convert integer to BCD
     </p>
     <p class="cl">
      {
     </p>
     <p class="cl">
      return((val/10*16)+(val%10));
     </p>
     <p class="cl">
      }
     </p>
     <p class="clf">
      uint8_t bcdToDec(uint8_t val)
     </p>
     <p class="cl">
      // Convert BCD to integer
     </p>
     <p class="cl">
      {
     </p>
     <p class="cl">
      return((val/16*10)+(val%16));
     </p>
     <p class="cl">
      }
     </p>
     <p class="cl2f">
      <!--<ccust1>3</ccust1>-->
      ❸ void setTimeDS3231(uint8_t hh, uint8_t mm, uint8_t ss, uint8_t dw,
     </p>
     <p class="cl">
      uint8_t dd, uint8_t mo, uint8_t yy)
     </p>
     <p class="cl">
      // Set the time on DS3231
     </p>
     <p class="cl">
      {
     </p>
     <p class="cl">
      I2CstartWait(0xD0);           // DS3231 write
     </p>
     <p class="cl">
      I2Cwrite(0x00);               // Start with seconds register
     </p>
     <p class="cl">
      I2Cwrite(decimalToBcd(ss));   // Seconds
     </p>
     <p class="cl">
      I2Cwrite(decimalToBcd(mm));   // Minutes
     </p>
     <p class="cl">
      I2Cwrite(decimalToBcd(hh));   // Hours
     </p>
     <p class="cl">
      I2Cwrite(decimalToBcd(dw));   // Day of week
     </p>
     <p class="cl">
      I2Cwrite(decimalToBcd(dd));   // Date
     </p>
     <p class="cl">
      I2Cwrite(decimalToBcd(mo));   // Month
     </p>
     <p class="cl">
      I2Cwrite(decimalToBcd(yy));   // Year
     </p>
     <p class="cl">
      I2Cstop();
     </p>
     <p class="cl">
      }
     </p>
     <p class="cl2f">
      <!--<ccust1>4</ccust1>-->
      ❹ void readTimeDS3231()
     </p>
     <p class="cl">
      // Retrieve time and date from DS3231
     </p>
     <p class="cl">
      <span id="p277">
      </span>
      {
     </p>
     <p class="cl">
      I2CstartWait(0xD0);           // DS3231 write
     </p>
     <p class="cl">
      I2Cwrite(0x00);               // Seconds register
     </p>
     <p class="cl">
      I2CstartWait(0xD1);           // DS3231 read
     </p>
     <p class="cl">
      seconds = bcdToDec(I2CreadACK());
     </p>
     <p class="cl">
      minutes = bcdToDec(I2CreadACK());
     </p>
     <p class="cl">
      hours = bcdToDec(I2CreadACK());
     </p>
     <p class="cl">
      dow = bcdToDec(I2CreadACK());
     </p>
     <p class="cl">
      dom = bcdToDec(I2CreadACK());
     </p>
     <p class="cl">
      mo = bcdToDec(I2CreadACK());
     </p>
     <p class="cl">
      years = bcdToDec(I2CreadACK());
     </p>
     <p class="cl">
      }
     </p>
     <p class="cl2f">
      <!--<ccust1>5</ccust1>-->
      ❺ void displayTimeMAX7219()
     </p>
     <p class="cl">
      // Display time then date on MAX7219 module
     </p>
     <p class="cl">
      {
     </p>
     <p class="cl">
      blankMAX7219();
     </p>
     <p class="cl">
      readTimeDS3231();
     </p>
     <p class="cl">
      // Display seconds
     </p>
     <p class="cl">
      if (seconds == 0)
     </p>
     <p class="cl">
      {  // Display '00'
     </p>
     <p class="cl">
      dispMAX7219(1,0,0);
     </p>
     <p class="cl">
      dispMAX7219(2,0,0);
     </p>
     <p class="cl">
      } else if (seconds &gt;0 &amp;&amp; seconds &lt;10)
     </p>
     <p class="cl">
      {  // Display leading zero
     </p>
     <p class="cl">
      dispMAX7219(1,seconds,0);
     </p>
     <p class="cl">
      dispMAX7219(2,0,0);
     </p>
     <p class="cl">
      } else
     </p>
     <p class="cl">
      {  // Seconds &gt; 10
     </p>
     <p class="cl">
      numberMAX7219(seconds);
     </p>
     <p class="cl">
      }
     </p>
     <p class="cl">
      dispMAX7219(3,10,0);          // Display a dash
     </p>
     <p class="cl">
      // Display minutes
     </p>
     <p class="cl">
      if (minutes == 0)
     </p>
     <p class="cl">
      {  // Display '00'
     </p>
     <p class="cl">
      dispMAX7219(4,0,0);
     </p>
     <p class="cl">
      dispMAX7219(5,0,0);
     </p>
     <p class="cl">
      } else if (minutes &gt;0 &amp;&amp; minutes &lt;10)
     </p>
     <p class="cl">
      {  // Display leading zero
     </p>
     <p class="cl">
      dispMAX7219(4,minutes,0);
     </p>
     <p class="cl">
      dispMAX7219(5,0,0);
     </p>
     <p class="cl">
      } else
     </p>
     <p class="cl">
      {  // Minutes &gt; 10
     </p>
     <p class="cl">
      dispMAX7219(4,(minutes % 10),0);
     </p>
     <p class="cl">
      dispMAX7219(5,(minutes / 10),0);
     </p>
     <p class="cl">
      }
     </p>
     <p class="cl">
      dispMAX7219(6,10,0);          // Display a dash
     </p>
     <p class="cl">
      // Display hours
     </p>
     <p class="cl">
      if (hours == 0)
     </p>
     <p class="cl">
      {  // Display '00'
     </p>
     <p class="cl">
      dispMAX7219(7,0,0);
     </p>
     <p class="cl">
      dispMAX7219(8,0,0);
     </p>
     <p class="cl">
      } else if (hours &gt;0 &amp;&amp; hours &lt;10)
     </p>
     <p class="cl">
      {  // Display leading zero
     </p>
     <p class="cl">
      dispMAX7219(7,hours,0);
     </p>
     <p class="cl">
      <span id="p278">
      </span>
      dispMAX7219(8,0,0);
     </p>
     <p class="cl">
      } else
     </p>
     <p class="cl">
      {  // Hours &gt; 10
     </p>
     <p class="cl">
      dispMAX7219(7,(hours % 10),0);
     </p>
     <p class="cl">
      dispMAX7219(8,(hours / 10),0);
     </p>
     <p class="cl">
      }
     </p>
     <p class="clf">
      _delay_ms(1000);
     </p>
     <p class="clf">
      // Display date
     </p>
     <p class="cl">
      if (dom &gt;0 &amp;&amp; dom &lt;10)
     </p>
     <p class="cl">
      {  // Display leading zero
     </p>
     <p class="cl">
      dispMAX7219(7,dom,0);
     </p>
     <p class="cl">
      dispMAX7219(8,0,0);
     </p>
     <p class="cl">
      } else
     </p>
     <p class="cl">
      {  // Seconds &gt; 10
     </p>
     <p class="cl">
      dispMAX7219(8,(dom / 10), 0);
     </p>
     <p class="cl">
      dispMAX7219(7,(dom % 10), 0);
     </p>
     <p class="cl">
      }
     </p>
     <p class="clf">
      dispMAX7219(6,10,0);                // Display a dash
     </p>
     <p class="clf">
      // Display month
     </p>
     <p class="cl">
      if (mo &gt;0 &amp;&amp; mo &lt;10)
     </p>
     <p class="cl">
      {  // Display leading zero
     </p>
     <p class="cl">
      dispMAX7219(4,mo,0);
     </p>
     <p class="cl">
      dispMAX7219(5,0,0);
     </p>
     <p class="cl">
      } else
     </p>
     <p class="cl">
      {  // Seconds &gt; 10
     </p>
     <p class="cl">
      dispMAX7219(5,(mo / 10), 0);
     </p>
     <p class="cl">
      dispMAX7219(4,(mo % 10), 0);
     </p>
     <p class="cl">
      }
     </p>
     <p class="clf">
      dispMAX7219(3,10,0);                // Display a dash
     </p>
     <p class="clf">
      // Display year
     </p>
     <p class="cl">
      if (years == 0)
     </p>
     <p class="cl">
      {   // Display '00'
     </p>
     <p class="cl">
      dispMAX7219(1,0,0);
     </p>
     <p class="cl">
      dispMAX7219(2,0,0);
     </p>
     <p class="cl">
      } else
     </p>
     <p class="cl">
      if (years &gt;0 &amp;&amp; years &lt;10)
     </p>
     <p class="cl">
      {  // Display leading zero
     </p>
     <p class="cl">
      dispMAX7219(1,years,0);
     </p>
     <p class="cl">
      dispMAX7219(2,0,0);
     </p>
     <p class="cl">
      } else
     </p>
     <p class="cl">
      {  // Years &gt; 10
     </p>
     <p class="cl">
      dispMAX7219(2,(years / 10), 0);
     </p>
     <p class="cl">
      dispMAX7219(1,(years % 10), 0);
     </p>
     <p class="cl">
      }
     </p>
     <p class="cl">
      _delay_ms(1000);
     </p>
     <p class="cl">
      }
     </p>
     <p class="clf">
      int main(void)
     </p>
     <p class="cl">
      {
     </p>
     <p class="cl">
      DDRB = 0b11111111;                  // Set PORTB as outputs
     </p>
     <p class="cl">
      I2Cenable();
     </p>
     <p class="cl">
      initMAX7219();
     </p>
     <p class="cl">
      <span id="p279">
      </span>
      // Uncomment to set time and date, then comment and reflash code
     </p>
     <p class="cl">
      // setTimeDS3231(9,13,0,5,29,4,21); // h,m,s,dow,dom,m,y
     </p>
     <p class="cl">
      while (1)
     </p>
     <p class="cl">
      {
     </p>
     <p class="cl">
      <!--<ccust1>6</ccust1>-->
      ❻ displayTimeMAX7219();
     </p>
     <p class="cl">
      _delay_ms(250);
     </p>
     <p class="cl">
      }
     </p>
     <p class="cll">
      }
     </p>
    </pre>
    <p class="calibre8">
     Once again, this code reuses some functions you’ve seen in previous projects (namely, the functions for the MAX7219 display in
     <a class="url" href="nsp-boxall502581-0021.xhtml#pro46">
      Project 46
     </a>
     from
     <a class="url" href="nsp-boxall502581-0021.xhtml#ch11">
      Chapter 11
     </a>
     and the I
     <sup class="calibre6">
      2
     </sup>
     C bus functions from this chapter’s
     <a class="url" href="nsp-boxall502581-0022.xhtml#pro49">
      Project 49
     </a>
     ).
    </p>
    <p class="calibre8">
     First, we declare the variables to deal with the time and date information
     <!--<ccust1>1</ccust1>-->
     ❶. These variables will hold the data to write to the DS3231 and receive data from the DS3231. As mentioned earlier, the DS3231 works with data in binary-coded decimal format, so the code includes functions to convert integers to and from BCD
     <!--<ccust1>2</ccust1>-->
     ❷.
    </p>
    <p class="calibre8">
     The
     <code class="calibre23">
      setTimeDS3231()
     </code>
     function accepts the time, day of week, and date and sends them to the DS3231
     <!--<ccust1>3</ccust1>-->
     ❸. It first writes to the DS3231 to set the register to address (
     <code class="calibre23">
      0x00
     </code>
     ), then sequentially writes each byte of data in the order described in
     <a class="url" href="nsp-boxall502581-0022.xhtml#tab1203">
      Table 12-3
     </a>
     . Note that each I
     <sup class="calibre6">
      2
     </sup>
     C write function uses the decimal-to-BCD function.
    </p>
    <p class="calibre8">
     The
     <code class="calibre23">
      readTimeDS3231()
     </code>
     function
     <!--<ccust1>4</ccust1>-->
     ❹ retrieves the time and date information. It requests a byte of data from the DS3231 register
     <code class="calibre23">
      0x00
     </code>
     , and as the function uses ACK in the read process, the DS3231 will sequentially send the following bytes of data from the registers. This means we can simply use
     <code class="calibre23">
      I2CreadACK()
     </code>
     seven times to retrieve all the required data. As we’re retrieving data from the DS3231, we use the BCD-to-decimal function within the I
     <sup class="calibre6">
      2
     </sup>
     C read functions.
    </p>
    <p class="calibre8">
     Next comes the
     <code class="calibre23">
      displayTimeMAX7219()
     </code>
     function
     <!--<ccust1>5</ccust1>-->
     ❺, which organizes the time and date data into digits and shows them on the MAX7219 display. It shows the time first, then the date after a short delay. You can remove the date display and just let your clock run continuously, if you prefer.
    </p>
    <p class="calibre8">
     The entire project is wrapped up in the main loop, where we initialize the GPIO, I
     <sup class="calibre6">
      2
     </sup>
     C, and SPI bus, then simply call the display function
     <!--<ccust1>6</ccust1>-->
     ❻ and delay until it is called again. For a challenge, why not write your own I
     <sup class="calibre6">
      2
     </sup>
     C and DS3231 libraries for future reference, or make an alarm clock as well?
    </p>
    <p class="calibre8">
     There’s still plenty more to learn, including new information on how to display data on popular character liquid crystal display modules, which we’ll explore in the
     <a class="url" href="nsp-boxall502581-0023.xhtml#ch13">
      next chapter
     </a>
     .
    </p>
   </div>
  </div>
 </div>
</div></body></html>