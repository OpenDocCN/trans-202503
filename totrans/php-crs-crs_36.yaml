- en: <hgroup>
  id: totrans-0
  prefs: []
  type: TYPE_NORMAL
  zh: <hgroup>
- en: 30 ORM LIBRARIES AND DATABASE SECURITY
  id: totrans-1
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 30 ORM 库与数据库安全
- en: </hgroup>
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: </hgroup>
- en: '![](../images/opener.jpg)'
  id: totrans-3
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/opener.jpg)'
- en: In this chapter, we’ll explore techniques that make working with databases easier
    and more secure. First, much of the CRUD code in repository classes can become
    tedious and repetitive to write, varying only in terms of the names of the model
    classes and their properties. *Object-relational mapping (ORM) libraries* relieve
    this problem, automating lower-level work like preparing and executing SQL queries
    based on the way an application’s model classes are named and structured. You’ll
    see how to use such a library to simplify or replace our repository classes with
    just a few lines of code. We’ll start by adding a simple ORM library to our example
    web application, then later integrate the professional-grade Doctrine ORM library
    with the project.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章中，我们将探索使数据库工作更简单、更安全的技术。首先，仓库类中的许多 CRUD 代码会变得乏味且重复，仅在模型类名称和其属性上有所不同。*对象关系映射（ORM）库*解决了这个问题，自动化了低级工作，比如根据应用程序的模型类的命名和结构准备和执行
    SQL 查询。你将看到如何使用这样的库，通过几行代码简化或替换我们的仓库类。我们将从向我们的示例网页应用程序添加一个简单的 ORM 库开始，然后在项目中整合专业级的
    Doctrine ORM 库。
- en: On the security front, adopting on ORM library will push us to remove any hardcoded
    database credentials from our code, instead placing those credentials in a separate
    data file. We’ll also explore best practices for handling login information in
    a web application, including using *password hashing* to avoid storing plaintext
    passwords in a database. As you’ll see, PHP provides built-in functions that make
    this process straightforward.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在安全方面，采用 ORM 库将推动我们从代码中移除任何硬编码的数据库凭证，而是将这些凭证放在一个单独的数据文件中。我们还将探索在网页应用程序中处理登录信息的最佳实践，包括使用*密码哈希*来避免在数据库中存储明文密码。正如你将看到的，PHP
    提供了内置的函数，使这个过程变得非常简单。
- en: Simplifying Database Code with an ORM Library
  id: totrans-6
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用 ORM 库简化数据库代码
- en: One approach to making web applications communicate with databases is to design
    and write the necessary low-level code from scratch for each project. This includes
    the code to connect to database servers, create schemas and tables, and perform
    the four CRUD operations so that the database tables can store the data to support
    the application. Implementing this code requires careful analysis of the project
    requirements, especially the requirements for which data needs to be persisted
    to a database. The result is code that’s tailored to the application at hand and
    can be written for computational efficiency to maximize speed.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 一种使网页应用程序与数据库进行通信的方法是为每个项目从零开始设计并编写必要的低级代码。这包括连接数据库服务器的代码、创建模式和表格的代码，以及执行四个
    CRUD 操作的代码，以便数据库表格能够存储支持应用程序的数据。实现这些代码需要对项目需求进行仔细分析，尤其是哪些数据需要持久化到数据库中。最终的结果是，代码是针对当前应用程序量身定制的，可以根据计算效率来编写，以最大化速度。
- en: We’ve followed this approach of designing and writing custom, application-specific
    database code in the last few chapters. It’s been helpful for learning about how
    to work with a database, but it also comes with disadvantages. First, it takes
    time to design, write, and test code for every new application. Second, if the
    application requirements change, both the web application’s database communication
    code and the database structure itself need to be changed accordingly. Finally,
    any new developers joining a software team for an ongoing project will have to
    learn all the details of the system’s design to communicate with the database.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在过去的几章中，我们采用了设计和编写定制的、特定应用程序的数据库代码的方法。这对学习如何与数据库交互很有帮助，但也带来了一些缺点。首先，每个新应用程序都需要花时间设计、编写和测试代码。其次，如果应用程序的需求发生变化，网页应用程序的数据库通信代码和数据库结构本身也需要相应地做出调整。最后，任何加入正在进行项目的开发者都必须学习系统设计的所有细节，以便能够与数据库进行交互。
- en: An alternative approach is to use an ORM library to abstract away the lower-level
    work of communication with the database. ORM libraries use the structure and associations
    of an application’s model classes (often with a little additional metadata) to
    automatically create and update the structure of the corresponding database tables.
    If changes in the application requirements lead to changes in the model classes
    (perhaps new model classes are added, or existing classes are given new properties
    or associations), then the ORM library can automatically update the database table
    structures accordingly and manage updated database queries based on the new model
    class declarations.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种方法是使用 ORM 库来抽象化与数据库通信的底层工作。ORM 库使用应用程序模型类的结构和关联（通常还会有一些附加的元数据）来自动创建和更新相应数据库表的结构。如果应用程序需求的变化导致模型类发生变化（例如新增模型类，或者现有类添加了新属性或关联），那么
    ORM 库可以根据新的模型类声明自动更新数据库表结构，并管理基于这些更新后的模型类的数据库查询。
- en: ORM libraries can be less computationally efficient than custom-written low-level
    database communication code. If speed isn’t the most important feature for a web
    application, however, they have several strengths. For one, the database structure
    and queries are updated as soon as the model classes are updated, which streamlines
    the coding process. Also, if the project uses a well-known, industrial-standard
    ORM library, new developers joining a project will likely already be familiar
    with the abstracted ways to use the ORM library to handle database operations.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 与自定义编写的低级数据库通信代码相比，ORM 库的计算效率可能较低。然而，如果速度不是 Web 应用程序中最重要的特性，它们有几个优点。首先，数据库结构和查询会在模型类更新的同时自动更新，这简化了编码过程。此外，如果项目使用的是一个知名的工业标准
    ORM 库，那么加入项目的新开发人员很可能已经熟悉使用 ORM 库处理数据库操作的抽象方式。
- en: Before we get into the details of how to use an ORM library, let’s consider
    an example that illustrates this approach’s benefits, compared to using custom
    code. [Listing 30-1](#lis30-1) shows an excerpt of the ProductRepository class
    developed in the previous two chapters.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们深入了解如何使用 ORM 库之前，让我们先看一个例子，说明这种方法与使用自定义代码相比的优势。[清单 30-1](#lis30-1)展示了前两章开发的
    ProductRepository 类的部分内容。
- en: '[PRE0]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Listing 30-1: Some of the contents of the ProductRepository class'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 30-1：ProductRepository 类的部分内容
- en: We developed this class manually, meaning we had to implement lower-level methods
    such as a constructor to retrieve a database connection and CRUD methods such
    as findAll() and find() to prepare and execute SQL queries. Compare this code
    with [Listing 30-2](#lis30-2), which declares an equivalent ProductRepository
    class with the help of an ORM library.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 我们手动开发了这个类，这意味着我们必须实现一些底层方法，比如构造函数来获取数据库连接，以及 CRUD 方法，如 findAll() 和 find()，以准备和执行
    SQL 查询。将这段代码与[清单 30-2](#lis30-2)进行对比，后者通过 ORM 库的帮助声明了一个等效的 ProductRepository 类。
- en: '[PRE1]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Listing 30-2: A ProductRepository class inheriting from an ORM library'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 30-2：一个继承自 ORM 库的 ProductRepository 类
- en: For straightforward database interactions, an ORM library can do almost all
    the work for us. Instead of implementing custom methods in the repository class,
    we simply inherit those methods from an ORM library superclass (in this case,
    DatabaseTableRepository). The superclass is designed to use *reflection*, a technique
    of inspecting the classes and objects it interacts with, such as the Product model
    class. Then the superclass uses what it finds to generate SQL queries suitable
    for objects of those classes.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 对于直接的数据库交互，ORM 库几乎可以为我们完成所有工作。我们不需要在 repository 类中实现自定义方法，而是简单地从 ORM 库的超类（在这种情况下是
    DatabaseTableRepository）继承这些方法。超类设计使用*反射*，这是一种检查它与之交互的类和对象的技术，比如 Product 模型类。然后，超类利用找到的信息生成适用于这些类对象的
    SQL 查询。
- en: In the coming sections, we’ll explore how this works in more detail by using
    a simple ORM library, one that I maintain as an open source project on GitHub.
    Later we’ll also try out an industrial-strength ORM library called Doctrine, one
    of the most popular ORM libraries available for modern PHP. For now, though, take
    a moment to appreciate how much shorter the ORM-assisted ProductRepository class
    declaration is than the manually coded version.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的章节中，我们将通过使用一个简单的 ORM 库来更详细地探讨这一过程，这是我在 GitHub 上作为开源项目维护的一个库。稍后，我们还将尝试一个工业级的
    ORM 库，名为 Doctrine，这是现代 PHP 中最流行的 ORM 库之一。不过现在，先花点时间欣赏一下 ORM 辅助的 ProductRepository
    类声明比手动编写版本要简短得多。
- en: Adding an ORM Library to a Project
  id: totrans-19
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 将ORM库添加到项目中
- en: 'Let’s extend our database-driven web application from the previous chapters
    to work with a simple ORM library called pdo-crud-for-free-repositories that I
    maintain (*[https://github.com/dr-matt-smith/pdo-crud-for-free-repositories](https://github.com/dr-matt-smith/pdo-crud-for-free-repositories)*).
    It has limited features but is straightforward to use, making it a good tool for
    introducing the basics of ORM libraries. To get started, enter the following at
    the command line to add the library to the project:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们扩展前几章中的数据库驱动Web应用程序，使用我维护的一个简单ORM库——pdo-crud-for-free-repositories（* [https://github.com/dr-matt-smith/pdo-crud-for-free-repositories](https://github.com/dr-matt-smith/pdo-crud-for-free-repositories)
    *）。该库功能有限，但易于使用，是介绍ORM库基础知识的好工具。要开始使用，在命令行中输入以下内容以将库添加到项目中：
- en: '[PRE2]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This will add a *mattsmithdev* folder inside *vendor* containing the library
    code.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 这将会在*vendor*文件夹中添加一个*mattsmithdev*文件夹，里面包含库的代码。
- en: At the time of this writing, the released version of the pdo-crud-for-free -repositories
    is compatible only with MySQL, so we’ll focus on the MySQL version of our web
    application rather than the SQLite version.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在撰写本文时，发布的pdo-crud-for-free-repositories版本仅与MySQL兼容，因此我们将重点介绍我们的Web应用程序的MySQL版本，而非SQLite版本。
- en: Moving Database Credentials to a .env File
  id: totrans-24
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 将数据库凭据移至.env文件
- en: The ORM library we’re using requires all our database credentials to be declared
    in a file named *.env*, commonly known as a *dotenv file*, rather than hardcoded
    in the Database class where we currently have them. Dotenv files are human-readable
    text files defining name/value pairs necessary for a program to run; other common
    file types for such variables include XML and YAML. This requirement is not a
    bad thing, since it also makes the application more secure.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用的ORM库要求所有数据库凭据都声明在名为*.env*的文件中，该文件通常被称为*dotenv文件*，而不是硬编码在我们目前的Database类中。Dotenv文件是人类可读的文本文件，用于定义程序运行所需的名称/值对；其他常见的文件类型包括XML和YAML。这一要求并不是坏事，因为它还增强了应用程序的安全性。
- en: Typically, we’d exclude dotenv files when using version-control systems such
    as Git so that when code is archived or pushed to open source projects, sensitive
    database credentials won’t be included. This reduces the chance of a security
    breach from code being published or distributed to unauthorized people. Another
    advantage of this approach is that different environments can be set up in multiple
    dotenv files, such as for local development, remote development, testing, and
    live production systems.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，在使用版本控制系统（如Git）时，我们会排除dotenv文件，以便在代码归档或推送到开源项目时，不会包含敏感的数据库凭据。这减少了通过代码发布或分发给未经授权的人所引发的安全漏洞的可能性。这种方法的另一个好处是，可以在多个dotenv文件中设置不同的环境，如本地开发、远程开发、测试和实际生产系统。
- en: To satisfy this ORM library requirement, create a file called *.env* and save
    it in the main project directory. Enter the contents of [Listing 30-3](#lis30-3)
    into the file, changing values such as the password and port to match the MySQL
    server properties running on your computer.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 为了满足该ORM库的要求，创建一个名为*.env*的文件，并将其保存在主项目目录中。将[列表30-3](#lis30-3)中的内容输入文件中，并根据您计算机上运行的MySQL服务器属性修改密码和端口等值。
- en: '[PRE3]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Listing 30-3: The database credentials in the .env file'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 列表30-3：.env文件中的数据库凭据
- en: These MySQL attributes were all previously defined as constants in our Database
    class. We can now delete the Database class from our project, since the ORM library
    comes with its own class for managing the connection with the database, based
    on the information in the dotenv file.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 这些MySQL属性之前都作为常量定义在我们的Database类中。现在，我们可以将Database类从项目中删除，因为ORM库自带了一个类来管理与数据库的连接，基于dotenv文件中的信息。
- en: Relegating Product Operations to the ORM Library
  id: totrans-31
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 将产品操作委托给ORM库
- en: Now that the ORM library has access to the database, we can shift responsibility
    for all CRUD operations relating to the product table from our ProductRepository
    class to the ORM library. We’ll still use the ProductRepository class, but as
    hinted earlier, instead of manually filling it with methods that prepare and execute
    SQL statements, we’ll simply declare it to be a subclass of one of the ORM library
    classes. Replace the contents of *src/ProductRepository.php* with the code shown
    in [Listing 30-4](#lis30-4).
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 既然 ORM 库已经可以访问数据库，我们就可以将所有与产品表相关的 CRUD 操作的责任，从 ProductRepository 类转移到 ORM 库中。我们仍然会使用
    ProductRepository 类，但正如之前所暗示的那样，我们不再手动填充它的方法来准备和执行 SQL 语句，而是简单地将它声明为 ORM 库类的一个子类。用
    [Listing 30-4](#lis30-4) 中显示的代码替换 *src/ProductRepository.php* 文件的内容。
- en: '[PRE4]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Listing 30-4: The much-simplified ProductRepository class'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 'Listing 30-4: 极大简化的 ProductRepository 类'
- en: 'The use statement specifies that we want to refer to the DatabaseTableRepository
    class in the Mattsmithdev\PdoCrudRepo namespace. Then we declare ProductRepository
    as a subclass of DatabaseTableRepository, with no code whatsoever in the class
    body. And that’s it! We now have a working ProductRepository class with just those
    few lines of code. It will inherit all the methods declared in the DatabaseTableRepository
    superclass that happen to follow the same naming convention we used previously:
    find(), findAll(), delete(), deleteAll(), and so on.'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 使用语句指定我们想要引用 Mattsmithdev\PdoCrudRepo 命名空间中的 DatabaseTableRepository 类。然后我们将
    ProductRepository 声明为 DatabaseTableRepository 的子类，类体中不包含任何代码。就这样！我们现在拥有了一个只包含几行代码的有效
    ProductRepository 类。它将继承 DatabaseTableRepository 超类中所有的方法，这些方法恰好遵循我们之前使用的命名约定：find()、findAll()、delete()、deleteAll()
    等。
- en: But how does the DatabaseTableRepository class know that we want it to work
    with a product table with id, description, and price fields? This is where reflection
    comes into play. The DatabaseTableRepository class uses this technique to infer
    the details about how to construct appropriate SQL statements based on the classes
    and objects it comes into contact with. In this case, the reflection code assumes
    that the ProductRepository repository class manages database methods for a model
    class in the same namespace called Product, and that a corresponding product table
    in the database has fields matching the property names of the Product class. As
    long as all the names align, the ORM library will be able to do its job.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，DatabaseTableRepository 类是如何知道我们希望它与一个具有 id、description 和 price 字段的产品表配合使用的呢？这就是反射技术发挥作用的地方。DatabaseTableRepository
    类使用这种技术来推断如何根据它接触到的类和对象构建适当的 SQL 语句。在这种情况下，反射代码假设 ProductRepository 仓库类管理一个与同一命名空间中的名为
    Product 的模型类相对应的数据库方法，并且数据库中相应的产品表具有与 Product 类的属性名称匹配的字段。只要所有的名称一致，ORM 库就能完成它的工作。
- en: For the reflection process to work, the DatabaseTableRepository methods need
    to receive objects of the appropriate model class, rather than free- floating
    variables as we’d previously designed the CRUD methods in [Chapter 29](chapter29.xhtml).
    To finalize the shift to the ORM library, we therefore need to refactor our ProductController
    class to pass in Product objects when calling the insert() and update() methods
    to process new and updated products. Change the *src/ProductController.php* file
    as shown in [Listing 30-5](#lis30-5).
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让反射过程正常工作，DatabaseTableRepository 方法需要接收适当模型类的对象，而不是我们之前在 [第29章](chapter29.xhtml)
    设计 CRUD 方法时使用的自由浮动变量。为了最终完成对 ORM 库的转换，我们需要重构我们的 ProductController 类，在调用 insert()
    和 update() 方法处理新产品和更新产品时，传入 Product 对象。按照 [Listing 30-5](#lis30-5) 中的方式修改 *src/ProductController.php*
    文件。
- en: '[PRE5]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Listing 30-5: The updated src/ProductController.php class'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 'Listing 30-5: 更新后的 src/ProductController.php 类'
- en: In the revised processCreate() method, we first create a new Product object
    and set its description and price properties to the values passed into the method.
    We then pass this Product object to the ProductRepository object’s insert() method
    to add the new product to the database ❶. The ORM library assumes that every database
    table has an auto-incrementing primary key named id, so no value for the product
    ID is needed when creating a new row in the database. We make a similar change
    to the processEdit() method, using the id to get a reference to the Product object
    to be updated ❷, setting the other properties received from the form, and passing
    the object reference to the repository class’s update() method.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在修改后的processCreate()方法中，我们首先创建一个新的Product对象，并将其描述和价格属性设置为传入方法的值。然后，我们将这个Product对象传递给ProductRepository对象的insert()方法，以将新产品添加到数据库中❶。ORM库假设每个数据库表都有一个名为id的自增主键，因此在创建新数据库行时，不需要为产品ID提供值。我们对processEdit()方法做了类似的修改，使用id来获取要更新的Product对象的引用❷，设置从表单接收到的其他属性，并将对象引用传递给仓库类的update()方法。
- en: Run the web server and you should now see the web application is working just
    as before, but with significantly less code! In this way, working with an ORM
    library greatly simplified the task of executing standard database CRUD operations.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 运行Web服务器，你现在应该能看到Web应用程序与之前一样工作，但代码大大减少！通过这种方式，使用ORM库大大简化了执行标准数据库CRUD操作的任务。
- en: NOTE
  id: totrans-42
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 注意
- en: '*Before moving on, make a copy of your project at this point. In “The Doctrine
    ORM Library” on [page 615](#pg_615), we’ll modify that copy to use Doctrine.*'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '*在继续之前，先在此时备份你的项目。在《Doctrine ORM库》一节中（见[第615页](#pg_615)），我们将修改该副本以使用Doctrine。*'
- en: Adding a New Database Table
  id: totrans-44
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 添加新数据库表
- en: Now that we’ve incorporated the ORM library into the project, let’s expand our
    web application by adding another table to the database. With the library handling
    all the CRUD operations, the process will be much more efficient than our effort
    in [Chapter 29](chapter29.xhtml) to get CRUD working for the product table. When
    we look at security in “Security Best Practices” on [page 608](#pg_608), we’ll
    discuss best practices for handling passwords, so we’ll go ahead and add a user
    table storing username and password information.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经将ORM库集成到项目中，让我们通过向数据库添加另一个表来扩展我们的Web应用程序。由于库处理所有CRUD操作，整个过程将比我们在[第29章](chapter29.xhtml)中为产品表实现CRUD时更高效。当我们在《安全最佳实践》一节（见[第608页](#pg_608)）中讨论安全时，我们将讨论处理密码的最佳实践，因此我们将继续添加一个存储用户名和密码信息的用户表。
- en: Along with the new database table, we’ll need a User model class, a UserRepository
    repository class (so named to match the ORM library’s requirements), a UserController
    controller class, and a page for displaying all the users. [Figure 30-1](#fig30-1)
    shows that page. Of course, this page exists just to illustrate that the database
    methods are working; displaying a list of usernames and passwords is *not* an
    example of secure web development.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 除了新的数据库表外，我们还需要一个User模型类，一个UserRepository仓库类（命名符合ORM库的要求），一个UserController控制器类，以及一个用于显示所有用户的页面。[图30-1](#fig30-1)展示了该页面。当然，这个页面仅用于演示数据库方法是否正常工作；显示用户名和密码列表*并不是*安全Web开发的示例。
- en: '![](../images/figure30-1.jpg)'
  id: totrans-47
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/figure30-1.jpg)'
- en: 'Figure 30-1: The User List page'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 图30-1：用户列表页面
- en: We’ll start by declaring the User model class. Add a *src/User.php* file containing
    the code in [Listing 30-6](#lis30-6) to the project.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从声明User模型类开始。将[列表30-6](#lis30-6)中的代码添加到*src/User.php*文件，并将其添加到项目中。
- en: '[PRE6]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Listing 30-6: The User class'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 列表30-6：User类
- en: The class has an integer id property (a requirement for the ORM library) and
    string properties for username and password. We declare standard getter and setter
    methods for each of these properties.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 该类具有一个整数id属性（这是ORM库的要求），以及用于存储用户名和密码的字符串属性。我们为这些属性声明了标准的getter和setter方法。
- en: Now we’ll create the UserRepository class in *src/UserRepository.php*. As with
    ProductRepository, we’ll have this class extend the ORM library’s DatabaseTableRepository
    class. [Listing 30-7](#lis30-7) shows the code.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将在*src/UserRepository.php*中创建UserRepository类。与ProductRepository一样，我们将让这个类继承ORM库的DatabaseTableRepository类。[列表30-7](#lis30-7)展示了代码。
- en: '[PRE7]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Listing 30-7: The simple UserRepository class'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 列表30-7：简单的UserRepository类
- en: We don’t need to declare any methods for this repository class, since it will
    inherit all the necessary CRUD methods from the DatabaseTableRepository class.
    Thanks to the naming of the UserRepository and User classes, these CRUD methods
    will know to work with the user table in the database.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不需要为这个仓库类声明任何方法，因为它将继承自DatabaseTableRepository类的所有必要的CRUD方法。由于UserRepository和User类的命名，这些CRUD方法将知道与数据库中的用户表进行交互。
- en: Next, let’s create a UserController class, with a method to retrieve all users
    from the database and display them with a Twig template. Create *src/UserController.php*
    containing the code in [Listing 30-8](#lis30-8).
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们创建一个UserController类，其中包含一个从数据库中检索所有用户并使用Twig模板显示它们的方法。创建*src/UserController.php*并包含[清单30-8](#lis30-8)中的代码。
- en: '[PRE8]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Listing 30-8: The UserController class declaring a list() method'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 清单30-8：UserController类声明list()方法
- en: We declare UserController as a subclass of Controller so that it will inherit
    a twig property for rendering templates. We declare a private userRepository property
    and initialize it in the constructor (where we also must first invoke the parent
    Controller class’s constructor to set up the twig property). We then declare a
    list() method, which uses the UserRepository object’s findAll() method (inherited
    from the ORM library) to retrieve all users from the database ❶. The results are
    returned as an array of objects, which we store as $users. We pass this array
    as the Twig variable users for rendering by the *templates/user/list.xhtml.twig*
    template.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将UserController声明为Controller的子类，以便它继承一个用于渲染模板的twig属性。我们声明一个私有的userRepository属性，并在构造函数中初始化它（同时必须先调用父类Controller的构造函数以设置twig属性）。接着，我们声明一个list()方法，它使用UserRepository对象的findAll()方法（继承自ORM库）从数据库中检索所有用户❶。结果作为对象数组返回，我们将其存储为$users。然后，我们将这个数组作为Twig变量users传递给*templates/user/list.xhtml.twig*模板进行渲染。
- en: Now we’ll add a navigation bar link for the User List page to the base Twig
    template that all other templates inherit from. Update *templates/base.xhtml.twig*
    to match the contents of [Listing 30-9](#lis30-9).
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将在所有其他模板继承的基本Twig模板中添加一个指向用户列表页面的导航栏链接。更新*templates/base.xhtml.twig*以匹配[清单30-9](#lis30-9)的内容。
- en: '[PRE9]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Listing 30-9: Adding a user list link to /templates/base.xhtml.twig'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 清单30-9：将用户列表链接添加到/templates/base.xhtml.twig
- en: Here we add a navigation list item with the text User List page. The anchor
    element has an action of users, and its CSS class attribute declares an empty
    Twig block called userLink. As with the other navigation bar items, this block
    can be overridden with the text active to highlight the link.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们添加了一个导航列表项，文本为用户列表页面。该锚元素的action为users，CSS类属性声明了一个名为userLink的空Twig块。与其他导航栏项一样，这个块可以被重写为文本active，以突出显示该链接。
- en: With the base template updated, we can now create the *templates/user/list.xhtml.twig*
    child template for the User List page. [Listing 30-10](#lis30-10) shows how.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 更新了基本模板后，我们现在可以为用户列表页面创建*templates/user/list.xhtml.twig*子模板。[清单30-10](#lis30-10)展示了如何操作。
- en: '[PRE10]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Listing 30-10: The list.xhtml.twig template'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 清单30-10：list.xhtml.twig模板
- en: In this template, we override the userLink block to contain the text active
    ❶, highlighting the User List page link in the navigation bar. In the body block,
    we use a Twig for loop ❷ to iterate through the users array, creating a list item
    for each user displaying the associated ID, username, and password.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个模板中，我们重写了userLink块，使其包含文本active ❶，在导航栏中突出显示用户列表页面链接。在body块中，我们使用Twig的for循环❷遍历用户数组，为每个用户创建一个列表项，显示关联的ID、用户名和密码。
- en: Now we need to add a case for the action=users route to our front-controller
    Application class. Update *src/Application.php* to match the contents of [Listing
    30-11](#lis30-11).
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要为action=users路由在我们的前端控制器应用程序类中添加一个案例。更新*src/Application.php*以匹配[清单30-11](#lis30-11)的内容。
- en: '[PRE11]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Listing 30-11: Adding a route to the user list in the Application class'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 清单30-11：在Application类中添加用户列表的路由
- en: We declare a userController property and initialize it as a new UserController
    object in the constructor. Then, in the switch statement, we declare a case for
    when the action is 'users', invoking the list() method of the UserController object.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 我们声明一个userController属性，并在构造函数中将其初始化为一个新的UserController对象。然后，在switch语句中，我们声明一个当action为'users'时的case，调用UserController对象的list()方法。
- en: All we need to do now is add the user table to the database schema and insert
    user rows into the table. Create a new helper script, *db/setup_users.php*, as
    shown in [Listing 30-12](#lis30-12).
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们只需要将用户表添加到数据库模式中，并向表中插入用户行。创建一个新的辅助脚本，*db/setup_users.php*，如[清单30-12](#lis30-12)所示。
- en: '[PRE12]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Listing 30-12: The setup script for the user table in /db/setup_users.php'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 清单30-12：/db/setup_users.php中用户表的设置脚本
- en: When we first set up the product table in [Chapter 28](chapter28.xhtml), we
    had to manually type out and execute each SQL statement to add a new row to the
    database. Now we can instead build each row as an instance of the User class and
    add it to the table by calling the insert() method of the UserRepository class
    (inherited from the ORM library). In this script, we do that for two users, assigning
    them usernames and passwords.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们第一次设置[第28章](chapter28.xhtml)中的产品表时，我们需要手动输入并执行每个SQL语句，以便向数据库中添加一行新数据。现在，我们可以通过将每一行构建为User类的实例，并通过调用UserRepository类的insert()方法（该方法继承自ORM库）来将其添加到表中。在这个脚本中，我们为两个用户做了这个操作，分配了他们的用户名和密码。
- en: First, though, we invoke the UserRepository class’s resetTable() method ❶, which
    drops any existing table mapped to the User class and creates a new table based
    on the names and data types of the User class. This is another “free” method automatically
    available to our repository class through inheritance from the ORM library’s DatabaseTableRepository
    class. To confirm the database table has been created and two User records have
    been inserted, the script ends by retrieving all users from the database with
    the findAll() method and printing them with var_dump().
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们调用UserRepository类的resetTable()方法❶，该方法会删除任何已映射到User类的现有表，并根据User类的名称和数据类型创建一个新表。通过继承自ORM库的DatabaseTableRepository类，这又是一个“免费”的方法，自动可用于我们的存储库类。为了确认数据库表已被创建并且两个User记录已被插入，脚本最后通过findAll()方法从数据库中检索所有用户并使用var_dump()打印它们。
- en: 'Enter php db/setup_users.php at the terminal to run this setup script. You
    should see the following output:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 在终端输入php db/setup_users.php来运行这个设置脚本。你应该会看到以下输出：
- en: '[PRE13]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The terminal output shows an array containing two User objects, proof that the
    user database table has been added to the database schema, complete with two users.
    At this point, you can also launch the web application again and visit the User
    List page. It should look like [Figure 30-1](#fig30-1).
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 终端输出显示了一个包含两个User对象的数组，证明用户数据库表已被添加到数据库模式中，并且已插入了两个用户。此时，你也可以重新启动Web应用程序并访问用户列表页面。它应该看起来像[图30-1](#fig30-1)。
- en: By working with my pdo-crud-for-free-repositories library, we’ve seen how using
    an ORM library can remove the need to code low-level database queries. This reduces
    the amount of code required for each individual web application, simplifying the
    development process. We’ll continue to use this library as we turn our attention
    to application security, but later we’ll return to the topic of ORM libraries
    to see the added benefits of working with a more sophisticated library like Doctrine.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用我的pdo-crud-for-free-repositories库，我们已经看到如何使用ORM库来避免编写底层数据库查询。这减少了每个Web应用程序所需的代码量，从而简化了开发过程。我们将继续使用这个库，转而关注应用程序安全性，但稍后我们会回到ORM库的话题，看看使用像Doctrine这样更复杂的库能带来的额外好处。
- en: Security Best Practices
  id: totrans-82
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 安全最佳实践
- en: Security is an essential part of software development, both in your local development
    environment and when deploying web applications to the real world as public websites.
    Perhaps the most common manifestation of security a user meets these days is a
    username/password login form. We’ll explore best practices for securing login
    information in this section.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 安全性是软件开发中的一个关键部分，无论是在本地开发环境中，还是在将Web应用程序部署到实际的公共网站时。如今，用户最常遇到的安全性体现之一便是用户名/密码登录表单。我们将在本节中探讨保护登录信息的最佳实践。
- en: Storing Hashed Passwords
  id: totrans-84
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 存储哈希密码
- en: You should never store plaintext passwords in your application’s database. Otherwise,
    if someone gets access to the database, all those accounts would be compromised.
    One option for securely storing data is to *encrypt* it, encoding data in such
    a way that it can be decoded back to its original form at a later time. When sending
    confidential messages, for example, it’s common to encrypt them first and to provide
    the intended recipient with the method for decrypting the message once received.
    For passwords, however, encryption isn’t the best solution; if the database were
    accessed, brute-force techniques could allow attackers to eventually decrypt the
    data (although depending on the speed of their computers, it might take a long
    time).
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 你绝不应该在应用程序的数据库中存储明文密码。否则，如果有人获得了数据库的访问权限，所有这些账户都会受到威胁。安全存储数据的一个选择是 *加密*，即以某种方式对数据进行编码，以便在以后能够解码回原始形式。例如，在发送机密消息时，通常会先对其加密，并在接收方收到消息后提供解密方法。然而，对于密码来说，加密并不是最好的解决方案；如果数据库被访问，暴力破解技术可能会允许攻击者最终解密数据（尽管根据他们计算机的速度，可能需要很长时间）。
- en: A better technique for password storage is *hashing*. This is an irreversible
    way of creating a new piece of data from the original data; there’s no way to
    reconstruct the plaintext password from the hashed version. The same password
    passed through the same hash algorithm will always yield the same hash, however.
    When a user is logging into an application, you can therefore test whether their
    password is valid by hashing what they’ve entered and comparing it with the hash
    stored in the database. With this mechanism, there’s no need to ever store the
    original plaintext password.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 一种更好的密码存储技术是 *哈希处理*。这是一种不可逆的方式，通过原始数据生成新的数据；无法从哈希版本恢复出明文密码。然而，相同的密码通过相同的哈希算法处理时将始终生成相同的哈希值。因此，当用户登录应用程序时，你可以通过哈希他们输入的密码并与数据库中存储的哈希值进行比较，从而验证密码是否有效。使用这种机制，永远不需要存储原始的明文密码。
- en: Let’s make our web application more secure by storing hashes rather than plaintext
    passwords in the user database table. Conveniently, modern PHP offers a built-in
    password_hash() function for calculating the hash of a string. We’ll change the
    setPassword() method of the User entity class to take advantage of this function.
    Update *src/User.php* to match the contents of [Listing 30-13](#lis30-13).
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过在用户数据库表中存储哈希值而不是明文密码来提高我们Web应用的安全性。方便的是，现代 PHP 提供了一个内置的 `password_hash()`
    函数，用于计算字符串的哈希值。我们将修改用户实体类的 `setPassword()` 方法，利用这个函数。请更新 *src/User.php* 文件，使其内容与
    [Listing 30-13](#lis30-13) 匹配。
- en: '[PRE14]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Listing 30-13: Storing a hashed password in the User class'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 'Listing 30-13: 在用户类中存储哈希密码'
- en: The revised setPassword() method takes in the plaintext password for a new user
    and passes it to the password_hash() function for hashing. The PASSWORD_DEFAULT
    constant means the function will use the strongest hashing algorithm available
    in the installed version of PHP, though there are other constants for explicitly
    choosing a particular hashing algorithm. We store the hash in the $hashedPassword
    variable and assign this as the value of the User object’s password property.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 修改后的 `setPassword()` 方法接受新用户的明文密码，并将其传递给 `password_hash()` 函数进行哈希处理。`PASSWORD_DEFAULT`
    常量意味着该函数将使用安装的 PHP 版本中最强的哈希算法，尽管也有其他常量可以明确选择某种特定的哈希算法。我们将哈希值存储在 `$hashedPassword`
    变量中，并将其作为用户对象的密码属性的值。
- en: 'With this change, any new User objects created and passed to the database will
    contain hashed rather than plaintext passwords. To prove it, rerun our user table
    setup script by entering php db/setup_users.php at the command line. This will
    delete and re-create the table with the modified User class. Here’s the resulting
    var_dump() output in the terminal:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这个更改，任何新创建并传递到数据库的用户对象将包含哈希密码，而不是明文密码。为了验证这一点，在命令行输入 `php db/setup_users.php`
    重新运行用户表设置脚本。这将删除并重新创建包含修改后用户类的表。以下是在终端中显示的 `var_dump()` 输出：
- en: '[PRE15]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The black text lines show the hashes in each password field. Each hash is a
    long character string that has no discernible relationship with the original password.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 黑色文本行显示每个密码字段中的哈希值。每个哈希值都是一个长字符字符串，与原始密码没有明显的关系。
- en: Verifying Hashed Passwords at Login
  id: totrans-94
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 登录时验证哈希密码
- en: Another useful built-in PHP function is password_verify(), which takes in a
    plaintext password, hashes it, and compares it with an existing hash to determine
    whether the password is correct. With this function, we can implement a login
    page for our application, where the user inputs a username and password for verification
    against their record in the user database table. [Figure 30-2](#fig30-2) shows
    the login page we’ll create.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个有用的内建 PHP 函数是 password_verify()，它接受一个明文密码，将其哈希化，并与现有的哈希值进行比较，以确定密码是否正确。使用这个函数，我们可以为应用程序实现一个登录页面，用户在其中输入用户名和密码，系统会根据用户数据库表中的记录进行验证。[图
    30-2](#fig30-2)展示了我们将要创建的登录页面。
- en: '![](../images/figure30-2.jpg)'
  id: totrans-96
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/figure30-2.jpg)'
- en: 'Figure 30-2: The new login page'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 图 30-2：新的登录页面
- en: Our application will need two new routes, one to request display of the login
    page (action=login) and one to request processing of the submitted data from the
    login form (action=processLogin). First, we’ll add cases for these routes to our
    front-controller Application class. Update the switch statement in *src/Application.php*
    to match [Listing 30-14](#lis30-14).
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的应用程序需要两个新路由，一个用于请求显示登录页面（action=login），另一个用于请求处理从登录表单提交的数据（action=processLogin）。首先，我们将为这些路由添加对应的情况到我们的前端控制器
    Application 类中。更新 *src/Application.php* 中的 switch 语句以匹配 [列表 30-14](#lis30-14)。
- en: '[PRE16]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Listing 30-14: Adding login routes to the Application class'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 30-14：向应用程序类添加登录路由
- en: For the 'login' case, we invoke the loginForm() method of the UserController
    object ❶. For the 'processLogin' case, we first attempt to extract the 'username'
    and 'password' values from the variables received in the POST request. If either
    is empty ❷, an appropriate error message is displayed by passing a string message
    to the error() method of the DefaultController object. Otherwise, the username
    and password are passed to the processLogin() method of the UserController object
    ❸.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 'login' 情况，我们调用 UserController 对象的 loginForm() 方法 ❶。对于 'processLogin' 情况，我们首先尝试从
    POST 请求中提取 'username' 和 'password' 的值。如果其中任何一个为空 ❷，则通过将字符串消息传递给 DefaultController
    对象的 error() 方法，显示相应的错误信息。否则，用户名和密码会传递给 UserController 对象的 processLogin() 方法 ❸。
- en: Now we need to add the new methods to the UserController class. Update *src/UserController.php*
    as shown in [Listing 30-15](#lis30-15).
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们需要向 UserController 类添加新方法。更新 *src/UserController.php*，如 [列表 30-15](#lis30-15)
    所示。
- en: '[PRE17]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Listing 30-15: Adding login methods to the UserController class'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 30-15：向 UserController 类添加登录方法
- en: For the loginForm() method, we simply render the appropriate Twig template,
    which doesn’t require any arguments. For the processLogin() method, we take in
    the received $username and $password variables and pass them to the isValidUsernamePassword()
    helper method ❶, which returns a Boolean. If true, we print a success message,
    or an error message if false. In a full web application, at this stage, we would
    store the login success in the session as we did in [Chapter 16](chapter16.xhtml).
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 loginForm() 方法，我们仅渲染相应的 Twig 模板，该模板不需要任何参数。对于 processLogin() 方法，我们接收 $username
    和 $password 变量，并将它们传递给 isValidUsernamePassword() 辅助方法 ❶，该方法返回一个布尔值。如果返回 true，我们显示成功消息；如果返回
    false，则显示错误消息。在完整的 Web 应用中，在此阶段，我们会像在 [第 16 章](chapter16.xhtml) 中那样将登录成功信息存储到会话中。
- en: The isValidUsernamePassword() helper is responsible for determining whether
    the database holds a record matching the received username and password. First,
    we call the UserRepository class method findOneByUsername(), which attempts to
    retrieve a record (in the form of a User object) from the user table matching
    the provided username ❷. If a single user can’t be retrieved, findOneByUsername()
    returns NULL, in which case the validation method returns false. Otherwise, we
    call PHP’s built-in password_verify() function, passing it the submitted password
    ($password) and the correct password hash (accessed with the User object’s getPassword()
    method) ❸. The password_verify() function hashes the provided plaintext password
    and returns a Boolean indicating whether it matches the provided hash.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: isValidUsernamePassword() 辅助函数负责确定数据库中是否存在与接收到的用户名和密码匹配的记录。首先，我们调用 UserRepository
    类的方法 findOneByUsername()，它尝试从用户表中检索与提供的用户名匹配的记录（以 User 对象的形式） ❷。如果无法检索到单个用户，findOneByUsername()
    会返回 NULL，此时验证方法返回 false。否则，我们调用 PHP 内建的 password_verify() 函数，将提交的密码（$password）和正确的密码哈希（通过
    User 对象的 getPassword() 方法访问）传入 ❸。password_verify() 函数会对提供的明文密码进行哈希处理，并返回一个布尔值，指示它是否与提供的哈希值匹配。
- en: Now let’s write the findOneByUsername() method for the UserRepository class.
    Update *src/UserRepository.php* to match the code in [Listing 30-16](#lis30-16).
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Listing 30-16: Adding the findOneByUsername() method to the UserRepository
    class'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
- en: The new findOneByUsername() method has a nullable ?User return type. It uses
    the searchByColumn() method inherited from the ORM library, which takes in a column
    name ('username') and a value (in the $username variable) and returns an array
    of records where the value in that column of the database table is a match. If
    the resulting array doesn’t have a length of exactly 1 (either because it’s empty
    or because multiple records were retrieved), findOneByUsername() returns NULL.
    However, if a single user matches the submitted username string, the corresponding
    User object is returned.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
- en: Note that the logic in this method could have been made part of the isValidUsernamePassword()
    method in UserController, but what’s needed is a query for a user with a given
    username, which is a model database query. It therefore makes sense to create
    this as a custom method in our UserRepository class, where all the code for querying
    the user database table lives. It’s also worth highlighting that even though we’re
    relying on an ORM library for generic methods such as find() and findAll(), it’s
    often still necessary to extend a repository class with custom database methods
    that support the more specialized controller logic specific to the application
    at hand. In this case, we need to search by the username column rather than id,
    so the inherited find() method wouldn’t do. The ORM library is still helping us
    through the searchByColumn() method, but we still need the custom logic of verifying
    that exactly one User object has been retrieved.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
- en: Next, we’ll add a login page link to the navigation bar in the base template.
    Update *templates/base.xhtml.twig* as shown in [Listing 30-17](#lis30-17).
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Listing 30-17: Adding a login link to the base.xhtml.twig template'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
- en: Here we add a navigation list item with the text Login and a URL route of action=login.
    With that added, we can create the child template for the login page itself in
    */templates/user/login.xhtml.twig*. [Listing 30-18](#lis30-18) shows the code.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Listing 30-18: The login.xhtml.twig template'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
- en: The body of the page features a <form> element with a POST action of processLogin.
    The form features fields for a username and password, along with a Submit button.
    Notice that the password input is of type "password" ❶. With this setting, the
    browser will display placeholder characters such as dots or asterisks, hiding
    the actual characters the user enters.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
- en: Try testing out the new login form with the username matt and password password1,
    or with any incorrect username/password combination. Thanks to PHP’s secure, handy
    password_verify() function, you should find that the form works, even though the
    database is storing password hashes rather than plaintext passwords.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
- en: Securing Database Credentials
  id: totrans-120
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Another important security measure for web applications is to avoid exposing
    your database credentials. Whether you declare these credentials as class constants
    or in a completely separate file such as *.env*, as we did earlier in the chapter,
    it’s important not to have them in any public-facing files.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
- en: To begin, you should have only a single file for your credentials. If you’re
    using class constants rather than a *.env* file, I recommend having a completely
    separate class that just declares the constants. Then you can reference this class
    from your Database class (or whatever other class is responsible for establishing
    the database connection).
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
- en: Next, mark the file containing your credentials to be ignored by any backup
    or archiving system. For example, if you’re using the Git distributed version
    control system, you’d list this file in your project’s *.gitignore* file.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
- en: The Doctrine ORM Library
  id: totrans-124
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The open source Doctrine project is a well-maintained, fully featured PHP ORM
    library. It’s widely used; for example, the Symfony framework uses Doctrine for
    all database communications. My small ORM library is fine for small projects and
    for learning the basics, but for larger projects with many interrelated model
    classes, Doctrine is a more robust, sophisticated solution. Some of its features
    include easily facilitating object-to-object references that become foreign keys
    in the database schema and providing low-level control of the database table and
    column names beyond the default naming conventions.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
- en: After [Listing 30-5](#lis30-5) (before adding the User model class), you were
    asked to make a copy of your project. (Don’t worry if you didn’t make a copy of
    your project at that point; you can copy my listing30-05 from the book codes at
    *[https://github.com/dr-matt-smith/php-crash-course](https://github.com/dr-matt-smith/php-crash-course)*.)
    The coming sections will show you how to adapt that copy of the project to use
    Doctrine rather than my pdo-crud-for-free-repositories ORM library.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
- en: Removing the Previous ORM Library
  id: totrans-127
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'First, let’s remove the previous ORM library features from the project. Enter
    the following at the command line to remove the pdo-crud-for-free -repositories
    library from the project’s */vendor* folder and *composer.json* project dependencies
    file:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: We also need to remove the references to the old library’s DatabaseTableRepository
    class from the ProductRepository class declaration. [Listing 30-19](#lis30-19)
    shows how to update the *src/UserRepository.php* file.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Listing 30-19: The ProductRepository class, without inheriting from the ORM
    library'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
- en: For now, we’re left with an empty class declaration, but later we’ll return
    to the class and integrate it with Doctrine.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
- en: Adding Doctrine
  id: totrans-134
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Now we’ll use Composer to add the Doctrine ORM library to the project, along
    with two other required libraries. Enter the following at the command line:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Doctrine requires a cache to aid its performance, and symfony/cache is the recommended
    choice. Additionally, symfony/dotenv will make it easy to access values from the
    project’s *.env* file.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
- en: Next, we need to connect Doctrine with the database. Create a script in the
    project’s top-level directory named *bootstrap.php*, containing the code in [Listing
    30-20](#lis30-20). This script is based on Doctrine’s documentation pages at *[https://www.doctrine-project.org](https://www.doctrine-project.org)*.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Listing 30-20: The bootstrap.php script to set up Doctrine'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
- en: We read in the Composer autoloader, create a Dotenv object to load the database
    credentials from the project’s *.env* file ❶, and package those credentials into
    a $connectionParams array. We then use this array and some Doctrine static methods
    to establish a database connection ❷ and create an EntityManager object ❸. The
    EntityManager class is key to the way Doctrine works; the class maintains the
    link between the model class objects in the PHP code and their corresponding database
    table rows defined with unique primary keys.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
- en: Any other script that reads in *bootstrap.php* will now have access to a database
    connection through the $connection variable and to Doctrine’s entity manager through
    the $entityManager variable.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
- en: Verifying That Doctrine Is Working
  id: totrans-143
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Before we go any further, let’s make sure Doctrine is successfully linked with
    the project’s database. [Listing 30-21](#lis30-21) shows a simple script that
    tests Doctrine by retrieving Product objects from the database as an associative
    array. Save this script as *public/doctrine1.php*.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Listing 30-21: The doctrine1.php script to retrieve existing rows from the
    database'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
- en: 'After reading in the autoloader and the Doctrine bootstrap script, we create
    an SQL query to select all rows from the product database table, then execute
    the query by using the Doctrine database connection (in the $connection variable).
    The results are returned as a nested array; each inner array maps the column names
    to the values in a particular row of the product database table. We loop through
    this array and print each row. If you run this *public/doctrine1.php* script,
    you should see the following output:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: We’ve successfully retrieved the two products from the database, indicating
    that Doctrine is up and running.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
- en: Creating Database Tables
  id: totrans-150
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: One of Doctrine’s strengths is its ability to update the structure of a database
    based on the classes it encounters in the application’s PHP code, creating new
    tables and columns as needed. To see how this works, let’s switch our project
    over to a new, empty database. Then we can use Doctrine to create the product
    table from scratch.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
- en: To begin, open the project’s *.env* file and change the value associated with
    the MYSQL_DATABASE key to demo2. Next, we need to write a script to create this
    new demo2 database schema. Create *db/create_database.php* and enter the contents
    of [Listing 30-22](#lis30-22).
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Listing 30-22: The db/create_database.php script to create the database named
    in the .env file'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
- en: We use a Dotenv object ❶ to read the database credentials from the *.env* file
    and create an array of connection parameters. Then, inside a try...catch block,
    we create a connection to the MySQL database server by using Doctrine’s DriverManager::getConnection()
    method ❷. We then get an array of all the database names and search that array
    for the database name from our *.env* file, storing the result (true or false)
    in the $databaseExists variable ❸.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
- en: If the database exists, we drop it by using the dropDatabase() method. Then
    we create the database anew by using the createDatabase() method ❹ and print a
    success message. If any Exception is caught ❺, we print an error message instead.
    Run this script and you should now have a new, empty database schema called demo2.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
- en: The basic usage of Doctrine is to run a command line script that reads metadata
    about model classes in the PHP code (called *entity classes* in Doctrine’s parlance)
    and executes SQL statements to create corresponding structures in the database
    schema. The command line script is usually placed in a file called */bin/doctrine*
    (without the.*php* file extension). Create this file as shown in [Listing 30-23](#lis30-23).
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Listing 30-23: The /bin/doctrine command line script'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
- en: 'This script invokes the run() method of Doctrine’s ConsoleRunner class. The
    method takes in the arguments from the command line and uses them to run whatever
    Doctrine command has been entered after bin/doctrine in the terminal. Let’s run
    this script to try updating the new database schema. Enter php bin/doctrine orm:schema-tool:create
    at the command line. You should see the following output:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: The script hasn’t done anything because we haven’t yet added any of the necessary
    metadata for Doctrine to know which model classes and properties should be mapped
    to which database tables and columns. We’ll now add metadata to the Product model
    class so that Doctrine will have a table to create in the database. As you’ll
    see, each metadata tag is preceded by a hash mark (#) and enclosed in square brackets.
    Modify the *src/Product.php* file as shown in [Listing 30-24](#lis30-24).
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Listing 30-24: Adding Doctrine metadata to the Product class'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
- en: To keep the metadata easier to read, we start with a use statement aliasing
    the Doctrine\ORM\Mapping class as ORM. Then we add metadata to the class itself
    and to each of its properties. We declare the class as an Entity ❶, indicating
    that it should correspond to a database table, and specify that this table should
    be named product. Without the latter, Doctrine would default to Product (starting
    with a capital letter) as the table name, to match the class name.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
- en: For the class’s id property, the Id tag indicates that this property should
    be used as the primary key ❷, Column indicates the property should correspond
    to a column in the database table, and GeneratedValue means the property should
    be auto-incremented in the database system. For the remaining properties, all
    we need is the Column tag. Notice that we can either specify the database column’s
    data type as part of the Column tag or let Doctrine guess the appropriate data
    type.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
- en: 'With this metadata added, we can run our Doctrine command line script again.
    First, let’s add the --dump-sql option, which will show the SQL that Doctrine
    *would* execute, without actually executing it yet:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'This shows that Doctrine will issue SQL code to create a product table with
    an auto-incrementing integer primary key id, a text description, and a floating-point
    price. Exactly what we want! Now run the command line script again without the
    --dump-sql option to execute that SQL:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Doctrine has now created the product table in the demo2 database schema.  ####
    Adding Records to a Table'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
- en: Now that we’ve used Doctrine to map our Product class to the product database
    table, we can create new Product objects and store their data in the database.
    [Listing 30-25](#lis30-25) shows the *public/doctrine2.php* script to do this.
    Add this file to the project.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Listing 30-25: The public/doctrine2.php script to insert and retrieve a database
    row'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
- en: We create a Product object ❶ and set its description and price. Then we use
    the Doctrine EntityManager object to add this product’s data to a queue (the persist()
    method) and insert the object into the database (the flush() method).
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
- en: 'To confirm this has worked, we use EntityManager to create and get a reference
    to a Doctrine repository object for the Product class ❷. This is a custom repository
    object linking the Product class with the records in the product database table.
    We use this repository object to retrieve all the records (in this case, just
    the one) from the table with the object’s findAll() method. Then we loop through
    the resulting $products array and print each object. Here’s the output of running
    this script:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'This output confirms that Doctrine has successfully added the "small hammer"
    object to the product database table.  #### Integrating Doctrine into the Application
    Code'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
- en: All the code is in place now to integrate the Doctrine ORM library into our
    main web application so that we can easily map objects and database table rows.
    First, to minimize changes required throughout the application code, we’ll add
    a helper class called OrmHelper that manages access to the Doctrine EntityManager
    instance. [Listing 30-26](#lis30-26) shows how to declare this class in *src/OrmHelper.php*.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Listing 30-26: The OrmHelper class storing and providing access to the $entityManager
    property'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
- en: This class declares a private static entityManager property, with public static
    getters and setters. We use static members to allow retrieval of a reference to
    the Doctrine EntityManager object from anywhere in our application code (after
    the variable has been set), without having to create an object or pass an object
    reference down through several constructor methods when creating the application,
    controller, or repository classes.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
- en: Notice that the setter method takes in a reference to an EntityManager object
    and passes it along to the class’s entityManager property. We’ve already created
    that reference in the *bootstrap.php* script, so we just need to read in the bootstrap
    script before invoking the setter method. We’ll do that now by updating the *public/index.php*
    script as shown in [Listing 30-27](#lis30-27).
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Listing 30-27: Updating the index.php script to bootstrap Doctrine and store
    the EntityManager object reference'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
- en: We add a require_once statement to read and run our Doctrine bootstrap script
    ❶. We add a use statement so that we can refer to the OrmHelper class in our code
    ❷. Then we store a reference to the script’s EntityManager object by calling the
    setEntityManager() static method of our OrmHelper class. This means the EntityManager
    object is now available anywhere in our web application logic via the public static
    method OrmHelper::getEntityManager().
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we need to fill out our ProductRepository class, which we left as an
    empty class declaration when we switched over to Doctrine. Our ProductController
    class expects ProductRepository to have CRUD methods like find(), findAll(), insert(),
    delete(), and so on. [Listing 30-28](#lis30-28) shows how to update *src/ProductRepository.php*
    accordingly.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Listing 30-28: Updating ProductRepository with Doctrine-based CRUD methods'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
- en: We declare ProductRepository as a subclass of Doctrine\ORM\EntityRepository.
    This means it will inherit methods such as find() and findAll() from its parent.
    The class declares one instance variable, an EntityManager object, which is assigned
    its value in the constructor via our OrmHelper class ❶. The remaining lines in
    the constructor retrieve the required metadata about the Product class and pass
    it along to the parent class’s constructor to tailor the repository class to the
    product table ❷.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
- en: We continue the class by declaring the remaining CRUD methods our application
    expects. For insert() and update(), we use the persist() and flush() methods of
    the EntityManager object methods to add or modify a database record. The delete()
    method uses the remove() and flush() methods of the EntityManager object to remove
    a record. Finally, the deleteAll() method retrieves all objects with the inherited
    findAll() method, then loops through them to remove each one from the database.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
- en: Creating Foreign-Key Relationships
  id: totrans-192
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: It may seem like we’ve done a lot of work to incorporate Doctrine while gaining
    little or no functionality beyond the previous ORM library. However, we can begin
    to see some of the real power of the Doctrine ORM library when we start creating
    foreign-key relationships between database tables and their corresponding model
    classes. In our code, we establish this relationship by adding a property to a
    model class whose value is a reference to an object of another model class. With
    the right metadata, Doctrine can see this relationship and generate all the SQL
    needed to realize it in the database.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
- en: To illustrate, let’s add a Category model class to our project along with the
    equivalent category database table. Then we’ll modify the Product model class
    so that each product is associated with a category. In the process, we’ll see
    how Doctrine manages the foreign-key relationship behind this association. [Listing
    30-29](#lis30-29) shows the *src/Category.php* script declaring the new Category
    class.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Listing 30-29: The Category model class, including Doctrine ORM metadata'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
- en: 'The initial metadata before the class name indicates that this simple model
    class (or Doctrine entity) should correspond to a database table called category
    ❶. The class has two properties: a unique integer id and a string name. As with
    the Product class, we include a tag specifying that id is to be autogenerated
    by the database ❷. For each property, we declare basic getter and setter methods.'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
- en: Now let’s add a category property to the Product class so that each Product
    object will be associated with one Category object. [Listing 30-30](#lis30-30)
    shows how to modify *src/Product.php*.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Listing 30-30: Adding a category property to the Product class'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
- en: We declare the category property as either NULL or a reference to a Category
    object, and give it public getter and setter methods. The metadata attribute preceding
    the property ❶ tells Doctrine that this field in the database should hold a foreign-key
    reference to a row in the category table. Here ManyToOne indicates that the foreign
    key establishes a *many-to-one* relationship, where many products can be of the
    same category, and targetEntity sets the model class (and database table) on the
    other end of the relationship.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
- en: 'Since we’ve changed the structure of the Product model class, as well as adding
    the new Category class, we need Doctrine to update the structure of the database
    accordingly. First, let’s use our *bin/doctrine* command-line script to drop the
    old product table from the database schema:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'This drops *all* tables from the schema (in our case, that’s just the product
    table). Now we’ll use the command-line script again to create the database schema
    anew, complete with the product and category tables and the foreign-key relationship
    between them. As before, we’ll first use the --dump-sql option to view the SQL
    statements Doctrine wants to run:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: This shows that Doctrine will issue SQL code to create the category and product
    tables, where product has a category_id field with a foreign-key reference to
    a category database row. Real-world databases abound with foreign-key references
    like this, and here we see how Doctrine excels at managing the SQL for these relationships
    so we don’t have to.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
- en: Run the command-line script once more without the --dump-sql option to execute
    the SQL statements and create these related database tables. To make sure the
    related tables have been successfully created in the database, we’ll write a one-off
    script creating related Product and Category objects, saving them to the database,
    and retrieving them. [Listing 30-31](#lis30-31) shows *public/doctrine3.php* implementing
    these actions. Add this file to your project.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Listing 30-31: The public/doctrine3.php script to insert related records into
    the database'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
- en: 'We create two Category objects for HARDWARE and APPLIANCES, then store them
    in the database by using the Doctrine EntityManager object from the bootstrap
    script. Notice that we call the persist() method on each Category object individually,
    then call the flush() method once ❶; flush() will batch-process any operations
    that have been queued up for it with methods like persist(). We next use our ProductRepository
    class to create and insert two Product objects into the database, one for each
    category. Then we retrieve an array of all the products from the database with
    the ProductRepository class’s findAll() method ❷. If the array isn’t empty, we
    loop through it and print each product. Here’s the output of running this script:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Each product is shown with its associated category. With just a little bit of
    metadata in the Product model classes (the Doctrine ManyToOne attribute added
    before the category property), we’ve created a whole database of foreign-key declaration
    and storage mapping.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
- en: Overall, although switching from my simple ORM library to Doctrine added complexity
    to the code, such as the need for a bootstrap script and metadata tags in the
    model classes, Doctrine comes with added benefits like increased flexibility and
    support for foreign-key relationships. Using a popular ORM library like Doctrine
    for a project also means that developers you collaborate with will be more likely
    to already be familiar with its operations, which can save time in code development
    and maintenance. Another advantage of ORM libraries like Doctrine is that they
    allow you to seamlessly switch from one DBMS to another (such as from MySQL to
    PostgreSQL), without any of your core web application code having to change. The
    only downside may be the effort of learning the library in the first place, and
    perhaps some performance reduction due to the extra layer of abstraction. Still,
    the advantages will in many cases outweigh any minor performance reduction.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-214
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, we used my pdo-crud-for-free-repositories library to explore
    the basics of ORM libraries, seeing how they can simplify the process of working
    with a database by eliminating the need for writing a lot of repetitive code for
    CRUD applications. When we transitioned to the Doctrine ORM library, we saw that
    this more robust and feature-complete library has added benefits like greater
    flexibility and support for foreign-key associations between model classes and
    their corresponding database tables.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
- en: This chapter also outlined important practices in web application security.
    In previous chapters, we were already using prepared SQL statements, which help
    protect against SQL injection attacks. Now we’ve added the ability to store and
    verify against hashed passwords, so we never need to store plaintext passwords
    in a database. We’ve also emphasized the importance of keeping database credentials
    in a separate file so that they won’t be published or archived and accidentally
    exposed.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
- en: Exercises
  id: totrans-217
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '1.   I’ve created a publicly shared sample project to help explore the pdo-crud
    -for-free-repositories library. The project uses PHP templates (not Twig) to illustrate
    how to use the ORM library for a Movie model class and its associated MovieRepository
    class. To check out the project, do the following:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
- en: 'a.   Enter the following at the command line to create a new project named
    *demo1* based on my published project template:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: b.   In the *demo1* directory that was created, edit the MySQL credentials in
    the *.env* file to match your computer’s setup.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
- en: c.   Run the database setup script in *db/migrateAndLoadFixtures.php.*
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
- en: d.   Run a web server and visit the home page and movie list page.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
- en: e.   Examine the Movie model class, and the listMovies() method in the Application
    class.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
- en: '2.   Use the pdo-crud-for-free-repositories library to create a MySQL CRUD
    web application for Book objects with these properties:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
- en: id (integer), an auto-incrementing primary key
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
- en: title (string)
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
- en: author (string)
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
- en: price (float)
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
- en: You can either create a new project from scratch, extend the demo project from
    the previous exercise, or adapt your work from Exercise 2 of the previous chapter.
    You may find it helpful to adapt the database schema creation and initial data
    script from [Listing 30-12](#lis30-12), or if you’re using the demo project, you
    can adapt the database setup script in *db/migrateAndLoadFixtures.php*.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
- en: '3.   Web application security is an enormous topic (the subject of entire books),
    and covering it exhaustively here would be impossible. Learn more about PHP security
    best practices by exploring the following resources:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
- en: The Paragon Initiative Enterprises PHP security guide, *[https://paragonie.com/blog/2017/12/2018-guide-building-secure-php-software](https://paragonie.com/blog/2017/12/2018-guide-building-secure-php-software)*
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
- en: The Open Web Application Security Project, *[https://owasp.org](https://owasp.org)*
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
- en: PHP The Right Way’s security chapters, by Josh Lockhart (codeguy), *[https://phptherightway.com/#security](https://phptherightway.com/#security)*
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
