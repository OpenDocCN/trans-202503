- en: <hgroup>
  prefs: []
  type: TYPE_NORMAL
- en: 30 ORM LIBRARIES AND DATABASE SECURITY
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: </hgroup>
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/opener.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In this chapter, we’ll explore techniques that make working with databases easier
    and more secure. First, much of the CRUD code in repository classes can become
    tedious and repetitive to write, varying only in terms of the names of the model
    classes and their properties. *Object-relational mapping (ORM) libraries* relieve
    this problem, automating lower-level work like preparing and executing SQL queries
    based on the way an application’s model classes are named and structured. You’ll
    see how to use such a library to simplify or replace our repository classes with
    just a few lines of code. We’ll start by adding a simple ORM library to our example
    web application, then later integrate the professional-grade Doctrine ORM library
    with the project.
  prefs: []
  type: TYPE_NORMAL
- en: On the security front, adopting on ORM library will push us to remove any hardcoded
    database credentials from our code, instead placing those credentials in a separate
    data file. We’ll also explore best practices for handling login information in
    a web application, including using *password hashing* to avoid storing plaintext
    passwords in a database. As you’ll see, PHP provides built-in functions that make
    this process straightforward.
  prefs: []
  type: TYPE_NORMAL
- en: Simplifying Database Code with an ORM Library
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: One approach to making web applications communicate with databases is to design
    and write the necessary low-level code from scratch for each project. This includes
    the code to connect to database servers, create schemas and tables, and perform
    the four CRUD operations so that the database tables can store the data to support
    the application. Implementing this code requires careful analysis of the project
    requirements, especially the requirements for which data needs to be persisted
    to a database. The result is code that’s tailored to the application at hand and
    can be written for computational efficiency to maximize speed.
  prefs: []
  type: TYPE_NORMAL
- en: We’ve followed this approach of designing and writing custom, application-specific
    database code in the last few chapters. It’s been helpful for learning about how
    to work with a database, but it also comes with disadvantages. First, it takes
    time to design, write, and test code for every new application. Second, if the
    application requirements change, both the web application’s database communication
    code and the database structure itself need to be changed accordingly. Finally,
    any new developers joining a software team for an ongoing project will have to
    learn all the details of the system’s design to communicate with the database.
  prefs: []
  type: TYPE_NORMAL
- en: An alternative approach is to use an ORM library to abstract away the lower-level
    work of communication with the database. ORM libraries use the structure and associations
    of an application’s model classes (often with a little additional metadata) to
    automatically create and update the structure of the corresponding database tables.
    If changes in the application requirements lead to changes in the model classes
    (perhaps new model classes are added, or existing classes are given new properties
    or associations), then the ORM library can automatically update the database table
    structures accordingly and manage updated database queries based on the new model
    class declarations.
  prefs: []
  type: TYPE_NORMAL
- en: ORM libraries can be less computationally efficient than custom-written low-level
    database communication code. If speed isn’t the most important feature for a web
    application, however, they have several strengths. For one, the database structure
    and queries are updated as soon as the model classes are updated, which streamlines
    the coding process. Also, if the project uses a well-known, industrial-standard
    ORM library, new developers joining a project will likely already be familiar
    with the abstracted ways to use the ORM library to handle database operations.
  prefs: []
  type: TYPE_NORMAL
- en: Before we get into the details of how to use an ORM library, let’s consider
    an example that illustrates this approach’s benefits, compared to using custom
    code. [Listing 30-1](#lis30-1) shows an excerpt of the ProductRepository class
    developed in the previous two chapters.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 30-1: Some of the contents of the ProductRepository class'
  prefs: []
  type: TYPE_NORMAL
- en: We developed this class manually, meaning we had to implement lower-level methods
    such as a constructor to retrieve a database connection and CRUD methods such
    as findAll() and find() to prepare and execute SQL queries. Compare this code
    with [Listing 30-2](#lis30-2), which declares an equivalent ProductRepository
    class with the help of an ORM library.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 30-2: A ProductRepository class inheriting from an ORM library'
  prefs: []
  type: TYPE_NORMAL
- en: For straightforward database interactions, an ORM library can do almost all
    the work for us. Instead of implementing custom methods in the repository class,
    we simply inherit those methods from an ORM library superclass (in this case,
    DatabaseTableRepository). The superclass is designed to use *reflection*, a technique
    of inspecting the classes and objects it interacts with, such as the Product model
    class. Then the superclass uses what it finds to generate SQL queries suitable
    for objects of those classes.
  prefs: []
  type: TYPE_NORMAL
- en: In the coming sections, we’ll explore how this works in more detail by using
    a simple ORM library, one that I maintain as an open source project on GitHub.
    Later we’ll also try out an industrial-strength ORM library called Doctrine, one
    of the most popular ORM libraries available for modern PHP. For now, though, take
    a moment to appreciate how much shorter the ORM-assisted ProductRepository class
    declaration is than the manually coded version.
  prefs: []
  type: TYPE_NORMAL
- en: Adding an ORM Library to a Project
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Let’s extend our database-driven web application from the previous chapters
    to work with a simple ORM library called pdo-crud-for-free-repositories that I
    maintain (*[https://github.com/dr-matt-smith/pdo-crud-for-free-repositories](https://github.com/dr-matt-smith/pdo-crud-for-free-repositories)*).
    It has limited features but is straightforward to use, making it a good tool for
    introducing the basics of ORM libraries. To get started, enter the following at
    the command line to add the library to the project:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: This will add a *mattsmithdev* folder inside *vendor* containing the library
    code.
  prefs: []
  type: TYPE_NORMAL
- en: At the time of this writing, the released version of the pdo-crud-for-free -repositories
    is compatible only with MySQL, so we’ll focus on the MySQL version of our web
    application rather than the SQLite version.
  prefs: []
  type: TYPE_NORMAL
- en: Moving Database Credentials to a .env File
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The ORM library we’re using requires all our database credentials to be declared
    in a file named *.env*, commonly known as a *dotenv file*, rather than hardcoded
    in the Database class where we currently have them. Dotenv files are human-readable
    text files defining name/value pairs necessary for a program to run; other common
    file types for such variables include XML and YAML. This requirement is not a
    bad thing, since it also makes the application more secure.
  prefs: []
  type: TYPE_NORMAL
- en: Typically, we’d exclude dotenv files when using version-control systems such
    as Git so that when code is archived or pushed to open source projects, sensitive
    database credentials won’t be included. This reduces the chance of a security
    breach from code being published or distributed to unauthorized people. Another
    advantage of this approach is that different environments can be set up in multiple
    dotenv files, such as for local development, remote development, testing, and
    live production systems.
  prefs: []
  type: TYPE_NORMAL
- en: To satisfy this ORM library requirement, create a file called *.env* and save
    it in the main project directory. Enter the contents of [Listing 30-3](#lis30-3)
    into the file, changing values such as the password and port to match the MySQL
    server properties running on your computer.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 30-3: The database credentials in the .env file'
  prefs: []
  type: TYPE_NORMAL
- en: These MySQL attributes were all previously defined as constants in our Database
    class. We can now delete the Database class from our project, since the ORM library
    comes with its own class for managing the connection with the database, based
    on the information in the dotenv file.
  prefs: []
  type: TYPE_NORMAL
- en: Relegating Product Operations to the ORM Library
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Now that the ORM library has access to the database, we can shift responsibility
    for all CRUD operations relating to the product table from our ProductRepository
    class to the ORM library. We’ll still use the ProductRepository class, but as
    hinted earlier, instead of manually filling it with methods that prepare and execute
    SQL statements, we’ll simply declare it to be a subclass of one of the ORM library
    classes. Replace the contents of *src/ProductRepository.php* with the code shown
    in [Listing 30-4](#lis30-4).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 30-4: The much-simplified ProductRepository class'
  prefs: []
  type: TYPE_NORMAL
- en: 'The use statement specifies that we want to refer to the DatabaseTableRepository
    class in the Mattsmithdev\PdoCrudRepo namespace. Then we declare ProductRepository
    as a subclass of DatabaseTableRepository, with no code whatsoever in the class
    body. And that’s it! We now have a working ProductRepository class with just those
    few lines of code. It will inherit all the methods declared in the DatabaseTableRepository
    superclass that happen to follow the same naming convention we used previously:
    find(), findAll(), delete(), deleteAll(), and so on.'
  prefs: []
  type: TYPE_NORMAL
- en: But how does the DatabaseTableRepository class know that we want it to work
    with a product table with id, description, and price fields? This is where reflection
    comes into play. The DatabaseTableRepository class uses this technique to infer
    the details about how to construct appropriate SQL statements based on the classes
    and objects it comes into contact with. In this case, the reflection code assumes
    that the ProductRepository repository class manages database methods for a model
    class in the same namespace called Product, and that a corresponding product table
    in the database has fields matching the property names of the Product class. As
    long as all the names align, the ORM library will be able to do its job.
  prefs: []
  type: TYPE_NORMAL
- en: For the reflection process to work, the DatabaseTableRepository methods need
    to receive objects of the appropriate model class, rather than free- floating
    variables as we’d previously designed the CRUD methods in [Chapter 29](chapter29.xhtml).
    To finalize the shift to the ORM library, we therefore need to refactor our ProductController
    class to pass in Product objects when calling the insert() and update() methods
    to process new and updated products. Change the *src/ProductController.php* file
    as shown in [Listing 30-5](#lis30-5).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 30-5: The updated src/ProductController.php class'
  prefs: []
  type: TYPE_NORMAL
- en: In the revised processCreate() method, we first create a new Product object
    and set its description and price properties to the values passed into the method.
    We then pass this Product object to the ProductRepository object’s insert() method
    to add the new product to the database ❶. The ORM library assumes that every database
    table has an auto-incrementing primary key named id, so no value for the product
    ID is needed when creating a new row in the database. We make a similar change
    to the processEdit() method, using the id to get a reference to the Product object
    to be updated ❷, setting the other properties received from the form, and passing
    the object reference to the repository class’s update() method.
  prefs: []
  type: TYPE_NORMAL
- en: Run the web server and you should now see the web application is working just
    as before, but with significantly less code! In this way, working with an ORM
    library greatly simplified the task of executing standard database CRUD operations.
  prefs: []
  type: TYPE_NORMAL
- en: NOTE
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*Before moving on, make a copy of your project at this point. In “The Doctrine
    ORM Library” on [page 615](#pg_615), we’ll modify that copy to use Doctrine.*'
  prefs: []
  type: TYPE_NORMAL
- en: Adding a New Database Table
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Now that we’ve incorporated the ORM library into the project, let’s expand our
    web application by adding another table to the database. With the library handling
    all the CRUD operations, the process will be much more efficient than our effort
    in [Chapter 29](chapter29.xhtml) to get CRUD working for the product table. When
    we look at security in “Security Best Practices” on [page 608](#pg_608), we’ll
    discuss best practices for handling passwords, so we’ll go ahead and add a user
    table storing username and password information.
  prefs: []
  type: TYPE_NORMAL
- en: Along with the new database table, we’ll need a User model class, a UserRepository
    repository class (so named to match the ORM library’s requirements), a UserController
    controller class, and a page for displaying all the users. [Figure 30-1](#fig30-1)
    shows that page. Of course, this page exists just to illustrate that the database
    methods are working; displaying a list of usernames and passwords is *not* an
    example of secure web development.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/figure30-1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 30-1: The User List page'
  prefs: []
  type: TYPE_NORMAL
- en: We’ll start by declaring the User model class. Add a *src/User.php* file containing
    the code in [Listing 30-6](#lis30-6) to the project.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 30-6: The User class'
  prefs: []
  type: TYPE_NORMAL
- en: The class has an integer id property (a requirement for the ORM library) and
    string properties for username and password. We declare standard getter and setter
    methods for each of these properties.
  prefs: []
  type: TYPE_NORMAL
- en: Now we’ll create the UserRepository class in *src/UserRepository.php*. As with
    ProductRepository, we’ll have this class extend the ORM library’s DatabaseTableRepository
    class. [Listing 30-7](#lis30-7) shows the code.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 30-7: The simple UserRepository class'
  prefs: []
  type: TYPE_NORMAL
- en: We don’t need to declare any methods for this repository class, since it will
    inherit all the necessary CRUD methods from the DatabaseTableRepository class.
    Thanks to the naming of the UserRepository and User classes, these CRUD methods
    will know to work with the user table in the database.
  prefs: []
  type: TYPE_NORMAL
- en: Next, let’s create a UserController class, with a method to retrieve all users
    from the database and display them with a Twig template. Create *src/UserController.php*
    containing the code in [Listing 30-8](#lis30-8).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 30-8: The UserController class declaring a list() method'
  prefs: []
  type: TYPE_NORMAL
- en: We declare UserController as a subclass of Controller so that it will inherit
    a twig property for rendering templates. We declare a private userRepository property
    and initialize it in the constructor (where we also must first invoke the parent
    Controller class’s constructor to set up the twig property). We then declare a
    list() method, which uses the UserRepository object’s findAll() method (inherited
    from the ORM library) to retrieve all users from the database ❶. The results are
    returned as an array of objects, which we store as $users. We pass this array
    as the Twig variable users for rendering by the *templates/user/list.xhtml.twig*
    template.
  prefs: []
  type: TYPE_NORMAL
- en: Now we’ll add a navigation bar link for the User List page to the base Twig
    template that all other templates inherit from. Update *templates/base.xhtml.twig*
    to match the contents of [Listing 30-9](#lis30-9).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 30-9: Adding a user list link to /templates/base.xhtml.twig'
  prefs: []
  type: TYPE_NORMAL
- en: Here we add a navigation list item with the text User List page. The anchor
    element has an action of users, and its CSS class attribute declares an empty
    Twig block called userLink. As with the other navigation bar items, this block
    can be overridden with the text active to highlight the link.
  prefs: []
  type: TYPE_NORMAL
- en: With the base template updated, we can now create the *templates/user/list.xhtml.twig*
    child template for the User List page. [Listing 30-10](#lis30-10) shows how.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 30-10: The list.xhtml.twig template'
  prefs: []
  type: TYPE_NORMAL
- en: In this template, we override the userLink block to contain the text active
    ❶, highlighting the User List page link in the navigation bar. In the body block,
    we use a Twig for loop ❷ to iterate through the users array, creating a list item
    for each user displaying the associated ID, username, and password.
  prefs: []
  type: TYPE_NORMAL
- en: Now we need to add a case for the action=users route to our front-controller
    Application class. Update *src/Application.php* to match the contents of [Listing
    30-11](#lis30-11).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 30-11: Adding a route to the user list in the Application class'
  prefs: []
  type: TYPE_NORMAL
- en: We declare a userController property and initialize it as a new UserController
    object in the constructor. Then, in the switch statement, we declare a case for
    when the action is 'users', invoking the list() method of the UserController object.
  prefs: []
  type: TYPE_NORMAL
- en: All we need to do now is add the user table to the database schema and insert
    user rows into the table. Create a new helper script, *db/setup_users.php*, as
    shown in [Listing 30-12](#lis30-12).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 30-12: The setup script for the user table in /db/setup_users.php'
  prefs: []
  type: TYPE_NORMAL
- en: When we first set up the product table in [Chapter 28](chapter28.xhtml), we
    had to manually type out and execute each SQL statement to add a new row to the
    database. Now we can instead build each row as an instance of the User class and
    add it to the table by calling the insert() method of the UserRepository class
    (inherited from the ORM library). In this script, we do that for two users, assigning
    them usernames and passwords.
  prefs: []
  type: TYPE_NORMAL
- en: First, though, we invoke the UserRepository class’s resetTable() method ❶, which
    drops any existing table mapped to the User class and creates a new table based
    on the names and data types of the User class. This is another “free” method automatically
    available to our repository class through inheritance from the ORM library’s DatabaseTableRepository
    class. To confirm the database table has been created and two User records have
    been inserted, the script ends by retrieving all users from the database with
    the findAll() method and printing them with var_dump().
  prefs: []
  type: TYPE_NORMAL
- en: 'Enter php db/setup_users.php at the terminal to run this setup script. You
    should see the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: The terminal output shows an array containing two User objects, proof that the
    user database table has been added to the database schema, complete with two users.
    At this point, you can also launch the web application again and visit the User
    List page. It should look like [Figure 30-1](#fig30-1).
  prefs: []
  type: TYPE_NORMAL
- en: By working with my pdo-crud-for-free-repositories library, we’ve seen how using
    an ORM library can remove the need to code low-level database queries. This reduces
    the amount of code required for each individual web application, simplifying the
    development process. We’ll continue to use this library as we turn our attention
    to application security, but later we’ll return to the topic of ORM libraries
    to see the added benefits of working with a more sophisticated library like Doctrine.
  prefs: []
  type: TYPE_NORMAL
- en: Security Best Practices
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Security is an essential part of software development, both in your local development
    environment and when deploying web applications to the real world as public websites.
    Perhaps the most common manifestation of security a user meets these days is a
    username/password login form. We’ll explore best practices for securing login
    information in this section.
  prefs: []
  type: TYPE_NORMAL
- en: Storing Hashed Passwords
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: You should never store plaintext passwords in your application’s database. Otherwise,
    if someone gets access to the database, all those accounts would be compromised.
    One option for securely storing data is to *encrypt* it, encoding data in such
    a way that it can be decoded back to its original form at a later time. When sending
    confidential messages, for example, it’s common to encrypt them first and to provide
    the intended recipient with the method for decrypting the message once received.
    For passwords, however, encryption isn’t the best solution; if the database were
    accessed, brute-force techniques could allow attackers to eventually decrypt the
    data (although depending on the speed of their computers, it might take a long
    time).
  prefs: []
  type: TYPE_NORMAL
- en: A better technique for password storage is *hashing*. This is an irreversible
    way of creating a new piece of data from the original data; there’s no way to
    reconstruct the plaintext password from the hashed version. The same password
    passed through the same hash algorithm will always yield the same hash, however.
    When a user is logging into an application, you can therefore test whether their
    password is valid by hashing what they’ve entered and comparing it with the hash
    stored in the database. With this mechanism, there’s no need to ever store the
    original plaintext password.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s make our web application more secure by storing hashes rather than plaintext
    passwords in the user database table. Conveniently, modern PHP offers a built-in
    password_hash() function for calculating the hash of a string. We’ll change the
    setPassword() method of the User entity class to take advantage of this function.
    Update *src/User.php* to match the contents of [Listing 30-13](#lis30-13).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 30-13: Storing a hashed password in the User class'
  prefs: []
  type: TYPE_NORMAL
- en: The revised setPassword() method takes in the plaintext password for a new user
    and passes it to the password_hash() function for hashing. The PASSWORD_DEFAULT
    constant means the function will use the strongest hashing algorithm available
    in the installed version of PHP, though there are other constants for explicitly
    choosing a particular hashing algorithm. We store the hash in the $hashedPassword
    variable and assign this as the value of the User object’s password property.
  prefs: []
  type: TYPE_NORMAL
- en: 'With this change, any new User objects created and passed to the database will
    contain hashed rather than plaintext passwords. To prove it, rerun our user table
    setup script by entering php db/setup_users.php at the command line. This will
    delete and re-create the table with the modified User class. Here’s the resulting
    var_dump() output in the terminal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: The black text lines show the hashes in each password field. Each hash is a
    long character string that has no discernible relationship with the original password.
  prefs: []
  type: TYPE_NORMAL
- en: Verifying Hashed Passwords at Login
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Another useful built-in PHP function is password_verify(), which takes in a
    plaintext password, hashes it, and compares it with an existing hash to determine
    whether the password is correct. With this function, we can implement a login
    page for our application, where the user inputs a username and password for verification
    against their record in the user database table. [Figure 30-2](#fig30-2) shows
    the login page we’ll create.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/figure30-2.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 30-2: The new login page'
  prefs: []
  type: TYPE_NORMAL
- en: Our application will need two new routes, one to request display of the login
    page (action=login) and one to request processing of the submitted data from the
    login form (action=processLogin). First, we’ll add cases for these routes to our
    front-controller Application class. Update the switch statement in *src/Application.php*
    to match [Listing 30-14](#lis30-14).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 30-14: Adding login routes to the Application class'
  prefs: []
  type: TYPE_NORMAL
- en: For the 'login' case, we invoke the loginForm() method of the UserController
    object ❶. For the 'processLogin' case, we first attempt to extract the 'username'
    and 'password' values from the variables received in the POST request. If either
    is empty ❷, an appropriate error message is displayed by passing a string message
    to the error() method of the DefaultController object. Otherwise, the username
    and password are passed to the processLogin() method of the UserController object
    ❸.
  prefs: []
  type: TYPE_NORMAL
- en: Now we need to add the new methods to the UserController class. Update *src/UserController.php*
    as shown in [Listing 30-15](#lis30-15).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 30-15: Adding login methods to the UserController class'
  prefs: []
  type: TYPE_NORMAL
- en: For the loginForm() method, we simply render the appropriate Twig template,
    which doesn’t require any arguments. For the processLogin() method, we take in
    the received $username and $password variables and pass them to the isValidUsernamePassword()
    helper method ❶, which returns a Boolean. If true, we print a success message,
    or an error message if false. In a full web application, at this stage, we would
    store the login success in the session as we did in [Chapter 16](chapter16.xhtml).
  prefs: []
  type: TYPE_NORMAL
- en: The isValidUsernamePassword() helper is responsible for determining whether
    the database holds a record matching the received username and password. First,
    we call the UserRepository class method findOneByUsername(), which attempts to
    retrieve a record (in the form of a User object) from the user table matching
    the provided username ❷. If a single user can’t be retrieved, findOneByUsername()
    returns NULL, in which case the validation method returns false. Otherwise, we
    call PHP’s built-in password_verify() function, passing it the submitted password
    ($password) and the correct password hash (accessed with the User object’s getPassword()
    method) ❸. The password_verify() function hashes the provided plaintext password
    and returns a Boolean indicating whether it matches the provided hash.
  prefs: []
  type: TYPE_NORMAL
- en: Now let’s write the findOneByUsername() method for the UserRepository class.
    Update *src/UserRepository.php* to match the code in [Listing 30-16](#lis30-16).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 30-16: Adding the findOneByUsername() method to the UserRepository
    class'
  prefs: []
  type: TYPE_NORMAL
- en: The new findOneByUsername() method has a nullable ?User return type. It uses
    the searchByColumn() method inherited from the ORM library, which takes in a column
    name ('username') and a value (in the $username variable) and returns an array
    of records where the value in that column of the database table is a match. If
    the resulting array doesn’t have a length of exactly 1 (either because it’s empty
    or because multiple records were retrieved), findOneByUsername() returns NULL.
    However, if a single user matches the submitted username string, the corresponding
    User object is returned.
  prefs: []
  type: TYPE_NORMAL
- en: Note that the logic in this method could have been made part of the isValidUsernamePassword()
    method in UserController, but what’s needed is a query for a user with a given
    username, which is a model database query. It therefore makes sense to create
    this as a custom method in our UserRepository class, where all the code for querying
    the user database table lives. It’s also worth highlighting that even though we’re
    relying on an ORM library for generic methods such as find() and findAll(), it’s
    often still necessary to extend a repository class with custom database methods
    that support the more specialized controller logic specific to the application
    at hand. In this case, we need to search by the username column rather than id,
    so the inherited find() method wouldn’t do. The ORM library is still helping us
    through the searchByColumn() method, but we still need the custom logic of verifying
    that exactly one User object has been retrieved.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we’ll add a login page link to the navigation bar in the base template.
    Update *templates/base.xhtml.twig* as shown in [Listing 30-17](#lis30-17).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 30-17: Adding a login link to the base.xhtml.twig template'
  prefs: []
  type: TYPE_NORMAL
- en: Here we add a navigation list item with the text Login and a URL route of action=login.
    With that added, we can create the child template for the login page itself in
    */templates/user/login.xhtml.twig*. [Listing 30-18](#lis30-18) shows the code.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 30-18: The login.xhtml.twig template'
  prefs: []
  type: TYPE_NORMAL
- en: The body of the page features a <form> element with a POST action of processLogin.
    The form features fields for a username and password, along with a Submit button.
    Notice that the password input is of type "password" ❶. With this setting, the
    browser will display placeholder characters such as dots or asterisks, hiding
    the actual characters the user enters.
  prefs: []
  type: TYPE_NORMAL
- en: Try testing out the new login form with the username matt and password password1,
    or with any incorrect username/password combination. Thanks to PHP’s secure, handy
    password_verify() function, you should find that the form works, even though the
    database is storing password hashes rather than plaintext passwords.
  prefs: []
  type: TYPE_NORMAL
- en: Securing Database Credentials
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Another important security measure for web applications is to avoid exposing
    your database credentials. Whether you declare these credentials as class constants
    or in a completely separate file such as *.env*, as we did earlier in the chapter,
    it’s important not to have them in any public-facing files.
  prefs: []
  type: TYPE_NORMAL
- en: To begin, you should have only a single file for your credentials. If you’re
    using class constants rather than a *.env* file, I recommend having a completely
    separate class that just declares the constants. Then you can reference this class
    from your Database class (or whatever other class is responsible for establishing
    the database connection).
  prefs: []
  type: TYPE_NORMAL
- en: Next, mark the file containing your credentials to be ignored by any backup
    or archiving system. For example, if you’re using the Git distributed version
    control system, you’d list this file in your project’s *.gitignore* file.
  prefs: []
  type: TYPE_NORMAL
- en: The Doctrine ORM Library
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The open source Doctrine project is a well-maintained, fully featured PHP ORM
    library. It’s widely used; for example, the Symfony framework uses Doctrine for
    all database communications. My small ORM library is fine for small projects and
    for learning the basics, but for larger projects with many interrelated model
    classes, Doctrine is a more robust, sophisticated solution. Some of its features
    include easily facilitating object-to-object references that become foreign keys
    in the database schema and providing low-level control of the database table and
    column names beyond the default naming conventions.
  prefs: []
  type: TYPE_NORMAL
- en: After [Listing 30-5](#lis30-5) (before adding the User model class), you were
    asked to make a copy of your project. (Don’t worry if you didn’t make a copy of
    your project at that point; you can copy my listing30-05 from the book codes at
    *[https://github.com/dr-matt-smith/php-crash-course](https://github.com/dr-matt-smith/php-crash-course)*.)
    The coming sections will show you how to adapt that copy of the project to use
    Doctrine rather than my pdo-crud-for-free-repositories ORM library.
  prefs: []
  type: TYPE_NORMAL
- en: Removing the Previous ORM Library
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'First, let’s remove the previous ORM library features from the project. Enter
    the following at the command line to remove the pdo-crud-for-free -repositories
    library from the project’s */vendor* folder and *composer.json* project dependencies
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: We also need to remove the references to the old library’s DatabaseTableRepository
    class from the ProductRepository class declaration. [Listing 30-19](#lis30-19)
    shows how to update the *src/UserRepository.php* file.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 30-19: The ProductRepository class, without inheriting from the ORM
    library'
  prefs: []
  type: TYPE_NORMAL
- en: For now, we’re left with an empty class declaration, but later we’ll return
    to the class and integrate it with Doctrine.
  prefs: []
  type: TYPE_NORMAL
- en: Adding Doctrine
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Now we’ll use Composer to add the Doctrine ORM library to the project, along
    with two other required libraries. Enter the following at the command line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Doctrine requires a cache to aid its performance, and symfony/cache is the recommended
    choice. Additionally, symfony/dotenv will make it easy to access values from the
    project’s *.env* file.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we need to connect Doctrine with the database. Create a script in the
    project’s top-level directory named *bootstrap.php*, containing the code in [Listing
    30-20](#lis30-20). This script is based on Doctrine’s documentation pages at *[https://www.doctrine-project.org](https://www.doctrine-project.org)*.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 30-20: The bootstrap.php script to set up Doctrine'
  prefs: []
  type: TYPE_NORMAL
- en: We read in the Composer autoloader, create a Dotenv object to load the database
    credentials from the project’s *.env* file ❶, and package those credentials into
    a $connectionParams array. We then use this array and some Doctrine static methods
    to establish a database connection ❷ and create an EntityManager object ❸. The
    EntityManager class is key to the way Doctrine works; the class maintains the
    link between the model class objects in the PHP code and their corresponding database
    table rows defined with unique primary keys.
  prefs: []
  type: TYPE_NORMAL
- en: Any other script that reads in *bootstrap.php* will now have access to a database
    connection through the $connection variable and to Doctrine’s entity manager through
    the $entityManager variable.
  prefs: []
  type: TYPE_NORMAL
- en: Verifying That Doctrine Is Working
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Before we go any further, let’s make sure Doctrine is successfully linked with
    the project’s database. [Listing 30-21](#lis30-21) shows a simple script that
    tests Doctrine by retrieving Product objects from the database as an associative
    array. Save this script as *public/doctrine1.php*.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 30-21: The doctrine1.php script to retrieve existing rows from the
    database'
  prefs: []
  type: TYPE_NORMAL
- en: 'After reading in the autoloader and the Doctrine bootstrap script, we create
    an SQL query to select all rows from the product database table, then execute
    the query by using the Doctrine database connection (in the $connection variable).
    The results are returned as a nested array; each inner array maps the column names
    to the values in a particular row of the product database table. We loop through
    this array and print each row. If you run this *public/doctrine1.php* script,
    you should see the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: We’ve successfully retrieved the two products from the database, indicating
    that Doctrine is up and running.
  prefs: []
  type: TYPE_NORMAL
- en: Creating Database Tables
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: One of Doctrine’s strengths is its ability to update the structure of a database
    based on the classes it encounters in the application’s PHP code, creating new
    tables and columns as needed. To see how this works, let’s switch our project
    over to a new, empty database. Then we can use Doctrine to create the product
    table from scratch.
  prefs: []
  type: TYPE_NORMAL
- en: To begin, open the project’s *.env* file and change the value associated with
    the MYSQL_DATABASE key to demo2. Next, we need to write a script to create this
    new demo2 database schema. Create *db/create_database.php* and enter the contents
    of [Listing 30-22](#lis30-22).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 30-22: The db/create_database.php script to create the database named
    in the .env file'
  prefs: []
  type: TYPE_NORMAL
- en: We use a Dotenv object ❶ to read the database credentials from the *.env* file
    and create an array of connection parameters. Then, inside a try...catch block,
    we create a connection to the MySQL database server by using Doctrine’s DriverManager::getConnection()
    method ❷. We then get an array of all the database names and search that array
    for the database name from our *.env* file, storing the result (true or false)
    in the $databaseExists variable ❸.
  prefs: []
  type: TYPE_NORMAL
- en: If the database exists, we drop it by using the dropDatabase() method. Then
    we create the database anew by using the createDatabase() method ❹ and print a
    success message. If any Exception is caught ❺, we print an error message instead.
    Run this script and you should now have a new, empty database schema called demo2.
  prefs: []
  type: TYPE_NORMAL
- en: The basic usage of Doctrine is to run a command line script that reads metadata
    about model classes in the PHP code (called *entity classes* in Doctrine’s parlance)
    and executes SQL statements to create corresponding structures in the database
    schema. The command line script is usually placed in a file called */bin/doctrine*
    (without the.*php* file extension). Create this file as shown in [Listing 30-23](#lis30-23).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 30-23: The /bin/doctrine command line script'
  prefs: []
  type: TYPE_NORMAL
- en: 'This script invokes the run() method of Doctrine’s ConsoleRunner class. The
    method takes in the arguments from the command line and uses them to run whatever
    Doctrine command has been entered after bin/doctrine in the terminal. Let’s run
    this script to try updating the new database schema. Enter php bin/doctrine orm:schema-tool:create
    at the command line. You should see the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: The script hasn’t done anything because we haven’t yet added any of the necessary
    metadata for Doctrine to know which model classes and properties should be mapped
    to which database tables and columns. We’ll now add metadata to the Product model
    class so that Doctrine will have a table to create in the database. As you’ll
    see, each metadata tag is preceded by a hash mark (#) and enclosed in square brackets.
    Modify the *src/Product.php* file as shown in [Listing 30-24](#lis30-24).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 30-24: Adding Doctrine metadata to the Product class'
  prefs: []
  type: TYPE_NORMAL
- en: To keep the metadata easier to read, we start with a use statement aliasing
    the Doctrine\ORM\Mapping class as ORM. Then we add metadata to the class itself
    and to each of its properties. We declare the class as an Entity ❶, indicating
    that it should correspond to a database table, and specify that this table should
    be named product. Without the latter, Doctrine would default to Product (starting
    with a capital letter) as the table name, to match the class name.
  prefs: []
  type: TYPE_NORMAL
- en: For the class’s id property, the Id tag indicates that this property should
    be used as the primary key ❷, Column indicates the property should correspond
    to a column in the database table, and GeneratedValue means the property should
    be auto-incremented in the database system. For the remaining properties, all
    we need is the Column tag. Notice that we can either specify the database column’s
    data type as part of the Column tag or let Doctrine guess the appropriate data
    type.
  prefs: []
  type: TYPE_NORMAL
- en: 'With this metadata added, we can run our Doctrine command line script again.
    First, let’s add the --dump-sql option, which will show the SQL that Doctrine
    *would* execute, without actually executing it yet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'This shows that Doctrine will issue SQL code to create a product table with
    an auto-incrementing integer primary key id, a text description, and a floating-point
    price. Exactly what we want! Now run the command line script again without the
    --dump-sql option to execute that SQL:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Doctrine has now created the product table in the demo2 database schema.  ####
    Adding Records to a Table'
  prefs: []
  type: TYPE_NORMAL
- en: Now that we’ve used Doctrine to map our Product class to the product database
    table, we can create new Product objects and store their data in the database.
    [Listing 30-25](#lis30-25) shows the *public/doctrine2.php* script to do this.
    Add this file to the project.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 30-25: The public/doctrine2.php script to insert and retrieve a database
    row'
  prefs: []
  type: TYPE_NORMAL
- en: We create a Product object ❶ and set its description and price. Then we use
    the Doctrine EntityManager object to add this product’s data to a queue (the persist()
    method) and insert the object into the database (the flush() method).
  prefs: []
  type: TYPE_NORMAL
- en: 'To confirm this has worked, we use EntityManager to create and get a reference
    to a Doctrine repository object for the Product class ❷. This is a custom repository
    object linking the Product class with the records in the product database table.
    We use this repository object to retrieve all the records (in this case, just
    the one) from the table with the object’s findAll() method. Then we loop through
    the resulting $products array and print each object. Here’s the output of running
    this script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'This output confirms that Doctrine has successfully added the "small hammer"
    object to the product database table.  #### Integrating Doctrine into the Application
    Code'
  prefs: []
  type: TYPE_NORMAL
- en: All the code is in place now to integrate the Doctrine ORM library into our
    main web application so that we can easily map objects and database table rows.
    First, to minimize changes required throughout the application code, we’ll add
    a helper class called OrmHelper that manages access to the Doctrine EntityManager
    instance. [Listing 30-26](#lis30-26) shows how to declare this class in *src/OrmHelper.php*.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 30-26: The OrmHelper class storing and providing access to the $entityManager
    property'
  prefs: []
  type: TYPE_NORMAL
- en: This class declares a private static entityManager property, with public static
    getters and setters. We use static members to allow retrieval of a reference to
    the Doctrine EntityManager object from anywhere in our application code (after
    the variable has been set), without having to create an object or pass an object
    reference down through several constructor methods when creating the application,
    controller, or repository classes.
  prefs: []
  type: TYPE_NORMAL
- en: Notice that the setter method takes in a reference to an EntityManager object
    and passes it along to the class’s entityManager property. We’ve already created
    that reference in the *bootstrap.php* script, so we just need to read in the bootstrap
    script before invoking the setter method. We’ll do that now by updating the *public/index.php*
    script as shown in [Listing 30-27](#lis30-27).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 30-27: Updating the index.php script to bootstrap Doctrine and store
    the EntityManager object reference'
  prefs: []
  type: TYPE_NORMAL
- en: We add a require_once statement to read and run our Doctrine bootstrap script
    ❶. We add a use statement so that we can refer to the OrmHelper class in our code
    ❷. Then we store a reference to the script’s EntityManager object by calling the
    setEntityManager() static method of our OrmHelper class. This means the EntityManager
    object is now available anywhere in our web application logic via the public static
    method OrmHelper::getEntityManager().
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we need to fill out our ProductRepository class, which we left as an
    empty class declaration when we switched over to Doctrine. Our ProductController
    class expects ProductRepository to have CRUD methods like find(), findAll(), insert(),
    delete(), and so on. [Listing 30-28](#lis30-28) shows how to update *src/ProductRepository.php*
    accordingly.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 30-28: Updating ProductRepository with Doctrine-based CRUD methods'
  prefs: []
  type: TYPE_NORMAL
- en: We declare ProductRepository as a subclass of Doctrine\ORM\EntityRepository.
    This means it will inherit methods such as find() and findAll() from its parent.
    The class declares one instance variable, an EntityManager object, which is assigned
    its value in the constructor via our OrmHelper class ❶. The remaining lines in
    the constructor retrieve the required metadata about the Product class and pass
    it along to the parent class’s constructor to tailor the repository class to the
    product table ❷.
  prefs: []
  type: TYPE_NORMAL
- en: We continue the class by declaring the remaining CRUD methods our application
    expects. For insert() and update(), we use the persist() and flush() methods of
    the EntityManager object methods to add or modify a database record. The delete()
    method uses the remove() and flush() methods of the EntityManager object to remove
    a record. Finally, the deleteAll() method retrieves all objects with the inherited
    findAll() method, then loops through them to remove each one from the database.
  prefs: []
  type: TYPE_NORMAL
- en: Creating Foreign-Key Relationships
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: It may seem like we’ve done a lot of work to incorporate Doctrine while gaining
    little or no functionality beyond the previous ORM library. However, we can begin
    to see some of the real power of the Doctrine ORM library when we start creating
    foreign-key relationships between database tables and their corresponding model
    classes. In our code, we establish this relationship by adding a property to a
    model class whose value is a reference to an object of another model class. With
    the right metadata, Doctrine can see this relationship and generate all the SQL
    needed to realize it in the database.
  prefs: []
  type: TYPE_NORMAL
- en: To illustrate, let’s add a Category model class to our project along with the
    equivalent category database table. Then we’ll modify the Product model class
    so that each product is associated with a category. In the process, we’ll see
    how Doctrine manages the foreign-key relationship behind this association. [Listing
    30-29](#lis30-29) shows the *src/Category.php* script declaring the new Category
    class.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 30-29: The Category model class, including Doctrine ORM metadata'
  prefs: []
  type: TYPE_NORMAL
- en: 'The initial metadata before the class name indicates that this simple model
    class (or Doctrine entity) should correspond to a database table called category
    ❶. The class has two properties: a unique integer id and a string name. As with
    the Product class, we include a tag specifying that id is to be autogenerated
    by the database ❷. For each property, we declare basic getter and setter methods.'
  prefs: []
  type: TYPE_NORMAL
- en: Now let’s add a category property to the Product class so that each Product
    object will be associated with one Category object. [Listing 30-30](#lis30-30)
    shows how to modify *src/Product.php*.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 30-30: Adding a category property to the Product class'
  prefs: []
  type: TYPE_NORMAL
- en: We declare the category property as either NULL or a reference to a Category
    object, and give it public getter and setter methods. The metadata attribute preceding
    the property ❶ tells Doctrine that this field in the database should hold a foreign-key
    reference to a row in the category table. Here ManyToOne indicates that the foreign
    key establishes a *many-to-one* relationship, where many products can be of the
    same category, and targetEntity sets the model class (and database table) on the
    other end of the relationship.
  prefs: []
  type: TYPE_NORMAL
- en: 'Since we’ve changed the structure of the Product model class, as well as adding
    the new Category class, we need Doctrine to update the structure of the database
    accordingly. First, let’s use our *bin/doctrine* command-line script to drop the
    old product table from the database schema:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'This drops *all* tables from the schema (in our case, that’s just the product
    table). Now we’ll use the command-line script again to create the database schema
    anew, complete with the product and category tables and the foreign-key relationship
    between them. As before, we’ll first use the --dump-sql option to view the SQL
    statements Doctrine wants to run:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: This shows that Doctrine will issue SQL code to create the category and product
    tables, where product has a category_id field with a foreign-key reference to
    a category database row. Real-world databases abound with foreign-key references
    like this, and here we see how Doctrine excels at managing the SQL for these relationships
    so we don’t have to.
  prefs: []
  type: TYPE_NORMAL
- en: Run the command-line script once more without the --dump-sql option to execute
    the SQL statements and create these related database tables. To make sure the
    related tables have been successfully created in the database, we’ll write a one-off
    script creating related Product and Category objects, saving them to the database,
    and retrieving them. [Listing 30-31](#lis30-31) shows *public/doctrine3.php* implementing
    these actions. Add this file to your project.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 30-31: The public/doctrine3.php script to insert related records into
    the database'
  prefs: []
  type: TYPE_NORMAL
- en: 'We create two Category objects for HARDWARE and APPLIANCES, then store them
    in the database by using the Doctrine EntityManager object from the bootstrap
    script. Notice that we call the persist() method on each Category object individually,
    then call the flush() method once ❶; flush() will batch-process any operations
    that have been queued up for it with methods like persist(). We next use our ProductRepository
    class to create and insert two Product objects into the database, one for each
    category. Then we retrieve an array of all the products from the database with
    the ProductRepository class’s findAll() method ❷. If the array isn’t empty, we
    loop through it and print each product. Here’s the output of running this script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: Each product is shown with its associated category. With just a little bit of
    metadata in the Product model classes (the Doctrine ManyToOne attribute added
    before the category property), we’ve created a whole database of foreign-key declaration
    and storage mapping.
  prefs: []
  type: TYPE_NORMAL
- en: Overall, although switching from my simple ORM library to Doctrine added complexity
    to the code, such as the need for a bootstrap script and metadata tags in the
    model classes, Doctrine comes with added benefits like increased flexibility and
    support for foreign-key relationships. Using a popular ORM library like Doctrine
    for a project also means that developers you collaborate with will be more likely
    to already be familiar with its operations, which can save time in code development
    and maintenance. Another advantage of ORM libraries like Doctrine is that they
    allow you to seamlessly switch from one DBMS to another (such as from MySQL to
    PostgreSQL), without any of your core web application code having to change. The
    only downside may be the effort of learning the library in the first place, and
    perhaps some performance reduction due to the extra layer of abstraction. Still,
    the advantages will in many cases outweigh any minor performance reduction.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, we used my pdo-crud-for-free-repositories library to explore
    the basics of ORM libraries, seeing how they can simplify the process of working
    with a database by eliminating the need for writing a lot of repetitive code for
    CRUD applications. When we transitioned to the Doctrine ORM library, we saw that
    this more robust and feature-complete library has added benefits like greater
    flexibility and support for foreign-key associations between model classes and
    their corresponding database tables.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter also outlined important practices in web application security.
    In previous chapters, we were already using prepared SQL statements, which help
    protect against SQL injection attacks. Now we’ve added the ability to store and
    verify against hashed passwords, so we never need to store plaintext passwords
    in a database. We’ve also emphasized the importance of keeping database credentials
    in a separate file so that they won’t be published or archived and accidentally
    exposed.
  prefs: []
  type: TYPE_NORMAL
- en: Exercises
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '1.   I’ve created a publicly shared sample project to help explore the pdo-crud
    -for-free-repositories library. The project uses PHP templates (not Twig) to illustrate
    how to use the ORM library for a Movie model class and its associated MovieRepository
    class. To check out the project, do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: 'a.   Enter the following at the command line to create a new project named
    *demo1* based on my published project template:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: b.   In the *demo1* directory that was created, edit the MySQL credentials in
    the *.env* file to match your computer’s setup.
  prefs: []
  type: TYPE_NORMAL
- en: c.   Run the database setup script in *db/migrateAndLoadFixtures.php.*
  prefs: []
  type: TYPE_NORMAL
- en: d.   Run a web server and visit the home page and movie list page.
  prefs: []
  type: TYPE_NORMAL
- en: e.   Examine the Movie model class, and the listMovies() method in the Application
    class.
  prefs: []
  type: TYPE_NORMAL
- en: '2.   Use the pdo-crud-for-free-repositories library to create a MySQL CRUD
    web application for Book objects with these properties:'
  prefs: []
  type: TYPE_NORMAL
- en: id (integer), an auto-incrementing primary key
  prefs: []
  type: TYPE_NORMAL
- en: title (string)
  prefs: []
  type: TYPE_NORMAL
- en: author (string)
  prefs: []
  type: TYPE_NORMAL
- en: price (float)
  prefs: []
  type: TYPE_NORMAL
- en: You can either create a new project from scratch, extend the demo project from
    the previous exercise, or adapt your work from Exercise 2 of the previous chapter.
    You may find it helpful to adapt the database schema creation and initial data
    script from [Listing 30-12](#lis30-12), or if you’re using the demo project, you
    can adapt the database setup script in *db/migrateAndLoadFixtures.php*.
  prefs: []
  type: TYPE_NORMAL
- en: '3.   Web application security is an enormous topic (the subject of entire books),
    and covering it exhaustively here would be impossible. Learn more about PHP security
    best practices by exploring the following resources:'
  prefs: []
  type: TYPE_NORMAL
- en: The Paragon Initiative Enterprises PHP security guide, *[https://paragonie.com/blog/2017/12/2018-guide-building-secure-php-software](https://paragonie.com/blog/2017/12/2018-guide-building-secure-php-software)*
  prefs: []
  type: TYPE_NORMAL
- en: The Open Web Application Security Project, *[https://owasp.org](https://owasp.org)*
  prefs: []
  type: TYPE_NORMAL
- en: PHP The Right Way’s security chapters, by Josh Lockhart (codeguy), *[https://phptherightway.com/#security](https://phptherightway.com/#security)*
  prefs: []
  type: TYPE_NORMAL
