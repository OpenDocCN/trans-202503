- en: '12'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: FILSKA
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Images/common01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: It’s time to design our first esolang, Filska. Filska, pronounced “full-ska,”
    is a word in the dialect of the Shetland Islands. It means “high-spirited fun.”
    Whether a programming language can embody such a thing is up for reasonable debate,
    but, as with most esolangs, fun is an ingredient, so the name seems appropriate.
    (As an aside, if you happen to enjoy Scottish fiddle music, as I do, you might
    look for music by a band from Shetland with the same name. The convergence of
    names is pure chance, I assure you.)
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we’ll outline Filska’s philosophy and design. Then, we’ll create
    an interpreter for it in Python. We’ll experiment with Filska itself in [Chapter
    13](ch13.xhtml#ch13).
  prefs: []
  type: TYPE_NORMAL
- en: '**Philosophy and Design**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Filska is an answer to this question: what is it like to program in a language
    where each subprogram can manipulate only a single memory location?'
  prefs: []
  type: TYPE_NORMAL
- en: Filska works with floating-point numbers and the language itself is simple to
    make implementing the interpreter easy. As we’ve seen, this is often the case
    with esolangs. So superficially, Filska looks a bit like assembly language. We’re
    interested in the experience of trying to code in a restricted language, one where
    each subprogram is allowed to manipulate only a single memory location; therefore,
    we might be excused for making the syntax simple.
  prefs: []
  type: TYPE_NORMAL
- en: Of course, if each subprogram manipulates only its own memory location, there
    is no way to share information between subprograms. A typical solution to such
    a problem is to use a stack, á la Forth, but we’ll be even more restrictive and
    emulate simple microprocessors. Therefore, Filska supports three floating-point
    registers, X, Y, and Z, which any subprogram can manipulate along with its memory
    location. And, as with many simple microprocessors, the registers are somewhat
    limited in their abilities. We might think of each Filska subprogram as having
    its own accumulator along with access to the three index registers.
  prefs: []
  type: TYPE_NORMAL
- en: Conceptually, a Filska program looks like [Figure 12-1](ch12.xhtml#ch012fig1).
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Images/12fig01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 12-1: The conceptual structure of a Filska program*'
  prefs: []
  type: TYPE_NORMAL
- en: 'The code in [Figure 12-1](ch12.xhtml#ch012fig1) is part of the example program
    outputting the points of the Sierpiński triangle. There are three subprograms:
    `main`, `loop`, and `print`. All Filska programs have at least a `main` subprogram
    where execution begins. The similarity to assembly language is clear.'
  prefs: []
  type: TYPE_NORMAL
- en: Each subprogram is responsible for a single memory location. In [Figure 12-1](ch12.xhtml#ch012fig1),
    the values in the memory location represent a possible state of the program. The
    `set,1` instruction in `main` sets `main`’s memory location to 1.
  prefs: []
  type: TYPE_NORMAL
- en: Also indicated are the three general purpose registers, X, Y, and Z. In the
    figure, X is set to 1 because of the `tmx` instruction in `main`, which transfers
    the current subprogram’s memory value (1) to X.
  prefs: []
  type: TYPE_NORMAL
- en: There’s more to say about what’s happening in [Figure 12-1](ch12.xhtml#ch012fig1),
    but we need a better understanding of Filska first. Therefore, let’s detail Filska
    so we can implement it in Python.
  prefs: []
  type: TYPE_NORMAL
- en: '***Program Structure and Syntax***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'A Filska program is a set of one or more subprograms. Execution begins with
    the `main` subprogram, which must exist. Filska’s syntax is especially simple:
    tokens are separated by whitespace. Each token is either part of a subprogram
    declaration or an instruction associated with a subprogram. Comments are allowed;
    they begin with a double quote (`"`) and run to the end of the line.'
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 12-1](ch12.xhtml#ch012list1) shows the complete source code to a simple
    program counting from 10 down to 1.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 12-1: Counting down from 10 to 1*'
  prefs: []
  type: TYPE_NORMAL
- en: The first items to notice are the comment lines beginning with double quotes.
    As you expect, comments are ignored by the interpreter. Next, a single subprogram,
    the required `main`, is defined. Syntactically, a subprogram is an opening brace
    (`{`), a name, one or more instructions, and a closing brace (`}`). All tokens
    are separated by whitespace, implying that a complete instruction, even if it
    consists of several parts, must not have spaces within it. Again, we do this to
    make our implementation easier so we can focus on the language itself. Lastly,
    Filska is not case sensitive, so `hlt` and `HLT` are the same instruction. We’ll
    use `hlt` in the text, but in code, any combination of case is fine.
  prefs: []
  type: TYPE_NORMAL
- en: If you run the program in [Listing 12-1](ch12.xhtml#ch012list1) with
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: you’ll get output counting down from 10 to 1 with one number per line. We’ll
    walk through this example later in the chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'If this were all there is to the idea of Filska, I wouldn’t waste time with
    it. However, there are some interesting constraints that make working with the
    language a bit of a challenge. It’s also fun: Filska requires alternative thinking
    to do things that might be second nature to you if you are used to standard programming
    languages.'
  prefs: []
  type: TYPE_NORMAL
- en: We already mentioned how each Filska subprogram manipulates its own memory.
    That’s one constraint. The other constraint has to do with program flow between
    subprograms. Filska does not have a call stack. There is no idea of a subroutine
    or function. Instead, a subprogram runs and, if instructed, transfers flow to
    another subprogram. Filska only runs one subprogram at a time, so we aren’t talking
    about concurrency here.
  prefs: []
  type: TYPE_NORMAL
- en: All subprograms run forever unless instructed otherwise. If the last instruction
    in a subprogram is executed, flow starts again at the top of the subprogram. Thus,
    a single Filska subprogram acts as a loop on its own. However, the example above
    ended with a call to `hlt` (halt). If you remove the `hlt` instruction, the countdown
    will repeat forever. Try it. Use CTRL-C to quit the interpreter when you get tired
    of watching the numbers flash by.
  prefs: []
  type: TYPE_NORMAL
- en: So infinite loops are implicit in Filska. What else is there to know? Each Filska
    subprogram maintains its own program counter, which is its own pointer to the
    instruction that should be executed next. In some fashion, all the programming
    languages we used do this. If we have a function like the following in Python
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: we would expect to call `f(3)` and get a return value of 23\. If we call `f`
    a second time with a different value, say `f(4)`, we would expect it to begin
    again from the first instruction and run through the `return` to give us 40 as
    the output. The program counter for `f` resets to 0 after the first call.
  prefs: []
  type: TYPE_NORMAL
- en: In Filska, unless we are explicit about resetting them, program counters persist
    when transferring to another subprogram. We’ll see how this works in the next
    section, but for now, it means if subprogram *A* moves to subprogram *B* and,
    after some sequence of instructions, subprogram *B* moves back to subprogram *A*,
    execution of *A* will begin *with the next instruction* and not with the first
    instruction. Therefore, it is incorrect to think of Filska subprograms as subroutines,
    as they don’t reset themselves, but rather persist in their current state between
    transfers to and from them.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can express the environment in which Filska operates with the following
    statements:'
  prefs: []
  type: TYPE_NORMAL
- en: Filska programs are collections of independent subprograms.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Filska subprograms manipulate a single floating-point memory location, M.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Filska subprograms have access to three floating-point registers shared between
    them: X, Y, and Z.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Filska subprograms loop when the last instruction is executed.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Transfers between subprograms do not automatically reset the caller’s program
    counter.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This environment is nonstandard, that is, it’s different from what we are used
    to in traditional programming languages. We might think of Filska as some sort
    of weird machine from the early days of computers, but that, of course, would
    be grossly unfair to those early machines. Perhaps we can agree that Filska is
    just a bit weird, but in a good way, because working with it forces us to expand
    our thinking—the usual approach to even basic programs doesn’t always work, as
    we’ll see in [Chapter 13](ch13.xhtml#ch13).
  prefs: []
  type: TYPE_NORMAL
- en: '***Flow Control***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Filska supports five instructions affecting program flow. We’ll talk about
    four of them here and defer the fifth until we discuss comparisons. The four instructions
    are: `jpr`, `jmp`, `gto`, and `hlt`. We’ll discuss them in reverse order beginning
    with `hlt`, which, as we’ve already seen, stops the Filska program and exits.'
  prefs: []
  type: TYPE_NORMAL
- en: To control flow within a subprogram, use `gto`, which is a three-letter mnemonic
    for “goto,” the bane of early computer programming. In Filska, `gto` accepts an
    offset in terms of instructions. An offset of 1 would move to the next instruction,
    an offset of 2 would move to the instruction after that, and so forth. To go backward,
    make the offset values negative. Primitive, yes, but doing this helps simplify
    the implementation and adds another small twist to the language. If you find yourself
    writing large Filska programs, feel free to add labels to the implementation.
  prefs: []
  type: TYPE_NORMAL
- en: Use `gto` to execute an unconditional jump *within* a subprogram. For example,
    this little block of code will set the subprogram’s memory location to 0 then
    loop forever, adding 1.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: We use `gto,-1` to go back to the instruction immediately before the `gto`.
    Note the syntax `gto,<offset>`, where no spaces are allowed, the comma is required,
    and `<offset>` is an integer, that is, the number of instructions to skip. Note
    that Filska does not insist on a single instruction per line, so
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: works just as well.
  prefs: []
  type: TYPE_NORMAL
- en: To move program flow from one subprogram to another, use `jmp` or `jpr` followed
    by the new subprogram’s name. For example, in [Figure 12-1](ch12.xhtml#ch012fig1),
    the `main` subprogram transfers to `loop` with `jmp,loop`. Note that the name
    of the target subprogram is fixed. Filska does not support any form of indirection.
  prefs: []
  type: TYPE_NORMAL
- en: We said before that Filska does not reset the program counter for a subprogram
    when transferring to a new subprogram. This is true if `jmp` is used.
  prefs: []
  type: TYPE_NORMAL
- en: However, if you use `jpr` instead, then the current subprogram’s counter *is*
    reset to 0, so the next time the subprogram is started, it will start from the
    beginning.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s set up an example. First, let’s write a small program to output some numbers
    to the console, one number per line. The code is shown in [Listing 12-2](ch12.xhtml#ch012list2).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 12-2: jmp example*'
  prefs: []
  type: TYPE_NORMAL
- en: There are a few things to note in [Listing 12-2](ch12.xhtml#ch012list2). First,
    there are two subprograms, `main` and `newline`. Second, we stated already that
    `set,1` sets `main`’s memory to one. Also, `prt` will display the current subprogram’s
    memory as a floating-point number. So the first line of `main` will display `1`
    at the console.
  prefs: []
  type: TYPE_NORMAL
- en: The next line transfers control from `main` to `newline`. This subprogram sets
    its memory to 10 and calls `chr`. Recall that ASCII 10 is the character code for
    a newline character on Linux. For Windows, it’s ASCII 13\. The Filska interpreter
    is happy with either character. It’s the same as using `"\n"` in Python. The `chr`
    instruction displays the subprogram’s memory as a character. So the point of `newline`
    is to move output to the next line.
  prefs: []
  type: TYPE_NORMAL
- en: The last instruction in `newline` is `jmp,main` to transfer control back to
    `main`. But *where* in `main` will execution start? Because `main` called `newline`
    with `jmp`, `main`’s program counter was not reset, so the next instruction executed
    is `set,2` followed by another transfer of control to `newline`.
  prefs: []
  type: TYPE_NORMAL
- en: Where will `newline` pick up? Previously, it transferred control back to `main`
    with a `jmp` instruction as well, so it will pick up at the next instruction.
    However, that was the last instruction in `newline`, so, according to our design,
    program flow will loop back to the beginning, making `set,13` the next instruction
    executed.
  prefs: []
  type: TYPE_NORMAL
- en: Therefore, each `jmp` to `newline` will effectively run the entire subprogram
    again. Good. This is what we want. Similarly, each transfer to `newline` from
    `main` uses `jmp`, so when `newline` transfers back to `main`, the next instruction
    is executed.
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 12-2](ch12.xhtml#ch012list2) will output `1`, then `2`, followed by
    `3`, and then stop because of the `hlt` instruction. The jumps to `newline` ensure
    each number is on its own line in the output.'
  prefs: []
  type: TYPE_NORMAL
- en: Note that because `newline` transfers to `main` via its final instruction, it
    has the effect and feel of a subroutine or function. But don’t be fooled. If another
    subprogram were to transfer control to `newline`, the result wouldn’t be to transfer
    back to that subprogram when done. Instead, `newline` would transfer control to
    `main`.
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 12-2](ch12.xhtml#ch012list2) shows us how to use `jmp` to transfer
    control between sub-programs and how to pick up where we left off if we return
    to the transferring subprogram. Now, let’s mess things up a bit. We’ll keep the
    code of [Listing 12-2](ch12.xhtml#ch012list2), but replace the first instance
    of `jmp,newline` with `jpr,newline`, using `jpr` in the place of `jmp`.'
  prefs: []
  type: TYPE_NORMAL
- en: If you make this change and run the code, you won’t see `1`, `2`, `3` at the
    console. Instead, you’ll see `1` repeating forever until you hit CTRL-C. Why?
    Because `jpr` transfers control to a new subprogram, just like `jmp`, but it also
    resets the caller’s program counter to 0\. So when `main` transfers control to
    `newline`, `main`’s program counter is set to 0, causing it to pick up at `set,1`
    again when `newline` transfers back to `main`. This sets up an endless loop that
    outputs `1` repeatedly.
  prefs: []
  type: TYPE_NORMAL
- en: As an exercise, restore the `jmp,newline` instruction in `main`, replace `jmp,main`
    in `newline` with `jpr,main`, and run the code. Is there any difference in the
    output compared to our earlier output? If not, why?
  prefs: []
  type: TYPE_NORMAL
- en: The answer is no, there is no difference; both versions output `1`, `2`, and
    `3` at the console. This is because the transfer back to `main` from `newline`
    is the *last* instruction, so resetting `newline`’s program counter is irrelevant
    in this case. If the program counter is reset, `newline` starts from its first
    instruction. If the program counter isn’t reset, it will loop back around to the
    beginning and start with the first instruction anyway.
  prefs: []
  type: TYPE_NORMAL
- en: '[Table 12-1](ch12.xhtml#ch012tab1) summarizes Filska’s flow control instructions.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 12-1:** Flow Control Instructions'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Instruction** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `*jmp*` | Transfer to a new subprogram and preserve the caller’s program
    counter. |'
  prefs: []
  type: TYPE_TB
- en: '| `*jpr*` | Transfer to a new subprogram and reset the caller’s program counter.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `*gto*` | Jump forward or backward within the current subprogram. |'
  prefs: []
  type: TYPE_TB
- en: '| `*hlt*` | Halt. Stop the program immediately and exit. |'
  prefs: []
  type: TYPE_TB
- en: Let’s move on now to see how Filska handles its little bit of memory.
  prefs: []
  type: TYPE_NORMAL
- en: '***Memory***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: We already know that each Filska subprogram manages a single floating-point
    number. We also know subprograms share access to three floating-point index registers.
    Let’s look at the instructions that manipulate these data values.
  prefs: []
  type: TYPE_NORMAL
- en: To set a subprogram’s memory, use `set`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The only way to directly set a memory value to a constant is via `set`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Several instructions transfer subprogram memory to or from an index register.
    The form of the instruction is straightforward: the source of the data comes before
    the destination. So to transfer a memory value to the X register, use `tmx`. Similarly,
    to transfer memory to the Z register, use `tmz`. To move data from an index register
    to memory, reverse the letters. Therefore, `tym` moves the current value of the
    Y register to memory.'
  prefs: []
  type: TYPE_NORMAL
- en: The transfer instructions are destructive, meaning that the destination value
    is overwritten. The `swp` instruction swaps two data values instead. The instruction
    takes a two-letter argument representing the two data sources to swap. The current
    subprogram’s memory is denoted as `M`. For example,
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: will first swap memory and the X register and then swap the Y and Z register
    values.
  prefs: []
  type: TYPE_NORMAL
- en: Filska does not support arrays or any form of heap memory, so that immediately
    precludes many possible programs. However, there is no practical upper bound on
    the number of subprograms allowed, so creative programming might mimic some larger
    memory operations. [Listing 12-3](ch12.xhtml#ch012list3) shows how to use a subprogram
    as a set-once, read-many memory location.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 12-3: Using a subprogram as ROM*'
  prefs: []
  type: TYPE_NORMAL
- en: The main program of [Listing 12-3](ch12.xhtml#ch012list3) loads the X register
    with 123 by first setting `main`’s memory to 123 followed by a transfer to the
    X register ➊. Then, a `jmp` to `mem` moves the 123 from X to `mem`’s memory. Just
    to show we can, we increment the memory before returning to `main` via `jmp`.
  prefs: []
  type: TYPE_NORMAL
- en: This first call to `mem` sets the local data value to 124 (as we incremented
    it). Subsequent calls to `mem` from `main` will start `mem` at the `tmx` instruction
    to transfer the 124 to the X register. In `main`, we set its memory to 1 and print
    it at the console along with a newline character to show that `main`’s memory
    is now changed ➋.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we make three calls to `mem`. After each call, the X register will contain
    `mem`’s local data value (124). Back in `main`, we transfer the X value to `main`’s
    memory and print it at the console ➌. It is not hard to imagine using a second
    index register, say Y, as an argument of sorts to tell `mem` to set its local
    memory to whatever is in X instead of setting X to the local memory.
  prefs: []
  type: TYPE_NORMAL
- en: '***Arithmetic***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: By *arithmetic* we mean binary math operations like addition and multiplication.
    The full list of supported binary operations is in [Table 12-2](ch12.xhtml#ch012tab2).
    The general format of the instruction is
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: with `<op>` being the command, `<dst>` the destination, and `<op1>` and `<op2>`
    the operands. The infix version is `<dst> = <op1><op><op2>` as in *c* = *a – b*.
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 12-2:** Binary Arithmetic Instructions'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Instruction** | **Example** | **Operation** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `*add*` | `*add*, *m*=*xy*` | Addition, *M* ← *X* + *Y* |'
  prefs: []
  type: TYPE_TB
- en: '| `*sub*` | `*sub*, *x*=*yz*` | Subtraction, *X* ← *Y – Z* |'
  prefs: []
  type: TYPE_TB
- en: '| `*mul*` | `*mul*, *z*=*xy*` | Multiplication, *Z* ← *X* × *Y* |'
  prefs: []
  type: TYPE_TB
- en: '| `*div*` | `*div*, *m*=*zx*` | Division, *M* ← *Z* ÷ *X* |'
  prefs: []
  type: TYPE_TB
- en: '| `*mod*` | `*mod*, *y*=*mz*` | Modulo, *Y* ← *M* mod *Z* |'
  prefs: []
  type: TYPE_TB
- en: '| `*pow*` | `*pow*, *z*=*xy*` | Power, *Z* ← *X*^(*Y*) |'
  prefs: []
  type: TYPE_TB
- en: You’ll notice from the examples in [Table 12-2](ch12.xhtml#ch012tab2) that the
    operands and the destination must be subprogram memory or one of the index registers.
    No constants are allowed. However, any combination of memory and registers is
    permitted. And as usual, to simplify the implementation, no spaces are allowed
    in the command.
  prefs: []
  type: TYPE_NORMAL
- en: '***Comparisons***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Filska handles logical comparisons via a flags register and two instructions.
    The flags register is a list of Boolean values indicating the result of the most
    recent comparison instruction (`cmp`). The flags are zero (`Z`), equal (`E`),
    less than (`L`), and greater than (`G`). The `cmp` instruction accepts a single
    argument and compares it to the subprogram’s memory, setting the appropriate flags
    as needed. The argument is a constant or one of the index registers.
  prefs: []
  type: TYPE_NORMAL
- en: For example, these instructions first set memory and then call `cmp`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: The comparison asks about the relationship between memory and the current value
    of the X index register. Let’s say X is 4\. The comparison code is
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: with `mem` being the current subprogram’s memory and `n` being the value of
    the X register.
  prefs: []
  type: TYPE_NORMAL
- en: 'Which flags are set depends on the values, but for this example, 3 < 4, so
    the `L` flag will be set and the others will remain unset. If X were 3, the `E`
    flag would be set instead. Now, consider these instructions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: In this case, `cmp` will set two flags. First, it will set the `L` flag because
    0 < 5\. Second, `cmp` will also set the zero flag (`Z`) because memory is 0.
  prefs: []
  type: TYPE_NORMAL
- en: The code above actually sets the zero flag twice. Checking whether a value is
    0 is so common that all of Filska’s instructions that modify subprogram memory
    check if the result is 0 and if so, set the zero flag. So the `set,0` instruction
    set the zero flag even before the `cmp` instruction, which sets it a second time.
    We’ll often use this fact in our example programs to branch on memory becoming
    0 without an explicit call to `cmp`. Note that even the transfer instructions
    affect the zero flag when moving values from the index registers to subprogram
    memory.
  prefs: []
  type: TYPE_NORMAL
- en: 'If `cmp` performs tests and sets flags, how do we act on the results? That’s
    where the test instruction, `tst`, comes into play. The `tst` instruction branches
    within the current subprogram based on the value of a flag. The syntax of the
    instruction is `tst,<flag>,<offset>`. For example, consider this sequence of instructions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: We first set memory to 1 and then execute `tst` to branch forward 10 instructions
    if the zero flag is set. Assigning a 1 to memory does not set the zero flag, so
    the `tst` instruction does not branch and execution continues with the next instruction.
    The `dec` instruction decrements memory, making it 0\. This operation *does* set
    the zero flag, so the next `tst` instruction will branch eight instructions forward.
    Note that branching eight instructions forward from the second `tst` instruction
    sets the program counter to the same instruction that the first `tst` instruction
    was targeting.
  prefs: []
  type: TYPE_NORMAL
- en: 'To test for conditions other than memory is 0, use `cmp` followed by the `tst`
    instruction. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: These instructions compare memory to X and branch backward if memory is less
    than or equal to X. Note that for the equal test to branch to the same location
    as the less-than test, we must account for the presence of the less-than `tst`
    instruction, which explains using *–*15 and *–*16, respectively.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `tst` instruction’s first argument is the flag to test: `Z`, `L`, `G`,
    or `E`. However, `tst` accepts one more flag, `N`, which means “not zero.” We
    saw this version of `tst` in [Listing 12-1](ch12.xhtml#ch012list1) earlier.'
  prefs: []
  type: TYPE_NORMAL
- en: '***Mathematical Functions***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Filska’s intended use is to crunch numbers. That’s why it manipulates floating-point
    values. To that end, Filska supports a set of mathematical functions, all of which
    operate on the current subprogram’s memory. [Table 12-3](ch12.xhtml#ch012tab3)
    has the complete set of supported functions.
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 12-3:** Filska’s Mathematical Functions'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Instruction** | **Operation** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `inc` | *M* ← *M* + 1 | Increment memory by one |'
  prefs: []
  type: TYPE_TB
- en: '| `dec` | *M* ← *M –* 1 | Decrement memory by one |'
  prefs: []
  type: TYPE_TB
- en: '| `sin` | *M* ← *sin*(*M*) | Sine of *M* (radians) |'
  prefs: []
  type: TYPE_TB
- en: '| `cos` | *M* ← *cos*(*M*) | Cosine of *M* (radians) |'
  prefs: []
  type: TYPE_TB
- en: '| `tan` | *M* ← *tan*(*M*) | Tangent of *M* (radians) |'
  prefs: []
  type: TYPE_TB
- en: '| `asn` | *M* ← *sin* ^(*–*1) (*M*) | Inverse sine of *M* (radians) |'
  prefs: []
  type: TYPE_TB
- en: '| `acs` | *M* ← *cos* ^(*–*1) (*M*) | Inverse cosine of *M* (radians) |'
  prefs: []
  type: TYPE_TB
- en: '| `atn` | *M* ← *tan* ^(*–*1) (*M*) | Inverse tangent of *M* (radians) |'
  prefs: []
  type: TYPE_TB
- en: '| `log` | *M* ← *log*(*M*) | Natural log |'
  prefs: []
  type: TYPE_TB
- en: '| `exp` | *M* ← *e*^(*M*) | Exponential |'
  prefs: []
  type: TYPE_TB
- en: '| `flr` | *M* ← ⌊*M* ⌋ | Floor of *M* |'
  prefs: []
  type: TYPE_TB
- en: '| `cel` | *M* ← ⌈*M* ⌉ | Ceiling of *M* |'
  prefs: []
  type: TYPE_TB
- en: '| `rnd` | *M* ← *U*[0, 1) | Uniform random number, [0, 1) |'
  prefs: []
  type: TYPE_TB
- en: '| `neg` | *M* ← *–M* | Negation of *M* |'
  prefs: []
  type: TYPE_TB
- en: '| `sqr` | ![Image](Images/f0329-01.jpg) | Square root of *M* |'
  prefs: []
  type: TYPE_TB
- en: The set of functions in [Table 12-3](ch12.xhtml#ch012tab3) are the minimal set
    supported by most programming languages. With these, it’s possible to implement
    many mathematical expressions, at least in pieces.
  prefs: []
  type: TYPE_NORMAL
- en: Internally, our implementation of Filska will use Python floats, meaning IEEE
    754 *binary64* values (C `double`). We have a good range available numerically,
    but if our algorithm naturally uses integers, we might be limited a bit, as we
    will not take advantage of Python’s abilities with arbitrary-sized integers. We’ll
    see this effect in [Chapter 13](ch13.xhtml#ch13) when we develop a Filska program
    to output the Fibonacci sequence.
  prefs: []
  type: TYPE_NORMAL
- en: '***Input and Output***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Filska supports three input/output instructions: `prt`, `chr`, and `ipt`. The
    first two we’ve seen several times already in the examples above. Use `prt` to
    output subprogram memory as a floating-point number. Filska’s implementation does
    check to see if memory is actually an integer and outputs it with an integer format
    if so. Otherwise, the format is explicitly for floating-point with 10 digits after
    the decimal.'
  prefs: []
  type: TYPE_NORMAL
- en: The `chr` instruction interprets memory as an ASCII code. This casts memory
    to an integer and then keeps only the lowest eight bits to ensure it is in the
    range [0, 255]. Then, it outputs the character associated with the resulting ASCII
    value.
  prefs: []
  type: TYPE_NORMAL
- en: The final instruction, `ipt`, accepts input from the user as a floating-point
    number. If the input received cannot be properly interpreted as a floating-point
    number, `ipt` unceremoniously returns 0\. The `ipt` instruction sets the zero
    flag as well.
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 12-4](ch12.xhtml#ch012list4) is a simple program that asks the user
    for a number and multiplies it by 2.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 12-4: Getting input from the user*'
  prefs: []
  type: TYPE_NORMAL
- en: The program first prints a `?` and then uses `ipt` to set memory to whatever
    number the user enters. Filska does not allow constants in arithmetic operations,
    so to multiply memory by 2, the user’s value is moved to the X register and memory
    is set to 2\. The `mul` instruction multiplies memory and X stores the result
    in memory. Next, the program prints the product (`prt`) with a newline character
    and then halts.
  prefs: []
  type: TYPE_NORMAL
- en: Input and output to the console are as straightforward as can be; however, when
    combined with input/output redirection, Filska can operate on a file and produce
    a new file as output. A simple modification to [Listing 12-4](ch12.xhtml#ch012list4)
    makes it possible to multiply a file of numbers by 2 (see [Listing 12-5](ch12.xhtml#ch012list5)).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 12-5: Multiplying a file by 2*'
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 12-5](ch12.xhtml#ch012list5) removes the question mark prompt and
    `hlt` instruction to make `main` loop forever. By design, Filska exits if the
    call to `ipt` fails for some reason, including if reading from a redirected file
    fails.'
  prefs: []
  type: TYPE_NORMAL
- en: To try [Listing 12-5](ch12.xhtml#ch012list5), first create a file of numbers,
    one per line. I used 1 through 10\. Ensure the final number does not have an empty
    line after it, as empty lines are read as 0\. With the file of numbers in place,
    run the program.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Assuming you stored the code in *example_input_file.filska* and your table of
    numbers in *input.txt*, you should see your table output at the console with each
    number multiplied by 2\. Naturally, you can redirect Filska output to a different
    file.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we know what Filska is as a language and the instructions it supports,
    let’s implement it in Python.
  prefs: []
  type: TYPE_NORMAL
- en: '**Implementating Filska**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this section, we’ll implement portions of Filska. I won’t be so pedantic
    as to dump every line of Python code on you here. The code for Filska is in the
    file *Filska.py*. Please read through it. All told, *Filska.py* is less than 700
    lines, including comments and blanks.
  prefs: []
  type: TYPE_NORMAL
- en: Here, we’ll detail the essential parts of the implementation. For example, a
    single instance of a particular class of instruction is all you need to understand
    the implementation of the entire class.
  prefs: []
  type: TYPE_NORMAL
- en: Therefore, we’ll present the implementation in a top-down fashion, starting
    with the code’s overall structure and operation. Then we’ll discuss parsing, which
    is especially easy given Filska’s design, and the execution loop.
  prefs: []
  type: TYPE_NORMAL
- en: Next comes an example of an instruction without arguments, followed by instructions
    that accept arguments. Lastly, we’ll end with flow control within and between
    subprograms. Again, I assume that you’ll look at *Filska.py* yourself. After all,
    at this point in the book we’ve gained enough experience with source code to learn
    directly from it most of the time.
  prefs: []
  type: TYPE_NORMAL
- en: '***Overall Structure and Operation***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Conceptually, a Filska interpreter parses the input source code into tokens,
    ignoring comments, and sorts those tokens into a dictionary of subprograms indexed
    by the subprogram name. Each subprogram has an associated local memory value,
    local flags, and a local program counter, an index into the subprogram’s token
    list. Tokens, memory, flags, and program counters are stored in Python dictionaries,
    each indexed by the subprogram name. Execution happens one token at a time for
    the current subprogram, looping at the end of the subprogram, and persisting the
    program counter between transfers to and from other subprograms, unless the `jpr`
    instruction is used, in which case the subprogram’s counter is set to 0.
  prefs: []
  type: TYPE_NORMAL
- en: The Filska interpreter itself is a single Python class, `Filska`. The constructor
    expects a string, the text of the code to be run, and, optionally, a Boolean flag
    to turn on runtime execution tracing. We’ll get to tracing later on when we start
    working with our example programs. We won’t look at how tracing is implemented
    here. Review the Filska source code to see how it’s done.
  prefs: []
  type: TYPE_NORMAL
- en: Using a class to implement a Filska interpreter enables the easy embedding of
    Filska into another program. Why you’d want to embed a Filska interpreter is a
    reasonable question, but you can if you want a quirky scripting language for your
    larger application. Modifications to Filska’s input/output instructions might
    make embedding more attractive. Imagine a version of the `Run` method (see below)
    that accepts a list of inputs and returns the program output as a list of tokens,
    and so on.
  prefs: []
  type: TYPE_NORMAL
- en: When run from the command line, Filska expects the program’s name and an optional
    `-t` flag to turn on execution tracing. On startup, Filska runs `main`, the traditional
    name for a Python program’s startup function (see [Listing 12-6](ch12.xhtml#ch012list6)).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 12-6: Creating a Filska interpreter from the command line*'
  prefs: []
  type: TYPE_NORMAL
- en: If no arguments are given, Filska displays a short usage message (not shown
    in the listing). Otherwise, `main` looks to see if a second command line argument
    is present and sets `trace` appropriately. The following line creates an instance
    of a Filska interpreter passing in the actual text of the program to run. Next,
    execution begins with a call to `Run`.
  prefs: []
  type: TYPE_NORMAL
- en: The constructor defines state member variables, including the index registers,
    a dictionary holding per subprogram memory (`mem`), a dictionary of subprogram
    instructions (`prog`), the per subprogram program counter (`PC`), and the name
    of the currently running subprogram (`CP`) initialized to `main`. The status flags
    come next (`flags`), also defined as a dictionary. Dictionaries are used for memory,
    program text, program counters, and status flags to isolate subprogram state.
    The only link between subprograms is the ability for each subprogram to interact
    with the shared index registers.
  prefs: []
  type: TYPE_NORMAL
- en: Filska programs are tokenized; therefore, running a subprogram means interpreting
    token by token. When instructions are encountered as tokens, the instruction is
    parsed if there are arguments. Then the instruction is looked up in a table, `exe`,
    which holds references to Python methods implementing the function.
  prefs: []
  type: TYPE_NORMAL
- en: '***Parsing***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Parsing a Filska program means splitting the source code string into tokens,
    ignoring comments, and separating the subprogram tokens and storing them in the
    `prog` dictionary. The `Parse` method tokenizes a program string to return a list
    of tokens. Next, `InitializeProg` sorts the subprograms and places them in the
    `prog` dictionary.
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 12-7](ch12.xhtml#ch012list7) shows how to split a source code string
    into tokens separated by whitespace.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 12-7: Tokenizing the source code*'
  prefs: []
  type: TYPE_NORMAL
- en: Filska comments begin with a double quote (`"`) and run to the end of the line.
    The `Parse` method scans the input source code character by character, keeping
    all characters that are not part of a comment line. This means a double quote
    is not allowed as part of a token.
  prefs: []
  type: TYPE_NORMAL
- en: With comments removed, the `return` statement uses standard Python functionality
    to first split on whitespace and then join again with a single space between tokens.
    The new string is made uppercase, thereby requiring Filska to be case insensitive,
    so `main` and `MAIN` refer to the same subprogram. Lastly, the last call to `split`
    tokenizes the program text returning a Python list of tokens.
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 12-8](ch12.xhtml#ch012list8) scans the list of tokens looking for
    opening braces (`{`).'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 12-8: Separating subprogram text*'
  prefs: []
  type: TYPE_NORMAL
- en: When the parser encounters an opening brace, a new subprogram starts. The `ExtractProg`
    method captures the subprogram’s tokens using the first token as the new subprogram
    name. Subprogram state, meaning memory, program counter, and flags, is also defined
    at the same time.
  prefs: []
  type: TYPE_NORMAL
- en: When `InitializeProg` exits, all subprograms have been defined and all their
    states initialized. The Filska program is then ready to execute with a call to
    `Run`.
  prefs: []
  type: TYPE_NORMAL
- en: '***The Execution Loop***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The `Run` method starts the execution loop (see [Listing 12-9](ch12.xhtml#ch012list9)).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 12-9: The execution loop*'
  prefs: []
  type: TYPE_NORMAL
- en: The execution loop is quite short. If not in trace mode, `Run` is nothing more
    than an endless loop that executes instruction after instruction until `hlt` quits
    inside `Execute` or the user hits CTRL-C. The value of `naptime` controls the
    overall speed of a Filska program. The default sleep time is 0.00001 seconds,
    which basically means “run as fast as possible.”
  prefs: []
  type: TYPE_NORMAL
- en: The `Execute` method in [Listing 12-10](ch12.xhtml#ch012list10) executes a single
    instruction of the current subprogram.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 12-10: Executing a single instruction*'
  prefs: []
  type: TYPE_NORMAL
- en: First, the current program (`prog`), program counter (`pc`), flags, and local
    memory (`mem`) are loaded for the current subprogram (`CP`). Next, the instruction
    executes by calling `Exec`, which we’ll detail shortly. When `Exec` returns, it
    passes back updated values for the current subprogram, program counter, local
    memory, and local flags. The state of the current subprogram is updated along
    with the name of the current subprogram if a `jmp` or `jpr` instruction was executed.
    Notice that `mem`, `pc`, and `flags` are updated first before the current subprogram
    name, as they refer to the subprogram whose instruction was just executed. If
    transferring to a new subprogram, the new subprogram’s flags are reset.
  prefs: []
  type: TYPE_NORMAL
- en: The `Exec` method in [Listing 12-11](ch12.xhtml#ch012list11) is responsible
    for processing a single instruction.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 12-11: Evaluating a single instruction*'
  prefs: []
  type: TYPE_NORMAL
- en: '`Exec` receives the token representing the instruction (`inst`), the number
    of instructions in the current subprogram (`proglen`), the current value of subprogram
    memory (`mem`), the program counter (`pc`), and the flags (`flags`). `Exec` returns
    the name of the subprogram to execute next (`cp`), which is usually unchanged,
    and the updated state for the subprogram whose instruction was just executed.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Each Filska instruction is processed by a method with the same name as the
    instruction. If the instruction affects flow control, like `jmp`, `jpr`, `gto`,
    or `tst`, it is processed with a varying set of arguments and return values. We’ll
    return to these instructions shortly. All other instructions follow the same format:
    they accept any remaining instruction text (`rest` ➊), memory, and flags as input,
    and return updated memory and flags ➋. Because most Filska instructions do not
    affect program flow, the program counter is updated by adding 1 and rolling over
    to 0 if the subprogram’s length is exceeded ➌.'
  prefs: []
  type: TYPE_NORMAL
- en: '***Instructions Without Arguments***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Non-flow control instructions come in two varieties: with arguments and without
    arguments. Let’s see how Filska instructions without arguments are implemented.'
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 12-12](ch12.xhtml#ch012list12) implements the `cos` instruction.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 12-12: A representative no-argument instruction*'
  prefs: []
  type: TYPE_NORMAL
- en: The arguments are any remaining portion of the instruction token after the three-character
    instruction has been removed, the current subprogram’s memory value, and the associated
    flags. For no-argument instructions, `rest` is an empty string. No-argument instructions
    operate on the subprogram’s memory or one of the index registers. Here, the cosine
    of memory is used to update it. As with almost all Filska instructions, a 0 result
    sets the zero flag. All instruction implementations return any new value of the
    memory and any updated flags.
  prefs: []
  type: TYPE_NORMAL
- en: '***Instructions with Arguments***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Filska instructions with arguments include `set`, `swp`, and all binary math
    operators. Of the latter, we’ll only detail `add`, as the others operate similarly.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s begin with `SET` (see [Listing 12-13](ch12.xhtml#ch012list13)). The `swp`
    instruction is similar.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 12-13: Implementation of SET*'
  prefs: []
  type: TYPE_NORMAL
- en: The single argument passed to `SET`, meaning the text of the token beyond the
    string `SET`, is in `rest`. Filska attempts to interpret `rest` as a floating-point
    number and uses 0 if the conversion fails. Naturally, a more sophisticated approach
    would issue an error message, but we can live with the simplification. If `n`
    is 0, the zero flag is set, and the updated memory value and flags returned (see
    [Listing 12-14](ch12.xhtml#ch012list14)).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 12-14: Implementation of ADD*'
  prefs: []
  type: TYPE_NORMAL
- en: Binary math operations like `ADD` use a four-character argument of the form
    <dst>= <op1><op2>. where <dst> is a destination, either memory or an index register,
    and <op1> and <op2> are sources. Memory is denoted as `M` and index registers
    by their names.
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 12-14](ch12.xhtml#ch012list14) implements addition. The text of the
    argument is in `rest`, as with `SET`. Interpretation of the argument happens in
    the `ops` method, which returns the operand values and the destination register’s
    name (or memory). The operation `ADD` adds the two operands (`ans`) and updates
    memory or index registers based on the destination by calling the `assign` method.
    The other binary operations are similarly implemented, differing only in the line
    defining `ans`.'
  prefs: []
  type: TYPE_NORMAL
- en: The `ops` method parses the four-character argument returning numeric values
    pulled from memory, or the index registers for the operands and the single character
    indicating the destination. The `assign` method takes the result, destination,
    current memory value, and flags, and updates the proper destination with the result.
    If the destination is memory and 0, the zero flag is also updated. Lastly, memory
    and flags are returned.
  prefs: []
  type: TYPE_NORMAL
- en: '***Flow Control Instructions***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Instructions controlling program flow are implemented separately, as their inputs
    and outputs vary depending on the instruction. We’ll begin with the jump instructions
    (`JMP` and `JPR`, which transfer program flow between subprograms (see [Listing
    12-15](ch12.xhtml#ch012list15)).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 12-15: The JMP and JPR instructions*'
  prefs: []
  type: TYPE_NORMAL
- en: The only implementation difference between `JMP` and `JPR` is how the program
    counter of the current subprogram is modified. For `JMP`, the program counter
    is incremented, rolling over if necessary, so the next transfer to the current
    subprogram begins with the instruction following `JMP`. For `JPR`, the program
    counter is set to 0 instead. Both instructions return the name of the subprogram
    to which execution is transferred.
  prefs: []
  type: TYPE_NORMAL
- en: The remaining flow control instructions, `GTO` and `TST`, operate within the
    current subprogram. [Listing 12-16](ch12.xhtml#ch012list16) presents the `GTO`
    instruction.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 12-16: Unconditional jump within a subprogram*'
  prefs: []
  type: TYPE_NORMAL
- en: The `GTO` instruction’s argument is an integer offset to the current program
    counter value, that is, a relative number of instructions to branch from the current
    instruction. First, `GTO` extracts the `offset` from the instruction text and
    converts it to an integer. If the conversion fails, the offset is silently set
    to 1 to move to the next instruction. Updating the program counter comes next.
    The instruction adds the offset, which may be positive or negative, to the program
    counter, with suitable checks for jumping too far back or forward. The updated
    program counter value is then returned.
  prefs: []
  type: TYPE_NORMAL
- en: The most complex Filska instruction is `TST` (see [Listing 12-17](ch12.xhtml#ch012list17)).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 12-17: Conditional branching within a subprogram*'
  prefs: []
  type: TYPE_NORMAL
- en: The first part of the `TST` instruction examines the first argument, the flag
    to test ➊. The current value of the flag is put into `v`. Notice how checking
    for “not zero” asks if the zero flag is currently false. The second part of the
    instruction interprets the offset argument if the desired flag is set ➋. This
    code matches `GTO` in that the offset is extracted and added to the program counter.
    If the flag is not set, the program counter is incremented as usual ➌.
  prefs: []
  type: TYPE_NORMAL
- en: The core of Filska is in the code above, but not all of it. Again, please spend
    some time reading through *filska.py* to familiarize yourself with the entire
    implementation.
  prefs: []
  type: TYPE_NORMAL
- en: '**Summary**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This chapter introduced Filska by discussing its design and the thinking behind
    it. We then detailed key portions of the Python implementation to see an embodiment
    of the design.
  prefs: []
  type: TYPE_NORMAL
- en: Now that Filska exists, let’s try to write some programs with it.
  prefs: []
  type: TYPE_NORMAL
