["```\npayload = {\n  ❶ \"token\": \"alphanumeric_code\",\n  ❷ \"radio\": \"cdma\",\n    \"mnc\": 120,\n  ❸ \"mcc\": 310,\n  ❹ \"cells\": [{\n      ❺ \"lac\": 23319,\n        \"cid\": 192337670\n    }],\n  ❻ \"address\": 1\n}\n```", "```\ndef lookup_tower(payload):\n    url = \"https://us1.unwiredlabs.com/v2/process.php\"\n    response = requests.request(\"POST\", url, data=json.dumps(payload))\n        return json.loads(response.text)\n```", "```\n{\n    \"status\":string,\n    \"balance\":int,\n    \"lat\":float,\n    \"lon\":float,\n    \"accuracy\":int,\n    \"address\":string\n}\n```", "```\nwith open(\"cellular_networks.json\") as f:\n    cells = json.load(f)[\"cells\"]\ntower_locs = []\n❶ for c in cells:\n  ❷ payload[\"cells\"] = c\n  ❸ tower_loc = lookup_tower(payload)\n  ❹ tower_locs.append(tower_loc)\n```", "```\nimport pandas as pd\nimport geopandas as gpd\n\ntower_df = pd.DataFrame(tower_locs)\ntower_df.drop([\"status\", \"balance\"], axis=1, inplace=True)\ngeo_df = gpd.GeoDataFrame(\n    tower_df,\n    geometry=gpd.points_from_xy(tower_df.lat, tower_df.lon)\n)\n```", "```\n# A normal function\ndef complex(a, b, c, d, x):\n    print(f\"you sent in {a},{b},{c},{d},{x}\")\n```", "```\nimport functools\n# A partial function that simplifies the previous one\nsimple = functools.partial(complex, 1, 1, 2, 3)\nsimple(5)\n```", "```\nyou sent in 1,1,2,3,5\n```", "```\nimport pyproj\nfrom functools import partial\nfrom shapely.geometry import Point \nfrom shapely.ops import transform\n\ndef get_shapely_circle(x):\n    lat = x[\"lat\"]\n    lon = x[\"lon\"]\n    radius = x[\"accuracy\"]\n  ❶ az_proj = \"+proj=aeqd +R=6371000 +units=m +lat_0={} +lon_0={}\"\n  ❷ wgs84_to_aeqd = partial(\n        pyproj.transform,\n        pyproj.Proj(\"+proj=longlat +datum=WGS84 +no_defs\"),\n        pyproj.Proj(az_proj.format(lat, lon))\n    )\n  ❸ aeqd_to_wgs84 = partial(\n        pyproj.transform,\n        pyproj.Proj(az_proj),\n        pyproj.Proj(\"+proj=longlat +datum=WGS84 +no_defs\"),\n    )\n❹center = Point(float(lon), float(lat))\n❺point_t = transform(wgs84_to_aeqd, center)\n ❻ buffer = point_t.buffer(radius)\n    # Get the polygon with lat lon coordinates.\n  ❼ circle_poly = transform(aeqd_to_wgs84, buffer)\n    return circle_poly\n\n❽ geo_df[\"geometry\"] = geo_df.apply(get_shapely_circle, axis=1)\n```", "```\nEMPTY = GeometryCollection()\ndef partition(poly_a, poly_b):\n    if not poly_a.intersects(poly_b):\n        return poly_a, poly_b, EMPTY\n    only_a = poly_a.difference(poly_b)\n    only_b = poly_b.difference(poly_a)\n    inter = poly_a.intersection(poly_b)\n    return only_a, only_b, inter\n```", "```\ndef cascaded_intersections(poly1, lst_poly):\n  ❶ result = [(lst_poly[0], (0,))]\n    for i, poly in enumerate(lst_poly[1:], start=1):\n        current = []\n        while result:\n            r_geo, res_idxs = result.pop(0)\n          ❷ only_res, only_poly, inter = partition(r_geo, poly)\n          ❸ for geo, idxs in ((only_res, res_idxs), (inter, res_idxs + (i,))):\n                if not geo.is_empty:\n                    current.append((geo, idxs))\n      ❹ curr_union = cascaded_union([elt[0] for elt in current])\n        only_poly = poly.difference(curr_union)\n      ❺ if not only_poly.is_empty:\n            current.append((only_poly, (i,)))\n        result = current\n      ❻ for r in range(len(result)-1, -1, -1):\n            geo, idxs = result[r]\n          ❼ if poly1.intersects(geo):\n                inter = poly1.intersection(geo)\n                result[r] = (inter, idxs)\n else:\n                del result[r]\n    only_poly1 = poly1.difference(cascaded_union([elt[0] for elt in result]))\n  ❽ only_poly1 = eliminate_small_areas(only_poly1, 1e-16*poly1.area)\n    if not only_poly1.is_empty:\n        result.append((only_poly1, None))\n    return [r[0] for r in result]\n\n❾ polys = list(geo_df[\"geometry\"])\n❿ results = cascaded_intersections(polys[0], polys[1:])\n```", "```\nx,y = results[1].exterior.xy\nprint(f\"\"\"Search bounded area:\n({min(y)}, {min(x)})\nto\n({max(y)}, {max(x)})\"\"\")\n```", "```\nSearch bounded area:\n(47.61858939197041, -122.35438376445335)\nto\n(47.6221396080296, -122.34381687278278)\n```", "```\ndef eliminate_small_areas(poly, small_area):\n  ❶ if isinstance(poly, Polygon):\n        if poly.area < small_area:\n            return EMPTY\n        else:\n            return poly\n  ❷ assert isinstance(poly, MultiPolygon)\n  ❸ l = [p for p in poly if p.area > small_area]\n  ❹ if len(l) == 0:\n        return EMPTY\n  ❺ if len(l) == 1:\n        return l[0]\n  ❻ return MultiPolygon(l)\n```"]