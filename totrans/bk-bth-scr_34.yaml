- en: <hgroup>
  prefs: []
  type: TYPE_NORMAL
- en: 31 TROUBLESHOOTING TIPS AND TESTING TECHNIQUES
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: </hgroup>
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/chapter.jpg)'
  prefs: []
  type: TYPE_IMG
- en: When I first started to share with a small number of friends and colleagues
    the fact that I was writing the book that you are now holding, what they wanted
    to see in it more than anything was a chapter on testing and troubleshooting because
    of the unique development challenges posed by Batch.
  prefs: []
  type: TYPE_NORMAL
- en: 'I’ve mentioned often that there’s no Batch compiler, and maybe this goes without
    saying, but there’s no animator or debugger either. Stepping through some Batch
    commands, stepping over others, setting breakpoints, and inspecting or modifying
    variables are pure fantasy, or a very bad novel in the making (or maybe my next
    project). There are two steps in the lifecycle of Batch code: it’s written, and
    it’s executed. That’s the list; there’s no compilation and no animation. But this
    doesn’t mean you can’t test bat files. In fact, it makes testing all the more
    crucial.'
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, I’ll step through a number of tips, discussing the various
    techniques I’ve learned and developed over my years of coding Batch applications,
    small and large.
  prefs: []
  type: TYPE_NORMAL
- en: (If the alliterative title doesn’t sit well with you, be thankful that I pared
    it down from “Tantalizingly Tidy Troubleshooting Tips and Timeless Testing Techniques”—a
    veritable tsunami of Ts.)
  prefs: []
  type: TYPE_NORMAL
- en: Capture stdout and stderr
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Without a doubt, the first step in testing and troubleshooting any bat file
    is capturing stdout and stderr to a trace file. While other languages offer an
    animator, Batch offers the next best thing—a detailed accounting of the results
    of most every command as each one executes. In some limited ways the trace might
    even be better than animation. It’s true that you can’t step through the code
    and manipulate variables as the bat file executes, but you can see the value of
    variables throughout the run and easily go in the reverse direction by simply
    scrolling up.
  prefs: []
  type: TYPE_NORMAL
- en: However, the trace can be daunting. If a loop executes 1,000 times, all 1,000
    executions are in the trace file, possibly spanning tens of thousands of lines.
    For this reason, most tips in this chapter will revolve around how to interpret
    the trace. The information in it is so invaluable, if you don’t remember how to
    capture stdout and stderr, return to [Chapter 12](chapter12.xhtml) and reacquaint
    yourself with the process before reading on.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you can capture the trace, being able to read it is paramount.
  prefs: []
  type: TYPE_NORMAL
- en: How to Navigate the Trace
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Always navigate the trace while referencing the bat file or files that generated
    it. It’s exceedingly easy to get lost in the trees of the trace file, and the
    original Batch code contains the map of the forest. This tip might seem obvious,
    but at times the trace may bear little resemblance to the bat code. For instance,
    in the trace you might see myVar being set like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'But that doesn’t tell you whether finalValue was hardcoded or set by other
    means, such as resolved from an intermediate variable. The original bat file will,
    however:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Also, traces can become so long and dense that performing a search is the only
    reasonable means of finding the desired section of output, but doing so can be
    trickier than you might imagine. Consider this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'The resulting trace might appear like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The interpreter shows the variables as resolved, so you can’t find this section
    of the trace by searching for the _pgmPurgeDB variable name from the bat file.
    Several sections of the code often look similar. For instance, multiple programs
    might execute, trailed by similar error handling.
  prefs: []
  type: TYPE_NORMAL
- en: The two most readily identifiable portions of this Batch code are the remark
    and error message. Let’s take advantage of these bits of hardcoded text. To manage
    this issue, make sure that each program has a unique remark before it and/or a
    unique error message in the error handling code block after it. Now to find this
    section of the code in the trace, just copy the remark or error message from the
    bat file and search for it in the trace. And you’ll be documenting your code to
    boot—a true win-win scenario.
  prefs: []
  type: TYPE_NORMAL
- en: 'Successful executions are similar and boring, but failures are often unique
    and interesting. Let’s execute the same code again, but this time imagine a user
    has asked us to investigate why the database wasn’t purged despite the apparent
    success of the bat file’s execution. The clues are in the trace:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: First comes the comment. Then the errorlevel variable resolves to 0 in the conditional
    clause of the if command, so the program must’ve executed successfully, right?
    No, this only means that the last process to set the variable set it to 0. Was
    that last process the executable? Hold on ... where’s the executable? It isn’t
    showing up in the trace after the remark. That’s a clue.
  prefs: []
  type: TYPE_NORMAL
- en: This demonstrates why it’s so important to reference the original Batch code
    when reading the trace and doing so line by line by line. Doing that clearly exposes
    the missing content, which in this case is a program invocation. Without the original
    bat file, it would’ve been very difficult to see that something was missing.
  prefs: []
  type: TYPE_NORMAL
- en: Getting back to our specific issue, its proximate cause is probably the variable
    for the program resolving to null or to one or more spaces, but what’s the root
    cause? Maybe the variable was misspelled in this code; maybe someone misspelled
    it earlier when defining it; maybe it was never defined at all; maybe some other
    process wiped it out. (But maybe someone prefixed the contents of _pgmPurgeDB
    with @, thus suppressing the executable name from the trace even though it did
    execute, or maybe I’m overthinking this.) What you can be assured of is that the
    execution of the program isn’t showing up in the trace, and that with a little
    more digging you’ll find the actual root cause.
  prefs: []
  type: TYPE_NORMAL
- en: Remember, this is uncompiled code; using an undefined variable is the type of
    issue a compiler would catch, but Batch coders don’t have that luxury.
  prefs: []
  type: TYPE_NORMAL
- en: Don’t Be Fooled by the Ghost Trace
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'I’ve witnessed more than one novice Batch coder fixating on a portion of the
    trace similar to the following example, convinced that the program failed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'After all, the trace clearly shows a line with the errorMsg variable being
    set to a string definitively stating that the program failed, but this is part
    of the “ghost trace.” The line above the message contains the if command and the
    conditional clause that triggers the logic: if 0 NEQ 0. This is false; hence,
    the code block didn’t execute, and any apparent execution is an apparition. If
    an else keyword and code block had been present, the code in that code block would
    have executed, but in this instance, after the interpreter evaluated the if command,
    control skipped to whatever came after the code block.'
  prefs: []
  type: TYPE_NORMAL
- en: For better or worse, the interpreter doesn’t suppress such unexecuted code blocks.
    Not everything in the trace actually executed. If a command in the code block
    generates output to stdout, the existence or nonexistence of that output in the
    trace verifies whether it executed. Many times, however, nothing in the code block
    generates output, so you must behave like the interpreter and attempt to evaluate
    the conditional clause.
  prefs: []
  type: TYPE_NORMAL
- en: Frustratingly, even this has limitations. You can’t always evaluate the results
    of some conditional clauses from the trace. For example, an if exist command determining
    the presence of a file is impossible to evaluate from just the conditional clause
    in the trace. You have little means of knowing whether the file existed when the
    code executed or whether connectivity to the file was momentarily lost.
  prefs: []
  type: TYPE_NORMAL
- en: If the code branches significantly, you can infer the result of the if command
    from what happens next in the trace. For instance, if that error message had been
    set, control would have immediately jumped to the :Abort label due to the goto
    command. Ask yourself if the next few lines in the trace look like the code under
    this label or the code after the code block. (This is another reason for one of
    those descriptive remarks I mentioned earlier.) However, if the code in the code
    block does nothing more than set a variable or two, you’ll be hard-pressed to
    determine whether it actually executed given the trace (although the next tip
    might help).
  prefs: []
  type: TYPE_NORMAL
- en: 'If nothing else, you can begin the code block that executes when the conditional
    clause is true with an echo true command. I hesitate to suggest this inelegant
    cluttering of the code, but this writes the true text, or whatever text you desire,
    to the trace immediately after the execution of the if command, but only if the
    code block executes, definitively showing the result of the if command. For instance:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The echo true command in the code block always finds its way into the trace.
    After all, the point of this tip is that the ghost trace contains unexecuted commands.
    But the true text coming immediately after the close parenthesis shows that the
    code block executed and that the mystery file definitely existed at the time the
    if command looked for it.
  prefs: []
  type: TYPE_NORMAL
- en: Create an Audit Trail of Variables
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'An audit trail of all the variables set, reset, or unset during the execution
    of a bat file can greatly aid your troubleshooting. As mentioned in the prior
    tip, this might be the only way to know whether a code block executed. To this
    end, near the beginning of a long-running bat file, I usually add the following
    two lines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: This one simple command, the set command with no arguments, writes all existing
    variables to the captured trace. At the end of the same process, you can execute
    the same command but with a refence to After Execution in the remark.
  prefs: []
  type: TYPE_NORMAL
- en: The remarks make both lists of all populated variables easy to find. The initial
    command details all variables set on the machine as the execution begins, and
    the latter shows what changed during the execution. You can do this only when
    debugging or as an audit trail for every execution.
  prefs: []
  type: TYPE_NORMAL
- en: 'I more than hinted at this technique in [Chapter 29](chapter29.xhtml) in relation
    to arrays and hash tables. You might populate these data structures by various
    means, and it doesn’t take many entries for the building of these data structures
    to make a mess of the trace. In that chapter, I recommended dumping the contents
    of an array or hash table to the trace with a more targeted set command. For instance,
    we built a hash table by the name of people. Since every entry in the data structure
    starts with people{, the following command displayed the entire contents of the
    hash table after the load or at any other point in the process flow:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Similarly, if your convention is to prepend all variables containing an executable
    program with the _prog text, the following displays the complete list of all such
    variables:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The command without an argument works best at the start and end of a long process
    because it provides you with the global set of variables, and the targeted command
    works great for a shorter list of variables at strategic locations in a bat file,
    perhaps just after some tricky code.
  prefs: []
  type: TYPE_NORMAL
- en: Understand the stdout of the for Command
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The complexity of the trace generated by a for command grows in relation to
    the complexity of the for command itself, but even a simple example demonstrates
    what can be a common misconception. The following code is from [Chapter 18](chapter18.xhtml),
    but instead of summing the integers from 1 to 100, it sums the integers from 1
    to the number defined by the count variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'To cut down on the length of the trace, assume that count is set to 3, meaning
    that it executes three times even though the following trace shows four set commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: The first line is the entire for /L command—but *not* its execution. Notice
    that count along with the encasing percent signs resolves to 3 in the input and
    that both references to %%i have changed to %i. This is actually how you would
    enter the variable in a for command at the command prompt, and for whatever reason
    this is how it appears in stdout. The next three lines show the three actual executions
    of the code block with the for variable resolved to 1, 2, and 3, respectively.
  prefs: []
  type: TYPE_NORMAL
- en: Because variables such as count are resolved in the first line, it can appear
    to be an actual execution. This is especially true with more involved examples
    using complex code blocks or many more executions of the loop. But understand
    that it’s just an informational setup for the executions yet to come. Think of
    it as an inarticulate introduction to a book, with chapters to follow, one for
    each execution of the loop.
  prefs: []
  type: TYPE_NORMAL
- en: The next tip demonstrates another source of confusion concerning the trace of
    the for command.
  prefs: []
  type: TYPE_NORMAL
- en: How to Interpret Unresolved Variables
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'This is very frustrating, but the interpreter resolves some variables in the
    trace, but not others. In the last tip I teased that the trace of the for command
    can get quite complex, and it doesn’t take much. To demonstrate, here’s a different
    take on a file that I used frequently when discussing the for /F command in [Chapter
    19](chapter19.xhtml). I’m doing nothing more than putting the entire record of
    a file into a variable and writing that record to both stdout and the console:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: (If you’re asking why I didn’t simply directly write the %%r token instead of
    incorporating the superfluous inRec variable, I’m demonstrating the resulting
    trace of a variable set and used inside a for command’s code block with as little
    else going on as possible. This condition occurs naturally and often with even
    moderately complex logic.)
  prefs: []
  type: TYPE_NORMAL
- en: 'As in the last tip, the trace first shows the for command largely, but not
    entirely, unchanged compared to the actual code. But in contrast, the interpreter
    displays this more complex command and its associated code block on multiple lines,
    making it easier to read:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, the first record in the files generates the following in the trace. Everything
    inside the parentheses is the code being executed, while the last line is the
    result of the first echo command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: By the way, each record in the file generates something very similar to this,
    so you can see how the trace can get very big very quickly; 100 records would
    have generated 600 lines of text.
  prefs: []
  type: TYPE_NORMAL
- en: The previous trace clearly shows the input record resolved from %%r and its
    assignment to the inRec variable, but—and this is important—the next two lines
    of the trace don’t show the resolution of !inRec! at all. Was it set and resolved
    correctly? In this instance, I use it in the first echo command to clearly show
    the contents of the variable in the trailing line of output, but you can’t see
    many other usages of the variable in the trace. For example, the second echo command
    is writing the same text to the console, but it doesn’t appear in the trace. (Think
    of this as the opposite of the ghost trace.)
  prefs: []
  type: TYPE_NORMAL
- en: Simply put, any variable assigned inside a code block and resolved with exclamation
    marks, also inside the code block, presents as the variable name surrounded by
    exclamation marks, that is, unresolved. When executed, it resolves as expected,
    but the trace gives you no indication of this fact.
  prefs: []
  type: TYPE_NORMAL
- en: This is an immensely unnerving batveat. There are nearly countless reasons to
    set and use a variable inside of the code block of a for command—and this is usually
    where the most interesting code resides—but what’s happening is lost into the
    ether. Delayed expansion, executed inside and outside of code blocks, is another
    victim of this issue.
  prefs: []
  type: TYPE_NORMAL
- en: There are a few ways to handle this. The first is do nothing at all; once this
    behavior is understood, a good coder can navigate these idiosyncrasies with the
    knowledge that they need to perform a certain amount of extrapolation to read
    the trace.
  prefs: []
  type: TYPE_NORMAL
- en: Second, strategically placed echo commands can show the results of a few lines
    of logic. You can write the text to the console for troubleshooting (more on this
    to come) or simply to the trace file. That’s in effect what I did in the prior
    listing with the first echo command.
  prefs: []
  type: TYPE_NORMAL
- en: Third, if the line-by-line results of each command are required, you can move
    the interesting code block to a called routine and invoke it with a call command,
    passing the needed tokens as arguments. The routine can then treat the tokens
    like parameters with the upshot being functionally equivalent code that’s now
    fully resolved in the trace.
  prefs: []
  type: TYPE_NORMAL
- en: I have some professional history with this issue. After implementing a very
    involved nested for structure culminating in the rename of a file, some continually
    raised questions as to whether the rename actually occurred. To ultimately settle
    the debate, I rewrote the code using a called routine. Unfortunately, we all must
    compromise elegance for functionality at times.
  prefs: []
  type: TYPE_NORMAL
- en: As a side note, this trace contains some oddities. The first line inside the
    code block has no indenting, and the others are indented one space, regardless
    of the indentation in the bat file. The redirection syntax, > con, precedes the
    echo command in the bat file, but in the trace, it’s moved to the end. I can’t
    explain these discrepancies, but I know they exist, and we must come to accept
    that what’s in the trace is a tortured rendering of the actual code.
  prefs: []
  type: TYPE_NORMAL
- en: Recognize Inconsistent Command Outputs
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Due to the vagaries of Batch, the messages produced from command to command
    varies, thus compounding the already nasty batveat from the prior tip. For example,
    if an xcopy command executes inside of a code block using variables set and resolved
    in the code block, the trace won’t show the resolved filename or names in the
    xcopy command. But if you use the /F option, the command writes a clear message
    to the trace detailing the result of the command, listing the file or files copied.
  prefs: []
  type: TYPE_NORMAL
- en: In contrast, a similar ren command produces no message from a successful rename,
    meaning that you can rename a file with no mention of it in the trace other than
    a ren command with unresolved filenames. A failed ren command writes a generic
    error message to stderr, but unlike the xcopy command, it doesn’t contain the
    filename. The end result is that if a failed ren command uses exclamation marks
    inside a for loop or it uses delayed expansion, an error message states that the
    rename failed without noting the file or giving any other information.
  prefs: []
  type: TYPE_NORMAL
- en: With experience you’ll learn what output to expect and when to expect it from
    commands that you commonly use. For other commands, expect the unexpected.
  prefs: []
  type: TYPE_NORMAL
- en: Write Variables to the Console
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Unless you’ve skipped directly to this chapter and to this tip, you’re more
    than familiar with an echo command redirecting its output to the console via the
    > con syntax. I’ve used the technique many times to show the results of code listings,
    and it’s very handy when troubleshooting, especially for complex for loops.
  prefs: []
  type: TYPE_NORMAL
- en: The trace can be both cryptic and large, which isn’t a good combination for
    readability. To tease out just the important data, I often place a temporary redirected
    echo command inside a loop to see the state of one or more variables during each
    pass.
  prefs: []
  type: TYPE_NORMAL
- en: 'For instance, the logic to add up a series of integers in “Understand the stdout
    of the for Command” on page 380 is difficult to test, because while we see the
    sum variable being set, we never see it resolved in any of the iterations of the
    loop in the trace. You won’t see the value of sum until you use it somewhere in
    the code after the loop, but if you aren’t getting the expected result, you’ll
    likely want to see those lost intermediate values. You can add a single line to
    the summation code so as to get a summation of events. See if you can spot it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Assume that count is set to 4 before this executes; the final sum should be
    10, but we’re getting 35.
  prefs: []
  type: TYPE_NORMAL
- en: 'The trace still hasn’t gone anywhere if you need more detail, but the additional
    command writes the following plain and comprehensive text to the console. The
    variables are labeled clearly, and the dashes just make them stand out and look
    nice:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'The index variable should increment (no surprise there), but a close inspection
    of the sum variable for each entry reveals the issue. The code never initialized
    sum, and it can be 26 in the first line only if it were 25 coming into the loop.
    An earlier process must be using the same generically named variable. After adding
    a quick set command initializing the variable to 0, the code displays the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Another close inspection of the sum variable now reveals that all is working
    as intended; that is, the prior sum plus the current index does in fact equal
    the current sum in every entry after the first, where it’s just 1. Once the testing
    and troubleshooting is complete, you can and should delete the echo command before
    moving on.
  prefs: []
  type: TYPE_NORMAL
- en: I’ve demonstrated this technique on one of the simplest for commands possible,
    but for commands can quickly become opaque. A simple redirected echo command or
    two can quickly and easily generate a synopsis of some tricky and repetitive logic
    to greatly aid your troubleshooting.
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 9](chapter9.xhtml), I expressed some very definitive views on indenting
    that I appear to have flouted with this echo command. As a quick recap, remarks
    have no indent, labels are indented one byte, and everything else is indented
    two bytes or more. In my opinion this is a must for the finished product, but
    this particular echo command is temporary, and it’s best to make that obvious.
    Otherwise, there’s a good chance that you unnecessarily and accidentally leave
    it in the code. This gaudy unindented command is all but begging to be deleted.
  prefs: []
  type: TYPE_NORMAL
- en: Decipher Different Types of Syntax Errors
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The interpreter writes two general types of error messages to stderr: errors
    generated by a command and syntax errors. Failed xcopy or del commands display
    the command itself in the trace followed by a clear error message stating why
    it couldn’t copy or delete a file.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Unfortunately, syntax errors don’t present consistently. One example of a syntax
    error is the use of the nonexistent and operator in a conditional clause. As mentioned
    in [Chapter 27](chapter27.xhtml), the interpreter might just ignore it and go
    on to execute whatever’s in the code block without even writing a message to stderr.
    A slightly different conditional clause with the same bad operator might write
    the if command to the trace followed by an error message:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: But this still plows ahead executing the code block and beyond. By the way,
    the text of this error message means that the interpreter is mistakenly trying
    to execute something in the command as if it were a program, but it’s often a
    syntax error instead.
  prefs: []
  type: TYPE_NORMAL
- en: 'There’s at least one more way that syntax errors can manifest themselves. To
    demonstrate, let’s consider this slightly modified version of the code discussed
    earlier in this chapter that does little more than execute a program and check
    the return code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'As simple as this code appears to be, the execution crashes, and the command
    window closes, leaving the following text at the bottom of the trace:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: A pessimist might point out that the generic error message is completely devoid
    of details. An optimist might point out that the interpreter definitively informs
    you of a syntax error, but when you begin to analyze the message, you realize
    that its digital author is unintentionally sinister.
  prefs: []
  type: TYPE_NORMAL
- en: The error message stating that the syntax is incorrect immediately follows the
    execution of the program; there isn’t even a blank line between them. It certainly
    suggests that the preceding line has the bad syntax. But no, the interpreter is
    something of a fortune teller. It’s stating that the following line—the one separated
    by a blank line—is the source of the gaffe, even though it looks like an uncontroversial
    if command.
  prefs: []
  type: TYPE_NORMAL
- en: To recap, syntax errors sometimes write an error message to the trace, and sometimes
    they don’t. Sometimes the interpreter blows past syntax errors, executing the
    commands coming next, and sometimes it doesn’t. Error messages sometimes come
    after the offending command, and sometimes they come before. My best advice is
    to find the general vicinity of the error. Look at the code before and after the
    message and avoid tunnel vision.
  prefs: []
  type: TYPE_NORMAL
- en: Before moving on, what’s wrong with the syntax in that if command anyway? This
    is where a compiler giving a succinct and pointed error message would be manna
    from heaven, but we’re armed with little more than our wits and an interpreter
    that has shrugged its binary shoulders and said, “Something’s wrong. Figure it
    out.” A heads-down interrogation of the line of code following it reveals a command
    name nearly impossible to misspell, if; a valid operator, neq; and two numbers
    to compare. D’oh! The open parenthesis is missing.
  prefs: []
  type: TYPE_NORMAL
- en: Modularize Wherever Possible
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The act of creating small bat files that perform definitive tasks has many benefits,
    not least among them is testing. You can easily set up another bat file to call
    the new bat file many times with various input parameters, each time verifying
    any and all outputs, which can take the form of returned parameters, data written
    to the console, or some action, such as a copied file.
  prefs: []
  type: TYPE_NORMAL
- en: To see an example of this simply flip back to [Chapter 11](chapter11.xhtml).
    After building the *MadLib.bat* file, I called it several times with many different
    input parameters. Turning to [Chapter 29](chapter29.xhtml), if you’re creating
    an array or hash table in a section of code in an already large process, one option
    is to code it in the existing bat file. But most of the time, a far better option
    is to create a new called bat file with all of the interesting logic. Then you
    can test the new bat file quickly and repeatedly with call commands from another
    bat file to work out any bugs. Finally, you’ll need to do little more than add
    a call command or two to the existing bat file containing the larger process.
  prefs: []
  type: TYPE_NORMAL
- en: You’ll soon see more examples of this. In [Chapter 32](chapter32.xhtml), after
    creating an object-oriented bat file, I’ll invoke it with multiple call commands
    from another bat file. Then in [Chapter 33](chapter33.xhtml), I’ll create a single
    bat file to handle stacks. Subsequent calls to it will then push items onto the
    stack and pull items off the stack. Modularize whenever possible.
  prefs: []
  type: TYPE_NORMAL
- en: Test Snippets in a Test Bat File
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Unfortunately, sometimes modularization isn’t possible. A large application
    might need a tweak to an existing for command. If it’s in a large bat file that’s
    part of an even larger process, it’s probably impractical to incorporate the change
    into a new module. To complicate matters, the lack of a compiler greatly increases
    the chances of you introducing errors when making even the most trivial of changes.
    If this is a long-running process, it might take an hour or longer just to learn
    that you omitted a parenthesis, and more complex changes often require multiple
    rounds of the coding-testing-tweaking triumvirate. It would be far better to test
    just the code in question, being able to run it repeatedly and quickly.
  prefs: []
  type: TYPE_NORMAL
- en: 'What we need is a way to mimic the actual environment of the new or updated
    logic in a simple and controlled setting. As a means to this end, every computer
    I work on has a *C:\Batch\* folder containing a bat file named *Test.bat* with
    these complete contents, at least to start:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: As it stands, this bat file will execute a very boring routine of three rem
    commands, capture stdout and stderr in a trace file, and hold the console open
    with the pause command. But this bat file is merely a shell. To test a code snippet
    from a larger bat file, paste it after the second rem command. Examples might
    include a complex for command or even a much longer snippet that builds and uses
    arrays while also reading from and writing to multiple files.
  prefs: []
  type: TYPE_NORMAL
- en: If the code expects certain variables to be set before the snippet executes,
    you can enter them as hardcoded values after the first rem command. If a file
    is to be read, mock one up and add its file connector in this section.
  prefs: []
  type: TYPE_NORMAL
- en: Similarly, if the process being tested is to set certain variables in the environment
    for later use, you can interrogate them with echo commands redirected to the console
    after the third rem command. Not only will you see these resolved variables on
    the console, but they’ll also be in the detailed trace (unless the issue of unresolved
    variables rears its head).
  prefs: []
  type: TYPE_NORMAL
- en: 'To demonstrate, if you were to use this technique to test the summation logic
    detailed earlier in this chapter, you might update the internal routine in the
    shell bat file like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: The code to be tested goes in the middle section, but this is just the starting
    point. You’ll need to define the count variable before the core logic executes,
    and since the ultimate result of this code is the value of one variable, you’ll
    want to resolve and display sum to the console in the third section of the routine.
  prefs: []
  type: TYPE_NORMAL
- en: You can now test, tweak, retest, and tweak again quickly, efficiently, and often.
    This isn’t a final test, but once this testing is satisfactory, you can copy and
    paste the listing into the main process. Now you can perform a full end-to-end
    test with a high level of confidence.
  prefs: []
  type: TYPE_NORMAL
- en: I also use this very same bat file for testing the modularized code that I introduced
    in the prior tip. You can easily add one or more call commands of other bat files
    to the middle section, while still using the first section for setup and the third
    for validation. Cutting and pasting is never elegant, but without a doubt, testing
    snippets in a test bat file is supremely effective.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'I cannot overstate the importance of mastering techniques for testing and troubleshooting
    Batch code. In this chapter, I plugged in the amplifier from *This Is Spinal Tap*
    and turned it up to 11\. With these 11 tips, I demonstrated how I develop and
    maintain bat files. In one sentence: capture and be able to read the trace, write
    output to the console, modularize when possible, and use *Test.bat* whenever appropriate.'
  prefs: []
  type: TYPE_NORMAL
- en: I’m sure that others have useful additions to this list, and I encourage you
    to seek them out. The only alternative to solid Batch testing is eventually giving
    up and writing some compiled code to perform a task that could’ve been done, and
    should’ve been done, with just a few lines of Batch.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next chapter tackles an exciting and interesting coding methodology: object-oriented
    design, a topic that you may not currently associate with Batch, but soon will.'
  prefs: []
  type: TYPE_NORMAL
