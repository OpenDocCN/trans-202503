- en: <hgroup>
  id: totrans-0
  prefs: []
  type: TYPE_NORMAL
  zh: <hgroup>
- en: 31 TROUBLESHOOTING TIPS AND TESTING TECHNIQUES
  id: totrans-1
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 31 个故障排除技巧和测试技术
- en: </hgroup>
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: </hgroup>
- en: '![](../images/chapter.jpg)'
  id: totrans-3
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/chapter.jpg)'
- en: When I first started to share with a small number of friends and colleagues
    the fact that I was writing the book that you are now holding, what they wanted
    to see in it more than anything was a chapter on testing and troubleshooting because
    of the unique development challenges posed by Batch.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 当我最初开始与少数朋友和同事分享我正在写这本书的事实时，他们最想在书中看到的是关于测试和故障排除的一章，因为批处理带来了独特的开发挑战。
- en: 'I’ve mentioned often that there’s no Batch compiler, and maybe this goes without
    saying, but there’s no animator or debugger either. Stepping through some Batch
    commands, stepping over others, setting breakpoints, and inspecting or modifying
    variables are pure fantasy, or a very bad novel in the making (or maybe my next
    project). There are two steps in the lifecycle of Batch code: it’s written, and
    it’s executed. That’s the list; there’s no compilation and no animation. But this
    doesn’t mean you can’t test bat files. In fact, it makes testing all the more
    crucial.'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 我经常提到没有批处理编译器，也许这不言而喻，但其实也没有动画器或调试器。逐步执行一些批处理命令，跳过其他命令，设置断点，检查或修改变量，这些都纯粹是幻想，或者说是一本很糟糕的小说（或者可能是我的下一个项目）。批处理代码的生命周期有两个步骤：编写和执行。就是这么简单；没有编译，也没有动画。但这并不意味着你不能测试批处理文件。实际上，这让测试变得更加重要。
- en: In this chapter, I’ll step through a number of tips, discussing the various
    techniques I’ve learned and developed over my years of coding Batch applications,
    small and large.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我将逐步介绍一些技巧，讨论我多年来在编码批处理应用程序过程中学到和开发的各种技术，无论是小型应用程序还是大型应用程序。
- en: (If the alliterative title doesn’t sit well with you, be thankful that I pared
    it down from “Tantalizingly Tidy Troubleshooting Tips and Timeless Testing Techniques”—a
    veritable tsunami of Ts.)
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: （如果这个押头韵的标题让你不太喜欢，那就感谢我将它从“令人垂涎的整洁故障排除技巧和永恒的测试技术”删减掉——这简直是 Ts 的海啸。）
- en: Capture stdout and stderr
  id: totrans-8
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 捕获 stdout 和 stderr
- en: Without a doubt, the first step in testing and troubleshooting any bat file
    is capturing stdout and stderr to a trace file. While other languages offer an
    animator, Batch offers the next best thing—a detailed accounting of the results
    of most every command as each one executes. In some limited ways the trace might
    even be better than animation. It’s true that you can’t step through the code
    and manipulate variables as the bat file executes, but you can see the value of
    variables throughout the run and easily go in the reverse direction by simply
    scrolling up.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 毋庸置疑，测试和故障排除任何批处理文件的第一步是将 stdout 和 stderr 捕获到追踪文件中。虽然其他编程语言提供了动画功能，但批处理提供了次优选择——详细记录每个命令执行的结果。在某些有限的情况下，追踪信息甚至可能比动画更好。确实，你不能在批处理文件执行时逐步调试代码并操作变量，但你可以看到变量的值，并通过简单的向上滚动轻松返回。
- en: However, the trace can be daunting. If a loop executes 1,000 times, all 1,000
    executions are in the trace file, possibly spanning tens of thousands of lines.
    For this reason, most tips in this chapter will revolve around how to interpret
    the trace. The information in it is so invaluable, if you don’t remember how to
    capture stdout and stderr, return to [Chapter 12](chapter12.xhtml) and reacquaint
    yourself with the process before reading on.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，追踪信息可能让人感到望而生畏。如果一个循环执行了 1,000 次，所有 1,000 次执行都会出现在追踪文件中，可能会跨越成千上万行。因此，本章的大部分技巧将围绕如何解读追踪信息展开。追踪中的信息非常宝贵，如果你不记得如何捕获
    stdout 和 stderr，请返回到[第 12 章](chapter12.xhtml)，重新熟悉一下捕获过程再继续阅读。
- en: Now that you can capture the trace, being able to read it is paramount.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你可以捕获追踪信息，能否读取这些信息至关重要。
- en: How to Navigate the Trace
  id: totrans-12
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 如何导航追踪信息
- en: 'Always navigate the trace while referencing the bat file or files that generated
    it. It’s exceedingly easy to get lost in the trees of the trace file, and the
    original Batch code contains the map of the forest. This tip might seem obvious,
    but at times the trace may bear little resemblance to the bat code. For instance,
    in the trace you might see myVar being set like so:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 始终在查看追踪信息时参考生成它的批处理文件。这是因为追踪文件的内容可能会让人迷失其中，原始的批处理代码就像是森林的地图。这个建议可能看起来很显而易见，但有时追踪信息可能与批处理代码差异很大。例如，在追踪信息中，你可能会看到像这样设置
    myVar：
- en: '[PRE0]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'But that doesn’t tell you whether finalValue was hardcoded or set by other
    means, such as resolved from an intermediate variable. The original bat file will,
    however:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 但这并不能告诉你 `finalValue` 是硬编码的，还是通过其他方式设置的，比如从一个中间变量解析出来的。不过，原始的 bat 文件会告诉你：
- en: '[PRE1]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Also, traces can become so long and dense that performing a search is the only
    reasonable means of finding the desired section of output, but doing so can be
    trickier than you might imagine. Consider this code:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，追踪信息可能变得非常长且密集，只有通过搜索才能找到所需的输出部分，但这样做可能比你想象的要复杂。考虑以下代码：
- en: '[PRE2]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The resulting trace might appear like so:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 生成的追踪信息可能如下所示：
- en: '[PRE3]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The interpreter shows the variables as resolved, so you can’t find this section
    of the trace by searching for the _pgmPurgeDB variable name from the bat file.
    Several sections of the code often look similar. For instance, multiple programs
    might execute, trailed by similar error handling.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 解释器显示变量已解析，因此你无法通过从 bat 文件中搜索 `_pgmPurgeDB` 变量名来找到追踪信息中的这一部分。代码的多个部分通常看起来相似。例如，多个程序可能会执行，并且后面跟着类似的错误处理。
- en: The two most readily identifiable portions of this Batch code are the remark
    and error message. Let’s take advantage of these bits of hardcoded text. To manage
    this issue, make sure that each program has a unique remark before it and/or a
    unique error message in the error handling code block after it. Now to find this
    section of the code in the trace, just copy the remark or error message from the
    bat file and search for it in the trace. And you’ll be documenting your code to
    boot—a true win-win scenario.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 这个 Batch 代码中最容易识别的两个部分是注释和错误信息。我们可以利用这些硬编码的文本来解决问题。为了解决这个问题，确保每个程序前都有一个独特的注释，或者每个程序后在错误处理代码块中有一个独特的错误信息。现在，为了在追踪信息中找到这一段代码，只需从
    bat 文件中复制注释或错误信息，并在追踪信息中进行搜索。这样，你也在记录代码——这简直是双赢的局面。
- en: 'Successful executions are similar and boring, but failures are often unique
    and interesting. Let’s execute the same code again, but this time imagine a user
    has asked us to investigate why the database wasn’t purged despite the apparent
    success of the bat file’s execution. The clues are in the trace:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 成功的执行过程通常相似且乏味，但失败往往独特且有趣。让我们再次执行相同的代码，但这次假设一个用户要求我们调查为什么数据库没有被清除，尽管 bat 文件看似成功执行了。线索就在追踪信息中：
- en: '[PRE4]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: First comes the comment. Then the errorlevel variable resolves to 0 in the conditional
    clause of the if command, so the program must’ve executed successfully, right?
    No, this only means that the last process to set the variable set it to 0. Was
    that last process the executable? Hold on ... where’s the executable? It isn’t
    showing up in the trace after the remark. That’s a clue.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 首先是注释。然后，`errorlevel` 变量在 if 命令的条件语句中解析为 0，因此程序应该是成功执行了，对吧？不，这仅仅意味着最后设置该变量的过程将其设置为
    0。最后设置该变量的过程是可执行文件吗？等一下……可执行文件在哪里？它没有在注释后出现在追踪信息中。这是一个线索。
- en: This demonstrates why it’s so important to reference the original Batch code
    when reading the trace and doing so line by line by line. Doing that clearly exposes
    the missing content, which in this case is a program invocation. Without the original
    bat file, it would’ve been very difficult to see that something was missing.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 这证明了在读取追踪信息时，逐行参考原始 Batch 代码是多么重要。逐行分析可以清楚地暴露缺失的内容，在这种情况下，就是程序调用。如果没有原始的 bat
    文件，就很难发现有东西缺失。
- en: Getting back to our specific issue, its proximate cause is probably the variable
    for the program resolving to null or to one or more spaces, but what’s the root
    cause? Maybe the variable was misspelled in this code; maybe someone misspelled
    it earlier when defining it; maybe it was never defined at all; maybe some other
    process wiped it out. (But maybe someone prefixed the contents of _pgmPurgeDB
    with @, thus suppressing the executable name from the trace even though it did
    execute, or maybe I’m overthinking this.) What you can be assured of is that the
    execution of the program isn’t showing up in the trace, and that with a little
    more digging you’ll find the actual root cause.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 回到我们特定的问题，其近因可能是程序的变量解析为 null 或一个或多个空格，但根本原因是什么？也许这个变量在代码中拼写错误；也许在早期定义它时有人拼错了它；也许它根本没有被定义过；也许是其他进程将其清空了。（但也许是有人在
    `_pgmPurgeDB` 的内容前加了 `@`，从而抑制了可执行文件名在追踪信息中的显示，即使它确实执行了，或者也许是我想得太复杂了。）你可以确定的是，程序的执行没有出现在追踪信息中，稍微再深挖一点，你就能找到实际的根本原因。
- en: Remember, this is uncompiled code; using an undefined variable is the type of
    issue a compiler would catch, but Batch coders don’t have that luxury.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，这是未编译的代码；使用未定义的变量是编译器会抓到的问题，但批处理程序员没有这个奢侈的待遇。
- en: Don’t Be Fooled by the Ghost Trace
  id: totrans-29
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 不要被幽灵跟踪所迷惑
- en: 'I’ve witnessed more than one novice Batch coder fixating on a portion of the
    trace similar to the following example, convinced that the program failed:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 我曾见过不止一个新手批处理程序员，盯着类似以下的跟踪记录部分，坚信程序失败了：
- en: '[PRE5]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'After all, the trace clearly shows a line with the errorMsg variable being
    set to a string definitively stating that the program failed, but this is part
    of the “ghost trace.” The line above the message contains the if command and the
    conditional clause that triggers the logic: if 0 NEQ 0. This is false; hence,
    the code block didn’t execute, and any apparent execution is an apparition. If
    an else keyword and code block had been present, the code in that code block would
    have executed, but in this instance, after the interpreter evaluated the if command,
    control skipped to whatever came after the code block.'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 毕竟，跟踪记录清楚地显示了一个将 errorMsg 变量设置为一个明确表示程序失败的字符串的行，但这只是“幽灵跟踪”。该消息上方的行包含 if 命令和触发逻辑的条件子句：if
    0 NEQ 0。这个条件是假的，因此代码块没有执行，任何看似执行的情况都只是幻象。如果存在 else 关键字和代码块，那个代码块中的代码本应会执行，但在这个例子中，解释器评估了
    if 命令后，控制跳过了代码块后面的内容。
- en: For better or worse, the interpreter doesn’t suppress such unexecuted code blocks.
    Not everything in the trace actually executed. If a command in the code block
    generates output to stdout, the existence or nonexistence of that output in the
    trace verifies whether it executed. Many times, however, nothing in the code block
    generates output, so you must behave like the interpreter and attempt to evaluate
    the conditional clause.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 无论好坏，解释器不会抑制这种未执行的代码块。跟踪记录中并非每一部分都执行了。如果代码块中的命令生成了输出到标准输出（stdout），则该输出在跟踪记录中是否存在，可以验证它是否执行了。然而，很多时候代码块中的内容并不会生成输出，因此你必须像解释器一样，尝试评估条件子句。
- en: Frustratingly, even this has limitations. You can’t always evaluate the results
    of some conditional clauses from the trace. For example, an if exist command determining
    the presence of a file is impossible to evaluate from just the conditional clause
    in the trace. You have little means of knowing whether the file existed when the
    code executed or whether connectivity to the file was momentarily lost.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 令人沮丧的是，甚至这个方法也有局限性。你并不总是能够从跟踪记录中评估某些条件子句的结果。例如，if exist 命令用于判断文件是否存在，但仅凭跟踪记录中的条件子句，无法评估出文件是否存在。你几乎无法得知在代码执行时，文件是否存在，或者文件的连接是否暂时丢失。
- en: If the code branches significantly, you can infer the result of the if command
    from what happens next in the trace. For instance, if that error message had been
    set, control would have immediately jumped to the :Abort label due to the goto
    command. Ask yourself if the next few lines in the trace look like the code under
    this label or the code after the code block. (This is another reason for one of
    those descriptive remarks I mentioned earlier.) However, if the code in the code
    block does nothing more than set a variable or two, you’ll be hard-pressed to
    determine whether it actually executed given the trace (although the next tip
    might help).
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 如果代码分支显著，你可以从跟踪记录中接下来的情况推断出 if 命令的结果。例如，如果错误消息已经被设置，控制会立即跳转到：Abort 标签，因为有 goto
    命令。问问自己，跟踪记录中的接下来的几行是否像该标签下的代码，还是像代码块后的代码。（这也是我之前提到的描述性注释的另一个原因。）然而，如果代码块中的代码只是设置了一个或两个变量，你很难仅凭跟踪记录判断它是否真正执行了（尽管下一个提示可能会有所帮助）。
- en: 'If nothing else, you can begin the code block that executes when the conditional
    clause is true with an echo true command. I hesitate to suggest this inelegant
    cluttering of the code, but this writes the true text, or whatever text you desire,
    to the trace immediately after the execution of the if command, but only if the
    code block executes, definitively showing the result of the if command. For instance:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有其他办法，你可以在条件子句为真的时候，开始执行的代码块中加入一个 echo true 命令。我不太愿意建议这样不优雅的代码杂乱无章，但它会在 if
    命令执行后立即将“true”文本，或者你希望的任何文本，写入到跟踪记录中，但只有当代码块执行时，才能明确显示 if 命令的结果。例如：
- en: '[PRE6]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The echo true command in the code block always finds its way into the trace.
    After all, the point of this tip is that the ghost trace contains unexecuted commands.
    But the true text coming immediately after the close parenthesis shows that the
    code block executed and that the mystery file definitely existed at the time the
    if command looked for it.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 代码块中的echo true命令总会出现在追踪中。毕竟，这个提示的重点在于，幽灵追踪包含了未执行的命令。但紧接在右括号之后的true文本显示了代码块已执行，并且当if命令查找该文件时，神秘文件确实存在。
- en: Create an Audit Trail of Variables
  id: totrans-39
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建变量的审计追踪
- en: 'An audit trail of all the variables set, reset, or unset during the execution
    of a bat file can greatly aid your troubleshooting. As mentioned in the prior
    tip, this might be the only way to know whether a code block executed. To this
    end, near the beginning of a long-running bat file, I usually add the following
    two lines:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在批处理文件执行过程中，所有已设置、重置或未设置的变量的审计追踪可以极大地帮助你排除故障。如前面的提示所述，这可能是唯一能知道某个代码块是否执行的方式。为此，在一个长时间运行的批处理文件的开始部分，我通常会添加以下两行：
- en: '[PRE7]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: This one simple command, the set command with no arguments, writes all existing
    variables to the captured trace. At the end of the same process, you can execute
    the same command but with a refence to After Execution in the remark.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 这个简单的命令，set命令不带参数，会将所有现有的变量写入捕获的追踪。在同一过程的末尾，你可以执行相同的命令，但备注中引用执行后的状态。
- en: The remarks make both lists of all populated variables easy to find. The initial
    command details all variables set on the machine as the execution begins, and
    the latter shows what changed during the execution. You can do this only when
    debugging or as an audit trail for every execution.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 这些备注使得所有已填充的变量列表易于查找。初始命令列出在执行开始时机器上设置的所有变量，后者则显示在执行过程中发生了什么变化。你只有在调试或作为每次执行的审计追踪时，才能执行此操作。
- en: 'I more than hinted at this technique in [Chapter 29](chapter29.xhtml) in relation
    to arrays and hash tables. You might populate these data structures by various
    means, and it doesn’t take many entries for the building of these data structures
    to make a mess of the trace. In that chapter, I recommended dumping the contents
    of an array or hash table to the trace with a more targeted set command. For instance,
    we built a hash table by the name of people. Since every entry in the data structure
    starts with people{, the following command displayed the entire contents of the
    hash table after the load or at any other point in the process flow:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 我在[第29章](chapter29.xhtml)中曾提到过这一技术，涉及数组和哈希表。你可能通过各种方式填充这些数据结构，而数据结构的构建即使条目不多，也可能使追踪变得杂乱。在那一章中，我建议使用更具针对性的set命令将数组或哈希表的内容转储到追踪中。例如，我们构建了一个名为people的哈希表。由于数据结构中的每个条目都以people{开头，以下命令将在加载后或任何其他流程节点显示哈希表的全部内容：
- en: '[PRE8]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Similarly, if your convention is to prepend all variables containing an executable
    program with the _prog text, the following displays the complete list of all such
    variables:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，如果你的约定是将所有包含可执行程序的变量前缀设置为_prog文本，那么以下命令将显示所有这些变量的完整列表：
- en: '[PRE9]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The command without an argument works best at the start and end of a long process
    because it provides you with the global set of variables, and the targeted command
    works great for a shorter list of variables at strategic locations in a bat file,
    perhaps just after some tricky code.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 不带参数的命令在长时间的过程开始和结束时效果最佳，因为它提供了全局变量集，而带有目标的命令则适用于在批处理文件中战略位置的较短变量列表，可能是在某些复杂代码之后。
- en: Understand the stdout of the for Command
  id: totrans-49
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 理解for命令的标准输出
- en: 'The complexity of the trace generated by a for command grows in relation to
    the complexity of the for command itself, but even a simple example demonstrates
    what can be a common misconception. The following code is from [Chapter 18](chapter18.xhtml),
    but instead of summing the integers from 1 to 100, it sums the integers from 1
    to the number defined by the count variable:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 由for命令生成的追踪复杂性与for命令本身的复杂性成正比，但即使是一个简单的例子也能展示一个常见的误解。以下代码来自[第18章](chapter18.xhtml)，但它的作用不是求1到100的整数和，而是求1到由count变量定义的数字范围的整数和：
- en: '[PRE10]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'To cut down on the length of the trace, assume that count is set to 3, meaning
    that it executes three times even though the following trace shows four set commands:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 为了减少追踪的长度，假设计数设置为3，这意味着它会执行三次，尽管以下追踪显示了四个设置命令：
- en: '[PRE11]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The first line is the entire for /L command—but *not* its execution. Notice
    that count along with the encasing percent signs resolves to 3 in the input and
    that both references to %%i have changed to %i. This is actually how you would
    enter the variable in a for command at the command prompt, and for whatever reason
    this is how it appears in stdout. The next three lines show the three actual executions
    of the code block with the for variable resolved to 1, 2, and 3, respectively.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 第一行是整个for /L命令——但*不是*它的执行。请注意，count以及括起来的百分号在输入中解析为3，而两个%%i的引用都变成了%i。这实际上是你在命令提示符中输入for命令时的变量形式，出于某种原因，它就是这样显示在stdout中的。接下来的三行展示了代码块的三次实际执行，for变量分别解析为1、2和3。
- en: Because variables such as count are resolved in the first line, it can appear
    to be an actual execution. This is especially true with more involved examples
    using complex code blocks or many more executions of the loop. But understand
    that it’s just an informational setup for the executions yet to come. Think of
    it as an inarticulate introduction to a book, with chapters to follow, one for
    each execution of the loop.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 因为像count这样的变量在第一行中被解析，所以它可能看起来像是实际执行。这一点在使用复杂代码块或更多循环执行的更复杂示例中尤为明显。但请理解，这只是对即将到来的执行的一个信息性设置。可以把它看作是一本书的无言介绍，后面还有章节，每一章对应一次循环执行。
- en: The next tip demonstrates another source of confusion concerning the trace of
    the for command.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个提示展示了另一个关于for命令追踪的混淆来源。
- en: How to Interpret Unresolved Variables
  id: totrans-57
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 如何解释未解析的变量
- en: 'This is very frustrating, but the interpreter resolves some variables in the
    trace, but not others. In the last tip I teased that the trace of the for command
    can get quite complex, and it doesn’t take much. To demonstrate, here’s a different
    take on a file that I used frequently when discussing the for /F command in [Chapter
    19](chapter19.xhtml). I’m doing nothing more than putting the entire record of
    a file into a variable and writing that record to both stdout and the console:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 这非常让人沮丧，但解释器在追踪中解析了一些变量，而其他变量没有解析。在上一条提示中我提到，for命令的追踪可以变得相当复杂，且不需要太多的东西。为了演示这一点，这里是一个不同的文件版本，我曾经在讨论[第19章](chapter19.xhtml)中的for
    /F命令时频繁使用。我的做法只是将文件的整个记录放入一个变量，并将该记录同时写入stdout和控制台：
- en: '[PRE12]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: (If you’re asking why I didn’t simply directly write the %%r token instead of
    incorporating the superfluous inRec variable, I’m demonstrating the resulting
    trace of a variable set and used inside a for command’s code block with as little
    else going on as possible. This condition occurs naturally and often with even
    moderately complex logic.)
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: （如果你问我为什么不直接写%%r标记，而是将多余的inRec变量包含进来，我正在展示一个在for命令的代码块内设置和使用变量的追踪结果，并尽可能减少其他内容的干扰。这种情况在逻辑稍微复杂一点的情况下自然而然地会发生。）
- en: 'As in the last tip, the trace first shows the for command largely, but not
    entirely, unchanged compared to the actual code. But in contrast, the interpreter
    displays this more complex command and its associated code block on multiple lines,
    making it easier to read:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 与上一条提示类似，追踪首先显示for命令，虽然大体上没有改变，但与实际代码相比还是有所不同。相反，解释器将这个更复杂的命令及其关联的代码块分成多行显示，便于阅读：
- en: '[PRE13]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Next, the first record in the files generates the following in the trace. Everything
    inside the parentheses is the code being executed, while the last line is the
    result of the first echo command:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，文件中的第一条记录在追踪中生成以下内容。括号内的是正在执行的代码，而最后一行是第一个echo命令的结果：
- en: '[PRE14]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: By the way, each record in the file generates something very similar to this,
    so you can see how the trace can get very big very quickly; 100 records would
    have generated 600 lines of text.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 顺便提一下，文件中的每一条记录都会生成类似这样的内容，因此你可以看到追踪很容易迅速变得非常庞大；100条记录将会生成600行文本。
- en: The previous trace clearly shows the input record resolved from %%r and its
    assignment to the inRec variable, but—and this is important—the next two lines
    of the trace don’t show the resolution of !inRec! at all. Was it set and resolved
    correctly? In this instance, I use it in the first echo command to clearly show
    the contents of the variable in the trailing line of output, but you can’t see
    many other usages of the variable in the trace. For example, the second echo command
    is writing the same text to the console, but it doesn’t appear in the trace. (Think
    of this as the opposite of the ghost trace.)
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的追踪信息清晰地显示了从%%r解析出的输入记录及其赋值给inRec变量的过程，但是——这点很重要——接下来的两行追踪完全没有显示!inRec!的解析。它是否被正确设置并解析了呢？在这个实例中，我在第一个echo命令中使用它，清楚地展示了变量的内容在输出的尾部行中，但你在追踪信息中看不到该变量的其他使用情况。例如，第二个echo命令正在向控制台写入相同的文本，但它没有出现在追踪中。（可以将这看作是与幽灵追踪相反的情况。）
- en: Simply put, any variable assigned inside a code block and resolved with exclamation
    marks, also inside the code block, presents as the variable name surrounded by
    exclamation marks, that is, unresolved. When executed, it resolves as expected,
    but the trace gives you no indication of this fact.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 简单来说，任何在代码块内部赋值并通过感叹号解决的变量（也在代码块内），会以感叹号包围的变量名形式呈现，也就是说，未解决的。当执行时，它按预期解决，但追踪信息不会给出任何相关提示。
- en: This is an immensely unnerving batveat. There are nearly countless reasons to
    set and use a variable inside of the code block of a for command—and this is usually
    where the most interesting code resides—but what’s happening is lost into the
    ether. Delayed expansion, executed inside and outside of code blocks, is another
    victim of this issue.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个极其令人不安的警告（batveat）。有几乎无数的理由在for命令的代码块内设置并使用变量——而且通常最有趣的代码就藏在这里——但是发生的事情却消失在虚无之中。延迟扩展（在代码块内部和外部执行）是这一问题的另一个受害者。
- en: There are a few ways to handle this. The first is do nothing at all; once this
    behavior is understood, a good coder can navigate these idiosyncrasies with the
    knowledge that they need to perform a certain amount of extrapolation to read
    the trace.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 处理这个问题有几种方法。第一种方法是完全不做任何处理；一旦理解了这种行为，一个好的程序员可以通过了解需要进行一定的推断来读取追踪信息，从而应对这些特性。
- en: Second, strategically placed echo commands can show the results of a few lines
    of logic. You can write the text to the console for troubleshooting (more on this
    to come) or simply to the trace file. That’s in effect what I did in the prior
    listing with the first echo command.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 第二种方法是巧妙地放置echo命令来显示几行逻辑的结果。你可以将文本写入控制台以进行故障排除（稍后会详细介绍），或者简单地写入追踪文件。这实际上是我在前一个列表中用第一个echo命令所做的。
- en: Third, if the line-by-line results of each command are required, you can move
    the interesting code block to a called routine and invoke it with a call command,
    passing the needed tokens as arguments. The routine can then treat the tokens
    like parameters with the upshot being functionally equivalent code that’s now
    fully resolved in the trace.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 第三种方法是，如果需要逐行显示每个命令的结果，你可以将有趣的代码块移到一个调用例程中，并通过call命令调用它，传递所需的令牌作为参数。该例程可以将令牌当作参数处理，最终结果是功能上等效的代码，且现在在追踪信息中完全解析。
- en: I have some professional history with this issue. After implementing a very
    involved nested for structure culminating in the rename of a file, some continually
    raised questions as to whether the rename actually occurred. To ultimately settle
    the debate, I rewrote the code using a called routine. Unfortunately, we all must
    compromise elegance for functionality at times.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 我对这个问题有一些职业经历。在实现一个非常复杂的嵌套for结构，最终导致重命名文件后，一直有人提出是否真的发生了重命名的问题。为了最终解决这个争论，我使用调用例程重写了代码。不幸的是，我们有时不得不为了功能性而妥协优雅性。
- en: As a side note, this trace contains some oddities. The first line inside the
    code block has no indenting, and the others are indented one space, regardless
    of the indentation in the bat file. The redirection syntax, > con, precedes the
    echo command in the bat file, but in the trace, it’s moved to the end. I can’t
    explain these discrepancies, but I know they exist, and we must come to accept
    that what’s in the trace is a tortured rendering of the actual code.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 顺便提一下，这个追踪信息包含了一些怪异现象。代码块内部的第一行没有缩进，其他行缩进了一个空格，无论bat文件中的缩进如何。重定向语法`> con`出现在bat文件中的echo命令之前，但在追踪信息中，它被移到了末尾。我无法解释这些不一致之处，但我知道它们存在，我们必须接受追踪信息中的内容是对实际代码的扭曲呈现。
- en: Recognize Inconsistent Command Outputs
  id: totrans-74
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 识别不一致的命令输出
- en: Due to the vagaries of Batch, the messages produced from command to command
    varies, thus compounding the already nasty batveat from the prior tip. For example,
    if an xcopy command executes inside of a code block using variables set and resolved
    in the code block, the trace won’t show the resolved filename or names in the
    xcopy command. But if you use the /F option, the command writes a clear message
    to the trace detailing the result of the command, listing the file or files copied.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 由于批处理命令的多变性，命令间产生的消息会有所不同，从而加重了前面提到的麻烦。例如，如果一个xcopy命令在代码块内执行，并使用在代码块中设置并解析的变量，那么跟踪信息不会显示解析后的文件名或文件名。然而，如果使用/F选项，该命令会将一条清晰的消息写入跟踪信息，详细列出命令的结果，列出复制的文件或文件。
- en: In contrast, a similar ren command produces no message from a successful rename,
    meaning that you can rename a file with no mention of it in the trace other than
    a ren command with unresolved filenames. A failed ren command writes a generic
    error message to stderr, but unlike the xcopy command, it doesn’t contain the
    filename. The end result is that if a failed ren command uses exclamation marks
    inside a for loop or it uses delayed expansion, an error message states that the
    rename failed without noting the file or giving any other information.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 相比之下，一个类似的ren命令在成功重命名时不会产生任何消息，意味着你可以重命名一个文件，但在跟踪信息中除了一个未解析的文件名的ren命令外没有任何提及。一个失败的ren命令会将一个通用的错误消息写入stderr，但不同于xcopy命令，它不包含文件名。最终结果是，如果一个失败的ren命令在for循环中使用了感叹号，或者使用了延迟扩展，那么错误消息会说明重命名失败，但没有提及文件名或提供任何其他信息。
- en: With experience you’ll learn what output to expect and when to expect it from
    commands that you commonly use. For other commands, expect the unexpected.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 随着经验的积累，你会学会预期何时从常用命令中获得什么输出。对于其他命令，你则要预期一些出乎意料的情况。
- en: Write Variables to the Console
  id: totrans-78
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 将变量写入控制台
- en: Unless you’ve skipped directly to this chapter and to this tip, you’re more
    than familiar with an echo command redirecting its output to the console via the
    > con syntax. I’ve used the technique many times to show the results of code listings,
    and it’s very handy when troubleshooting, especially for complex for loops.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 除非你直接跳到这一章和这个提示，否则你一定非常熟悉回显命令通过> con语法将输出重定向到控制台。我多次使用过这种技巧来展示代码列表的结果，尤其在故障排除时，它非常方便，特别是在处理复杂的for循环时。
- en: The trace can be both cryptic and large, which isn’t a good combination for
    readability. To tease out just the important data, I often place a temporary redirected
    echo command inside a loop to see the state of one or more variables during each
    pass.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 跟踪信息可能既隐晦又庞大，这对于可读性来说不是一个好组合。为了提取出重要数据，我经常在循环中放置一个临时重定向的回显命令，以便在每次循环时查看一个或多个变量的状态。
- en: 'For instance, the logic to add up a series of integers in “Understand the stdout
    of the for Command” on page 380 is difficult to test, because while we see the
    sum variable being set, we never see it resolved in any of the iterations of the
    loop in the trace. You won’t see the value of sum until you use it somewhere in
    the code after the loop, but if you aren’t getting the expected result, you’ll
    likely want to see those lost intermediate values. You can add a single line to
    the summation code so as to get a summation of events. See if you can spot it:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，“理解for命令的标准输出”第380页中的逻辑，计算一系列整数的和，这很难进行测试，因为虽然我们能看到sum变量被设置，但我们从未在任何一次循环迭代中看到它在跟踪信息中被解析。直到在循环后使用sum时，你才会看到它的值，但如果你没有得到预期的结果，你很可能会想查看那些丢失的中间值。你可以在求和代码中添加一行，以便获得事件的求和。看看你能否发现它：
- en: '[PRE15]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Assume that count is set to 4 before this executes; the final sum should be
    10, but we’re getting 35.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 假设在执行之前，count的值被设置为4；最终的和应该是10，但我们得到了35。
- en: 'The trace still hasn’t gone anywhere if you need more detail, but the additional
    command writes the following plain and comprehensive text to the console. The
    variables are labeled clearly, and the dashes just make them stand out and look
    nice:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你需要更多的细节，跟踪信息仍然没有改变，但额外的命令将以下简洁明了的文本写入控制台。变量被清楚地标注，破折号使它们更突出、更易于阅读：
- en: '[PRE16]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The index variable should increment (no surprise there), but a close inspection
    of the sum variable for each entry reveals the issue. The code never initialized
    sum, and it can be 26 in the first line only if it were 25 coming into the loop.
    An earlier process must be using the same generically named variable. After adding
    a quick set command initializing the variable to 0, the code displays the following:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 索引变量应该递增（这没什么意外的），但对每个条目的sum变量进行仔细检查后，问题显现出来。代码从未初始化sum，只有当它在进入循环时为25时，第一行中的sum才能为26。之前的某个过程必须使用了这个同名的变量。添加一个快速的set命令将该变量初始化为0后，代码显示如下：
- en: '[PRE17]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Another close inspection of the sum variable now reveals that all is working
    as intended; that is, the prior sum plus the current index does in fact equal
    the current sum in every entry after the first, where it’s just 1. Once the testing
    and troubleshooting is complete, you can and should delete the echo command before
    moving on.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 再次仔细检查sum变量，现在可以发现一切按预期工作；也就是说，之前的sum加上当前的索引，确实等于每个条目中的当前sum，从第一个条目开始，它仅为1。一旦测试和故障排除完成，你可以并且应该删除echo命令，然后继续往下。
- en: I’ve demonstrated this technique on one of the simplest for commands possible,
    but for commands can quickly become opaque. A simple redirected echo command or
    two can quickly and easily generate a synopsis of some tricky and repetitive logic
    to greatly aid your troubleshooting.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 我已经在最简单的for命令之一上演示了这种技巧，但for命令很快就变得晦涩难懂。一两个简单的重定向echo命令可以迅速且轻松地生成一些复杂且重复的逻辑摘要，从而大大帮助你的故障排除。
- en: In [Chapter 9](chapter9.xhtml), I expressed some very definitive views on indenting
    that I appear to have flouted with this echo command. As a quick recap, remarks
    have no indent, labels are indented one byte, and everything else is indented
    two bytes or more. In my opinion this is a must for the finished product, but
    this particular echo command is temporary, and it’s best to make that obvious.
    Otherwise, there’s a good chance that you unnecessarily and accidentally leave
    it in the code. This gaudy unindented command is all but begging to be deleted.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第9章](chapter9.xhtml)中，我曾对缩进表达过一些非常明确的看法，而我似乎在这个echo命令中违背了这些规则。简单回顾一下，注释没有缩进，标签缩进一个字节，其他所有内容缩进两个字节或更多。在我看来，这对于最终产品是必须遵守的，但这个echo命令是临时的，最好让这一点显而易见。否则，很有可能你会不小心将其遗留在代码中。这个花哨且未缩进的命令几乎在乞求被删除。
- en: Decipher Different Types of Syntax Errors
  id: totrans-91
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 解读不同类型的语法错误
- en: 'The interpreter writes two general types of error messages to stderr: errors
    generated by a command and syntax errors. Failed xcopy or del commands display
    the command itself in the trace followed by a clear error message stating why
    it couldn’t copy or delete a file.'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 解释器将两种通用的错误信息写入stderr：由命令生成的错误和语法错误。失败的xcopy或del命令会在跟随清晰错误信息的跟踪中显示命令本身，说明为何无法复制或删除文件。
- en: 'Unfortunately, syntax errors don’t present consistently. One example of a syntax
    error is the use of the nonexistent and operator in a conditional clause. As mentioned
    in [Chapter 27](chapter27.xhtml), the interpreter might just ignore it and go
    on to execute whatever’s in the code block without even writing a message to stderr.
    A slightly different conditional clause with the same bad operator might write
    the if command to the trace followed by an error message:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，语法错误并不总是以一致的方式呈现。语法错误的一个例子是在条件子句中使用不存在的and运算符。如[第27章](chapter27.xhtml)中提到的，解释器可能会直接忽略它，继续执行代码块中的内容，甚至不会写入stderr。一个稍微不同的条件子句使用相同的错误运算符，可能会将if命令写入跟踪，然后是错误信息：
- en: '[PRE18]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: But this still plows ahead executing the code block and beyond. By the way,
    the text of this error message means that the interpreter is mistakenly trying
    to execute something in the command as if it were a program, but it’s often a
    syntax error instead.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 但这仍然继续执行代码块及之后的内容。顺便提一下，这条错误信息的意思是解释器错误地尝试将命令中的某些内容当作程序来执行，但通常这实际上是语法错误。
- en: 'There’s at least one more way that syntax errors can manifest themselves. To
    demonstrate, let’s consider this slightly modified version of the code discussed
    earlier in this chapter that does little more than execute a program and check
    the return code:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 语法错误至少还有一种表现形式。为了演示这一点，让我们考虑一下本章早些时候讨论的稍作修改的代码版本，该代码除了执行一个程序并检查返回码外，几乎没有做其他任何事情：
- en: '[PRE19]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'As simple as this code appears to be, the execution crashes, and the command
    window closes, leaving the following text at the bottom of the trace:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管这段代码看起来很简单，但执行时却崩溃了，命令窗口关闭，追踪底部留下了以下文字：
- en: '[PRE20]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: A pessimist might point out that the generic error message is completely devoid
    of details. An optimist might point out that the interpreter definitively informs
    you of a syntax error, but when you begin to analyze the message, you realize
    that its digital author is unintentionally sinister.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 悲观主义者可能会指出，通用错误信息完全缺乏细节。乐观主义者可能会指出，解释器明确地告诉你语法错误，但当你开始分析这个信息时，你会意识到它的数字化作者无意间显得有些阴险。
- en: The error message stating that the syntax is incorrect immediately follows the
    execution of the program; there isn’t even a blank line between them. It certainly
    suggests that the preceding line has the bad syntax. But no, the interpreter is
    something of a fortune teller. It’s stating that the following line—the one separated
    by a blank line—is the source of the gaffe, even though it looks like an uncontroversial
    if command.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 错误信息指出语法不正确，紧随程序执行之后；它们之间甚至没有空行。这显然暗示着前一行有语法错误。但实际上，解释器更像是个占卜师。它声明接下来的那一行——被空行隔开的那一行——是错误的源头，尽管它看起来像是一个无争议的if命令。
- en: To recap, syntax errors sometimes write an error message to the trace, and sometimes
    they don’t. Sometimes the interpreter blows past syntax errors, executing the
    commands coming next, and sometimes it doesn’t. Error messages sometimes come
    after the offending command, and sometimes they come before. My best advice is
    to find the general vicinity of the error. Look at the code before and after the
    message and avoid tunnel vision.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 总结一下，语法错误有时会在追踪中写出错误信息，有时则不会。有时解释器会忽略语法错误，继续执行接下来的命令，有时则不会。错误信息有时会在出错的命令之后出现，有时会出现在之前。我的最佳建议是，找出错误的大致位置。查看错误信息前后的代码，避免出现“隧道视野”。
- en: Before moving on, what’s wrong with the syntax in that if command anyway? This
    is where a compiler giving a succinct and pointed error message would be manna
    from heaven, but we’re armed with little more than our wits and an interpreter
    that has shrugged its binary shoulders and said, “Something’s wrong. Figure it
    out.” A heads-down interrogation of the line of code following it reveals a command
    name nearly impossible to misspell, if; a valid operator, neq; and two numbers
    to compare. D’oh! The open parenthesis is missing.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续之前，那个if命令的语法到底有什么问题呢？这正是编译器提供简洁明了的错误信息时，简直是天降甘霖，但我们仅有的武器不过是我们的聪明才智和一个耸耸二进制肩膀的解释器，它说：“出错了，自己找原因。”紧盯着它后面的代码行进行仔细检查，命令名称几乎不可能拼错，if；有效的运算符，neq；以及两个要比较的数字。哎呀！缺少了一个左括号。
- en: Modularize Wherever Possible
  id: totrans-104
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 尽可能模块化
- en: The act of creating small bat files that perform definitive tasks has many benefits,
    not least among them is testing. You can easily set up another bat file to call
    the new bat file many times with various input parameters, each time verifying
    any and all outputs, which can take the form of returned parameters, data written
    to the console, or some action, such as a copied file.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 创建执行特定任务的小bat文件有很多好处，其中最重要的一项是测试。你可以轻松设置另一个bat文件来多次调用新bat文件，使用不同的输入参数，每次都验证所有输出结果，这些输出可以是返回的参数、写入控制台的数据，或是某些操作，比如复制文件。
- en: To see an example of this simply flip back to [Chapter 11](chapter11.xhtml).
    After building the *MadLib.bat* file, I called it several times with many different
    input parameters. Turning to [Chapter 29](chapter29.xhtml), if you’re creating
    an array or hash table in a section of code in an already large process, one option
    is to code it in the existing bat file. But most of the time, a far better option
    is to create a new called bat file with all of the interesting logic. Then you
    can test the new bat file quickly and repeatedly with call commands from another
    bat file to work out any bugs. Finally, you’ll need to do little more than add
    a call command or two to the existing bat file containing the larger process.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看这个例子的实例，只需翻到[第11章](chapter11.xhtml)。在构建了*MadLib.bat*文件后，我多次使用不同的输入参数调用它。转到[第29章](chapter29.xhtml)，如果你在一个已经很大的过程中的某一部分代码里创建一个数组或哈希表，一种选择是将其编码到现有的bat文件中。但大多数情况下，更好的选择是创建一个新的bat文件，包含所有有趣的逻辑。然后你可以通过从另一个bat文件使用call命令来快速并反复测试新bat文件，以排除任何漏洞。最后，你只需要在包含更大过程的现有bat文件中添加一两个call命令即可。
- en: You’ll soon see more examples of this. In [Chapter 32](chapter32.xhtml), after
    creating an object-oriented bat file, I’ll invoke it with multiple call commands
    from another bat file. Then in [Chapter 33](chapter33.xhtml), I’ll create a single
    bat file to handle stacks. Subsequent calls to it will then push items onto the
    stack and pull items off the stack. Modularize whenever possible.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 你很快就会看到更多这样的例子。在[第32章](chapter32.xhtml)中，在创建一个面向对象的bat文件后，我将通过另一个bat文件使用多个call命令来调用它。然后在[第33章](chapter33.xhtml)中，我将创建一个单独的bat文件来处理栈。随后对它的调用将推送项目到栈上并从栈中取出项目。尽可能进行模块化。
- en: Test Snippets in a Test Bat File
  id: totrans-108
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 测试 Bat 文件中的代码片段
- en: Unfortunately, sometimes modularization isn’t possible. A large application
    might need a tweak to an existing for command. If it’s in a large bat file that’s
    part of an even larger process, it’s probably impractical to incorporate the change
    into a new module. To complicate matters, the lack of a compiler greatly increases
    the chances of you introducing errors when making even the most trivial of changes.
    If this is a long-running process, it might take an hour or longer just to learn
    that you omitted a parenthesis, and more complex changes often require multiple
    rounds of the coding-testing-tweaking triumvirate. It would be far better to test
    just the code in question, being able to run it repeatedly and quickly.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，有时候模块化并不可行。一个大型应用程序可能需要调整现有的for命令。如果它在一个大型的bat文件中，且这个文件是一个更大流程的一部分，将更改集成到新模块中可能不切实际。更复杂的是，由于缺乏编译器，当你做出即使是最微小的更改时，出错的几率大大增加。如果这是一个长时间运行的过程，你可能需要一小时甚至更长时间才能发现自己遗漏了一个括号，而更复杂的更改通常需要多轮的编码-测试-调整。最好只测试待测试的代码，能够快速反复运行它。
- en: 'What we need is a way to mimic the actual environment of the new or updated
    logic in a simple and controlled setting. As a means to this end, every computer
    I work on has a *C:\Batch\* folder containing a bat file named *Test.bat* with
    these complete contents, at least to start:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要的是一种方法，在简单和受控的环境中模拟新逻辑或更新逻辑的实际环境。为了实现这一目标，我在每台工作计算机上都有一个*C:\Batch\*文件夹，其中包含一个名为*Test.bat*的bat文件，至少一开始其内容是完整的：
- en: '[PRE21]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: As it stands, this bat file will execute a very boring routine of three rem
    commands, capture stdout and stderr in a trace file, and hold the console open
    with the pause command. But this bat file is merely a shell. To test a code snippet
    from a larger bat file, paste it after the second rem command. Examples might
    include a complex for command or even a much longer snippet that builds and uses
    arrays while also reading from and writing to multiple files.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，这个bat文件将执行一个非常无聊的例程，包含三个rem命令，捕获stdout和stderr到追踪文件，并通过pause命令保持控制台打开。但这个bat文件仅仅是一个外壳。要测试来自更大bat文件的代码片段，可以将其粘贴到第二个rem命令之后。示例可能包括一个复杂的for命令，或者一个更长的片段，它在构建和使用数组的同时，还读取和写入多个文件。
- en: If the code expects certain variables to be set before the snippet executes,
    you can enter them as hardcoded values after the first rem command. If a file
    is to be read, mock one up and add its file connector in this section.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 如果代码期望在代码片段执行之前设置某些变量，你可以在第一个rem命令之后将它们作为硬编码值输入。如果需要读取某个文件，可以在此部分创建一个模拟文件，并添加其文件连接器。
- en: Similarly, if the process being tested is to set certain variables in the environment
    for later use, you can interrogate them with echo commands redirected to the console
    after the third rem command. Not only will you see these resolved variables on
    the console, but they’ll also be in the detailed trace (unless the issue of unresolved
    variables rears its head).
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，如果被测试的过程是为了在环境中设置某些变量以供后续使用，你可以在第三个rem命令之后，通过将echo命令重定向到控制台来查询它们。你不仅能在控制台上看到这些解析后的变量，还能在详细的追踪信息中看到它们（除非未解析的变量问题再次出现）。
- en: 'To demonstrate, if you were to use this technique to test the summation logic
    detailed earlier in this chapter, you might update the internal routine in the
    shell bat file like so:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 为了演示，如果你使用这种技术来测试本章前面详细介绍的求和逻辑，你可以像这样更新shell bat文件中的内部例程：
- en: '[PRE22]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The code to be tested goes in the middle section, but this is just the starting
    point. You’ll need to define the count variable before the core logic executes,
    and since the ultimate result of this code is the value of one variable, you’ll
    want to resolve and display sum to the console in the third section of the routine.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 待测试的代码放在中间部分，但这只是起点。你需要在核心逻辑执行之前定义计数变量，并且由于这段代码的最终结果是一个变量的值，你将需要在程序的第三部分解析并显示sum到控制台。
- en: You can now test, tweak, retest, and tweak again quickly, efficiently, and often.
    This isn’t a final test, but once this testing is satisfactory, you can copy and
    paste the listing into the main process. Now you can perform a full end-to-end
    test with a high level of confidence.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你可以快速、高效、频繁地进行测试、调整、重新测试和再次调整。这不是最终测试，但一旦测试满意，你可以将清单复制并粘贴到主流程中。现在你可以以较高的信心执行完整的端到端测试。
- en: I also use this very same bat file for testing the modularized code that I introduced
    in the prior tip. You can easily add one or more call commands of other bat files
    to the middle section, while still using the first section for setup and the third
    for validation. Cutting and pasting is never elegant, but without a doubt, testing
    snippets in a test bat file is supremely effective.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 我也使用同一个批处理文件来测试我在之前的技巧中介绍的模块化代码。你可以轻松地在中间部分添加一个或多个其他批处理文件的调用命令，同时仍然使用第一部分进行设置，第三部分进行验证。剪切和粘贴从来不优雅，但毫无疑问，在测试批处理文件中的代码片段是非常有效的。
- en: Summary
  id: totrans-120
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 总结
- en: 'I cannot overstate the importance of mastering techniques for testing and troubleshooting
    Batch code. In this chapter, I plugged in the amplifier from *This Is Spinal Tap*
    and turned it up to 11\. With these 11 tips, I demonstrated how I develop and
    maintain bat files. In one sentence: capture and be able to read the trace, write
    output to the console, modularize when possible, and use *Test.bat* whenever appropriate.'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 我无法过分强调掌握测试和故障排除批处理代码技术的重要性。在这一章中，我插入了*《尖峰时刻》*中的放大器，并把音量调到11。通过这11个技巧，我展示了我如何开发和维护批处理文件。用一句话总结：捕获并能够读取跟踪，写入控制台输出，尽可能进行模块化，并在适当时使用*Test.bat*。
- en: I’m sure that others have useful additions to this list, and I encourage you
    to seek them out. The only alternative to solid Batch testing is eventually giving
    up and writing some compiled code to perform a task that could’ve been done, and
    should’ve been done, with just a few lines of Batch.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 我相信其他人会有有用的补充内容，我鼓励你去寻找它们。对批处理的测试，唯一的替代方案就是最终放弃并编写一些已编译的代码来执行本可以并且应该通过几行批处理代码完成的任务。
- en: 'The next chapter tackles an exciting and interesting coding methodology: object-oriented
    design, a topic that you may not currently associate with Batch, but soon will.'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 下一章将讨论一种令人兴奋且有趣的编码方法：面向对象设计，这个话题你可能现在还不会与批处理（Batch）联系在一起，但很快你会发现它的关联。
