<html><head></head><body>
<div id="book-content">
<div id="sbo-rt-content"><section epub:type="chapter" role="doc-chapter" aria-labelledby="ch15">&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_295" aria-label="295"/>&#13;
<hgroup>&#13;
<h2 class="CHAPTER" id="ch15">&#13;
<span class="CN"><samp class="SANS_Futura_Std_Bold_Condensed_B_11">15</samp></span>&#13;
<span class="CT"><samp class="SANS_Dogma_OT_Bold_B_11">CRYPTOCURRENCY CRYPTOGRAPHY</samp></span>&#13;
</h2>&#13;
</hgroup>&#13;
<figure class="opener"><img class="opener" src="../images/opener.jpg" alt="" width="401" height="386"/></figure>&#13;
<p class="TNI1">This chapter wasn’t in the initial edition of this book when it came out in fall 2017, a period when cryptocurrency and blockchain were at peak hype. While blockchain hasn’t quite lived up to its promises of disrupting several industries, it has profoundly influenced cryptographic research and engineering. Blockchain applications have brought new exciting problems, attracted fresh talent, and offered a novel way to bridge theory and practice.</p>&#13;
<p class="TX">Before “crypto” became synonymous with cryptocurrency, cryptographic algorithms and protocols largely pertained to standard functionalities such as encryption and secure channels. The more arcane protocols were restricted to niche research areas and technical articles, typically catering to researchers’ interests and presented only in academic <span role="doc-pagebreak" epub:type="pagebreak" id="pg_296" aria-label="296"/>conferences. New algorithms were predominantly crafted by academic researchers and would see real-world deployment, if ever, after at least five years of peer review and analysis and after numerous research papers detailing unsuccessful cryptanalysis attempts.</p>&#13;
<p class="TX">Blockchain turned that process upside down. Much like how the cryptographic protocols of Signal and Tor sidestepped the conventional academic route, blockchain enthusiasts were less bound by tradition. Groundbreaking protocols often debuted in blog posts or informal white papers, with implementation following shortly after. Occasionally, they’d forgo written specifications altogether, letting the code speak for itself. Only after widespread adoption would academia take notice. The most notable case is the Bitcoin protocol, which didn’t undergo formal peer review before being deployed.</p>&#13;
<p class="TX">Many seasoned researchers identified novel challenges within the blockchain domain, often collaborating directly with blockchain entities. They developed complex protocols that not only pushed boundaries and garnered peer recognition but also saw rapid real-world implementation, impacting thousands, if not millions, of systems. Prime instances include efficient ECDSA threshold signature schemes and zero-knowledge proof systems. In some scenarios, existing protocols with little practical use found impactful use cases, such as Boneh–Lynn–Shacham (BLS) signatures.</p>&#13;
<p class="TX">This chapter provides an overview of these cryptographic algorithms and protocols—those tailored for blockchain and those that thrived due to it. I won’t delve into defining blockchain or its workings, as there are myriad online resources. Instead, I emphasize the cryptographic schemes underpinning blockchains, which hold significance irrespective of the blockchain use cases. Even if you remain skeptical of the blockchain phenomenon, I trust you’ll find this chapter enlightening.</p>&#13;
<section epub:type="division" aria-labelledby="sec1">&#13;
<h3 class="H1"><span id="sec1"/><span id="h1-103"/><samp class="SANS_Futura_Std_Bold_B_11">Hashing Applications</samp></h3>&#13;
<p class="TNI">Hash functions, the Swiss Army knives of cryptography, serve numerous applications in blockchain systems, including:</p>&#13;
<p class="ListHead"><b>Hashing a transaction’s data</b></p>&#13;
<p class="ListPlainFirst0">Hash functions can produce a digest signed by the transaction’s issuer, typically with ECDSA-secp256k1 or Ed25519. Verifying the signature ensures that the owner of a given address approved of the information hashed, leading to including the transaction in the chain’s ledger.</p>&#13;
<p class="ListPlain">In the blockchain Ethereum, a transaction’s hash serves as its unique identifier; for example, you can enter a hash in the search field of <i><a href="https://etherscan.io">https://<wbr/>etherscan<wbr/>.io</a></i> to retrieve the associated transaction. Ethereum transaction hashes use Keccak-256—which is similar but not identical to SHA3-256—and process-encoded data. This data includes the recipient’s address, the amount of ether (ticker ETH) sent, any smart contract input, the gas price and limit, a nonce (increasing for each new transaction), and a signature of the transaction.</p>&#13;
<p class="ListHead"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_297" aria-label="297"/><b>Hashing the content of a block</b></p>&#13;
<p class="ListPlainFirst">Hash functions can include the digest in the subsequent block to “chain” the blocks. For example, each Bitcoin block has a <i>block header</i> that includes the previous block’s hash, a tree hash of the recorded transactions, and some metadata (version, timestamp, nonce, and so on). Bitcoin computes the previous block’s hash by hashing the header of the previous block using double SHA-256, or <b>SHA-256</b>(<b>SHA-256</b>(block header)). This unorthodox construction eliminates the risk of length extension attacks and adds a safety net in case SHA-256 was found to be insecure—which is unlikely.</p>&#13;
<p class="TX">Aside from these basic use cases, hash functions are the main building block in key components of blockchain systems.</p>&#13;
<section epub:type="division" aria-labelledby="sec2">&#13;
<h4 class="H2"><span id="sec2"/><span id="h2-186"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Merkle Trees</samp></h4>&#13;
<p class="TNI"><i>Merkle trees</i> are a type of hash tree, which is a data structure computing a root value from leaf values according to a tree pattern. In hash trees, the parent node is computed by hashing the child nodes. Merkle trees are, for example, used to create a Bitcoin block’s header. They’re named after computer scientist Ralph Merkle, whose 1979 cryptographic scheme construction used binary hash trees.</p>&#13;
<section epub:type="division" aria-labelledby="sec3">&#13;
<h5 class="H3"><span id="sec3"/><samp class="SANS_Futura_Std_Bold_Condensed_B_11">Tree Hashing Computation</samp></h5>&#13;
<p class="TNI">A Merkle tree takes as input values that constitute its <i>leaves</i>—that is, the values from which the <i>root</i> (the output) is computed. You generally represent data structure trees with their root at the top and leaves at the bottom.</p>&#13;
<p class="TX">For example, <a href="chapter15.xhtml#fig15-1">Figure 15-1</a> shows a Merkle tree hashing four values (<i>A</i>, <i>B</i>, <i>C</i>, <i>D</i>).</p>&#13;
<figure class="IMG"><img id="fig15-1" class="img7" src="../images/fig15-1.jpg" alt="" width="898" height="776"/>&#13;
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 15-1: A hash tree, where the leaves are the input and the root is the output</samp></p></figcaption>&#13;
</figure>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_298" aria-label="298"/>The tree hashing then works as follows:</p>&#13;
<ul class="ul">&#13;
<li class="BL">Hashing each of the four values to obtain the four hashes <b>H</b>(<i>A</i>), <b>H</b>(<i>B</i>), <b>H</b>(<i>C</i>), and <b>H</b>(<i>D</i>).</li>&#13;
<li class="BL">Hashing together each consecutive pair of hashes to obtain <b>H</b>(<b>H</b>(<i>A</i>) || <b>H</b>(<i>B</i>)) and <b>H</b>(<b>H</b>(<i>C</i>) || <b>H</b>(<i>D</i>)). Here you concatenate the hash values (as the || symbol denotes).</li>&#13;
<li class="BL">Hashing the two hashes together to obtain the root of the tree, which is the final output of the tree hashing: <b>H</b>(<b>H</b>(<b>H</b>(<i>A</i>) || <b>H</b>(<i>B</i>)) || <b>H</b>(<b>H</b>(<i>C</i>) || <b>H</b>(<i>D</i>))).</li>&#13;
</ul>&#13;
<p class="TX">If you omit the initial hashing of the input values—which is necessary only if the values aren’t already the size of the hash—you go from four values to one with a tree of two layers, or of <i>height</i> two. Note that while the input data may be a different size, all hash values are the same size. Generally, a tree of <i>n</i> layers has 2<i><sup>n</sup></i> leaves, allowing you to process up to 2<i><sup>n</sup></i> values by computing 2<i><sup>n</sup></i> – 1 hashes from the (hashed) leaves.</p>&#13;
<p class="TX">If the number of input values isn’t exactly 2<i><sup>n</sup></i> for some integer <i>n</i>, a common technique is to add dummy values (for example, set to zero or to the last value in the list); the padding rule should, however, be carefully chosen to avoid trivial collisions.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec4">&#13;
<h5 class="H3"><span id="sec4"/><samp class="SANS_Futura_Std_Bold_Condensed_B_11">Merkle Proofs</samp></h5>&#13;
<p class="TNI">A Merkle tree’s structure can be leveraged to prove that a given value belongs to the list of 2<i><sup>n</sup></i> values hashed without recomputing the whole tree (which takes on the order of 2<i><sup>n</sup></i> operations) but only in time proportional to the <i>height</i> of the tree—that is, its number of layers <i>n</i>. Depending on the context, such proofs are called a <i>membership path</i>, an <i>inclusion proof</i>, or a <i>Merkle proof</i>. This is a Merkle tree’s killer feature, which general-purpose hash functions don’t offer.</p>&#13;
<p class="TX"><a href="chapter15.xhtml#fig15-2">Figure 15-2</a> shows how this works. The shaded cells are the values sufficient to prove that <i>V</i><sub>1</sub> is one of the values hashed to obtain the root.</p>&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_299" aria-label="299"/>&#13;
<figure class="IMG"><img id="fig15-2" class="img7" src="../images/fig15-2.jpg" alt="" width="903" height="780"/>&#13;
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 15-2: A Merkle tree, wherein the shaded cells constitute the membership path of</samp> <samp class="SANS_Futura_Std_Book_11">A</samp></p></figcaption>&#13;
</figure>&#13;
<p class="TX">Say you want to prove that <i>A</i> was one of the values hashed, without revealing <i>B</i>, <i>C</i>, or <i>D</i>. First, hash <i>A</i> to obtain the actual leaf of the hash tree. Then, assume that you’ve received <i>A</i>’s membership path, which consists of the other shaded values, <b>H</b>(<i>B</i>) and <b>H</b>(<b>H</b>(<i>C</i>) || <b>H</b>(<i>D</i>)). To verify that <i>A</i> belongs to the tree, compute the following:</p>&#13;
<ul class="ul">&#13;
<li class="BL"><i>X</i> = <b>H</b>(<b>H</b>(<i>A</i>) || <b>H</b>(<i>B</i>)), since you know <i>A</i> and <b>H</b>(<i>B</i>)</li>&#13;
<li class="BL"><b>H(H</b>(<i>X</i>) || <b>H</b>(<b>H</b>(<i>C</i>) || <b>H</b>(<i>D</i>))), since you know <b>H</b>(<b>H</b>(<i>C</i>) || <b>H</b>(<i>D</i>))</li>&#13;
</ul>&#13;
<p class="TX">It took only two hashes of sibling values to prove <i>A</i>’s inclusion, or as many hashes as the height of the tree. A tree with eight leaves has a height of three; thus, a membership path verification needs three sibling hashes. With 16 leaves, you need four sibling hashes, and so on, with <i>n</i> sibling hashes for a tree with 2<i><sup>n</sup></i> leaves.</p>&#13;
<p class="TX">Blockchain applications often use Merkle trees to hash transactions into a single <i>Merkle root</i>, such as that included in a Bitcoin block header. A typical Bitcoin block registers about 2,000 transactions, which requires a tree of height 11 (2<sup>11</sup> = 2,048). In this case, it takes 2,048 – 1 = 2,047 sibling hashes to compute the root from the leaves, where each leaf is the hash of a transaction’s data. Each hash computes a double SHA-256, so in the case of 2,048 transactions, it takes 2,047 + 2,048 = 4,095 double SHA-256s, or 8,190 calls to SHA-256.</p>&#13;
<p class="TX">Ethereum uses a slightly more complex tree-based data structure, combining Merkle trees with <i>Patricia tries</i> (this is not a typo; “trie” comes from “retrieval”), a tree-like structure that stores key-value pairs. This structure serves Ethereum’s state-based model, which significantly differs from Bitcoin’s UTXO (unspent transaction output) model, for which simpler Merkle trees are sufficient.</p>&#13;
</section>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec5">&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_300" aria-label="300"/>&#13;
<h4 class="H2"><span id="sec5"/><span id="h2-187"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Proof of Work</samp></h4>&#13;
<p class="TNI">Proof of work (PoW) is arguably the most critical component of a blockchain’s consensus protocol—for those based on PoW rather than proof of stake (PoS) or other protocols.</p>&#13;
<p class="TX">A <i>PoW</i> is essentially a hash function that takes some fixed inputs and variable inputs and whose result must match a certain pattern to be valid. Parties that aim to <i>solve</i> a PoW repeatedly compute the hash with different values of the variable inputs until the result satisfies some constraint.</p>&#13;
<p class="TX">For example, in Bitcoin and some other PoW-based blockchains, the constraint is that the hash value when seen as a 256-bit number must be less than a given number. This can also be seen as the hash value having a given number of leading zeros, when seeing the hash as the big-endian encoding of a 256-bit number.</p>&#13;
<p class="TX">For example, in 2022 the highest Bitcoin difficulty value (as reported on <i><a href="https://btc.com/stats/diff">https://<wbr/>btc<wbr/>.com<wbr/>/stats<wbr/>/diff</a></i>) was 34,244,331,613,176, or approximately 2<sup>45</sup>. You multiply this by 2<sup>32</sup> to find the actual value that the hash must be less than, 2<sup>77</sup>. For each block, all the network participants (<i>miners</i>) jointly compute in the order of 2<sup>77</sup> double SHA-256 computations to find a solution to the PoW. Such a solution consists of a nonce (the variable part of the PoW hash’s input) that yields a hash value less than 2<sup>77</sup>. The fixed part of the PoW hash’s input consists of the block header values (version, previous block hash, Merkle tree root, timestamp, and difficulty target value).</p>&#13;
<p class="TX">Without a PoW “slowing down” the production of blocks in a blockchain, new valid blocks could be produced instantaneously, meaning that histories of transactions could be produced and re-created at will. It would be impossible to achieve <i>finality</i> (that is, the assurance that a block, and thus a set of transactions, cannot be reverted or changed once accepted by the network). In particular, it would be impossible to protect the network against <i>double spending</i>, or spending the same coins in two distinct transactions.</p>&#13;
<p class="TX">Not all PoW schemes are as simple as Bitcoin’s, which uses a general-purpose hash function (SHA-256). Several PoWs attempted to make its computation on dedicated hardware less efficient compared to general-purpose CPUs to discourage the centralization of mining by organizations investing in the development of optimized hardware miner technology—as opposed to off-the-shelf servers and computers that anyone can use. Implemented tricks include the following:</p>&#13;
<p class="RunInPara"><b>Memory hardness </b>You can force the PoW to use a large amount of memory, typically by generating a huge table and accessing at unpredictable addresses. For example, Ethereum’s PoW used the Ethash algorithm, which required approximately 4GB of memory. (In September 2022, Ethereum abandoned Ethash and switched from a PoW to a proof-of-stake mechanism.)</p>&#13;
<p class="RunInPara"><b>Virtual machines </b>As some malware do, you can create a custom set of computer instructions that would be translated to standard instructions by a virtual machine application, while also potentially using a large <span role="doc-pagebreak" epub:type="pagebreak" id="pg_301" aria-label="301"/>amount of memory to compute a PoW’s solution. This is the approach of RandomX, a PoW algorithm adopted by the Monero blockchain.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec6">&#13;
<h4 class="H2"><span id="sec6"/><span id="h2-188"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Hierarchical Key Derivation</samp></h4>&#13;
<p class="TNI">Blockchain users generally want to manage multiple accounts, such that each account consists of a key pair where:</p>&#13;
<ul class="ul">&#13;
<li class="BL">The <i>private key</i> must be secret, as it’s the signing key required to sign transactions and transfer funds from the account.</li>&#13;
<li class="BL">The <i>public key</i> must be public, as it’s used to verify signatures of transactions. It’s also the value from which the account’s address is derived. For example, Bitcoin derives addresses from a public key using a combination of SHA-256 and RIPEMD-160 hashing. Note that in some blockchains, such as Bitcoin, the public key is not public until the account issues a transaction.</li>&#13;
</ul>&#13;
<p class="TX">To reliably manage all these keys, blockchain developers defined <i>hierarchical deterministic wallets (HD wallets)</i>, which make key management less cumbersome and risky than having to generate and back up a fresh random key for each new account.</p>&#13;
<p class="TX">With HD wallets, you generate and store one secret, the <i>seed</i> (also called the <i>master key</i> or <i>entropy</i>). This seed is the only randomly generated value and the only one providing entropy, or uncertainty, and therefore secrecy to the private signing keys derived from it. Wallet software applications often encode the seed as a <i>seed phrase</i>, or <i>mnemonic</i>, a sequence of 12 to 24 words that makes it easier to save and memorize.</p>&#13;
<p class="TX">Let’s review how this key derivation works using the HMAC-SHA-512 pseudorandom function (the HMAC construction instantiated with SHA-512): from a seed <i>S</i> of 128 or 256 bits, compute HMAC-SHA-512 with the seed as a key input, and as a message input an identifier of the underlying elliptic curve (a string that can be “Bitcoin seed,” “Nist256p1 seed,” or “ed25519 seed”). The first 256 bits of the result are the master key, <i>k</i>, and the last 256 bits are the master chain code, <i>c</i>, a value used to derive more keys.</p>&#13;
<p class="TX">You can derive a <i>child private key</i> from <i>k</i> and <i>c</i> as follows, given an identifier <i>i</i> (a number at most 2<sup>31</sup>): compute HMAC-SHA-512 with the chain code <i>c</i> as a key, and a message including <i>k</i> and <i>i</i>. The 512-bit result is parsed as a 256-bit value <i>L</i> followed by a 256-bit chain code <i>R</i>. In simplified notation, <i>L</i> || <i>R</i> = HMAC-SHA-512(<i>c</i>, <i>k</i> || <i>i</i>). You then set the child private key to <i>k</i> + <i>L</i>, and its chain code is <i>R</i>.</p>&#13;
<p class="TX">You can in turn derive keys from the obtained key and chain code to establish a key <i>hierarchy</i>. For example, from the key with index 0, you derive all your keys for Bitcoin, and from the key with index 60, you derive all your keys for Ethereum. Conventions associating a number to each blockchain network are standardized as part of the document “SLIP-0044: Registered Coin Types for BIP-0044.”</p>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_302" aria-label="302"/>If you first derive a child key with identifier 0 and next derive a key with identifier (say) 29 from this key and its chain code, then the key’s <i>derivation path</i> is 0/29. You’ll have done two calls of HMAC-SHA-512, yielding, respectively, <i>L</i><sub>1</sub> and <i>L</i><sub>2</sub> as their first 256 bits, and the final private key is <i>k</i> + <i>L</i><sub>1</sub> + <i>L</i><sub>2</sub>. Therefore, you can see all keys derived from a given master key <i>k</i> as <i>k</i> plus the sum of values HMAC-SHA-512 returns. This derivation is called <i>hardened</i> because you need both the private key <i>k</i> and the chain code <i>c</i> of the parent key.</p>&#13;
<blockquote>&#13;
<p class="Note"><span class="NoteHead"><samp class="SANS_Dogma_OT_Bold_B_15">NOTE</samp></span></p>&#13;
</blockquote>&#13;
<p class="NOTE-TXT"><i>For the</i> <span class="note_Italic">nonhardened</span> <i>version, use the public key instead of the private key, which allows you to determine the public key of a child key from its parent public key. For more details, see the initial Bitcoin standard document “BIP32: Hierarchical Deterministic Wallets” and its generalized standard document “SLIP-0010: Universal Private Key Derivation from Master Private Key.”</i></p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec7">&#13;
<h4 class="H2"><span id="sec7"/><span id="h2-189"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Algebraic Hash Functions</samp></h4>&#13;
<p class="TNI">Hash functions like SHA-3 and BLAKE3 operate on <i>bytes</i>, or on <i>words</i> of 4 or 8 bytes, where a byte is a chunk of 8 bits. The input data is a sequence of bytes, where each byte can take any of the 256 possible values from 0x00 to 0xff (255), and likewise the output data is a sequence of arbitrary bytes. This works well when using data efficiently converted into a sequence of bytes and when operations on bytes or words are efficient (such as XOR, word bit shift, and integer addition).</p>&#13;
<section epub:type="division" aria-labelledby="sec8">&#13;
<h5 class="H3"><span id="sec8"/><samp class="SANS_Futura_Std_Bold_Condensed_B_11">The Mathematical Computer</samp></h5>&#13;
<p class="TNI">Say you have a computer that works with numbers only in a given range, such as numbers modulo 13. The XOR operation won’t do well with such numbers, because not all 4-bit numbers are less than 13; for example, a XOR between 10 and 4 will give you 14, which is out of range. You might reduce it modulo 13 to obtain 1, but then 10 XOR 4 yields the same result as 10 XOR 11, a problem you don’t have when working with bytes. This tends to significantly reduce the security of the hash function—through collisions, for example.</p>&#13;
<p class="TX">Even worse, your computer knows only operations modulo 13: addition, subtraction, multiplication, and division. It doesn’t have a built-in bitwise XOR instruction, so it simulates it with its modulo 13 arithmetic instructions, which isn’t straightforward or computationally efficient. I’ll leave the details of this simulation as an exercise.</p>&#13;
<p class="TX">Your task is to create a hash function that works only (or mostly) with arithmetic operations for the given range of numbers and doesn’t use bitwise operations including XOR, OR, AND, or bit shifts.</p>&#13;
<p class="TX">You need this kind of function to efficiently run certain advanced cryptographic protocols—namely, multiparty computation (MPC) and zero-knowledge proofs, which you’ll see later in this chapter. Such protocols often operate in the realm of mathematical structures such as finite fields (for example, sets of integers modulo a prime number) and sometimes have <span role="doc-pagebreak" epub:type="pagebreak" id="pg_303" aria-label="303"/>to “convert” a program into mathematical equations. In principle, you can convert any program into equations. But when the program isn’t optimized for the underlying math structure, the equations get very large and slow to compute. <i>Algebraic hash functions</i> aim to address this issue by designing hash functions that are both secure and easy to implement with only arithmetic operations in a finite field.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec9">&#13;
<h5 class="H3"><span id="sec9"/><samp class="SANS_Futura_Std_Bold_Condensed_B_11">Design Principles</samp></h5>&#13;
<p class="TNI">Let’s consider the design principles of <i>Poseidon</i>, a hash function designed in 2019 for zero-knowledge proof systems and rapidly adopted by many blockchain systems. Such proofs sometimes have to express a hash function as a circuit of arithmetic operations over a large finite field, such as those of integers modulo a 255-bit prime number. In that case, Poseidon proved orders of magnitude more efficient than general-purpose hash functions like SHA-256.</p>&#13;
<p class="TX">Poseidon uses the sponge hash function construction (see <span class="Xref"><a href="chapter7.xhtml">Chapter 7</a></span>), so it needs to construct a <i>permutation</i>, an invertible transformation with input and output of the same size. It applies this permutation to a state that is a vector of finite field elements. In the relevant applications, such a finite field usually consists of numbers modulo a prime, which may be as small as 31 bits and as large as 381 bits, depending on the application.</p>&#13;
<p class="TX">Then, like most hash functions, the permutation iterates a series of rounds, so it needs to design a <i>round function</i>.</p>&#13;
<p class="TX">Finally, Poseidon breaks down its permutation into three layers, with three different purposes, reminiscent of AES’s rounds:</p>&#13;
<ul class="ul">&#13;
<li class="BL">A <i>unicity</i> layer, <i>AddRoundConstants</i>, which Poseidon notes as <i>ARC</i>() in the documentation. This adds constant values to the state’s elements, such that the constants are different for each round. Making each round unique prevents attacks including the slide attack. To avoid defining and storing many constants, Poseidon generates constants from a deterministic random bit generator initialized with an encoding of the Poseidon instance characteristics (number of rounds, finite field, S-box type, and so on).</li>&#13;
<li class="BL">A <i>nonlinear</i> layer or <i>S-box layer</i>, <i>SubWords</i>, which Poseidon’s documentation notes as <i>S</i>. This layer adds <i>confusion</i>, the property that the input and output values of the function are related by high-degree algebraic equations—and thus are as far as possible from linear and low-degree equations, which differential cryptanalysis can exploit. S-box transforms each element of its state independently of the others, typically mapping a field element <i>x</i> to <i>x</i><sup>3</sup> or <i>x</i><sup>5</sup>. The exponent is kept relatively low to be efficiently computed.</li>&#13;
<li class="BL">A <i>linear</i> layer, <i>MixLayer</i>, which Poseidon notes as <i>M</i>() in the documentation. MixLayer brings <i>diffusion</i>, or the propagation of differences in the initial state across all elements. For example, if the state consists of the four-element vector (<i>x</i><sub>1</sub>, <i>x</i><sub>2</sub>, <i>x</i><sub>3</sub>, <i>x</i><sub>4</sub>), then <i>M</i>() replaces each element with a linear combination of all elements. It might replace <i>x</i><sub>1</sub> with <span role="doc-pagebreak" epub:type="pagebreak" id="pg_304" aria-label="304"/>the result of 2<i>x</i><sub>1</sub> + 10<i>x</i><sub>2</sub> + <i>x</i><sub>3</sub> + 3<i>x</i><sub>4</sub>. Such a transformation corresponds to a multiplication of a vector by a matrix. Poseidon’s matrices must satisfy certain security properties and should be designed for efficient implementation.</li>&#13;
</ul>&#13;
<p class="TX">A <i>full round</i> of Poseidon applies the three layers in this order: <i>ARC</i>(), <i>S</i> to each element, and <i>M</i>(). A <i>partial round</i> applies <i>S</i> to only one element and may use a different matrix in <i>M</i>(). A Poseidon <i>instance</i> then iterates full rounds, partial rounds, and full rounds—the number of which depends on the instance, number of elements, finite field, and target security level.</p>&#13;
<blockquote>&#13;
<p class="Note"><span class="NoteHead"><samp class="SANS_Dogma_OT_Bold_B_15">NOTE</samp></span></p>&#13;
</blockquote>&#13;
<p class="NOTE-TXT"><i>For more details on Poseidon, see</i> <span class="note_LinkURL_Italic"><a href="https://www.poseidon-hash.info">https://<wbr/>www<wbr/>.poseidon<wbr/>-hash<wbr/>.info</a></span> <i>as well as the initial Poseidon paper (</i><span class="note_LinkURL_Italic"><a href="https://eprint.iacr.org/2019/458.pdf">https://<wbr/>eprint<wbr/>.iacr<wbr/>.org<wbr/>/2019<wbr/>/458<wbr/>.pdf</a></span><i>) and the improved design Poseidon2 paper (</i><span class="note_LinkURL_Italic"><a href="https://eprint.iacr.org/2023/323.pdf">https://<wbr/>eprint<wbr/>.iacr<wbr/>.org<wbr/>/2023<wbr/>/323<wbr/>.pdf</a></span><i>).</i></p>&#13;
<p class="TX">Poseidon is one of many algebraic hash functions created to address practical use cases. Other designs include MiMC, Monolith, Rescue-Prime, and Tip5.</p>&#13;
</section>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec10">&#13;
<h4 class="H2"><span id="sec10"/><span id="h2-190"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">How Things Can Go Wrong</samp></h4>&#13;
<p class="TNI">Let’s look at some security failures that involve hash functions and their applications in the blockchain world.</p>&#13;
<section epub:type="division" aria-labelledby="sec11">&#13;
<h5 class="H3"><span id="sec11"/><samp class="SANS_Futura_Std_Bold_Condensed_B_11">Broken Custom Hash</samp></h5>&#13;
<p class="TNI">The 2017 blockchain project Iota was quite weird. It claimed to use an architecture different from the sequential chain of blocks of most blockchains, closer to direct acyclic graph (DAG), which was much less secure. It also encoded data not in bits but in <i>trits</i>, units taking three values instead of two, supposedly to make computations more efficient on processors that don’t exist.</p>&#13;
<p class="TX">Iota didn’t use an elliptic curve-based signature scheme like ECDSA or Ed25519 but rather a hash-based signature scheme based on the established Winternitz construction, thus offering post-quantum security—except Iota also designed its own custom hash function, Curl.</p>&#13;
<p class="TX">Iota became one of the top 10 most popular cryptocurrencies and made grandiose claims about its potential usefulness and its security. But its custom hash function, which it claimed to develop with the aid of artificial intelligence, turned out to be very weak against collision attacks. Using off-the-shelf hardware, researchers found collisions within minutes, which could be exploited only in contrived attack scenarios. Iota quickly patched its hash function.</p>&#13;
<p class="TX">After this fiasco, renowned cryptography and security expert Bruce Schneier commented, “In 2017, leaving your crypto algorithm vulnerable to differential cryptanalysis is a rookie mistake. It says that no one of any caliber analyzed their system, and that the odds that their fix makes the system secure is low.”</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec12">&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_305" aria-label="305"/>&#13;
<h5 class="H3"><span id="sec12"/><samp class="SANS_Futura_Std_Bold_Condensed_B_11">Wallet with Low Entropy</samp></h5>&#13;
<p class="TNI">The hierarchical key derivation model from earlier in this section is secure on paper but in practice only if it’s implemented correctly. You can usually verify this using test vectors within the BIP32 and SLIP-0010 standard documents. If you obtain the same input/output values as those documented, your implementation is likely correct, though not necessarily secure.</p>&#13;
<p class="TX">In 2022, the popular cryptocurrency mobile wallet application Trust Wallet announced the release of a browser extension version that used WebAssembly (Wasm) technology to run efficiently on different browsers. However, Wasm couldn’t use the same PRNG as the mobile versions; it had to define a different one.</p>&#13;
<p class="TX">A poor PRNG can be cryptography’s Achilles’ heel (see <span class="Xref"><a href="chapter2.xhtml">Chapter 2</a></span>). In Trust Wallet, the developers used the Mersenne Twister PRNG (mt19937), which is not a cryptographic PRNG. Its entropy is at most 32 bits, and it produces its output bits using simple linear combinations of the internal state values.</p>&#13;
<p class="TX">As Trust Wallet’s PRNG had 32 bits of entropy, it could generate only 2<sup>32</sup> different seeds for users’ wallets. An attacker could then compute all the 2<sup>32</sup> possible seeds and, for each seed, compute the private keys and addresses derived using hierarchical key derivation. They could then scan blockchains to find addresses generated by Trust Wallet and steal their tokens. The Ledger company researchers who found the flaw commented, “Running such an attack takes much more than a couple of hours, but is doable with a few GPUs in less than a day.”</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec13">&#13;
<h5 class="H3"><span id="sec13"/><samp class="SANS_Futura_Std_Bold_Condensed_B_11">Collisions from Domain Separation Failures</samp></h5>&#13;
<p class="TNI">Let’s discuss how to find collisions for a hash function that is collision resistant. As cryptographer Moti Yung said, “If it sounds impossible, then it’s cryptographically interesting.”</p>&#13;
<p class="TX">Imagine the following simple case: an application receives messages <i>A</i> and <i>B</i> from two parties, Alice and Bob, and then hashes these two messages together to create a hash value unique for these messages. It could then compute <b>H</b>(<i>A</i> || <i>B</i>) by hashing the string consisting of <i>A</i> followed by <i>B</i>. Even if your hash function is collision resistant, you’ll get the same hash value for <i>A</i> = COL and <i>B</i> = LISION as for <i>A</i> = CO and <i>B</i> = LLISION. You end up with a hash collision with respect to the application’s input values, although it’s not a collision for the hash function because the hash function <b>H</b> processes the same string in the two cases, COLLISION.</p>&#13;
<p class="TX">To avoid the problem, encode the application’s input values into a string that’s unique per input, with no ambiguous encoding: for each string, you should be able to uniquely identify the original set of input values. In our example, adding a dollar sign ($) character as a separator between the two inputs seems to avoid the collision between COL || LISION and CO || LLISION: you would get the strings COL$LISION and CO$LLISION, leading to different hash values.</p>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_306" aria-label="306"/>But a separator symbol isn’t enough to eliminate ambiguities when the character is authorized in the application’s input values. For example, take the string COL$$LISION as the concatenation of two input strings separated with $. You could have obtained that string from two pairs of inputs: COL and $LISION, COL$ and LISION. Note that the problem doesn’t occur when the input values are a fixed, constant size—for example, a first string of two characters and a second of three characters. Even in that case, it’s still safer to use some separator or encoding that prevents collisions, as a future patch may introduce variable-length input.</p>&#13;
<p class="TX">Researchers have found bugs of this type in threshold signing protocols, which you’ll see later in this chapter, as well as in e-voting protocols, where the resulting hash collisions could be exploited to violate the security properties of these protocols.</p>&#13;
</section>&#13;
</section>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec14">&#13;
<h3 class="H1"><span id="sec14"/><span id="h1-104"/><samp class="SANS_Futura_Std_Bold_B_11">Multisignature Protocols</samp></h3>&#13;
<p class="TNI">In a cryptographic <i>multisignature protocol</i>, participants jointly produce a signature of a message that’s functionally equivalent to having all parties separately sign the message; an obtained signature means all parties agreed to sign the message. The advantage is that instead of having as many signatures as signers, there’s only one. Anyone who has the public keys of all the signers can then verify the signature.</p>&#13;
<p class="TX">Blockchain platforms employ multisignatures when multiple parties manage an account to ensure that all parties endorse issued transactions. A single party can also use them if they have multiple keys on multiple devices to prevent a single compromised key from allowing the attack to issue transactions. Such multisignature protocols are one of the many types of <i>collective signature</i> protocols, where parties run a protocol to produce a signature.</p>&#13;
<p class="TX">Before diving into the technical details, let’s clarify how these multisignatures differ from related protocols.</p>&#13;
<section epub:type="division" aria-labelledby="sec15">&#13;
<h4 class="H2"><span id="sec15"/><span id="h2-191"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Multiple Multiparty Signatures</samp></h4>&#13;
<p class="TNI">Despite their similar name, the multisignature protocols we’ll discuss are different from on-chain multisignature scripts or multisignature smart contracts, as used in Bitcoin and Ethereum, respectively. The latter aren’t cryptographic protocols because participants independently submit their individual signature to the blockchain network. The network in turn verifies a rule such as “if a transaction has signatures from <i>pub</i><sub>1</sub> and <i>pub</i><sub>2</sub>, then accept it” or “if a transaction is signed by any two parties among <i>pub</i><sub>1</sub>, <i>pub</i><sub>2</sub>, and <i>pub</i><sub>3</sub>, then accept it”—rejecting the transaction otherwise. Here we implicitly view public keys <i>pub</i> as the identifiers of the parties, as is common in blockchain protocols.</p>&#13;
<p class="TX">Compared to on-chain multisigs, multisignature protocols produce a single signature; there’s then only one signature to verify rather than multiple ones. The multisignature scripts and smart contracts instead process several signatures and consist of a verification rule rather than a protocol <span role="doc-pagebreak" epub:type="pagebreak" id="pg_307" aria-label="307"/>on the signers’ end. In both cases, verification requires the public keys of all signers.</p>&#13;
<p class="TX">Multisignature protocols also differ from two types of other collective signature protocols, which you’ll see in the following sections. In both protocols, the outcome is a single signature, but the difference is how and from what it’s created:</p>&#13;
<p class="ListHead"><b>Aggregate signature protocols</b></p>&#13;
<ul class="ul">&#13;
<li class="BL">Like in multisignatures, each participant has their own key pair (public and private keys).</li>&#13;
<li class="BL">Unlike in multisignatures, participants may sign different messages, rather than the same one. A participant can also sign multiple messages.</li>&#13;
<li class="BL">Like in multisignatures, the verification of a signature requires multiple public keys (or a single aggregate version thereof, for supporting protocols).</li>&#13;
</ul>&#13;
<p class="ListHead"><b>Threshold signature protocols</b></p>&#13;
<ul class="ul">&#13;
<li class="BL">Unlike in multisignatures, participants don’t use their own keys. Instead, they have shares (also called <i>shards</i>) of a single private key, such that no single participant ever knows the full key, even during the protocol’s execution.</li>&#13;
<li class="BL">Like in multisignatures, participants sign a single message.</li>&#13;
<li class="BL">Unlike in multisignatures, verification requires a single public key.</li>&#13;
</ul>&#13;
<p class="TX">Now that we’ve defined what multisignatures are, let’s see how they work in their most illustrious use case: Schnorr signatures.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec16">&#13;
<h4 class="H2"><span id="sec16"/><span id="h2-192"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Schnorr Signature Protocols</samp></h4>&#13;
<p class="TNI">Mathematician Claus-Peter Schnorr created the eponymous signature scheme in 1989 and filed a patent for it, which prevented its wide adoption until 2008, when the EdDSA scheme (see <span class="Xref"><a href="chapter12.xhtml">Chapter 12</a></span>) optimized it to work with modern elliptic curves. Schnorr’s scheme is simpler than the ECDSA standard, making it easier to turn into a multisignature scheme. Bitcoin supports Schnorr signatures, which were introduced in 2022 as better support for multisignature protocols.</p>&#13;
<blockquote>&#13;
<p class="Note"><span class="NoteHead"><samp class="SANS_Dogma_OT_Bold_B_15">NOTE</samp></span></p>&#13;
</blockquote>&#13;
<p class="NOTE-TXT"><i>We’ll use additive notation (as with EdDSA and when working with elliptic curve), rather than the original multiplicative notation (as used when working with integers in a multiplicative group). Therefore, the public key</i> <span class="note_Italic">A</span> <i>associated with a private key</i> <span class="note_Italic">a</span> <i>is the elliptic curve point</i> <span class="note_Italic">A</span> <i>=</i> <span class="note_Italic">aG</span><i>, where</i> <span class="note_Italic">G</span> <i>is a predefined base point, and group elements are points combined by addition. This is opposed to the multiplicative notation where we’d have</i> <span class="note_Italic">A</span> <i>=</i> <span class="note_Italic">g</span><sup>a</sup> <i>for some group generator</i> <span class="note_Italic">g</span><i>, where group elements are numbers multiplied together.</i></p>&#13;
<section epub:type="division" aria-labelledby="sec17">&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_308" aria-label="308"/>&#13;
<h5 class="H3"><span id="sec17"/><samp class="SANS_Futura_Std_Bold_Condensed_B_11">Single-Signer Schnorr Signatures</samp></h5>&#13;
<p class="TNI">Before seeing how multiparty signing works, let’s see how single-party Schnorr signing works. Suppose Alice has a private key <i>a</i>, with associated public key <i>A</i> = <i>aG</i>. Here <i>a</i> is a number, or scalar, in a given range of numbers (specifically, the finite field over which the elliptic curve is defined, typically positive integers modulo some large prime numbers, of at least approximately 256 bits), and <i>G</i> is a fixed base point of the curve.</p>&#13;
<p class="TX">To sign a message <i>M</i>, Alice proceeds as follows:</p>&#13;
<p class="NLF">  1.  Pick a secret random number, <i>r</i>, and compute the point <i>R</i> = <i>rG</i>. The value <i>r</i> is a <i>nonce</i>, a one-time private key with <i>R</i> its public key.</p>&#13;
<p class="NL">  2.  Compute <i>h</i> = <b>H</b>(<i>R</i> || <i>A</i> || <i>M</i>), the value that you’ll “connect” to the private key <i>a</i> and the one-time private key <i>r</i> to sign <i>M</i>. We not only hash the message but also bind <i>h</i> to the signer and the nonce, respectively, via the nonsecret values <i>A</i> and <i>R</i>. Without these, different attacks would be possible.</p>&#13;
<p class="NLL">  3.  Compute <i>s</i> = <i>r</i> + <i>ha</i> and return the pair (<i>R</i>, <i>s</i>) as a signature. You can see <i>s</i> as the multiplication between the secret key and the data to sign, where the secret <i>r</i> masks the result; without this, it’s trivial to recover the private key from a signature.</p>&#13;
<p class="TX">Verify a signature by checking that <i>sG</i> equals <i>R</i> + <b>H</b>(<i>R</i> || <i>A</i> || <i>M</i>)<i>A</i>. This works because from <i>s</i> = <i>r</i> + <i>ha</i>, substituting <i>r</i> + <i>ha</i> for <i>s</i> in <i>sG</i>, you obtain</p>&#13;
<figure class="DIS-IMG"><img class="img1" src="../images/pg308-1.jpg" alt="" width="1385" height="37"/></figure>&#13;
<p class="Continued">with <i>h</i> = <b>H</b>(<i>R</i> || <i>A</i> || <i>M</i>), which the verifier must compute from the message <i>M</i>, the public key <i>A</i>, and the <i>R</i> part of the signature.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec18">&#13;
<h5 class="H3"><span id="sec18"/><samp class="SANS_Futura_Std_Bold_Condensed_B_11">Schnorr Multisignatures</samp></h5>&#13;
<p class="TNI">In multisignatures we don’t have one signer but multiple ones. For the sake of simplicity, we’ll describe the case of two cosigners: meet Bob, who’ll sign messages jointly with Alice. Bob’s private key is <i>b</i> and his public key is <i>B</i> = <i>bG</i>. To jointly create a multisignature, Alice and Bob could proceed as follows to sign a message <i>M</i>:</p>&#13;
<p class="NLF">  1.  Alice picks a nonce <i>r</i><sub>A</sub>, computes <i>R</i><sub>A</sub> = <i>r</i><sub>A</sub><i>G</i>, and sends <i>R</i><sub>A</sub> to Bob.</p>&#13;
<p class="NL">  2.  Bob picks a nonce <i>r</i><sub>B</sub>, computes <i>R</i><sub>B</sub> = <i>r</i><sub>B</sub><i>G</i>, and sends <i>R</i><sub>B</sub> to Alice.</p>&#13;
<p class="NL">  3.  They compute <i>R</i> = <i>R</i><sub>A</sub> + <i>R</i><sub>B</sub> and set <i>h</i> = <b>H</b>(<i>R</i> || <i>A</i> || <i>B</i> || <i>M</i>), the value that Alice and Bob will use to generate their part of the signature. A specific value of <i>h</i> is bound to the parties via their public keys (<i>A</i> and <i>B</i>) and bound to the current signing session via the nonce <i>R</i> only for the specific signature execution as defined by the nonce <i>R</i>.</p>&#13;
<p class="NL">  4.  Alice computes <i>s</i><sub>A</sub> = <i>r</i><sub>A</sub> + <i>ha</i> and sends it to Bob.</p>&#13;
<p class="NL">  5.  Bob computes <i>s</i><sub>B</sub> = <i>r</i><sub>B</sub> + <i>hb</i> and sends it to Alice.</p>&#13;
<p class="NLL"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_309" aria-label="309"/>  6.  They both compute <i>R</i> = <i>R</i><sub>A</sub> + <i>R</i><sub>B</sub> and <i>s</i> = <i>s</i><sub>A</sub> + <i>s</i><sub>B</sub> and return (<i>R</i>, <i>s</i>) as the signature.</p>&#13;
<p class="TX">To verify a signature, check that <i>sG</i> equals <i>R</i> + <i>h</i>(<i>A + B</i>). Substituting <i>s</i> in <i>sG</i> by the previously computed value results in the following:</p>&#13;
<figure class="DIS-IMG"><img class="img1" src="../images/pg309-1.jpg" alt="" width="1385" height="109"/></figure>&#13;
<p class="TX">Note that the verifier needs to know both <i>A</i> and <i>B</i>, and not only their sum <i>A</i> + <i>B</i>, because they need both values to compute <b>H</b>(<i>R</i> || <i>A</i> || <i>B</i> || <i>M</i>). However, if <i>h</i> is instead defined as <b>H</b>(<i>R</i> || <i>A</i> + <i>B</i> || <i>M</i>), a verifier can use a single public key <i>A</i> + <i>B</i> without knowing that the signature is issued by two parties. We call the “merging” of multiple public keys into one <i>key aggregation</i>. This is particularly useful to reduce the size of the data to hash when there are many signers.</p>&#13;
<blockquote>&#13;
<p class="Note"><span class="NoteHead"><samp class="SANS_Dogma_OT_Bold_B_15">NOTE</samp></span></p>&#13;
</blockquote>&#13;
<p class="NOTE-TXT"><i>I’ve described basic Schnorr multisignatures in the case of two parties, but the protocol scales to an arbitrary number of parties with public keys</i> <span class="note_Italic">P</span><span class="ePub-I-SUB">1</span><i>,</i> <span class="note_Italic">P</span><span class="ePub-I-SUB">2</span> <i>, . . . ,</i> <span class="note_Italic">P</span><sub>n</sub><i>. In the definition, replace</i> <span class="note_Italic">A</span> <i>+</i> <span class="note_Italic">B</span> <i>with</i> <span class="note_Italic">P</span><span class="ePub-I-SUB">1</span> <i>+</i> <span class="note_Italic">P</span><span class="ePub-I-SUB">2</span> <i>+ . . . +</i> <span class="note_Italic">P</span><sub>n</sub><i>, replace</i> <span class="note_Italic">A</span> <i>||</i> <span class="note_Italic">B</span> <i>with</i> <span class="note_Italic">P</span><span class="ePub-I-SUB">1</span> <i>||</i> <span class="note_Italic">P</span><span class="ePub-I-SUB">2</span> <i>|| . . . ||</i> <span class="note_Italic">P</span><sub>n</sub><i>, and replace “sends it to Bob/Alice” with “sends it to everyone.” You can apply a similar protocol to EdDSA and Ed25519, variants of Schnorr’s scheme.</i></p>&#13;
</section>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec19">&#13;
<h4 class="H2"><span id="sec19"/><span id="h2-193"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">How Things Can Go Wrong</samp></h4>&#13;
<p class="TNI">The Schnorr multisignature protocol is relatively simple but may fail in the following attack scenarios.</p>&#13;
<section epub:type="division" aria-labelledby="sec20">&#13;
<h5 class="H3"><span id="sec20"/><samp class="SANS_Futura_Std_Bold_Condensed_B_11">Key Cancellation Attack</samp></h5>&#13;
<p class="TNI">In this attack, Bob convinces signature verifiers that he jointly signed a message with Alice, whereas Alice hasn’t seen the message and didn’t interact with Bob. An attacker could exploit this in a scenario where you expect Alice and Bob to jointly sign messages—for example, in transactions that require both parties’ approval. In the normal case, the verifiers would know Alice’s public key <i>A</i> and Bob’s public key <i>B</i>, and Bob and Alice would know each other’s keys.</p>&#13;
<p class="TX">Now suppose the following happens: Alice sends her public key <i>A</i> to everyone including Bob, but instead of sharing his public key <i>B</i>, Bob shares <i>C</i> = <i>B</i> – <i>A</i> = (<i>b</i> – <i>a</i>)<i>G</i> with the verifiers, and <i>B</i> with Alice. That Bob doesn’t know the private key corresponding to <i>C</i> won’t matter for the attack.</p>&#13;
<p class="TX">Bob has to sign a message using his private key <i>b</i>, as in the single-signer case, but with <i>h</i> = <b>H</b>(<i>R</i> || <i>A</i> || <i>C</i> || <i>M</i>), as if he were signing with Alice. He returns (<i>R</i>, <i>s</i>) as a signature, with <i>R</i> = <i>rG</i> for an <i>r</i> of his choice and <i>s</i> = <i>r</i> + <i>hb.</i></p>&#13;
<p class="TX">Expecting signatures from Alice and Bob, verifiers check that <i>sG</i> equals <i>R</i> + <i>h</i>(<i>A + C</i>), which is correct because <i>A</i> + <i>C</i> = <i>A</i> + (<i>B</i> – <i>A</i>) = <i>B</i>. Bob can therefore forge multisignature without even interacting with Alice and without knowing her private key.</p>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_310" aria-label="310"/>In practice, you can avoid this attack by requesting signers to prove the knowledge of the private key—for example, by signing a message. Since Bob doesn’t know the private key corresponding to <i>C</i>, he can’t provide such evidence. As you’ll see with the MuSig protocol, you can also avoid the attack at the protocol level.</p>&#13;
<p class="TX">The attack scales to an arbitrary number of parties, a context that’s often called a <i>rogue key attack</i>. Having received the public keys of all other parties, an attacker Bob would just define his public key as <i>B</i> – <i>X</i>, with <i>X</i> the sum of all other parties’ public keys.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec21">&#13;
<h5 class="H3"><span id="sec21"/><samp class="SANS_Futura_Std_Bold_Condensed_B_11">Repeated Nonces</samp></h5>&#13;
<p class="TNI">Like in ECDSA, repeated nonces are lethal to the Schnorr multisignature protocol. Imagine that Alice’s pseudorandom generator fails and she generates the same secret nonce <i>r</i><sub>A</sub> twice in two runs of the protocol: she sends an initial <i>s</i><sub>A</sub> = <i>r</i><sub>A</sub> + <i>ha</i> to Bob, and a second <i>s</i><sub>A</sub><i>'</i> = <i>r</i><sub>A</sub> + <i>h'a</i> where the first <i>h</i> and the second <i>h'</i> also depend on Bob’s randomness. You thus have <i>r</i><sub>A</sub> = <i>ha – s</i><sub>A</sub> and <i>r</i><sub>A</sub> = <i>h'a – s</i><sub>A</sub><i>'</i>, which implies <i>ha – s</i><sub>A</sub> = <i>h'a – s</i><sub>A</sub><i>'</i> or, equivalently,</p>&#13;
<figure class="DIS-IMG"><img class="img1" src="../images/pg310-1.jpg" alt="" width="1384" height="44"/></figure>&#13;
<p class="Continued">from which you can compute Alice’s private key <i>a</i> = (<i>s</i><sub>A</sub> – <i>s</i><sub>A</sub><i>'</i>) / (<i>h – h'</i>).</p>&#13;
<p class="TX">One approach to eliminate security risks caused by a randomness failure is to get rid of randomness. For example, computing the nonce by hashing the message and the private key as in Ed25519 works when there’s a single signer. However, setting <i>r</i> to <b>H</b>(<i>a</i> || <i>M</i>) won’t work in the case of multisignatures: if Alice and Bob sign the same message twice, then Alice computes a first <i>s</i><sub>A</sub> = <i>r</i><sub>A</sub> + <i>ha</i> and a second <i>s</i><sub>A</sub><i>'</i> = <i>r</i><sub>A</sub> + <i>h'a</i>, where in both cases <i>r</i><sub>A</sub> <i>=</i> <b>H</b>(<i>a</i> <b>||</b> <i>M</i>), where <i>h'</i> will be distinct from <i>h</i> if a malicious Bob sends a different value than <b>H</b>(<i>b</i> <b>||</b> <i>M</i>). In this case, Bob—and any eavesdropper of the communications—can again compute <i>a</i> as (<i>s</i><sub>A</sub> – <i>s</i><sub>A</sub><i>'</i>) / (<i>h – h'</i>).</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec22">&#13;
<h5 class="H3"><span id="sec22"/><samp class="SANS_Futura_Std_Bold_Condensed_B_11">Parallel Execution Insecurity</samp></h5>&#13;
<p class="TNI">The Schnorr multisignature protocol is insecure when the attacker can initiate multiple simultaneous signature protocols. The attack is too complicated to describe here but is documented in the research articles available at <i><a href="https://eprint.iacr.org/2018/417">https://<wbr/>eprint<wbr/>.iacr<wbr/>.org<wbr/>/2018<wbr/>/417</a></i> and <i><a href="https://eprint.iacr.org/2020/945">https://<wbr/>eprint<wbr/>.iacr<wbr/>.org<wbr/>/2020<wbr/>/945</a></i>.</p>&#13;
</section>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec23">&#13;
<h4 class="H2"><span id="sec23"/><span id="h2-194"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Safer Schnorr Multisignatures</samp></h4>&#13;
<p class="TNI">To avoid the key cancellation attack and repeated nonce issues, researchers developed more advanced multisignature protocols and in particular the MuSig protocols: MuSig, MuSig2, and MuSig-DN, where <i>MuSig</i> stands for <i>multisignature</i> and <i>DN</i> for <i>deterministic nonce</i>. MuSig protocols also support key aggregation to allow a verifier to check a signature using only one public key that’s derived from the signers’ keys, such that the aggregated key doesn’t reveal the number of signers or their public keys.</p>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_311" aria-label="311"/>Let’s see MuSig’s main trick in action. If we’re in the simplest case of two signers, Alice and Bob, using the same notations as in the previous sections, instead of computing <i>s</i><sub>A</sub> = <i>r</i><sub>A</sub> + <i>ha</i> as her share of the signature, Alice computes <i>s</i><sub>A</sub> = <i>r</i><sub>A</sub> + <i><span xml:lang="el" lang="el">μ</span></i><sub>A</sub><i>ha</i>, thus multiplying the <i>ha</i> part with the <i><span xml:lang="el" lang="el">μ</span></i><sub>A</sub> value. She computes <i><span xml:lang="el" lang="el">μ</span></i><sub>A</sub> (where <i><span xml:lang="el" lang="el">μ</span></i> is the Greek letter mu) by hashing the list of participants’ public keys followed by Alice’s key, <b>H</b>(<i>A</i> || <i>B</i> || <i>A</i>). Likewise, Bob computes <i>s</i><sub>B</sub> = <i>r</i><sub>B</sub> + <i><span xml:lang="el" lang="el">μ</span></i><sub>B</sub><i>hb</i> with <i><span xml:lang="el" lang="el">μ</span></i><sub>B</sub> = <b>H</b>(<i>A</i> || <i>B</i> || <i>B</i>), hashing the list of public keys followed by his key.</p>&#13;
<p class="TX">Alice then computes the <i>aggregate public key</i> as <i>X</i> = <i><span xml:lang="el" lang="el">μ</span></i><sub>A</sub><i>A</i> + <i><span xml:lang="el" lang="el">μ</span></i><sub>B</sub><i>B</i>, the sum of the public keys multiplied by their respective <i><span xml:lang="el" lang="el">μ</span></i> values. The hash of the message is then <i>h</i> = <b>H</b>(<i>R</i> || <i>X</i> || <i>M</i>) instead of <b>H</b>(<i>R</i> || (<i>A</i> + <i>B</i>) || <i>M</i>) in the vulnerable version multisignature scheme supporting key aggregation.</p>&#13;
<p class="TX">This trick works because a malicious Bob can no longer forge another public key that would “cancel” Alice’s <i>A</i>, as he could by setting <i>C</i> = <i>B</i> – <i>A</i> in the key cancellation attack. In the equation <i>X</i> = <i><span xml:lang="el" lang="el">μ</span></i><sub>A</sub><i>A</i> + <i><span xml:lang="el" lang="el">μ</span></i><sub>B</sub><i>B</i>, Bob has to find a new value of <i>B</i> that yields the “right” <i><span xml:lang="el" lang="el">μ</span></i> coefficients to remove <i>A</i> from the equation. But that’s now impossible because the equation is nonlinear with respect to <i>A</i> and <i>B</i> (linearity is often synonymous with insecurity—see <span class="Xref"><a href="chapter2.xhtml">Chapter 2</a></span>).</p>&#13;
<p class="TX">When there are more than two signers, you apply the trick in a similar way, computing the <i><span xml:lang="el" lang="el">μ</span></i> coefficients by hashing the list of keys followed by the signer’s key and then aggregating the public keys into a single <i>X</i> by computing the sum of the public keys multiplied by their respective <i><span xml:lang="el" lang="el">μ</span></i>.</p>&#13;
<blockquote>&#13;
<p class="Note"><span class="NoteHead"><samp class="SANS_Dogma_OT_Bold_B_15">NOTE</samp></span></p>&#13;
</blockquote>&#13;
<p class="NOTE-TXT"><i>For more details on the MuSig protocols and how the MuSig-DN version securely derives nonces from the message, see</i> <span class="note_LinkURL_Italic"><a href="https://bitcoinops.org/en/topics/musig/">https://<wbr/>bitcoinops<wbr/>.org<wbr/>/en<wbr/>/topics<wbr/>/musig<wbr/>/</a></span>.</p>&#13;
</section>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec24">&#13;
<h3 class="H1"><span id="sec24"/><span id="h1-105"/><samp class="SANS_Futura_Std_Bold_B_11">Aggregate Signature Protocols</samp></h3>&#13;
<p class="TNI"><i>Aggregate signatures</i> have multiple signers, and each signer signs a message (which can be distinct for all signers); then these signatures are merged into a single signature. From only this signature and from the signers’ public keys and the messages they signed, verification checks that all signers signed their respective messages. Because a single signature must be stored, instead of as many signatures as signers, verification time is proportional to the number of messages. When all signers sign the same message, verification can be as fast as the verification of a single signer’s signature, regardless of the number of signers.</p>&#13;
<p class="TX">Aggregate signatures are notably used in Ethereum, specifically in its consensus layer. In this use case, validator nodes endorse proposals to change the state of the system (as blocks) and leverage aggregate signatures to minimize the signature storage space and verification time. They use the Boneh–Lynn–Shacham (BLS) signature scheme, which you’ll learn about in this section, starting with the magic behind BLS signatures: cryptographic pairings.</p>&#13;
<section epub:type="division" aria-labelledby="sec25">&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_312" aria-label="312"/>&#13;
<h4 class="H2"><span id="sec25"/><span id="h2-195"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Pairings</samp></h4>&#13;
<p class="TNI">In elliptic curve cryptography, a <i>pairing</i> is an operation that transforms two points from two elliptic curve groups (not necessarily the same) into a finite field element. The standard notation for a pairing between two elliptic curve points <i>P</i> and <i>Q</i> is <i>e</i>(<i>P</i>, <i>Q</i>). Pairings used in cryptography have the property called <i>bilinearity</i> and are thus called <i>bilinear pairings</i>, which means they satisfy the following for any points <i>P</i>, <i>Q</i>, and <i>R</i>:</p>&#13;
<figure class="DIS-IMG"><img class="img1" src="../images/pg312-1.jpg" alt="" width="1392" height="107"/></figure>&#13;
<p class="TX">Here, adding a point <i>R</i> to an operand is equivalent to multiplying the result by the pairing between <i>R</i> and the other operand. Consequently, if you add a point to itself <i>n</i> times—that is, if you multiply it by a number <i>n</i>—then you have</p>&#13;
<figure class="DIS-IMG"><img class="img1" src="../images/pg312-2.jpg" alt="" width="1392" height="41"/></figure>&#13;
<p class="Continued">or <i>e</i>(<i>P</i>, <i>Q</i>) multiplied by itself <i>n</i> times, which is also equal to <i>e</i>(<i>P</i>, <i>nQ</i>).</p>&#13;
<p class="TX">If you have different points <i>P</i><sub>1</sub>, <i>P</i><sub>2</sub>, . . . , <i>P</i><span class="ePub-I-SUB">n</span>, you can turn addition of the input values into multiplication of the output values:</p>&#13;
<figure class="DIS-IMG"><img class="img1" src="../images/pg312-3.jpg" alt="" width="1392" height="44"/></figure>&#13;
<p class="TX">The internals of how pairings work is beyond this book’s scope. For more details, see the article “Cryptographic Pairings” by Kristin Lauter and Michael Naehrig (<i><a href="https://eprint.iacr.org/2017/1108">https://<wbr/>eprint<wbr/>.iacr<wbr/>.org<wbr/>/2017<wbr/>/1108</a></i>) and the book <i>Guide to Pairing-Based Cryptography</i> by Nadia El Mrabet and Marc Joye (Chapman and Hall/CRC, 2016).</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec26">&#13;
<h4 class="H2"><span id="sec26"/><span id="h2-196"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">BLS Signatures</samp></h4>&#13;
<p class="TNI">BLS signatures were presented in 2006 in the article “Short Signatures from the Weil Pairing” by Dan Boneh, Ben Lynn, and Hovav Shacham. It stated that the scheme was designed “for systems where signatures are typed in by a human or signatures are sent over a low-bandwidth channel.” BLS signatures turned out to be used in highly automated systems over high-bandwidth channels, which benefited from a property described in a subsequent paper: aggregation of signatures and of public keys.</p>&#13;
<blockquote>&#13;
<p class="Note"><span class="NoteHead"><samp class="SANS_Dogma_OT_Bold_B_15">NOTE</samp></span></p>&#13;
</blockquote>&#13;
<p class="NOTE-TXT"><i>Don’t confuse BLS signatures with BLS (Barreto–Lynn–Scott) curves, which have an author (Lynn) in common. BLS curves are elliptic curves designed to be pairing friendly, allowing secure and efficient pairing operations. In fact, BLS signatures often work with points over a BLS curve. For example, the Ethereum BLS signature relies on the curve BLS12-381.</i></p>&#13;
<section epub:type="division" aria-labelledby="sec27">&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_313" aria-label="313"/>&#13;
<h5 class="H3"><span id="sec27"/><samp class="SANS_Futura_Std_Bold_Condensed_B_11">Single-Signer Signature and Verification</samp></h5>&#13;
<p class="TNI">In BLS signatures, Alice’s private key is a scalar number <i>a</i>, and her public key is <i>A</i> = <i>aG</i>, for a predefined base point <i>G</i>. To sign a message <i>M</i>, she first computes <i>H</i> = <b>H</b>(<i>M</i>), where the hash function returns a curve point rather than a bit string or a scalar—the <i>H</i> notation follows the general convention that you denote points as capital letters. The signature is then <i>S</i> = <i>aH</i>. This looks much simpler than a Schnorr’s or an ECDSA signature: just hash the message and multiply the result with the private key.</p>&#13;
<p class="TX">To verify a BLS signature, compute two pairing operations:</p>&#13;
<ul class="ul">&#13;
<li class="BL"><i>e</i>(<i>A</i>, <i>H</i>) between the public key and the hashed message (note that <i>A</i> = <i>aG</i>)</li>&#13;
<li class="BL"><i>e</i>(<i>G</i>, <i>S</i>) between the base point and the signature (note that <i>S</i> = <i>aH</i>)</li>&#13;
</ul>&#13;
<p class="Continued">These values should be equal because of the pairing’s bilinearity property:</p>&#13;
<figure class="DIS-IMG"><img class="img1" src="../images/pg313-1.jpg" alt="" width="1387" height="38"/></figure>&#13;
<p class="Continued">If the equality holds, the signature is accepted; otherwise, it’s rejected.</p>&#13;
<p class="TX">Ignoring the complexity of the pairing operation, such pairing-based signatures are the simplest signature scheme.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec28">&#13;
<h5 class="H3"><span id="sec28"/><samp class="SANS_Futura_Std_Bold_Condensed_B_11">Aggregate Signatures from Multiple Signers</samp></h5>&#13;
<p class="TNI">Let’s further exploit the magic of BLS signatures and bilinear pairings, considering a scenario wherein <i>n</i> signers with private keys <i>k</i><sub>1</sub>, <i>k</i><sub>2</sub>, . . . , <i>k</i><span class="ePub-I-SUB">n</span> and public keys <i>P</i><sub>1</sub>, <i>P</i><sub>2</sub>, . . . , <i>P</i><span class="ePub-I-SUB">n</span> sign <i>n</i> messages <i>M</i><sub>1</sub>, <i>M</i><sub>2</sub>, . . . , <i>M</i><span class="ePub-I-SUB">n</span> and produce the signatures <i>S</i><sub>1</sub>, <i>S</i><sub>2</sub>, . . . , <i>S</i><span class="ePub-I-SUB">n</span>. Note that <i>H</i><span class="ePub-I-SUB">i</span> = <b>H</b>(<i>M</i><span class="ePub-I-SUB">i</span>) is the hash of the <i>i</i>th message.</p>&#13;
<p class="TX">You can aggregate signatures <i>S</i><span class="ePub-I-SUB">i</span> = <i>k</i><span class="ePub-I-SUB">i</span><i>H</i><span class="ePub-I-SUB">i</span> into one by adding them to obtain <i>S</i> = <i>S</i><sub>1</sub> + <i>S</i><sub>2</sub> + . . . + <i>S</i><span class="ePub-I-SUB">n</span>. Observe that computing <i>e</i>(<i>G</i>, <i>S</i>), as in the verification of a single signature, results in the following, owing to the bilinearity property:</p>&#13;
<figure class="DIS-IMG"><img class="img1" src="../images/pg313-2.jpg" alt="" width="1387" height="44"/></figure>&#13;
<p class="Continued">Remember that pairings satisfy <i>e</i>(<i>nP</i>, <i>Q</i>) = <i>e</i>(<i>P</i>, <i>nQ</i>). You can thus replace each <i>e</i>(<i>G</i>, <i>S</i><span class="ePub-I-SUB">i</span>) term with <i>e</i>(<i>P</i><span class="ePub-I-SUB">i</span>, <i>H</i><span class="ePub-I-SUB">i</span>) by “moving” the multiplicative factor <i>k</i><span class="ePub-I-SUB">i</span> to the left operand of the pairing: the first operand will thus be <i>k</i><span class="ePub-I-SUB">i</span><i>G</i> = <i>P</i><span class="ePub-I-SUB">i</span> instead of <i>G</i>, and the second will be <i>H</i><span class="ePub-I-SUB">i</span> instead of <i>S</i><span class="ePub-I-SUB">i</span> = <i>k</i><span class="ePub-I-SUB">i</span><i>H</i><span class="ePub-I-SUB">i</span>.</p>&#13;
<p class="TX">After aggregating multiple signatures of multiple signers over multiple messages into a single signature, you can verify the aggregate signature from the signers’ public keys and messages signed. Verification just checks the equality between <i>e</i>(<i>G</i>, <i>S</i>) and the product of all pairings <i>e</i>(<i>P</i><span class="ePub-I-SUB">i</span>, <i>H</i><span class="ePub-I-SUB">i</span>). There are 1 + <i>n</i> pairings to compute, rather than the 2<i>n</i> pairings if you hadn’t aggregated the signatures—in this case, the signatures occupy <i>n</i> times as much memory as the aggregated one.</p>&#13;
<p class="TX">Let’s consider a scenario where you’ll aggregate both signatures and public keys.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec29">&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_314" aria-label="314"/>&#13;
<h5 class="H3"><span id="sec29"/><samp class="SANS_Futura_Std_Bold_Condensed_B_11">Aggregate Public Keys</samp></h5>&#13;
<p class="TNI">Imagine that all signers sign the same message <i>M</i> and that you aggregate all public keys into a single one: <i>P</i> = <i>P</i><sub>1</sub> + <i>P</i><sub>2</sub> + . . . + <i>P</i><span class="ePub-I-SUB">n</span>. Note that <i>k</i><sub>1</sub>, <i>k</i><sub>2</sub>, . . . , <i>k</i><span class="ePub-I-SUB">n</span> still represents their respective private keys and <i>H</i> = <b>H</b>(<i>M</i>) the hash of the message. Given valid signatures <i>S</i><span class="ePub-I-SUB">i</span>, you obtain the following equality:</p>&#13;
<figure class="DIS-IMG"><img class="img1" src="../images/pg314-1.jpg" alt="" width="1387" height="304"/></figure>&#13;
<p class="TX">You therefore verify the signatures of <i>n</i> parties over the same message using only two pairing operations, <i>e</i>(<i>P</i>, <i>H</i>) and <i>e</i>(<i>G</i>, <i>S</i>). This is extremely efficient, as it makes signature verification essentially independent of the number of parties, as you can add points efficiently, whereas pairings are costly to compute. In addition to the computing efficiency, aggregating keys and signatures also saves memory.</p>&#13;
</section>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec30">&#13;
<h4 class="H2"><span id="sec30"/><span id="h2-197"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">How Things Can Go Wrong</samp></h4>&#13;
<p class="TNI">Like many elliptic curve cryptography schemes, BLS signatures should avoid invalid keys and weak parameters to be secure. And like the previous protocols, BLS signatures could be vulnerable to key cancellation attack. Let’s explore the details.</p>&#13;
<section epub:type="division" aria-labelledby="sec31">&#13;
<h5 class="H3"><span id="sec31"/><samp class="SANS_Futura_Std_Bold_Condensed_B_11">Invalid Keys</samp></h5>&#13;
<p class="TNI">BLS signatures are specified in an Internet-Draft, a working document of the IETF available at <i><a href="https://github.com/cfrg/draft-irtf-cfrg-bls-signature">https://<wbr/>github<wbr/>.com<wbr/>/cfrg<wbr/>/draft<wbr/>-irtf<wbr/>-cfrg<wbr/>-bls<wbr/>-signature</a></i>. This specifies core operations including key generation (the algorithm <samp class="SANS_TheSansMonoCd_W5Regular_11">KeyGen</samp>), signature (<samp class="SANS_TheSansMonoCd_W5Regular_11">CoreSign</samp>), verification (<samp class="SANS_TheSansMonoCd_W5Regular_11">CoreVerify</samp>), and key validation (<samp class="SANS_TheSansMonoCd_W5Regular_11">KeyValidate</samp>). Given a public key, the latter ensures the validity of a public key in that it “represents a valid, non-identity point that is in the correct subgroup.”</p>&#13;
<p class="TX">Key validation prevents the use of weak private/public keys pairs, for which signatures are easier to forge. For example, take the trivial case of a zero secret key <i>a</i> = 0. It follows that the signature of any message <i>M</i> is 0 × <b>H</b>(<i>M</i>) = 0. It’s therefore trivial to forge a signature for any message. In that case, the public key is then 0 × <i>G</i> = <i>O</i>, which is the point at infinity. If key validation rejects public keys equal to <i>O</i>, it ensures that the secret key is not zero.</p>&#13;
<p class="TX">A less trivial case is when the public key, as an elliptic curve point, has a value that makes it easier to forge signatures—that is, to create a valid signature without knowing the private key. Not all points on a given elliptic curve are equally secure—in particular, points that belong to a small <span role="doc-pagebreak" epub:type="pagebreak" id="pg_315" aria-label="315"/>subgroup rather than to the main subgroup of points. If a public key point belongs to one such small subgroup, there will be way fewer possible valid signatures, making it easier to forge a signature. Likewise, if the public key offered to the verification function doesn’t belong to the elliptic curve, then valid signatures are easy to forge.</p>&#13;
<p class="TX">It’s therefore crucial to check that public keys are valid using the <samp class="SANS_TheSansMonoCd_W5Regular_11">KeyValidate</samp> algorithm from the aforementioned specification, as copied in <a href="chapter15.xhtml#Lis15-1">Listing 15-1</a>.</p>&#13;
<span id="Lis15-1"/><pre><code>Inputs:&#13;
- PK, a public key in the format output by SkToPk.&#13;
&#13;
Outputs:&#13;
- result, either VALID or INVALID&#13;
&#13;
Procedure:&#13;
1. xP = pubkey_to_point(PK)&#13;
2. If xP is INVALID, return INVALID&#13;
3. If xP is the identity element, return INVALID&#13;
4. If pubkey_subgroup_check(xP) is INVALID, return INVALID&#13;
5. return VALID</code></pre>&#13;
<p class="ListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 15-1: The</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">KeyValidate</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">algorithm ensures that a BLS public key is valid.</samp></p>&#13;
<p class="TX">If you implement BLS signatures, make sure your code does all the checks described in the BLS specification when validating public keys and signatures.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec32">&#13;
<h5 class="H3"><span id="sec32"/><samp class="SANS_Futura_Std_Bold_Condensed_B_11">Key Cancellation Attack</samp></h5>&#13;
<p class="TNI">In their basic form, BLS aggregate signatures with aggregate public keys are subject to the same type of key cancellation attack as Schnorr signatures: if an attacker knows the public keys <i>P</i><sub>1</sub>, <i>P</i><sub>2</sub>, . . . , <i>P</i><span class="ePub-I-SUB">n –</span> <sub>1</sub> of the first <i>n</i> – 1 signers, they can claim that their public key is</p>&#13;
<figure class="DIS-IMG"><img class="img1" src="../images/pg315-1.jpg" alt="" width="1390" height="45"/></figure>&#13;
<p class="Continued">where <i>X</i> is the public key for which they know the private key <i>x</i>, such that <i>X</i> = <i>xG</i>. When the attacker presents a signature created from <i>x</i>, unsuspecting users verify a message’s signature using the public key <i>P</i><sub>1</sub> + <i>P</i><sub>2</sub> + . . . + <i>P</i><span class="ePub-I-SUB">n</span>, which is equal to <i>X</i>. The attacker can single-handedly sign a message on behalf of the set of supposed signers.</p>&#13;
<p class="TX">To prevent this attack, users may prove the knowledge of their public key’s private key by signing a message. As the attacker doesn’t know the private key of <i>P</i><span class="ePub-I-SUB">n</span>, they would fail this test.</p>&#13;
<p class="TX">Another mitigation is to modify the aggregate signature scheme so that the returned signature isn’t just the sum of signature <i>S</i> = <i>S</i><sub>1</sub> + <i>S</i><sub>2</sub> + . . . + <i>S</i><span class="ePub-I-SUB">n</span> but instead the sum with coefficients derived from public keys, as in</p>&#13;
<figure class="DIS-IMG"><img class="img1" src="../images/pg315-2.jpg" alt="" width="1390" height="44"/></figure>&#13;
<p class="Continued"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_316" aria-label="316"/>where <i>t</i><span class="ePub-I-SUB">i</span> = <b>H</b>(<i>P</i><span class="ePub-I-SUB">i</span> || <i>P</i><sub>1</sub> || <i>P</i><sub>2</sub> || . . . || <i>P</i><span class="ePub-I-SUB">n</span>) for <i>i</i> = 1, 2, . . . , <i>n</i>. The aggregate public key used to verify a signature is then <i>P</i> = <i>t</i><sub>1</sub><i>P</i><sub>1</sub> + <i>t</i><sub>2</sub><i>P</i><sub>2</sub> + . . . + <i>t</i><span class="ePub-I-SUB">n</span><i>P</i><span class="ePub-I-SUB">n</span>. You can see that this trick works by checking that <i>e</i>(<i>P</i>, <b>H</b>(<i>M</i>)) still equals <i>e</i>(<i>G</i>, <i>S</i>).</p>&#13;
</section>&#13;
</section>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec33">&#13;
<h3 class="H1"><span id="sec33"/><span id="h1-106"/><samp class="SANS_Futura_Std_Bold_B_11">Threshold Signature Protocols</samp></h3>&#13;
<p class="TNI"><i>Threshold signatures</i> differ from multisignatures and aggregate signatures—which require all participants in the signing protocol to have their own public and private key—in that there’s a single private key <i>k</i> and a single public key <i>P</i>, and there are <i>n</i> participants that each has a distinct <i>share</i> of the key <i>k</i><span class="ePub-I-SUB">i</span> where a parameter <i>t</i> (the <i>threshold</i>) is defined such that <i>t</i> &lt; <i>n</i> and:</p>&#13;
<ul class="ul">&#13;
<li class="BL"><i>t</i> + 1 signers can jointly issue a valid signature of some message that is verified using the public key <i>P</i>, in such a way that no signer learns the private key <i>k</i>. This is done by running a protocol that uses the shares <i>k</i><span class="ePub-I-SUB">i</span> of each signer and the message to be signed, without ever exposing the private key to any party.</li>&#13;
<li class="BL">A set of <i>t</i> signers or fewer can’t create a signature and therefore can’t determine the private key <i>k</i> either.</li>&#13;
</ul>&#13;
<p class="Continued">The issued signature looks like a normal, single-signer signature and verifies as such.</p>&#13;
<p class="TX">Threshold signatures are a specific type of <i>multiparty computation (MPC)</i>, a class of protocols wherein <i>n</i> participants compute the output of some function <i>f</i>(<i>x</i><sub>1</sub>, <i>x</i><sub>2</sub>, . . . , <i>x</i><span class="ePub-I-SUB">n</span>) such that each participant knows their respective input <i>x</i><span class="ePub-I-SUB">i</span> and learns the output of the function but doesn’t learn the other participants’ <i>x</i><span class="ePub-I-SUB">i</span> inputs. In the case of threshold signatures, the <i>x</i><span class="ePub-I-SUB">i</span>s are shares of the private key, and the output is a signature. I’ll elaborate on what a share is in the “<span class="Xref">Secret-Sharing Techniques</span>” section on <a href="#sec38">page 319</a>.</p>&#13;
<p class="TX">Threshold signatures have the benefit of “hiding” the number of co-signers and their identities, as verifiers see only a signature from a single private key. While some multisignature and aggregate signature schemes share this property, threshold signatures better suit the use case of crypto asset custody because there’s only one private key and one public key; you can directly apply threshold signatures to distribute control of any address.</p>&#13;
<section epub:type="division" aria-labelledby="sec34">&#13;
<h4 class="H2"><span id="sec34"/><span id="h2-198"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Use Cases</samp></h4>&#13;
<p class="TNI">Threshold signatures are used in cryptocurrency and digital asset management to distribute control of an address across multiple systems or parties. They can serve to share control of an account between a service provider and a user’s device: each party has one share of the key and must run a protocol together to sign a transaction, thus spending funds. This setup ensures that an attacker can’t autonomously authorize transactions, even if they breach the user’s device and obtain the key shares. Similarly, the provider can’t initiate transactions without the user’s consent. However, implementing this model reliably poses challenges, particularly key management aspects (key generation, key rotation, backups, and so on).</p>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_317" aria-label="317"/>An organization can also use threshold signatures to distribute custody of funds across multiple systems, such as different device types, data centers, operating systems, and software components. This approach is particularly suitable for cold wallets and accounts containing significant assets. Relying solely on threshold signatures is insufficient, as comprehensive security measures and controls are crucial. For example, one must properly separate accesses to IT components to ensure that distinct individuals or IT service providers have access to different systems (thus different shares). Moreover, the initiation and approval of transactions must be subject to strict controls and an audit trail.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec35">&#13;
<h4 class="H2"><span id="sec35"/><span id="h2-199"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Security Model</samp></h4>&#13;
<p class="TNI">As with all cryptographic protocols, we need to define what it means for a threshold signing scheme to be secure. Such a security model includes the security goal (what should be hard for an attacker to do) and the attacker model (the assumptions about the attacker’s capabilities). Let’s delve into these two characteristics.</p>&#13;
<section epub:type="division" aria-labelledby="sec36">&#13;
<h5 class="H3"><span id="sec36"/><samp class="SANS_Futura_Std_Bold_Condensed_B_11">Security Goals</samp></h5>&#13;
<p class="TNI">The main security goal of threshold signature is the same as that of single-party signatures: an attacker must not be able to forge valid signatures, which implies they must not be able to determine the private key. This also implies that the protocol ensures <i>input privacy</i>: the key shares held by the parties shouldn’t leak to any other party. Finally, the protocol must ensure <i>correctness</i>: the signature the protocol computes must be valid and accessible to all participants in the protocol execution.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec37">&#13;
<h5 class="H3"><span id="sec37"/><samp class="SANS_Futura_Std_Bold_Condensed_B_11">Attacker Models</samp></h5>&#13;
<p class="TNI">There isn’t one security model for threshold signatures; instead, an attacker is characterized according to several dimensions. The common threat in all attack scenarios is the assumption that an attacker can actively attack network communications—capturing, modifying, and injecting messages. Using a secure channel to establish authenticated and encrypted communications between the parties thwarts such attacks. Protocol designers also assume reliable communications in that all transmitted messages should be received in the same order they were sent.</p>&#13;
<p class="TX">The attacker model of threshold signatures considers the <i>corruption</i> of participants—namely, that an attacker compromises their system, learns their secrets, and essentially gets them to do what they want. The model assumes that an attacker can’t corrupt more than <i>t</i> parties; otherwise, they’d be able to forge signatures, by definition of the threshold signing functionality.</p>&#13;
<p class="TX">Let’s examine the parameters to consider when an attacker can corrupt participants.</p>&#13;
<p class="TX">First, we characterize an attacker by the <i>number of parties</i> they could corrupt. Two categories of threshold signatures exist, each defined by the <span role="doc-pagebreak" epub:type="pagebreak" id="pg_318" aria-label="318"/>maximum number of malicious participants that can be compromised without compromising the security of the protocol:</p>&#13;
<p class="RunInPara"><b>Honest majority </b>Here, the attacker is limited to corrupting less than half of the key-sharing parties. Therefore, the threshold <i>t</i> must satisfy <i>t</i> &lt; <i>n</i>/2. By definition, a threshold signing protocol with parameters (<i>t</i>, <i>n</i>) must be safe even with compromised <i>t</i> participants. Protocols designed under the honest majority assumption are typically more efficient, but they can’t accommodate arbitrary values of <i>t</i>. For instance, a protocol with parameters (4, 5) is infeasible in this model, as it requires tolerating up to four corrupted parties.</p>&#13;
<p class="RunInPara"><b>Dishonest majority </b>This model allows the protocol to support any value of <i>t</i> from 1 to <i>n</i> – 1. It enables the creation of protocols where all but one of the <i>n</i> parties could be corrupted, yet the malicious parties would still be incapable of forging signatures or recovering the private key. This model offers more flexibility in terms of the threshold value but often requires more complex and robust security mechanisms.</p>&#13;
<p class="TX">We also characterize an attacker by what they can do once they corrupt a party and learn their secret values (including the key share). There are two attacker models defining this:</p>&#13;
<p class="RunInPara"><b>Passive, or honest-but-curious </b>They learn information from corrupted parties but can’t force them to deviate from the protocol. This models “read-only” compromises, where an attacker gets a snapshot of a system’s memory, both storage and volatile memory (RAM, processor registers).</p>&#13;
<p class="RunInPara"><b>Active, or malicious </b>Parties may arbitrarily deviate from the prescribed protocol. This models systems fully compromised by an attacker or controlled by a malicious insider (such as an operator, administrator, or cloud provider).</p>&#13;
<p class="TX">A protocol secure against active attackers is therefore always secure against passive attackers, but not the other way around.</p>&#13;
<p class="TX">There are two ways for an attacker to choose which parties to corrupt, which are defined by the following models of corruption type:</p>&#13;
<p class="RunInPara"><b>Static corruption </b>The attacker must choose which participants to corrupt before starting the protocol.</p>&#13;
<p class="RunInPara"><b>Adaptive corruption </b>The attacker may wait until after the protocol begins to choose which participants to corrupt—and then learn the history of their operations throughout the protocol.</p>&#13;
<p class="TX">A protocol secure against static corruption is always secure against adaptive corruption, but not the other way around. However, there are techniques to convert a protocol from secure against static corruption to secure against adaptive corruption.</p>&#13;
</section>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec38">&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_319" aria-label="319"/>&#13;
<h4 class="H2"><span id="sec38"/><span id="h2-200"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Secret-Sharing Techniques</samp></h4>&#13;
<p class="TNI">A key ingredient of threshold signatures is <i>secret-sharing</i> protocols, or techniques that split a secret into multiple pieces (<i>shares</i>) distributed to different parties in a way that the parties can then jointly recompute the initial secret. Secret-sharing protocols can notably be used when creating backups of private keys such that different parties store different shares in different locations.</p>&#13;
<section epub:type="division" aria-labelledby="sec39">&#13;
<h5 class="H3"><span id="sec39"/><samp class="SANS_Futura_Std_Bold_Condensed_B_11">Additive Sharing</samp></h5>&#13;
<p class="TNI">The simplest way to share a secret that you see as a number is through <i>additive sharing</i>: given a number <i>s</i>, you share it as <i>n</i> values <i>s</i><sub>1</sub>, <i>s</i><sub>2</sub>, . . . , <i>s</i><span class="ePub-I-SUB">n</span> such that <i>s</i><sub>1</sub> + <i>s</i><sub>2</sub> + . . . + <i>s</i><span class="ePub-I-SUB">n</span> = <i>s.</i> For example, if you work with numbers modulo 100, you could create a random additive sharing of the number <i>s</i> = 47 into four shares as follows: pick three random numbers between 0 and 99, say <i>s</i><sub>1</sub> = 12, <i>s</i><sub>2</sub> = 94, and <i>s</i><sub>3</sub> = 80, and set <i>s</i><sub>4</sub> = <i>s</i> – <i>s</i><sub>1</sub> – <i>s</i><sub>2</sub> – <i>s</i><sub>3</sub> = 61. (Note that subtraction is computed modulo 100, such that –1 = 99, –2 = 98, and so on.)</p>&#13;
<p class="TX">This approach is very simple but requires using all the shares to recover the original secret.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec40">&#13;
<h5 class="H3"><span id="sec40"/><samp class="SANS_Futura_Std_Bold_Condensed_B_11">Threshold Sharing</samp></h5>&#13;
<p class="TNI">Threshold sharing is closer to what threshold signatures do: given parameters <i>n</i> and <i>t</i> &lt; <i>n</i> and the secret <i>s</i>, it creates shares such that you can recover the secret using any set of <i>t</i> shares out of the <i>n</i> created.</p>&#13;
<p class="TX">The best-known threshold sharing method is <i>Shamir’s secret sharing</i>, which leverages the following property of polynomials: given a polynomial of degree <i>t</i> of the form</p>&#13;
<figure class="DIS-IMG"><img class="img1" src="../images/pg319-1.jpg" alt="" width="1388" height="46"/></figure>&#13;
<p class="Continued">you need the result of only <i>t</i> + 1 evaluations of <i>f</i>(<i>x</i>) on <i>t</i> + 1 distinct values of <i>x</i> to determine all <i>a</i><span class="ePub-I-SUB">i</span> coefficients, which are fixed values.</p>&#13;
<p class="TX">To create a threshold secret sharing from this property, set <i>a</i><sub>0</sub> = <i>s</i>, the secret. Then pick random values of <i>a</i><sub>1</sub> to <i>a</i><span class="ePub-I-SUB">t</span> and compute <i>f</i>(<i>x</i>) for <i>n</i> distinct values of <i>x</i>, which will be the <i>n</i> shares of the secret.</p>&#13;
<p class="TX">Recomputing the coefficients from the <i>f</i>(<i>x</i>) values is a technique called <i>Lagrange interpolation</i>, from the 18th-century Italian mathematician who developed a general method to determine the equation of a curve given a list of points on that curve. Indeed, you can view the problem geometrically. If the equation has degree 1 (and is of the form <i>a</i><sub>0</sub> + <i>a</i><sub>1</sub><i>x</i>), then it’s the equation of a line, and knowing two points on a line is sufficient to uniquely identify the line. Likewise, if the equation has degree 2 (of the form <i>a</i><sub>0</sub> + <i>a</i><sub>1</sub><i>x</i> + <i>a</i><sub>2</sub><i>x</i><sup>2</sup>), then the curve is a parabola, whose equation can be determined with three points.</p>&#13;
<p class="TX">We sometimes find implementations of Shamir’s secret sharing defining a function <b>Lagrange</b>() that computes the interpolation and returns the <i>a</i><sub>0</sub> coefficient, which is the shared secret. If you have values of <i>f</i>(<i>x</i>) to combine <span role="doc-pagebreak" epub:type="pagebreak" id="pg_320" aria-label="320"/>to recover the secret, you can define the operation <b>Lagrange</b>(<i>s</i><sub>1</sub>, <i>s</i><sub>2</sub>, . . . , <i>s</i><span class="ePub-I-SUB">t</span>) returning the shared secret <i>s</i>. This works for any combination of <i>t</i> distinct shares, not necessarily the first <i>t</i> ones. The details of the <b>Lagrange</b>() operation are a bit too technical for this book, but you can implement it as a series of basic additions, multiplications, and inverses.</p>&#13;
</section>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec41">&#13;
<h4 class="H2"><span id="sec41"/><span id="h2-201"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">The Trivial Case</samp></h4>&#13;
<p class="TNI">One of the simplest types of threshold signature uses the BLS signature, as viewed earlier in the context of aggregate signatures. Recall that given a private key <i>k</i>, BLS signatures compute a signature by multiplying <i>k</i> with the curve point <i>H</i> = <b>H</b>(<i>M</i>). You can use additive sharing to create a threshold scheme with parameters (<i>n</i> – 1, <i>n</i>). For example, if <i>n</i> = 3, split the key into three shares such that <i>k</i><sub>1</sub> + <i>k</i><sub>2</sub> + <i>k</i><sub>3</sub> = <i>k</i>. Each party then computes their share of the signature by multiplying their share <i>k</i><span class="ePub-I-SUB">i</span> with <i>H</i>. Adding the three shares then yields the following:</p>&#13;
<figure class="DIS-IMG"><img class="img1" src="../images/pg320-1.jpg" alt="" width="1388" height="44"/></figure>&#13;
<p class="Continued">Combining the three shares via addition gives a valid signature with <i>k</i>, even if none of the parties knows <i>k</i>. The parties could also recover <i>k</i> if they add their respective shares, but adding the shares of two parties reveals no information on <i>k</i> if the shares were randomly generated.</p>&#13;
<p class="TX">To create a threshold signature scheme with arbitrary <i>t</i> and <i>n</i>, use the Shamir secret-sharing technique and leverage the linearity of the <b>Lagrange</b>() operation: you generate the key shares <i>k</i><span class="ePub-I-SUB">i</span> as described in the “<span class="Xref">Threshold Sharing</span>” section and compute the signature like so:</p>&#13;
<figure class="DIS-IMG"><img class="img1" src="../images/pg320-2.jpg" alt="" width="1388" height="44"/></figure>&#13;
<p class="Continued">Again, you obtain a valid signature with the key <i>k</i>.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec42">&#13;
<h4 class="H2"><span id="sec42"/><span id="h2-202"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">The Simple Case</samp></h4>&#13;
<p class="TNI">You’ll now compute Schnorr signatures in the threshold setting, which is a bit more technical than with BLS signatures. Recall the Schnorr scheme computes a signature as <i>s</i> = <i>r</i> + <i>ha</i>, where <i>h</i> = <b>H</b>(<i>R</i> || <i>A</i> || <i>M</i>), <i>r</i> is the per-signature random nonce, and <i>a</i> is the signer’s private key. The signature also includes <i>R</i> = <i>rG</i>, the public nonce value. This is relatively easy to turn into a threshold signature scheme, owing to its linearity with respect to secret values: observe that the secret <i>r</i> is added to the secret <i>a</i> multiplied by the hash <i>h</i>, which is not secret.</p>&#13;
<p class="TX">Imagine the simplest case of two signers, with an additive sharing of the private signing key <i>k</i> = <i>a</i> + <i>b</i>, with <i>a</i> and <i>b</i> the respective key shares of the two signers. To sign, the two parties could generate secret nonces <i>r</i><sub>A</sub> and <i>r</i><sub>B</sub>, with respective public values <i>R</i><sub>A</sub> = <i>r</i><sub>A</sub><i>G</i> and <i>R</i><sub>B</sub> = <i>r</i><sub>B</sub><i>G</i>. The parties can then exchange these values and compute the public nonce <i>R</i> = <i>R</i><sub>A</sub> + <i>R</i><sub>B</sub>, which will be part of the signature. <i>R</i> is then the public value you derive from the private value <i>r</i> = <i>r</i><sub>A</sub> + <i>r</i><sub>B</sub>, since you have:</p>&#13;
<figure class="DIS-IMG"><img class="img1" src="../images/pg320-3.jpg" alt="" width="1388" height="43"/></figure>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_321" aria-label="321"/>Next, the parties compute their shares of the signature: <i>s</i><sub>A</sub> = <i>r</i><sub>A</sub> + <i>ha</i> and <i>s</i><sub>B</sub> = <i>r</i><sub>B</sub> + <i>hb</i>, which are added together to yield:</p>&#13;
<figure class="DIS-IMG"><img class="img1" src="../images/pg321-1.jpg" alt="" width="1386" height="43"/></figure>&#13;
<p class="TX">You thus obtain <i>r</i> + <i>hk</i>, a signature from the key <i>k</i>, even though participants used only the additive shares <i>a</i> and <i>b</i> in their computations. To obtain a threshold construction for arbitrary parameters <i>t</i> and <i>n</i>, Shamir’s secret sharing can be used instead of additive sharing.</p>&#13;
<p class="TX">The previous construction isn’t secure enough to satisfy all the security requirements of a threshold signing scheme. It’s notably vulnerable to key cancellation attacks unless participants <i>commit</i> to their nonces in a preliminary phase of the protocol—for example, by sending the hash of their nonce. It also has a number of subtle vulnerabilities addressed by the protocol Flexible Round-Optimized Schnorr Threshold (FROST) signatures, designed by cryptographers Chelsea Komlo and Ian Goldberg in 2020 and documented at <i><a href="https://eprint.iacr.org/2020/852">https://<wbr/>eprint<wbr/>.iacr<wbr/>.org<wbr/>/2020<wbr/>/852</a></i>.</p>&#13;
<blockquote>&#13;
<p class="Note"><span class="NoteHead"><samp class="SANS_Dogma_OT_Bold_B_15">NOTE</samp></span></p>&#13;
</blockquote>&#13;
<p class="NOTE-TXT"><i>The EdDSA signature protocol from <a href="chapter12.xhtml">Chapter 12</a> is similar to Schnorr’s signatures but computes the nonce as a hash from the message, rather than as a random, arbitrary value. This complicates the creation of threshold signature protocols compliant with the original EdDSA specification.</i></p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec43">&#13;
<h4 class="H2"><span id="sec43"/><span id="h2-203"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">The Hard Case</samp></h4>&#13;
<p class="TNI">The hardest signature scheme to run in a threshold setting is also the most common. The ECDSA signature algorithm (see <span class="Xref"><a href="chapter12.xhtml">Chapter 12</a></span>) is more complex than Schnorr signatures and EdDSA because it involves a division. Given a message hash <i>h</i> = <b>H</b>(<i>M</i>), the signer picks a random number <i>k</i>, computes the number <i>r</i> from the point <i>kG</i>’s coordinates, and computes the signature as <i>s</i> = (<i>h</i> + <i>ra</i>) / <i>k</i>, where <i>a</i> is the private key of the signer.</p>&#13;
<p class="TX">Efficient and secure ECDSA threshold signatures remain a challenging research problem among cryptographers. The first practical protocols appeared in the late 2010s, motivated by the use case of cryptocurrency—most of the leading cryptocurrencies, including Bitcoin and Ethereum, then supported only ECDSA as a transaction signing scheme.</p>&#13;
<p class="TX">Cryptographers devised several approaches to build ECDSA threshold signing protocols. For example, Yehuda Lindell’s 2017 “Fast Secure Two-Party ECDSA Signing” (<i><a href="https://eprint.iacr.org/2017/552">https://<wbr/>eprint<wbr/>.iacr<wbr/>.org<wbr/>/2017<wbr/>/552</a></i>) required a commitment scheme, homomorphic encryption scheme, and zero-knowledge proof system. The complexity of such protocols complicated their understanding, implementation, and security analysis, leading to a number of security flaws in deployed systems.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec44">&#13;
<h4 class="H2"><span id="sec44"/><span id="h2-204"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">How Things Can Go Wrong</samp></h4>&#13;
<p class="TNI">Specific security issues in threshold signature protocols are often complex and involve details of cryptographic constructions that I haven’t covered in this book. Therefore, instead of specific problems, I’ll discuss categories <span role="doc-pagebreak" epub:type="pagebreak" id="pg_322" aria-label="322"/>of problems that impacted real deployments of threshold signatures, from widely used open source software to commercial solutions.</p>&#13;
<section epub:type="division" aria-labelledby="sec45">&#13;
<h5 class="H3"><span id="sec45"/><samp class="SANS_Futura_Std_Bold_Condensed_B_11">Papers vs. Code</samp></h5>&#13;
<p class="TNI">When engineers need to implement a threshold signature protocol from their research papers, they encounter challenges. These papers, primarily aimed at cryptography researchers, often vary in editorial quality and are complicated, heavy in mathematics, and quite new. This recency can mean that an experimental protocol might not be as secure as intended. These factors contribute to a range of real-world security issues, which can be categorized into four main areas:</p>&#13;
<p class="RunInPara"><b>Insecure protocol </b>If the protocol isn’t secure on paper, it won’t be more secure in implementation. Common issues include overlooked edge cases or inadequate validation when receiving inputs from other parties. For example, some protocols failed to verify if an encrypted number falls within the expected range, leading to practical attacks.</p>&#13;
<p class="RunInPara"><b>Incomplete description </b>Research papers aren’t technical specifications but are written for academic audiences, so they often lack practical implementation details like networking and encoding. A notable example is the TSSHOCK attack on threshold signatures, which exploited ambiguous encoding in a hash function’s input elements, as described in “<span class="runinpara_Xref">Collisions from Domain Separation Failures</span>” on <a href="#sec13">page 305</a>.</p>&#13;
<p class="RunInPara"><b>Incomplete implementation </b>The complexity of threshold signing protocols, with their numerous subcomponents and detailed requirements, can lead to overlooked security validations, particularly if these are mentioned only in appendixes. An instance of this was when a protocol required a number <i>N</i> = <i>pq</i> (for Paillier encryption) to be verified as the product of two large enough primes via a zero-knowledge proof, but this verification was omitted in the implementation, allowing insecure <i>N</i> values.</p>&#13;
<p class="RunInPara"><b>Insecure component choice </b>Descriptions of protocols usually don’t say “use the hash function BLAKE3” or “use the 256-bit elliptic curve nistp256”; instead, they say “use a hash function and an elliptic curve that offer the security level you need.” It’s thus up to the implementers to pick suitable primitives and use their programming interfaces securely. For example, using an RSA modulus of 1,024 bits isn’t enough to ensure 128-bit security.</p>&#13;
<p class="TX">Additionally, risks arise when implementers intentionally modify a protocol, perhaps to enhance efficiency or fit a specific use case. This usually doesn’t end well. For examples of attacks on threshold signatures, see the papers “Alpha-Rays: Key Extraction Attacks on Threshold ECDSA Implementations” by Dmytro Tymokhanov and Omer Shlomovits (<i><a href="https://eprint.iacr.org/2021/1621">https://<wbr/>eprint<wbr/>.iacr<wbr/>.org<wbr/>/2021<wbr/>/1621</a></i>) and “Practical Key-Extraction Attacks in Leading <span role="doc-pagebreak" epub:type="pagebreak" id="pg_323" aria-label="323"/>MPC Wallets” by Nikolaos Makriyannis, Oren Yomtov, and Arik Galansky (<i><a href="https://eprint.iacr.org/2023/1234">https://<wbr/>eprint<wbr/>.iacr<wbr/>.org<wbr/>/2023<wbr/>/1234</a></i>).</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec46">&#13;
<h5 class="H3"><span id="sec46"/><samp class="SANS_Futura_Std_Bold_Condensed_B_11">Key Management Aspects</samp></h5>&#13;
<p class="TNI">A friend once remarked, “For every 10 lines of encryption code, there are 1,500 lines of key management,” which emphasizes the criticality and intricacy of key management processes, including key creation, storage, backup, and recovery. While these facets may be overlooked in academic papers focusing on theoretical aspects, they’re vital in practical applications. Engineers and security professionals implementing threshold signing in a production environment must prioritize these key management issues—even the most robust threshold signature protocols are no substitute for comprehensive key management practices.</p>&#13;
<p class="TX">Let’s review the main key management considerations for an organization employing threshold signatures to safeguard substantial cryptocurrency holdings:</p>&#13;
<p class="RunInPara"><b>Key generation </b>Whether you’re using distributed key generation or centralized generation, you must ensure that the secret values aren’t exposed to unauthorized systems or parties during or after the key generation. This assurance is generally provided through rigorous processes such as key ceremonies, ensuring supply-chain integrity and audit trail, to demonstrate that keys have been generated properly. Don’t allow another party (such as a cloud provider) to generate keys on your behalf or to have the capability to read them at any time.</p>&#13;
<p class="RunInPara"><b>Key storage </b>Storing a key as multiple shares instead of a single value doesn’t diminish the necessity for secure storage. Safeguarding numerous secrets across diverse platforms can present more of a challenge than protecting a single secret on a unified platform. Key shares must be stored in some type of secure memory, protected against unauthorized access, tampering, and physical attacks.</p>&#13;
<p class="RunInPara"><b>Key backup and recovery </b>Implementing a threshold scheme where, for instance, you require three out of six shares to sign a transaction, protects against the loss of key shares or system outages. Nevertheless, this doesn’t negate the necessity for key backups, which you should also maintain as threshold shares. It’s imperative to distribute access to these backup shares among distinct parties. Additionally, validate the reliability of backups periodically to ensure they haven’t been compromised and can be effectively utilized to reconstruct the key when necessary, such as during disaster recovery drills.</p>&#13;
</section>&#13;
</section>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec47">&#13;
<h3 class="H1"><span id="sec47"/><span id="h1-107"/><samp class="SANS_Futura_Std_Bold_B_11">Zero-Knowledge Proofs</samp></h3>&#13;
<p class="TNI"><i>Zero-knowledge proofs (ZKPs)</i> are one of cryptographers’ most powerful tools. These are protocols between two parties, a <i>prover</i> and a <i>verifier</i>, where the prover convinces the verifier that something is true without revealing <span role="doc-pagebreak" epub:type="pagebreak" id="pg_324" aria-label="324"/>anything about why. For example, the prover could prove that they know a solution to some hard computational problem without revealing the solution. You might create a ZKP for any <b>NP</b>-complete problems to prove you know a solution without revealing it.</p>&#13;
<p class="TX">More generally, ZKPs are used to prove a statement, such as “the number encrypted in this ciphertext is between 100 and 200” or “for a given plaintext <i>P</i> and ciphertext <i>C</i>, I know a secret key <i>K</i> for which <i>C</i> = <b>AES</b>(<i>K</i>, <i>P</i>).”</p>&#13;
<p class="TX">For a non-technical introduction to zero-knowledge proofs, I recommend cryptographer Amit Sahai’s video “Computer Scientist Explains One Concept in 5 Levels of Difficulty” (<i><a href="https://youtu.be/fOGdb1CTu5c">https://<wbr/>youtu<wbr/>.be<wbr/>/fOGdb1CTu5c</a></i>). For mathematical details, see the links on <i><a href="https://github.com/matter-labs/awesome-zero-knowledge-proofs">https://<wbr/>github<wbr/>.com<wbr/>/matter<wbr/>-labs<wbr/>/awesome<wbr/>-zero<wbr/>-knowledge<wbr/>-proofs</a></i>.</p>&#13;
<blockquote>&#13;
<p class="Note"><span class="NoteHead"><samp class="SANS_Dogma_OT_Bold_B_15">NOTE</samp></span></p>&#13;
</blockquote>&#13;
<p class="NOTE-TXT"><i>The term</i> <span class="note_Italic">zero-knowledge proof</span> <i>is a simplification of more accurate terms from the research literature. For example, many “zero-knowledge proof” protocols are in fact</i> <span class="note_Italic">zero-knowledge arguments of knowledge</span><i>. Researchers reserve the term</i> <span class="note_Italic">proof</span> <i>for unconditional security and use</i> <span class="note_Italic">argument</span> <i>for computational security. Furthermore, the term</i> <span class="note_Italic">witness</span> <i>refers to the secret allowing the prover to prove its statement, as a generalization of</i> <span class="note_Italic">secret</span> <i>or</i> <span class="note_Italic">secret key</span><i>, due to its broader scope.</i></p>&#13;
<section epub:type="division" aria-labelledby="sec48">&#13;
<h4 class="H2"><span id="sec48"/><span id="h2-205"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Security Model</samp></h4>&#13;
<p class="TNI">What does it mean for a ZKP protocol to be secure? Is the attacker the prover or the verifier? How can they attack the protocol? Let’s answer these questions by examining security goals and attacker models.</p>&#13;
<section epub:type="division" aria-labelledby="sec49">&#13;
<h5 class="H3"><span id="sec49"/><samp class="SANS_Futura_Std_Bold_Condensed_B_11">Security Goals</samp></h5>&#13;
<p class="TNI">A secure ZKP must satisfy the following notions:</p>&#13;
<p class="RunInPara"><b>Completeness </b>If the prover follows the protocol using the correct secret, an honest verifier is convinced of the truth of the statement. In other words, the protocol always works.</p>&#13;
<p class="RunInPara"><b>Soundness </b>If the prover doesn’t know the secret, they can’t convince the honest verifier of a false statement (except with negligible probability). In other words, provers can’t cheat.</p>&#13;
<p class="RunInPara"><b>Zero-knowledge </b>A verifier learns nothing beyond the fact that the statement is true. Specifically, they can’t learn anything about the prover’s secret.</p>&#13;
<p class="TX">The notion that a verifier “will be convinced of the truth of the statement” is guaranteed by the mutual agreement that the protocol satisfies these three properties—namely, that a prover could not complete the protocol if the statement was false (for example, if they didn’t know the solution they claim to).</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec50">&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_325" aria-label="325"/>&#13;
<h5 class="H3"><span id="sec50"/><samp class="SANS_Futura_Std_Bold_Condensed_B_11">Attacker Models</samp></h5>&#13;
<p class="TNI">Both parties can potentially be attackers attempting to compromise soundness and zero-knowledge, respectively:</p>&#13;
<p class="RunInPara"><b>Malicious provers </b>Want to prove a false statement—for example, to wrongly convince the verifier that they know a solution to some hard problem. Such an attacker can deviate from the protocol to try to fool the verifier. In practice, this is the greatest threat to ZKPs in applications like confidential program execution.</p>&#13;
<p class="RunInPara"><b>Malicious verifiers </b>Want to extract information about the secret (the <i>witness</i>), thereby breaking the zero-knowledge property. Attacker models distinguish <i>passive</i> verifier attackers (honest-but-curious) and <i>active</i> verifier attackers (who can arbitrarily deviate from the protocol).</p>&#13;
<p class="TX">Note that malicious verifiers can challenge completeness by claiming they aren’t convinced by the truth of a statement. In practice, this isn’t an issue, as the prover can repeat the proof protocol for other (honest) verifiers who would expose the lying verifier.</p>&#13;
</section>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec51">&#13;
<h4 class="H2"><span id="sec51"/><span id="h2-206"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Schnorr’s Protocol</samp></h4>&#13;
<p class="TNI">Claus-Peter Schnorr, who created the eponymous signature scheme, also described a similar construction that is a zero-knowledge <i>proof of knowledge of a discrete logarithm</i>. It’s the basis for Schnorr’s and EdDSA signatures, as well as for many more complex ZKPs.</p>&#13;
<p class="TX">Schnorr’s protocol works in three steps to prove the knowledge of <i>a</i> such that <i>aG</i> = <i>A</i>—that is, the discrete logarithm of <i>A</i> with respect to the generator <i>G</i>:</p>&#13;
<p class="NLF">  1.  <i>Commitment</i>: The prover picks a random number <i>r</i> and sends <i>R</i> = <i>rG</i>.</p>&#13;
<p class="NL">  2.  <i>Challenge</i>: The verifier sends a random number <i>c</i>.</p>&#13;
<p class="NLL">  3.  <i>Response</i>: The prover sends <i>s</i> = <i>r</i> + <i>ca</i>, and the verifier accepts if and only if <i>sG</i> = <i>R + cA</i>.</p>&#13;
<blockquote>&#13;
<p class="Note"><span class="NoteHead"><samp class="SANS_Dogma_OT_Bold_B_15">NOTE</samp></span></p>&#13;
</blockquote>&#13;
<p class="NOTE-TXT"><i>This kind of three-step protocol, with a commitment, a challenge, and a response, is called a</i> <span class="note_Italic">sigma protocol</span><i>, after the shape of the uppercase Greek letter sigma (<span xml:lang="el" lang="el">Σ</span>).</i></p>&#13;
<p class="TX">The <i>completeness</i> of Schnorr’s protocol is the easiest to verify: if <i>a</i> satisfies <i>aG</i> = <i>A</i>, you’ll have</p>&#13;
<figure class="DIS-IMG"><img class="img1" src="../images/pg325-1.jpg" alt="" width="1388" height="37"/></figure>&#13;
<p class="Continued">which is the prover’s validation condition.</p>&#13;
<p class="TX">To see that the protocol ensures <i>soundness</i>—that the prover must know <i>a</i>—imagine that the prover uses the same <i>r</i> twice in two runs of the <span role="doc-pagebreak" epub:type="pagebreak" id="pg_326" aria-label="326"/>protocol. The verifier thus gets two responses, <i>s</i><sub>1</sub> = <i>r</i> + <i>c</i><sub>1</sub><i>a</i> and <i>s</i><sub>2</sub> = <i>r</i> + <i>c</i><sub>2</sub><i>a</i>, for the two distinct challengers <i>c</i><sub>1</sub> and <i>c</i><sub>2</sub>. Now they can compute</p>&#13;
<figure class="DIS-IMG"><img class="img1" src="../images/pg326-1.jpg" alt="" width="1381" height="45"/></figure>&#13;
<p class="Continued">and divide the result by (<i>c</i><sub>1</sub> – <i>c</i><sub>2</sub>) to obtain <i>a</i>. Since the check that <i>sG</i> equals <i>R</i> + <i>cA</i> ensures that you had <i>s</i> = <i>r</i> + <i>ca</i>, it follows that the prover must know <i>a</i> when executing this protocol correctly. This kind of logical reasoning is called a <i>knowledge extractor</i>, and it’s the main technique to show that a ZKP is sound.</p>&#13;
<p class="TX">The protocol can also be proved to be zero-knowledge, using a technique called a <i>simulator</i>, an algorithm that creates messages (or a <i>transcript of communication</i>) that are indistinguishable from those in a real execution of a zero-knowledge proof. However, unlike a real prover, the simulator doesn’t necessarily know the secret (or witness) being proven. Despite this, the messages it generates still appear valid and convincing to the verifier in the context of the proof system.</p>&#13;
<p class="TX">In Schnorr’s protocol, the simulator works backward and first chooses a random response, <i>s</i>, to show that a real <i>s</i> will be “as random” as a purely random one. Then it picks a random challenge <i>c</i> and computes the original commitment as <i>R</i> = <i>sG</i> – <i>cA</i>. The proof that the protocol is zero-knowledge then demonstrates that these three values are indistinguishable from those of a real execution of a protocol yet don’t require the knowledge of the secret <i>a</i>. (Note that in Schnorr’s case, you must assume that the verifier follows the protocol and picks a random <i>c</i>.)</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec52">&#13;
<h4 class="H2"><span id="sec52"/><span id="h2-207"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Noninteractive Proofs</samp></h4>&#13;
<p class="TNI">Schnorr’s protocol is <i>interactive</i>: the prover sends a first message, the verifier responds with a challenge, and the prover sends them a response—the parties interact over three rounds of messages. But what if the verifier can’t send messages and just wants to receive a single message that convinces them? How can one create such <i>noninteractive</i> proofs from an interactive protocol?</p>&#13;
<p class="TX">Let’s take another look at the Schnorr protocol, wherein the verifier sends a random challenge <i>c</i>, a value that must be unpredictable to the prover. If the prover knows <i>c</i> before sending <i>R</i>, they can cheat, as follows: given <i>c</i>, choose some arbitrary value for <i>s</i>, and compute <i>R</i> = <i>sG</i> – <i>cA</i>; then send this <i>R</i> to the verifier, and send <i>s</i> as a response to <i>c</i>. Verification succeeds, yet the prover didn’t need to use the secret value <i>a</i>.</p>&#13;
<p class="TX">How do you make <i>c</i> unpredictable to the prover without interacting with a verifier? The trick is to derive <i>c</i> from <i>R</i> using a hash function, which prevents the prover from finding a pair (<i>R</i>, <i>c</i>) that satisfies <i>sG</i> = <i>R</i> + <i>cA</i> due to the pseudorandom behavior of hash functions.</p>&#13;
<p class="TX">To generate a <i>noninteractive zero-knowledge (NIZK)</i> proof of knowledge of the secret <i>a</i> using Schnorr’s protocol, a prover proceeds as follows:</p>&#13;
<p class="NL"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_327" aria-label="327"/>  1.  <i>Commitment</i>: The prover picks a random number <i>r</i> and computes <i>R</i> = <i>rG</i>.</p>&#13;
<p class="NL">  2.  <i>Challenge</i>: The prover computes <i>c</i> = <b>H</b>(<i>G</i> || <i>R</i> || <i>A</i>); you must include the values <i>G</i> and <i>A</i> to bind the <i>c</i> generation to the generator parameter <i>G</i> and to the public key <i>A</i> of the prover.</p>&#13;
<p class="NL">  3.  <i>Response</i>: The prover computes <i>s</i> = <i>r</i> + <i>ca</i> and generates the proof as an encoding of <i>R</i> and <i>s</i>.</p>&#13;
<p class="TX">To verify a proof (<i>R</i>, <i>s</i>) received from the prover with public key <i>A</i>, a verifier recomputes the challenge <i>c</i> = <b>H</b>(<i>G</i> || <i>R</i> || <i>A</i>) and checks the equality if <i>sG</i> = <i>R</i> + <i>cA</i>.</p>&#13;
<p class="TX">The trick in hash function protocol data to replace verifier-generated challenges was formalized by the <i>Fiat–Shamir transform</i>, a general technique to turn an interactive protocol into a noninteractive one. For this transform to be applicable, a verifier’s random challenges must be independent of the prover’s message and be public (nonsecret) values.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec53">&#13;
<h4 class="H2"><span id="sec53"/><span id="h2-208"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">zkSNARKs</samp></h4>&#13;
<p class="TNI">Let’s talk about the kind of zero-knowledge proof that’s seen wide adoption in blockchain applications due to its power and efficiency. For example, zkSNARKs are the cornerstone of the Zcash confidential transaction platform: in Zcash, zkSNARKs prove that a certain amount has been deducted from an account and credited to another account, without revealing the amount of the accounts and without leading to a prohibitively large amount of computation or storage.</p>&#13;
<p class="TX">A <i>zkSNARK</i> is a type of noninteractive proof of knowledge that offers the zero-knowledge (<i>zk</i>) property, where <i>SNARK</i> stands for the following:</p>&#13;
<p class="RunInPara"><b>Succinct </b>The proof is very small compared to the size of the statement and the secret. It may be similar in size to the statement size’s logarithm, or even of <i>constant size</i>—always of the same size regardless of the statement’s size.</p>&#13;
<p class="RunInPara"><b>Noninteractive </b>A SNARK is a noninteractive argument of knowledge, typically using the Fiat–Shamir transform to turn an interactive protocol into a noninteractive one. It doesn’t need the verifier to send messages to the prover.</p>&#13;
<p class="RunInPara"><b>Argument </b>The <i>argument</i> of knowledge is a computationally secure proof that is conditionally secure. In other words, it wouldn’t be secure against an attacker with infinite computing power, which is generally a tolerable limitation.</p>&#13;
<p class="RunInPara"><b>Of knowledge </b>A SNARK offers completeness and soundness, as an argument of knowledge.</p>&#13;
<p class="Continued">In addition, proving and verifying a zkSNARK must be computationally efficient.</p>&#13;
<p class="TX">Generating such a succinct proof when you want to prove the knowledge of a solution to a problem whose description doesn’t even fit in the proof size sounds counterintuitive. For example, what about statements like <span role="doc-pagebreak" epub:type="pagebreak" id="pg_328" aria-label="328"/>“I know a solution to the equation <i>f</i>(<i>x</i>) = 0,” when the equation <i>f</i>(<i>x</i>) can be of arbitrary size? From a theoretical perspective, short proofs make sense because the only information a proof must convey is the <i>knowledge</i> of some solution and generally the <i>correctness</i> of some statement, as opposed to the actual solution and secrets; the proof must be zero-knowledge and reveal only that information to the verifier.</p>&#13;
<p class="TX">In 2016, cryptographer Jens Groth published the article “On the Size of Pairing-Based Non-interactive Arguments” (<i><a href="https://eprint.iacr.org/2016/260">https://<wbr/>eprint<wbr/>.iacr<wbr/>.org<wbr/>/2016<wbr/>/260</a></i>), which describes an exceptionally efficient zkSNARK. The proof consisted of only three group elements and could be verified by computing three pairing operations (the same type of pairing as with BLS signatures). The Zcash protocol adopted this breakthrough result, which laid the foundation for several other zkSNARKs. Groth’s zkSNARK is usually just called <i>Groth16</i>.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec54">&#13;
<h4 class="H2"><span id="sec54"/><span id="h2-209"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">From Statements to Proofs</samp></h4>&#13;
<p class="TNI">zkSNARKs are some of the most complex cryptographic constructions, with one of their most complex and costly steps being <i>arithmetization</i>, an operation that converts the statement to prove into a fixed number of polynomial equations, which are generally of the form</p>&#13;
<figure class="DIS-IMG"><img class="img1" src="../images/pg328-1.jpg" alt="" width="1392" height="46"/></figure>&#13;
<p class="Continued">for a polynomial of degree <i>n</i>, where the coefficients <i>a</i><span class="ePub-I-SUB">i</span> are elements of some finite ring or finite field structure. The proving algorithm then processes the polynomials to create the zkSNARK proof.</p>&#13;
<p class="TX">Arithmetization follows a general workflow:</p>&#13;
<p class="NLF">  1.  Describe the statement to prove using formal notations, such as a computer program, equations, or logical formulas.</p>&#13;
<p class="NL">  2.  Transform the formal expression from step 1 into a <i>circuit</i>, which defines an output from input values by applying a sequence of <i>gates</i> to the input, similar to logical gates in a Boolean or electronic circuit, except that the gates may be algebraic operations such as addition and multiplication.</p>&#13;
<p class="NLL">  3.  Turn the circuit into a structured list of <i>constraints</i>, according to the zkSNARK proof system’s constraint system. Such constraints are lists of conditions that the input must fulfill to satisfy the statement to prove.</p>&#13;
<p class="TX">The statement to prove may be as trivial as “I know integer <i>x</i> and <i>y</i> satisfying the equation <i>x</i><sup>3</sup> + <i>y</i><sup>2</sup> + <i>xy</i> + 55 = 0 mod 57.” This completes step 1 by having a formal equation expressing the problem. To complete step 2, you may break down the equation as a sequence of simple operations involving two operands (Groth16 requires this). This works as follows, where you write the intermediate values <i>v</i><sub>0</sub>, <i>v</i><sub>1</sub>, . . . , <i>v</i><sub>6</sub>:</p>&#13;
<div class="spc">&#13;
<p class="ListPlain1">Set <i>v</i><sub>0</sub> = <i>x</i> × <i>x</i>.</p>&#13;
<p class="ListPlain1">Set <i>v</i><sub>1</sub> = <i>x</i> × <i>v</i><sub>0</sub>; thus <i>v</i><sub>1</sub> = <i>x</i><sup>3</sup>.</p>&#13;
<p class="ListPlain1">Set <i>v</i><sub>2</sub> = <i>y</i> × <i>y</i>.</p>&#13;
<p class="ListPlain1"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_329" aria-label="329"/>Set <i>v</i><sub>3</sub> = <i>x</i> × <i>y</i>.</p>&#13;
<p class="ListPlain1">Set <i>v</i><sub>4</sub> = <i>v</i><sub>1</sub> <i>+ v</i><sub>2</sub>.</p>&#13;
<p class="ListPlain1">Set <i>v</i><sub>5</sub> = <i>v</i><sub>4</sub> <i>+ v</i><sub>3</sub>.</p>&#13;
<p class="ListPlain1">Set <i>v</i><sub>6</sub> = <i>v</i><sub>5</sub> + 55; thus <i>v</i><sub>6</sub> = <i>x</i><sup>3</sup> + <i>y</i><sup>2</sup> + <i>xy</i> + 55.</p>&#13;
</div>&#13;
<p class="Continued">Such a translation of a long equation into a series of small ones is called <i>flattening</i>.</p>&#13;
<p class="TX">The prover then converts these operations—the circuit—into a set of mathematical structures that serve to construct the polynomials processed by the prover. The long polynomials are finally “compressed” into a proof using randomness, specifically the concept of <i>probabilistically checkable proof (PCP)</i>, which is a major discovery from the field of complexity theory. This convinces a verifier that many constraints are satisfied with only a few actual constraint checks, while preserving the zero-knowledge property.</p>&#13;
<p class="TX">To learn more about the intricacies of arithmetization, research the two main approaches used by zkSNARKs: rank-1 constraint systems (R1CS) and algebraic intermediate representations (AIR).</p>&#13;
<p class="TX">Finally, note that we distinguish <i>nonuniversal</i> and <i>universal</i> zkSNARK proof systems: in the former, the prover works for a specific, predefined statement. In particular, the setup phase of the proof system creates parameters suitable only to a given statement. However, universal proof systems such as Marlin and Plonk take as input a statement and create a proof for it. They’re more flexible but also more complex to construct and have higher computation overhead.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec55">&#13;
<h4 class="H2"><span id="sec55"/><span id="h2-210"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">How Things Can Go Wrong</samp></h4>&#13;
<p class="TNI">zkSNARKs can suffer from the same classes of problems as in the context of threshold signatures, from an insecure protocol to implementation flaws. Security issues can arise at different stages of the workflow, from the statement definition to the arithmetization step and the proof computation. The security notion impacted may be completeness, soundness, or zero-knowledge. But most of the time, the greatest risk concerns soundness, or the possibility of an attacker to cheat and fool a verifier—both because of the potential impact on the application and the subtlety of soundness bugs, whereas a leak of “knowledge” is less likely, especially if the proof must remain a valid one accepted by a verifier.</p>&#13;
<p class="TX">In the forthcoming examples, we’ll focus on Schnorr’s protocol. The problems are relatively simple, but more complex proof systems can have much subtler issues.</p>&#13;
<p class="TX">Recall that Schnorr’s noninteractive protocol proves the knowledge of <i>a</i> to a verifier that knows <i>A</i> = <i>aG</i> by sending a verifier <i>s</i> = <i>r</i> + <i>ca</i> and <i>R</i> = <i>rG</i> for a random <i>r</i> and <i>c</i> = <b>H</b>(<i>G</i> || <i>R</i> || <i>A</i>). The verifier then checks the equality <i>sG</i> = <i>R</i> + <i>cA</i> after recomputing <i>c</i>. In the interactive version, the verifier chooses <i>c</i> randomly.</p>&#13;
<section epub:type="division" aria-labelledby="sec56">&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_330" aria-label="330"/>&#13;
<h5 class="H3"><span id="sec56"/><samp class="SANS_Futura_Std_Bold_Condensed_B_11">Insufficient Fiat–Shamir Hashing</samp></h5>&#13;
<p class="TNI">Imagine that instead of <i>c</i> = <b>H</b>(<i>G</i> || <i>R</i> || <i>A</i>), a noninteractive Schnorr proof did <i>c</i> = <b>H</b>(<i>G</i> || <i>A</i>), making the challenge <i>c</i> independent of the nonce <i>R</i>. The attacker then picks an arbitrary value for <i>s</i> and computes <i>R</i> = <i>sG</i> – <i>cA</i>. The resulting proof consisting of <i>s</i> and <i>R</i> is valid, yet the attacker didn’t need to know <i>a</i>, thereby breaking the protocol’s soundness.</p>&#13;
<p class="TX">Likewise, if <i>c</i> = <b>H</b>(<i>G</i> || <i>R</i>), omitting the public key <i>A</i> from the data hashed to define the challenge <i>c</i>, an attack is possible: the attacker can now choose arbitrary <i>R</i> and <i>s</i> values and compute the point <i>B</i> = (1/<i>c</i>) × (<i>sG</i> – <i>R</i>), which satisfies <i>sG</i> = <i>R</i> + <i>cB</i>. This gives the attacker a proof of knowledge of the discrete logarithm of <i>B</i>—namely, <i>b</i> such that <i>B</i> = <i>bG</i>—whereas they don’t know it.</p>&#13;
<p class="TX">These attacks illustrate the importance of including all necessary values in the hash function input when using the Fiat–Shamir transform to make a protocol noninteractive.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec57">&#13;
<h5 class="H3"><span id="sec57"/><samp class="SANS_Futura_Std_Bold_Condensed_B_11">Replay Attacks</samp></h5>&#13;
<p class="TNI">A replay is a trivial but potentially devastating attack. If an attacker learns the value of some noninteractive proof of knowledge, they can send it to another party and say they created it, claiming the credit for the knowledge proven.</p>&#13;
<p class="TX">You may avoid this by binding the proof to the identity of the prover, including their public key in the data hashed. To prevent replay by the same party over time, you may bind the proof to a session identifier or timestamp by including such values in the data processed by the Fiat–Shamir hashes.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec58">&#13;
<h5 class="H3"><span id="sec58"/><samp class="SANS_Futura_Std_Bold_Condensed_B_11">Randomness Reuse</samp></h5>&#13;
<p class="TNI">Consider the interactive Schnorr protocol, where the verifier picks a random <i>c</i>. If the prover has a flawed pseudorandom generator and reuses the same challenge <i>r</i> twice, then an attacker observing the exchanged values can recover the secret <i>a</i> by using the two proofs <i>s</i><sub>1</sub> = <i>r</i> + <i>c</i><sub>1</sub><i>a</i> and <i>s</i><sub>2</sub> = <i>r</i> + <i>c</i><sub>2</sub><i>a</i> for two distinct challengers, <i>c</i><sub>1</sub> and <i>c</i><sub>2</sub>, and computing <i>a</i> = (<i>s</i><sub>1</sub> – <i>s</i><sub>2</sub>) / (<i>c</i><sub>1</sub> – <i>c</i><sub>2</sub>).</p>&#13;
</section>&#13;
</section>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec59">&#13;
<h3 class="H1"><span id="sec59"/><span id="h1-108"/><samp class="SANS_Futura_Std_Bold_B_11">Really Serious Crypto</samp></h3>&#13;
<p class="TNI">With this final chapter, we’ve reviewed some of the most captivating topics in cryptography at the time of writing, from both theoretical and practical viewpoints. We’ve touched only the surface, though, particularly in the realm of zero-knowledge proof systems, an active research and engineering space with extensive applications beyond blockchain technology. But cool cryptography isn’t the panacea of blockchains. From multiparty computation protocols such as private set intersection (PSI) to homomorphic encryption used for private evaluation of AI models, new applications and use cases call for better, faster cryptographic functionalities.</p>&#13;
<p class="TX">We’re witnessing a golden age in cryptography, with an unprecedented convergence of theoretical principles and practical applications. This <span role="doc-pagebreak" epub:type="pagebreak" id="pg_331" aria-label="331"/>synergy is providing almost magical solutions to some of the most daunting security and privacy problems. Nonetheless, significant challenges need to be addressed, particularly in the legal and regulatory spheres. It’s imperative that technologists and policymakers collaborate closely to navigate these challenges and that both attempt to understand each other’s perspectives. It is my hope that this book, and particularly this last chapter, contributes to demystifying cryptography and making it more accessible and less enigmatic for all its readers.</p>&#13;
</section>&#13;
</section>&#13;
</div>
</div>
</body></html>