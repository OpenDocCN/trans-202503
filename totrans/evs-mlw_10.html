<html><head></head><body>
<section epub:type="chapter" role="doc-chapter" aria-labelledby="ch8">&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_129" aria-label="129"/>&#13;
<hgroup>&#13;
&#13;
<h2 class="CHAPTER" id="ch8">&#13;
<span class="CN"><samp class="SANS_Futura_Std_Bold_Condensed_B_11">8</samp></span>&#13;
<span class="CT"><samp class="SANS_Dogma_OT_Bold_B_11">EVADING SANDBOXES AND DISRUPTING ANALYSIS</samp></span>&#13;
</h2>&#13;
</hgroup>&#13;
<figure class="opener"><img class="opener" src="../images/opener.jpg" alt=""/></figure>&#13;
<p class="TNI2">In previous chapters, you’ve learned about several techniques that malware uses to establish context and better understand its current environment. When malware determines that it’s running in an analyst’s lab or in an otherwise hostile environment, it may take evasive measures, such as delaying its execution, creating decoys, or even actively impeding investigation efforts by interfering with the analyst’s tools. This chapter will focus on these and other methods that malware uses to hide from and circumvent analysis tools.</p>&#13;
<section epub:type="division" aria-labelledby="sec1">&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_130" aria-label="130"/>&#13;
<h3 class="H1" id="sec1"><span id="h-106"/><samp class="SANS_Futura_Std_Bold_B_11">Self-Termination</samp></h3>&#13;
<p class="TNI1">A simple and effective way in which malware can avoid analysis is <i>self-termination</i>. The malware can simply call Windows API functions such as <samp class="SANS_TheSansMonoCd_W5Regular_11">TerminateProcess</samp> or <samp class="SANS_TheSansMonoCd_W5Regular_11">ExitProcess</samp> to issue a “kill” command to its own process, like so:</p>&#13;
<pre class="pre-51"><code>is_vm = enumerate_reg_keys(keys)&#13;
if (is_vm)&#13;
{&#13;
  current_process = GetCurrentProcess()&#13;
  TerminateProcess(current_process, ... )&#13;
}</code></pre>&#13;
<p class="TX">This malware pseudocode first calls its own internal <samp class="SANS_TheSansMonoCd_W5Regular_11">enumerate_reg_keys</samp> function to enumerate some of the VM-related registry keys discussed in <span class="Xref"><a href="chapter4.xhtml">Chapter 4</a>.</span> (The details of the function aren’t shown here.) Next, if <samp class="SANS_TheSansMonoCd_W5Regular_11">is_vm</samp> returns true, the malware requests a handle to its own process (<samp class="SANS_TheSansMonoCd_W5Regular_11">GetCurrentProcess</samp>) and then terminates itself by calling <samp class="SANS_TheSansMonoCd_W5Regular_11">TerminateProcess</samp>. The <samp class="SANS_TheSansMonoCd_W5Regular_11">ExitProcess</samp> function can be used in the same way, with a few trivial differences. Sometimes malware even calls both functions to ensure that it has successfully terminated.</p>&#13;
<p class="TX">This technique is especially effective against automated sandboxes, which can’t monitor the behavior of a malware sample that has terminated itself. However, a sandbox could flag the function itself or detect that the sample terminated itself too soon. This approach can also be effective against a malware analyst interacting with the sample manually, as the analyst will have to walk backward through the code in a debugger or disassembler to determine how and why the malware terminated itself.</p>&#13;
<p class="TX">When you’re analyzing a malware sample that’s using this technique, setting a debugger breakpoint on <samp class="SANS_TheSansMonoCd_W5Regular_11">ExitProcess</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">TerminateProcess</samp> may help you catch the malware before it has a chance to kill itself. This will allow you to inspect the call stack and the code leading up to the process termination, and hopefully to identify what caused it. Keep in mind, however, that these API functions might also be called during a crash, so the malware may not be invoking them directly for evasion purposes.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec2">&#13;
&#13;
<h3 class="H1" id="sec2"><span id="h-107"/><samp class="SANS_Futura_Std_Bold_B_11">Delayed Execution</samp></h3>&#13;
<p class="TNI1">Imagine a typical automated malware analysis sandbox environment. This environment will boot up on demand, detonate a malware sample, monitor the malware’s behaviors for a few minutes (depending on how the sandbox is configured), and then shut down. But what if the malware delays its own execution to “time out” the sandbox analysis process? For example, perhaps the malware executes a sleep routine in which it lies dormant for several minutes, outlasting the short life of the sandbox environment. It’s not unheard of for advanced malware to delay its execution for hours or even <span role="doc-pagebreak" epub:type="pagebreak" id="pg_131" aria-label="131"/>weeks at a time. This is an effective method of evading sandboxes and frustrating malware analysts’ efforts.</p>&#13;
<section epub:type="division" aria-labelledby="sec3">&#13;
&#13;
<h4 class="H2" id="sec3"><span id="h-108"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_I_11">Sleep Function Calls</samp></h4>&#13;
<p class="TNI1">Perhaps the most common form of delayed execution is malware simply invoking the <samp class="SANS_TheSansMonoCd_W5Regular_11">Sleep</samp> function from the Windows API. <samp class="SANS_TheSansMonoCd_W5Regular_11">Sleep</samp>, as well as its cousin, <samp class="SANS_TheSansMonoCd_W5Regular_11">SleepEx</samp>, takes a parameter that represents the sleep time in milliseconds. The following assembly code shows a snippet of a malware sample calling the <samp class="SANS_TheSansMonoCd_W5Regular_11">Sleep</samp> function:</p>&#13;
<pre class="pre-52"><code>push 493E0h ; 5 minutes&#13;
call Sleep</code></pre>&#13;
<p class="TX">In this case, the <samp class="SANS_TheSansMonoCd_W5Regular_11">493E0h</samp> parameter passed to <samp class="SANS_TheSansMonoCd_W5Regular_11">Sleep</samp> is the time in hexadecimal, representing 300,000 milliseconds, or 5 minutes.</p>&#13;
<blockquote>&#13;
<p class="Note"><span class="NoteHead"><samp class="SANS_Dogma_OT_Bold_B_15">NOTE</samp></span></p>&#13;
</blockquote>&#13;
<p class="NOTE-TXT"><i>For more information on the <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">Sleep</samp> function and how malware can use it, see <a href="chapter7.xhtml">Chapter 7</a>.</i></p>&#13;
<p class="TX">To bypass this technique, you could put a breakpoint on <samp class="SANS_TheSansMonoCd_W5Regular_11">Sleep</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">SleepEx</samp> function calls and then modify the <samp class="SANS_TheSansMonoCd_W5Regular_11">dwMilliseconds</samp> parameter passed to it. Alternatively, you could <samp class="SANS_TheSansMonoCd_W5Regular_11">nop</samp> out these <samp class="SANS_TheSansMonoCd_W5Regular_11">Sleep</samp> instructions or jump over them in a debugger. These aren’t always foolproof solutions, however; advanced malware may calculate the system time before and after the calls to <samp class="SANS_TheSansMonoCd_W5Regular_11">Sleep</samp> to verify that the <samp class="SANS_TheSansMonoCd_W5Regular_11">Sleep</samp> function executed correctly! Lastly, many modern sandboxes can intercept calls to <samp class="SANS_TheSansMonoCd_W5Regular_11">Sleep</samp> and modify them, dramatically lowering the sample’s total sleep time.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec4">&#13;
&#13;
<h4 class="H2" id="sec4"><span id="h-109"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_I_11">Timeouts</samp></h4>&#13;
<p class="TNI1">Malware can take a less traditional route to delay its execution by using Windows utilities, such as <i>ping.exe</i>, to cause a <i>timeout</i>. This approach often works better than the sleep method, since it’s more difficult for sandboxes to interfere with. Another advantage is that it may confuse the analysis process, as the malware analyst must figure out why the malware sample is invoking a certain application.</p>&#13;
<p class="TX">In the following code snippet, a malware sample is executing <i>ping.exe</i> to ping Google 1,000 times. Depending on the network connection speed, this could create a long delay or even cause the sandbox to time out and stop analysis:</p>&#13;
<pre class="pre-53"><code>push eax ; "ping.exe google.com -n 1000"&#13;
push 0;&#13;
call CreateProcessA</code></pre>&#13;
<p class="TX">Malware can also call the <i>timeout.exe</i> Windows tool, which is typically used in batch scripts to pause command processing, in order to delay execution. Be on the lookout for malware invoking these types of tools. Use code <span role="doc-pagebreak" epub:type="pagebreak" id="pg_132" aria-label="132"/>analysis and debugging to understand why the malware might be executing this behavior.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec5">&#13;
&#13;
<h4 class="H2" id="sec5"><span id="h-110"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_I_11">Time and Logic Bombs</samp></h4>&#13;
<p class="TNI1">In a <i>time bomb</i>, the malware sets a specific time, such as a certain date or time of day, for when it will execute. For example, a malware sample may contain embedded code that executes only at 9 <small>AM</small> every morning, once every Saturday, or on December 26, 2024, at 5:55 <small>PM</small>. Unless the sandbox or malware analyst manually sets the date or time to trick the malware into running, the sample won’t execute its malicious code.</p>&#13;
<p class="TX">Similar to a time bomb, in a <i>logic bomb,</i> the malware executes after a specific event (such as a certain file deletion or database transaction) has occurred on the host. Logic bombs may be even more effective than time bombs, since they can be very specific to the malware’s operating environment.</p>&#13;
<p class="TX">The following simplified pseudocode demonstrates a time bomb technique in which the malware sample gets the current system date and compares it to a hardcoded date (in this case, 2024):</p>&#13;
<pre class="pre-54"><code><var>--snip--</var>&#13;
GetSystemTime(&amp;systemTime)&#13;
&#13;
if (systemTime.wYear &lt;= '2024') {&#13;
  KillSelf()&#13;
}</code></pre>&#13;
<p class="TX">If the malware determines that the current date is 2024 or earlier, it will fail to execute.</p>&#13;
<p class="TX">Sometimes a sandbox can identify whether malware is using these techniques, but they often fly under the radar. The best way to identify time and logic bombs is code analysis. Inspecting the malware sample in a disassembler or debugger may uncover the time, date, or logic that the malware is looking for. Once you identify this, you can simply set your analysis system time to match it or try to re-create the logic. Alternatively, you could modify the malware’s code in a disassembler or debugger to bypass these checks.</p>&#13;
<p class="TX">It’s important to note that, besides being used for evasion, time bomb techniques are used to control the malware’s spread. Malware may be programmed to <i>not</i> execute after a specific date or time in order to better control it or otherwise limit its lifetime.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec6">&#13;
&#13;
<h4 class="H2" id="sec6"><span id="h-111"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_I_11">Dummy Code and Infinite Loops</samp></h4>&#13;
<p class="TNI1">Some malware authors introduce <i>dummy code</i> into their malware that loops, possibly infinitely, calling CPU-intensive functions or functions that serve no purpose other than to time out the analysis. The dummy code usually <span role="doc-pagebreak" epub:type="pagebreak" id="pg_133" aria-label="133"/>runs once the malware has detected a sandbox or VM environment. The following assembly code example shows what that might look like:</p>&#13;
<pre class="pre-55"><code>loop:&#13;
inc ecx&#13;
cmp ecx,ecx&#13;
je loop</code></pre>&#13;
<p class="TX">In this basic <samp class="SANS_TheSansMonoCd_W5Regular_11">for</samp> loop, the value of <samp class="SANS_TheSansMonoCd_W5Regular_11">ecx</samp> is incremented by 1 and then compared to itself. If it’s equal to itself (hint: it will be), the loop repeats. This simple code will stall the malware’s execution indefinitely, or at least until the sandbox terminates or the malware analyst becomes frustrated and kills the process.</p>&#13;
<p class="TX">Similarly, some malware repeatedly calls Windows API functions to stall analysis. For example, it might call <samp class="SANS_TheSansMonoCd_W5Regular_11">RegEnumKey</samp> to enumerate the host’s entire registry, which will take a significant amount of time. Alternatively, the malware sample might repeatedly call <samp class="SANS_TheSansMonoCd_W5Regular_11">LoadLibrary</samp> on nonexistent libraries. While writing this book, I analyzed a Dridex banking trojan sample that executes <samp class="SANS_TheSansMonoCd_W5Regular_11">GetProcAddress</samp> over <i>five million times</i> to resolve addresses of functions it never uses (see <a href="chapter8.xhtml#fig8-1">Figure 8-1</a>). This stalls analysis, uses up valuable sandbox memory and CPU resources, and sometimes results in a crash.</p>&#13;
<figure class="IMG"><img class="img100" id="fig8-1" src="../images/fig8-1.jpg" alt=""/>&#13;
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 8-1: Delaying analysis by repeatedly executing GetProcAddress</samp></p></figcaption>&#13;
</figure>&#13;
<p class="TX">Dridex has also been known to execute <samp class="SANS_TheSansMonoCd_W5Regular_11">OutputDebugString</samp> in an infinite loop, which has the same effect as the <samp class="SANS_TheSansMonoCd_W5Regular_11">GetProcAddress</samp> approach. The <samp class="SANS_TheSansMonoCd_W5Regular_11">OutputDebugString</samp> function will be discussed in more detail in <span class="Xref"><a href="chapter10.xhtml">Chapter 10</a></span>.</p>&#13;
<aside class="box" aria-label="box-7">&#13;
<p class="BoxTitle" id="box-7"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_134" aria-label="134"/><samp class="SANS_Dogma_OT_Bold_B_11">PERSISTENCE MECHANISMS FOR DELAYING EXECUTION</samp></p>&#13;
<p class="BoxBodyFirst"><samp class="SANS_Futura_Std_Book_11">Oftentimes, malware attempts to establish persistence on the victim host in order to “survive” system shutdowns and reboots, but persistence is also a great delayed-execution tactic. Malware can configure a persistence mechanism in the form of a scheduled task on the victim host to execute its payload only after a certain event or amount of time. <a href="chapter15.xhtml">Chapter 15</a> will discuss several ways to achieve persistence.</samp></p>&#13;
</aside>&#13;
</section>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec7">&#13;
&#13;
<h3 class="H1" id="sec7"><span id="h-112"/><samp class="SANS_Futura_Std_Bold_B_11">Forcing Reboots and Logouts</samp></h3>&#13;
<p class="TNI1">Forcing a system shutdown, reboot, or logout can be an effective method of evasion, especially in sandboxes. It will promptly halt all analysis efforts, at least until the host is back up. Most modern sandboxes are able to deal with this, however, and if the sandbox senses a shutdown or logout has been issued, it will simply continue analysis after the machine is back up. But this can still negatively affect the malware analysis process. In the case of reboots, for example, artifacts that were once in memory may now be destroyed.</p>&#13;
<p class="TX">Malware can force a reboot or shutdown by invoking functions such as <samp class="SANS_TheSansMonoCd_W5Regular_11">InitiateShutdown</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">InitiateSystemShutdown</samp>, and <samp class="SANS_TheSansMonoCd_W5Regular_11">InitiateSystemShutdownEx</samp>. All three functions operate similarly and take a few key arguments, such as an option specifying whether to shut down or reboot the host, as well as a <i>timeout</i> value representing the duration between the function call and the reboot or shutdown. Another API function that malware might use is <samp class="SANS_TheSansMonoCd_W5Regular_11">ExitWindows</samp> (or its sibling, <samp class="SANS_TheSansMonoCd_W5Regular_11">ExitWindowsEx</samp>), which adds the option to log out the user, rather than simply rebooting or shutting down the host. Finally, the system can also be shut down using WMI, PowerShell, or the built-in Windows <i>shutdown.exe</i> tool.</p>&#13;
<p class="TX">Malware often uses this technique after it has established persistence, at which point it forces a reboot and then runs its actual payload. In this way, it successfully evades certain automated analysis sandboxes and confuses (or at least annoys) malware analysts trying to investigate the sample.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec8">&#13;
&#13;
<h3 class="H1" id="sec8"><span id="h-113"/><samp class="SANS_Futura_Std_Bold_B_11">Decoys and Noise</samp></h3>&#13;
<p class="TNI1">Some malware authors take advantage of the fact that sandboxes operate in a predictable way. For example, sandboxes must capture a large amount of data to understand and assess a malware sample’s behaviors, and malware can exploit this by generating lots of <i>noisy</i> or <i>decoy</i> data that can quickly overwhelm a sandbox or hamper analysis. This section covers a few different ways in which malware can do this.</p>&#13;
<section epub:type="division" aria-labelledby="sec9">&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_135" aria-label="135"/>&#13;
<h4 class="H2" id="sec9"><span id="h-114"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_I_11">API Hammering</samp></h4>&#13;
<p class="TNI1">When a sandbox detonates a malware sample, it logs the malware’s behaviors and function calls. <i>API hammering</i> involves calling the same function many times (in some cases, hundreds of thousands of times) to quickly fill up the sandbox logs and flood the analysis environment with useless data. As a result, the sandbox may be unable to successfully analyze the sample due to too much noise and a full log. Furthermore, malware samples using API-hammering techniques will take a lot longer to fully execute in a sandbox since its logging behaviors introduce extra overhead. If the same sample were executed on a normal end-user system, it would execute much more quickly.</p>&#13;
<p class="TX">Nearly any Windows API function can be abused for this purpose. Two I’ve seen are <samp class="SANS_TheSansMonoCd_W5Regular_11">printf</samp> (a C function that prints characters to the calling application) and <samp class="SANS_TheSansMonoCd_W5Regular_11">TlsGetValue</samp>. The malware sample shown in <a href="chapter8.xhtml#fig8-2">Figure 8-2</a> called the <samp class="SANS_TheSansMonoCd_W5Regular_11">TlsGetValue</samp> function over 30,000 times in a row!</p>&#13;
<figure class="IMG"><img class="img60" id="fig8-2" src="../images/fig8-2.jpg" alt=""/>&#13;
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 8-2: Malware using API hammering by calling TlsGetValue multiple times</samp></p></figcaption>&#13;
</figure>&#13;
<p class="TX">The malware families Nymaim and Trickbot both employ API-hammering techniques, as described in blog posts from Joe Security (<a href="https://www.joesecurity.org"><i>https://<wbr/>www<wbr/>.joesecurity<wbr/>.org</i></a>). At least one Nymaim variant makes over <i>half a million</i> benign Windows API function calls if the sample detects that it’s running in a VM or sandbox environment! As you can imagine, this generates an enormous amount of data in a sandbox log. Some sandboxes, unable to handle that volume of data, would likely terminate the analysis early.</p>&#13;
<p class="TX">Many modern sandboxes can detect API hammering, however, and will flag such behavior as suspicious or even stop logging the questionable function altogether. A sandbox might also modify the running malware sample’s <span role="doc-pagebreak" epub:type="pagebreak" id="pg_136" aria-label="136"/>behavior or take other actions to prevent API hammering from interfering with analysis. But if left undetected, API hammering can severely impact the sandbox’s ability to assess the malware.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec10">&#13;
&#13;
<h4 class="H2" id="sec10"><span id="h-115"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_I_11">Unnecessary Process Spawning</samp></h4>&#13;
<p class="TNI1">Like API hammering, unnecessary process spawning is a technique used to overwhelm sandboxes and malware analysts. The malware sample shown in <a href="chapter8.xhtml#fig8-3">Figure 8-3</a> spawns several hundred processes, all named <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">&lt;xxxx&gt;.tmp</samp>, to hide its true activity.</p>&#13;
<figure class="IMG"><img class="img60" id="fig8-3" src="../images/fig8-3.jpg" alt=""/>&#13;
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 8-3: Malware spawning a large number of “dummy” processes</samp></p></figcaption>&#13;
</figure>&#13;
<p class="TX">Because of the staggering number of processes the malware creates, it’s difficult for the analyst to identify which ones are worth investigating. Sandboxes may also be overwhelmed by all the data.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec11">&#13;
&#13;
<h4 class="H2" id="sec11"><span id="h-116"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_I_11">Decoy Network Communication</samp></h4>&#13;
<p class="TNI1">Some malware variants send fake or decoy network traffic to attempt to conceal the real malicious traffic. One malware family, Formbook, is well known for using this technique. Formbook connects to a randomized list of several decoy web addresses and one actual <i>command and control (C2)</i> address, which can confuse analysts and sandboxes. In some cases, these decoy addresses are real domains that can lead the malware analyst down <span role="doc-pagebreak" epub:type="pagebreak" id="pg_137" aria-label="137"/>the wrong paths during the investigation. <a href="chapter8.xhtml#fig8-4">Figure 8-4</a> shows Formbook connecting to multiple decoy C2 addresses using normal HTTP <samp class="SANS_TheSansMonoCd_W5Regular_11">GET</samp> requests.</p>&#13;
<figure class="IMG"><img class="img100" id="fig8-4" src="../images/fig8-4.jpg" alt=""/>&#13;
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 8-4: Formbook connecting to decoy C2 addresses</samp></p></figcaption>&#13;
</figure>&#13;
<p class="TX">As you can see, all of the traffic looks almost identical, but only one of these connections is for the real C2 server.</p>&#13;
<blockquote>&#13;
<p class="Note"><span class="NoteHead"><samp class="SANS_Dogma_OT_Bold_B_15">NOTE</samp></span></p>&#13;
</blockquote>&#13;
<p class="NOTE-TXT"><i>You can download the Formbook malware from VirusTotal or MalShare using the following file hash:</i></p>&#13;
<blockquote>&#13;
<p class="NoteCodeSpaceAbove1">SHA256: 08ef1473879e6e8197f1eadfe3e51a9dbdc9c892e442b57a3186a64ecc9d1e41</p>&#13;
</blockquote>&#13;
</section>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec12">&#13;
&#13;
<h3 class="H1" id="sec12"><span id="h-117"/><samp class="SANS_Futura_Std_Bold_B_11">Anti-hooking</samp></h3>&#13;
<p class="TNI1">Many malware analysis sandboxes and tools use <i>API hooking</i>, or simply <i>hooking</i>, to analyze malware behavior. This involves injecting a piece of code, called a <i>hook</i>, into the malware’s memory space. The hook then intercepts API function calls, redirects them to a different function or modifies their behavior, and passes them on to the original function. This hook is often a module, typically in the form of a DLL, that then monitors the sample as it runs (see <a href="chapter8.xhtml#fig8-5">Figure 8-5</a>).</p>&#13;
<figure class="IMG"><img class="img100" id="fig8-5" src="../images/fig8-5.jpg" alt=""/>&#13;
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 8-5: A sandbox hooking a running malware process</samp></p></figcaption>&#13;
</figure>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_138" aria-label="138"/>In this example, a sandbox has hooked the running malware’s process (hooked malware) via DLL injection (the sandbox hooking DLL). The sandbox modifies the first few bytes of the function it’s hooking (inside <i>user32.dll</i>) and inserts a jump (<samp class="SANS_TheSansMonoCd_W5Regular_11">jmp</samp>) instruction. Now any calls to the function in the <i>user32.dll</i> library will jump to the hook code in the sandbox hooking DLL. The installed hook allows the sandbox to intercept and monitor function calls and potentially modify the function call parameters or return values.</p>&#13;
<p class="TX">To implement a hook, the sandbox agent inserts a jump statement into the beginning of a function it wishes to hook. The following assembly code excerpt shows the first few bytes of the <samp class="SANS_TheSansMonoCd_W5Regular_11">ReadFile</samp> function after it has been hooked by a sandbox:</p>&#13;
<pre class="pre-56"><code>0x77000000 jmp hook_code&#13;
0x77000005 // Start of real ReadFile code</code></pre>&#13;
<p class="TX">In this hooked code, the inserted jump statement will ensure that when the malware calls the <samp class="SANS_TheSansMonoCd_W5Regular_11">ReadFile</samp> function, the execution flow will transfer to the sandbox hook code (<samp class="SANS_TheSansMonoCd_W5Regular_11">hook_code</samp>) before executing the real <samp class="SANS_TheSansMonoCd_W5Regular_11">ReadFile</samp> code. This type of hook is called <i>inline hooking</i>. Sandboxes use a technique called <i>process injection</i> to inject inline hooks into target processes. We’ll discuss injection and various types of hooking in more detail in <span class="Xref"><a href="chapter12.xhtml">Chapter 12</a></span>.</p>&#13;
<p class="TX">Some analysis tools, such as API Monitor and certain debugger plug-ins, use hooks for similar purposes. One example is the popular tool ScyllaHide, which can be used to circumvent anti-debugging techniques in malware. (<span class="Xref"><a href="chapter10.xhtml">Chapter 10</a></span> will cover ScyllaHide in greater detail.) In this section, we’ll dig deeper into some of the ways in which malware can detect and circumvent hooking and monitoring.</p>&#13;
<section epub:type="division" aria-labelledby="sec13">&#13;
&#13;
<h4 class="H2" id="sec13"><span id="h-118"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_I_11">Hook Detection</samp></h4>&#13;
<p class="TNI1">Before executing, malware will likely try to detect whether it’s being hooked by a sandbox or an analysis tool by scanning its own memory for these injected hooking modules. In <span class="Xref"><a href="chapter7.xhtml">Chapter 7</a></span>, you saw how malware can call functions such as <samp class="SANS_TheSansMonoCd_W5Regular_11">Module32First</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">Module32Next</samp> to enumerate its loaded modules. For hook detection, the malware sample may keep track of which modules it will load, so if it enumerates its loaded modules and notices an anomalous loaded module, it may assume that it’s being hooked or otherwise monitored.</p>&#13;
<p class="TX">Before executing its target function, malware can check whether a sandbox has modified that function’s code in an attempt to hook it. In order to accomplish this, the malware invokes either <samp class="SANS_TheSansMonoCd_W5Regular_11">ReadProcessMemory</samp> or <samp class="SANS_TheSansMonoCd_W5Regular_11">NtReadVirtualMemory</samp> to read the memory where the suspect function resides, and then it inspects the first few bytes of the function. The malware will be on the lookout for anomalous jump instructions that have been inserted into the beginning of the function in question, a sure sign of hooking, as the following pseudocode illustrates:</p>&#13;
<pre class="pre-57"><code><span role="doc-pagebreak" epub:type="pagebreak" id="pg_139" aria-label="139"/>handle = GetModuleHandle("ntdll.dll")&#13;
functionAddress = GetProcAddress(handle, "NtAllocateVirtualMemory")&#13;
&#13;
ReadProcessMemory(GetCurrentProcess(), functionAddress, buffer, bufferSize, &amp;bytesRead)&#13;
&#13;
if (buffer[0] == 0xE9)&#13;
  {&#13;
     // Function hooked&#13;
      return true&#13;
  }</code></pre>&#13;
<p class="TX">This malware’s code first obtains a handle for <samp class="SANS_TheSansMonoCd_W5Regular_11">ntdll.dll</samp> and the address for <samp class="SANS_TheSansMonoCd_W5Regular_11">NtAllocateVirtualMemory</samp>. The code then invokes <samp class="SANS_TheSansMonoCd_W5Regular_11">ReadProcessMemory</samp> to inspect the first byte of the <samp class="SANS_TheSansMonoCd_W5Regular_11">NtAllocateVirtualMemory</samp> function. If the first byte is a jump instruction (hex <samp class="SANS_TheSansMonoCd_W5Regular_11">E9</samp>), then the malware assumes that <samp class="SANS_TheSansMonoCd_W5Regular_11">NtAllocateVirtualMemory</samp> is hooked and that it’s being monitored by a sandbox or analysis tool.</p>&#13;
<p class="TX">We’ll come back to this technique in a moment in <span class="Xref">“Performing Unaligned Function Calls”</span> on <span class="Xref"><a href="chapter8.xhtml#pg_140">page 140</a></span>.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec14">&#13;
&#13;
<h4 class="H2" id="sec14"><span id="h-119"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_I_11">Hook Removal (Unhooking)</samp></h4>&#13;
<p class="TNI1">After detecting a hook, the malware sample can attempt to remove it by restoring the original data. There are a few ways in which malware can attempt to do this.</p>&#13;
<p class="TX">First, malware can manually unload any suspicious modules (injected hooking DLLs) that it determines have been loaded into its process address space. Once it detects an anomalous module, it can call the <samp class="SANS_TheSansMonoCd_W5Regular_11">FreeLibrary</samp> function. <samp class="SANS_TheSansMonoCd_W5Regular_11">FreeLibrary</samp> takes as a parameter the handle of the library module the malware wishes to unload.</p>&#13;
<p class="TX">A possibly better way for malware to accomplish this unhooking is by manually reloading Windows libraries that appear to be hooked. Malware can scan its loaded libraries for signs of a hooking module, and once it detects a hook, it can unload that DLL (using a function such as <samp class="SANS_TheSansMonoCd_W5Regular_11">FreeLibrary</samp>) and then reload the fresh, unhooked library from disk. This effectively removes any function hooks installed by the sandbox or analysis tool.</p>&#13;
<p class="TX">Alternatively, once the malware detects that a function is hooked, it can simply rewrite the original code into the function, replacing the jump to the hooking code. To unhook an inline hook, the malware can simply remove the hooked bytes of the function (the jump statement) or overwrite them with something else, as the following pseudocode demonstrates:</p>&#13;
<pre class="pre-58"><code>handle = GetModuleHandle("ntdll.dll")&#13;
functionAddress = GetProcAddress(handle, "NtAllocateVirtualMemory")&#13;
&#13;
VirtualProtect(functionAddress, size, PAGE_EXECUTE_READWRITE, &amp;oldProtect)&#13;
memcpy(functionAddress, "\x4c\x8b\xd1\xb8", 4)&#13;
&#13;
VirtualProtect(functionAddress, size, oldProtect, &amp;newOldProtect)</code></pre>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_140" aria-label="140"/>In this code, the malware gets the address (<samp class="SANS_TheSansMonoCd_W5Regular_11">GetProcAddress</samp>) of the library and function it wishes to unhook (in this case, <samp class="SANS_TheSansMonoCd_W5Regular_11">NtAllocateVirtualMemory</samp>), then calls <samp class="SANS_TheSansMonoCd_W5Regular_11">VirtualProtect</samp> to prepare the function for modification by giving it execute, read, and write permissions. Then, the malware copies (<samp class="SANS_TheSansMonoCd_W5Regular_11">memcpy</samp>) the four bytes (<samp class="SANS_TheSansMonoCd_W5Regular_11">\x4c\x8b\xd1\xb8</samp>) to the beginning of the target function’s code. These bytes are the standard, unhooked, original bytes that would reside in the target function before they were hooked by the sandbox. Finally, the malware calls <samp class="SANS_TheSansMonoCd_W5Regular_11">VirtualProtect</samp> again to change the memory permissions back to what they originally were.</p>&#13;
<p class="TX">Some sandboxes are aware that malware can try to unhook their installed function hooks and will be on the lookout for this. Similar to how malware scans its process memory for signs of hooking, sandboxes can periodically check whether their hooks are still in place and, if not, replace them. Or, sandboxes may monitor malware unhooking behaviors, such as by monitoring calls to <samp class="SANS_TheSansMonoCd_W5Regular_11">ReadProcessMemory</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">WriteProcessMemory</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">memcpy</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">FreeLibrary</samp>, and others.</p>&#13;
<p class="TX">Next, let’s discuss a subtler approach that malware can take to get around sandbox hooks: hook circumvention.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec15">&#13;
&#13;
<h4 class="H2" id="sec15"><span id="h-120"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_I_11">Hook Circumvention</samp></h4>&#13;
<p class="TNI1">As opposed to hook removal, <i>hook circumvention</i> bypasses or prevents hooking altogether. Examples of hook circumvention techniques include calling Windows functions in abnormal ways and manually loading code libraries (thus sidestepping the normal library-loading process). Since some sandboxes can detect whether their hooks are removed or altered, these methods can be less noisy and more difficult to detect.</p>&#13;
<section epub:type="division" aria-labelledby="sec16">&#13;
&#13;
<h5 class="H3" id="sec16"><samp class="SANS_Futura_Std_Bold_Condensed_B_11">Performing Unaligned Function Calls</samp></h5>&#13;
<p class="TNI1">In <i>unaligned</i> function calling, the malware indirectly calls functions by jumping over the sandbox hooking code, effectively skipping it entirely. Normally, malware will call a Windows API function, such as <samp class="SANS_TheSansMonoCd_W5Regular_11">ReadFile</samp>, by using a call instruction (<samp class="SANS_TheSansMonoCd_W5Regular_11">call ReadFile</samp>). This instruction will jump to the beginning of <samp class="SANS_TheSansMonoCd_W5Regular_11">ReadFile</samp> (inside the <i>kernel32.dll</i> module) and execute this code. If the <samp class="SANS_TheSansMonoCd_W5Regular_11">ReadFile</samp> function is hooked by a sandbox, however, the hooking code will be executed first, as discussed earlier in this chapter. In the following code, a hook has been injected into this function:</p>&#13;
<pre class="pre-59"><code>0x77000000 jmp hook_code&#13;
0x77000005 // Start of real ReadFile code</code></pre>&#13;
<p class="TX">To implement an unaligned function call, the malware can directly jump to the <samp class="SANS_TheSansMonoCd_W5Regular_11">0x77000005</samp> address by executing the instruction <samp class="SANS_TheSansMonoCd_W5Regular_11">jmp 0x77000005</samp> (or adding 5 bytes to the base address, as in <samp class="SANS_TheSansMonoCd_W5Regular_11">jmp 0x77000000</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">+ 0x5</samp>), rather than calling <samp class="SANS_TheSansMonoCd_W5Regular_11">ReadFile</samp> normally. This will skip the hooking <samp class="SANS_TheSansMonoCd_W5Regular_11">jmp</samp> statement at <samp class="SANS_TheSansMonoCd_W5Regular_11">0x77000000</samp> and directly execute the real <samp class="SANS_TheSansMonoCd_W5Regular_11">ReadFile</samp> code starting at <samp class="SANS_TheSansMonoCd_W5Regular_11">0x77000005</samp>.</p>&#13;
<p class="TX">One caveat here is that the malware must explicitly specify the function address, meaning it must know that address beforehand. One way the <span role="doc-pagebreak" epub:type="pagebreak" id="pg_141" aria-label="141"/>malware can obtain the address is by calling <samp class="SANS_TheSansMonoCd_W5Regular_11">GetProcAddress</samp>, as shown in this simplified assembly code:</p>&#13;
<pre class="pre-60"><code><var>--snip--</var>&#13;
call GetProcAddress&#13;
mov address, eax&#13;
cmp [address], 0E9h&#13;
je  skip_hook&#13;
<var>--snip--</var>&#13;
skip_hook:&#13;
lea eax, [address+5]&#13;
jmp eax</code></pre>&#13;
<p class="TX">The malware sample calls <samp class="SANS_TheSansMonoCd_W5Regular_11">GetProcAddress</samp> to get the address of its desired target function, and it then stores that value in <samp class="SANS_TheSansMonoCd_W5Regular_11">address</samp> (<samp class="SANS_TheSansMonoCd_W5Regular_11">mov address, eax</samp>). The address points to the beginning of the function, where the malware is checking for hooks. Next, the malware compares the code at this address to the hex value <samp class="SANS_TheSansMonoCd_W5Regular_11">0E9h</samp> (one of the assembly opcodes for <samp class="SANS_TheSansMonoCd_W5Regular_11">jmp</samp>). If this opcode exists, the code jumps to the <samp class="SANS_TheSansMonoCd_W5Regular_11">skip_hook</samp> function, which adds 5 bytes to the address of the target function and stores the pointer to this final address in EAX (<samp class="SANS_TheSansMonoCd_W5Regular_11">lea eax, [address+5]</samp>). Finally, the code jumps to this new address (<samp class="SANS_TheSansMonoCd_W5Regular_11">jmp eax</samp>), bypassing the hook.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec17">&#13;
&#13;
<h5 class="H3" id="sec17"><samp class="SANS_Futura_Std_Bold_Condensed_B_11">Calling Low-Level and Uncommon Functions</samp></h5>&#13;
<p class="TNI1">To circumvent hooking behaviors in sandboxes and analysis tools, some malware invokes lower-level Native API calls, attempting to avoid the more commonly hooked higher-level calls. For example, malware can call the <samp class="SANS_TheSansMonoCd_W5Regular_11">NtProtectVirtualMemory</samp> function directly, rather than calling <samp class="SANS_TheSansMonoCd_W5Regular_11">VirtualProtect</samp> in an attempt to bypass any hooks on the latter.</p>&#13;
<p class="TX">Alternatively, malware can even make direct syscalls into the kernel, bypassing the normal WinAPI calling procedures. (We discussed syscalls in <span class="Xref"><a href="chapter1.xhtml">Chapter 1</a>.</span>) Some sandboxes may not monitor direct calls into the kernel, and that can leave blind spots in the analysis reports from these sandboxes. As this is also a technique used to circumvent endpoint defenses, we’ll return to this topic in detail in <span class="Xref"><a href="chapter13.xhtml">Chapter 13</a></span>.</p>&#13;
<p class="TX">Since automated sandboxes and some malware analysis tools hook or monitor the common Windows functions, malware may also use uncommon functions as a hook circumvention tactic. The Windows API contains a huge number of functions that cover nearly every task a program could want to complete, so inevitably, there are rarely used and near-duplicate functions. For example, the <samp class="SANS_TheSansMonoCd_W5Regular_11">SHEnumKeyEx</samp> function is very similar to <samp class="SANS_TheSansMonoCd_W5Regular_11">RegEnumKey</samp> and can also be used to enumerate registry keys, but it’s far less commonly used. Thus, <samp class="SANS_TheSansMonoCd_W5Regular_11">SHEnumKeyEx</samp> may receive less attention from automated sandboxes and analysts and may go unnoticed when used by malware to thwart hooking attempts.</p>&#13;
<p class="TX">Unfortunately, providing a list of all of these lesser-used functions is impossible since the Windows API is so extensive. However, it’s important <span role="doc-pagebreak" epub:type="pagebreak" id="pg_142" aria-label="142"/>to keep this tactic in mind when investigating malware and researching any API calls you’re unfamiliar with.</p>&#13;
<aside class="box" aria-label="box-8">&#13;
<p class="BoxTitle" id="box-8"><samp class="SANS_Dogma_OT_Bold_B_11">SOCKETS</samp></p>&#13;
<p class="BoxBodyFirst"><samp class="SANS_Futura_Std_Book_11">Most modern Windows applications use higher-level network communication libraries such as WinINet (</samp><samp class="SANS_Futura_Std_Book_Oblique_I_11">Wininet.dll</samp><samp class="SANS_Futura_Std_Book_11">), WinHTTP (</samp><samp class="SANS_Futura_Std_Book_Oblique_I_11">Winhttp.dll</samp><samp class="SANS_Futura_Std_Book_11">), and URLMon (</samp><samp class="SANS_Futura_Std_Book_Oblique_I_11">Urlmon.dll</samp><samp class="SANS_Futura_Std_Book_11">). These are also some of the internet communication libraries most commonly loaded by malware; in fact, most of the malware examples throughout this book use these libraries. The primary benefit of these libraries for malware authors is their ease of use and simple implementation.</samp></p>&#13;
<p class="Boxtext"><samp class="SANS_Futura_Std_Book_11">That said, some malware uses the lower-level library Winsock instead. With Winsock, malware authors have greater flexibility in the way they craft and manipulate their network connections. Additionally, because they operate at a lower level than the previously mentioned libraries, Winsock functions may fly under the radar of analysis tools like web proxies, and analysts can therefore miss some malware behaviors. The following pseudocode demonstrates how a malware sample might create a socket and send data to a remote server:</samp></p>&#13;
<pre class="pre-61"><code><samp class="SANS_TheSansMonoCd_W5Regular_11">int sock = socket("AF_INET", 1, 6);</samp>&#13;
<samp class="SANS_TheSansMonoCd_W5Regular_11">int connect(sock, *sockaddr, length);</samp>&#13;
<samp class="SANS_TheSansMonoCd_W5Regular_11">send(sock, *data , strlen(*data) , 0);</samp></code></pre>&#13;
<p class="Boxtext"><samp class="SANS_Futura_Std_Book_11">In this basic example, the malware sample creates a socket (</samp><samp class="SANS_TheSansMonoCd_W5Regular_11">sock</samp><samp class="SANS_Futura_Std_Book_11">) with parameters specifying that it should use IPv4 (</samp><samp class="SANS_TheSansMonoCd_W5Regular_11">AF_INET</samp><samp class="SANS_Futura_Std_Book_11">), connection-based byte streams (</samp><samp class="SANS_TheSansMonoCd_W5Regular_11">1</samp><samp class="SANS_Futura_Std_Book_11">), and the TCP protocol (</samp><samp class="SANS_TheSansMonoCd_W5Regular_11">6</samp><samp class="SANS_Futura_Std_Book_11">). Next, the malware attempts to connect to a remote server (</samp><samp class="SANS_TheSansMonoCd_W5Regular_11">connect</samp><samp class="SANS_Futura_Std_Book_11">), specifying</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">sock</samp> <samp class="SANS_Futura_Std_Book_11">and a pointer to the</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">sockaddr</samp> <samp class="SANS_Futura_Std_Book_11">table, which contains information about the remote service, such as the hostname and TCP port number. Finally, the malware sends data (</samp><samp class="SANS_TheSansMonoCd_W5Regular_11">send</samp><samp class="SANS_Futura_Std_Book_11">) to the remote server, specifying a pointer to</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">data</samp><samp class="SANS_Futura_Std_Book_11">, which contains the data that the malware wishes to send to the remote server.</samp></p>&#13;
<p class="BoxBodyLast"><samp class="SANS_Futura_Std_Book_11">The details of sockets and how they work are beyond the scope of this book. For more information on sockets and all their possible parameters, MSDN is a great resource.</samp></p>&#13;
</aside>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec18">&#13;
&#13;
<h5 class="H3" id="sec18"><samp class="SANS_Futura_Std_Bold_Condensed_B_11">Manually Loading Libraries and Calling Functions</samp></h5>&#13;
<p class="TNI1">Malware can also manually load Windows libraries, rather than relying on the standard Windows loader. As you may recall from <span class="Xref"><a href="chapter1.xhtml">Chapter 1</a></span>, the standard way in which Windows applications load libraries is by using functions such as <samp class="SANS_TheSansMonoCd_W5Regular_11">LoadLibrary</samp>. The <samp class="SANS_TheSansMonoCd_W5Regular_11">LoadLibrary</samp> function maps the requested library into memory, making for a quick and simple loading process, with the OS doing all the heavy lifting. The downside to this simplicity is that sandboxes <span role="doc-pagebreak" epub:type="pagebreak" id="pg_143" aria-label="143"/>and other analysis tools can easily implement hooks within this library to intercept function calls.</p>&#13;
<p class="TX">To circumvent this, malware can manually map the library file into its process address space by using <samp class="SANS_TheSansMonoCd_W5Regular_11">NtMapViewOfSection</samp>, as shown in this simplified pseudocode:</p>&#13;
<pre class="pre-62"><code>file_name = "C:\Windows\System32\Ntdll.dll"&#13;
NtCreateFile(file_handle, ..., file_name, ... )&#13;
NtCreateSection(section_handle, ..., file_handle)&#13;
NtMapViewOfSection(section_handle, process_handle, ...)</code></pre>&#13;
<p class="TX">In this example, the malware uses <samp class="SANS_TheSansMonoCd_W5Regular_11">NtCreateFile</samp> to get a handle to the file <i>C:\Windows\System32\Ntdll.dll</i>, which is the library it wishes to load. Next, the malware creates a section object using <samp class="SANS_TheSansMonoCd_W5Regular_11">NtCreateSection</samp> and references the previously obtained file handle. A <i>section object</i> is a section of memory that can be shared with other processes, and it provides a method of mapping a file into this area of memory. After the section object is created, the malware maps the <i>ntdll.dll</i> file into it using <samp class="SANS_TheSansMonoCd_W5Regular_11">NtMapViewOfSection</samp>. The <samp class="SANS_TheSansMonoCd_W5Regular_11">process_handle</samp> variable represents the target process into which the file will be mapped. In this case, it’s the malware’s own process.</p>&#13;
<p class="TX">Another similar method is to read the file from disk, rather than mapping it into memory. To read <i>ntdll.dll</i> from disk, the malware can call <samp class="SANS_TheSansMonoCd_W5Regular_11">ReadFile</samp> (or <samp class="SANS_TheSansMonoCd_W5Regular_11">NtReadFile</samp>) and pass the target filename as a parameter. With either of these methods, once the library is mapped or read into memory, the malware can execute its intended functions by jumping to or calling the addresses in the target library. Note that these methods would not be effective “out of the box” and would require some additional work from the malware, such as properly locating the offsets of the functions within the DLL it wishes to call.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec19">&#13;
&#13;
<h5 class="H3" id="sec19"><samp class="SANS_Futura_Std_Bold_Condensed_B_11">Writing Custom Functions</samp></h5>&#13;
<p class="TNI1">Finally, malware authors may choose to rewrite Windows functions entirely and include them in their malware samples to avoid hooking. This is often the most difficult hook circumvention technique to implement; many factors come into play, and the modified function must work perfectly with the victim host’s operating system. It’s quite rare to see this malware approach in practice.</p>&#13;
</section>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec20">&#13;
&#13;
<h4 class="H2" id="sec20"><span id="h-121"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_I_11">Anti-hooking Toolsets</samp></h4>&#13;
<p class="TNI1">There are also tools written specifically for anti-hooking purposes. One example is the appropriately named anticuckoo project (<a href="https://github.com/therealdreg/anticuckoo"><i>https://<wbr/>github<wbr/>.com<wbr/>/therealdreg<wbr/>/anticuckoo</i></a>), which detects potential sandbox hooking by using various methods. Additionally, the tool allows users to exploit the sandbox by modifying the hooked function’s code and possibly causing a memory stack corruption, thus causing the sandbox to crash. This project doesn’t seem to be maintained anymore, but it’s a good example of research on the topic of sandbox anti-hooking. For additional information on this technique, read <span role="doc-pagebreak" epub:type="pagebreak" id="pg_144" aria-label="144"/>the informative blog post “Prevalent Threats Targeting Cuckoo Sandbox Detection and Our Mitigation” at <a href="https://www.fortinet.com/blog/threat-research/prevalent-threats-targeting-cuckoo-sandbox-detection-and-our-mitigation"><i>https://<wbr/>www<wbr/>.fortinet<wbr/>.com<wbr/>/blog<wbr/>/threat<wbr/>-research<wbr/>/prevalent<wbr/>-threats<wbr/>-targeting<wbr/>-cuckoo<wbr/>-sandbox<wbr/>-detection<wbr/>-and<wbr/>-our<wbr/>-mitigation</i></a>.</p>&#13;
<p class="TX">Malware analysis is a cat-and-mouse game. Offensive-security researchers and malware authors consistently come up with new ways to detect and circumvent hooking, so malware analysts and sandbox developers must adapt. For example, the Cuckoo sandbox authors implemented several <i>anti-anti-hooking</i> techniques, such as preventing hooks from being overwritten by restricting memory protection modification. Many other commercial sandboxes have implemented similar functionalities.</p>&#13;
</section>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec21">&#13;
&#13;
<h3 class="H1" id="sec21"><span id="h-122"/><samp class="SANS_Futura_Std_Bold_B_11">Circumventing Sandbox Analysis</samp></h3>&#13;
<p class="TNI1">Because they’re automated, sandboxes are susceptible to evasion tactics at the meta level, by which I mean the level of the sandbox product itself, not its implementation or the underlying OS. For example, certain sandboxes have a size limit on submitted files, so malware authors can simply artificially increase the size of the malware file to circumvent them. Other sandboxes can’t process certain file types or scripts. It’s becoming more common for malicious files to be delivered via email in an encrypted state, with the decryption password in the text of the email. An end user may happily enter this password, decrypt the file, and run the malware, but a sandbox has a much more difficult time with this!</p>&#13;
<p class="TX">Also, some sandboxes have trouble monitoring certain file types. At the time of this writing, many commercial and open source sandboxes don’t fully support Microsoft .NET, which is a cross-platform development framework for Windows. Since .NET implements its own functions that differ from the native Windows and NT API functions, these sandboxes may miss important details about the malware’s behaviors and functionalities.</p>&#13;
<p class="TX">These are just a few examples, and there are many other methods of tricking sandboxes into not executing the malware at all. Keep this in mind when analyzing malware in an automated sandbox, and always be on the lookout for the evasion techniques listed here. It’s also important to properly evaluate a sandbox product to ensure it fits your needs before you deploy it in your environment.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec22">&#13;
&#13;
<h3 class="H1" id="sec22"><span id="h-123"/><samp class="SANS_Futura_Std_Bold_B_11">Disrupting Manual Investigation</samp></h3>&#13;
<p class="TNI1">The techniques discussed in this chapter so far have focused on evading sandboxes, but malware can also directly interfere with manual analysis. For example, <span class="Xref"><a href="chapter4.xhtml">Chapter 4</a></span> described how malware can enumerate the processes running on a host so that it can detect a sandbox environment, a VM, or analysis tooling. However, along with detecting these tools, some malware can actively terminate them.</p>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_145" aria-label="145"/>To terminate a target process, malware can iterate through the process tree by using <samp class="SANS_TheSansMonoCd_W5Regular_11">CreateToolhelp32Snapshot</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">Process32First</samp>, and <samp class="SANS_TheSansMonoCd_W5Regular_11">Process32Next</samp>, as you saw in <span class="Xref"><a href="chapter4.xhtml">Chapter 4</a>.</span> The malware can then call <samp class="SANS_TheSansMonoCd_W5Regular_11">OpenProcess</samp> to obtain a handle to a victim process, followed by <samp class="SANS_TheSansMonoCd_W5Regular_11">TerminateProcess</samp>. The following assembly code example demonstrates how a malware sample might terminate a remote process:</p>&#13;
<pre class="pre-63"><code><var>--snip--</var>&#13;
push  [ebp+dwProcessId] ; PID of "wireshark.exe"&#13;
push  0 ; bInheritHandle&#13;
push  0x1 ; dwDesiredAccess&#13;
call  OpenProcess&#13;
mov   [ebp+ProcessHandle], eax&#13;
xor   eax, eax&#13;
<var>--snip--</var>&#13;
push  [ebp+ProcessHandle]&#13;
call  TerminateProcess</code></pre>&#13;
<p class="TX">In this code snippet, the malware calls <samp class="SANS_TheSansMonoCd_W5Regular_11">OpenProcess</samp> with parameters representing the <samp class="SANS_TheSansMonoCd_W5Regular_11">processID</samp> of the target process (<i>wireshark.exe</i>, in this case), the <samp class="SANS_TheSansMonoCd_W5Regular_11">InheritHandle</samp> value (which isn’t important here), and the <samp class="SANS_TheSansMonoCd_W5Regular_11">dwDesiredAccess</samp> value (the process access rights that the malware’s process is requesting). In this case, the malware is requesting access rights <samp class="SANS_TheSansMonoCd_W5Regular_11">1</samp> (<samp class="SANS_TheSansMonoCd_W5Regular_11">0x1</samp> in hex), which equates to <samp class="SANS_TheSansMonoCd_W5Regular_11">PROCESS_TERMINATE</samp> and allows a calling process (the malware) to terminate another process (<i>wireshark.exe</i>). Wireshark is, of course, just an example here. Malware can query and terminate any process if it has the correct permissions to do so.</p>&#13;
<blockquote>&#13;
<p class="Note"><span class="NoteHead"><samp class="SANS_Dogma_OT_Bold_B_15">NOTE</samp></span></p>&#13;
</blockquote>&#13;
<p class="NOTE-TXT"><i>Sometimes renaming a malware analysis tool’s executable file before launching it will trick simple malware that’s employing this method. For example, renaming</i> <span class="note_Italic">wireshark.exe</span> <i>to</i> <span class="note_Italic">krahseriw.exe</span> <i>might prevent malware from “seeing” this process, thus preventing its termination. This solution won’t work in all cases, however.</i></p>&#13;
<p class="TX">Another tactic malware can use is disorienting the analyst. One interesting malware sample I’ve investigated creates a directory under <i>C:\Users\&lt;user&gt;\AppData\Local\Temp</i>. The malware names the directory a randomly generated number (for example, <i>21335493</i>) and writes temporary files that are necessary to its functionalities into it. In order to protect the directory, the malware constantly enumerates all open windows, looking specifically for windows that reference this temporary directory name, and issues a “kill” request for the window if there’s a match.</p>&#13;
<p class="TX">Here’s a simplified pseudocode example of this technique in action:</p>&#13;
<pre class="pre-64"><code>windows[] = EnumWindows()&#13;
for (i = 0; i &lt; windows[].length; i++) {&#13;
  window_text = GetWindowText(windows[i])&#13;
  if (windows_text == "21335493") {&#13;
    PostMessage(windows[i], WM_CLOSE)&#13;
  }&#13;
}</code></pre>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_146" aria-label="146"/>This malware sample uses <samp class="SANS_TheSansMonoCd_W5Regular_11">EnumWindows</samp> to enumerate all desktop windows and then loops through all the window title text, using <samp class="SANS_TheSansMonoCd_W5Regular_11">GetWindowText</samp>, to look for <samp class="SANS_TheSansMonoCd_W5Regular_11">21335493</samp>. If the code finds a window containing this text, the malware calls the <samp class="SANS_TheSansMonoCd_W5Regular_11">PostMessage</samp> function with the <samp class="SANS_TheSansMonoCd_W5Regular_11">WM_CLOSE</samp> parameter, forcing that window to close. Now, if the malware analyst tries to open the <i>21335493</i> temporary directory in, say, Explorer, it will be closed automatically before the analyst can inspect its contents.</p>&#13;
<p class="TX">These two examples only scratch the surface. Starting in <span class="Xref"><a href="chapter10.xhtml">Chapter 10</a></span>, I’ll discuss other interesting measures that malware authors can implement in their code to confuse and impede manual analysis.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec23">&#13;
&#13;
<h3 class="H1" id="sec23"><span id="h-124"/><samp class="SANS_Futura_Std_Bold_B_11">Hypervisor Exploits and VM Escaping</samp></h3>&#13;
<p class="TNI1">The last technique we’ll cover in this chapter may be the ultimate sandbox and VM evasion move: exploiting the hypervisor itself or escaping it entirely. While it’s rarely seen in malware, there have been occasional uses of this technique in the wild, as well as the odd vulnerability discovered in products such as VMware and VirtualBox. One notable example is Cloudburst, an exploit developed in 2009 by Immunity Inc. that affected certain versions of VMware hypervisors. Playing a specially crafted video file on the Windows VM would exploit a flaw in VMware’s display functions and possibly allow code to execute on the host OS itself.</p>&#13;
<p class="TX">Most known hypervisor vulnerabilities don’t directly allow code execution on the host, meaning that complete “escape” from the sandbox environment is unlikely. For example, some of these vulnerabilities allow for writing files to the host or possibly reading files from the host, but they won’t allow malicious files or code to be executed on the host. In addition, at the time of this writing, all of these discovered and reported vulnerabilities have been patched by their respective hypervisor vendors. As long as you, the malware analyst, are detonating malware on an updated and patched hypervisor, your host system is theoretically safe.</p>&#13;
<blockquote>&#13;
<p class="Note"><span class="NoteHead"><samp class="SANS_Dogma_OT_Bold_B_15">NOTE</samp></span></p>&#13;
</blockquote>&#13;
<p class="NOTE-TXT"><i>I say “theoretically” here because there’s always the possibility of zero-day vulnerabilities and unknown, unreported bugs in hypervisor code that malware could potentially exploit. There’s always a risk when you’re analyzing malware, but I believe any risk is outweighed by the benefits. In <a href="appendix-A.xhtml">Appendix A</a>, we’ll discuss a few steps you can take to ensure you’re working in the safest environment possible.</i></p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec24">&#13;
&#13;
<h3 class="H1" id="sec24"><span id="h-125"/><samp class="SANS_Futura_Std_Bold_B_11">Evasion Countermeasures</samp></h3>&#13;
<p class="TNI1">As mentioned earlier, there’s a cat-and-mouse game between malware authors and malware researchers: authors invent a novel technique for detecting or bypassing analyst tools and sandboxes, and analysts and defensive-security researchers adapt. A great example of this is how far automated-analysis sandboxes have come. Many modern sandboxes have implemented countermeasures for the detection and evasion tactics mentioned throughout the past few chapters.</p>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_147" aria-label="147"/>Sandboxes can alert malware analysts to detection and evasion attempts, providing a window into the malware internals and enabling the analysts to respond appropriately. You can manually circumvent many such techniques by attaching the process to a debugger, setting breakpoints on interesting function calls, and modifying the malware’s code in the debugger itself or in a disassembler. These function calls can be <samp class="SANS_TheSansMonoCd_W5Regular_11">nop</samp>’ed out, jumped over, or modified (by manipulating the function parameters or return values, as <span class="Xref"><a href="chapter3.xhtml">Chapter 3</a></span> explained). Finally, many of the techniques can be circumvented by properly configuring your VM and hypervisor. I’ll discuss how to do so in <span class="Xref"><a href="appendix-A.xhtml">Appendix A</a></span>.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec25">&#13;
&#13;
<h3 class="H1" id="sec25"><span id="h-126"/><samp class="SANS_Futura_Std_Bold_B_11">Summary</samp></h3>&#13;
<p class="TNI1">This chapter gave you an overview of the methods that malware might use to evade sandboxes, VM environments, and analysis tooling when it detects that it’s being monitored. In <span class="Xref"><a href="part3.xhtml">Part III</a></span>, you’ll build on some of this knowledge as we begin to explore how malware uses anti-reversing techniques to interfere with disassemblers, detect and evade dynamic code analysis tools like debuggers, and misdirect malware analysts.</p>&#13;
</section>&#13;
</section>&#13;
</body></html>