- en: '**9**'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**VISUALIZING MALWARE TRENDS**'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/common01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Sometimes the best way to analyze malware collections is to visualize them.
    Visualizing security data allows us to quickly recognize trends in malware and
    within the threat landscape at large. These visualizations are often far more
    intuitive than nonvisual statistics, and they can help communicate insights to
    diverse audiences. For example, in this chapter, you see how visualization can
    help us identify the types of malware prevalent in a dataset, the trends within
    malware datasets (the emergence of ransomware as a trend in 2016, for example),
    and the relative efficacy of commercial antivirus systems at detecting malware.
  prefs: []
  type: TYPE_NORMAL
- en: Working through these examples, you come away understanding how to create your
    own visualizations that can lead to valuable insights by using the Python data
    analysis package `pandas`, as well as the Python data visualization packages `seaborn`
    and `matplotlib`. The `pandas` package is used mostly for loading and manipulating
    data and doesn’t have much to do with data visualization itself, but it’s very
    useful for preparing data for visualization.
  prefs: []
  type: TYPE_NORMAL
- en: '**Why Visualizing Malware Data Is Important**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To see how visualizing malware data can be helpful, let’s go through two examples.
    The first visualization addresses the following question: is the antivirus industry’s
    ability to detect ransomware improving? The second visualization asks which malware
    types have trended over the period of a year. Let’s look at the first example
    shown in [Figure 9-1](ch09.xhtml#ch09fig1).'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f0156-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 9-1: Visualization of ransomware detections over time*'
  prefs: []
  type: TYPE_NORMAL
- en: I created this ransomware visualization using data collected from thousands
    of ransomware malware samples. This data contains the results of running 57 separate
    antivirus engines against each file. Each circle represents a malware sample.
    The y-axis represents how many detections, or positives, each malware sample received
    from the antivirus engines when it was scanned. Keep in mind that while this y-axis
    stops at 60, the maximum count for a given scan is 57, the total number of scanners.
    The x-axis represents when each malware sample was first seen on the malware analysis
    site *[VirusTotal.com](http://VirusTotal.com)* and scanned.
  prefs: []
  type: TYPE_NORMAL
- en: In this plot, we can see the antivirus community’s ability to detect these malicious
    files started off relatively strong in June 2016, dipped around July 2016, and
    then steadily rose over the rest of the year. By the end of 2016, ransomware files
    were still missed by an average of about 25 percent of antivirus engines, so we
    can conclude that the security community remained somewhat weak at detecting these
    files during this time.
  prefs: []
  type: TYPE_NORMAL
- en: To extend this investigation, you could create a visualization that shows *which*
    antivirus engines are detecting ransomware and at what rate, and how they are
    improving over time. Or you could look at some other category of malware (for
    example, Trojan horses). Such plots are useful in deciding which antivirus engines
    to purchase, or deciding which kinds of malware you might want to design custom
    detection solutions for—perhaps to supplement a commercial antivirus detection
    system (for more on building custom detection systems, see [Chapter 8](ch08.xhtml#ch08)).
  prefs: []
  type: TYPE_NORMAL
- en: Now let’s look at [Figure 9-2](ch09.xhtml#ch09fig2), which is another sample
    visualization, created using the same dataset used for [Figure 9-1](ch09.xhtml#ch09fig1).
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f0157-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 9-2: Visualization of per-family malware detections over time*'
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 9-2](ch09.xhtml#ch09fig2) shows the top 20 most common malware families
    and how frequently they occurred relative to one another over a 150-day period.
    The plot reveals some key insights: whereas the most popular malware family, Allaple.A,
    occurred consistently over the 150-day span, other malware families, like Nemucod.FG,
    were prevalent for shorter spans of time and then went silent. A plot like this,
    generated using malware detected on your own workplace’s network, can reveal helpful
    trends showing what types of malware are involved in attacks against your organization
    over time. Without the creation of a comparison figure such as this one, understanding
    and comparing the relative peaks and volumes of these malware types over time
    would be difficult and time consuming.'
  prefs: []
  type: TYPE_NORMAL
- en: These two examples show how useful malware visualization can be. The rest of
    this chapter shows how to create your own visualizations. We start by discussing
    the sample dataset used in this chapter and then we use the `pandas` package to
    analyze the data. Finally, we use the `matplotlib` and `seaborn` packages to visualize
    the data.
  prefs: []
  type: TYPE_NORMAL
- en: '**Understanding Our Malware Dataset**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The dataset we use contains data describing 37,000 unique malware binaries
    collected by VirusTotal, a malware detection aggregation service. Each binary
    is labeled with four fields: the number of antivirus engines (out of 57) that
    flagged the binary as malicious (I call this the number of *positives* associated
    with each sample), the size of each binary, the binary’s *type* (bitcoin miner,
    keylogger, ransomware, trojan, or worm), and the date on which the binary was
    first seen. We’ll see that even with this fairly limited amount of metadata for
    each binary, we can analyze and visualize the data in ways that reveal important
    insights into the dataset.'
  prefs: []
  type: TYPE_NORMAL
- en: '***Loading Data into pandas***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The popular Python data analysis library `pandas` makes it easy to load data
    into analysis objects called `DataFrame`s, and then provides methods to slice,
    transform, and analyze that repackaged data. We use `pandas` to load and analyze
    our data and prep it for easy visualization. Let’s use [Listing 9-1](ch09.xhtml#ch09list1)
    to define and load some sample data into the Python interpreter.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 9-1: Loading data into* pandas *directly*'
  prefs: []
  type: TYPE_NORMAL
- en: Here we define some data, which we call `example_data`, as a list of Python
    dictionaries ➊. Once we have created this list of `dicts`, we pass it to the `DataFrame`
    constructor ➋ to get the corresponding `pandas` `DataFrame`. Each of these `dicts`
    becomes a row in the resulting `DataFrame`. The keys in the `dicts` (`column1`
    and `column2`) become columns. This is one way to load data into `pandas` directly.
  prefs: []
  type: TYPE_NORMAL
- en: You can also load data from external CSV files. Let’s use the code in [Listing
    9-2](ch09.xhtml#ch09list2) to load this chapter’s dataset (available on the virtual
    machine or in the data and code archive that accompany this book).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 9-2: Loading data into* pandas *from an external CSV file*'
  prefs: []
  type: TYPE_NORMAL
- en: 'When you import *malware_data.csv*, the resulting `malware` object should look
    something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'We now have a `pandas` `DataFrame` composed of our malware dataset. It has
    four columns: `positives` (the number of antivirus detections out of 57 antivirus
    engines for that sample), `size` (the number of bytes that malware binary takes
    up on disk), `type` (the type of malware, such as Trojan horse, worm, and so on),
    and `fs_bucket` (the date on which this malware was first seen).'
  prefs: []
  type: TYPE_NORMAL
- en: '***Working with a pandas DataFrame***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Now that we have our data in a `pandas` `DataFrame`, let’s look at how to access
    and manipulate it by calling the `describe()` method, as shown in [Listing 9-3](ch09.xhtml#ch09list3).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 9-3: Calling the* describe() *method*'
  prefs: []
  type: TYPE_NORMAL
- en: As shown in [Listing 9-3](ch09.xhtml#ch09list3), calling the `describe()` method
    shows some useful statistics about our `DataFrame`. The first line, `count`, counts
    the total number of non-null `positives` rows, and the total number of non-null
    rows. The second line gives the `mean`, or average number of positives per sample,
    and the mean size of the malware samples. Next comes the standard deviation for
    both `positives` and `size`, and the minimum value of each column in all the samples
    in the dataset. Finally, we see percentile values for each of the columns and
    the maximum value for the columns.
  prefs: []
  type: TYPE_NORMAL
- en: Suppose we’d like to retrieve the data for one of the columns in the malware
    `DataFrame`, such as the `positives` column (to view the average number of detections
    each file has, for example, or plot a histogram showing the distribution of positives
    over the dataset). To do this, we simply write `malware['positives']`, which returns
    the `positives` column as a list of numbers, as shown in [Listing 9-4](ch09.xhtml#ch09list4).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 9-4: Returning the* positives *column*'
  prefs: []
  type: TYPE_NORMAL
- en: After retrieving a column, we can compute statistics on it directly. For example,
    `malware['positives'].mean()` computes the mean of the column, `malware['positives'].max()`
    computes the maximum value, `malware['positives'].min()` computes the minimum
    value, and `malware['positives'].std()` computes the standard deviation. [Listing
    9-5](ch09.xhtml#ch09list5) shows examples of each.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 9-5: Calculating the mean, maximum, and minimum values and the standard
    deviation*'
  prefs: []
  type: TYPE_NORMAL
- en: We can also slice and dice the data to do more detailed analysis. For example,
    [Listing 9-6](ch09.xhtml#ch09list6) computes the mean positives for the trojan,
    bitcoin, and worm types of malware.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 9-6: Calculating the average detection rates of different malwares*'
  prefs: []
  type: TYPE_NORMAL
- en: 'We first select the rows of the `DataFrame` where `type` is set to `trojan`
    using the following notation: `malware[malware[''type''] == ''trojan'']`. To select
    the `positives` column of the resulting data and compute the mean, we extend this
    expression as follows: `malware[malware[''type''] == ''trojan''][''positives''].mean()`.
    [Listing 9-6](ch09.xhtml#ch09list6) yields an interesting result, which is that
    worms get detected more frequently than bitcoin mining and Trojan horse malware.
    Because 49.9 > 35.8 and 33.4, on average, malicious `worm` samples (49.9) are
    detected by more vendors than malicious `bitcoin` and `trojan` samples (35.8,
    33.4).'
  prefs: []
  type: TYPE_NORMAL
- en: '***Filtering Data Using Conditions***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: We can select a subset of the data using other conditions as well. For example,
    we can use “greater than” and “less than” style conditions on numerical data like
    malware file size to filter the data, and then compute statistics on the resulting
    subsets. This can be useful if we’re interested in finding out whether the effectiveness
    of the antivirus engines is related to file size. We can check this using the
    code in [Listing 9-7](ch09.xhtml#ch09list7).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 9-7: Filtering the results by malware file size*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Take the first line in the preceding code: first, we subset our `DataFrame`
    by only samples that have a size over one million (`malware[malware[''size'']
    > 1000000]`). Then we grab the `positives` column and calculate the mean (`[''positives''].mean()`),
    which is about 33.5\. As we do this for higher and higher file sizes, we see that
    the average number of detections for each group goes down. This means we’ve discovered
    that there is indeed a relationship between malware file size and the average
    number of antivirus engines that detect those malware samples, which is interesting
    and merits further investigation. We explore this visually next by using `matplotlib`
    and `seaborn`.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Using matplotlib to Visualize Data**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The go-to library for Python data visualization is `matplotlib`; in fact, most
    other Python visualization libraries are essentially convenience wrappers around
    `matplotlib`. It’s easy to use `matplotlib` with `pandas`: we use `pandas` to
    get, slice, and dice the data we want to plot, and we use `matplotlib` to plot
    it. The most useful `matplotlib` function for our purposes is the `plot` function.
    [Figure 9-3](ch09.xhtml#ch09fig3) shows what the `plot` function can do.'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f0162-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 9-3: A plot of malware samples’ sizes and the number of antivirus detections*'
  prefs: []
  type: TYPE_NORMAL
- en: Here, I plot the `positives` and `size` attributes of our malware dataset. An
    interesting result emerges, as foreshadowed by our discussion of `pandas` in the
    previous section. It shows that small files and very large files are rarely detected
    by most of the 57 antivirus engines that scanned these files. Files of middling
    size (around 10^(4.5)–10⁷) are detected by most engines, however. This may be
    because small files don’t contain enough information to allow engines to determine
    they are malicious, and big files are too slow to scan, causing many antivirus
    systems to punt on scanning them at all.
  prefs: []
  type: TYPE_NORMAL
- en: '***Plotting the Relationship Between Malware Size and Vendor Detections***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Let’s walk through how to make the plot shown in [Figure 9-3](ch09.xhtml#ch09fig3)
    by using the code in [Listing 9-8](ch09.xhtml#ch09list8).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 9-8: Visualizing data using the* plot() *function*'
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, it doesn’t take much code to render this plot. Let’s walk through
    what each line does. First, we import ➊ the necessary libraries, including `pandas`
    and the `matplotlib` library’s `pyplot` module. Then we call the `read_csv` function
    ➋, which, as you learned earlier, loads our malware dataset into a `pandas DataFrame`.
  prefs: []
  type: TYPE_NORMAL
- en: Next we call the `plot()` function. The first argument to the function is the
    malware `size` data ➌, and the next argument is the malware `positives` data ➍,
    or the number of positive detections for each malware sample. These arguments
    define the data that `matplotlib` will plot, with the first argument representing
    the data to be shown on the x-axis and the second representing the data to be
    shown on the y-axis. The next argument, `'bo'` ➎, tells `matplotlib` what color
    and shape to use to represent the data. Finally, we set `alpha`, or the transparency
    of the circles, to `0.1` ➏, so we can see how dense the data is within different
    regions of the plot, even when the circles completely overlap each other.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*The* b *in* `bo` *stands for* blue*, and the* o *stands for* circle*, meaning
    that we’re telling* matplotlib *to plot blue circles to represent our data. Other
    colors you can try are green (*g*), red (*r*), cyan (*c*), magenta (*m*), yellow
    (*y*), black (*k*), and white (*w*). Other shapes you can try are a point (*.*),
    a single pixel per data point (*,*), a square (*s*), and a pentagon (*p*). For
    complete details, see the* matplotlib *documentation at* [http://matplotlib.org](http://matplotlib.org).'
  prefs: []
  type: TYPE_NORMAL
- en: After we call the `plot()` function, we set the scale of the x-axis to be logarithmic
    ➐. This means that we’ll be viewing the malware size data in terms of powers of
    10, making it easier to see the relationships between very small and very large
    files.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we’ve plotted our data, we label our axes and title our plot. The x-axis
    represents the size of the malware file `("File size in bytes (log` `base-10)``")`,
    and the y-axis represents the number of detections `("Number of detections")`.
    Because there are 57 antivirus engines we’re analyzing, we set the y-axis scale
    to the range 0 to 57 at ➑. Finally, we call the `show()` function ➒ to display
    the plot. We could replace this call with `pyplot.savefig("myplot.png")` if we
    wanted to save the plot as an image instead.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we’ve gone through an initial example, let’s do another.
  prefs: []
  type: TYPE_NORMAL
- en: '***Plotting Ransomware Detection Rates***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: This time, let’s try reproducing [Figure 9-1](ch09.xhtml#ch09fig1), the ransomware
    detection plot I showed at the beginning of this chapter. [Listing 9-9](ch09.xhtml#ch09list9)
    presents the entire code that plots our ransomware detections over time.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 9-9: Plotting ransomware detection rates over time*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Some of the code in [Listing 9-9](ch09.xhtml#ch09list9) should be familiar
    from what I’ve explained thus far, and some won’t be. Let’s walk through the code,
    line by line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: The helpful Python package `dateutil` enables you to easily parse dates from
    many different formats. We import `dateutil` because we’ll be parsing dates so
    we can visualize them.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: We also import the `matplotlib` library’s `pyplot` module as well as `pandas`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: These lines read in our dataset and create a filtered dataset called `ransomware`
    that contains only ransomware samples, because that’s the type of data we’re interested
    in plotting here.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'These five lines of code mirror the code in [Listing 9-8](ch09.xhtml#ch09list8):
    they plot the data, title the plot, label its x- and y-axes, and then render everything
    to the screen (see [Figure 9-4](ch09.xhtml#ch09fig4)). Again, if we wanted to
    save this plot to disk, we could replace the `pyplot.show()` call with `pyplot.savefig("myplot.png")`.'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f0165-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 9-4: Visualization of ransomware detections over time*'
  prefs: []
  type: TYPE_NORMAL
- en: Let’s try one more plot using the `plot()` function.
  prefs: []
  type: TYPE_NORMAL
- en: '***Plotting Ransomware and Worm Detection Rates***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: This time, instead of just plotting ransomware detections over time, let’s also
    plot worm detections in the same graph. What becomes clear in [Figure 9-5](ch09.xhtml#ch09fig5)
    is that the antivirus industry is better at detecting worms (an older malware
    trend) than ransomware (a newer malware trend).
  prefs: []
  type: TYPE_NORMAL
- en: In this plot, we see how many antivirus engines detected malware samples (y-axis)
    over time (x-axis). Each red dot represents a `type="ransomware"` malware sample,
    whereas each blue dot represents a `type="worm"` sample. We can see that on average,
    more engines detect worm samples than ransomware samples. However, the number
    of engines detecting both samples has been trending slowly up over time.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f0166-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 9-5: Visualization of ransomware and worm malware detections over time*'
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 9-10](ch09.xhtml#ch09list10) shows the code for making this plot.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 9-10: Plotting ransomware and worm detection rates over time*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s walk through the code by looking at the first part of [Listing 9-10](ch09.xhtml#ch09list10):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'The code is similar to the previous example. The difference thus far is that
    we create the `worm` filtered version of our data ➊ using the same method with
    which we create the `ransomware` filtered data. Now let’s take a look at the rest
    of the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'The main difference between this code and [Listing 9-9](ch09.xhtml#ch09list9)
    is that we call the `plot()` function twice: once for the ransomware data using
    the `ro` selector ➊ to create red circles, and once more on the worm data using
    the `bo` selector ➋ to create blue circles for the worm data. Note that if we
    wanted to plot a third dataset, we could do this too. Also, unlike [Listing 9-9](ch09.xhtml#ch09list9),
    here, at ➌, we create a legend for our figure showing that the blue marks stand
    for worm malware and the red marks stand for ransomware. The parameter `framealpha`
    determines how translucent the background of the legend is (by setting it to 1,
    we make it completely opaque), and the parameter `markerscale` scales the size
    of the markers in the legend (in this case, by a factor of three).'
  prefs: []
  type: TYPE_NORMAL
- en: In this section, you’ve learned how to make some simple plots in `matplotlib`.
    However, let’s be honest—they’re not gorgeous. In the next section, we’re going
    to use another plotting library that should allow us to give our plots a more
    professional look, and help us implement more complex visualizations quickly.
  prefs: []
  type: TYPE_NORMAL
- en: '**Using seaborn to Visualize Data**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Now that we’ve discussed `pandas` and `matplotlib`, let’s move on to `seaborn`,
    which is a visualization library actually built on top of `matplotlib` but wrapped
    up in a slicker container. It includes built-in themes to style our graphics as
    well as premade higher-level functions that save time in performing more complicated
    analyses. These features make it simple and easy to produce sophisticated, beautiful
    plots.
  prefs: []
  type: TYPE_NORMAL
- en: To explore `seaborn`, let’s start by making a bar chart showing how many examples
    of each malware type we have in our dataset (see [Figure 9-6](ch09.xhtml#ch09fig6)).
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f0168-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 9-6: Bar chart plot of the different kinds of malware in this chapter’s
    dataset*'
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 9-11](ch09.xhtml#ch09list11) shows the code to make this plot.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 9-11: Creating a bar chart of malware counts by type*'
  prefs: []
  type: TYPE_NORMAL
- en: In this code, we first read in our data via `pandas.read_csv` ➊ and then use
    `seaborn`’s `countplot` function to create a barplot of the `type` column in our
    `DataFrame` ➋. Finally, we make the plot appear by calling `pyplot`’s `show()`
    method at ➌. Recall that `seaborn` wraps `matplotlib`, which means we need to
    ask `matplotlib` to display our `seaborn` figures. Now let’s move on to a more
    complex sample plot.
  prefs: []
  type: TYPE_NORMAL
- en: '***Plotting the Distribution of Antivirus Detections***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The premise for the following plot is as follows: suppose we want to understand
    the distribution (frequency) of antivirus detections across malware samples in
    our dataset to understand what percentage of malware is missed by most antivirus
    engines, and what percentage is detected by most engines. This information gives
    us a view of the efficacy of the commercial antivirus industry. We can do this
    by plotting a bar chart (a histogram) showing, for each number of detections,
    the proportion of malware samples that had that number of detections, as shown
    in [Figure 9-7](ch09.xhtml#ch09fig7).'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f0169-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 9-7: Visualization of distribution of antivirus detections (positives)*'
  prefs: []
  type: TYPE_NORMAL
- en: The x-axis of this figure represents categories of malware samples, sorted by
    how many out of 57 total antivirus engines detected them. If a sample was detected
    as malicious by 50 of 57 engines, it is placed at 50, if it was only detected
    by 10 engines out of 57, it goes in the 10 category. The height of each bar is
    proportional to how many total samples ended up in that category.
  prefs: []
  type: TYPE_NORMAL
- en: 'The plot makes it clear that many malware samples are detected by most of our
    57 antivirus engines (shown by the big bump in frequencies in the upper-rightmost
    region of the plot) but also that a substantial minority of samples are detected
    by a small number of engines (shown in the leftmost region of the plot). We don’t
    show samples that were detected by fewer than five engines because of the methodology
    I used to construct this dataset: I define malware as samples that five or more
    antivirus engines detect. This plotted result, with substantial numbers of samples
    receiving just 5–30 detections, indicates that there is still significant disagreement
    between engines in malware detection. A sample that was detected as malware by
    10 out of 57 engines either indicates that 47 engines failed to detect it, or
    that 10 made a mistake and issued a false positive on a benign file. The latter
    possibility is very unlikely, because antivirus vendors’ products have very low
    false-positive rates: it’s much more likely that most engines missed these samples.'
  prefs: []
  type: TYPE_NORMAL
- en: Making this plot requires just a few lines of plotting code, as shown in [Listing
    9-12](ch09.xhtml#ch09list12).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 9-12: Plotting distribution of positives*'
  prefs: []
  type: TYPE_NORMAL
- en: The `seaborn` package has a built-in function to create distribution plots (histograms),
    and so all we’ve done is pass the `distplot` function the data we wanted to display,
    which is `malware['positives']` ➊. Then we use the axis object returned by `seaborn`
    to configure the plot title, x-axis label, and y-axis label to describe our plot
    ➋.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let’s try a `seaborn` plot with two variables: the number of positive detections
    for malware (files with five or more detections) and their file sizes. We created
    this plot before with `matplotlib` in [Figure 9-3](ch09.xhtml#ch09fig3), but we
    can achieve a more attractive and informative result using `seaborn`’s `jointplot`
    function. The resulting plot, shown in [Figure 9-8](ch09.xhtml#ch09fig8), is richly
    informative but takes a bit of effort to understand at first, so let’s walk through
    it.'
  prefs: []
  type: TYPE_NORMAL
- en: This plot is similar to the histogram we made in [Figure 9-7](ch09.xhtml#ch09fig7),
    but instead of displaying the distribution of a single variable via bar heights,
    this plot shows the distributions of *two* variables (the size of a malware file,
    on the x-axis, and the number of detections, on the y-axis) via color intensity.
    The darker the region, the more data is in that region. For example, we can see
    that files most commonly have a size of about 10^(5.5) and a positives value of
    about 53\. The subplots on the top and right of the main plots show a smoothed
    version of the frequencies of the size and detections data, which reveal the distribution
    of detections (as we saw in the previous plot) and file sizes.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f0171-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 9-8: Visualization of the distribution of malware file sizes versus
    positive detections*'
  prefs: []
  type: TYPE_NORMAL
- en: The center plot is the most interesting, because it shows the relationship between
    size and positives. Instead of showing individual data points, like in [Figure
    9-3](ch09.xhtml#ch09fig3) with `matplotlib`, it shows the overall trend in a way
    that’s much clearer. This shows that very large malware files (size 10⁶ and greater)
    are less commonly detected by antivirus engines, which tells us we might want
    to custom-build a solution that specializes in detecting such malware.
  prefs: []
  type: TYPE_NORMAL
- en: Creating this plot just requires one plotting call to `seaborn`, as shown in
    [Listing 9-13](ch09.xhtml#ch09list13).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 9-13: Plotting the distribution of malware file sizes vs. positive
    detections*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here, we use `seaborn`’s `jointplot` function to create a joint distribution
    plot of the `positives` and `size` columns in our `DataFrame` ➊. Also, somewhat
    confusingly, for `seaborn`’s `jointplot` function, we have to call a different
    function than in [Listing 9-11](ch09.xhtml#ch09list11) to label our axes: the
    `set_axis_labels()` function ➋, whose first argument is the x-axis label and whose
    second argument is the y-axis label.'
  prefs: []
  type: TYPE_NORMAL
- en: '***Creating a Violin Plot***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The last plot type we explore in this chapter is the `seaborn` violin plot.
    This plot allows us to elegantly explore the distribution of a given variable
    across several malware types. For example, suppose we’re interested in seeing
    the distribution of file sizes per malware type in our dataset. In this case,
    we can create a plot like [Figure 9-9](ch09.xhtml#ch09fig9).
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f0172-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 9-9: Visualization of file sizes by malware type*'
  prefs: []
  type: TYPE_NORMAL
- en: On the y-axis of this plot are file sizes, represented as powers of 10\. On
    the x-axis we enumerate each malware type. As you can see, the thickness of the
    bars representing each file type varies at different size levels, which show how
    much of the data for that malware type is of that size. For example, you can see
    that there’s a substantial number of very large ransomware files, and that worms
    tend to have smaller file sizes—probably because worms aim to spread rapidly across
    a network, and worm authors thus tend to minimize their file sizes. Knowing these
    patterns could potentially help us to classify unknown files better (a larger
    file being more likely to be ransomware and less likely to be a worm), or teach
    us what file sizes we should focus on in a defensive tool targeted at a specific
    type of malware.
  prefs: []
  type: TYPE_NORMAL
- en: Making the violin plot takes one plotting call, as shown in [Listing 9-14](ch09.xhtml#ch09list14).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 9-14: Creating a violin plot*'
  prefs: []
  type: TYPE_NORMAL
- en: In [Listing 9-14](ch09.xhtml#ch09list14), first we create the violin plot ➊.
    Next we tell `seaborn` to set the axis labels and title and to set the y-axis
    to log-scale ➋. Finally, we make the plot appear ➌. We can also make an analogous
    plot showing the number of positives for each malware type, as shown in [Figure
    9-10](ch09.xhtml#ch09fig10).
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f0173-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 9-10: Visualization of the number of antivirus positives (detections)
    per malware type*'
  prefs: []
  type: TYPE_NORMAL
- en: The only difference between [Figure 9-9](ch09.xhtml#ch09fig9) and [Figure 9-10](ch09.xhtml#ch09fig10)
    is that instead of looking at file size on the y-axis, we’re looking at the number
    of positives each file received. The results show some interesting trends. For
    example, ransomware is almost always detected by more than 30 scanners. The bitcoin,
    trojan, and keylogger malware types, in contrast, are detected by less than 30
    scanners a substantial portion of the time, meaning more of these types are slipping
    past the security industry’s defenses (folks who don’t have the scanners that
    detect these files installed are likely getting infected by these samples). [Listing
    9-15](ch09.xhtml#ch09list15) shows how to create the plot shown in [Figure 9-10](ch09.xhtml#ch09fig10).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 9-15: Visualizing antivirus detections per malware type*'
  prefs: []
  type: TYPE_NORMAL
- en: The only differences in this code and the previous are that we pass the `violinplot`
    function different data (`malware['positives``']` instead of `malware['size']`),
    we label the axes differently, we set the title differently, and we omit setting
    the y-axis scale to log-10.
  prefs: []
  type: TYPE_NORMAL
- en: '**Summary**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how visualization of malware data allows you to
    get macroscopic insights into trending threats and the efficacy of security tools.
    You used `pandas`, `matplotlib`, and `seaborn` to create your own visualizations
    and gain insight into sample datasets.
  prefs: []
  type: TYPE_NORMAL
- en: You also learned how to use methods like `describe()` in `pandas` to show useful
    statistics and how to extract subsets of your dataset. You then used these subsets
    of data to create your own visualizations to assess improvements in antivirus
    detections, analyze trending malware types, and answer other broader questions.
  prefs: []
  type: TYPE_NORMAL
- en: These are powerful tools that transform the security data you have into actionable
    intelligence that can inform the development of new tools and techniques. I hope
    you’ll learn more about data visualizations and incorporate them into your malware
    and security analysis workflow.
  prefs: []
  type: TYPE_NORMAL
