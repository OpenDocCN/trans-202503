<html><head></head><body>
<h2 class="h2"><span epub:type="pagebreak" id="page_145"/><span class="big">6</span><br/>DATA</h2>&#13;
<div class="image1"><img alt="Image" src="../images/common01.jpg"/></div>&#13;
<p class="noindent">This chapter is all about data: reading it, writing it, visualizing it, and analyzing it. We’ll begin with a discussion of input and output using Racket ports (an essential tool we’ll use throughout this chapter).</p>&#13;
<h3 class="h3" id="ch00lev1sec_34">I/O, I/O, It’s Off to Work We Go</h3>&#13;
<p class="noindent">Data is transferred in Racket via ports: data flows into an input port and out of output ports. The general process of transferring data to or from an external source (such a text file or database server) is referred to as <em>I/O</em>. Let’s look at some examples of ports.</p>&#13;
<h4 class="h4" id="ch00lev2sec_48"><strong><em>File I/O Ports</em></strong></h4>&#13;
<p class="noindent">Ports can be used for writing and reading data to a file, as the following dialog illustrates.</p>&#13;
<pre>&gt; ; Output some stuff&#13;
<span class="codestrong1">(define out-port (open-output-file "data/SomeStuff.txt"))&#13;
(display "some stuff" out-port)&#13;
(close-output-port out-port)</span>&#13;
&#13;
<span epub:type="pagebreak" id="page_146"/>&gt; ; Read it back in&#13;
<span class="codestrong1">(define in-port (open-input-file "data/SomeStuff.txt"))&#13;
(read-line in-port)&#13;
(close-input-port in-port)</span>&#13;
"some stuff"</pre>&#13;
<p class="indent">If we attempt to open a port to a file that already exists, we get an error.</p>&#13;
<pre>&gt; <span class="codestrong1">(define more-out (open-output-file "data/SomeStuff.txt"))</span>&#13;
open-output-file: file exists&#13;
  path: ...\data\SomeStuff.txt</pre>&#13;
<p class="indent">The default mode of operation for <span class="literal">open-output-file</span> is to create a new file. Since we can’t create a new file twice, we need to declare how we intend to handle an existing file. This is managed via the <span class="literal">#:exists</span> keyword: we can append to the existing file by specifying ’<span class="literal">append</span> as its value, blow away the file and create a new file with ’<span class="literal">replace</span>, or keep the file but delete the contents with ’<span class="literal">truncate</span> (the default for value for <span class="literal">#:exists</span> is ’<span class="literal">error</span>, which means to generate an error if the file exists). We exercise a few of these options below.</p>&#13;
<pre>&gt; <span class="codestrong1">(define out-port (open-output-file "data/SomeStuff.txt" #:exists 'append))&#13;
  (display "some more stuff\n" out-port)&#13;
  (close-output-port out-port)</span>&#13;
&#13;
&gt; <span class="codestrong1">(define in-port (open-input-file "data/SomeStuff.txt"))</span>&#13;
&gt; <span class="codestrong1">(read-line in-port)</span>&#13;
"some stuff"&#13;
&#13;
&gt; <span class="codestrong1">(read-line in-port)</span>&#13;
"some more stuff"&#13;
&gt; <span class="codestrong1">(close-input-port in-port)</span>&#13;
&#13;
&gt; <span class="codestrong1">(define out-port (open-output-file "data/SomeStuff.txt" #:exists 'truncate))&#13;
  (display "some new stuff\n" out-port)&#13;
  (close-output-port out-port)</span>&#13;
&#13;
&gt; <span class="codestrong1">(define in-port (open-input-file "data/SomeStuff.txt"))</span>&#13;
&gt; <span class="codestrong1">(read-line in-port)</span>&#13;
"some new stuff"&#13;
&gt; <span class="codestrong1">(read-line in-port)</span>&#13;
#&lt;eof&gt;&#13;
&gt; <span class="codestrong1">(close-input-port in-port)</span></pre>&#13;
<p class="indent">Once the end of the file is reached, <span class="literal">read-line</span> returns an end of file object; this prints as <span class="literal">#&lt;eof&gt;</span> but is defined as <span class="literal">eof</span> in Racket. This value can be tested for with the <span class="literal">eof-object?</span> predicate.</p>&#13;
<pre><span epub:type="pagebreak" id="page_147"/>&gt; <span class="codestrong1">eof</span>&#13;
#&lt;eof&gt;&#13;
&#13;
&gt; <span class="codestrong1">(eof-object? eof)</span>&#13;
#t</pre>&#13;
<p class="indent">Every time a port is opened, you must remember to close it when the data transfer is complete. The closing can be performed automatically by using either <span class="literal">call-with-output-file</span> or <span class="literal">call-with-input-file</span> (depending on which way the data is flowing). These procedures work by supplying them with a function that does the actual data transfer. Here are some examples using this approach.</p>&#13;
<pre>&gt; <span class="codestrong1">(call-with-output-file "data/SomeData.txt"&#13;
    #:exists 'truncate&#13;
    (λ (out-port)&#13;
      (display "Data line1\n" out-port)&#13;
      (display "Data line2\n" out-port)&#13;
      (display "Data line3\n" out-port)&#13;
      (display "Data line4\n" out-port)))</span>&#13;
&#13;
&gt; <span class="codestrong1">(call-with-input-file "data/SomeData.txt"&#13;
    (λ (in-port)&#13;
      (let loop()&#13;
        (let ([data (read-line in-port)])&#13;
          (unless (eof-object? data)&#13;
            (displayln data)&#13;
            (loop))))))</span>&#13;
Data line1&#13;
Data line2&#13;
Data line3&#13;
Data line4</pre>&#13;
<p class="indent">We’ll explore file ports in greater detail a bit later in the chapter.</p>&#13;
<h4 class="h4" id="ch00lev2sec_49"><strong><em>String Ports</em></strong></h4>&#13;
<p class="noindent">Ports can be opened against strings. This can be handy when trying to build a string where different components of the string will be appended at various times within a procedure. We’ll put string ports to good use in <a href="ch10.xhtml">Chapter 10</a> when we build string representations of algebraic expressions. Some simple examples are provided here:</p>&#13;
<pre>&gt; <span class="codestrong1">(define str-port (open-output-string))</span>&#13;
&gt; <span class="codestrong1">(display "Hello "   str-port)&#13;
  (display "there, " str-port)&#13;
  (display "amigo!"   str-port)</span>&#13;
<span epub:type="pagebreak" id="page_148"/>&gt; <span class="codestrong1">(get-output-string str-port)</span>&#13;
"Hello there, amigo!"</pre>&#13;
<p class="indent">Unlike file ports, string ports don’t have to be explicitly closed.</p>&#13;
<h4 class="h4" id="ch00lev2sec_50"><strong><em>Computer-to-Computer Ports</em></strong></h4>&#13;
<p class="noindent">Ports can be set up to allow two computers to communicate with each other. This type of communication uses the TCP/IP protocol. To establish the connections, the first computer (called the <em>server</em>) establishes itself as a listener with the <span class="literal">tcp-listen</span> command. This command accepts an unsigned integer as a port number (this is a TCP/IP port number). Note that a Racket port is a different entity from the TCP port specified by the port number. The server then calls <span class="literal">tcp-accept</span>, which returns two values—an input port and an output port—to permit two-way communication between the computers. The following session illustrates setting up a server and the server waiting for a query from a client computer.</p>&#13;
<p class="noindentt"><strong>Computer 1</strong> – The Server</p>&#13;
<pre>&gt; <span class="codestrong1">(define comp1 (tcp-listen 999))&#13;
  (define-values (comp1-in comp1-out) (tcp-accept comp1))&#13;
  (read-line comp1-in)&#13;
  (displayln "Got it, bro!\n" comp1-out)&#13;
  (close-input-port comp1-in) &#13;
  (close-output-port comp1-out)</span>&#13;
 "Hello there!"</pre>&#13;
<p class="indent">The string <span class="literal">"Hello there!"</span> is sent from the client. This is the result of executing the line <span class="literal">(read-line comp1-in)</span>, after which the server responds with <span class="literal">"Got it, bro!"</span>.</p>&#13;
<p class="indent">The client establishes its communication link by a using <span class="literal">tcp-connect</span>. The <span class="literal">tcp-connect</span> command takes the server computer name and the port number established by the server as arguments. It then initiates the dialog by sending <span class="literal">(displayln "Hello there!\n" comp2-out)</span> over the output port and waiting for a response from the server with <span class="literal">(read-line comp2-in)</span>.</p>&#13;
<p class="noindentt"><strong>Computer 2</strong> – The Client</p>&#13;
<pre>&gt; <span class="codestrong1">(define-values (comp2-in comp2-out) (tcp-connect "Comp1Name" 999))&#13;
  (displayln "Hello there!\n" comp2-out)&#13;
  (flush-output comp2-out)&#13;
  (read-line comp2-in)&#13;
  (close-input-port comp2-in) &#13;
  (close-output-port comp2-out)</span>&#13;
"Got it, bro!"</pre>&#13;
<p class="indent">This is just a simple example; there are of course a number of nuances to setting up successful communication channels between computers. Consult the Racket Documentation for additional details.</p>&#13;
<h3 class="h3" id="ch00lev1sec_35"><span epub:type="pagebreak" id="page_149"/>Introduction to Security</h3>&#13;
<p class="noindent">Now that we’ve explored ports, let’s see how we can use them to enhance our security. No, not computer security. In this section, we’ll take a look at a type of security that virtually everyone is interested in: money. In particular we’ll be exploring securities such as stocks and bonds. The specific data we’re going to look at is price over time. There are a number of ways to look at prices: stock prices of individual corporations, average prices over an industry or group of institutions, or prices of index funds.</p>&#13;
<p class="indent"><a href="ch06.xhtml#ch6tab1">Table 6-1</a> lists the various entities we’ll be investigating. In the remainder of the chapter, we’ll refer to these entities as <em>assets</em>. The Symbol column indicates the stock market symbol that’s used to look up price information. Definitions for entries in the Type column are as follows:</p>&#13;
<div class="bq5">&#13;
<p class="noindent"><strong>Corp</strong> An individual corporation. Most of these should be reasonably familiar.</p>&#13;
<p class="noindent"><strong>Index</strong> A market index—just an indicator and not something you actually invest in. The Dow Jones Industrial Average is the weighted average consisting of 30 large publicly traded institutions. The S&amp;P 500 (Standard and Poor’s 500) is similar but consists of 500 large publicly traded institutions.</p>&#13;
<p class="noindent"><strong>Index Fund</strong> An index fund, unlike an index, <em>can</em> be invested in. An index fund is typically composed of some mix of stocks or bonds. The Vanguard Total Bond Market fund is composed of a mix of long-term and short-term and both corporate and government bonds. The idea of index funds is that investing in a range of institutions minimized risk since the poor performance of one investment will be mitigated when averaged in with the remaining investments.</p>&#13;
</div>&#13;
<p class="tabcap" id="ch6tab1"><strong>Table 6-1</strong>: A Selection of Securities</p>&#13;
<table class="table1">&#13;
<colgroup>&#13;
<col style="width:33%"/>&#13;
<col style="width:33%"/>&#13;
<col style="width:34%"/>&#13;
</colgroup>&#13;
<thead>&#13;
<tr>&#13;
<th class="table-h" style="vertical-align: top;"><p class="taba"><strong>Name</strong></p></th>&#13;
<th class="table-h" style="vertical-align: top;"><p class="taba"><strong>Symbol</strong></p></th>&#13;
<th class="table-h" style="vertical-align: top;"><p class="taba"><strong>Type</strong></p></th>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr>&#13;
<td class="table-b1" style="vertical-align: top;"><p class="taba">Amazon</p></td>&#13;
<td class="table-b1" style="vertical-align: top;"><p class="taba">AMZN</p></td>&#13;
<td class="table-b1" style="vertical-align: top;"><p class="taba">Corp</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="table-a" style="vertical-align: top;"><p class="taba">Apple</p></td>&#13;
<td class="table-a" style="vertical-align: top;"><p class="taba">AAPL</p></td>&#13;
<td class="table-a" style="vertical-align: top;"><p class="taba">Corp</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="table-b1" style="vertical-align: top;"><p class="taba">Bank of America</p></td>&#13;
<td class="table-b1" style="vertical-align: top;"><p class="taba">BAC</p></td>&#13;
<td class="table-b1" style="vertical-align: top;"><p class="taba">Corp</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="table-a" style="vertical-align: top;"><p class="taba">Dow Jones</p></td>&#13;
<td class="table-a" style="vertical-align: top;"><p class="taba">^DJI</p></td>&#13;
<td class="table-a" style="vertical-align: top;"><p class="taba">Index</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="table-b1" style="vertical-align: top;"><p class="taba">ExxonMobil</p></td>&#13;
<td class="table-b1" style="vertical-align: top;"><p class="taba">XOM</p></td>&#13;
<td class="table-b1" style="vertical-align: top;"><p class="taba">Corp</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="table-a" style="vertical-align: top;"><p class="taba">Ford</p></td>&#13;
<td class="table-a" style="vertical-align: top;"><p class="taba">F</p></td>&#13;
<td class="table-a" style="vertical-align: top;"><p class="taba">Corp</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="table-b1" style="vertical-align: top;"><p class="taba">Microsoft</p></td>&#13;
<td class="table-b1" style="vertical-align: top;"><p class="taba">MSFT</p></td>&#13;
<td class="table-b1" style="vertical-align: top;"><p class="taba">Corp</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="table-a" style="vertical-align: top;"><p class="taba">S&amp;P 500</p></td>&#13;
<td class="table-a" style="vertical-align: top;"><p class="taba">^GSPC</p></td>&#13;
<td class="table-a" style="vertical-align: top;"><p class="taba">Index</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="table-h1" style="vertical-align: top;"><p class="taba">Vanguard Total Bond Market</p></td>&#13;
<td class="table-h1" style="vertical-align: top;"><p class="taba">VBMFX</p></td>&#13;
<td class="table-h1" style="vertical-align: top;"><p class="taba">Index Fund</p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<p class="indent">The data we’re going to examine was downloaded from the Yahoo! Finance website. This data is in the form of <em>comma-separated value (CSV)</em> files. What this means is that each value in the file is separated by a comma, and each record occupies a single line. Here’s an example from a file containing the Dow Jones Industrial Average for the first few days of the year 2007 <span epub:type="pagebreak" id="page_150"/>(we’ve lopped off a few decimal places from the prices to keep the listing from extending off the page).</p>&#13;
<pre>Date,Open,High,Low,Close,Adj Close,Volume&#13;
2007-01-03,12459.540,12580.349,12404.820,12474.519,12474.519,327200000&#13;
2007-01-04,12473.160,12510.410,12403.860,12480.690,12480.690,259060000&#13;
2007-01-05,12480.049,12480.129,12365.410,12398.009,12398.009,235220000</pre>&#13;
<p class="indent">The first row gives a short description of each data value in the succeeding rows. <a href="ch06.xhtml#ch6tab2">Table 6-2</a> gives a more detailed description.</p>&#13;
<p class="tabcap" id="ch6tab2"><strong>Table 6-2</strong>: CSV File Format</p>&#13;
<table class="table1">&#13;
<colgroup>&#13;
<col style="width:40%"/>&#13;
<col style="width:60%"/>&#13;
</colgroup>&#13;
<thead>&#13;
<tr>&#13;
<th class="table-h" style="vertical-align: top;"><p class="taba"><strong>Value</strong></p></th>&#13;
<th class="table-h" style="vertical-align: top;"><p class="taba"><strong>Description</strong></p></th>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr>&#13;
<td class="table-b1" style="vertical-align: top;"><p class="taba">Date</p></td>&#13;
<td class="table-b1" style="vertical-align: top;"><p class="taba">Date of transactions (year-month-day)</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="table-a" style="vertical-align: top;"><p class="taba">Open</p></td>&#13;
<td class="table-a" style="vertical-align: top;"><p class="taba">Price when market opened</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="table-b1" style="vertical-align: top;"><p class="taba">High</p></td>&#13;
<td class="table-b1" style="vertical-align: top;"><p class="taba">Highest traded price for the day</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="table-a" style="vertical-align: top;"><p class="taba">Low</p></td>&#13;
<td class="table-a" style="vertical-align: top;"><p class="taba">Lowest traded price for the day</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="table-b1" style="vertical-align: top;"><p class="taba">Close</p></td>&#13;
<td class="table-b1" style="vertical-align: top;"><p class="taba">Price when the market closed</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="table-a" style="vertical-align: top;"><p class="taba">Adj Close</p></td>&#13;
<td class="table-a" style="vertical-align: top;"><p class="taba">Adjusted closing price</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="table-h1" style="vertical-align: top;"><p class="taba">Volume</p></td>&#13;
<td class="table-h1" style="vertical-align: top;"><p class="taba">Number of trades for the day</p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<p class="indent">The adjusted close reflects any adjustments based on dividends or stock splits (the term <em>split</em> means if you owned a single stock share selling for $100, you’d own two shares at $50 after the split).</p>&#13;
<h3 class="h3" id="ch00lev1sec_36">Getting Data into Racket</h3>&#13;
<p class="noindent">The first order of business is to get the CSV data into a form that will be useful within Racket. We’ll use a <span class="literal">hist</span> structure to contain the data for a single record from the CSV file. This struct has the following form.</p>&#13;
<pre>(struct hist (date open high low close adj-close vol)&#13;
  #:transparent)</pre>&#13;
<p class="noindent">The field names should need no explanation.</p>&#13;
<p class="indent">The following function will take a file port and return a <span class="literal">hist</span> structure populated with the data values from the current import record (the next unread line in the file) with each price entry converted to a numeric value.</p>&#13;
<pre>(define (import-record port)&#13;
  (let ([rec (read-line port)])&#13;
    (if (eof-object? rec)&#13;
        eof&#13;
     <span class="ent">➊</span> (match (string-split rec ",")&#13;
      <span class="ent">➋</span> [(list date open high low close adj-close vol)&#13;
       <span class="ent">➌</span> (hist date&#13;
                (string-&gt;number open)&#13;
                (string-&gt;number high)&#13;
                <span epub:type="pagebreak" id="page_151"/>(string-&gt;number low)&#13;
                (string-&gt;number close)&#13;
                (string-&gt;number adj-close)&#13;
                (string-&gt;number vol))]&#13;
       <span class="ent">➍</span> [_ (error "Failed to load record.")]))))</pre>&#13;
<p class="indent">Here we’ve taken the opportunity to exercise another of Racket’s hidden treasures, pattern matching. <em>Pattern matching</em> uses the <span class="literal">match</span> form <span class="ent">➊</span> included in the <em>racket/match</em> library (not to worry; this library is automatically included with the <em>racket</em> library).</p>&#13;
<p class="indent">A <span class="literal">match</span> expression looks a bit like a <span class="literal">cond</span> expression, but instead of having to use a complex Boolean expression, we simply provide the data structure we want to match against. It’s possible to use a number of different structures as patterns to match against, including literal values, but we’ll simply use a list for this exercise <span class="ent">➋</span>. The split <span class="literal">rec</span> values are bound to the identifiers <span class="literal">date</span>, <span class="literal">open</span>, and so on. If a match is found, then a <span class="literal">hist</span> structure is returned <span class="ent">➌</span>. A single underscore (<span class="literal">_</span>) serves as a wildcard that matches anything <span class="ent">➍</span> (for example if the number of values in the split list did not match the number of items in the binding list, an <span class="literal">error</span> exception would be raised). With this in place, the following code reads in a few values (in the following code segments, the reader should substitute their own data path where paths starting with <span class="literal">StockHistory/</span> are used):</p>&#13;
<pre>&gt; <span class="codestrong1">(define in-port &#13;
    (open-input-file "StockHistory/Daily/XOM.csv"))</span>&#13;
&gt; <span class="codestrong1">(import-record in-port)</span>&#13;
(hist "Date" #f #f #f #f #f #f)&#13;
&#13;
&gt; <span class="codestrong1">(import-record in-port)</span>&#13;
(hist "1980-01-02" 3.445313 3.453125 3.351563 3.367188 0.692578 6622400)&#13;
&#13;
&gt; <span class="codestrong1">(import-record in-port)</span>&#13;
(hist "1980-01-03" 3.320313 3.320313 3.25 3.28125 0.674902 7222400)&#13;
&#13;
&gt; <span class="codestrong1">(close-input-port in-port)</span></pre>&#13;
<p class="indent">The first <span class="literal">hist</span> structure produced contains false values because the header strings in the first line of the CSV file couldn’t be converted to numbers by <span class="literal">import-record</span>.</p>&#13;
<p class="indent">For display purposes, we often want to uniformly format the history records to display each value as a string right-aligned and with a certain precision. The following function performs this service:</p>&#13;
<pre>(define (format-rec rec width prec)&#13;
  (match rec&#13;
    [(hist date open high low close adj-close vol)&#13;
     (hist date&#13;
           (~r open #:min-width width  #:precision (list '= prec))&#13;
           (~r high #:min-width width  #:precision (list '= prec))&#13;
           <span epub:type="pagebreak" id="page_152"/>(~r low #:min-width width  #:precision (list '= prec))&#13;
           (~r close #:min-width width  #:precision (list '= prec))&#13;
           (~r adj-close #:min-width width  #:precision (list '= prec))&#13;
           (~r vol #:min-width 9 ))]))</pre>&#13;
<p class="indent">The <span class="literal">width</span> parameter specifies the overall width of each value, and the <span class="literal">prec</span> parameter specifies the precision. Applying this function to the first few rows of the ExxonMobil data results in the following:</p>&#13;
<pre>&gt; <span class="codestrong1">(define in-port &#13;
    (open-input-file "StockHistory/Daily/XOM.csv"))</span>&#13;
&gt; <span class="codestrong1">(import-record in-port)</span>&#13;
(hist "Date" #f #f #f #f #f #f)&#13;
&#13;
&gt; <span class="codestrong1">(format-rec (import-record in-port) 6 2)</span>&#13;
(hist "1980-01-02" "  3.45" "  3.45" "  3.35" "  3.37" "  0.69" "  6622400")&#13;
&#13;
&gt; <span class="codestrong1">(format-rec (import-record in-port) 6 2)</span>&#13;
(hist "1980-01-03" "  3.32" "  3.32" "  3.25" "  3.28" "  0.67" "  7222400")&#13;
&#13;
&gt; <span class="codestrong1">(close-input-port in-port)</span></pre>&#13;
<p class="indent">Notice that some of the output values are padded with spaces because the numbers are less than six characters wide when formatted with two decimal places.</p>&#13;
<p class="indent">Since we’ll sometimes want to display the data in tabular form, we’ll take advantage of the <span class="literal">text-table</span> package. Unfortunately, this package isn’t included with the default Racket install, so it’ll need to be installed via either Racket’s package manager or the <span class="literal">raco</span> command line tool (see <a href="ch02.xhtml">Chapter 2</a> on <span class="literal">infix</span> for an example of how to install packages). Once the <span class="literal">text-table</span> package is installed, the following command must be included in your definition file or executed in the interactive window:</p>&#13;
<pre>(require text-table)</pre>&#13;
<p class="indent">The <span class="literal">text-table</span> package defines the <span class="literal">table-&gt;string</span> function, which takes a list of lists, where each sublist represents a row in the table. Here’s a simple example of how it can be used.</p>&#13;
<pre>&gt; <span class="codestrong1">(define data '((a b c) (1 2 3) (4 5 6)))</span>&#13;
&gt; <span class="codestrong1">(display (table-&gt;string data))</span>&#13;
+-+-+-+&#13;
|a|b|c|&#13;
+-+-+-+&#13;
|1|2|3|&#13;
+-+-+-+&#13;
|4|5|6|&#13;
+-+-+-+</pre>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_153"/>The data that we’re going to be querying against has a file structure similar to the one shown in <a href="ch06.xhtml#ch6fig1">Figure 6-1</a>. The files have records (one record for each day, month, or week) for years 1980 through the end of 2016 (where available).</p>&#13;
<div class="image"><img alt="Image" src="../images/06fig02.jpg"/></div>&#13;
<p class="figcap" id="ch6fig1"><em>Figure 6-1: Stock history file structure</em></p>&#13;
<p class="indent">The following code will display rows of stock history when given the stock symbol and time period (either <span class="literal">"Daily"</span>, <span class="literal">"Monthly"</span>, or <span class="literal">"Weekly"</span>—files for each period are stored in a corresponding folder). In addition, a filter must be specified. The filter is a function that accepts a <span class="literal">hist</span> structure and returns <span class="literal">#t</span> or <span class="literal">#f</span> depending on what’s being searched for.</p>&#13;
<pre>(define (show sym period filter)&#13;
  (let ([in-port (open-input-file&#13;
      (build-path "StockHistory" period (string-append sym ".csv")))])&#13;
    (read-line in-port) ; skip past header row&#13;
 <span class="ent">➊</span> (let* ([recs&#13;
         (reverse&#13;
         <span class="ent">➋</span> (let loop([rec-list '()])&#13;
           <span class="ent">➌</span> (let ([rec (import-record in-port)])&#13;
                (if (eof-object? rec)&#13;
                    rec-list&#13;
                 <span class="ent">➍</span> (if (filter rec)&#13;
                     <span class="ent">➎</span> (let* ([rec (format-rec rec 8 2)]&#13;
                               [rec (list (hist-date rec)&#13;
                                          (hist-high rec)&#13;
                                          (hist-low rec)&#13;
                                          (hist-close rec))])                          &#13;
                       <span epub:type="pagebreak" id="page_154"/><span class="ent">➏</span> (loop (cons rec rec-list)))&#13;
                     <span class="ent">➐</span> (loop rec-list))))))]&#13;
       <span class="ent">➑</span> [tbl-list (cons (list "   Date" "  High" "  Low" "  Close") recs)])&#13;
      (close-input-port in-port)&#13;
   <span class="ent">➒</span> (display (table-&gt;string tbl-list)))))</pre>&#13;
<p class="indent">Once the input file is opened and we’ve skipped past the header line, the code line <span class="literal">(let* ([recs</span> <span class="ent">➊</span> binds two variables: <span class="literal">recs</span> and <span class="literal">tbl-list</span> <span class="ent">➑</span>. Note that <span class="literal">recs</span> is used to initialize <span class="literal">tbl-list</span> <span class="ent">➑</span>, which simply adds a header for the data contained in <span class="literal">recs</span>. Then the final output is generated <span class="ent">➒</span>.</p>&#13;
<p class="indent">In the main body of code, we set up a function called <span class="literal">loop</span> <span class="ent">➋</span> to recursively extract the data from the input file (the <span class="literal">reverse</span> just prior to this is needed since the recursive call builds up the data in the reverse order). Note that <span class="literal">rec-list</span> is initialized with an empty list. The identifier <span class="literal">rec</span> <span class="ent">➌</span> is populated with a single row from the input file. Once the end of the file is reached, we output the compiled <span class="literal">rec-list</span>, but until then we use the filter to search for records that meet our criteria <span class="ent">➍</span>. When such a record is found, we bind a local version of <span class="literal">rec</span> using our previously defined <span class="literal">format-rec</span> code <span class="ent">➎</span>. Since we’re in a <span class="literal">let*</span> form, we bind a new local version of <span class="literal">rec</span> on the next line with data extracted from the imported record. Having done this, we add this to the previously imported data <span class="ent">➏</span> and recursively call <span class="literal">loop</span>. If the filter’s criteria are not met, we simply trigger the reading of the next row of data from the import file with the existing data <span class="ent">➐</span>.</p>&#13;
<p class="indent">Let’s take a look at the year 2008 when things started to go horribly wrong in the financial sector. (The <span class="literal">substring</span> function is used to pull the year out of the date field and display only records where the year is equal to 2008.)</p>&#13;
<pre>&gt; <span class="codestrong1">(show "^DJI" "Monthly"&#13;
        (λ (rec) (equal? (substring (hist-date rec) 0 4) "2008")))</span>&#13;
&#13;
+----------+--------+--------+--------+&#13;
|   Date   |  High  |  Low   |  Close |&#13;
+----------+--------+--------+--------+&#13;
|2008-01-01|13279.54|11634.82|12650.36|&#13;
+----------+--------+--------+--------+&#13;
|2008-02-01|12767.74|12069.47|12266.39|&#13;
+----------+--------+--------+--------+&#13;
|2008-03-01|12622.07|11731.60|12262.89|&#13;
+----------+--------+--------+--------+&#13;
|2008-04-01|13010.00|12266.47|12820.13|&#13;
+----------+--------+--------+--------+&#13;
|2008-05-01|13136.69|12442.59|12638.32|&#13;
+----------+--------+--------+--------+&#13;
|2008-06-01|12638.08|11287.56|11350.01|&#13;
+----------+--------+--------+--------+&#13;
<span epub:type="pagebreak" id="page_155"/>|2008-07-01|11698.17|10827.71|11378.02|&#13;
+----------+--------+--------+--------+&#13;
|2008-08-01|11867.11|11221.53|11543.96|&#13;
+----------+--------+--------+--------+&#13;
|2008-09-01|11790.17|10365.45|10850.66|&#13;
+----------+--------+--------+--------+&#13;
|2008-10-01|10882.52| 7882.51| 9325.01|&#13;
+----------+--------+--------+--------+&#13;
|2008-11-01| 9653.95| 7449.38| 8829.04|&#13;
+----------+--------+--------+--------+&#13;
|2008-12-01| 9026.41| 8118.50| 8776.39|&#13;
+----------+--------+--------+--------+</pre>&#13;
<p class="indent">During that year, the Dow swung from a high of 13,279.54 in January to a low of 7,449.38 in November. A swing of 5,380 points, or a 44 percent drop!</p>&#13;
<p class="indent">A year earlier, Microsoft had been averaging around $30 a share, but it dropped below $19 a few times in 2008. Let’s see when that happened.</p>&#13;
<pre>&gt; <span class="codestrong1">(show "MSFT" "Daily"&#13;
     (λ (rec) (and&#13;
                     (&lt; (hist-close rec) 19)&#13;
                     (equal? (substring (hist-date rec) 0 4) "2008"))))</span>&#13;
&#13;
+----------+--------+--------+--------+&#13;
|   Date   |  High  |  Low   |  Close |&#13;
+----------+--------+--------+--------+&#13;
|2008-11-19|   19.95|   18.25|   18.29|&#13;
+----------+--------+--------+--------+&#13;
|2008-11-20|   18.84|   17.50|   17.53|&#13;
+----------+--------+--------+--------+&#13;
|2008-12-01|   19.95|   18.60|   18.61|&#13;
+----------+--------+--------+--------+&#13;
|2008-12-29|   19.21|   18.64|   18.96|&#13;
+----------+--------+--------+--------+</pre>&#13;
<h3 class="h3" id="ch00lev1sec_37">A Database Detour</h3>&#13;
<p class="noindent">This section is entirely optional since the rest of the chapter isn’t dependent on the ideas presented here. But we do want to present some information on random file access that could be useful in various scenarios. <em>Random file access</em> is a key component for efficient data queries. In particular, random file access is a critical component in any database. A database is mainly just a predefined collection of tables, with each table potentially containing multiple records. So far, to locate a particular record in a table, we’ve scanned a file, record by record, until the desired entry was located. On average half <span epub:type="pagebreak" id="page_156"/>the records have to be checked, and in the worst case, all the records are checked. This is clearly not very efficient.</p>&#13;
<p class="indent">Normally, we’re looking for a particular date, and the fact that the records are in date order suggests that a binary search might be applicable (if you don’t know what a binary search is, we’ll delve into the details shortly); but there is a problem. In CSV files, the records are packed together with a variable number of characters in each record, so there is no way to accurately get positioned on a particular record without reading through the file starting from the beginning. The key is to allocate slots for each record where each slot is a fixed size, but large enough to hold the largest record. To facilitate this, we’ll define the following function:</p>&#13;
<pre>(define (file-info sym period)&#13;
  (let ([port (open-input-file&#13;
          (build-path "StockHistory" period (string-append sym ".csv")))]&#13;
        [recs 0]&#13;
        [max-size 0])&#13;
    (let loop ()&#13;
      (let ([rec (read-line port)])&#13;
        (unless (eof-object? rec)&#13;
          (let ([len (string-length rec)])&#13;
            (set! recs (add1 recs))&#13;
            (unless (&lt;= len max-size)&#13;
              (set! max-size len)))&#13;
          (loop))))&#13;
    (close-input-port port)&#13;
    (values recs max-size)))</pre>&#13;
<p class="indent">This function scans the input file to determine the number of records in the file and the maximum record size.</p>&#13;
<p class="indent">With the information returned from <span class="literal">file-info</span>, we can construct an appropriately formatted data file. This file reserves the first slot to hold the information returned from <span class="literal">file-info</span> since this will be useful when we get around to actually searching the file. The remaining slots are populated with values from the source file by using the <span class="literal">file-position</span> function to set the location the values are written to (by calling <span class="literal">display</span>). Unused space at the end of a record is filled with zero (0) bytes. To actually create the file, we define a function called <span class="literal">csv-&gt;db</span>:</p>&#13;
<pre>(define (csv-&gt;db sym period)&#13;
  (let*-values ([(recs max-size) (file-info sym period)]&#13;
      [(in-port) (open-input-file&#13;
        (build-path "StockHistory" period (string-append sym ".csv")))]&#13;
   <span class="ent">➊</span> [(out-port) (open-output-file&#13;
       (build-path "StockHistory" period (string-append sym ".db"))&#13;
         #:exists 'truncate)]&#13;
      [(slot-size) (+ 10 max-size)])&#13;
 <span class="ent">➋</span> (file-position out-port (* recs slot-size))&#13;
 <span class="ent">➌</span> (display (make-string slot-size #\space) out-port)&#13;
    <span epub:type="pagebreak" id="page_157"/>(file-position out-port 0)&#13;
 <span class="ent">➍</span> (display recs out-port)&#13;
    (display "," out-port)&#13;
 <span class="ent">➎</span> (displayln slot-size out-port)&#13;
    (read-line in-port) ; read past header&#13;
    (for ([ i (in-range 1 recs)])&#13;
      (let ([rec (read-line in-port)]&#13;
            [pos (* i slot-size)])&#13;
     <span class="ent">➏</span> (file-position out-port pos)&#13;
     <span class="ent">➐</span> (displayln rec out-port)))&#13;
    (close-input-port in-port)&#13;
    (close-output-port out-port)&#13;
    ))</pre>&#13;
<p class="indent">This function creates a data file in the same folder as the source file, with the same name, except that the output file <span class="ent">➊</span> has <em>.db</em> as a file extension instead of <em>.csv</em>. Next, we set the file position to the end of the file <span class="ent">➋</span> and write a dummy record <span class="ent">➌</span>. This is an efficiency step to keep the operating system from constantly enlarging the file every time a record is written. We write the number of records and slot size to the first record in the file <span class="ent">➍</span> <span class="ent">➎</span>. For each record in the input file, we then position the output file pointer <span class="ent">➏</span> and write out the record <span class="ent">➐</span>.</p>&#13;
<p class="indent">Having thus created a searchable data file, we can now create a routine to perform a binary search to efficiently find a record for a particular date. (For more detailed information on binary searches in general, see the Wikipedia article: <a href="http://en.wikipedia.org/wiki/Binary_search_algorithm"><em>http://en.wikipedia.org/wiki/Binary_search_algorithm</em></a>.)</p>&#13;
<pre> (define (bin-search sym period date)&#13;
<span class="ent">➊</span> (let* ([port (open-input-file&#13;
          (build-path "StockHistory" period (string-append sym ".db")))]&#13;
      [info (string-split (read-line port) ",")]&#13;
      [recs (string-&gt;number (first info))]&#13;
      [slot-size (string-&gt;number (second info))]&#13;
      [min 1]&#13;
   <span class="ent">➋</span> [max recs])&#13;
    &#13;
 <span class="ent">➌</span> (define (get-date rec)&#13;
      (substring rec 0 10))&#13;
&#13;
 <span class="ent">➍</span> (define (get-rec i)&#13;
      (file-position port (* slot-size i))&#13;
      (read-line port))&#13;
    &#13;
    (let loop ()&#13;
   <span class="ent">➎</span> (if (&gt; min max)&#13;
          (begin&#13;
            (close-input-port port)&#13;
            #f)&#13;
       <span epub:type="pagebreak" id="page_158"/><span class="ent">➎</span> (let* ([i (floor (/ (+ min max) 2))]&#13;
                 [rec (get-rec i)]&#13;
                 [d (get-date rec)])&#13;
            (cond [(string&lt;? d date)&#13;
                <span class="ent">➏</span> (set! min (add1 i))&#13;
                   (loop)]&#13;
                  [(string&gt;? d date)&#13;
                <span class="ent">➐</span> (set! max (sub1 i))&#13;
                   (loop)]&#13;
                  [else&#13;
                   (close-input-port port)&#13;
                <span class="ent">➑</span> rec]))))))</pre>&#13;
<p class="indent">First, we perform some basic initialization <span class="ent">➊</span> <span class="ent">➋</span>. After opening the input file, we read the first record (which contains the number of records and slot size) and bind <span class="literal">recs</span> and <span class="literal">slot-size</span> to the appropriate values. Next, we define a couple of helper functions to simplify retrieving data for the current record <span class="ent">➌</span> <span class="ent">➍</span>. The remainder of the code is a straightforward implementation of a binary search routine, the main body consisting of a loop (via recursive function <span class="literal">loop</span>). The search begins by testing whether any records remain to be checked <span class="ent">➎</span>. If <span class="literal">(&gt; min max)</span> is true, all records have been checked and no match has been found, so the function returns <span class="literal">#f</span>. Next, we compare the date of the middle element of the file with the target date <span class="ent">➏</span>. If the target date matches the middle element, the current record is returned <span class="ent">➑</span>. If the target date is less than or greater than the date of the current element, the search continues by narrowing down the range of the file by resetting <span class="literal">min</span> <span class="ent">➏</span> and <span class="literal">max</span> <span class="ent">➐</span> as needed.</p>&#13;
<p class="indent">We test our creation by first forming a searchable data file for Microsoft stock prices with the following:</p>&#13;
<pre>&gt; <span class="codestrong1">(csv-&gt;db "MSFT" "Daily")</span></pre>&#13;
<p class="indent">If we’re then interested in retrieving the stock price record for March 13, 1992, we do it like this:</p>&#13;
<pre>&gt; <span class="codestrong1">(bin-search "MSFT" "Daily" "1992-03-13")</span>&#13;
"1992-03-13,2.552083,2.562500,2.510417,2.520833,1.674268,36761600"</pre>&#13;
<p class="indent">The Microsoft file has 7,768 records. On average, a linear search would have to examine 3,884 records. The worst-case performance of a binary search is given by the following expression, where <em>t</em> is the number of checks that need to be performed and <em>n</em> is the number of records:</p>&#13;
<p class="center"><em>t</em> = ⌊log<sub>2</sub>(n + 1)⌋</p>&#13;
<p class="indent">This means that searching the Microsoft data would only require the following checks. Examining 12 records is a lot better than examining 3,884.</p>&#13;
<div class="image1"><img alt="Image" src="../images/p0158-1.jpg"/></div>&#13;
<h3 class="h3" id="ch00lev1sec_38"><span epub:type="pagebreak" id="page_159"/>Data Visualization</h3>&#13;
<p class="noindent">A picture is worth a thousand dollars, er . . . a thousand words. So far we’ve been looking at data. Now we want to look at information. The difference is this: data is just a raw assemblage of numbers, dates, and strings; information says how these things are related. Just perusing a list of numbers doesn’t provide much insight into their meaning, but often a visual representation invokes an epiphany. In light of this, we turn to the topic of data visualization. In this section we’ll look at financial data in two different ways: value over time and frequency analysis via histograms.</p>&#13;
<p class="indent">To ensure that we have everything we need, we start from scratch with the following definitions.</p>&#13;
<pre>#lang racket&#13;
(require plot)&#13;
(require text-table)&#13;
&#13;
(define (data-path symbol period)&#13;
  (build-path "StockHistory" period (string-append symbol ".csv")))&#13;
&#13;
(struct hist (date open high low close adj-close vol)&#13;
  #:transparent)&#13;
&#13;
(define symbols '("^DJI" "^GSPC" "AAPL" "AMZN"&#13;
                         "BAC" "F" "MSFT" "VBMFX" "XOM"))&#13;
&#13;
(define symbol-color&#13;
  (make-hash&#13;
   (list&#13;
    (cons "^DJI" "black")&#13;
    (cons "^GSPC" "gray")&#13;
    (cons "AAPL" "black")&#13;
    (cons "AMZN" "gray")&#13;
    (cons "BAC" "purple")&#13;
    (cons "F" "orange")&#13;
    (cons "MSFT" "blue")&#13;
    (cons "VBMFX" "black")&#13;
    (cons "XOM" "gray")&#13;
    )))&#13;
&#13;
(define symbol-style&#13;
  (make-hash&#13;
   (list&#13;
    (cons "^DJI" 'solid)&#13;
    (cons "^GSPC" 'solid)&#13;
    (cons "AAPL" 'dot)&#13;
    (cons "AMZN" 'dot)&#13;
    (cons "BAC" 'dot-dash)&#13;
    <span epub:type="pagebreak" id="page_160"/>(cons "F" 'solid)&#13;
    (cons "MSFT" 'long-dash)&#13;
    (cons "VBMFX" 'short-dash)&#13;
    (cons "XOM" 'short-dash)&#13;
    )))</pre>&#13;
<p class="indent">Most of this should be self-explanatory. As a reminder, the <span class="literal">text-table</span> package isn’t part of the default Racket setup (see <a href="ch06.xhtml#ch00lev1sec_36">“Getting Data into Racket” on page 150</a> for more info). We use <span class="literal">data-path</span> to keep from hardcoding the file paths in the body of various functions. To differentiate multiple assets on plots, they’re assigned unique colors in <span class="literal">symbol-color</span> and line styles in <span class="literal">symbol-style</span>.</p>&#13;
<p class="indent">We’ll again make use of <span class="literal">import-record</span>, which is reproduced here.</p>&#13;
<pre>(define (import-record port)&#13;
  (let ([rec (read-line port)])&#13;
    (if (eof-object? rec)&#13;
        eof&#13;
        (match (string-split rec ",")&#13;
          [(list date open high low close adj-close vol)&#13;
           (hist date&#13;
                 (string-&gt;number open)&#13;
                 (string-&gt;number high)&#13;
                 (string-&gt;number low)&#13;
                 (string-&gt;number close)&#13;
                 (string-&gt;number adj-close)&#13;
                 (string-&gt;number vol))]&#13;
          [_ (error "Failed to load record.")]))))</pre>&#13;
<p class="indent">While this function extracts everything in the record, for the remainder of the chapter we’ll primarily be interested in the date and closing price.</p>&#13;
<p class="indent">Since we’ll be plotting time-varying values, we need to convert the date string from each record into a numeric value. We can do this with the following vector and function:</p>&#13;
<pre>(define month-days&#13;
  #(0 0 31 59.25 90.25 120.25 151.25 181.25&#13;
      212.25 243.25 273.25 304.25 334.25))&#13;
&#13;
(define (date-&gt;number d)&#13;
  (match (string-split d "-")&#13;
    [(list year month day)&#13;
     (let ([year (string-&gt;number year)]&#13;
           [month (string-&gt;number month)]&#13;
           [day (string-&gt;number day)])&#13;
       (exact-&gt;inexact (+ year&#13;
                          (/ (vector-ref month-days month) 365.25)&#13;
                          (/ (sub1 day) 365.25))))]))</pre>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_161"/>The <span class="literal">month-days</span> vector provides the number of elapsed days in the year for the first day of any given month (the month number is the index; for example, February is represented by index 2). For example the entry with index 2 is 31, indicating that on February 1, 31 days have elapsed. Months after February have an extra quarter-day to account for leap years. The date conversion happens in <span class="literal">date-&gt;number</span> where the year forms the integer portion of the date, and the month and day provide the fractional portion. The fact that February can have 28 or 29 days is handled by an approximation that should be sufficient for our purpose.</p>&#13;
<h4 class="h4" id="ch00lev2sec_51"><strong><em>Plotting for Success</em></strong></h4>&#13;
<p class="noindent">As you saw in the <a href="ch04.xhtml">Chapter 4</a>, Racket plots a sequence of line segments by using a <span class="literal">lines</span> form that takes a list of vectors as its argument. Each vector specifies the <em>x</em> (date) and <em>y</em> (close price) coordinates of a segment end point. To construct this list, we use the <span class="literal">get-coords</span> function:</p>&#13;
<pre>(define (get-coords symbol period filter normalize)&#13;
  (let ([in-port (open-input-file (data-path symbol period))]&#13;
        [start-price #f])&#13;
    (read-line in-port)&#13;
    (let* ([recs&#13;
      (reverse&#13;
        (let loop([rec-list '()])&#13;
          (let ([rec (import-record in-port)])&#13;
            (if (eof-object? rec)&#13;
               rec-list&#13;
               (if (filter rec)&#13;
                 (let ([date-val (date-&gt;number (hist-date rec))]&#13;
                     [close (hist-close rec)])&#13;
                   (unless start-price (set! start-price close))&#13;
                   (let ([val &#13;
                  <span class="ent">➊</span> (if normalize (/ close start-price) close)])&#13;
                     (loop &#13;
                       (cons (vector date-val val) rec-list))))&#13;
                 (loop rec-list))))))])&#13;
      (close-input-port in-port)&#13;
      recs)))</pre>&#13;
<p class="indent">As with other examples, this function takes the stock symbol, time period type, and a filter function as arguments. Since the assets we’re examining can have widely differing values, to enable showing them on the same plot we provide the ability to normalize the values with an extra parameter. What this means is that instead of plotting the actual value, we plot the ratio of the first value in the time period to the actual value <span class="ent">➊</span>. This way all the assets start out with a value of 1, but we still see how the relative values vary over time. A few examples will make this clear shortly.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_162"/>The routine that does the plotting is quite simple.</p>&#13;
<pre>(define (plot-symbols symbols period filter&#13;
                      [normalize #f]&#13;
                      [anchor 'top-left]&#13;
                      [y-min #f]&#13;
                      [y-max #f])&#13;
  (let* ([plot-data&#13;
          (for/list ([symbol symbols])&#13;
            (let ([color (hash-ref symbol-color symbol)]&#13;
                  [style (hash-ref symbol-style symbol)])&#13;
              (lines (get-coords symbol period filter normalize)&#13;
                     #:label symbol&#13;
                     #:width 1.5&#13;
                     #:color color&#13;
                     #:style style)))]&#13;
         [ymin (if (and normalize (not y-min)) 0.0 y-min)]&#13;
         [ymax (if (and normalize (not y-max)) 2.0 y-max)])&#13;
    (parameterize&#13;
        ([plot-width 400]&#13;
         [plot-height 250]&#13;
         [plot-x-label "Year"]&#13;
         [plot-y-label #f]&#13;
         [plot-legend-anchor anchor])&#13;
      (plot plot-data&#13;
            #:y-min ymin&#13;
            #:y-max ymax))))</pre>&#13;
<p class="indent">This time we provide it with a list of stock symbols (to allow multiple assets to be plotted at the same time), a time period type, and a filter function as arguments. We also have the option to specify whether or not the plot normalizes the data with the optional <span class="literal">normalize</span> parameter, which defaults to <span class="literal">#f</span>. Since plotted values can occur on just about any portion of the plot, we allow the user to specify where the legend is positioned with the optional <span class="literal">anchor</span> parameter. In addition we allow the user to override the default range of <em>y</em> values.</p>&#13;
<p class="indent">Since we’re primarily going to be plotting data for some range of years or dates, we’ll define a couple of function factories that create query functions by specifying the range of dates we’re interested in.</p>&#13;
<pre><span epub:type="pagebreak" id="page_163"/>(define (year-range y1 y2)&#13;
  (λ (rec) &#13;
    (string&lt;=? y1 (substring (hist-date rec) 0 4)&#13;
               y2)))&#13;
&#13;
(define (date-range d1 d2)&#13;
  (λ (rec) &#13;
    (string&lt;=? d1 (substring (hist-date rec) 0 10)&#13;
               d2)))</pre>&#13;
<p class="indent">Having established the prerequisites, we’re ready to generate some plots. Let’s begin by plotting Dow Jones data for 2007 and 2008 (see <a href="ch06.xhtml#ch6fig2">Figure 6-2</a>).</p>&#13;
<pre>&gt; <span class="codestrong1">(plot-symbols '("^DJI") "Daily"&#13;
                (year-range "2007" "2008")&#13;
                #f 'bottom-left)</span></pre>&#13;
<div class="image"><img alt="Image" src="../images/06fig03.jpg"/></div>&#13;
<p class="figcap" id="ch6fig2"><em>Figure 6-2: Dow Jones daily close price 2007–2008</em></p>&#13;
<p class="indent">Now we can actually <em>see</em> the precipitous drop that occurred in October of 2008. Next, let’s look at a few other institutions to see how they fared (see <a href="ch06.xhtml#ch6fig3">Figure 6-3</a>).</p>&#13;
<pre>&gt; <span class="codestrong1">(plot-symbols '("^DJI" "^GSPC" "AAPL" "VBMFX") "Daily"&#13;
                (year-range "2007" "2008")&#13;
                #f 'bottom-left)</span></pre>&#13;
<div class="image"><span epub:type="pagebreak" id="page_164"/><img alt="Image" src="../images/06fig04.jpg"/></div>&#13;
<p class="figcap" id="ch6fig3"><em>Figure 6-3: Multiple daily close prices</em></p>&#13;
<p class="indent">Unfortunately, the Dow numbers are so large, they’ve swamped everybody else. Now let’s see what happens when we normalize the numbers (see <a href="ch06.xhtml#ch6fig4">Figure 6-4</a>).</p>&#13;
<pre>&gt; <span class="codestrong1">(plot-symbols '("^DJI" "^GSPC" "AAPL" "VBMFX") "Daily"&#13;
                (year-range "2007" "2008")&#13;
                #t 'bottom-left)</span></pre>&#13;
<div class="image"><img alt="Image" src="../images/06fig05.jpg"/></div>&#13;
<p class="figcap" id="ch6fig4"><em>Figure 6-4: Normalized daily close prices</em></p>&#13;
<p class="indent">It’s clear that the Dow and S&amp;P 500 general market indices track fairly close to each other. Apple is all over the map. The bond fund stayed steady throughout the mayhem.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_165"/>What have we learned? Well, it would be foolish to make too many assumptions based on a few plots. It’s fairly clear, though, that at least for this time period, bonds barely wiggled, the market as a whole (represented by the index indicators S&amp;P 500 and the Dow) had some turbulence, but not as much as Apple.</p>&#13;
<p class="indent">Let’s take a longer view and see what comes up in <a href="ch06.xhtml#ch6fig5">Figure 6-5</a>.</p>&#13;
<pre>&gt; <span class="codestrong1">(plot-symbols '("^GSPC" "AAPL" "XOM") "Monthly"&#13;
                (year-range "1981" "2016")&#13;
                #t 'top-left 0 20)</span></pre>&#13;
<div class="image"><img alt="Image" src="../images/p0165-01.jpg"/></div>&#13;
<p class="figcap" id="ch6fig5"><em>Figure 6-5: Monthly close prices 1981–2016</em></p>&#13;
<p class="indent">So around 2005-ish, Apple went off the chart (more about that a bit latter). Let’s examine ExxonMobil in a bit more detail. Since this is a normalized chart, we’re seeing the relative difference in the prices; this means that at the end of 2016, ExxonMobil stock was worth roughly 18 times what it was worth at the beginning of 1981. Sounds like a lot, but is it really? We can get some idea of the average annual return this represents by using the compound interest formula given by the following:</p>&#13;
<div class="image1"><img alt="Image" src="../images/p0165-02.jpg"/></div>&#13;
<p class="indent">In this formula, <em>V</em> is the current value, <em>P</em> is the initial principal, <em>i</em> is the annual interest rate, <em>n</em> is the number of compounding periods per year (we’re going to assume monthly compounding, so this will be 12), and <em>t</em> is the number of periods (so <em>nt</em> is 12 times the number of years). We want to know the annual interest <em>i</em>, so after a bit of algebra (we won’t bore you with the details), we get this:</p>&#13;
<div class="image1"><img alt="Image" src="../images/p0165-03.jpg"/></div>&#13;
<p class="noindent"><span epub:type="pagebreak" id="page_166"/>The following function will calculate this value for us:</p>&#13;
<pre>(define (int-rate v p t)&#13;
  (let ([n 12.0])&#13;
    (* n (- (expt (/ v p) (/ 1 (* n t))) 1))))</pre>&#13;
<p class="indent">So over 35 years, $1 invested in ExxonMobil stock would yield an interest rate of . . .</p>&#13;
<pre>&gt; <span class="codestrong1">(int-rate 18 1 35)</span>&#13;
0.08286686131778254</pre>&#13;
<p class="noindent">Or around 8 percent, which is quite respectable given that ExxonMobil also pays quarterly dividends, which sweetens the pot even more.</p>&#13;
<p class="indent">But what about that wild stallion, Apple? Well, let’s adjust our range a bit and see what develops.</p>&#13;
<pre>&gt; <span class="codestrong1">(plot-symbols '("^GSPC" "AAPL" "XOM") "Monthly"&#13;
                (year-range "1981" "2016")&#13;
                #t 'top-left 0 300)</span></pre>&#13;
<div class="image"><img alt="Image" src="../images/06fig07.jpg"/></div>&#13;
<p class="figcap" id="ch6fig6"><em>Figure 6-6: Monthly close prices up to $300</em></p>&#13;
<p class="indent">Wow, a dollar invested in 1981 (after a long dry spell) would be worth about $225 at the end of 2016. Who knew? Let’s see what the effective interest rate is.</p>&#13;
<pre>&gt; <span class="codestrong1">(int-rate 225 1 35)</span>&#13;
0.15574778848870174</pre>&#13;
<p class="indent">Almost 16 percent—not too shabby. Is Apple a good investment? Well, any (honest) financial advisor will tell you this repeatedly: past performance is not a guarantee of future results.</p>&#13;
<h4 class="h4" id="ch00lev2sec_52"><span epub:type="pagebreak" id="page_167"/><strong><em>Lumping Things Together</em></strong></h4>&#13;
<p class="noindent">One thing besides the outrageous return on investment (ROI) of Apple stands out: its value is very erratic. Let’s look at ExxonMobil and Apple during the period of time before things got really crazy in 2008 (see <a href="ch06.xhtml#ch6fig7">Figure 6-7</a>).</p>&#13;
<pre>&gt; <span class="codestrong1">(plot-symbols '("AAPL" "XOM") "Daily"&#13;
                (date-range "2007-01-01" "2008-09-30")&#13;
                #t 'top-left 0.5 2.5)</span></pre>&#13;
<div class="image"><img alt="Image" src="../images/06fig08.jpg"/></div>&#13;
<p class="figcap" id="ch6fig7"><em>Figure 6-7: Apple and ExxonMobil before the crash</em></p>&#13;
<p class="indent">It’s clear that even over this short interval of time, the value of Apple from one day to the next would not be easy to predict. If someone isn’t interested in the specific value of a stock, but rather how variable it is, one way to visualize the variability is with a histogram. A <em>histogram</em> represents data by showing how often values fall into certain ranges. We call these ranges <em>bins</em>. To aid in our analysis, we’ll supplement each histogram with a table that gives the range of values and counts for each bin.</p>&#13;
<p class="indent">To begin, we define a function that extracts a particular data field for an investment given the stock symbol, period, filter function, and the corresponding <span class="literal">hist</span> structure field.</p>&#13;
<pre>(define (get-data symbol period filter field)&#13;
  (let ([in-port (open-input-file (data-path symbol period))])&#13;
    (read-line in-port)&#13;
    (let* ([recs&#13;
            (reverse&#13;
             (let loop([rec-list '()])&#13;
               (let ([rec (import-record in-port)])&#13;
                 (if (eof-object? rec)&#13;
                     rec-list&#13;
                     (if (filter rec)&#13;
                         <span epub:type="pagebreak" id="page_168"/>(loop (cons (field rec) rec-list))&#13;
                         (loop rec-list))))))])&#13;
      (close-input-port in-port)&#13;
      recs)))</pre>&#13;
<p class="indent">For example if we wanted the maximum stock cost for Microsoft in 1999 (a pretty good year for Microsoft) in the monthly data, we could get it this way:</p>&#13;
<pre>&gt; <span class="codestrong1">(get-data "MSFT" "Monthly"&#13;
                (year-range "1999" "1999")&#13;
                hist-close)</span>&#13;
'(43.75 37.53125 44.8125 40.65625 40.34375 45.09375 42.90625 46.28125 45.28125&#13;
      46.28125 45.523399 58.375)</pre>&#13;
<p class="indent">The following function compiles the data (a list of values) and populates bins with the proper count of values.</p>&#13;
<pre>(define (categorize data avg num-bins)&#13;
  (let* ([bin (make-vector num-bins 0)]&#13;
         [bin-min (* 0.4 avg)]&#13;
         [bin-max (* 1.6 avg)]&#13;
         [bin-delta (/ (- bin-max bin-min) num-bins)])&#13;
    (define (update-bin val)&#13;
      (when (&lt;= bin-min val bin-max)&#13;
        (let ([i (inexact-&gt;exact (floor (/ (- val bin-min) bin-delta)))])&#13;
          (vector-set! bin i (add1 (vector-ref bin i))))))&#13;
    (let loop ([val-list data])&#13;
      (unless (null? val-list)&#13;
        (update-bin (car val-list))&#13;
        (loop (cdr val-list))))&#13;
    (values bin-min bin-max&#13;
            (for/list ([i (in-range num-bins)])&#13;
              (vector i (vector-ref bin i))))))</pre>&#13;
<p class="indent">This function first sets an overall range of values that are 60 percent below and 60 percent above the average value. Within this range, data values will be compiled into the <span class="literal">bin</span> vector. At the end of the process, the function returns the overall minimum and maximum range of the bins as well as categorized values contained in <span class="literal">bin</span>. Each vector in <span class="literal">bin</span> contains the bin index and the number of values in the bin (it has to be formatted this way to work with Racket’s <span class="literal">discrete-histogram</span> function).</p>&#13;
<p class="indent">To display the data in tabular form, we define <span class="literal">bin-table</span>, which will display the bin index along with the range of values for the bin and the number of values in each bin.</p>&#13;
<pre>(define (bin-table bins bin-min bin-max)&#13;
  (let* ([num-bins (length bins)]&#13;
         [bin-delta (/ (- bin-max bin-min) num-bins)]&#13;
         <span epub:type="pagebreak" id="page_169"/>[rows&#13;
          (for/list ([i (in-range num-bins)]&#13;
                     [bin bins])&#13;
            (let ([bmin (+ bin-min (* bin-delta i))]&#13;
                  [bmax (+ bin-min (* bin-delta (add1 i)))]&#13;
                  [count (vector-ref bin 1)])&#13;
              (list&#13;
               (~r i #:min-width 3)&#13;
               (~r bmin #:min-width 8  #:precision (list '= 2))&#13;
               (~r bmax #:min-width 8  #:precision (list '= 2))&#13;
               (~r count #:min-width 4))))])&#13;
    (table-&gt;string (cons '("Bin" "   Min" "   Max" "Vals") rows))))</pre>&#13;
<p class="indent">After we’ve laid the groundwork, creating a function to generate the output is quite simple.</p>&#13;
<pre>(define (histogram-symbol symbol period filter [bins 11])&#13;
  (let*-values ([(data) (get-data symbol period filter hist-close)]&#13;
                [(avg) (/ (apply + data) (length data))]&#13;
                [(bin-min bin-max hist-data) (categorize data avg bins)])&#13;
    (displayln (bin-table hist-data bin-min bin-max))&#13;
    (parameterize&#13;
        ([plot-width 400]&#13;
         [plot-height 250]&#13;
         [plot-x-label #f]&#13;
         [plot-y-label "Frequency"])&#13;
      (plot (discrete-histogram hist-data)))))</pre>&#13;
<p class="indent">Let’s see what this tells us about Apple and ExxonMobil (see <a href="ch06.xhtml#ch6fig8">Figures 6-8</a> and <a href="ch06.xhtml#ch6fig9">6-9</a>).</p>&#13;
<pre>&gt; <span class="codestrong1">(histogram-symbol "AAPL" "Daily" (date-range "2007-01-01" "2008-09-30"))</span>&#13;
+---+--------+--------+----+&#13;
|Bin|   Min  |   Max  |Vals|&#13;
+---+--------+--------+----+&#13;
|  0|    8.06|   10.25|   0|&#13;
+---+--------+--------+----+&#13;
|  1|   10.25|   12.45|  30|&#13;
+---+--------+--------+----+&#13;
|  2|   12.45|   14.65|  55|&#13;
+---+--------+--------+----+&#13;
|  3|   14.65|   16.85|  20|&#13;
+---+--------+--------+----+&#13;
|  4|   16.85|   19.04|  87|&#13;
+---+--------+--------+----+&#13;
|  5|   19.04|   21.24|  54|&#13;
+---+--------+--------+----+&#13;
|  6|   21.24|   23.44|  46|&#13;
+---+--------+--------+----+&#13;
|  7|   23.44|   25.64|  81|&#13;
+---+--------+--------+----+&#13;
<span epub:type="pagebreak" id="page_170"/>|  8|   25.64|   27.83|  61|&#13;
+---+--------+--------+----+&#13;
|  9|   27.83|   30.03|   6|&#13;
+---+--------+--------+----+&#13;
| 10|   30.03|   32.23|   0|&#13;
+---+--------+--------+----+</pre>&#13;
<div class="image"><img alt="Image" src="../images/06fig09.jpg"/></div>&#13;
<p class="figcap" id="ch6fig8"><em>Figure 6-8: Apple histogram</em></p>&#13;
<pre>&gt; <span class="codestrong1">(histogram-symbol "XOM" "Daily" (date-range "2007-01-01" "2008-09-30"))</span>&#13;
&#13;
+---+--------+--------+----+&#13;
|Bin|   Min  |   Max  |Vals|&#13;
+---+--------+--------+----+&#13;
|  0|   33.65|   42.83|   0|&#13;
+---+--------+--------+----+&#13;
|  1|   42.83|   52.00|   0|&#13;
+---+--------+--------+----+&#13;
|  2|   52.00|   61.18|   0|&#13;
+---+--------+--------+----+&#13;
|  3|   61.18|   70.36|   4|&#13;
+---+--------+--------+----+&#13;
|  4|   70.36|   79.54| 106|&#13;
+---+--------+--------+----+&#13;
|  5|   79.54|   88.71| 210|&#13;
+---+--------+--------+----+&#13;
|  6|   88.71|   97.89| 120|&#13;
+---+--------+--------+----+&#13;
|  7|   97.89|  107.07|   0|&#13;
+---+--------+--------+----+&#13;
<span epub:type="pagebreak" id="page_171"/>|  8|  107.07|  116.25|   0|&#13;
+---+--------+--------+----+&#13;
|  9|  116.25|  125.42|   0|&#13;
+---+--------+--------+----+&#13;
| 10|  125.42|  134.60|   0|&#13;
+---+--------+--------+----+</pre>&#13;
<div class="image"><img alt="Image" src="../images/06fig09.jpg"/></div>&#13;
<p class="figcap" id="ch6fig9"><em>Figure 6-9: ExxonMobil histogram</em></p>&#13;
<p class="noindent">It’s clear from the histograms that values for Apple are dispersed over a wider range of values than the data for ExxonMobil for the same time period. This higher volatility is the price Apple investors pay for the possibility of getting larger returns.</p>&#13;
<h3 class="h3" id="ch00lev1sec_39">A Bit of Statistics</h3>&#13;
<p class="noindent">We demonstrated in the previous section that the old truism that a picture is worth a thousand words makes a bit of sense, at least in terms of analyzing investment data. But it’s also true that a single number is worth, well, at least one picture. So far our analysis has primarily been qualitative, where we used a number of techniques to visualize our data. We now turn to a couple of standard statistical tools that are widely used for quantitative analysis.</p>&#13;
<h4 class="h4" id="ch00lev2sec_53"><strong><em>Standard Deviation</em></strong></h4>&#13;
<p class="noindent">In the last section, we looked at using histograms to get some idea of how widely dispersed stock values were over some period of time. This type of information can be summed up in a single number called the <em>standard deviation</em>. For a given set of numbers, the standard deviation indicates how much individual numbers deviate from the overall average of the set. <span epub:type="pagebreak" id="page_172"/>You might think of it as the average amount of deviation. Standard deviation is defined by the following formula:</p>&#13;
<div class="image1"><img alt="Image" src="../images/p0172-02.jpg"/></div>&#13;
<p class="noindent">In this equation, <em>n</em> is the number of values, the Greek letter mu (<em>μ</em>) represents the mean or average of all the data values, and the <em>x</em><sub><em>i</em></sub> represents the individual numbers.</p>&#13;
<p class="indent">Closely related to standard deviation is the statistical concept of <em>variance</em>, which is simply the square of the standard deviation:</p>&#13;
<div class="image1"><img alt="Image" src="../images/p0173-01.jpg"/></div>&#13;
<p class="noindent">We shall see a bit later that variance is useful in regression analysis where we attempt to determine how data is trending.</p>&#13;
<p class="indent">We wrap the standard deviation formula in a Racket function as follows:</p>&#13;
<pre>(define (std-deviation nums)&#13;
  (let* ([n (length nums)]&#13;
         [mu (/ (apply + nums) n)]&#13;
         [sqr-diff (map (λ (x) (sqr (- x mu))) nums)])&#13;
    (sqrt (/ (apply + sqr-diff) n))))</pre>&#13;
<p class="indent">We can now compute numerical values with which we can analyze the deviation of different assets. Let’s take a look at the data we generated histograms for.</p>&#13;
<pre>&gt; <span class="codestrong1">(define apple (get-data "AAPL" "Daily" (date-range "2007-01-01" "2008-09-30"&#13;
    ) hist-close))</span>&#13;
&gt; <span class="codestrong1">(define xom (get-data "XOM" "Daily" (date-range "2007-01-01" "2008-09-30")&#13;
    hist-close))</span>&#13;
&#13;
&gt; <span class="codestrong1">(std-deviation apple)</span>&#13;
4.811932439819516&#13;
&#13;
&gt; <span class="codestrong1">(std-deviation xom)</span>&#13;
6.399636764602135</pre>&#13;
<p class="indent">This <em>seems</em> to indicate that Apple actually had less deviation than ExxonMobil. This is where the proper interpretation of data is crucial. The histogram data showed us the spread of data within ± 60% of the <em>average</em> value. To make sense of the deviation data, let’s get the average value of these stocks.</p>&#13;
<pre>&gt; <span class="codestrong1">(define apple-avg (/ (apply + apple) (length apple)))</span>&#13;
&gt; <span class="codestrong1">apple-avg</span>&#13;
20.143350647727257&#13;
&#13;
<span epub:type="pagebreak" id="page_173"/>&gt; <span class="codestrong1">(define xom-avg (/ (apply + xom) (length xom)))</span>&#13;
&gt; <span class="codestrong1">xom-avg</span>&#13;
84.12513634318191&#13;
&#13;
&gt; <span class="codestrong1">(/ (std-deviation apple) apple-avg)</span>&#13;
0.23888441024395504&#13;
&#13;
&gt; <span class="codestrong1">(/ (std-deviation xom) xom-avg)</span>&#13;
0.07607282487478317</pre>&#13;
<p class="indent">From this we can now see that Apple typically deviated almost 24 percent from its average price during that period whereas ExxonMobil only deviated about 7.5 percent.</p>&#13;
<p class="indent">While here we’re strictly looking at the standard deviation of the close price, this is <em>not</em> how deviation is normally evaluated in a financial sense. What is of most interest in that regard is deviation of <em>returns</em>. A stock that has a steady 10 percent annual return would clearly have some price deviation, but it would have almost no deviation based on returns. Another consideration is that change in stock price alone is not necessarily an indication of returns since dividends (for those stocks that pay dividends) come into play as well.</p>&#13;
<h4 class="h4" id="ch00lev2sec_54"><strong><em>Regression</em></strong></h4>&#13;
<p class="noindent">In our analysis of various financial assets, we’ve mentioned the adage that past performance is not a guarantee of future results, which is true, but past performance might suggest future results. Given a disparate set of data points, it’s often of interest to determine whether or not they suggest a trend. The statistical tool called <em>regression analysis</em> attempts to make just such a determination. Regression analysis fits a straight line to a set of data points (since we’re only fitting our data to a straight line, this is technically called <em>linear regression</em>) where <em>x</em> is called the <em>independent predictor</em> or <em>predictor variable</em>, and <em>y</em> is called the <em>dependent response</em>. The desired outcome is this <em>regression</em> or <em>prediction</em> line:</p>&#13;
<p class="center"><em>y</em> = <em>a + bx</em></p>&#13;
<p class="noindent">The idea is that given this line and some <em>x</em>-value, we can compute an estimated value for <em>y</em>. The parameters <em>a</em> and <em>b</em> are defined in such a way as to minimize the total distance of the <em>y</em> data values from the line. Specifically, if (<em>x</em><sub><em>i</em></sub>, <em>y</em><sub><em>i</em></sub>) are the actual data points, we let <em>ŷ</em><sub><em>i</em></sub> = <em>a</em> + <em>bx</em><sub><em>i</em></sub> (this is the estimated value of <em>y</em> at <em>x</em><sub><em>i</em></sub>), in which case regression analysis seeks to minimize the <em>sum of squares errors</em> given by the following:</p>&#13;
<div class="image1"><span epub:type="pagebreak" id="page_174"/><img alt="Image" src="../images/06eqa01.jpg"/></div>&#13;
<p class="indent">If <img alt="Image" src="../images/x-bar.jpg"/> is the mean, or average, of all the <em>x</em> values and <img alt="Image" src="../images/y-bar.jpg"/> is the mean of all the <em>y</em> values, it can be shown that the <em>a</em> and <em>b</em> parameters of the regression line are given by the following:</p>&#13;
<div class="image1"><img alt="Image" src="../images/p0174-04.jpg"/></div>&#13;
<p class="indent">The formidable-looking Equation (6.1) is actually the ratio of two simpler formulas: the <em>covariance</em> of <em>x</em> and <em>y</em> and the variance of <em>x</em>. We’ve already seen that the variance of <em>x</em> is given by the following:</p>&#13;
<div class="image1"><img alt="Image" src="../images/p0174-01.jpg"/></div>&#13;
<p class="noindent">The covariance of <em>x</em> and <em>y</em> is defined by the following:</p>&#13;
<div class="image1"><img alt="Image" src="../images/p0174-02.jpg"/></div>&#13;
<p class="indent">Covariance is a measure of the joint variability of two random variables (in our case the <em>x</em><sub><em>i</em></sub> and <em>y</em><sub><em>i</em></sub>). We make use of the following slightly altered form of these last two equations, along with a couple of others, to develop a method to determine how well our regression line actually fits the data.</p>&#13;
<div class="image1"><img alt="Image" src="../images/p0174-03.jpg"/></div>&#13;
<p class="indent">We see that SS<sub><em>xx</em></sub> is just a slightly tweaked version of <img alt="Image" src="../images/p174.jpg"/> and SS<sub><em>xy</em></sub> is likewise a tweaked version of Cov(<em>x</em>, <em>y</em>). The last equation, sum of squares regression, represents the sum of the squares of the distance of the estimated <em>ŷ</em>’s from the mean of the <em>y</em>-values to the regression line (the line that minimizes this distance will give us the best fit to the data). We saw in Equation (6.1) that the slope of the regression line is given by the following:</p>&#13;
<div class="image1"><span epub:type="pagebreak" id="page_175"/><img alt="Image" src="../images/06eqa03.jpg"/></div>&#13;
<p class="noindent">But the following can also be shown:</p>&#13;
<div class="image1"><img alt="Image" src="../images/p0175-01.jpg"/></div>&#13;
<p class="noindent">The last equation is called the <em>squared correlation</em> or <em>coefficient of determination</em>. This number can vary between 0 and 1. A value of 1 indicates the data points perfectly fit the regression line, and a value of 0 indicates there’s no correlation.</p>&#13;
<p class="indent">The regression line parameters can be computed with the following Racket function:</p>&#13;
<pre>(define (regression-params data)&#13;
  (define (x v) (vector-ref v 0))&#13;
  (define (y v) (vector-ref v 1))&#13;
  (let* ([num (length data)] &#13;
         [totx (apply + (map x data))]&#13;
         [toty (apply + (map y data))]&#13;
         [avgx (/ totx num)]&#13;
         [avgy (/ toty num)]&#13;
         [ss-xy (apply + (map (λ (v) (* (- (x v) avgx) (- (y v) avgy))) data))]&#13;
         [ss-xx (apply + (map (λ (v) (sqr (- (x v) avgx))) data))]&#13;
         [b (/ ss-xy ss-xx)]&#13;
         [a (- avgy (* b avgx))])&#13;
    (values a b)))</pre>&#13;
<p class="indent">This is a straightforward adaption of Equations (6.1) and (6.2). Let’s see what this tells us about Bank of America when it was in its downward spiral during the 2008 financial crisis.</p>&#13;
<pre>&gt; <span class="codestrong1">(define bac (get-coords "BAC" "Monthly"&#13;
                          (date-range "2007-07-01" "2009-02-01")&#13;
                          #f))</span>&#13;
                          &#13;
&gt; <span class="codestrong1">(regression-params bac)</span>&#13;
54422.310899480566&#13;
-27.082265190974677</pre>&#13;
<p class="indent">The second value is the slope of the regression line, which indicates that during that period, it was losing an average of $27 per year (over half its value in July of 2007). Ouch.</p>&#13;
<p class="indent">We now define a plot routine that accepts a single asset symbol, but that plots the data points instead of lines and includes the corresponding regression line.</p>&#13;
<pre>(define (plot-regression symbol period filter&#13;
                         [anchor 'top-left])&#13;
  (let* ([coords (get-coords symbol period filter #f)]&#13;
         <span epub:type="pagebreak" id="page_176"/>[plot-data &#13;
          (let ([color (hash-ref symbol-color symbol)])&#13;
            (points coords #:label symbol #:color color))])&#13;
    (let-values ([(a b) (regression-params coords)])&#13;
      (parameterize &#13;
          ([plot-width 400]&#13;
           [plot-height 250]&#13;
           [plot-x-label "Year"]&#13;
           [plot-y-label #f]&#13;
           [plot-legend-anchor anchor])&#13;
        (plot (list&#13;
               plot-data&#13;
               (function (λ (x) (+ (* b x) a))&#13;
                         #:color "black" #:label "Regr")))))))</pre>&#13;
<p class="indent">We can see Bank of America’s distress in graphic detail in <a href="ch06.xhtml#ch6fig10">Figure 6-10</a>.</p>&#13;
<pre>&gt; <span class="codestrong1">(plot-regression "BAC" "Monthly"&#13;
                (date-range "2007-07-01" "2009-02-01")&#13;
                'bottom-left)</span></pre>&#13;
<div class="image"><img alt="Image" src="../images/06fig10.jpg"/></div>&#13;
<p class="figcap" id="ch6fig10"><em>Figure 6-10: Regression line plotted on Bank of America data</em></p>&#13;
<p class="indent">To determine how well the regression line fits the data, we define a <span class="literal">correlation</span> function:</p>&#13;
<pre>(define (correlation data)&#13;
  (define (x v) (vector-ref v 0))&#13;
  (define (y v) (vector-ref v 1))&#13;
  (let* ([num (length data)] &#13;
         [totx (apply + (map x data))]&#13;
         [toty (apply + (map y data))]&#13;
         <span epub:type="pagebreak" id="page_177"/>[avgx (/ totx num)]&#13;
         [avgy (/ toty num)]&#13;
         [ss-xx (apply + (map (λ (v) (sqr (- (x v) avgx))) data))]         &#13;
         [ss-yy (apply + (map (λ (v) (sqr (- (y v) avgy))) data))]&#13;
         [ss-xy (apply + (map (λ (v) (* (- (x v) avgx) (- (y v) avgy))) data))]&#13;
         [b (/ ss-xy ss-xx)]&#13;
         [a (- avgy (* b avgx))]&#13;
         [ssr (apply + (map (λ (v) (sqr (- (+ (* b (x v)) a) avgy))) data))])&#13;
    (/ ssr ss-yy)))</pre>&#13;
<p class="indent">This is also just a direct implementation of the definition of <em>R</em><sup>2</sup> given above. With this we can test the fit of the Bank of America least squares line to the data.</p>&#13;
<pre>&gt; <span class="codestrong1">(define bac (get-coords "BAC" "Monthly"&#13;
                          (date-range "2007-07-01" "2009-02-01")&#13;
                          #f))</span>&#13;
&gt; <span class="codestrong1">(correlation bac)</span>&#13;
0.8799353920116734</pre>&#13;
<p class="indent">This indicates a fairly good fit. But in many cases the data doesn’t provide a good fit with a straight line. For instance if we include the start of the recovery phase, we wind up with a plot such as the following in <a href="ch06.xhtml#ch6fig11">Figure 6-11</a>.</p>&#13;
<pre>&gt; <span class="codestrong1">(plot-regression "BAC" "Monthly"&#13;
                   (year-range "2008" "2009")&#13;
                   'bottom-left)</span></pre>&#13;
<div class="image"><img alt="Image" src="../images/06fig11.jpg"/></div>&#13;
<p class="figcap" id="ch6fig11"><em>Figure 6-11: Poorly fitting regression line</em></p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_178"/>And this indicates some degree of correlation, but not as good as what we had before:</p>&#13;
<pre>&gt; <span class="codestrong1">(define bac (get-coords "BAC" "Monthly"&#13;
                          (year-range "2008" "2009")&#13;
                          #f))</span>&#13;
                          &#13;
&gt; <span class="codestrong1">(correlation bac)</span>&#13;
0.6064135484684874</pre>&#13;
<h3 class="h3" id="ch00lev1sec_40">Summary</h3>&#13;
<p class="noindent">In this chapter, we looked at various ways of accessing and analyzing data using Racket and DrRacket. We began by introducing the mechanics of how to import and export data to and from Racket ports. Once we had mastered this bit of technology, we leveraged it to look at securities in the form of raw historical stock market values. We then took a slight detour and explored binary search using random file access. Having defined a mechanism to access and parse our stock market data, we then looked at qualitative methods to analyze our data using various visualization techniques. Finally, we bit the bullet and introduced a bit of mathematics, which allowed us to do some statistical quantitative analysis.</p>&#13;
<p class="indent">Next up, we see how we can use some sophisticated search algorithms to solve some classical problems in recreational mathematics.</p>&#13;
</body></html>