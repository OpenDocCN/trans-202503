<html><head></head><body>
<h2 class="h2" id="ch20"><span epub:type="pagebreak" id="page_491"/><strong><span class="big">20</span><br/>SMALL SYSTEM SERVICES</strong></h2>
<div class="image1"><img src="../images/common01.jpg" alt="image"/></div>
<p class="noindent">Even a server with a very narrowly defined role, such as a dedicated web server, needs a variety of small “helper” services to handle basic administrative issues. In this chapter, we’ll discuss some of those services, such as time synchronization, sending mail, DHCP services, scheduling tasks, and so on. We’ll start by securing your remote connections to your FreeBSD server with SSH.</p>
<h3 class="h3" id="lev873"><strong>Secure Shell</strong></h3>
<p class="noindent">One of Unix’s great strengths is its ease of remote administration. Whether the server is in front of you or in a remote, barricaded laboratory in a subterranean, maximum-security installation surrounded by vicious guard dogs mentored by a megalomaniacal weasel named Ivan, if you have network access to the machine, you can control it.</p>
<p class="indent"><span epub:type="pagebreak" id="page_492"/>For many years, telnet(1) was the standard way to access a remote server. As a remote administration protocol, however, telnet has one crushing problem: everything sent over most versions of telnet is unencrypted. Anyone with a packet sniffer, attached anywhere along your connection, can steal your username, your password, and any information you view in your telnet session. When you use telnet, the best password-selection scheme in the world can’t protect your username and password. Intruders place illicit packet sniffers anywhere they can; I’ve seen them on small local networks and global enterprise networks, in law firms handling sensitive government work, on home PCs, and on internet backbones. The only defense against a packet sniffer is to handle your authentication credentials and data in such a way that a packet sniffer can’t make sense of them. That’s where SSH, or secure shell, comes in.</p>
<p class="indent">SSH behaves much like telnet in that it provides a highly configurable terminal window on a remote host. But unlike telnet, SSH encrypts everything you send across the network. SSH ensures not only that your passwords can’t be sniffed but also that the commands you enter and their output are encrypted. While telnet does have a few minor advantages over SSH in that it requires less CPU time and is simpler to configure, SSH’s security advantages utterly outweigh them. SSH also has many features that telnet doesn’t have, such as the ability to tunnel arbitrary protocols through the encrypted session. SSH runs on every modern variant of Unix and even on Microsoft Windows.</p>
<p class="indent">SSH encrypts and authenticates remote connections via public-key cryptography. The SSH daemon offers the server’s public key to clients and keeps the private key to itself. The client and server use the cryptographic key to negotiate a cryptographically secure channel between them. Since both public and private keys are necessary to complete this transaction, your data is secure; even if someone captures your SSH traffic, they can see only encrypted garbage.</p>
<p class="indent">To use SSH, you must run an SSH server on your FreeBSD machine and an SSH client on your workstation.</p>
<h4 class="h4" id="lev874"><strong><em>The SSH Server: sshd(8)</em></strong></h4>
<p class="noindent">The sshd(8) daemon listens for SSH requests coming in from the network on TCP port 22. To enable sshd at boot, add the following line to <em>/etc/rc.conf</em>:</p>
<pre>sshd_enable="YES"</pre>
<p class="indent">Once this is set, you can use the <em>/etc/rc.d/sshd</em> script or <code>service sshd</code> subcommands to start and stop SSH. Stopping the SSH daemon doesn’t terminate SSH sessions that are already in use; it only prevents the daemon from accepting new connections.</p>
<p class="indent">Unlike unencrypted protocols we look at, sshd is difficult to test by hand. One thing you can do is confirm that sshd is running by using nc(1) to connect to the SSH TCP port.</p>
<pre><span epub:type="pagebreak" id="page_493"/># <span class="codestrong1">nc localhost 22</span><br/>SSH-2.0-OpenSSH_7.2 FreeBSD-20160310</pre>
<p class="indent">We connect to port 22, and get an SSH banner back. We can see that the daemon listening on this port calls itself SSH version 2, implemented in OpenSSH 7.2, on FreeBSD, version 20160310. You can get all this information from a simple nc(1) connection, but it’s the last free information sshd offers. Unless you’re capable of encrypting packets by hand, on the fly, this is about as far as you can go. Press <small>CTRL</small>-C to leave nc(1) and return to the command prompt.</p>
<h4 class="h4" id="lev875"><strong><em>SSH Keys and Fingerprints</em></strong></h4>
<p class="noindent">The first time you start sshd(8), the program realizes that it has no encryption keys and automatically creates them. The initializing sshd process creates three pairs of keys: an RSA key, an ECDSA key, and an ED25519 key.</p>
<p class="indent">The key files ending in <em>.pub</em> contain the public keys for each type of key. These are the keys that sshd hands to connecting clients. This gives the connecting user the ability to verify that the server he’s connecting to is really the server he thinks it is. (Intruders have tricked users into logging into bogus machines in order to capture their usernames and passwords.) Take a look at one of these public-key files; it’s pretty long. Even when a user is offered the chance to confirm that the server is offering the correct key, it’s so long that even the most paranoid users won’t bother to verify every single character.</p>
<p class="indent">Fortunately, SSH allows you to generate a <em>key fingerprint</em>, which is a much shorter representation of a key. You can’t encrypt traffic or negotiate connections with the fingerprint, but the chances of two unrelated keys having the same fingerprint are negligible. To generate a fingerprint for a public key, enter the command <code>ssh-keygen -lf</code> <span class="codeitalic1">keyfile.pub</span>.</p>
<pre># <span class="codestrong1">ssh-keygen -lf /etc/ssh/ssh_host_rsa_key.pub</span> <br/>2048 SHA256:tEcBfgXctTfaaEF9d5QK3oYUwr5Tb/cuIr3MNxV4wwE root@bert (RSA)</pre>
<p class="indent">The first number, <code>2048</code>, shows the number of bits in the key. 2048 is standard for an RSA key in 2018, but as computing power increases, I expect this number to increase. The string starting with <code>tEcB</code> and ending with <code>wwE</code> is the fingerprint of the public key. While it’s long, it’s much shorter and much more readable than the actual key. Copy this key fingerprint from the original server to a place where you can access it from your client machines. If a human needs to verify the fingerprint, try a web page or a paper list. If your SSH clients support SSHFP records and your DNS zones support DNSSEC, you can use DNS instead. Use this key to confirm your server’s identity the first time you connect, or use one of the other key distribution methods.</p>
<h4 class="h4" id="lev876"><span epub:type="pagebreak" id="page_494"/><strong><em>Configuring the SSH Daemon</em></strong></h4>
<p class="noindent">While sshd comes with a perfectly usable configuration, you might want to tweak the settings once you learn all the features sshd(8) offers. The configuration file <em>/etc/ssh/sshd_config</em> lists all the default settings, commented out with a hash mark (<code>#</code>). If you want to change the value for a setting, uncomment the entry and change its value.</p>
<p class="indent">We won’t discuss all the available sshd options; that would take a rather large book of its own. Moreover, OpenSSH advances quickly enough to make that book obsolete before it hits the shelves. Instead, we’ll focus on some of the more common desirable configuration changes people make.</p>
<p class="indent">After changing the SSH daemon’s configuration, restart the daemon with <code>/etc/rc.d/sshd restart</code> or <code>service sshd restart</code>.</p>
<h5 class="h5" id="lev877"><strong>VersionAddendum FreeBSD-20170902</strong></h5>
<p class="noindent">The <code>VersionAddendum</code> appears in the server name when you connect to sshd’s TCP port. Some people recommend changing this to disguise the operating system version. Identifying a computer’s operating system is simple enough, however, by using fingerprinting techniques on packets exchanged with the host, so this isn’t generally worth the time. (On the other hand, if changing <code>VersionAddendum</code> to <code>DrunkenBadgerSoftware</code> amuses you, proceed.)</p>
<h5 class="h5" id="lev878"><strong>Port 22</strong></h5>
<p class="noindent">sshd(8) defaults to listening to TCP port 22. If you want, you can change this to a nonstandard port. If you want sshd to listen to multiple ports (for example, port 443 in addition to port 22), you can include multiple <code>Port</code> entries on separate lines:</p>
<pre>Port 22<br/>Port 443</pre>
<p class="indent">Changing the port isn’t useful as a security measure. It can be useful to reduce log chatter. I freely admit to having a small SSH server that listens on a variety of popular TCP ports specifically to bypass useless network security devices. But it doesn’t make SSH any more <em>secure</em>.</p>
<h5 class="h5" id="lev879"><strong>ListenAddress 0.0.0.0</strong></h5>
<p class="noindent">sshd defaults to listening for incoming requests on all IP addresses on the machine. If you need to restrict the range of addresses to listen on (for example, on a jail server), you can specify it here:</p>
<pre>ListenAddress 203.0.113.8</pre>
<p class="indent">If you want sshd to listen on multiple addresses, use multiple <code>ListenAddress</code> lines.</p>
<h5 class="h5" id="lev880"><span epub:type="pagebreak" id="page_495"/><strong>SyslogFacility AUTH and LogLevel INFO</strong></h5>
<p class="noindent">These two settings control how sshd(8) logs connection information. See <a href="ch21.xhtml#ch21">Chapter 21</a> for more information on logging.</p>
<h5 class="h5" id="lev881"><strong>LoginGraceTime 2m</strong></h5>
<p class="noindent">This controls how long a user has to log in after getting connected. If an incoming user connects but doesn’t successfully log in within this time window, sshd drops the connection.</p>
<h5 class="h5" id="lev882"><strong>PermitRootLogin no</strong></h5>
<p class="noindent">Do not let people log into your server as root. Instead, they should SSH in as a regular user and become root with su(1). Allowing direct root logins eliminates any hope you have of identifying who misconfigured your system and allows intruders to cover their tracks much more easily.</p>
<h5 class="h5" id="lev883"><strong>MaxAuthTries 6</strong></h5>
<p class="noindent">This is the number of times a user may attempt to enter a password during a single connection. After this number of unsuccessful attempts to log in, the user is disconnected.</p>
<h5 class="h5" id="lev884"><strong>AllowTcpForwarding yes</strong></h5>
<p class="noindent">SSH allows users to forward arbitrary TCP/IP ports to a remote system. If your users have shell access, they can install their own port forwarders, so there’s little reason to disable this.</p>
<h5 class="h5" id="lev885"><strong>X11Forwarding yes</strong></h5>
<p class="noindent">Unix-like operating systems use the X11 (or X) protocol to display graphical programs. In X, the display is separated from the physical machine. You can run, say, a web browser on one machine and display the results on another.</p>
<p class="indent">As X has had a checkered security history, many admins reflexively disable X forwarding. Denying X forwarding over SSH doesn’t disable X forwarding in general, however. Most users, if denied SSH-based X forwarding, just forward X over unencrypted TCP/IP using either X’s built-in network awareness or a third-party forwarder, which in most circumstances is far worse than allowing X over SSH. If your sshd server has the X libraries and client programs installed, a user can forward X one way or another; it’s best to let SSH handle the forwarding for you. If you don’t have the X software installed, then <code>X11Forwarding</code> has no effect.</p>
<h5 class="h5" id="lev886"><strong>Banner /some/path</strong></h5>
<p class="noindent">The banner is a message that’s displayed before authentication occurs. The most common use for this option is to display legal warnings. The default is not to use a banner.</p>
<h5 class="h5" id="lev887"><span epub:type="pagebreak" id="page_496"/><strong>Subsystem sftp /usr/libexec/sftp-server</strong></h5>
<p class="noindent">SSH allows you to securely copy files from one system to another with scp(1). While scp works well, it’s not very user-friendly. The sftp server provides an FTP-like interface to file transfer, reducing the amount of time you must spend on user education but still maintaining solid security.</p>
<h4 class="h4" id="lev888"><strong><em>Managing SSH User Access</em></strong></h4>
<p class="noindent">By default, anyone with a legitimate shell can log into the server. Using the configuration variables <code>AllowGroups</code>, <code>DenyGroups</code>, <code>AllowUsers</code>, and <code>DenyUsers</code>, sshd(8) lets you define particular users and groups that may or may not access your machine.</p>
<p class="indent">When you explicitly list users who may SSH into a machine, any user who isn’t listed can’t SSH in.</p>
<p class="indent">For example, the <code>AllowGroups</code> option lets you restrict SSH access to users in specified groups defined in <em>/etc/group</em> (see <a href="ch09.xhtml#ch09">Chapter 9</a>). If this option is set and a user isn’t in any of the allowed groups, he can’t log in. Separate multiple groups with spaces:</p>
<pre>AllowGroups wheel webmaster dnsadmin</pre>
<p class="indent">If you don’t want to give a whole group SSH access, you can list individual users with <code>AllowUsers</code>. By using <code>AllowUsers</code>, you disallow SSH access for everyone except the listed users.</p>
<p class="indent">The <code>DenyGroups</code> list is the opposite of <code>AllowGroups</code>. Users in the specified system groups can’t log in. The listed group must be their primary group, meaning it must be listed in <em>/etc/master.passwd</em> and not just <em>/etc/group</em>. This limitation makes <code>DenyGroups</code> less useful than it seems at first; you can’t define a general group called <em>nossh</em> and just add users to it, unless you make it their primary group as well. Explicitly listing allowed groups is a much more useful policy.</p>
<p class="indent">Finally, the <code>DenyUsers</code> variable lists users who may not log in. You can use this to explicitly forbid certain users who are in a group that is otherwise allowed.</p>
<p class="indent">These four different settings make it possible for a user to be in multiple groups simultaneously. For example, one user might be in a group listed in <code>AllowGroups</code> and a group listed in <code>DenyGroups</code>. What then? The SSH daemon checks these values in the order: <code>DenyUsers</code>, <code>AllowUsers</code>, <code>DenyGroups</code>, and <code>AllowGroups</code>. The first rule that matches wins. For example, suppose Bert is a member of the wheel group. Here’s a snippet of <em>sshd_config</em> :</p>
<pre>DenyUsers: bert<br/>AllowGroups: wheel</pre>
<p class="indent">Bert can’t SSH into this machine because <code>DenyUsers</code> is checked before <code>AllowGroups</code>.</p>
<h4 class="h4" id="lev889"><span epub:type="pagebreak" id="page_497"/><strong><em>SSH Clients</em></strong></h4>
<p class="noindent">Of course, FreeBSD comes with the SSH client, as do most Unix-like operating systems. If possible, use the included SSH client—it’s part of OpenSSH, developed by a subset of the OpenBSD team, and it’s not only the most popular implementation but also the best. If you’ve been sentenced to run a Microsoft operating system, I recommend PuTTY, which is free for commercial or noncommercial purposes and has excellent terminal emulation. Microsoft is integrating a fork of OpenSSH into Windows, but it’s still in beta as I write this.</p>
<p class="indent">This is a FreeBSD book, so we’ll focus on FreeBSD’s OpenSSH client. You can configure the client in a variety of ways, but the most common configuration choices available simply disable the functions offered by the server. If you’re really interested in tweaking your client’s behavior, read ssh_config(5).</p>
<p class="indent">To connect to another host with SSH, type <code>ssh</code> <span class="codeitalic1">hostname</span>. In response, you’ll see something like this:</p>
<pre># <span class="codestrong1">ssh mwl.io</span><br/>The authenticity of host 'mwl.io (203.0.113.221)' can't be established.<br/>ECDSA key fingerprint is SHA256:ZxOWglg4oqcZKHOLv5tfqPlAwDW6UGVbiTvjfAjMc4E.<br/>No matching host key fingerprint found in DNS. <br/>Are you sure you want to continue connecting (yes/no)? <span class="codestrong1">yes</span></pre>
<p class="indent">Your client immediately retrieves the public key from the host you’re connecting to and checks its own internal list of SSH keys for a matching key for that host. If the key offered by the server matches the key the client has in its list, the client assumes you’re talking to the correct host. If the client doesn’t have the host key in its list of known hosts, it presents the key fingerprint for your approval.</p>
<p class="indent">The fingerprint presented by the SSH client should be identical to the fingerprint you generated on your server. If the fingerprint isn’t identical, you’re connecting to the wrong host and you need to immediately disconnect. If it matches, accept the key and continue. Once you accept the fingerprint, the key is saved under your home directory in <em>.ssh/known_hosts</em>.</p>
<p class="indent">If you’re building a new server on your local network for your private use, perhaps you don’t have to manually compare the key fingerprints. You should still copy the key fingerprint, however, since you’ll eventually want to connect from a remote location and will need to verify the key. If many people will connect to a server, it’s generally okay to put the fingerprint on a web page. You must decide how much security you need. I strongly encourage you to err on the side of caution.</p>
<p class="indent">Accept the host key, and you’ll be allowed to log into the server. While using a private key with a passphrase is preferable to using passwords, a password with SSH is still better than telnet.</p>
<h5 class="h5" id="lev890"><span epub:type="pagebreak" id="page_498"/><strong>Copying Files over SSH</strong></h5>
<p class="noindent">The SSH client is fine for command line access, but what about moving files from one system to another? SSH includes two tools for moving files across the network: scp(1) and sftp(1).</p>
<p class="indent">scp(1) is “secure copy” and is ideal for moving individual files. scp takes two arguments: first, the file’s current location; then, the desired location. The desired location is specified as <em>&lt;username&gt;@&lt;hostname&gt;:&lt;filename&gt;</em>. Suppose I want to copy the file <em>bookbackup.tgz</em> from my local system to the remote server <em>mwl.io</em>, giving the remote copy a different name. I’d run:</p>
<pre># <span class="codestrong1">scp bookbackup.tgz mwlucas@mwl.io:bookbackup-january.tgz</span></pre>
<p class="indent">If you want to give the new copy the same name, you can leave off the filename in the second argument:</p>
<pre># <span class="codestrong1">scp bookbackup.tgz mwlucas@mwl.io:</span></pre>
<p class="indent">scp(1) also lets you copy files from a remote system to your local system:</p>
<pre># <span class="codestrong1">scp mwlucas@mwl.io:bookbackup-january.tgz bookbackup.tgz</span></pre>
<p class="indent">If you don’t want to change the filename on the local system, you can use a single dot as the destination name:</p>
<pre># <span class="codestrong1">scp mwlucas@mwl.io:bookbackup.tgz .</span></pre>
<p class="indent">Finally, if your username on the remote system is the same as your local username, you can delete the username and the <code>@</code> sign. For example, to back up my work, I just use:</p>
<pre># <span class="codestrong1">scp bookbackup.tgz mwl.io:</span></pre>
<p class="indent">While this looks complicated, it’s quite useful for quickly moving individual files around the network.</p>
<p class="indent">If you like interactive systems or if you don’t know the precise name of the file you want to grab from a remote server, sftp(1) is your friend. sftp(1) takes a single argument, the username and server name, using scp’s syntax for a remote server:</p>
<pre># <span class="codestrong1">sftp mwlucas@mwl.io</span><br/>Connecting to bewilderbeast...<br/>Password:<br/>sftp&gt; <span class="codestrong1">ls</span></pre>
<p class="indent">The sftp(1) client looks much like a standard command line FTP client; it supports the usual FTP commands, such as <code>ls</code> (list), <code>cd</code> (change directory), <code>get</code> (download a file), and <code>put</code> (upload a file). One important difference is that sftp(1) doesn’t require a choice between ASCII and binary transfers; it just transfers the file as is.</p>
<p class="indent"><span epub:type="pagebreak" id="page_499"/>With SSH, scp, and sftp, you can completely eliminate cleartext passwords from your network.</p>
<div class="sidebar">
<p class="sidebart"><strong>OPENSSH PASSWORDS AND KEYS</strong></p>
<p class="spara">To truly secure your system, use key-based SSH authentication. Creating keys isn’t hard, but deploying them in a way that best suits your environment is more complicated than I can fit in here. Eliminating SSH passwords is the single greatest security improvement you can make in your network.</p>
</div>
<p class="indent">While SSH is the most common sysadmin tool, we’ve just brushed its surface. Time you spend mastering SSH will pay itself back several fold. You can find several good tutorials online and a few decent books, including my own <em>SSH Mastery</em> (Tilted Windmill Press, 2018).</p>
<h3 class="h3" id="lev891"><strong>Email</strong></h3>
<p class="noindent">Running an email server has become vastly more complicated in the last few years. Coping with the spam, viruses, and random crud that arrives on a mail server requires a specialized skill set, and the amount of that crud balloons every year. Think carefully before you deploy a mail server. Every host needs some sort of mail client, however. FreeBSD includes two software suites that can be used for managing local mail and forwarding mail to the mail server: Sendmail and the Dragonfly Mail Agent.</p>
<p class="indent"><em>Sendmail</em> is the great-granddaddy of mail programs. It can be a server, a client, a filter, and an arbitrary mail spindler. If you want to exchange mail with sites so isolated that they communicate once a day over UUCP over a dialup line, and also exchange mail with the latest commercial mail servers, Sendmail is a solid choice. For most of us, though, the Swiss Army Car Crusher of Email is overkill.</p>
<p class="indent">The <em>Dragonfly Mail Agent (DMA)</em> comes from Dragonfly BSD. It’s a very minimal mail client that can deliver mail on the local host or forward it to a mail server. It’s exactly what your average host needs to forward daily status mails to the minion tasked with reading them, to send reports from your application to the application administrator, and to forward all those annoying reports your WordPress security plugin wants you to read.</p>
<p class="indent">We’ll spend some time with DMA. Before we can go there, though, let’s talk about how FreeBSD copes with the world’s multiplicity of mail servers.</p>
<h4 class="h4" id="lev892"><strong><em>mailwrapper(8)</em></strong></h4>
<p class="noindent">For decades, Sendmail was the only mail server available for Unix-like systems. As such, huge amounts of software expects every server to have <em>/usr/sbin/sendmail</em> and expects it to behave exactly like Sendmail. What makes <span epub:type="pagebreak" id="page_500"/>matters worse, Sendmail behaves differently when called by different names. The program mailq(1) is a hard link to sendmail(8), but as it has a different name, it behaves differently. So do newaliases(1), send-mail(8), hoststat(8), and purgestat(8).<sup><a href="footnote.xhtml#ch20fn1" id="ch20fn1a">1</a></sup></p>
<p class="indent">As clients expect to find Sendmail, any replacement mail server must precisely emulate Sendmail, down to this multiname behavior. Using a different mail server isn’t as easy as erasing the Sendmail binaries and replacing them with something else. But people try.</p>
<p class="indent">As a result, sysadmins exploring unfamiliar Unix systems might have no idea what <em>/usr/sbin/sendmail</em> really is! If someone previously installed several different mail servers in an effort to find something less ghastly than Sendmail, you’ll have to resort to detective work and dogged persistence to identify your so-called sendmail(8).</p>
<p class="indent">FreeBSD does an end-run around all this confusion by using a separate mailwrapper(8) program. The mail wrapper directs requests for Sendmail to the preferred mail server, installed elsewhere.</p>
<p class="indent">Configure mailwrapper(8) in <em>/etc/mail/mailer.conf</em>. This file contains a list of program names, along with the paths to the actual programs to be called. Here’s the default <em>mailer.conf</em> directing everything to good old sendmail(8):</p>
<pre>sendmail        /usr/libexec/sendmail/sendmail<br/>send-mail       /usr/libexec/sendmail/sendmail<br/>mailq           /usr/libexec/sendmail/sendmail<br/>newaliases      /usr/libexec/sendmail/sendmail<br/>hoststat        /usr/libexec/sendmail/sendmail<br/>purgestat       /usr/libexec/sendmail/sendmail</pre>
<p class="indent">Each of these six “programs” in the left column is a name that other programs might use for Sendmail. The right column gives the path to the program that should be called instead. Here, we see that Sendmail is installed as <em>/usr/libexec/sendmail/sendmail</em>. If you use an alternative mailer, you must edit <em>mailer.conf</em> to point to the proper path to the mailer programs. Most alternative mailers use separate programs for each of these functions because the cost of disk space has plunged since Sendmail’s birth. When you install an alternative mailer from a package or port, the post-install message usually provides instructions on exactly how to update <em>mailer.conf</em> for your installation. Follow those instructions if you want the new mail server to work. If you install a different mail server without using a package, you need to edit <em>mailer.conf</em> yourself.</p>
<h4 class="h4" id="lev893"><strong><em>The Dragonfly Mail Agent</em></strong></h4>
<p class="noindent">The Dragonfly Mail Agent (DMA) can deliver mail locally and send mail to another server. It can’t receive mail over the network. Where most mail <span epub:type="pagebreak" id="page_501"/>servers bind to TCP port 25 on the local host, dma(8) does not. It delivers mail only for programs that can call <em>/usr/sbin/sendmail</em> or one of its counterparts.</p>
<p class="indent">Before activating DMA, configure it in <em>/etc/dma/dma.conf</em>. This file contains variables you can uncomment and set to a specific value. While DMA has several configurable settings, you should leave most of them at the default.</p>
<h5 class="h5" id="lev894"><strong>Smart Host</strong></h5>
<p class="noindent">A smart host is the actual mail server, the host this client should relay mail through. Use the hostname or IP address.</p>
<pre>SMARTHOST=mail.mwl.io</pre>
<h5 class="h5" id="lev895"><strong>TCP Port</strong></h5>
<p class="noindent">If your mail administrator is a madman that runs the smart host’s email on a nonstandard port, or if you’re trying to evade your ISP’s block port 25 outbound, set the TCP port here:</p>
<pre>PORT 2025</pre>
<p class="indent">If you don’t set a smart host but do set a port, you’ll break mail delivery.</p>
<h5 class="h5" id="lev896"><strong>False Hostname and Usernames</strong></h5>
<p class="noindent">You might want your server to claim to be a different host when it sends mail. Maybe your cloud provider has given this system a hostname composed of random digits and numbers, but you want it to send mail as <em>www.example.com</em>. Use the MAILNAME to set a fake hostname.</p>
<pre>MAILNAME www.mwl.io</pre>
<p class="indent">If you give MAILNAME the full path to a file, dma(8) will use the first line of that file as the hostname.</p>
<p class="indent">Some mail servers very strictly inspect relayed mail and reject inadequately forged messages. For those hosts, you’ll need to use the MASQUERADE option. Masquerading gives you a couple different options for changing messages. If you use an entire email address, all mail sent via dma(8) is rewritten so it comes from that address. If you use a username with an @ sign, such as <code>bert@</code>, all email appears to be coming from that user at the host. A hostname on its own leaves the sending username untouched but changes the hostname.</p>
<pre>MASQUERADE bert@mwl.io</pre>
<p class="indent">Any messages sent from this host appear to be from Bert. Any replies will go to him. All is as it should be.</p>
<h5 class="h5" id="lev897"><span epub:type="pagebreak" id="page_502"/><strong>Disable Local Delivery</strong></h5>
<p class="noindent">Some hosts should never receive mail. No account on the host should ever get mail, not even from other local accounts. Totally disable local mail delivery by uncommenting the NULLCLIENT option.</p>
<h5 class="h5" id="lev898"><strong>Secure Transport</strong></h5>
<p class="noindent">Over the decades, the email protocol has had a whole bunch of different security measures wedged into it. Your mail server might use any or all of them. Speak to your email administrator about what your smart host requires and supports.</p>
<p class="indent">Enable TLS (or SSL, if your mail server is notably awful) by uncommenting the SECURETRANSFER option. You don’t need to set this to a value; its mere presence turns on TLS. If your mail server needs STARTTLS, also uncomment that option. If you want to send mail even if TLS negotiation fails, also uncomment OPPORTUNISTIC_TLS.</p>
<p class="indent">These three options all require the previous options. You can use SECURETRANSFER on its own, STARTTLS and SECURETRANSFER together, or all three. STARTTLS and SECURETRANSFER without their preceding options don’t work.</p>
<p class="indent">If you need a local TLS certificate, set it with the CERTFILE option.</p>
<pre>CERTFILE /etc/ssl/host.crt</pre>
<p class="indent">These options should let you connect to just about any smart host.</p>
<h5 class="h5" id="lev899"><strong>Username and Password</strong></h5>
<p class="noindent">Some smart hosts require clients authenticate with a username and password. Put authentication credentials in the file <em>/etc/dma/auth.conf</em>. Each entry needs the format:</p>
<pre><span class="codeitalic1">user</span>|<span class="codeitalic1">host</span>:<span class="codeitalic1">password</span></pre>
<p class="indent">Suppose my smart host is <em>mail.mwl.io</em>. The username is <em>www1</em>, and the password is <em>BatteryHorseStapleCorrect</em>. My <em>auth.conf</em> would contain:</p>
<pre>www1|mail.mwl.io:BatteryHorseStapleCorrect</pre>
<p class="indent">DMA will use this to log into your host.</p>
<p class="indent">If you want to use a username and password over an unencrypted connection, you must set the INSECURE variable. Sending unencrypted authentication information over the network is a bad idea, but many mail servers are full of bad ideas.</p>
<h5 class="h5" id="lev900"><strong>Enabling DMA</strong></h5>
<p class="noindent">Using DMA requires shutting down any existing Sendmail processes and enabling dma(8) in <em>mailer.conf</em>.</p>
<p class="indent"><span epub:type="pagebreak" id="page_503"/>Sendmail runs as a daemon even when it only handles local delivery. Shut down Sendmail with service(8) or the <em>/etc/rc.d/sendmail</em> script.</p>
<pre># <span class="codestrong1">service sendmail stop</span></pre>
<p class="indent">Make sure it never starts again.</p>
<pre># <span class="codestrong1">sysrc sendmail_enable=NONE</span></pre>
<p class="indent">Now, go to <em>/etc/mail/mailer.conf</em> and point every mail program to dma(8).</p>
<pre>sendmail        /usr/libexec/dma<br/>send-mail       /usr/libexec/dma<br/>mailq           /usr/libexec/dma<br/>newaliases      /usr/libexec/dma<br/>rmail           /usr/libexec/dma</pre>
<p class="indent">DMA has no persistent daemon, so it doesn’t need a startup script.</p>
<p class="indent">Congratulations, you now have a small, simple, effective client mail agent.</p>
<h4 class="h4" id="lev901"><strong><em>The Aliases File and DMA</em></strong></h4>
<p class="noindent">The <em>/etc/mail/aliases</em> file contains redirections for email sent to specific accounts or usernames. Even mail clients and mail agents like DMA use the aliases file. Adding an entry to the aliases file is a good way to locally redirect email.</p>
<p class="indent">While the aliases file has a whole bunch of features, DMA can exercise only a few of them. Features like redirecting email to an arbitrary file don’t work. We’ll discuss the basic functions.</p>
<p class="indent">Open up the aliases file and look around. Each line starts with an alias name or address, followed by a colon and a list of real users to send the email to. We’ll illustrate how aliases work by example.</p>
<h5 class="h5" id="lev902"><strong>Forwarding Email from One User to Another</strong></h5>
<p class="noindent">Someone should always read email sent to the root account. Rather than having that someone log onto every server to read the messages, forward all of root’s email to another email address.</p>
<pre>root: bert@mwl.io</pre>
<p class="indent">I’ve assigned Bert the job of reading all the mail from all the machines.<sup><a href="footnote.xhtml#ch20fn2" id="ch20fn2a">2</a></sup></p>
<p class="indent">Many email addresses don’t have accounts associated with them. For example, the required postmaster address often doesn’t have an account. You can use an alias to forward this to a real account.</p>
<pre>postmaster: root</pre>
<p class="indent"><span epub:type="pagebreak" id="page_504"/>So, postmaster forwards to root, which forwards to Bert. Bert gets all the email for these two addresses.</p>
<p class="indent">The default aliases file contains a variety of standard addresses for internet services, as well as aliases for all of the default FreeBSD service accounts. They all go to root by default. By defining a real address as a destination for your root email, you’ll automatically get all system administration email.</p>
<h5 class="h5" id="lev903"><strong>Aliased Mailing Lists</strong></h5>
<p class="noindent">You can list multiple users to create small mailing lists. This doesn’t scale for dynamic lists, but it’s sufficient for quick and dirty lists.</p>
<pre>escalate: mwlucas@mwl.io, bert@mwl.io, helpdesk@mwl.io</pre>
<p class="indent">The moment you find yourself creating an aliased mailing list is the moment you need to start considering which mailing list solution you’re going to deploy. You’ll need it sooner than you think.</p>
<h3 class="h3" id="lev904"><strong>Network Time</strong></h3>
<p class="noindent">If a database starts entering dates three hours behind, or if emails arrive dated tomorrow, you’ll hear about it pretty quickly. Time is <em>important</em>.<sup><a href="footnote.xhtml#ch20fn3" id="ch20fn3a">3</a></sup> You have two tools to manage system time: tzsetup(8) to control the time zone and ntpd(8) to adjust the clock. Start by setting your time zone manually, and then use network time protocol.</p>
<h4 class="h4" id="lev905"><strong><em>Setting the Time Zone</em></strong></h4>
<p class="noindent">Time zone is easy to manage with tzsetup(8), a menu-driven program that makes the appropriate changes on your system for each time zone. Global organizations might use the default of UTC (Universal Time Clock, previously known as Greenwich Mean Time, currently known as Coordinated Universal Time, soon to be known by Yet Another Name) on their systems, while others use their own local time. Enter <code>tzsetup</code>, follow the geographic prompts, and choose the appropriate time zone for your location. If you know your time zone’s official name, you can set it at the command prompt without going through the prompts.</p>
<pre># <span class="codestrong1">tzsetup America/Detroit</span></pre>
<p class="indent">The tzsetup(8) program copies the relevant time zone file from <em>/usr/share/zoneinfo</em> to <em>/etc/localtime</em>. This is a binary file, and you can’t edit with your average text editor. If the characteristics of your time zone change—for example, the day Daylight Saving Time begins changes—you must <span epub:type="pagebreak" id="page_505"/>upgrade FreeBSD to get the new time zone files and then rerun tzsetup(8) to correctly reconfigure time.</p>
<p class="indent">Users can use the <code>TZ</code> environment variable to set their personal time zone.</p>
<h4 class="h4" id="lev906"><strong><em>Network Time Protocol</em></strong></h4>
<p class="noindent"><em>Network time protocol (NTP)</em> is a method to synchronize time across a network. You can make your local computer’s clock match the atomic clock at your government’s research lab or the time on your main server. Computers that offer time synchronization are called <em>time servers</em> and are roughly lumped into two groups: Tier 1 and Tier 2.</p>
<p class="indent">Tier 1 NTP servers are directly connected to a highly accurate timekeeping device. If you really need this sort of accuracy, then what you really need is your own atomic clock. A USB radio clock such as that found on an inexpensive GPS might look very nice, but USB turns out to be a lousy medium for transferring timing data. Go price a dedicated non-USB GPS receiver, and then choose a Tier 1 NTP server instead.</p>
<p class="indent">Tier 2 NTP servers feed off the Tier 1 NTP servers, providing time service as a public service. Their service is accurate to within a fraction of a second and is sufficient for almost all non–life sustaining applications. Some digging will even lead you to Tier 3 time servers, which feed off of Tier 2 servers.</p>
<p class="indent">The best source of time servers is the list at <em><a href="http://www.pool.ntp.org/">http://www.pool.ntp.org/</a></em>. This group has collected public NTP servers into round-robin DNS pools, allowing easy NTP configuration. These NTP servers are arranged first in a global list, then by continent, and then by country. For example, if you’re in Canada, a brief search on that site leads you to <em>0.ca.pool.ntp.org</em>, <em>1.ca.pool.ntp.org</em>, and <em>2.ca.pool.ntp.org</em>. We’ll use these servers in the following examples, but look up the proper servers for your country and use those instead when setting up your own time service.</p>
<h5 class="h5" id="lev907"><strong>Configuring ntpd(8)</strong></h5>
<p class="noindent">ntpd(8) checks the system clock against a list of time servers. It takes a reasonable average of the times provided by the time servers, discarding any servers too far away from the consensus, and gradually adjusts the system time to match the average. This gives the most accurate system time possible, without demanding too much from any one server, and helps keep errant hardware in check. Configure NTP in <em>/etc/ntpd.conf</em>. Here’s a sample that uses Canadian time servers:</p>
<pre>server 1.ca.pool.ntp.org<br/>server 2.ca.pool.ntp.org<br/>server 3.ca.pool.ntp.org</pre>
<p class="indent">This system checks three time servers for updates. If you list only one server, ntpd(8) slaves its clock to that one server and shares any time problems that server experiences. Using two time servers guarantees that your system won’t know what time it is; remember, NTP takes an average of its <span epub:type="pagebreak" id="page_506"/>time servers but throws out any values too far out of range of the others. How can NTP decide whether one server is wrong when it has only two values to choose from? Using three time servers is optimal; if one server runs amok, ntpd recognizes that the time offered by that server doesn’t make sense against the time offered by the other two servers. (Think of this as a “tyranny of the majority”; the one guy whose opinion differs from the rest doesn’t get any voice at all.)</p>
<h5 class="h5" id="lev908"><strong>ntpd(8) at Boot Time</strong></h5>
<p class="noindent">To have ntpd perform a one-time clock synchronization at boot and then continually adjust the clock afterward, set the following in <em>/etc/rc.conf</em>:</p>
<pre>ntpd_enable="YES"<br/>ntpd_sync_on_start="YES"</pre>
<p class="indent">Ntpd will force correct time immediately on boot and then gently keep the clock synchronized.</p>
<h5 class="h5" id="lev909"><strong>Instant Time Correction</strong></h5>
<p class="noindent">ntpd(8) is great at keeping the system clock accurate over time, but it adjusts the local clock only gradually. If your time is off by hours or days (which isn’t unlikely at install time or after a long power outage), you probably want to set your clock correctly before letting any time-sensitive applications start. ntpd(8) includes that functionality as well, with <code>ntpd -q</code>.</p>
<p class="indent">To perform a single brute-force correction of your clock, use <code>ntpd -q</code>. This connects to your NTP servers, gets the correct time, sets your system clock, and exits.</p>
<pre># <span class="codestrong1">ntpd -q</span><br/>ntpd: time set -76.976809s</pre>
<p class="indent">This system’s time was off by about 77 seconds but is now synchronized with the NTP servers.</p>
<p class="indent">Do not change the clock arbitrarily on a production system. Time-sensitive software, such as many database-driven applications, has problems if time suddenly moves forward or backward.</p>
<p class="indent">If you have really good hardware with an excellent oscillator, using <code>ntpd -q</code> at boot handles all of your time problems. Very few people have that sort of hardware, however. Most of us have to make do with commodity hardware with notoriously poor clocks. The best way to ensure you have accurate time is to run ntpd(8) to gently adjust your clock on an ongoing basis.</p>
<h5 class="h5" id="lev910"><strong>Redistributing Time</strong></h5>
<p class="noindent">While ntpd doesn’t use a large amount of network bandwidth, having every server on your network query the public NTP servers is a waste of network resources—both yours and that of the time-server donors. It can also lead to very slight (subsecond) variances in time on your own network.</p>
<p class="indent"><span epub:type="pagebreak" id="page_507"/>Reliable time servers aren’t virtual machines. Tier 1 NTP servers are all run on real hardware specifically to avoid the clock jittering virtual machines can suffer.</p>
<p class="indent">I recommend setting up three authoritative time servers for your network. Have these servers synchronize their clock with the global NTP pool. Configure each server on your network to point to these servers for NTP updates. That way, every clock on your network will be perfectly synchronized. You won’t have to trawl through NTP logs to try to determine whether a particular server in the global time server pool has somehow messed up your system clock. It’s best to enforce this policy via firewall rules at your network border; allowing only your time server to communicate with outside NTP servers eliminates one common source of temporal chaos.</p>
<h3 class="h3" id="lev911"><strong>Name Service Switching</strong></h3>
<p class="noindent">Any Unix-like system performs innumerable checks of many different name services. We’ve already talked about the Domain Name System that maps hostnames to IP addresses (see <a href="ch07.xhtml#ch07">Chapter 7</a>), but there’s also a password entry lookup service, a TCP/IP port number and name lookup service, an IP protocol name and number lookup service, and so on. You can use <em>/etc/nsswitch.conf</em> to configure how your FreeBSD system makes these queries and what information sources it uses through nsswitch (name service switching).</p>
<p class="indent">Each name service has an <em>nsswitch.conf</em> entry including the type of the service and the information sources it uses. We previously saw an example of name service switching in <a href="ch08.xhtml#ch08">Chapter 8</a>. Remember this entry for host lookups?</p>
<pre>hosts: files dns</pre>
<p class="indent">This means, “Look for IP addresses in the local files first, and then query DNS.” The other information sources work similarly. FreeBSD, like most other Unix-like operating systems, supports name service switching for the information sources listed in <a href="ch20.xhtml#ch20tab1">Table 20-1</a>.</p>
<p class="tabcap" id="ch20tab1"><strong>Table 20-1:</strong> Lookups Supporting Name Service Switching</p>
<table class="topbot-d">
<thead>
<tr>
<td style="vertical-align: top;" class="table-h"><p class="tab_th"><strong>Lookup</strong></p></td>
<td style="vertical-align: top;" class="table-h"><p class="tab_th"><strong>Function</strong></p></td>
</tr>
</thead>
<tbody>
<tr>
<td style="vertical-align: top;" class="table-b"><p class="taba"><code>groups</code></p></td>
<td style="vertical-align: top;" class="table-b"><p class="taba">Group membership checks (<em>/etc/group</em>)</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table-b"><p class="taba"><code>hosts</code></p></td>
<td style="vertical-align: top;" class="table-b"><p class="taba">Hostname and IP checks (DNS and <em>/etc/hosts</em>)</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table-b"><p class="taba"><code>networks</code></p></td>
<td style="vertical-align: top;" class="table-b"><p class="taba">Network entries (<em>/etc/networks</em>)</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table-b"><p class="taba"><code>passwd</code></p></td>
<td style="vertical-align: top;" class="table-b"><p class="taba">Password entries (<em>/etc/passwd</em>)</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table-b"><p class="taba"><code>shells</code></p></td>
<td style="vertical-align: top;" class="table-b"><p class="taba">Checks for valid shells (<em>/etc/shells</em>)</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table-b"><p class="taba"><code>services</code></p></td>
<td style="vertical-align: top;" class="table-b"><p class="taba">TCP and UDP services (<em>/etc/services</em>)</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table-b"><p class="taba"><code>rpc</code></p></td>
<td style="vertical-align: top;" class="table-b"><p class="taba">Remote procedure calls (<em>/etc/rpc)</em></p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table-ba"><p class="taba"><code>proto</code></p></td>
<td style="vertical-align: top;" class="table-ba"><p class="taba">TCP/IP network protocols (<em>/etc/protocols</em>)</p></td>
</tr>
</tbody>
</table>
<p class="indent"><span epub:type="pagebreak" id="page_508"/>Most of these you don’t want to muck with, unless you like breaking system functionality. If you have a Kerberos or an NIS domain, for example, you might want to have your FreeBSD box attach to them for user and group information—but if you don’t, reconfiguring the password lookups would make your system slow at best or entirely stop working at worst!</p>
<p class="indent">For each name service, you must specify one or more sources of information. Many of these name services are very simple and default to having a single authoritative source of information—a file. Others, such as the host’s name service, are more complicated and have multiple sources. A few are very complicated simply because of the vast array of information available and the many possible ways to get that information. As this book doesn’t cover Kerberos, NIS, or any other enterprise-level user management systems, we won’t cover changing password, group, and shell information sources. If you’re in such an environment, read nsswitch.conf(5) for details.</p>
<p class="indent">Most common services have specific valid information sources. <em>Files</em> are the standard text files containing information for the service. For example, network protocols are traditionally stored in <em>/etc/protocols</em>, network services in <em>/etc/services</em>, and passwords in <em>/etc/passwd</em> and friends. A source of <em>dns</em> means that the information is available on a DNS server, as is typical for the hosts service responsible for mapping hostnames to IP addresses. The password service often uses <em>compat</em>, which grants compatibility with <em>/etc/passwd</em> and NIS but could also use <em>files</em>. You might add information sources to the system—for example, enabling LDAP authentication adds the <em>ldap</em> information source.</p>
<p class="indent">List each desired information source in the order you want them to be tried. Our <code>hosts</code> entry tells the name service lookup to try the local file first and then query the DNS server.</p>
<pre>hosts: files dns</pre>
<p class="indent">If you deploy a central authentication scheme like LDAP, you’ll need to add an appropriate entry to tell the host to look up passwords and groups in LDAP. The important question is, should hosts use their local password file and then fall back to LDAP or start with LDAP and fall back to the password file?</p>
<pre>passwd: ldap files</pre>
<p class="indent">Here, we start with LDAP but fall back to the password file if LDAP isn’t available.</p>
<h3 class="h3" id="lev912"><strong>inetd</strong></h3>
<p class="noindent">The inetd(8) daemon handles incoming network connections for less frequently used network services. Most systems don’t have a steady stream of incoming FTP requests, so why have the FTP daemon running all the time? <span epub:type="pagebreak" id="page_509"/>Instead, inetd listens to the network for incoming FTP requests. When an FTP request arrives, inetd(8) starts the FTP server and hands off the request. Other common programs that rely on inetd are telnet, tftp, and POP3.</p>
<p class="indent">Inetd also handles functions so small and rarely used that they’re easier to implement within inetd, rather than route them through a separate program. This includes discard (which dumps any data received into the black hole of <em>/dev/null</em>), chargen (which pours out a stream of characters), and other functions. These days, most of these services are not only not required but often considered harmful. The chargen service, for example, is mostly useful for denial-of-service attacks.</p>
<div class="sidebar">
<p class="sidebart"><strong>INETD SECURITY</strong></p>
<p class="spara">Some sysadmins think of inetd as a single service with a monolithic security profile. Others say that inetd has a bad security history. Neither is exactly true. The inetd server itself is fairly secure, but it absorbs a certain amount of blame for the programs it forwards requests to. Some services that inetd can support, such as ftp, telnet, and so on, are inherently insecure, while others have had a troubled childhood and act out as a result (for example, popper). Treat inetd as you would any other network server program: do not run inetd unless you need it, and then confirm that it offers only trusted and secure programs!</p>
</div>
<h4 class="h4" id="lev913"><strong><em>/etc/inetd.conf</em></strong></h4>
<p class="noindent">Take a look at <em>/etc/inetd.conf</em>. Most daemons have separate IPv4 and IPv6 configurations, but if you’re not running IPv6, you can ignore the IPv6 entries. Let’s look at one entry, the FTP server configuration.</p>
<pre><span class="ent">➊</span>ftp    <span class="ent">➋</span>stream     <span class="ent">➌</span>tcp     <span class="ent">➍</span>nowait     <span class="ent">➎</span>root      <span class="ent">➏</span>/usr/libexec/ftpd     <span class="ent">➐</span>ftpd -l</pre>
<p class="indent">The first field is the service name <span class="ent">➊</span>, which must match a name in <em>/etc/services</em>. inetd performs a service name lookup to identify which TCP port it should listen to. If you want to change the TCP/IP port your FTP server runs on, change the port for FTP in <em>/etc/services</em>. (You could also change the first field to match the service that runs on the desired port, but I find that this makes the entry slightly confusing.)</p>
<p class="indent">The socket type <span class="ent">➋</span> dictates what sort of connection this is. All TCP connections are of type <code>stream</code>, while UDP connections are of type <code>dgram</code>. While you might find other possible values, if you’re considering using them, either you’re reading the documentation for a piece of software that tells you what to use, or you’re just wrong.</p>
<p class="indent"><span epub:type="pagebreak" id="page_510"/>The protocol <span class="ent">➌</span> is the layer 4 network protocol, either <code>tcp</code> (IPv4 TCP), <code>udp</code> (IPv4 UDP), <code>tcp6</code> (IPv6 TCP), or <code>udp6</code> (IPv6 UDP). If your server accepts both IPv4 and IPv6 connections, use the entries <code>tcp46</code> or <code>udp46</code>.</p>
<p class="indent">The next field indicates whether inetd should wait for the server program to close the connection or just start the program and go away <span class="ent">➍</span>. As a general rule, TCP daemons use <code>nowait</code> while UDP daemons need <code>wait</code>. (There are exceptions to this, but they’re rare.) inetd(8) starts a new instance of the network daemon for each incoming request. If a service uses <code>nowait</code>, you can control the maximum number of connections inetd accepts per second by adding a slash and a number directly after <code>nowait</code>, like this: <code>nowait/5</code>. One way intruders (usually script kiddies) try to knock servers off the internet is by opening more requests for a service than the server can handle. By rate-limiting incoming connections, you can stop this. On the other hand, this means that your intruder can stop other people from using the service at all. Choose your poison carefully!</p>
<p class="indent">We then have the user <span class="ent">➎</span> that the server daemon runs as. The FTP server ftpd(8) runs as root, as it must service requests for many system users, but other servers run as dedicated users.</p>
<p class="indent">The sixth field is the full path to the server program inetd runs when a connection request arrives <span class="ent">➏</span>. Services integrated with inetd(8) appear as internal.</p>
<p class="indent">The last field gives the command to start the external program, including any desired command line arguments <span class="ent">➐</span>.</p>
<h4 class="h4" id="lev914"><strong><em>Configuring inetd Servers</em></strong></h4>
<p class="noindent">While <em>/etc/inetd.conf</em> seems to use a lot of information, adding a program is actually pretty simple. The easiest way to learn about inetd(8) is to implement a simple service with it. For example, let’s implement a Quote of the Day (qotd) service. When you connect to the qotd port, the server sends back a random quote and disconnects. FreeBSD includes a random quote generator, fortune(1), in its games collection. This random quote generator is all we need to implement an inetd-based network program. We must specify a port number, a network protocol, a user, a path, and a command line.</p>
<h5 class="h5" id="lev915"><strong>port number</strong></h5>
<p class="noindent">The <em>/etc/services</em> file lists qotd on port 17.</p>
<h5 class="h5" id="lev916"><strong>network protocol</strong></h5>
<p class="noindent">The qotd service requires that you connect to a network port and get something back, so it needs to run over TCP. Remember, UDP is connectionless—a reply isn’t required. We must specify <code>tcp</code> in our inetd configuration, which means that we must specify <code>nowait</code> in the fourth field.</p>
<h5 class="h5" id="lev917"><span epub:type="pagebreak" id="page_511"/><strong>user</strong></h5>
<p class="noindent">Best practice says to create an unprivileged user to run the qotd service, as discussed in <a href="ch19.xhtml#ch19">Chapter 19</a>. For this example, we’ll just use the general unprivileged user nobody, but if you were implementing this in production, you’d want to create an unprivileged user qotd.</p>
<h5 class="h5" id="lev918"><strong>path</strong></h5>
<p class="noindent">Find fortune at <em>/usr/bin/fortune</em>.</p>
<h5 class="h5" id="lev919"><strong>Running the Command</strong></h5>
<p class="noindent">fortune(6) doesn’t require any command line arguments, but you can add them if you like.<sup><a href="footnote.xhtml#ch20fn4" id="ch20fn4a">4</a></sup> On FreeBSD 11, believers in Murphy’s Law can use <code>fortune murphy</code>, while <em>Star Trek</em> fans can get quotes with <code>fortune startrek</code>. (The latter correctly includes only the One True <em>Star Trek</em>, not any of the wannabe followups.) Those interested in education could use <code>fortune freebsd-tips</code>. FreeBSD 12 removes many of the fortune databases, sadly.</p>
<h5 class="h5" id="lev920"><strong>Sample inetd.conf Configuration</strong></h5>
<p class="noindent">Putting this all together, the entry for qotd in <em>/etc/inetd.conf</em> looks like this:</p>
<pre>qotd    stream    tcp    nowait    nobody    /usr/bin/fortune    fortune</pre>
<p class="indent">You might think this example trivial, but providing other services out of inetd(8) is no more difficult.</p>
<h4 class="h4" id="lev921"><strong><em>Starting inetd(8)</em></strong></h4>
<p class="noindent">First, enable inetd(8) at boot by adding the following entry to <em>/etc/rc.conf</em>:</p>
<pre>inetd_enable=YES</pre>
<p class="indent">With this set, start inetd by hand with <code>/etc/rc.d/inetd start</code>. Now that inetd is running, telnet to port 17 to test our new service:</p>
<pre>   # <span class="codestrong1">telnet localhost 17</span><br/><span class="ent">➊</span> Trying 127.0.0.1...<br/>   Connected to localhost.<br/>   Escape character is '^]'.<br/><span class="ent">➋</span> It is difficult to produce a television documentary that is both<br/>   incisive and probing when every twelve minutes one is interrupted by<br/>   twelve dancing rabbits singing about toilet paper.<br/>                   -- Rod Serling<br/>   Connection closed by foreign host.</pre>
<p class="indent"><span epub:type="pagebreak" id="page_512"/>It works! We have the usual TCP/IP connection information <span class="ent">➊</span> and our random fortune <span class="ent">➋</span>. (As an added bonus, you also know why I don’t write for television.)</p>
<h4 class="h4" id="lev922"><strong><em>Changing inetd’s Behavior</em></strong></h4>
<p class="noindent">inetd behaves differently depending on the flags you set for it. The default flags turn on TCP wrappers, as configured in <em>/etc/hosts.allow</em> (see <a href="ch19.xhtml#ch19">Chapter 19</a>). <a href="ch20.xhtml#ch20tab2">Table 20-2</a> lists some of the useful flags.</p>
<p class="tabcap" id="ch20tab2"><strong>Table 20-2:</strong> inetd(8) Flags</p>
<table class="topbot-d">
<thead>
<tr>
<td style="vertical-align: top;" class="table-h"><p class="tab_th"><strong>Flag</strong></p></td>
<td style="vertical-align: top;" class="table-h"><p class="tab_th"><strong>Description</strong></p></td>
</tr>
</thead>
<tbody>
<tr>
<td style="vertical-align: top;" class="table-b"><p class="taba"><code>-l</code></p></td>
<td style="vertical-align: top;" class="table-b"><p class="taba">Log every successful connection.</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table-b"><p class="taba"><code>-c</code></p></td>
<td style="vertical-align: top;" class="table-b"><p class="taba">Set the maximum number of connections per second that can be made to any service. By default, there’s no limit. Note that “unlimited” isn’t the same as “infinite”—your hardware only handles so many connections.</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table-b"><p class="taba"><code>-C</code></p></td>
<td style="vertical-align: top;" class="table-b"><p class="taba">Set the number of times one IP address can connect to a single service in one minute. This connection rate is unlimited by default, but using this can be useful against people trying to monopolize your bandwidth or resources.</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table-b"><p class="taba"><code>-R</code></p></td>
<td style="vertical-align: top;" class="table-b"><p class="taba">Set the maximum number of times any one service can be started in one minute. The default is 256. If you use <code>-R 0</code>, you allow an unlimited number of connections to any one service.</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table-b"><p class="taba"><code>-a</code></p></td>
<td style="vertical-align: top;" class="table-b"><p class="taba">Set the IP address inetd(8) attaches to. By default, inetd listens on all IP addresses attached to the system.</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table-b"><p class="taba"><code>-w</code></p></td>
<td style="vertical-align: top;" class="table-b"><p class="taba">Use TCP wrappers for programs started by inetd(8), as per <em>hosts.allow</em> (see <a href="ch19.xhtml#ch19">Chapter 19</a>).</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table-ba"><p class="taba"><code>-W</code></p></td>
<td style="vertical-align: top;" class="table-ba"><p class="taba">Use TCP wrappers for services integrated with inetd(8), as per <em>hosts.allow</em> (see <a href="ch19.xhtml#ch19">Chapter 19</a>).</p></td>
</tr>
</tbody>
</table>
<p class="indent">As an extreme example, if you want to use TCP wrappers, allow only two connections per second from any single host, allow an unlimited number of service invocations per minute, and listen only on the IP address 203.0.113.2, then you’d set the following in <em>/etc/rc.conf</em>:</p>
<pre>inetd_flags="-Ww -c 2 -R 0 -a 203.0.113.2"</pre>
<p class="indent">With inetd(8), almost anything can be a network service.</p>
<h3 class="h3" id="lev923"><strong>DHCP</strong></h3>
<p class="noindent"><em>Dynamic Host Configuration Protocol (DHCP)</em> is the standard method for handing out IP addresses to client computers. While DHCP services aren’t integrated with FreeBSD out of the box, they’re commonly required to implement such services as diskless workstations. We’ll cover the basics of DHCP configuration here so you can set up your own network.</p>
<p class="indent"><span epub:type="pagebreak" id="page_513"/>These days, every firewall and embedded device has a DHCP server. Why would you need a separate DHCP server? Most of the embedded DHCP servers lack functions needed to run diskless clients, such as network-booted servers and VoIP phones. When they do support such functions, those DHCP servers are often difficult to manage. Services are meant to run on actual servers. We’ll cover enough of DHCP to let you configure your own network clients, including diskless hosts.</p>
<p class="indent">FreeBSD packages include several DHCP servers. The two I like are OpenBSD’s dhcpd and ISC DHCP server. The <em>ISC DHCP server</em> is an industry standard and supports every feature you could possibly want. For small deployments, I recommend OpenBSD’s <em>dhcpd</em>. The OpenBSD folks took ISC DHCP, ripped out all the rarely used features, and made a smaller, simpler server. The configuration file is still one-way compatible; you can run an OpenBSD dhcpd configuration on ISC’s DHCP server without trouble. (The reverse is also true if you’re not using any of the features OpenBSD ripped out of the server.) If you want to run diskless FreeBSD clients, or if you need LDAP integration, switching to the more complex ISC server is fairly straightforward. You can install only one of the two servers.</p>
<p class="indent">The package for either server includes dhcpd(8), the configuration file <em>/usr/local/etc/dhcpd.conf</em>, and extensive man pages.</p>
<div class="sidebar">
<p class="sidebart"><strong>ROGUE DHCP SERVERS</strong></p>
<p class="spara">Each network should have one and only one set of authoritative DHCP information. If you set up your own DHCP server on a network that already has one, such as in your company office, you’ll probably break a whole bunch of clients and trigger a whole bunch of phone calls to the network team. Setting up a “rogue” DHCP server is a great way to have the network team ignore all of your help requests from now until forever.</p>
</div>
<h4 class="h4" id="lev924"><strong><em>How DHCP Works</em></strong></h4>
<p class="noindent">DHCP can be terribly complicated in a large network where we are relaying DHCP requests between offices, but it’s rather simple on a local Ethernet. Each DHCP client sends a broadcast across the local Ethernet asking for someone—anyone—to provide network configuration information. If your DHCP server is on that local Ethernet, it answers directly. If your DHCP server is on another network segment, the router for that network segment needs to know which IP address to forward the DHCP request to. The DHCP server then loans configuration information to the client and tracks which clients have been assigned which IP addresses. A configuration issued to a client is called a <em>lease</em>. Like the lease you pay on a home or auto, DHCP leases expire and must be renewed occasionally.</p>
<p class="indent"><span epub:type="pagebreak" id="page_514"/>The client can request certain features—for example, Microsoft clients ask for the IP address of the WINS server, while diskless systems ask where to find a kernel. You can set all these options as necessary.</p>
<p class="indent">Each client is uniquely identified by the MAC address of the network card used to connect to the network. ISC dhcpd tracks MAC and IP addresses, as well as leases, in the file <em>/var/db/dhcpd.leases</em>. In this file, you can identify which hosts have which IP addresses. If a host disappears from the network for a time and returns, dhcpd(8) reissues the same IP to that client if that IP is still available.</p>
<h4 class="h4" id="lev925"><strong><em>Configuring dhcpd(8)</em></strong></h4>
<p class="noindent">The file <em>/usr/local/etc/dhcpd.conf</em> contains all the configuration for dhcpd. While ISC dhcpd(8) can and does fill entire books on its own, we’ll focus on the functions needed for a basic small office as well as those used in the examples later in this book. The default <em>dhcpd.conf</em> is well commented and includes still more examples, while dhcpd.conf(5) is painfully exhaustive. We’re going to assume that you’re running a single DHCP server on your network, and that your server should answer all requests for DHCP services. (It’s entirely possible to cluster dhcpd for fault tolerance, but that’s beyond our scope here.)</p>
<h5 class="h5" id="lev926"><strong>Global Settings</strong></h5>
<p class="noindent">Start your <em>dhcpd.conf</em> with a few general rules for client configuration. These rules apply to all DHCP clients unless specifically overridden.</p>
<pre><span class="ent">➊</span> option domain-name "mwl.io";<br/><span class="ent">➋</span> option domain-name-servers 198.51.100.2, 198.51.100.3;<br/><span class="ent">➌</span> option subnet-mask 255.255.255.0;<br/><span class="ent">➍</span> default-lease-time 600;<br/><span class="ent">➎</span> max-lease-time 7200;</pre>
<p class="indent">Each DHCP client registers its hostname with the DHCP server, but the client must learn the local domain name from the server. (It’s also possible for the DHCP server to set the client’s hostname.) Set this with the <code>domain-name</code> option <span class="ent">➊</span>. You can give your DHCP clients any domain name you like; they don’t need to share the server’s domain name. You can include multiple domains if you separate them with spaces, but not all operating systems will recognize additional domain names.</p>
<p class="indent">Every TCP/IP client needs a DNS server or two. Specify them with the option <code>domain-name-servers</code> <span class="ent">➋</span>. Separate multiple DNS servers with commas.</p>
<p class="indent">It’s a good idea to set a default subnet mask <span class="ent">➌</span>. Individual networks can override this, but a global default is useful.</p>
<p class="indent">The normal duration of a lease is given (in seconds) by the <code>default-lease-time</code> option <span class="ent">➍</span>. After the lease time runs out, the client requests a new DHCP lease from the DHCP server. DHCP servers commonly default to a small number of minutes, but if your network is fairly <span epub:type="pagebreak" id="page_515"/>stable you can extend this to hours or a couple days. If the client can’t reach the DHCP server, it continues to use the old lease for a number of minutes equal to the maximum life of the lease, specified with <code>max-lease-time</code> <span class="ent">➎</span>. You can think of the maximum lease time as “if my DHCP server fails, this is how long I have to replace it before the phone starts ringing.” Give yourself time to fix the issue.<sup><a href="footnote.xhtml#ch20fn5" id="ch20fn5a">5</a></sup></p>
<p class="indent">Now define subnets.</p>
<h5 class="h5" id="lev927"><strong>Subnet Settings</strong></h5>
<p class="noindent">Each subnet on your network needs a <code>subnet</code> statement to identify configuration information for DHCP clients on that subnet. For example, here’s a network statement for a single small office network:</p>
<pre><span class="ent">➊</span> subnet 198.51.100.0 netmask 255.255.255.0 {<br/>  <span class="ent">➋</span> range 198.51.100.50 198.51.100.99;<br/>  <span class="ent">➌</span> option routers 198.51.100.1;<br/>  }</pre>
<p class="indent">Each subnet declaration starts by identifying the network number and netmask <span class="ent">➊</span> of the subnet. Here, we have a subnet using the IP network number 198.51.100.0 with the netmask 255.255.255.0, or the IP addresses 198.51.100.1 through 198.51.100.255. The information that follows in braces all pertains to hosts on that particular subnet.</p>
<p class="indent">The <code>range</code> keyword <span class="ent">➋</span> identifies the IP addresses that dhcpd(8) may issue to clients. In this example, we have 50 IP addresses available for clients. If 51 DHCP clients connect before any leases expire, the last host won’t get an address.</p>
<p class="indent">Define a default route with the <code>routers</code> option <span class="ent">➌</span>. Note that you can’t define additional routes with dhcpd(8); instead, your local network router needs to have the proper routes to reach the destination. If you have multiple gateways on your local network, your gateway transmits an ICMP redirect to the DHCP client to give it an updated route. (If you have no idea what this means, that’s all right. When you need it, you’ll abruptly comprehend what I’m talking about, and if you never need it, you’ve just wasted the two seconds it took to read this aside.)</p>
<p class="indent">If you have multiple subnets, create multiple subnet statements. Some of those subnets might need settings different than the global defaults, such as a netmask or DNS servers. If so, use those same keywords to define those values for that subnet.</p>
<p class="indent">Dhcpd lets you set anything from the subnet mask, boot servers, and even WINS servers for antediluvian Windows clients. We’ll use some of these less common settings to manage diskless clients in <a href="ch23.xhtml#ch23">Chapter 23</a>. See dhcpd.conf(5) for an exhaustive list.</p>
<h4 class="h4" id="lev928"><span epub:type="pagebreak" id="page_516"/><strong><em>Managing dhcpd(8)</em></strong></h4>
<p class="noindent">Dhcpd defaults to listening to all network interfaces to catch DHCP request broadcasts. I’ve run many DHCP servers with multiple network cards, however, and usually want dhcpd to listen only to a single interface. Give the desired interface as a command line argument.</p>
<pre>sysrc dhcpd_flags="em1"</pre>
<p class="indent">Now enable dhcpd(8) itself.</p>
<pre>sysrc dhcpd_enable=YES</pre>
<p class="indent">You can now fire up dhcpd with <code>service dhcpd start</code>.</p>
<p class="indent">Congratulations, you’re ready to go!</p>
<h3 class="h3" id="lev929"><strong>Printing and Print Servers</strong></h3>
<p class="noindent">Printing on Unix-like operating systems is a topic that makes new sysadmins cry and seasoned sysadmins ramble on about the good old days when printers were TTY devices and about the younger generation not knowing how good they have it.<sup><a href="footnote.xhtml#ch20fn6" id="ch20fn6a">6</a></sup> The most common printing situations are printers directly attached to a computer via a USB port and printers attached to a network print server.</p>
<p class="indent">If you have a printer attached directly to your FreeBSD machine, such as by a USB cable, I suggest using the <em>Common Unix Printing System (CUPS)</em>. This suite of software manages many popular consumer-grade and commercial printers, from lowly inkjets to web-scale laser printers. I’m not going into any detail about CUPS, as it’s complicated and varies by printer model. Learn more about CUPS at <em><a href="http://www.cups.org/">http://www.cups.org/</a></em>. Many brands of printers have special setup programs in CUPS, such as HP’s <code>hp-setup</code>. If your printer supports a network connection, though, try to avoid CUPS and use network printing instead.</p>
<p class="indent">Accessing a remote print server or network printer via the <em>Line Printer Spooler Daemon (LPD)</em> is simple in comparison. LPD takes in PostScript and produces printouts. Most office print servers run LPD. The lpd(8) daemon manages LPD. Most modern networked printers also support LPD and can act as their own print server.</p>
<p class="indent">Test for LPD support by connecting to TCP port 515; if you get a connection, the device speaks LPD.</p>
<pre># <span class="codestrong1">nc -v color-printer 515</span><br/>Connection to color-printer 515 port [tcp/printer] succeeded!</pre>
<p class="indent">This device supports LPD. We can send print jobs to it by configuring <em>/etc/printcap</em>.</p>
<h4 class="h4" id="lev930"><span epub:type="pagebreak" id="page_517"/><strong><em>/etc/printcap</em></strong></h4>
<p class="noindent">Every printer your system knows about needs an entry in <em>/etc/printcap</em>, the printer capability database. This file is, by modern standards, in a rather obtuse format and will look very unfamiliar to anyone who hasn’t previously worked with termcap(5). Fortunately, to access a print server you don’t need to understand printcap(5); you just need to use the following template.</p>
<p class="indent">To connect to a printer on a print server, you must have the print server’s hostname or IP address and its name for the printer you want to access. Make an entry in <em>/etc/printcap</em> following this template. Pay special attention to the colons and backslashes—they’re absolutely vital.</p>
<pre><span class="ent">➊</span> lp|<span class="codeitalic1">printername</span>:\<br/>       <span class="ent">➋</span> :sh=:\<br/>       <span class="ent">➌</span> :rm=<span class="codeitalic1">printservername</span>:\<br/>       <span class="ent">➍</span> :sd=/var/spool/output/lpd/<span class="codeitalic1">printername</span>:\<br/>       <span class="ent">➎</span> :lf=/var/log/lpd-errs:\<br/>       <span class="ent">➏</span> :rp=<span class="codeitalic1">printername</span>:</pre>
<p class="indent">Our first line shows the printer’s name <span class="ent">➊</span>. If you print from LibreOffice or a graphical web browser, these names will show up as printer options. Each printer can have any number of names, separated by the pipe symbol (<code>|</code>). The default printer on any Unix-like system is called <em>lp</em>, so list that as one of the names for your preferred printer. One other name should be the name used by the print server for your printer (for example, <em>3rdFloorPrinter</em>). Be warned, Microsoft print servers frequently share one printer under several different names and use different names to handle printing differently. If you find this to be the case on your network, be sure to choose the PostScript name.<sup><a href="footnote.xhtml#ch20fn7" id="ch20fn7a">7</a></sup></p>
<p class="indent">By default, lpd(8) precedes each print job with a page listing the job name, number, host, and other information. Unless you’re in an environment with a single massive shared printer, this is probably a waste of paper. The <code>:sh:\</code> entry <span class="ent">➋</span> suppresses this page.</p>
<p class="indent">The <code>rm</code> (remote machine) variable <span class="ent">➌</span> provides the hostname of the print server. You must be able to ping this server by the name you give here. If the print server is part of the printer, give the printer’s hostname here.</p>
<p class="indent">Each printer requires a unique spool directory <span class="ent">➍</span>, where the local print daemon can store documents in transit to the print server. This directory must be owned by user <em>root</em> and group <em>daemon</em>.</p>
<p class="indent">Unlike spool directories, which must be different, printers can share a common log file <span class="ent">➎</span>.</p>
<p class="indent">Finally, specify the remote printer name <span class="ent">➏</span>, as the print server identifies it. If you’re connecting directly to a printer, not to a central print server, you can skip this entry—but you must get rid of the trailing slash on the previous line.</p>
<p class="indent">Be sure you end <em>/etc/printcap</em> with a new line; don’t just terminate the file immediately after the printer name. Also, note that unlike every other entry in this template, the last line doesn’t require a trailing backslash.</p>
<p class="indent"><span epub:type="pagebreak" id="page_518"/>Printers have dozens and dozens of options, from the cost per page to manually setting a string to feed a new sheet of paper. Most of these are obsolete today. If you have an older printer or special needs, though, consult printcap(5) for enough glorious detail to choke on.</p>
<h4 class="h4" id="lev931"><strong><em>Enabling LPD</em></strong></h4>
<p class="noindent">Set <code>lpd_enable</code> to <code>YES</code> in <em>/etc/rc.conf</em> to have lpd(8) start at boot. Any time you edit <em>/etc/printcap</em> you must restart lpd(8). View the print queue with lpq(1) and watch for any problems in <em>/var/log/lpd-errs</em>.</p>
<h3 class="h3" id="lev932"><strong>TFTP</strong></h3>
<p class="noindent">Let’s end our discussion of small network services with perhaps the smallest network service still used, the <em>Trivial File Transfer Protocol (TFTP)</em>. TFTP lets you transfer files from machine to machine without any authentication whatsoever. It’s also much less flexible than file copy protocols, such as SCP or FTP. TFTP is still used by makers of embedded devices, such as Cisco, to load system configurations and operating system updates. We cover it here only because diskless clients use TFTP to download their operating system kernel and get their initial configuration information. Run tftpd(8) out of inetd(8) on TCP port 69.</p>
<div class="sidebar">
<p class="sidebart"><strong>TFTP SECURITY</strong></p>
<p class="spara">TFTP isn’t suitable for use on the public internet. Anyone can read or write files on a TFTP server! Only use TFTP behind a firewall or at least protect it tightly with TCP wrappers (see <a href="ch19.xhtml#ch19">Chapter 19</a>).</p>
</div>
<p class="indent">Setting up a tftpd(8) server involves four steps: choosing a root directory for your server, creating files for the server, choosing an owner for your files, and running the server process.</p>
<h4 class="h4" id="lev933"><strong><em>Root Directory</em></strong></h4>
<p class="noindent">The tftpd(8) daemon defaults to using the directory <em>/tftpboot</em>. This might be suitable if you have only a couple files that you rarely access, but the root partition is best reserved for files that don’t change often. You don’t want a TFTP upload to crash your system by filling the root partition! If you’re running ZFS, create a tftp dataset. On UFS, I usually put my tftpd(8) root directory in <em>/var/tftpboot</em> and add a symlink to <em>/tftpboot</em>:</p>
<pre># <span class="codestrong1">mkdir /var/tftpboot</span><br/># <span class="codestrong1">ln -s /var/tftpboot /tftpboot</span></pre>
<p class="indent"><span epub:type="pagebreak" id="page_519"/>Now you can create files for access via TFTP.</p>
<h4 class="h4" id="lev934"><strong><em>tftpd and Files</em></strong></h4>
<p class="noindent">Users can both read and write files via TFTP. If you want tftpd(8) users to be able to read a file, the file must be world-readable:</p>
<pre># <span class="codestrong1">chmod +r /var/tftproot/</span><span class="codestrongitalic1">filename</span></pre>
<p class="indent">Similarly, tftpd(8) won’t allow anyone to upload a file unless a file of that name already exists and is world-writable. Remember, programs and regular files have different permissions. A program must have execute permissions in addition to read and write permissions, so you must set permissions differently for programs and files. You can use touch(1) to precreate files that you’ll want to upload via TFTP.</p>
<pre># <span class="codestrong1">chmod 666 /var/tftproot/</span><span class="codestrongitalic1">filename</span><br/># <span class="codestrong1">chmod 777 /var/tftproot/</span><span class="codestrongitalic1">programname</span></pre>
<p class="indent">Yes, this means that anyone who knows a file’s name can overwrite the contents of that file. Make vital files read-only.<sup><a href="footnote.xhtml#ch20fn8" id="ch20fn8a">8</a></sup> This also means you don’t have to worry about someone uploading a big file and filling your hard drive.</p>
<h4 class="h4" id="lev935"><strong><em>File Ownership</em></strong></h4>
<p class="noindent">Files in a TFTP server should be owned by a user with the least possible privilege. If you run a TFTP server only intermittently, you can use the nobody user. For example, if you need the TFTP server only to perform the occasional embedded device upgrade, let the nobody user own your files and just turn tftpd(8) off when it’s not needed. If you run a permanent TFTP server, however, it’s best to have a dedicated tftp unprivileged user to own the files. The tftp user doesn’t need to own the <em>tftproot</em> directory and, in fact, should have an entirely different home directory. He needs ownership only of the files available to users.</p>
<h4 class="h4" id="lev936"><strong><em>tftpd(8) Configuration</em></strong></h4>
<p class="noindent">tftpd(8) is configured entirely through command line arguments, and there aren’t many of them. For a full list, read tftpd(8), but here are the most commonly used ones.</p>
<p class="indent">If you create a user just to run tftpd(8), specify that user with the <code>-u</code> argument. If you don’t specify a user, tftpd(8) runs as nobody. Create an unprivileged user.</p>
<p class="indent">I recommend logging all requests to your TFTP daemon. The <code>-l</code> argument turns on logging. tftpd(8) uses the <code>FTP</code> facility, which you must enable in <em>syslog.conf</em> (see <a href="ch21.xhtml#ch21">Chapter 21</a>).</p>
<p class="indent"><span epub:type="pagebreak" id="page_520"/>Tftpd supports chrooting with the <code>-s</code> flag. This lets you confine tftpd(8) to your selected directory. You don’t want users to TFTP world-readable files such as <em>/etc/passwd</em>, or even <em>/boot/kernel/kernel</em>, just on general principle! Always chroot your tftpd(8) installation.</p>
<p class="indent">You can chroot TFTP clients by IP address with the <code>-c</code> argument. In this case, you must create a directory for every client permitted to connect. For example, suppose the only host you want to give TFTP access to is your router, with the IP address of 192.168.1.1. You could create a directory <em>/var/tftproot/192.168.1.1</em> and use <code>-c</code>. You must also use <code>-s</code> to define the base directory of <em>/var/tftproot</em>. This is a good compromise when you must offer TFTP to only one or two hosts, but you don’t want the world to have access to your TFTP server.</p>
<p class="indent">You can choose to allow a client to write new files to your TFTP server. This is a bad idea because it lets remote users fill up your hard disks with arbitrary files. If you must have this functionality, use the <code>-w</code> flag.</p>
<p class="indent">For example, suppose you want to log all requests to tftpd, chroot to <em>/var/tftpboot</em>, run the server as the user tftpd, and chroot clients by IP address. The command to run tftpd would look like this:</p>
<pre>tftpd -l -u tftpd -c -s /var/tftpboot</pre>
<p class="indent">Enter this into <em>inetd.conf</em> as described earlier this chapter, restart inetd(8), and you’re in business!</p>
<h3 class="h3" id="lev937"><strong>Scheduling Tasks</strong></h3>
<p class="noindent">The FreeBSD job scheduler, cron(8), allows the administrator to have the system run any command on a regular basis. Combined with the system maintenance scheduling system, periodic(8), you can schedule almost anything.</p>
<h4 class="h4" id="lev938"><strong><em>cron(8)</em></strong></h4>
<p class="noindent">If you need to back up your database nightly or reload the nameserver four times a day, cron is your friend. cron(8) configuration files are called <em>crontabs</em> and are managed with crontab(1). Every user has a separate crontab stored in <em>/var/cron/tabs</em>, and the global crontab file is <em>/etc/crontab</em>. Global cron entries can also be placed in <em>/etc/cron.d</em> and will be run as if they were part of <em>/etc/crontab</em>.</p>
<h5 class="h5" id="lev939"><strong>User Crontabs vs. /etc/crontab</strong></h5>
<p class="noindent">The purpose of <em>/etc/crontab</em> is different from that of individual users’ crontabs. With <em>/etc/crontab</em>, root may specify which user will run a particular command. For example, in <em>/etc/crontab</em>, the sysadmin can say, “Run this job at 10 <small>PM</small> Tuesdays as root, and run this other job at 7 <small>AM</small> as <em>www</em>.” Other users can run jobs only as themselves. Of course, root can also edit a user’s crontab.</p>
<p class="indent"><span epub:type="pagebreak" id="page_521"/>Also, any system user can view <em>/etc/crontab</em>. If you have a scheduled job that you don’t want users to know about, place it in a user crontab. For example, if you have an unprivileged user for your database, use that unprivileged user’s crontab to run database maintenance jobs.</p>
<p class="indent"><em>/etc/crontab</em> is considered a FreeBSD system file. Don’t overwrite it when you upgrade! One way to simplify upgrading <em>/etc/crontab</em> is to set your custom entries at the end of the file, marked off with a few lines of hash marks (<code>#</code>). The <em>/etc/crontab</em> file must end with a new line, or the last line won’t get parsed and run. That’s fine if your last entry is a comment, but not so good if it’s a command.</p>
<p class="indent">Finally, while you edit <em>/etc/crontab</em> with a text editor, edit a user crontab with <code>crontab -e</code>.</p>
<h5 class="h5" id="lev940"><strong>cron and Environment</strong></h5>
<p class="noindent">Crontabs run in a shell, and programs might require environment variables to run correctly. You can also specify environment variables on the command line for each command you run from cron. cron doesn’t inherit any environment variables from anywhere; any environment variables a program needs must be specified in the crontab. For example, here’s the environment from <em>/etc/crontab</em> on a FreeBSD 12 system:</p>
<pre>SHELL=/bin/sh<br/>PATH=/etc:/bin:/sbin:/usr/bin:/usr/sbin</pre>
<p class="indent">Yes, this is extremely minimal! Feel free to add environment variables as needed to user crontabs, but be conservative when changing <em>/etc/crontab</em>. If you need a custom environment variable, it’s safest to use a user crontab rather than <em>/etc/crontab</em> because many of the commands in <em>/etc/crontab</em> are for core system maintenance.</p>
<h5 class="h5" id="lev941"><strong>Crontab Format</strong></h5>
<p class="noindent">Beneath the environment statements, a user crontab is divided into six columns. The first five columns represent the time the command should run, as minute, hour, day of the month, month of the year, and day of the week, in that order. An asterisk (<code>*</code>) in any column means <em>every one</em>, while a number means <em>at this exact time</em>. Minutes, hours, and days of the week begin with 0, and days of the month and months begin with 1. Also, thanks to an ancient disagreement between AT&amp;T and BSD, Sunday can be represented by either 7 or 0. After the time, list the command to be run at that time.</p>
<p class="indent">The <em>/etc/crontab</em> file, and files under <em>/etc/cron.d</em>, have one extra column: the user under which to run the command. It goes between the time specification and the command itself. Check out the many examples in <em>/etc/crontab</em> if you like.</p>
<h5 class="h5" id="lev942"><span epub:type="pagebreak" id="page_522"/><strong>Sample Crontabs</strong></h5>
<p class="noindent">Assume that we’re editing the crontab of an unprivileged user to schedule maintenance of a program. As <em>/etc/crontab</em> has column headings at the top, we’ll demonstrate user crontabs here. (To use these examples in <em>/etc/crontab</em>, just add the user before the command.) Here, we want to run the program <em>/usr/local/bin/maintenance.sh</em> at 55 minutes after each hour, every single hour:</p>
<pre>55    *    *    *    *    /usr/local/bin/maintenance.sh</pre>
<p class="indent">Asterisks tell cron to run this job every hour, on every day of the month, every month, and on every weekday. The <code>55</code> tells cron to run this job only at minute 55.</p>
<p class="indent">To run the same job at 1:55 <small>PM</small> every day, use the following:</p>
<pre>55    13    *    *    *    /usr/local/bin/maintenance.sh</pre>
<p class="indent">Here, <code>13</code> represents 1:00 <small>PM</small> on the 24-hour clock, and <code>55</code> is the number of minutes past that hour.</p>
<p class="indent">One common mistake people make when using cron is specifying a large unit of time but missing the small one. For example, suppose you want to run the job every day at 8 <small>AM</small>:</p>
<pre>*    8    *    *    *    /usr/local/bin/maintenance.sh</pre>
<p class="indent">This is wrong. Yes, the job will run at 8:00 <small>AM</small>. It will also run at 8:01, 8:02, 8:03, and so on, until 9 <small>AM</small>. If your job takes more than one minute to run, you’ll quickly bring your system to its knees. The correct way to specify 8:00 <small>AM</small>, and only 8:00 <small>AM</small>, is this:</p>
<pre>0    8    *    *    *    /usr/local/bin/maintenance.sh</pre>
<p class="indent">To specify ranges of time, such as running the program once an hour, every hour, between 8 <small>AM</small> and 6 <small>PM</small>, Monday through Friday, use something like this:</p>
<pre>55    8-18    *    *    1-5    /usr/local/bin/maintenance.sh</pre>
<p class="indent">To specify multiple exact times, separate them with commas:</p>
<pre>55    8,10,12,14,16    *    *    *    /usr/local/bin/maintenance.sh</pre>
<p class="indent">More interestingly, you can specify fractions of time, or <em>steps</em>. For example, to run a program every 5 minutes, use:</p>
<pre>*/5    *    *    *    *    /usr/local/bin/maintenance.sh</pre>
<p class="indent"><span epub:type="pagebreak" id="page_523"/>You can combine ranges with steps. To run the program every 5 minutes, but 1 minute after the previous example, use this:</p>
<pre>1-56/5    *    *    *    *    /usr/local/bin/maintenance.sh</pre>
<p class="indent">Control the day a job runs with two fields: the day of the month and the day of the week. If you specify both, the job will run whenever <em>either</em> condition is met. For example, tell cron to run a job on the 1st and the 15th of every month, plus every Monday, as follows:</p>
<pre>55    13    *    1,15    1    /usr/local/bin/maintenance.sh</pre>
<p class="indent">If your job has a nonstandard environment, set the environment on the command line just as you would in the shell. For example, if your program requires a <code>LD_LIBRARY_PATH</code> environment variable, you can set it thus:</p>
<pre>55    *    *    *    *    LD_LIBRARY_PATH=/usr/local/mylibs ; /usr/local/bin/maintenance.sh</pre>
<p class="indent">cron also supports special scheduling, such as <em>annually</em> or <em>daily</em>, with the <code>@</code> symbol. Most of these terms are best not used, as they can be ambiguous. While the machine knows exactly what they mean, humans tend to misunderstand! One useful crontab entry is for <em>whenever the system boots</em>, which is <code>@</code><code>reboot</code>. This lets an unprivileged user run jobs when the system boots. Use the <code>@reboot</code> label instead of the time fields:</p>
<pre>@reboot    /usr/local/bin/maintenance.sh</pre>
<p class="indent">Crontabs and cron(8) let you schedule your work any way you like, eliminating the human being from many routine maintenance tasks.</p>
<h4 class="h4" id="lev943"><strong><em>periodic(8)</em></strong></h4>
<p class="noindent">Some system maintenance jobs should be run only on particular systems, but the way they should be run is identical across all hosts. That’s where periodic(8) comes in.</p>
<p class="indent">The periodic(8) command runs system functions on schedule, as cron(8) determines. Periodic checks a directory for a set of scripts to run. FreeBSD includes several directories for periodic tasks: <em>/etc/periodic/daily</em>, <em>/etc/periodic/weekly</em>, <em>/etc/periodic/monthly</em>, and <em>/etc/periodic/security</em>. Depending on which packages you install, you might have corresponding directories in <em>/usr/local/etc/periodic</em>. When cron runs, say, periodic daily, periodic(8) checks each script in each <em>periodic/daily</em> directory to see whether it should be run.</p>
<p class="indent">When you have spare time, I recommend perusing the periodic(8) scripts. You might find disabled maintenance scripts useful for your environment.</p>
<p class="indent">Which scripts should be run? The default settings are listed in <em>/etc/defaults/periodic.conf</em>, but you can override them in <em>/etc/periodic.conf</em>.</p>
<p class="indent">Once periodic(8) runs, it mails the results of the scripts to root on the local machine. Forward root’s mail to someone who will actually read it.</p>
<p class="indent"><span epub:type="pagebreak" id="page_524"/>Why use periodic(8)? It’s all for system maintenance. <em>/etc/crontab</em> is for configuring your own system administration jobs. Using separate scripts allows the system upgrade process to replace tasks and packages to add and remove them.</p>
<p class="indent">All periodic(8) jobs run as root, though. If you have scheduled jobs that should be run by less privileged users, run them from the user’s crontab.</p>
<p class="indent">Now that you have a decent understanding of the common small services provided by FreeBSD, let’s go on to performance.</p>
</body></html>