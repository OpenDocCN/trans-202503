- en: '**6'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '**6'
- en: KERNEL GAMES**
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: KERNEL GAMES**
- en: '![image](../images/common01.jpg)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/common01.jpg)'
- en: If you’re new to Unix administration, the word *kernel* might intimidate you.
    After all, the kernel is one of those secret parts of a computer that mere mortals
    are not meant to dabble in. In some versions of Unix, kernel tampering is unthinkable.
    Microsoft doesn’t advertise that its operating systems even have kernels, which
    is like glossing over the fact that human beings have brains.^([1](footnote.xhtml#ch06fn1))
    While high-level users can access the kernel through a variety of methods, this
    isn’t widely acknowledged or encouraged. In many parts of the open source Unix-like
    world, however, meddling with the kernel is a very viable and expected way to
    change system behavior. It would probably be an excellent way to adjust other
    operating systems, if you were allowed to do so.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你是Unix管理的新手，*内核*这个词可能会让你感到害怕。毕竟，内核是计算机中的一些神秘部分，普通人不应该轻易触碰。在某些版本的Unix中，篡改内核是不可想象的。微软甚至不宣传它的操作系统有内核，这就像忽略了人类有大脑这一事实一样。^([1](footnote.xhtml#ch06fn1))
    虽然高级用户可以通过各种方法访问内核，但这并不被广泛承认或鼓励。然而，在许多开源类Unix的世界中，干预内核是改变系统行为的一种非常可行且预期的方式。如果你被允许这样做，这可能也是调整其他操作系统的一个极好方式。
- en: The FreeBSD kernel can be dynamically tuned or changed on the fly, and most
    aspects of system performance can be adjusted as needed. We’ll discuss the kernel’s
    sysctl interface and how you can use it to alter a running kernel.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: FreeBSD的内核可以动态调节或随时更改，大多数系统性能的方面可以根据需要进行调整。我们将讨论内核的sysctl接口，以及如何使用它来更改正在运行的内核。
- en: At the same time, some parts of the kernel can be altered only while the system
    is in the early stages of booting. The boot loader lets you adjust the kernel
    before the host even finds its filesystems.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 同时，内核的某些部分只能在系统启动的早期阶段进行修改。引导加载程序允许你在主机甚至没有找到其文件系统之前调整内核。
- en: Some kernel features require extensive reconfiguration. You can custom-build
    kernels for really tiny systems or build a kernel tuned precisely for the hardware
    you’re running. The best way to do this is to build your own kernel.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 一些内核特性需要大量的重新配置。你可以为非常小的系统定制内核，或者为你正在运行的硬件精确调整一个内核。做到这一点的最佳方法是自己构建内核。
- en: FreeBSD has a modular kernel, meaning that entire chunks of the kernel can be
    loaded or unloaded from the operating system, turning entire subsystems on or
    off as desired. This is highly useful in this age of removable hardware, such
    as PC cards and USB devices. Loadable kernel modules can impact performance, system
    behavior, and hardware support.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: FreeBSD有一个模块化的内核，这意味着可以将整个内核部分加载或卸载，从操作系统中打开或关闭整个子系统。这在如今可拆卸硬件时代非常有用，例如PC卡和USB设备。可加载的内核模块会影响性能、系统行为和硬件支持。
- en: Finally, we’ll cover basic debugging of your kernel, including some of the scary-looking
    messages it gives out as well as when and how to boot alternate kernels.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将讨论如何调试你的内核，包括一些看起来可怕的错误信息，以及何时以及如何启动备用内核。
- en: '**What Is the Kernel?**'
  id: totrans-9
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**什么是内核？**'
- en: 'You’ll hear many different definitions of a kernel. Many are just flat-out
    confusing, some are technically correct but bewilder the novice, while others
    are wrong. The following definition isn’t complete, but it’ll do for most people
    most of the time and it’s comprehensible: *the kernel is the interface between
    the hardware and the software*.'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 你会听到很多关于内核的不同定义。许多定义完全令人困惑，有些技术上是正确的，但让初学者感到困惑，而其他的则是错误的。以下的定义并不完整，但对于大多数人来说，它足够简单易懂：*内核是硬件和软件之间的接口*。
- en: The kernel lets the software write data to disk drives and to the network. When
    a program wants memory, the kernel handles all the low-level details of accessing
    the physical memory chip and allocating resources for the job. Once your MP3 file
    passes through the codec software, the kernel translates the codec output into
    a stream of zeros and ones that your particular sound card understands. When a
    program requests CPU time, the kernel schedules a time slot for it. In short,
    the kernel provides all the software interfaces that programs need in order to
    access hardware resources.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 内核让软件可以将数据写入磁盘驱动器和网络。当一个程序需要内存时，内核负责处理访问物理内存芯片和为该任务分配资源的所有底层细节。一旦你的MP3文件通过编解码器软件，内核将编解码器输出转换为你的特定声卡能够理解的零和一的流。当一个程序请求CPU时间时，内核会为其安排一个时间槽。简而言之，内核提供了程序访问硬件资源所需的所有软件接口。
- en: While the kernel’s job is easy to define (at least in this simplistic manner),
    it’s actually a complicated task. Different programs expect the kernel to provide
    different interfaces to the hardware, and different types of hardware provide
    interfaces differently. For example, FreeBSD supports a few dozen families of
    Ethernet cards, each with its own requirements that the kernel must handle. If
    the kernel can’t talk to the network card, the system isn’t on the network. Different
    programs request memory to be arranged in different ways, and if you have a program
    that requests memory in a manner the kernel doesn’t support, you’re out of luck.
    The way your kernel investigates some hardware during the boot sequence defines
    how the hardware behaves, so you have to control that. Some devices identify themselves
    in a friendly manner, while others lock up if you dare to ask them what they’re
    for.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然内核的工作定义起来很简单（至少在这种简化的方式下），但实际上它是一项复杂的任务。不同的程序期望内核提供不同的硬件接口，而不同类型的硬件以不同的方式提供接口。例如，FreeBSD
    支持几打种类的以太网卡，每种卡都有自己的要求，内核必须处理这些要求。如果内核无法与网卡通信，系统就无法联网。不同的程序请求以不同的方式安排内存，如果你有一个请求内核不支持的内存安排方式的程序，那你就倒霉了。内核在启动序列中如何检查某些硬件，决定了硬件的行为方式，所以你必须控制这一点。有些设备以友好的方式自我标识，而有些则在你询问它们的功能时会锁死。
- en: The kernel and any modules included with FreeBSD are files in the directory
    */boot/kernel*. Third-party kernel modules go in */boot/modules*. Files elsewhere
    in the system are not part of the kernel. Nonkernel files are collectively called
    the *userland*, meaning they’re intended for users even if they use kernel facilities.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 内核和 FreeBSD 附带的任何模块都是 */boot/kernel* 目录中的文件。第三方内核模块放在 */boot/modules* 中。系统中的其他文件不是内核的一部分。非内核文件统称为
    *userland*，意味着它们是为用户准备的，即使它们使用内核的功能。
- en: Since a kernel is just a set of files, you can have alternative kernels on hand
    for special situations. On systems where you’ve built your own kernel, you will
    find */boot/kernel.old*, a directory containing the kernel that was installed
    before your current kernel. I habitually copy the kernel installed with the system
    into */boot/kernel.install*. You can also create your own special kernels. The
    FreeBSD team makes configuring and installing kernels as simple as possible. The
    simplest and best-supported way to alter a kernel is through the sysctl interface.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 由于内核只是文件集合，你可以为特殊情况准备备用内核。在你自己构建内核的系统中，你会找到 */boot/kernel.old*，这是一个目录，包含了当前内核之前安装的内核。我习惯性地将与系统一起安装的内核复制到
    */boot/kernel.install*。你也可以创建自己的特殊内核。FreeBSD 团队使得配置和安装内核尽可能简单。改变内核最简单且最有支持的方式是通过
    sysctl 接口。
- en: '**Kernel State: sysctl**'
  id: totrans-15
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**内核状态：sysctl**'
- en: The sysctl(8) program allows you to peek at the values used by the kernel and,
    in some cases, to set them. Just to make things more confusing, these values are
    also sometimes known as *sysctls*. The sysctl interface is a powerful feature
    because, in many cases, it will let you solve performance issues without rebuilding
    the kernel or reconfiguring an application. Unfortunately, this power also gives
    you the ability to sweep the legs out from under a running program and make your
    users really, really unhappy.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: sysctl(8) 程序允许你查看内核使用的值，并在某些情况下设置它们。更复杂的是，这些值有时也被称为 *sysctl*。sysctl 接口是一个强大的功能，因为在许多情况下，它可以让你解决性能问题，而无需重建内核或重新配置应用程序。不幸的是，这种能力也让你有可能将正在运行的程序“踢倒”，并让你的用户非常不高兴。
- en: The sysctl(8) program handles all sysctl operations. Throughout this book, I’ll
    point out how particular sysctls change system behavior, but first, you need to
    understand sysctls in general. Start by grabbing all the human-visible sysctls
    on your system and saving them to a file so you can study them easily.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: sysctl(8) 程序处理所有的 sysctl 操作。在本书中，我将指出特定的 sysctl 如何改变系统行为，但首先，你需要一般性地了解 sysctl。开始时，先抓取你系统中所有对人类可见的
    sysctl，并将它们保存到一个文件中，以便你可以轻松地进行研究。
- en: '[PRE0]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The file *sysctl.out* now contains hundreds of sysctl variables and their values,
    most of which will look utterly meaningless. A few of them, however, you can interpret
    without knowing much:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 文件 *sysctl.out* 现在包含了数百个 sysctl 变量及其值，其中大部分看起来毫无意义。然而，你可以理解其中一些，而无需了解太多内容：
- en: '[PRE1]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: This particular sysctl, called `kern.hostname`, has the value `storm`. Oddly
    enough, the system I ran this command on has a hostname of *storm*, and the sysctl
    hints that this is the kernel’s name for the system it’s running on. See these
    sysctls with the `-a` flag. Most sysctls are meant to be read this way, but a
    few, called *opaque sysctls*, can only be interpreted by userland programs. Show
    opaque sysctls with the `-o` flag.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 这个特定的sysctl，叫做`kern.hostname`，其值为`storm`。奇怪的是，我运行该命令的系统的主机名也是*storm*，而且该sysctl提示这是内核为其运行的系统指定的名称。使用`-a`标志查看这些sysctl。大多数sysctl都应该以这种方式读取，但有一些被称为*不透明sysctl*，只能由用户态程序解读。使用`-o`标志显示不透明的sysctl。
- en: '[PRE2]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: I could guess that the variable `net.local.stream.pcblist` represents something
    for the network stack. I can’t even guess what the value means. Userland programs
    like netstat(1) pull information from these opaque sysctls.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 我可以猜测变量`net.local.stream.pcblist`代表了网络栈中的某些内容，但我甚至无法猜测其值的含义。像`netstat(1)`这样的用户态程序从这些不透明的sysctl中获取信息。
- en: '***sysctl MIBs***'
  id: totrans-24
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***sysctl MIBs***'
- en: The sysctls are organized in a tree format called a *management information
    base (MIB)* with several broad categories, such as net (network), kern (kernel),
    and vm (virtual memory). [Table 6-1](ch06.xhtml#ch06tab1) lists the roots of the
    sysctl MIB tree on a system running the GENERIC kernel.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 这些sysctl以树状格式组织，称为*管理信息库（MIB）*，包含多个大类，如net（网络）、kern（内核）和vm（虚拟内存）。[表6-1](ch06.xhtml#ch06tab1)列出了在运行GENERIC内核的系统上sysctl
    MIB树的根节点。
- en: '**Table 6-1:** Roots of the sysctl MIB Tree'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '**表6-1：** sysctl MIB树的根节点'
- en: '| **sysctl** | **Function** |'
  id: totrans-27
  prefs: []
  type: TYPE_TB
  zh: '| **sysctl** | **功能** |'
- en: '| --- | --- |'
  id: totrans-28
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `kern` | Core kernel functions and features |'
  id: totrans-29
  prefs: []
  type: TYPE_TB
  zh: '| `kern` | 核心内核功能和特性 |'
- en: '| `vm` | Virtual memory system |'
  id: totrans-30
  prefs: []
  type: TYPE_TB
  zh: '| `vm` | 虚拟内存系统 |'
- en: '| `vfs` | Filesystem |'
  id: totrans-31
  prefs: []
  type: TYPE_TB
  zh: '| `vfs` | 文件系统 |'
- en: '| `net` | Networking |'
  id: totrans-32
  prefs: []
  type: TYPE_TB
  zh: '| `net` | 网络 |'
- en: '| `debug` | Debugging |'
  id: totrans-33
  prefs: []
  type: TYPE_TB
  zh: '| `debug` | 调试 |'
- en: '| `hw` | Hardware |'
  id: totrans-34
  prefs: []
  type: TYPE_TB
  zh: '| `hw` | 硬件 |'
- en: '| `machdep` | Machine-dependent settings |'
  id: totrans-35
  prefs: []
  type: TYPE_TB
  zh: '| `machdep` | 机器相关设置 |'
- en: '| `user` | Userland interface information |'
  id: totrans-36
  prefs: []
  type: TYPE_TB
  zh: '| `user` | 用户态接口信息 |'
- en: '| `p1003_1b` | POSIX behavior |'
  id: totrans-37
  prefs: []
  type: TYPE_TB
  zh: '| `p1003_1b` | POSIX行为 |'
- en: '| `kstat` | Kernel statistics |'
  id: totrans-38
  prefs: []
  type: TYPE_TB
  zh: '| `kstat` | 内核统计信息 |'
- en: '| `dev` | Device-specific information |'
  id: totrans-39
  prefs: []
  type: TYPE_TB
  zh: '| `dev` | 设备特定信息 |'
- en: '| `security` | Security-specific kernel features |'
  id: totrans-40
  prefs: []
  type: TYPE_TB
  zh: '| `security` | 特定于安全的内核功能 |'
- en: 'Each of these categories is divided further. For example, the `net` category,
    covering all networking sysctls, is divided into categories such as IP, ICMP,
    TCP, and UDP. The concept of a management information base is used in several
    other parts of system administration, as we’ll see in [Chapter 21](ch21.xhtml#ch21)
    and you’ll see throughout your career. The terms *sysctl MIB* and *sysctl* are
    frequently used interchangeably. Each category is named by stringing together
    the parent category and all of its children to create a unique variable name,
    such as:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 这些类别每个还会进一步细分。例如，`net`类别，涵盖所有与网络相关的sysctl，被分为IP、ICMP、TCP和UDP等子类别。管理信息库的概念在系统管理的其他部分也有应用，我们将在[第21章](ch21.xhtml#ch21)看到，未来的职业生涯中你也会接触到。术语*sysctl
    MIB*和*sysctl*通常可以互换使用。每个类别的命名是通过将父类别和所有子类别串联在一起，形成一个唯一的变量名，例如：
- en: '[PRE3]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Here we have five sysctls plucked from the middle of the `kern` category. The
    first two are directly beneath the `kern` label and have no sensible grouping
    with other values other than the fact that they’re kernel-related. The remaining
    three all begin with `kern.ipc`; they’re part of the IPC (interprocess communication)
    section of kernel sysctls. If you keep reading the sysctls you saved, you’ll see
    that some sysctl variables are several categories deep.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 这里列出了五个sysctl，来自`kern`类别的中间部分。前两个直接位于`kern`标签下，除了它们与内核相关这一点外，并没有与其他值有明显的分组关系。剩余的三个都以`kern.ipc`开头，它们属于内核sysctl的IPC（进程间通信）部分。如果你继续阅读你保存的sysctl，你会发现一些sysctl变量有多个类别层级。
- en: '***sysctl Values and Definitions***'
  id: totrans-44
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***sysctl值和定义***'
- en: Each MIB has a value that represents a buffer, setting, or characteristic used
    by the kernel. Changing the value changes how the kernel operates. For example,
    the kernel handles transmitting and receiving packets, but by default won’t send
    a packet from one interface to another. You can change a sysctl to permit this
    forwarding, thereby turning your host into a router.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 每个MIB都有一个值，表示内核使用的缓冲区、设置或特性。更改该值会改变内核的操作方式。例如，内核负责传输和接收数据包，但默认情况下不会将数据包从一个接口发送到另一个接口。你可以更改一个sysctl以允许这种转发，从而将主机变成一个路由器。
- en: Each sysctl value is either a string, an integer, a binary value, or an opaque.
    *Strings* are free-form texts of arbitrary length; *integers* are ordinary whole
    numbers; *binary* values are either 0 (off) or 1 (on); and *opaques* are pieces
    of machine code that only specialized programs can interpret.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 每个 sysctl 值可以是字符串、整数、二进制值或不透明类型。*字符串* 是任意长度的自由格式文本；*整数* 是普通的整数；*二进制* 值可以是 0（关闭）或
    1（开启）；*不透明类型* 是机器代码片段，只有专门的程序才能解释。
- en: Many sysctl values are not well documented; there is no single document listing
    all available sysctl MIBs and their functions. A MIB’s documentation generally
    appears in a man page for the corresponding function, or sometimes only in the
    source code. For example, the original documentation for the MIB `kern.securelevel`
    (discussed in [Chapter 9](ch09.xhtml#ch09)) is in security(7). Although sysctl
    documentation has expanded in recent years, many MIBs still have no documentation.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 许多 sysctl 值文档不全；没有一个单一的文档列出了所有可用的 sysctl MIB 及其功能。MIB 的文档通常出现在相应功能的 man 页面中，或者有时仅出现在源代码中。例如，`kern.securelevel`
    的原始文档（在[第 9 章](ch09.xhtml#ch09)讨论）在 security(7) 中。尽管近年来 sysctl 文档有所扩展，许多 MIB 仍然没有文档。
- en: 'Fortunately, some MIBs have obvious meanings. For example, as we discuss later
    in this chapter, this is an important MIB if you frequently boot different kernels:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，某些 MIB 有明显的含义。例如，正如我们在本章后面讨论的那样，如果你经常启动不同的内核，这是一个重要的 MIB：
- en: '[PRE4]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: If you’re debugging a problem and have to reboot with several different kernels
    in succession, you can easily forget which kernel you’ve booted (not that this
    has ever happened to me, really). A reminder can therefore be helpful.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在调试一个问题，并且需要依次重启多个不同的内核，你可能会很容易忘记已经启动了哪个内核（不过，实际上这从未发生过在我身上）。因此，一个提醒可能会很有帮助。
- en: 'An easy way to get some idea of what a sysctl does is to use the `-d` switch
    with the full MIB. This prints a brief description of the sysctl:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 了解一个 sysctl 的作用的一个简单方法是使用 `-d` 开关与完整的 MIB 结合使用。这会打印出该 sysctl 的简短描述：
- en: '[PRE5]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: This brief definition tells you that this sysctl controls exactly what you might
    think it does. Unfortunately, not all sysctls provide definitions with `-d`. While
    this example is fairly easy, other MIBs might be much more difficult to guess.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 这个简短的定义告诉你，这个 sysctl 控制的正是你可能想象的内容。不幸的是，并不是所有的 sysctl 都提供 `-d` 参数的定义。虽然这个例子相对简单，但其他
    MIB 可能更难以猜测。
- en: '***Viewing sysctls***'
  id: totrans-54
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***查看 sysctl 设置***'
- en: 'To view all the MIBs available in a particular subtree of the MIB tree, use
    the `sysctl` command with the name of the part of the tree you want to see. For
    example, to see everything under `kern`, enter this command:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看 MIB 树中特定子树下所有可用的 MIB，可以使用 `sysctl` 命令并输入你想查看的树的名称。例如，要查看 `kern` 下的所有内容，输入以下命令：
- en: '[PRE6]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'This list goes on for quite some time. If you’re just becoming familiar with
    sysctls, you might use this to see what’s available. To get the exact value of
    a specific sysctl, give the full MIB name as an argument:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 这个列表会持续很长时间。如果你刚开始熟悉 sysctl，你可能会用这个来查看可用项。要获取特定 sysctl 的确切值，请将完整的 MIB 名称作为参数传入：
- en: '[PRE7]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The MIB `kern.securelevel` has the integer value `-1`. We’ll discuss the meaning
    of this sysctl and its value in [Chapter 9](ch09.xhtml#ch09).
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: MIB `kern.securelevel` 的整数值为 `-1`。我们将在[第 9 章](ch09.xhtml#ch09)中讨论这个 sysctl 及其值的含义。
- en: '***Changing sysctls***'
  id: totrans-60
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***更改 sysctl 设置***'
- en: 'Some sysctls are read-only. For example, take a look at the hardware MIBs:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 有些 sysctl 是只读的。例如，看看硬件 MIB：
- en: '[PRE8]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The FreeBSD Project has yet to develop the technology to change Intel hardware
    into ARM64 hardware via a software setting, so this sysctl is read-only. If you
    were able to change it, all you’d do is crash your system. FreeBSD protects you
    by not allowing you to change this value. An attempt to change it won’t hurt anything,
    but you’ll get a warning. On the other hand, consider the following MIB:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: FreeBSD 项目尚未开发出通过软件设置将 Intel 硬件转换为 ARM64 硬件的技术，因此这个 sysctl 是只读的。如果你能够修改它，所有你会做的就是崩溃系统。FreeBSD
    通过不允许你更改此值来保护你。尝试更改它不会造成任何损害，但你会收到警告。另一方面，考虑以下 MIB：
- en: '[PRE9]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'This MIB determines whether users can mount removable media, such as CDROM
    and floppy drives, as discussed in [Chapter 13](ch13.xhtml#ch13). Changing this
    MIB requires no extensive tweaks within the kernel or modifications to hardware;
    it’s only an in-kernel permissions setting. To change this value, use the `sysctl(8)`
    command, the sysctl MIB, an equal sign, and the desired value:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 这个MIB决定用户是否可以挂载可移动媒体，如CDROM和软盘驱动器，详见[第13章](ch13.xhtml#ch13)。更改此MIB不需要对内核进行大量调整或修改硬件；它只是一个内核内的权限设置。要更改此值，可以使用`sysctl(8)`命令、sysctl
    MIB、等号和期望的值：
- en: '[PRE10]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The sysctl(8) program responds by showing the sysctl name, the old value, and
    the new value. This sysctl is now changed. A sysctl that can be tuned on the fly
    like this is called a *runtime tunable sysctl*.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: sysctl(8)程序会响应并显示sysctl名称、旧值和新值。这个sysctl现在已经更改。像这样可以动态调整的sysctl称为*运行时可调sysctl*。
- en: '***Setting sysctls Automatically***'
  id: totrans-68
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***自动设置sysctl***'
- en: Once you’ve tweaked your kernel’s settings to your whim, you’ll want those settings
    to remain after a reboot. Use the file */etc/sysctl.conf* for this. List each
    sysctl you want to set and the desired value in this file. For example, to set
    the `vfs.usermount` sysctl at boot, add the following on its own line in */etc/sysctl.conf*`:`
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你调整了内核设置以满足个人需求，你可能希望这些设置在重启后仍然生效。可以使用文件*/etc/sysctl.conf*来实现这一点。在这个文件中列出你希望设置的每个sysctl及其期望值。例如，要在启动时设置`vfs.usermount`
    sysctl，可以在*/etc/sysctl.conf*中添加如下内容：
- en: '[PRE11]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '**The Kernel Environment**'
  id: totrans-71
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**内核环境**'
- en: The kernel is a program started by the boot loader. The boot loader can hand
    environment variables to the kernel, creating the *kernel environment*. The kernel
    environment is also a MIB tree, much like the sysctl tree. Many, but not all,
    of these environment variables later get mapped onto read-only sysctls.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 内核是由引导加载程序启动的一个程序。引导加载程序可以将环境变量传递给内核，从而创建*内核环境*。内核环境也是一个MIB树，类似于sysctl树。很多（但并非所有）环境变量最终会被映射为只读的sysctl。
- en: '***Viewing the Kernel Environment***'
  id: totrans-73
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***查看内核环境***'
- en: Use kenv(8) to view the kernel environment. Give it the name of a kernel environment
    variable to see just that variable, or run it without arguments to see the whole
    tree.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 使用kenv(8)查看内核环境。为它提供一个内核环境变量的名称，可以只查看该变量，或者不带参数运行它以查看整个树状结构。
- en: '[PRE12]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: These variables look an awful lot like the loader variables. Because they are
    the loader variables. They frequently relate to initial hardware probes. If your
    serial port uses an unusual memory address, the kernel needs to know about that
    before trying to probe it.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 这些变量看起来很像加载器变量，因为它们就是加载器变量。它们通常与初始硬件探测相关。如果你的串口使用了不寻常的内存地址，内核需要在尝试探测之前知道这个信息。
- en: These environment settings are also called *boot-time tunable sysctls*, or *tunables*,
    frequently related to low-level hardware settings. As an example, when the kernel
    first probes a hard drive, it must decide whether it’s going to provide ident-based
    or GPT ID-based labels. This decision must be made before anything in the kernel
    accesses the hard drive, and you can’t change your mind without rebooting the
    machine.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 这些环境设置也被称为*启动时可调的sysctl*，或*可调项*，通常与低级硬件设置相关。例如，当内核首次探测硬盘时，它必须决定是否使用基于标识的标签或基于GPT
    ID的标签。这个决定必须在内核访问硬盘之前做出，而且在不重启机器的情况下无法改变。
- en: Kernel environment variables can be set only from the loader. You can make changes
    manually at boot time or set them in */boot/loader.conf* to take effect at the
    next boot (see [Chapter 4](ch04.xhtml#ch04)).
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 内核环境变量只能通过加载程序设置。你可以在启动时手动进行更改，或在*/boot/loader.conf*中设置它们，以便在下次启动时生效（见[第4章](ch04.xhtml#ch04)）。
- en: Much like *sysctl.conf*, setting tunable values in *loader.conf* will let you
    really mess up a machine. The good news is that these values are easily unset.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 就像*sysctl.conf*一样，在*loader.conf*中设置可调值也可能会导致系统崩溃。好消息是，这些值可以轻松恢复。
- en: '**TOO MANY TUNABLES?**'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '**有太多可调项吗？**'
- en: Don’t become confused between sysctl values that can be set only at boot, sysctl
    values that can be tuned on the fly, and sysctls that can be set on the fly but
    have been configured to automatically adjust at boot. Remember that boot-time
    tunable sysctls involve low-level kernel functions, while runtime tunables involve
    higher-level functions. Having sysctls adjust themselves at boot is merely an
    example of saving your work—it doesn’t change the category that the sysctl belongs
    to.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 不要将只能在启动时设置的sysctl值、可以动态调整的sysctl值和已配置为在启动时自动调整但可以动态设置的sysctl值混淆。记住，启动时可调的sysctl涉及低级内核功能，而运行时可调的sysctl涉及更高级的功能。让sysctl在启动时自行调整仅仅是保存你工作的一个例子——它并不改变该sysctl所属的类别。
- en: '***Dropping Hints to Device Drivers***'
  id: totrans-82
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***向设备驱动程序提供提示***'
- en: You can use environment variables to tell device drivers needed settings. You’ll
    learn about these settings by reading the driver man pages and other documentation.
    Additionally, much ancient hardware requires the kernel to address it at very
    specific IRQ and memory values. If you’re old enough to remember plug-and-pray,
    “hardware configuration” floppy disks, and special slots for bus master cards,
    you know what I’m talking about and probably have one of these systems polluting
    your hardware closet even today. (If you’re too young for that, buy one of us
    geezers a drink and listen to our horror stories.^([2](footnote.xhtml#ch06fn2)))
    You can tell FreeBSD to probe for such hardware at any IRQ or memory address you
    specify, which is very useful when you have a card with a known configuration
    but the floppy that can change that configuration biodegraded years ago.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用环境变量来告知设备驱动程序所需的设置。你将通过阅读驱动程序的手册页和其他文档来了解这些设置。此外，许多古老的硬件要求内核以非常特定的IRQ和内存值来访问它们。如果你足够老，记得插卡即“上天祈祷”的“硬件配置”软盘和专门的总线主卡插槽，你知道我在说什么，甚至今天你可能还会在你的硬件柜里找到这样的系统。（如果你太年轻了，给我们这些老人买一杯酒，听听我们的噩梦故事。^([2](footnote.xhtml#ch06fn2)))
    你可以告诉FreeBSD探测你指定的任何IRQ或内存地址上的硬件，这在你有一张已知配置的卡，而那张改变配置的软盘已经腐烂了多年前时非常有用。
- en: 'If you’re truly unfortunate, you might have a machine with a built-in floppy
    disk drive. Look in */boot/device.hints* to find entries that configure this hardware:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你真的很不幸运，可能会拥有一台内置软盘驱动器的机器。查看 */boot/device.hints*，可以找到配置此硬件的条目：
- en: '[PRE13]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: These entries are all hints for the fdc(4) device driver ➊. The entry is used
    for fdc device number zero ➋. If you enable this device, a booting kernel will
    probe for a card at memory address (or port ➌) 0x3F0 ➍, IRQ 6 ➎, and DRQ 2 ➏.
    If it finds a device with these characteristics, it gets assigned the fdc(4) driver.
    If that device isn’t a floppy drive, you’ll have amusing crashes.^([3](footnote.xhtml#ch06fn3))
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 这些条目都是给fdc(4)设备驱动程序的提示 ➊。该条目用于fdc设备编号零 ➋。如果启用此设备，启动时内核将探测位于内存地址（或端口 ➌）0x3F0
    ➍、IRQ 6 ➎ 和 DRQ 2 ➏的卡。如果它发现具有这些特征的设备，就会将其分配给fdc(4)驱动程序。如果该设备不是软盘驱动器，你将看到有趣的崩溃。^([3](footnote.xhtml#ch06fn3))
- en: '**TESTING BOOT-TIME TUNABLES**'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '**测试启动时可调参数**'
- en: All of these hints and boot-time tunable sysctls are available in the boot loader
    and can be set interactively at the OK prompt, as discussed in [Chapter 4](ch04.xhtml#ch04).
    You can test settings without editing *loader.conf*, find the value that works,
    and only then make the change permanent in a file.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些提示和启动时可调的sysctl都可以在启动加载器中使用，并可以在OK提示符下交互设置，如[第4章](ch04.xhtml#ch04)中所讨论。你可以在不编辑
    *loader.conf* 的情况下测试设置，找到合适的值后，再将其永久修改到文件中。
- en: Boot-time tunables and sysctl let you adjust how a kernel behaves, but kernel
    modules let you add functionality to a running kernel.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 启动时可调参数和sysctl让你调整内核的行为，但内核模块允许你向正在运行的内核添加功能。
- en: '**Kernel Modules**'
  id: totrans-90
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**内核模块**'
- en: Kernel modules are parts of a kernel that can be started, or loaded, when needed
    and unloaded when unused. Kernel modules can be loaded when you plug in a piece
    of hardware and removed with that hardware. This greatly expands the system’s
    flexibility. Plus, a kernel with all possible functions compiled into it would
    be rather large. Using modules, you can have a smaller, more efficient kernel
    and load rarely used functionality only when it’s required.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 内核模块是内核的一部分，可以在需要时启动或加载，在不使用时卸载。内核模块可以在插入硬件时加载，并随硬件一起移除。这极大地扩展了系统的灵活性。而且，若将所有可能的功能都编译到内核中，内核的体积会非常庞大。使用模块后，你可以拥有一个更小、更高效的内核，只有在需要时才加载那些不常用的功能。
- en: Just as the default kernel is held in the file */boot/kernel/kernel*, kernel
    modules are the other files under */boot/kernel*. Take a look in that directory
    to see hundreds of kernel module files. Each kernel module name ends in *.ko*.
    Generally speaking, the file is named after the functionality contained in the
    module. For example, the file */boot/kernel/wlan.ko* handles the wlan(4) wireless
    layer. FreeBSD needs this module for wireless networking.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 就像默认的内核文件保存在*/boot/kernel/kernel*一样，内核模块也保存在*/boot/kernel/*目录下。查看该目录，您会看到数百个内核模块文件。每个内核模块的名称以*.ko*结尾。通常情况下，文件的名称与模块所包含的功能相对应。例如，文件*/boot/kernel/wlan.ko*处理wlan(4)无线层。FreeBSD需要这个模块来支持无线网络。
- en: '***Viewing Loaded Modules***'
  id: totrans-93
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***查看已加载的模块***'
- en: The kldstat(8) command shows modules loaded into the kernel.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: kldstat(8)命令显示已加载到内核中的模块。
- en: '[PRE14]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: This desktop has three kernel modules loaded. The first is the kernel proper
    ➊; then, modules to support ZFS ➋ and the OpenSolaris kernel functions needed
    by ZFS ➌ follow. I experiment with Linux software on this host (see [Chapter 17](ch17.xhtml#ch17)),
    so finding the linprocfs(5) module ➍ loaded is not a surprise.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 这个桌面系统上已经加载了三个内核模块。第一个是内核本身➊；接着是支持ZFS的模块➋，以及ZFS所需的OpenSolaris内核功能模块➌。由于我在这个主机上试验Linux软件（参见[第17章](ch17.xhtml#ch17)），所以看到加载了linprocfs(5)模块➍并不意外。
- en: Each module contains one or more submodules, which you can view using `kldstat
    -v`, but the kernel itself has a few hundred submodules—so be ready for a lot
    of output.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 每个模块都包含一个或多个子模块，您可以通过使用`kldstat -v`来查看它们，但内核本身有数百个子模块——因此准备好面对大量输出。
- en: '***Loading and Unloading Modules***'
  id: totrans-98
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***加载和卸载模块***'
- en: 'Loading and unloading kernel modules is done with kldload(8) and kldunload(8).
    For example, suppose I’m experimenting with IPMI on a test host. This requires
    the ipmi(4) kernel module. While I’d normally load this automatically at boot
    using *loader.conf*, I’m in the lab. I use the `kldload` command and the name
    of the kernel module or the file containing the kernel module for that feature:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 加载和卸载内核模块可以使用kldload(8)和kldunload(8)命令。例如，假设我在测试主机上实验IPMI功能。这需要ipmi(4)内核模块。虽然我通常会使用*loader.conf*在启动时自动加载该模块，但我现在在实验室中。我使用`kldload`命令和包含该功能的内核模块或文件的名称：
- en: '[PRE15]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: If I happen to remember the name of the module, I can just use that. The module
    name doesn’t need the *.ko* at the end of the file. I happen to recall the name
    of the IPMI module.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我恰好记得模块的名称，我可以直接使用该名称。模块名称不需要后缀*.ko*。我恰好记得IPMI模块的名称。
- en: '[PRE16]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Most often, my feeble brain relies on tab completion in my shell to remind me
    of the module’s full and proper name.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数情况下，我那颗脆弱的脑袋依赖于shell中的tab补全功能来提醒我模块的完整和正确名称。
- en: Once I finish experimenting, I’ll unload the module.^([4](footnote.xhtml#ch06fn4))
    Specify the name of the kernel module as it appears in kldstat(8).
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 实验完成后，我会卸载该模块。^([4](footnote.xhtml#ch06fn4))指定在kldstat(8)中显示的内核模块名称。
- en: '[PRE17]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Any module that’s actively in use, such as the *opensolaris.ko* module loaded
    whenever you use ZFS, will not be permitted to unload. Attempting to unload an
    active module gives you an error like this:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 任何正在使用中的模块，如每当使用ZFS时加载的*opensolaris.ko*模块，都不允许卸载。尝试卸载一个正在使用中的模块时，您将遇到类似下面的错误：
- en: '[PRE18]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Sysadmins load modules much more often than they unload them. Unloading modules
    is expected to work, and it works the overwhelming majority of the time, but it’s
    arguably the most common way to panic a system. If unloading a module triggers
    a panic, file a bug report as per [Chapter 24](ch24.xhtml#ch24).
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 系统管理员加载模块的频率远远高于卸载模块。卸载模块通常能正常工作，并且大多数情况下都能成功，但它也是导致系统崩溃最常见的方式之一。如果卸载模块时触发了崩溃，请按照[第24章](ch24.xhtml#ch24)的指引提交错误报告。
- en: '***Loading Modules at Boot***'
  id: totrans-109
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***启动时加载模块***'
- en: 'Use */boot/loader.conf* to load modules at boot. The default *loader.conf*
    includes many examples of loading kernel modules, but the syntax is always the
    same. Take the name of the kernel module, chop off the trailing *.ko*, and add
    the string `_load="YES"`. For example, to load the module */boot/kernel/procfs.ko*
    automatically at boot, add this to *loader.conf*:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 使用*/boot/loader.conf*文件在启动时加载模块。默认的*loader.conf*包含了许多加载内核模块的示例，但语法始终是相同的。获取内核模块的名称，去掉后缀*.ko*，然后添加字符串`_load="YES"`。例如，要在启动时自动加载模块*/boot/kernel/procfs.ko*，可以在*loader.conf*中添加以下内容：
- en: '[PRE19]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The hard part, of course, is knowing which module to load. The easy ones are
    device drivers; if you install a new network or SCSI card that your kernel doesn’t
    support, you can load the driver module instead of reconfiguring the kernel. In
    this case, you’ll need to find out which driver supports your card; the man pages
    and Google are your friends there. I’ll be giving specific pointers to kernel
    modules to solve particular problems throughout this book.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，最难的部分是知道加载哪个模块。简单的模块是设备驱动程序；如果你安装了一个新的网络卡或SCSI卡，而你的内核不支持它，你可以加载驱动程序模块，而不必重新配置内核。在这种情况下，你需要找出哪个驱动程序支持你的卡；man页和Google会帮助你解决这个问题。在本书中，我会为解决特定问题提供具体的内核模块指引。
- en: Wait a minute, though—why would FreeBSD make you load a device driver to recognize
    hardware if it recognizes almost everything at boot? That’s an excellent question!
    The answer is that you may have built your own custom kernel and removed support
    for hardware you’re not using. You don’t know how to build a kernel? Well, let’s
    fix that right now.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 等一下——为什么FreeBSD需要你加载一个设备驱动来识别硬件，而它在启动时几乎可以识别所有硬件？这是个很好的问题！答案是，你可能已经构建了自己的定制内核，并移除了对你不使用的硬件的支持。你不知道如何构建内核？好吧，让我们现在就解决这个问题。
- en: '**Build Your Own Kernel**'
  id: totrans-114
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**构建你自己的内核**'
- en: Eventually, you’ll find that you can’t tweak your kernel as much as you like
    using only sysctl(8) and modules, and your only solution will be to build a customized
    kernel. This sounds much harder than it is; we’re not talking about writing code
    here—just editing a text file and running a couple of commands. If you follow
    the process, it’s perfectly safe. If you *don’t* follow the process, well, it’s
    like driving on the wrong side of the road. (Downtown. During rush hour.) But
    the recovery from a bad kernel isn’t that bad, either.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 最终，你会发现，仅仅使用sysctl(8)和模块，你无法像希望的那样调整内核，你唯一的解决方法就是构建一个定制内核。这听起来比实际操作要难；我们说的并不是写代码——只是编辑一个文本文件并运行几个命令。如果你按照流程操作，它是完全安全的。如果你*不*按照流程操作，那么，就像在错误的车道上开车一样。（市中心。高峰时段。）不过，从一个坏的内核恢复过来也并不像想象中那么糟糕。
- en: The kernel shipped in a default install is called *GENERIC*. GENERIC is configured
    to run on a wide variety of hardware, although not necessarily optimally. GENERIC
    boots nicely on most hardware from the last 15 years or so, and I frequently use
    it in production. When you customize your kernel, you can add support for specific
    hardware, remove support for hardware you don’t need, or enable features not included
    in GENERIC.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 默认安装中附带的内核称为*GENERIC*。GENERIC被配置为在各种硬件上运行，尽管不一定是最优的。GENERIC可以在过去15年左右的大多数硬件上顺利启动，我在生产环境中经常使用它。当你定制内核时，可以为特定硬件添加支持，移除不需要的硬件支持，或者启用GENERIC中未包含的功能。
- en: '**DON’T REBUILD THE KERNEL**'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '**不要重建内核**'
- en: Once upon a time, building a kernel was considered a rite of passage. This is
    no longer the case. Most sysadmins need to rebuild a kernel only when they’re
    playing with experimental features or specialty hardware.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 曾几何时，构建内核被视为一种成长的仪式。但现在已经不是这种情况了。大多数系统管理员只在玩实验性特性或专用硬件时才需要重建内核。
- en: '***Preparations***'
  id: totrans-119
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***准备工作***'
- en: You must have the kernel source code before you can build a kernel. If you followed
    my advice back in [Chapter 3](ch03.xhtml#ch03), you’re all set. If not, you can
    either go back into the installer and load the kernel sources, download the source
    code from a FreeBSD mirror, or jump ahead to [Chapter 18](ch18.xhtml#ch18) and
    use svnlite(1). If you don’t remember whether you installed the source code, look
    into your */usr/src* directory. If it contains a bunch of files and directories,
    you have the kernel sources.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 在构建内核之前，必须拥有内核源代码。如果你按照我在[第3章](ch03.xhtml#ch03)中的建议操作，那么你已经准备好了。如果没有，你可以重新进入安装程序并加载内核源代码，或者从FreeBSD镜像站下载源代码，或者跳到[第18章](ch18.xhtml#ch18)使用svnlite(1)。如果你不记得是否安装了源代码，可以查看你的*/usr/src*目录。如果其中包含一堆文件和目录，那么你已经有了内核源代码。
- en: Before building a new kernel, you must know what hardware your system has. This
    can be difficult to determine; the brand name on a component doesn’t necessarily
    describe the device’s identity or abilities. Many companies use rebranded generic
    components—I remember one manufacturer that released four different network cards
    under the same model name and didn’t even put a version number on the first three.
    The only way to tell the difference was to keep trying different device drivers
    until one of them worked. This has been going on for decades—many different companies
    manufactured NE2000-compatible network cards. The outside of the box had a vendor’s
    name on it, but the circuits on the card said *NE2000*. Fortunately, some vendors
    use a standard architecture for their drivers and hardware; you can be fairly
    sure that an Intel network card will be recognized by the Intel device driver.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 在构建新内核之前，你必须了解系统的硬件配置。这可能是一个棘手的问题；组件上的品牌名称不一定能描述设备的身份或功能。许多公司使用重新品牌化的通用组件——我记得有一家厂商发布了四款不同的网卡，但都使用了相同的型号名称，前三款甚至没有标注版本号。唯一区分它们的方法就是不断尝试不同的设备驱动程序，直到找到一个有效的。这个问题已经存在了几十年——许多不同的公司都生产
    NE2000 兼容的网卡。盒子外面有厂商的名字，但卡片上的电路却标注了 *NE2000*。幸运的是，一些厂商为其驱动程序和硬件使用标准架构；你可以相当确定英特尔的网卡会被英特尔的设备驱动程序识别。
- en: The best place to see what hardware FreeBSD found on your system is the file
    */var/run/dmesg.boot*, discussed in [Chapter 4](ch04.xhtml#ch04). Each entry represents
    either a hardware or software feature in the kernel. As you work on a new kernel
    for a system, keep the *dmesg.boot* of that system handy.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 查看 FreeBSD 系统上硬件信息的最佳位置是文件 */var/run/dmesg.boot*，在[第 4 章](ch04.xhtml#ch04)中有讨论。每一项条目代表内核中的硬件或软件特性。在为系统构建新内核时，随时保留该系统的
    *dmesg.boot* 非常重要。
- en: '***Buses and Attachments***'
  id: totrans-123
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***总线和连接***'
- en: 'Every device in the computer is attached to some other device. If you read
    your *dmesg.boot* carefully, you can see these chains of attachments. Here’s an
    edited set of boot messages to demonstrate:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 计算机中的每个设备都连接到其他某个设备。如果你仔细阅读 *dmesg.boot*，你可以看到这些连接链条。以下是编辑后的启动消息集，来做个演示：
- en: '[PRE20]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Our first device on this system is acpi0 ➊. You might not know what that is,
    but you could always read `man acpi` to find out. (Or, if you must, you could
    read the rest of this chapter.) There’s a power button ➋ on the acpi0 device.
    The CPUs ➌ are also attached to acpi0, as is a timekeeping device ➍. Eventually
    we have the first PCI bridge, pcib0 ➎, attached to the acpi0 device. The first
    PCI bus ➏ is in turn attached to the PCI bridge.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 这个系统上的第一个设备是 acpi0 ➊。你可能不知道它是什么，但你可以随时阅读 `man acpi` 来了解。(或者，如果你非得这么做，可以读完整章。)
    在 acpi0 设备上有一个电源按钮 ➋。CPU ➌ 也连接到 acpi0 设备，还有一个计时设备 ➍。最终，我们找到了第一个 PCI 桥，pcib0 ➎，它连接到
    acpi0 设备。第一个 PCI 总线 ➏ 也连接到 PCI 桥。
- en: So, your common PCI devices connect to a hierarchy of buses that, in turn, attach
    to a PCI bridge to talk to the rest of the computer. You could read *dmesg.boot*
    and draw a tree of all the devices on the system; while that isn’t necessary,
    understanding what’s attached where makes configuring a kernel much more likely
    to succeed.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，你常见的 PCI 设备连接到一系列总线，这些总线再通过 PCI 桥与计算机的其他部分通信。你可以查看 *dmesg.boot* 并绘制系统上所有设备的树状图；虽然这不是必须的，但了解各设备的连接位置会让配置内核的成功几率大大提高。
- en: If you’re in doubt, use pciconf(8) to see what’s actually on your system. `pciconf
    -lv` will list every PCI device attached to the system, whether or not the current
    kernel found a driver for it.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你有疑问，可以使用 pciconf(8) 来查看系统上实际存在的设备。`pciconf -lv` 将列出系统上每一个 PCI 设备，无论当前内核是否为其找到驱动程序。
- en: '***Back Up Your Working Kernel***'
  id: totrans-129
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***备份你的工作内核***'
- en: A bad kernel can render your system unbootable, so you absolutely must keep
    a good kernel around at all times. The kernel install process keeps your previous
    kernel around for backup purposes, in the directory */boot/kernel.old*. This is
    nice for being able to fall back, but I recommend that you go further. See [Chapter
    4](ch04.xhtml#ch04) for details on booting alternate kernels.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 一个坏的内核可能会使你的系统无法启动，因此你必须时刻保留一个好的内核。内核安装过程会将你之前的内核保留下来作为备份，存放在目录 */boot/kernel.old*
    中。这对于能够回滚是很有用的，但我建议你更进一步。有关启动备用内核的详细信息，请参见[第 4 章](ch04.xhtml#ch04)。
- en: If you don’t keep a known good backup, here’s what can happen. If you build
    a new kernel, find that you made a minor mistake, and have to rebuild it again,
    the system-generated backup kernel is actually the first kernel you made—the one
    with that minor mistake. Your working kernel has been deleted. When you discover
    that your new custom kernel has the same problem, or an even more serious error,
    you’ll deeply regret the loss of that working kernel.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你没有保留一个已知的良好备份，可能会发生以下情况。如果你构建了一个新的内核，发现自己犯了一个小错误，必须重新构建它，而系统生成的备份内核实际上是你第一次制作的内核——那个包含小错误的内核。你的工作内核已经被删除。当你发现新的自定义内核也有相同的问题，或者甚至是更严重的错误时，你会深深后悔失去那个工作内核。
- en: 'A common place to keep a known good kernel is */boot/kernel.good*. Back up
    your working, reliable kernel like this:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 一个常见的保留已知良好内核的位置是*/boot/kernel.good*。像这样备份你的工作、可靠的内核：
- en: '[PRE21]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: If you’re using ZFS, a boot environment might make more sense than copying (see
    [Chapter 12](ch12.xhtml#ch12)).
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你正在使用ZFS，那么启动环境可能比复制更有意义（请参阅[第12章](ch12.xhtml#ch12)）。
- en: Don’t be afraid to keep a variety of kernels on hand. Disk space is cheaper
    than time. I know people who keep kernels in directories named by date so that
    they can fall back to earlier versions if necessary. Many people also keep a current
    copy of the GENERIC kernel in */boot/kernel.GENERIC* for testing and debugging
    purposes. The only way to have too many kernels is to fill up your hard drive.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 不要害怕手头保留各种内核。磁盘空间比时间便宜。我知道一些人会将内核保存在以日期命名的目录中，以便在必要时回退到早期版本。许多人还会将当前版本的GENERIC内核保存在*/boot/kernel.GENERIC*中，用于测试和调试目的。拥有太多内核的唯一方法是把硬盘填满。
- en: '***Configuration File Format***'
  id: totrans-136
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***配置文件格式***'
- en: FreeBSD’s kernel is configured via text files. There’s no graphical utility
    or menu-driven system for kernel configuration; it’s still much the same as in
    4.4 BSD. If you’re not comfortable with text configuration files, building a kernel
    is just not for you.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: FreeBSD的内核通过文本文件进行配置。没有图形化工具或菜单驱动的系统来配置内核；这与4.4 BSD时的情况基本相同。如果你对文本配置文件不熟悉，构建内核就不适合你。
- en: 'Each kernel configuration entry is on a single line. You’ll see a label to
    indicate what sort of entry this is, and then a term for the entry. Many entries
    also have comments set off with a hash mark, much like this entry for the FreeBSD
    filesystem FFS:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 每个内核配置条目都位于单独的一行。你会看到一个标签来表示这是什么类型的条目，然后是条目的术语。许多条目还会有以井号标记的注释，类似于FreeBSD文件系统FFS的这个条目。
- en: '[PRE22]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Every complete kernel configuration file is made up of five types of entries:
    `cpu`, `ident`, `makeoptions`, `options`, and `devices`. The presence or absence
    of these entries dictates how the kernel supports the associated feature or hardware:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 每个完整的内核配置文件由五种类型的条目组成：`cpu`、`ident`、`makeoptions`、`options`和`devices`。这些条目的存在与否决定了内核如何支持相关的功能或硬件：
- en: cpu This label indicates what kind of processor this kernel supports. The kernel
    configuration file for the boring old PC hardware includes several CPU entries
    to cover processors such as the 486 (I486_CPU), Pentium (I586_CPU), and Pentium
    Pro through modern Pentium 4 CPUs (I686_CPU). The kernel configuration for amd64/EM64T
    hardware includes only one CPU type, HAMMER, as that architecture has only one
    CPU family. While a kernel configuration can include multiple CPU types, they
    must be of similar architectures; a kernel can run on 486 and Pentium CPUs, but
    you can’t have a single kernel run on both Intel-compatible and ARM processors.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: cpu 这个标签表示该内核支持哪种类型的处理器。针对那些普通PC硬件的内核配置文件包括几个CPU条目，以涵盖如486（I486_CPU）、奔腾（I586_CPU）和奔腾Pro到现代奔腾4
    CPU（I686_CPU）等处理器。而amd64/EM64T硬件的内核配置仅包括一个CPU类型——HAMMER，因为该架构只有一个CPU系列。虽然一个内核配置可以包括多个CPU类型，但它们必须是相似架构的；一个内核可以在486和奔腾CPU上运行，但你不能让一个内核同时在Intel兼容的处理器和ARM处理器上运行。
- en: ident Every kernel has a single `ident` line, giving a name for the kernel.
    That’s how the GENERIC kernel gets its name; it’s an arbitrary text string.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: ident 每个内核都有一行`ident`，为内核提供一个名称。这就是GENERIC内核获得名称的方式；它是一个任意的文本字符串。
- en: makeoptions This string gives instructions to the kernel-building software.
    The most common option is `DEBUG=-g`, which tells the compiler to build a debugging
    kernel. Debugging kernels help developers troubleshoot system problems.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: makeoptions 这个字符串为内核构建软件提供指令。最常见的选项是`DEBUG=-g`，它告诉编译器构建一个调试内核。调试内核帮助开发人员排查系统问题。
- en: options These are kernel functions that don’t require particular hardware. This
    includes filesystems, networking protocols, and in-kernel debuggers.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 选项 这些是内核功能，不需要特定硬件。包括文件系统、网络协议和内核内调试器。
- en: devices Also known as *device drivers*, these provide the kernel with instructions
    on how to speak to certain devices. If you want your system to support a piece
    of hardware, the kernel must include the device driver for that hardware. Some
    device entries, called *pseudodevices*, aren’t tied to particular hardware, but
    instead support whole categories of hardware—such as Ethernet, random number generators,
    or memory disks. You might wonder what differentiates a pseudodevice from an option.
    The answer is that pseudodevices appear to the system as devices in at least some
    ways, while options have no device-like features. For example, the loopback pseudodevice
    is a network interface that connects to only the local machine. While no hardware
    exists for it, software can connect to the loopback interface and send network
    traffic to other software on the same machine.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 设备 也称为*设备驱动程序*，这些为内核提供了如何与特定设备通信的指令。如果你希望系统支持某个硬件，内核必须包括该硬件的设备驱动程序。有些设备条目，称为*伪设备*，并不与特定硬件绑定，而是支持整个硬件类别——例如以太网、随机数生成器或内存磁盘。你可能会问，伪设备与选项有什么区别。答案是，伪设备在至少某些方面表现得像设备，而选项没有类似设备的特征。例如，回环伪设备是一个仅连接到本地机器的网络接口。尽管它没有硬件支持，但软件可以连接到回环接口，并将网络流量发送到同一机器上的其他软件。
- en: 'Here’s another snippet of a configuration file—the part that covers ATA controllers:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 这是配置文件的另一个片段——涵盖ATA控制器的部分：
- en: '[PRE23]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Each of these devices is a different type of ATA controller. Compare these
    entries to a couple of our ATA entries in */var/run/dmesg.boot* :'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 这些设备是不同类型的ATA控制器。将这些条目与我们在*/var/run/dmesg.boot*中查看的几个ATA条目进行比较：
- en: '[PRE24]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The kernel configuration has an ATA bus, `device ata`. It’s a “legacy” ATA bus,
    whatever the word “legacy” means today. The dmesg snippet here starts with the
    atapci device, the controller where ATA meets PCI. We then have two ATA buses,
    ata0 and ata1\. Disk ada0 is on ata0, while CD drive cd0 is on ata1.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 内核配置中有一个ATA总线，`device ata`。它是一个“传统”ATA总线，不管“传统”这个词今天是什么意思。这里的dmesg片段以atapci设备开始，这是ATA与PCI连接的控制器。接下来有两个ATA总线，ata0和ata1。磁盘ada0在ata0上，而CD驱动器cd0在ata1上。
- en: Without `device ata` in the kernel configuration, the kernel would not recognize
    the ATA bus. Even if the system figured out that the system has a DVD drive, the
    kernel wouldn’t know the route to get information to and from it. Your kernel
    configuration must include all the intermediary devices for the drivers that rely
    on them. On the other hand, if your system doesn’t have ATA RAID drives, floppy
    drives, or tape drives, you can remove those device drivers from your kernel.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 如果内核配置中没有`device ata`，内核将无法识别ATA总线。即使系统发现系统有一个DVD驱动器，内核也不知道如何与它进行信息交换。你的内核配置必须包含所有依赖于它们的驱动程序的中介设备。另一方面，如果你的系统没有ATA
    RAID驱动器、软盘驱动器或磁带驱动器，你可以从内核中移除这些设备驱动程序。
- en: If this host had an AHCI, MVS, or SIIS controller, those device names would
    show up in dmesg instead of ata.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 如果该主机有AHCI、MVS或SIIS控制器，那么这些设备名称将在dmesg中显示，而不是ata。
- en: '***Configuration Files***'
  id: totrans-153
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***配置文件***'
- en: 'Fortunately, you don’t normally create a kernel configuration file from scratch;
    instead, you build on an existing one. Start with the GENERIC kernel for your
    hardware architecture. It can be found in */sys/<arch>/conf* —for example, the
    i386 kernel configuration files are in */sys/i386/conf*, the amd64 kernel configuration
    files are in */sys/amd64/conf*, and so on. This directory contains several files,
    of which the most important are *DEFAULTS*, *GENERIC*, *GENERIC.hints*, *MINIMAL*,
    and *NOTES*:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，你通常不需要从头开始创建内核配置文件；相反，你是基于现有的配置文件进行构建的。从适合你硬件架构的GENERIC内核开始。它可以在*/sys/<arch>/conf*中找到——例如，i386内核配置文件位于*/sys/i386/conf*，amd64内核配置文件位于*/sys/amd64/conf*，依此类推。该目录包含多个文件，其中最重要的是*DEFAULTS*、*GENERIC*、*GENERIC.hints*、*MINIMAL*和*NOTES*：
- en: '***DEFAULTS*** This is a list of options and devices that are enabled by default
    for a given architecture. That doesn’t mean that you can compile and run *DEFAULTS*,
    but it is a starting point should you want to build a kernel by adding devices.
    Using *GENERIC* is easier, though.'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: '***默认设置*** 这是为特定架构启用的选项和设备列表。这并不意味着你可以编译和运行*默认设置*，但如果你想通过添加设备来构建内核，它是一个起点。不过，使用*GENERIC*更为简单。'
- en: '***GENERIC*** This is the configuration for the standard kernel. It contains
    all the settings needed to get standard hardware of that architecture up and running;
    this is the kernel configuration used by the installer.'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: '***GENERIC*** 这是标准内核的配置。它包含了启动并运行该架构的标准硬件所需的所有设置；这是安装程序使用的内核配置。'
- en: '***GENERIC.hints*** This is the hints file that is later installed as */boot/device.hints*.
    This file provides configuration information for older hardware.'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: '***GENERIC.hints*** 这是稍后会安装到*/boot/device.hints*的提示文件。此文件提供了旧硬件的配置信息。'
- en: '***MINIMAL*** This configuration excludes anything that can be loaded from
    a module.'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: '***MINIMAL*** 此配置排除了任何可以从模块加载的内容。'
- en: '***NOTES*** This is an all-inclusive kernel configuration for that hardware
    platform. Every platform-specific feature is included in *NOTES*. Find platform-independent
    kernel features in */usr/src/sys/conf/NOTES*.'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: '***NOTES*** 这是该硬件平台的全面内核配置。每个平台特定的功能都包含在*NOTES*中。平台无关的内核功能请参见*/usr/src/sys/conf/NOTES*。'
- en: Many architectures also have architecture-specific configurations, needed only
    for that hardware. The i386 architecture includes the PAE kernel configuration,
    which lets you use more than 4GB of RAM on a 32-bit system. The arm architecture
    includes dozens of configurations, one for each of the many different platforms
    FreeBSD supports.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 许多架构还有仅针对特定硬件的架构特定配置。i386架构包括PAE内核配置，使你能够在32位系统上使用超过4GB的RAM。arm架构包括数十种配置，每种都对应FreeBSD支持的不同平台。
- en: Sometimes, you’ll find a kernel configuration that does exactly what you want.
    I want the smallest possible kernel. The *MINIMAL* kernel looks like a good place
    to start. Let’s build it.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，你会找到一个完全符合你需求的内核配置。我想要最小的内核。*MINIMAL*内核看起来是一个不错的起点。让我们来构建它。
- en: '**Building a Kernel**'
  id: totrans-162
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**构建内核**'
- en: A base install of FreeBSD, combined with the operating system source code, includes
    all the infrastructure you need to easily build a kernel. All you need to do is
    tell the system which kernel configuration to build through the KERNCONF variable.
    You can set KERNCONF in */etc/src.conf* (or */etc/make.conf*, if you’re really
    old-school).
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 一个基础的FreeBSD安装，加上操作系统源代码，包含了构建内核所需的所有基础设施。你所需要做的就是通过KERNCONF变量告诉系统要构建哪个内核配置。你可以在*/etc/src.conf*（或*/etc/make.conf*，如果你真的是老派做法）中设置KERNCONF。
- en: '[PRE25]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: If you’re experimenting with building and running different kernels, though,
    it’s best to set the configuration file on the command line when you build the
    kernel. Build the kernel with the `make buildkernel` command.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你正在尝试构建和运行不同的内核，最好在构建内核时在命令行中设置配置文件。使用`make buildkernel`命令来构建内核。
- en: '[PRE26]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'The build process first runs config(8) to find syntactical configuration errors.
    If config(8) detects a problem, it reports the error and stops. Some errors are
    blatantly obvious—for example, you might have accidentally deleted support for
    the Unix File System (UFS) but included support for booting off of UFS. One requires
    the other, and config(8) will tell you exactly what’s wrong. Other messages are
    strange and obscure; those that may take the longest to figure out are like this:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 构建过程首先运行config(8)来查找语法配置错误。如果config(8)检测到问题，它会报告错误并停止。有些错误是非常明显的——例如，你可能不小心删除了对Unix文件系统（UFS）的支持，但却包含了从UFS启动的支持。一个依赖于另一个，config(8)会告诉你具体出了什么问题。其他一些错误消息则比较陌生和难以理解；那些最难以解决的错误可能像这样：
- en: '[PRE27]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: NET6 is the IPv6 option, isn’t it? No, that’s *I* NET6\. Apparently some doofus
    examined the config file in a text editor and accidentally deleted a letter. The
    error is perfectly self-explanatory—once you’re familiar with all the supported
    kernel options. Read these errors carefully!
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: NET6是IPv6选项，不是吗？不，那是*I* NET6。显然有个傻瓜在文本编辑器中查看配置文件时不小心删除了一个字母。这个错误一目了然——只要你熟悉所有支持的内核选项。仔细阅读这些错误信息！
- en: Once config(8) validates the configuration, the kernel build process takes a
    few minutes on a modern machine. A successful build ends with a message like this.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦config(8)验证了配置，内核构建过程将在现代计算机上完成几分钟。构建成功后会显示类似这样的消息。
- en: '[PRE28]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: After building the kernel, install it. Running `make installkernel` moves your
    current kernel to */boot/kernel.old* and installs the new kernel in */boot/kernel*.
    Installing a kernel is much faster than building it.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 构建完内核后，进行安装。运行`make installkernel`会将当前内核移到*/boot/kernel.old*，并将新内核安装到*/boot/kernel*。安装内核的速度比构建内核要快得多。
- en: '**TRUSTING THE KERNEL**'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: '**信任内核**'
- en: Eventually, you’ll get to where you trust your kernel configuration and want
    to build and install it in a single command. The `make kernel` command builds
    and installs the kernel. Truly intense sysadmins run `make kernel && reboot`.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
- en: Once the install completes, reboot your server and watch the boot messages.
    If everything worked, you’ll get something like the following, showing exactly
    what kernel is running and when it was built.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: The catch is, the MINIMAL kernel doesn’t boot all hardware. It doesn’t boot
    *most* hardware. And of the hardware MINIMAL can boot, it won’t boot most FreeBSD
    installations on that hardware.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
- en: MINIMAL leaves everything that can be a module in a module. Disk partitioning
    methods, both GPT and MBR, can be modules. You must load either *geom_part_gpt.ko*
    or *geom_part_mbr.ko* via *loader.conf* to boot MINIMAL. Filesystems are modules
    too, so you have to load those. In short, you have to load every stupid module
    required by the hardware and your installation decisions. MINIMAL is a good reference
    of what all kernels need, and a decent place to start designing your own kernel,
    but insufficient for production.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
- en: '***Booting an Alternate Kernel***'
  id: totrans-179
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: So, what to do if your new kernel doesn’t work, or if it works badly? Perhaps
    you forgot a device driver or accidentally cut out the `INET` option and can’t
    access the internet. Sometimes it’ll hang up so early in the boot process that
    the only thing you can do is reboot the host. Don’t panic! You did keep your old
    kernel, right? Here’s what to do.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
- en: Start by recording the error message. You’ll need to research that message to
    find out how your new kernel failed you.^([5](footnote.xhtml#ch06fn5)) To fix
    the error, though, you’ll need to boot a working kernel so you can build an improved
    kernel.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
- en: Back in [Chapter 4](ch04.xhtml#ch04), we discussed the mechanics of booting
    an alternate kernel. We’ll go through the process of what to type here, but to
    see some of the in-depth details of loader management, you’ll want to go back
    to the earlier section. For now, we’ll focus on the reasons to boot an alternate
    kernel and on how to do it correctly.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
- en: Start by deciding which kernel you want to boot. Your old kernel should be in
    a directory under */boot*; in this section, we’ll assume that you want to boot
    the kernel in */boot/kernel.good*. Reboot and interrupt the boot to get to the
    boot menu. The fifth option lets you choose a different kernel. The menu displays
    every kernel directory listed in the `kernels` option in *loader.conf*. While
    it lists `kernel` and `kernel.old` by default, I’ll add `kernel.good`.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
- en: 'Once you install another new kernel, though, remember: the existing */boot/kernel*
    gets copied to */boot/kernel.old*, so your new kernel can be placed in */boot/kernel*.
    If that kernel doesn’t boot, and your new kernel also doesn’t boot, you’ll be
    left without a working kernel. This kind of sucks. Be sure you keep a known good
    kernel on hand.'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
- en: '**Custom Kernel Configuration**'
  id: totrans-185
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Maybe none of the provided kernel configurations are suitable for you. You need
    something different. FreeBSD lets you create whatever you want. It’s easiest to
    modify an existing configuration, however. You can either copy an existing file
    or use `include` options. We’ll start by modifying an existing file. Be sure you
    use the correct architecture directory, probably either */sys/amd64/conf* or */sys/i386/conf*.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
- en: Do not edit any of the files in the configuration directory directly. Instead,
    copy GENERIC to a file named after your machine or the kernel’s function and then
    edit the copy. For this example, I’m building a minimal kernel to support VirtualBox
    systems. I copy the file *GENERIC* to a file called *VBOX* and open *VBOX* in
    my preferred text editor.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
- en: '***Trimming a Kernel***'
  id: totrans-188
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Once upon a time, memory was far more expensive than it is today and was available
    only in smaller quantities. When a system has 128MB of RAM, you want every bit
    of that to be available for work, not holding useless device drivers. Today, when
    a cheap laptop somehow suffers through the day with a paltry 64GB RAM, kernel
    size is almost irrelevant.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
- en: For most of us, stripping unnecessary drivers and features out of a kernel to
    shrink it is a waste of time and energy, but I would encourage you to do it once.
    It will teach you how to build a kernel so that when you have to test a kernel
    patch or something, you won’t need to learn kernel building along with coping
    with the problem compelling the rebuild. It’ll also help when you start experimenting
    with FreeBSD on tiny hosts like a BeagleBone or Raspberry Pi.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
- en: I want to build a kernel that supports VirtualBox kernels. I boot a working
    FreeBSD install on VirtualBox so I can get at *dmesg.boot*. I’ll be going back
    and forth between the dmesg and the configuration, commenting out unneeded entries.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
- en: '**CPU Types**'
  id: totrans-192
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: On most architectures, FreeBSD supports only one or two types of CPU. The amd64
    platform supports only one, HAMMER. The i386 platform supports three, but two
    of those—the 486 and the original Pentium—are wildly obsolete outside the embedded
    market.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'You need to include only the CPU you have. If you’re not sure of the CPU in
    your hardware, check *dmesg.boot*. I have an ancient laptop that shows:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: As shown in bold, this is a 686-class CPU, which means that I can remove the
    I486_CPU and I586_CPU statements to make my kernel smaller.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
- en: '**Core Options**'
  id: totrans-198
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Following the CPU type configuration entries, we have a whole list of options
    for basic FreeBSD services, such as TCP/IP and filesystems. An average system
    won’t require all of these, but having them present provides a great deal of flexibility.
    You’ll also encounter options rarely used in your environment as well as those
    you can remove from your custom kernel configuration. We won’t discuss all possible
    kernel options but will cover specific examples of different option types. I’ll
    specifically mention those that can be trimmed from an internet server. The LINT
    file, man pages, and your favorite internet search engine can fill you in on the
    other options. If you’re in doubt about an option, keep it. Or disable it and
    see what breaks.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the following network-related options:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: These options support networking. INET is the standard old-fashioned TCP/IP,
    while INET6 supports IPv6\. Much Unix-like software depends on TCP/IP, so you
    certainly require both of these. IPSEC and IPSEC_SUPPORT let you use the IPSec
    VPN protocol. I certainly won’t use these on my virtual machines, so I’ll comment
    them out.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
- en: The TCP_OFFLOAD option lets the network stack offload TCP/IP computations to
    the network card. That sounds good, except the vnet(4) network interfaces on virtual
    machines don’t perform that function. Off with its head!
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
- en: The TCP_HHOOK option gives you a convenient man page to read. Would I use this
    option? Maaaybe. More importantly, I don’t know what software I’m running will
    need it. I’ll keep it.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
- en: The SCTP transport protocol is nifty, but totally useless to the virtual machines
    running on my laptop. Bye-bye.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: The FFS option provides the standard FreeBSD filesystem, UFS. Even a ZFS host
    needs UFS support. Keep it. The other options are all related to FFS. We discuss
    FFS and its options in more detail than you care for in [Chapter 11](ch11.xhtml#ch11),
    but for right now, just trust me and go with it.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
- en: Soft updates ensure disk integrity even when the system shuts down incorrectly.
    As discussed in acl(9), UFS access control lists allow you to grant very detailed
    permissions on files, which I won’t need on my virtual host. Whack!
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
- en: UFS_DIRHASH enables directory hashing, making directories with thousands of
    files more efficient. Keep that. And I’m going to use soft updates journaling,
    not gjournaling, so UFS_GJOURNAL can go away.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: This option—and all other _ROOT options—lets the system use something other
    than a standard UFS or ZFS filesystem as a disk device for the root partition.
    The installer uses a memory device (MD) as a root partition. If you’re using a
    diskless system (see [Chapter 23](ch23.xhtml#ch23)), you’ll need an NFS root partition.
    If you’re running FreeBSD on a standard computer system, with a hard drive and
    a keyboard and whatnot, your kernel doesn’t need any of these features.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: These two options support the Network File System (see [Chapter 13](ch13.xhtml#ch13)).
    The vital question here is, do you need NFS? If so, do you need to be a server
    or a client? I’ll include these.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: These options support intermittently used filesystems, such as FAT, CDs, the
    process filesystem, and the pseudo-filesystem framework. We discuss many of these
    filesystems in [Chapter 13](ch13.xhtml#ch13), but they’re all available as kernel
    modules. Kill them.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: These compatibility options let your system run software built for older versions
    of FreeBSD or software that makes assumptions about the kernel that were valid
    for older versions of FreeBSD but are no longer true. If you’re installing a system
    from scratch, you probably won’t need compatibility with FreeBSD 4, 5, or 6, but
    a surprising amount of software requires compatibility with 32-bit FreeBSD. Keep
    the `COMPAT_FREEBSD32` option, or your system *will* break.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: The `SCSI_DELAY` option specifies the number of milliseconds FreeBSD waits after
    finding your SCSI controllers before probing them, giving them a chance to spin
    up and identify themselves to the SCSI bus. If you have no SCSI hardware, you
    can remove this line.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: These options enable System-V-style shared memory and interprocess communication.
    Many database programs use this feature.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
- en: '**Multiple Processors**'
  id: totrans-222
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'The following entries enable symmetric multiprocessing (SMP) in i386 kernels:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: These probably don’t hurt, but if you know you’re running on a board with a
    single core, possibly a system that’s very old or using embedded hardware, you
    can remove them.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
- en: '**Device Drivers**'
  id: totrans-226
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: After all the options, you’ll find device driver entries, which are grouped
    in fairly sensible ways. To shrink your kernel, you’ll want to get rid of everything
    that your host isn’t using—but what, exactly, is your host not using? Search for
    each device driver in *dmesg.boot*.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
- en: The first device entries are buses, such as `device pci` and `device acpi`.
    Keep these, unless you truly don’t have that sort of bus in your system.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
- en: Next, we reach what most people consider device drivers proper—entries for floppy
    drives, SCSI controllers, RAID controllers, and so on. If your goal is to reduce
    the size of your kernel, this is a good place to trim heavily; remove all device
    drivers for hardware your computer doesn’t have. You’ll also find a section of
    device drivers for such mundane things as keyboards, video cards, USB ports, and
    so on. You almost certainly don’t want to delete these.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
- en: The network card device driver section is quite long and looks much like the
    SCSI and IDE sections. If you’re not going to replace your network card any time
    soon, you can eliminate drivers for any network cards you aren’t using.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
- en: We won’t list all the device drivers here, as there’s very little to be learned
    from such a list other than the hardware FreeBSD supported at the time I wrote
    this section. Check the release notes for the version of FreeBSD you’re running
    to see what hardware it supports.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
- en: You’ll also find a big section of drivers for virtualization. The most commonly
    used virtual interfaces are based on VirtIO, but you’ll also see specific drivers
    for Xen, Hyper-V, and VMware. A kernel needs only the drivers for the virtualization
    platform it’s run on. Kernels for real hardware don’t need any of them, even if
    the host will have virtual machines running on it.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
- en: '**Pseudodevices**'
  id: totrans-233
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: You’ll find a selection of pseudodevices near the bottom of the GENERIC kernel
    configuration. As the name suggests, these are created entirely out of software.
    Here are some of the more commonly used pseudodevices.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: The loopback device allows the system to communicate with itself via network
    sockets and network protocols. We’ll discuss network connections in some detail
    in the next chapter. You might be surprised at just how many programs use the
    loopback device, so don’t remove it.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: These devices provide pseudorandom numbers, required for cryptography operations
    and such mission-critical applications as games. Some of them require support
    in the underlying chipset. FreeBSD supports a variety of randomness sources, transparently
    aggregating them all into the random devices */dev/random* and */dev/urandom*.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Ethernet has many device-like characteristics, and it’s simplest for FreeBSD
    to treat it as a device. Leave this, unless you’re looking for a learning opportunity.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: These devices support networking features like VLANs and different sorts of
    tunnels.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Memory disks allow you to store files in memory. This is useful for very fast,
    temporary data storage, as we’ll learn in [Chapter 13](ch13.xhtml#ch13). For most
    (but not all) internet servers, memory disks are a waste of RAM. You can also
    use memory disks to mount and access disk images. If you’re not using memory disks,
    you can remove them from your kernel.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
- en: '**Removable Hardware**'
  id: totrans-245
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: The GENERIC kernel supports a few different sorts of removable hardware. If
    you have a laptop built in a year containing two consecutive nines or zeros, it
    might have Cardbus or even PCMCIA cards. Otherwise, you don’t need that support
    in your kernel. FreeBSD supports hot-pluggable PCI cards, but if you don’t have
    them? Throw those drivers out.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
- en: '**Including the Configuration File**'
  id: totrans-247
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Your kernel binary might be separated from the machine it’s built on. I recommend
    using the INCLUDE_CONFIG_FILE option to copy the kernel configuration into the
    compiled kernel. You’ll lose any comments, but at least you’ll have the options
    and devices in this kernel and can duplicate it if needed. The sysctl `kern.conftxt`
    contains the kernel.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
- en: Once you have your trimmed kernel, try to build it. Your first kernel configuration
    will invariably go wrong.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
- en: '***Troubleshooting Kernel Builds***'
  id: totrans-250
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'If your kernel build fails, the first troubleshooting step is to look at the
    last lines of the output. Some of these errors are quite cryptic, but others will
    be self-explanatory. The important thing to remember is that errors that say,
    “Stop in *some directory*” aren’t useful; the useful error will be before these.
    We talked about how to solve these problems in “[Asking for Help](ch01.xhtml#lev60)”
    on [page 11](ch01.xhtml#page_11): take the error message and toddle off to the
    search engine. Compile errors usually result from a configuration error.'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
- en: Fortunately, FreeBSD insists upon compiling a complete kernel before installing
    anything. A busted build won’t damage your installed system. It will, however,
    give you an opportunity to test those troubleshooting skills we talked about way
    back in [Chapter 1](ch01.xhtml#ch01).
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
- en: 'The most common sort of error is when the `make buildkernel` stage fails. It
    might look something like this:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: You’ll see a few pages of Error code 1 messages, but the actual error appears
    before them.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
- en: Some line in our kernel requires the functions `vesa_unload_ioctl` ➊ and `vesa_load_ioctl`
    ➋, but the device or option that provides that function isn’t in the kernel. Try
    an internet search for the errors. See whether there’s a man page for those functions.
    If all else fails, search the source code.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Wait—wasn’t there a reference to a “syscons” driver in the GENERIC config file?
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: I had commented out the sc(4) driver. Add it back in and try again.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
- en: There are more “proper” ways of figuring out what kernel devices require what
    devices. They all boil down to “read and comprehend the source code.” Trial, error,
    research, and more trial and error turn out to be quicker for most of us.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
- en: '**Inclusions, Exclusions, and Expanding the Kernel**'
  id: totrans-262
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Now that you can build a kernel, let’s get a little fancy and see how to use
    inclusions, the various *no* configurations, and the *NOTES* file.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
- en: '***NOTES***'
  id: totrans-264
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'FreeBSD’s kernel includes all sorts of features that aren’t included in GENERIC.
    Many of these special features are intended for very specific systems or for weird
    corner cases of a special network. You can find a complete list of hardware-specific
    features in the file *NOTES* under each platform’s kernel configuration directory—for
    example, */sys/amd64/conf/NOTES*. Hardware-independent kernel features—those that
    work on every platform FreeBSD supports—can be found in */sys/conf/NOTES*. If
    you have hardware that doesn’t appear to be completely supported in the GENERIC
    kernel, take a look at *NOTES*. Some of these features are obscure, but if you
    have the hardware, you’ll appreciate them. Let’s take a look at a typical entry
    from *NOTES*:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: Are you using any of these video cards on your desktop? Maybe you want a custom
    kernel that includes the appropriate device driver.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
- en: If the *NOTES* file lists all the features for every possible device, why not
    just use it as the basis for your kernel? First, such a kernel would use up far
    more memory than the GENERIC kernel. While even small modern machines have enough
    memory to run GENERIC without trouble, if the kernel becomes ten times larger
    without the corresponding increase in functionality, people would get annoyed.
    Also, many options are mutually exclusive. You’ll find options that let you dictate
    how the kernel schedules processes, for example. The kernel can use only one scheduler
    at a time, and each scheduler runs its tendrils throughout the kernel. Adding
    all of them to the kernel simultaneously would increase code complexity and decrease
    stability.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
- en: I make it a point to review *NOTES* every release or two, just to look for interesting
    new features.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
- en: '***Inclusions and Exclusions***'
  id: totrans-270
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'FreeBSD’s kernel configuration has two interesting abilities that can make
    maintaining a kernel easier: the `no` options and the `include` feature.'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
- en: 'The `include` feature lets you pull a separate file into the kernel configuration.
    For example, if you have a kernel configuration that can be described as “GENERIC
    with a couple extra tidbits,” you could include the GENERIC kernel configuration
    with an `include` statement:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'So, if you want to build a kernel that has all the functionality of GENERIC
    but also supports the DRM features of the VIA 3d chips, you could create a valid
    kernel configuration composed entirely of the following:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: You might think that this is actually more work than copying GENERIC to a new
    file and editing it, and you’d be correct. Why would you bother with this, then?
    The biggest reason is that as you upgrade FreeBSD, the GENERIC configuration can
    change. The GENERIC in FreeBSD 12.1 is slightly different from that in 12.0\.
    Your new configuration is valid for both releases and in both cases can be legitimately
    described as “GENERIC plus my options.”
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
- en: This works well for including items but isn’t very good for removing things
    from the kernel. Rather than manually recreating your kernel for every new FreeBSD
    version, you can use an `include` statement but exclude unneeded entries with
    the `nodevice` and `nooptions` keywords. Remove unwanted device drivers with `nodevice`,
    while `nooptions` disables unwanted options.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
- en: Take a look at the GENERIC-NODEBUG kernel configuration on a -current machine.
    It’s the same as the GENERIC configuration, but it has all of the debugging features
    disabled.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: We start by including the GENERIC kernel configuration. This kernel identifies
    itself as GENERIC-NODEBUG, though. The following seven `nooptions` statements
    turn off FreeBSD-current’s standard debugging options. Developers use the GENERIC-NODEBUG
    kernel to see whether the kernel debugger is causing problems. If a kernel with
    debugging panics while a kernel without debugging does not panic, the debugging
    code suddenly looks suspiciously dubious.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
- en: '***Skipping Modules***'
  id: totrans-281
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: If you’ve gone to the trouble of building a custom kernel, you probably know
    exactly which kernel modules your host needs. Why build all these dozens of kernel
    modules if you’re never going to use them? You can turn off the building of modules
    with the `MODULES_OVERRIDE` option. Set `MODULES_OVERRIDE` to the list of modules
    you want to build and install.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: Perhaps you want to build most of the modules, but you have reason to loathe
    a specific module. Exclude it from the build with `WITHOUT_MODULES`. Here, I exclude
    vmm from the build, because I don’t want even the temptation of running bhyve(8)
    on VirtualBox. It’s only a small step from there to running a dozen layers of
    virtualization and wondering why my laptop is slow.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: Selectively building modules, combined with custom kernels, lets you lock yourself
    into really itty-bitty boxes. You’ll only understand how itty-bitty those boxes
    are when you find you’re missing a feature you never thought you’d need. If you
    must build a kernel, be generous in what you keep.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
- en: Now that your local machine is tuned precisely the way you want it, let’s consider
    the rest of the internet.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
