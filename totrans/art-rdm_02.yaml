- en: '**2'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: HIDING INFORMATION**
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/common.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Steganography*, from the Greek term for “covered writing,” is the art of concealing
    a message so that adversaries aren’t aware that the message is present. Unlike
    cryptography, which relies on the difficulty of undoing the algorithm that generated
    the encrypted message, steganography relies on secrecy. Anyone can read the covered
    message if they know how the message is hidden. If the art of hiding a message
    is called steganography, then *steganalysis* is the process of detecting hidden
    messages. It’s a classic arms race: steganographers improve their techniques while
    steganalysis attempts to thwart them.'
  prefs: []
  type: TYPE_NORMAL
- en: While steganography exists anywhere a 0 and 1 can be hidden, it is most commonly
    found in text, binary files, audio, video, and images. Excepting video, these
    are also the targets of our experiments.
  prefs: []
  type: TYPE_NORMAL
- en: '### **In Strings**'
  prefs: []
  type: TYPE_NORMAL
- en: This section presents two experiments with text. The first hides a message in
    a string of words using a fixed offset, and the second uses random offsets.
  prefs: []
  type: TYPE_NORMAL
- en: '**A BRIEF HISTORY OF DECEPTION**'
  prefs: []
  type: TYPE_NORMAL
- en: Steganography has been around for a long time, in close association with cryptography.
  prefs: []
  type: TYPE_NORMAL
- en: In the 5th century BCE, the ancient Greek author, Herodotus, related a story
    about Histiaeus, exiled tyrant of Miletus, in what is now modern-day Turkey. He
    claims that Histiaeus shaved the head of a slave and tattooed a message on his
    scalp, then waited for the man’s hair to grow back before sending him to Miletus.
    Friends of Histiaeus shaved the man’s head and read the message—instructions to
    revolt against the Persians. Ultimately, the revolt failed and Histiaeus’s head
    was sent to the Persian king, Darius.
  prefs: []
  type: TYPE_NORMAL
- en: In 1605, Sir Francis Bacon developed a secretive communication method that combines
    steganography and cryptography. First, Bacon devised a five-digit binary code
    for each letter of the alphabet. Then, he used the cipher to hide messages in
    ordinary text with slight modifications to the font to indicate a 0 or 1 (Bacon
    used “a” and “b” in place of 0 and 1).
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, we might hide the message “EAT AT JOES” using this cipher as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The first line shows the text, a line from *Alice’s Adventures in Wonderland*,
    where lowercase letters represent “a” and uppercase represent “b.” In practice,
    the font used for “a” letters would be almost, but not quite, the same as the
    font used for “b” letters. The actual Bacon cipher for each letter of the message
    is on the second line. To figure out the message, we organize the letters in groups
    of five like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/f0040-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '***Fixed Offset***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'During WWI, a German spy sent the following message from New York:'
  prefs: []
  type: TYPE_NORMAL
- en: Apparently neutral’s protest is thoroughly discounted and ignored. Isman hard
    hit. Blockade issue affects pretext for embargo on by-products, ejecting suets
    and vegetable oils.
  prefs: []
  type: TYPE_NORMAL
- en: 'The missive contains a hidden message. Extracting the second letter of each
    word gives us:'
  prefs: []
  type: TYPE_NORMAL
- en: Pershing sails from NY June 1.
  prefs: []
  type: TYPE_NORMAL
- en: Note that we’re interpreting the final “i” as “1.” The message was useless in
    the end as Pershing sailed from New York on May 28.
  prefs: []
  type: TYPE_NORMAL
- en: While using the second letter is better than the first as it’s more challenging
    to accidentally spot the message, security is still low. However, this idea provides
    a starting point for hiding messages in a string of words. Let’s begin by developing
    a script to embed a text message using words from a *pool text*, a large text
    document from which we select words, and a selected letter offset from the beginning
    of each word. There is no randomness to this example, but it sets us up for the
    following experiment.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s our approach:'
  prefs: []
  type: TYPE_NORMAL
- en: Select a letter offset from the beginning of the word. The German spy used an
    offset of one for the second letter of each word. Recall that computer scientists
    use zero-based numbering, starting at 0 rather than 1.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Hide a source message, text only, by selecting words from a pool text—for example,
    a book—such that the current letter of the word is the offset letter of the selected
    word.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Write the resulting list of words to disk as the hidden message.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The source code we need is in *steg_simple.py*. I suggest reviewing it before
    continuing. Notice that the file does not import `RE`; there is nothing random
    here.
  prefs: []
  type: TYPE_NORMAL
- en: 'To learn how it works, here’s an example that hides the contents of *message.txt*
    using words selected from *alice.txt* with an offset of 2:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Use the command line
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'to produce the following in *output.txt*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'The offset is zero-based, meaning an offset of 0 uses the first letter, so
    an offset of 2 uses the third letter. With that in mind, we see the embedded message
    as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Every underlined letter of which is the message:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: First, *steg_simple.py* reads the message file, removes any characters that
    aren’t letters, and then uppercases the remaining characters. The result is a
    Python list of the words in the message. The pool text receives similar treatment.
  prefs: []
  type: TYPE_NORMAL
- en: Next, *steg_simple.py* processes each word of the message, letter by letter,
    scanning the pool text for words where the offset letter matches the current message
    letter. Each match is appended to the output list of words. When all message letters
    have been similarly processed, the output list is written to disk.
  prefs: []
  type: TYPE_NORMAL
- en: 'Changing the offset modifies the output list; for example, making it 3 in the
    previous listing results in the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that we’ve embedded the message, let’s get it back:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'The *tmp.txt* file contains the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: We’ve lost punctuation and spaces, and the message is screaming at us in all
    caps, but it’s discernible.
  prefs: []
  type: TYPE_NORMAL
- en: Now let’s walk through the source code for this example. Both the input message
    and, if encoding, the pool file are run through `ProcessText` to remove non-letters
    and return a list of words, as shown in [Listing 2-1](ch02.xhtml#ch02list01).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 2-1: Converting a string of text to a list of words*'
  prefs: []
  type: TYPE_NORMAL
- en: The outer loop processes the list of words generated by the first line (`s`).
    This list still contains non-space characters. The inner loop over the characters
    of each word in `s` builds the letters-only version and appends it to `text`.
    When all is said and done, the function returns `text`.
  prefs: []
  type: TYPE_NORMAL
- en: The bottom of *steg_simple.py* interprets the command line according to the
    mode, encode or decode. The code is shown in [Listing 2-2](ch02.xhtml#ch02list02).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 2-2: Parsing the command line*'
  prefs: []
  type: TYPE_NORMAL
- en: All the action is in `Encode` and `Decode`. Let’s begin with `Encode`, as in
    [Listing 2-3](ch02.xhtml#ch02list03).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 2-3: Encoding the message*'
  prefs: []
  type: TYPE_NORMAL
- en: First, `Encode` reads and processes both the message and pool text ➊. Next comes
    a triply nested loop ➋, first to process each word of the message (`msg`), then
    character by character (`c`), and lastly to search the pool text (`pool`) for
    a word where the offset character matches. The index into the pool text (`idx`)
    is set to zero initially and only ever incremented afterward, so the per-character
    search does not begin from the start each time but continues moving through the
    pool text file. In theory, this means the set of selected words is more diverse,
    as the same word is not selected repeatedly to match the same character of the
    message.
  prefs: []
  type: TYPE_NORMAL
- en: After processing the entire message, `enc` contains the selected words in order.
    All that remains is to dump them to disk ➌. Notice the Python idiom to convert
    a list of words into a single string by calling the `join` method on a string
    constant (a space) before appending a final newline character.
  prefs: []
  type: TYPE_NORMAL
- en: Decoding a message is less involved, as shown in [Listing 2-4](ch02.xhtml#ch02list04).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 2-4: Decoding the message*'
  prefs: []
  type: TYPE_NORMAL
- en: '`Decode` processes the encoded message file to make a list of words (`enc`).
    Then the function examines each word, extracts the `offset` letter, and adds it
    to `plain`, the output string. Finally, `Decode` dumps the output string to the
    decoded message file.'
  prefs: []
  type: TYPE_NORMAL
- en: '***Random Offset***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The previous experiment works, but it’s not too difficult to defeat. A bit of
    trial and error will locate the offset and reveal the hidden message. We can do
    slightly better by changing the offset at random so that the third letter of the
    first word is important, the fifth letter of the second, the first followed by
    the third again, and so on. The result is still not particularly secure but is
    likely to confound accidental discovery of the message.
  prefs: []
  type: TYPE_NORMAL
- en: The file *steg_text.py* implements this approach and introduces us to a technique
    we’ll use throughout the remainder of the chapter, namely using a randomness engine
    with a fixed seed to generate a deterministic sequence of randomly selected offsets.
    Let’s take a look at what this approach buys us.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we run *steg_text.py* on the same input message as the quotation about
    not sharing secrets. In this case, the command line is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Take note of the “secret key,” which is, in reality, a pseudorandom number generator
    seed. We won’t be able to recover the hidden message without it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Each run of *steg_text.py* produces a new *output.txt* and secret key. For
    the previous run, *output.txt* became:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'This corresponds to per-word offsets of:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: The offsets are selected pseudorandomly using the reported seed, which here
    is 499,377.
  prefs: []
  type: TYPE_NORMAL
- en: 'To recover the original message, use:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: With *steg_text.py*, the output is harder to parse because the offsets are random.
    If we knew there was a hidden message, it would require effort to recover it because
    of the many paths through the letters of each word. For example, [Figure 2-1](ch02.xhtml#ch02fig01)
    shows every path through the first three words, for a total of 40 combinations.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/02fig01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-1: All the paths through the first three words*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Each combination is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/f0045-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The combinations ITH, ITE, TWE, THE, THR, TAR, TAH are the only possible beginnings
    of common English words, for example: Ithaca, item, tweet, theme, three, tarnish,
    and tahini. The fourth word, THE, adds one more letter to each of the existing
    prefixes, of which only THRE and TART seem plausible. The following word, HEAR,
    makes it clear that the first word of the message is likely THREE or the beginning
    of the next word after TART, assuming the message isn’t itself encrypted.'
  prefs: []
  type: TYPE_NORMAL
- en: The source code for this example is similar to *steg_simple.py* and uses the
    same `ProcessText` function shown in [Listing 2-1](ch02.xhtml#ch02list01). The
    important parts for us are the encoder and decoder functions. Let’s start with
    the encoder, shown in [Listing 2-5](ch02.xhtml#ch02list05).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 2-5: Encoding with random offsets*'
  prefs: []
  type: TYPE_NORMAL
- en: As with *steg_simple.py*, the message and pool files are loaded and processed.
    The secret key is selected using the default randomness engine, PCG64 ➊. With
    `key` in hand, a new generator is initialized with `key` as the seed (`rng`).
  prefs: []
  type: TYPE_NORMAL
- en: Each letter of the message is encoded by searching the pool for a matching word,
    but this time, the generator ➋ returns the `offset` to use. After all message
    letters have been processed, the function writes the final output file and reports
    the secret key ➌. Compare [Listing 2-5](ch02.xhtml#ch02list05) with [Listing 2-3](ch02.xhtml#ch02list03);
    the fixed `offset` is now replaced by a randomly generated one.
  prefs: []
  type: TYPE_NORMAL
- en: The decoder is shown in [Listing 2-6](ch02.xhtml#ch02list06).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 2-6: Decoding with random offsets*'
  prefs: []
  type: TYPE_NORMAL
- en: The secret key forms the seed for the generator; then, the message is decoded
    word by word using the next value from the generator before writing the message
    to disk.
  prefs: []
  type: TYPE_NORMAL
- en: Some may object at this point as the experiments select words that, while actual
    words, do not form a meaningful sentence, which might tip off an adversary. I
    agree. My defense is that a simple program cannot generate a meaningful sentence,
    but we are still embedding a message and therefore following the spirit of steganography,
    if not the absolute law of it. Fear not; experiments later in the chapter produce
    unambiguous results.
  prefs: []
  type: TYPE_NORMAL
- en: Steganography with text is merely a warm-up exercise, as we can make better
    use of what the digital age offers. So let’s leave text behind and progress to
    hiding arbitrary files in other files.
  prefs: []
  type: TYPE_NORMAL
- en: '**In Random Data**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In [Chapter 1](ch01.xhtml), we used `ent` as a tool to help us decide whether
    a file contains random data. Here we’ll embed an arbitrary file inside a file
    of random data so that tools like `ent` still lead us to believe the file contains
    random data, even though it no longer does. This is true steganography in that
    the file appears random both before and after embedding the data we wish to hide.
  prefs: []
  type: TYPE_NORMAL
- en: To accomplish our goal, we need to think in terms of bits, not characters and
    words. The file we want to hide, as well as the pool file, is merely a stream
    of bits; we don’t care what those bits represent. The idea, then, is to randomly
    scatter the bits of the source file throughout the bits of the pool file.
  prefs: []
  type: TYPE_NORMAL
- en: For example, if we want to hide source bits 11011011 in
  prefs: []
  type: TYPE_NORMAL
- en: '110101011000101010010110101011001010010111'
  prefs: []
  type: TYPE_NORMAL
- en: then we need to scatter the bits randomly
  prefs: []
  type: TYPE_NORMAL
- en: '110101011001101010010010101011001110010111'
  prefs: []
  type: TYPE_NORMAL
- en: in such a way that we can recover the random bit positions later on to reconstruct
    the original file.
  prefs: []
  type: TYPE_NORMAL
- en: This approach works if the pool file is substantially larger than the file we
    wish to hide. For any source bit, the probability that the pool file bit we select
    is already the same value is 50 percent because we assume the pool file to be
    random. Therefore, with enough pool file bits and random placement of the source
    file bits, we don’t expect most tools like `ent` to pick up that the file has
    been modified. However, the proper ratio between hidden bits and pool file bits
    is difficult to ascertain. Fewer hidden bits are better, but how many can we insert
    until they become noticeable? We’ll perform a simple experiment shortly to try
    to figure out the answer.
  prefs: []
  type: TYPE_NORMAL
- en: We’re almost ready to think about coding. Our plan is to randomly scatter the
    source file bits throughout the bits of the pool file. We can get the random bit
    positions by using `RE` with a fixed seed value to generate a sequence of random
    offset values, one for each source bit.
  prefs: []
  type: TYPE_NORMAL
- en: But while we can undoubtedly encode the source file with what we have, can we
    get it back? How many bits do we read out of the encoded file? We don’t know how
    long the source file was, so we need to encode not only the source file but also
    its length.
  prefs: []
  type: TYPE_NORMAL
- en: For example, if the source file is 10,356 bytes long, we need to encode not
    only all 8 × 10,356 = 82,848 bits of the file but also the number of bytes we
    encoded. We’ll use 32 bits to encode the file length, so we will encode 82,848
    + 32 = 82,880 bits, the first 32 representing the encoded file length in bytes.
    Then, to recover the file, we read 32 bits and form the length to know how many
    additional bits to extract.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s lay out the steps. To encode a file:'
  prefs: []
  type: TYPE_NORMAL
- en: Read the source file and convert it to a list of bits.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Prepend the list of bits by the 32 bits from the length of the source file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Read the pool file and convert it to a list of bits.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Generate a random list of offset positions, one for each source bit, using the
    supplied key as the seed.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set the pool bit at each offset position to the corresponding source bit value.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Convert the pool bits back to a set of bytes and write them to disk.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'To decode a file:'
  prefs: []
  type: TYPE_NORMAL
- en: Read the encoded file and convert it to a list of bits.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Generate 32 offset positions using the supplied key as the seed.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Calculate the file length and number of bits to read.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Generate offset positions for that many bits.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Collect the bits at those positions and convert them to bytes.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Write the bytes to disk as the extracted file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'It seems complicated, and there is some accounting to keep track of, but in
    the end it’s straightforward: we’ll randomly scatter the source file bits throughout
    the pool file and then collect them to extract the source file.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we get to the code, we’ll first learn how to run it so you can experiment.
    To use the code, we need a file to embed and a pool file. The book’s GitHub repository
    contains *RandomDotOrg_sm.bin*, a 5MB file of random data from *[random.org](http://random.org)*
    that is used with permission. It will be the pool file for this example. As we
    can see, `ent` likes this file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: As for the source file, look in the directory *test_images*, which contains
    a collection of standard image-processing test images of various types and sizes.
    We’ll use these again later in the chapter when we experiment with hiding files
    in images. Presently, we want *boat.png*, shown in [Figure 2-2](ch02.xhtml#ch02fig02).
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/02fig02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-2: The boat image*'
  prefs: []
  type: TYPE_NORMAL
- en: 'The code we need is in *steg_random.py*. To encode a file, use a command line
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'The code takes about 30 seconds to run. When it finishes, the *output.bin*
    file contains the hidden image. Does `ent` still like this file? It does:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'To recover the image, run *steg_random.py* a second time using the same key
    (12345):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: The file *tmp.png* now contains the boat image.
  prefs: []
  type: TYPE_NORMAL
- en: 'The code in *make_random.py* generates files of random bytes using the random
    number generators available in the `RE` class. I recommend using this code to
    create pool files for your experiments. For example, use the following to generate
    a file of 5 million bytes using the Mersenne Twister:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: As with most programs, running *make_random.py* without arguments tells us how
    to use the code.
  prefs: []
  type: TYPE_NORMAL
- en: '***How Much Can You Hide?***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Let’s try to figure out how many bits we can hide before tools like `ent` give
    suspicious results. To do so, we need the code in *steg_random_test.py*. I’ll
    let you read the code; it’s a simple script that does the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Uses *make_random.py* to make a random file of 10 million bytes
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Uses *steg_random.py* to embed ever-larger files that are nothing but the letter
    *A* repeated
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Runs `ent` on the result and extracts the estimated value of *π*
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Plots the estimate of *π* as a function of the embedded file size
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Repeating the letter *A* creates a file that is the antithesis of random; it’s
    as nonrandom as possible, with an entropy of zero. Therefore, it’s the worst possible
    file to embed, which will have the most negative effect on the output. There’s
    nothing special about the letter *A*; any single-byte value will do.
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 2-3](ch02.xhtml#ch02fig03) shows the result.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/02fig03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-3: The effect on the estimate of π when embedding ever-larger files
    of* A *repeated*'
  prefs: []
  type: TYPE_NORMAL
- en: There’s a linear relationship between the estimate of *π* and the embedded number
    of *A*s. The pool file on its own gives an estimate that is 0.01 percent off,
    which is good. Hiding 50,000 *A*s bumps the error to 0.05 percent, which is also
    not likely to raise eyebrows. However, 100,000 *A*s changes the error to 0.5 percent,
    which is starting to look suspicious.
  prefs: []
  type: TYPE_NORMAL
- en: Since the pool file had 10 million bytes, 100,000 bytes is equal to 10⁵/10⁷
    = 0.01 = 1 percent, implying that hiding files that are less than 1 percent the
    size of the pool file should, in general, result in an output file that won’t
    be noticed.
  prefs: []
  type: TYPE_NORMAL
- en: For example, [Table 2-1](ch02.xhtml#ch02tab01) shows the estimated π values
    from `ent` for a pool file (using `urandom`) of 10 million bytes along with the
    output of *steg_random.py* when hiding 100,000 bytes that are all *A*s, the first
    100,000 characters of *alice.txt*, or another random file of bytes using `RDRAND`.
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 2-1:** Estimated π Values by Hidden File Type'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Hidden file type** | **Estimated *π* values** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `urandom` pool | 3.142167657 (0.02%) |'
  prefs: []
  type: TYPE_TB
- en: '| Hide `RDRAND` | 3.142429257 (0.03%) |'
  prefs: []
  type: TYPE_TB
- en: '| Hide *alice.txt* | 3.146091658 (0.14%) |'
  prefs: []
  type: TYPE_TB
- en: '| Hide *A*s | 3.157525263 (0.51%) |'
  prefs: []
  type: TYPE_TB
- en: 'These results hint that, for a hidden file that’s 1 percent the size of the
    pool file, we should expect a tool like `ent` to show a slight increase in metrics
    related to nonrandomness, like a larger error in estimating *π*. Note that *alice.txt*
    is a text file, so we can expect a binary file to do even better. The moral of
    the story is: hide your data in a random file that is at least 100 times larger
    than the data itself.'
  prefs: []
  type: TYPE_NORMAL
- en: Now let’s take a look at the code.
  prefs: []
  type: TYPE_NORMAL
- en: '***The steg_random.py Code***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The code in *steg_random.py* is slightly more complex than the code we’ve used
    so far. I suggest reviewing *steg_random.py* before continuing. You’ll see two
    utility functions, `MakeBit` and `MakeByte`. We’ll use these functions here and
    in the following sections, so we’ll define them before moving on to the encode
    and decode functions.
  prefs: []
  type: TYPE_NORMAL
- en: '**Converting Between Bits and Bytes**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: We intend to work with bits and bytes, so it helps to have functions that convert
    between the two. This is the point of `MakeBit` and `MakeByte`. [Listing 2-7](ch02.xhtml#ch02list07)
    shows `MakeBit`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 2-7: Converting bytes to bits*'
  prefs: []
  type: TYPE_NORMAL
- en: The argument (`byt`) is an array of bytes that we want to turn into an output
    array of bits (`b`). There are eight bits per byte, so we define `b` up front
    and then fill it in by processing the bytes in `byte` one by one using the `for`
    loop.
  prefs: []
  type: TYPE_NORMAL
- en: For each byte, we ask Python to convert it to a binary string (`s`), being careful
    to insist on leading zeros. Then, we place each bit into the output array using
    an ever-increasing index (`k`) before returning to the caller.
  prefs: []
  type: TYPE_NORMAL
- en: We also need to convert an array of bits back to an array of bytes; `MakeByte`
    is shown in [Listing 2-8](ch02.xhtml#ch02list08).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 2-8: Converting bits to bytes*'
  prefs: []
  type: TYPE_NORMAL
- en: The argument is an array of bits (`b`), so its length will be a multiple of
    eight. Therefore, `n` is the number of bytes we need in the output array. To get
    the bytes, we first reshape `b` to group every eight bits. In other words, if
    the array is a vector of 32 bits
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: it becomes
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: in `t`, a 4×8 array of bits representing 4 bytes.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we multiply each row of `t` by the vector representing the place value
    of each bit in a byte. Finally, we sum the resulting vector to give the actual
    byte value (`v`), which we place into the output array, `byt`.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let’s learn how to hide bits in a random file.
  prefs: []
  type: TYPE_NORMAL
- en: '**Encoding a File**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Encoding a file is accomplished by the cleverly named `Encode` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Our goal is to randomly scatter the bits of the source file (`sfile`) among
    the bits of the pool file (`pfile`) and dump the result to the destination file
    (`dfile`). The seed for the generator is in `key`.
  prefs: []
  type: TYPE_NORMAL
- en: In the first code paragraph, we read the source file into an array of bytes
    (`src`). As discussed previously, we also need to encode the length of the file,
    which we do by representing the number of bytes as a hexadecimal string (`s`).
    We’re using an unsigned 32-bit integer as the file length, so we can only hide
    files less than 4,294,967,296 bytes. That shouldn’t be a problem for us. The individual
    bytes representing the length are extracted from `s` and interpreted as hexadecimal
    numbers from the most significant (`b3`) down to the least (`b0`). As `src` is
    still a vector of bytes, we add the 4 bytes of the length to the beginning using
    NumPy’s `hstack` function. Finally, we use `MakeBit` to convert `src` to a vector
    of bits.
  prefs: []
  type: TYPE_NORMAL
- en: In the second code paragraph, we construct `idx`, a vector of ever-increasing
    offsets, one per bit of `src`. These are the positions in the pool that will be
    updated with `src`’s bit values. First, `step` is a vector of offsets from a low
    of 1 to a high of 15 bits. Note the use of `key` to set the seed. The `idx` vector
    is constructed from the offsets by adding each offset to the last element of `idx`
    before appending the new offset to `idx`.
  prefs: []
  type: TYPE_NORMAL
- en: The third paragraph reads the pool file as a vector of bits (`pool`). If the
    pool file is too short to accommodate all the bit offset positions in `idx`, the
    program delivers a terse message and abruptly ends.
  prefs: []
  type: TYPE_NORMAL
- en: 'At this point, we have all we need: `src` as bits, `pool` as bits, and `idx`
    telling us where the bits of `src` go. Therefore, the fourth paragraph is a simple
    loop setting the proper bit of `pool` to the corresponding bit of `src`. We march
    through `src` sequentially, and `idx` likewise, but the values in `idx` are the
    positions in `pool` that get updated.'
  prefs: []
  type: TYPE_NORMAL
- en: The final paragraph converts the now updated `pool` into a vector of bytes and
    writes it to the destination file (`dfile`).
  prefs: []
  type: TYPE_NORMAL
- en: We can officially encode a file; now let’s get it back.
  prefs: []
  type: TYPE_NORMAL
- en: '**Decoding a File**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Decoding a file uses the similarly named `Decode` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Here, `sfile` is the name of the file generated by `Encode` and `dfile` is the
    name of the desired output file. Note that `key` must match the value used to
    encode.
  prefs: []
  type: TYPE_NORMAL
- en: The code first reads the encoded file and immediately converts it to a vector
    of bits (`src`).
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following code paragraph, the properly seeded generator is created (`rng`).
    Notice the `RE` instantiation: integer, default PCG64 generator, low of 1 and
    high of 15, with the seed. This is the configuration used for encoding, as it
    must be.'
  prefs: []
  type: TYPE_NORMAL
- en: The first 32 encoded bits are extracted by adding the 32 values in `step` to
    each final offset in `idx`, as for `Encode`. The resulting `bits` are passed to
    the helper function, `MessageLength`, as in [Listing 2-9](ch02.xhtml#ch02list09).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 2-9: Converting 32 bits to an unsigned integer*'
  prefs: []
  type: TYPE_NORMAL
- en: This function makes the 32-bit vector a vector of 4 bytes (`b`); multiplies
    each byte, highest-order byte first, by the proper place value; and sums to get
    the actual encoded file length in bytes (`n`). Working with the bytes of the 32-bit
    value is the same as treating it like a base-256 number, hence the exponents on
    256.
  prefs: []
  type: TYPE_NORMAL
- en: In the final paragraph, the bit positions for the remainder of the encoded file
    are calculated from `step` and `idx` as before, but we need to add the extra offset
    to account for the 32 bits already read. Once `idx` is constructed, it is immediately
    used to extract the `bits`. All bits collected are converted to bytes (`dest`)
    and finally dumped to the output file (`dfile`).
  prefs: []
  type: TYPE_NORMAL
- en: Whew! Much is happening in *steg_random.py*. Thankfully, most of it transfers
    to the remaining two sections of this chapter, where we hide data in audio files
    and images. Let’s learn to whisper carefully so that no one hears us unless we
    want them to.
  prefs: []
  type: TYPE_NORMAL
- en: '**In an Audio File**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Digital audio is ubiquitous and a natural target for steganography. This section
    explores how to embed files in digital audio, specifically WAV files. Our approach
    is similar to the previous section: we’ll scatter the bits of the file across
    the digital samples. However, instead of altering random bits, we’ll alter the
    least-significant bit to minimize the impact and make the message essentially
    silent.'
  prefs: []
  type: TYPE_NORMAL
- en: The file we need is *steg_audio.py*. Be sure to review the file before proceeding.
    You’ll notice it uses `MakeBit` and `MakeByte`, which we have worked with before—see
    [Listings 2-7](ch02.xhtml#ch02list07) and [2-8](ch02.xhtml#ch02list08), respectively.
    Likewise, you’ll also see `MessageLength` ([Listing 2-9](ch02.xhtml#ch02list09)).
  prefs: []
  type: TYPE_NORMAL
- en: We discussed digital sampling in [Chapter 1](ch01.xhtml) when generating random
    bits from the microphone input. At that time, we wanted 32-bit floating-point
    samples. Here, we’ll use more common signed 16-bit samples in the range [–32,768,
    32,767]. Such samples use two bytes each. We’ll restrict ourselves to changing
    only the least-significant bit, thereby altering the sample value by at most 1,
    which no one will hear.
  prefs: []
  type: TYPE_NORMAL
- en: WAV files are not compressed and, therefore, might be rather large. Most internet
    audio is in the form of MP3s, which employ *lossy compression*. The human auditory
    system doesn’t need all the information in raw audio samples—about 90 percent
    or so can be discarded, which is the “loss.” However, as we’re planning on using
    the simplest of audio steganography approaches, and our hidden file will be lost
    if the file is converted to an MP3, we must use the full WAV file. There are more
    sophisticated types of audio steganography that employ characters, like echoes,
    that survive the compression process, but this is out of the scope of this book.
  prefs: []
  type: TYPE_NORMAL
- en: 'The algorithm’s needs are quite close to that of the previous section:'
  prefs: []
  type: TYPE_NORMAL
- en: Read the source file and convert it to bits along with the file length in bytes.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Read the original WAV file, ensure the source file will fit, and work with only
    one channel if it’s stereo.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Generate a random but ever-increasing list of indices into the WAV samples,
    one for each bit of the source file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Alter bit 0 of the selected samples to match the corresponding source file bit.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Write the altered samples to a new audio file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We’ll first use the code to hide files, then we’ll explore the code itself.
  prefs: []
  type: TYPE_NORMAL
- en: '***A Quiet Live Performance***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Let’s play around with *steg_audio.py* before walking through the code. The
    book’s GitHub repository includes several sample WAV files courtesy of composer
    Paul Kneusel (*[https://www.paulkneusel.com](https://www.paulkneusel.com)*). First,
    let’s hide an image in *Fireflies*, a live performance in 2016 by pianist Kristen
    Kosey. *Fireflies* is a quiet piece, thereby increasing the probability that we’ll
    hear any effect from altering the samples. Here’s the command line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: First, we supply the secret key, 2718281828, then the file to embed, *tulips_gray.png*,
    followed by the output filename, *tmp.wav*, and finally the source WAV file, *Fireflies.wav*.
    The code informs us that it used 3,712,480 samples to store the bits of *tulips_gray.png*.
    Bonus points for readers who recognize the secret key.
  prefs: []
  type: TYPE_NORMAL
- en: 'As before, we recover the hidden file with the same code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: This produces *tmp.png*, the original image file shown in [Figure 2-4](ch02.xhtml#ch02fig04).
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/02fig04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-4: The recovered image*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Play the output file, *tmp.wav*. Listen closely and try to hear the difference
    between *tmp.wav* and the original *Fireflies.wav*. The image file is well-hidden
    and utterly imperceptible. This is steganography as it should be: unnoticed.'
  prefs: []
  type: TYPE_NORMAL
- en: Okay, *steg_audio.py* works, but what did it really do? We need to change the
    least-significant bit of each sample to match the corresponding bit of the file
    we’re hiding. Let’s look at the first eight bits of *tulips_gray.png* along with
    the corresponding sample offsets and the samples themselves, as in [Table 2-2](ch02.xhtml#ch02tab02).
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 2-2:** The First Eight Bits of *tulips_gray.png* with Offsets and Samples'
  prefs: []
  type: TYPE_NORMAL
- en: '|   | **0** | **1** | **2** | **3** | **4** | **5** | **6** | **7** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- | --- | --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| **Bits** | 1 | 0 | 0 | 0 | 1 | 0 | 0 | 1 |'
  prefs: []
  type: TYPE_TB
- en: '| **Offsets** | 35 | 36 | 50 | 68 | 85 | 90 | 92 | 99 |'
  prefs: []
  type: TYPE_TB
- en: '| **Samples** | 65,533 | 5 | 7 | 65,532 | 65,535 | 65,532 | 5 | 65,534 |'
  prefs: []
  type: TYPE_TB
- en: Sample 35 has value 65,533, and we want the least-significant bit of sample
    35 to be a 1\. Likewise, sample 36 is 5, and we want its least-significant bit
    to be a 0, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: We previously discussed that WAV files use signed 16-bit integers in the range
    [–32,768, 32,767]. This is true, but when we read the audio samples, we interpret
    them as unsigned integers in the range [0, 65,535] instead to avoid working with
    negative numbers. We’ll change the interpretation back to signed 16-bit integers
    before writing the output WAV file.
  prefs: []
  type: TYPE_NORMAL
- en: We want sample 35, currently 65,533, to be such that the first bit is a 1\.
    We have a few options to accomplish this. For one, we can use low-level bit operations.
    But notice that when bit 0 of an integer is a 1 the number is odd, and when it’s
    a 0 the number is even. In this case, 65,533 is odd, meaning bit 0 is already
    a 1, so we leave the sample as is.
  prefs: []
  type: TYPE_NORMAL
- en: 'The second sample is currently a 5, but we want bit 0 to be a 0\. As 5 is an
    odd number, we subtract 1 to make the new sample value a 4 with bit 0 a 0, as
    desired. This process repeats for each bit of the file we’re hiding. Either the
    sample’s least-significant bit is already correct, or it’s off by one, requiring
    us to add or subtract 1\. To summarize: we add 1 only if we need the sample to
    be an odd number; likewise, we subtract 1 only if we want the sample to be an
    even number.'
  prefs: []
  type: TYPE_NORMAL
- en: Let’s return to my arrogant statement about the image file being “utterly imperceptible.”
    Suppose an adversary were to acquire the original *Fireflies* sound file. A bit-by-bit
    comparison of the samples might offer a clue that something is up, but we changed
    samples only when they needed to be changed. Therefore, merely extracting samples
    that differ between the suspect WAV file and the original won’t be enough to discover
    the hidden file because, on average, only half the samples used to encode the
    file will need to be altered. In other words, it’s doubtful the original file
    can be recovered without knowledge of the distribution of the samples used.
  prefs: []
  type: TYPE_NORMAL
- en: What if the adversary had only the altered WAV file? In that case, a savvy adversary
    suspecting steganography might decide that the least-significant bit of the samples
    is the one that is likely changed because altering other bits would produce noise
    when the WAV file is played, and none is present. This suspicion might prompt
    the adversary to examine the distribution of bit 0 across the samples and compare
    it with other WAV files.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you run *steg_audio_test.py*, you’ll be presented with this output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Each line reports the distribution of bit 0 across the samples in the corresponding
    WAV file. For instance, *Fireflies.wav* has 5,104,781 even samples and 5,103,286
    odd samples (for channel 0 only). The final value in each row is the p-value for
    a *χ*² test asking whether the even and odd sample counts are as expected if the
    evenness or oddness of a sample’s value is random. Only the first few digits of
    the p-value are meaningful.
  prefs: []
  type: TYPE_NORMAL
- en: Recall that p-values above 0.05 indicate support for the null hypothesis, the
    claim that the samples are equally likely to be even or odd. The p-values for
    Fireflies, Attitude, and Fun-Key are all in good agreement with the null hypothesis.
  prefs: []
  type: TYPE_NORMAL
- en: The final line, `Encoded`, shows the distribution for *tmp.wav*, the version
    of Fireflies with *tulips_gray.png* hidden inside it. Here, the p-value is 7 ×
    10^(–11), which is as good an approximation of 0 as any. In other words, the *χ*²
    test tells us that bit 0 is *not* in accordance with the null hypothesis—massively
    so. Upon seeing these results, our adversary would be convinced that something
    fishy is going on.
  prefs: []
  type: TYPE_NORMAL
- en: So, is my arrogance justified? No, not at all. A simple statistical test, combined
    with a bit of thought about how one might hide information in a WAV file, has
    given strong support to the notion that this particular WAV file has been manipulated.
    Also, even though our adversary strongly suspects we’ve manipulated the WAV file,
    they’re still unable to extract the information because they don’t know *which*
    bits were altered.
  prefs: []
  type: TYPE_NORMAL
- en: I encourage you to experiment with *steg_audio.py* and WAV files you have on
    hand. When you’re ready, read on to walk through the code.
  prefs: []
  type: TYPE_NORMAL
- en: '***The steg_audio.py Code***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The file *steg_audio.py* consists of five functions and a small driver at the
    bottom. We’re already familiar with the `MakeBit`, `MakeByte`, and `MessageLength`
    functions (see [Listings 2-7](ch02.xhtml#ch02list07), [2-8](ch02.xhtml#ch02list08),
    and [2-9](ch02.xhtml#ch02list09)).
  prefs: []
  type: TYPE_NORMAL
- en: The remaining two are the `Encode` and `Decode` functions. You might notice
    a trend here. The overall structure of *steg_audio.py* matches the structure of
    *steg_random.py*. Let’s peruse `Encode` to follow the process in this case. It’s
    best to absorb the function piecemeal, so [Listing 2-10](ch02.xhtml#ch02list010)
    shows the first part.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 2-10: Hiding data in an audio file (part 1)*'
  prefs: []
  type: TYPE_NORMAL
- en: The first paragraph of [Listing 2-10](ch02.xhtml#ch02list010) is identical to
    the corresponding code in *steg_random.py*. The file to embed is loaded and converted
    to bits after prepending the file size in bytes (`src`).
  prefs: []
  type: TYPE_NORMAL
- en: The second paragraph reads the audio file, keeping the sampling rate (`sample_rate`)
    and the raw samples as signed 16-bit integers (`raw`). Next, the `if` interprets
    the samples as unsigned 16-bit integers while also selecting channel 0 if more
    than one channel exists. The net result is `samples`, the actual values we’ll
    update. The third paragraph is a sanity check to see if there are enough samples
    to hide the source file.
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 2-11](ch02.xhtml#ch02list011) shows the remainder of `Encode`.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 2-11: Hiding data in an audio file (part 2)*'
  prefs: []
  type: TYPE_NORMAL
- en: With the samples prepared, we’re ready to hide some data. First, we create a
    vector of offsets using the supplied key (`step`). We did the same with *steg_random.py*.
    The offsets are used to build `idx`, a vector of samples to modify. A final sanity
    check confirms there are enough samples.
  prefs: []
  type: TYPE_NORMAL
- en: The second `for` loop sets the least-significant bit of the selected samples,
    altering it by 1 as necessary to make it odd or even depending on the current
    bit (`src[i]`).
  prefs: []
  type: TYPE_NORMAL
- en: The loop body needs some explanation. If the current source bit is a 0, there
    are two possibilities for the current sample (`samples[idx[i]]`). If the sample
    is odd, meaning the remainder after dividing by 2 is 1, we subtract 1 from the
    sample to make it even. Otherwise, the bit we want to store is a 1, meaning we
    check to see if the sample is currently even, and if it is, we add 1 to make it
    odd.
  prefs: []
  type: TYPE_NORMAL
- en: The final paragraph reinterprets the samples as signed integers (`out`) and
    writes them to disk using the original sample rate. If the audio file is stereo,
    channel 0 is updated, leaving the other channels as they were.
  prefs: []
  type: TYPE_NORMAL
- en: To extract a hidden file, we reverse the process with `Decode`, as shown in
    [Listing 2-12](ch02.xhtml#ch02list012).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 2-12: Decoding data hidden in an audio file*'
  prefs: []
  type: TYPE_NORMAL
- en: 'There are four steps: read the encoded WAV file as unsigned integer samples,
    generate the same set of indices as used to encode the file, extract the bits,
    and write them to disk.'
  prefs: []
  type: TYPE_NORMAL
- en: In the second paragraph, the pseudorandom generator is configured as in `Encode`
    before generating the first 32 step values to extract the encoded file length.
    We need the length to know how many samples to query to reconstruct the hidden
    file. Notice the call to `MessageLength`, [Listing 2-9](ch02.xhtml#ch02list09).
  prefs: []
  type: TYPE_NORMAL
- en: In the third paragraph, the actual bits of the file are extracted now that we
    know how many there are. To finish, the bits are converted to bytes and written
    to the output file (`dfile`).
  prefs: []
  type: TYPE_NORMAL
- en: Let’s try hiding data in images next. The process is similar to hiding data
    in a file of random bytes or in an audio file, but we’ll dispense with the notion
    of a secret key.
  prefs: []
  type: TYPE_NORMAL
- en: '### **In an Image File**'
  prefs: []
  type: TYPE_NORMAL
- en: 'For the final experiment of this chapter, we’ll hide files in images. The method
    should be familiar: we’ll scatter the bits of the file across the pixels of the
    image by making small changes to the existing pixel colors. This is the most compact
    experiment in terms of code, but we need to discuss a few things about digital
    images before diving in. Specifically, we need to understand how computers store
    and interpret images, after which I can describe the algorithm. Experiments follow
    before a code walkthrough. You know the drill.'
  prefs: []
  type: TYPE_NORMAL
- en: '***Defining Image Formats***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The phrase “image format” has multiple meanings, especially when working in
    Python.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first references how the image is stored on disk. There are many options
    that fall primarily into two camps: lossy and lossless.'
  prefs: []
  type: TYPE_NORMAL
- en: Lossy image formats compress by throwing information away, much like an MP3
    file. The information retained is sufficient to reconstruct the image to some
    level of fidelity with the original. The most common lossy image format is JPEG,
    which usually has a *.jpg* file extension. This format uses discrete cosine transforms
    across small patches to retain essential levels of detail while discarding those
    that don’t contribute substantially to the reconstruction of the image.
  prefs: []
  type: TYPE_NORMAL
- en: 'Lossless image formats either retain all pixel information or compress the
    image losslessly, meaning the recovered data is a bit-for-bit match with the original,
    uncompressed image. The most common lossless image format is PNG (*.png*). We’ll
    restrict ourselves to using only PNG files, as lossy formats like JPEG aren’t
    acceptable for the same reason MP3 files aren’t: the subtle changes made to the
    image will be lost. Advanced steganographic techniques are robust to lossy formats,
    but they are far beyond what we can explore here.'
  prefs: []
  type: TYPE_NORMAL
- en: “Image format” also refers to the pixels themselves, with the main divisions
    being grayscale and color.
  prefs: []
  type: TYPE_NORMAL
- en: 'A grayscale image is the simplest: each pixel is a single number, a byte, representing
    the intensity of the pixels from black (0) to white (255) and shades of gray in
    between. Grayscale images with 16-bit pixels are rare, so we’ll ignore them here.'
  prefs: []
  type: TYPE_NORMAL
- en: Computers have many options when representing color images. It’s most common
    to separate the color of each pixel into a combination of red, green, and blue.
    That is, a pixel showing as a whitish red can be represented as a mix of red,
    green, and blue that arrives at that color. The red, green, and blue *channels*
    are typically bytes, with 0 meaning none of that color and 255 being maximum intensity
    for that color. For example, the whitish red color is `A94141`, which is a triplet
    of hexadecimal numbers for the amount of red, green, and blue. Converting the
    hexadecimal to decimal, we have 169 out of 255 red, 65 green, and 65 blue.
  prefs: []
  type: TYPE_NORMAL
- en: '#### ***Using NumPy and PIL***'
  prefs: []
  type: TYPE_NORMAL
- en: To NumPy, a grayscale image is a 2D array of bytes. Likewise, a color image,
    or RGB image, is a 3D array of bytes—one 2D array for each color channel. We’ll
    use RGB images for the upcoming experiments. If a grayscale image is loaded, it
    will be converted to RGB by duplicating the grayscale values for each channel.
  prefs: []
  type: TYPE_NORMAL
- en: 'NumPy will use the images as arrays, but how do we get them into Python in
    the first place? For that, we need the *Python Imaging Library (PIL)*, now called
    *Pillow*. It’s included with most Linux distributions and is available for Windows
    and macOS. For Linux and macOS, enter the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: Any version 8.4 or later should work. We need it only to read and write image
    files.
  prefs: []
  type: TYPE_NORMAL
- en: 'The book’s GitHub page includes a collection of standard test images. We’ve
    used several already without bringing them into Python. Let’s remedy that now:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: Here, I’m showing the Python prompt and the commands entered manually. The first
    two lines load NumPy and PIL’s `Image` class. We only need `Image`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next two lines load the file *apples.png* into `im`, an instance of the
    `Image` class. To make the image a NumPy array, pass it to `np.array` to create
    `d`. Notice `d`’s shape: (352, 375, 3). The image has 352 rows, its height, and
    375 columns, its width. The final dimension is 3 for the red, green, and blue
    channels.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following two lines load *barbara.png* and convert it to a NumPy array.
    In this case, the array has only two dimensions: height and width, both 256\.
    This is a grayscale file with one channel.'
  prefs: []
  type: TYPE_NORMAL
- en: The final three commands load *barbara.png* a second time but immediately pass
    the image to the `Image`’s `convert` method to turn it into an RGB image. The
    NumPy array now has three dimensions, though as a grayscale image, each color
    channel is the same.
  prefs: []
  type: TYPE_NORMAL
- en: 'While many books have been written on image processing in Python, fortunately
    all we need to know is how to open an image file, ensure that it’s RGB, turn it
    into a NumPy array, and write a NumPy array to disk as an image. Continuing with
    the previous example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: The first line rereads *apples.png* and then immediately changes it into a NumPy
    array. We’ll use this idiom consistently.
  prefs: []
  type: TYPE_NORMAL
- en: The next three lines swap the red and green color channels. Read through them
    carefully. Since NumPy makes the third index the channel, we need to explicitly
    mention the height and width.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next line uses `Image`’s `fromarray` method to change `d` into an `Image`
    object: `im`. The final line writes the altered image to disk as *bad_apples.png*
    using the `save` method. PIL uses the file extension to specify the format, in
    this case a PNG file. Open *bad_apples.png* to learn why I picked that name.'
  prefs: []
  type: TYPE_NORMAL
- en: '***Hiding Bits in Pixels***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In order to scatter the bits of the hidden file throughout the pixels of the
    image, we need to load the source file and convert it to bits using *MakeBit*.
    Then we load the image file, confirm it’s an RGB image, and convert it to a NumPy
    array.
  prefs: []
  type: TYPE_NORMAL
- en: Our previous experiments altered bits of the pool file to make them match the
    bits of the source file. The sequence of random offsets into the pool file was
    reproducible because we set the randomness engine’s seed to the secret key. While
    we could do the same here, we’ll take a different approach. Variety is the spice
    of life, as they say.
  prefs: []
  type: TYPE_NORMAL
- en: 'We’ll use the unaltered image as our key. When hiding a file, we’ll initialize
    the randomness engine without setting the seed, meaning each run of the code hides
    the same file in different locations in the image. Because we’re altering specific
    bits, we’ll know which bits we altered by using the unaltered image. To simplify
    things, we’ll do much as we did for the audio samples: one bit of the hidden file
    per byte of the image file.'
  prefs: []
  type: TYPE_NORMAL
- en: While we could set the least-significant bit of the pixel, as we did for the
    audio file, we’d never be able to detect where the image pixel already had the
    proper bit value. And since we’re abandoning the secret key to get a unique set
    of altered pixels per run, we’d never know which pixels happened to have the proper
    bit value by chance.
  prefs: []
  type: TYPE_NORMAL
- en: Instead of looking for bit 0 of the pixel to be 0 or 1, or equivalently asking
    if the pixel is even or odd, we’ll encode 0 bits by adding 1 to the pixel and
    1 bits by adding 2\. In this scenario, any pixel of the unaltered image that isn’t
    the same as the corresponding pixel of the altered image holds a bit of the hidden
    file.
  prefs: []
  type: TYPE_NORMAL
- en: In RGB images, each pixel is actually three bytes; we can alter any of them.
    When we implement the algorithm, we’ll *unravel* the image by asking NumPy to
    turn the three-dimensional array into a single vector, which is how the image
    data is stored in the computer’s memory. Where specific red, green, and blue bytes
    end up in the unraveled array is irrelevant as long as NumPy makes the process
    repeatable, which it does.
  prefs: []
  type: TYPE_NORMAL
- en: With the image bytes as a vector, we select a subset of locations—as many as
    there are bits in the hidden file—and alter them by adding 1 if the corresponding
    bit is a 0, or 2 if the bit is a 1.
  prefs: []
  type: TYPE_NORMAL
- en: 'Bytes are unsigned numbers in the range [0, 255], meaning if the pixel value
    is 255 and we add 1 to encode a 0, we’ll wrap around to 0 (or 1 if adding 2 for
    a 1 bit). That won’t do at all, so we make an executive decision: before encoding,
    we’ll alter all image pixel bytes greater than 253 and set them to 253 so that
    adding 1 gives us 254 and adding 2 gives 255; hence no overflow.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We’re able to alter the image pixel bytes for two reasons: the code will do
    this for the unaltered image each time, even when decoding, so it’s reproducible;
    and because the bytes represent color values, the difference between 255 and 253
    is too subtle to see, especially when there’s a global change in overall color
    intensity or shade.'
  prefs: []
  type: TYPE_NORMAL
- en: The resulting code is *steg_image.py*, which I encourage you to study before
    reading further. I’ll walk through the code after we experiment with it.
  prefs: []
  type: TYPE_NORMAL
- en: This approach is just as fragile as the audio approach. We’ll throw away the
    encoding if we store our encoded image using a lossy image format like JPEG. We
    can use a JPEG as the original image because NumPy will decode it the same way
    each time, but even that might be a risk because a future version of NumPy might
    alter the algorithm used to decode the image (this is unlikely, but possible).
    Again, we’ll restrict ourselves to using only losslessly compressed PNG files.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let’s have some fun!
  prefs: []
  type: TYPE_NORMAL
- en: '***Hiding One Image in Another***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'For our first experiment, we’ll hide an image (*cameraman.png*) within a second
    image (*apples.png*). The command line we need is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: We tell *steg_image.py* we want to encode, then provide the file to encode (*cameraman.png*)
    followed by the reference image (*apples.png*) and the output image file, *tmp.png*.
  prefs: []
  type: TYPE_NORMAL
- en: Open both *apples.png* and *tmp.png* and look carefully, flipping rapidly between
    the two if your software allows. Do you see any differences? A meticulous examination
    might reveal some, but my eye doesn’t notice anything.
  prefs: []
  type: TYPE_NORMAL
- en: 'To recover *cameraman.png*, use:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: The *cameraman.png* file is 16 percent the size of *apples.png*, and was easily
    hidden among the apples. How large can the file be before we notice it?
  prefs: []
  type: TYPE_NORMAL
- en: If you run *steg_image_test.py*, then you’ll get a new output directory, *steg_image_test*,
    containing multiple images with names like *apple_A_0.60.png* and *violet_rand_0.40.png*.
    The files are images, each hiding either a specific number of *A*s or random data
    read from `RDRAND`. The first part of the name is the test image source, *apples.png*
    or *violet.png*. The latter is a 512×512-pixel image of a light violet color.
  prefs: []
  type: TYPE_NORMAL
- en: The fraction in each name is the fraction of the reference pixel images used
    to hold the encoded data. For example, *apple_A_0.60.png* is hiding the letter
    *A* so that 60 percent of the pixels in *apples.png* have been modified. The fractions
    start at 5 percent and go up to 99 percent. Take a look at these output files,
    especially the violet ones. Even when 99 percent of the pixels have been modified
    with either the same byte repeated or highly random bytes, we’re unable to see
    a difference between the output image file and the original. This is an example
    of imperceptible steganography. For brevity, I won’t discuss *steg_image_test.py*
    in detail, but do take a look at it.
  prefs: []
  type: TYPE_NORMAL
- en: We’ve hidden an image in another image. What’s stopping us from hiding a message
    in an image, then hiding the image with the hidden message in another image, and
    so on, to produce a final output image with a set of Russian doll images inside
    it? Why, nothing at all. Let’s do it.
  prefs: []
  type: TYPE_NORMAL
- en: The script we want to run is in *russian_dolls_example*, which is shown in [Listing
    2-13](ch02.xhtml#ch02list013).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 2-13: Encoding and decoding Russian dolls*'
  prefs: []
  type: TYPE_NORMAL
- en: 'This is a shell script you can run with:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: When finished, take a look at the image with all the nested images and the original
    message, *russian_dolls.png*. Then compare the source file, *kilroy.txt*, with
    *output.txt* to see that they are the same. The intermediate images with each
    stage of the encoding process are in the system *tmp* directory.
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 2-5](ch02.xhtml#ch02fig05) shows the process of building a stack of
    Russian dolls.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/02fig05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-5: Building a stack of Russian dolls*'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, the text message “Kilroy was here” is hidden in the small version of
    the apples image. Then, that image is hidden in the peppers image, which is hidden
    in the fruit image, all of which are hidden in the tulips image as the final output.
    Reversing the process to decode step by step delivers the original message: Kilroy
    was here.'
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*The phrase “Kilroy was here” was used by American and British troops in WWII,
    partly as a joke and partly to mark places where they had already been. It caught
    on after the war, becoming an early meme of sorts, often with a silly character
    face to accompany the message.*'
  prefs: []
  type: TYPE_NORMAL
- en: Let’s walk through the code to see where Kilroy has been.
  prefs: []
  type: TYPE_NORMAL
- en: '***The steg_image.py Code***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Of all our experiments, *steg_image.py* is perhaps the simplest. It uses both
    `MakeBit` and `MakeByte`, and has a simple driver to call `Encode` and `Decode`.
    Let’s focus on those two functions, beginning with `Encode`, shown in [Listing
    2-14](ch02.xhtml#ch02list014).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 2-14: Hiding a file in an image*'
  prefs: []
  type: TYPE_NORMAL
- en: The file to hide (`mfile`) is read as bytes and immediately converted into a
    vector of bits ➊. The reference image is read next, as RGB if not already, and
    then converted to a NumPy array (`simg`).
  prefs: []
  type: TYPE_NORMAL
- en: As mentioned previously, we need to prevent overflow when encoding bits, so
    we use NumPy’s `where` function to locate the places in the image that are greater
    than 253\. The `where` function returns a collection of indices, regardless of
    the dimensionality of `simg`, that are immediately used to change said locations
    to 253, the new maximum. This covers all red, green, and blue parts of the image.
  prefs: []
  type: TYPE_NORMAL
- en: We intend to use the image as a vector, so we next grab the actual row, column,
    and channel (= 3) numbers to use later when re-forming the image.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we tell NumPy to make the three-dimensional image array a vector by calling
    `ravel` ➋. In NumPy, the word *ravel* is a contronym, a word that is its own antonym.
    In this case, ravel means to *unravel*, to change the array into a vector, a one-dimensional
    beast. After `ravel` is called, `simg` is a vector of the bytes of the image.
    We don’t care about where each specific red, green, and blue byte landed; NumPy
    applies `ravel` consistently.
  prefs: []
  type: TYPE_NORMAL
- en: We have the image as a vector of bytes and the source file as a vector of bits.
    To scatter the bits across the bytes, we need a vector of locations; that’s the
    purpose of `rng` ➌. First, we initialize `rng` using the Mersenne Twister. The
    following four lines build the vector of indices, the bytes we’ll modify (`p`).
  prefs: []
  type: TYPE_NORMAL
- en: We want `p` to have as many elements as bits in `src`. First, we set `p` to
    0, 1, 2, . . . , *n* – 1 for the *n* number of bytes in the image, `simg`. The
    resulting vector is shuffled to create a unique permutation of the values.
  prefs: []
  type: TYPE_NORMAL
- en: The following two lines keep as many elements of `p` as we need to place each
    bit of the source file (`msg`) and sort `p` so the list of indices is in order
    numerically. This last step is necessary because we’re not setting `rng`’s seed,
    so we must apply some order to the image bytes updated to preserve the order of
    the bits in `msg`. You’ll see what I mean when we review `Decode`.
  prefs: []
  type: TYPE_NORMAL
- en: To scatter the bits of `msg` we need only iterate over them and use the corresponding
    index in `p` ➍. We add the bit value plus 1 so that 0 bits become 1 and 1 bit
    becomes 2\. This change lets us detect all altered bits by using the reference
    image as the key.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we `reshape` the updated image bytes to create the 3D output array.
    Notice that `reshape` applies the proper reinterpretation of the bytes in memory,
    an interpretation that matches the order used by `ravel`. In other words, `reshape`
    ravels the array in the opposite sense of the word. The array is passed to the
    PIL `Image` class to be output as a PNG file.
  prefs: []
  type: TYPE_NORMAL
- en: As shown in [Listing 2-15](ch02.xhtml#ch02list015), `Decode` recovers hidden
    files using the reference image as a key.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 2-15: Decoding an image*'
  prefs: []
  type: TYPE_NORMAL
- en: '`Decode` loads two image files, the one with the hidden data (`dimg`) and the
    reference image (`simg`), as NumPy arrays. The function then immediately converts
    both image files to vectors of bytes, and the reference image is passed through
    `convert` to make it an RGB image, as `Encode` did. Also as in `Encode`, reference
    image byte values above 253 are set to 253.'
  prefs: []
  type: TYPE_NORMAL
- en: NumPy’s `where` returns all the locations where the two images disagree. Because
    we assume the reference image is *exactly* the same image used when creating `dimg`,
    any differences represent bits of the hidden file.
  prefs: []
  type: TYPE_NORMAL
- en: The difference between the encoded image and the reference image gives us the
    bit values, but as 1 and 2, not 0 and 1\. Therefore, we subtract one more to make
    `d` the vector of hidden bit values. Because we insisted that the bytes were altered
    in numerical order when encoding, the order in which the difference appears in
    the image matches the proper order for the output bits. In other words, we don’t
    need to sort anything; the indices returned by `where` are already in sorted order.
  prefs: []
  type: TYPE_NORMAL
- en: The remaining two lines convert `d` to bytes and write them to the output file
    (`mfile`).
  prefs: []
  type: TYPE_NORMAL
- en: '**Exercises**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Steganography offers many possibilities. Here are some to explore and contemplate:'
  prefs: []
  type: TYPE_NORMAL
- en: Bacon’s cipher uses subtle changes in the type to embed binary codes representing
    letters. What needs to change to embed arbitrary binary data in a text block?
    What about using spaces between words with a proportional font?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Make your own “spaceship cipher” to hide secret messages in drawings. This might
    be a good activity for the kids.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Our text experiments neglected to encode the spaces between words. Remedy that
    oversight.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Can you think of a simple sentence structure with many word options and use
    that to encode a text message à la *steg_text.py*? Generate random sentences using
    a large pool of adjectives, adverbs, nouns, and verbs, so the output reads as
    grammatically correct sentences.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We used channel 0 when hiding data in audio files. Use both stereo channels
    to double the amount of data that can be encoded.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Replicate hiding binary data in a file of random bytes, but substitute an audio
    file of white noise (random samples). This removes the restriction on changing
    only the lowest-order bit of each sample. How much data can you fit using both
    channels before the sound changes? What does a file of random bytes sound like
    in the first place? Might sound be a good way to detect randomness in data?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Lossy image compression destroys our simple approach of changing byte values
    to encode information. How might we add redundancy so that the message persists
    even after using JPEG compression?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What happens to image encoding when the image is resized? Can you think of a
    way to preserve the message using nearest-neighbor sampling? Nearest-neighbor
    sampling duplicates existing pixels when expanding the image and throws pixels
    away when shrinking the image, that is, it does not interpolate.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let me know what you think and how it goes.
  prefs: []
  type: TYPE_NORMAL
- en: '**Summary**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This chapter explored randomness and steganography, the hiding of information.
    We first defined the term, and then contemplated a smattering of historical uses.
    That section alone could easily be a separate book, but it set the stage for the
    experiments.
  prefs: []
  type: TYPE_NORMAL
- en: First, we hid text in other text using random selections of letters in a list
    of discrete words. Pseudorandom generators proved helpful with the seed, the secret
    key necessary for correctly decoding the hidden message.
  prefs: []
  type: TYPE_NORMAL
- en: The following experiment worked with a file of random bytes. The hidden data
    was scattered, bit by bit, throughout the random data, again using the pseudorandom
    generator seed as the secret key. We found that a ratio of about 100:1 between
    the size of the random data and the hidden data generally preserved sufficient
    randomness in the output to properly conceal our message.
  prefs: []
  type: TYPE_NORMAL
- en: Then we scattered the bits of the hidden file across bit 0 of a set of WAV sound
    samples; this led to an output audio file that gave no auditory indication it
    had been altered. However, a statistical test on the distribution of bit 0 for
    the WAV file revealed evidence of tampering, though extraction of the hidden data
    remained extremely difficult.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we used the color information in a reference image to embed a file.
    In this experiment, no secret key was necessary; the reference file itself was
    the key. Each encoding generated a different collection of altered image bytes
    at the expense of requiring the entire reference image as the key. We learned
    how computers store and manipulate color images and how to work with image data
    in NumPy. We’ll use this knowledge again in [Chapter 5](ch05.xhtml).
  prefs: []
  type: TYPE_NORMAL
- en: 'It isn’t difficult to imagine illegitimate uses of steganography. I’m reminded
    here of the wisdom of Ben Parker: with great power comes great responsibility.
    If you’re inclined to use steganography for something other than simple “I wonder
    if it would work” experiments, think carefully about it, put this book down, get
    a cup of coffee, take a walk, and forget about it.'
  prefs: []
  type: TYPE_NORMAL
- en: The next chapter introduces us to the vast, randomness-heavy world of simulation.
    I think it’ll be fun. I hope you agree.
  prefs: []
  type: TYPE_NORMAL
- en: Read *poem.txt*. It’s an Easter egg.
  prefs: []
  type: TYPE_NORMAL
