- en: '**2'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '**2'
- en: HIDING INFORMATION**
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 隐藏信息**
- en: '![Image](../images/common.jpg)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/common.jpg)'
- en: '*Steganography*, from the Greek term for “covered writing,” is the art of concealing
    a message so that adversaries aren’t aware that the message is present. Unlike
    cryptography, which relies on the difficulty of undoing the algorithm that generated
    the encrypted message, steganography relies on secrecy. Anyone can read the covered
    message if they know how the message is hidden. If the art of hiding a message
    is called steganography, then *steganalysis* is the process of detecting hidden
    messages. It’s a classic arms race: steganographers improve their techniques while
    steganalysis attempts to thwart them.'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: '*隐写术*（Steganography），源自希腊语“隐蔽写作”，是一种隐藏信息的艺术，使得敌人无法察觉该信息的存在。与加密术不同，加密术依赖于破解加密算法的困难，而隐写术则依赖于保密性。只要知道如何隐藏信息，任何人都可以读取被隐藏的信息。如果隐藏信息的艺术被称为隐写术，那么*隐写分析*就是检测隐藏信息的过程。这是一个经典的军备竞赛：隐写术专家改进他们的技术，而隐写分析则试图阻止他们。'
- en: While steganography exists anywhere a 0 and 1 can be hidden, it is most commonly
    found in text, binary files, audio, video, and images. Excepting video, these
    are also the targets of our experiments.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管隐写术可以在任何可以隐藏0和1的地方存在，但它最常见于文本、二进制文件、音频、视频和图像中。除了视频之外，这些也是我们实验的目标。
- en: '### **In Strings**'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: '### **在字符串中**'
- en: This section presents two experiments with text. The first hides a message in
    a string of words using a fixed offset, and the second uses random offsets.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 本节展示了两个文本实验。第一个使用固定偏移隐藏信息，第二个则使用随机偏移。
- en: '**A BRIEF HISTORY OF DECEPTION**'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: '**欺骗的简短历史**'
- en: Steganography has been around for a long time, in close association with cryptography.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 隐写术已经存在了很长时间，并且与加密术紧密相连。
- en: In the 5th century BCE, the ancient Greek author, Herodotus, related a story
    about Histiaeus, exiled tyrant of Miletus, in what is now modern-day Turkey. He
    claims that Histiaeus shaved the head of a slave and tattooed a message on his
    scalp, then waited for the man’s hair to grow back before sending him to Miletus.
    Friends of Histiaeus shaved the man’s head and read the message—instructions to
    revolt against the Persians. Ultimately, the revolt failed and Histiaeus’s head
    was sent to the Persian king, Darius.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 公元前5世纪，古希腊作家希罗多德讲述了关于米利都的流放暴君赫斯提亚乌斯的故事，米利都位于现代土耳其。他声称赫斯提亚乌斯剃光了一名奴隶的头发，并在他的头皮上刺上了一条信息，然后等待奴隶的头发长回，再将他送往米利都。赫斯提亚乌斯的朋友剃了那名奴隶的头发，并读取了信息——这是一条反对波斯人起义的指令。最终，起义失败，赫斯提亚乌斯的头颅被送给了波斯国王大流士。
- en: In 1605, Sir Francis Bacon developed a secretive communication method that combines
    steganography and cryptography. First, Bacon devised a five-digit binary code
    for each letter of the alphabet. Then, he used the cipher to hide messages in
    ordinary text with slight modifications to the font to indicate a 0 or 1 (Bacon
    used “a” and “b” in place of 0 and 1).
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 1605年，弗朗西斯·培根爵士开发了一种结合隐写术和加密术的秘密通信方法。首先，培根为字母表中的每个字母设计了一个五位二进制代码。然后，他使用该密码通过对字体做微小修改来隐藏信息，以表示0或1（培根用“a”和“b”代替0和1）。
- en: 'For example, we might hide the message “EAT AT JOES” using this cipher as:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们可能会用这种密码隐藏信息“EAT AT JOES”：
- en: '[PRE0]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The first line shows the text, a line from *Alice’s Adventures in Wonderland*,
    where lowercase letters represent “a” and uppercase represent “b.” In practice,
    the font used for “a” letters would be almost, but not quite, the same as the
    font used for “b” letters. The actual Bacon cipher for each letter of the message
    is on the second line. To figure out the message, we organize the letters in groups
    of five like so:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 第一行展示了文本，这是《爱丽丝梦游仙境》中的一行，其中小写字母代表“a”，大写字母代表“b”。实际上，“a”字母使用的字体几乎与“大写b”的字体相同，但稍有不同。每个信息字母的实际培根密码在第二行显示。为了找出消息，我们将字母按五个一组组织，如下所示：
- en: '![Image](../images/f0040-01.jpg)'
  id: totrans-14
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/f0040-01.jpg)'
- en: '***Fixed Offset***'
  id: totrans-15
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***固定偏移***'
- en: 'During WWI, a German spy sent the following message from New York:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一次世界大战期间，一名德国间谍从纽约发出了以下消息：
- en: Apparently neutral’s protest is thoroughly discounted and ignored. Isman hard
    hit. Blockade issue affects pretext for embargo on by-products, ejecting suets
    and vegetable oils.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，中立者的抗议完全被忽视和拒绝。伊斯曼遭受重创。封锁问题影响了对副产品的禁运借口，排除了动物脂肪和植物油。
- en: 'The missive contains a hidden message. Extracting the second letter of each
    word gives us:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 该信件包含一条隐藏的信息。提取每个单词的第二个字母，我们得到：
- en: Pershing sails from NY June 1.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 珀尔辛号从纽约出发，日期为6月1日。
- en: Note that we’re interpreting the final “i” as “1.” The message was useless in
    the end as Pershing sailed from New York on May 28.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们将最终的“i”解释为“1”。最终，消息变得毫无意义，因为珀辛将船从纽约开出，日期是 5 月 28 日。
- en: While using the second letter is better than the first as it’s more challenging
    to accidentally spot the message, security is still low. However, this idea provides
    a starting point for hiding messages in a string of words. Let’s begin by developing
    a script to embed a text message using words from a *pool text*, a large text
    document from which we select words, and a selected letter offset from the beginning
    of each word. There is no randomness to this example, but it sets us up for the
    following experiment.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管使用第二个字母比第一个字母更好，因为它更难意外地发现消息，但安全性仍然较低。然而，这个想法为将消息隐藏在单词串中提供了一个起点。我们从开发一个脚本开始，使用来自
    *池文本*（一个包含大量文本的文档，从中选择单词）和每个单词的选定字母偏移来嵌入文本消息。这个示例没有随机性，但它为接下来的实验做了准备。
- en: 'Here’s our approach:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们的方法：
- en: Select a letter offset from the beginning of the word. The German spy used an
    offset of one for the second letter of each word. Recall that computer scientists
    use zero-based numbering, starting at 0 rather than 1.
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从单词的开头选择一个字母偏移量。德国间谍为每个单词的第二个字母使用了偏移量为 1。回想一下，计算机科学家使用的是零基计数，从 0 开始，而不是从 1 开始。
- en: Hide a source message, text only, by selecting words from a pool text—for example,
    a book—such that the current letter of the word is the offset letter of the selected
    word.
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过从池文本（例如一本书）中选择单词来隐藏一个源消息（仅文本），使得每个单词的当前字母就是所选单词的偏移字母。
- en: Write the resulting list of words to disk as the hidden message.
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将生成的单词列表写入磁盘，作为隐藏消息。
- en: The source code we need is in *steg_simple.py*. I suggest reviewing it before
    continuing. Notice that the file does not import `RE`; there is nothing random
    here.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要的源代码在 *steg_simple.py* 中。建议在继续之前先查看它。请注意，文件没有导入 `RE`，这里没有任何随机性。
- en: 'To learn how it works, here’s an example that hides the contents of *message.txt*
    using words selected from *alice.txt* with an offset of 2:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解它是如何工作的，这里有一个示例，通过使用偏移量为 2 从 *alice.txt* 中选择单词来隐藏 *message.txt* 的内容：
- en: '[PRE1]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Use the command line
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 使用命令行
- en: '[PRE2]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'to produce the following in *output.txt*:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 生成以下内容并保存到 *output.txt*：
- en: '[PRE3]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The offset is zero-based, meaning an offset of 0 uses the first letter, so
    an offset of 2 uses the third letter. With that in mind, we see the embedded message
    as:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 偏移量是基于零的，意味着偏移量为 0 使用第一个字母，因此偏移量为 2 使用第三个字母。考虑到这一点，我们可以看到嵌入的消息是：
- en: '[PRE4]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Every underlined letter of which is the message:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 每个下划线字母就是消息的内容：
- en: '[PRE5]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: First, *steg_simple.py* reads the message file, removes any characters that
    aren’t letters, and then uppercases the remaining characters. The result is a
    Python list of the words in the message. The pool text receives similar treatment.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，*steg_simple.py* 读取消息文件，去除所有不是字母的字符，然后将剩余字符转为大写。结果是一个包含消息中单词的 Python 列表。池文本也会做类似的处理。
- en: Next, *steg_simple.py* processes each word of the message, letter by letter,
    scanning the pool text for words where the offset letter matches the current message
    letter. Each match is appended to the output list of words. When all message letters
    have been similarly processed, the output list is written to disk.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，*steg_simple.py* 逐个字母处理消息中的每个单词，通过扫描池文本来查找字母偏移与当前消息字母匹配的单词。每找到一个匹配项，就将其附加到输出的单词列表中。当所有的消息字母都被类似地处理后，输出列表会被写入磁盘。
- en: 'Changing the offset modifies the output list; for example, making it 3 in the
    previous listing results in the following:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 改变偏移量会修改输出列表；例如，将其设置为 3 会得到如下结果：
- en: '[PRE6]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Now that we’ve embedded the message, let’s get it back:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经嵌入了消息，让我们把它取回来：
- en: '[PRE7]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The *tmp.txt* file contains the following:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '*tmp.txt* 文件包含以下内容：'
- en: '[PRE8]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: We’ve lost punctuation and spaces, and the message is screaming at us in all
    caps, but it’s discernible.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 我们丢失了标点和空格，消息以全大写字母形式“喊”出来，但它是可以辨认的。
- en: Now let’s walk through the source code for this example. Both the input message
    and, if encoding, the pool file are run through `ProcessText` to remove non-letters
    and return a list of words, as shown in [Listing 2-1](ch02.xhtml#ch02list01).
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们逐步分析这个示例的源代码。输入消息和（如果是编码）池文件都会通过 `ProcessText` 处理，去除非字母字符并返回一个单词列表，如 [清单
    2-1](ch02.xhtml#ch02list01) 所示。
- en: '[PRE9]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '*Listing 2-1: Converting a string of text to a list of words*'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 2-1：将一串文本转换为一个单词列表*'
- en: The outer loop processes the list of words generated by the first line (`s`).
    This list still contains non-space characters. The inner loop over the characters
    of each word in `s` builds the letters-only version and appends it to `text`.
    When all is said and done, the function returns `text`.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 外部循环处理由第一行（`s`）生成的单词列表。该列表仍然包含非空格字符。内部循环遍历每个单词的字符，构建仅包含字母的版本，并将其附加到`text`中。完成所有操作后，函数返回`text`。
- en: The bottom of *steg_simple.py* interprets the command line according to the
    mode, encode or decode. The code is shown in [Listing 2-2](ch02.xhtml#ch02list02).
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '*steg_simple.py* 的底部根据模式解析命令行，是编码还是解码。代码展示在[Listing 2-2](ch02.xhtml#ch02list02)中。'
- en: '[PRE10]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '*Listing 2-2: Parsing the command line*'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '*Listing 2-2: 解析命令行*'
- en: All the action is in `Encode` and `Decode`. Let’s begin with `Encode`, as in
    [Listing 2-3](ch02.xhtml#ch02list03).
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 所有的操作都在`Encode`和`Decode`中进行。我们先从`Encode`开始，如[Listing 2-3](ch02.xhtml#ch02list03)所示。
- en: '[PRE11]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '*Listing 2-3: Encoding the message*'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '*Listing 2-3: 编码消息*'
- en: First, `Encode` reads and processes both the message and pool text ➊. Next comes
    a triply nested loop ➋, first to process each word of the message (`msg`), then
    character by character (`c`), and lastly to search the pool text (`pool`) for
    a word where the offset character matches. The index into the pool text (`idx`)
    is set to zero initially and only ever incremented afterward, so the per-character
    search does not begin from the start each time but continues moving through the
    pool text file. In theory, this means the set of selected words is more diverse,
    as the same word is not selected repeatedly to match the same character of the
    message.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，`Encode`读取并处理消息和池文本 ➊。接下来是一个三重嵌套的循环 ➋，首先处理消息中的每个单词（`msg`），然后逐个字符处理（`c`），最后在池文本（`pool`）中搜索与偏移字符匹配的单词。池文本的索引（`idx`）最初设置为零，并且之后只会递增，因此每次字符的搜索不会从头开始，而是继续在池文本文件中移动。理论上，这意味着选中的单词集合更加多样化，因为相同的单词不会重复选择以匹配消息中的相同字符。
- en: After processing the entire message, `enc` contains the selected words in order.
    All that remains is to dump them to disk ➌. Notice the Python idiom to convert
    a list of words into a single string by calling the `join` method on a string
    constant (a space) before appending a final newline character.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 处理完整个消息后，`enc`按顺序包含了选中的单词。剩下的就是将它们写入磁盘 ➌。注意Python的惯用法，通过在字符串常量（一个空格）上调用`join`方法将单词列表转换为单个字符串，最后添加一个换行符。
- en: Decoding a message is less involved, as shown in [Listing 2-4](ch02.xhtml#ch02list04).
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 解码消息的过程相对简单，如[Listing 2-4](ch02.xhtml#ch02list04)所示。
- en: '[PRE12]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '*Listing 2-4: Decoding the message*'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '*Listing 2-4: 解码消息*'
- en: '`Decode` processes the encoded message file to make a list of words (`enc`).
    Then the function examines each word, extracts the `offset` letter, and adds it
    to `plain`, the output string. Finally, `Decode` dumps the output string to the
    decoded message file.'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '`Decode`处理编码后的消息文件，生成一个单词列表（`enc`）。然后该函数检查每个单词，提取`offset`字母，并将其添加到`plain`中，这是输出字符串。最后，`Decode`将输出字符串写入解码后的消息文件。'
- en: '***Random Offset***'
  id: totrans-62
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***随机偏移***'
- en: The previous experiment works, but it’s not too difficult to defeat. A bit of
    trial and error will locate the offset and reveal the hidden message. We can do
    slightly better by changing the offset at random so that the third letter of the
    first word is important, the fifth letter of the second, the first followed by
    the third again, and so on. The result is still not particularly secure but is
    likely to confound accidental discovery of the message.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的实验有效，但并不难被破解。通过一些试验和错误，可以找到偏移并揭示隐藏的信息。我们可以通过随机改变偏移值来稍微提高安全性，使得第一个单词的第三个字母很重要，第二个单词的第五个字母很重要，接着是第一个字母和第三个字母，依此类推。结果仍然不是特别安全，但可能会使得意外发现信息变得困难。
- en: The file *steg_text.py* implements this approach and introduces us to a technique
    we’ll use throughout the remainder of the chapter, namely using a randomness engine
    with a fixed seed to generate a deterministic sequence of randomly selected offsets.
    Let’s take a look at what this approach buys us.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 文件*steg_text.py*实现了这种方法，并引入了我们将在本章剩余部分使用的一种技术，即使用固定种子的随机引擎生成一个确定性的随机选择偏移序列。让我们看看这种方法能为我们带来什么。
- en: 'First, we run *steg_text.py* on the same input message as the quotation about
    not sharing secrets. In this case, the command line is:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们在与关于不共享秘密的引用相同的输入消息上运行*steg_text.py*。在这种情况下，命令行是：
- en: '[PRE13]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Take note of the “secret key,” which is, in reality, a pseudorandom number generator
    seed. We won’t be able to recover the hidden message without it.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意“秘密密钥”，它实际上是一个伪随机数生成器种子。没有它，我们无法恢复隐藏的消息。
- en: 'Each run of *steg_text.py* produces a new *output.txt* and secret key. For
    the previous run, *output.txt* became:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 每次运行 *steg_text.py* 都会生成一个新的 *output.txt* 和秘密密钥。对于之前的运行，*output.txt* 变成了：
- en: '[PRE14]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'This corresponds to per-word offsets of:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 这对应于每个单词的偏移量：
- en: '[PRE15]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The offsets are selected pseudorandomly using the reported seed, which here
    is 499,377.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 偏移量是使用报告的种子伪随机选择的，这里的种子是 499,377。
- en: 'To recover the original message, use:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 要恢复原始消息，请使用：
- en: '[PRE16]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: With *steg_text.py*, the output is harder to parse because the offsets are random.
    If we knew there was a hidden message, it would require effort to recover it because
    of the many paths through the letters of each word. For example, [Figure 2-1](ch02.xhtml#ch02fig01)
    shows every path through the first three words, for a total of 40 combinations.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 *steg_text.py* 时，输出更难解析，因为偏移量是随机的。如果我们知道有隐藏消息，就需要付出努力去恢复它，因为每个单词字母的路径有很多种选择。例如，[图
    2-1](ch02.xhtml#ch02fig01)展示了通过前面三个单词的所有路径，总共有 40 种组合。
- en: '![Image](../images/02fig01.jpg)'
  id: totrans-76
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/02fig01.jpg)'
- en: '*Figure 2-1: All the paths through the first three words*'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 2-1：通过前三个单词的所有路径*'
- en: 'Each combination is as follows:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 每个组合如下：
- en: '![Image](../images/f0045-01.jpg)'
  id: totrans-79
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/f0045-01.jpg)'
- en: 'The combinations ITH, ITE, TWE, THE, THR, TAR, TAH are the only possible beginnings
    of common English words, for example: Ithaca, item, tweet, theme, three, tarnish,
    and tahini. The fourth word, THE, adds one more letter to each of the existing
    prefixes, of which only THRE and TART seem plausible. The following word, HEAR,
    makes it clear that the first word of the message is likely THREE or the beginning
    of the next word after TART, assuming the message isn’t itself encrypted.'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 组合 ITH、ITE、TWE、THE、THR、TAR、TAH 是常见英语单词可能的开头，例如：Ithaca、item、tweet、theme、three、tarnish
    和 tahini。第四个单词 THE 给每个现有的前缀加了一个字母，其中只有 THRE 和 TART 看起来是合理的。接下来的单词 HEAR 让人清楚地知道，消息的第一个单词很可能是
    THREE，或者是 TART 后面下一个单词的开头，假设消息本身没有被加密。
- en: The source code for this example is similar to *steg_simple.py* and uses the
    same `ProcessText` function shown in [Listing 2-1](ch02.xhtml#ch02list01). The
    important parts for us are the encoder and decoder functions. Let’s start with
    the encoder, shown in [Listing 2-5](ch02.xhtml#ch02list05).
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 这个示例的源代码类似于 *steg_simple.py*，并使用了[清单 2-1](ch02.xhtml#ch02list01)中显示的相同 `ProcessText`
    函数。对我们来说，重要的部分是编码器和解码器函数。我们从编码器开始，如[清单 2-5](ch02.xhtml#ch02list05)所示。
- en: '[PRE17]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '*Listing 2-5: Encoding with random offsets*'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 2-5：使用随机偏移进行编码*'
- en: As with *steg_simple.py*, the message and pool files are loaded and processed.
    The secret key is selected using the default randomness engine, PCG64 ➊. With
    `key` in hand, a new generator is initialized with `key` as the seed (`rng`).
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 和 *steg_simple.py* 一样，消息和池文件会被加载和处理。秘密密钥是使用默认的随机引擎 PCG64 ➊ 选择的。手中有了 `key`，一个新的生成器就会使用
    `key` 作为种子（`rng`）进行初始化。
- en: Each letter of the message is encoded by searching the pool for a matching word,
    but this time, the generator ➋ returns the `offset` to use. After all message
    letters have been processed, the function writes the final output file and reports
    the secret key ➌. Compare [Listing 2-5](ch02.xhtml#ch02list05) with [Listing 2-3](ch02.xhtml#ch02list03);
    the fixed `offset` is now replaced by a randomly generated one.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 每个消息字母通过在池中搜索匹配的单词来编码，但这次，生成器 ➋ 返回要使用的 `offset`。在所有消息字母处理完毕后，函数会写入最终输出文件并报告秘密密钥
    ➌。请比较[清单 2-5](ch02.xhtml#ch02list05)和[清单 2-3](ch02.xhtml#ch02list03)；固定的 `offset`
    现在被随机生成的值替代了。
- en: The decoder is shown in [Listing 2-6](ch02.xhtml#ch02list06).
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 解码器在[清单 2-6](ch02.xhtml#ch02list06)中展示。
- en: '[PRE18]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '*Listing 2-6: Decoding with random offsets*'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 2-6：使用随机偏移进行解码*'
- en: The secret key forms the seed for the generator; then, the message is decoded
    word by word using the next value from the generator before writing the message
    to disk.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 秘密密钥构成了生成器的种子；然后，消息按单词解码，每次使用生成器中的下一个值，最后将消息写入磁盘。
- en: Some may object at this point as the experiments select words that, while actual
    words, do not form a meaningful sentence, which might tip off an adversary. I
    agree. My defense is that a simple program cannot generate a meaningful sentence,
    but we are still embedding a message and therefore following the spirit of steganography,
    if not the absolute law of it. Fear not; experiments later in the chapter produce
    unambiguous results.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 有人可能会反对，因为实验中选用的词语虽然是实际存在的词，但并没有形成有意义的句子，这可能会引起对手的注意。我同意这种看法。我的辩护是，简单的程序无法生成有意义的句子，但我们仍然在嵌入一个消息，因此我们仍然遵循隐写术的精神，即便没有完全遵守它的绝对规则。别担心，章节后面的实验会给出明确的结果。
- en: Steganography with text is merely a warm-up exercise, as we can make better
    use of what the digital age offers. So let’s leave text behind and progress to
    hiding arbitrary files in other files.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 使用文本隐写术只是热身练习，因为我们可以更好地利用数字时代所提供的工具。所以，让我们放弃文本，转向隐藏任意文件到其他文件中的方法。
- en: '**In Random Data**'
  id: totrans-92
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**在随机数据中**'
- en: In [Chapter 1](ch01.xhtml), we used `ent` as a tool to help us decide whether
    a file contains random data. Here we’ll embed an arbitrary file inside a file
    of random data so that tools like `ent` still lead us to believe the file contains
    random data, even though it no longer does. This is true steganography in that
    the file appears random both before and after embedding the data we wish to hide.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第1章](ch01.xhtml)中，我们使用了`ent`工具来帮助我们判断文件是否包含随机数据。在这里，我们将一个任意文件嵌入到一个随机数据的文件中，目的是使得像`ent`这样的工具仍然让我们相信该文件包含随机数据，尽管实际上它不再是随机的。这才是真正的隐写术，因为在嵌入我们希望隐藏的数据之前和之后，文件看起来都是随机的。
- en: To accomplish our goal, we need to think in terms of bits, not characters and
    words. The file we want to hide, as well as the pool file, is merely a stream
    of bits; we don’t care what those bits represent. The idea, then, is to randomly
    scatter the bits of the source file throughout the bits of the pool file.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现我们的目标，我们需要从比特的角度思考，而不是字符和单词。我们想要隐藏的文件以及池文件，仅仅是一串比特；我们不关心这些比特代表什么。因此，关键是将源文件的比特随机散布到池文件的比特中。
- en: For example, if we want to hide source bits 11011011 in
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果我们想要隐藏源比特11011011在
- en: '110101011000101010010110101011001010010111'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '110101011000101010010110101011001010010111'
- en: then we need to scatter the bits randomly
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们需要将比特随机散布。
- en: '110101011001101010010010101011001110010111'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '110101011001101010010010101011001110010111'
- en: in such a way that we can recover the random bit positions later on to reconstruct
    the original file.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 以便我们可以稍后恢复随机比特位置，从而重建原始文件。
- en: This approach works if the pool file is substantially larger than the file we
    wish to hide. For any source bit, the probability that the pool file bit we select
    is already the same value is 50 percent because we assume the pool file to be
    random. Therefore, with enough pool file bits and random placement of the source
    file bits, we don’t expect most tools like `ent` to pick up that the file has
    been modified. However, the proper ratio between hidden bits and pool file bits
    is difficult to ascertain. Fewer hidden bits are better, but how many can we insert
    until they become noticeable? We’ll perform a simple experiment shortly to try
    to figure out the answer.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法适用于池文件比我们想要隐藏的文件大得多的情况。对于任何源比特，我们选择的池文件比特与源比特相同的概率是50%，因为我们假设池文件是随机的。因此，通过足够的池文件比特和源文件比特的随机分布，我们不认为大多数工具像`ent`会发现文件已被修改。然而，隐藏比特和池文件比特之间的正确比例很难确定。隐藏比特越少越好，但我们可以插入多少比特才不会显得显眼呢？我们将在接下来的实验中简要探讨这个问题。
- en: We’re almost ready to think about coding. Our plan is to randomly scatter the
    source file bits throughout the bits of the pool file. We can get the random bit
    positions by using `RE` with a fixed seed value to generate a sequence of random
    offset values, one for each source bit.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 我们几乎准备好考虑编码问题了。我们的计划是将源文件的比特随机散布到池文件的比特中。我们可以通过使用`RE`和固定的种子值来生成一系列随机偏移值，从而获得随机的比特位置，每个源比特对应一个偏移值。
- en: But while we can undoubtedly encode the source file with what we have, can we
    get it back? How many bits do we read out of the encoded file? We don’t know how
    long the source file was, so we need to encode not only the source file but also
    its length.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 但虽然我们无疑可以用现有的方法对源文件进行编码，我们能否将它恢复出来？我们从编码文件中读取多少比特？我们并不知道源文件的长度，因此我们不仅需要编码源文件，还需要编码它的长度。
- en: For example, if the source file is 10,356 bytes long, we need to encode not
    only all 8 × 10,356 = 82,848 bits of the file but also the number of bytes we
    encoded. We’ll use 32 bits to encode the file length, so we will encode 82,848
    + 32 = 82,880 bits, the first 32 representing the encoded file length in bytes.
    Then, to recover the file, we read 32 bits and form the length to know how many
    additional bits to extract.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果源文件长度为10,356字节，我们不仅需要编码文件的所有8 × 10,356 = 82,848比特，还需要编码文件的字节数。我们将使用32比特来编码文件长度，所以我们将编码82,848
    + 32 = 82,880比特，前32个比特表示编码的文件长度（单位：字节）。然后，为了恢复文件，我们读取32个比特并形成长度，以便知道要提取多少额外的比特。
- en: 'Let’s lay out the steps. To encode a file:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来列出步骤。要编码一个文件：
- en: Read the source file and convert it to a list of bits.
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 读取源文件并将其转换为比特列表。
- en: Prepend the list of bits by the 32 bits from the length of the source file.
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在比特列表前添加32位，表示源文件的长度。
- en: Read the pool file and convert it to a list of bits.
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 读取池文件并将其转换为比特列表。
- en: Generate a random list of offset positions, one for each source bit, using the
    supplied key as the seed.
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用提供的密钥作为种子，生成一个随机的偏移位置列表，每个源比特对应一个偏移位置。
- en: Set the pool bit at each offset position to the corresponding source bit value.
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在每个偏移位置设置池比特为对应的源比特值。
- en: Convert the pool bits back to a set of bytes and write them to disk.
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将池比特转换回字节集合并写入磁盘。
- en: 'To decode a file:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 解码文件的方法：
- en: Read the encoded file and convert it to a list of bits.
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 读取编码文件并将其转换为比特列表。
- en: Generate 32 offset positions using the supplied key as the seed.
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用提供的密钥作为种子，生成32个偏移位置。
- en: Calculate the file length and number of bits to read.
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 计算文件长度和要读取的比特数。
- en: Generate offset positions for that many bits.
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 生成那么多比特的偏移位置。
- en: Collect the bits at those positions and convert them to bytes.
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 收集这些位置的比特并将它们转换为字节。
- en: Write the bytes to disk as the extracted file.
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将字节写入磁盘，作为提取的文件。
- en: 'It seems complicated, and there is some accounting to keep track of, but in
    the end it’s straightforward: we’ll randomly scatter the source file bits throughout
    the pool file and then collect them to extract the source file.'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 这看起来有点复杂，需要进行一些记录，但最终是直接的：我们将源文件的比特随机散布在池文件中，然后再收集它们以提取源文件。
- en: 'Before we get to the code, we’ll first learn how to run it so you can experiment.
    To use the code, we need a file to embed and a pool file. The book’s GitHub repository
    contains *RandomDotOrg_sm.bin*, a 5MB file of random data from *[random.org](http://random.org)*
    that is used with permission. It will be the pool file for this example. As we
    can see, `ent` likes this file:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们进入代码之前，我们首先学习如何运行它，以便你能进行实验。使用代码时，我们需要一个要嵌入的文件和一个池文件。本书的GitHub仓库包含*RandomDotOrg_sm.bin*，这是一个来自*[random.org](http://random.org)*的5MB随机数据文件，经过许可使用。它将作为本例的池文件。如我们所见，`ent`喜欢这个文件：
- en: '[PRE19]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: As for the source file, look in the directory *test_images*, which contains
    a collection of standard image-processing test images of various types and sizes.
    We’ll use these again later in the chapter when we experiment with hiding files
    in images. Presently, we want *boat.png*, shown in [Figure 2-2](ch02.xhtml#ch02fig02).
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 至于源文件，请查看目录*test_images*，其中包含了一些标准的图像处理测试图像，涵盖各种类型和大小。我们将在本章后面再次使用这些图像，实验如何将文件隐藏在图像中。目前，我们需要的是*boat.png*，如[图2-2](ch02.xhtml#ch02fig02)所示。
- en: '![Image](../images/02fig02.jpg)'
  id: totrans-122
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/02fig02.jpg)'
- en: '*Figure 2-2: The boat image*'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '*图2-2：船的图像*'
- en: 'The code we need is in *steg_random.py*. To encode a file, use a command line
    like this:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要的代码在*steg_random.py*中。要编码文件，请使用如下命令行：
- en: '[PRE20]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The code takes about 30 seconds to run. When it finishes, the *output.bin*
    file contains the hidden image. Does `ent` still like this file? It does:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 该代码运行大约需要30秒。完成后，*output.bin*文件包含了隐藏的图像。`ent`仍然喜欢这个文件吗？它喜欢：
- en: '[PRE21]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'To recover the image, run *steg_random.py* a second time using the same key
    (12345):'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 要恢复图像，请第二次运行*steg_random.py*，使用相同的密钥（12345）：
- en: '[PRE22]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The file *tmp.png* now contains the boat image.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，文件*tmp.png*包含了船的图像。
- en: 'The code in *make_random.py* generates files of random bytes using the random
    number generators available in the `RE` class. I recommend using this code to
    create pool files for your experiments. For example, use the following to generate
    a file of 5 million bytes using the Mersenne Twister:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: '*make_random.py*中的代码使用`RE`类中可用的随机数生成器生成随机字节文件。我建议使用这个代码来创建实验所需的池文件。例如，使用以下命令生成一个包含500万字节的文件，使用梅森旋转算法：'
- en: '[PRE23]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: As with most programs, running *make_random.py* without arguments tells us how
    to use the code.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 与大多数程序一样，运行*make_random.py*而不带参数会告诉我们如何使用该代码。
- en: '***How Much Can You Hide?***'
  id: totrans-134
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***你能隐藏多少？***'
- en: 'Let’s try to figure out how many bits we can hide before tools like `ent` give
    suspicious results. To do so, we need the code in *steg_random_test.py*. I’ll
    let you read the code; it’s a simple script that does the following:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试找出在工具如`ent`给出可疑结果之前，我们可以隐藏多少比特。为此，我们需要使用*steg_random_test.py*中的代码。我让你自己阅读代码；它是一个简单的脚本，执行以下操作：
- en: Uses *make_random.py* to make a random file of 10 million bytes
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用*make_random.py*生成一个1000万字节的随机文件
- en: Uses *steg_random.py* to embed ever-larger files that are nothing but the letter
    *A* repeated
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用*steg_random.py*嵌入越来越大的文件，这些文件仅由重复的字母*A*组成
- en: Runs `ent` on the result and extracts the estimated value of *π*
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行`ent`对结果进行分析，并提取估算的*π*值
- en: Plots the estimate of *π* as a function of the embedded file size
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 绘制*π*的估算值与嵌入文件大小的关系
- en: Repeating the letter *A* creates a file that is the antithesis of random; it’s
    as nonrandom as possible, with an entropy of zero. Therefore, it’s the worst possible
    file to embed, which will have the most negative effect on the output. There’s
    nothing special about the letter *A*; any single-byte value will do.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 重复字母*A*创建了一个完全非随机的文件；它尽可能地非随机，熵为零。因此，这是最糟糕的嵌入文件，它会对输出产生最负面的影响。字母*A*本身没有什么特别之处，任何单字节值都可以。
- en: '[Figure 2-3](ch02.xhtml#ch02fig03) shows the result.'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 2-3](ch02.xhtml#ch02fig03)展示了结果。'
- en: '![Image](../images/02fig03.jpg)'
  id: totrans-142
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/02fig03.jpg)'
- en: '*Figure 2-3: The effect on the estimate of π when embedding ever-larger files
    of* A *repeated*'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 2-3：嵌入越来越大的*A*重复文件对*π*估算值的影响'
- en: There’s a linear relationship between the estimate of *π* and the embedded number
    of *A*s. The pool file on its own gives an estimate that is 0.01 percent off,
    which is good. Hiding 50,000 *A*s bumps the error to 0.05 percent, which is also
    not likely to raise eyebrows. However, 100,000 *A*s changes the error to 0.5 percent,
    which is starting to look suspicious.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '*π*的估算值与嵌入的*A*字符数量之间存在线性关系。池文件本身的估算误差为0.01%，这是不错的。隐藏50,000个*A*将误差提升至0.05%，这通常不会引起注意。然而，100,000个*A*将误差提高到0.5%，这开始显得有些可疑。'
- en: Since the pool file had 10 million bytes, 100,000 bytes is equal to 10⁵/10⁷
    = 0.01 = 1 percent, implying that hiding files that are less than 1 percent the
    size of the pool file should, in general, result in an output file that won’t
    be noticed.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 由于池文件有1000万字节，100,000字节等于10⁵/10⁷ = 0.01 = 1%，这意味着隐藏小于池文件大小1%的文件通常不会引起注意。
- en: For example, [Table 2-1](ch02.xhtml#ch02tab01) shows the estimated π values
    from `ent` for a pool file (using `urandom`) of 10 million bytes along with the
    output of *steg_random.py* when hiding 100,000 bytes that are all *A*s, the first
    100,000 characters of *alice.txt*, or another random file of bytes using `RDRAND`.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，[表2-1](ch02.xhtml#ch02tab01)显示了使用`urandom`生成的10百万字节池文件，通过*steg_random.py*隐藏100,000字节的结果，这些字节全部是*A*字符，或者是*alice.txt*的前100,000个字符，或者是使用`RDRAND`生成的其他随机文件的输出。
- en: '**Table 2-1:** Estimated π Values by Hidden File Type'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '**表 2-1：** 按隐藏文件类型估算的*π*值'
- en: '| **Hidden file type** | **Estimated *π* values** |'
  id: totrans-148
  prefs: []
  type: TYPE_TB
  zh: '| **隐藏文件类型** | **估算的*π*值** |'
- en: '| --- | --- |'
  id: totrans-149
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `urandom` pool | 3.142167657 (0.02%) |'
  id: totrans-150
  prefs: []
  type: TYPE_TB
  zh: '| `urandom`池 | 3.142167657 (0.02%) |'
- en: '| Hide `RDRAND` | 3.142429257 (0.03%) |'
  id: totrans-151
  prefs: []
  type: TYPE_TB
  zh: '| 隐藏`RDRAND` | 3.142429257 (0.03%) |'
- en: '| Hide *alice.txt* | 3.146091658 (0.14%) |'
  id: totrans-152
  prefs: []
  type: TYPE_TB
  zh: '| 隐藏*alice.txt* | 3.146091658 (0.14%) |'
- en: '| Hide *A*s | 3.157525263 (0.51%) |'
  id: totrans-153
  prefs: []
  type: TYPE_TB
  zh: '| 隐藏*A*字符 | 3.157525263 (0.51%) |'
- en: 'These results hint that, for a hidden file that’s 1 percent the size of the
    pool file, we should expect a tool like `ent` to show a slight increase in metrics
    related to nonrandomness, like a larger error in estimating *π*. Note that *alice.txt*
    is a text file, so we can expect a binary file to do even better. The moral of
    the story is: hide your data in a random file that is at least 100 times larger
    than the data itself.'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 这些结果表明，对于一个大小为池文件1%的隐藏文件，我们应该期待像`ent`这样的工具在与非随机性相关的度量指标上显示出轻微的增加，比如在估算*π*时出现更大的误差。请注意，*alice.txt*是一个文本文件，因此我们可以期待二进制文件的效果会更好。故事的寓意是：将你的数据隐藏在一个至少比数据本身大100倍的随机文件中。
- en: Now let’s take a look at the code.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们看一下代码。
- en: '***The steg_random.py Code***'
  id: totrans-156
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***steg_random.py代码***'
- en: The code in *steg_random.py* is slightly more complex than the code we’ve used
    so far. I suggest reviewing *steg_random.py* before continuing. You’ll see two
    utility functions, `MakeBit` and `MakeByte`. We’ll use these functions here and
    in the following sections, so we’ll define them before moving on to the encode
    and decode functions.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: '*steg_random.py*中的代码比我们目前使用的代码稍微复杂一些。我建议在继续之前先复习一下*steg_random.py*。你会看到两个工具函数，`MakeBit`和`MakeByte`。我们将在这里和后续的章节中使用这些函数，所以在继续编码和解码函数之前，我们先来定义它们。'
- en: '**Converting Between Bits and Bytes**'
  id: totrans-158
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**位与字节之间的转换**'
- en: We intend to work with bits and bytes, so it helps to have functions that convert
    between the two. This is the point of `MakeBit` and `MakeByte`. [Listing 2-7](ch02.xhtml#ch02list07)
    shows `MakeBit`.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 我们打算处理位和字节，所以拥有可以相互转换的函数会很有帮助。这就是`MakeBit`和`MakeByte`的作用。[列表 2-7](ch02.xhtml#ch02list07)展示了`MakeBit`。
- en: '[PRE24]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '*Listing 2-7: Converting bytes to bits*'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 2-7：将字节转换为位*'
- en: The argument (`byt`) is an array of bytes that we want to turn into an output
    array of bits (`b`). There are eight bits per byte, so we define `b` up front
    and then fill it in by processing the bytes in `byte` one by one using the `for`
    loop.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 参数（`byt`）是我们希望转换为输出位数组（`b`）的字节数组。每个字节包含八个位，因此我们提前定义了`b`，然后使用`for`循环逐一处理`byt`中的字节来填充它。
- en: For each byte, we ask Python to convert it to a binary string (`s`), being careful
    to insist on leading zeros. Then, we place each bit into the output array using
    an ever-increasing index (`k`) before returning to the caller.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 对于每个字节，我们要求 Python 将其转换为二进制字符串（`s`），并且特别注意前导零。然后，我们使用不断增加的索引（`k`）将每一位放入输出数组中，最后返回给调用者。
- en: We also need to convert an array of bits back to an array of bytes; `MakeByte`
    is shown in [Listing 2-8](ch02.xhtml#ch02list08).
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要将位数组转换回字节数组；`MakeByte`在[列表 2-8](ch02.xhtml#ch02list08)中展示。
- en: '[PRE25]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '*Listing 2-8: Converting bits to bytes*'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 2-8：将位转换为字节*'
- en: The argument is an array of bits (`b`), so its length will be a multiple of
    eight. Therefore, `n` is the number of bytes we need in the output array. To get
    the bytes, we first reshape `b` to group every eight bits. In other words, if
    the array is a vector of 32 bits
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 参数是一个位数组（`b`），因此其长度将是 8 的倍数。因此，`n`是我们在输出数组中需要的字节数。为了得到字节，我们首先将`b`重新排列，将每八个位分为一组。换句话说，如果数组是一个包含
    32 位的向量
- en: '[PRE26]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: it becomes
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 它变成了
- en: '[PRE27]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: in `t`, a 4×8 array of bits representing 4 bytes.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 在`t`中，是一个 4×8 的位数组，表示 4 个字节。
- en: Next, we multiply each row of `t` by the vector representing the place value
    of each bit in a byte. Finally, we sum the resulting vector to give the actual
    byte value (`v`), which we place into the output array, `byt`.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将`t`的每一行与表示字节中每个位的位值的向量相乘。最后，我们将得到的向量求和，得到实际的字节值（`v`），并将其放入输出数组`byt`中。
- en: Now, let’s learn how to hide bits in a random file.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们来学习如何将位隐藏在随机文件中。
- en: '**Encoding a File**'
  id: totrans-174
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**文件编码**'
- en: 'Encoding a file is accomplished by the cleverly named `Encode` function:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 文件的编码通过巧妙命名的`Encode`函数完成：
- en: '[PRE28]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Our goal is to randomly scatter the bits of the source file (`sfile`) among
    the bits of the pool file (`pfile`) and dump the result to the destination file
    (`dfile`). The seed for the generator is in `key`.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的目标是将源文件（`sfile`）的位随机地分散到池文件（`pfile`）的位中，并将结果输出到目标文件（`dfile`）。生成器的种子存储在`key`中。
- en: In the first code paragraph, we read the source file into an array of bytes
    (`src`). As discussed previously, we also need to encode the length of the file,
    which we do by representing the number of bytes as a hexadecimal string (`s`).
    We’re using an unsigned 32-bit integer as the file length, so we can only hide
    files less than 4,294,967,296 bytes. That shouldn’t be a problem for us. The individual
    bytes representing the length are extracted from `s` and interpreted as hexadecimal
    numbers from the most significant (`b3`) down to the least (`b0`). As `src` is
    still a vector of bytes, we add the 4 bytes of the length to the beginning using
    NumPy’s `hstack` function. Finally, we use `MakeBit` to convert `src` to a vector
    of bits.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一个代码段中，我们将源文件读取到字节数组（`src`）中。如前所述，我们还需要编码文件的长度，我们通过将字节数表示为十六进制字符串（`s`）来完成。我们使用一个无符号的
    32 位整数作为文件长度，因此我们只能隐藏小于 4,294,967,296 字节的文件。这应该不会成为问题。表示长度的各个字节从`src`中提取出来，并按从最高有效位（`b3`）到最低有效位（`b0`）的顺序解释为十六进制数。由于`src`仍然是一个字节向量，我们通过使用
    NumPy 的`hstack`函数将长度的 4 个字节加到开头。最后，我们使用`MakeBit`将`src`转换为位向量。
- en: In the second code paragraph, we construct `idx`, a vector of ever-increasing
    offsets, one per bit of `src`. These are the positions in the pool that will be
    updated with `src`’s bit values. First, `step` is a vector of offsets from a low
    of 1 to a high of 15 bits. Note the use of `key` to set the seed. The `idx` vector
    is constructed from the offsets by adding each offset to the last element of `idx`
    before appending the new offset to `idx`.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 在第二段代码中，我们构建了`idx`，它是一个不断增加的偏移量向量，每个位对应`src`的一个偏移量。这些是`pool`中的位置，将用`src`的位值进行更新。首先，`step`是一个偏移量向量，从1到15位不等。注意使用`key`来设置种子。`idx`向量是通过将每个偏移量添加到`idx`的最后一个元素，然后再将新的偏移量附加到`idx`来构建的。
- en: The third paragraph reads the pool file as a vector of bits (`pool`). If the
    pool file is too short to accommodate all the bit offset positions in `idx`, the
    program delivers a terse message and abruptly ends.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 第三段代码读取池文件作为位向量（`pool`）。如果池文件太短，无法容纳`idx`中的所有位偏移位置，程序将显示简洁的消息并立即终止。
- en: 'At this point, we have all we need: `src` as bits, `pool` as bits, and `idx`
    telling us where the bits of `src` go. Therefore, the fourth paragraph is a simple
    loop setting the proper bit of `pool` to the corresponding bit of `src`. We march
    through `src` sequentially, and `idx` likewise, but the values in `idx` are the
    positions in `pool` that get updated.'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，我们拥有所需的一切：`src`作为位，`pool`作为位，`idx`告诉我们`src`的位应该放到哪里。因此，第四段代码是一个简单的循环，将`pool`的正确位设置为`src`的对应位。我们按顺序遍历`src`，同时遍历`idx`，但`idx`中的值是`pool`中需要更新的位置。
- en: The final paragraph converts the now updated `pool` into a vector of bytes and
    writes it to the destination file (`dfile`).
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一段将更新后的`pool`转换为字节向量并写入目标文件（`dfile`）。
- en: We can officially encode a file; now let’s get it back.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以正式对文件进行编码；现在让我们把它解码回来。
- en: '**Decoding a File**'
  id: totrans-184
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**解码文件**'
- en: 'Decoding a file uses the similarly named `Decode` function:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 解码文件使用了一个同名的`Decode`函数：
- en: '[PRE29]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Here, `sfile` is the name of the file generated by `Encode` and `dfile` is the
    name of the desired output file. Note that `key` must match the value used to
    encode.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`sfile`是由`Encode`生成的文件名，`dfile`是所需的输出文件名。请注意，`key`必须与用于编码的值匹配。
- en: The code first reads the encoded file and immediately converts it to a vector
    of bits (`src`).
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 代码首先读取编码后的文件，并立即将其转换为位向量（`src`）。
- en: 'In the following code paragraph, the properly seeded generator is created (`rng`).
    Notice the `RE` instantiation: integer, default PCG64 generator, low of 1 and
    high of 15, with the seed. This is the configuration used for encoding, as it
    must be.'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的代码段中，创建了正确设置种子的生成器（`rng`）。请注意`RE`的实例化：整数类型，默认的PCG64生成器，位范围从1到15，并使用种子。这是编码时使用的配置，因为它必须一致。
- en: The first 32 encoded bits are extracted by adding the 32 values in `step` to
    each final offset in `idx`, as for `Encode`. The resulting `bits` are passed to
    the helper function, `MessageLength`, as in [Listing 2-9](ch02.xhtml#ch02list09).
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将`step`中的32个值添加到`idx`中的每个最终偏移量中，提取前32个编码位，方法与`Encode`类似。得到的`bits`被传递到辅助函数`MessageLength`中，参考[列表
    2-9](ch02.xhtml#ch02list09)。
- en: '[PRE30]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '*Listing 2-9: Converting 32 bits to an unsigned integer*'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 2-9：将32位转换为无符号整数*'
- en: This function makes the 32-bit vector a vector of 4 bytes (`b`); multiplies
    each byte, highest-order byte first, by the proper place value; and sums to get
    the actual encoded file length in bytes (`n`). Working with the bytes of the 32-bit
    value is the same as treating it like a base-256 number, hence the exponents on
    256.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 该函数将32位向量转换为4字节的字节向量（`b`）；按正确的位值依次乘以每个字节，从最高位字节开始；然后相加得到实际的编码文件长度（以字节为单位，`n`）。处理32位值的字节与将其视为基数为256的数字类似，因此使用了256的指数。
- en: In the final paragraph, the bit positions for the remainder of the encoded file
    are calculated from `step` and `idx` as before, but we need to add the extra offset
    to account for the 32 bits already read. Once `idx` is constructed, it is immediately
    used to extract the `bits`. All bits collected are converted to bytes (`dest`)
    and finally dumped to the output file (`dfile`).
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 在最后一段中，计算编码文件剩余部分的位位置，就像之前一样从`step`和`idx`计算，但我们需要加上额外的偏移量来考虑已经读取的32位。`idx`构建完成后，立即用于提取`bits`。所有收集到的位被转换为字节（`dest`），最终输出到文件（`dfile`）。
- en: Whew! Much is happening in *steg_random.py*. Thankfully, most of it transfers
    to the remaining two sections of this chapter, where we hide data in audio files
    and images. Let’s learn to whisper carefully so that no one hears us unless we
    want them to.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 呼！在*steg_random.py*中发生了很多事情。幸运的是，大部分内容可以转移到本章的剩余两节，那里我们将数据隐藏到音频文件和图像中。让我们学会小心地低语，这样除非我们希望别人听见，否则没人能听到我们的声音。
- en: '**In an Audio File**'
  id: totrans-196
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**在音频文件中**'
- en: 'Digital audio is ubiquitous and a natural target for steganography. This section
    explores how to embed files in digital audio, specifically WAV files. Our approach
    is similar to the previous section: we’ll scatter the bits of the file across
    the digital samples. However, instead of altering random bits, we’ll alter the
    least-significant bit to minimize the impact and make the message essentially
    silent.'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 数字音频无处不在，是隐写术的天然目标。本节探讨如何将文件嵌入到数字音频中，特别是WAV文件。我们的方法与上一节类似：我们将把文件的位散布到数字样本中。然而，区别在于，我们不会改变随机的位，而是改变最低有效位，以最小化影响，使得信息几乎是静默的。
- en: The file we need is *steg_audio.py*. Be sure to review the file before proceeding.
    You’ll notice it uses `MakeBit` and `MakeByte`, which we have worked with before—see
    [Listings 2-7](ch02.xhtml#ch02list07) and [2-8](ch02.xhtml#ch02list08), respectively.
    Likewise, you’ll also see `MessageLength` ([Listing 2-9](ch02.xhtml#ch02list09)).
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要的文件是*steg_audio.py*。在继续之前，务必检查一下这个文件。你会注意到它使用了`MakeBit`和`MakeByte`，这些我们之前已经使用过——分别参见[清单
    2-7](ch02.xhtml#ch02list07)和[2-8](ch02.xhtml#ch02list08)。同样，你还会看到`MessageLength`（[清单
    2-9](ch02.xhtml#ch02list09)）。
- en: We discussed digital sampling in [Chapter 1](ch01.xhtml) when generating random
    bits from the microphone input. At that time, we wanted 32-bit floating-point
    samples. Here, we’ll use more common signed 16-bit samples in the range [–32,768,
    32,767]. Such samples use two bytes each. We’ll restrict ourselves to changing
    only the least-significant bit, thereby altering the sample value by at most 1,
    which no one will hear.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在[第一章](ch01.xhtml)中讨论了数字采样，当时我们从麦克风输入生成随机位。那时，我们需要32位浮点数样本。在这里，我们将使用更常见的有符号16位样本，范围为[–32,768,
    32,767]。这种样本每个使用两个字节。我们将限制只改变最低有效位，从而使样本值最多改变1，听不出任何差别。
- en: WAV files are not compressed and, therefore, might be rather large. Most internet
    audio is in the form of MP3s, which employ *lossy compression*. The human auditory
    system doesn’t need all the information in raw audio samples—about 90 percent
    or so can be discarded, which is the “loss.” However, as we’re planning on using
    the simplest of audio steganography approaches, and our hidden file will be lost
    if the file is converted to an MP3, we must use the full WAV file. There are more
    sophisticated types of audio steganography that employ characters, like echoes,
    that survive the compression process, but this is out of the scope of this book.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: WAV文件未压缩，因此可能相当大。大多数互联网音频是MP3格式的，这种格式采用*有损压缩*。人类听觉系统并不需要所有原始音频样本中的信息——大约90%的信息可以丢弃，这就是所谓的“损失”。然而，由于我们计划使用最简单的音频隐写方法，并且如果文件转换为MP3格式，隐藏的文件将会丢失，因此我们必须使用完整的WAV文件。有更复杂的音频隐写方法使用回声等特征，它们能在压缩过程中生存下来，但这些内容超出了本书的范围。
- en: 'The algorithm’s needs are quite close to that of the previous section:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 该算法的需求与上一节的需求非常相似：
- en: Read the source file and convert it to bits along with the file length in bytes.
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 读取源文件并将其转换为位，以及文件的字节长度。
- en: Read the original WAV file, ensure the source file will fit, and work with only
    one channel if it’s stereo.
  id: totrans-203
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 读取原始WAV文件，确保源文件能适配，并且如果是立体声，只使用一个声道。
- en: Generate a random but ever-increasing list of indices into the WAV samples,
    one for each bit of the source file.
  id: totrans-204
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 生成一个随机但不断增长的索引列表，指向WAV样本中的每一位，代表源文件的每一位。
- en: Alter bit 0 of the selected samples to match the corresponding source file bit.
  id: totrans-205
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 改变选定样本的第0位，使其与相应的源文件位匹配。
- en: Write the altered samples to a new audio file.
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将修改后的音频样本写入一个新的音频文件。
- en: We’ll first use the code to hide files, then we’ll explore the code itself.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先将使用代码隐藏文件，然后再探索代码本身。
- en: '***A Quiet Live Performance***'
  id: totrans-208
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***一个安静的现场表演***'
- en: 'Let’s play around with *steg_audio.py* before walking through the code. The
    book’s GitHub repository includes several sample WAV files courtesy of composer
    Paul Kneusel (*[https://www.paulkneusel.com](https://www.paulkneusel.com)*). First,
    let’s hide an image in *Fireflies*, a live performance in 2016 by pianist Kristen
    Kosey. *Fireflies* is a quiet piece, thereby increasing the probability that we’ll
    hear any effect from altering the samples. Here’s the command line:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 在详细讲解代码之前，让我们先试试 *steg_audio.py*。本书的 GitHub 仓库提供了几种示例 WAV 文件，由作曲家 Paul Kneusel
    提供 (*[https://www.paulkneusel.com](https://www.paulkneusel.com)*)。首先，让我们在 *Fireflies*
    中隐藏一张图像，这是一首 2016 年由钢琴家 Kristen Kosey 演奏的现场表演曲目。*Fireflies* 是一首安静的曲子，从而增加了我们可能听到由样本改变所产生的效果的概率。以下是命令行：
- en: '[PRE31]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: First, we supply the secret key, 2718281828, then the file to embed, *tulips_gray.png*,
    followed by the output filename, *tmp.wav*, and finally the source WAV file, *Fireflies.wav*.
    The code informs us that it used 3,712,480 samples to store the bits of *tulips_gray.png*.
    Bonus points for readers who recognize the secret key.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们提供秘密密钥 2718281828，然后是要嵌入的文件 *tulips_gray.png*，接着是输出文件名 *tmp.wav*，最后是源 WAV
    文件 *Fireflies.wav*。代码告诉我们它用了 3,712,480 个样本来存储 *tulips_gray.png* 的比特。能够识别秘密密钥的读者会得到额外积分。
- en: 'As before, we recover the hidden file with the same code:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 与之前一样，我们使用相同的代码恢复隐藏的文件：
- en: '[PRE32]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: This produces *tmp.png*, the original image file shown in [Figure 2-4](ch02.xhtml#ch02fig04).
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 这会生成 *tmp.png*，即在 [图 2-4](ch02.xhtml#ch02fig04) 中显示的原始图像文件。
- en: '![Image](../images/02fig04.jpg)'
  id: totrans-215
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/02fig04.jpg)'
- en: '*Figure 2-4: The recovered image*'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 2-4：恢复的图像*'
- en: 'Play the output file, *tmp.wav*. Listen closely and try to hear the difference
    between *tmp.wav* and the original *Fireflies.wav*. The image file is well-hidden
    and utterly imperceptible. This is steganography as it should be: unnoticed.'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 播放输出文件 *tmp.wav*。仔细听，尝试辨别 *tmp.wav* 和原始文件 *Fireflies.wav* 之间的差异。图像文件被巧妙地隐藏，几乎无法察觉。这就是隐写术的本质：不被察觉。
- en: Okay, *steg_audio.py* works, but what did it really do? We need to change the
    least-significant bit of each sample to match the corresponding bit of the file
    we’re hiding. Let’s look at the first eight bits of *tulips_gray.png* along with
    the corresponding sample offsets and the samples themselves, as in [Table 2-2](ch02.xhtml#ch02tab02).
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，*steg_audio.py* 可以工作，但它到底做了什么？我们需要将每个样本的最低有效位改为与我们隐藏的文件对应的比特。让我们查看 *tulips_gray.png*
    的前八个比特，以及对应的样本偏移量和样本值，如 [表 2-2](ch02.xhtml#ch02tab02) 中所示。
- en: '**Table 2-2:** The First Eight Bits of *tulips_gray.png* with Offsets and Samples'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: '**表 2-2：** *tulips_gray.png* 的前八个比特与偏移量和样本'
- en: '|   | **0** | **1** | **2** | **3** | **4** | **5** | **6** | **7** |'
  id: totrans-220
  prefs: []
  type: TYPE_TB
  zh: '|   | **0** | **1** | **2** | **3** | **4** | **5** | **6** | **7** |'
- en: '| --- | --- | --- | --- | --- | --- | --- | --- | --- |'
  id: totrans-221
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- | --- | --- | --- | --- | --- |'
- en: '| **Bits** | 1 | 0 | 0 | 0 | 1 | 0 | 0 | 1 |'
  id: totrans-222
  prefs: []
  type: TYPE_TB
  zh: '| **比特** | 1 | 0 | 0 | 0 | 1 | 0 | 0 | 1 |'
- en: '| **Offsets** | 35 | 36 | 50 | 68 | 85 | 90 | 92 | 99 |'
  id: totrans-223
  prefs: []
  type: TYPE_TB
  zh: '| **偏移量** | 35 | 36 | 50 | 68 | 85 | 90 | 92 | 99 |'
- en: '| **Samples** | 65,533 | 5 | 7 | 65,532 | 65,535 | 65,532 | 5 | 65,534 |'
  id: totrans-224
  prefs: []
  type: TYPE_TB
  zh: '| **样本** | 65,533 | 5 | 7 | 65,532 | 65,535 | 65,532 | 5 | 65,534 |'
- en: Sample 35 has value 65,533, and we want the least-significant bit of sample
    35 to be a 1\. Likewise, sample 36 is 5, and we want its least-significant bit
    to be a 0, and so on.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 样本 35 的值为 65,533，我们希望样本 35 的最低有效位为 1。同样，样本 36 的值为 5，我们希望其最低有效位为 0，以此类推。
- en: We previously discussed that WAV files use signed 16-bit integers in the range
    [–32,768, 32,767]. This is true, but when we read the audio samples, we interpret
    them as unsigned integers in the range [0, 65,535] instead to avoid working with
    negative numbers. We’ll change the interpretation back to signed 16-bit integers
    before writing the output WAV file.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前讨论过，WAV 文件使用的是范围为 [–32,768, 32,767] 的有符号 16 位整数。这是正确的，但当我们读取音频样本时，为了避免处理负数，我们将其解释为范围为
    [0, 65,535] 的无符号整数。我们将在写入输出 WAV 文件之前，再将解释方式改回有符号 16 位整数。
- en: We want sample 35, currently 65,533, to be such that the first bit is a 1\.
    We have a few options to accomplish this. For one, we can use low-level bit operations.
    But notice that when bit 0 of an integer is a 1 the number is odd, and when it’s
    a 0 the number is even. In this case, 65,533 is odd, meaning bit 0 is already
    a 1, so we leave the sample as is.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望样本 35 当前为 65,533，使其第一个比特为 1。为此我们有几种选择。一个方法是使用低级位操作。但请注意，当整数的第 0 位为 1 时，数字为奇数，而当第
    0 位为 0 时，数字为偶数。在这种情况下，65,533 已经是奇数，意味着第 0 位已经是 1，所以我们可以保持样本不变。
- en: 'The second sample is currently a 5, but we want bit 0 to be a 0\. As 5 is an
    odd number, we subtract 1 to make the new sample value a 4 with bit 0 a 0, as
    desired. This process repeats for each bit of the file we’re hiding. Either the
    sample’s least-significant bit is already correct, or it’s off by one, requiring
    us to add or subtract 1\. To summarize: we add 1 only if we need the sample to
    be an odd number; likewise, we subtract 1 only if we want the sample to be an
    even number.'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个样本当前值为5，但我们希望位0为0。由于5是奇数，我们减去1使新样本值变为4，且位0为0，符合我们的要求。这个过程会对我们要隐藏的文件中的每个位重复进行。样本的最低有效位要么已经正确，要么偏差1，需要加1或减1。总结一下：只有当我们需要样本为奇数时才加1；同样，只有当我们需要样本为偶数时才减1。
- en: Let’s return to my arrogant statement about the image file being “utterly imperceptible.”
    Suppose an adversary were to acquire the original *Fireflies* sound file. A bit-by-bit
    comparison of the samples might offer a clue that something is up, but we changed
    samples only when they needed to be changed. Therefore, merely extracting samples
    that differ between the suspect WAV file and the original won’t be enough to discover
    the hidden file because, on average, only half the samples used to encode the
    file will need to be altered. In other words, it’s doubtful the original file
    can be recovered without knowledge of the distribution of the samples used.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回到我之前关于图像文件“完全不可察觉”的傲慢说法。假设对手获取了原始的*Fireflies*声音文件。对样本进行逐比特比较可能会提供一些线索，表明有些异常，但我们仅在需要更改样本时才会进行更改。因此，单纯提取可疑WAV文件和原始文件之间不同的样本，不足以发现隐藏的文件，因为平均来说，只有一半的样本需要被修改。换句话说，没有关于所用样本分布的知识，原始文件很难恢复。
- en: What if the adversary had only the altered WAV file? In that case, a savvy adversary
    suspecting steganography might decide that the least-significant bit of the samples
    is the one that is likely changed because altering other bits would produce noise
    when the WAV file is played, and none is present. This suspicion might prompt
    the adversary to examine the distribution of bit 0 across the samples and compare
    it with other WAV files.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 如果对手只有修改过的WAV文件呢？在这种情况下，一个精明的对手如果怀疑存在隐写术，可能会认为样本的最低有效位（least-significant bit）是最可能被改变的，因为修改其他位会在播放WAV文件时产生噪音，但实际上并未出现噪音。这种怀疑可能促使对手检查位0在样本中的分布，并与其他WAV文件进行对比。
- en: 'If you run *steg_audio_test.py*, you’ll be presented with this output:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你运行*steg_audio_test.py*，你会看到以下输出：
- en: '[PRE33]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Each line reports the distribution of bit 0 across the samples in the corresponding
    WAV file. For instance, *Fireflies.wav* has 5,104,781 even samples and 5,103,286
    odd samples (for channel 0 only). The final value in each row is the p-value for
    a *χ*² test asking whether the even and odd sample counts are as expected if the
    evenness or oddness of a sample’s value is random. Only the first few digits of
    the p-value are meaningful.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 每行报告了对应WAV文件中位0的分布情况。例如，*Fireflies.wav*中有5,104,781个偶数样本和5,103,286个奇数样本（仅针对通道0）。每行的最后一个值是*χ*²检验的p值，该检验用于判断样本的偶数和奇数计数是否符合预期，即样本的偶奇性是否随机。只有p值的前几个数字才有意义。
- en: Recall that p-values above 0.05 indicate support for the null hypothesis, the
    claim that the samples are equally likely to be even or odd. The p-values for
    Fireflies, Attitude, and Fun-Key are all in good agreement with the null hypothesis.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，p值大于0.05表示支持零假设，即样本是偶数或奇数的可能性相同。Fireflies、Attitude 和 Fun-Key 的p值与零假设的结果高度一致。
- en: The final line, `Encoded`, shows the distribution for *tmp.wav*, the version
    of Fireflies with *tulips_gray.png* hidden inside it. Here, the p-value is 7 ×
    10^(–11), which is as good an approximation of 0 as any. In other words, the *χ*²
    test tells us that bit 0 is *not* in accordance with the null hypothesis—massively
    so. Upon seeing these results, our adversary would be convinced that something
    fishy is going on.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一行，`Encoded`，显示的是*tmp.wav*的分布情况，这是带有*tulips_gray.png*文件隐藏其中的Fireflies版本。此时，p值为7
    × 10^(–11)，这是接近0的最好的近似值。换句话说，*χ*²检验告诉我们，位0*不*符合零假设——而且偏差极大。看到这些结果后，我们的对手会确信有些不对劲。
- en: So, is my arrogance justified? No, not at all. A simple statistical test, combined
    with a bit of thought about how one might hide information in a WAV file, has
    given strong support to the notion that this particular WAV file has been manipulated.
    Also, even though our adversary strongly suspects we’ve manipulated the WAV file,
    they’re still unable to extract the information because they don’t know *which*
    bits were altered.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，我的傲慢是否合理呢？不，完全不合理。一项简单的统计测试，再加上一些关于如何在WAV文件中隐藏信息的思考，强有力地支持了这种观点：这个WAV文件已经被篡改。而且，尽管我们的对手强烈怀疑我们篡改了WAV文件，但他们依然无法提取信息，因为他们不知道*哪一*位被改变了。
- en: I encourage you to experiment with *steg_audio.py* and WAV files you have on
    hand. When you’re ready, read on to walk through the code.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 我鼓励你尝试使用*steg_audio.py*和手头的WAV文件。当你准备好时，继续阅读以跟随代码的讲解。
- en: '***The steg_audio.py Code***'
  id: totrans-238
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***steg_audio.py 代码***'
- en: The file *steg_audio.py* consists of five functions and a small driver at the
    bottom. We’re already familiar with the `MakeBit`, `MakeByte`, and `MessageLength`
    functions (see [Listings 2-7](ch02.xhtml#ch02list07), [2-8](ch02.xhtml#ch02list08),
    and [2-9](ch02.xhtml#ch02list09)).
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: '*steg_audio.py*文件包含五个函数和底部的一个小驱动程序。我们已经熟悉了`MakeBit`、`MakeByte`和`MessageLength`函数（见[清单2-7](ch02.xhtml#ch02list07)，[2-8](ch02.xhtml#ch02list08)和[2-9](ch02.xhtml#ch02list09)）。'
- en: The remaining two are the `Encode` and `Decode` functions. You might notice
    a trend here. The overall structure of *steg_audio.py* matches the structure of
    *steg_random.py*. Let’s peruse `Encode` to follow the process in this case. It’s
    best to absorb the function piecemeal, so [Listing 2-10](ch02.xhtml#ch02list010)
    shows the first part.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 剩下的两个函数是`Encode`和`Decode`。你可能会注意到一个趋势。*steg_audio.py*的整体结构与*steg_random.py*的结构相匹配。让我们仔细看看`Encode`，跟踪这个过程。最好分段吸收这个函数，所以[清单2-10](ch02.xhtml#ch02list010)展示了第一部分。
- en: '[PRE34]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: '*Listing 2-10: Hiding data in an audio file (part 1)*'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单2-10：在音频文件中隐藏数据（第一部分）*'
- en: The first paragraph of [Listing 2-10](ch02.xhtml#ch02list010) is identical to
    the corresponding code in *steg_random.py*. The file to embed is loaded and converted
    to bits after prepending the file size in bytes (`src`).
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: '[清单2-10](ch02.xhtml#ch02list010)的第一段与*steg_random.py*中的对应代码相同。嵌入的文件在预先添加文件大小（以字节为单位，`src`）后被加载并转换为比特。'
- en: The second paragraph reads the audio file, keeping the sampling rate (`sample_rate`)
    and the raw samples as signed 16-bit integers (`raw`). Next, the `if` interprets
    the samples as unsigned 16-bit integers while also selecting channel 0 if more
    than one channel exists. The net result is `samples`, the actual values we’ll
    update. The third paragraph is a sanity check to see if there are enough samples
    to hide the source file.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 第二段读取音频文件，保持采样率（`sample_rate`）和原始样本作为有符号16位整数（`raw`）。接着，`if`语句将样本解释为无符号16位整数，同时如果有多个通道，则选择通道0。最终结果是`samples`，即我们要更新的实际值。第三段是一个合理性检查，用来验证是否有足够的样本来隐藏源文件。
- en: '[Listing 2-11](ch02.xhtml#ch02list011) shows the remainder of `Encode`.'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: '[清单2-11](ch02.xhtml#ch02list011)展示了`Encode`的其余部分。'
- en: '[PRE35]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: '*Listing 2-11: Hiding data in an audio file (part 2)*'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单2-11：在音频文件中隐藏数据（第二部分）*'
- en: With the samples prepared, we’re ready to hide some data. First, we create a
    vector of offsets using the supplied key (`step`). We did the same with *steg_random.py*.
    The offsets are used to build `idx`, a vector of samples to modify. A final sanity
    check confirms there are enough samples.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 准备好样本后，我们可以开始隐藏一些数据。首先，我们使用提供的密钥（`step`）创建一个偏移量向量。我们在*steg_random.py*中也做了同样的事。这些偏移量用于构建`idx`，一个要修改的样本向量。最终的合理性检查确认了有足够的样本。
- en: The second `for` loop sets the least-significant bit of the selected samples,
    altering it by 1 as necessary to make it odd or even depending on the current
    bit (`src[i]`).
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个`for`循环设置所选样本的最低有效位，根据当前位（`src[i]`）的值，必要时将其改为奇数或偶数。
- en: The loop body needs some explanation. If the current source bit is a 0, there
    are two possibilities for the current sample (`samples[idx[i]]`). If the sample
    is odd, meaning the remainder after dividing by 2 is 1, we subtract 1 from the
    sample to make it even. Otherwise, the bit we want to store is a 1, meaning we
    check to see if the sample is currently even, and if it is, we add 1 to make it
    odd.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 循环体需要一些解释。如果当前源位是0，那么当前样本（`samples[idx[i]]`）有两种可能性。如果样本是奇数，即除以2后的余数为1，我们从样本中减去1使其变为偶数。否则，我们要存储的位是1，这意味着我们检查样本是否为偶数，如果是的话，我们加1使其变为奇数。
- en: The final paragraph reinterprets the samples as signed integers (`out`) and
    writes them to disk using the original sample rate. If the audio file is stereo,
    channel 0 is updated, leaving the other channels as they were.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一段将样本重新解释为有符号整数（`out`），并使用原始采样率将其写入磁盘。如果音频文件是立体声，则更新通道0，其他通道保持不变。
- en: To extract a hidden file, we reverse the process with `Decode`, as shown in
    [Listing 2-12](ch02.xhtml#ch02list012).
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 要提取隐藏的文件，我们使用`Decode`逆向该过程，如[列表 2-12](ch02.xhtml#ch02list012)所示。
- en: '[PRE36]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: '*Listing 2-12: Decoding data hidden in an audio file*'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 2-12：解码隐藏在音频文件中的数据*'
- en: 'There are four steps: read the encoded WAV file as unsigned integer samples,
    generate the same set of indices as used to encode the file, extract the bits,
    and write them to disk.'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 该过程包括四个步骤：读取编码的WAV文件作为无符号整数样本，生成与编码文件时使用的相同的索引集，提取位并将其写入磁盘。
- en: In the second paragraph, the pseudorandom generator is configured as in `Encode`
    before generating the first 32 step values to extract the encoded file length.
    We need the length to know how many samples to query to reconstruct the hidden
    file. Notice the call to `MessageLength`, [Listing 2-9](ch02.xhtml#ch02list09).
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 在第二段中，伪随机生成器被配置为与`Encode`中相同，然后生成前32个步骤值以提取编码的文件长度。我们需要文件长度来确定重构隐藏文件时需要查询多少样本。注意对`MessageLength`的调用，[列表
    2-9](ch02.xhtml#ch02list09)。
- en: In the third paragraph, the actual bits of the file are extracted now that we
    know how many there are. To finish, the bits are converted to bytes and written
    to the output file (`dfile`).
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 在第三段中，文件的实际位已经被提取出来，因为我们现在知道它们的数量。最后，这些位被转换为字节并写入输出文件（`dfile`）。
- en: Let’s try hiding data in images next. The process is similar to hiding data
    in a file of random bytes or in an audio file, but we’ll dispense with the notion
    of a secret key.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来我们尝试在图像中隐藏数据。这个过程类似于在随机字节文件或音频文件中隐藏数据，但我们将不再使用秘密密钥的概念。
- en: '### **In an Image File**'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: '### **图像文件中的内容**'
- en: 'For the final experiment of this chapter, we’ll hide files in images. The method
    should be familiar: we’ll scatter the bits of the file across the pixels of the
    image by making small changes to the existing pixel colors. This is the most compact
    experiment in terms of code, but we need to discuss a few things about digital
    images before diving in. Specifically, we need to understand how computers store
    and interpret images, after which I can describe the algorithm. Experiments follow
    before a code walkthrough. You know the drill.'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的最后实验是将文件隐藏在图像中。这个方法应该很熟悉：我们通过对现有像素颜色做小的改变，将文件的位分散到图像的像素中。这是最紧凑的实验，就代码而言，但在深入之前，我们需要讨论一些关于数字图像的内容。具体来说，我们需要了解计算机如何存储和解读图像，然后我将介绍算法。实验之后是代码讲解。你知道流程。
- en: '***Defining Image Formats***'
  id: totrans-261
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***定义图像格式***'
- en: The phrase “image format” has multiple meanings, especially when working in
    Python.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: “图像格式”这一术语有多重含义，特别是在使用Python时。
- en: 'The first references how the image is stored on disk. There are many options
    that fall primarily into two camps: lossy and lossless.'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个提到的是图像如何存储在磁盘上。存储方式有很多选项，主要可以分为两大类：有损和无损。
- en: Lossy image formats compress by throwing information away, much like an MP3
    file. The information retained is sufficient to reconstruct the image to some
    level of fidelity with the original. The most common lossy image format is JPEG,
    which usually has a *.jpg* file extension. This format uses discrete cosine transforms
    across small patches to retain essential levels of detail while discarding those
    that don’t contribute substantially to the reconstruction of the image.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 有损图像格式通过丢弃信息进行压缩，类似于MP3文件。保留的信息足以将图像重构到一定程度的原始图像保真度。最常见的有损图像格式是JPEG，通常具有*.jpg*文件扩展名。该格式使用离散余弦变换（DCT）对小块进行处理，以保留重要的细节层级，同时丢弃那些对图像重构贡献不大的部分。
- en: 'Lossless image formats either retain all pixel information or compress the
    image losslessly, meaning the recovered data is a bit-for-bit match with the original,
    uncompressed image. The most common lossless image format is PNG (*.png*). We’ll
    restrict ourselves to using only PNG files, as lossy formats like JPEG aren’t
    acceptable for the same reason MP3 files aren’t: the subtle changes made to the
    image will be lost. Advanced steganographic techniques are robust to lossy formats,
    but they are far beyond what we can explore here.'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 无损图像格式要么保留所有像素信息，要么无损压缩图像，这意味着恢复的数据与原始未压缩图像在逐位上完全一致。最常见的无损图像格式是 PNG（*.png*）。我们将仅使用
    PNG 文件，因为像 JPEG 这样的有损格式不被接受，原因与 MP3 文件相同：对图像进行的细微更改会丢失。先进的隐写术技术对有损格式是强大的，但它们远超我们在这里可以探索的范围。
- en: “Image format” also refers to the pixels themselves, with the main divisions
    being grayscale and color.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: “图像格式”还指的是像素本身，主要的划分为灰度图像和彩色图像。
- en: 'A grayscale image is the simplest: each pixel is a single number, a byte, representing
    the intensity of the pixels from black (0) to white (255) and shades of gray in
    between. Grayscale images with 16-bit pixels are rare, so we’ll ignore them here.'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 灰度图像是最简单的：每个像素是一个单独的数字，一个字节，表示从黑色（0）到白色（255）以及其中的灰色阴影的像素强度。16 位像素的灰度图像很少见，因此我们在这里将忽略它们。
- en: Computers have many options when representing color images. It’s most common
    to separate the color of each pixel into a combination of red, green, and blue.
    That is, a pixel showing as a whitish red can be represented as a mix of red,
    green, and blue that arrives at that color. The red, green, and blue *channels*
    are typically bytes, with 0 meaning none of that color and 255 being maximum intensity
    for that color. For example, the whitish red color is `A94141`, which is a triplet
    of hexadecimal numbers for the amount of red, green, and blue. Converting the
    hexadecimal to decimal, we have 169 out of 255 red, 65 green, and 65 blue.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 计算机在表示彩色图像时有许多选择。最常见的是将每个像素的颜色分为红色、绿色和蓝色的组合。也就是说，一个显示为淡红色的像素可以表示为红色、绿色和蓝色的混合，得到了这种颜色。红色、绿色和蓝色的
    *通道* 通常是字节，0 表示没有这种颜色，255 是该颜色的最大强度。例如，淡红色是 `A94141`，这是表示红色、绿色和蓝色数量的三个十六进制数。将十六进制转换为十进制，我们得到
    169（红色，最大值为 255）、65（绿色）和 65（蓝色）。
- en: '#### ***Using NumPy and PIL***'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: '#### ***使用 NumPy 和 PIL***'
- en: To NumPy, a grayscale image is a 2D array of bytes. Likewise, a color image,
    or RGB image, is a 3D array of bytes—one 2D array for each color channel. We’ll
    use RGB images for the upcoming experiments. If a grayscale image is loaded, it
    will be converted to RGB by duplicating the grayscale values for each channel.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 对 NumPy 来说，灰度图像是一个 2D 字节数组。同样，彩色图像或 RGB 图像是一个 3D 字节数组——每个颜色通道对应一个 2D 数组。我们将使用
    RGB 图像进行接下来的实验。如果加载的是灰度图像，它将通过复制灰度值到每个通道来转换为 RGB。
- en: 'NumPy will use the images as arrays, but how do we get them into Python in
    the first place? For that, we need the *Python Imaging Library (PIL)*, now called
    *Pillow*. It’s included with most Linux distributions and is available for Windows
    and macOS. For Linux and macOS, enter the following:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: NumPy 将图像作为数组使用，但我们如何将它们首先导入到 Python 中呢？为此，我们需要 *Python 图像库 (PIL)*，现在称为 *Pillow*。它包含在大多数
    Linux 发行版中，并且适用于 Windows 和 macOS。对于 Linux 和 macOS，输入以下内容：
- en: '[PRE37]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Any version 8.4 or later should work. We need it only to read and write image
    files.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 任何 8.4 或更高版本都应该能工作。我们只需要它来读取和写入图像文件。
- en: 'The book’s GitHub page includes a collection of standard test images. We’ve
    used several already without bringing them into Python. Let’s remedy that now:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 本书的 GitHub 页面包括一系列标准测试图像。我们已经使用了其中的一些，而没有将它们导入到 Python 中。现在让我们来解决这个问题：
- en: '[PRE38]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Here, I’m showing the Python prompt and the commands entered manually. The first
    two lines load NumPy and PIL’s `Image` class. We only need `Image`.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我展示了 Python 提示符和手动输入的命令。前两行加载了 NumPy 和 PIL 的 `Image` 类。我们只需要 `Image`。
- en: 'The next two lines load the file *apples.png* into `im`, an instance of the
    `Image` class. To make the image a NumPy array, pass it to `np.array` to create
    `d`. Notice `d`’s shape: (352, 375, 3). The image has 352 rows, its height, and
    375 columns, its width. The final dimension is 3 for the red, green, and blue
    channels.'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的两行将文件 *apples.png* 加载到 `im` 中，这是 `Image` 类的一个实例。为了将图像转换为 NumPy 数组，将其传递给
    `np.array` 创建 `d`。注意 `d` 的形状：（352，375，3）。该图像有 352 行（即高度）和 375 列（即宽度）。最后的维度是 3，表示红色、绿色和蓝色通道。
- en: 'The following two lines load *barbara.png* and convert it to a NumPy array.
    In this case, the array has only two dimensions: height and width, both 256\.
    This is a grayscale file with one channel.'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 以下两行加载*barbara.png*并将其转换为NumPy数组。在这种情况下，数组只有两个维度：高度和宽度，都是256。这是一个具有一个通道的灰度文件。
- en: The final three commands load *barbara.png* a second time but immediately pass
    the image to the `Image`’s `convert` method to turn it into an RGB image. The
    NumPy array now has three dimensions, though as a grayscale image, each color
    channel is the same.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 最后三个命令再次加载*barbara.png*，但立即将图像传递给`Image`的`convert`方法，将其转换为RGB图像。NumPy数组现在具有三维，虽然作为灰度图像，每个颜色通道都是相同的。
- en: 'While many books have been written on image processing in Python, fortunately
    all we need to know is how to open an image file, ensure that it’s RGB, turn it
    into a NumPy array, and write a NumPy array to disk as an image. Continuing with
    the previous example:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管已经有很多书籍介绍了Python中的图像处理，但幸运的是我们只需要知道如何打开图像文件，确保它是RGB，转化为NumPy数组，并将NumPy数组以图像的形式写入磁盘。继续之前的例子：
- en: '[PRE39]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: The first line rereads *apples.png* and then immediately changes it into a NumPy
    array. We’ll use this idiom consistently.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 第一行重新读取*apples.png*，然后立即将其转换为NumPy数组。我们将始终使用这种习惯用法。
- en: The next three lines swap the red and green color channels. Read through them
    carefully. Since NumPy makes the third index the channel, we need to explicitly
    mention the height and width.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的三行交换红色和绿色颜色通道。仔细阅读它们。由于NumPy将第三个索引作为通道，我们需要明确提到高度和宽度。
- en: 'The next line uses `Image`’s `fromarray` method to change `d` into an `Image`
    object: `im`. The final line writes the altered image to disk as *bad_apples.png*
    using the `save` method. PIL uses the file extension to specify the format, in
    this case a PNG file. Open *bad_apples.png* to learn why I picked that name.'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 下一行使用`Image`的`fromarray`方法将`d`转换为`Image`对象：`im`。最后一行使用`save`方法将修改后的图像保存为*bad_apples.png*。PIL使用文件扩展名来指定格式，在这种情况下是PNG文件。打开*bad_apples.png*来了解为什么我选择这个名字。
- en: '***Hiding Bits in Pixels***'
  id: totrans-285
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***隐藏比特到像素中***'
- en: In order to scatter the bits of the hidden file throughout the pixels of the
    image, we need to load the source file and convert it to bits using *MakeBit*.
    Then we load the image file, confirm it’s an RGB image, and convert it to a NumPy
    array.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 为了将隐藏文件的比特散布到图像的像素中，我们需要加载源文件并使用*MakeBit*将其转换为比特。然后我们加载图像文件，确认它是RGB图像，并将其转换为NumPy数组。
- en: Our previous experiments altered bits of the pool file to make them match the
    bits of the source file. The sequence of random offsets into the pool file was
    reproducible because we set the randomness engine’s seed to the secret key. While
    we could do the same here, we’ll take a different approach. Variety is the spice
    of life, as they say.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前的实验修改了池文件的比特，使其与源文件的比特匹配。对池文件的随机偏移序列是可重现的，因为我们将随机引擎的种子设置为密钥。虽然我们可以在这里做同样的事情，但我们将采取不同的方法。正如他们所说，生活需要一些变化。
- en: 'We’ll use the unaltered image as our key. When hiding a file, we’ll initialize
    the randomness engine without setting the seed, meaning each run of the code hides
    the same file in different locations in the image. Because we’re altering specific
    bits, we’ll know which bits we altered by using the unaltered image. To simplify
    things, we’ll do much as we did for the audio samples: one bit of the hidden file
    per byte of the image file.'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用未修改的图像作为我们的密钥。当隐藏文件时，我们将初始化随机引擎，但不设置种子，这意味着每次运行代码时，隐藏的文件会在图像的不同位置。由于我们修改的是特定的比特，因此我们通过使用未修改的图像可以知道我们修改了哪些比特。为了简化，我们将像处理音频样本时一样：每个图像文件的字节隐藏一个文件的比特。
- en: While we could set the least-significant bit of the pixel, as we did for the
    audio file, we’d never be able to detect where the image pixel already had the
    proper bit value. And since we’re abandoning the secret key to get a unique set
    of altered pixels per run, we’d never know which pixels happened to have the proper
    bit value by chance.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我们可以设置像素的最低有效位，就像我们对音频文件所做的那样，但我们永远无法检测到图像像素是否已经有正确的比特值。由于我们放弃了密钥以获得每次运行不同的修改像素集，我们永远无法知道哪些像素碰巧已经有了正确的比特值。
- en: Instead of looking for bit 0 of the pixel to be 0 or 1, or equivalently asking
    if the pixel is even or odd, we’ll encode 0 bits by adding 1 to the pixel and
    1 bits by adding 2\. In this scenario, any pixel of the unaltered image that isn’t
    the same as the corresponding pixel of the altered image holds a bit of the hidden
    file.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 与其寻找像素的第0位是0还是1，或者等效地询问该像素是偶数还是奇数，我们通过将1加到像素值来编码0位，将2加到像素值来编码1位。在这种情况下，未修改的图像中任何与修改后图像对应像素不同的像素，都会存储隐藏文件的一位。
- en: In RGB images, each pixel is actually three bytes; we can alter any of them.
    When we implement the algorithm, we’ll *unravel* the image by asking NumPy to
    turn the three-dimensional array into a single vector, which is how the image
    data is stored in the computer’s memory. Where specific red, green, and blue bytes
    end up in the unraveled array is irrelevant as long as NumPy makes the process
    repeatable, which it does.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 在RGB图像中，每个像素实际上有三个字节；我们可以修改其中任何一个。当我们实现这个算法时，我们将通过要求NumPy将三维数组转换为一个单一的向量来“解开”图像，这是图像数据在计算机内存中的存储方式。红色、绿色和蓝色字节在解开的数组中的位置并不重要，只要NumPy能够保证这个过程是可重复的，而它做到了。
- en: With the image bytes as a vector, we select a subset of locations—as many as
    there are bits in the hidden file—and alter them by adding 1 if the corresponding
    bit is a 0, or 2 if the bit is a 1.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 将图像字节作为一个向量后，我们选择一个位置子集——与隐藏文件中的位数一样多——并通过加1来修改它们，如果相应的位是0，或者加2如果该位是1。
- en: 'Bytes are unsigned numbers in the range [0, 255], meaning if the pixel value
    is 255 and we add 1 to encode a 0, we’ll wrap around to 0 (or 1 if adding 2 for
    a 1 bit). That won’t do at all, so we make an executive decision: before encoding,
    we’ll alter all image pixel bytes greater than 253 and set them to 253 so that
    adding 1 gives us 254 and adding 2 gives 255; hence no overflow.'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 字节是无符号数字，范围在[0, 255]之间，这意味着如果像素值是255，我们加1来编码0时，将回绕到0（或者加2编码1时回绕到1）。这可不行，所以我们做出了一个决策：在编码之前，我们将所有大于253的图像像素字节修改为253，这样加1后变成254，加2后变成255，从而避免溢出。
- en: 'We’re able to alter the image pixel bytes for two reasons: the code will do
    this for the unaltered image each time, even when decoding, so it’s reproducible;
    and because the bytes represent color values, the difference between 255 and 253
    is too subtle to see, especially when there’s a global change in overall color
    intensity or shade.'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 我们能够修改图像像素字节有两个原因：首先，代码每次都会为未修改的图像执行这一操作，即使在解码时也是如此，因此这是可重复的；其次，因为字节表示的是颜色值，255与253之间的差异太微妙，以至于无法看出，特别是在整体颜色强度或阴影有全局变化时。
- en: The resulting code is *steg_image.py*, which I encourage you to study before
    reading further. I’ll walk through the code after we experiment with it.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 生成的代码是*steg_image.py*，我鼓励你在继续阅读之前先研究一下它。我们将在实验后逐步讲解这段代码。
- en: This approach is just as fragile as the audio approach. We’ll throw away the
    encoding if we store our encoded image using a lossy image format like JPEG. We
    can use a JPEG as the original image because NumPy will decode it the same way
    each time, but even that might be a risk because a future version of NumPy might
    alter the algorithm used to decode the image (this is unlikely, but possible).
    Again, we’ll restrict ourselves to using only losslessly compressed PNG files.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法与音频方法一样脆弱。如果我们使用有损图像格式（如JPEG）存储编码后的图像，我们将丢弃编码。我们可以使用JPEG作为原始图像，因为NumPy每次都会以相同的方式解码它，但这甚至可能存在风险，因为未来版本的NumPy可能会改变解码图像时使用的算法（虽然这种可能性不大，但确实存在）。再次强调，我们将仅限于使用无损压缩的PNG文件。
- en: Now, let’s have some fun!
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们玩得开心一点吧！
- en: '***Hiding One Image in Another***'
  id: totrans-298
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***在一张图像中隐藏另一张图像***'
- en: 'For our first experiment, we’ll hide an image (*cameraman.png*) within a second
    image (*apples.png*). The command line we need is:'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的第一次实验中，我们将在第二张图像（*apples.png*）中隐藏一张图像（*cameraman.png*）。我们需要的命令行是：
- en: '[PRE40]'
  id: totrans-300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: We tell *steg_image.py* we want to encode, then provide the file to encode (*cameraman.png*)
    followed by the reference image (*apples.png*) and the output image file, *tmp.png*.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 我们告诉*steg_image.py*我们要编码，然后提供要编码的文件（*cameraman.png*），接着是参考图像（*apples.png*）和输出图像文件（*tmp.png*）。
- en: Open both *apples.png* and *tmp.png* and look carefully, flipping rapidly between
    the two if your software allows. Do you see any differences? A meticulous examination
    might reveal some, but my eye doesn’t notice anything.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 打开*apples.png*和*tmp.png*，仔细观察，如果你的软件允许，可以快速切换两者。你看到有什么区别吗？仔细检查可能会发现一些差异，但我眼睛并没有察觉到什么。
- en: 'To recover *cameraman.png*, use:'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 要恢复*cameraman.png*，请使用：
- en: '[PRE41]'
  id: totrans-304
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: The *cameraman.png* file is 16 percent the size of *apples.png*, and was easily
    hidden among the apples. How large can the file be before we notice it?
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: '*cameraman.png* 文件是 *apples.png* 大小的 16%，并且轻松地隐藏在苹果图像中。那么文件有多大时我们才能察觉到它？'
- en: If you run *steg_image_test.py*, then you’ll get a new output directory, *steg_image_test*,
    containing multiple images with names like *apple_A_0.60.png* and *violet_rand_0.40.png*.
    The files are images, each hiding either a specific number of *A*s or random data
    read from `RDRAND`. The first part of the name is the test image source, *apples.png*
    or *violet.png*. The latter is a 512×512-pixel image of a light violet color.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你运行 *steg_image_test.py*，你会得到一个新的输出目录 *steg_image_test*，其中包含多个图像，文件名类似 *apple_A_0.60.png*
    和 *violet_rand_0.40.png*。这些文件是图像，每个图像隐藏了特定数量的 *A* 字符或从 `RDRAND` 读取的随机数据。文件名的第一部分是测试图像来源，*apples.png*
    或 *violet.png*。后者是一个 512×512 像素的淡紫色图像。
- en: The fraction in each name is the fraction of the reference pixel images used
    to hold the encoded data. For example, *apple_A_0.60.png* is hiding the letter
    *A* so that 60 percent of the pixels in *apples.png* have been modified. The fractions
    start at 5 percent and go up to 99 percent. Take a look at these output files,
    especially the violet ones. Even when 99 percent of the pixels have been modified
    with either the same byte repeated or highly random bytes, we’re unable to see
    a difference between the output image file and the original. This is an example
    of imperceptible steganography. For brevity, I won’t discuss *steg_image_test.py*
    in detail, but do take a look at it.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 每个文件名中的分数表示用于存放编码数据的参考像素图像的比例。例如，*apple_A_0.60.png* 隐藏了字母 *A*，因此 *apples.png*
    中 60% 的像素已经被修改。比例从 5% 开始，一直到 99%。查看这些输出文件，尤其是紫色文件。即使 99% 的像素已经被修改成相同的字节重复或高度随机的字节，我们仍然无法察觉输出图像文件与原始图像之间的区别。这是不可察觉的隐写术的一个例子。为了简洁起见，我不会详细讨论
    *steg_image_test.py*，但请你一定看看它。
- en: We’ve hidden an image in another image. What’s stopping us from hiding a message
    in an image, then hiding the image with the hidden message in another image, and
    so on, to produce a final output image with a set of Russian doll images inside
    it? Why, nothing at all. Let’s do it.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经将一张图像隐藏在另一张图像中。那我们为什么不能将一条消息隐藏在一张图像中，再把这张隐藏有消息的图像隐藏在另一张图像中，依此类推，最终生成一张包含俄罗斯套娃图像的输出图像呢？为什么不呢？让我们来试试。
- en: The script we want to run is in *russian_dolls_example*, which is shown in [Listing
    2-13](ch02.xhtml#ch02list013).
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 我们要运行的脚本在 *russian_dolls_example* 中，详见 [清单 2-13](ch02.xhtml#ch02list013)。
- en: '[PRE42]'
  id: totrans-310
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: '*Listing 2-13: Encoding and decoding Russian dolls*'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 2-13：编码和解码俄罗斯套娃*'
- en: 'This is a shell script you can run with:'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个你可以运行的 Shell 脚本：
- en: '[PRE43]'
  id: totrans-313
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: When finished, take a look at the image with all the nested images and the original
    message, *russian_dolls.png*. Then compare the source file, *kilroy.txt*, with
    *output.txt* to see that they are the same. The intermediate images with each
    stage of the encoding process are in the system *tmp* directory.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 完成后，查看带有所有嵌套图像和原始消息的图像 *russian_dolls.png*。然后将源文件 *kilroy.txt* 与 *output.txt*
    进行比较，看看它们是否相同。编码过程每个阶段的中间图像保存在系统的 *tmp* 目录中。
- en: '[Figure 2-5](ch02.xhtml#ch02fig05) shows the process of building a stack of
    Russian dolls.'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 2-5](ch02.xhtml#ch02fig05)展示了构建俄罗斯套娃堆的过程。'
- en: '![Image](../images/02fig05.jpg)'
  id: totrans-316
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/02fig05.jpg)'
- en: '*Figure 2-5: Building a stack of Russian dolls*'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 2-5：构建俄罗斯套娃堆*'
- en: 'First, the text message “Kilroy was here” is hidden in the small version of
    the apples image. Then, that image is hidden in the peppers image, which is hidden
    in the fruit image, all of which are hidden in the tulips image as the final output.
    Reversing the process to decode step by step delivers the original message: Kilroy
    was here.'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，“Kilroy was here”这条文本消息被隐藏在苹果图像的小版本中。然后，该图像被隐藏在辣椒图像中，辣椒图像又被隐藏在水果图像中，最终这些都被隐藏在郁金香图像中作为最终输出。逆向这个过程，逐步解码，就能得到原始信息：“Kilroy
    was here”。
- en: '**NOTE**'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*The phrase “Kilroy was here” was used by American and British troops in WWII,
    partly as a joke and partly to mark places where they had already been. It caught
    on after the war, becoming an early meme of sorts, often with a silly character
    face to accompany the message.*'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: '*“Kilroy was here”这句话在二战期间被美英军队使用，部分作为玩笑，部分作为标记他们已经到过的地方。战后它成为了一种早期的网络迷因，通常会伴随一个傻乎乎的角色面孔。*'
- en: Let’s walk through the code to see where Kilroy has been.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们一起走一遍代码，看看 Kilroy 出现过的地方。
- en: '***The steg_image.py Code***'
  id: totrans-322
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***steg_image.py 代码***'
- en: Of all our experiments, *steg_image.py* is perhaps the simplest. It uses both
    `MakeBit` and `MakeByte`, and has a simple driver to call `Encode` and `Decode`.
    Let’s focus on those two functions, beginning with `Encode`, shown in [Listing
    2-14](ch02.xhtml#ch02list014).
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们所有的实验中，*steg_image.py* 可能是最简单的。它使用了`MakeBit`和`MakeByte`，并有一个简单的驱动程序来调用`Encode`和`Decode`。让我们集中讨论这两个函数，从`Encode`开始，见[列表2-14](ch02.xhtml#ch02list014)。
- en: '[PRE44]'
  id: totrans-324
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: '*Listing 2-14: Hiding a file in an image*'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表2-14：将文件隐藏在图像中*'
- en: The file to hide (`mfile`) is read as bytes and immediately converted into a
    vector of bits ➊. The reference image is read next, as RGB if not already, and
    then converted to a NumPy array (`simg`).
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 要隐藏的文件（`mfile`）被读取为字节，并立即转换为比特向量 ➊。接下来，读取参考图像，如果图像还不是RGB格式，则转换为RGB格式，然后转为NumPy数组（`simg`）。
- en: As mentioned previously, we need to prevent overflow when encoding bits, so
    we use NumPy’s `where` function to locate the places in the image that are greater
    than 253\. The `where` function returns a collection of indices, regardless of
    the dimensionality of `simg`, that are immediately used to change said locations
    to 253, the new maximum. This covers all red, green, and blue parts of the image.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，我们需要防止在编码比特时发生溢出，因此我们使用NumPy的`where`函数来定位图像中大于253的位置。`where`函数返回一组索引，不论`simg`的维度如何，这些索引会立即用于将这些位置更改为253，这是新的最大值。这样可以涵盖图像中的所有红、绿、蓝部分。
- en: We intend to use the image as a vector, so we next grab the actual row, column,
    and channel (= 3) numbers to use later when re-forming the image.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 我们打算将图像作为向量使用，因此接下来我们获取实际的行、列和通道（= 3）编号，这些将在稍后重新形成图像时使用。
- en: Next, we tell NumPy to make the three-dimensional image array a vector by calling
    `ravel` ➋. In NumPy, the word *ravel* is a contronym, a word that is its own antonym.
    In this case, ravel means to *unravel*, to change the array into a vector, a one-dimensional
    beast. After `ravel` is called, `simg` is a vector of the bytes of the image.
    We don’t care about where each specific red, green, and blue byte landed; NumPy
    applies `ravel` consistently.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们告诉NumPy通过调用`ravel` ➋将三维图像数组转换为向量。在NumPy中，`ravel`是一个反义词，即一个词语本身就是其反义词。在这种情况下，`ravel`的意思是*展开*，将数组转换为向量，一个一维的结构。调用`ravel`后，`simg`就成为了图像字节的向量。我们不关心每个特定的红、绿、蓝字节的具体位置；NumPy会一致地应用`ravel`。
- en: We have the image as a vector of bytes and the source file as a vector of bits.
    To scatter the bits across the bytes, we need a vector of locations; that’s the
    purpose of `rng` ➌. First, we initialize `rng` using the Mersenne Twister. The
    following four lines build the vector of indices, the bytes we’ll modify (`p`).
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将图像表示为字节向量，将源文件表示为比特向量。为了将比特分散到字节中，我们需要一个位置向量；这就是`rng` ➌的作用。首先，我们使用梅森旋转算法初始化`rng`。接下来的四行代码构建了索引向量，即我们将要修改的字节（`p`）。
- en: We want `p` to have as many elements as bits in `src`. First, we set `p` to
    0, 1, 2, . . . , *n* – 1 for the *n* number of bytes in the image, `simg`. The
    resulting vector is shuffled to create a unique permutation of the values.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望`p`的元素数量与`src`中的比特数量相同。首先，我们将`p`设置为0，1，2，…，*n* – 1，其中*n*是图像`simg`中的字节数。得到的向量经过洗牌，创建了一个值的唯一排列。
- en: The following two lines keep as many elements of `p` as we need to place each
    bit of the source file (`msg`) and sort `p` so the list of indices is in order
    numerically. This last step is necessary because we’re not setting `rng`’s seed,
    so we must apply some order to the image bytes updated to preserve the order of
    the bits in `msg`. You’ll see what I mean when we review `Decode`.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 以下两行保留了`p`中我们需要的元素，以便将源文件（`msg`）的每个比特放置其中，并对`p`进行排序，使得索引列表按数字顺序排列。这个最后的步骤是必要的，因为我们没有设置`rng`的种子，因此必须对图像字节的更新应用某种顺序，以保持`msg`中比特的顺序。我们在回顾`Decode`时，你会明白我是什么意思。
- en: To scatter the bits of `msg` we need only iterate over them and use the corresponding
    index in `p` ➍. We add the bit value plus 1 so that 0 bits become 1 and 1 bit
    becomes 2\. This change lets us detect all altered bits by using the reference
    image as the key.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 为了将`msg`的比特分散，我们只需要遍历它们，并使用`p`中的对应索引 ➍。我们将比特值加1，使得0变成1，1变成2。这个变化使我们能够通过使用参考图像作为密钥来检测所有被修改的比特。
- en: Finally, we `reshape` the updated image bytes to create the 3D output array.
    Notice that `reshape` applies the proper reinterpretation of the bytes in memory,
    an interpretation that matches the order used by `ravel`. In other words, `reshape`
    ravels the array in the opposite sense of the word. The array is passed to the
    PIL `Image` class to be output as a PNG file.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
- en: As shown in [Listing 2-15](ch02.xhtml#ch02list015), `Decode` recovers hidden
    files using the reference image as a key.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  id: totrans-336
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: '*Listing 2-15: Decoding an image*'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
- en: '`Decode` loads two image files, the one with the hidden data (`dimg`) and the
    reference image (`simg`), as NumPy arrays. The function then immediately converts
    both image files to vectors of bytes, and the reference image is passed through
    `convert` to make it an RGB image, as `Encode` did. Also as in `Encode`, reference
    image byte values above 253 are set to 253.'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
- en: NumPy’s `where` returns all the locations where the two images disagree. Because
    we assume the reference image is *exactly* the same image used when creating `dimg`,
    any differences represent bits of the hidden file.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
- en: The difference between the encoded image and the reference image gives us the
    bit values, but as 1 and 2, not 0 and 1\. Therefore, we subtract one more to make
    `d` the vector of hidden bit values. Because we insisted that the bytes were altered
    in numerical order when encoding, the order in which the difference appears in
    the image matches the proper order for the output bits. In other words, we don’t
    need to sort anything; the indices returned by `where` are already in sorted order.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
- en: The remaining two lines convert `d` to bytes and write them to the output file
    (`mfile`).
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
- en: '**Exercises**'
  id: totrans-342
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Steganography offers many possibilities. Here are some to explore and contemplate:'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
- en: Bacon’s cipher uses subtle changes in the type to embed binary codes representing
    letters. What needs to change to embed arbitrary binary data in a text block?
    What about using spaces between words with a proportional font?
  id: totrans-344
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Make your own “spaceship cipher” to hide secret messages in drawings. This might
    be a good activity for the kids.
  id: totrans-345
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Our text experiments neglected to encode the spaces between words. Remedy that
    oversight.
  id: totrans-346
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Can you think of a simple sentence structure with many word options and use
    that to encode a text message à la *steg_text.py*? Generate random sentences using
    a large pool of adjectives, adverbs, nouns, and verbs, so the output reads as
    grammatically correct sentences.
  id: totrans-347
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We used channel 0 when hiding data in audio files. Use both stereo channels
    to double the amount of data that can be encoded.
  id: totrans-348
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Replicate hiding binary data in a file of random bytes, but substitute an audio
    file of white noise (random samples). This removes the restriction on changing
    only the lowest-order bit of each sample. How much data can you fit using both
    channels before the sound changes? What does a file of random bytes sound like
    in the first place? Might sound be a good way to detect randomness in data?
  id: totrans-349
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Lossy image compression destroys our simple approach of changing byte values
    to encode information. How might we add redundancy so that the message persists
    even after using JPEG compression?
  id: totrans-350
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有损图像压缩破坏了我们通过改变字节值来编码信息的简单方法。我们如何增加冗余，使信息即使经过 JPEG 压缩后仍能保持？
- en: What happens to image encoding when the image is resized? Can you think of a
    way to preserve the message using nearest-neighbor sampling? Nearest-neighbor
    sampling duplicates existing pixels when expanding the image and throws pixels
    away when shrinking the image, that is, it does not interpolate.
  id: totrans-351
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当图像被调整大小时，图像编码会发生什么变化？你能想到使用最近邻插值保留信息的办法吗？最近邻插值在放大图像时复制现有像素，在缩小图像时丢弃像素，也就是说，它不进行插值。
- en: Let me know what you think and how it goes.
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 告诉我你的想法和进展如何。
- en: '**Summary**'
  id: totrans-353
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**总结**'
- en: This chapter explored randomness and steganography, the hiding of information.
    We first defined the term, and then contemplated a smattering of historical uses.
    That section alone could easily be a separate book, but it set the stage for the
    experiments.
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 本章探讨了随机性和隐写术，即信息的隐藏。我们首先定义了这些术语，然后回顾了一些历史上的应用。仅这一部分内容就足以成为一本单独的书，但它为实验做了铺垫。
- en: First, we hid text in other text using random selections of letters in a list
    of discrete words. Pseudorandom generators proved helpful with the seed, the secret
    key necessary for correctly decoding the hidden message.
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们通过随机选择离散单词列表中的字母，将文本隐藏在其他文本中。伪随机生成器在种子、解码隐藏消息所需的秘密密钥方面 proved to be helpful.
- en: The following experiment worked with a file of random bytes. The hidden data
    was scattered, bit by bit, throughout the random data, again using the pseudorandom
    generator seed as the secret key. We found that a ratio of about 100:1 between
    the size of the random data and the hidden data generally preserved sufficient
    randomness in the output to properly conceal our message.
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的实验使用了一组随机字节的文件。隐藏的数据被散布在随机数据中，逐位分布，同样使用伪随机生成器种子作为秘密密钥。我们发现，随机数据和隐藏数据的大小比例大约为100:1时，通常可以保留足够的随机性，以正确隐藏我们的信息。
- en: Then we scattered the bits of the hidden file across bit 0 of a set of WAV sound
    samples; this led to an output audio file that gave no auditory indication it
    had been altered. However, a statistical test on the distribution of bit 0 for
    the WAV file revealed evidence of tampering, though extraction of the hidden data
    remained extremely difficult.
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将隐藏文件的位分散到一组 WAV 音频样本的第 0 位中；这导致了一个输出音频文件，听起来并没有任何改变的迹象。然而，对 WAV 文件中第 0
    位分布的统计测试揭示了篡改的迹象，尽管提取隐藏数据仍然极其困难。
- en: Finally, we used the color information in a reference image to embed a file.
    In this experiment, no secret key was necessary; the reference file itself was
    the key. Each encoding generated a different collection of altered image bytes
    at the expense of requiring the entire reference image as the key. We learned
    how computers store and manipulate color images and how to work with image data
    in NumPy. We’ll use this knowledge again in [Chapter 5](ch05.xhtml).
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们使用参考图像中的颜色信息来嵌入文件。在这个实验中，不需要秘密密钥；参考文件本身就是密钥。每次编码都会生成一组不同的修改后的图像字节，代价是需要整个参考图像作为密钥。我们了解了计算机如何存储和处理彩色图像，以及如何在
    NumPy 中操作图像数据。我们将在[第5章](ch05.xhtml)中再次使用这些知识。
- en: 'It isn’t difficult to imagine illegitimate uses of steganography. I’m reminded
    here of the wisdom of Ben Parker: with great power comes great responsibility.
    If you’re inclined to use steganography for something other than simple “I wonder
    if it would work” experiments, think carefully about it, put this book down, get
    a cup of coffee, take a walk, and forget about it.'
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下隐写术的非法用途并不困难。我在这里想起了本·帕克的智慧：能力越大，责任越大。如果你打算将隐写术用于除了简单的“我想知道它是否有效”的实验之外的其他目的，请仔细考虑，放下这本书，喝杯咖啡，散步，忘掉它。
- en: The next chapter introduces us to the vast, randomness-heavy world of simulation.
    I think it’ll be fun. I hope you agree.
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 下一章将引导我们进入一个广阔的、充满随机性的模拟世界。我觉得会很有趣。希望你也同意。
- en: Read *poem.txt*. It’s an Easter egg.
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 阅读*poem.txt*。它是一个彩蛋。
