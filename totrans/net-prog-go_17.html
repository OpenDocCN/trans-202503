<html><head></head><body>
<section>&#13;
<header>&#13;
<h1 class="chapter">&#13;
<span class="ChapterNumber"><span epub:type="pagebreak" id="Page_295" title="295"/>13</span><br/>&#13;
<span class="ChapterTitle">Logging and Metrics</span>&#13;
</h1>&#13;
</header>&#13;
<figure class="opener">&#13;
<img alt="" src="image_fi/book_art/chapterart.png"/>&#13;
</figure>&#13;
<p class="ChapterIntro">In an ideal world, our code would be free of bugs from the outset. Our network services would exceed our expectations for performance and capacity, and they would be robust enough to adapt to unexpected input without our intervention. But in the real world, we need to worry about unexpected and potentially malicious input, hardware degradation, network outages, and outright bugs in our code.</p>&#13;
<p>Monitoring our applications, no matter whether they are on premises or in the cloud, is vital to providing resilient, functional services to our users. Comprehensive logging allows us to receive timely details about errors, anomalies, or other actionable events, and metrics give us insight into the current state of our services, as well as help us identify bottlenecks. Taken together, logging and metrics allow us to manage service issues and focus our development efforts to avoid future failures.</p>&#13;
<p><span epub:type="pagebreak" id="Page_296" title="296"/>You’ve used Go’s <code>log</code> and <code>fmt</code> packages to give you feedback in previous chapters, but this chapter will take a deeper dive into logging and instrumenting your services. You will learn how to use log levels to increase or decrease the verbosity of your logs and when to use each log level. You’ll learn how to add structure to your log entries so software can help you make better sense of log entries and zero in on relevant logs. I’ll introduce you to the concept of wide event logging, which will help you maintain a handle on the amount of data you log as your services scale. You’ll learn techniques for dynamically enabling debug logging and managing log file rotation from your code.</p>&#13;
<p>This chapter will also introduce you to Go kit’s <code>metrics</code> package. Per Go kit’s documentation, the <code>metrics</code> package “provides a set of uniform interfaces for service instrumentation.” You’ll learn how to instrument your services by using counters, gauges, and histograms.</p>&#13;
<p>By the end of this chapter, you should have a handle on how to approach logging, how to manage log files to prevent them from consuming too much hard drive space, and how to instrument your services to gain insight into their current state.</p>&#13;
<h2 id="h1-500884c13-0001">Event Logging</h2>&#13;
<p class="BodyFirst">Logging is hard. Even experienced developers struggle to get it right. It’s tough to anticipate what questions you’ll need your logs to answer in the future, when your service fails—yet you should resist the urge to log everything just in case. You need to strike a balance in order to log the right information to answer those questions without overwhelming yourself with irrelevant log lines. Overzealous logging may suit you fine in development, where you control the scale of testing and overall entropy of your service, but it will quickly degrade your ability to find the needle in the haystack when you need to diagnose production failures.</p>&#13;
<p>In addition to figuring out what to log, you need to consider that logging isn’t free. It consumes CPU and I/O time your application could otherwise use. A log entry added to a busy <code>for</code> loop while in development may help you understand what your service is doing. But it may become a bottleneck in production, insidiously adding latency to your service. </p>&#13;
<p>Instead, sampling these log entries, or logging on demand, may provide suitable compromises between log output and overhead. You might find it helpful to use <em>wide</em><em>event</em> log entries, which summarize a transaction. For example, a service in development may log half a dozen entries about a request, any intermediate steps, and a response. In production, a single wide event log entry providing these details scales better. You’ll learn more about wide event log entries in “Scaling Up with Wide Event Logging” <span class="xref" itemid="xref_target_on page 312">on page 312</span>.</p>&#13;
<p>Lastly, logging is subjective. An anomaly may be inconsequential in my application but indicative of a larger issue in your application. Whereas I could ignore the anomaly, you’d likely want to know about it. For this <span epub:type="pagebreak" id="Page_297" title="297"/>reason, it’s best if we discuss logging in terms of best practices. These practices are a good baseline approach, but you should tailor them to each application.</p>&#13;
<h3 id="h2-500884c13-0001">The log Package</h3>&#13;
<p class="BodyFirst">You have superficial experience using Go’s <code>log</code> package, in earlier chapters, for basic logging needs, like timestamping log entries and optionally exiting your application with <code>log.Fatal</code>. But it has a few more features we have yet to explore. These require us to go beyond the package-level logger and instantiate our own <code>*log.Logger</code> instance. You can do this using the <code>log.New</code> function:</p>&#13;
<pre><code>func New(out io.Writer, prefix string, flag int) *Logger</code></pre>&#13;
<p>The <code>log.New</code> function accepts an <code>io.Writer</code>, a string prefix to use on each log line, and a set of flags that modify the logger’s output. Accepting an <code>io.Writer</code> means the logger can write to anything that satisfies that interface, including an in-memory buffer or a network socket. </p>&#13;
<p>The default logger writes its output to <code>os.Stderr</code>, standard error. Let’s look at an example logger in <a href="#listing13-1" id="listinganchor13-1">Listing 13-1</a> that writes to <code>os.Stdout</code>, standard output.</p>&#13;
<pre><code>func Example_log() {&#13;
    l := log.New(<span class="CodeAnnotation">1</span>os.Stdout, <span class="CodeAnnotation">2</span>"example: ", <span class="CodeAnnotation">3</span>log.Lshortfile)&#13;
    l.Print("logging to standard output")&#13;
&#13;
    // Output:&#13;
    // example: <span class="CodeAnnotation">4</span>log_test.go:12: logging to standard output&#13;
}</code></pre>&#13;
<p class="CodeListingCaption"><a id="listing13-1">Listing 13-1</a>: Writing a log entry to standard output (<em>log_test.go</em>)</p>&#13;
<p>You create a new <code>*log.Logger</code> instance that writes to standard output <span class="CodeAnnotation">1</span>. The logger prefixes each line with the string <em>example:</em><span class="CodeAnnotation">2</span>. The flags of the default logger are <code>log.Ldate</code> and <code>log.Ltime</code>, collectively <code>log.LstdFlags</code>, which print the timestamp of each log entry. Since you want to simplify the output for testing purposes when you run the example on the command line, you omit the timestamp and configure the logger to write the source code filename and line of each log entry <span class="CodeAnnotation">3</span>. The <code>l.Print</code> function on line 12 of the <em>log_test.go</em> file results in the output of those values <span class="CodeAnnotation">4</span>. This behavior can help with development and debugging, allowing you to zero in on the exact file and line of an interesting log entry.</p>&#13;
<p>Recognizing that the logger accepts an <code>io.Writer</code>, you may realize this allows you to use multiple writers, such as a log file and standard output or an in-memory ring buffer and a centralized logging server over a network. Unfortunately, the <code>io.MultiWriter</code> is not ideal for use in logging. An <code>io.MultiWriter</code> writes to each of its writers in sequence, aborting if it receives an error from any <code>Write</code> call. This means that if you configure <span epub:type="pagebreak" id="Page_298" title="298"/>your <code>io.MultiWriter</code> to write to a log file and standard output in that order, standard output will never receive the log entry if an error occurred when writing to the log file.</p>&#13;
<p>Fear not. It’s an easy problem to solve. Let’s create our own <code>io.MultiWriter</code> implementation, starting in <a href="#listing13-2" id="listinganchor13-2">Listing 13-2</a>, that sustains writes across its writers and accumulates any errors it encounters.</p>&#13;
<pre><code>package ch13&#13;
&#13;
import (&#13;
    "io"&#13;
&#13;
    "go.uber.org/multierr"&#13;
)&#13;
&#13;
type sustainedMultiWriter struct {&#13;
    writers []io.Writer&#13;
}&#13;
&#13;
func (s *sustainedMultiWriter) <span class="CodeAnnotation">1</span>Write(p []byte) (n int, err error) {&#13;
    for _, w := range s.writers {&#13;
        i, wErr := <span class="CodeAnnotation">2</span>w.Write(p)&#13;
        n += i&#13;
        err = <span class="CodeAnnotation">3</span>multierr.Append(err, wErr)&#13;
    }&#13;
&#13;
    return n, err&#13;
}</code></pre>&#13;
<p class="CodeListingCaption"><a id="listing13-2">Listing 13-2</a>: A multiwriter that sustains writing even after receiving an error (<em>writer.go</em>)</p>&#13;
<p>As with <code>io.MultiWriter</code>, you’ll use a struct that contains a slice of <code>io.Writer</code> instances for your sustained multiwriter. Your multiwriter implements the <code>io.Writer</code> interface <span class="CodeAnnotation">1</span>, so you can pass it into your logger. It calls each writer’s <code>Write</code> method <span class="CodeAnnotation">2</span>, accumulating any errors with the help of Uber’s <code>multierr</code> package <span class="CodeAnnotation">3</span>, before ultimately returning the total written bytes and cumulative error.</p>&#13;
<p><a href="#listing13-3" id="listinganchor13-3">Listing 13-3</a> adds a function to initialize a new sustained multiwriter from one or more writers.</p>&#13;
<pre><code><var>--snip--</var>&#13;
&#13;
func SustainedMultiWriter(writers ...io.Writer) io.Writer {&#13;
    mw := &amp;sustainedMultiWriter{writers: <span class="CodeAnnotation">1</span>make([]io.Writer, 0, len(writers))}&#13;
&#13;
    for _, w := range writers {&#13;
        if m, ok := <span class="CodeAnnotation">2</span>w.(*sustainedMultiWriter); ok {&#13;
            mw.writers = <span class="CodeAnnotation">3</span>append(mw.writers, m.writers...)&#13;
            continue&#13;
        }&#13;
&#13;
        mw.writers = <span class="CodeAnnotation">4</span>append(mw.writers, w)&#13;
<span epub:type="pagebreak" id="Page_299" title="299"/>    }&#13;
&#13;
    return mw&#13;
}</code></pre>&#13;
<p class="CodeListingCaption"><a id="listing13-3">Listing 13-3</a>: Creating a sustained multiwriter (<em>writer.go</em>)</p>&#13;
<p>First, you instantiate a new <code>*sustainedMultiWriter</code>, initialize its writers slice <span class="CodeAnnotation">1</span>, and cap it to the expected length of writers. You then loop through the given writers and append them to the slice <span class="CodeAnnotation">4</span>. If a given writer is itself a <code>*sustainedMultiWriter</code><span class="CodeAnnotation">2</span>, you instead append its writers <span class="CodeAnnotation">3</span>. Finally, you return the pointer to the initialized <code>sustainedMultiWriter</code>.</p>&#13;
<p>You can now put your sustained multiwriter to good use in <a href="#listing13-4" id="listinganchor13-4">Listing 13-4</a>.</p>&#13;
<pre><code>package ch13&#13;
&#13;
import (&#13;
    "bytes"&#13;
    "fmt"&#13;
    "log"&#13;
    "os"&#13;
)&#13;
&#13;
func Example_logMultiWriter() {&#13;
    logFile := new(bytes.Buffer)&#13;
    w := <span class="CodeAnnotation">1</span>SustainedMultiWriter(os.Stdout, logFile)&#13;
    l := log.New(w, "example: ", <span class="CodeAnnotation">2</span>log.Lshortfile|log.Lmsgprefix)&#13;
&#13;
    fmt.Println("standard output:")&#13;
    l.Print("Canada is south of Detroit")&#13;
&#13;
    fmt.Print("\nlog file contents:\n", logFile.String())&#13;
&#13;
    // Output:&#13;
    // standard output:&#13;
    // log_test.go:24: example: Canada is south of Detroit&#13;
    //&#13;
    // log file contents:&#13;
    // log_test.go:24: example: Canada is south of Detroit&#13;
}</code></pre>&#13;
<p class="CodeListingCaption"><a id="listing13-4">Listing 13-4</a>: Logging simultaneously to a log file and standard output (<em>log_test.go</em>)</p>&#13;
<p>You create a new sustained multiwriter <span class="CodeAnnotation">1</span>, writing to standard output, and a <code>bytes.Buffer</code> meant to act as a log file in this example. Next, you create a new logger using your sustained multiwriter, the prefix <em><code>example</code>:</em>, and two flags <span class="CodeAnnotation">2</span> to modify the logger’s behavior. The addition of the <code>log.Lmsgprefix</code> flag (first available in Go 1.14) tells the logger to locate the prefix just before the log message. You can see the effect this has on the log entries in the example output. When you run this example, you see that the logger writes the log entry to the sustained multiwriter, which in turn writes the log entry to both standard output and the log file.</p>&#13;
<h3 id="h2-500884c13-0002"><span epub:type="pagebreak" id="Page_300" title="300"/>Leveled Log Entries</h3>&#13;
<p class="BodyFirst">I wrote earlier in the chapter that verbose logging may be inefficient in production and can overwhelm you with the sheer number of log entries as your service scales up. One way to avoid this is by instituting <em>logging levels</em>, which assign a priority to each kind of event, enabling you to always log high-priority errors but conditionally log low-priority entries more suited for debugging and development purposes. For example, you’d always want to know if your service is unable to connect to its database, but you may care to log only details about individual connections while in development or when diagnosing a failure.</p>&#13;
<p>I recommend you create just a few log levels to begin with. In my experience, you can address most use cases with just an <em>error</em> level and a <em>debug</em> level, maybe even an <em>info</em> level on occasion. Error log entries should accompany some sort of alert, since these entries indicate a condition that needs your attention. Info log entries typically log non-error information. For example, it may be appropriate for your use case to log a successful database connection or to add a log entry when a listener is ready for incoming connections on a network socket. Debug log entries should be verbose and serve to help you diagnose failures, as well as aid development by helping you reason about the workflow.</p>&#13;
<p>Go’s ecosystem offers several logging packages, most of which support numerous log levels. Although Go’s <code>log</code> package does not have inherent support for leveled log entries, you can add similar functionality by creating separate loggers for each log level you need. <a href="#listing13-5" id="listinganchor13-5">Listing 13-5</a> does this: it writes log entries to a log file, but it also writes debug logs to standard output.</p>&#13;
<pre><code><var>--snip--</var>&#13;
&#13;
func Example_logLevels() {&#13;
    lDebug := log.New(os.Stdout, <span class="CodeAnnotation">1</span>"DEBUG: ", log.Lshortfile)&#13;
    logFile := new(bytes.Buffer)&#13;
    w := SustainedMultiWriter(logFile, <span class="CodeAnnotation">2</span>lDebug.Writer())&#13;
    lError := log.New(w, <span class="CodeAnnotation">3</span>"ERROR: ", log.Lshortfile)&#13;
&#13;
    fmt.Println("standard output:")&#13;
    lError.Print("cannot communicate with the database")&#13;
    lDebug.Print("you cannot hum while holding your nose")&#13;
&#13;
    fmt.Print("\nlog file contents:\n", logFile.String())&#13;
&#13;
    // Output:&#13;
    // standard output:&#13;
    // ERROR: log_test.go:43: cannot communicate with the database&#13;
    // DEBUG: log_test.go:44: you cannot hum while holding your nose&#13;
    //&#13;
    // log file contents:&#13;
    // ERROR: log_test.go:43: cannot communicate with the database&#13;
}</code></pre>&#13;
<p class="CodeListingCaption"><a id="listing13-5">Listing 13-5</a>: Writing debug entries to standard output and errors to both the log file and standard output (<em>log_test.go</em>)</p>&#13;
<p><span epub:type="pagebreak" id="Page_301" title="301"/>First, you create a debug logger that writes to standard output and uses the <code>DEBUG:</code> prefix <span class="CodeAnnotation">1</span>. Next, you create a <code>*bytes.Buffer</code> to masquerade as a log file for this example and instantiate a sustained multiwriter. The sustained multiwriter writes to both the log file and the debug logger’s <code>io.Writer</code><span class="CodeAnnotation">2</span>. Then, you create an error logger that writes to the sustained multiwriter by using the prefix <code>ERROR:</code><span class="CodeAnnotation">3</span> to differentiate its log entries from the debug logger. Finally, you use each logger and verify that they output what you expect. Standard output should display log entries from both loggers, whereas the log file should contain only error log entries.</p>&#13;
<p>As an exercise, figure out how to make the debug logger conditional without wrapping its <code>Print</code> call in a conditional. If you need a hint, you’ll find a suitable writer in the <code>io/ioutil</code> package that will let you discard its output.</p>&#13;
<p>This section is meant to demonstrate additional uses of the <code>log</code> package beyond what you’ve used so far in this book. Although it’s possible to use this technique to log at different levels, you’d be better served by a logger with inherent support for log levels, like the Zap logger described in the next section.</p>&#13;
<h3 id="h2-500884c13-0003">Structured Logging</h3>&#13;
<p class="BodyFirst">The log entries made by the code you’ve written so far are meant for human consumption. They are easy for you to read, since each log entry is little more than a message. This means that finding log lines relevant to an issue involves liberal use of the <code>grep</code> command or, at worst, manually skimming log entries. But this could become more challenging if the number of log entries increases. You may find yourself looking for a needle in a haystack. Remember, logging is useful only if you can quickly find the information you need. </p>&#13;
<p>A common approach to solving this problem is to add metadata to your log entries and then parse the metadata with software to help you organize them. This type of logging is called <em>structured logging</em>. Creating structured log entries involves adding key-value pairs to each log entry. In these, you may include the time at which you logged the entry, the part of your application that made the log entry, the log level, the hostname or IP address of the node that created the log entry, and other bits of metadata that you can use for indexing and filtering. Most structured loggers encode log entries as JSON before writing them to log files or shipping them to centralized logging servers. Structured logging makes the whole process of collecting logs in a centralized server easy, since the additional metadata associated with each log entry allows the server to organize and collate log entries across services. Once they’re indexed, you can query the log server for specific log entries to better find timely answers to your questions.</p>&#13;
<h4 id="h3-500884c13-0001">Using the Zap Logger</h4>&#13;
<p class="BodyFirst">Discussing specific centralized logging solutions is beyond the scope of this book. If you’re interested in learning more, I suggest you initially investigate <span epub:type="pagebreak" id="Page_302" title="302"/>Elasticsearch or Apache Solr. Instead, this section focuses on implementing the logger itself. You’ll use the Zap logger from Uber, found at <a class="LinkURL" href="https://pkg.go.dev/go.uber.org/zap/">https://pkg.go.dev/go.uber.org/zap/</a>, which allows you to integrate log file rotation. </p>&#13;
<p><em>Log file rotation</em> is the process of closing the current log file, renaming it, and then opening a new log file after the current log file reaches a specific age or size threshold. Rotating log files is a good practice to prevent them from filling up your available hard drive space. Plus, searching through smaller, date-delimited log files is more efficient than searching through a single, monolithic log file. For example, you may want to rotate your log files every week and keep only eight weeks’ worth of rotated log files. If you wanted to look at log entries for an event that occurred last week, you could limit your search to a single log file. Also, you can compress the rotated log files to further save hard drive space.</p>&#13;
<p>I’ve used other structured loggers on large projects, and in my experience, Zap causes the least overhead; I can use it in busy bits of code without a noticeable performance hit, unlike other heavyweight structured loggers. But your mileage may vary, so I encourage you to find what works best for you. You can apply the structured logging principles and log file management techniques described here to other structured loggers.</p>&#13;
<p>The Zap logger includes <code>zap.Core</code> and its options. The <code>zap.Core</code> has three components: a log-level threshold, an output, and an encoder. The <em>log-level threshold</em> sets the minimum log level that Zap will log; Zap will simply ignore any log entry below that level, allowing you to leave debug logging in your code and configure Zap to conditionally ignore it. Zap’s <em>output</em> is a <code>zapcore.WriteSyncer</code>, which is an <code>io.Writer</code> with an additional <code>Sync</code> method. Zap can write log entries to any object that implements this interface. And the <em>encoder</em> can encode the log entry before writing it to the output. </p>&#13;
<h4 id="h3-500884c13-0002">Writing the Encoder</h4>&#13;
<p class="BodyFirst">Although Zap provides a few helper functions, such as <code>zap.NewProduction</code> or <code>zap.NewDevelopment</code>, to quickly create production and development loggers, you’ll create one from scratch, starting with the encoder configuration in <a href="#listing13-6" id="listinganchor13-6">Listing 13-6</a>.</p>&#13;
<pre><code>package ch13&#13;
&#13;
import (&#13;
    "bytes"&#13;
    "fmt"&#13;
    "io/ioutil"&#13;
    "log"&#13;
    "os"&#13;
    "path/filepath"&#13;
    "runtime"&#13;
    "testing"&#13;
    "time"&#13;
&#13;
    "go.uber.org/zap"&#13;
    "go.uber.org/zap/zapcore"&#13;
    "gopkg.in/fsnotify.v1"&#13;
<span epub:type="pagebreak" id="Page_303" title="303"/>    "gopkg.in/natefinch/lumberjack.v2"&#13;
)&#13;
&#13;
var encoderCfg = zapcore.EncoderConfig{&#13;
    MessageKey: <span class="CodeAnnotation">1</span>"msg",&#13;
    NameKey:    <span class="CodeAnnotation">2</span>"name",&#13;
&#13;
    LevelKey:    "level",&#13;
    EncodeLevel: <span class="CodeAnnotation">3</span>zapcore.LowercaseLevelEncoder,&#13;
&#13;
    CallerKey:    "caller",&#13;
    EncodeCaller: <span class="CodeAnnotation">4</span>zapcore.ShortCallerEncoder,&#13;
&#13;
 <span class="CodeAnnotation">5</span> // TimeKey:   "time",&#13;
    // EncodeTime: zapcore.ISO8601TimeEncoder,&#13;
}</code></pre>&#13;
<p class="CodeListingCaption"><a id="listing13-6">Listing 13-6</a>: The encoder configuration for your Zap logger (<em>zap_test.go</em>)</p>&#13;
<p>The encoder configuration is independent of the encoder itself in that you can use the same encoder configuration no matter whether you’re passing it to a JSON encoder or a console encoder. The encoder will use your configuration to dictate its output format. Here, your encoder configuration dictates that the encoder use the key <code>msg </code><span class="CodeAnnotation">1</span> for the log message and the key <code>name</code><span class="CodeAnnotation">2</span> for the logger’s name in the log entry. Likewise, the encoder configuration tells the encoder to use the key <code>level</code> for the logging level and encode the level name using all lowercase characters <span class="CodeAnnotation">3</span>. If the logger is configured to add caller details, you want the encoder to associate these details with the <code>caller</code> key and encode the details in an abbreviated format <span class="CodeAnnotation">4</span>.</p>&#13;
<p>Since you need to keep the output of the following examples consistent, you’ll omit the <code>time</code> key <span class="CodeAnnotation">5</span> so it won’t show up in the output. In practice, you’d want to uncomment these two fields.</p>&#13;
<h4 id="h3-500884c13-0003">Creating the Logger and Its Options</h4>&#13;
<p class="BodyFirst">Now that you’ve defined the encoder configuration, let’s use it in <a href="#listing13-7" id="listinganchor13-7">Listing 13-7</a> by instantiating a Zap logger.</p>&#13;
<pre><code><var>--snip--</var>&#13;
&#13;
func Example_zapJSON() {&#13;
    zl := zap.New(&#13;
     <span class="CodeAnnotation">1</span> zapcore.NewCore(&#13;
         <span class="CodeAnnotation">2</span> zapcore.NewJSONEncoder(encoderCfg),&#13;
         <span class="CodeAnnotation">3</span> zapcore.Lock(os.Stdout),&#13;
         <span class="CodeAnnotation">4</span> zapcore.DebugLevel,&#13;
        ),&#13;
     <span class="CodeAnnotation">5</span> zap.AddCaller(),&#13;
        zap.Fields(&#13;
         <span class="CodeAnnotation">6</span> zap.String("version", runtime.Version()),&#13;
        ),&#13;
    )&#13;
    defer func() { _ = <span class="CodeAnnotation">7</span>zl.Sync() }()&#13;
&#13;
<span epub:type="pagebreak" id="Page_304" title="304"/>    example := <span class="CodeAnnotation">8</span>zl.Named("example")&#13;
    example.Debug("test debug message")&#13;
    example.Info("test info message")&#13;
&#13;
    // Output:&#13;
 <span class="CodeAnnotation">9</span> // {"level":"debug","name":"example","caller":"ch13/zap_test.go:49",&#13;
"msg":"test debug message","version":"<span class="CodeAnnotation">a</span>go1.15.5"}&#13;
    // {"level":"info","name":"example","caller":"ch13/zap_test.go:50",&#13;
"msg":"test info message","version":"go1.15.5"}&#13;
}</code></pre>&#13;
<p class="CodeListingCaption"><a id="listing13-7">Listing 13-7</a>: Instantiating a new logger from the encoder configuration and logging to JSON (<em>zap_test.go</em>)</p>&#13;
<p>The <code>zap.New</code> function accepts a <code>zap.Core</code><span class="CodeAnnotation">1</span> and zero or more <code>zap.Options</code>. In this example, you’re passing the <code>zap.AddCaller</code> option <span class="CodeAnnotation">5</span>, which instructs the logger to include the caller information in each log entry, and a field <span class="CodeAnnotation">6</span> named <code>version</code> that inserts the runtime version in each log entry.</p>&#13;
<p>The <code>zap.Core</code> consists of a JSON encoder using your encoder configuration <span class="CodeAnnotation">2</span>, a <code>zapcore.WriteSyncer</code><span class="CodeAnnotation">3</span>, and the logging threshold <span class="CodeAnnotation">4</span>. If the <code>zapcore.WriteSyncer</code> isn’t safe for concurrent use, you can use <code>zapcore.Lock</code> to make it concurrency safe, as in this example.</p>&#13;
<p>The Zap logger includes seven log levels, in increasing severity: <code>DebugLevel</code>, <code>InfoLevel</code>, <code>WarnLevel</code>, <code>ErrorLevel</code>, <code>DPanicLevel</code>, <code>PanicLevel</code>, and <code>FatalLevel</code>. The <code>InfoLevel</code> is the default. <code>DPanicLevel</code> and <code>PanicLevel</code> entries will cause Zap to log the entry and then panic. An entry logged at the <code>FatalLevel</code> will cause Zap to call <code>os.Exit(1)</code> after writing the log entry. Since your logger is using <code>DebugLevel</code>, it will log all entries.</p>&#13;
<p>I recommend you restrict the use of <code>DPanicLevel</code> and <code>PanicLevel</code> to development and <code>FatalLevel</code> to production, and only then for catastrophic startup errors, such as a failure to connect to the database. Otherwise, you’re asking for trouble. As mentioned earlier, you can get a lot of mileage out of <code>DebugLevel</code>, <code>ErrorLevel</code>, and on occasion, <code>InfoLevel</code>.</p>&#13;
<p>Before you start using the logger, you want to make sure you defer a call to its <code>Sync</code> method <span class="CodeAnnotation">7</span> to ensure all buffered data is written to the output. </p>&#13;
<p>You can also assign the logger a name by calling its <code>Named</code> method <span class="CodeAnnotation">8</span> and using the returned logger. By default, a logger has no name. A named logger will include a name key in the log entry, provided you defined one in the encoder configuration. </p>&#13;
<p>The log entries <span class="CodeAnnotation">9</span> now include metadata around the log message, so much so that the log line output exceeds the width of this book. It’s also important to mention that the Go version <span class="CodeAnnotation">a</span> in the example output is dependent on the version of Go you’re using to test this example. Although you’re encoding each log entry in JSON, you can still read the additional metadata you’re including in the logs. You could ingest this JSON into something like Elasticsearch and run queries on it, letting Elasticsearch do the heavy lifting of returning only those log lines that are relevant to your query.</p>&#13;
<h4 id="h3-500884c13-0004"><span epub:type="pagebreak" id="Page_305" title="305"/>Using the Console Encoder</h4>&#13;
<p class="BodyFirst">The preceding example included a bunch of functionality in relatively little code. Let’s instead assume you want to log something a bit more human-readable, yet that has structure. Zap includes a console encoder that’s essentially a drop-in replacement for its JSON encoder. <a href="#listing13-8" id="listinganchor13-8">Listing 13-8</a> uses the console encoder to write structured log entries to standard output.</p>&#13;
<pre><code><var>--snip--</var>&#13;
&#13;
func Example_zapConsole() {&#13;
    zl := zap.New(&#13;
        zapcore.NewCore(&#13;
         <span class="CodeAnnotation">1</span> zapcore.NewConsoleEncoder(encoderCfg),&#13;
            zapcore.Lock(os.Stdout),&#13;
         <span class="CodeAnnotation">2</span> zapcore.InfoLevel,&#13;
        ),&#13;
    )&#13;
    defer func() { _ = zl.Sync() }()&#13;
&#13;
    console := <span class="CodeAnnotation">3</span>zl.Named("[console]")&#13;
    console.Info("this is logged by the logger")&#13;
 <span class="CodeAnnotation">4</span> console.Debug("this is below the logger's threshold and won't log")&#13;
    console.Error("this is also logged by the logger")&#13;
&#13;
    // Output:&#13;
 <span class="CodeAnnotation">5</span> // info   [console]   this is logged by the logger&#13;
    // error  [console]   this is also logged by the logger&#13;
}</code></pre>&#13;
<p class="CodeListingCaption"><a id="listing13-8">Listing 13-8</a>: Writing structured logs using console encoding (<em>zap_test.go</em>)</p>&#13;
<p>The console encoder <span class="CodeAnnotation">1</span> uses tabs to separate fields. It takes instruction from your encoder configuration to determine which fields to include and how to format each. </p>&#13;
<p>Notice you don’t pass the <code>zap.AddCaller</code> and <code>zap.Fields</code> options to the logger in this example. As a result, the log entries won’t have <code>caller</code> and <code>version</code> fields. Log entries will include the <code>caller</code> field only if the logger has the <code>zap.AddCaller</code> option and the encoder configuration defines its <code>CallerKey</code>, as in <a href="#listing13-6">Listing 13-6</a>.</p>&#13;
<p>You name the logger <span class="CodeAnnotation">3</span> and write three log entries, each with a different log level. Since the logger’s threshold is the <code>info</code> level <span class="CodeAnnotation">2</span>, the debug log entry <span class="CodeAnnotation">4</span> does not appear in the output because <code>debug</code> is below the <code>info</code> threshold.</p>&#13;
<p>The output <span class="CodeAnnotation">5</span> lacks key names but includes the field values delimited by a tab character. Although not obvious in print, there’s a tab character between the log level, the log name, and the log message. If you type this into your editor, be mindful to add tab characters between those elements lest the example fail when you run it.</p>&#13;
<h4 id="h3-500884c13-0005"><span epub:type="pagebreak" id="Page_306" title="306"/>Logging with Different Outputs and Encodings</h4>&#13;
<p class="BodyFirst">Zap includes useful functions that allow you to concurrently log to different outputs, using different encodings, at different log levels. <a href="#listing13-9" id="listinganchor13-9">Listing 13-9</a> creates a logger that writes JSON to a log file and console encoding to standard output. The logger writes only the debug log entries to the console.</p>&#13;
<pre><code><var>--snip--</var>&#13;
&#13;
func Example_zapInfoFileDebugConsole() {&#13;
    logFile := <span class="CodeAnnotation">1</span>new(bytes.Buffer)&#13;
    zl := zap.New(&#13;
        zapcore.NewCore(&#13;
            zapcore.NewJSONEncoder(encoderCfg),&#13;
            zapcore.Lock(<span class="CodeAnnotation">2</span>zapcore.AddSync(logFile)),&#13;
            zapcore.InfoLevel,&#13;
        ),&#13;
    )&#13;
    defer func() { _ = zl.Sync() }()&#13;
&#13;
 <span class="CodeAnnotation">3</span> zl.Debug("this is below the logger's threshold and won't log")&#13;
    zl.Error("this is logged by the logger")</code></pre>&#13;
<p class="CodeListingCaption"><a id="listing13-9">Listing 13-9</a>: Using <var>*bytes.Buffer</var> as the log output and logging JSON to it (<em>zap_test.go</em>)</p>&#13;
<p>You’re using <code>*bytes.Buffer</code><span class="CodeAnnotation">1</span> to act as a mock log file. The only problem with this is that <code>*bytes.Buffer</code> does not have a <code>Sync</code> method and does not implement the <code>zapcore.WriteSyncer</code> interface. Thankfully, Zap includes a helper function named <code>zapcore.AddSync</code><span class="CodeAnnotation">2</span> that intelligently adds a no-op <code>Sync</code> method to an <code>io.Writer</code>. Aside from the use of this function, the rest of the logger implementation should be familiar to you. It’s logging JSON to the log file and excluding any log entries below the <code>info</code> level. As a result, the first log entry <span class="CodeAnnotation">3</span> should not appear in the log file at all.</p>&#13;
<p>Now that you have a logger writing JSON to a log file, let’s experiment with Zap and create a new logger in <a href="#listing13-10" id="listinganchor13-10">Listing 13-10</a> that can simultaneously write JSON log entries to a log file and console log entries to standard output.</p>&#13;
<pre><code><var>--snip--</var>&#13;
&#13;
    zl = <span class="CodeAnnotation">1</span>zl.WithOptions(&#13;
     <span class="CodeAnnotation">2</span> zap.WrapCore(&#13;
            func(c zapcore.Core) zapcore.Core {&#13;
                ucEncoderCfg := encoderCfg&#13;
             <span class="CodeAnnotation">3</span> ucEncoderCfg.EncodeLevel = zapcore.CapitalLevelEncoder&#13;
                return <span class="CodeAnnotation">4</span>zapcore.NewTee(&#13;
                    c,&#13;
                 <span class="CodeAnnotation">5</span> zapcore.NewCore(&#13;
                        zapcore.NewConsoleEncoder(ucEncoderCfg),&#13;
                        zapcore.Lock(os.Stdout),&#13;
                        zapcore.DebugLevel,&#13;
                    ),&#13;
                )&#13;
            },&#13;
        ),&#13;
<span epub:type="pagebreak" id="Page_307" title="307"/>    )&#13;
&#13;
    fmt.Println("standard output:")&#13;
 <span class="CodeAnnotation">6</span> zl.Debug("this is only logged as console encoding")&#13;
    zl.Info("this is logged as console encoding and JSON")&#13;
&#13;
    fmt.Print("\nlog file contents:\n", logFile.String())&#13;
&#13;
    // Output:&#13;
    // standard output:&#13;
    // DEBUG   this is only logged as console encoding&#13;
    // INFO    this is logged as console encoding and JSON&#13;
    //&#13;
    // log file contents:&#13;
    // {"level":"error","msg":"this is logged by the logger"}&#13;
    // {"level":"info","msg":"this is logged as console encoding and JSON"}&#13;
}</code></pre>&#13;
<p class="CodeListingCaption"><a id="listing13-10">Listing 13-10</a>: Extending the logger to log to multiple outputs (<em>zap_test.go</em>)</p>&#13;
<p>Zap’s <code>WithOptions</code> method <span class="CodeAnnotation">1</span> clones the existing logger and configures the clone with the given options. You can use the <code>zap.WrapCore</code> function <span class="CodeAnnotation">2</span> to modify the underlying <code>zap.Core</code> of the cloned logger. To mix things up, you make a copy of the encoder configuration and tweak it to instruct the encoder to output the level using all capital letters <span class="CodeAnnotation">3</span>. Lastly, you use the <code>zapcore.NewTee</code> function, which is like the <code>io.MultiWriter</code> function, to return a <code>zap.Core</code> that writes to multiple cores <span class="CodeAnnotation">4</span>. In this example, you’re passing in the existing core and a new core <span class="CodeAnnotation">5</span> that writes <code>debug</code>-level log entries to standard output.</p>&#13;
<p>When you use the cloned logger, both the log file and standard output receive any log entry at the <code>info</code> level or above, whereas only standard output receives debugging log entries <span class="CodeAnnotation">6</span>.</p>&#13;
<h4 id="h3-500884c13-0006">Sampling Log Entries</h4>&#13;
<p class="BodyFirst">One of my warnings to you with regard to logging is to consider how it impacts your application from a CPU and I/O perspective. You don’t want logging to become your application’s bottleneck. This normally means taking special care when logging in the busy parts of your application. </p>&#13;
<p>One method to mitigate the logging overhead in critical code paths, such as a loop, is to sample log entries. It may not be necessary to log each entry, especially if your logger is outputting many duplicate log entries. Instead, try logging every <em>n</em>th occurrence of a duplicate entry. </p>&#13;
<p>Conveniently, Zap has a logger that does just that. <a href="#listing13-11" id="listinganchor13-11">Listing 13-11</a> creates a logger that will constrain its CPU and I/O overhead by logging a subset of log entries.</p>&#13;
<pre><code><var>--snip--</var>&#13;
&#13;
func Example_zapSampling() {&#13;
    zl := zap.New(&#13;
     <span class="CodeAnnotation">1</span> zapcore.NewSamplerWithOptions(&#13;
<span epub:type="pagebreak" id="Page_308" title="308"/>            zapcore.NewCore(&#13;
                zapcore.NewJSONEncoder(encoderCfg),&#13;
                zapcore.Lock(os.Stdout),&#13;
                zapcore.DebugLevel,&#13;
            ),&#13;
          <span class="CodeAnnotation">2</span>time.Second, <span class="CodeAnnotation">3</span>1, <span class="CodeAnnotation">4</span>3,&#13;
        ),&#13;
    )&#13;
    defer func() { _ = zl.Sync() }()&#13;
&#13;
    for i := 0; i &lt; 10; i++ {&#13;
        if i == 5 {&#13;
         <span class="CodeAnnotation">5</span> time.Sleep(time.Second)&#13;
        }&#13;
     <span class="CodeAnnotation">6</span> zl.Debug(fmt.Sprintf("%d", i))&#13;
     <span class="CodeAnnotation">7</span> zl.Debug("debug message")&#13;
    }&#13;
&#13;
    // <span class="CodeAnnotation">8</span>Output:&#13;
    // {"level":"debug","msg":"0"}&#13;
    // {"level":"debug","msg":"debug message"}&#13;
    // {"level":"debug","msg":"1"}&#13;
    // {"level":"debug","msg":"2"}&#13;
    // {"level":"debug","msg":"3"}&#13;
    // {"level":"debug","msg":"debug message"}&#13;
    // {"level":"debug","msg":"4"}&#13;
    // {"level":"debug","msg":"5"}&#13;
    // {"level":"debug","msg":"debug message"}&#13;
    // {"level":"debug","msg":"6"}&#13;
    // {"level":"debug","msg":"7"}&#13;
    // {"level":"debug","msg":"8"}&#13;
    // {"level":"debug","msg":"debug message"}&#13;
    // {"level":"debug","msg":"9"}&#13;
}</code></pre>&#13;
<p class="CodeListingCaption"><a id="listing13-11">Listing 13-11</a>: Logging a subset of log entries to limit CPU and I/O overhead (<em>zap_test.go</em>)</p>&#13;
<p>The <code>NewSamplerWithOptions</code> function <span class="CodeAnnotation">1</span> wraps <code>zap.Core</code> with sampling functionality. It requires three additional arguments: a sampling interval <span class="CodeAnnotation">2</span>, the number of initial duplicate log entries to record <span class="CodeAnnotation">3</span>, and an integer <span class="CodeAnnotation">4</span> representing the <em>n</em>th duplicate log entry to record after that point. In this example, you are logging the first log entry, and then every third duplicate log entry that the logger receives in a one-second interval. Once the interval elapses, the logger starts over and logs the first entry, then every third duplicate for the remainder of the one-second interval.</p>&#13;
<p>Let’s look at this in action. You make 10 iterations around a loop. Each iteration logs both the counter <span class="CodeAnnotation">6</span> and a generic debug message <span class="CodeAnnotation">7</span>, which stays the same for each iteration. On the sixth iteration, the example sleeps for one second <span class="CodeAnnotation">5</span> to ensure that the sample logger starts logging anew during the next one-second interval.</p>&#13;
<p>Examining the output <span class="CodeAnnotation">8</span>, you see that the debug message prints during the first iteration and not again until the logger encounters the third duplicate debug message during the fourth loop iteration. But on the sixth <span epub:type="pagebreak" id="Page_309" title="309"/>iteration, the example sleeps, and the sample logger ticks over to the next one-second interval, starting the logging over. It logs the first debug message of the interval in the sixth loop iteration and the third duplicate debug message in the ninth iteration of the loop.</p>&#13;
<p>Granted, this is a contrived example, but one that illustrates how to use this log-sampling technique as a compromise in CPU- and I/O-sensitive portions of your code. One place this technique may be applicable is when sending work to worker goroutines. Although you may send work as fast as the workers can handle it, you might want periodic updates on each worker’s progress without having to incur too much logging overhead. The sample logger allows you to temper the log output and strike a balance between timely updates and minimal overhead.</p>&#13;
<h4 id="h3-500884c13-0007">Performing On-Demand Debug Logging</h4>&#13;
<p class="BodyFirst">If debug logging introduces an unacceptable burden on your application under normal operation, or if the sheer amount of debug log data overwhelms your available storage space, you might want the ability to enable debug logging on demand. One technique is to use a semaphore file to enable debug logging. A <em>semaphore file</em> is an empty file whose existence is meant as a signal to the logger to change its behavior. If the semaphore file is present, the logger outputs <code>debug</code>-level logs. Once you remove the semaphore file, the logger reverts to its previous log level.</p>&#13;
<p>Let’s use the <code>fsnotify</code> package to allow your application to watch for filesystem notifications. In addition to the standard library, the <code>fsnotify</code> package uses the <code>x/sys</code> package. Before you start writing code, let’s make sure our <code>x/sys</code> package is current:</p>&#13;
<pre><code>$ <b>go get -u golang.org/x/sys/...</b></code></pre>&#13;
<p>Not all logging packages provide safe methods to asynchronously modify log levels. Be aware that you may introduce a race condition if you attempt to modify a logger’s level at the same time that the logger is reading the log level. The Zap logger allows you to retrieve a <code>sync/atomic</code>-based leveler to dynamically modify a logger’s level while avoiding race conditions. You’ll pass the atomic leveler to the <code>zapcore.NewCore</code> function in place of a log level, as you’ve previously done.</p>&#13;
<p>The <code>zap.AtomicLevel</code> struct implements the <code>http.Handler</code> interface. You can integrate it into an API and dynamically change the log level over HTTP instead of using a semaphore.</p>&#13;
<p><a href="#listing13-12" id="listinganchor13-12">Listing 13-12</a> begins an example of dynamic logging using a semaphore file. You’ll implement this example over the next few listings.</p>&#13;
<pre><code><var>--snip--</var>&#13;
&#13;
func Example_zapDynamicDebugging() {&#13;
    tempDir, err := ioutil.TempDir("", "")&#13;
    if err != nil {&#13;
        log.Fatal(err)&#13;
    }&#13;
<span epub:type="pagebreak" id="Page_310" title="310"/>    defer func() { _ = os.RemoveAll(tempDir) }()&#13;
&#13;
    debugLevelFile := <span class="CodeAnnotation">1</span>filepath.Join(tempDir, "level.debug")&#13;
    atomicLevel := <span class="CodeAnnotation">2</span>zap.NewAtomicLevel()&#13;
&#13;
    zl := zap.New(&#13;
        zapcore.NewCore(&#13;
            zapcore.NewJSONEncoder(encoderCfg),&#13;
            zapcore.Lock(os.Stdout),&#13;
         <span class="CodeAnnotation">3</span> atomicLevel,&#13;
        ),&#13;
    )&#13;
    defer func() { _ = zl.Sync() }()</code></pre>&#13;
<p class="CodeListingCaption"><a id="listing13-12">Listing 13-12</a>: Creating a new logger using an atomic leveler (<em>zap_test.go</em>)</p>&#13;
<p>Your code will watch for the <em>level.debug</em> file <span class="CodeAnnotation">1</span> in the temporary directory. When the file is present, you’ll dynamically change the logger’s level to <code>debug</code>. To do that, you need a new atomic leveler <span class="CodeAnnotation">2</span>. By default, the atomic leveler uses the <code>info</code> level, which suits this example just fine. You pass in the atomic leveler <span class="CodeAnnotation">3</span> when creating the core as opposed to specifying a log level itself.</p>&#13;
<p>Now that you have an atomic leveler and a place to store your semaphore file, let’s write the code that will watch for semaphore file changes in <a href="#listing13-13" id="listinganchor13-13">Listing 13-13</a>.</p>&#13;
<pre><code><var>--snip--</var>&#13;
&#13;
    watcher, err := <span class="CodeAnnotation">1</span>fsnotify.NewWatcher()&#13;
    if err != nil {&#13;
        log.Fatal(err)&#13;
    }&#13;
    defer func() { _ = watcher.Close() }()&#13;
&#13;
    err = <span class="CodeAnnotation">2</span>watcher.Add(tempDir)&#13;
    if err != nil {&#13;
        log.Fatal(err)&#13;
    }&#13;
&#13;
    ready := make(chan struct{})&#13;
    go func() {&#13;
        defer close(ready)&#13;
&#13;
        originalLevel := <span class="CodeAnnotation">3</span>atomicLevel.Level()&#13;
&#13;
        for {&#13;
            select {&#13;
            case event, ok := <span class="CodeAnnotation">4</span>&lt;-watcher.Events:&#13;
                if !ok {&#13;
                    return&#13;
                }&#13;
                if event.Name == <span class="CodeAnnotation">5</span>debugLevelFile {&#13;
                    switch {&#13;
                    case event.Op&amp;fsnotify.Create == <span class="CodeAnnotation">6</span>fsnotify.Create:&#13;
                        atomicLevel.SetLevel(zapcore.DebugLevel)&#13;
<span epub:type="pagebreak" id="Page_311" title="311"/>                        ready &lt;- struct{}{}&#13;
                    case event.Op&amp;fsnotify.Remove == <span class="CodeAnnotation">7</span>fsnotify.Remove:&#13;
                        atomicLevel.SetLevel(originalLevel)&#13;
                        ready &lt;- struct{}{}&#13;
                    }&#13;
                }&#13;
            case err, ok := <span class="CodeAnnotation">8</span>&lt;-watcher.Errors:&#13;
                if !ok {&#13;
                    return&#13;
                }&#13;
                zl.Error(err.Error())&#13;
            }&#13;
        }&#13;
    }()</code></pre>&#13;
<p class="CodeListingCaption"><a id="listing13-13">Listing 13-13</a>: Watching for any changes to the semaphore file (<em>zap_test.go</em>)</p>&#13;
<p>First, you create a filesystem watcher <span class="CodeAnnotation">1</span>, which you’ll use to watch the temporary directory <span class="CodeAnnotation">2</span>. The watcher will notify you of any changes to or within that directory. You also want to capture the current log level <span class="CodeAnnotation">3</span> so that you can revert to it when you remove the semaphore file. </p>&#13;
<p>Next, you listen for events from the watcher <span class="CodeAnnotation">4</span>. Since you’re watching a directory, you filter out any event unrelated to the semaphore file <span class="CodeAnnotation">5</span> itself. Even then, you’re interested in only the creation of the semaphore file or its removal. If the event indicates the creation of the semaphore file <span class="CodeAnnotation">6</span>, you change the atomic leveler’s level to <code>debug</code>. If you receive a semaphore file removal event <span class="CodeAnnotation">7</span>, you set the atomic leveler’s level back to its original level.</p>&#13;
<p>If you receive an error from the watcher <span class="CodeAnnotation">8</span> at any point, you log it at the <code>error</code> level.</p>&#13;
<p>Let’s see how this works in practice. <a href="#listing13-14" id="listinganchor13-14">Listing 13-14</a> tests the logger with and without the semaphore file present.</p>&#13;
<pre><code><var>--snip--</var>&#13;
&#13;
 <span class="CodeAnnotation">1</span> zl.Debug("this is below the logger's threshold")&#13;
&#13;
    df, err := <span class="CodeAnnotation">2</span>os.Create(debugLevelFile)&#13;
    if err != nil {&#13;
        log.Fatal(err)&#13;
    }&#13;
    err = df.Close()&#13;
    if err != nil {&#13;
        log.Fatal(err)&#13;
    }&#13;
    &lt;-ready&#13;
&#13;
 <span class="CodeAnnotation">3</span> zl.Debug("this is now at the logger's threshold")&#13;
&#13;
    err = <span class="CodeAnnotation">4</span>os.Remove(debugLevelFile)&#13;
    if err != nil {&#13;
        log.Fatal(err)&#13;
    }&#13;
    &lt;-ready&#13;
&#13;
<span epub:type="pagebreak" id="Page_312" title="312"/> <span class="CodeAnnotation">5</span> zl.Debug("this is below the logger's threshold again")&#13;
 <span class="CodeAnnotation">6</span> zl.Info("this is at the logger's current threshold")&#13;
&#13;
    // Output:&#13;
    // {"level":"debug","msg":"this is now at the logger's threshold"}&#13;
    // {"level":"info","msg":"this is at the logger's current threshold"}&#13;
}</code></pre>&#13;
<p class="CodeListingCaption"><a id="listing13-14">Listing 13-14</a>: Testing the logger’s use of the semaphore file (<em>zap_test.go</em>)</p>&#13;
<p>The logger’s current log level via the atomic leveler is <code>info</code>. Therefore, the logger does not write the initial debug log entry <span class="CodeAnnotation">1</span> to standard output. But if you create the semaphore file <span class="CodeAnnotation">2</span>, the code in <a href="#listing13-13">Listing 13-13</a> should dynamically change the logger’s level to <code>debug</code>. If you add another debug log entry <span class="CodeAnnotation">3</span>, the logger should write it to standard output. You then remove the semaphore file <span class="CodeAnnotation">4</span> and write both a debug log entry <span class="CodeAnnotation">5</span> and an info log entry <span class="CodeAnnotation">6</span>. Since the semaphore file no longer exists, the logger should write only the info log entry to standard output.</p>&#13;
<h3 id="h2-500884c13-0004">Scaling Up with Wide Event Logging</h3>&#13;
<p class="BodyFirst"><em>Wide event logging</em> is a technique that creates a single, structured log entry per event to summarize the transaction, instead of logging numerous entries as the transaction progresses. This technique is most applicable to request-response loops, such as API calls, but it can be adapted to other use cases. When you summarize transactions in a structured log entry, you reduce the logging overhead while conserving the ability to index and search for transaction details.</p>&#13;
<p>One approach to wide event logging is to wrap an API handler in middleware. But first, since the <code>http.ResponseWriter</code> is a bit stingy with its output, you need to create your own response writer type (<a href="#listing13-15" id="listinganchor13-15">Listing 13-15</a>) to collect and log the response code and length.</p>&#13;
<pre><code>package ch13&#13;
&#13;
import (&#13;
    "io"&#13;
    "io/ioutil"&#13;
    "net"&#13;
    "net/http"&#13;
    "net/http/httptest"&#13;
    "os"&#13;
&#13;
    "go.uber.org/zap"&#13;
    "go.uber.org/zap/zapcore"&#13;
)&#13;
&#13;
type wideResponseWriter struct {&#13;
 <span class="CodeAnnotation">1</span> http.ResponseWriter&#13;
    length, status int&#13;
}&#13;
&#13;
<span epub:type="pagebreak" id="Page_313" title="313"/>func (w *wideResponseWriter) <span class="CodeAnnotation">2</span>WriteHeader(status int) {&#13;
    w.ResponseWriter.WriteHeader(status)&#13;
    w.status = status&#13;
}&#13;
&#13;
func (w *wideResponseWriter) <span class="CodeAnnotation">3</span>Write(b []byte) (int, error) {&#13;
    n, err := w.ResponseWriter.Write(b)&#13;
    w.length += n&#13;
&#13;
    if w.status == 0 {&#13;
        w.status = <span class="CodeAnnotation">4</span>http.StatusOK&#13;
    }&#13;
&#13;
    return n, err&#13;
}</code></pre>&#13;
<p class="CodeListingCaption"><a id="listing13-15">Listing 13-15</a>: Creating a <var>ResponseWriter</var> to capture the response status code and length (<em>wide_test.go</em>)</p>&#13;
<p>The new type embeds an object that implements the <code>http.ResponseWriter</code> interface <span class="CodeAnnotation">1</span>. In addition, you add <code>length</code> and <code>status</code> fields, since those values are ultimately what you want to log from the response. You override the <code>WriteHeader</code> method <span class="CodeAnnotation">2</span> to easily capture the status code. Likewise, you override the <code>Write</code> method <span class="CodeAnnotation">3</span> to keep an accurate accounting of the number of written bytes and optionally set the status code <span class="CodeAnnotation">4</span> should the caller execute <code>Write</code> before <code>WriteHeader</code>.</p>&#13;
<p><a href="#listing13-16" id="listinganchor13-16">Listing 13-16</a> uses your new type in wide event logging middleware.</p>&#13;
<pre><code><var>--snip--</var>&#13;
&#13;
func WideEventLog(logger *zap.Logger, next http.Handler) http.Handler {&#13;
    return http.HandlerFunc(&#13;
        func(w http.ResponseWriter, r *http.Request) {&#13;
            wideWriter := <span class="CodeAnnotation">1</span>&amp;wideResponseWriter{ResponseWriter: w}&#13;
&#13;
         <span class="CodeAnnotation">2</span> next.ServeHTTP(wideWriter, r)&#13;
&#13;
            addr, _, _ := net.SplitHostPort(r.RemoteAddr)&#13;
         <span class="CodeAnnotation">3</span> logger.Info("example wide event",&#13;
                zap.Int("status_code", wideWriter.status),&#13;
                zap.Int("response_length", wideWriter.length),&#13;
                zap.Int64("content_length", r.ContentLength),&#13;
                zap.String("method", r.Method),&#13;
                zap.String("proto", r.Proto),&#13;
                zap.String("remote_addr", addr),&#13;
                zap.String("uri", r.RequestURI),&#13;
                zap.String("user_agent", r.UserAgent()),&#13;
            )&#13;
        },&#13;
    )&#13;
}</code></pre>&#13;
<p class="CodeListingCaption"><a id="listing13-16">Listing 13-16</a>: Implementing wide event logging middleware (<em>wide_test.go</em>)</p>&#13;
<p><span epub:type="pagebreak" id="Page_314" title="314"/>The wide event logging middleware accepts both a <code>*zap.Logger</code> and an <code>http.Handler</code> and returns an <code>http.Handler</code>. If this pattern is unfamiliar to you, please read “Handlers” <span class="xref" itemid="xref_target_on page 193">on page 193</span>. </p>&#13;
<p>First, you embed the <code>http.ResponseWriter</code> in a new instance of your wide event logging–aware response writer <span class="CodeAnnotation">1</span>. Then, you call the <code>ServeHTTP</code> method of the next <code>http.Handler</code><span class="CodeAnnotation">2</span>, passing in your response writer. Finally, you make a single log entry <span class="CodeAnnotation">3</span> with various bits of data about the request and response.</p>&#13;
<p>Keep in mind that I’m taking care here to omit values that would change with each execution and break the example output, like call duration. You would likely have to write code to deal with these in a real implementation. </p>&#13;
<p><a href="#listing13-17" id="listinganchor13-17">Listing 13-17</a> puts the middleware into action and demonstrates the expected output.</p>&#13;
<pre><code><var>--snip--</var>&#13;
&#13;
func Example_wideLogEntry() {&#13;
    zl := zap.New(&#13;
        zapcore.NewCore(&#13;
            zapcore.NewJSONEncoder(encoderCfg),&#13;
            zapcore.Lock(os.Stdout),&#13;
            zapcore.DebugLevel,&#13;
        ),&#13;
    )&#13;
    defer func() { _ = zl.Sync() }()&#13;
&#13;
    ts := httptest.NewServer(&#13;
     <span class="CodeAnnotation">1</span> WideEventLog(zl, http.HandlerFunc(&#13;
            func(w http.ResponseWriter, r *http.Request) {&#13;
                defer func(r io.ReadCloser) {&#13;
                    _, _ = io.Copy(ioutil.Discard, r)&#13;
                    _ = r.Close()&#13;
                }(r.Body)&#13;
                _, _ = <span class="CodeAnnotation">2</span>w.Write([]byte("Hello!"))&#13;
            },&#13;
        )),&#13;
    )&#13;
    defer ts.Close()&#13;
&#13;
    resp, err := <span class="CodeAnnotation">3</span>http.Get(ts.URL + "/test")&#13;
    if err != nil {&#13;
     <span class="CodeAnnotation">4</span> zl.Fatal(err.Error())&#13;
    }&#13;
    _ = resp.Body.Close()&#13;
&#13;
    // <span class="CodeAnnotation">5</span>Output:&#13;
    // {"level":"info","msg":"example wide event","status_code":200,&#13;
"response_length":6,"content_length":0,"method":"GET","proto":"HTTP/1.1",&#13;
"remote_addr":"127.0.0.1","uri":"/test","user_agent":"Go-http-client/1.1"}&#13;
}</code></pre>&#13;
<p class="CodeListingCaption"><a id="listing13-17">Listing 13-17</a>: Using the wide event logging middleware to log the details of a GET call (<em>wide_test.go</em>)</p>&#13;
<p><span epub:type="pagebreak" id="Page_315" title="315"/>As in Chapter 9, you use the <code>httptest</code> server with your <code>WideEventLog</code> middleware <span class="CodeAnnotation">1</span>. You pass <code>*zap.Logger</code> into the middleware as the first argument and <code>http.Handler</code> as the second argument. The handler writes a simple <em>Hello!</em> to the response <span class="CodeAnnotation">2</span> so the response length is nonzero. That way, you can prove that your response writer works. The logger writes the log entry immediately before you receive the response to your GET request <span class="CodeAnnotation">3</span>. As before, I must wrap the JSON output <span class="CodeAnnotation">5</span> for printing in this book, but it consumes a single line otherwise.</p>&#13;
<p>Since this is just an example, I elected to use the logger’s <code>Fatal</code> method <span class="CodeAnnotation">4</span>, which writes the error message to the log file and calls <code>os.Exit(1)</code> to terminate the application. You shouldn’t use this in code that is supposed to keep running in the event of an error.</p>&#13;
<h3 id="h2-500884c13-0005">Log Rotation with Lumberjack</h3>&#13;
<p class="BodyFirst">If you elect to output log entries to a file, you could leverage an application like <em>logrotate</em> to keep them from consuming all available hard drive space. The downside to using a third-party application to manage log files is that the third-party application will need to signal to your application to reopen its log file handle lest your application keep writing to the rotated log file.</p>&#13;
<p>A less invasive and more reliable option is to add log file management directly to your logger by using a library like <em>Lumberjack</em>. Lumberjack handles log rotation in a way that is transparent to the logger, because your logger treats Lumberjack as any other <code>io.Writer</code>. Meanwhile, Lumberjack keeps track of the log entry accounting and file rotation for you.</p>&#13;
<p><a href="#listing13-18" id="listinganchor13-18">Listing 13-18</a> adds log rotation to a typical Zap logger implementation.</p>&#13;
<pre><code><var>--snip--</var>&#13;
&#13;
func TestZapLogRotation(t *testing.T) {&#13;
    tempDir, err := ioutil.TempDir("", "")&#13;
    if err != nil {&#13;
        t.Fatal(err)&#13;
    }&#13;
    defer func() { _ = os.RemoveAll(tempDir) }()&#13;
&#13;
    zl := zap.New(&#13;
        zapcore.NewCore(&#13;
            zapcore.NewJSONEncoder(encoderCfg),&#13;
         <span class="CodeAnnotation">1</span> zapcore.AddSync(&#13;
             <span class="CodeAnnotation">2</span> &amp;lumberjack.Logger{&#13;
                    Filename:   <span class="CodeAnnotation">3</span>filepath.Join(tempDir, "debug.log"),&#13;
                    Compress:   <span class="CodeAnnotation">4</span>true,&#13;
                    LocalTime:  <span class="CodeAnnotation">5</span>true,&#13;
                    MaxAge:     <span class="CodeAnnotation">6</span>7,&#13;
                    MaxBackups: <span class="CodeAnnotation">7</span>5,&#13;
                    MaxSize:    <span class="CodeAnnotation">8</span>100,&#13;
                },&#13;
            ),&#13;
            zapcore.DebugLevel,&#13;
        ),&#13;
    )&#13;
<span epub:type="pagebreak" id="Page_316" title="316"/>    defer func() { _ = zl.Sync() }()&#13;
&#13;
    zl.Debug("debug message written to the log file")&#13;
}</code></pre>&#13;
<p class="CodeListingCaption"><a id="listing13-18">Listing 13-18</a>: Adding log rotation to the Zap logger using Lumberjack (<em>zap_test.go</em>)</p>&#13;
<p>Like the <code>*bytes.Buffer</code> in <a href="#listing13-9">Listing 13-9</a>, <code>*lumberjack.Logger</code><span class="CodeAnnotation">2</span> does not implement the <code>zapcore.WriteSyncer</code>. It, too, lacks a <code>Sync</code> method. Therefore, you need to wrap it in a call to <code>zapcore.AddSync</code><span class="CodeAnnotation">1</span>. </p>&#13;
<p>Lumberjack includes several fields to configure its behavior, though its defaults are sensible. It uses a log filename in the format <em>&lt;processname&gt;-lumberjack.log</em>, saved in the temporary directory, unless you explicitly give it a log filename <span class="CodeAnnotation">3</span>. You can also elect to save hard drive space and have Lumberjack compress <span class="CodeAnnotation">4</span> rotated log files. Each rotated log file is timestamped using UTC by default, but you can instruct Lumberjack to use local time <span class="CodeAnnotation">5</span> instead. Finally, you can configure the maximum log file age before it should be rotated <span class="CodeAnnotation">6</span>, the maximum number of rotated log files to keep <span class="CodeAnnotation">7</span>, and the maximum size in megabytes <span class="CodeAnnotation">8</span> of a log file before it should be rotated.</p>&#13;
<p>You can continue using the logger as if it were writing directly to standard output or <code>*os.File</code>. The difference is that Lumberjack will intelligently handle the log file management for you.</p>&#13;
<h2 id="h1-500884c13-0002">Instrumenting Your Code</h2>&#13;
<p class="BodyFirst"><em>Instrumenting</em> your code is the process of collecting metrics for the purpose of making inferences about the current state of your service—such as the duration of each request-response loop, the size of each response, the number of connected clients, the latency between your service and a third-party API, and so on. Whereas logs provide a record of how your service got into a certain state, metrics give you insight into that state itself.</p>&#13;
<p>Instrumentation is easy, so much so that I’m going to give you the opposite advice I did for logging: instrument everything (initially). Fine-grained instrumentation involves hardly any overhead, it’s efficient to ship, and it’s inexpensive to store. Plus, instrumentation can solve one of the challenges of logging I mentioned earlier: that you won’t initially know all the questions you’ll want to ask, particularly for complex systems. An insidious problem may be ready to ruin your weekend because you lack critical metrics to give you an early warning that something is wrong.</p>&#13;
<p>This section will introduce you to metric types and show you the basics for using those types in your services. You will learn about Go kit’s <code>metrics</code> package, which is an abstraction layer that provides useful interfaces for popular metrics platforms. You’ll round out the instrumentation by using Prometheus as your target metrics platform and set up an endpoint for Prometheus to scrape. If you elect to use a different platform <span epub:type="pagebreak" id="Page_317" title="317"/>in the future, you will need to swap out only the Prometheus bits of this code; you could leave the Go kit code as is. If you’re just getting started with instrumentation, one option is to use Grafana Cloud at <a href="https://grafana.com/products/cloud/">https://grafana.com/products/cloud/</a> to scrape and visualize your metrics. Its free tier is adequate for experimenting with instrumentation.</p>&#13;
<h3 id="h2-500884c13-0006">Setup</h3>&#13;
<p class="BodyFirst">To abstract the implementation of your metrics and the packages they depend on, let’s begin by putting them in their own package (<a href="#listing13-19" id="listinganchor13-19">Listing 13-19</a>).</p>&#13;
<pre><code>package metrics&#13;
&#13;
import (&#13;
    "flag"&#13;
&#13;
 <span class="CodeAnnotation">1</span> "github.com/go-kit/kit/metrics"&#13;
 <span class="CodeAnnotation">2</span> "github.com/go-kit/kit/metrics/prometheus"&#13;
 <span class="CodeAnnotation">3</span> prom "github.com/prometheus/client_golang/prometheus"&#13;
)&#13;
&#13;
var (&#13;
    Namespace = <span class="CodeAnnotation">4</span>flag.String("namespace", "web", "metrics namespace")&#13;
    Subsystem = <span class="CodeAnnotation">5</span>flag.String("subsystem", "server1", "metrics subsystem")</code></pre>&#13;
<p class="CodeListingCaption"><a id="listing13-19">Listing 13-19</a>: Imports and command line flags for the metrics example (<em>instrumentation/metrics/metrics.go</em>)</p>&#13;
<p>You import Go kit’s <code>metrics</code> package <span class="CodeAnnotation">1</span>, which provides the interfaces your code will use, its <code>prometheus</code> adapter <span class="CodeAnnotation">2</span> so you can use Prometheus as your metrics platform, and Go’s Prometheus client package <span class="CodeAnnotation">3</span> itself. All Prometheus-related imports reside in this package. The rest of your code will use Go kit’s interfaces. This allows you to swap out the underlying metrics platform without the need to change your code’s instrumentation.</p>&#13;
<p>Prometheus prefixes its metrics with a namespace and a subsystem. You could use the service name for the namespace and the node or hostname for the subsystem, for example. In this example, you’ll use <code>web</code> for the namespace <span class="CodeAnnotation">4</span> and <code>server1</code> for the subsystem <span class="CodeAnnotation">5</span> by default. As a result, your metrics will use the <code>web_server1_</code> prefix. You’ll see this prefix in <a href="#listing13-30" id="listinganchor13-30">Listing 13-30</a>’s command line output.</p>&#13;
<p>Now let’s explore the various metric types, starting with counters.</p>&#13;
<h3 id="h2-500884c13-0007">Counters</h3>&#13;
<p class="BodyFirst"><em>Counters</em> are used for tracking values that only increase, such as request counts, error counts, or completed task counts. You can use a counter to calculate the rate of increase for a given interval, such as the number of connections per minute.</p>&#13;
<p><a href="#listing13-20" id="listinganchor13-20">Listing 13-20</a> defines two counters: one to track the number of requests and another to account for the number of write errors.</p>&#13;
<span epub:type="pagebreak" id="Page_318" title="318"/><pre><code><var>--snip--</var>&#13;
&#13;
    Requests <span class="CodeAnnotation">1</span>metrics.Counter = <span class="CodeAnnotation">2</span>prometheus.NewCounterFrom(&#13;
     <span class="CodeAnnotation">3</span> prom.CounterOpts{&#13;
            Namespace: *Namespace,&#13;
            Subsystem: *Subsystem,&#13;
            Name:    <span class="CodeAnnotation">4</span>"request_count",&#13;
            Help:    <span class="CodeAnnotation">5</span>"Total requests",&#13;
        },&#13;
        []string{},&#13;
    )&#13;
&#13;
    WriteErrors metrics.Counter = prometheus.NewCounterFrom(&#13;
        prom.CounterOpts{&#13;
            Namespace: *Namespace,&#13;
            Subsystem: *Subsystem,&#13;
            Name:      "write_errors_count",&#13;
            Help:      "Total write errors",&#13;
        },&#13;
        []string{},&#13;
    )</code></pre>&#13;
<p class="CodeListingCaption"><a id="listing13-20">Listing 13-20</a>: Creating counters as Go kit interfaces (<em>instrumentation/metrics/metrics.go</em>)</p>&#13;
<p>Each counter implements Go kit’s <code>metrics.Counter</code> interface <span class="CodeAnnotation">1</span>. The concrete type for each counter comes from Go kit’s <code>prometheus</code> adapter <span class="CodeAnnotation">2</span> and relies on a <code>CounterOpts</code> struct <span class="CodeAnnotation">3</span> from the Prometheus client package for configuration. Aside from the namespace and subsystem values we covered, the other important values you set are the metric name <span class="CodeAnnotation">4</span> and its help string <span class="CodeAnnotation">5</span>, which describes the metric.</p>&#13;
<h3 id="h2-500884c13-0008">Gauges</h3>&#13;
<p class="BodyFirst"><em>Gauges</em> allow you to track values that increase or decrease, such as the current memory usage, in-flight requests, queue sizes, fan speed, or the number of ThinkPads on my desk. Gauges do not support rate calculations, such as the number of connections per minute or megabits transferred per second, while counters do.</p>&#13;
<p><a href="#listing13-21" id="listinganchor13-21">Listing 13-21</a> creates a gauge to track open connections.</p>&#13;
<pre><code><var>--snip--</var>&#13;
&#13;
    OpenConnections <span class="CodeAnnotation">1</span>metrics.Gauge = <span class="CodeAnnotation">2</span>prometheus.NewGaugeFrom(&#13;
     <span class="CodeAnnotation">3</span> prom.GaugeOpts{&#13;
            Namespace: *Namespace,&#13;
            Subsystem: *Subsystem,&#13;
            Name:      "open_connections",&#13;
            Help:      "Current open connections",&#13;
        },&#13;
        []string{},&#13;
    )</code></pre>&#13;
<p class="CodeListingCaption"><a id="listing13-21">Listing 13-21</a>: Creating a gauge as a Go kit interface (<em>instrumentation/metrics/metrics.go</em>)</p>&#13;
<p><span epub:type="pagebreak" id="Page_319" title="319"/>Creating a gauge is much like creating a counter. You create a new variable of Go kit’s <code>metrics.Gauge</code> interface <span class="CodeAnnotation">1</span> and use the <code>NewGaugeFrom</code> function <span class="CodeAnnotation">2</span> from Go kit’s <code>prometheus</code> adapter to create the underlying type. The Prometheus client’s <code>GaugeOpts</code> struct <span class="CodeAnnotation">3</span> provides the settings for your new gauge.</p>&#13;
<h3 id="h2-500884c13-0009">Histograms and Summaries</h3>&#13;
<p class="BodyFirst">A <em>histogram</em> places values into predefined buckets. Each bucket is associated with a range of values and named after its maximum one. When a value is observed, the histogram increments the maximum value of the smallest bucket into which the value fits. In this way, a histogram tracks the frequency of observed values for each bucket. </p>&#13;
<p>Let’s look at a quick example. Assuming you have three buckets valued at 0.5, 1.0, and 1.5, if a histogram observes the value 0.42, it will increment the counter associated with bucket 0.5, because 0.5 is the smallest bucket that can contain 0.42. It covers the range of 0.5 and smaller values. If the histogram observes the value 1.23, it will increment the counter associated with the bucket 1.5, which covers values in the range of above 1.0 through 1.5. Naturally, the 1.0 bucket covers the range of above 0.5 through 1.0.</p>&#13;
<p>You can use a histogram’s distribution of observed values to estimate a percentage or an average of all values. For example, you could use a histogram to calculate the average request sizes or response sizes observed by your service.</p>&#13;
<p>A <em>summary</em> is a histogram with a few differences. First, a histogram requires predefined buckets, whereas a summary calculates its own buckets. Second, the metrics server calculates averages or percentages from histograms, whereas your service calculates the averages or percentages from summaries. As a result, you can aggregate histograms across services on the metrics server, but you cannot do the same for summaries. </p>&#13;
<p>The general advice is to use summaries when you don’t know the range of expected values, but I’d advise you to use histograms whenever possible so that you can aggregate histograms on the metrics server. Let’s use a histogram to observe request duration (see <a href="#listing13-22" id="listinganchor13-22">Listing 13-22</a>).</p>&#13;
<pre><code><var>--snip--</var>&#13;
&#13;
    RequestDuration <span class="CodeAnnotation">1</span>metrics.Histogram = <span class="CodeAnnotation">2</span>prometheus.NewHistogramFrom(&#13;
     <span class="CodeAnnotation">3</span> prom.HistogramOpts{&#13;
            Namespace: *Namespace,&#13;
            Subsystem: *Subsystem,&#13;
            Buckets: <span class="CodeAnnotation">4</span>[]float64{&#13;
                0.0000001, 0.0000002, 0.0000003, 0.0000004, 0.0000005,&#13;
                0.000001, 0.0000025, 0.000005, 0.0000075, 0.00001,&#13;
                0.0001, 0.001, 0.01,&#13;
            },&#13;
            Name: "request_duration_histogram_seconds",&#13;
            Help: "Total duration of all requests",&#13;
        },&#13;
        []string{},&#13;
    )&#13;
)</code></pre>&#13;
<p class="CodeListingCaption"><a id="listing13-22">Listing 13-22</a>: Creating a histogram metric (<em>instrumentation/metrics/metrics.go</em>)</p>&#13;
<p><span epub:type="pagebreak" id="Page_320" title="320"/>Both the summary and histogram metric types implement Go kit’s <code>metrics.Histogram</code> interface <span class="CodeAnnotation">1</span> from its <code>prometheus</code> adapter. Here, you’re using a histogram metric type <span class="CodeAnnotation">2</span>, using the Prometheus client’s <code>HistogramOpts</code> struct <span class="CodeAnnotation">3</span> for configuration. Since Prometheus’s default bucket sizes are too large for the expected request duration range when communicating over localhost, you define custom bucket sizes <span class="CodeAnnotation">4</span>. I encourage you to experiment with the number of buckets and bucket sizes.</p>&#13;
<p>If you’d rather implement <code>RequestDuration</code> as a summary metric, you can substitute the code in <a href="#listing13-22">Listing 13-22</a> for the code in <a href="#listing13-23" id="listinganchor13-23">Listing 13-23</a>.</p>&#13;
<pre><code><var>--snip--</var>&#13;
&#13;
    RequestDuration <span class="CodeAnnotation">1</span>metrics.Histogram = prometheus.NewSummaryFrom(&#13;
        prom.SummaryOpts{&#13;
            Namespace: *Namespace,&#13;
            Subsystem: *Subsystem,&#13;
            Name: "request_duration_summary_seconds",&#13;
            Help: "Total duration of all requests",&#13;
        },&#13;
        []string{},&#13;
    )&#13;
)</code></pre>&#13;
<p class="CodeListingCaption"><a id="listing13-23">Listing 13-23</a>: Optionally creating a summary metric</p>&#13;
<p>As you can see, this looks a lot like a histogram, minus the <code>Bucket</code> method. Notice that you still use the <code>metrics.Histogram</code> interface <span class="CodeAnnotation">1</span> with a Prometheus summary metric. This is because Go kit does not distinguish between histograms and summaries; only your implementation of the interface does.</p>&#13;
<h2 id="h1-500884c13-0003">Instrumenting a Basic HTTP Server</h2>&#13;
<p class="BodyFirst">Let’s combine these metric types in a practical example: instrumenting a Go HTTP server. The biggest challenges here are determining what you want to instrument, where best to instrument it, and what metric type is most appropriate for each value you want to track. If you use Prometheus for your metrics platform, as you’ll do here, you’ll also need to add an HTTP endpoint for the Prometheus server to scrape.</p>&#13;
<p><a href="#listing13-24" id="listinganchor13-24">Listing 13-24</a> details the initial code needed for an application that comprises an HTTP server to serve the metrics endpoint and another HTTP server to pass all requests to an instrumented handler.</p>&#13;
<pre><code>package main&#13;
&#13;
import (&#13;
    "bytes"&#13;
    "flag"&#13;
    "fmt"&#13;
<span epub:type="pagebreak" id="Page_321" title="321"/>    "io"&#13;
    "io/ioutil"&#13;
    "log"&#13;
    "math/rand"&#13;
    "net"&#13;
    "net/http"&#13;
    "sync"&#13;
    "time"&#13;
&#13;
 <span class="CodeAnnotation">1</span> "github.com/prometheus/client_golang/prometheus/promhttp"&#13;
&#13;
 <span class="CodeAnnotation">2</span> "github.com/awoodbeck/gnp/ch13/instrumentation/metrics"&#13;
)&#13;
&#13;
var (&#13;
    metricsAddr = <span class="CodeAnnotation">3</span>flag.String("metrics", "127.0.0.1:8081",&#13;
        "metrics listen address")&#13;
    webAddr = <span class="CodeAnnotation">4</span>flag.String("web", "127.0.0.1:8082", "web listen address")&#13;
)</code></pre>&#13;
<p class="CodeListingCaption"><a id="listing13-24">Listing 13-24</a>: Imports and command line flags for the metrics example (<em>instrumentation/main.go</em>)</p>&#13;
<p>The only imports your code needs are the <code>promhttp</code> package for the metrics endpoint and your <code>metrics</code> package to instrument your code. The <code>promhttp</code> package <span class="CodeAnnotation">1</span> includes an <code>http.Handler</code> that a Prometheus server can use to scrape metrics from your application. This handler serves not only your metrics but also metrics related to the runtime, such as the Go version, number of cores, and so on. At a minimum, you can use the metrics provided by the Prometheus handler to gain insight into your service’s memory utilization, open file descriptors, heap and stack details, and more.</p>&#13;
<p>All variables exported by your <code>metrics</code> package <span class="CodeAnnotation">2</span> are Go kit interfaces. Your code doesn’t need to concern itself with the underlying metrics platform or its implementation, only how these metrics are made available to the metrics server. In a real-world application, you could further abstract the Prometheus handler to fully remove any dependency other than your metrics package from the rest of your code. But in the interest of keeping this example succinct, I’ve included the Prometheus handler in the <code>main</code> package.</p>&#13;
<p>Now, onto the code you want to instrument. <a href="#listing13-25" id="listinganchor13-25">Listing 13-25</a> adds the function your web server will use to handle all incoming requests.</p>&#13;
<pre><code><var>--snip--</var>&#13;
&#13;
func helloHandler(w http.ResponseWriter, _ *http.Request) {&#13;
 <span class="CodeAnnotation">1</span> metrics.Requests.Add(1)&#13;
    defer func(start time.Time) {&#13;
     <span class="CodeAnnotation">2</span> metrics.RequestDuration.Observe(time.Since(start).Seconds())&#13;
    }(time.Now())&#13;
&#13;
<span epub:type="pagebreak" id="Page_322" title="322"/>    _, err := w.Write([]byte("Hello!"))&#13;
    if err != nil {&#13;
     <span class="CodeAnnotation">3</span> metrics.WriteErrors.Add(1)&#13;
    }&#13;
}</code></pre>&#13;
<p class="CodeListingCaption"><a id="listing13-25">Listing 13-25</a>: An instrumented handler that responds with random latency (<em>instrumentation/main.go</em>)</p>&#13;
<p>Even in such a simple handler, you’re able to make three meaningful measurements. You increment the requests counter upon entering the handler <span class="CodeAnnotation">1</span> since it’s the most logical place to account for it. You also immediately defer a function that calculates the request duration and uses the request duration summary metric to observe it <span class="CodeAnnotation">2</span>. Lastly, you account for any errors writing the response <span class="CodeAnnotation">3</span>. </p>&#13;
<p>Now, you need to put the handler to use. But first, you need a helper function that will allow you to spin up a couple of HTTP servers: one to serve the metrics endpoint and one to serve this handler. <a href="#listing13-26" id="listinganchor13-26">Listing 13-26</a> details such a function.</p>&#13;
<pre><code><var>--snip--</var>&#13;
&#13;
func newHTTPServer(addr string, mux http.Handler,&#13;
    stateFunc <span class="CodeAnnotation">1</span>func(net.Conn, http.ConnState)) error {&#13;
    l, err := net.Listen("tcp", addr)&#13;
    if err != nil {&#13;
        return err&#13;
    }&#13;
&#13;
    srv := &amp;http.Server{&#13;
        Addr:              addr,&#13;
        Handler:           mux,&#13;
        IdleTimeout:       time.Minute,&#13;
        ReadHeaderTimeout: 30 * time.Second,&#13;
        ConnState:         stateFunc,&#13;
    }&#13;
&#13;
    go func() { log.Fatal(srv.Serve(l)) }()&#13;
&#13;
    return nil&#13;
}&#13;
&#13;
func <span class="CodeAnnotation">2</span>connStateMetrics(_ net.Conn, state http.ConnState) {&#13;
    switch state {&#13;
    case http.StateNew:&#13;
     <span class="CodeAnnotation">3</span> metrics.OpenConnections.Add(1)&#13;
    case http.StateClosed:&#13;
     <span class="CodeAnnotation">4</span> metrics.OpenConnections.Add(-1)&#13;
    }&#13;
}</code></pre>&#13;
<p class="CodeListingCaption"><a id="listing13-26">Listing 13-26</a>: Functions to create an HTTP server and instrument connection states (<em>instrumentation/main.go</em>)</p>&#13;
<p><span epub:type="pagebreak" id="Page_323" title="323"/>This HTTP server code resembles that of Chapter 9. The exception here is you’re defining the server’s <code>ConnState</code> field, accepting it as an argument <span class="CodeAnnotation">1</span> to the <code>newHTTPServer</code> function.</p>&#13;
<p>The HTTP server calls its <code>ConnState</code> field anytime a network connection changes. You can leverage this functionality to instrument the number of open connections the server has at any one time. You can pass the <code>connStateMetrics</code> function <span class="CodeAnnotation">2</span> to the <code>newHTTPServer</code> function anytime you want to initialize a new HTTP server and track its open connections. If the server establishes a new connection, you increment the open connections gauge <span class="CodeAnnotation">3</span> by 1. If a connection closes, you decrement the gauge <span class="CodeAnnotation">4</span> by 1. Go kit’s gauge interface provides an <code>Add</code> method, so decrementing a value involves adding a negative number.</p>&#13;
<p>Let’s create an example that puts all these pieces together. <a href="#listing13-27" id="listinganchor13-27">Listing 13-27</a> creates an HTTP server to serve up the Prometheus endpoint and another HTTP server to serve your instrumented handler.</p>&#13;
<pre><code><var>--snip--</var>&#13;
&#13;
func main() {&#13;
    flag.Parse()&#13;
    rand.Seed(time.Now().UnixNano())&#13;
&#13;
    mux := http.NewServeMux()&#13;
 <span class="CodeAnnotation">1</span> mux.Handle("/metrics/", promhttp.Handler())&#13;
    if err := newHTTPServer(*metricsAddr, mux, <span class="CodeAnnotation">2</span>nil); err != nil {&#13;
        log.Fatal(err)&#13;
    }&#13;
    fmt.Printf("Metrics listening on %q ...\n", *metricsAddr)&#13;
&#13;
    if err := newHTTPServer(*webAddr, <span class="CodeAnnotation">3</span>http.HandlerFunc(helloHandler),&#13;
      <span class="CodeAnnotation">4</span>connStateMetrics); err != nil {&#13;
        log.Fatal(err)&#13;
    }&#13;
    fmt.Printf("Web listening on %q ...\n\n", *webAddr)</code></pre>&#13;
<p class="CodeListingCaption"><a id="listing13-27">Listing 13-27</a>: Starting two HTTP servers to serve <var>metrics</var> and the <var>helloHandler</var> (<em>instrumentation/main.go</em>)</p>&#13;
<p>First, you spawn an HTTP server with the sole purpose of serving the Prometheus handler <span class="CodeAnnotation">1</span> at the <code>/metrics/</code> endpoint where Prometheus scrapes metrics from by default. Since you do not pass in a function for the third argument <span class="CodeAnnotation">2</span>, this HTTP server won’t have a function assigned to its <code>ConnState</code> field to call on each connection state change. Then, you spin up another HTTP server to handle each request with the <code>helloHandler</code><span class="CodeAnnotation">3</span>. But this time, you pass in the <code>connStateMetrics</code> function <span class="CodeAnnotation">4</span>. As a result, this HTTP server will gauge open connections.</p>&#13;
<p>Now, you can spin up many HTTP clients to make a bunch of requests to affect your metrics (see <a href="#listing13-28" id="listinganchor13-28">Listing 13-28</a>).</p>&#13;
<span epub:type="pagebreak" id="Page_324" title="324"/><pre><code><var>--snip--</var>&#13;
&#13;
    clients := <span class="CodeAnnotation">1</span>500&#13;
    gets := <span class="CodeAnnotation">2</span>100&#13;
    wg := new(sync.WaitGroup)&#13;
&#13;
    fmt.Printf("Spawning %d connections to make %d requests each ...",&#13;
        clients, gets)&#13;
    for i := 0; i &lt; clients; i++ {&#13;
        wg.Add(1)&#13;
        go func() {&#13;
            defer wg.Done()&#13;
&#13;
            c := &amp;http.Client{&#13;
                Transport: <span class="CodeAnnotation">3</span>http.DefaultTransport.(*http.Transport).Clone(),&#13;
            }&#13;
&#13;
            for j := 0; j &lt; gets; j++ {&#13;
                resp, err := <span class="CodeAnnotation">4</span>c.Get(fmt.Sprintf("http://%s/", *webAddr))&#13;
                if err != nil {&#13;
                    log.Fatal(err)&#13;
                }&#13;
                _, _ = <span class="CodeAnnotation">5</span>io.Copy(ioutil.Discard, resp.Body)&#13;
                _ = <span class="CodeAnnotation">6</span>resp.Body.Close()&#13;
            }&#13;
        }()&#13;
    }&#13;
 <span class="CodeAnnotation">7</span> wg.Wait()&#13;
    fmt.Print(" done.\n\n")</code></pre>&#13;
<p class="CodeListingCaption"><a id="listing13-28">Listing 13-28</a>: Instructing 500 HTTP clients to each make 100 GET calls (<em>instrumentation/main.go</em>)</p>&#13;
<p>You start by spawning 500 HTTP clients <span class="CodeAnnotation">1</span> to each make 100 GET calls <span class="CodeAnnotation">2</span>. But first, you need to address a problem. The <code>http.Client</code> uses the <code>http.DefaultTransport</code> if its <code>Transport</code> method is nil. The <code>http.DefaultTransport</code> does an outstanding job of caching TCP connections. If all 500 HTTP clients use the same transport, they’ll all make calls over about two TCP sockets. Our open connections gauge would reflect the two idle connections when you’re done with this example, which isn’t really the goal. </p>&#13;
<p>Instead, you must make sure to give each HTTP client its own transport. Cloning the default transport <span class="CodeAnnotation">3</span> is good enough for our purposes.</p>&#13;
<p>Now that each client has its own transport and you’re assured each client will make its own TCP connection, you iterate through a GET call <span class="CodeAnnotation">4</span> 100 times with each client. You must also be diligent about draining <span class="CodeAnnotation">5</span> and closing <span class="CodeAnnotation">6</span> the response body so each client can reuse its TCP connection.</p>&#13;
<p>Once all 500 HTTP clients complete their 100 calls <span class="CodeAnnotation">7</span>, you can move on to <a href="#listing13-29" id="listinganchor13-29">Listing 13-29</a> and check the current state of the metrics.</p>&#13;
<span epub:type="pagebreak" id="Page_325" title="325"/><pre><code><var>--snip--</var>&#13;
&#13;
    resp, err := <span class="CodeAnnotation">1</span>http.Get(fmt.Sprintf("http://%s/metrics", *metricsAddr))&#13;
    if err != nil {&#13;
        log.Fatal(err)&#13;
    }&#13;
&#13;
    b, err := ioutil.ReadAll(resp.Body)&#13;
    if err != nil {&#13;
        log.Fatal(err)&#13;
    }&#13;
    _ = resp.Body.Close()&#13;
&#13;
    metricsPrefix := <span class="CodeAnnotation">2</span>fmt.Sprintf("%s_%s", *metrics.Namespace,&#13;
        *metrics.Subsystem)&#13;
    fmt.Println("Current Metrics:")&#13;
    for _, line := range bytes.Split(b, []byte("\n")) {&#13;
        if <span class="CodeAnnotation">3</span>bytes.HasPrefix(line, []byte(metricsPrefix)) {&#13;
            fmt.Printf("%s\n", line)&#13;
        }&#13;
    }&#13;
}</code></pre>&#13;
<p class="CodeListingCaption"><a id="listing13-29">Listing 13-29</a>: Displaying the current metrics matching your namespace and subsystem (<em>instrumentation/main.go</em>)</p>&#13;
<p>You retrieve all the metrics from the metrics endpoint <span class="CodeAnnotation">1</span>. This will cause the metrics web server to return all metrics stored by the Prometheus client, in addition to details about each metric it tracks, which includes the metrics you added. Since you’re interested in only your metrics, you can check each line starting with your namespace, an underscore, and your subsystem <span class="CodeAnnotation">2</span>. If the line matches this prefix <span class="CodeAnnotation">3</span>, you print it to standard output. Otherwise, you ignore the line and move on.</p>&#13;
<p>Let’s run this example on the command line and examine the resulting metrics in <a href="#listing13-30">Listing 13-30</a>.</p>&#13;
<pre><code>$ <b>go run instrumentation/main.go</b>&#13;
Metrics listening on "127.0.0.1:8081" ...&#13;
Web listening on "127.0.0.1:8082" ...&#13;
&#13;
Spawning 500 connections to make 100 requests each ... done.&#13;
&#13;
Current Metrics:&#13;
web_server1_open_connections <span class="CodeAnnotation">1</span>500&#13;
web_server1_request_count <span class="CodeAnnotation">2</span>50000&#13;
web_server1_request_duration_histogram_seconds_bucket{le="1e-07"} <span class="CodeAnnotation">3</span>0&#13;
web_server1_request_duration_histogram_seconds_bucket{le="2e-07"} 1&#13;
web_server1_request_duration_histogram_seconds_bucket{le="3e-07"} 613&#13;
web_server1_request_duration_histogram_seconds_bucket{le="4e-07"} 13591&#13;
web_server1_request_duration_histogram_seconds_bucket{le="5e-07"} 33216&#13;
web_server1_request_duration_histogram_seconds_bucket{le="1e-06"} 40183&#13;
<span epub:type="pagebreak" id="Page_326" title="326"/>web_server1_request_duration_histogram_seconds_bucket{le="2.5e-06"} 49876&#13;
web_server1_request_duration_histogram_seconds_bucket{le="5e-06"} 49963&#13;
web_server1_request_duration_histogram_seconds_bucket{le="7.5e-06"} 49973&#13;
web_server1_request_duration_histogram_seconds_bucket{le="1e-05"} 49979&#13;
web_server1_request_duration_histogram_seconds_bucket{le="0.0001"} 49994&#13;
web_server1_request_duration_histogram_seconds_bucket{le="0.001"} 49997&#13;
web_server1_request_duration_histogram_seconds_bucket{le="0.01"} <span class="CodeAnnotation">4</span>50000&#13;
web_server1_request_duration_histogram_seconds_bucket{le="+Inf"} 50000&#13;
web_server1_request_duration_histogram_seconds_sum <span class="CodeAnnotation">5</span>0.04102166899999979&#13;
web_server1_request_duration_histogram_seconds_count <span class="CodeAnnotation">6</span>50000</code></pre>&#13;
<p class="CodeListingCaption"><a id="listing13-30">Listing 13-30</a>: Web server output and resulting metrics</p>&#13;
<p>As expected, 500 connections were open <span class="CodeAnnotation">1</span> at the time you queried the metrics. These connections are idle. You can experiment with the HTTP client by invoking its <code>CloseIdleConnections</code> method after it’s done making 100 GET calls; see how that change affects the open connections gauge. Likewise, see what happens to the open connections when you don’t define their <code>Transport</code> field.</p>&#13;
<p>The request count is 50,000 <span class="CodeAnnotation">2</span>, so all requests succeeded. </p>&#13;
<p>Do you notice what’s missing? The write errors counter. Since no write errors occur, the write errors counter never increments. As a result, it doesn’t show up in the metrics output. You could make a call to <code>metrics.WriteErrors.Add(0)</code> to make the metric show up without changing its value, but its absence probably bothers you more than it bothers Prometheus. Just be aware that the metrics output may not include all instrumented metrics, just the ones that have changed since initialization.</p>&#13;
<p>The underlying Prometheus histogram is a <em>cumulative</em> histogram: any value that increments a bucket’s counter also increments the counters for all buckets less than the value. Therefore, you see increasing values in each bucket until you reach the 0.01 bucket <span class="CodeAnnotation">4</span>. Even though you define a range of buckets, Prometheus adds an infinite bucket for you. In this example, you defined a bucket smaller than all observed values <span class="CodeAnnotation">3</span>, so its counter is still zero.</p>&#13;
<p>A histogram and a summary maintain two additional counters: the sum of all observed values <span class="CodeAnnotation">5</span> and the total number of observed values <span class="CodeAnnotation">6</span>. If you use a summary, the Prometheus endpoint will present only these two counters. It will not detail the summary’s buckets as it does with a histogram. Therefore, the Prometheus server can aggregate histogram buckets but cannot do the same for summaries.</p>&#13;
<h2 id="h1-500884c13-0004">What You’ve Learned</h2>&#13;
<p class="BodyFirst">Logging is hard. Instrumentation, not so much. Be frugal with your logging and generous with your instrumentation. Logging isn’t free and can quickly add latency if you aren’t mindful of where and how much you log. You cannot go wrong by logging actionable items, particularly ones that should trigger an alert. On the other hand, instrumentation is very efficient. You should instrument everything, at least initially. Metrics detail the current state of your <span epub:type="pagebreak" id="Page_327" title="327"/>service and provide insight into potential problems, whereas logs provide an immutable audit trail of sorts that explains the current state of your service and helps you diagnose failures. </p>&#13;
<p>Go’s <code>log</code> package provides enough functionality to satisfy basic log requirements. But it becomes cumbersome when you need to log to more than one output or at varying levels of verbosity. At that point, you’re better off with a comprehensive solution such as Uber’s Zap logger. No matter what logger you use, consider adding structure to your log entries by including additional metadata. Structured logging allows you to leverage software to quickly filter and search log entries, particularly if you centralize logs across your infrastructure.</p>&#13;
<p>On-demand debug logging and wide event logging are two methods you can use to collect important information while minimizing logging’s impact on the performance of your service. You can use the creation of a semaphore file to signal your logger to enable debug logging. When you remove the semaphore file, the logger immediately disables debug logging. Wide event logs summarize events in a request-response loop. You can replace numerous log entries with a single wide event log without hindering your ability to diagnose failures.</p>&#13;
<p>One approach to instrumentation is to use Go kit’s <code>metrics</code> package, which provides interfaces for common metric types and adapters for popular metrics platforms. It allows you to abstract the details of each metrics platform away from your instrumented code.</p>&#13;
<p>The <code>metrics</code> package supports counters, gauges, histograms, and summaries. Counters monotonically increase and can be used to calculate rates of change. Use counters to track values like request counts, error counts, or completed tasks. Gauges track values that can increase and decrease, such as current memory usage, in-flight requests, and queue sizes. Histograms and summaries place observed values in buckets and allow you to estimate averages or percentages of all values. You could use a histogram or summary to approximate the average request duration or response size.</p>&#13;
<p>Taken together, logging and metrics give you necessary insight into your service, allowing you to proactively address potential problems and recover from failures.</p>&#13;
</section>&#13;
</body></html>