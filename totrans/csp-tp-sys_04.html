<html><head></head><body>
<div id="sbo-rt-content"><section aria-labelledby="ch4" epub:type="chapter" role="doc-chapter">
<header>
<h1 class="CHAPTER" id="ch4">
<span class="CN"><span aria-label=" Page 105. " epub:type="pagebreak" id="pg_105" role="doc-pagebreak"/><samp class="SANS_Futura_Std_Bold_Condensed_B_11">4</samp></span>
<span class="CT"><samp class="SANS_Dogma_OT_Bold_B_11">IMPLICIT AND EXPLICIT COPYING</samp></span>
</h1>
</header>
<figure class="opener"><img alt="" class="opener" height="191" src="../images/opener-img.png" width="191"/>
</figure>
<p class="COS">In almost any useful program, the values of variables are constantly being copied, even when we don’t realize it. In this chapter, we’ll examine the causes and the possible consequences of copying. This topic might seem trivial, but copying can have hidden costs that can prove problematic when it’s not clear that a section of code <i>is</i> making copies.</p>
<p class="TX">We’ll explore the following:</p>
<ul class="BL">
<li class="BL">Why knowing whether a value is a copy is vital to understanding a program</li>
<li class="BL">How to avoid copying values in certain circumstances</li>
<li class="BL">Where the compiler may be making hidden copies of values</li>
<li class="BL">What we can do to prevent the need for the compiler to make hidden copies</li>
</ul>
<p class="TX"><span aria-label=" Page 106. " epub:type="pagebreak" id="pg_106" role="doc-pagebreak"/>You know from previous chapters that copying references is always a cheap operation, because it doesn’t also copy the instance. When we copy a value type instance, however, the value of each field is also copied, costing time and memory space, especially if the instance consists of several fields. Knowing when copying might occur, then, may help us identify opportunities to avoid some copies, thereby improving our program’s memory usage and speed.</p>
<p class="TX">The relative cost difference between copying a reference and copying an instance is part of the rationale behind the common advice to make value types small. However, the cost of copying is only one part of the story. Copying value type instances around is usually cheap, although some pathological cases may be cause for concern, but working with a copy might also have <i>semantic</i> implications. In particular, if we haven’t noticed that we’ve made a copy, we might be surprised that changes we’ve made to a value aren’t visible in the way we expect. Correspondingly, unexpected changes to an instance that have occurred using a copied reference can be the cause of subtle problems.</p>
<section aria-labelledby="sec1" epub:type="division">
<h2 class="H1" id="sec1"><span id="h-79"/><samp class="SANS_Futura_Std_Bold_B_11">Copying by Simple Assignment</samp></h2>
<p class="TNI">The differences in copy behavior of value types and reference types can have subtle consequences that can be hidden in apparently simple expressions that make a copy. The simplest example of copying occurs as the result of assignment:</p>
<pre><code>var copy = existing;</code></pre>
<p class="TX">Assigning the value of one variable to another like this is called <i>simple assignment</i>, and the left side—the target of the assignment—must be either a variable, or a property or indexer with an accessible <samp class="SANS_TheSansMonoCd_W5Regular_11">set</samp> accessor. The right side is an <i>expression</i>, which describes anything that can be evaluated to produce a value. The expression might be a simple value like a literal or an <samp class="SANS_TheSansMonoCd_W5Regular_11">enum</samp> member, another variable, or a more complex expression, such as a call to a method.</p>
<p class="TX">Both variables and values are associated with a type. Since in the preceding example we use type deduction for <samp class="SANS_TheSansMonoCd_W5Regular_11">copy</samp> with the <samp class="SANS_TheSansMonoCd_W5Regular_11">var</samp> declaration, the compiler deduces the type of the <samp class="SANS_TheSansMonoCd_W5Regular_11">copy</samp> variable from the type of the <i>value</i> of <samp class="SANS_TheSansMonoCd_W5Regular_11">existing</samp>. The type of the target variable doesn’t necessarily need to be identical to the type of the value being assigned. If we specify a different type for the target variable, the type of the value on the right must be <i>implicitly convertible</i> to the type of the variable on the left.</p>
<p class="TX">We can try to explicitly coerce the value to the target type by using an explicit cast, which you saw in <span class="Xref"><a href="chapter2.xhtml">Chapter 2</a></span>. For example, a <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp> can be explicitly cast to an <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>, although the conversion may lose information because the value is truncated. If the compiler detects that an explicit conversion can never succeed, such as from a <samp class="SANS_TheSansMonoCd_W5Regular_11">string</samp> to an <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>, the code won’t <span aria-label=" Page 107. " epub:type="pagebreak" id="pg_107" role="doc-pagebreak"/>compile. Otherwise, the conversion happens at run time and may fail with an <samp class="SANS_TheSansMonoCd_W5Regular_11">InvalidCastException</samp> if the conversion fails.</p>
<section aria-labelledby="sec2" epub:type="division">
<h3 class="H2" id="sec2"><span id="h-80"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Value Copy Behavior</samp></h3>
<p class="TNI">We know a copy of a non-<samp class="SANS_TheSansMonoCd_W5Regular_11">null</samp> reference refers to the same instance in memory as the original reference. That means any change we make to an instance of a reference type is visible via <i>all</i> the references to that instance. By comparison, when we copy an instance of a value type, the copy is a new, independent instance of the type, with copies of the original value’s fields.</p>
<p class="TX">However, it’s not always the case that changes to one instance of a value type can’t be observed by other instances. If any of the fields copied from the original value type instance are references, the copied instances will have copies of those references. Therefore, a copy of a value type instance can still alias an object on the heap via its fields. To illustrate, consider the ill-advised example in <a href="#list4-1">Listing 4-1</a>, where the <samp class="SANS_TheSansMonoCd_W5Regular_11">Item</samp> property of the <samp class="SANS_TheSansMonoCd_W5Regular_11">Purchase</samp> struct is a reference to a mutable <samp class="SANS_TheSansMonoCd_W5Regular_11">Product</samp> class.</p>
<pre id="list4-1"><code>public sealed class Product&#13;
{&#13;
    public int     Id {get; set;}&#13;
    public decimal Price {get; set;}&#13;
}&#13;
public readonly struct Purchase&#13;
{&#13;
    <b>public Product  Item {get; init;}</b>&#13;
    public DateTime Ordered {get; init;}&#13;
    public int      Quantity {get; init;}&#13;
}</code></pre>
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 4-1: Mutable reference fields</samp></p>
<p class="TX">Here, <samp class="SANS_TheSansMonoCd_W5Regular_11">Product</samp> is a simple data-carrier class, similar to types often used to read data from a database or message queue. A common characteristic of simple data carriers like <samp class="SANS_TheSansMonoCd_W5Regular_11">Product</samp> is to have mutable properties to read and write their values. The <samp class="SANS_TheSansMonoCd_W5Regular_11">Purchase</samp> type, meanwhile, is a struct and a well-behaved value type; it’s marked <samp class="SANS_TheSansMonoCd_W5Regular_11">readonly</samp>, and all of its properties are <samp class="SANS_TheSansMonoCd_W5Regular_11">init</samp>-only, meaning they can be given a value only when a new <samp class="SANS_TheSansMonoCd_W5Regular_11">Purchase</samp> instance is initialized.</p>
<p class="TX">Even though <samp class="SANS_TheSansMonoCd_W5Regular_11">Purchase</samp> is a <samp class="SANS_TheSansMonoCd_W5Regular_11">readonly</samp> struct, it is <i>not</i> immutable because its <samp class="SANS_TheSansMonoCd_W5Regular_11">Item</samp> property is a mutable type. Moreover, that property is a reference because <samp class="SANS_TheSansMonoCd_W5Regular_11">Product</samp> is a reference type. Two <samp class="SANS_TheSansMonoCd_W5Regular_11">Purchase</samp> instances, therefore, can refer to the same <i>mutable</i> <samp class="SANS_TheSansMonoCd_W5Regular_11">Product</samp> instance on the heap. To illustrate this, let’s look at how instances of these types are set out in memory.</p>
<p class="TX"><span aria-label=" Page 108. " epub:type="pagebreak" id="pg_108" role="doc-pagebreak"/>We create instances of the <samp class="SANS_TheSansMonoCd_W5Regular_11">Purchase</samp> type and its properties from <a href="#list4-1">Listing 4-1</a> like this:</p>
<pre><code>var existing = new Purchase&#13;
    {&#13;
        Item = new Product {Id = 10990, Price = 12.99m},&#13;
        Ordered = DateTime.Parse("2024-02-02"),&#13;
        Quantity = 12&#13;
    };</code></pre>
<p class="TX">The memory used by the <samp class="SANS_TheSansMonoCd_W5Regular_11">existing</samp> variable might look something like <a href="#fig4-1">Figure 4-1</a>.</p>
<figure class="IMG"><img alt="" class="img70" height="313" id="fig4-1" src="../images/Figure4-1.png" width="483"/>
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 4-1: The memory layout of a reference in a struct</samp></p></figcaption>
</figure>
<p class="TX">Since <samp class="SANS_TheSansMonoCd_W5Regular_11">Purchase</samp> is a value type, a variable of type <samp class="SANS_TheSansMonoCd_W5Regular_11">Purchase</samp> contains a complete instance in place wherever the variable is declared. In <a href="#fig4-1">Figure 4-1</a>, the <samp class="SANS_TheSansMonoCd_W5Regular_11">existing</samp> identifier is a name representing a memory location containing the values of the three fields of a <samp class="SANS_TheSansMonoCd_W5Regular_11">Purchase</samp> type. One of those fields is a backing field for the <samp class="SANS_TheSansMonoCd_W5Regular_11">Item</samp> property, whose type is the <samp class="SANS_TheSansMonoCd_W5Regular_11">Product</samp> class. As a reference type, the <samp class="SANS_TheSansMonoCd_W5Regular_11">Product</samp> instance is allocated on the heap, and the <samp class="SANS_TheSansMonoCd_W5Regular_11">Item</samp> property stores a reference to it. The content of the other property values, being value type instances, is stored directly within the <samp class="SANS_TheSansMonoCd_W5Regular_11">existing</samp> variable. Now consider what happens when we <i>copy</i> the <samp class="SANS_TheSansMonoCd_W5Regular_11">existing</samp> variable in <a href="#list4-2">Listing 4-2</a>.</p>
<pre id="list4-2"><code>var existing = new Purchase&#13;
    {&#13;
        Item = new Product {Id = 10990, Price = 12.99m},&#13;
        Ordered = DateTime.Parse("2024-02-02"),&#13;
        Quantity = 12&#13;
    };&#13;
--<var>snip--</var>&#13;
<b>var copy</b> <b>=</b> <b>existing;</b></code></pre>
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 4-2: Copying the value of the existing variable</samp></p>
<p class="TX"><span aria-label=" Page 109. " epub:type="pagebreak" id="pg_109" role="doc-pagebreak"/>Because the type of the <samp class="SANS_TheSansMonoCd_W5Regular_11">Item</samp> property is a class, only the <i>reference</i> is copied to the new <samp class="SANS_TheSansMonoCd_W5Regular_11">copy</samp> variable’s instance, leaving both the <samp class="SANS_TheSansMonoCd_W5Regular_11">existing</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">copy</samp> variables referring to the same <samp class="SANS_TheSansMonoCd_W5Regular_11">Product</samp> instance on the heap, as depicted in <a href="#fig4-2">Figure 4-2</a>.</p>
<figure class="IMG"><img alt="" class="img100" height="319" id="fig4-2" src="../images/Figure4-2.png" width="809"/>
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 4-2: The memory layout after copying a struct instance</samp></p></figcaption>
</figure>
<p class="TX">Having copied <samp class="SANS_TheSansMonoCd_W5Regular_11">existing</samp> to <samp class="SANS_TheSansMonoCd_W5Regular_11">copy</samp>, we now have two <samp class="SANS_TheSansMonoCd_W5Regular_11">Purchase</samp> instances in memory, but the instance data for <samp class="SANS_TheSansMonoCd_W5Regular_11">Item</samp> hasn’t been copied. Each <samp class="SANS_TheSansMonoCd_W5Regular_11">Purchase</samp> instance has a reference to the same <samp class="SANS_TheSansMonoCd_W5Regular_11">Product</samp> on the heap.</p>
</section>
<section aria-labelledby="sec3" epub:type="division">
<h3 class="H2" id="sec3"><span id="h-81"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Read-Only Properties vs. Immutable Types</samp></h3>
<p class="TNI">Making the <samp class="SANS_TheSansMonoCd_W5Regular_11">Purchase</samp> struct in <a href="#list4-1">Listing 4-1</a> read-only doesn’t protect it from unintended side effects associated with aliasing references, nor does the fact that its <samp class="SANS_TheSansMonoCd_W5Regular_11">Item</samp> property has no <samp class="SANS_TheSansMonoCd_W5Regular_11">set</samp> accessor. We could still inadvertently modify the object referred to by the <samp class="SANS_TheSansMonoCd_W5Regular_11">Item</samp> property because even though <samp class="SANS_TheSansMonoCd_W5Regular_11">Purchase.Item</samp> has no <samp class="SANS_TheSansMonoCd_W5Regular_11">set</samp> accessor, the <samp class="SANS_TheSansMonoCd_W5Regular_11">Product</samp> type it refers to has mutable properties. If we alter a property of the <samp class="SANS_TheSansMonoCd_W5Regular_11">Product</samp> instance via the <samp class="SANS_TheSansMonoCd_W5Regular_11">copy</samp> variable, that change is visible in the <samp class="SANS_TheSansMonoCd_W5Regular_11">existing</samp> variable, as demonstrated in <a href="#list4-3">Listing 4-3</a>.</p>
<pre id="list4-3"><code>var existing = new Purchase&#13;
    {&#13;
        Item = new Product {Id = 10990, Price = 12.99m},&#13;
        Ordered = DateTime.Parse("2024-02-02"),&#13;
        Quantity = 12&#13;
    };&#13;
var copy = existing;&#13;
<b>copy.Item.Price</b> <b>=</b> <b>14.99;</b>&#13;
Assert.That(existing.Item.Price, Is.EqualTo(14.99));</code></pre>
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 4-3: Altering the state of a Product via a shared reference</samp></p>
<p class="TX">Because the properties of the <samp class="SANS_TheSansMonoCd_W5Regular_11">Product</samp> type are writable, we can change the instance by using any reference to it. If we make the <samp class="SANS_TheSansMonoCd_W5Regular_11">Product</samp> type <span aria-label=" Page 110. " epub:type="pagebreak" id="pg_110" role="doc-pagebreak"/>immutable, we can’t change the data in a <samp class="SANS_TheSansMonoCd_W5Regular_11">Product</samp> instance via <i>any</i> reference to it, so it doesn’t matter that it’s shared among multiple reference variables. It isn’t especially unusual for value types to contain references as fields or properties, but we must be cautious about the <i>kinds</i> of references we store in a value type. If we want to avoid the issues associated with unexpected changes to <samp class="SANS_TheSansMonoCd_W5Regular_11">Purchase</samp> instances, we must make sure that the object referred to by <samp class="SANS_TheSansMonoCd_W5Regular_11">Purchase.Item</samp> can’t be changed via <i>any</i> reference; it’s not enough to simply ensure that the referenced object can’t be changed via <samp class="SANS_TheSansMonoCd_W5Regular_11">Purchase</samp> itself. The simplest way to achieve that would be to make <samp class="SANS_TheSansMonoCd_W5Regular_11">Product</samp> immutable. More generally, value types with reference type fields should refer only to immutable types.</p>
<p class="TX">Knowing whether we have a copy of a reference or a copy of a complete instance is valuable information. Assigning one variable to another is the most visible example of how values are copied in a program. In the next few sections, we’ll look at some less obvious examples of values being copied and see how our programs may be making more copies than we think.</p>
</section>
</section>
<section aria-labelledby="sec4" epub:type="division">
<h2 class="H1" id="sec4"><span id="h-82"/><samp class="SANS_Futura_Std_Bold_B_11">Creating New Objects</samp></h2>
<p class="TNI">Most of the time, we don’t need to worry about how object instances use memory; that’s the CLR’s responsibility. We create object instances with the <samp class="SANS_TheSansMonoCd_W5Regular_11">new</samp> expression, which abstracts the details of how and where memory for the object is allocated. New objects are always created by calling a constructor, although, as you saw in <span class="Xref"><a href="chapter2.xhtml">Chapter 2</a></span>, when we use the object initialization syntax, the constructor call may be implicitly inserted by the compiler. Either approach may require an extra copy of a new value type instance, so to more closely monitor the memory our programs use, we need to pay extra attention to <i>how</i> we construct new objects.</p>
<p class="TX">For example, <a href="#list4-4">Listing 4-4</a> shows an instance of a <samp class="SANS_TheSansMonoCd_W5Regular_11">Purchase</samp> value type being created via object initialization. Although not visible in the code, an extra copy of the <samp class="SANS_TheSansMonoCd_W5Regular_11">Purchase</samp> instance is used to perform the initialization.</p>
<pre id="list4-4"><code>public readonly struct Purchase&#13;
{&#13;
    public Product   Item {get; init;}&#13;
    public DateTime  Ordered {get; init;}&#13;
    public int       Quantity {get; init;}&#13;
}&#13;
var order = new Purchase&#13;
    {&#13;
        Item = new Product {Id = 10990, Price = 12.99m},&#13;
        Ordered = DateTime.Parse("2024-02-02"),&#13;
        Quantity = 12&#13;
    };</code></pre>
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 4-4: Creating a new instance of the Purchase value type via object initialization</samp></p>
<blockquote>
<p class="NOTE"><span class="NoteHead"><samp class="SANS_Dogma_OT_Bold_B_21">NOTE</samp></span></p>
</blockquote>
<p class="NOTE-TXT"><i>The extra copy of Purchase is required only if we actually access its properties, but setting property values that are never read probably isn’t common.</i></p>
<p class="TX"><span aria-label=" Page 111. " epub:type="pagebreak" id="pg_111" role="doc-pagebreak"/>When we use object initialization to create a new object, the constructor is still invoked, even when it isn’t specified. Since <samp class="SANS_TheSansMonoCd_W5Regular_11">Purchase</samp> is a struct and has no user-defined constructors, the new instance is first default-initialized and then its properties are assigned according to the values specified between the braces.</p>
<p class="TX">The default-initialized instance created by the constructor call is <i>not</i> observable by our code. The properties of the new instance are initialized via a hidden variable, which is then copied to the target variable—the <samp class="SANS_TheSansMonoCd_W5Regular_11">order</samp> variable in <a href="#list4-4">Listing 4-4</a>—after the object initialization has completed. When the code to initialize a <samp class="SANS_TheSansMonoCd_W5Regular_11">Purchase</samp> is compiled, the compiler emits the equivalent of <a href="#list4-5">Listing 4-5</a>.</p>
<pre id="list4-5"><code><b>var __temp</b> <b>=</b> <b>new Purchase();</b>&#13;
__temp.Item = new Product {Id = 10990, Price = 12.99m};&#13;
__temp.Ordered = DateTime.Parse("2024-02-02");&#13;
__temp.Quantity = 12;&#13;
<b>var order</b> <b>=</b> <b>__temp;</b></code></pre>
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 4-5: Code that’s equivalent to object initialization syntax</samp></p>
<blockquote>
<p class="NOTE"><span class="NoteHead"><samp class="SANS_Dogma_OT_Bold_B_21">NOTE</samp></span></p>
</blockquote>
<p class="NOTE-TXT"><i>We couldn’t have written the same code ourselves, because the Purchase type’s Item, Ordered, and Quantity properties are init-only. The compiler would also translate the initialization of the Item property into a call to the constructor and separately set its properties, but for brevity’s sake, the object-initialization syntax has been left intact here.</i></p>
<p class="TX">After the constructor has completed, the instance has only been default-initialized, and, in particular, the <samp class="SANS_TheSansMonoCd_W5Regular_11">Item</samp> property will be <samp class="SANS_TheSansMonoCd_W5Regular_11">null</samp> since it’s a reference type. The purpose of this two-stage initialization is to prevent that incomplete instance from being observed. The value of the hidden <samp class="SANS_TheSansMonoCd_W5Regular_11">__temp</samp> variable is copied to the target <samp class="SANS_TheSansMonoCd_W5Regular_11">order</samp> variable when the initialization is complete, after all the properties have been assigned.</p>
<section aria-labelledby="sec5" epub:type="division">
<h3 class="H2" id="sec5"><span id="h-83"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Overwriting a Value</samp></h3>
<p class="TNI">A hidden variable also allows us to reassign a variable by using properties of its previous value. <a href="#list4-6">Listing 4-6</a> reinitializes the <samp class="SANS_TheSansMonoCd_W5Regular_11">order</samp> variable with a new instance and uses the existing value of <samp class="SANS_TheSansMonoCd_W5Regular_11">order.Item</samp> for the <samp class="SANS_TheSansMonoCd_W5Regular_11">Item</samp> property of the new instance.</p>
<pre id="list4-6"><code>order = new Purchase&#13;
    {&#13;
        <b>Item</b> <b>=</b> <b>order.Item,</b>&#13;
        Ordered = DateTime.Parse("2024-02-03"),&#13;
        Quantity = 5&#13;
    };</code></pre>
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 4-6: Reinitializing the order variable by using its own properties</samp></p>
<p class="TX">Without the hidden <samp class="SANS_TheSansMonoCd_W5Regular_11">__temp</samp> variable introduced by the compiler, the result of the <samp class="SANS_TheSansMonoCd_W5Regular_11">new</samp> expression would be assigned to <samp class="SANS_TheSansMonoCd_W5Regular_11">order</samp> before the value of <span aria-label=" Page 112. " epub:type="pagebreak" id="pg_112" role="doc-pagebreak"/>the <samp class="SANS_TheSansMonoCd_W5Regular_11">Item</samp> property had been obtained. The initialization of the <samp class="SANS_TheSansMonoCd_W5Regular_11">order</samp> variable would be similar to the following:</p>
<pre><code>order = new Purchase();&#13;
<b>order.Item</b> <b>=</b> <b>order.Item;</b>&#13;
order.Ordered = DateTime.Parse("2024-02-03");&#13;
order.Quantity = 5;</code></pre>
<p class="TX">Notice that the <samp class="SANS_TheSansMonoCd_W5Regular_11">order</samp> variable being assigned to is default-initialized before its properties are set. The <samp class="SANS_TheSansMonoCd_W5Regular_11">Item</samp> property is effectively being used to reinitialize itself. Without the hidden <samp class="SANS_TheSansMonoCd_W5Regular_11">__temp</samp> variable, <samp class="SANS_TheSansMonoCd_W5Regular_11">Item</samp> will be initialized to <samp class="SANS_TheSansMonoCd_W5Regular_11">null</samp> during the <samp class="SANS_TheSansMonoCd_W5Regular_11">order</samp> variable’s initialization and then reassigned that same <samp class="SANS_TheSansMonoCd_W5Regular_11">null</samp> value. As a result, the <samp class="SANS_TheSansMonoCd_W5Regular_11">order</samp> variable’s <samp class="SANS_TheSansMonoCd_W5Regular_11">Item</samp> property will end up with the value <samp class="SANS_TheSansMonoCd_W5Regular_11">null</samp>, which is certainly not what we intend. The approach shown in <a href="#list4-5">Listing 4-5</a> correctly handles this behavior by not overwriting the <samp class="SANS_TheSansMonoCd_W5Regular_11">order</samp> instance until the temporary copy has been fully initialized.</p>
<p class="TX">When <samp class="SANS_TheSansMonoCd_W5Regular_11">Purchase</samp> is a value type, as in these examples, the extra <samp class="SANS_TheSansMonoCd_W5Regular_11">__temp</samp> copy might be significant, because it’s a copy of the whole instance value. When the type is a class or a record, the copy is just a new reference to the same instance, so the cost of the extra copy is negligible.</p>
<p class="TX">Prior to C# v9.0, object initialization could be used only for properties with a public <samp class="SANS_TheSansMonoCd_W5Regular_11">set</samp> accessor. This restriction was removed with the introduction of <samp class="SANS_TheSansMonoCd_W5Regular_11">init</samp>-only properties, but in general a constructor is a more direct method for initializing an instance, at least in part because it avoids the need for a hidden variable—well, <i>most</i> of the time. As you’ll see next, this is not universally true for value types.</p>
</section>
<section aria-labelledby="sec6" epub:type="division">
<h3 class="H2" id="sec6"><span id="h-84"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Constructing Value Types</samp></h3>
<p class="TNI">When we create a local variable instance of a struct or record struct type via a user-defined constructor, the compiler can introduce a variation on the two-stage initialization we saw with object initialization. The compiler still inserts a hidden variable, but instead of setting properties, it adds code to directly call the required constructor on the hidden instance before copying its value to the target variable.</p>
<p class="TX"><a href="#list4-7">Listing 4-7</a> shows a <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp> struct whose properties have neither <samp class="SANS_TheSansMonoCd_W5Regular_11">set</samp> nor <samp class="SANS_TheSansMonoCd_W5Regular_11">init</samp> accessors, so we must use a constructor to initialize the properties.</p>
<pre id="list4-7"><code>public readonly struct Color&#13;
{&#13;
    public Color(int red, int green, int blue)&#13;
        =&gt; (Red, Green, Blue) = (red, green, blue);&#13;
    public int Red {get;}&#13;
    public int Green {get;}&#13;
    public int Blue {get;}&#13;
}&#13;
<b>var background</b> <b>=</b> <b>new Color(red: 0xFF, green: 0xA5, blue: 0x0);</b></code></pre>
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 4-7: Calling a constructor to initialize the Color struct’s properties</samp></p>
<p class="TX"><span aria-label=" Page 113. " epub:type="pagebreak" id="pg_113" role="doc-pagebreak"/>A constructor has the special name <samp class="SANS_TheSansMonoCd_W5Regular_11">.ctor</samp> in the compiled code, so creating an instance of <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp> with arguments is broadly equivalent to this:</p>
<pre><code>Color __temp;&#13;
__temp..ctor(red: 0xFF, green: 0xA5, blue: 0x0);&#13;
Color background = __temp;</code></pre>
<p class="TX">The constructor is invoked on the <samp class="SANS_TheSansMonoCd_W5Regular_11">__temp</samp> value <i>in place</i> on the second line. The declaration of the <samp class="SANS_TheSansMonoCd_W5Regular_11">__temp</samp> variable causes the compiler to reserve enough space for a default instance of <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp>, and, at run time, the constructor is invoked on that instance as if it were a normal method.</p>
<p class="TX">Since <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp> is a value type, the hidden variable represents a full instance, and that instance is copied in full to the target variable. This behavior applies only to user-defined constructors of struct and record struct types; the default constructor for a value type simply default-initializes each field and thus doesn’t require a hidden copy.</p>
<p class="TX">As we saw with object initialization, the hidden <samp class="SANS_TheSansMonoCd_W5Regular_11">__temp</samp> variable prevents a partially constructed instance from ever being observable. In practice, the compiler can typically optimize away the hidden instance altogether, but in some circumstances, such as when constructing an instance might fail with an exception, a hidden copy can’t be avoided. Consider the <samp class="SANS_TheSansMonoCd_W5Regular_11">Brush</samp> class in <a href="#list4-8">Listing 4-8</a>, whose <samp class="SANS_TheSansMonoCd_W5Regular_11">background</samp> field is initialized using a field initializer. In the <samp class="SANS_TheSansMonoCd_W5Regular_11">Assign</samp> method, we assign a new value for <samp class="SANS_TheSansMonoCd_W5Regular_11">background</samp>.</p>
<pre id="list4-8"><code>public class Brush&#13;
{&#13;
    public void Assign(int r, int g, int b)&#13;
    {&#13;
        <b>background</b> <b>=</b> <b>new Color(red: r, green: g, blue: b);</b>&#13;
    }&#13;
    private Color background = new Color(red: 0xFF, green: 0xA5, blue: 0);&#13;
}</code></pre>
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 4-8: Calling a struct constructor that might throw an exception</samp></p>
<p class="TX">The hidden temporary copy of <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp> is essential when we reassign the <samp class="SANS_TheSansMonoCd_W5Regular_11">background</samp> field within the <samp class="SANS_TheSansMonoCd_W5Regular_11">Assign</samp> method of <samp class="SANS_TheSansMonoCd_W5Regular_11">Brush</samp>, as it ensures that <samp class="SANS_TheSansMonoCd_W5Regular_11">background</samp> always has a valid and predictable value. If the <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp> constructor were called directly on the <samp class="SANS_TheSansMonoCd_W5Regular_11">background</samp> instance and failed with an exception, it might leave <samp class="SANS_TheSansMonoCd_W5Regular_11">background</samp> in an indeterminate state. In the <samp class="SANS_TheSansMonoCd_W5Regular_11">Assign</samp> method, the compiler must ensure that the existing value for the <samp class="SANS_TheSansMonoCd_W5Regular_11">background</samp> field can be used, even if the constructor for <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp> throws an exception.</p>
<p class="TX">By separating the construction of the <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp> instance from assigning to the <samp class="SANS_TheSansMonoCd_W5Regular_11">background</samp> field, the compiler ensures that the only <i>observable</i> states for the variable are either the fully constructed value, if no exception occurred, or its previous value, if the constructor throws an exception. Note that copying a value type instance will never throw an exception; copying the value from one memory location to another is always safe and doesn’t require new memory to be allocated at run time.</p>
<p class="TX"><span aria-label=" Page 114. " epub:type="pagebreak" id="pg_114" role="doc-pagebreak"/>Copying value type instances isn’t guaranteed to be atomic. For example, if the type has multiple fields or floating-point values, a different thread could observe the target value partway through the copy operation, a risk known as <i>memory tearing</i>. This is an issue only when multiple threads share memory that can be written. However, it’s important to remember that mutability isn’t just about setting properties; immutable values can be copied as well. The simplest protection against memory tearing is to make sure that memory accessible to multiple threads is truly read-only.</p>
</section>
<section aria-labelledby="sec7" epub:type="division">
<h3 class="H2" id="sec7"><span id="h-85"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Copying Records Like Value Types</samp></h3>
<p class="TNI"><span class="Xref"><a href="chapter2.xhtml">Chapter 2</a></span> showed how to use non-destructive mutation to copy an existing record instance and alter selected properties of that copy by using the <samp class="SANS_TheSansMonoCd_W5Regular_11">with</samp> keyword. <a href="#list4-9">Listing 4-9</a> shows how a <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp> record can be cloned this way.</p>
<pre id="list4-9"><code>public sealed record Color(int Red, int Green, int Blue);&#13;
var pink = new Color(Red: 0xFF, Green: 0xA5, Blue: 0xFF);&#13;
<b>var orange</b> <b>=</b> <b>pink with {Blue</b> <b>=</b> <b>0};</b></code></pre>
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 4-9: Cloning a record instance by using with</samp></p>
<p class="TX">Cloning an instance by using non-destructive mutation means that the original instance is preserved while the copied instance is changed. In <a href="#list4-9">Listing 4-9</a>, the cloned variable <samp class="SANS_TheSansMonoCd_W5Regular_11">orange</samp> takes all the properties from <samp class="SANS_TheSansMonoCd_W5Regular_11">pink</samp> <i>except</i> the <samp class="SANS_TheSansMonoCd_W5Regular_11">Blue</samp> property, which is explicitly given the value <samp class="SANS_TheSansMonoCd_W5Regular_11">0</samp>.</p>
<p class="TX">The same syntax can be used to copy structs and record structs and provides a convenient way to set <samp class="SANS_TheSansMonoCd_W5Regular_11">init</samp>-only properties on the target variable. Record types have an additional benefit because they’re reference types and thus don’t have the copy-by-value semantics of a true value type. If we just assign a record variable to another variable, we still get two references to the same instance, as shown here:</p>
<pre><code>var black = pink;&#13;
Assert.That(ReferenceEquals(black, pink), Is.True);</code></pre>
<p class="TX">If the <samp class="SANS_TheSansMonoCd_W5Regular_11">pink</samp> variable were a value type, <samp class="SANS_TheSansMonoCd_W5Regular_11">black</samp> would be a copy of the instance. The <samp class="SANS_TheSansMonoCd_W5Regular_11">with</samp> keyword always copies an instance, regardless of whether it’s a value type or reference type.</p>
<p class="TX">Just as with object initialization, the compiler creates a hidden temporary instance and sets its properties before copying it to the target variable. Non-destructive mutation differs from object initialization in that, for records, the new instance is created using a virtual compiler-generated <samp class="SANS_TheSansMonoCd_W5Regular_11">Clone</samp> method. This method is essential because, by default, positional records like the <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp> record in this example do not have an accessible parameterless constructor.</p>
<p class="TX">Record structs and structs can always be constructed without arguments and are always copied by value, meaning they don’t have or need a <span aria-label=" Page 115. " epub:type="pagebreak" id="pg_115" role="doc-pagebreak"/><samp class="SANS_TheSansMonoCd_W5Regular_11">Clone</samp> method. The <samp class="SANS_TheSansMonoCd_W5Regular_11">with</samp> syntax isn’t supported by class types because, among other challenges, most classes aren’t intended to model value semantics.</p>
<p class="TX">The initialization process for reference type instances differs from the process for value types, mainly because of the way the different types are allocated and stored in memory. That has consequences for the variables we use to access those instances too, especially when we need to use a reference variable to refer to a value type instance, causing the value to be boxed.</p>
</section>
</section>
<section aria-labelledby="sec8" epub:type="division">
<h2 class="H1" id="sec8"><span id="h-86"/><samp class="SANS_Futura_Std_Bold_B_11">Identifying Unnecessary Boxing</samp></h2>
<p class="TNI">Value type instances don’t exist on the heap except as part of another object, so we can’t use a reference to refer to them directly. Boxing, as you know from <span class="Xref"><a href="chapter2.xhtml">Chapter 2</a></span>, solves this by copying the value to a known place on the heap and allowing us to reference that copy.</p>
<p class="TX">However, because boxing always copies to the heap, the box is subject to garbage collection and other heap management tasks. If we box values indiscriminately, then our program’s performance and memory use will suffer. Taking the time to identify and remove unnecessary boxing will improve our code’s efficiency.</p>
<p class="TX">Boxing occurs anytime we use a reference type variable to refer to a value type instance. It usually happens implicitly (although we can explicitly box a value, it’s rarely necessary). Recall from <span class="Xref"><a href="chapter2.xhtml">Chapter 2</a></span> that all types ultimately derive from <samp class="SANS_TheSansMonoCd_W5Regular_11">object</samp>, so we can always implicitly cast a value of any type to <samp class="SANS_TheSansMonoCd_W5Regular_11">object</samp>. When that value isn’t already a reference, the result is a reference to a boxed instance.</p>
<p class="TX">Let’s look at an example. The <samp class="SANS_TheSansMonoCd_W5Regular_11">Clone</samp> method in <a href="#list4-10">Listing 4-10</a> creates a new local instance of the <samp class="SANS_TheSansMonoCd_W5Regular_11">Coordinate</samp> value type and returns an <samp class="SANS_TheSansMonoCd_W5Regular_11">object</samp> reference to it. The returned value is a reference to a <samp class="SANS_TheSansMonoCd_W5Regular_11">Coordinate</samp> that has been boxed.</p>
<pre id="list4-10"><code>public readonly struct Coordinate&#13;
{&#13;
    public int X {get; init;}&#13;
    public int Y {get; init;}&#13;
    public object Clone()&#13;
    {&#13;
        var item = new Coordinate {X = this.X, Y = this.Y};&#13;
        return item;&#13;
    }&#13;
    <var>--snip--</var>&#13;
}</code></pre>
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 4-10: Returning a reference to a boxed value type variable</samp></p>
<p class="TX">When we call the <samp class="SANS_TheSansMonoCd_W5Regular_11">Clone</samp> method, we are returned an <samp class="SANS_TheSansMonoCd_W5Regular_11">object</samp> reference to a boxed <samp class="SANS_TheSansMonoCd_W5Regular_11">Coordinate</samp> instance. The boxing occurs just before the method exits; space is allocated on the heap for a copy of <samp class="SANS_TheSansMonoCd_W5Regular_11">item</samp>’s value, and a reference to that box is returned from the method.</p>
<p class="TX"><span aria-label=" Page 116. " epub:type="pagebreak" id="pg_116" role="doc-pagebreak"/>Unboxing, the reverse of boxing, copies the value inside a box on the heap into an instance of its original value type. Unboxing must always be done explicitly and is syntactically the same as an explicit cast from the boxed value to the target type, as shown in <a href="#list4-11">Listing 4-11</a>.</p>
<pre id="list4-11"><code>var original = new Coordinate(<var>--snip--)</var>;&#13;
object box = original.Clone();&#13;
<b>Coordinate clone</b> <b>=</b> <b>(Coordinate)box;</b></code></pre>
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 4-11: Unboxing to the original type</samp></p>
<p class="TX">When a value type implements one or more interfaces, instances can also be referred to by a variable of any of those interface types, and this also requires the instance to be boxed.</p>
<section aria-labelledby="sec9" epub:type="division">
<h3 class="H2" id="sec9"><span id="h-87"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">To an Interface</samp></h3>
<p class="TNI">A value can be boxed only when it can be implicitly converted to the target reference type. Since all value types are sealed—meaning inheritance is prohibited—that valid conversion can be to an <samp class="SANS_TheSansMonoCd_W5Regular_11">object</samp> variable reference, a <samp class="SANS_TheSansMonoCd_W5Regular_11">System.ValueType</samp> (which itself is <i>not</i> a value type), or an interface implemented by the value type. If the value is an <samp class="SANS_TheSansMonoCd_W5Regular_11">enum</samp> member, it can also be converted to the <samp class="SANS_TheSansMonoCd_W5Regular_11">System.Enum</samp> class or any of the interfaces implemented by <samp class="SANS_TheSansMonoCd_W5Regular_11">System.Enum</samp>.</p>
<p class="TX">We need a direct <samp class="SANS_TheSansMonoCd_W5Regular_11">object</samp> reference to a value in only a very few cases, and there’s no excuse for boxing to a <samp class="SANS_TheSansMonoCd_W5Regular_11">System.ValueType</samp>, except perhaps for purely didactic examples. A value type variable can implicitly convert to any interface implemented by the type, such as the <samp class="SANS_TheSansMonoCd_W5Regular_11">IComparable</samp> interface implemented by the <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp> struct in <a href="#list4-12">Listing 4-12</a>.</p>
<pre id="list4-12"><code><b>public readonly struct Color : IComparable&lt;Color&gt;</b>&#13;
{&#13;
    public Color(uint val) =&gt; rgb = val;&#13;
    int IComparable&lt;Color&gt;.CompareTo(Color other)&#13;
        =&gt; rgb.CompareTo(other.rgb);&#13;
    private readonly uint rgb;&#13;
}</code></pre>
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 4-12: The IComparable interface implemented by the Color struct</samp></p>
<p class="TX">The <samp class="SANS_TheSansMonoCd_W5Regular_11">IComparable&lt; T &gt;</samp> interface specifies a single method named <samp class="SANS_TheSansMonoCd_W5Regular_11">CompareTo</samp>, in which we define the comparison operation allowing collections of <samp class="SANS_TheSansMonoCd_W5Regular_11">T</samp> to be sorted. The implementation for <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp> here simply defers to its <samp class="SANS_TheSansMonoCd_W5Regular_11">uint</samp> field, which implements the <samp class="SANS_TheSansMonoCd_W5Regular_11">IComparable&lt; uint&gt;</samp> interface.</p>
<p class="TX">Note that the implementation of <samp class="SANS_TheSansMonoCd_W5Regular_11">IComparable&lt; Color</samp><samp class="SANS_TheSansMonoCd_W5Regular_11">&gt;</samp><samp class="SANS_TheSansMonoCd_W5Regular_11">.CompareTo</samp> is an <i>explicit</i> implementation, meaning we can invoke <samp class="SANS_TheSansMonoCd_W5Regular_11">CompareTo</samp> only by using a reference to the interface type. Any attempt to call <samp class="SANS_TheSansMonoCd_W5Regular_11">CompareTo</samp> directly on a <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp> variable results in a compile error. If we cast a <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp> variable <span aria-label=" Page 117. " epub:type="pagebreak" id="pg_117" role="doc-pagebreak"/>to the <samp class="SANS_TheSansMonoCd_W5Regular_11">IComparable&lt; Color&gt;</samp> interface, the value will be boxed into an <samp class="SANS_TheSansMonoCd_W5Regular_11">IComparable&lt; Color&gt;</samp> reference, as in <a href="#list4-13">Listing 4-13</a>.</p>
<pre id="list4-13"><code>var red = new Color(0xFF0000);&#13;
var green = new Color(0x00FF00);&#13;
<b>IComparable&lt;Color&gt;</b> <b>compare</b> <b>=</b> <b>red;</b>&#13;
var less = compare.CompareTo(green);</code></pre>
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 4-13: Explicitly boxing to an interface type</samp></p>
<p class="TX">When we initialize this <samp class="SANS_TheSansMonoCd_W5Regular_11">compare</samp> variable, the value of <samp class="SANS_TheSansMonoCd_W5Regular_11">red</samp> is boxed, because variables of any interface type are references. We could avoid the box by making <samp class="SANS_TheSansMonoCd_W5Regular_11">CompareTo</samp> nonexplicit, allowing us to call it directly using the <samp class="SANS_TheSansMonoCd_W5Regular_11">red</samp> variable without casting to the interface. That’s not to say that we should prefer nonexplicit implementations; explicit interface methods are a good way to segregate the public interface of a type.</p>
<p class="TX">We can call an explicit interface implementation by using a generic type parameter that has been constrained to the interface type. In this case, no cast is needed, and no boxing takes place. To demonstrate, the generic <samp class="SANS_TheSansMonoCd_W5Regular_11">LessThan</samp> method in <a href="#list4-14">Listing 4-14</a> doesn’t box its parameters, even when we pass <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp> values as arguments for it, because the generic parameter <samp class="SANS_TheSansMonoCd_W5Regular_11">T</samp> is constrained to the <samp class="SANS_TheSansMonoCd_W5Regular_11">IComparable&lt; T &gt;</samp> interface.</p>
<pre id="list4-14"><code>public static bool LessThan&lt;T&gt;(T left, T right)&#13;
    <b>where T : IComparable&lt;T&gt;</b>&#13;
{&#13;
    return left.CompareTo(right) &lt; 0;&#13;
}&#13;
var red = new Color(0xFF0000);&#13;
var green = new Color(0x00FF00);&#13;
Assert.That(LessThan(green, red), Is.True);</code></pre>
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 4-14: Constraining the generic type parameter T to the IComparable</samp><span class="TheSansMonoCd_W5Regular_11">&lt;</span> <span class="TheSansMonoCd_W5Regular_Italic_I_11">T</span> <span class="TheSansMonoCd_W5Regular_11">&gt;</span> <samp class="SANS_Futura_Std_Book_Oblique_I_11">interface type</samp></p>
<p class="TX">When a generic type parameter is constrained in this way, a variable of the generic type is considered to be of the type used for the constraint. In this example, <samp class="SANS_TheSansMonoCd_W5Regular_11">left</samp> is used as if it were an <samp class="SANS_TheSansMonoCd_W5Regular_11">IComparable&lt; T &gt;</samp> variable. We can invoke the method directly on whatever value <samp class="SANS_TheSansMonoCd_W5Regular_11">T</samp> represents, even when the implementing method is an explicit implementation.</p>
</section>
<section aria-labelledby="sec10" epub:type="division">
<h3 class="H2" id="sec10"><span id="h-88"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">In Method Calls</samp></h3>
<p class="TNI">Boxing a value type instance by assigning it to a reference variable is often conspicuous in our code, but boxing also occurs when we pass a value type instance as an argument for a reference type method parameter. As with assigning to a reference variable, the value is boxed implicitly if an implicit conversion to the type of the parameter exists. Since boxing is usually <span aria-label=" Page 118. " epub:type="pagebreak" id="pg_118" role="doc-pagebreak"/>implicit, it can be hard to spot. For example, <a href="#list4-15">Listing 4-15</a> boxes the <samp class="SANS_TheSansMonoCd_W5Regular_11">now</samp> variable because <samp class="SANS_TheSansMonoCd_W5Regular_11">DateTime</samp> is a value type, and <samp class="SANS_TheSansMonoCd_W5Regular_11">Console.WriteLine</samp> takes an <samp class="SANS_TheSansMonoCd_W5Regular_11">object?</samp> parameter following the format <samp class="SANS_TheSansMonoCd_W5Regular_11">string</samp> parameter.</p>
<pre id="list4-15"><code>DateTime now = DateTime.Now;&#13;
--<var>snip--</var>&#13;
Console.WriteLine("Time now: {0}", now);</code></pre>
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 4-15: Boxing the now argument for Console.WriteLine</samp></p>
<p class="TX">If we remain aware when we’re passing value types as arguments for reference type parameters, we can minimize the need to box the arguments or alter the code to avoid the box. However, it’s important to weigh the costs of boxing against the context of the rest of the code.</p>
<p class="TX">For example, rather than just passing the <samp class="SANS_TheSansMonoCd_W5Regular_11">now</samp> variable as the argument to <samp class="SANS_TheSansMonoCd_W5Regular_11">Console.WriteLine</samp> in <a href="#list4-15">Listing 4-15</a>, we could pass <samp class="SANS_TheSansMonoCd_W5Regular_11">now.ToString</samp>, which doesn’t need a box because the <samp class="SANS_TheSansMonoCd_W5Regular_11">DateTime</samp> struct overrides the <samp class="SANS_TheSansMonoCd_W5Regular_11">ToString</samp> method, and the <samp class="SANS_TheSansMonoCd_W5Regular_11">WriteLine</samp> method would call it anyway. Arguably, though, explicitly calling <samp class="SANS_TheSansMonoCd_W5Regular_11">ToString</samp> reduces the directness of the code, and the cost of boxing the <samp class="SANS_TheSansMonoCd_W5Regular_11">now</samp> variable is minimal compared to that of writing to the console.</p>
<p class="TX">When we call a base class virtual method on a value type instance that doesn’t specifically override that method, the instance is boxed in order to call the base class implementation. If the method is overridden by the type, as <samp class="SANS_TheSansMonoCd_W5Regular_11">ToString</samp> is in <samp class="SANS_TheSansMonoCd_W5Regular_11">DateTime</samp>, then no boxing occurs. We avoid the need to box our own value types in such situations by overriding all the virtual methods inherited from <samp class="SANS_TheSansMonoCd_W5Regular_11">object</samp>: <samp class="SANS_TheSansMonoCd_W5Regular_11">ToString</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp>, and <samp class="SANS_TheSansMonoCd_W5Regular_11">GetHashCode</samp>.</p>
<p class="TX">Calling the <samp class="SANS_TheSansMonoCd_W5Regular_11">GetType</samp> method on a value, however, will <i>always</i> cause the value to be boxed. The <samp class="SANS_TheSansMonoCd_W5Regular_11">GetType</samp> method is used to obtain the run-time type of a variable and is implemented on <samp class="SANS_TheSansMonoCd_W5Regular_11">object</samp>. However, <samp class="SANS_TheSansMonoCd_W5Regular_11">GetType</samp> isn’t virtual, so it can’t be overridden.</p>
<p class="TX">The lesson here is that we should avoid calling <samp class="SANS_TheSansMonoCd_W5Regular_11">GetType</samp> for value types. If we need type information on a value, we can use <samp class="SANS_TheSansMonoCd_W5Regular_11">typeof</samp> instead. Since value types are sealed and can’t inherit any other type, the compile-time type returned by <samp class="SANS_TheSansMonoCd_W5Regular_11">typeof</samp> will always match the run-time type given by <samp class="SANS_TheSansMonoCd_W5Regular_11">GetType</samp>.</p>
</section>
</section>
<section aria-labelledby="sec11" epub:type="division">
<h2 class="H1" id="sec11"><span id="h-89"/><samp class="SANS_Futura_Std_Bold_B_11">Method Parameters and Arguments</samp></h2>
<p class="TNI">Most copies of values aren’t so easily avoided, and passing arguments to methods is perhaps where the majority of copies are made. Trying to avoid such copying is not always beneficial, but understanding the mechanics of method calls is essential. This section examines where hidden copies can be found in properties, indexers, operators, and conversions, often as the result of behind-the-scenes method calls.</p>
<p class="TX">Methods can take their parameters either by value or by reference. As you saw in <span class="Xref"><a href="chapter3.xhtml">Chapter 3</a></span>, reference parameters are distinctive in that we need to use one of the <samp class="SANS_TheSansMonoCd_W5Regular_11">ref</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">out</samp>, or <samp class="SANS_TheSansMonoCd_W5Regular_11">in</samp> keywords to declare them as well as, for <samp class="SANS_TheSansMonoCd_W5Regular_11">ref</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">out</samp> parameters, on the arguments passed to them. Parameters that are not reference parameters are known as <i>value parameters</i>. Passing an <span aria-label=" Page 119. " epub:type="pagebreak" id="pg_119" role="doc-pagebreak"/>argument to a value parameter is so common that it’s easy to forget it results in a copy. Capturing the result of a method call also generally makes a copy of the returned value.</p>
<p class="TX">Additionally, the semantic and behavioral differences between value types and reference types have important consequences when we’re using the value returned from a method. It’s not even always obvious that we are calling a method or using a value returned from one. However, before we investigate those circumstances, let’s revisit the essential mechanics of value parameters and return values.</p>
<section aria-labelledby="sec12" epub:type="division">
<h3 class="H2" id="sec12"><span id="h-90"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Passing and Returning by Value</samp></h3>
<p class="TNI"><a href="#list4-16">Listing 4-16</a> shows a simple value type, <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp>, that has a static <samp class="SANS_TheSansMonoCd_W5Regular_11">Incremented</samp> method that takes a value parameter, <samp class="SANS_TheSansMonoCd_W5Regular_11">original</samp>, and returns a new value. Both the parameter and the return statement in the <samp class="SANS_TheSansMonoCd_W5Regular_11">Incremented</samp> method represent copies of <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp> instances.</p>
<pre id="list4-16"><code>public readonly struct Speed&#13;
{&#13;
    private Speed(double ms) =&gt; InMetersPerSecond = ms;&#13;
    public double InMetersPerSecond {get;}&#13;
    public static Speed FromMetersPerSecond(double val) =&gt; new Speed(val);&#13;
    <b>public static Speed Incremented(Speed original)</b>&#13;
    <b>{</b>&#13;
        <b>var result</b> <b>=</b>&#13;
            <b>Speed.FromMetersPerSecond(original.InMetersPerSecond</b> <b>+</b> <b>10);</b>&#13;
        <b>return result;</b>&#13;
    <b>}</b>&#13;
}&#13;
var start = Speed.FromMetersPerSecond(40);&#13;
var end = Speed.Incremented(start);&#13;
Assert.That(end.InMetersPerSecond, Is.EqualTo(50));</code></pre>
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 4-16: Passing and returning Speed instances by value</samp></p>
<p class="TX">The <samp class="SANS_TheSansMonoCd_W5Regular_11">Incremented</samp> method receives its <samp class="SANS_TheSansMonoCd_W5Regular_11">original</samp> parameter by value, meaning <samp class="SANS_TheSansMonoCd_W5Regular_11">original</samp> is a local variable within the method. The return is also by value, so a whole new instance of <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp> is returned as a new value when we call the method. As an optimization, the compiler may be able to avoid that copy by using the <samp class="SANS_TheSansMonoCd_W5Regular_11">result</samp> local variable to assign the target variable directly, as long as the observable effect is identical to making a copy. We can either assign the value to a new variable, as we do here, or use the new value to overwrite the value of the <samp class="SANS_TheSansMonoCd_W5Regular_11">start</samp> variable passed as the argument in the first place.</p>
<p class="TX">Instead of a plain static method, we could use an extension method, which we call as if it were an instance method. The first parameter of an extension method is special because it represents the <samp class="SANS_TheSansMonoCd_W5Regular_11">this</samp> identifier that would be implicitly available within an ordinary instance member. An <span aria-label=" Page 120. " epub:type="pagebreak" id="pg_120" role="doc-pagebreak"/>extension method is a good candidate for providing different, perhaps less common, units of measurement. <a href="#list4-17">Listing 4-17</a> uses an extension method called <samp class="SANS_TheSansMonoCd_W5Regular_11">InMph</samp> to obtain the value of a <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp> in miles per hour.</p>
<pre id="list4-17"><code>public static class SpeedExtensions&#13;
{&#13;
    <b>public static double InMph(this Speed speed)</b>&#13;
        =&gt; speed.InMetersPerSecond * 2.236936;&#13;
}&#13;
var mph = initial.InMph();</code></pre>
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 4-17: Defining the InMph extension method for Speed</samp></p>
<p class="TX">Despite the special <samp class="SANS_TheSansMonoCd_W5Regular_11">this</samp> syntax in the <samp class="SANS_TheSansMonoCd_W5Regular_11">InMph</samp> extension method’s declaration, the first parameter is still just a value parameter, taking its argument by value. The <samp class="SANS_TheSansMonoCd_W5Regular_11">initial</samp> variable’s value will therefore be copied into the <samp class="SANS_TheSansMonoCd_W5Regular_11">speed</samp> parameter in order to call the method. The <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp> type is a struct, so every copy we make represents a whole instance of <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp>.</p>
<blockquote>
<p class="NOTE"><span class="NoteHead"><samp class="SANS_Dogma_OT_Bold_B_21">NOTE</samp></span></p>
</blockquote>
<p class="NOTE-TXT"><i>We have many online converters to choose from for this type of conversion. The one used for <a href="#list4-17">Listing 4-17</a> is from the Inch Calculator website,</i> <a href="https://www.inchcalculator.com/convert/meter-per-second-to-mile-per-hour/"><span class="LinkURL_R">https://www.inchcalculator.com/convert/meter-per-second-to-mile-per-hour/</span><i>.</i></a></p>
</section>
<section aria-labelledby="sec13" epub:type="division">
<h3 class="H2" id="sec13"><span id="h-91"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Accessing Properties</samp></h3>
<p class="TNI">Whenever we access a property, we’re really making a call to a method, either to obtain its value or to set a new one. Both <samp class="SANS_TheSansMonoCd_W5Regular_11">get</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">set</samp> accessors are implemented as hidden methods on a type. By default, <samp class="SANS_TheSansMonoCd_W5Regular_11">set</samp> has a value parameter, and <samp class="SANS_TheSansMonoCd_W5Regular_11">get</samp> returns by value. In either case, therefore, when we access the property, we make a copy of the value. This process is easy to overlook because the syntax for using a property looks like it’s directly getting or setting a field.</p>
<p class="TX">Consider the <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp> property of the <samp class="SANS_TheSansMonoCd_W5Regular_11">Velocity</samp> value type shown in <a href="#list4-18">Listing 4-18</a>.</p>
<pre id="list4-18"><code>public readonly struct Velocity&#13;
{&#13;
    public Velocity(Speed speed, Angle angle)&#13;
        =&gt; (Speed, Direction) = (speed, angle);&#13;
    <b>public Speed Speed {get;}</b>&#13;
    public Angle Direction {get;}&#13;
}</code></pre>
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 4-18: Defining properties of the Velocity struct</samp></p>
<p class="TX">Looking at the compiled CIL for the <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp> property of the <samp class="SANS_TheSansMonoCd_W5Regular_11">Velocity</samp> struct, we see that the property accessor is emitted as a call to the hidden <samp class="SANS_TheSansMonoCd_W5Regular_11">get_Speed</samp> method:</p>
<pre><code><span aria-label=" Page 121. " epub:type="pagebreak" id="pg_121" role="doc-pagebreak"/>.property instance valuetype Speed Speed()&#13;
{&#13;
    .get instance valuetype Speed Velocity::<b>get_Speed</b>()&#13;
} // end of property Velocity::Speed</code></pre>
<p class="TX">Apart from the CIL-specific markers <samp class="SANS_TheSansMonoCd_W5Regular_11">.property</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">instance</samp>, and <samp class="SANS_TheSansMonoCd_W5Regular_11">valuetype</samp>, the call to <samp class="SANS_TheSansMonoCd_W5Regular_11">get_Speed</samp> is a regular method call. The compiler has synthesized the <samp class="SANS_TheSansMonoCd_W5Regular_11">get_Speed</samp> method too, and its signature looks like this in the CIL:</p>
<pre><code>.method public hidebysig specialname instance valuetype Speed&#13;
    <b>get_Speed</b>() cil managed&#13;
{&#13;
    <var>--snip--</var></code></pre>
<p class="TX">If <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp> had a corresponding <samp class="SANS_TheSansMonoCd_W5Regular_11">set</samp> accessor, it would be emitted as a method named <samp class="SANS_TheSansMonoCd_W5Regular_11">set_Speed</samp> that takes a <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp> parameter and returns <samp class="SANS_TheSansMonoCd_W5Regular_11">void</samp>. The CIL markers <samp class="SANS_TheSansMonoCd_W5Regular_11">hidebysig</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">specialname</samp> aren’t used during execution, but they’re used by tools that work with CIL.</p>
<p class="TX">The compiler implements the <samp class="SANS_TheSansMonoCd_W5Regular_11">get_Speed</samp> accessor as a method that takes no parameters and returns a value of <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp> <i>by value</i>. It’s almost exactly as if we’d written our own method returning a <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp> like this:</p>
<pre><code>public Speed get_Speed()&#13;
{&#13;
    // return a Speed value&#13;
}</code></pre>
<p class="TX">The <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp> property’s <samp class="SANS_TheSansMonoCd_W5Regular_11">get</samp> accessor returns a <i>copy</i> of a <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp> instance by value, in exactly the same way as any method returning a <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp> by value.</p>
<p class="TX">It’s easy to mistake using a property or indexer for directly accessing a field, since the method calls injected by the compiler are conveniently hidden. However, it’s important to be aware that accessing a property or indexer calls a method and typically copies values.</p>
<blockquote>
<p class="NOTE"><span class="NoteHead"><samp class="SANS_Dogma_OT_Bold_B_21">NOTE</samp></span></p>
</blockquote>
<p class="NOTE-TXT"><span class="Roman">Indexers</span> <i>are special instance methods that allow an object to be accessed as if it were an array or similar sequence-like object. They’re implemented via methods in the same way as properties.</i></p>
</section>
<section aria-labelledby="sec14" epub:type="division">
<h3 class="H2" id="sec14"><span id="h-92"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Using Expressions with Operators</samp></h3>
<p class="TNI">Expressions with operators, such as <samp class="SANS_TheSansMonoCd_W5Regular_11">+</samp> or <samp class="SANS_TheSansMonoCd_W5Regular_11">==</samp>, often also represent method calls, requiring copies for parameters and return values and perhaps making other copies internally. For example, in <a href="#list4-19">Listing 4-19</a> we add two <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp> values.</p>
<pre id="list4-19"><code>var start = Speed.FromMetersPerSecond(55);&#13;
var increase = Speed.FromMetersPerSecond(15);&#13;
var final = <b>start</b> <b>+</b> <b>increase</b>;</code></pre>
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 4-19: Adding two Speed values</samp></p>
<p class="TX"><span aria-label=" Page 122. " epub:type="pagebreak" id="pg_122" role="doc-pagebreak"/>The method call behind this addition may not be immediately apparent, but a closer look shows that simply adding instances together might represent several copies. <a href="#list4-20">Listing 4-20</a> shows the canonical form of <samp class="SANS_TheSansMonoCd_W5Regular_11">operator+</samp> for adding two <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp> values.</p>
<pre id="list4-20"><code>public static Speed operator+(Speed left, Speed right)&#13;
    =&gt; new Speed(left.InMetersPerSecond + right.InMetersPerSecond);</code></pre>
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 4-20: Defining the addition operator for Speed</samp></p>
<p class="TX">The <samp class="SANS_TheSansMonoCd_W5Regular_11">left</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">right</samp> parameters for <samp class="SANS_TheSansMonoCd_W5Regular_11">operator+</samp> represent one copy each. Conceptually, a copy is also made for the return value, although the compiler is free to optimize that copy away and construct the new <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp> instance directly in the target variable being assigned.</p>
<p class="TX">We might also overload the <samp class="SANS_TheSansMonoCd_W5Regular_11">==</samp> equality operator, comparisons like <samp class="SANS_TheSansMonoCd_W5Regular_11">operator&lt;</samp>, the binary combination operators <samp class="SANS_TheSansMonoCd_W5Regular_11">|</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">&amp;</samp>, and even the truth operators <samp class="SANS_TheSansMonoCd_W5Regular_11">true</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">false</samp>, allowing us to include a variable in a Boolean test expression like <samp class="SANS_TheSansMonoCd_W5Regular_11">if(speed) {…}</samp>. Hopefully, we would <i>not</i> be tempted to overload the truth operators for a type like <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp>.</p>
<p class="TX">All such operator overloads are implemented as static methods for a type, and all take at least one parameter, which is the type to which they belong. That parameter is usually taken by value and thus represents a copy.</p>
<p class="TX">User-defined conversion operators are methods too, and when their parameter or return type is a value type, it is copied by value in the same way. Spotting where an implicit conversion is being invoked can be particularly difficult because the process leaves few syntactic clues in the code. To illustrate, consider the <samp class="SANS_TheSansMonoCd_W5Regular_11">Velocity</samp> type in <a href="#list4-21">Listing 4-21</a>, which defines an implicit conversion from a <samp class="SANS_TheSansMonoCd_W5Regular_11">Velocity</samp> to a <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp>.</p>
<pre id="list4-21"><code>public readonly struct Velocity&#13;
{&#13;
    public Velocity(Speed speed, Angle angle)&#13;
        =&gt; (Speed, Direction) = (speed, angle);&#13;
    public Speed Speed {get;}&#13;
    public Angle Direction {get;}&#13;
    <b>public static implicit operator Speed(Velocity velocity)</b>&#13;
        <b>=&gt;</b> <b>velocity.Speed;</b>&#13;
}</code></pre>
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 4-21: A user-defined implicit conversion</samp></p>
<p class="TX">This conversion operator uses one copy of <samp class="SANS_TheSansMonoCd_W5Regular_11">Velocity</samp> for the parameter, and two copies of <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp>—one to access the property of the <samp class="SANS_TheSansMonoCd_W5Regular_11">velocity</samp> parameter, and another to return the value. As with other methods, the compiler may be able to avoid an explicit copy of the return value. In <a href="#list4-22">Listing 4-22</a>, the <samp class="SANS_TheSansMonoCd_W5Regular_11">DistanceInKm</samp> method takes a <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp> parameter and is called with an instance of <samp class="SANS_TheSansMonoCd_W5Regular_11">Velocity</samp>, rather than the <samp class="SANS_TheSansMonoCd_W5Regular_11">velocity.Speed</samp> property.</p>
<pre id="list4-22"><code><span aria-label=" Page 123. " epub:type="pagebreak" id="pg_123" role="doc-pagebreak"/>public double <b>DistanceInKm(Speed speed, TimeSpan elapsed)</b>&#13;
    =&gt; speed.InMetersPerSecond / 1000 * elapsed.TotalSeconds;&#13;
var velocity = new Velocity(initial, direction);&#13;
var distance = <b>DistanceInKm(velocity, TimeSpan.FromHours(2));</b></code></pre>
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 4-22: Using an implicit conversion to pass an argument</samp></p>
<p class="TX">Although this looks to be a regular call to the <samp class="SANS_TheSansMonoCd_W5Regular_11">DistanceInKm</samp> method, the <samp class="SANS_TheSansMonoCd_W5Regular_11">velocity</samp> argument first needs to be converted to a <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp>. Our type conversion operator makes this possible, and since we made the conversion implicit, the compiler simply inserts the call to that operator when we call <samp class="SANS_TheSansMonoCd_W5Regular_11">DistanceInKm</samp>, copying the <samp class="SANS_TheSansMonoCd_W5Regular_11">Velocity</samp> argument and <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp> return value in the process.</p>
<p class="TX">Type conversions need to be used wisely. They can hide all sorts of complexity, quite apart from the copies they usually represent. Implicit conversions happen invisibly by design, leaving only subtle clues in code that employs them, such as in method calls like <samp class="SANS_TheSansMonoCd_W5Regular_11">DistanceInKm</samp> in <a href="#list4-22">Listing 4-22</a>. Explicit user-defined conversions are syntactically more obvious in the code that uses them, but it’s still easy to overlook that they, too, represent a call to a method.</p>
<p class="TX">When a method returns a variable by reference—which we first examined in <span class="Xref"><a href="chapter3.xhtml">Chapter 3</a></span>—we can use that by-reference variable to directly alter the underlying variable, provided neither is read-only. However, remember that ref returns are an optimization feature and shouldn’t be introduced indiscriminately.</p>
<p class="TX">All other non-<samp class="SANS_TheSansMonoCd_W5Regular_11">void</samp> methods produce values, not variables, meaning we can’t assign to the result directly. If we forget this and misuse a return value, it can result in surprising behavior.</p>
</section>
</section>
<section aria-labelledby="sec15" epub:type="division">
<h2 class="H1" id="sec15"><span id="h-93"/><samp class="SANS_Futura_Std_Bold_B_11">Modifying Return Type Instances</samp></h2>
<p class="TNI">You saw in <span class="Xref"><a href="chapter2.xhtml">Chapter 2</a></span> that a variable can be assigned to, but a value can’t. Values are the result of expressions, including method calls, and are immutable. We can’t directly modify the value returned from any method.</p>
<p class="TX">One common source of confusion is that value type instances and reference type instances have different behavior in this regard: if the method returns a reference to a mutable type, we can use the returned reference to directly modify the instance in memory, but we can’t modify a mutable value type instance unless we first copy the returned value to a variable. Understanding how value types differ from reference types in this respect will help us avoid some common hazards and better appreciate the best practice of making all value types immutable.</p>
<p class="TX">When a return value is a value type instance, we can’t use it to set property values or change any of the value’s public fields. We must assign that value to a variable before we can change it. To demonstrate, <a href="#list4-23">Listing 4-23</a> <span aria-label=" Page 124. " epub:type="pagebreak" id="pg_124" role="doc-pagebreak"/>shows a struct with an intentionally mutable <samp class="SANS_TheSansMonoCd_W5Regular_11">InMetersPerSecond</samp> property and a static class factory method named <samp class="SANS_TheSansMonoCd_W5Regular_11">FromKmh</samp>.</p>
<pre id="list4-23"><code>public struct Speed&#13;
{&#13;
    public double InMetersPerSecond {get; set;}&#13;
    public static Speed FromKmh(double val)&#13;
        =&gt; new Speed(val * 1000 / 3600);&#13;
    private Speed(double ms) =&gt; InMetersPerSecond = ms;&#13;
}&#13;
<b>Speed.FromKmh(70).InMetersPerSecond</b> <b>=</b> <b>15.2;</b></code></pre>
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 4-23: Attempting to modify the return value of FromKmh</samp></p>
<p class="TX">On the last line, we attempt to set a value for the <samp class="SANS_TheSansMonoCd_W5Regular_11">InMetersPerSecond</samp> property of the value returned from the static method, which gives us a compilation error:</p>
<pre><code>[CS1612] Cannot modify the return value of 'Speed.FromKmh(double)' because it is not a variable</code></pre>
<p class="TX">This example fails to compile because the <samp class="SANS_TheSansMonoCd_W5Regular_11">FromKmh</samp> method returns a <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp> <i>value</i>. The compiler rejects any modifications to the value, even though the <samp class="SANS_TheSansMonoCd_W5Regular_11">InMetersPerSecond</samp> property has a public <samp class="SANS_TheSansMonoCd_W5Regular_11">set</samp> accessor.</p>
<blockquote>
<p class="NOTE"><span class="NoteHead"><samp class="SANS_Dogma_OT_Bold_B_21">NOTE</samp></span></p>
</blockquote>
<p class="NOTE-TXT"><i>C</i><span class="symbol">++</span> <i>programmers would refer to the returned value as an rvalue.</i></p>
<p class="TX">If modifications to a return value were permitted, they would be made on a temporary instance introduced by the compiler to capture the value returned by the method. The lifetime of the <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp> instance created in the <samp class="SANS_TheSansMonoCd_W5Regular_11">FromKmh</samp> method in <a href="#list4-23">Listing 4-23</a> ends when the method returns, so the return value needs to be stored somewhere—namely, in a hidden copy of the instance.</p>
<p class="TX">In any case, we would normally assign the <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp> value returned by <samp class="SANS_TheSansMonoCd_W5Regular_11">FromKmh</samp> to another variable. We are permitted to modify the <samp class="SANS_TheSansMonoCd_W5Regular_11">InMetersPerSecond</samp> property of the target <i>variable</i> because <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp> has a public <samp class="SANS_TheSansMonoCd_W5Regular_11">set</samp> accessor, as shown here:</p>
<pre><code>var start = Speed.FromKmh(70);&#13;
start.InMetersPerSecond = 15.2;</code></pre>
<p class="TX">The prohibition against modifying a returned value is not specific to properties; it also applies if we try to modify a public field on the return value. The compiler prevents such modifications because the return value from a method isn’t a variable. However, as you’ve already seen, several parts of code don’t look like methods but are represented in the compiled code as methods. This restriction on modifying return values applies equally to them because they also produce temporary copies.</p>
<section aria-labelledby="sec16" epub:type="division">
<h3 class="H2" id="sec16"><span id="h-94"/><span aria-label=" Page 125. " epub:type="pagebreak" id="pg_125" role="doc-pagebreak"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Reference Type Properties</samp></h3>
<p class="TNI">If the value returned from a method—or property, indexer, or operator—is a reference, we can modify the instance referred to because the temporary copy of the value is another reference to that same instance. We can therefore use the returned reference to set publicly mutable properties, although we can’t change the value of the reference itself by assigning it to refer to a different object.</p>
<p class="TX">Consider <a href="#list4-24">Listing 4-24</a>, which uses the value returned from the <samp class="SANS_TheSansMonoCd_W5Regular_11">Data</samp> method to set a property of a reference type instance.</p>
<pre id="list4-24"><code>public class ReadBuffer&#13;
{&#13;
    public StringBuilder Data()&#13;
        =&gt; buffer;&#13;
    private readonly StringBuilder buffer = new();&#13;
}&#13;
var buffer = new ReadBuffer();&#13;
<b>buffer.Data().Capacity</b> <b>=</b> <b>128;</b></code></pre>
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 4-24: Setting a reference type property</samp></p>
<p class="TX">The <samp class="SANS_TheSansMonoCd_W5Regular_11">StringBuilder</samp> type is a class with a publicly writable <samp class="SANS_TheSansMonoCd_W5Regular_11">Capacity</samp> property. The value returned from <samp class="SANS_TheSansMonoCd_W5Regular_11">ReadBuffer.Data</samp> is a reference to the <samp class="SANS_TheSansMonoCd_W5Regular_11">StringBuilder</samp> instance stored as a field of <samp class="SANS_TheSansMonoCd_W5Regular_11">ReadBuffer</samp>. Therefore, we can use the reference returned from the <samp class="SANS_TheSansMonoCd_W5Regular_11">Data</samp> method to set the <samp class="SANS_TheSansMonoCd_W5Regular_11">Capacity</samp> of the instance stored as a field of <samp class="SANS_TheSansMonoCd_W5Regular_11">buffer</samp>.</p>
<p class="TX">We can’t assign that reference to a new instance of <samp class="SANS_TheSansMonoCd_W5Regular_11">StringBuilder</samp>, however, as that would be changing the value being returned, not the instance:</p>
<pre><code>buffer.Data() = new StringBuilder();</code></pre>
<p class="TX">This fails to compile because we’re attempting to assign to a value, not a variable:</p>
<pre><code>[CS0131] The left-hand side of an assignment must be a variable, property or indexer</code></pre>
<p class="TX">The difference in behavior between methods returning references and those returning value type instances is one of the reasons it’s recommended to make all value types immutable. By doing so, we remove any confusion over where a value type instance can be modified, because it can’t be modified by anything. When we attempt to modify a returned value, our code fails to compile. When the value is a value type instance, the failure to compile is a good thing: if the modification were permitted, we wouldn’t be changing the instance we might think we were changing. Unless a value type is truly immutable, preferably by being a read-only struct or read-only <span aria-label=" Page 126. " epub:type="pagebreak" id="pg_126" role="doc-pagebreak"/>record struct, an instance can still be modified by its instance methods, even when it’s a hidden copy.</p>
</section>
<section aria-labelledby="sec17" epub:type="division">
<h3 class="H2" id="sec17"><span id="h-95"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Instance Methods and Mutability</samp></h3>
<p class="TNI">Although we can’t set the value of a property on a returned value type instance, we can call methods on that instance. If the type has non-read-only fields, or properties with a <samp class="SANS_TheSansMonoCd_W5Regular_11">set</samp> accessor, the method we call can mutate the instance. In this next example, we have a mutable <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp> struct with a <samp class="SANS_TheSansMonoCd_W5Regular_11">Reset</samp> method that changes the value of the <samp class="SANS_TheSansMonoCd_W5Regular_11">InMetersPerSecond</samp> property:</p>
<pre><code>public struct Speed&#13;
{&#13;
    public double InMetersPerSecond {get; set;}&#13;
    <b>public void Reset()</b> <b>=&gt;</b> <b>InMetersPerSecond</b> <b>=</b> <b>0;</b>&#13;
    <var>--snip--</var>&#13;
}</code></pre>
<p class="TX">The <samp class="SANS_TheSansMonoCd_W5Regular_11">Reset</samp> method can be called on any <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp> value, including one returned from a method or property. In <a href="#list4-25">Listing 4-25</a>, we use the value of the <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp> property of a <samp class="SANS_TheSansMonoCd_W5Regular_11">Velocity</samp> object to call <samp class="SANS_TheSansMonoCd_W5Regular_11">Reset</samp>.</p>
<pre id="list4-25"><code>var velocity = new Velocity(Speed.FromKmh(55), Angle.FromDegrees(45));&#13;
<b>velocity.Speed.Reset();</b>&#13;
Assert.That(velocity.Speed.InMetersPerSecond, Is.EqualTo(0));</code></pre>
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 4-25: Calling the Reset method on the value returned by Velocity’s Speed property</samp></p>
<p class="TX">When we call <samp class="SANS_TheSansMonoCd_W5Regular_11">Reset</samp> on <samp class="SANS_TheSansMonoCd_W5Regular_11">velocity.Speed</samp>, we might be tempted to think we’ve changed the value stored in the <samp class="SANS_TheSansMonoCd_W5Regular_11">velocity</samp> variable, but <samp class="SANS_TheSansMonoCd_W5Regular_11">velocity</samp> doesn’t change here, and the test fails, because the <samp class="SANS_TheSansMonoCd_W5Regular_11">Reset</samp> method mutates only the instance used to call it. The instance returned from the <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp> property is a temporary value. Recall from <a href="#list4-23">Listing 4-23</a> that we can’t use the value to directly set the <samp class="SANS_TheSansMonoCd_W5Regular_11">InMetersPerSecond</samp> property, but we can change that property via an instance method of <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp>.</p>
<p class="TX">We can mutate a value obtained from an indexer in a similar way, and we can just as easily overlook that only the hidden copy gets altered. Consider <a href="#list4-26">Listing 4-26</a>, which calls a method on the value returned from the <samp class="SANS_TheSansMonoCd_W5Regular_11">Journey</samp> type’s indexer.</p>
<pre id="list4-26"><code>public class Journey&#13;
{&#13;
    <var>--snip--</var>&#13;
    public Velocity this[int idx]&#13;
    {&#13;
        get =&gt; legs[idx];<span aria-label=" Page 127. " epub:type="pagebreak" id="pg_127" role="doc-pagebreak"/>&#13;
        set =&gt; legs[idx] = value;&#13;
  }&#13;
    private List&lt;Velocity&gt; legs = new List&lt;Velocity&gt;();&#13;
}&#13;
<b>journey[0].Speed.Reset();</b></code></pre>
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 4-26: Calling a method on the value returned by Journey’s indexer</samp></p>
<p class="TX">An indexer is implemented as a method, in the same way as a property, and has precisely the same behavior. Again, it’s easy to forget that properties are not variables, especially when they’re value type instances. The compiler can’t prevent us from calling a method on a returned value, because it’s a perfectly reasonable thing to want to do. The only way to prevent this erroneous behavior is to make <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp> an immutable type, thereby disallowing any mutating methods entirely. This is another good reason to make all value types immutable.</p>
</section>
<section aria-labelledby="sec18" epub:type="division">
<h3 class="H2" id="sec18"><span id="h-96"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Properties as Arguments for Read-Only Parameters</samp></h3>
<p class="TNI">Another consequence of method returns being values rather than variables is that they can’t be directly passed as arguments for <samp class="SANS_TheSansMonoCd_W5Regular_11">ref</samp> or <samp class="SANS_TheSansMonoCd_W5Regular_11">out</samp> parameters. As you saw in <span class="Xref"><a href="chapter3.xhtml">Chapter 3</a></span>, by-reference parameters receive the address of their arguments, but only variables have addresses. If we first assign a method return or property result to a variable, we can pass the variable by reference.</p>
<p class="TX"><span class="Xref"><a href="chapter3.xhtml">Chapter 3</a></span> also explained that an <samp class="SANS_TheSansMonoCd_W5Regular_11">in</samp> parameter is an immutable by- reference variable. Although <samp class="SANS_TheSansMonoCd_W5Regular_11">in</samp> parameters take the address of their argument in exactly the same way that <samp class="SANS_TheSansMonoCd_W5Regular_11">ref</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">out</samp> parameters do, they’re designed to behave as if they’re value parameters. The compiler therefore allows us to pass a nonvariable as an argument for an <samp class="SANS_TheSansMonoCd_W5Regular_11">in</samp> parameter but copies the value to a hidden variable, and it’s that variable’s address that’s passed.</p>
<p class="TX"><a href="#list4-27">Listing 4-27</a> defines a <samp class="SANS_TheSansMonoCd_W5Regular_11">BallisticRange</samp> method with two <samp class="SANS_TheSansMonoCd_W5Regular_11">in</samp> parameters, and calls it using the <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">Direction</samp> properties of a <samp class="SANS_TheSansMonoCd_W5Regular_11">Velocity</samp> type.</p>
<pre id="list4-27"><code>public static double BallisticRange(<samp class="SANS_TheSansMonoCd_W7Bold_B_11">in Speed initialSpeed, in Angle initialDirection</samp>)&#13;
{&#13;
    const double Gravity = 9.81;&#13;
    return initialSpeed.InMetersPerSecond * initialSpeed.InMetersPerSecond *&#13;
            Math.Sin(initialDirection.InRadians * 2) / Gravity;&#13;
}&#13;
public readonly struct Velocity&#13;
{&#13;
    public Velocity(Speed speed, Angle angle)&#13;
        =&gt; (Speed, Direction) = (speed, angle);&#13;
<span aria-label=" Page 128. " epub:type="pagebreak" id="pg_128" role="doc-pagebreak"/>&#13;
    public Speed Speed {get;}&#13;
    public Angle Direction {get;}&#13;
}&#13;
var velocity = new Velocity(Speed.FromMetersPerSecond(55),&#13;
                            Angle.FromRadians(0.78));&#13;
<b>var distance</b> <b>=</b> <b>BallisticRange(velocity.Speed, velocity.Direction);</b></code></pre>
<p class="CodeListingCaptionWide"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 4-27: Passing properties as in arguments</samp></p>
<p class="TX">Recall that, unlike with <samp class="SANS_TheSansMonoCd_W5Regular_11">ref</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">out</samp> arguments, we don’t need to modify the arguments passed for <samp class="SANS_TheSansMonoCd_W5Regular_11">in</samp> parameters with the <samp class="SANS_TheSansMonoCd_W5Regular_11">in</samp> keyword.</p>
<p class="TX">Here, the compiler takes copies of the values it has obtained from <samp class="SANS_TheSansMonoCd_W5Regular_11">velocity.Speed</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">velocity.Direction</samp> and passes references to those copies to the <samp class="SANS_TheSansMonoCd_W5Regular_11">BallisticRange</samp> method’s <samp class="SANS_TheSansMonoCd_W5Regular_11">in</samp> parameters. It’s as if we’d written this:</p>
<pre><code>var __temp_Speed = velocity.Speed;&#13;
var __temp_Angle = velocity.Direction;&#13;
var distance = BallisticRange(in __temp_Speed, in __temp_Angle);</code></pre>
<p class="TX">The <samp class="SANS_TheSansMonoCd_W5Regular_11">__temp_Speed</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">__temp_Angle</samp> copies are made because accessing a property’s <samp class="SANS_TheSansMonoCd_W5Regular_11">get</samp> accessor produces a value, not a variable. Passing an argument by reference effectively requires the compiler to take its address in memory, but only variables have addresses. The <samp class="SANS_TheSansMonoCd_W5Regular_11">get</samp> accessor returns a temporary value that needs to be either assigned to a variable so its address can be taken or passed to a value parameter, which makes a copy of the value. Although <samp class="SANS_TheSansMonoCd_W5Regular_11">in</samp> parameters can help reduce the number of copies our applications make, we see their benefits only when we’re passing variables as arguments.</p>
<p class="TX">A hidden copy is also made for other expressions that are not variables, such as constants and value type method return values. These copies are made only for the read-only <samp class="SANS_TheSansMonoCd_W5Regular_11">in</samp> parameters. If we try to pass a property value or other nonvariable to a <samp class="SANS_TheSansMonoCd_W5Regular_11">ref</samp> or <samp class="SANS_TheSansMonoCd_W5Regular_11">out</samp> parameter, the compiler simply rejects our code. Such <i>mutable</i> reference variables are intended to be modified by the called method, and those modifications would be illegal on a constant or the temporary value returned by a <samp class="SANS_TheSansMonoCd_W5Regular_11">get</samp> accessor.</p>
</section>
</section>
<section aria-labelledby="sec19" epub:type="division">
<h2 class="H1" id="sec19"><span id="h-97"/><samp class="SANS_Futura_Std_Bold_B_11">Defensive Copies</samp></h2>
<p class="TNI">Whenever the compiler requires a read-only variable but can’t guarantee that its value will never change, the compiler will make a <i>defensive copy</i>. As a result, any change, however inadvertent, is made to the hidden copy and not the visible variable, so the change can’t be observed.</p>
<p class="TX">You saw one example of the compiler making a defensive copy of a value type instance in <a href="#list4-8">Listing 4-8</a>, where constructing a value type with arguments makes a hidden temporary instance, and then the compiler copies it to the target variable when the constructor has completed. This process protects an existing value from any exceptions that may occur inside the constructor body. If an exception occurs, the original value remains intact.</p>
<p class="TX"><span aria-label=" Page 129. " epub:type="pagebreak" id="pg_129" role="doc-pagebreak"/>The compiler may also make a defensive copy of a value type instance to protect a read-only variable from modifications.</p>
<p class="TX">Defensive copies aren’t required for references because the compiler can always detect a change to the value of a reference. If a reference variable is read-only, any attempt to assign a new reference to it fails to compile. Whether or not the instance being referred to is immutable makes no difference here; if we require the instance to be read-only, it’s up to us to ensure that it doesn’t change. The value of a value type variable is the instance, and a mutable value can be changed by its instance methods, so the compiler may introduce a defensive copy when we call those methods if the variable is supposed to be read-only.</p>
<section aria-labelledby="sec20" epub:type="division">
<h3 class="H2" id="sec20"><span id="h-98"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Mutable Value Types and in Parameters</samp></h3>
<p class="TNI">In <span class="Xref"><a href="chapter3.xhtml">Chapter 3</a></span>, you saw how to use the <samp class="SANS_TheSansMonoCd_W5Regular_11">in</samp> modifier for a method parameter to avoid copying the argument if the method’s implementation won’t modify the corresponding parameter variable’s value. However, unless the compiler can guarantee that even inadvertent changes to the parameter values aren’t possible, it will make defensive copies of those values.</p>
<p class="TX"><a href="#list4-27">Listing 4-27</a> showed the <samp class="SANS_TheSansMonoCd_W5Regular_11">BallisticRange</samp> method, which has two read-only reference parameters, <samp class="SANS_TheSansMonoCd_W5Regular_11">initialSpeed</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">initialDirection</samp>. The method implementation uses properties of those parameter variables (<samp class="SANS_TheSansMonoCd_W5Regular_11">InMetersPerSecond</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">InRadians</samp>, respectively) to calculate its return value. If the types of those properties aren’t explicitly immutable, the compiler will make defensive copies of their values to guarantee the read-only characteristics of the <samp class="SANS_TheSansMonoCd_W5Regular_11">in</samp> parameters. The <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">Angle</samp> struct types used by <samp class="SANS_TheSansMonoCd_W5Regular_11">BallisticRange</samp> are shown in <a href="#list4-28">Listing 4-28</a>. Neither type’s properties are mutable, but note that the types themselves aren’t marked <samp class="SANS_TheSansMonoCd_W5Regular_11">readonly</samp>.</p>
<pre id="list4-28"><code>public struct Speed&#13;
{&#13;
      <var>--snip--</var>&#13;
    public double InMetersPerSecond =&gt; amount;&#13;
    private readonly double amount;&#13;
}&#13;
public struct Angle&#13;
{&#13;
    public double InRadians {get;}&#13;
      <var>--snip--</var>&#13;
}&#13;
public static double BallisticRange(in Speed initialSpeed, in Angle initialDirection)&#13;
{&#13;
    const double Gravity = 9.81;&#13;
    return initialSpeed.InMetersPerSecond * initialSpeed.InMetersPerSecond *&#13;
            Math.Sin(initialDirection.InRadians * 2) / Gravity;&#13;
}</code></pre>
<p class="CodeListingCaptionWide"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 4-28: Using in parameter properties for the BallisticRange method</samp></p>
<p class="TX"><span aria-label=" Page 130. " epub:type="pagebreak" id="pg_130" role="doc-pagebreak"/>Within <samp class="SANS_TheSansMonoCd_W5Regular_11">BallisticRange</samp>, the compiler makes a copy of the <samp class="SANS_TheSansMonoCd_W5Regular_11">initial</samp> parameter for each use of the <samp class="SANS_TheSansMonoCd_W5Regular_11">initialspeed.InMetersPerSecond</samp> property (so two copies in all), even though there’s no attempt to modify the <samp class="SANS_TheSansMonoCd_W5Regular_11">initialSpeed</samp> parameter variable in <samp class="SANS_TheSansMonoCd_W5Regular_11">BallisticRange</samp>. The <samp class="SANS_TheSansMonoCd_W5Regular_11">initialDirection</samp> parameter, on the other hand, isn’t copied when its <samp class="SANS_TheSansMonoCd_W5Regular_11">InRadians</samp> property is accessed, although, like <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp>, the <samp class="SANS_TheSansMonoCd_W5Regular_11">Angle</samp> struct isn’t a read-only type.</p>
<p class="TX">To determine why the <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp> parameter is copied, but the <samp class="SANS_TheSansMonoCd_W5Regular_11">Angle</samp> parameter is not, we need to understand what the compiler provides and what assumptions it makes.</p>
</section>
<section aria-labelledby="sec21" epub:type="division">
<h3 class="H2" id="sec21"><span id="h-99"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Automatic vs. Nonautomatic Properties</samp></h3>
<p class="TNI">Although the properties of both the <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">Angle</samp> types in <a href="#list4-28">Listing 4-28</a> are <samp class="SANS_TheSansMonoCd_W5Regular_11">get</samp>-only, they differ in the way they’re implemented. The <samp class="SANS_TheSansMonoCd_W5Regular_11">InRadians</samp> property of <samp class="SANS_TheSansMonoCd_W5Regular_11">Angle</samp> is an <i>automatic property</i>, meaning the compiler introduces a hidden backing field for it and generates the implementation of the <samp class="SANS_TheSansMonoCd_W5Regular_11">get</samp> accessor to obtain the field’s value. If we had also specified a <samp class="SANS_TheSansMonoCd_W5Regular_11">set</samp> accessor for <samp class="SANS_TheSansMonoCd_W5Regular_11">InRadians</samp>, the compiler would generate the corresponding implementation to set the backing field’s value.</p>
<p class="TX">By contrast, the <samp class="SANS_TheSansMonoCd_W5Regular_11">InMetersPerSecond</samp> property of <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp> is an <i>expression-bodied property</i>, meaning it returns the value of an explicitly declared private field. An expression-bodied property is equivalent to a <i>nonautomatic</i> property with no <samp class="SANS_TheSansMonoCd_W5Regular_11">set</samp> accessor, like this:</p>
<pre><code>public double InMetersPerSecond&#13;
{&#13;
    get {return amount;}&#13;
}</code></pre>
<p class="TX">We’d normally understand this to be a read-only property, since we can’t usually change the value of a property with no <samp class="SANS_TheSansMonoCd_W5Regular_11">set</samp> accessor. However, C# has no rule that says <samp class="SANS_TheSansMonoCd_W5Regular_11">get</samp> accessors <i>can’t</i> modify the fields of a type; it’s merely a convention. Within <samp class="SANS_TheSansMonoCd_W5Regular_11">BallisticRange</samp>, the <samp class="SANS_TheSansMonoCd_W5Regular_11">InMetersPerSecond</samp> property is accessed via an immutable reference; if the <samp class="SANS_TheSansMonoCd_W5Regular_11">get</samp> accessor did indeed modify the value of the parameter, that change would be visible outside the <samp class="SANS_TheSansMonoCd_W5Regular_11">BallisticRange</samp> method because the argument was passed by reference.</p>
<p class="TX">If the parameter variable is supposed to be immutable, as with <samp class="SANS_TheSansMonoCd_W5Regular_11">in</samp> parameters, the compiler must satisfy itself that using the variable in any way won’t change its value. Without this guarantee, the compiler makes defensive copies of the value everywhere the parameter is used to access a property or call a method. If the method or property <i>did</i> mutate the value, only the hidden copy would be affected. The change would never be observable outside the <samp class="SANS_TheSansMonoCd_W5Regular_11">BallisticRange</samp> method via the argument passed to the method’s parameter.</p>
<p class="TX">The <samp class="SANS_TheSansMonoCd_W5Regular_11">InRadians</samp> property of <samp class="SANS_TheSansMonoCd_W5Regular_11">Angle</samp> in <a href="#list4-28">Listing 4-28</a> is also <samp class="SANS_TheSansMonoCd_W5Regular_11">get</samp>-only, but because it’s an automatic property, the compiler adds a special attribute to the <samp class="SANS_TheSansMonoCd_W5Regular_11">get</samp> accessor method to indicate that it’s a read-only implementation. <a href="#list4-29">Listing 4-29</a> shows the generated CIL for the <samp class="SANS_TheSansMonoCd_W5Regular_11">get_InRadians</samp> method.</p>
<pre id="list4-29"><code><span aria-label=" Page 131. " epub:type="pagebreak" id="pg_131" role="doc-pagebreak"/>.method public hidebysig specialname instance float64&#13;
get_InRadians() cil managed&#13;
{&#13;
  .custom instance void [System.Runtime]&#13;
          <b>System.Runtime.CompilerServices.IsReadOnlyAttribute</b>::.ctor()&#13;
   = (01 00 00 00)&#13;
--<var>snip--</var></code></pre>
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 4-29: A read-only automatic property</samp></p>
<p class="TX">The compiler adds the <samp class="SANS_TheSansMonoCd_W5Regular_11">IsReadOnlyAttribute</samp> indicator for automatic properties in the compiled code and can check for the presence of the attribute cheaply, even when the type of the parameter is declared in a different compiled assembly. In a positional record struct, the compiler generates the properties for the parameters given to the type. The <samp class="SANS_TheSansMonoCd_W5Regular_11">get</samp> accessors of those generated properties also have <samp class="SANS_TheSansMonoCd_W5Regular_11">IsReadOnlyAttribute</samp> applied.</p>
<p class="TX">When we use an <samp class="SANS_TheSansMonoCd_W5Regular_11">in</samp> parameter variable to call methods or access property values, the compiler checks those methods and properties. If this attribute is present, the compiler knows it can avoid making defensive copies.</p>
</section>
<section aria-labelledby="sec22" epub:type="division">
<h3 class="H2" id="sec22"><span id="h-100"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Read-Only Reference Variables</samp></h3>
<p class="TNI">Defensive copies are also required when we use read-only local reference variables, unless the compiler is satisfied that accessing the variable can’t change its value. We explored in <span class="Xref"><a href="chapter3.xhtml">Chapter 3</a></span> how local reference variables are used in cooperation with reference return values.</p>
<p class="TX">A method or property of a class or a record—but not a struct or record struct—can return an instance field by reference. If we return a value by reference, no copy of the value is made. Making it read-only ensures that the value can’t be modified using that reference. For example, the <samp class="SANS_TheSansMonoCd_W5Regular_11">Projectile</samp> class in <a href="#list4-30">Listing 4-30</a> has properties that return instance fields by reference.</p>
<pre id="list4-30"><code>public sealed class Projectile&#13;
{&#13;
    public Projectile(Speed speed, Angle angle)&#13;
        =&gt; (initial, direction) = (speed, angle);&#13;
    <b>public ref readonly Speed Speed</b> <b>=&gt;</b> <b>ref initialSpeed;</b>&#13;
    <b>public ref readonly Angle Angle</b> <b>=&gt;</b> <b>ref initialDirection;</b>&#13;
    private readonly Speed initialSpeed;&#13;
    private readonly Angle initialDirection;&#13;
}</code></pre>
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 4-30: Defining ref return values for the Projectile class</samp></p>
<p class="TX">The references returned by these <samp class="SANS_TheSansMonoCd_W5Regular_11">Angle</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp> properties can never outlive the <samp class="SANS_TheSansMonoCd_W5Regular_11">Projectile</samp> instance because <samp class="SANS_TheSansMonoCd_W5Regular_11">Projectile</samp> is a class, so its instances are allocated on the heap and their lifetimes are governed by the garbage collector. Value types are not permitted to return their fields by reference because the instance’s lifetime might end before any reference to its internals.</p>
<p class="TX"><span aria-label=" Page 132. " epub:type="pagebreak" id="pg_132" role="doc-pagebreak"/>With <samp class="SANS_TheSansMonoCd_W5Regular_11">ref readonly</samp> properties, we would usually also capture the returned reference in a local read-only reference variable, also called a <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">ref readonly</samp> <i>local</i>. In the following code, we use <samp class="SANS_TheSansMonoCd_W5Regular_11">ref readonly</samp> locals to receive the references returned from the properties of <samp class="SANS_TheSansMonoCd_W5Regular_11">Projectile</samp> from <a href="#list4-30">Listing 4-30</a>:</p>
<pre><code>var dart = new Projectile(initial, direction);&#13;
<b>ref readonly var speed</b> <b>=</b> <b>ref dart.Speed;</b>&#13;
<b>ref readonly var angle</b> <b>=</b> <b>ref dart.Angle;</b>&#13;
var kmh = speed.InMetersPerSecond;&#13;
var degrees = angle.InRadians;</code></pre>
<p class="TX">Because the properties of <samp class="SANS_TheSansMonoCd_W5Regular_11">Projectile</samp> return read-only references, we must assign them to read-only reference variables, or explicitly copy their value by omitting the <samp class="SANS_TheSansMonoCd_W5Regular_11">ref</samp> keyword altogether on the target variables.</p>
<p class="TX">A read-only reference variable must be guaranteed to be immutable in the same way as an <samp class="SANS_TheSansMonoCd_W5Regular_11">in</samp> parameter. The compiler therefore makes a defensive copy of the <samp class="SANS_TheSansMonoCd_W5Regular_11">speed</samp> variable when we later use its <samp class="SANS_TheSansMonoCd_W5Regular_11">InMetersPerSecond</samp> property, in case that property mutates the value.</p>
<p class="TX">The <samp class="SANS_TheSansMonoCd_W5Regular_11">InRadians</samp> property of <samp class="SANS_TheSansMonoCd_W5Regular_11">Angle</samp>, being an automatic property, has the <samp class="SANS_TheSansMonoCd_W5Regular_11">IsReadOnlyAttribute</samp> indicator, so the compiler doesn’t require a copy of the <samp class="SANS_TheSansMonoCd_W5Regular_11">angle</samp> variable. If we manually copy the value of a <samp class="SANS_TheSansMonoCd_W5Regular_11">ref</samp> return, there’s no danger of <samp class="SANS_TheSansMonoCd_W5Regular_11">Projectile</samp>’s read-only field being changed via that variable, so the compiler doesn’t introduce an additional copy in that case.</p>
</section>
<section aria-labelledby="sec23" epub:type="division">
<h3 class="H2" id="sec23"><span id="h-101"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Read-Only Fields</samp></h3>
<p class="TNI">Each access to a property of a read-only field will produce a defensive copy, unless the compiler is satisfied that the property doesn’t change its instance. The same is true when we call an instance method of a read-only field.</p>
<p class="TX">In <a href="#list4-31">Listing 4-31</a>, we make the <samp class="SANS_TheSansMonoCd_W5Regular_11">BallisticRange</samp> method from <a href="#list4-28">Listing 4-28</a> an instance member of the <samp class="SANS_TheSansMonoCd_W5Regular_11">Projectile</samp> class and alter its implementation to use instance fields of the class instead of taking <samp class="SANS_TheSansMonoCd_W5Regular_11">in</samp> parameters.</p>
<pre id="list4-31"><code>public sealed class Projectile&#13;
{&#13;
    public double BallisticRange()&#13;
    {&#13;
        const double Gravity = 9.81;&#13;
        return initialSpeed.InMetersPerSecond * initialSpeed.InMetersPerSecond *&#13;
               Math.Sin(initialDirection.InRadians * 2) / Gravity;&#13;
    }&#13;
    <b>private readonly Speed initialSpeed;</b>&#13;
    <b>private readonly Angle initialDirection;</b>&#13;
}</code></pre>
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 4-31: Accessing properties of read-only fields of the Projectile class</samp></p>
<p class="TX"><span aria-label=" Page 133. " epub:type="pagebreak" id="pg_133" role="doc-pagebreak"/>The <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">Angle</samp> types are the same as those in <a href="#list4-28">Listing 4-28</a>, but they’re read-only fields rather than parameters. Since read-only fields must be immutable, the compiler makes a defensive copy of the <samp class="SANS_TheSansMonoCd_W5Regular_11">initialSpeed</samp> field’s value for each access to the field’s <samp class="SANS_TheSansMonoCd_W5Regular_11">InMetersPerSecond</samp> property. Using the <samp class="SANS_TheSansMonoCd_W5Regular_11">Angle.InRadians</samp> property doesn’t cause a defensive copy, because it’s an automatic property.</p>
<p class="TX">Interestingly, if we made the fields of <samp class="SANS_TheSansMonoCd_W5Regular_11">Projectile</samp> <i>non</i>-read-only, the compiler would omit the defensive copies. The reason should be clear by now: the defensive copies are required to prevent <i>unwanted</i> modifications to read-only variables from being visible. If the variables are not read-only, allowing them to be altered causes no problems and requires no defensive intervention by the compiler.</p>
<p class="TX">However, making conceptually immutable fields and properties mutable isn’t really a solution. What we’d really like are stronger guarantees of immutability, rather than sacrificing immutability in favor of fewer defensive copies. We can take measures that allow us to use <samp class="SANS_TheSansMonoCd_W5Regular_11">in</samp> parameters, <samp class="SANS_TheSansMonoCd_W5Regular_11">ref</samp> local variables, and read-only fields without incurring the cost of extra defensive copies made by the compiler.</p>
<aside aria-labelledby="box2" class="box">
<h4 class="BH" id="box2"><samp class="SANS_Dogma_OT_Bold_B_11">THE CAUSES OF DEFENSIVE COPIES</samp></h4>
<p class="BTNI"><samp class="SANS_Futura_Std_Book_11">Many caveats exist around read-only references and read-only fields, so if we’re to avoid the potential copies introduced by the compiler, we have a lot to consider. The compiler may introduce defensive copying in several situations, but the rules can be summarized quite simply:</samp></p>
<p class="BTX"><samp class="SANS_Futura_Std_Book_11">For some expression</samp> <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">x</samp><samp class="SANS_TheSansMonoCd_W5Regular_11">.</samp><samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">Y</samp><samp class="SANS_Futura_Std_Book_11">, where</samp> <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">Y</samp> <samp class="SANS_Futura_Std_Book_11">might be a property or a method, the compiler makes a defensive copy of the value of</samp> <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">x</samp> <samp class="SANS_Futura_Std_Book_11">if all of the following are true:</samp></p>
<ul class="BL">
<li class="BBL"><samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">x</samp> <samp class="SANS_Futura_Std_Book_11">is a read-only field, an</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">in</samp> <samp class="SANS_Futura_Std_Book_11">parameter, or a</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">ref readonly</samp> <samp class="SANS_Futura_Std_Book_11">local</samp><samp class="SANS_Futura_Std_Book_Oblique_I_11">.</samp></li>
<li class="BBL"><samp class="SANS_Futura_Std_Book_11">The type of</samp> <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">x</samp> <samp class="SANS_Futura_Std_Book_11">is a non-read-only value type.</samp></li>
<li class="BBL"><samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">Y</samp> <samp class="SANS_Futura_Std_Book_11">is not marked</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">readonly</samp><samp class="SANS_Futura_Std_Book_11">.</samp></li>
</ul>
<p class="BoxBodyCustom2"><samp class="SANS_Futura_Std_Book_11">If</samp> <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">Y</samp> <samp class="SANS_Futura_Std_Book_11">is a field, no defensive copy is needed in any circumstance because just reading a field can’t possibly mutate it. Any attempt to write to</samp> <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">Y</samp> <samp class="SANS_Futura_Std_Book_11">will be caught by the compiler because</samp> <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">x</samp> <samp class="SANS_Futura_Std_Book_11">is read-only. However, avoiding defensive copies isn’t a good reason to expose public fields on structs or record structs, because in doing so we lose all the benefits of encapsulated data. Using the</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">readonly</samp> <samp class="SANS_Futura_Std_Book_11">modifier on the type, or at least the properties and methods, encodes the intent of immutability much more effectively.</samp></p>
</aside>
</section>
</section>
<section aria-labelledby="sec24" epub:type="division">
<h2 class="H1" id="sec24"><span id="h-102"/><samp class="SANS_Futura_Std_Bold_B_11">Defending Against Mutation</samp></h2>
<p class="TNI">We can alter our code in a few ways to avoid the need for defensive copying. In each approach, we provide a guarantee that a method or property never <span aria-label=" Page 134. " epub:type="pagebreak" id="pg_134" role="doc-pagebreak"/>alters the value of an instance, meaning the compiler doesn’t need to make a copy to protect a read-only variable.</p>
<p class="TX">To recap, the following kinds of variables are read-only:</p>
<ul class="BL">
<li class="BL"><samp class="SANS_TheSansMonoCd_W5Regular_11">in</samp> parameters</li>
<li class="BL"><samp class="SANS_TheSansMonoCd_W5Regular_11">ref readonly</samp> local variables</li>
<li class="BL">Read-only fields</li>
</ul>
<p class="TX">When we use read-only value type variables to access a property or call a method, the compiler may require a defensive copy of the value. If the variable’s type is a reference type, there’s no need for a defensive copy, although we must remember that even when a reference variable is read-only, the instance can still be changed. Defensive copies of value type instances are required when the compiler can’t guarantee that the value is immutable.</p>
<p class="TX">One simple way to avoid many defensive copies is to use automatic rather than manually implemented properties. As we’ve discussed, the compiler adds the <samp class="SANS_TheSansMonoCd_W5Regular_11">IsReadOnlyAttribute</samp> marker to the <samp class="SANS_TheSansMonoCd_W5Regular_11">get</samp> accessor of an automatic property to confirm that it doesn’t alter the value in any way. When the property is accessed, the presence of the attribute proves to the compiler that a defensive copy isn’t required.</p>
<p class="TX">However, using automatic properties is not always possible or desirable, such as when we want a common backing field that’s used by several properties, or a property that performs a calculation. Making properties automatic also doesn’t prevent the compiler from making defensive copies when calling methods via a read-only variable. Fortunately, we can employ several alternatives to automatic properties to help avoid defensive copying. Which approach we choose will depend on the specific needs of an application, but in each case we’re explicitly guaranteeing that calling a method or accessing a property can’t alter the state of the instance.</p>
<section aria-labelledby="sec25" epub:type="division">
<h3 class="H2" id="sec25"><span id="h-103"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Read-Only Accessors and Methods</samp></h3>
<p class="TNI">One option for avoiding defensive copies when accessing a nonautomatic property is to add the <samp class="SANS_TheSansMonoCd_W5Regular_11">readonly</samp> modifier to the property, as shown for the <samp class="SANS_TheSansMonoCd_W5Regular_11">InMetersPerSecond</samp> property in <a href="#list4-32">Listing 4-32</a>. For properties that also need a <samp class="SANS_TheSansMonoCd_W5Regular_11">set</samp> accessor, like the <samp class="SANS_TheSansMonoCd_W5Regular_11">InKmh</samp> property shown here, we can use <samp class="SANS_TheSansMonoCd_W5Regular_11">readonly</samp> just for the <samp class="SANS_TheSansMonoCd_W5Regular_11">get</samp> accessor.</p>
<pre id="list4-32"><code>public struct Speed&#13;
{&#13;
    <var>--snip--</var>&#13;
    <b>public readonly double InMetersPerSecond</b> <b>=&gt;</b> <b>amount;</b>&#13;
    public double InKmh&#13;
    {&#13;
        <b>readonly get</b> <b>=&gt;</b> <b>amount / 1000 * 3600;</b><span aria-label=" Page 135. " epub:type="pagebreak" id="pg_135" role="doc-pagebreak"/>&#13;
        private set {amount = value / 3.6;}&#13;
  }&#13;
    private double amount;&#13;
}</code></pre>
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 4-32: Declaring a read-only get accessor</samp></p>
<p class="TX">Note that if we attempt to set a value for the mutable <samp class="SANS_TheSansMonoCd_W5Regular_11">InKmh</samp> property by using a read-only variable, such as an <samp class="SANS_TheSansMonoCd_W5Regular_11">in</samp> parameter, the compiler will give an error message saying that the variable is read-only. Similarly, a read-only property can’t modify instance fields of the type; attempting to do so results in a compiler error.</p>
<p class="TX">Individual instance methods of structs and record structs can also be marked <samp class="SANS_TheSansMonoCd_W5Regular_11">readonly</samp>, as shown here with the <samp class="SANS_TheSansMonoCd_W5Regular_11">Sin</samp> method for our <samp class="SANS_TheSansMonoCd_W5Regular_11">Angle</samp> type:</p>
<pre><code>public struct Angle&#13;
{&#13;
    public readonly double InRadians {get;}&#13;
    <b>public readonly double Sin()</b>&#13;
        =&gt; Math.Sin(InRadians);&#13;
}</code></pre>
<p class="TX">Adding the <samp class="SANS_TheSansMonoCd_W5Regular_11">readonly</samp> modifier for property accessors and methods causes the compiler to annotate the compiled methods with the <samp class="SANS_TheSansMonoCd_W5Regular_11">IsReadOnlyAttribute</samp>, which the compiler can easily check for when the property or method is used with a read-only variable.</p>
</section>
<section aria-labelledby="sec26" epub:type="division">
<h3 class="H2" id="sec26"><span id="h-104"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Read-Only Types</samp></h3>
<p class="TNI">When a struct or record struct doesn’t need to modify its fields or properties, we can make the whole type read-only. <a href="#list4-33">Listing 4-33</a> makes the <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp> struct entirely immutable by adding the <samp class="SANS_TheSansMonoCd_W5Regular_11">readonly</samp> keyword to the type declaration.</p>
<pre id="list4-33"><code><b>public readonly struct Speed</b>&#13;
{&#13;
    public Speed(double amount) =&gt; this.amount = amount;&#13;
    public double InMetersPerSecond =&gt; amount;&#13;
    public double InKmh =&gt; amount / 1000 * 3600;&#13;
    private readonly double amount;&#13;
}</code></pre>
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 4-33: Declaring a read-only struct</samp></p>
<p class="TX">This is the ultimate move in immutability: all fields of a read-only struct must be read-only, and its properties can’t have <samp class="SANS_TheSansMonoCd_W5Regular_11">set</samp> accessors. We don’t need to add the <samp class="SANS_TheSansMonoCd_W5Regular_11">readonly</samp> modifier to the individual properties or any methods of <span aria-label=" Page 136. " epub:type="pagebreak" id="pg_136" role="doc-pagebreak"/><samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp>. The compiler adds the <samp class="SANS_TheSansMonoCd_W5Regular_11">IsReadOnlyAttribute</samp> attribute to every method and property of a read-only type.</p>
<p class="TX">We can avoid almost all defensive copies by making our value types read-only because this provides the strongest possible guarantee to the compiler that its instance methods and properties don’t mutate the value.</p>
<p class="TX">Making a value type read-only isn’t sufficient to avoid <i>all</i> invisible copies the compiler makes. Using a property as an argument to an <samp class="SANS_TheSansMonoCd_W5Regular_11">in</samp> parameter will always copy the property value if it’s a value type. Regardless of the type’s immutability, a property isn’t a variable, so the compiler must copy its value so that a reference to it can be passed to an <samp class="SANS_TheSansMonoCd_W5Regular_11">in</samp> parameter.</p>
<p class="TX">When the compiler determines that a defensive copy is required to protect a value from potential change, the copy is invisible. The purpose of reference parameters, and local reference variables in particular, is to <i>avoid</i> unnecessary copying to make our code more efficient. Defensive copies negate any advantage of passing value type instances by reference. Using the <samp class="SANS_TheSansMonoCd_W5Regular_11">readonly</samp> keyword on all structs and record structs is the most effective way to reduce the need for those invisible copies.</p>
</section>
</section>
<section aria-labelledby="sec27" epub:type="division">
<h2 class="H1" id="sec27"><span id="h-105"/><samp class="SANS_Futura_Std_Bold_B_11">Summary</samp></h2>
<blockquote epub:type="epigraph" role="doc-epigraph">
<p class="EP"><i>The real problem is that programmers have spent far too much time worrying about efficiency in the wrong places and at the wrong times.</i></p>
<footer class="EPS">—Donald E. Knuth, “Computer Programming as an Art,” <i>Communications of the ACM 1974</i></footer></blockquote>
<p class="BodyContinued">Values are copied a lot in most programs—perhaps more than many programmers think. It’s easy, for example, to overlook the fact that when we access a property, we’re making a copy of the value, and the pass-by-value nature of value type instances can make this a hidden cost. Practically every access of a value type instance involves a copy. Some copies are obvious, immediately apparent when we read the code. Other copies are more subtle, and still others are completely invisible and might even be surprising. Whether it’s references or instances that we’re copying, those copies happen frequently, often implicitly, and sometimes unexpectedly.</p>
<p class="TX">It’s widely recommended to make value types small to minimize the cost of copying them. In practice, however, too much emphasis is placed on their size. Making copies of values, even when they’re instances with several fields, is generally inexpensive but may still be costlier than copying a reference.</p>
<p class="TX">We can model values as classes or use records that have value-like behavior to try to alleviate the cost of copies. Knowing when copies occur—and how often—can help us choose between implementing a value as a value type or a reference type. This knowledge can also play an important role in identifying algorithm bottlenecks in existing programs. Minimizing copying is certainly a micro-optimization, however, and whether the cost of copying is significant is something we can judge only by measuring it. We need to weigh the cost of copying value type instances against other penalties, such as the garbage-collection overhead we’d add by introducing a reference type instead.</p>
<p class="TX"><span aria-label=" Page 137. " epub:type="pagebreak" id="pg_137" role="doc-pagebreak"/>Even hidden copies might represent little or no performance impact. In many cases, even if the compiler introduces defensive copies, the just-in-time (JIT) compiler may be able to optimize those copies away. Nevertheless, we can employ some useful techniques to help both the compiler and the JIT compiler maximize performance. We shouldn’t be too careless with copies because memory is a finite resource.</p>
<p class="TX">Making our value types immutable can make our programs more efficient, but doing so has other important benefits. Mutable values can lead to surprising behavior, which in turn leads to errors. If we make our value types immutable by default, we won’t suffer many of the problems associated with unexpected aliasing. We also get the best advantage from the assumptions the compiler makes for truly read-only values. This is not premature optimization—it’s deliberately choosing not to make our programs less efficient.</p>
<p class="TX">Copying values is usually not expensive, unless the instances are exceedingly large. We face many other considerations beyond how performance is affected by copying value type instances. If the behavior we want from a type is best modeled by a value type, we should choose to implement it as a struct or a record struct.</p>
</section>
</section>
</div></body></html>