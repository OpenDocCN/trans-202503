- en: '**11**'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '**11**'
- en: '**WEAPONIZING CAN FINDINGS**'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '**武器化CAN发现**'
- en: '![image](graphics/common-01.jpg)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![image](graphics/common-01.jpg)'
- en: Now that you’re able to explore and identify CAN packets, it’s time to put that
    knowledge to use and learn to hack something. You’ve already used your identified
    packets to perform actions on a car, but unlocking or starting a car using packets
    is recon, rather than actual hacking. The goal of this chapter is to show you
    how to weaponize your findings. In the software world, *weaponize* means “take
    an exploit and make it easy to execute.” When you first find a vulnerability,
    it may take many steps and specific knowledge to successfully pull off the exploit.
    Weaponizing a finding enables you to take your research and put it into a self-contained
    executable.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您可以探索并识别CAN数据包，接下来是时候将这些知识付诸实践，学习如何破解某些东西。您已经使用识别的数据包在车辆上执行了操作，但通过数据包解锁或启动汽车更多的是侦察，而不是实际的黑客攻击。本章的目标是展示如何将您的发现进行武器化。在软件世界中，*武器化*指的是“将一个漏洞变得易于执行。”当您首次发现一个漏洞时，可能需要多个步骤和特定的知识才能成功利用该漏洞。而武器化一个发现则能够让您将研究成果转化为一个独立的可执行文件。
- en: 'In this chapter, we’ll see how to take an action—for example, unlocking a car—and
    put it into Metasploit, a security auditing tool designed to exploit software.
    Metasploit is a popular attack framework often used in penetration testing. It
    has a large database of functional exploits and *payloads*, the code that runs
    once a system has been exploited—for example, once the car has been unlocked.
    You’ll find a wealth of information on Metasploit online and in print, including
    *Metasploit: The Penetration Tester’s Guide* (No Starch Press, 2011).'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: '在本章中，我们将看到如何执行一个操作——例如解锁一辆车——并将其融入Metasploit中，Metasploit是一个设计用来利用软件漏洞的安全审计工具。Metasploit是一个广泛使用的攻击框架，通常用于渗透测试。它拥有一个庞大的功能性漏洞库和*有效载荷*，有效载荷是指系统被攻击后执行的代码——例如，车辆被解锁后执行的代码。您可以在线和印刷版中找到大量关于Metasploit的信息，包括*Metasploit:
    The Penetration Tester’s Guide*（No Starch Press, 2011）。'
- en: In order to weaponize your findings you *will* need to write code. In this chapter,
    we’ll write a Metasploit payload designed to target the architecture of the infotainment
    or telematics system. As our first exercise, we’ll write *shellcode*, the small
    snippet of code that’s injected into an exploit, to create a CAN signal that will
    control a vehicle’s temperature gauge. We’ll include a loop to make sure our spoofed
    CAN signal is continuously sent, with a builtin delay to prevent the bus from
    being flooded with packets that might create an inadvertent denial-of-service
    attack. Next, we’ll write the code to control the temperature gauge. Then, we’ll
    convert that code into shellcode so that we can fine-tune it to make the shellcode
    smaller or reduce NULL values if necessary. When we’re finished, we’ll have a
    payload that we can place into a specialized tool or use with an attack framework
    like Metasploit.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 为了武器化您的发现，您*将*需要编写代码。在本章中，我们将编写一个Metasploit有效载荷，旨在攻击信息娱乐系统或车载通信系统的架构。作为我们的第一个练习，我们将编写*Shellcode*，即注入到漏洞中的小段代码，用于创建一个CAN信号来控制车辆的温度计。我们将包括一个循环，确保伪造的CAN信号持续发送，并内置延迟以防止总线被数据包淹没，避免造成意外的拒绝服务攻击。接下来，我们将编写控制温度计的代码。然后，我们将把这段代码转换为Shellcode，以便我们能够进行微调，使Shellcode变得更小或减少空值（NULL值）。完成后，我们将拥有一个有效载荷，可以将其放入一个专用工具中或与像Metasploit这样的攻击框架一起使用。
- en: '**NOTE**'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*To get the most out of this chapter, you’ll need to have a good understanding
    of programming and programming methodologies. I assume some familiarity with C
    and assembly languages, both x86 and ARM, and the Metasploit framework.*'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: '*为了充分理解本章内容，您需要对编程及编程方法有较好的理解。我假设您对C语言和汇编语言（包括x86和ARM架构）以及Metasploit框架有一定的了解。*'
- en: '**Writing the Exploit in C**'
  id: totrans-8
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**用C语言编写漏洞代码**'
- en: We’ll write the exploit for this spoofed CAN signal in C because C compiles
    to fairly clean assembly that we can reference to make our shellcode. We’ll use
    vcan0, a virtual CAN device, to test the exploit, but for the real exploit, you’d
    want to instead use can0 or the actual CAN bus device that you’re targeting. [Listing
    11-1](ch11.html#ch11list1) shows the *temp_shell* exploit.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用C语言编写这个伪造的CAN信号的漏洞代码，因为C语言编译后生成的汇编代码较为简洁，我们可以利用这些汇编代码来制作我们的Shellcode。我们将使用vcan0，一个虚拟CAN设备，来测试这个漏洞，但在实际攻击中，您应使用can0或您目标的真实CAN总线设备。[列表11-1](ch11.html#ch11list1)显示了*temp_shell*漏洞代码。
- en: '**NOTE**'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*You’ll need to create a virtual CAN device in order to test this program.
    See [Chapter 3](ch03.html#ch03) for details.*'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: '*您需要创建一个虚拟CAN设备来测试此程序。有关详细信息，请参阅[第3章](ch03.html#ch03)。*'
- en: In [Listing 11-1](ch11.html#ch11list1), we create a CAN packet with an arbitration
    ID of 0x510 and set the second byte to 0xFF. The second byte of the 0x510 packet
    represents the engine temperature. By setting this value to 0xFF, we max out the
    reported engine temperature, signaling that the vehicle is overheating. The packet
    needs to be sent repeatedly to be effective.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '*Listing 11-1: C loop to spam CAN ID 0x510*'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 11-1](ch11.html#ch11list1) sets up a socket in almost the same way
    as you’d set up a normal networking socket, except it uses the CAN family `PF_CAN`
    ➊. We use `ifr_name` to define which interface we want to listen on—in this case,
    `"vcan0"` ➋.'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
- en: We can set up our frame using a simple frame structure that matches our packet,
    with `can_id` ➌ containing the arbitration ID, `can_dlc` containing the packet
    length, and the `data[]` array holding the packet contents.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
- en: We want to send this packet more than once, so we set up a `while` loop and
    set a sleep timer ➍ to send the packet at regular intervals. (Without the `sleep`
    statement, you’d flood the bus and other signals wouldn’t be able to talk properly.)
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
- en: 'To confirm that this code works, compile it as shown here:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Now run `candump` in a separate window on vcan0, as shown in the next listing.
    The *temp_shellcode* program should send the necessary CAN packets to control
    the temperate gauge.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The `candump` results show that the signal 0x510 ➊ is repeatedly broadcast and
    that the second byte is properly set to 0xFF ➌. Notice that the other values of
    the CAN packet are set to values that we didn’t specify, such as 0x5D ➋ and 0x40
    ➍. This is because we didn’t initialize the *frame.data* section, and there is
    some memory garbage in the other bytes of the signal. To get rid of this memory
    garbage, set the other bytes of the 0x510 signal to the values you recorded during
    testing when you identified the signal—that is, set the other bytes to `frame.data[]`.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
- en: '***Converting to Assembly Code***'
  id: totrans-23
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Though our *temp_shell* program is small, it’s still almost 9KB because we wrote
    it in C, which includes a bunch of other libraries and code stubs that increase
    the size of the program. We want our shellcode to be as small as possible because
    we’ll often have only a small area of memory available for our exploit to run,
    and the smaller our shellcode, the more places it can be injected.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
- en: In order to shrink the size of our program, we’ll convert its C code to assembly
    and then convert the assembly shellcode. If you’re already familiar with assembly
    language, you could just write your code in assembly to begin with, but most people
    find it easier to test their payloads in C first.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
- en: The only difference between writing this script and standard assembly scripts
    is that you’ll need to avoid creating NULLs, as you may want to inject the shellcode
    into a buffer that might null-terminate. For example, buffers that are treated
    as strings will scan the values and stop when it see a NULL value. If your payload
    has a NULL in the middle, your code won’t work. (If you know that your payload
    will never be used in a buffer that will be interpreted as a string, then you
    can skip this step.)
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
- en: '*Alternatively, you could wrap your payload with an encoder to hide any NULLs,
    but doing so will increase its size, and using encoders is beyond the scope of
    this chapter. You also won’t have a data section to hold all of your string and
    constant values as you would in a standard program. We want our code to be self-sufficient
    and we don’t want to rely on the ELF header to set up any values for us, so if
    we want to use strings in our payload, we have to be creative in how we place
    them on the stack.*'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to convert the C code to assembly, you will need to review the system
    header files. All method calls go right to the kernel, and you can see them all
    in this header file:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'For this example, we’ll use 64-bit assembly, which uses the following registers:
    `%rax`, `%rbx`, `%rcx`, `%rdx`, `%rsi`, `%rdi`, `%rbp`, `%rsp`, `%r8`, `%r15`,
    `%rip`, `%eflags`, `%cs`, `%ss`, `%ds`, `%es`, `%fs`, and `%gs`.'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
- en: 'To call a kernel system call, use `syscall`—rather than `int 0x80`—where `%rax`
    has the system call number, which you can find in *unistd_64.h*. The parameters
    are passed in the registers in this order: `%rdi`, `%rsi`, `%rdx`, `%r10`, `%r8`,
    and `%r9`.'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
- en: Note that the register order is slightly different than when passing arguments
    to a function.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 11-2](ch11.html#ch11list2) shows the resulting assembly code that
    we store in the *temp_shell.s* file.'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '*Listing 11-2: Sending CAN ID 0x510 packets in 64-bit assembly*'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
- en: The code in [Listing 11-2](ch11.html#ch11list2) is exactly the same as the C
    code we wrote in [Listing 11-1](ch11.html#ch11list1), except that it’s now written
    in 64-bit assembly.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
- en: '*I’ve commented the code to show the relationship between the lines of the
    original C code and each chunk of assembly code.*'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
- en: 'To compile and link the program to make it an executable, use `nasm` and `ld`,
    as shown here:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The size of the object header now shows that the program is around 1008 bytes
    ➊, or just over 1KB, which is significantly smaller than the compiled C program.
    Once we strip the ELF header caused by the linking step (`ld`), our code will
    be even smaller still.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
- en: '***Converting Assembly to Shellcode***'
  id: totrans-43
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Now that your program is of more suitable size, you can use one line of Bash
    to convert your object file to shellcode right at the command line, as shown in
    [Listing 11-3](ch11.html#ch11list3).
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '*Listing 11-3: Converting object file to shellcode*'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
- en: This series of commands runs through your compiled object file and pulls out
    the hex bytes that make up the program, printing them to the screen. The bytes
    output is your shellcode. If you count up the printed bytes, you can see that
    this shellcode is 168 bytes—that’s more like it.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
- en: '***Removing NULLs***'
  id: totrans-48
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: But we’re not done yet. If you look at the shellcode in [Listing 11-3](ch11.html#ch11list3),
    you’ll notice that we still have some NULL values (`\x00`) that we need to eliminate.
    One way to do so is to use a loader, which Metasploit has, to wrap the bytes or
    rewrite parts of the code to eliminate the NULLs.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
- en: You could also rewrite your assembly to remove NULLs from the final assembly,
    typically by replacing MOVs and values that would have NULLs in them with a command
    to erase a register and another command to add the appropriate value. For instance,
    a command like `MOV RDI, 0x03` will convert to hex that has a lot of leading NULLs
    before the 3\. To get around this, you could first XOR RDI to itself (`XOR RDI,
    RDI`), which would result in RDI being a NULL, and then increase RDI (`INC RDI`)
    three times. You may have to be creative in some spots.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
- en: 'Once you’ve made the modifications to remove these NULL values, you can convert
    the shellcode to code that can be embedded in a string buffer. I won’t show the
    altered assembly code because it’s not very legible, but the new shellcode looks
    like this:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '***Creating a Metasploit Payload***'
  id: totrans-53
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '[Listing 11-4](ch11.html#ch11list4) is a template for a Metasploit payload
    that uses our shellcode. Save this payload in *modules/payloads/singles/linux/armle/*,
    and name it something similar to the action that you’ll be performing, like *flood_temp.rb*.
    The example payload in [Listing 11-4](ch11.html#ch11list4) is designed for an
    infotainment system on ARM Linux with an Ethernet bus. Instead of modifying temperature,
    this shellcode unlocks the car doors. The following code is a standard payload
    structure, other than the payload variable that we set to the desired vehicle
    shellcode.'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '*Listing 11-4: Template for Metasploit payload using our shellcode*'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
- en: 'The `payload` variable ➊ in [Listing 11-4](ch11.html#ch11list4) translates
    to the following ARM assembly code:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: This code is similar to the shellcode we created in [Listing 11-3](ch11.html#ch11list3),
    except that it’s built for ARM rather than x64 Intel, and it functions over Ethernet
    instead of talking directly to the CAN drivers. Of course, if the infotainment
    center uses a CAN driver rather than an Ethernet driver, you need to write to
    the CAN driver instead of the network.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
- en: Once you have a payload ready, you can add it to the arsenal of existing Metasploit
    exploits for use against a vehicle’s infotainment center. Because Metasploit parses
    the payload file, you can simply choose it as an option to use against any target
    infotainment unit. If a vulnerability is found, the payload will run and perform
    the action of the packet you mimicked, such as unlocking the doors, starting the
    car, and so on.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
- en: '*You could write your weaponizing program in assembly and use it as your exploit
    rather than going through Metasploit, but I recommend using Metasploit. It has
    a large collection of vehicle-based payloads and exploits available, so it’s worth
    the extra time it takes to convert your code.*'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
- en: '**Determining Your Target Make**'
  id: totrans-63
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: So far you’ve located a vulnerability in an infotainment unit and you have the
    CAN bus packet payload ready to go. If your intention was to perform a security
    engagement on just one type of vehicle, you’re good to go. But if you intend to
    use your payload on all vehicles with a particular infotainment or telematics
    system installed, you have a bit more to do; these systems are installed by various
    manufacturers and CAN bus networks vary between manufacturers and even between
    models.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
- en: In order to use this exploit against more than one type of vehicle, you’ll need
    to detect the make of the vehicle that your shellcode is executing on before transmitting
    packets.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
- en: '**WARNING**'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
- en: '*Failure to detect the make of the vehicle could produce unexpected results
    and could be very dangerous! For example, a packet that on one make of vehicle
    unlocks the car door could bleed the brakes on another. There’s no way to know
    for sure where your exploit will run, so be sure to verify the vehicle.*'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
- en: 'Determining the make of vehicle is analogous to determining which OS version
    the target host is running, as we did in “[Determining the Update File Type](ch09.html#ch09lev2sec2)”
    on [page 160](ch09.html#page_160). You may be able to find this information in
    the memory space of the infotainment unit by adding the ability to scan RAM in
    your shellcode. Otherwise, there are two ways to determine what type of vehicle
    your code is running on via the CAN bus: interactive probing and passive CAN bus
    fingerprinting.'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
- en: '***Interactive Probing***'
  id: totrans-69
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The interactive probing method involves using the ISO-TP packets to query the
    PID that holds the VIN. If we can access the VIN and decipher the code, it’ll
    tell us the make and model of the target vehicle.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
- en: '**Querying the VIN**'
  id: totrans-71
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Recall from “[Sending Data with ISO-TP and CAN](ch04.html#ch04lev2sec4)” on
    [page 55](ch04.html#page_55) that you use the OBD-II Mode 2 PID 9 protocol to
    query the VIN. This protocol uses the ISO-TP multipacket standard, which can be
    cumbersome to implement in shellcode. You can, however, just take what you need
    from the ISO-TP standard rather than implementing it in full. For example, because
    ISO-TP runs as normal CAN traffic, you could send a packet with your shellcode
    using an ID of 0x7DF and a 3-byte packet payload of 0x02 0x09 0x02; then you could
    receive normal CAN traffic with an ID 0x7E8\. The first packet received will be
    part of a multipart packet followed by the remaining packets. The first packet
    has the most significant information in it and may be all you need to differentiate
    between vehicles.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
- en: '*You could assemble the multipart packet yourself and then implement a full
    VIN decoder, but doing so can be inefficient. Regardless of whether you reassemble
    the full VIN or just use a segment of the VIN, it’s better to decode the VIN yourself.*'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
- en: '**Decoding the VIN**'
  id: totrans-75
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: The VIN has a fairly simple layout. The first three characters, known as the
    *World Manufacturer Identifier (WMI) code*, represent the make of the vehicle.
    The first character in the WMI code determines the region of manufacture. The
    next two characters are manufacturer specific. (The list is too long to print
    here, but you can find a list of WMI codes with a simple online search.) For example,
    in [Chapter 4](ch04.html#ch04) (see [Table 4-4](ch04.html#ch4tab4) on [page 57](ch04.html#page_57))
    we had a VIN of 1G1ZT53826F109149, which gave us a WMI of 1G1\. According to the
    WMI codes, this tells us that the make of the car is Chevrolet.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
- en: The next 6 bytes of the VIN make up the *Vehicle Descriptor Section (VDS)*.
    The first 2 bytes in the VDS—bytes 4 and 5 of the VIN—tell us the vehicle model
    and other specs, such as how many doors the vehicle has, the engine size, and
    so on. For example, in the VIN 1G1ZT53826F109149, the VDS is ZT5382, of which
    *ZT* gives us the model. A quick search online tells us that this is a Chevrolet
    Malibu. (The details of the VDS vary depending on the vehicle and the manufacturer.)
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
- en: If you need the year your vehicle was made, you’ll have to grab more packets
    because the year is stored at byte 10\. This byte isn’t directly translatable,
    and you’ll need to use a table to determine the year (see [Table 11-1](ch11.html#ch11tab1)).
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 11-1:** Determining the Year of Manufacture'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
- en: '| **Character** | **Year** | **Character** | **Year** | **Character** | **Year**
    | **Character** | **Year** |'
  id: totrans-80
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- | --- | --- | --- | --- |'
  id: totrans-81
  prefs: []
  type: TYPE_TB
- en: '| A | 1980 | L | 1990 | Y | 2000 | A | 2010 |'
  id: totrans-82
  prefs: []
  type: TYPE_TB
- en: '| B | 1981 | M | 1991 | 1 | 2001 | B | 2011 |'
  id: totrans-83
  prefs: []
  type: TYPE_TB
- en: '| C | 1982 | N | 1992 | 2 | 2002 | C | 2012 |'
  id: totrans-84
  prefs: []
  type: TYPE_TB
- en: '| D | 1983 | P | 1993 | 3 | 2003 | D | 2013 |'
  id: totrans-85
  prefs: []
  type: TYPE_TB
- en: '| E | 1984 | R | 1994 | 4 | 2004 | E | 2014 |'
  id: totrans-86
  prefs: []
  type: TYPE_TB
- en: '| F | 1985 | W | 1995 | 5 | 2005 | F | 2015 |'
  id: totrans-87
  prefs: []
  type: TYPE_TB
- en: '| G | 1986 | T | 1996 | 6 | 2006 | G | 2016 |'
  id: totrans-88
  prefs: []
  type: TYPE_TB
- en: '| H | 1987 | V | 1997 | 7 | 2007 | H | 2017 |'
  id: totrans-89
  prefs: []
  type: TYPE_TB
  zh: '| H | 1987 | V | 1997 | 7 | 2007 | H | 2017 |'
- en: '| J | 1988 | W | 1998 | 8 | 2008 | J | 2018 |'
  id: totrans-90
  prefs: []
  type: TYPE_TB
  zh: '| J | 1988 | W | 1998 | 8 | 2008 | J | 2018 |'
- en: '| K | 1989 | X | 1999 | 9 | 2009 | K | 2019 |'
  id: totrans-91
  prefs: []
  type: TYPE_TB
  zh: '| K | 1989 | X | 1999 | 9 | 2009 | K | 2019 |'
- en: For exploit purposes, knowing the year isn’t as important as knowing whether
    your code will work on your target vehicle, but if your exploit depends on an
    exact make, model, and year, you’ll need to perform this step. For instance, if
    you know that the infotainment system you’re targeting is installed in both Honda
    Civics and Pontiac Azteks, you can check the VIN to see whether your target vehicle
    fits. Hondas are manufactured in Japan and Pontiacs are made in North America,
    so the first byte of the WMI needs to be either a *J* or a *1*, respectively.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 对于利用漏洞来说，知道年份并不像知道你的代码是否能在目标车辆上运行那么重要，但如果你的漏洞依赖于特定的品牌、型号和年份，你需要执行这一步。例如，如果你知道你所针对的车载信息娱乐系统既安装在本田思域（Honda
    Civic）也安装在庞蒂亚克阿兹特克（Pontiac Aztek）上，你可以通过检查VIN来确认目标车辆是否符合要求。本田是日本制造的，而庞蒂亚克是北美制造的，因此WMI的第一个字节分别需要是*J*或*1*。
- en: '**NOTE**'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*Your payload would still work on other vehicles made in North America or Japan
    if that radio unit is installed in some other vehicle that you’re unaware of.*'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '*如果你所针对的车辆上的无线电单元安装在其他你不了解的车辆上，你的有效载荷仍然能够在其他北美或日本制造的车辆上工作。*'
- en: Once you know what platform you’re running on, you can either execute the proper
    payload if you’ve found the right vehicle or exit out gracefully.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你知道了运行平台，你可以选择执行正确的有效载荷，如果你找到了合适的载体，或者优雅地退出。
- en: '**Detection Risk of Interactive Probing**'
  id: totrans-96
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**交互式探测的检测风险**'
- en: The advantage of using interactive probing to determine the make of your target
    vehicle is that this method will work for any make or model of car. Every car
    has a VIN that can be decoded to give you the information you need, and you need
    no prior knowledge of the platform’s CAN packets in order to make a VIN query.
    However, this method does require you to *transmit* the query on the CAN bus,
    which means it’s detectable and you may be discovered before you can trigger your
    payload. (Also, our examples used cheap hacks to avoid properly handling ISO-TP,
    which could lead to errors.)
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 使用交互式探测来确定目标车辆的品牌的优势在于，这种方法适用于任何品牌或型号的汽车。每辆车都有一个VIN码，可以解码得到所需的信息，并且你不需要预先了解平台的CAN数据包就能进行VIN查询。然而，这种方法确实需要你*传输*查询到CAN总线上，这意味着它是可检测的，你可能会在触发有效载荷之前被发现。（此外，我们的示例使用了廉价的黑客技术来避免正确处理ISO-TP，这可能导致错误。）
- en: '***Passive CAN Bus Fingerprinting***'
  id: totrans-98
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***被动CAN总线指纹识别***'
- en: If you’re concerned about being detected before you can use your payload, you
    should avoid any sort of active probing. Passive CAN bus fingerprinting is less
    detectable, so if you discover that the model vehicle you’re targeting isn’t supported
    by your exploit, you can exit gracefully without having created any network traffic,
    thus limiting your chances of being detected. Passive CAN bus fingerprinting involves
    monitoring network traffic to gather information unique to certain makes of vehicles
    and then matching that information to a known fingerprint. This area of research
    is relatively new, and as of this writing, the only tools available for gathering
    and detecting bus fingerprints are the ones released by Open Garages.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你担心在使用有效载荷之前被检测到，应该避免任何形式的主动探测。被动CAN总线指纹识别更不容易被检测到，因此如果你发现你所针对的车型不被你的漏洞支持，你可以优雅地退出，而不会产生任何网络流量，从而降低被检测到的风险。被动CAN总线指纹识别包括监控网络流量，收集特定车型所独有的信息，然后将这些信息与已知指纹进行匹配。这一研究领域相对较新，截至本文写作时，唯一可用的收集和检测总线指纹的工具是Open
    Garages发布的工具。
- en: The concept of passive CAN bus fingerprinting is taken from IPv4 passive operating
    system fingerprinting, like that used by the p0f tool. When passive IPv4 fingerprinting,
    details in the packet header, such as the window size and TTL values, can be used
    to identify the operating system that created the packet. By monitoring network
    traffic and knowing which operating systems set which values in the packet header
    by default, it’s possible to determine which operating system the packet originated
    from without transmitting on the network.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 被动CAN总线指纹识别的概念来源于IPv4的被动操作系统指纹识别，例如p0f工具所使用的技术。在被动IPv4指纹识别中，数据包头部的细节，例如窗口大小和TTL值，可以用来识别创建数据包的操作系统。通过监控网络流量，并了解哪些操作系统默认设置了数据包头部中的哪些值，可以在不通过网络传输的情况下确定数据包的来源操作系统。
- en: 'We can use a similar methodology with CAN packets. The unique identifiers for
    CAN are as follows:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用类似的方法论来处理 CAN 数据包。CAN 的唯一标识符如下：
- en: • Dynamic size (otherwise set to 8 bytes)
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: • 动态大小（否则设置为 8 字节）
- en: • Intervals between signals
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: • 信号间的间隔
- en: • Padding values (0x00, 0xFF 0xAA, and so on)
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: • 填充值（0x00, 0xFF, 0xAA 等等）
- en: • Signals used
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: • 使用的信号
- en: Because different makes and models use different signals, unique signal IDs
    can reveal the type of vehicle that’s being examined. And even when the signal
    IDs are the same, the timing intervals can be unique. Each CAN packet has a DLC
    field to define the length of the data, though some manufacturers will set this
    to 8 by default and pad out the data to always ensure that 8 bytes are used. Manufacturers
    will use different values to pad their data, so this can also be an indicator
    of the make.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 因为不同的汽车品牌和型号使用不同的信号，独特的信号 ID 可以揭示正在检查的车辆类型。即使信号 ID 相同，时序间隔也可能是独特的。每个 CAN 数据包都有一个
    DLC 字段，用来定义数据的长度，尽管一些制造商默认将其设置为 8，并通过填充数据来确保始终使用 8 个字节。制造商会使用不同的值来填充数据，因此这也可以作为识别品牌的指标。
- en: '**CAN of Fingers**'
  id: totrans-107
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**CAN 的指纹**'
- en: 'The Open Garages tool for passive fingerprinting is called *CAN of Fingers
    (c0f)* and is available for free at *[https://github.com/zombieCraig/c0f/](https://github.com/zombieCraig/c0f/)*.
    c0f samples a bunch of CAN bus packets and creates a fingerprint that can later
    be identified and stored. A fingerprint from c0f—a JSON consumable object—might
    look like this:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 被动指纹识别的 Open Garages 工具叫做 *CAN 的指纹（c0f）*，并可以在 *[https://github.com/zombieCraig/c0f/](https://github.com/zombieCraig/c0f/)*
    免费获得。c0f 会采样大量 CAN 总线数据包，并创建一个可以稍后识别和存储的指纹。c0f 的指纹——一个可供 JSON 消费的对象——可能如下所示：
- en: '[PRE10]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Five fields make up the fingerprint: `Make`, `Model`, `Year`, `Trim`, and `Dynamic`.
    The first four values—`Make`, `Model`, `Year`, and `Trim`—are all listed as `Unknown`
    if they’re not in the database. [Table 11-2](ch11.html#ch11tab2) lists the identified
    attributes that are unique to the vehicle.'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 五个字段构成了指纹：`Make`、`Model`、`Year`、`Trim` 和 `Dynamic`。如果数据库中没有这些值，前四个值——`Make`、`Model`、`Year`
    和 `Trim`——将都列为 `Unknown`。[表格 11-2](ch11.html#ch11tab2)列出了独特于车辆的已识别属性。
- en: '**Table 11-2:** Vehicle Attributes for Passive Fingerprinting'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '**表格 11-2：** 被动指纹识别的车辆属性'
- en: '| **Attribute** | **Value type** | **Description** |'
  id: totrans-112
  prefs: []
  type: TYPE_TB
  zh: '| **属性** | **值类型** | **描述** |'
- en: '| --- | --- | --- |'
  id: totrans-113
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| Dynamic | Binary value | If the DLC has a dynamic length, this is set to
    `true`. |'
  id: totrans-114
  prefs: []
  type: TYPE_TB
  zh: '| 动态 | 二进制值 | 如果 DLC 有动态长度，则设置为 `true`。 |'
- en: '| Padding | Hex value | If padding is used, this attribute will be set to the
    byte used for padding. This example does not have padding, so the attribute is
    not included. |'
  id: totrans-115
  prefs: []
  type: TYPE_TB
  zh: '| 填充 | 十六进制值 | 如果使用填充，则此属性将设置为用于填充的字节。此示例没有填充，因此未包括此属性。 |'
- en: '| Common | Array of IDs | The common signal IDs based on the frequency seen
    on the bus. |'
  id: totrans-116
  prefs: []
  type: TYPE_TB
  zh: '| 常见 | ID 数组 | 基于总线上频率出现的常见信号 ID。 |'
- en: '| Main ID | Hex ID | The most common signal ID based on the frequency of occurrence
    and interval. |'
  id: totrans-117
  prefs: []
  type: TYPE_TB
  zh: '| 主 ID | 十六进制 ID | 基于出现频率和间隔的最常见信号 ID。 |'
- en: '| Main Interval | Floating point value | The shortest interval time of the
    most common ID (MainID) that repeats on the bus. |'
  id: totrans-118
  prefs: []
  type: TYPE_TB
  zh: '| 主间隔 | 浮动值 | 总线中最常见的 ID（MainID）重复的最短间隔时间。 |'
- en: '**Using c0f**'
  id: totrans-119
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**使用 c0f**'
- en: Many CAN signals that fire at intervals will appear in a logfile the same amount
    of times as each other, with similar intervals between occurrences. c0f will group
    the signals together by the number of occurrences.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 许多以间隔触发的 CAN 信号将在日志文件中以相同的次数出现，且出现之间的间隔相似。c0f 将根据出现次数将信号分组。
- en: To get a better idea of how c0f determines the common and main IDs, run `c0f`
    with the `--print-stats` option, as shown in [Listing 11-5](ch11.html#ch11list5).
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更好地了解 c0f 如何确定常见和主 ID，请运行 `c0f` 并使用 `--print-stats` 选项，如[清单 11-5](ch11.html#ch11list5)所示。
- en: '[PRE11]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '*Listing 11-5: Running `c0f` with the `--print-stats` option*'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 11-5：运行 `c0f` 并使用 `--print-stats` 选项*'
- en: The common IDs are the grouping of signals that occurred 326 times (the highest
    count). The main ID is the common ID with the shortest average interval—in this
    case, signal 0x143 at 0.009998 ms ➋.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 常见 ID 是信号的组合，这些信号出现了 326 次（出现次数最多）。主 ID 是具有最短平均间隔的常见 ID——在这种情况下，信号 0x143，间隔为
    0.009998 毫秒 ➋。
- en: The c0f tool saves these fingerprints in a database so that you can passively
    identify buses, but for the purpose of shellcode development, we can just use
    main ID and main interval to quickly determine whether we’re on the target we
    expect to be on. Taking the result shown in [Listing 11-5](ch11.html#ch11list5)
    as our target, we’d listen to the CAN socket for signal 0x143 and know that the
    longest we’d have to wait is 0.009998 ms before aborting if we didn’t see an ID
    of 0x143\. (Just be sure that when you’re checking how much time has passed since
    you started sniffing the bus, you use a time method with high precision, such
    as `clock_gettime`.) You could get more fine-grained identification by ensuring
    that you also identified all of the common IDs as well.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
- en: It’s possible to design fingerprints that aren’t supported by c0f. For instance,
    notice in the c0f statistical output in [Listing 11-5](ch11.html#ch11list5) that
    the signal ID 0x039 occurred 215 times ➊. That’s a strange ratio compared to the
    other common packets. The common packets are occurring about 5 percent of the
    time, but 0x039 occurs about 3.5 percent of the time and is the only signal with
    that ratio. Your shellcode could gather a common ID and calculate the ratio of
    0x039 occurring to see whether it matches. This could just be a fluke based on
    current vehicle conditions at the time of the recording, but it might be interesting
    to investigate. The sample size should be increased and multiple runs should be
    used to verify findings before embedding the detection into your shellcode.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
- en: '*c0f isn’t the only way to quickly detect what type of vehicle you’re on; the
    output could be used for additional creative ways to identify your target system
    without transmitting packets. The future may bring systems that can hide from
    c0f, or we may discover a newer, more efficient way to passively identify a target
    vehicle.*'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
- en: '**Responsible Exploitation**'
  id: totrans-129
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You now know how to identify whether your exploit is running on the target it’s
    designed for and even how to check without transmitting a single packet. You don’t
    want to flood a bus with a bogus signal, as this will shut the network down, and
    flooding the wrong signal on the wrong vehicle can have unknown affects.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
- en: When sharing exploit code, consider adding a bogus identification routine or
    complete VIN check to prevent someone from simply launching your exploit haphazardly.
    Doing so will at least force the script kiddies to understand enough of the code
    to modify it to fit the proper vehicles. When attacking interval-based CAN signals,
    the proper way to do this is to listen for the CAN ID you want to modify and,
    when you receive it through your read request, to modify *only* the byte(s) you
    want to alter and immediately send it back out. This will prevent flooding, immediately
    override the valid signal, and retain any other attributes in the signal that
    aren’t the target of the attack.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
- en: Security developers need access to exploits to test the strength of their protections.
    New ideas from both the attack and defense teams need to be shared, but do so
    responsibly.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
- en: '**Summary**'
  id: totrans-133
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to build working payloads from your research.
    You took proof-of-concept C code, converted it to payloads in assembly, and then
    converted your assembly to shellcodes that you could use with Metasploit to make
    your payloads more modular. You also learned safe ways to ensure that your payloads
    wouldn’t accidentally be run on unexpected vehicles with the help of VIN decoding
    and passive CAN bus identification techniques. You even learned some ways to prevent
    script kiddies from taking your code and injecting it into random vehicles.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
