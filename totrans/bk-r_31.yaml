- en: '**26**'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**INTERACTIVE 3D PLOTS**'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/common-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: When it comes to 3D plots, it’s important to be able to view them from different
    angles to interpret the function or surface that’s been displayed. The `rgl` package
    by Adler et al. ([2015](ref.xhtml#ref01)) offers some fantastic, simple-to-use
    R functions that allow you to rotate and zoom in on three-dimensional plots with
    your mouse. In this chapter, you’ll look at a few examples that show off the possibilities
    of `rgl`.
  prefs: []
  type: TYPE_NORMAL
- en: Under the hood, `rgl` utilizes OpenGL—a standard application programming interface—to
    render the graphics on your computer screen. Install `rgl` (for example, by calling
    `install.packages("rgl")` at the prompt) and then call `library("rgl")` to load
    it.
  prefs: []
  type: TYPE_NORMAL
- en: '**26.1 Point Clouds**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Let’s begin with the most basic of 3D plots—*point clouds*. In statistics, this
    tool is typically used to provide scatterplots of three continuous variables,
    as you saw when you created static 3D scatterplots.
  prefs: []
  type: TYPE_NORMAL
- en: '***26.1.1 Basic 3D Cloud***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Return to the built-in `iris` data, composed of four measurements taken on
    three species of flower. Create the following four vectors in your workspace for
    accessibility, as you did in [Section 25.2.1](ch25.xhtml#ch25lev2sec249):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'You use the `plot3d` function of `rgl` to display an interactive 3D cloud of
    points. It’s called in the way familiar for scatterplots—by supplying the *x*-,
    *y*-, and *z*-coordinates to the `x`, `y`, and `z` arguments, respectively. The
    following line opens an RGL device and produces a scatterplot of petal width,
    length, and sepal width from the `iris` data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: You’ll probably want to increase the size of the device with your mouse to see
    the data better. Then, by left-clicking the plot and holding the button down,
    you can move the mouse to rotate the plot in any direction you like. If you right-click
    the plot and hold, you control the zoom. Specifically, rightclicking and holding
    while moving the mouse upward will zoom out, and right-clicking and holding while
    moving the mouse downward will zoom in. The axis tick marks and labels automatically
    appear on different sides based on your viewing angle. [Figure 26-1](ch26.xhtml#ch26fig1)
    shows this plot.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f26-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 26-1: An interactive 3D scatterplot of the* `iris` *data using the*
    `plot3d` *function of* `rgl`*. This is the default appearance of plotting the
    petal width, petal length, and sepal width.*'
  prefs: []
  type: TYPE_NORMAL
- en: '***26.1.2 Visual Enhancements and Legends***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: You can alter the appearance of a `plot3d` scatterplot in new ways as well as
    some familiar ways. For example, the optional `type` argument, defaulting to `"p"`
    for “points,” plots the points as dots as in the most recent scatterplot. To draw
    points as visible 3D spheres, use `type="s"`. You can control the size of any
    plotted points or spheres by using `size`, and you can control the color (or colors)
    by using `col`. The `legend3d` function is the `rgl` analog of `legend` and is
    also useful; it works by changing the background image upon which the interactive
    plot sits.
  prefs: []
  type: TYPE_NORMAL
- en: 'To illustrate these modifications, let’s replot the same `iris` observations.
    First, close any currently open RGL graphics devices. Then, execute the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: This will start a new RGL device, coloring spheres according to flower species.
    As usual, you pass the `col` argument a vector of the same length as the plotted
    coordinates, and it will assign the color to the corresponding point in an element-wise
    fashion. You specify the `size` parameter on a slightly different scale than the
    traditional R graphics parameter `cex`, and it changes according to the value
    of `type`—inspect the help file `?plot3d` for details. With a little experimentation,
    it’s not difficult to find a size value that suits the plot.
  prefs: []
  type: TYPE_NORMAL
- en: 'To add a legend, first resize the RGL device with your mouse to your preferred
    display size and then execute the following line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: This inserts a static, unmovable legend referencing the plotted species by color.
    The `legend3d` function actually calls the base R `legend` function, so they are
    conveniently used in the same way. With the static legend in place, the scatterplot
    remains fully interactive, and you can continue to rotate and zoom. [Figure 26-2](ch26.xhtml#ch26fig2)
    shows all this.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `legend3d` function changes the background canvas, which is why you have
    to open a new device and resize it manually before you add the legend. If you
    now produced a new `rgl` plot in the same device without closing it first or resetting
    the background, the flower species legend would still be there. If you’re making
    multiple `rgl` plots, you can reset the background to its default white canvas
    at any time by calling the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: If you try that with the most recent plot still active, you’ll see that the
    flower species legend disappears and the scatterplot remains. Alternatively, you
    can just close your RGL device when you’re done so that a new device will be used
    for any subsequent plot.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f26-02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 26-2: Replotting the* `iris` *petal width, length, and sepal width
    data with* `plot3d`*. Observations are plotted as spheres, increased in size,
    and colored according to species type; a legend is added via* `legend3d`.'
  prefs: []
  type: TYPE_NORMAL
- en: '***26.1.3 Adding Further 3D Components***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: You can also add new observations and lines to a current 3D plot. The `rgl`
    package includes the functions `points3d`, `lines3d`, and `segments3d`, reminiscent
    of `points`, `lines`, and `segments` from base R graphics. As an example, in [Section
    25.2.2](ch25.xhtml#ch25lev2sec250), you used an optional argument to add vertical
    lines from the base of the *x*-*y* plane to each plotted point in `scatterplot3d`.
    In a `plot3d` scatterplot, you would use `segments3d` to the same effect. In addition,
    you can add the grid that’s drawn by default on the same plane in a `scatterplot3d`
    plot by using the `grid3d` function for `rgl` graphics.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s put that into practice. Take a look back at [Figure 25-8](ch25.xhtml#ch25fig8)
    on [page 652](ch25.xhtml#page_652). To create a similar plot using `rgl` functionality,
    where color is used to reference the fourth continuous variable, sepal length,
    first re-create the palette and set up the colors for each observation. This is
    done here with a categorization of 50 colors (see [Section 25.1.4](ch25.xhtml#ch25lev2sec245)).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Then, either close any currently active RGL devices or clear the background
    of the one in focus. A call to `plot3d` starts the plot with appropriately colored
    spheres.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: You supply a vector of length 3 to the `aspect` argument, describing the relative
    lengths of the *x*-, *y*-, and *z*-axes, in that order. By changing the second
    entry to `1.75`, you’re lengthening the *y*-axis by that multiplicative factor
    relative to the others. This creates the stretched-out effect along the *y*-axis.
    The colors are assigned by vector indexing using the `slen.cols` factor vector,
    and `xlab`, `ylab`, and `zlab` are used to tidy up the axis titles.
  prefs: []
  type: TYPE_NORMAL
- en: Now, to add a vertical line from the *x*-*y* plane to each observation, you
    need to understand how to use the `segments3d` function. Unlike its base R counterpart,
    `segments3d` doesn’t separate the “from” and “to” coordinates into different arguments
    (recall the use of `x0`, `y0`, `x1`, and `y1` in `segments` and `arrows`). Instead,
    it takes each sequential pair of observations provided to the `x`, `y`, and `z`
    arguments to be the beginning and end of each line segment, in that order.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, to draw the vertical lines on the existing RGL device, you first need to
    set up these vectors containing a “from” location and a “to” location in the 3D
    space. Consider the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The first two lines set up the vectors for the *x*- and *y*-components, `xfromto`
    and `yfromto`, respectively, by simply replicating each observation twice. These
    are easy, since the “from–to” values don’t change in these coordinate directions.
    The *z*-component does change, however. You first create the `zfromto` vector
    by replicating the smallest sepal width value, `min(swid)`, by two times the size
    of the data set, so you have a vector that matches `xfromto` and `yfromto` in
    length. Then, every second position of `zfromto` is overwritten using the elements
    of the sepal width vector. This gives you “from” *z* values for all observations,
    namely `min(swid)`, matched (in the pairwise fashion as required for `segments3d`)
    with the “to” *z* values in `swid` itself. Together with `xfromto` and `yfromto`,
    you’ll therefore end up with lines that go from the bottom *x*-*y* plane of the
    plot (the vertical position of which is automatically level at `min(swid)`) up
    to the actual `swid` value (which is of course the corresponding *z* value of
    each sphere).
  prefs: []
  type: TYPE_NORMAL
- en: To help understand the way they’ve been set up, print the coordinate vectors
    to your console screen so you can see what they hold. Then a call to `segments3d`
    places the lines on the plot.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: To ensure the color of each line matches its corresponding sphere, you also
    need to replicate each entry of the vector-indexed collection of colors provided
    by `cols[slen.cols]` twice, which implies a constant “from–to” color.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, executing the following line places a reference grid over the lower *x*-*y*
    plane:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: To the `side` argument you specify the axis you want held constant (in this
    case, *z*) and at which end to place the grid (in this case, because you want
    the grid at the lower end of the *z*-axis, you specify with a minus symbol). To
    place the grid at the upper end of the vertical axis, which is on the top side
    of the rectangular prism, you would specify `side="z+"`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Lastly, you can add a custom, continuous-color legend to the plot to reference
    the sepal length. The `bgplot3d` function is a more general version of `legend3d`;
    it allows you to specify any plotting commands you like to define the RGL device
    background. Let’s do so using the `colorlegend` function of the `shape` package,
    first explored in [Section 25.1.5](ch25.xhtml#ch25lev2sec246). Make sure you have
    the `shape` package loaded and that your RGL device of the scatterplot is sized
    to your liking. On my machine, I execute the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: The `bgplot3d` function can take multiple plotting commands, which you need
    to provide as a code chunk within braces, `{}`, with each command separated by
    a semicolon (`;`). In this example, the initial call to `plot.new()` silently
    initializes the background of the RGL device so that you can add the continuous-color
    legend. Without that call, `colorlegend` will still work, but a warning will be
    issued. [Figure 26-3](ch26.xhtml#ch26fig3) shows the final result, with the scatterplot
    still spinnable and zoomable with your mouse.
  prefs: []
  type: TYPE_NORMAL
- en: The ability to rotate a 3D scatterplot and any of the plots you’ll see over
    the next few sections with simple mouse commands is especially handy when you’re
    exploring visuals of higher-dimensional data. You’re not restricted to a single
    viewpoint, and you don’t need to manually decide on a viewing angle before actually
    producing the plot. The `rgl` functionality also makes it easy to add extra elements
    to an existing plot—something that’s harder to do with `scatterplot3d` or `persp`
    plots. That said, certain features you might take for granted in more traditional
    plotting can be difficult to mirror in interactive plots. For example, no equivalent
    of the `pch` graphical parameter is readily available in `rgl`. To plot different
    symbols, you would need to design, render, and place new 3D shapes.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f26-03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 26-3: This demonstrates the addition of lines and a plane grid to a*
    `plot3d` *3D scatterplot of the* `iris` *data to mimic the earlier* `scatterplot3d`
    *example of the same data.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**Exercise 26.1**'
  prefs: []
  type: TYPE_NORMAL
- en: Turn back to the `survey` data frame in the `MASS` package, checking the description
    of the present variables in the help file `?survey` if you need to. Create a copy
    of `survey` containing only the writing handspan, nonwriting handspan, left- or
    right-handedness, sex, and height columns. Then use `na.omit` to remove any rows
    of this subsetted data frame that contain missing values.
  prefs: []
  type: TYPE_NORMAL
- en: Produce a basic interactive 3D point cloud of student height on the *z*-axis,
    writing handspan on the *x*-axis, and nonwriting handspan on the *y*-axis.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create a more informative version of the scatterplot in (a) that uses color
    to distinguish between sexes and uses point size to distinguish between left-
    and right-handed individuals, following these guidelines:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: – Start by plotting only those points that correspond to right-handed individuals.
    Set the color via vector indexing using the numeric version of sex for right-handed
    individuals—females should be black, males red.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: – Set the plotted point size as 4 for the right-handed individuals and ensure
    tidy axis labels.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: – Using `points3d`, add the points for left-handed individuals to the existing
    plot. Colors are to be assigned according to sex in the same way as for the right-handed
    students, but this time, the point size should be set at 10.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '– Resize the RGL device to your liking and add a legend to the top-left corner
    that references the four types of points: `"Male RH"`, `"Female RH"`, `"Male LH"`,
    and `"Female LH"`. In setting the legend, use a `pch` value of `19` and use `pt.cex`
    values of `0.8` and `1.5` for right- and left-handed individuals, respectively.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'For reference, my version of the rotatable 3D scatterplot is shown here:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![image](../images/f0698-01.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: In [Exercise 25.2](ch25.xhtml#ch25exc2) on [page 652](ch25.xhtml#page_652),
    you looked at a static 3D scatterplot of the built-in `airquality` data. Again,
    create a copy of the data frame, omitting any rows with `NA` entries.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a similar version of the plot from the earlier exercise using `rgl`
    functionality, displaying wind speed, solar radiation, and temperature on the
    *x*-, *y*-, and *z*-axes, respectively, according to the following guidelines:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: – Set up 50 colors from the built-in `topo.colors` palette. Set up the appropriate
    color index vector for the ozone values, based on the categorization approach.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: – Plot the observations as size 1 spheres, colored as before, and modify the
    aspect ratio so that the *y*-axis is 1.5 times the length of the other two axes.
    Provide neat axis titles.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: – Add correspondingly colored lines, one for each observation, stretching vertically
    upward from the *x*-*y* plane to meet the plotted spheres. Also, place a grid
    on the lower *x*-*y* plane.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '– Modify the background of the RGL device to include a color legend referencing
    the ozone level; use a sequence of values between 60 and 95, in steps of 5, to
    label it. Here’s my result:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![image](../images/f0699-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**26.2 Bivariate Surfaces**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Next you’ll look at plotting bivariate surfaces—a continuous surface calculated
    with respect to a 2D *x*-*y* evaluation grid—with `rgl`. In [Chapter 25](ch25.xhtml#ch25),
    you plotted these using `contour`, `filled.contour`, `image`, and `persp` in base
    R graphics. Anything that you’re able to plot using those functions can also be
    plotted as an interactive perspective plot with the `persp3d` function of `rgl`.
  prefs: []
  type: TYPE_NORMAL
- en: '***26.2.1 Basic Perspective Surface***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Take the `mtcars` response surface of mean MPG as a function of horsepower
    and weight (first used in [Section 25.4.1](ch25.xhtml#ch25lev2sec254)) as an easy
    initial example. In [Section 25.6.1](ch25.xhtml#ch25lev2sec258), you plotted static,
    base R perspective plots of this surface. The next few lines will refit the multiple
    linear regression model and re-create the 20 × 20 evaluation grid *x*- and *y*-sequences:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: To create the surface, predict using the evaluation grid in `hp.wt` as you’ve
    done previously, but this time, include the calculation of a prediction interval
    for the raw observations.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: '(You’ll use the interval in a later example.) Then, construct the *z*-matrix
    and draw a green `persp3d` surface with the following two lines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: The result is shown on the left of [Figure 26-4](ch26.xhtml#ch26fig4). If you
    compare it to [Figure 25-19](ch25.xhtml#ch25fig19) on [page 681](ch25.xhtml#page_681),
    you can see that it shows the same surface. The default lighting and shadowing
    effect produced by the `persp3d` surface helps with depth perception, similar
    to the `shade` argument to `persp`. The main benefit of this version is the mouse-based
    rotation and zoom interactivity.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f26-04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 26-4: Two interactive* `persp3d` *versions of the* `mtcars` *response
    surface. Left: Default appearance in green. Right: Red, 70 percent opacity surface,
    with original data superimposed in the 3D space. Both plots can be rotated and
    zoomed with the mouse.*'
  prefs: []
  type: TYPE_NORMAL
- en: '***26.2.2 Additional Components***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Another useful attribute of a `persp3d` plotted surface is the ability to add
    further components easily—something that’s nowhere near as straightforward in
    base R functionality. You’ll continue using the objects just created for the `mtcars`
    response surface.
  prefs: []
  type: TYPE_NORMAL
- en: '**Adding Points**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'As this response surface is based on a model fitted to data on the three variables
    of horsepower, weight, and MPG, it would be useful to view the raw observations
    alongside the fitted model. For this, you can use `points3d`, which works just
    like `points` in base R graphics. Execute the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Resize the RGL device to your liking and keep the device open. These two commands
    plotted the predicted mean MPG response surface, this time in red at 70 percent
    opacity using the optional `alpha` argument, and then added the raw observations
    to the same image in green, slightly enlarged from their default size. You can
    see this plot on the right of [Figure 26-4](ch26.xhtml#ch26fig4); you can now
    compare the fit of the response surface to the raw data and view it from any angle.
  prefs: []
  type: TYPE_NORMAL
- en: '**Adding Surfaces**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: You can also add more perspective surfaces! Let’s continue to add to the current
    plot using the `car.pred` object you created for [Figure 26-4](ch26.xhtml#ch26fig4).
    The response surface is stored as the first column in `car.pred`; the corresponding
    lower and upper prediction limits are stored as the second and third columns—flip
    back to [Section 20.4.2](ch20.xhtml#ch20lev2sec182) for a discussion of `predict`
    for linear regression models. To add these prediction bounds to the response surface
    displayed on the right of [Figure 26-4](ch26.xhtml#ch26fig4), you first need to
    store each bounding surface as a *z*-matrix corresponding to the *x*-*y* evaluation
    grid.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Then, simply call `persp3d` for each of these *z*-matrices and use the optional
    `add` argument set to `TRUE`—this instructs the `persp3d` function to add to the
    existing graphic without refreshing the plot.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Here you’ve also set the color for each additional surface to cyan and set the
    opacity at 50 percent. You can see the result on the left of [Figure 26-5](ch26.xhtml#ch26fig5).
    After rotating it with your mouse, you’ll be able to see that the observations
    all fall between the 3D 99 percent prediction interval bounds for this particular
    model.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f26-05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 26-5: Adding further surfaces denoting the 99 percent prediction interval
    to an existing* `persp3d` *plot of the fitted* `mtcars` *model. Left: Green points
    make up the raw observations. Right: Raw observations are labeled with added text,
    and corresponding line segments mark the corresponding residuals.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Alternatively, you could label raw observations with the row names attribute
    of the original `mtcars` data frame as added text so that you could identify which
    car is which in the plot. In this case, the names are obtained as a vector of
    character strings using the built-in `rownames` function. To add text to an existing
    3D graphic, `rgl` has its own analog of the traditional `text` function, `text3d`.
    Executing the following four lines replots the translucent red response surface,
    adds the appropriate text at the (*x*, *y*, *z*) coordinates corresponding to
    that car, and again adds the cyan prediction interval:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: The text is harder to visually locate than the green dots, so it makes sense
    to point their locations out on the fitted surface—and what better way to do so
    than using the fitted model residuals? The `segments3d` function is ideal for
    this purpose, as you know from the 3D scatterplots of the `iris` data. First,
    you need to set up the “from–to” vectors in the three coordinates (refer to [Section
    26.1](ch26.xhtml#ch26lev1sec92) for an explanation of `segments3d`).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Here, again, the *x*- and *y*-axis values don’t change when moving from the
    “from” location to the “to” location, so these are simply double-replicates of
    each horsepower and weight entry of the original data frame. You need to instruct
    the *z*-axis “from” values to remain as the fitted values of the model (in other
    words, the actual vertical location of the response surface), and the “to” values
    are the raw data *z* values. Then, a final call to `segments3d` draws on the residuals,
    as standard black line segments, for each `text3d`-labeled car.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Take a moment to interact with the final product, shown on the right of [Figure
    26-5](ch26.xhtml#ch26fig5).
  prefs: []
  type: TYPE_NORMAL
- en: '***26.2.3 Coloring by z Value***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: One advantage of `persp3d` plots is that you can color the surface according
    to the *z* values without needing to do anything special. Recall that if you were
    using the base R `persp` function, coloring by *z* value would require a minor
    workaround, because you’d need to calculate the relevant vertical position as
    the average of four adjacent *z*-matrix entries that make up each facet (see [Section
    25.6.2](ch25.xhtml#ch25lev2sec259)).
  prefs: []
  type: TYPE_NORMAL
- en: Fortunately, this isn’t necessary with `persp3d`. Continuing one last time with
    the `mtcars` response surface, you can set up your desired color palette and assign
    colors to the entries of the *z*-matrix themselves without having to average out
    each set of four adjacent values first.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Then, using categorization to assign color to values on a continuum, you just
    need to index `blues200` by `zm.colors` when specifying the `col` value in `persp3d`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: '[Figure 26-6](ch26.xhtml#ch26fig6) shows the result.'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f26-06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 26-6: Showing a result of direct color assignment corresponding to
    the* z*-matrix value in use of* `persp3d` *for the* `mtcars` *response surface*'
  prefs: []
  type: TYPE_NORMAL
- en: '***26.2.4 Dealing with the Aspect Ratio***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Taking a break from the `mtcars` model, you’ll now return to the bivariate
    kernel density estimate of the Chorley-Ribble data, used in [Sections 25.5.2](ch25.xhtml#ch25lev2sec257)
    and [25.6.2](ch25.xhtml#ch25lev2sec259). Load the `spatstat` package to access
    the `chorley` data and use the `MASS` package to access the `kde2D` function.
    Repeated from earlier for convenience, the following code calculates the KDE surface
    using `kde2D`, stored as the `$z` component of the `chor.dens.WIN` object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: It also truncates the surface to fall within the polygon that represents the
    geographical study region by setting all elements of the *z*-matrix outside that
    polygon to `NA` (you studied in detail how to do this in [Section 25.5.2](ch25.xhtml#ch25lev2sec257)).
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, executing the next few lines of code generates 200 colors from the built-in
    `rainbow` palette that you’ve used previously for this KDE plot and categorizes
    the entries of the truncated *z*-matrix appropriately:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Note again that the difference here is you don’t need to calculate facet averages
    as you did in [Section 25.6.2](ch25.xhtml#ch25lev2sec259)—`cut` is applied directly
    to `zm`.
  prefs: []
  type: TYPE_NORMAL
- en: Before calling `persp3d`, it’s worth remembering that since you’re dealing with
    a geographical area, you should consider the aspect ratio in the *x*- and *y*-coordinate
    directions. As you saw in [Section 26.1](ch26.xhtml#ch26lev1sec92), the `aspect`
    argument in `rgl` functions operates a little differently than the `asp` argument
    in `image` or the `scale`/`expand` arguments in `persp`. In `rgl` plots, including
    `persp3d`, `aspect` requests a numeric vector of length 3, which defines the relative
    scale of the *x*-, *y*-, and *z*-axes, in that order.
  prefs: []
  type: TYPE_NORMAL
- en: To determine the appropriate relative scales for the Chorley-Ribble data, you
    need to calculate the total *x*-axis and *y*-axis widths that the study region
    is defined upon and find their ratio.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: This was done using the `$xrange` and `$yrange` components of the `spatstat`
    polygon, subtracting the lower limit from the upper in each case. The final ratio
    of `xd/yd` reveals that you almost have a one-to-one scale, though technically
    the region is physically wider in the *x*-axis, by a factor of around 1.076, than
    it is in the *y*-axis.
  prefs: []
  type: TYPE_NORMAL
- en: Factoring that in, you can call `persp3d` to plot the KDE surface correctly.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: You use `aspect` to stipulate that the *x*-axis should be scaled according to
    a factor of `xd/yd` relative to the *y*-axis, that the *y*-axis is taken as the
    reference scale of 1, and that the *z*-axis should be squashed by a factor of
    0.75 relative to the *y*-axis. This is arbitrarily set so that the graphic is
    similar to the original `persp` plot in [Figure 25-21](ch25.xhtml#ch25fig21) on
    [page 685](ch25.xhtml#page_685).
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s finish off the plot by adding a color legend. Ensure you have the `shape`
    package loaded, resize your RGL device containing the result of the most recent
    call to `persp3d`, and execute the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Remember that `bgplot3d` must be used to change the background of the current
    RGL device—refer to the end of [Section 26.1](ch26.xhtml#ch26lev1sec92). You might
    want to experiment a little with `posx` and `posy` to find your preferred placement
    of the color legend. [Figure 26-7](ch26.xhtml#ch26fig7) shows the result on my
    machine.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f26-07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 26-7: An interactive* `persp3d` *representation of the Chorley-Ribble
    kernel density estimate, colored according to* z*-axis values, with a static color
    legend*'
  prefs: []
  type: TYPE_NORMAL
- en: '**Exercise 26.2**'
  prefs: []
  type: TYPE_NORMAL
- en: Return to the measurements in the built-in `airquality` data frame. Create a
    copy of the data frame containing the variables pertaining to temperature, wind
    speed, ozone level, and month; delete all rows with any missing values. You’re
    now going to experiment with an `rgl` visualization of an earlier regression model
    for mean temperature.
  prefs: []
  type: TYPE_NORMAL
- en: Refit the multiple linear model from [Exercise 25.4](ch25.xhtml#ch25exc4) on
    [page 676](ch25.xhtml#page_676), which regressed temperature against the main
    effects and an interactive effect of wind speed and ozone. Use `expand.grid` and
    `predict` to construct a *z*-matrix of the response surface; include the estimation
    of a 95 percent confidence interval for the fitted mean. Then, use `rgl` functionality
    to produce an interactive 3D plot of the response surface and color it yellow.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Using the built-in `topo.colors` palette, replot the response surface, assigning
    the colors according to the *z* value and setting the opacity at 80 percent. Tidy
    up the axis titles, resize the RGL device, and leave the plot open.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Enhance the plot from (b) as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Generate exactly five colors from a custom palette that goes from `"red4"` to
    `"pink"` and add the raw wind, ozone, and temperature observations as points to
    the plot of the response surface. The points should be colored according to month
    (May through September) using these five colors in order. Set the size of the
    added points to `10`.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Add vertical lines that denote the residuals of the fitted model to the plot;
    in other words, each observation should have a vertical line connecting it to
    the corresponding fitted value of the response surface. These added lines should
    use the custom palette from earlier to match the color of each data point.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Add the upper and lower 95 percent confidence limits you stored as part of the
    model prediction in (a). The added surfaces should both be gray with 50 percent
    opacity.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a legend to the top-right corner of the interactive plot referencing the
    five colors of points/lines according to month. Use a `pch` value of `19` and
    a `cex` value of `2`.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The result should look like this:'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '![image](../images/f0707-01.jpg)'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_IMG
- en: 'Next, load the `spatstat` package and revisit the `clmfires` data set. Execute
    the following lines to restrict attention to only the intentionally lit fires
    and to obtain the geographical study region:'
  prefs: []
  type: TYPE_NORMAL
- en: R> fire <- split(clmfires)$intentional
  prefs: []
  type: TYPE_NORMAL
- en: R> firewin <- clmfires$window
  prefs: []
  type: TYPE_NORMAL
- en: Reproduce the static perspective plot from [Exercise 25.5](ch25.xhtml#ch25exc5)
    (e) on [page 689](ch25.xhtml#page_689) as an interactive perspective plot, based
    on the following guidelines. Then keep the plot open.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: – Calculate the KDE surface of the `$x`- and `$y`-coordinates of `fire`, truncated
    to the study region in `firewin`, using a 256 × 256 evaluation grid.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: – Use the built-in color palette `heat.colors` to color the surface according
    to the *z* value. Set the opacity to 70 percent.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: – Ensure the *x*-*y* axes have the correct ratio. Then reduce the vertical aspect
    ratio to be 0.6 relative to the *y*-axis.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: – Suppress the *z*-axis title but add neat `"X"` and `"Y"` titles to the other
    two axes.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Make the following enhancements to the plot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add the raw observations so they lie underneath the surface itself. To do this,
    set a constant *z* value for each data point as the minimum (and non-`NA`) value
    of the *z*-matrix.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'You can obtain the vectors of the *x*- and *y*-coordinates of the irregular
    polygon that forms the study region by using the `vertices` function of `spatstat`
    as follows:'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: R> firepoly <- vertices(firewin)
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: R> fwx <- firepoly$x
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: R> fwy <- firepoly$y
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: By supplying these two vectors to the appropriate `x` and `y` arguments of the
    `lines3d` function, add the study region to surround the superimposed observations
    lying flush to the *x*-*y* plane underneath the plotted surface. Again, you’ll
    need to specify the *z* value as the minimum *z*-matrix value for all drawn lines.
    Set `lwd=2` for a slightly thicker line than the one drawn by default.
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Your production should look something like this:'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '![image](../images/f0708-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**26.3 Trivariate Surfaces**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: So far you’ve looked at bivariate functions of the form *z* = *f* (*x*, *y*),
    where your evaluation grid is two-dimensional. In other words, you evaluate the
    function *f* from an *x* value and a *y* value; the *x* and *y* values are plotted
    on the first two axes, and the values of *f* are used to plot a third dimension.
    Next you’ll plot *trivariate* functions, which can be thought of as *w* = *f*
    (*x*, *y*, *z*). That is, the evaluation grid is itself three-dimensional, and
    *f* gives you a fourth value, *w*, to use for plotting the surface.
  prefs: []
  type: TYPE_NORMAL
- en: '***26.3.1 Evaluation Coordinates in 3D***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: When dealing with a trivariate mathematical function, you need an *x*, a *y*,
    and a *z* value to evaluate the result. Rather than a flat evaluation grid, you’ll
    have an evaluation *lattice* that sits in a cube or some other 3D prism.
  prefs: []
  type: TYPE_NORMAL
- en: As a perfect first example of a trivariate function, you’ll create a “color
    cube” of RGB colors, where each point is the result of three values in red, green,
    and blue—refer to [Section 25.1.1](ch25.xhtml#ch25lev2sec242) for details. You’ll
    use the three physical axes to reflect the evaluation lattice in the red, green,
    and blue values, and the result will be a point plotted with that color in that
    position in the 3D space.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code sets up the evaluation lattice in the three coordinate directions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: The first four lines generate equally spaced increasing sequences in the three
    colors spanning the standard 0 to 255 RGB integer range. Then you use the built-in
    `expand.grid` function to generate the data frame of all unique color triplets
    according to these three sequences, resulting in an evaluation lattice of exactly
    11³ = 1331 specific coordinates. Note that `expand.grid` works in the same way
    for higher-dimensional evaluation grids as it does for bivariate *x*-*y* grids
    (refer to [Section 25.3.1](ch25.xhtml#ch25lev2sec251)).
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, a call to `plot3d` places spheres at each 3D evaluation coordinate
    (recall the use of the `rgb` command from [Section 25.1.1](ch25.xhtml#ch25lev2sec242)):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: '[Figure 26-8](ch26.xhtml#ch26fig8) shows the result from two different angles
    so you can see how the intensities of the red, green, and blue components of an
    RGB triplet control the color of each point.'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f26-08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 26-8: The* `rgl` *“color cube,” created as spheres whose fourth-dimension
    result (color itself) is the product of evaluating the trivariate RGB function.*'
  prefs: []
  type: TYPE_NORMAL
- en: '***26.3.2 Isosurfaces***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: One of the problems with plotting the individual spheres of points at each 3D
    evaluation coordinate is revealed by [Figure 26-8](ch26.xhtml#ch26fig8)—it’s difficult
    to see spheres “inside” the 3D prism. This same issue complicates the more general
    case of visualizing a continuous trivariate function.
  prefs: []
  type: TYPE_NORMAL
- en: To remedy this, you could instead produce an *isosurface*, which can be thought
    of as a kind of trivariate analog of a contour plot.
  prefs: []
  type: TYPE_NORMAL
- en: With an isosurface, you select a certain level of the values *w* = *f* (*x*,
    *y*, *z*) and join up all the entries of *w* at that level inside the 3D space
    to form a shape or “blob.” These blobs show where in the 3D space the trivariate
    function takes on the chosen value. If you then plot these blobs at various levels,
    you get a 3D version of the contour plots you created in [Section 25.4.1](ch25.xhtml#ch25lev2sec254),
    showing which levels hold the highest densities of observations.
  prefs: []
  type: TYPE_NORMAL
- en: '**Higher-Dimensional Probability Densities**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Cast your mind back to the univariate normal probability density function detailed
    in [Section 16.2.2](ch16.xhtml#ch16lev2sec142). First, I’ll introduce the idea
    of higherdimensional density functions with the bivariate version of the normal
    distribution, and then I’ll go one step further and use the trivariate version
    to illustrate isosurface plotting.
  prefs: []
  type: TYPE_NORMAL
- en: 'To work with multivariate normal distributions, you can use the `mvtnorm` package,
    installed with a call to `install.packages("mvtnorm")`. Just like the `rnorm`
    function for the univariate normal, the `rmvnorm` function is used to generate
    random variates from a specified multivariate normal. Once you’ve installed `mvtnorm`,
    execute the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: This produces the plot on the left of [Figure 26-9](ch26.xhtml#ch26fig9). The
    `rmvnorm` function is used to generate 500 independent variates from the standard
    bivariate normal distribution. You center the variates around the coordinate (0,0)
    by passing a numeric vector to `mean`. By default, independent standard deviation
    components of 1 are used in both *x*-*y* coordinate directions.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f26-09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 26-9: Viewing randomly generated data, and the standard bivariate normal
    density they came from, using* `mvtnorm` *functionality*'
  prefs: []
  type: TYPE_NORMAL
- en: 'To actually view the bivariate density function, you need to decide on the
    *x*-*y* evaluation grid and construct the *z*-matrix as usual using `expand.grid`.
    The following code sets up an evenly spaced sequence to use in both coordinate
    directions and uses the `dmvnorm` function (this is the multivariate version of
    `dnorm` and gives you the density function value at specified coordinates) to
    fill the *z*-matrix:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, you can use `contour` (or `persp` or `persp3d`) to view the density from
    which the data in `rand2d.norm` were generated for comparison (truncated to the
    limits −3 to 3 in both axes). The following line produces the plot on the right
    of [Figure 26-9](ch26.xhtml#ch26fig9):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: '**Basic One-Level Isosurface**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Now let’s increase the dimension once more—what does a *trivariate* normal density
    function look like?
  prefs: []
  type: TYPE_NORMAL
- en: 'First, let’s take a look at some data generated from this density. The following
    code generates 500 random variates again:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: However, since you supplied a vector of length 3 as the `mean` argument to `rmvnorm`,
    the function knows you have three dimensions to work with. You’re telling it that
    you want the data to come from a trivariate normal, with means of 0, 0, and 0
    in each coordinate direction. You can see the `rgl` point cloud of the data produced
    via `plot3d` on the left of [Figure 26-10](ch26.xhtml#ch26fig10).
  prefs: []
  type: TYPE_NORMAL
- en: To calculate and display the actual trivariate density function that generated
    these data, you’ll need a 3D evaluation lattice, as noted at the beginning of
    [Section 26.3](ch26.xhtml#ch26lev1sec94).
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f26-10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 26-10: Left: Viewing data randomly generated from the standard trivariate
    normal distribution. Right: Concept of the 3D evaluation lattice upon which the
    trivariate density function itself will be plotted.*'
  prefs: []
  type: TYPE_NORMAL
- en: Take a look at the plot on the right of [Figure 26-10](ch26.xhtml#ch26fig10).
    It shows a 3D 11 × 11 × 11 evaluation lattice based on sequences spanning [−3,3]
    in *x*, *y*, and *z*. This should give you a clear idea of how increasing the
    dimension of a continuous function works. Each intersection in the 11 × 11 × 11
    grid is the 3D equivalent of each intersection of the solid lines in the 2D 6
    × 4 evaluation grid in [Figure 25-9](ch25.xhtml#ch25fig9) on [page 656](ch25.xhtml#page_656),
    and each of the 10³ mini-3D cubes in this 3D lattice is the 3D equivalent of a
    2D facet, as noted in the discussion of [Figure 25-20](ch25.xhtml#ch25fig20) on
    [page 683](ch25.xhtml#page_683). (As with [Figure 25-9](ch25.xhtml#ch25fig9),
    you can find the code to plot this 3D lattice on the book’s website.)
  prefs: []
  type: TYPE_NORMAL
- en: To plot the result of the trivariate function, you need the unique evaluation
    coordinates of the evaluation lattice. Using `vals`, the sequence of values between
    −3 and 3 created earlier, the following code produces a data frame of all 50³
    = 125,000 unique 3D evaluation lattice coordinates.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Then you use `dmvnorm` to get the numeric value of the standard trivariate normal
    just as you did in the bivariate setting. The function automatically knows you’re
    requesting the trivariate density because your data argument `xyz` has three columns.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Note that the result is stored appropriately as a 50 × 50 × 50 3D array—refer
    to [Section 3.4](ch03.xhtml#ch03lev1sec15) for details on `array`. Look at the
    conceptual diagram of a 3D array ([Figure 3-3](ch03.xhtml#ch3fig3) on [page 53](ch03.xhtml#page_53))
    and compare it to the 3D lattice on the right of [Figure 26-10](ch26.xhtml#ch26fig10).
    The trivariate normal values in the object `w` are clearly represented by a 3D
    block of numbers sitting at each corresponding unique evaluation coordinate in
    the defined 3D space.
  prefs: []
  type: TYPE_NORMAL
- en: An isosurface can be produced using the `contour3d` function, part of the `misc3d`
    package ([Feng and Tierney, 2008](ref.xhtml#ref22)), which works closely with
    `rgl`. To use it, you need to decide on the level (or levels) at which to plot
    the surface. For densities, you typically make this choice with respect to what’s
    called the *α*-level contours; for more details, see the authoritative text on
    the theory of multivariate densities by Scott ([1992](ref.xhtml#ref60)). In brief,
    for some density *f*, these levels delineate the (1 − *α*) × 100 percent “most
    dense” observations by setting the isosurface to be drawn at positions in the
    multivariate evaluation lattice that correspond to the density value given by
    *α* × max(*f*).
  prefs: []
  type: TYPE_NORMAL
- en: For the trivariate standard normal, the maximum value of the density is located
    at the mean at the coordinate (0,0,0).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: You’ll use this when producing the next couple of plots. Next, install `misc3d`,
    load it with `library("misc3d")`, and then call `contour3d`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: This produces an isosurface in an RGL device that you can rotate and zoom as
    you desire; you can see the result on the left of [Figure 26-11](ch26.xhtml#ch26fig11).
    You supply `contour3d` with the arguments `x`, `y`, and `z` as evenly spaced sequences
    in the *x*-, *y*-, and *z*-coordinate directions, respectively (all are defined
    by the vector `vals` in this case). You supply the corresponding 3D array, defining
    the entire result of the trivariate function to `f`, and pass the level (or levels)
    at which you want to draw the isosurface itself to `level`. Here, I’ve chosen
    the *α*-level to leave only 5 percent of the probability in the tails of the distribution,
    meaning that 95 percent of the total mass is held within the “blob.”
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f26-11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 26-11: An isosurface of the trivariate standard normal density function
    produced using* `contour3d` *of the* `misc3d` *package. Left: Stand-alone plot
    drawn at an *α* level of 0.05\. Right: Adding the same surface to an existing*
    `rgl` *plot of randomly generated trivariate normal observations, at 50 percent
    opacity.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'The plot matches what you might expect—the shape of the trivariate density
    is relatively clear based on the plot of the randomly generated data you produced
    earlier. However, without scale, it’s little more than a statistical golf ball.
    It’s often more helpful to view the data alongside the density from which they
    came, which is also easy to do. The following code replots the data in `rand3d.norm`
    using `plot3d` and calls `contour3d` again to draw at the *α* level of 0.05:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: Just as with the traditional R `contour` function, if you want to use `contour3d`
    to add to an existing `rgl` plot (as is the case here), you need to explicitly
    specify `add=TRUE`. You can also use the optional `alpha` argument to adjust opacity,
    reduced to 50 percent in this example, to “see inside” the density isosurface.
  prefs: []
  type: TYPE_NORMAL
- en: '**Controlling Multiple Levels with Color and Opacity**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Playing with opacity is especially useful when you want to plot the isosurface
    at multiple *α* levels at once. Color is also useful in this way, as a variable
    that can represent a fourth dimension without adding an additional physical axis
    to the graph.
  prefs: []
  type: TYPE_NORMAL
- en: 'To view the trivariate normal density at multiple levels, consider the plot
    produced by executing the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: '[Figure 26-12](ch26.xhtml#ch26fig12) shows the result. Here, you replot the
    500 randomly generated trivariate normal observations, and another call to `contour3d`
    now draws contours at four specific *α*-levels of the trivariate density—0.05,
    0.2, 0.6, and 0.95\. You use the optional `color` argument to render these inpink,
    green, blue, and red, respectively, and progressively increase the opacity of
    each level with the `alpha` argument.'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f26-12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 26-12: An isosurface of the trivariate normal density plotted at four
    levels, over the randomly generated observations. Color and opacity are used to
    distinguish among the different numeric levels of the plotted function.*'
  prefs: []
  type: TYPE_NORMAL
- en: You should be able to see that you can gauge the increase in the denseness of
    the points in the 3D space for this distribution in a similar way as you’d use
    standard 2D contours to appraise the distribution of bivariate observations.
  prefs: []
  type: TYPE_NORMAL
- en: '***26.3.3 Example: Nonparametric Trivariate Density***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: For an extended example using real data, look once more at the built-in `quakes`
    data frame, which includes the spatial location, magnitude, and depth of 1000
    seismic events.
  prefs: []
  type: TYPE_NORMAL
- en: In [Section 25.4.1](ch25.xhtml#ch25lev2sec254), you constructed bivariate kernel
    density estimates of the 2D longitude-latitude spatial coordinates, using the
    `MASS` function `kde2D`. As noted there, KDE extends naturally to higher dimensions.
    The goal now is to calculate and visualize a density estimate of the same spatial
    earthquake data, but this time to do so based on the trivariate coordinates of
    longitude, latitude, *and* depth, in 3D space.
  prefs: []
  type: TYPE_NORMAL
- en: '**Raw Data**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: First, let’s look at the raw observations. The following code creates a copy
    of the `quakes` data, extracting those three variables and rendering `depth` negative.
    I dothis so that, when plotted, earthquake depth corresponds to moving *down*
    the vertical axis to give the impression of depth below sea level.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'In the usual `rgl` fashion, you create a point cloud of the raw data with the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: '[Figure 26-13](ch26.xhtml#ch26fig13) shows the result. If you spin the plot
    so that you’re looking down directly from the top with a bird’s-eye view, you’ll
    recognize the 2D spatial patterning that you’ve plotted already; see, for example,
    [Figure 13-1](ch13.xhtml#ch13fig1) ([page 265](ch13.xhtml#page_265)), [Figure
    23-1](ch23.xhtml#ch23fig1) ([page 578](ch23.xhtml#page_578)), or [Figure 25-12](ch25.xhtml#ch25fig12)
    ([page 662](ch25.xhtml#page_662)).'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f26-13.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 26-13: Viewing the 3D spatial dispersion of the earthquake occurrences—latitude,
    longitude, and depth*'
  prefs: []
  type: TYPE_NORMAL
- en: '**Calculating the 3D Estimate**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: The evaluation lattice for this kernel estimate will be defined by the entire
    3D space in which the longitude-latitude-depth data reside, exactly as illustrated
    in [Section 26.3.2](ch26.xhtml#ch26lev2sec269).
  prefs: []
  type: TYPE_NORMAL
- en: To actually calculate the 3D KDE surface for the `quak` data, you’ll use the
    impressive functionality of the contributed package `ks` ([Duong, 2007](ref.xhtml#ref20)).
    Install the package and load it with a call to `library("ks")`. The `kde` function
    within the `ks` package allows you to use kernel smoothing to estimate the probability
    density of 1D through 6D data.
  prefs: []
  type: TYPE_NORMAL
- en: The first argument you supply to `kde` is your data, in the form of a matrix
    or data frame, with the tag `x`. Note that the order of the columns in your data
    object matters when using `kde`. When called as follows with `quak`, and taking
    into account the extraction order of the three variables in the earlier code that
    created `quak`, the *x*-, *y*-, and *z*-coordinate axes in the resulting 3D kernel
    estimate will correspond to longitude, latitude, and depth, respectively.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: This matches the way the data are displayed in [Figure 26-13](ch26.xhtml#ch26fig13).
    The `gridsize` argument specifies the lattice resolution in each axis. In this
    example, I’ve settled on a 64 × 64 × 64 lattice; by default, `kde` chooses the
    range of evaluation in each coordinate direction so that it’s slightly wider than
    the observed data. Finally, to plot the result, it’s useful to also specify the
    argument `compute.cont=TRUE`; I’ll go into the reason for this in a moment.
  prefs: []
  type: TYPE_NORMAL
- en: 'The returned object has several components. The 3D estimate is provided as
    an appropriately sized array as the `$estimate` member; if you want to check,
    execution of the following line confirms it matches the desired lattice resolution:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'The `$eval.points` component holds a list whose members are the specific evaluation
    coordinates, which are equally spaced sequences in each of the three axes. The
    number of members reflects the dimension of the problem, and their order corresponds
    to the specific axis. You can extract them with the following lines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: If you print these vectors to your console screen, you’ll see that each is a
    vector of length 64, with `x.latt`, `y.latt`, and `z.latt` corresponding to the
    variables matching the order of the columns in the data frame `quak`.
  prefs: []
  type: TYPE_NORMAL
- en: '**Isosurface Level Selection**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: The selection of the level to display depends on the range of values that make
    up the result of the trivariate function itself. When you choose `compute.cont=TRUE`
    in the call to `kde`, you’re automatically provided with a collection of appropriate
    levels. These are returned in the component `$cont` as a numeric vector with a
    length of exactly 99, representing each integer between 1 percent and 99 percent.
  prefs: []
  type: TYPE_NORMAL
- en: Internally, these levels are calculated by working out the result of the trivariate
    function at the location of each of the originally observed data points and then
    using `quantile` to obtain all the integer-valued percentiles (from 99 percent
    to 1 percent) of these density values (for a refresher on quantiles, refer to
    [Section 13.2.3](ch13.xhtml#ch13lev2sec118)). These are returned in decreasing
    order; in other words, `quak.dens3d$cont[1]` corresponds to the 99th percentile,
    and `quak.dens3d$cont[99]` is the 1st percentile.
  prefs: []
  type: TYPE_NORMAL
- en: 'Though these values are obtained in a different way from the *α*-levels you
    experimented with when plotting the trivariate normal density, you essentially
    end up with same interpretation when visualizing the result—these values allow
    you to draw the isosurfaces at the level of estimated observation “denseness”
    that you want. For example, the lower quartile (aka the 25th percentile) is extracted
    with the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: This provides the value of the KDE trivariate function that is estimated to
    separate the most spatially diffuse 25 percent of the observations from the rest
    (in other words, so that the resulting blobs encapsulate the most spatially dense
    75 percent of the data).
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*At the time of writing, both the* `rgl` *and* `misc3d` *packages are dependencies
    of* `ks`. *This means they are loaded automatically when you load* `ks`*, so you
    don’t need to call* `library("rgl")` *or* `library("misc3d")` *explicitly in this
    case, and* `plot3d` *and* `contour3d` *are already available to you. This may
    change as the developers update their packages over time.*'
  prefs: []
  type: TYPE_NORMAL
- en: When you execute the following code, it first replots the `quak` data that the
    density estimate is based on and then adds the corresponding isosurface using
    the lower point-wise density quartile as the desired level. You can see the result
    on the left of [Figure 26-14](ch26.xhtml#ch26fig14).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: '![image](../images/f26-14.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 26-14: Isosurfaces (3D contour plots) of a trivariate kernel density
    estimate drawn at point-specific density quantiles, based on use of the contributed*
    `kde` *and* `contour3d` *functions. Left: Solid blue delineation of the lower
    quartile—the 25 percent most diffuse points. Right: Green delineation of the median—the
    50 percent most diffuse from the 50 percent most dense—with opacity reduced by
    half.*'
  prefs: []
  type: TYPE_NORMAL
- en: Looking at the image, the blue blobs representing the 3D contour at the specified
    level are clear to see. Higher levels of the trivariate function, that is, more
    densely grouped points, are “inside” these blobs. In other words, the blue shapes
    encapsulate the observations associated with the highest 75 percent of estimated
    density with respect to latitude, longitude, and depth. To see inside the isosurfaces,
    you can adjust the opacity with `alpha`.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s take the level that delineates the observations associated with the lower
    and upper 50 percent of estimated density values.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: Then, rerun the call to `plot3d` to replot the raw `quak` data. After that,
    a call to `contour3d` produces the result on the right of [Figure 26-14](ch26.xhtml#ch26fig14),
    allowing you to see through the green blobs.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'Lastly, you’ll highlight the top 80 percent of the mostly densely clustered
    observations using multiple levels. Execute the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: This obtains four levels—the quantiles above which the 80 percent, 60 percent,
    40 percent, and 20 percent most densely clustered observations are identified.
    Then set up a couple of vectors to control the color and opacity of each increasing
    level of denseness accordingly.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: The range of colors and alpha levels means the isosurface will darken in color
    and become more opaque as the density increases.
  prefs: []
  type: TYPE_NORMAL
- en: One final time, replot the raw `quak` data using `plot3d` as earlier. Then it’s
    simply a matter of supplying your vectors of length 4 to each appropriate argument
    in `contour3d`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: '[Figure 26-15](ch26.xhtml#ch26fig15) shows the results. You can see that the
    tightest grouping of earthquakes occurs quite deep and toward the eastern edge
    of the 3D spatial prism (the visible “three-chamber” density blob is a well-known
    feature of these particular data).'
  prefs: []
  type: TYPE_NORMAL
- en: '**26.4 Handling Parametric Equations**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In most of the examples in the chapter so far, the surfaces are directly defined
    by the coordinates of a regular evaluation grid or lattice, but there are situations
    where the final axis you want to visualize is *not* a function of some evaluation
    grid. This occurs quite naturally when you simply want to draw familiar geometric
    shapes but also extends to more complicated situations in mathematics.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, you’ll plot from a collection of parametric equations, which
    together define the shape or surface of interest. This section will assume you’re
    familiar with the fundamental trigonometric functions *sine* and *cosine*, as
    well as the conversion of angles from *degrees* to *radians*, since by default
    R deals exclusively with the latter. That said, I’ll walk you through the relevant
    calculations and R code as needed.
  prefs: []
  type: TYPE_NORMAL
- en: '***26.4.1 Simple Loci***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Using mathematical terminology, a *locus* (plural *loci*) is a set of points
    that satisfy, and are defined by, a particular set of parametric equations. In
    R, these equations govern how individual numeric elements of the resulting objects
    are calculated, which you can then easily plot using familiar functions.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*When discussing loci, any reference to 2D or 3D space refers to* Euclidian
    space*, which is the standard way in which you’ve dealt with coordinates in the*
    x*-,* y*-, and* z*-axes so far.*'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f26-15.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 26-15: Three screenshots of the trivariate kernel density estimate
    of the earthquake observations, taken from varying angles and with different levels
    of zoom. Increasing levels of denseness are reflected by isosurfaces of darkening
    yellow-to-red color and increased opacity.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**2D Circle**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Let’s start with a simple example. One of the most immediately recognizable
    shapes defined in this way is a 2D circle. To find any point on a circle, you
    need to know the circle’s center and its radius, and you need to provide a specific
    angle at which to look (typically taken to be relative to a perfectly horizontal
    line). Any planar 2D point (*x*,*y*) that lies on a circle can be expressed with
    the following equations if you take the center to be at the coordinate (*a*, *b*),
    with a fixed radius of *r* > 0 and looking at the angle *θ*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/e26-1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: If you’re working in degrees, then technically 0 ≤ *θ* < 360; to convert to
    radians, you must multiply by *π*/180 such that 0 ≤ *θ* < 2*π*.
  prefs: []
  type: TYPE_NORMAL
- en: 'To draw a circle based on the equations in (26.1), first decide on a radius,
    then decide on a center point, and then generate the corresponding values of *x*
    and *y*. Consider the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: The circle will have a radius of 3 and be centered at (1,−4.4). Given the sequence
    defined as `angle`, note the plot will place a point at each integer angle from
    0 to 360 degrees—I’ve allowed the upper limit to be equal to exactly 360 to fully
    complete the rotation—after which you convert to radians (with multiplication
    by *π*/180) in order to use the built-in R functions `cos` and `sin`. The geometric
    value of pi (*π* = 3.1415...) is held within the ready-to-use R object `pi` (see
    the help file `?Constants`). The last three lines execute the plot, shown in [Figure
    26-16](ch26.xhtml#ch26fig16).
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f26-16.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 26-16: Drawing a 2D circle in R with center (1,*−*4.4) and radius 3,
    following the relevant parametric equations of the locus*'
  prefs: []
  type: TYPE_NORMAL
- en: The key takeaway here is that *y* isn’t calculated as a direct result of *x*
    in the same way as you might obtain a fine, evenly spaced increasing sequence
    in *x* and then evaluate *y* when plotting, for example, a linear regression model.
    Rather, the equations in (26.1) jointly define the rules of the locus in the 2D
    space.
  prefs: []
  type: TYPE_NORMAL
- en: '**3D Cylinder**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Plotting surfaces with three dimensions is done in much the same way, only now
    your equations set up the rules for all satisfying points in the *x*-, *y*-, and
    *z*-axes.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, points lying on a hollow cylinder can be defined by the following
    equations:'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/e26-2.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'To actually plot points that satisfy these rules, you need to decide on a fixed
    radius *r*, recognize that 0 ≤ *θ* < 360 (in degrees), and define a fixed maximum
    height *h* so that you can ensure 0 ≤ *z* ≤ *h*. With that information, to generate
    vectors for *x*, *y*, and *z*, you need to first set up numeric sequences spanning
    the possible values of *θ* and *z*. Consider the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: These lines show a radius of 3 set as `r` and a maximum height of 10 as `h`.
    The sequence in *z* is set up as the 11 integer values from 0 to 10 in `zseq`—this
    will allow you to place points on the locus at each of these defined *z* values.
    The sequence for *θ* is set up as 0 ≤ *θ* < 2*π* in `theta` (note the necessary
    conversion to radians). Then, you need all unique combinations of these parameter
    values to get all relevant (*x*, *y*, *z*) coordinates for plotting. You know
    how to do that from [Section 25.3.1](ch25.xhtml#ch25lev2sec251), using `expand.grid`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: Calling `nrow` on the result shows that you now have 11 × 361 = 3971 unique
    height-angle values. Now you’re able to generate the values for *x*, *y*, and
    *z* as defined by (26.2). You could use a `for` loop ([Section 10.2.1](ch10.xhtml#ch10lev2sec92)),
    cycling through each row of `ztheta`, but a neater way would be to use implicit
    looping in `apply` (refer to [Section 10.2.3](ch10.xhtml#ch10lev2sec94) for details).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: Note that disposable functions (see [Section 11.3.2](ch11.xhtml#ch11lev2sec104))
    are used to operate on the two-element height-angle (in that order) vectors that
    make up each row of `ztheta`.
  prefs: []
  type: TYPE_NORMAL
- en: You can use `persp3d` from `rgl` to plot this kind of parametrically defined
    surface, but in a slightly different way than in earlier sections of this chapter.
    The calculated `x`, `y`, and `z` coordinates must now *all* be supplied as identically
    sized, appropriately arranged matrices. This is because there’s no longer an evenly
    spaced evaluation grid in the *x*- and *y*-coordinate directions—along with the
    *z* values, the *x* and *y* values have all been defined through an application
    of (26.2). In these types of plots, you effectively have a *latent* evaluation
    grid defined by the unique combinations of parameter values (height and angle
    in this case).
  prefs: []
  type: TYPE_NORMAL
- en: The matrices in all of the *x*-, *y*-, and *z*-coordinates are given by the
    three 11 × 361 matrices filled with `x`, `y`, and `z` in the typical column-wise
    fashion.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'At this point, it’s worth introducing the built-in `outer` function, which
    takes a sequence of values in two variables and produces all unique combinations
    of values, computes the result at each combination, and then returns the results
    as a matrix—doing the three tasks just done by `expand.grid`, `apply`, and `matrix`
    in one go. With this approach, you could create `xm`, `ym`, and `zm` indentically
    by simply calling the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: The only difference here is that the anonymous function provided as the third
    argument must be explicitly defined in terms of two separate arguments that represent
    the values of the necessary height and angle parameters.
  prefs: []
  type: TYPE_NORMAL
- en: However you obtain `xm`, `ym`, and `zm`, it’s now just a matter of calling `persp3d`
    with these coordinate matrices. Make an additional call to `points3d` to emphasize
    the precise evaluation points that are returned in those matrices. The result
    of the next two lines is shown on the left of [Figure 26-17](ch26.xhtml#ch26fig17).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: '![image](../images/f26-17.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 26-17: Drawing a cylinder and a cone using* `persp3d`*, with matrix
    arguments in all three coordinate directions. The loci are defined by the corresponding
    parametric equations. The black rings visible on the cylinder represent the actual
    evaluation points stored in the required matrices* `xm`, `ym`*, and* `zm`.'
  prefs: []
  type: TYPE_NORMAL
- en: '**3D Cone**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'This next example will show that once you understand the procedure involved
    with setting up the *x*-, *y*-, and *z*-coordinate matrices, you can display virtually
    any 3D shape or surface with ease. Taking *r*, *h*, and *θ* to be the base radius,
    maximum height, and angle, respectively, a cone follows these equations:'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/e26-3.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Using the same objects `r`, `h`, `zseq`, and `theta` from earlier, the following
    code alters the disposable functions in `outer` to reflect (26.3). The right of
    [Figure 26-17](ch26.xhtml#ch26fig17) shows the result.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: '***26.4.2 Mathematical Abstractions***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Many areas of mathematics, applied mathematical modeling, and statistics utilize
    high-dimensional shapes. To round off this chapter, and indeed the book, let’s
    employ `rgl` to take a look at a couple of famous abstractions using skills from
    [Section 26.4.1](ch26.xhtml#ch26lev2sec271).
  prefs: []
  type: TYPE_NORMAL
- en: '**Möbius Strip**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: A classic example is the *Möbius strip*—a continuous surface that has only one
    side and one edge. It can be expressed using the parametric equations
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/e26-4.jpg)'
  prefs: []
  type: TYPE_IMG
- en: where
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f0726-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: with −1 ≤ *v* ≤ 1 and 0 ≤ *θ* < 2*π* (assuming angles measured in radians).
    The parameter *v* controls the position of the point along the width of the strip,
    and *θ* controls the rotation angle.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can draw the strip in the same way as the cylinder and cone from earlier.
    First, set up the sequences over the possible values of *v* and *θ*, done here
    at a resolution of 200 each:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: Next, use `outer` to obtain the 200 × 200 matrices in each of the *x*-, *y*-,
    and *z*-coordinates as per (26.4).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, a quick call to `plot3d` from the `rgl` package will show you the 40,000
    locations, based on the defined `vseq` and `theta` sequences, that lie on the
    Möbius strip. The result of the following line is shown on the left of [Figure
    26-18](ch26.xhtml#ch26fig18):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s display the strip as a continuous surface using `persp3d` to fully appreciate
    the one-side/one-edge phenomenon. The image on the right of [Figure 26-18](ch26.xhtml#ch26fig18)
    shows the result of the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: Note the use of `axes` to suppress the default box and axes and the use of empty
    strings to remove the default axis titles denoting `xm`, `ym`, and `zm`.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f26-18.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 26-18: Drawing a Möbius strip in R. Left: Specifically calculated points
    on the strip, visualized with* `plot3d`*. Right: Surface formed by joining up
    the points on the left via* `persp3d`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'You could also use color in a more interesting way to emphasize the wraparound
    nature of a Möbius strip. Taking inspiration from a similar collection of colors
    defined in [Section 25.1.3](ch25.xhtml#ch25lev2sec244), create the following custom
    palette:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: This palette has been specifically generated to go from a dark red to white
    to blue but also to wrap around from the blue back to white and the dark red.
    This is needed for the way in which colors from `patriot.colors` will be assigned,
    in a point-wise fashion, to the plotted strip.
  prefs: []
  type: TYPE_NORMAL
- en: 'The color vector for plotting the surface will need to be of length 200² =
    40,000 given the preset value of `res` (governing the length of both `vseq` and
    `theta`). To fill the vector, execute the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: The first line generates exactly 399 colors from `patriot.colors`, and the second
    sets up a vector of the required length, which will store the assigned colors
    (`stripcols`). The `for` loop ensures that at the first iteration, the elements
    `1` through `200` in `stripcols` will be assigned colors `1` through `200` from
    `patcols`; at the second iteration, the elements `201` through `400` will be assigned
    colors `2` through `201` from `patcols`, and so on. This gives the colors their
    wraparound appearance.
  prefs: []
  type: TYPE_NORMAL
- en: 'To properly understand the `for` loop, first look at the order of the arguments
    as supplied to the calls to `outer`. Having `vseq` first and `theta` second implies
    that each column of 200 in the resulting matrices corresponds to a span from −1
    to 1 in *v*, which refers to moving from one end of one of the lines of points
    to the other, that is, along the width of the strip. By using an index variable
    `i` from `0` to `199` (inclusive), the loop assigns each consecutive block of
    200 elements in `stripcols` (increased at every iteration via `+res*i`) the 200
    elements from the 399 `patcols` by collectively moving forward exactly one element
    (increased at every iteration via `+i`). What that does is change the color from
    red to white to blue in the plotted lines of points in the early stages of the
    loop, but as it progresses, working its way around the strip, the specific span
    of that palette is incrementally shifted until it goes from blue to white to red
    as you rotate around to the last few plotted lines of points. The effect is a
    smooth change in color as you alter both *v* and *θ*. You can see the result of
    the following in [Figure 26-19](ch26.xhtml#ch26fig19):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: '![image](../images/f26-19.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 26-19: A patriotic Möbius strip, created with the careful construction
    of an appropriate color vector.*'
  prefs: []
  type: TYPE_NORMAL
- en: The plot can still be rotated and zoomed as usual on your computer. You can
    experiment with `aspect` to alter the specific axis aspect ratios purely to enhance
    the appearance of the final product; here I’ve widened both the *x*- and *y*-axes
    relative to the *z*-axis.
  prefs: []
  type: TYPE_NORMAL
- en: '**Torus**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Another shape often expressed in 3D space is a *ring torus* (plural *tori*).
    This is the classic topological “shape with one hole” and resembles, for lack
    of a better word, a doughnut. The mathematical properties of tori are quite useful
    in many fields.
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameterization of a torus may be achieved with these equations:'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/e26-5.jpg)'
  prefs: []
  type: TYPE_IMG
- en: where
  prefs: []
  type: TYPE_NORMAL
- en: '*F*(*θ*[2]; *α*, *β*) = *β* + *α* cos *θ*[2]'
  prefs: []
  type: TYPE_NORMAL
- en: with 0 ≤ *θ*[1] < 2*π* and the same for *θ*[2] (assuming angles measured in
    radians). The fixed values *α* and *β* control the radius of the “tube” (in other
    words, the relative thickness of the doughnut) and the overall size of the torus
    in terms of distance from the middle of the hole to the middle of the tube. Provided
    *α* < *β*, the equations in (26.5) give you the classic ring torus shape; you
    can get different kinds of tori by relaxing that condition on *α* and *β*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Setting *α* = 1 and *β* = 2, the following code uses the `theta` object defined
    earlier for the Möbius strip to compute the matrices in the *x*-, *y*-, and *z-*coordinate
    directions as per (26.5):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: Refer to [Section 26.4.1](ch26.xhtml#ch26lev2sec271) to remind yourself of the
    usage of `outer` if you need to do so.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, this line reveals the calculated points of the torus:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: 'And this gives you the final appearance of the continuous surface:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: '[Figure 26-20](ch26.xhtml#ch26fig20) shows the results of both.'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f26-20.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 26-20: Drawing a ring torus in R. Left: Specifically calculated points
    on the surface, visualized with* `plot3d`*. Right: Shape formed by joining up
    the points on the left using* `persp3d`.'
  prefs: []
  type: TYPE_NORMAL
- en: Earlier, you used a specifically constructed color vector to color the Möbius
    strip, but you can assign color on any such surface by identifying the specific
    points in the defined matrices that you want to exert control over. Since it’s
    the last example in the book, let’s have a little fun with the current mathematical
    doughnut to illustrate this point-wise indexing.
  prefs: []
  type: TYPE_NORMAL
- en: First, the dough needs to look authentic. The following line sets up the vector
    of length 200² = 40,000 to store the colors you’re going to use. Initially, every
    element is set as a dough-colored tan.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, add some icing. If you look at the distribution of the points, displayed
    in the plot on the left of [Figure 26-20](ch26.xhtml#ch26fig20), you can see that
    the “top half” of plotted locations on the surface of this torus are at *z*-coordinates
    greater than zero. With this, you can overwrite the relevant elements of `donutcols`
    with the following line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: 'Lastly, any premium doughnut should have sprinkles. You need a mechanism to
    identify random locations on the top half of the surface and color them appropriately.
    To do this, you can use the built-in `sample` function to randomly select a subset
    of elements from an existing vector. If you have the integers 1 through 10, for
    example, and you want to randomly select four, you can execute the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: The argument `x` takes the vector from which to select a sample, and `size`
    takes the number of elements you want to draw from that vector. Note that you’re
    likely to get a different set of four random numbers when executing this line.
  prefs: []
  type: TYPE_NORMAL
- en: 'With that knowledge, you can use this code to make sprinkles:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: This sets up five distinct sprinkle colors; then randomly selects 300 locations,
    strictly from locations on the iced surface area; and finally assigns to them
    the five colors. The nature of vector recycling means there will be exactly 60
    of each color sprinkle, randomly placed on the top half of the torus. You can
    add more sprinkles by increasing `size`, though given the number of colors, you
    should ensure `size` remains evenly divisible by 5.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following call completes the visual treat, shown in [Figure 26-21](ch26.xhtml#ch26fig21):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: '![image](../images/f26-21.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 26-21: A delicious mathematical doughnut. Coloring of the torus surface
    is achieved by identification of corresponding positions in a color vector and
    subsequent element replacement.*'
  prefs: []
  type: TYPE_NORMAL
- en: You can find a more serious (and technical) visualization of a ring torus, in
    its role as a convenient computational structure used for generating specially
    defined high-dimensional random normal variates, in Davies and Bryant ([2013](ref.xhtml#ref15)).
  prefs: []
  type: TYPE_NORMAL
- en: '**Exercise 26.3**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Ensure you have the functionality of the `mvtnorm`, `rgl`, `misc3d`, and `ks`
    packages available in your current R session. By specifying different *covariance
    matrices*, you can control how the different components of a multivariate normal
    random variable relate to one another, which affects the appearance of the distribution
    itself. In the standard trivariate normal density, for example, the three elements
    (*x*, *y*, *z*) are independent of one another. Executing the following code will
    generate 1000 observations from a nonstandard trivariate normal distribution where
    the three elements are related to one another in a specific way:'
  prefs: []
  type: TYPE_NORMAL
- en: R> covmat <- matrix(c(1,0.8,0.4,0.8,1,0.6,0.4,0.6,1),3,3)
  prefs: []
  type: TYPE_NORMAL
- en: R> rand3d.norm <- rmvnorm(1000,mean=c(0,0,0),sigma=covmat)
  prefs: []
  type: TYPE_NORMAL
- en: Note that the covariance matrix `covmat` is supplied to the optional `sigma`
    and that the mean of this collection of points remains centered at (0,0,0).
  prefs: []
  type: TYPE_NORMAL
- en: Plot the generated data as an interactive 3D point cloud, with simple axis titles
    `"x"`, `"y"`, and `"z"`. You should see how the points form an elliptical shape,
    in contrast to the spherical shape in the standard trivariate normal in [Figures
    26-11](ch26.xhtml#ch26fig11) and [26-12](ch26.xhtml#ch26fig12). Keep the plot
    open.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Using a 50 × 50 × 50 evaluation lattice between −3 and 3 in each of the three
    axes, calculate this particular trivariate normal density function using `dmvnorm`
    and store it as an appropriately sized array. Note that you’ll also need to set
    `sigma=covmat` in any use of `dmvnorm`. Calculate the maximum value of the density
    and use this to superimpose upon the point cloud isosurfaces at three specific
    *α* levels—0.1, 0.5, and 0.9\. Color the three isosurfaces `"yellow"`, `"seagreen4"`,
    and `"navyblue"` and set them at 20 percent, 40 percent, and 60 percent opacity,
    respectively.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, use `ks` functionality to calculate a 3D kernel estimate of the density
    based on the 1000 generated observations. Ensure that the returned object contains
    the vector of 99 sensible contour levels. Replot the point cloud of (a) in a new
    RGL device and then make two separate calls to `contour3d` as follows.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The first should superimpose the theoretical contour at an *α* level of 0.5
    from (b) only. Use the same color and opacity as you did in (b).
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: The second should draw the isosurface at the 50th percentile as estimated from
    the point-specific KDE surface. Make it red and reduce the opacity to 20 percent.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Here are my results from (b) on the left and (c) on the right. Note that the
    appearance of your KDE isosurface will vary because of the random generation of
    the 1000 data points, which dictate the final estimate.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![image](../images/f0733-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The `MASS` package has another data set you’ve not yet met. The `Boston` data
    frame object contains a number of descriptive observations concerning house prices
    in suburbs of Boston, Massachusetts, in the 1970s ([Harrison and Rubinfeld, 1978](ref.xhtml#ref31)).
    Load the `MASS` package and inspect the help file `?Boston` to learn about the
    present variables.
  prefs: []
  type: TYPE_NORMAL
- en: 'Focus on the variables for average number of rooms, percentage of lower-socioeconomic-status
    dwellings, and median value—you’re going to experiment with the visualization
    of a 3D scatter-plot as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Use `rgl` functionality to plot the three variables, with rooms, status, and
    value on the *x*-, *y*-, and *z*-axes, respectively; supply tidy axis titles.
    The data points should be plotted as gray spheres, with a size of 0.5\. Keep the
    plot open.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Use `ks` functionality to estimate the trivariate density function of these
    data. Base the estimate on a 64 × 64 × 64 evaluation lattice; ensure the 99 integer
    percentiles of the observation-specific density levels are returned. Superimpose
    isosurface contours delineating the 75 percent, 50 percent, and 10 percent “most
    dense” observations using green, yellow, and blue. Set the opacity at 10 percent,
    40 percent, and 50 percent, respectively.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally, add reference grids along the three planes identified at the lower
    *z*-, upper *x*-, and upper *y*-axis locations.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Interpret the final plot from (d). For example, what values of the present variables
    tend to characterize the most common types of houses in Boston’s suburbs?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Here’s the result:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![image](../images/f0734-01.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: 'The *umbilic torus* is another interesting 3D shape in mathematics and can
    be defined by the following parametric equations:'
  prefs: []
  type: TYPE_NORMAL
- en: '*x* = sin(*θ*)*F*(*θ*, *φ*)'
  prefs: []
  type: TYPE_NORMAL
- en: '*y* = cos(*θ*)*F*(*θ*, *φ*)'
  prefs: []
  type: TYPE_NORMAL
- en: '*z* = sin(*θ*/3 − 2*φ*) + 2sin(*θ*/3 + *φ*)'
  prefs: []
  type: TYPE_NORMAL
- en: In these equations, *F*(*θ*, *φ*) = 7 + cos(*θ*/3 − 2*φ*) + 2 cos(*θ*/3 + *φ*),
    and you allow for both −*π* ≤ *θ* ≤ *π* and −*π* ≤ *φ* ≤ *π*.
  prefs: []
  type: TYPE_NORMAL
- en: Using a sequence of length 1000 for both *θ* and *φ*, as well as 1000 colors
    generated from the built-in `rainbow` palette assigned directly to the `col` argument,
    produce an interactive 3D plot of the umbilic torus. Suppress the box, axes, and
    axis titles. In viewing the object from different perspectives, note that, much
    like the Möbius strip you plotted earlier, this shape has only one edge.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Here’s the result:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![image](../images/f0735-01.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: '**Important Code in This Chapter**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '| **Function/operator** | **Brief description** | **First occurrence** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `plot3d` | Interactive 3D point cloud | [Section 26.1.1](ch26.xhtml#ch26lev2sec261),
    [p. 692](ch26.xhtml#page_692) |'
  prefs: []
  type: TYPE_TB
- en: '| `legend3d` | Add RGL device legend | [Section 26.1.2](ch26.xhtml#ch26lev2sec262),
    [p. 693](ch26.xhtml#page_693) |'
  prefs: []
  type: TYPE_TB
- en: '| `bg3d` | Reset RGL device background | [Section 26.1.2](ch26.xhtml#ch26lev2sec262),
    [p. 693](ch26.xhtml#page_693) |'
  prefs: []
  type: TYPE_TB
- en: '| `segments3d` | Add 3D line segments | [Section 26.1.3](ch26.xhtml#ch26lev2sec263),
    [p. 696](ch26.xhtml#page_696) |'
  prefs: []
  type: TYPE_TB
- en: '| `grid3d` | Add plane grid | [Section 26.1.3](ch26.xhtml#ch26lev2sec263),
    [p. 696](ch26.xhtml#page_696) |'
  prefs: []
  type: TYPE_TB
- en: '| `bgplot3d` | Alter/replot RGL device background | [Section 26.1.3](ch26.xhtml#ch26lev2sec263),
    [p. 696](ch26.xhtml#page_696) |'
  prefs: []
  type: TYPE_TB
- en: '| `persp3d` | Interactive 3D perspective surface | [Section 26.2.1](ch26.xhtml#ch26lev2sec264),
    [p. 700](ch26.xhtml#page_700) |'
  prefs: []
  type: TYPE_TB
- en: '| `points3d` | Add 3D points | [Section 26.2.2](ch26.xhtml#ch26lev2sec265),
    [p. 701](ch26.xhtml#page_701) |'
  prefs: []
  type: TYPE_TB
- en: '| `text3d` | Add 3D text | [Section 26.2.2](ch26.xhtml#ch26lev2sec265), [p.
    702](ch26.xhtml#page_702) |'
  prefs: []
  type: TYPE_TB
- en: '| `rmvnorm` | Random multivariate normal variates | [Section 26.3.2](ch26.xhtml#ch26lev2sec269),
    [p. 711](ch26.xhtml#page_711) |'
  prefs: []
  type: TYPE_TB
- en: '| `dmvnorm` | Multivariate normal density | [Section 26.3.2](ch26.xhtml#ch26lev2sec269),
    [p. 711](ch26.xhtml#page_711) |'
  prefs: []
  type: TYPE_TB
- en: '| `contour3d` | Draw isosurface | [Section 26.3.2](ch26.xhtml#ch26lev2sec269),
    [p. 713](ch26.xhtml#page_713) |'
  prefs: []
  type: TYPE_TB
- en: '| `kde` | Multivariate kernel estimation | [Section 26.3.3](ch26.xhtml#ch26lev2sec270),
    [p. 717](ch26.xhtml#page_717) |'
  prefs: []
  type: TYPE_TB
- en: '| `pi` | Geometric value *π* | [Section 26.4.1](ch26.xhtml#ch26lev2sec271),
    [p. 722](ch26.xhtml#page_722) |'
  prefs: []
  type: TYPE_TB
- en: '| `sin`, `cos` | Sine and cosine | [Section 26.4.1](ch26.xhtml#ch26lev2sec271),
    [p. 722](ch26.xhtml#page_722) |'
  prefs: []
  type: TYPE_TB
- en: '| `outer` | Outer array product | [Section 26.4.1](ch26.xhtml#ch26lev2sec271),
    [p. 724](ch26.xhtml#page_724) |'
  prefs: []
  type: TYPE_TB
- en: '| `sample` | Random sample from vector | [Section 26.4.2](ch26.xhtml#ch26lev2sec272),
    [p. 731](ch26.xhtml#page_731) |'
  prefs: []
  type: TYPE_TB
