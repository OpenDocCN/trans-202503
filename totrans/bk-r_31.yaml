- en: '**26**'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '**26**'
- en: '**INTERACTIVE 3D PLOTS**'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '**交互式 3D 图**'
- en: '![image](../images/common-01.jpg)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/common-01.jpg)'
- en: When it comes to 3D plots, it’s important to be able to view them from different
    angles to interpret the function or surface that’s been displayed. The `rgl` package
    by Adler et al. ([2015](ref.xhtml#ref01)) offers some fantastic, simple-to-use
    R functions that allow you to rotate and zoom in on three-dimensional plots with
    your mouse. In this chapter, you’ll look at a few examples that show off the possibilities
    of `rgl`.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 当谈到 3D 绘图时，能够从不同的角度查看它们非常重要，这样才能解读所显示的函数或表面。Adler 等人（[2015](ref.xhtml#ref01)）的
    `rgl` 包提供了一些非常棒、易于使用的 R 函数，可以让你通过鼠标旋转和放大三维图形。在本章中，你将看到一些展示 `rgl` 功能的例子。
- en: Under the hood, `rgl` utilizes OpenGL—a standard application programming interface—to
    render the graphics on your computer screen. Install `rgl` (for example, by calling
    `install.packages("rgl")` at the prompt) and then call `library("rgl")` to load
    it.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 从内部实现来看，`rgl` 使用 OpenGL —— 一个标准的应用程序接口 —— 在你的计算机屏幕上渲染图形。安装 `rgl`（例如，通过在提示符下调用
    `install.packages("rgl")`）后，再调用 `library("rgl")` 来加载它。
- en: '**26.1 Point Clouds**'
  id: totrans-5
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**26.1 点云**'
- en: Let’s begin with the most basic of 3D plots—*point clouds*. In statistics, this
    tool is typically used to provide scatterplots of three continuous variables,
    as you saw when you created static 3D scatterplots.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从最基本的 3D 图开始——*点云*。在统计学中，这个工具通常用于提供三种连续变量的散点图，就像你在创建静态 3D 散点图时看到的那样。
- en: '***26.1.1 Basic 3D Cloud***'
  id: totrans-7
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***26.1.1 基础 3D 云图***'
- en: 'Return to the built-in `iris` data, composed of four measurements taken on
    three species of flower. Create the following four vectors in your workspace for
    accessibility, as you did in [Section 25.2.1](ch25.xhtml#ch25lev2sec249):'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 回到内置的 `iris` 数据集，该数据集由对三种花卉的四个测量值组成。像在[第 25.2.1 节](ch25.xhtml#ch25lev2sec249)中做的那样，在你的工作空间中创建以下四个向量以方便访问：
- en: '[PRE0]'
  id: totrans-9
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'You use the `plot3d` function of `rgl` to display an interactive 3D cloud of
    points. It’s called in the way familiar for scatterplots—by supplying the *x*-,
    *y*-, and *z*-coordinates to the `x`, `y`, and `z` arguments, respectively. The
    following line opens an RGL device and produces a scatterplot of petal width,
    length, and sepal width from the `iris` data:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用 `rgl` 的 `plot3d` 函数来显示一个交互式的 3D 点云。它的调用方式和散点图类似——分别将 *x*、*y* 和 *z* 坐标传递给
    `x`、`y` 和 `z` 参数。以下代码行打开一个 RGL 设备，并绘制来自 `iris` 数据集的花瓣宽度、花瓣长度和萼片宽度的散点图：
- en: '[PRE1]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: You’ll probably want to increase the size of the device with your mouse to see
    the data better. Then, by left-clicking the plot and holding the button down,
    you can move the mouse to rotate the plot in any direction you like. If you right-click
    the plot and hold, you control the zoom. Specifically, rightclicking and holding
    while moving the mouse upward will zoom out, and right-clicking and holding while
    moving the mouse downward will zoom in. The axis tick marks and labels automatically
    appear on different sides based on your viewing angle. [Figure 26-1](ch26.xhtml#ch26fig1)
    shows this plot.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能想要使用鼠标增大设备的大小，以便更清楚地查看数据。然后，通过左键点击图形并按住按钮，你可以移动鼠标，在任何你喜欢的方向旋转图形。如果右键点击图形并按住，你可以控制缩放。具体来说，右键点击并按住同时将鼠标向上移动将会缩小，右键点击并按住同时将鼠标向下移动将会放大。坐标轴的刻度线和标签会根据你的观察角度自动出现在不同的侧面。[图
    26-1](ch26.xhtml#ch26fig1)展示了这一图形。
- en: '![image](../images/f26-01.jpg)'
  id: totrans-13
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f26-01.jpg)'
- en: '*Figure 26-1: An interactive 3D scatterplot of the* `iris` *data using the*
    `plot3d` *function of* `rgl`*. This is the default appearance of plotting the
    petal width, petal length, and sepal width.*'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 26-1：使用 `rgl` 的 `plot3d` 函数绘制的* `iris` *数据的交互式 3D 散点图。 这是绘制花瓣宽度、花瓣长度和萼片宽度时的默认显示效果。*'
- en: '***26.1.2 Visual Enhancements and Legends***'
  id: totrans-15
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***26.1.2 视觉增强和图例***'
- en: You can alter the appearance of a `plot3d` scatterplot in new ways as well as
    some familiar ways. For example, the optional `type` argument, defaulting to `"p"`
    for “points,” plots the points as dots as in the most recent scatterplot. To draw
    points as visible 3D spheres, use `type="s"`. You can control the size of any
    plotted points or spheres by using `size`, and you can control the color (or colors)
    by using `col`. The `legend3d` function is the `rgl` analog of `legend` and is
    also useful; it works by changing the background image upon which the interactive
    plot sits.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过一些新的方式以及一些熟悉的方式来改变`plot3d`散点图的外观。例如，默认的可选参数`type`设置为“p”（即“点”），将点绘制为像最近的散点图那样的小圆点。要将点绘制为可见的3D球体，可以使用`type="s"`。你可以通过使用`size`来控制任何绘制的点或球体的大小，还可以通过使用`col`来控制颜色（或颜色）。`legend3d`函数是`rgl`库中`legend`函数的类似物，它也非常有用；它通过更改交互式图形背景图像来工作。
- en: 'To illustrate these modifications, let’s replot the same `iris` observations.
    First, close any currently open RGL graphics devices. Then, execute the following:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 为了说明这些修改，让我们重新绘制相同的`iris`观察数据。首先，关闭任何当前打开的RGL图形设备。然后，执行以下命令：
- en: '[PRE2]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This will start a new RGL device, coloring spheres according to flower species.
    As usual, you pass the `col` argument a vector of the same length as the plotted
    coordinates, and it will assign the color to the corresponding point in an element-wise
    fashion. You specify the `size` parameter on a slightly different scale than the
    traditional R graphics parameter `cex`, and it changes according to the value
    of `type`—inspect the help file `?plot3d` for details. With a little experimentation,
    it’s not difficult to find a size value that suits the plot.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 这将启动一个新的RGL设备，根据花卉物种为球体着色。像往常一样，你需要将`col`参数传递一个与绘制坐标长度相同的向量，它会逐一为对应的点分配颜色。你指定`size`参数时使用的尺度略有不同于传统R图形的`cex`参数，它会根据`type`的值发生变化——可以查看帮助文件`?plot3d`了解详细信息。通过一些实验，你可以轻松找到一个适合图形的大小值。
- en: 'To add a legend, first resize the RGL device with your mouse to your preferred
    display size and then execute the following line:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 要添加图例，首先用鼠标调整RGL设备的大小到你喜欢的显示尺寸，然后执行以下命令：
- en: '[PRE3]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: This inserts a static, unmovable legend referencing the plotted species by color.
    The `legend3d` function actually calls the base R `legend` function, so they are
    conveniently used in the same way. With the static legend in place, the scatterplot
    remains fully interactive, and you can continue to rotate and zoom. [Figure 26-2](ch26.xhtml#ch26fig2)
    shows all this.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 这会插入一个静态、不可移动的图例，通过颜色引用绘制的物种。`legend3d`函数实际上调用了基础R的`legend`函数，因此它们的使用方法非常方便。图例静态显示后，散点图仍然是完全交互式的，你可以继续旋转和缩放。[图26-2](ch26.xhtml#ch26fig2)展示了这一切。
- en: 'The `legend3d` function changes the background canvas, which is why you have
    to open a new device and resize it manually before you add the legend. If you
    now produced a new `rgl` plot in the same device without closing it first or resetting
    the background, the flower species legend would still be there. If you’re making
    multiple `rgl` plots, you can reset the background to its default white canvas
    at any time by calling the following:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '`legend3d`函数会改变背景画布，这就是为什么在添加图例之前，你需要手动打开一个新设备并调整其大小。如果你在没有先关闭设备或重置背景的情况下，在同一个设备中创建了一个新的`rgl`图形，花卉物种的图例仍然会存在。如果你要创建多个`rgl`图形，可以随时通过调用以下命令将背景重置为默认的白色画布：'
- en: '[PRE4]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: If you try that with the most recent plot still active, you’ll see that the
    flower species legend disappears and the scatterplot remains. Alternatively, you
    can just close your RGL device when you’re done so that a new device will be used
    for any subsequent plot.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你尝试在最最近的图形仍然处于活动状态时使用此方法，你会看到花卉物种的图例消失，而散点图仍然存在。或者，你可以在完成时直接关闭RGL设备，这样任何后续图形都会使用新的设备。
- en: '![image](../images/f26-02.jpg)'
  id: totrans-26
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f26-02.jpg)'
- en: '*Figure 26-2: Replotting the* `iris` *petal width, length, and sepal width
    data with* `plot3d`*. Observations are plotted as spheres, increased in size,
    and colored according to species type; a legend is added via* `legend3d`.'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '*图26-2：使用`plot3d`重新绘制*`iris`*花瓣宽度、长度和萼片宽度数据。观察值被绘制为球体，增加了大小，并根据物种类型着色；通过`legend3d`添加了图例。*'
- en: '***26.1.3 Adding Further 3D Components***'
  id: totrans-28
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***26.1.3 添加更多的3D组件***'
- en: You can also add new observations and lines to a current 3D plot. The `rgl`
    package includes the functions `points3d`, `lines3d`, and `segments3d`, reminiscent
    of `points`, `lines`, and `segments` from base R graphics. As an example, in [Section
    25.2.2](ch25.xhtml#ch25lev2sec250), you used an optional argument to add vertical
    lines from the base of the *x*-*y* plane to each plotted point in `scatterplot3d`.
    In a `plot3d` scatterplot, you would use `segments3d` to the same effect. In addition,
    you can add the grid that’s drawn by default on the same plane in a `scatterplot3d`
    plot by using the `grid3d` function for `rgl` graphics.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以向当前的 3D 图形中添加新的观察点和线条。`rgl` 包含了 `points3d`、`lines3d` 和 `segments3d` 函数，类似于基础
    R 图形中的 `points`、`lines` 和 `segments`。举个例子，在[第 25.2.2 节](ch25.xhtml#ch25lev2sec250)中，你使用了一个可选参数，将垂直线从
    *x*-*y* 平面基准点画到每个绘制的点，在 `scatterplot3d` 中实现这一功能。如果是在 `plot3d` 散点图中，你将使用 `segments3d`
    达到相同效果。此外，你还可以通过 `rgl` 图形的 `grid3d` 函数添加默认情况下在相同平面上绘制的网格线，这是 `scatterplot3d` 图形的默认功能。
- en: Let’s put that into practice. Take a look back at [Figure 25-8](ch25.xhtml#ch25fig8)
    on [page 652](ch25.xhtml#page_652). To create a similar plot using `rgl` functionality,
    where color is used to reference the fourth continuous variable, sepal length,
    first re-create the palette and set up the colors for each observation. This is
    done here with a categorization of 50 colors (see [Section 25.1.4](ch25.xhtml#ch25lev2sec245)).
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们实际操作一下。回顾一下 [图 25-8](ch25.xhtml#ch25fig8) 和 [第 652 页](ch25.xhtml#page_652)。要使用
    `rgl` 功能创建类似的图形，其中颜色用于表示第四个连续变量——花萼长度，首先重新创建调色板并为每个观察点设置颜色。这里通过对 50 种颜色的分类实现（见[第
    25.1.4 节](ch25.xhtml#ch25lev2sec245)）。
- en: '[PRE5]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Then, either close any currently active RGL devices or clear the background
    of the one in focus. A call to `plot3d` starts the plot with appropriately colored
    spheres.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，关闭任何当前激活的 RGL 设备，或者清除聚焦设备的背景。调用 `plot3d` 会用适当颜色的球体开始绘制图形。
- en: '[PRE6]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: You supply a vector of length 3 to the `aspect` argument, describing the relative
    lengths of the *x*-, *y*-, and *z*-axes, in that order. By changing the second
    entry to `1.75`, you’re lengthening the *y*-axis by that multiplicative factor
    relative to the others. This creates the stretched-out effect along the *y*-axis.
    The colors are assigned by vector indexing using the `slen.cols` factor vector,
    and `xlab`, `ylab`, and `zlab` are used to tidy up the axis titles.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 你向 `aspect` 参数提供一个长度为 3 的向量，描述 *x*、*y* 和 *z* 轴的相对长度。通过将第二个条目改为 `1.75`，你将 *y*
    轴的长度按该倍数相对于其他轴进行了拉伸。这会在 *y* 轴上产生拉伸效果。颜色通过使用 `slen.cols` 因子向量的向量索引分配，而 `xlab`、`ylab`
    和 `zlab` 用来整理坐标轴的标题。
- en: Now, to add a vertical line from the *x*-*y* plane to each observation, you
    need to understand how to use the `segments3d` function. Unlike its base R counterpart,
    `segments3d` doesn’t separate the “from” and “to” coordinates into different arguments
    (recall the use of `x0`, `y0`, `x1`, and `y1` in `segments` and `arrows`). Instead,
    it takes each sequential pair of observations provided to the `x`, `y`, and `z`
    arguments to be the beginning and end of each line segment, in that order.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，要从 *x*-*y* 平面到每个观察点添加垂直线，你需要了解如何使用 `segments3d` 函数。与基础 R 中的 `segments` 不同，`segments3d`
    不会将“起点”和“终点”坐标分成不同的参数（回想一下在 `segments` 和 `arrows` 中使用的 `x0`、`y0`、`x1` 和 `y1`）。相反，它将依次处理传递给
    `x`、`y` 和 `z` 参数的每对观察点，将它们视为每个线段的起点和终点。
- en: 'So, to draw the vertical lines on the existing RGL device, you first need to
    set up these vectors containing a “from” location and a “to” location in the 3D
    space. Consider the following code:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，要在现有的 RGL 设备上绘制垂直线，首先需要设置包含“起点”和“终点”位置的向量，这些位置位于 3D 空间中。考虑以下代码：
- en: '[PRE7]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The first two lines set up the vectors for the *x*- and *y*-components, `xfromto`
    and `yfromto`, respectively, by simply replicating each observation twice. These
    are easy, since the “from–to” values don’t change in these coordinate directions.
    The *z*-component does change, however. You first create the `zfromto` vector
    by replicating the smallest sepal width value, `min(swid)`, by two times the size
    of the data set, so you have a vector that matches `xfromto` and `yfromto` in
    length. Then, every second position of `zfromto` is overwritten using the elements
    of the sepal width vector. This gives you “from” *z* values for all observations,
    namely `min(swid)`, matched (in the pairwise fashion as required for `segments3d`)
    with the “to” *z* values in `swid` itself. Together with `xfromto` and `yfromto`,
    you’ll therefore end up with lines that go from the bottom *x*-*y* plane of the
    plot (the vertical position of which is automatically level at `min(swid)`) up
    to the actual `swid` value (which is of course the corresponding *z* value of
    each sphere).
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 前两行分别通过简单地将每个观测值复制两次，设置了*x*和*y*分量的向量`xfromto`和`yfromto`。这些非常简单，因为这些坐标方向上的“从–到”值不会变化。然而，*z*分量会变化。你首先通过将最小的花萼宽度值`min(swid)`复制两倍数据集大小来创建`zfromto`向量，从而得到一个与`xfromto`和`yfromto`长度相同的向量。然后，`zfromto`的每隔一个位置会被花萼宽度向量的元素覆盖。这为所有观测值提供了“从”*z*值，即`min(swid)`，并按要求（以对方式配对）与`swid`中的“到”*z*值匹配。结合`xfromto`和`yfromto`，你将得到从图表底部*x*-*y*平面（其垂直位置自动定在`min(swid)`）到实际`swid`值的线条（这当然是每个球体的相应*z*值）。
- en: To help understand the way they’ve been set up, print the coordinate vectors
    to your console screen so you can see what they hold. Then a call to `segments3d`
    places the lines on the plot.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 为了帮助理解它们是如何设置的，可以将坐标向量打印到控制台屏幕，以便查看它们的内容。然后，调用`segments3d`将这些线条绘制到图表上。
- en: '[PRE8]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: To ensure the color of each line matches its corresponding sphere, you also
    need to replicate each entry of the vector-indexed collection of colors provided
    by `cols[slen.cols]` twice, which implies a constant “from–to” color.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确保每条线的颜色与其对应的球体匹配，你还需要将`cols[slen.cols]`中由向量索引的颜色集合中的每个条目复制两次，这意味着颜色的“从–到”是恒定的。
- en: 'Then, executing the following line places a reference grid over the lower *x*-*y*
    plane:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，执行以下操作将参考网格放置在下方的*x*-*y*平面上：
- en: '[PRE9]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: To the `side` argument you specify the axis you want held constant (in this
    case, *z*) and at which end to place the grid (in this case, because you want
    the grid at the lower end of the *z*-axis, you specify with a minus symbol). To
    place the grid at the upper end of the vertical axis, which is on the top side
    of the rectangular prism, you would specify `side="z+"`.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 对于`side`参数，你需要指定要保持不变的轴（在这里是*z*轴）以及放置网格的位置（在这种情况下，因为你希望网格位于*z*轴的下端，所以你使用负号指定）。如果你想将网格放置在垂直轴的上端，即矩形棱柱的顶部，你可以指定`side="z+"`。
- en: 'Lastly, you can add a custom, continuous-color legend to the plot to reference
    the sepal length. The `bgplot3d` function is a more general version of `legend3d`;
    it allows you to specify any plotting commands you like to define the RGL device
    background. Let’s do so using the `colorlegend` function of the `shape` package,
    first explored in [Section 25.1.5](ch25.xhtml#ch25lev2sec246). Make sure you have
    the `shape` package loaded and that your RGL device of the scatterplot is sized
    to your liking. On my machine, I execute the following:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，你可以向图表添加一个自定义的、连续颜色的图例，用于参考花萼长度。`bgplot3d`函数是`legend3d`的一个更通用版本；它允许你指定任何绘图命令来定义RGL设备的背景。我们将使用`shape`包中的`colorlegend`函数来实现这一点，该函数在[第25.1.5节](ch25.xhtml#ch25lev2sec246)中首次介绍。确保你已经加载了`shape`包，并且散点图的RGL设备大小符合你的需求。在我的机器上，我执行以下操作：
- en: '[PRE10]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The `bgplot3d` function can take multiple plotting commands, which you need
    to provide as a code chunk within braces, `{}`, with each command separated by
    a semicolon (`;`). In this example, the initial call to `plot.new()` silently
    initializes the background of the RGL device so that you can add the continuous-color
    legend. Without that call, `colorlegend` will still work, but a warning will be
    issued. [Figure 26-3](ch26.xhtml#ch26fig3) shows the final result, with the scatterplot
    still spinnable and zoomable with your mouse.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '`bgplot3d`函数可以接受多个绘图命令，这些命令需要作为一个代码块放在大括号`{}`内，每个命令用分号（`;`）分隔。在此示例中，最初调用`plot.new()`会静默初始化RGL设备的背景，以便你可以添加连续颜色的图例。如果没有这个调用，`colorlegend`仍然可以工作，但会发出警告。[图26-3](ch26.xhtml#ch26fig3)显示了最终结果，散点图仍然可以通过鼠标进行旋转和缩放。'
- en: The ability to rotate a 3D scatterplot and any of the plots you’ll see over
    the next few sections with simple mouse commands is especially handy when you’re
    exploring visuals of higher-dimensional data. You’re not restricted to a single
    viewpoint, and you don’t need to manually decide on a viewing angle before actually
    producing the plot. The `rgl` functionality also makes it easy to add extra elements
    to an existing plot—something that’s harder to do with `scatterplot3d` or `persp`
    plots. That said, certain features you might take for granted in more traditional
    plotting can be difficult to mirror in interactive plots. For example, no equivalent
    of the `pch` graphical parameter is readily available in `rgl`. To plot different
    symbols, you would need to design, render, and place new 3D shapes.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 旋转3D散点图以及你将在接下来的几节中看到的任何图形，使用简单的鼠标命令特别方便，尤其是当你在探索高维数据的可视化时。你不受限于单一视角，也不需要在实际生成图形之前手动决定视角。`rgl`功能还使得将额外元素添加到现有图形中变得容易——这是`scatterplot3d`或`persp`图形难以做到的。尽管如此，你可能会发现某些在传统绘图中习以为常的功能在交互式图形中很难实现。例如，`rgl`中没有与`pch`图形参数对应的功能。要绘制不同的符号，你需要设计、渲染并放置新的3D形状。
- en: '![image](../images/f26-03.jpg)'
  id: totrans-49
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f26-03.jpg)'
- en: '*Figure 26-3: This demonstrates the addition of lines and a plane grid to a*
    `plot3d` *3D scatterplot of the* `iris` *data to mimic the earlier* `scatterplot3d`
    *example of the same data.*'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '*图26-3：这展示了在`iris`数据的`plot3d` *3D散点图*上添加线条和平面网格，以模拟之前的`scatterplot3d`同一数据的示例。*'
- en: '**Exercise 26.1**'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '**练习26.1**'
- en: Turn back to the `survey` data frame in the `MASS` package, checking the description
    of the present variables in the help file `?survey` if you need to. Create a copy
    of `survey` containing only the writing handspan, nonwriting handspan, left- or
    right-handedness, sex, and height columns. Then use `na.omit` to remove any rows
    of this subsetted data frame that contain missing values.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 返回`survey`数据框，位于`MASS`包中，如果需要的话，可以查看帮助文件`?survey`以了解当前变量的描述。创建一个`survey`的副本，仅包含书写手距、非书写手距、左撇子或右撇子、性别和身高这几列。然后使用`na.omit`来删除包含缺失值的这一子集数据框的行。
- en: Produce a basic interactive 3D point cloud of student height on the *z*-axis,
    writing handspan on the *x*-axis, and nonwriting handspan on the *y*-axis.
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 生成一个基本的交互式3D点云，*z*-轴表示学生身高，*x*-轴表示书写手距，*y*-轴表示非书写手距。
- en: 'Create a more informative version of the scatterplot in (a) that uses color
    to distinguish between sexes and uses point size to distinguish between left-
    and right-handed individuals, following these guidelines:'
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个更具信息量的散点图版本，使用颜色区分性别，使用点的大小区分左撇子和右撇子个体，按照以下指导进行：
- en: – Start by plotting only those points that correspond to right-handed individuals.
    Set the color via vector indexing using the numeric version of sex for right-handed
    individuals—females should be black, males red.
  id: totrans-55
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: – 首先绘制只对应右撇子个体的点。通过使用性别的数字版本来设置颜色，右撇子女性应为黑色，男性为红色。
- en: – Set the plotted point size as 4 for the right-handed individuals and ensure
    tidy axis labels.
  id: totrans-56
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: – 将右撇子个体的绘制点大小设置为4，并确保坐标轴标签整洁。
- en: – Using `points3d`, add the points for left-handed individuals to the existing
    plot. Colors are to be assigned according to sex in the same way as for the right-handed
    students, but this time, the point size should be set at 10.
  id: totrans-57
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: – 使用`points3d`，将左撇子个体的点添加到现有图形中。颜色应按照与右撇子学生相同的方式根据性别分配，但这次，点的大小应设置为10。
- en: '– Resize the RGL device to your liking and add a legend to the top-left corner
    that references the four types of points: `"Male RH"`, `"Female RH"`, `"Male LH"`,
    and `"Female LH"`. In setting the legend, use a `pch` value of `19` and use `pt.cex`
    values of `0.8` and `1.5` for right- and left-handed individuals, respectively.'
  id: totrans-58
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: – 调整RGL设备的大小，并在左上角添加一个图例，参考四种类型的点：“`Male RH`”（男性RH）、“`Female RH`”（女性RH）、“`Male
    LH`”（男性LH）和“`Female LH`”（女性LH）。在设置图例时，使用 `pch` 值为 `19`，并为右撇子和左撇子分别使用 `pt.cex`
    值 `0.8` 和 `1.5`。
- en: 'For reference, my version of the rotatable 3D scatterplot is shown here:'
  id: totrans-59
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 作为参考，我的可旋转3D散点图版本如下所示：
- en: '![image](../images/f0698-01.jpg)'
  id: totrans-60
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![image](../images/f0698-01.jpg)'
- en: In [Exercise 25.2](ch25.xhtml#ch25exc2) on [page 652](ch25.xhtml#page_652),
    you looked at a static 3D scatterplot of the built-in `airquality` data. Again,
    create a copy of the data frame, omitting any rows with `NA` entries.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在[练习25.2](ch25.xhtml#ch25exc2)中，您查看了内置的 `airquality` 数据的静态3D散点图。再次创建数据框的副本，省略任何包含
    `NA` 条目的行。
- en: 'Create a similar version of the plot from the earlier exercise using `rgl`
    functionality, displaying wind speed, solar radiation, and temperature on the
    *x*-, *y*-, and *z*-axes, respectively, according to the following guidelines:'
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `rgl` 功能创建一个与之前练习相似的图，分别在 *x*、*y* 和 *z* 轴上显示风速、太阳辐射和温度，按照以下指南：
- en: – Set up 50 colors from the built-in `topo.colors` palette. Set up the appropriate
    color index vector for the ozone values, based on the categorization approach.
  id: totrans-63
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: – 从内置的 `topo.colors` 调色板中设置50种颜色。根据分类方法，为臭氧值设置相应的颜色索引向量。
- en: – Plot the observations as size 1 spheres, colored as before, and modify the
    aspect ratio so that the *y*-axis is 1.5 times the length of the other two axes.
    Provide neat axis titles.
  id: totrans-64
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: – 将观测值绘制为大小为1的球体，颜色与之前相同，并修改长宽比，使得 *y* 轴的长度是其他两个轴的1.5倍。提供整洁的轴标题。
- en: – Add correspondingly colored lines, one for each observation, stretching vertically
    upward from the *x*-*y* plane to meet the plotted spheres. Also, place a grid
    on the lower *x*-*y* plane.
  id: totrans-65
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: – 添加相应颜色的线条，每条线代表一个观测值，从 *x*–*y* 平面垂直向上延伸，直到与绘制的球体相交。同时，在下方的 *x*–*y* 平面上放置网格。
- en: '– Modify the background of the RGL device to include a color legend referencing
    the ozone level; use a sequence of values between 60 and 95, in steps of 5, to
    label it. Here’s my result:'
  id: totrans-66
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: – 修改RGL设备的背景，包含一个与臭氧水平相关的颜色图例；使用60到95之间以5为步长的数值来标记它。这是我的结果：
- en: '![image](../images/f0699-01.jpg)'
  id: totrans-67
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f0699-01.jpg)'
- en: '**26.2 Bivariate Surfaces**'
  id: totrans-68
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**26.2 双变量表面**'
- en: Next you’ll look at plotting bivariate surfaces—a continuous surface calculated
    with respect to a 2D *x*-*y* evaluation grid—with `rgl`. In [Chapter 25](ch25.xhtml#ch25),
    you plotted these using `contour`, `filled.contour`, `image`, and `persp` in base
    R graphics. Anything that you’re able to plot using those functions can also be
    plotted as an interactive perspective plot with the `persp3d` function of `rgl`.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，你将使用 `rgl` 绘制双变量表面——一个相对于2D *x*–*y* 评估网格计算出的连续表面。在[第25章](ch25.xhtml#ch25)中，你使用基础R图形的
    `contour`、`filled.contour`、`image` 和 `persp` 绘制了这些图形。任何你能够使用这些函数绘制的图形，也可以通过 `rgl`
    的 `persp3d` 函数绘制为交互式透视图。
- en: '***26.2.1 Basic Perspective Surface***'
  id: totrans-70
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***26.2.1 基本透视表面***'
- en: 'Take the `mtcars` response surface of mean MPG as a function of horsepower
    and weight (first used in [Section 25.4.1](ch25.xhtml#ch25lev2sec254)) as an easy
    initial example. In [Section 25.6.1](ch25.xhtml#ch25lev2sec258), you plotted static,
    base R perspective plots of this surface. The next few lines will refit the multiple
    linear regression model and re-create the 20 × 20 evaluation grid *x*- and *y*-sequences:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 以 `mtcars` 数据集中的平均MPG（每加仑英里数）作为马力和重量的函数响应面（首次在[第25.4.1节](ch25.xhtml#ch25lev2sec254)中使用）作为一个简单的初步示例。在[第25.6.1节](ch25.xhtml#ch25lev2sec258)中，你绘制了该响应面的静态基础R视角图。接下来的几行将重新拟合多元线性回归模型，并重新创建20
    × 20的评估网格 *x* 和 *y* 序列：
- en: '[PRE11]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: To create the surface, predict using the evaluation grid in `hp.wt` as you’ve
    done previously, but this time, include the calculation of a prediction interval
    for the raw observations.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 为了创建该表面，像之前一样使用 `hp.wt` 中的评估网格进行预测，但这次，包含对原始观测值的预测区间计算。
- en: '[PRE12]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '(You’ll use the interval in a later example.) Then, construct the *z*-matrix
    and draw a green `persp3d` surface with the following two lines:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: （你将在后续示例中使用该间隔。）然后，构建 *z* 矩阵，并用以下两行绘制一个绿色的 `persp3d` 表面：
- en: '[PRE13]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The result is shown on the left of [Figure 26-4](ch26.xhtml#ch26fig4). If you
    compare it to [Figure 25-19](ch25.xhtml#ch25fig19) on [page 681](ch25.xhtml#page_681),
    you can see that it shows the same surface. The default lighting and shadowing
    effect produced by the `persp3d` surface helps with depth perception, similar
    to the `shade` argument to `persp`. The main benefit of this version is the mouse-based
    rotation and zoom interactivity.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 结果如[图26-4](ch26.xhtml#ch26fig4)的左侧所示。如果你将其与[图25-19](ch25.xhtml#ch25fig19)进行比较，便可以看到它显示了相同的表面。`persp3d`表面所产生的默认光照和阴影效果有助于深度感知，类似于`persp`的`shade`参数。这个版本的主要优点是基于鼠标的旋转和缩放交互性。
- en: '![image](../images/f26-04.jpg)'
  id: totrans-78
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f26-04.jpg)'
- en: '*Figure 26-4: Two interactive* `persp3d` *versions of the* `mtcars` *response
    surface. Left: Default appearance in green. Right: Red, 70 percent opacity surface,
    with original data superimposed in the 3D space. Both plots can be rotated and
    zoomed with the mouse.*'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '*图26-4：两种交互式* `persp3d` *版本的* `mtcars` *响应面。左侧：绿色的默认外观。右侧：红色，70%不透明度的表面，原始数据在三维空间中叠加。两个图都可以通过鼠标旋转和缩放。*'
- en: '***26.2.2 Additional Components***'
  id: totrans-80
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***26.2.2 添加组件***'
- en: Another useful attribute of a `persp3d` plotted surface is the ability to add
    further components easily—something that’s nowhere near as straightforward in
    base R functionality. You’ll continue using the objects just created for the `mtcars`
    response surface.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '`persp3d`绘制的表面还有一个有用的属性，那就是可以轻松地添加更多组件——这是基础R功能中远远不如这个方法直接的事情。你将继续使用之前为`mtcars`响应面创建的对象。'
- en: '**Adding Points**'
  id: totrans-82
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**添加点**'
- en: 'As this response surface is based on a model fitted to data on the three variables
    of horsepower, weight, and MPG, it would be useful to view the raw observations
    alongside the fitted model. For this, you can use `points3d`, which works just
    like `points` in base R graphics. Execute the following:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这个响应面是基于适配于马力、重量和MPG这三个变量的数据的模型，它会很有帮助将原始观测数据与拟合模型一起查看。为此，你可以使用`points3d`，它的功能就像基础R图形中的`points`。执行以下命令：
- en: '[PRE14]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Resize the RGL device to your liking and keep the device open. These two commands
    plotted the predicted mean MPG response surface, this time in red at 70 percent
    opacity using the optional `alpha` argument, and then added the raw observations
    to the same image in green, slightly enlarged from their default size. You can
    see this plot on the right of [Figure 26-4](ch26.xhtml#ch26fig4); you can now
    compare the fit of the response surface to the raw data and view it from any angle.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 调整RGL设备的大小以适应你的需要并保持设备开启。这两个命令绘制了预测的平均MPG响应面，这次使用可选的`alpha`参数设置为70%的不透明度并显示为红色，然后将原始观测数据以绿色添加到同一图像中，并略微放大它们的默认大小。你可以在[图26-4](ch26.xhtml#ch26fig4)的右侧看到这个图；你现在可以比较响应面与原始数据的拟合情况，并从任何角度查看。
- en: '**Adding Surfaces**'
  id: totrans-86
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**添加表面**'
- en: You can also add more perspective surfaces! Let’s continue to add to the current
    plot using the `car.pred` object you created for [Figure 26-4](ch26.xhtml#ch26fig4).
    The response surface is stored as the first column in `car.pred`; the corresponding
    lower and upper prediction limits are stored as the second and third columns—flip
    back to [Section 20.4.2](ch20.xhtml#ch20lev2sec182) for a discussion of `predict`
    for linear regression models. To add these prediction bounds to the response surface
    displayed on the right of [Figure 26-4](ch26.xhtml#ch26fig4), you first need to
    store each bounding surface as a *z*-matrix corresponding to the *x*-*y* evaluation
    grid.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以添加更多的透视表面！让我们继续使用你为[图26-4](ch26.xhtml#ch26fig4)创建的`car.pred`对象来添加当前图表。响应面存储在`car.pred`的第一列；相应的上下预测限制存储在第二列和第三列——回到[第20.4.2节](ch20.xhtml#ch20lev2sec182)讨论线性回归模型的`predict`。要将这些预测边界添加到[图26-4](ch26.xhtml#ch26fig4)右侧显示的响应面，你首先需要将每个边界表面存储为一个对应于*x*-*y*评估网格的*z*-矩阵。
- en: '[PRE15]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Then, simply call `persp3d` for each of these *z*-matrices and use the optional
    `add` argument set to `TRUE`—this instructs the `persp3d` function to add to the
    existing graphic without refreshing the plot.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，简单地对每一个*z*-矩阵调用`persp3d`，并使用可选的`add`参数设置为`TRUE`——这指示`persp3d`函数将新的图形添加到现有的图形中，而不刷新图表。
- en: '[PRE16]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Here you’ve also set the color for each additional surface to cyan and set the
    opacity at 50 percent. You can see the result on the left of [Figure 26-5](ch26.xhtml#ch26fig5).
    After rotating it with your mouse, you’ll be able to see that the observations
    all fall between the 3D 99 percent prediction interval bounds for this particular
    model.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，你还将每个附加表面的颜色设置为青色，并将不透明度设置为50%。你可以在[图26-5](ch26.xhtml#ch26fig5)左侧看到结果。通过鼠标旋转它，你将能够看到所有观测值都落在这个特定模型的3D
    99%预测区间的范围内。
- en: '![image](../images/f26-05.jpg)'
  id: totrans-92
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f26-05.jpg)'
- en: '*Figure 26-5: Adding further surfaces denoting the 99 percent prediction interval
    to an existing* `persp3d` *plot of the fitted* `mtcars` *model. Left: Green points
    make up the raw observations. Right: Raw observations are labeled with added text,
    and corresponding line segments mark the corresponding residuals.*'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '*图26-5：在现有的`persp3d`拟合`mtcars`模型图中，添加进一步的表面表示99%预测区间。左侧：绿色点表示原始观测值。右侧：原始观测值被加上文本标签，相应的线段标记了对应的残差。*'
- en: 'Alternatively, you could label raw observations with the row names attribute
    of the original `mtcars` data frame as added text so that you could identify which
    car is which in the plot. In this case, the names are obtained as a vector of
    character strings using the built-in `rownames` function. To add text to an existing
    3D graphic, `rgl` has its own analog of the traditional `text` function, `text3d`.
    Executing the following four lines replots the translucent red response surface,
    adds the appropriate text at the (*x*, *y*, *z*) coordinates corresponding to
    that car, and again adds the cyan prediction interval:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 另外，你可以使用原始`mtcars`数据框的行名属性将原始观测值标注为文本，这样你就可以在图中识别出每辆车对应的名称。在这种情况下，可以使用内置的`rownames`函数将名称作为字符字符串向量获取。为了在现有的3D图形中添加文本，`rgl`有一个类似于传统`text`函数的函数`text3d`。执行以下四行代码会重新绘制半透明的红色响应面，在对应的（*x*，*y*，*z*）坐标处添加适当的文本，并再次添加青色的预测区间：
- en: '[PRE17]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The text is harder to visually locate than the green dots, so it makes sense
    to point their locations out on the fitted surface—and what better way to do so
    than using the fitted model residuals? The `segments3d` function is ideal for
    this purpose, as you know from the 3D scatterplots of the `iris` data. First,
    you need to set up the “from–to” vectors in the three coordinates (refer to [Section
    26.1](ch26.xhtml#ch26lev1sec92) for an explanation of `segments3d`).
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 由于文本比绿色点更难以视觉定位，因此在拟合的表面上标出它们的位置是有意义的——而使用拟合模型的残差来实现这一点又有什么比这更好的方法呢？正如你从`iris`数据的3D散点图中知道的那样，`segments3d`函数非常适合这个目的。首先，你需要在三个坐标轴上设置“从–到”向量（有关`segments3d`的解释，请参见[第26.1节](ch26.xhtml#ch26lev1sec92)）。
- en: '[PRE18]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Here, again, the *x*- and *y*-axis values don’t change when moving from the
    “from” location to the “to” location, so these are simply double-replicates of
    each horsepower and weight entry of the original data frame. You need to instruct
    the *z*-axis “from” values to remain as the fitted values of the model (in other
    words, the actual vertical location of the response surface), and the “to” values
    are the raw data *z* values. Then, a final call to `segments3d` draws on the residuals,
    as standard black line segments, for each `text3d`-labeled car.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，*x*轴和*y*轴的值在从“从”位置到“到”位置的过程中并没有变化，因此它们只是原始数据框中每个马力和重量条目的双重副本。你需要指示*z*轴的“从”值保持为模型的拟合值（换句话说，响应面的实际垂直位置），而“到”值是原始数据的*z*值。然后，最后一次调用`segments3d`函数绘制残差，每个带有`text3d`标签的汽车对应一条标准的黑色线段。
- en: '[PRE19]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Take a moment to interact with the final product, shown on the right of [Figure
    26-5](ch26.xhtml#ch26fig5).
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 花一点时间与最终产品互动，见[图26-5](ch26.xhtml#ch26fig5)右侧。
- en: '***26.2.3 Coloring by z Value***'
  id: totrans-101
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***26.2.3 根据z值着色***'
- en: One advantage of `persp3d` plots is that you can color the surface according
    to the *z* values without needing to do anything special. Recall that if you were
    using the base R `persp` function, coloring by *z* value would require a minor
    workaround, because you’d need to calculate the relevant vertical position as
    the average of four adjacent *z*-matrix entries that make up each facet (see [Section
    25.6.2](ch25.xhtml#ch25lev2sec259)).
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '`persp3d`图的一个优点是，你可以根据*z*值着色表面，而无需做任何特殊处理。回想一下，如果你使用的是基础R的`persp`函数，按*z*值着色将需要一个小小的变通，因为你需要计算作为每个面片四个相邻*z*矩阵条目的平均值来获得相关的垂直位置（见[第25.6.2节](ch25.xhtml#ch25lev2sec259)）。'
- en: Fortunately, this isn’t necessary with `persp3d`. Continuing one last time with
    the `mtcars` response surface, you can set up your desired color palette and assign
    colors to the entries of the *z*-matrix themselves without having to average out
    each set of four adjacent values first.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，使用`persp3d`时并不需要这么做。再次以`mtcars`响应面为例，你可以设置所需的颜色调色板，并直接将颜色分配给*z*-矩阵的条目，而无需先平均每组相邻的四个值。
- en: '[PRE20]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Then, using categorization to assign color to values on a continuum, you just
    need to index `blues200` by `zm.colors` when specifying the `col` value in `persp3d`.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，使用分类方法为连续值分配颜色，当在`persp3d`中指定`col`值时，只需要通过`zm.colors`索引`blues200`。
- en: '[PRE21]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '[Figure 26-6](ch26.xhtml#ch26fig6) shows the result.'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '[图26-6](ch26.xhtml#ch26fig6)展示了结果。'
- en: '![image](../images/f26-06.jpg)'
  id: totrans-108
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f26-06.jpg)'
- en: '*Figure 26-6: Showing a result of direct color assignment corresponding to
    the* z*-matrix value in use of* `persp3d` *for the* `mtcars` *response surface*'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '*图26-6：展示在`persp3d`中使用*z*-矩阵值直接分配颜色，生成的`mtcars`响应面结果*'
- en: '***26.2.4 Dealing with the Aspect Ratio***'
  id: totrans-110
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***26.2.4 处理纵横比***'
- en: 'Taking a break from the `mtcars` model, you’ll now return to the bivariate
    kernel density estimate of the Chorley-Ribble data, used in [Sections 25.5.2](ch25.xhtml#ch25lev2sec257)
    and [25.6.2](ch25.xhtml#ch25lev2sec259). Load the `spatstat` package to access
    the `chorley` data and use the `MASS` package to access the `kde2D` function.
    Repeated from earlier for convenience, the following code calculates the KDE surface
    using `kde2D`, stored as the `$z` component of the `chor.dens.WIN` object:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 从`mtcars`模型中休息一下，你现在将返回到Chorley-Ribble数据的双变量核密度估计，该数据在[第25.5.2节](ch25.xhtml#ch25lev2sec257)和[25.6.2节](ch25.xhtml#ch25lev2sec259)中使用。加载`spatstat`包以访问`chorley`数据，并使用`MASS`包访问`kde2D`函数。为了方便起见，以下代码计算使用`kde2D`的KDE表面，结果存储在`chor.dens.WIN`对象的`$z`组件中：
- en: '[PRE22]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: It also truncates the surface to fall within the polygon that represents the
    geographical study region by setting all elements of the *z*-matrix outside that
    polygon to `NA` (you studied in detail how to do this in [Section 25.5.2](ch25.xhtml#ch25lev2sec257)).
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 它还通过将所有位于该多边形外部的*z*-矩阵元素设置为`NA`，将表面截断，以使其落入表示地理研究区域的多边形内（你已经在[第25.5.2节](ch25.xhtml#ch25lev2sec257)中详细学习了如何实现这一点）。
- en: 'Then, executing the next few lines of code generates 200 colors from the built-in
    `rainbow` palette that you’ve used previously for this KDE plot and categorizes
    the entries of the truncated *z*-matrix appropriately:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，执行接下来的几行代码生成200种颜色，这些颜色来自你之前为这个KDE图使用的内置`rainbow`调色板，并将截断后的*z*-矩阵条目适当地分类：
- en: '[PRE23]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Note again that the difference here is you don’t need to calculate facet averages
    as you did in [Section 25.6.2](ch25.xhtml#ch25lev2sec259)—`cut` is applied directly
    to `zm`.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 请再次注意，区别在于你不需要像在[第25.6.2节](ch25.xhtml#ch25lev2sec259)中那样计算面板平均值——`cut`直接应用于`zm`。
- en: Before calling `persp3d`, it’s worth remembering that since you’re dealing with
    a geographical area, you should consider the aspect ratio in the *x*- and *y*-coordinate
    directions. As you saw in [Section 26.1](ch26.xhtml#ch26lev1sec92), the `aspect`
    argument in `rgl` functions operates a little differently than the `asp` argument
    in `image` or the `scale`/`expand` arguments in `persp`. In `rgl` plots, including
    `persp3d`, `aspect` requests a numeric vector of length 3, which defines the relative
    scale of the *x*-, *y*-, and *z*-axes, in that order.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在调用`persp3d`之前，值得记住的是，由于你处理的是地理区域，应该考虑*x*轴和*y*轴方向的纵横比。正如你在[第26.1节](ch26.xhtml#ch26lev1sec92)中看到的，`rgl`函数中的`aspect`参数的作用与`image`中的`asp`参数或`persp`中的`scale`/`expand`参数有所不同。在`rgl`图形中，包括`persp3d`，`aspect`请求一个长度为3的数值向量，用来定义*x*、*y*和*z*轴的相对比例，顺序为*x*轴、*y*轴和*z*轴。
- en: To determine the appropriate relative scales for the Chorley-Ribble data, you
    need to calculate the total *x*-axis and *y*-axis widths that the study region
    is defined upon and find their ratio.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确定Chorley-Ribble数据的适当相对比例，你需要计算定义研究区域的总*x*轴和*y*轴宽度，并找出它们的比率。
- en: '[PRE24]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: This was done using the `$xrange` and `$yrange` components of the `spatstat`
    polygon, subtracting the lower limit from the upper in each case. The final ratio
    of `xd/yd` reveals that you almost have a one-to-one scale, though technically
    the region is physically wider in the *x*-axis, by a factor of around 1.076, than
    it is in the *y*-axis.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 这是通过使用`spatstat`多边形的`$xrange`和`$yrange`组件完成的，分别在每种情况下从上限减去下限。最终的`xd/yd`比率显示出你几乎达到了1:1的比例，尽管从技术上讲，区域在*x*轴上的物理宽度比在*y*轴上的宽度大，大约是1.076倍。
- en: Factoring that in, you can call `persp3d` to plot the KDE surface correctly.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到这一点，你可以调用`persp3d`正确绘制KDE曲面。
- en: '[PRE25]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: You use `aspect` to stipulate that the *x*-axis should be scaled according to
    a factor of `xd/yd` relative to the *y*-axis, that the *y*-axis is taken as the
    reference scale of 1, and that the *z*-axis should be squashed by a factor of
    0.75 relative to the *y*-axis. This is arbitrarily set so that the graphic is
    similar to the original `persp` plot in [Figure 25-21](ch25.xhtml#ch25fig21) on
    [page 685](ch25.xhtml#page_685).
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`aspect`来指定*x*轴应该根据`xd/yd`的比例因子相对于*y*轴进行缩放，*y*轴被视为参考比例1，*z*轴应相对于*y*轴按0.75的因子进行压缩。这个设置是任意的，使得图形与[图
    25-21](ch25.xhtml#ch25fig21)中在[第685页](ch25.xhtml#page_685)的原始`persp`图形相似。
- en: 'Let’s finish off the plot by adding a color legend. Ensure you have the `shape`
    package loaded, resize your RGL device containing the result of the most recent
    call to `persp3d`, and execute the following command:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过添加一个颜色图例来完成图形的绘制。确保已经加载了`shape`包，调整包含最近一次调用`persp3d`结果的RGL设备大小，并执行以下命令：
- en: '[PRE26]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Remember that `bgplot3d` must be used to change the background of the current
    RGL device—refer to the end of [Section 26.1](ch26.xhtml#ch26lev1sec92). You might
    want to experiment a little with `posx` and `posy` to find your preferred placement
    of the color legend. [Figure 26-7](ch26.xhtml#ch26fig7) shows the result on my
    machine.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，必须使用`bgplot3d`来更改当前RGL设备的背景—请参考[第26.1节](ch26.xhtml#ch26lev1sec92)的末尾。你可能想稍微实验一下`posx`和`posy`，以找到你偏好的颜色图例位置。[图
    26-7](ch26.xhtml#ch26fig7)展示了我机器上的结果。
- en: '![image](../images/f26-07.jpg)'
  id: totrans-127
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f26-07.jpg)'
- en: '*Figure 26-7: An interactive* `persp3d` *representation of the Chorley-Ribble
    kernel density estimate, colored according to* z*-axis values, with a static color
    legend*'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 26-7：一个交互式* `persp3d` *表示的 Chorley-Ribble 核密度估计，按*z*轴值着色，并带有静态颜色图例*'
- en: '**Exercise 26.2**'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '**练习 26.2**'
- en: Return to the measurements in the built-in `airquality` data frame. Create a
    copy of the data frame containing the variables pertaining to temperature, wind
    speed, ozone level, and month; delete all rows with any missing values. You’re
    now going to experiment with an `rgl` visualization of an earlier regression model
    for mean temperature.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 返回内置的`airquality`数据框中的测量值。创建一个数据框的副本，包含与温度、风速、臭氧水平和月份相关的变量；删除所有包含缺失值的行。现在，你将使用`rgl`对之前的均温回归模型进行可视化实验。
- en: Refit the multiple linear model from [Exercise 25.4](ch25.xhtml#ch25exc4) on
    [page 676](ch25.xhtml#page_676), which regressed temperature against the main
    effects and an interactive effect of wind speed and ozone. Use `expand.grid` and
    `predict` to construct a *z*-matrix of the response surface; include the estimation
    of a 95 percent confidence interval for the fitted mean. Then, use `rgl` functionality
    to produce an interactive 3D plot of the response surface and color it yellow.
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重新拟合[练习 25.4](ch25.xhtml#ch25exc4)中的多元线性模型，该模型对温度与主要效应和风速与臭氧的交互效应进行了回归。使用`expand.grid`和`predict`构造响应面对应的*z*矩阵；包括对拟合均值的95%置信区间估计。然后，使用`rgl`功能生成响应面的交互式3D图，并将其着色为黄色。
- en: Using the built-in `topo.colors` palette, replot the response surface, assigning
    the colors according to the *z* value and setting the opacity at 80 percent. Tidy
    up the axis titles, resize the RGL device, and leave the plot open.
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用内置的`topo.colors`调色板，重新绘制响应面，将颜色根据*z*值进行分配，并设置不透明度为80%。整理轴标题，调整RGL设备大小，并保持图形打开。
- en: 'Enhance the plot from (b) as follows:'
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如下所示，增强(b)中的图形：
- en: Generate exactly five colors from a custom palette that goes from `"red4"` to
    `"pink"` and add the raw wind, ozone, and temperature observations as points to
    the plot of the response surface. The points should be colored according to month
    (May through September) using these five colors in order. Set the size of the
    added points to `10`.
  id: totrans-134
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从一个自定义调色板中生成正好五种颜色，颜色从`"red4"`到`"pink"`，并将原始的风速、臭氧和温度观察值作为点添加到响应面图上。根据月份（5月到9月）使用这五种颜色按顺序为点着色。将添加的点的大小设置为`10`。
- en: Add vertical lines that denote the residuals of the fitted model to the plot;
    in other words, each observation should have a vertical line connecting it to
    the corresponding fitted value of the response surface. These added lines should
    use the custom palette from earlier to match the color of each data point.
  id: totrans-135
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 向图形添加垂直线，表示拟合模型的残差；换句话说，每个观察值应有一条垂直线将其连接到响应曲面的相应拟合值。这些添加的线条应该使用先前的自定义调色板，以匹配每个数据点的颜色。
- en: Add the upper and lower 95 percent confidence limits you stored as part of the
    model prediction in (a). The added surfaces should both be gray with 50 percent
    opacity.
  id: totrans-136
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加在 (a) 中存储的模型预测的上下 95% 置信区间。添加的曲面应为灰色，并具有 50% 的不透明度。
- en: Add a legend to the top-right corner of the interactive plot referencing the
    five colors of points/lines according to month. Use a `pch` value of `19` and
    a `cex` value of `2`.
  id: totrans-137
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在交互式图形的右上角添加一个图例，参考按月份划分的五种颜色的点/线。使用 `pch` 值为 `19`，`cex` 值为 `2`。
- en: 'The result should look like this:'
  id: totrans-138
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 结果应如下所示：
- en: '![image](../images/f0707-01.jpg)'
  id: totrans-139
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_IMG
  zh: '![image](../images/f0707-01.jpg)'
- en: 'Next, load the `spatstat` package and revisit the `clmfires` data set. Execute
    the following lines to restrict attention to only the intentionally lit fires
    and to obtain the geographical study region:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，加载 `spatstat` 包并重新访问 `clmfires` 数据集。执行以下代码行，仅关注故意点燃的火灾，并获取地理研究区域：
- en: R> fire <- split(clmfires)$intentional
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: R> fire <- split(clmfires)$intentional
- en: R> firewin <- clmfires$window
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: R> firewin <- clmfires$window
- en: Reproduce the static perspective plot from [Exercise 25.5](ch25.xhtml#ch25exc5)
    (e) on [page 689](ch25.xhtml#page_689) as an interactive perspective plot, based
    on the following guidelines. Then keep the plot open.
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 根据以下指南，将 [练习 25.5](ch25.xhtml#ch25exc5) (e) 中的静态透视图在 [第689页](ch25.xhtml#page_689)
    上重现为交互式透视图。然后保持该图形打开。
- en: – Calculate the KDE surface of the `$x`- and `$y`-coordinates of `fire`, truncated
    to the study region in `firewin`, using a 256 × 256 evaluation grid.
  id: totrans-144
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: – 计算 `fire` 的 `$x` 和 `$y` 坐标的 KDE 曲面，限制为 `firewin` 中的研究区域，使用 256 × 256 的评估网格。
- en: – Use the built-in color palette `heat.colors` to color the surface according
    to the *z* value. Set the opacity to 70 percent.
  id: totrans-145
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: – 使用内置的颜色调色板 `heat.colors`，根据 *z* 值为表面着色。将不透明度设置为 70%。
- en: – Ensure the *x*-*y* axes have the correct ratio. Then reduce the vertical aspect
    ratio to be 0.6 relative to the *y*-axis.
  id: totrans-146
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: – 确保 *x*-*y* 轴具有正确的比例。然后将垂直方向的纵横比缩小为相对于 *y*-轴的 0.6。
- en: – Suppress the *z*-axis title but add neat `"X"` and `"Y"` titles to the other
    two axes.
  id: totrans-147
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: – 抑制 *z*-轴标题，但在另外两个轴上添加整齐的 `"X"` 和 `"Y"` 标题。
- en: 'Make the following enhancements to the plot:'
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对图形进行以下增强：
- en: Add the raw observations so they lie underneath the surface itself. To do this,
    set a constant *z* value for each data point as the minimum (and non-`NA`) value
    of the *z*-matrix.
  id: totrans-149
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加原始观察值，使其位于表面下方。为此，将每个数据点的常量 *z* 值设置为 *z*-矩阵的最小（且非 `NA`）值。
- en: 'You can obtain the vectors of the *x*- and *y*-coordinates of the irregular
    polygon that forms the study region by using the `vertices` function of `spatstat`
    as follows:'
  id: totrans-150
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您可以通过以下方式使用 `spatstat` 的 `vertices` 函数获取形成研究区域的非规则多边形的 *x* 和 *y* 坐标向量：
- en: R> firepoly <- vertices(firewin)
  id: totrans-151
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: R> firepoly <- vertices(firewin)
- en: R> fwx <- firepoly$x
  id: totrans-152
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: R> fwx <- firepoly$x
- en: R> fwy <- firepoly$y
  id: totrans-153
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: R> fwy <- firepoly$y
- en: By supplying these two vectors to the appropriate `x` and `y` arguments of the
    `lines3d` function, add the study region to surround the superimposed observations
    lying flush to the *x*-*y* plane underneath the plotted surface. Again, you’ll
    need to specify the *z* value as the minimum *z*-matrix value for all drawn lines.
    Set `lwd=2` for a slightly thicker line than the one drawn by default.
  id: totrans-154
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 通过将这两个向量提供给 `lines3d` 函数的适当 `x` 和 `y` 参数，将研究区域添加到位于绘制表面下方的 *x*-*y* 平面上，以包围叠加的观察值。同样，您需要指定
    *z* 值作为所有绘制线条的最小 *z*-矩阵值。设置 `lwd=2` 以绘制比默认线条稍粗的线条。
- en: 'Your production should look something like this:'
  id: totrans-155
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你的结果应该像这样：
- en: '![image](../images/f0708-01.jpg)'
  id: totrans-156
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f0708-01.jpg)'
- en: '**26.3 Trivariate Surfaces**'
  id: totrans-157
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**26.3 三维曲面**'
- en: So far you’ve looked at bivariate functions of the form *z* = *f* (*x*, *y*),
    where your evaluation grid is two-dimensional. In other words, you evaluate the
    function *f* from an *x* value and a *y* value; the *x* and *y* values are plotted
    on the first two axes, and the values of *f* are used to plot a third dimension.
    Next you’ll plot *trivariate* functions, which can be thought of as *w* = *f*
    (*x*, *y*, *z*). That is, the evaluation grid is itself three-dimensional, and
    *f* gives you a fourth value, *w*, to use for plotting the surface.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，您已经看到了形式为 *z* = *f* (*x*, *y*) 的二元函数，其中您的评估网格是二维的。换句话说，您通过 *x* 值和 *y*
    值来评估函数 *f*；*x* 和 *y* 值绘制在前两个坐标轴上，*f* 的值则用于绘制第三维。接下来，您将绘制 *三变量* 函数，它可以看作是 *w* =
    *f* (*x*, *y*, *z*)。也就是说，评估网格本身是三维的，而 *f* 会给您一个第四个值 *w*，用于绘制表面。
- en: '***26.3.1 Evaluation Coordinates in 3D***'
  id: totrans-159
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***26.3.1 三维评估坐标***'
- en: When dealing with a trivariate mathematical function, you need an *x*, a *y*,
    and a *z* value to evaluate the result. Rather than a flat evaluation grid, you’ll
    have an evaluation *lattice* that sits in a cube or some other 3D prism.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理三变量数学函数时，您需要一个 *x*、一个 *y* 和一个 *z* 值来评估结果。与平面的评估网格不同，您将拥有一个位于立方体或其他三维棱镜中的评估
    *格子*。
- en: As a perfect first example of a trivariate function, you’ll create a “color
    cube” of RGB colors, where each point is the result of three values in red, green,
    and blue—refer to [Section 25.1.1](ch25.xhtml#ch25lev2sec242) for details. You’ll
    use the three physical axes to reflect the evaluation lattice in the red, green,
    and blue values, and the result will be a point plotted with that color in that
    position in the 3D space.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 作为三变量函数的完美示例，您将创建一个“颜色立方体”，其中每个点是红色、绿色和蓝色的三种值的结果——有关详细信息，请参见 [第 25.1.1 节](ch25.xhtml#ch25lev2sec242)。您将使用三个物理轴来反映红色、绿色和蓝色值的评估格子，结果将在
    3D 空间中的相应位置绘制该颜色的点。
- en: 'The following code sets up the evaluation lattice in the three coordinate directions:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码设置了三个坐标方向上的评估格子：
- en: '[PRE27]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: The first four lines generate equally spaced increasing sequences in the three
    colors spanning the standard 0 to 255 RGB integer range. Then you use the built-in
    `expand.grid` function to generate the data frame of all unique color triplets
    according to these three sequences, resulting in an evaluation lattice of exactly
    11³ = 1331 specific coordinates. Note that `expand.grid` works in the same way
    for higher-dimensional evaluation grids as it does for bivariate *x*-*y* grids
    (refer to [Section 25.3.1](ch25.xhtml#ch25lev2sec251)).
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 前四行生成三种颜色在标准 0 到 255 的 RGB 整数范围内等间距递增的序列。然后，您使用内置的 `expand.grid` 函数根据这三个序列生成包含所有唯一颜色三元组的数据框，从而得到一个包含
    11³ = 1331 个特定坐标的评估格子。请注意，`expand.grid` 对于高维评估网格的工作方式与对二元 *x*-*y* 网格的工作方式相同（有关详细信息，请参见
    [第 25.3.1 节](ch25.xhtml#ch25lev2sec251)）。
- en: 'Finally, a call to `plot3d` places spheres at each 3D evaluation coordinate
    (recall the use of the `rgb` command from [Section 25.1.1](ch25.xhtml#ch25lev2sec242)):'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，调用 `plot3d` 在每个 3D 评估坐标点上放置球体（回想一下在 [第 25.1.1 节](ch25.xhtml#ch25lev2sec242)中使用的
    `rgb` 命令）：
- en: '[PRE28]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '[Figure 26-8](ch26.xhtml#ch26fig8) shows the result from two different angles
    so you can see how the intensities of the red, green, and blue components of an
    RGB triplet control the color of each point.'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 26-8](ch26.xhtml#ch26fig8)展示了从两个不同角度得到的结果，您可以看到 RGB 三元组的红色、绿色和蓝色分量的强度如何控制每个点的颜色。'
- en: '![image](../images/f26-08.jpg)'
  id: totrans-168
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f26-08.jpg)'
- en: '*Figure 26-8: The* `rgl` *“color cube,” created as spheres whose fourth-dimension
    result (color itself) is the product of evaluating the trivariate RGB function.*'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 26-8：由 `rgl` 创建的“颜色立方体”，该立方体作为球体，其中第四维的结果（颜色本身）是评估三变量 RGB 函数的结果。*'
- en: '***26.3.2 Isosurfaces***'
  id: totrans-170
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***26.3.2 等值面***'
- en: One of the problems with plotting the individual spheres of points at each 3D
    evaluation coordinate is revealed by [Figure 26-8](ch26.xhtml#ch26fig8)—it’s difficult
    to see spheres “inside” the 3D prism. This same issue complicates the more general
    case of visualizing a continuous trivariate function.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 在每个 3D 评估坐标点绘制单独的点球时，问题暴露出来了——[图 26-8](ch26.xhtml#ch26fig8)中显示了这个问题——很难看到“内部”的球体，这个问题同样使得可视化连续三变量函数变得更加复杂。
- en: To remedy this, you could instead produce an *isosurface*, which can be thought
    of as a kind of trivariate analog of a contour plot.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这个问题，您可以改为生成一个 *等值面*，它可以被看作是等高线图的三变量类比。
- en: With an isosurface, you select a certain level of the values *w* = *f* (*x*,
    *y*, *z*) and join up all the entries of *w* at that level inside the 3D space
    to form a shape or “blob.” These blobs show where in the 3D space the trivariate
    function takes on the chosen value. If you then plot these blobs at various levels,
    you get a 3D version of the contour plots you created in [Section 25.4.1](ch25.xhtml#ch25lev2sec254),
    showing which levels hold the highest densities of observations.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 使用等值面时，你选择一个特定的值层次 *w* = *f* (*x*, *y*, *z*)，并将该层次上所有的*w*值在3D空间内连接起来形成一个形状或“块”。这些块显示了在三维空间中，三变量函数在哪些位置取到了所选的值。如果你再在不同的层次上绘制这些块，你将得到一个3D版本的等高线图，展示哪些层次具有最高的观测密度，正如你在[第25.4.1节](ch25.xhtml#ch25lev2sec254)中所创建的那样。
- en: '**Higher-Dimensional Probability Densities**'
  id: totrans-174
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**高维概率密度**'
- en: Cast your mind back to the univariate normal probability density function detailed
    in [Section 16.2.2](ch16.xhtml#ch16lev2sec142). First, I’ll introduce the idea
    of higherdimensional density functions with the bivariate version of the normal
    distribution, and then I’ll go one step further and use the trivariate version
    to illustrate isosurface plotting.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 回想一下[第16.2.2节](ch16.xhtml#ch16lev2sec142)中详细介绍的单变量正态概率密度函数。首先，我将介绍高维密度函数的概念，使用双变量版本的正态分布，然后我会进一步使用三变量版本来演示等值面绘图。
- en: 'To work with multivariate normal distributions, you can use the `mvtnorm` package,
    installed with a call to `install.packages("mvtnorm")`. Just like the `rnorm`
    function for the univariate normal, the `rmvnorm` function is used to generate
    random variates from a specified multivariate normal. Once you’ve installed `mvtnorm`,
    execute the following code:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 为了处理多元正态分布，你可以使用`mvtnorm`包，可以通过调用`install.packages("mvtnorm")`进行安装。与单变量正态分布的`rnorm`函数类似，`rmvnorm`函数用于从指定的多元正态分布中生成随机变量。安装了`mvtnorm`后，执行以下代码：
- en: '[PRE29]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: This produces the plot on the left of [Figure 26-9](ch26.xhtml#ch26fig9). The
    `rmvnorm` function is used to generate 500 independent variates from the standard
    bivariate normal distribution. You center the variates around the coordinate (0,0)
    by passing a numeric vector to `mean`. By default, independent standard deviation
    components of 1 are used in both *x*-*y* coordinate directions.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 这产生了[图 26-9](ch26.xhtml#ch26fig9)左侧的图形。`rmvnorm`函数用于从标准双变量正态分布中生成500个独立的变量。你通过传递一个数值向量给`mean`来将这些变量围绕坐标(0,0)进行居中处理。默认情况下，*x*-*y*坐标方向上的独立标准差分量均为1。
- en: '![image](../images/f26-09.jpg)'
  id: totrans-179
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f26-09.jpg)'
- en: '*Figure 26-9: Viewing randomly generated data, and the standard bivariate normal
    density they came from, using* `mvtnorm` *functionality*'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 26-9：使用`mvtnorm`功能查看随机生成的数据，以及它们来源的标准双变量正态密度*'
- en: 'To actually view the bivariate density function, you need to decide on the
    *x*-*y* evaluation grid and construct the *z*-matrix as usual using `expand.grid`.
    The following code sets up an evenly spaced sequence to use in both coordinate
    directions and uses the `dmvnorm` function (this is the multivariate version of
    `dnorm` and gives you the density function value at specified coordinates) to
    fill the *z*-matrix:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 要实际查看双变量密度函数，你需要决定* x *-* y *评估网格，并像往常一样使用`expand.grid`构造*z*矩阵。以下代码在两个坐标方向上设置了一个均匀间隔的序列，并使用`dmvnorm`函数（这是`dnorm`的多元版本，给定指定坐标时提供密度函数值）来填充*z*矩阵：
- en: '[PRE30]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Then, you can use `contour` (or `persp` or `persp3d`) to view the density from
    which the data in `rand2d.norm` were generated for comparison (truncated to the
    limits −3 to 3 in both axes). The following line produces the plot on the right
    of [Figure 26-9](ch26.xhtml#ch26fig9):'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，你可以使用`contour`（或`persp`或`persp3d`）来查看用于比较的`rand2d.norm`数据生成的密度（限制在−3到3的范围内）。以下代码行生成了[图
    26-9](ch26.xhtml#ch26fig9)右侧的图形：
- en: '[PRE31]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: '**Basic One-Level Isosurface**'
  id: totrans-185
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**基本一阶等值面**'
- en: Now let’s increase the dimension once more—what does a *trivariate* normal density
    function look like?
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们再增加一个维度——*三变量*正态密度函数是什么样子的？
- en: 'First, let’s take a look at some data generated from this density. The following
    code generates 500 random variates again:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们看看从这个密度生成的一些数据。以下代码再次生成500个随机变量：
- en: '[PRE32]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: However, since you supplied a vector of length 3 as the `mean` argument to `rmvnorm`,
    the function knows you have three dimensions to work with. You’re telling it that
    you want the data to come from a trivariate normal, with means of 0, 0, and 0
    in each coordinate direction. You can see the `rgl` point cloud of the data produced
    via `plot3d` on the left of [Figure 26-10](ch26.xhtml#ch26fig10).
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，由于你将一个长度为3的向量作为`mean`参数传递给`rmvnorm`，该函数知道你有三个维度要处理。你告诉它，你希望数据来自一个三元正态分布，且在每个坐标方向上的均值为0、0和0。你可以在[图26-10](ch26.xhtml#ch26fig10)左侧看到通过`plot3d`生成的数据的`rgl`点云。
- en: To calculate and display the actual trivariate density function that generated
    these data, you’ll need a 3D evaluation lattice, as noted at the beginning of
    [Section 26.3](ch26.xhtml#ch26lev1sec94).
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 要计算并显示生成这些数据的实际三元密度函数，你需要一个3D评估网格，如[第26.3节](ch26.xhtml#ch26lev1sec94)开头所述。
- en: '![image](../images/f26-10.jpg)'
  id: totrans-191
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f26-10.jpg)'
- en: '*Figure 26-10: Left: Viewing data randomly generated from the standard trivariate
    normal distribution. Right: Concept of the 3D evaluation lattice upon which the
    trivariate density function itself will be plotted.*'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: '*图26-10：左侧：查看从标准三元正态分布随机生成的数据。右侧：三元密度函数将被绘制的3D评估网格的概念图。*'
- en: Take a look at the plot on the right of [Figure 26-10](ch26.xhtml#ch26fig10).
    It shows a 3D 11 × 11 × 11 evaluation lattice based on sequences spanning [−3,3]
    in *x*, *y*, and *z*. This should give you a clear idea of how increasing the
    dimension of a continuous function works. Each intersection in the 11 × 11 × 11
    grid is the 3D equivalent of each intersection of the solid lines in the 2D 6
    × 4 evaluation grid in [Figure 25-9](ch25.xhtml#ch25fig9) on [page 656](ch25.xhtml#page_656),
    and each of the 10³ mini-3D cubes in this 3D lattice is the 3D equivalent of a
    2D facet, as noted in the discussion of [Figure 25-20](ch25.xhtml#ch25fig20) on
    [page 683](ch25.xhtml#page_683). (As with [Figure 25-9](ch25.xhtml#ch25fig9),
    you can find the code to plot this 3D lattice on the book’s website.)
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 看一看[图26-10](ch26.xhtml#ch26fig10)右侧的图表。它显示了基于在*x*、*y*和*z*中跨越[−3,3]的序列生成的3D 11
    × 11 × 11评估网格。这应该能清晰地展示如何通过增加连续函数的维度来工作。这个11 × 11 × 11网格中的每个交点是[图25-9](ch25.xhtml#ch25fig9)中二维6
    × 4评估网格中的每个实线交点的三维等价物，而这个3D网格中的每个10³个迷你3D立方体是二维面片的三维等价物，如在[图25-20](ch25.xhtml#ch25fig20)的讨论中所提到的，在[第683页](ch25.xhtml#page_683)。
    (与[图25-9](ch25.xhtml#ch25fig9)类似，你可以在本书的网站上找到绘制此3D网格的代码。)
- en: To plot the result of the trivariate function, you need the unique evaluation
    coordinates of the evaluation lattice. Using `vals`, the sequence of values between
    −3 and 3 created earlier, the following code produces a data frame of all 50³
    = 125,000 unique 3D evaluation lattice coordinates.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 要绘制三元函数的结果，你需要评估网格的独特评估坐标。使用`vals`，即之前创建的跨越-3到3的值序列，以下代码会生成一个包含所有50³ = 125,000个独特3D评估网格坐标的数据框。
- en: '[PRE33]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Then you use `dmvnorm` to get the numeric value of the standard trivariate normal
    just as you did in the bivariate setting. The function automatically knows you’re
    requesting the trivariate density because your data argument `xyz` has three columns.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，你使用`dmvnorm`来获取标准三元正态分布的数值，就像在二元正态分布中做的那样。该函数会自动识别你请求的是三元密度，因为你的数据参数`xyz`有三列。
- en: '[PRE34]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Note that the result is stored appropriately as a 50 × 50 × 50 3D array—refer
    to [Section 3.4](ch03.xhtml#ch03lev1sec15) for details on `array`. Look at the
    conceptual diagram of a 3D array ([Figure 3-3](ch03.xhtml#ch3fig3) on [page 53](ch03.xhtml#page_53))
    and compare it to the 3D lattice on the right of [Figure 26-10](ch26.xhtml#ch26fig10).
    The trivariate normal values in the object `w` are clearly represented by a 3D
    block of numbers sitting at each corresponding unique evaluation coordinate in
    the defined 3D space.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，结果被适当地存储为一个50 × 50 × 50的3D数组——有关`array`的详细信息，请参见[第3.4节](ch03.xhtml#ch03lev1sec15)。查看3D数组的概念图（[图3-3](ch03.xhtml#ch3fig3)在[第53页](ch03.xhtml#page_53)）并将其与[图26-10](ch26.xhtml#ch26fig10)右侧的3D网格进行比较。对象`w`中的三元正态值显然是通过一个3D数值块表示的，坐落在定义的3D空间中的每个对应的独特评估坐标上。
- en: An isosurface can be produced using the `contour3d` function, part of the `misc3d`
    package ([Feng and Tierney, 2008](ref.xhtml#ref22)), which works closely with
    `rgl`. To use it, you need to decide on the level (or levels) at which to plot
    the surface. For densities, you typically make this choice with respect to what’s
    called the *α*-level contours; for more details, see the authoritative text on
    the theory of multivariate densities by Scott ([1992](ref.xhtml#ref60)). In brief,
    for some density *f*, these levels delineate the (1 − *α*) × 100 percent “most
    dense” observations by setting the isosurface to be drawn at positions in the
    multivariate evaluation lattice that correspond to the density value given by
    *α* × max(*f*).
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用`contour3d`函数生成等高面，该函数是`misc3d`包的一部分（[Feng and Tierney, 2008](ref.xhtml#ref22)），与`rgl`密切配合。要使用它，你需要决定绘制等高面时的水平（或多个水平）。对于密度图，通常根据所谓的*α*水平等高线来做出此选择；有关更多细节，请参阅Scott的权威著作《多元密度理论》（[1992](ref.xhtml#ref60)）。简而言之，对于某个密度*f*，这些水平通过将等高面绘制在多元评估格点中与密度值*α*
    × max(*f*)对应的位置来划定（1 − *α*) × 100百分比的“最密集”观察值。
- en: For the trivariate standard normal, the maximum value of the density is located
    at the mean at the coordinate (0,0,0).
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 对于三元标准正态分布，密度的最大值位于坐标(0,0,0)的均值处。
- en: '[PRE35]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: You’ll use this when producing the next couple of plots. Next, install `misc3d`,
    load it with `library("misc3d")`, and then call `contour3d`.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 在生成接下来的几个图时，你需要使用这个方法。接下来，安装`misc3d`，用`library("misc3d")`加载它，然后调用`contour3d`。
- en: '[PRE36]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: This produces an isosurface in an RGL device that you can rotate and zoom as
    you desire; you can see the result on the left of [Figure 26-11](ch26.xhtml#ch26fig11).
    You supply `contour3d` with the arguments `x`, `y`, and `z` as evenly spaced sequences
    in the *x*-, *y*-, and *z*-coordinate directions, respectively (all are defined
    by the vector `vals` in this case). You supply the corresponding 3D array, defining
    the entire result of the trivariate function to `f`, and pass the level (or levels)
    at which you want to draw the isosurface itself to `level`. Here, I’ve chosen
    the *α*-level to leave only 5 percent of the probability in the tails of the distribution,
    meaning that 95 percent of the total mass is held within the “blob.”
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 这将在RGL设备中生成一个等高面，你可以根据需要旋转和缩放它；你可以在[图26-11](ch26.xhtml#ch26fig11)的左侧看到结果。你需要为`contour3d`提供`x`、`y`和`z`作为在*x*、*y*、*z*坐标方向上的均匀间隔序列（在这个例子中，所有这些都是由向量`vals`定义的）。你还需要为函数`f`提供相应的3D数组，定义三元函数的整体结果，并将你希望绘制等高面的水平（或多个水平）传递给`level`。在这里，我选择了*α*水平，以便将分布尾部的5%概率留在外面，这意味着95%的总质量集中在“团块”内。
- en: '![image](../images/f26-11.jpg)'
  id: totrans-205
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f26-11.jpg)'
- en: '*Figure 26-11: An isosurface of the trivariate standard normal density function
    produced using* `contour3d` *of the* `misc3d` *package. Left: Stand-alone plot
    drawn at an *α* level of 0.05\. Right: Adding the same surface to an existing*
    `rgl` *plot of randomly generated trivariate normal observations, at 50 percent
    opacity.*'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: '*图26-11：使用`misc3d`包的`contour3d`函数生成的三元标准正态密度函数等高面。左图：在*α*水平为0.05时绘制的独立图形。右图：将相同的等高面添加到现有的`rgl`图中，图中包含随机生成的三元正态观察值，且不透明度为50%。*'
- en: 'The plot matches what you might expect—the shape of the trivariate density
    is relatively clear based on the plot of the randomly generated data you produced
    earlier. However, without scale, it’s little more than a statistical golf ball.
    It’s often more helpful to view the data alongside the density from which they
    came, which is also easy to do. The following code replots the data in `rand3d.norm`
    using `plot3d` and calls `contour3d` again to draw at the *α* level of 0.05:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 图形与预期相符——基于你之前生成的随机数据的图形，三元密度的形状相对清晰。然而，没有缩放的话，它不过是一个统计学上的高尔夫球。通常，将数据与其来源的密度一起查看会更有帮助，而这也是很容易做到的。以下代码使用`plot3d`重新绘制`rand3d.norm`中的数据，并再次调用`contour3d`以在*α*水平为0.05时绘制：
- en: '[PRE37]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Just as with the traditional R `contour` function, if you want to use `contour3d`
    to add to an existing `rgl` plot (as is the case here), you need to explicitly
    specify `add=TRUE`. You can also use the optional `alpha` argument to adjust opacity,
    reduced to 50 percent in this example, to “see inside” the density isosurface.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 就像传统的R `contour`函数一样，如果你希望使用`contour3d`添加到现有的`rgl`图中（就像这里的情况），你需要显式指定`add=TRUE`。你还可以使用可选的`alpha`参数来调整不透明度，在这个例子中降低到50%，以便“查看”密度等高面的内部。
- en: '**Controlling Multiple Levels with Color and Opacity**'
  id: totrans-210
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**通过颜色和不透明度控制多个水平**'
- en: Playing with opacity is especially useful when you want to plot the isosurface
    at multiple *α* levels at once. Color is also useful in this way, as a variable
    that can represent a fourth dimension without adding an additional physical axis
    to the graph.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 玩弄透明度特别有用，特别是在你想要同时绘制多个*α*水平的等值面时。颜色也在这方面非常有用，作为一个变量，可以表示第四维，而无需在图形中添加额外的物理轴。
- en: 'To view the trivariate normal density at multiple levels, consider the plot
    produced by executing the following code:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 要在多个层次上查看三变量正态密度，请执行以下代码生成的图形：
- en: '[PRE38]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: '[Figure 26-12](ch26.xhtml#ch26fig12) shows the result. Here, you replot the
    500 randomly generated trivariate normal observations, and another call to `contour3d`
    now draws contours at four specific *α*-levels of the trivariate density—0.05,
    0.2, 0.6, and 0.95\. You use the optional `color` argument to render these inpink,
    green, blue, and red, respectively, and progressively increase the opacity of
    each level with the `alpha` argument.'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 26-12](ch26.xhtml#ch26fig12)显示了结果。在这里，你重新绘制了500个随机生成的三变量正态观测数据，另一个`contour3d`调用现在在三变量密度的四个特定*α*水平（0.05、0.2、0.6和0.95）上绘制了等高线。你使用可选的`color`参数将这些等高线分别渲染为粉色、绿色、蓝色和红色，并通过`alpha`参数逐步增加每个水平的透明度。'
- en: '![image](../images/f26-12.jpg)'
  id: totrans-215
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f26-12.jpg)'
- en: '*Figure 26-12: An isosurface of the trivariate normal density plotted at four
    levels, over the randomly generated observations. Color and opacity are used to
    distinguish among the different numeric levels of the plotted function.*'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 26-12：在四个不同的水平上绘制的三变量正态密度等值面，覆盖在随机生成的观测数据上。使用颜色和透明度来区分绘制函数的不同数值水平。*'
- en: You should be able to see that you can gauge the increase in the denseness of
    the points in the 3D space for this distribution in a similar way as you’d use
    standard 2D contours to appraise the distribution of bivariate observations.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该能够看到，在这个分布的三维空间中，你可以通过类似于使用标准二维等高线来评估双变量观测分布的方式，来衡量点密度的增加。
- en: '***26.3.3 Example: Nonparametric Trivariate Density***'
  id: totrans-218
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***26.3.3 示例：非参数三变量密度***'
- en: For an extended example using real data, look once more at the built-in `quakes`
    data frame, which includes the spatial location, magnitude, and depth of 1000
    seismic events.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看使用真实数据的扩展示例，请再次查看内置的`quakes`数据框，它包含了1000次地震事件的空间位置、震级和深度。
- en: In [Section 25.4.1](ch25.xhtml#ch25lev2sec254), you constructed bivariate kernel
    density estimates of the 2D longitude-latitude spatial coordinates, using the
    `MASS` function `kde2D`. As noted there, KDE extends naturally to higher dimensions.
    The goal now is to calculate and visualize a density estimate of the same spatial
    earthquake data, but this time to do so based on the trivariate coordinates of
    longitude, latitude, *and* depth, in 3D space.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第25.4.1节](ch25.xhtml#ch25lev2sec254)，你使用`MASS`函数`kde2D`构建了二维经度-纬度空间坐标的双变量核密度估计。如那里所述，KDE自然扩展到更高维度。现在的目标是计算并可视化相同空间地震数据的密度估计，但这次基于三变量坐标——经度、纬度和*深度*，在三维空间中进行。
- en: '**Raw Data**'
  id: totrans-221
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**原始数据**'
- en: First, let’s look at the raw observations. The following code creates a copy
    of the `quakes` data, extracting those three variables and rendering `depth` negative.
    I dothis so that, when plotted, earthquake depth corresponds to moving *down*
    the vertical axis to give the impression of depth below sea level.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们看一下原始观测数据。以下代码创建了`quakes`数据的副本，提取了三个变量并将`depth`设置为负值。我这样做是为了在绘制时，使得地震深度对应于沿垂直轴向*下*移动，给人一种深度低于海平面的印象。
- en: '[PRE39]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'In the usual `rgl` fashion, you create a point cloud of the raw data with the
    following:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 以通常的`rgl`方式，你可以通过以下代码创建原始数据的点云：
- en: '[PRE40]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: '[Figure 26-13](ch26.xhtml#ch26fig13) shows the result. If you spin the plot
    so that you’re looking down directly from the top with a bird’s-eye view, you’ll
    recognize the 2D spatial patterning that you’ve plotted already; see, for example,
    [Figure 13-1](ch13.xhtml#ch13fig1) ([page 265](ch13.xhtml#page_265)), [Figure
    23-1](ch23.xhtml#ch23fig1) ([page 578](ch23.xhtml#page_578)), or [Figure 25-12](ch25.xhtml#ch25fig12)
    ([page 662](ch25.xhtml#page_662)).'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 26-13](ch26.xhtml#ch26fig13)显示了结果。如果你旋转图形，使得你直接从上方俯视，你将认出你已经绘制的二维空间模式；例如，可以参见[图
    13-1](ch13.xhtml#ch13fig1)（[第265页](ch13.xhtml#page_265)）、[图 23-1](ch23.xhtml#ch23fig1)（[第578页](ch23.xhtml#page_578)）或[图
    25-12](ch25.xhtml#ch25fig12)（[第662页](ch25.xhtml#page_662)）。'
- en: '![image](../images/f26-13.jpg)'
  id: totrans-227
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f26-13.jpg)'
- en: '*Figure 26-13: Viewing the 3D spatial dispersion of the earthquake occurrences—latitude,
    longitude, and depth*'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 26-13：查看地震事件的三维空间分布——纬度、经度和深度*'
- en: '**Calculating the 3D Estimate**'
  id: totrans-229
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**计算3D估计**'
- en: The evaluation lattice for this kernel estimate will be defined by the entire
    3D space in which the longitude-latitude-depth data reside, exactly as illustrated
    in [Section 26.3.2](ch26.xhtml#ch26lev2sec269).
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 该核估计的评估网格将由经度-纬度-深度数据所在的整个3D空间定义，正如[第26.3.2节](ch26.xhtml#ch26lev2sec269)中所示。
- en: To actually calculate the 3D KDE surface for the `quak` data, you’ll use the
    impressive functionality of the contributed package `ks` ([Duong, 2007](ref.xhtml#ref20)).
    Install the package and load it with a call to `library("ks")`. The `kde` function
    within the `ks` package allows you to use kernel smoothing to estimate the probability
    density of 1D through 6D data.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 要实际计算`quak`数据的3D KDE表面，你将使用贡献包`ks`（[Duong, 2007](ref.xhtml#ref20)）的强大功能。安装该包并通过调用`library("ks")`加载它。`ks`包中的`kde`函数允许你使用核平滑来估计1D到6D数据的概率密度。
- en: The first argument you supply to `kde` is your data, in the form of a matrix
    or data frame, with the tag `x`. Note that the order of the columns in your data
    object matters when using `kde`. When called as follows with `quak`, and taking
    into account the extraction order of the three variables in the earlier code that
    created `quak`, the *x*-, *y*-, and *z*-coordinate axes in the resulting 3D kernel
    estimate will correspond to longitude, latitude, and depth, respectively.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 你传递给`kde`的第一个参数是你的数据，形式为矩阵或数据框，并带有标签`x`。注意，在使用`kde`时，数据对象中列的顺序非常重要。当与`quak`一起调用时，并考虑到之前代码中创建`quak`时提取的三个变量的顺序，结果3D核估计中的*x*、*y*和*z*坐标轴将分别对应经度、纬度和深度。
- en: '[PRE41]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: This matches the way the data are displayed in [Figure 26-13](ch26.xhtml#ch26fig13).
    The `gridsize` argument specifies the lattice resolution in each axis. In this
    example, I’ve settled on a 64 × 64 × 64 lattice; by default, `kde` chooses the
    range of evaluation in each coordinate direction so that it’s slightly wider than
    the observed data. Finally, to plot the result, it’s useful to also specify the
    argument `compute.cont=TRUE`; I’ll go into the reason for this in a moment.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 这与[图26-13](ch26.xhtml#ch26fig13)中显示数据的方式一致。`gridsize`参数指定每个轴的网格分辨率。在这个例子中，我选择了64
    × 64 × 64的网格；默认情况下，`kde`会选择每个坐标方向上略宽于观测数据的评估范围。最后，为了绘制结果，指定参数`compute.cont=TRUE`也是有用的；稍后我会解释这样做的原因。
- en: 'The returned object has several components. The 3D estimate is provided as
    an appropriately sized array as the `$estimate` member; if you want to check,
    execution of the following line confirms it matches the desired lattice resolution:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 返回的对象有多个组成部分。3D估计作为适当大小的数组通过`$estimate`成员提供；如果你想检查，执行以下代码行可以确认它与期望的网格分辨率匹配：
- en: '[PRE42]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'The `$eval.points` component holds a list whose members are the specific evaluation
    coordinates, which are equally spaced sequences in each of the three axes. The
    number of members reflects the dimension of the problem, and their order corresponds
    to the specific axis. You can extract them with the following lines:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: '`$eval.points`组件包含一个列表，其成员是特定的评估坐标，这些坐标在三个轴上是等间距的序列。成员的数量反映了问题的维度，其顺序对应于特定轴。你可以通过以下代码提取它们：'
- en: '[PRE43]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: If you print these vectors to your console screen, you’ll see that each is a
    vector of length 64, with `x.latt`, `y.latt`, and `z.latt` corresponding to the
    variables matching the order of the columns in the data frame `quak`.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你将这些向量打印到控制台屏幕上，你会看到每个向量的长度为64，`x.latt`、`y.latt`和`z.latt`对应于与数据框`quak`中列的顺序匹配的变量。
- en: '**Isosurface Level Selection**'
  id: totrans-240
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**等值面级别选择**'
- en: The selection of the level to display depends on the range of values that make
    up the result of the trivariate function itself. When you choose `compute.cont=TRUE`
    in the call to `kde`, you’re automatically provided with a collection of appropriate
    levels. These are returned in the component `$cont` as a numeric vector with a
    length of exactly 99, representing each integer between 1 percent and 99 percent.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 选择显示的级别取决于构成三变量函数结果的值的范围。当你在调用`kde`时选择`compute.cont=TRUE`，你会自动获得一组适当的级别。这些级别在`$cont`组件中作为一个长度恰好为99的数值向量返回，表示从1%到99%的每个整数。
- en: Internally, these levels are calculated by working out the result of the trivariate
    function at the location of each of the originally observed data points and then
    using `quantile` to obtain all the integer-valued percentiles (from 99 percent
    to 1 percent) of these density values (for a refresher on quantiles, refer to
    [Section 13.2.3](ch13.xhtml#ch13lev2sec118)). These are returned in decreasing
    order; in other words, `quak.dens3d$cont[1]` corresponds to the 99th percentile,
    and `quak.dens3d$cont[99]` is the 1st percentile.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 在内部，这些水平是通过计算每个原始观察数据点位置上三变量函数的结果，然后使用`quantile`函数获得这些密度值的所有整数百分位数（从99百分位到1百分位）（有关分位数的复习，请参见[第13.2.3节](ch13.xhtml#ch13lev2sec118)）。这些值按降序返回；换句话说，`quak.dens3d$cont[1]`对应于第99百分位，`quak.dens3d$cont[99]`对应于第1百分位。
- en: 'Though these values are obtained in a different way from the *α*-levels you
    experimented with when plotting the trivariate normal density, you essentially
    end up with same interpretation when visualizing the result—these values allow
    you to draw the isosurfaces at the level of estimated observation “denseness”
    that you want. For example, the lower quartile (aka the 25th percentile) is extracted
    with the following:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管这些值是通过与绘制三变量正态密度时实验的*α*水平不同的方式获得的，但当你可视化结果时，本质上你会得到相同的解释——这些值允许你在所需的估计观察“密度”水平上绘制等值面。例如，较低四分位数（即第25百分位数）可以通过以下方式提取：
- en: '[PRE44]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: This provides the value of the KDE trivariate function that is estimated to
    separate the most spatially diffuse 25 percent of the observations from the rest
    (in other words, so that the resulting blobs encapsulate the most spatially dense
    75 percent of the data).
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 这提供了KDE三变量函数的值，该值估算出将最空间分散的25%的观察与其余部分区分开来的值（换句话说，使得结果中的斑块包含了最密集的75%的数据）。
- en: '**NOTE**'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*At the time of writing, both the* `rgl` *and* `misc3d` *packages are dependencies
    of* `ks`. *This means they are loaded automatically when you load* `ks`*, so you
    don’t need to call* `library("rgl")` *or* `library("misc3d")` *explicitly in this
    case, and* `plot3d` *and* `contour3d` *are already available to you. This may
    change as the developers update their packages over time.*'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: '*在撰写时，* `rgl` *和* `misc3d` *包是* `ks` *的依赖项。这意味着当你加载* `ks` *时，它们会自动加载，因此在这种情况下，你不需要显式调用*
    `library("rgl")` *或* `library("misc3d")` *，* `plot3d` *和* `contour3d` *已经可以使用。随着开发者更新其包，这种情况可能会有所变化。*'
- en: When you execute the following code, it first replots the `quak` data that the
    density estimate is based on and then adds the corresponding isosurface using
    the lower point-wise density quartile as the desired level. You can see the result
    on the left of [Figure 26-14](ch26.xhtml#ch26fig14).
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 当你执行以下代码时，它首先重新绘制了基于密度估计的`quak`数据，然后使用下四分位点的密度值作为所需的水平，添加了相应的等值面。你可以在[图26-14](ch26.xhtml#ch26fig14)的左侧看到结果。
- en: '[PRE45]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: '![image](../images/f26-14.jpg)'
  id: totrans-250
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f26-14.jpg)'
- en: '*Figure 26-14: Isosurfaces (3D contour plots) of a trivariate kernel density
    estimate drawn at point-specific density quantiles, based on use of the contributed*
    `kde` *and* `contour3d` *functions. Left: Solid blue delineation of the lower
    quartile—the 25 percent most diffuse points. Right: Green delineation of the median—the
    50 percent most diffuse from the 50 percent most dense—with opacity reduced by
    half.*'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: '*图26-14：基于使用贡献的* `kde` *和* `contour3d` *函数绘制的三变量核密度估计的等值面（3D等高线图），在特定点密度分位数处。左侧：蓝色实线表示下四分位数——最分散的25%点。右侧：绿色表示中位数——最分散的50%与最密集的50%之间的分界线，透明度减半。*'
- en: Looking at the image, the blue blobs representing the 3D contour at the specified
    level are clear to see. Higher levels of the trivariate function, that is, more
    densely grouped points, are “inside” these blobs. In other words, the blue shapes
    encapsulate the observations associated with the highest 75 percent of estimated
    density with respect to latitude, longitude, and depth. To see inside the isosurfaces,
    you can adjust the opacity with `alpha`.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 看着图像，可以清楚地看到代表指定水平的3D等高线的蓝色斑块。三变量函数的较高水平，即密集分布的点，位于这些斑块的“内部”。换句话说，蓝色形状包含了与纬度、经度和深度相关的估计密度的最高75%观察数据。要查看等值面内部，你可以通过调整透明度`alpha`来实现。
- en: Let’s take the level that delineates the observations associated with the lower
    and upper 50 percent of estimated density values.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们取出划定下半部分和上半部分50%估计密度值所对应观察的水平。
- en: '[PRE46]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Then, rerun the call to `plot3d` to replot the raw `quak` data. After that,
    a call to `contour3d` produces the result on the right of [Figure 26-14](ch26.xhtml#ch26fig14),
    allowing you to see through the green blobs.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，重新运行`plot3d`调用以重新绘制原始`quak`数据。之后，调用`contour3d`产生[图 26-14](ch26.xhtml#ch26fig14)右侧的结果，让你能够透过绿色斑块看到更多信息。
- en: '[PRE47]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Lastly, you’ll highlight the top 80 percent of the mostly densely clustered
    observations using multiple levels. Execute the following:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，你将使用多个层次突出显示最密集聚集的前80%的观测数据。执行以下操作：
- en: '[PRE48]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: This obtains four levels—the quantiles above which the 80 percent, 60 percent,
    40 percent, and 20 percent most densely clustered observations are identified.
    Then set up a couple of vectors to control the color and opacity of each increasing
    level of denseness accordingly.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 这将得到四个层次——确定最密集聚集观测数据的80%、60%、40%和20%的分位数。然后，设置几个向量来控制每个密度层次的颜色和透明度。
- en: '[PRE49]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: The range of colors and alpha levels means the isosurface will darken in color
    and become more opaque as the density increases.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 颜色和透明度的范围意味着等值面在密度增加时会变暗并变得更加不透明。
- en: One final time, replot the raw `quak` data using `plot3d` as earlier. Then it’s
    simply a matter of supplying your vectors of length 4 to each appropriate argument
    in `contour3d`.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一次，像之前一样使用`plot3d`重新绘制原始`quak`数据。然后，只需将长度为4的向量传递给`contour3d`中的每个相应参数。
- en: '[PRE50]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: '[Figure 26-15](ch26.xhtml#ch26fig15) shows the results. You can see that the
    tightest grouping of earthquakes occurs quite deep and toward the eastern edge
    of the 3D spatial prism (the visible “three-chamber” density blob is a well-known
    feature of these particular data).'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 26-15](ch26.xhtml#ch26fig15)展示了结果。你可以看到，地震的最紧密聚集出现在非常深的位置，且位于3D空间棱柱的东部边缘（可见的“三室”密度斑块是这些特定数据的一个著名特征）。'
- en: '**26.4 Handling Parametric Equations**'
  id: totrans-265
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**26.4 处理参数方程**'
- en: In most of the examples in the chapter so far, the surfaces are directly defined
    by the coordinates of a regular evaluation grid or lattice, but there are situations
    where the final axis you want to visualize is *not* a function of some evaluation
    grid. This occurs quite naturally when you simply want to draw familiar geometric
    shapes but also extends to more complicated situations in mathematics.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，本章中的大多数例子中，曲面是由常规评估网格或格点的坐标直接定义的，但也有一些情况，你希望可视化的最终轴*不是*某个评估网格的函数。这种情况在你只是想绘制常见几何形状时非常自然，但也扩展到更复杂的数学情境。
- en: In this section, you’ll plot from a collection of parametric equations, which
    together define the shape or surface of interest. This section will assume you’re
    familiar with the fundamental trigonometric functions *sine* and *cosine*, as
    well as the conversion of angles from *degrees* to *radians*, since by default
    R deals exclusively with the latter. That said, I’ll walk you through the relevant
    calculations and R code as needed.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，你将从一组参数方程中绘图，这些方程共同定义了感兴趣的形状或曲面。本节假设你熟悉基本的三角函数*正弦*和*余弦*，以及角度从*度*到*弧度*的转换，因为默认情况下，R只处理后者。话虽如此，我会在需要时引导你完成相关的计算和R代码。
- en: '***26.4.1 Simple Loci***'
  id: totrans-268
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***26.4.1 简单轨迹***'
- en: Using mathematical terminology, a *locus* (plural *loci*) is a set of points
    that satisfy, and are defined by, a particular set of parametric equations. In
    R, these equations govern how individual numeric elements of the resulting objects
    are calculated, which you can then easily plot using familiar functions.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 使用数学术语，*轨迹*（复数形式为*loci*）是满足并由特定参数方程定义的一组点。在R中，这些方程决定了结果对象中每个数字元素的计算方式，随后你可以使用熟悉的函数轻松地绘制它们。
- en: '**NOTE**'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*When discussing loci, any reference to 2D or 3D space refers to* Euclidian
    space*, which is the standard way in which you’ve dealt with coordinates in the*
    x*-,* y*-, and* z*-axes so far.*'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: '*在讨论轨迹时，任何关于二维或三维空间的引用都指的是*欧几里得空间*，这就是你迄今为止处理* x*、* y* 和* z*轴坐标的标准方式。*'
- en: '![image](../images/f26-15.jpg)'
  id: totrans-272
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f26-15.jpg)'
- en: '*Figure 26-15: Three screenshots of the trivariate kernel density estimate
    of the earthquake observations, taken from varying angles and with different levels
    of zoom. Increasing levels of denseness are reflected by isosurfaces of darkening
    yellow-to-red color and increased opacity.*'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 26-15：地震观测的三维核密度估计的三个截图，分别从不同角度和不同的缩放级别拍摄。密度增加的层次通过等值面的黄色到红色变暗颜色和更高的透明度反映出来。*'
- en: '**2D Circle**'
  id: totrans-274
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**二维圆**'
- en: 'Let’s start with a simple example. One of the most immediately recognizable
    shapes defined in this way is a 2D circle. To find any point on a circle, you
    need to know the circle’s center and its radius, and you need to provide a specific
    angle at which to look (typically taken to be relative to a perfectly horizontal
    line). Any planar 2D point (*x*,*y*) that lies on a circle can be expressed with
    the following equations if you take the center to be at the coordinate (*a*, *b*),
    with a fixed radius of *r* > 0 and looking at the angle *θ*:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从一个简单的例子开始。通过这种方式定义的最易识别的形状之一是二维圆。要找到圆上的任何一点，您需要知道圆心位置及其半径，并提供一个特定的角度（通常相对于水平线）。位于圆上的任何平面二维点
    (*x*,*y*) 都可以通过以下方程表示，如果您将圆心设为坐标 (*a*, *b*)，半径为 *r* > 0，并且查看角度 *θ*：
- en: '![image](../images/e26-1.jpg)'
  id: totrans-276
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/e26-1.jpg)'
- en: If you’re working in degrees, then technically 0 ≤ *θ* < 360; to convert to
    radians, you must multiply by *π*/180 such that 0 ≤ *θ* < 2*π*.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您使用的是度数，则严格来说 0 ≤ *θ* < 360；要转换为弧度，必须乘以 *π*/180，使得 0 ≤ *θ* < 2*π*。
- en: 'To draw a circle based on the equations in (26.1), first decide on a radius,
    then decide on a center point, and then generate the corresponding values of *x*
    and *y*. Consider the following code:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 要根据（26.1）中的方程绘制圆，首先确定半径，然后确定圆心位置，再生成相应的 *x* 和 *y* 值。请参见以下代码：
- en: '[PRE51]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: The circle will have a radius of 3 and be centered at (1,−4.4). Given the sequence
    defined as `angle`, note the plot will place a point at each integer angle from
    0 to 360 degrees—I’ve allowed the upper limit to be equal to exactly 360 to fully
    complete the rotation—after which you convert to radians (with multiplication
    by *π*/180) in order to use the built-in R functions `cos` and `sin`. The geometric
    value of pi (*π* = 3.1415...) is held within the ready-to-use R object `pi` (see
    the help file `?Constants`). The last three lines execute the plot, shown in [Figure
    26-16](ch26.xhtml#ch26fig16).
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 该圆的半径为 3，中心在 (1,−4.4)。给定定义为 `angle` 的序列，注意该图会在从 0 到 360 度的每个整数角度上放置一个点——我已将上限设置为恰好
    360，以完整地完成旋转——然后将其转换为弧度（通过 *π*/180 的乘法），以便使用内置的 R 函数 `cos` 和 `sin`。圆周率的几何值 (*π*
    = 3.1415...) 存储在 R 中可直接使用的对象 `pi` 中（请参见帮助文件 `?Constants`）。最后三行执行绘图，结果如图 [26-16](ch26.xhtml#ch26fig16)
    所示。
- en: '![image](../images/f26-16.jpg)'
  id: totrans-281
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f26-16.jpg)'
- en: '*Figure 26-16: Drawing a 2D circle in R with center (1,*−*4.4) and radius 3,
    following the relevant parametric equations of the locus*'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 26-16：在 R 中绘制中心为 (1,*−*4.4) 且半径为 3 的二维圆，遵循相关的参量方程*'
- en: The key takeaway here is that *y* isn’t calculated as a direct result of *x*
    in the same way as you might obtain a fine, evenly spaced increasing sequence
    in *x* and then evaluate *y* when plotting, for example, a linear regression model.
    Rather, the equations in (26.1) jointly define the rules of the locus in the 2D
    space.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的关键要点是，*y* 不是直接由 *x* 计算得出的，就像在绘制例如线性回归模型时，您可能会获得一个均匀间隔递增的 *x* 序列，然后计算出相应的
    *y*。相反，方程（26.1）联合定义了二维空间中轨迹的规则。
- en: '**3D Cylinder**'
  id: totrans-284
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**3D 圆柱体**'
- en: Plotting surfaces with three dimensions is done in much the same way, only now
    your equations set up the rules for all satisfying points in the *x*-, *y*-, and
    *z*-axes.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 绘制三维曲面的方法基本相同，只是现在您的方程式定义了在 *x*、*y* 和 *z* 轴上所有满足条件的点的规则。
- en: 'For example, points lying on a hollow cylinder can be defined by the following
    equations:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，位于空心圆柱上的点可以通过以下方程定义：
- en: '![image](../images/e26-2.jpg)'
  id: totrans-287
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/e26-2.jpg)'
- en: 'To actually plot points that satisfy these rules, you need to decide on a fixed
    radius *r*, recognize that 0 ≤ *θ* < 360 (in degrees), and define a fixed maximum
    height *h* so that you can ensure 0 ≤ *z* ≤ *h*. With that information, to generate
    vectors for *x*, *y*, and *z*, you need to first set up numeric sequences spanning
    the possible values of *θ* and *z*. Consider the following code:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 要实际绘制满足这些规则的点，您需要决定一个固定的半径 *r*，并认识到 0 ≤ *θ* < 360（以度为单位），同时定义一个固定的最大高度 *h*，以确保
    0 ≤ *z* ≤ *h*。根据这些信息，为了生成 *x*、*y* 和 *z* 的向量，您需要首先设置数值序列，涵盖 *θ* 和 *z* 的可能值。请参见以下代码：
- en: '[PRE52]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: These lines show a radius of 3 set as `r` and a maximum height of 10 as `h`.
    The sequence in *z* is set up as the 11 integer values from 0 to 10 in `zseq`—this
    will allow you to place points on the locus at each of these defined *z* values.
    The sequence for *θ* is set up as 0 ≤ *θ* < 2*π* in `theta` (note the necessary
    conversion to radians). Then, you need all unique combinations of these parameter
    values to get all relevant (*x*, *y*, *z*) coordinates for plotting. You know
    how to do that from [Section 25.3.1](ch25.xhtml#ch25lev2sec251), using `expand.grid`.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 这些行展示了半径设置为 3（`r`）和最大高度设置为 10（`h`）。*z* 的序列设置为 `zseq` 中从 0 到 10 的 11 个整数值——这将允许你在每个定义的
    *z* 值上放置点。*θ* 的序列设置为 0 ≤ *θ* < 2*π*（在 `theta` 中，注意需要转换为弧度）。接下来，你需要这些参数值的所有唯一组合，以获取绘图所需的所有相关
    (*x*, *y*, *z*) 坐标。你可以通过 [第 25.3.1 节](ch25.xhtml#ch25lev2sec251) 使用 `expand.grid`
    来做到这一点。
- en: '[PRE53]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: Calling `nrow` on the result shows that you now have 11 × 361 = 3971 unique
    height-angle values. Now you’re able to generate the values for *x*, *y*, and
    *z* as defined by (26.2). You could use a `for` loop ([Section 10.2.1](ch10.xhtml#ch10lev2sec92)),
    cycling through each row of `ztheta`, but a neater way would be to use implicit
    looping in `apply` (refer to [Section 10.2.3](ch10.xhtml#ch10lev2sec94) for details).
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 调用 `nrow` 函数查看结果，表明你现在有 11 × 361 = 3971 个独特的高度-角度值。现在，你可以根据公式 (26.2) 生成 *x*、*y*
    和 *z* 的值。你可以使用 `for` 循环（见 [第 10.2.1 节](ch10.xhtml#ch10lev2sec92)），逐行遍历 `ztheta`，但更简洁的方式是使用
    `apply` 中的隐式循环（详细内容参见 [第 10.2.3 节](ch10.xhtml#ch10lev2sec94)）。
- en: '[PRE54]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: Note that disposable functions (see [Section 11.3.2](ch11.xhtml#ch11lev2sec104))
    are used to operate on the two-element height-angle (in that order) vectors that
    make up each row of `ztheta`.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，使用了可丢弃函数（参见 [第 11.3.2 节](ch11.xhtml#ch11lev2sec104)），这些函数用于对 `ztheta` 每一行组成的两个元素的高度-角度向量进行操作。
- en: You can use `persp3d` from `rgl` to plot this kind of parametrically defined
    surface, but in a slightly different way than in earlier sections of this chapter.
    The calculated `x`, `y`, and `z` coordinates must now *all* be supplied as identically
    sized, appropriately arranged matrices. This is because there’s no longer an evenly
    spaced evaluation grid in the *x*- and *y*-coordinate directions—along with the
    *z* values, the *x* and *y* values have all been defined through an application
    of (26.2). In these types of plots, you effectively have a *latent* evaluation
    grid defined by the unique combinations of parameter values (height and angle
    in this case).
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用 `rgl` 中的 `persp3d` 来绘制这种参数化定义的曲面，但方式与本章前面的部分有所不同。现在，计算出的 *x*、*y* 和 *z*
    坐标必须作为大小相同、适当排列的矩阵一起提供。这是因为 *x* 和 *y* 坐标方向上不再有均匀间隔的评估网格——连同 *z* 值，*x* 和 *y* 值已经通过应用
    (26.2) 进行定义。在这种类型的图中，你实际上拥有一个由参数值（在此为高度和角度）的独特组合定义的 *潜在* 评估网格。
- en: The matrices in all of the *x*-, *y*-, and *z*-coordinates are given by the
    three 11 × 361 matrices filled with `x`, `y`, and `z` in the typical column-wise
    fashion.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 所有的 *x*、*y* 和 *z* 坐标矩阵由三个 11 × 361 的矩阵组成，这些矩阵按典型的列优先方式填充了 `x`、`y` 和 `z` 值。
- en: '[PRE55]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'At this point, it’s worth introducing the built-in `outer` function, which
    takes a sequence of values in two variables and produces all unique combinations
    of values, computes the result at each combination, and then returns the results
    as a matrix—doing the three tasks just done by `expand.grid`, `apply`, and `matrix`
    in one go. With this approach, you could create `xm`, `ym`, and `zm` indentically
    by simply calling the following:'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，值得介绍内置的 `outer` 函数，它接受两个变量的值序列，生成所有独特的值组合，在每个组合上计算结果，并将结果返回为矩阵——一次性完成了 `expand.grid`、`apply`
    和 `matrix` 三个步骤。使用这种方法，你可以通过简单地调用以下代码来创建相同的 `xm`、`ym` 和 `zm`：
- en: '[PRE56]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: The only difference here is that the anonymous function provided as the third
    argument must be explicitly defined in terms of two separate arguments that represent
    the values of the necessary height and angle parameters.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 唯一的区别是，作为第三个参数传递的匿名函数必须明确地定义为两个单独的参数，这些参数表示必要的高度和角度参数的值。
- en: However you obtain `xm`, `ym`, and `zm`, it’s now just a matter of calling `persp3d`
    with these coordinate matrices. Make an additional call to `points3d` to emphasize
    the precise evaluation points that are returned in those matrices. The result
    of the next two lines is shown on the left of [Figure 26-17](ch26.xhtml#ch26fig17).
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 无论你如何获得 `xm`、`ym` 和 `zm`，现在只需要调用 `persp3d` 并传入这些坐标矩阵。再调用一次 `points3d`，以强调这些矩阵中返回的精确评估点。接下来的两行代码的结果显示在
    [图 26-17](ch26.xhtml#ch26fig17) 的左侧。
- en: '[PRE57]'
  id: totrans-302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: '![image](../images/f26-17.jpg)'
  id: totrans-303
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f26-17.jpg)'
- en: '*Figure 26-17: Drawing a cylinder and a cone using* `persp3d`*, with matrix
    arguments in all three coordinate directions. The loci are defined by the corresponding
    parametric equations. The black rings visible on the cylinder represent the actual
    evaluation points stored in the required matrices* `xm`, `ym`*, and* `zm`.'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: '*图26-17：使用 `persp3d` 绘制圆柱体和圆锥体，矩阵参数在三个坐标方向上。轨迹由对应的参数方程定义。圆柱体上可见的黑色环代表存储在所需矩阵`xm`、`ym`和`zm`中的实际评估点。*'
- en: '**3D Cone**'
  id: totrans-305
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**3D 圆锥体**'
- en: 'This next example will show that once you understand the procedure involved
    with setting up the *x*-, *y*-, and *z*-coordinate matrices, you can display virtually
    any 3D shape or surface with ease. Taking *r*, *h*, and *θ* to be the base radius,
    maximum height, and angle, respectively, a cone follows these equations:'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个示例将展示，一旦你理解了设置 *x*、*y* 和 *z* 坐标矩阵的过程，你就可以轻松显示几乎任何 3D 形状或表面。将 *r*、*h* 和 *θ*
    分别视为底面半径、最大高度和角度，一个圆锥体遵循以下方程：
- en: '![image](../images/e26-3.jpg)'
  id: totrans-307
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/e26-3.jpg)'
- en: Using the same objects `r`, `h`, `zseq`, and `theta` from earlier, the following
    code alters the disposable functions in `outer` to reflect (26.3). The right of
    [Figure 26-17](ch26.xhtml#ch26fig17) shows the result.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 使用之前的相同对象 `r`、`h`、`zseq` 和 `theta`，以下代码会修改 `outer` 中的可用函数，以反映（26.3）。[图26-17](ch26.xhtml#ch26fig17)右侧显示了结果。
- en: '[PRE58]'
  id: totrans-309
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: '***26.4.2 Mathematical Abstractions***'
  id: totrans-310
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***26.4.2 数学抽象***'
- en: Many areas of mathematics, applied mathematical modeling, and statistics utilize
    high-dimensional shapes. To round off this chapter, and indeed the book, let’s
    employ `rgl` to take a look at a couple of famous abstractions using skills from
    [Section 26.4.1](ch26.xhtml#ch26lev2sec271).
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 数学的许多领域、应用数学建模和统计学都利用高维形状。为了总结这一章，实际上也是整本书的总结，让我们使用`rgl`来通过[第26.4.1节](ch26.xhtml#ch26lev2sec271)中的技能，观察一些著名的抽象概念。
- en: '**Möbius Strip**'
  id: totrans-312
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**莫比乌斯带**'
- en: A classic example is the *Möbius strip*—a continuous surface that has only one
    side and one edge. It can be expressed using the parametric equations
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 一个经典的例子是 *莫比乌斯带* ——一个只有一个面和一条边的连续表面。它可以通过参数方程表示：
- en: '![image](../images/e26-4.jpg)'
  id: totrans-314
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/e26-4.jpg)'
- en: where
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 其中
- en: '![image](../images/f0726-01.jpg)'
  id: totrans-316
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f0726-01.jpg)'
- en: with −1 ≤ *v* ≤ 1 and 0 ≤ *θ* < 2*π* (assuming angles measured in radians).
    The parameter *v* controls the position of the point along the width of the strip,
    and *θ* controls the rotation angle.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 其中 −1 ≤ *v* ≤ 1 且 0 ≤ *θ* < 2*π*（假设角度以弧度为单位）。参数 *v* 控制点在带宽上的位置，*θ* 控制旋转角度。
- en: 'You can draw the strip in the same way as the cylinder and cone from earlier.
    First, set up the sequences over the possible values of *v* and *θ*, done here
    at a resolution of 200 each:'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以像之前绘制圆柱体和圆锥体一样绘制莫比乌斯带。首先，设置 *v* 和 *θ* 的可能值序列，这里设置的分辨率为 200：
- en: '[PRE59]'
  id: totrans-319
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: Next, use `outer` to obtain the 200 × 200 matrices in each of the *x*-, *y*-,
    and *z*-coordinates as per (26.4).
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，使用 `outer` 获取每个 *x*、*y* 和 *z* 坐标的 200 × 200 矩阵，如（26.4）所示。
- en: '[PRE60]'
  id: totrans-321
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'Then, a quick call to `plot3d` from the `rgl` package will show you the 40,000
    locations, based on the defined `vseq` and `theta` sequences, that lie on the
    Möbius strip. The result of the following line is shown on the left of [Figure
    26-18](ch26.xhtml#ch26fig18):'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，快速调用 `rgl` 包中的 `plot3d` 函数，可以展示基于定义的 `vseq` 和 `theta` 序列的 40,000 个点，这些点位于莫比乌斯带上。以下代码的结果显示在[图26-18](ch26.xhtml#ch26fig18)的左侧：
- en: '[PRE61]'
  id: totrans-323
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'Let’s display the strip as a continuous surface using `persp3d` to fully appreciate
    the one-side/one-edge phenomenon. The image on the right of [Figure 26-18](ch26.xhtml#ch26fig18)
    shows the result of the following code:'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用 `persp3d` 将莫比乌斯带显示为一个连续表面，以充分理解其一面一边的现象。[图26-18](ch26.xhtml#ch26fig18)右侧显示了以下代码的结果：
- en: '[PRE62]'
  id: totrans-325
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: Note the use of `axes` to suppress the default box and axes and the use of empty
    strings to remove the default axis titles denoting `xm`, `ym`, and `zm`.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意使用 `axes` 来抑制默认的框和坐标轴，并使用空字符串来移除默认的坐标轴标题，表示 `xm`、`ym` 和 `zm`。
- en: '![image](../images/f26-18.jpg)'
  id: totrans-327
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f26-18.jpg)'
- en: '*Figure 26-18: Drawing a Möbius strip in R. Left: Specifically calculated points
    on the strip, visualized with* `plot3d`*. Right: Surface formed by joining up
    the points on the left via* `persp3d`.'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: '*图26-18：在 R 中绘制莫比乌斯带。左：在带上的具体计算点，通过 `plot3d` 可视化。右：通过 `persp3d` 连接左侧的点形成的表面。*'
- en: 'You could also use color in a more interesting way to emphasize the wraparound
    nature of a Möbius strip. Taking inspiration from a similar collection of colors
    defined in [Section 25.1.3](ch25.xhtml#ch25lev2sec244), create the following custom
    palette:'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以以更有趣的方式使用颜色来强调莫比乌斯环的环绕特性。受[第25.1.3节](ch25.xhtml#ch25lev2sec244)中类似颜色集的启发，创建以下自定义调色板：
- en: '[PRE63]'
  id: totrans-330
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: This palette has been specifically generated to go from a dark red to white
    to blue but also to wrap around from the blue back to white and the dark red.
    This is needed for the way in which colors from `patriot.colors` will be assigned,
    in a point-wise fashion, to the plotted strip.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 该调色板特别生成了从深红色到白色再到蓝色的过渡，并且还会从蓝色回到白色和深红色，形成环绕效果。这是因为`patriot.colors`中的颜色将按点逐一分配给绘制的条带。
- en: 'The color vector for plotting the surface will need to be of length 200² =
    40,000 given the preset value of `res` (governing the length of both `vseq` and
    `theta`). To fill the vector, execute the following:'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 为了绘制表面，颜色向量的长度需要为200² = 40,000，考虑到预设的`res`值（决定了`vseq`和`theta`的长度）。为了填充该向量，执行以下操作：
- en: '[PRE64]'
  id: totrans-333
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: The first line generates exactly 399 colors from `patriot.colors`, and the second
    sets up a vector of the required length, which will store the assigned colors
    (`stripcols`). The `for` loop ensures that at the first iteration, the elements
    `1` through `200` in `stripcols` will be assigned colors `1` through `200` from
    `patcols`; at the second iteration, the elements `201` through `400` will be assigned
    colors `2` through `201` from `patcols`, and so on. This gives the colors their
    wraparound appearance.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 第一行生成了来自`patriot.colors`的399种颜色，第二行设置了所需长度的向量，用于存储分配的颜色（`stripcols`）。`for`循环确保在第一次迭代时，将`stripcols`中第1到200个元素分配给`patcols`中的第1到200种颜色；在第二次迭代时，将`stripcols`中第201到400个元素分配给`patcols`中的第2到201种颜色，以此类推。这样就实现了颜色的环绕效果。
- en: 'To properly understand the `for` loop, first look at the order of the arguments
    as supplied to the calls to `outer`. Having `vseq` first and `theta` second implies
    that each column of 200 in the resulting matrices corresponds to a span from −1
    to 1 in *v*, which refers to moving from one end of one of the lines of points
    to the other, that is, along the width of the strip. By using an index variable
    `i` from `0` to `199` (inclusive), the loop assigns each consecutive block of
    200 elements in `stripcols` (increased at every iteration via `+res*i`) the 200
    elements from the 399 `patcols` by collectively moving forward exactly one element
    (increased at every iteration via `+i`). What that does is change the color from
    red to white to blue in the plotted lines of points in the early stages of the
    loop, but as it progresses, working its way around the strip, the specific span
    of that palette is incrementally shifted until it goes from blue to white to red
    as you rotate around to the last few plotted lines of points. The effect is a
    smooth change in color as you alter both *v* and *θ*. You can see the result of
    the following in [Figure 26-19](ch26.xhtml#ch26fig19):'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 为了正确理解`for`循环，首先查看传递给`outer`函数的参数顺序。将`vseq`放在第一位，`theta`放在第二位，意味着结果矩阵的每一列（长度为200）对应于在*v*的范围从−1到1的跨度，这指的是从某一行点的一端移动到另一端，也就是沿着条带的宽度。通过使用一个从`0`到`199`（包括`199`）的索引变量`i`，循环将`stripcols`中每一个连续的200个元素（在每次迭代中通过`+res*i`增加）分配给399个`patcols`中的200个元素，方法是每次迭代时前进一个元素（通过`+i`增加）。这样做的结果是，循环早期绘制的点线条中颜色从红色变为白色再变为蓝色，但随着循环的进行，颜色逐渐环绕条带，直到在最后几行绘制的点线条中颜色从蓝色变为白色再变为红色。其效果是随着*v*和*θ*的变化，颜色平滑地过渡。你可以在[图26-19](ch26.xhtml#ch26fig19)中看到以下结果：
- en: '[PRE65]'
  id: totrans-336
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: '![image](../images/f26-19.jpg)'
  id: totrans-337
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f26-19.jpg)'
- en: '*Figure 26-19: A patriotic Möbius strip, created with the careful construction
    of an appropriate color vector.*'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: '*图26-19：一条爱国的莫比乌斯环，通过精心构建合适的颜色向量创建。*'
- en: The plot can still be rotated and zoomed as usual on your computer. You can
    experiment with `aspect` to alter the specific axis aspect ratios purely to enhance
    the appearance of the final product; here I’ve widened both the *x*- and *y*-axes
    relative to the *z*-axis.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 该绘图仍然可以像往常一样在你的电脑上进行旋转和缩放。你可以尝试调整`aspect`，修改特定轴的长宽比，以增强最终效果；在这里，我已将*x*轴和*y*轴相对于*z*轴进行了拉宽。
- en: '**Torus**'
  id: totrans-340
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**环面**'
- en: Another shape often expressed in 3D space is a *ring torus* (plural *tori*).
    This is the classic topological “shape with one hole” and resembles, for lack
    of a better word, a doughnut. The mathematical properties of tori are quite useful
    in many fields.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个常见的三维空间形状是*环形圆环*（复数形式为*tori*）。这是经典的拓扑学“有一个孔的形状”，像是一个更通俗的说法——甜甜圈。圆环的数学性质在许多领域都非常有用。
- en: 'Parameterization of a torus may be achieved with these equations:'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 圆环的参数化可以通过以下方程实现：
- en: '![image](../images/e26-5.jpg)'
  id: totrans-343
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/e26-5.jpg)'
- en: where
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 在哪里
- en: '*F*(*θ*[2]; *α*, *β*) = *β* + *α* cos *θ*[2]'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: '*F*(*θ*[2]; *α*, *β*) = *β* + *α* cos *θ*[2]'
- en: with 0 ≤ *θ*[1] < 2*π* and the same for *θ*[2] (assuming angles measured in
    radians). The fixed values *α* and *β* control the radius of the “tube” (in other
    words, the relative thickness of the doughnut) and the overall size of the torus
    in terms of distance from the middle of the hole to the middle of the tube. Provided
    *α* < *β*, the equations in (26.5) give you the classic ring torus shape; you
    can get different kinds of tori by relaxing that condition on *α* and *β*.
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 其中 0 ≤ *θ*[1] < 2*π* 且 *θ*[2] 同理（假设角度以弧度为单位）。固定值*α*和*β*控制“管道”的半径（换句话说，就是甜甜圈的相对厚度）以及圆环的整体大小，即从孔的中间到管道中间的距离。假设*α*
    < *β*，公式（26.5）给你提供了经典的环形圆环形状；你可以通过放宽*α*和*β*的条件得到不同类型的圆环。
- en: 'Setting *α* = 1 and *β* = 2, the following code uses the `theta` object defined
    earlier for the Möbius strip to compute the matrices in the *x*-, *y*-, and *z-*coordinate
    directions as per (26.5):'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 将*α* = 1 和 *β* = 2，以下代码使用先前定义的`theta`对象计算Möbius带在 *x*、*y* 和 *z* 坐标方向上的矩阵，如公式（26.5）所示：
- en: '[PRE66]'
  id: totrans-348
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: Refer to [Section 26.4.1](ch26.xhtml#ch26lev2sec271) to remind yourself of the
    usage of `outer` if you need to do so.
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 如果需要，参考[第26.4.1节](ch26.xhtml#ch26lev2sec271)来提醒自己如何使用`outer`。
- en: 'Then, this line reveals the calculated points of the torus:'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，这一行展示了圆环的计算点：
- en: '[PRE67]'
  id: totrans-351
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'And this gives you the final appearance of the continuous surface:'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，你就得到了连续表面的最终外观：
- en: '[PRE68]'
  id: totrans-353
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: '[Figure 26-20](ch26.xhtml#ch26fig20) shows the results of both.'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 26-20](ch26.xhtml#ch26fig20)展示了两者的结果。'
- en: '![image](../images/f26-20.jpg)'
  id: totrans-355
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f26-20.jpg)'
- en: '*Figure 26-20: Drawing a ring torus in R. Left: Specifically calculated points
    on the surface, visualized with* `plot3d`*. Right: Shape formed by joining up
    the points on the left using* `persp3d`.'
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 26-20：在 R 中绘制圆环。左图：在表面上特别计算的点，通过* `plot3d`* 可视化。右图：通过使用* `persp3d`* 将左侧的点连接起来形成的形状。'
- en: Earlier, you used a specifically constructed color vector to color the Möbius
    strip, but you can assign color on any such surface by identifying the specific
    points in the defined matrices that you want to exert control over. Since it’s
    the last example in the book, let’s have a little fun with the current mathematical
    doughnut to illustrate this point-wise indexing.
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 之前，你使用了一个特意构建的颜色向量来给Möbius带着色，但你也可以通过识别定义矩阵中你想要控制的特定点，给任何这样的表面赋色。由于这是书中的最后一个例子，让我们在当前的数学“甜甜圈”上稍微玩一下，通过这个点状索引来说明这一点。
- en: First, the dough needs to look authentic. The following line sets up the vector
    of length 200² = 40,000 to store the colors you’re going to use. Initially, every
    element is set as a dough-colored tan.
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，甜甜圈需要看起来真实。以下代码行设置了一个长度为200² = 40,000的向量，用来存储你将要使用的颜色。最初，每个元素都设置为甜甜圈的颜色——棕黄色。
- en: '[PRE69]'
  id: totrans-359
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'Next, add some icing. If you look at the distribution of the points, displayed
    in the plot on the left of [Figure 26-20](ch26.xhtml#ch26fig20), you can see that
    the “top half” of plotted locations on the surface of this torus are at *z*-coordinates
    greater than zero. With this, you can overwrite the relevant elements of `donutcols`
    with the following line:'
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，加点装饰。如果你查看点的分布（如[图 26-20](ch26.xhtml#ch26fig20)左侧的图所示），你可以看到这个圆环表面上“上半部分”的绘制位置的*z*坐标大于零。基于这一点，你可以使用以下一行代码覆盖`donutcols`中相关的元素：
- en: '[PRE70]'
  id: totrans-361
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'Lastly, any premium doughnut should have sprinkles. You need a mechanism to
    identify random locations on the top half of the surface and color them appropriately.
    To do this, you can use the built-in `sample` function to randomly select a subset
    of elements from an existing vector. If you have the integers 1 through 10, for
    example, and you want to randomly select four, you can execute the following:'
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，任何优质的甜甜圈都应该撒上糖粒。你需要一种机制来识别表面上半部分的随机位置，并为其着色。为此，你可以使用内置的`sample`函数从现有向量中随机选择一部分元素。例如，如果你有整数1到10，并且想要随机选择四个，可以执行以下操作：
- en: '[PRE71]'
  id: totrans-363
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: The argument `x` takes the vector from which to select a sample, and `size`
    takes the number of elements you want to draw from that vector. Note that you’re
    likely to get a different set of four random numbers when executing this line.
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 参数`x`接受一个向量，用于从中选择样本，`size`则是你希望从该向量中抽取的元素数量。注意，当执行这一行代码时，你很可能会得到一组不同的四个随机数。
- en: 'With that knowledge, you can use this code to make sprinkles:'
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这些知识，你可以使用以下代码制作撒花：
- en: '[PRE72]'
  id: totrans-366
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: This sets up five distinct sprinkle colors; then randomly selects 300 locations,
    strictly from locations on the iced surface area; and finally assigns to them
    the five colors. The nature of vector recycling means there will be exactly 60
    of each color sprinkle, randomly placed on the top half of the torus. You can
    add more sprinkles by increasing `size`, though given the number of colors, you
    should ensure `size` remains evenly divisible by 5.
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码设置了五种不同的撒花颜色；然后从冰面区域的300个位置中随机选择位置；最后将五种颜色分配给这些位置。由于向量回收的特性，每种颜色的撒花数量将精确为60，随机分布在环面的上半部分。你可以通过增加`size`来增加撒花数量，不过鉴于颜色数量，你应该确保`size`能被5整除。
- en: 'The following call completes the visual treat, shown in [Figure 26-21](ch26.xhtml#ch26fig21):'
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 以下调用完成了视觉效果，如[图 26-21](ch26.xhtml#ch26fig21)所示：
- en: '[PRE73]'
  id: totrans-369
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: '![image](../images/f26-21.jpg)'
  id: totrans-370
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f26-21.jpg)'
- en: '*Figure 26-21: A delicious mathematical doughnut. Coloring of the torus surface
    is achieved by identification of corresponding positions in a color vector and
    subsequent element replacement.*'
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 26-21：美味的数学甜甜圈。环面表面的着色是通过识别颜色向量中对应位置并替换元素来实现的。*'
- en: You can find a more serious (and technical) visualization of a ring torus, in
    its role as a convenient computational structure used for generating specially
    defined high-dimensional random normal variates, in Davies and Bryant ([2013](ref.xhtml#ref15)).
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在Davies和Bryant（[2013](ref.xhtml#ref15)）中找到一个更为严谨（且技术性更强）的环面可视化，环面作为一种便捷的计算结构，用于生成特别定义的高维随机正态变量。
- en: '**Exercise 26.3**'
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: '**练习 26.3**'
- en: 'Ensure you have the functionality of the `mvtnorm`, `rgl`, `misc3d`, and `ks`
    packages available in your current R session. By specifying different *covariance
    matrices*, you can control how the different components of a multivariate normal
    random variable relate to one another, which affects the appearance of the distribution
    itself. In the standard trivariate normal density, for example, the three elements
    (*x*, *y*, *z*) are independent of one another. Executing the following code will
    generate 1000 observations from a nonstandard trivariate normal distribution where
    the three elements are related to one another in a specific way:'
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 确保在当前R会话中可以使用`mvtnorm`、`rgl`、`misc3d`和`ks`包的功能。通过指定不同的*协方差矩阵*，你可以控制多元正态随机变量的各个成分之间的关系，从而影响分布本身的外观。例如，在标准的三元正态密度中，三个元素（*x*、*y*、*z*）彼此是独立的。执行以下代码将生成1000个观测值，这些值来自一个非标准的三元正态分布，其中三个元素按特定方式相互关联：
- en: R> covmat <- matrix(c(1,0.8,0.4,0.8,1,0.6,0.4,0.6,1),3,3)
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: R> covmat <- matrix(c(1,0.8,0.4,0.8,1,0.6,0.4,0.6,1),3,3)
- en: R> rand3d.norm <- rmvnorm(1000,mean=c(0,0,0),sigma=covmat)
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: R> rand3d.norm <- rmvnorm(1000,mean=c(0,0,0),sigma=covmat)
- en: Note that the covariance matrix `covmat` is supplied to the optional `sigma`
    and that the mean of this collection of points remains centered at (0,0,0).
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，协方差矩阵`covmat`作为可选参数传递给`sigma`，并且这些点的均值仍然保持在(0,0,0)的中心位置。
- en: Plot the generated data as an interactive 3D point cloud, with simple axis titles
    `"x"`, `"y"`, and `"z"`. You should see how the points form an elliptical shape,
    in contrast to the spherical shape in the standard trivariate normal in [Figures
    26-11](ch26.xhtml#ch26fig11) and [26-12](ch26.xhtml#ch26fig12). Keep the plot
    open.
  id: totrans-378
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将生成的数据绘制为交互式3D点云，轴标签为`"x"`、`"y"`和`"z"`。你应该能够看到点云形成一个椭圆形，这与标准三元正态分布中的球形分布（见[图
    26-11](ch26.xhtml#ch26fig11)和[26-12](ch26.xhtml#ch26fig12)）形成对比。保持图形窗口开启。
- en: Using a 50 × 50 × 50 evaluation lattice between −3 and 3 in each of the three
    axes, calculate this particular trivariate normal density function using `dmvnorm`
    and store it as an appropriately sized array. Note that you’ll also need to set
    `sigma=covmat` in any use of `dmvnorm`. Calculate the maximum value of the density
    and use this to superimpose upon the point cloud isosurfaces at three specific
    *α* levels—0.1, 0.5, and 0.9\. Color the three isosurfaces `"yellow"`, `"seagreen4"`,
    and `"navyblue"` and set them at 20 percent, 40 percent, and 60 percent opacity,
    respectively.
  id: totrans-379
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用在每个轴上从−3到3的50 × 50 × 50评估网格，使用`dmvnorm`计算此三变量正态密度函数并将其存储为适当大小的数组。请注意，你还需要在使用`dmvnorm`时设置`σ=covmat`。计算密度的最大值，并利用这个最大值在点云等值面上叠加三个特定的*α*水平——0.1、0.5和0.9。将这三个等值面分别着色为`"yellow"`、`"seagreen4"`和`"navyblue"`，并设置它们的透明度分别为20%、40%和60%。
- en: Now, use `ks` functionality to calculate a 3D kernel estimate of the density
    based on the 1000 generated observations. Ensure that the returned object contains
    the vector of 99 sensible contour levels. Replot the point cloud of (a) in a new
    RGL device and then make two separate calls to `contour3d` as follows.
  id: totrans-380
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，使用`ks`功能基于1000个生成的观察数据计算3D核密度估计。确保返回的对象包含99个合理的等值层级向量。重新绘制（a）部分的点云图，在一个新的RGL设备中显示，然后按照以下方式调用`contour3d`两次。
- en: The first should superimpose the theoretical contour at an *α* level of 0.5
    from (b) only. Use the same color and opacity as you did in (b).
  id: totrans-381
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第一个应该仅叠加（b）部分的*α*水平为0.5的理论等值面。使用和（b）中相同的颜色和透明度。
- en: The second should draw the isosurface at the 50th percentile as estimated from
    the point-specific KDE surface. Make it red and reduce the opacity to 20 percent.
  id: totrans-382
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第二个应该绘制从点特定KDE曲面估算的50百分位的等值面。将其设置为红色，并将透明度降低至20%。
- en: Here are my results from (b) on the left and (c) on the right. Note that the
    appearance of your KDE isosurface will vary because of the random generation of
    the 1000 data points, which dictate the final estimate.
  id: totrans-383
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这是我在（b）部分的结果，左侧是（b）的结果，右侧是（c）的结果。请注意，由于1000个数据点是随机生成的，KDE等值面（isosurface）的外观会有所不同，这些数据点决定了最终的估计结果。
- en: '![image](../images/f0733-01.jpg)'
  id: totrans-384
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f0733-01.jpg)'
- en: The `MASS` package has another data set you’ve not yet met. The `Boston` data
    frame object contains a number of descriptive observations concerning house prices
    in suburbs of Boston, Massachusetts, in the 1970s ([Harrison and Rubinfeld, 1978](ref.xhtml#ref31)).
    Load the `MASS` package and inspect the help file `?Boston` to learn about the
    present variables.
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: '`MASS`包中有另一个数据集你还没有接触过。`Boston`数据框对象包含了关于1970年代美国马萨诸塞州波士顿郊区房价的许多描述性观察数据（[Harrison
    和 Rubinfeld, 1978](ref.xhtml#ref31)）。加载`MASS`包并查看帮助文件`?Boston`，了解当前的变量。'
- en: 'Focus on the variables for average number of rooms, percentage of lower-socioeconomic-status
    dwellings, and median value—you’re going to experiment with the visualization
    of a 3D scatter-plot as follows:'
  id: totrans-386
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 关注变量中平均房间数、低社会经济地位住房的百分比和中位房价——你将进行如下的3D散点图可视化实验：
- en: Use `rgl` functionality to plot the three variables, with rooms, status, and
    value on the *x*-, *y*-, and *z*-axes, respectively; supply tidy axis titles.
    The data points should be plotted as gray spheres, with a size of 0.5\. Keep the
    plot open.
  id: totrans-387
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`rgl`功能绘制三个变量，分别在*x*、*y*、*z*轴上绘制房间数、状态和价值；提供整洁的轴标题。数据点应以灰色球体表示，大小为0.5。保持该图像打开。
- en: Use `ks` functionality to estimate the trivariate density function of these
    data. Base the estimate on a 64 × 64 × 64 evaluation lattice; ensure the 99 integer
    percentiles of the observation-specific density levels are returned. Superimpose
    isosurface contours delineating the 75 percent, 50 percent, and 10 percent “most
    dense” observations using green, yellow, and blue. Set the opacity at 10 percent,
    40 percent, and 50 percent, respectively.
  id: totrans-388
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`ks`功能估算这些数据的三变量密度函数。基于64 × 64 × 64的评估网格进行估算；确保返回99个观察特定密度水平的整数百分位数。使用绿色、黄色和蓝色绘制出分别表示75百分位、50百分位和10百分位“最密集”观察的等值面轮廓。设置透明度分别为10%、40%和50%。
- en: Finally, add reference grids along the three planes identified at the lower
    *z*-, upper *x*-, and upper *y*-axis locations.
  id: totrans-389
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，在下方的*z*轴、上方的*x*轴和上方的*y*轴位置添加参考网格。
- en: Interpret the final plot from (d). For example, what values of the present variables
    tend to characterize the most common types of houses in Boston’s suburbs?
  id: totrans-390
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 解释（d）部分的最终图形。例如，当前变量的哪些值倾向于表征波士顿郊区最常见类型的房屋？
- en: 'Here’s the result:'
  id: totrans-391
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 结果如下：
- en: '![image](../images/f0734-01.jpg)'
  id: totrans-392
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![image](../images/f0734-01.jpg)'
- en: 'The *umbilic torus* is another interesting 3D shape in mathematics and can
    be defined by the following parametric equations:'
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: '*umbilic torus* 是数学中另一个有趣的3D形状，可以通过以下参数方程定义：'
- en: '*x* = sin(*θ*)*F*(*θ*, *φ*)'
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: '*x* = sin(*θ*)*F*(*θ*, *φ*)'
- en: '*y* = cos(*θ*)*F*(*θ*, *φ*)'
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: '*y* = cos(*θ*)*F*(*θ*, *φ*)'
- en: '*z* = sin(*θ*/3 − 2*φ*) + 2sin(*θ*/3 + *φ*)'
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: '*z* = sin(*θ*/3 − 2*φ*) + 2sin(*θ*/3 + *φ*)'
- en: In these equations, *F*(*θ*, *φ*) = 7 + cos(*θ*/3 − 2*φ*) + 2 cos(*θ*/3 + *φ*),
    and you allow for both −*π* ≤ *θ* ≤ *π* and −*π* ≤ *φ* ≤ *π*.
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些方程中，*F*(*θ*, *φ*) = 7 + cos(*θ*/3 − 2*φ*) + 2 cos(*θ*/3 + *φ*)，并且你允许 −*π*
    ≤ *θ* ≤ *π* 和 −*π* ≤ *φ* ≤ *π*。
- en: Using a sequence of length 1000 for both *θ* and *φ*, as well as 1000 colors
    generated from the built-in `rainbow` palette assigned directly to the `col` argument,
    produce an interactive 3D plot of the umbilic torus. Suppress the box, axes, and
    axis titles. In viewing the object from different perspectives, note that, much
    like the Möbius strip you plotted earlier, this shape has only one edge.
  id: totrans-398
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用长度为1000的*θ*和*φ*序列，以及从内置的`rainbow`调色板生成的1000种颜色，直接分配给`col`参数，生成一个交互式的umbilic
    torus 3D图。去掉盒子、坐标轴和坐标轴标题。在从不同角度查看物体时，请注意，与之前绘制的莫比乌斯带类似，这个形状只有一条边。
- en: 'Here’s the result:'
  id: totrans-399
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 结果如下：
- en: '![image](../images/f0735-01.jpg)'
  id: totrans-400
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![image](../images/f0735-01.jpg)'
- en: '**Important Code in This Chapter**'
  id: totrans-401
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**本章的重要代码**'
- en: '| **Function/operator** | **Brief description** | **First occurrence** |'
  id: totrans-402
  prefs: []
  type: TYPE_TB
  zh: '| **函数/运算符** | **简要描述** | **首次出现** |'
- en: '| --- | --- | --- |'
  id: totrans-403
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| `plot3d` | Interactive 3D point cloud | [Section 26.1.1](ch26.xhtml#ch26lev2sec261),
    [p. 692](ch26.xhtml#page_692) |'
  id: totrans-404
  prefs: []
  type: TYPE_TB
  zh: '| `plot3d` | 交互式3D点云 | [第26.1.1节](ch26.xhtml#ch26lev2sec261)，[第692页](ch26.xhtml#page_692)
    |'
- en: '| `legend3d` | Add RGL device legend | [Section 26.1.2](ch26.xhtml#ch26lev2sec262),
    [p. 693](ch26.xhtml#page_693) |'
  id: totrans-405
  prefs: []
  type: TYPE_TB
  zh: '| `legend3d` | 添加RGL设备图例 | [第26.1.2节](ch26.xhtml#ch26lev2sec262)，[第693页](ch26.xhtml#page_693)
    |'
- en: '| `bg3d` | Reset RGL device background | [Section 26.1.2](ch26.xhtml#ch26lev2sec262),
    [p. 693](ch26.xhtml#page_693) |'
  id: totrans-406
  prefs: []
  type: TYPE_TB
  zh: '| `bg3d` | 重置RGL设备背景 | [第26.1.2节](ch26.xhtml#ch26lev2sec262)，[第693页](ch26.xhtml#page_693)
    |'
- en: '| `segments3d` | Add 3D line segments | [Section 26.1.3](ch26.xhtml#ch26lev2sec263),
    [p. 696](ch26.xhtml#page_696) |'
  id: totrans-407
  prefs: []
  type: TYPE_TB
  zh: '| `segments3d` | 添加3D线段 | [第26.1.3节](ch26.xhtml#ch26lev2sec263)，[第696页](ch26.xhtml#page_696)
    |'
- en: '| `grid3d` | Add plane grid | [Section 26.1.3](ch26.xhtml#ch26lev2sec263),
    [p. 696](ch26.xhtml#page_696) |'
  id: totrans-408
  prefs: []
  type: TYPE_TB
  zh: '| `grid3d` | 添加平面网格 | [第26.1.3节](ch26.xhtml#ch26lev2sec263)，[第696页](ch26.xhtml#page_696)
    |'
- en: '| `bgplot3d` | Alter/replot RGL device background | [Section 26.1.3](ch26.xhtml#ch26lev2sec263),
    [p. 696](ch26.xhtml#page_696) |'
  id: totrans-409
  prefs: []
  type: TYPE_TB
  zh: '| `bgplot3d` | 更改/重新绘制RGL设备背景 | [第26.1.3节](ch26.xhtml#ch26lev2sec263)，[第696页](ch26.xhtml#page_696)
    |'
- en: '| `persp3d` | Interactive 3D perspective surface | [Section 26.2.1](ch26.xhtml#ch26lev2sec264),
    [p. 700](ch26.xhtml#page_700) |'
  id: totrans-410
  prefs: []
  type: TYPE_TB
  zh: '| `persp3d` | 交互式3D透视面 | [第26.2.1节](ch26.xhtml#ch26lev2sec264)，[第700页](ch26.xhtml#page_700)
    |'
- en: '| `points3d` | Add 3D points | [Section 26.2.2](ch26.xhtml#ch26lev2sec265),
    [p. 701](ch26.xhtml#page_701) |'
  id: totrans-411
  prefs: []
  type: TYPE_TB
  zh: '| `points3d` | 添加3D点 | [第26.2.2节](ch26.xhtml#ch26lev2sec265)，[第701页](ch26.xhtml#page_701)
    |'
- en: '| `text3d` | Add 3D text | [Section 26.2.2](ch26.xhtml#ch26lev2sec265), [p.
    702](ch26.xhtml#page_702) |'
  id: totrans-412
  prefs: []
  type: TYPE_TB
  zh: '| `text3d` | 添加3D文本 | [第26.2.2节](ch26.xhtml#ch26lev2sec265)，[第702页](ch26.xhtml#page_702)
    |'
- en: '| `rmvnorm` | Random multivariate normal variates | [Section 26.3.2](ch26.xhtml#ch26lev2sec269),
    [p. 711](ch26.xhtml#page_711) |'
  id: totrans-413
  prefs: []
  type: TYPE_TB
  zh: '| `rmvnorm` | 随机多元正态变量 | [第26.3.2节](ch26.xhtml#ch26lev2sec269)，[第711页](ch26.xhtml#page_711)
    |'
- en: '| `dmvnorm` | Multivariate normal density | [Section 26.3.2](ch26.xhtml#ch26lev2sec269),
    [p. 711](ch26.xhtml#page_711) |'
  id: totrans-414
  prefs: []
  type: TYPE_TB
  zh: '| `dmvnorm` | 多元正态密度 | [第26.3.2节](ch26.xhtml#ch26lev2sec269)，[第711页](ch26.xhtml#page_711)
    |'
- en: '| `contour3d` | Draw isosurface | [Section 26.3.2](ch26.xhtml#ch26lev2sec269),
    [p. 713](ch26.xhtml#page_713) |'
  id: totrans-415
  prefs: []
  type: TYPE_TB
  zh: '| `contour3d` | 绘制等值面 | [第26.3.2节](ch26.xhtml#ch26lev2sec269)，[第713页](ch26.xhtml#page_713)
    |'
- en: '| `kde` | Multivariate kernel estimation | [Section 26.3.3](ch26.xhtml#ch26lev2sec270),
    [p. 717](ch26.xhtml#page_717) |'
  id: totrans-416
  prefs: []
  type: TYPE_TB
  zh: '| `kde` | 多元核估计 | [第26.3.3节](ch26.xhtml#ch26lev2sec270)，[第717页](ch26.xhtml#page_717)
    |'
- en: '| `pi` | Geometric value *π* | [Section 26.4.1](ch26.xhtml#ch26lev2sec271),
    [p. 722](ch26.xhtml#page_722) |'
  id: totrans-417
  prefs: []
  type: TYPE_TB
  zh: '| `pi` | 几何常数 *π* | [第26.4.1节](ch26.xhtml#ch26lev2sec271)，[第722页](ch26.xhtml#page_722)
    |'
- en: '| `sin`, `cos` | Sine and cosine | [Section 26.4.1](ch26.xhtml#ch26lev2sec271),
    [p. 722](ch26.xhtml#page_722) |'
  id: totrans-418
  prefs: []
  type: TYPE_TB
  zh: '| `sin`, `cos` | 正弦和余弦 | [第26.4.1节](ch26.xhtml#ch26lev2sec271)，[第722页](ch26.xhtml#page_722)
    |'
- en: '| `outer` | Outer array product | [Section 26.4.1](ch26.xhtml#ch26lev2sec271),
    [p. 724](ch26.xhtml#page_724) |'
  id: totrans-419
  prefs: []
  type: TYPE_TB
  zh: '| `outer` | 外积运算 | [第26.4.1节](ch26.xhtml#ch26lev2sec271)，[第724页](ch26.xhtml#page_724)
    |'
- en: '| `sample` | Random sample from vector | [Section 26.4.2](ch26.xhtml#ch26lev2sec272),
    [p. 731](ch26.xhtml#page_731) |'
  id: totrans-420
  prefs: []
  type: TYPE_TB
  zh: '| `sample` | 从向量中随机抽样 | [第26.4.2节](ch26.xhtml#ch26lev2sec272)，[第731页](ch26.xhtml#page_731)
    |'
