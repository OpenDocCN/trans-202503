<html><head></head><body>
<h2 class="h2" id="ch03"><a id="page_37"/><strong><span class="big">3</span></strong><br/><strong>Web Security</strong></h2>
<div class="image1"><img alt="image" src="graphics/common-01.jpg"/></div>
<p class="noindent">You may not have realized it before, but the Internet as we know it couldn’t exist without a solution to the shared key problem. Think about a typical situation: you’re buying something at an online retailer that you’ve never purchased from before. At some point you will be asked for your credit card data. Your browser tells you that your data is secure, perhaps by displaying a “lock” icon in the corner. But for the browser to protect your card number using AES, both your system and the retailer must use the same encryption key. How do two systems securely transmit data without getting together beforehand to exchange a key?</p>
<p class="indent">Solving this shared key problem is essential to providing any security on the Web. We’ll explore the solution to the shared key problem in this chapter, which uses all the techniques we’ve seen in the previous two chapters, plus a new special ingredient: public-key cryptography.</p>
<h3 class="h3" id="ch03lev1sec01"><a id="page_38"/><strong>How Public-Key Cryptography Solves the Shared Key Problem</strong></h3>
<p class="noindent">In the world of physical security, the shared key problem has a straightforward solution because locks and keys are two separate things. Suppose person A needs to ship confidential physical documents to person B. Person B could buy a strongbox and a keyed lock and then mail the box and lock to person A while keeping the key. Then person A puts the documents in the box, locks the box with B’s lock, and ships the box back to B. Because B has the only key to the lock, this is a secure delivery method.</p>
<p class="indent">This is the desired situation for transmitting data digitally as well. We need to separate the methods for locking and unlocking data, so that knowing how to encrypt data won’t provide the means to decrypt the resulting ciphertext.</p>
<p class="indent">In <a href="ch01.html#ch01">Chapter 1</a>, we learned about AES, which is a symmetric-key encryption method, meaning the same key is used for encryption and decryption. For transmission, we need an <em>asymmetric-key</em> encryption method, with one key for encryption and another key for decryption. The encryption key is known as the <em>public key</em>, because it can be freely distributed with no ill effects if it falls into the hands of an attacker; for this reason, asymmetric-key encryption is also known as <em>public-key cryptography</em>. The decryption key is known only to the recipient, so it’s known as the <em>private key</em>. These relationships are shown in <a href="ch03.html#ch3fig1">Figure 3-1</a>.</p>
<div class="image"><img alt="image" src="graphics/f03-01.jpg"/></div>
<p class="figuret"><a id="ch3fig1"/><em>Figure 3-1: Asymmetric-key encryption, with a public key for encryption and a private key for decryption. Only the receiver has the private key.</em></p>
<h3 class="h3" id="ch03lev1sec02"><strong>Math Tools for Public-Key Cryptography</strong></h3>
<p class="noindent">What public-key cryptography requires, then, is an encryption method that’s reversible but <em>not</em> with the cipher key that was used in the encryption. The basic tools of the encryption methods we’ve seen so far won’t work for public-key cryptography. The most common operation in AES, for example, is exclusive-or, which is used precisely because when something is XORed twice with the same binary number, you get the same number you started with. Reversible operations such as XOR inevitably lead to having the same key for encryption and decryption.</p>
<p class="indent"><a id="page_39"/>Public-key encryption, therefore, requires a new technique. As it turns out, the secrets to public-key encryption lie in the hidden relationships between numbers. In order to explain what those relationships are and how they can be exploited for cryptography, we need to go over a few pieces of math terminology.</p>
<h4 class="h4" id="ch03lev2sec01"><strong><em>Invertible Functions</em></strong></h4>
<p class="noindent">Broadly stated, a <em>function</em> describes any situation where each numerical input results in a single numerical output. The current Celsius temperature, for example, is a function of the current Fahrenheit temperature. For any particular temperature in Fahrenheit degrees, there is exactly one matching temperature in Celsius degrees.</p>
<p class="indent">In the same way, the monetary value of a pile of coins is a function of the number of coins of each type. A pile containing three quarters, two nickels, a dime, and four pennies has a monetary value of 99 cents. This pile of coins cannot be worth any other amount.</p>
<p class="indent">Sometimes a function can be reversed to produce another function. If we know a temperature in degrees Fahrenheit, we also know it in degrees Celsius, and the reverse is true: if we know a temperature in Celsius, we can also figure it out in Fahrenheit. In mathematical terms, we would say that the Celsius-to-Fahrenheit function is the <em>inversion</em> of the Fahrenheit-to-Celsius function, and that the original function is <em>invertible</em>. The coin example, though, is not invertible. The same total monetary value can be produced by multiple combinations of coins. If the coins in my pocket are worth 99 cents, I might have three quarters, two nickels, a dime, and four pennies, or I might have nine dimes and nine pennies, or some other combination.</p>
<h4 class="h4" id="ch03lev2sec02"><strong><em>One-Way Functions</em></strong></h4>
<p class="noindent">For some invertible functions, computing in one direction may be a lot easier than the other. For example, the mathematical concepts of <em>square</em> and <em>square root</em> are complementary functions. Suppose you have a square room in your home that is covered in black-and-white tiles, as shown in <a href="ch03.html#ch3fig2">Figure 3-2</a>. To find the total surface area of the floor, you multiply 12 by 12 to get 144.</p>
<p class="indent">We say that 144 is the <em>square</em> of 12. Going in the other direction, we say that 12 is the <em>square root</em> of 144. These are both functions; each number has one square and one square root. The difficulty of computing these two functions is very different, though. Figuring out a number’s square is easy: you just multiply the number by itself. Figuring out the square root is hard. Unless you have a table of values to help you, computing a square root is effectively a trial-and-error process. You make a guess at what the root might be, multiply that guess by itself, see if your guess was too high or too low, and then adjust your next guess accordingly, repeating the process until you find the exact square root or get close enough that you are willing to stop. When a function is invertible but its inverse is much harder to compute, it is called a <em>one-way function</em>.</p>
<div class="image"><a id="page_40"/><img alt="image" src="graphics/f03-02.jpg"/></div>
<p class="figuret"><a id="ch3fig2"/><em>Figure 3-2: A square room with walls 12 feet long has a total area of 144 feet.</em></p>
<h4 class="h4" id="ch03lev2sec03"><strong><em>Trapdoor Functions</em></strong></h4>
<p class="noindent">Asymmetric encryption requires a one-way function so that the encryption key can be public—the encryption will be easy, but the decryption will be so hard as to be infeasible. The problem is, we shouldn’t make the decryption infeasible for the intended recipient as well. So any old one-way function isn’t going to do the trick. We need what’s known as a <em>trapdoor function</em>, a one-way function where the inverse function is hard in general, but easy when some secret value is known.</p>
<h5 class="h5" id="ch03lev3sec01"><strong>Prime Numbers</strong></h5>
<p class="noindent">The particular trapdoor function we’ll discuss involves prime numbers. A number is <em>prime</em> if it is greater than 1 and can only be divided (without a remainder) by itself and 1. For example, 5 is prime because it can be divided only by itself and 1. It cannot be evenly divided into 2, 3, or 4 parts. The number 6, though, can be divided by 2 and 3 in addition to 1 and itself. It is therefore a nonprime, or <em>composite</em>, number. Smaller numbers that divide into a larger number are known as the larger number’s <em>factors</em>. Every number is divisible by itself and by 1, but we call these <em>trivial factors</em> and tend to ignore them when discussing factors. A prime number has only trivial factors.</p>
<h5 class="h5" id="ch03lev3sec02"><strong>Coprime Numbers</strong></h5>
<p class="noindent">In a related concept, two numbers are said to be <em>coprime</em> if they share only 1 as a factor. Either number may or may not be prime itself, but each can be thought of as prime as far as the other number knows. For example, the composite numbers 9 and 4 are coprime because there is no number that divides them both except for 1. In contrast, 6 isn’t coprime with either 9 or 4, because 6 shares factors with both. These relationships are demonstrated in <a href="ch03.html#ch3tab1">Table 3-1</a>.</p>
<p class="tablet"><a id="page_41"/><a id="ch3tab1"/><strong>Table 3-1:</strong> Showing that 9 and 4 Are Coprime, but 6 Is Not Coprime with 9 or 4</p>
<table border="0" cellpadding="0" cellspacing="0" class="topbot" width="100%">
<thead>
<tr>
<td class="table_th" valign="top"><p class="table"><strong>Divisor</strong></p></td>
<td class="table_th" valign="top"><p class="table"><strong>Remainder from 9</strong></p></td>
<td class="table_th" valign="top"><p class="table"><strong>Remainder from 6</strong></p></td>
<td class="table_th" valign="top"><p class="table"><strong>Remainder from 4</strong></p></td>
</tr>
</thead>
<tbody>
<tr>
<td class="table_co" valign="top"><p class="table">9</p></td>
<td class="table_co" valign="top"><p class="table">(trivial)</p></td>
<td class="table_co" valign="top"><p class="table"> </p></td>
<td class="table_co" valign="top"><p class="table"> </p></td>
</tr>
<tr>
<td class="table" valign="top"><p class="table">8</p></td>
<td class="table" valign="top"><p class="table">1</p></td>
<td class="table" valign="top"><p class="table"> </p></td>
<td class="table" valign="top"><p class="table"> </p></td>
</tr>
<tr>
<td class="table_co" valign="top"><p class="table">7</p></td>
<td class="table_co" valign="top"><p class="table">2</p></td>
<td class="table_co" valign="top"><p class="table"> </p></td>
<td class="table_co" valign="top"><p class="table"> </p></td>
</tr>
<tr>
<td class="table" valign="top"><p class="table">6</p></td>
<td class="table" valign="top"><p class="table">3</p></td>
<td class="table" valign="top"><p class="table">(trivial)</p></td>
<td class="table" valign="top"><p class="table"> </p></td>
</tr>
<tr>
<td class="table_co" valign="top"><p class="table">5</p></td>
<td class="table_co" valign="top"><p class="table">4</p></td>
<td class="table_co" valign="top"><p class="table">1</p></td>
<td class="table_co" valign="top"><p class="table"> </p></td>
</tr>
<tr>
<td class="table" valign="top"><p class="table">4</p></td>
<td class="table" valign="top"><p class="table">1</p></td>
<td class="table" valign="top"><p class="table">2</p></td>
<td class="table" valign="top"><p class="table">(trivial)</p></td>
</tr>
<tr>
<td class="table_co" valign="top"><p class="table">3</p></td>
<td class="table_co" valign="top"><p class="table">0</p></td>
<td class="table_co" valign="top"><p class="table">0</p></td>
<td class="table_co" valign="top"><p class="table">1</p></td>
</tr>
<tr>
<td class="table" valign="top"><p class="table">2</p></td>
<td class="table" valign="top"><p class="table">1</p></td>
<td class="table" valign="top"><p class="table">0</p></td>
<td class="table" valign="top"><p class="table">0</p></td>
</tr>
<tr>
<td class="table_co" valign="top"><p class="table">1</p></td>
<td class="table_co" valign="top"><p class="table">(trivial)</p></td>
<td class="table_co" valign="top"><p class="table">(trivial)</p></td>
<td class="table_co" valign="top"><p class="table">(trivial)</p></td>
</tr>
</tbody>
</table>
<p class="indent">Although 1 is not a prime number, it’s considered to be coprime with every other number.</p>
<h5 class="h5" id="ch03lev3sec03"><strong>Prime Factors</strong></h5>
<p class="noindent">Now we are getting close to the hidden relationships that make public-key encryption work. If we multiply two prime numbers, the resulting product has only those two prime numbers as factors (again, not counting itself and 1). For example, 5 and 3 are prime numbers. The product of 3 and 5 is 15, and 15 has only 3 and 5 as factors, as shown in <a href="ch03.html#ch3tab2">Table 3-2</a>.</p>
<p class="tablet"><a id="ch3tab2"/><strong>Table 3-2:</strong> The Product of Prime Numbers 3 and 5 Is 15, and 15 Has Only 3 and 5 as Factors</p>
<table border="0" cellpadding="0" cellspacing="0" class="topbot" width="70%">
<thead>
<tr>
<td class="table_th" valign="top"><p class="table"><strong>Divide 15 by</strong></p></td>
<td class="table_th" valign="top"><p class="table"><strong>Result</strong></p></td>
<td class="table_th" valign="top"><p class="table"><strong>Remainder</strong></p></td>
</tr>
</thead>
<tbody>
<tr>
<td class="table_co" valign="top"><p class="table">15</p></td>
<td class="table_co" valign="top"><p class="table">0</p></td>
<td class="table_co" valign="top"><p class="table">0 (trivial)</p></td>
</tr>
<tr>
<td class="table" valign="top"><p class="table">14</p></td>
<td class="table" valign="top"><p class="table">1</p></td>
<td class="table" valign="top"><p class="table">1</p></td>
</tr>
<tr>
<td class="table_co" valign="top"><p class="table">13</p></td>
<td class="table_co" valign="top"><p class="table">1</p></td>
<td class="table_co" valign="top"><p class="table">2</p></td>
</tr>
<tr>
<td class="table" valign="top"><p class="table">12</p></td>
<td class="table" valign="top"><p class="table">1</p></td>
<td class="table" valign="top"><p class="table">3</p></td>
</tr>
<tr>
<td class="table_co" valign="top"><p class="table">11</p></td>
<td class="table_co" valign="top"><p class="table">1</p></td>
<td class="table_co" valign="top"><p class="table">4</p></td>
</tr>
<tr>
<td class="table" valign="top"><p class="table">10</p></td>
<td class="table" valign="top"><p class="table">1</p></td>
<td class="table" valign="top"><p class="table">5</p></td>
</tr>
<tr>
<td class="table_co" valign="top"><p class="table">9</p></td>
<td class="table_co" valign="top"><p class="table">1</p></td>
<td class="table_co" valign="top"><p class="table">6</p></td>
</tr>
<tr>
<td class="table" valign="top"><p class="table">8</p></td>
<td class="table" valign="top"><p class="table">1</p></td>
<td class="table" valign="top"><p class="table">7</p></td>
</tr>
<tr>
<td class="table_co" valign="top"><p class="table">7</p></td>
<td class="table_co" valign="top"><p class="table">2</p></td>
<td class="table_co" valign="top"><p class="table">1</p></td>
</tr>
<tr>
<td class="table" valign="top"><p class="table">6</p></td>
<td class="table" valign="top"><p class="table">2</p></td>
<td class="table" valign="top"><p class="table">3</p></td>
</tr>
<tr>
<td class="table_co" valign="top"><p class="table">5</p></td>
<td class="table_co" valign="top"><p class="table">3</p></td>
<td class="table_co" valign="top"><p class="table">0</p></td>
</tr>
<tr>
<td class="table" valign="top"><p class="table">4</p></td>
<td class="table" valign="top"><p class="table">3</p></td>
<td class="table" valign="top"><p class="table">3</p></td>
</tr>
<tr>
<td class="table_co" valign="top"><p class="table">3</p></td>
<td class="table_co" valign="top"><p class="table">5</p></td>
<td class="table_co" valign="top"><p class="table">0</p></td>
</tr>
<tr>
<td class="table" valign="top"><p class="table">2</p></td>
<td class="table" valign="top"><p class="table">7</p></td>
<td class="table" valign="top"><p class="table">1</p></td>
</tr>
<tr>
<td class="table_co" valign="top"><p class="table">1</p></td>
<td class="table_co" valign="top"><p class="table">15</p></td>
<td class="table_co" valign="top"><p class="table">0 (trivial)</p></td>
</tr>
</tbody>
</table>
<p class="indent"><a id="page_42"/>This is a one-way function. If I give you two prime numbers, you can easily multiply them together, although you might use a calculator if the numbers are large. The inverse of this function would mean starting with the product of two prime numbers and finding the two original primes. That’s considerably harder.</p>
<p class="indent">Let’s take 18,467 as an example. This number is indeed the product of two primes—but <em>which</em> two primes? To answer this question, you would need to divide 18,467 by every prime number starting from 2. Eventually you would discover that 18,467 divided by 59 is 313, which means that 59 and 313 are the two prime factors.</p>
<p class="indent">Finding the prime factors is very difficult if all you have is the product. However, when you have the product and one of the two factors, finding the other factor is simple, because all you have to do is divide the first prime into the product. That makes it a trapdoor function—easy in one direction, hard in another unless you have the extra piece of information. If the prime numbers are large enough, finding the factors is infeasible without the trapdoor.</p>
<h3 class="h3" id="ch03lev1sec03"><strong>The RSA Encryption Method</strong></h3>
<p class="noindent">This trapdoor function is at the heart of the <em>RSA</em> public-key encryption system, named after the initials of its inventors: Rivest, Shamir, and Adleman. In actual practice, this system uses very large numbers to prevent a simple brute-force attack, but I’ll use small numbers in a simplified example to more easily demonstrate how it works.</p>
<p class="indent">Suppose that siblings Zed and Abigail share a bank account but live apart. Zed has just changed the account’s four-digit PIN to 1482 and needs to send this new number to Abigail via email. Because email transmissions pass through many potentially insecure computers, the PIN must be encrypted in some way, but Zed and Abigail haven’t previously shared a cipher key that would allow the use of a method like AES. Instead, Zed will securely transmit the new PIN using RSA.</p>
<h4 class="h4" id="ch03lev2sec04"><strong><em>Creating the Keys</em></strong></h4>
<p class="noindent">Although Zed has the confidential data to transmit in this example, the RSA procedure begins with Abigail, who must produce a public key before Zed can encrypt the PIN.</p>
<h5 class="h5" id="ch03lev3sec04"><strong>Step 1</strong></h5>
<p class="noindent">Abigail begins by choosing two prime numbers; let’s say she chooses 97 and 113.</p>
<h5 class="h5" id="ch03lev3sec05"><strong>Step 2</strong></h5>
<p class="noindent">Abigail multiplies these two numbers together to get 10,961. To keep things straight, I’ll call this number the <em>prime-product</em>.</p>
<h5 class="h5" id="ch03lev3sec06"><a id="page_43"/><strong>Step 3</strong></h5>
<p class="noindent">Next Abigail must compute a <em>totient</em> (which is pronounced <em>TOE-shent</em>, to rhyme with <em>quotient</em>). For a number <em>N</em>, the totient is the amount of numbers that are less than <em>N</em> and coprime with <em>N</em>. For example, the number 15 is coprime with 1, 2, 4, 7, 8, 11, 13, or 14, as shown in <a href="ch03.html#ch3fig3">Figure 3-3</a>. Because there are eight numbers coprime with 15, the totient of 15 is 8.</p>
<div class="image"><img alt="image" src="graphics/f03-03.jpg"/></div>
<p class="figuret"><a id="ch3fig3"/><em>Figure 3-3: The eight circled numbers have no factors in common with 15. Therefore the totient of 15 is 8.</em></p>
<p class="indent">Computing the totient of a number normally requires checking every smaller number for common factors, and therefore it’s a lot of work—for huge numbers, finding the totient is practically impossible. However, if the number in question is the product of two prime numbers, there’s a shortcut: simply subtract 1 from each of the two prime numbers and multiply the results together. For example, 15 is the product of two primes, 3 and 5. If we subtract 1 from each of the two primes, we get 2 and 4; if we multiply 2 and 4 we get 8, the totient of 15.</p>
<p class="indent">This shortcut greatly aids Abigail, whose next step is computing the totient of the prime-product, 10,961. Since that is the product of the primes 97 and 113, the totient of 10,961 is 96 × 112, or 10,752.</p>
<h5 class="h5" id="ch03lev3sec07"><strong>Step 4</strong></h5>
<p class="noindentb">Now Abigail selects a number that meets the following criteria:</p>
<p class="bull">• Greater than 1</p>
<p class="bull">• Less than the totient</p>
<p class="bull">• Coprime with the totient</p>
<p class="noindentt"><a id="page_44"/>Let’s say she picks 5. This is acceptable because it is greater than 1, it is less than 10,752, and there is no number other than 1 that divides both 5 and 10,752. Abigail is going to share this number with Zed, so we’ll call it the public key.</p>
<h5 class="h5" id="ch03lev3sec08"><strong>Step 5</strong></h5>
<p class="noindent">The chosen public key determines Abigail’s private key, the number she has to keep secret. For any given public key and totient, there is just one number that can serve as the private key, and we can identify it by testing successive multiples of the totient. For each multiple, we add 1 and see if the result is divisible by the public key. When it is, the result of this division is the private key.</p>
<p class="indent">The process is demonstrated in <a href="ch03.html#ch3tab3">Table 3-3</a>. The first multiple of 10,752 is 10,752 itself; Abigail adds 1 to make 10,753, then divides by 5, getting 2,150 with a remainder of 3. She tries the second multiple, 21,504, and when she adds 1 and divides by 5, she gets 4,301 and no remainder, so her private key is 4,301.</p>
<p class="tablet"><a id="ch3tab3"/><strong>Table 3-3:</strong> Finding the Private Key</p>
<table border="0" cellpadding="0" cellspacing="0" class="topbot" width="100%">
<thead>
<tr>
<td class="table_th" valign="top"><p class="table"><strong>Multiple</strong></p></td>
<td class="table_th" valign="top"><p class="table"><strong>Multiply by 10,752</strong></p></td>
<td class="table_th" valign="top"><p class="table"><strong>Add 1</strong></p></td>
<td class="table_th" valign="top"><p class="table"><strong>Divide by 5</strong></p></td>
<td class="table_th" valign="top"><p class="table"><strong>Remainder</strong></p></td>
</tr>
</thead>
<tbody>
<tr>
<td class="table" valign="top"><p class="table">1</p></td>
<td class="table" valign="top"><p class="table">10,752</p></td>
<td class="table" valign="top"><p class="table">10,753</p></td>
<td class="table" valign="top"><p class="table">2,150</p></td>
<td class="table" valign="top"><p class="table">3</p></td>
</tr>
<tr>
<td class="table" valign="top"><p class="table">2</p></td>
<td class="table" valign="top"><p class="table">21,504</p></td>
<td class="table" valign="top"><p class="table">21,505</p></td>
<td class="table" valign="top"><p class="table">4,301</p></td>
<td class="table" valign="top"><p class="table">0</p></td>
</tr>
</tbody>
</table>
<p class="indent">Of course, with larger numbers it may take a lot more multiples to find the private key, but there is always one number that will pass the test. The number of multiples tested will always be less than the public key (in our example, Abigail knows she’ll find the private key in four tries or less). In any case, now that Abigail has her private key, the actual encryption can begin.</p>
<h4 class="h4" id="ch03lev2sec05"><strong><em>Encrypting Data with RSA</em></strong></h4>
<p class="noindent">Abigail emails both her prime-product (10,961) and public key (5) to Zed. Because these numbers don’t allow anyone to decrypt the resulting ciphertext, it doesn’t matter who else reads the email before it reaches Zed.</p>
<p class="indent">The actual encryption of the new PIN takes just two steps.</p>
<h5 class="h5" id="ch03lev3sec09"><strong>Step 1</strong></h5>
<p class="noindent">Zed raises the PIN, 1,482, to the power of the public key, 5—that is, 1,482 is multiplied by itself five times:</p>
<p class="center">1,482 × 1,482 × 1,482 × 1,482 × 1,482 = 7,148,929,565,430,432</p>
<h5 class="h5" id="ch03lev3sec10"><strong>Step 2</strong></h5>
<p class="noindent">The second step is to find the remainder of dividing the result of step 1 by the prime-product. In this case, 10,961 goes into 7,148,929,565,430,432 about 652 billion times, but all Zed cares about is that the remainder of that division is 2,122. Zed sends this remainder to Abigail.</p>
<h5 class="h5" id="ch03lev3sec11"><a id="page_45"/><strong>Step 3</strong></h5>
<p class="noindent">On the receiving end, Abigail performs two similar steps to decrypt the ciphertext. She starts by raising the ciphertext number, 2,122, to the power of the private key, 4,301. Because 2,122<sup>4,301</sup> is enormous—over 14,000 digits—I won’t show it here.</p>
<h5 class="h5" id="ch03lev3sec12"><strong>Step 4</strong></h5>
<p class="noindent">Abigail finds the remainder of dividing the enormous number from step 3 by the prime-product. The remainder of that division is exactly 1,482, revealing Zed’s PIN.</p>
<h4 class="h4" id="ch03lev2sec06"><strong><em>RSA Effectiveness</em></strong></h4>
<p class="noindent">Remember that the goal of RSA, like any encryption system, is making encryption easy, decryption easy for the intended recipient, and decryption very hard for anyone else. A summary of our RSA example is shown in <a href="ch03.html#ch3fig4">Figure 3-4</a>.</p>
<p class="indentb">Even using much larger primes, encryption and authorized decryption are easy with the aid of the computer, as a review of the steps in our example will show.</p>
<p class="order1">1.   Abigail picked two prime numbers and multiplied them together to produce her <em>prime-product</em>. Multiplying two numbers together is easy.</p>
<p class="order1">2.   Abigail computed the <em>totient</em> of the prime-product by subtracting one from each of the two prime numbers before multiplying. Subtraction and multiplication are easy.</p>
<p class="order1">3.   Abigail chose a <em>public key</em>, a number that shares no factors with the totient. For large numbers, this would be impractical to find by hand, but for a computer, this is easy.</p>
<p class="order1">4.   Abigail found the appropriate value for her <em>private key</em>, which should, when multiplied by the number chosen for her public key, produce a number that’s 1 more than a multiple of the totient. This is a chore to do by hand, but for a computer, this too is easy.</p>
<p class="order1">5.   Abigail sent Zed the prime-product and public key.</p>
<p class="order1">6.   Zed raised the PIN to the power of the public key. For a computer, this is relatively easy.</p>
<p class="order1">7.   Zed divided the result from the previous step by the prime-product and took the remainder. Division is easy.</p>
<p class="order1">8.   Zed sent the remainder to Abigail.</p>
<p class="order1">9.   Abigail raised the number Zed sent to the power of the private key. Easy.</p>
<p class="order1">10. Abigail divided the result of the previous step by the prime-product and took the remainder, revealing Zed’s PIN. Easy.</p>
<div class="image"><a id="page_46"/><img alt="image" src="graphics/f03-04.jpg"/></div>
<p class="figuret"><a id="ch3fig4"/><em>Figure 3-4: A summary of the RSA example. The box in the middle shows Zed’s responsibilities; the rest are Abigail’s.</em></p>
<p class="indent">RSA encryption and decryption by authorized parties is easy work for a computer, but unauthorized decryption is maddeningly difficult. To decrypt, an attacker must have both the prime-product, which Abigail gives out freely, and the private key, which she keeps to herself. How could an attacker compute the private key? Finding that number means first finding the totient of the prime-product, but remember, Abigail was only able to compute the totient quickly because she knows the two prime numbers that created the prime-product. Without those two prime numbers, an attacker must find the totient the hard way—by checking every number less than the prime-product to find all the coprimes.</p>
<p class="indent"><a id="page_47"/>In our example, the prime-product is small, so it’s feasible for a computer to find the totient in this brute-force manner. In actual practice, though, prime-products are huge, and finding their totients isn’t feasible at all. In fact, an attacker would be better off searching for the two primes that make the prime-product, to use the shortcut method of making the totient. That still requires checking all numbers up to the square root of the prime-product, though, so for large numbers this is as infeasible as finding the totient the long way.</p>
<p class="indent">The RSA encryption method therefore creates our desired digital equivalent of a “lockbox.” Encryption and decryption no longer share the same secrets, so knowing how to lock the data doesn’t provide the ability to unlock it.</p>
<h4 class="h4" id="ch03lev2sec07"><strong><em>RSA Use in the Real World</em></strong></h4>
<p class="noindent">Our simplified example demonstrates the basics of RSA encryption, but for real-world use, we have to consider a few other details.</p>
<h5 class="h5" id="ch03lev3sec13"><strong>Bidirectional Transmission</strong></h5>
<p class="noindent">The system shown in the example allows for Zed to securely transmit to Abigail, but not the other way around. If they wanted to send secure messages in either direction, Zed would have to go through all the steps that Abigail did, making his own prime-product, totient, public key, and private key, and sending the prime-product and public key to Abigail.</p>
<h5 class="h5" id="ch03lev3sec14"><strong>Key Size</strong></h5>
<p class="noindent">In RSA, the last step of either encryption or decryption is taking the remainder of division with the prime-product, which means the plaintext number must be less than the prime-product. In the example with Abigail and Zed, then, the largest possible plaintext number is 14,960. That’s not a problem for Zed and his four-digit PIN, but for general use larger ranges are needed.</p>
<p class="indent">Just as important, the larger the value of the prime-product, the more difficult it will be for an attacker to find the two prime factors. In other words, the size of the prime-product directly affects the security of encryption. In current practice, primes are chosen to produce a prime-product with a minimum of 1,024 bits. As you may recall, the Advanced Encryption Standard described in <a href="ch01.html#ch01">Chapter 1</a> used only 128 or 256 bits for the key. So we are talking about a truly humongous number—1,024 bits is equivalent to a decimal number of over 300 digits.</p>
<h5 class="h5" id="ch03lev3sec15"><strong>Long Plaintexts and Performance</strong></h5>
<p class="noindent">A 1,024-bit key allows the encryption of very large numbers. But a typical text, image, or audio file is a long series of small numbers, not one big number. How do we transmit a long series of numbers using RSA? With AES, long files would be chopped up into as many 128-bit blocks as necessary. <a id="page_48"/>In theory, we could do the same with RSA, chopping up files into a multitude of 1,024-bit blocks and applying RSA to each block. The problem is that RSA encryption is much slower than AES.</p>
<p class="indent">AES has more steps than the RSA Encryption Standard, but even so, AES is high-performance because the steps themselves are so simple. The most common operations are XOR and shifting bits around, and these operations are individually trivial. You can grasp this by working out the result of these operations in your head, as shown in <a href="ch03.html#ch3fig5">Figure 3-5</a>.</p>
<div class="image"><img alt="image" src="graphics/f03-05.jpg"/></div>
<p class="figuret"><a id="ch3fig5"/><em>Figure 3-5: Computing XOR or rotating bits to new positions is easy.</em></p>
<p class="indent">In contrast, the RSA process has only a few steps, but the reliance on exponentiation means more work overall. Consider a relatively small exponent: 17<sup>16</sup>. Written out, that’s ...</p>
<p class="center">17 × 17 × 17 × 17 × 17 × 17 × 17 × 17 × 17 × 17 × 17 × 17 × 17 × 17 × 17 × 17</p>
<p class="indent">Try working that out in your head, and you see the problem. Now imagine exponents involving numbers with hundreds of digits. Although a computer can handle these calculations, exponents are clearly a lot more work than simple XORs. Because exponents take so much time, using RSA for large amounts of data is impractical.</p>
<h5 class="h5" id="ch03lev3sec16"><strong>Combining Systems</strong></h5>
<p class="noindent">The solution to the RSA performance problem is simple: don’t transmit large amounts of data with RSA. Instead, use RSA to transmit an encryption key for another, faster method, such as AES.</p>
<p class="indent">Returning to Abigail and Zed, suppose Zed needs to send Abigail a long document that he has already converted to a series of numbers using the ASCII table. Zed would prefer to encrypt the document using AES rather than take on the hard work of RSA. To use AES, though, Zed and Abigail would both need to share an AES encryption key. RSA provides the means to share that key safely. Zed can create the AES key himself, then encrypt it with RSA using Abigail’s public key. Then Zed can encrypt the <a id="page_49"/>long document using AES, and Abigail can decrypt the resulting ciphertext using the key they now share. This process is illustrated in <a href="ch03.html#ch3fig6">Figure 3-6</a>.</p>
<div class="image"><img alt="image" src="graphics/f03-06.jpg"/></div>
<p class="figuret"><a id="ch3fig6"/><em>Figure 3-6: Combining RSA and AES to produce an asymmetric public-key system with high performance</em></p>
<p class="indent">In this figure, the A-lock symbol means “encrypted with AES” while the R-lock means “encrypted with RSA.” By sending both the AES-encrypted document and the AES key encrypted with her public RSA key, Abigail has everything necessary to decrypt the document, but an attacker intercepting the transmission won’t be able to decrypt the document without Abigail’s private key.</p>
<p class="indent">By combining the two encryption methods, we combine their strengths to get the high performance of AES and the shared keys of RSA. Public-key encryption is typically used this way, to initiate a symmetric-key encryption process that would otherwise be impossible.</p>
<h4 class="h4" id="ch03lev2sec08"><strong><em>RSA for Authentication</em></strong></h4>
<p class="noindent">Public-key cryptography creates an authentication problem. Because the public key is just that—public—anyone can send an encrypted message to the private key owner; therefore, the recipient of a transmission cannot be <a id="page_50"/>certain of the sender’s identity. This problem doesn’t occur with symmetric-key encryption, because the secrecy of the one key, when it can be shared, ensures not only the security of the message but also that the message originated with the other person who has the key. Luckily, public-key cryptography can be also be used to authenticate.</p>
<h5 class="h5" id="ch03lev3sec17"><strong>Authentication Using RSA</strong></h5>
<p class="noindent">In our RSA example, Abigail has her prime-product of 10,961 and her private key of 4,301, while Zed has the prime-product and Abigail’s public key of 5. This allows Zed to send a secure message to Abigail, but it also allows Abigail to send an authenticated message to Zed.</p>
<p class="indent">Suppose Abigail wants to send that same PIN, 1482, back to Zed to acknowledge its receipt, and in such a way that Zed can be sure the acknowledgment comes from Abigail.</p>
<p class="indent">Abigail takes the PIN, 1,482, and raises it to the power of her private key (instead of the public key used for encryption). 1,482<sup>4,301</sup> is another huge number—it has over 13,000 digits—so I’m not going to write it here, but when that huge number is divided by the prime-product of 10,961, the remainder is 8,742. Abigail sends an email with that remainder to Zed. Zed now raises that 8,742 to the power of Abigail’s public key, 5, which results in 51,056,849,256,616,667,232. Finally, Zed divides that number by the prime-product, getting a remainder of 1,482. Zed recognizes this number as the PIN, and knows it must have been transformed using Abigail’s private key, proving the number came from Abigail. The relationship between security and authentication in RSA is shown in <a href="ch03.html#ch3fig7">Figure 3-7</a>.</p>
<div class="image"><img alt="image" src="graphics/f03-07.jpg"/></div>
<p class="figuret"><a id="ch3fig7"/><em>Figure 3-7: The RSA process provides either encryption or authentication.</em></p>
<p class="indent">We can authenticate entire files by applying this authentication process to the encryption key of a system like AES and sending the encrypted file and the authenticated key to the recipient.</p>
<p class="indent"><a id="page_51"/>The RSA process can therefore produce an authenticated message <em>or</em> a secure message, depending on whether we encrypt with a private key or a public key. Ideally we’d like messages to be both authenticated and secure. We can accomplish this by applying both variations of the process to the same message. In our example, illustrated in <a href="ch03.html#ch3fig8">Figure 3-8</a>, Abigail could encrypt the number she wants to transmit with her private key, then encrypt the result with Zed’s public key. Upon receipt, Zed would reverse the procedures, first decrypting with his private key, then again with Abigail’s public key.</p>
<div class="image"><img alt="image" src="graphics/f03-08.jpg"/></div>
<p class="figuret"><a id="ch3fig8"/><em>Figure 3-8: Applying the RSA with the sender’s private key and the recipient’s public key provides authentication and security.</em></p>
<h5 class="h5" id="ch03lev3sec18"><strong>Identity Authorities</strong></h5>
<p class="noindent">You may have noticed that authentication introduces a subtler version of the shared key problem. Zed knew the email came from Abigail because he recognized the PIN produced when he transformed the number using Abigail’s public key, which means the sender must have the matching private key. But if Zed is worried about someone pretending to be Abigail, how exactly does he know that the public key was sent by Abigail in the first place, not by an imposter who has hacked Abigail’s email account?</p>
<p class="indent">The solution to this problem is an <em>authority</em>, a third party that helps verify identities. As you’ll see, authorities provide the digital equivalent of ID cards. When two computers initiate a secure, authenticated transmission through the exchange of public keys, they show their IDs, which assures each computer of the identity of the other. Of course, this assumes each computer trusts the authority providing the ID, so in the end, authentication requires having implicit faith in someone. One either trusts that the transmission comes from the entity that claims to have sent it, or one trusts some third party to identify the sender. Identity authorities form a crucial component of the ultimate subject of this chapter, web security.</p>
<h3 class="h3" id="ch03lev1sec04"><a id="page_52"/><strong>Security on the Web: HTTPS</strong></h3>
<p class="noindent">Web pages are transferred using HTTP, which stands for <em>Hypertext Transfer Protocol</em>. When this data is transferred securely, it is called HTTPS, where the <em>S</em> stands for <em>secure</em>. This is why you’ll see <em>https</em> at the beginning of your browser’s address bar when you are transferring sensitive data—or I hope you do. Web security is something most people take for granted, but it’s an amazing feat to instantly create trust and security between two automated parties who may have just been introduced, requiring all the tricks and techniques you’ve seen so far.</p>
<p class="indent">For this discussion, suppose you’re purchasing from a retail website using a computer or phone. In this scenario, your computer is known as the <em>client</em>. The computer running the website for the retailer is the <em>server</em>. This is the first time you’ve made a purchase from this retailer, so you have to provide shipping and billing information such as your address and credit card number. This situation cries out for security, but it requires authentication as well.</p>
<p class="indent">To see why, you have to remember that your computer is not directly connected to the server. Your data will be passed along from system to system, through computers managed by your Internet service provider (ISP) and those managed by the retailer’s ISP, and possibly through intermediate systems managed by neither. It’s possible for any of these systems to be compromised by attackers such that the infected system would intercept transmissions headed for the retailer, responding in its place. If this happens, when you place your order, you’re giving your data away to attackers, not to the retailer. Although the data is encrypted, it is encrypted with the key provided by the compromised system, so the encryption ensures only that no one else eavesdrops on the data you are sending to the attackers. This sort of impersonation is known as a <em>man-in-the-middle</em> attack, and is foiled by good authentication.</p>
<h4 class="h4" id="ch03lev2sec09"><strong><em>Handshaking</em></strong></h4>
<p class="noindent">Secure transmission of data occurs in sessions. A <em>session</em> is the web equivalent of a phone call: an extended conversation that begins when you first load a page on a site and ends after you have not interacted with the site for some predetermined amount of time.</p>
<p class="indent">Before the transmission can begin, your client and the server must successfully perform a ritual called <em>handshaking</em>. The name implies that it’s just two computers saying howdy, but it’s more like a tense scene in a crime show where one guy doesn’t want to show the “stuff” in the back of the van until the other guy shows the cash in the briefcase. The handshaking phase, if successful, authenticates the server to the client, and creates the key that will be used for encrypting the data throughout the session. As with Abigail and Zed, a public-key encryption system is used just long enough to share the keys needed for the better-performing private-key encryption system.</p>
<h5 class="h5" id="ch03lev3sec19"><a id="page_53"/><strong>Step 1</strong></h5>
<p class="noindent">The client tells the server which encryption methods it supports. The HTTPS protocol allows computers to choose from a suite of acceptable methods for encryption, which means that different secure websites that you access may use different encryption techniques providing higher or lower levels of security. In addition to the encryption support information, the client also provides a randomly generated number—the purpose of which you’ll soon see.</p>
<h5 class="h5" id="ch03lev3sec20"><strong>Step 2</strong></h5>
<p class="noindent">The server responds with its own list of supported encryption methods and also its <em>certificate</em>. The server certificate contains several pieces of data, including the domain name of the site (such as <a href="http://amazon.com">amazon.com</a>) and the name of the certificate <em>issuer</em> (the authority that will verify the site’s identity). It also contains the server’s public key. HTTPS can use several different public-key cryptographic systems, but RSA is common. The server uses the same certificate for every client it transacts with, so the public-and-private key pair only has to be created once for each certificate. Although this means the server uses the same RSA keys for all clients, as you’ll see, the RSA keys are used only during this handshaking phase.</p>
<p class="indent">The server certificate also contains a <em>signature</em>. As discussed in <a href="ch02.html#ch02">Chapter 2</a>, digital signatures are hash codes. In this case, the server hashes the certificate data and encrypts the hash code using the server’s private key.</p>
<p class="indent">In addition, the server also sends a random number to the client, just as the client has sent a random number to the server.</p>
<h5 class="h5" id="ch03lev3sec21"><strong>Step 3</strong></h5>
<p class="noindent">The client validates the certificate. There are two aspects to the validation. First, the client applies the server’s public key to the hash code in the certificate, then hashes the certificate itself and compares the two hash codes. If the codes match, the certificate is internally valid, but it doesn’t prove this is the actual certificate for the site.</p>
<p class="indent">Now the client must check with the issuer of the certificate, a certification authority with built-in trust with your browser. If you drill down into your browser’s options, you will find a list of issuers under a heading such as “Trusted root certification authorities.” The issuer provides a copy of the site’s certificate; when this matches the certificate provided by the server, the client is assured of the identity of the server.</p>
<h5 class="h5" id="ch03lev3sec22"><strong>Step 4</strong></h5>
<p class="noindent">The client generates another random number, 48 bytes long, or 384 bits, known as the <em>premaster secret</em>. As the name implies, this number must remain a secret. However, the client needs to send it to the server, so the client encrypts it using the server’s public key.</p>
<h5 class="h5" id="ch03lev3sec23"><a id="page_54"/><strong>Step 5</strong></h5>
<p class="noindent">The client and server independently create the 384-bit <em>master secret</em> by hashing a combination of the premaster secret and the two random numbers that were exchanged in the first two steps. Once the master secret is created, the premaster secret and the other two random numbers are discarded.</p>
<p class="indent">Note that the master secret is not exchanged between client and server. By this stage, both the client and the server have all the numbers needed to create the master secret. They independently run the numbers through the same process to produce the same result.</p>
<p class="indent">A summary of the handshaking process is shown in <a href="ch03.html#ch3fig9">Figure 3-9</a>.</p>
<div class="image"><img alt="image" src="graphics/f03-09.jpg"/></div>
<p class="figuret"><a id="ch3fig9"/><em>Figure 3-9: The HTTPS handshaking procedure</em></p>
<h4 class="h4" id="ch03lev2sec10"><strong><em>Transmitting Data Under HTTPS</em></strong></h4>
<p class="noindent">Now the client and server can begin sending actual data—web pages and media from the server, and user data from the client. The 384 bits of the master secret are divided into three 128-bit sections, each providing a different aspect of security.</p>
<h5 class="h5" id="ch03lev3sec24"><a id="page_55"/><strong>Data Encryption</strong></h5>
<p class="noindent">The first section of the master secret is used as the key for a private-key encryption system such as AES. Each of the subsequent data transmissions during the secure session will be encrypted using this cipher key.</p>
<h5 class="h5" id="ch03lev3sec25"><strong>Block Chaining</strong></h5>
<p class="noindent">Because web pages have standard header formats that could provide cribs to attackers, a method such as block chaining (discussed in <a href="ch01.html#ch01">Chapter 1</a>) is employed. As you may recall, such systems need a starting value to encrypt the first block of the transmission; the middle 128-bit section of the master secret is used as this starting value.</p>
<h5 class="h5" id="ch03lev3sec26"><strong>Message Authentication Code</strong></h5>
<p class="noindent">The final 128-bit section of the master secret is used to create a <em>message authentication code</em>, or <em>MAC</em>, for each transmission. In this case, we’re not trying to authenticate the identity of the sender—that was already handled in the handshaking phase. Instead, the MAC ensures that data isn’t altered during transmission.</p>
<p class="indent">In this process, each transmission is hashed through a function like MD5, but first the transmission data is combined with the remaining 128-bit section of the master secret. This is known as <em>keyed hashing</em>, and the 128-bit section in this context is known as a <em>MAC key</em>. Using a keyed hash helps foil man-in-the-middle attacks. An attacker who wishes to pass a fake transmission to the receiver will need the MAC key to produce a hash code that will be accepted as genuine by the receiver.</p>
<p class="indent">The hashing occurs before the encryption, so that both the original message and the hash code are encrypted.</p>
<h3 class="h3" id="ch03lev1sec05"><strong>The Shared Key Problem Solved?</strong></h3>
<p class="noindent">So that’s how data is securely transmitted over the Web. As you can see, solving the shared key problem requires just about every trick in the cryptography toolkit. Public-key encryption creates the secure channel for initial communications. Private-key encryption is used to secure individual transmissions of data. Hashing authenticates both the session and individual messages. If the site uses passwords to authenticate users, then all of the password techniques from <a href="ch02.html#ch02">Chapter 2</a> would come into play as well.</p>
<p class="indent">Web security is a complex system of techniques. And therein lies a potential problem: the complexity of computer security can hide weaknesses. Just as a machine with more parts has more parts that can break down, the layering of so many intricate methods and techniques can mask undiscovered vulnerabilities. Sometimes the vulnerability is not within any one part, but in how the parts are connected. Although methods like RSA and AES are currently considered safe, clever attackers may find ways to break the security without breaking the underlying encryption methods.</p>
<p class="indent"><a id="page_56"/>For example, earlier versions of HTTPS were vulnerable to a particular man-in-the-middle attack that arose from the observation that most secure sessions begin with a user clicking on a link. Suppose, for example, that you have received an email from the bank that issues your credit card with a link to your most recent account statement. The link is an HTTPS address, which means that when you click it, your browser will launch and request a secure connection with the bank’s server. However, this request itself is not secure. An attacker’s program could intercept this request and pass it along to the bank server as a request for a plain unencrypted HTTP connection, and then eavesdrop on all the unencrypted traffic that followed. The user might be tipped off by the prefix in the address bar, but how many users would think to check that? To cover this security hole, web servers can now tell browsers that all connections must be made through HTTPS—but that solution doesn’t foil an attacker who can intercept the announcement as well. The ultimate solution may be to require HTTPS for all web communications.</p>
<p class="indent">Undoubtedly new vulnerabilities will be found in the future, requiring the invention of new defenses. Computer security is a moving target. We’ll never be able to declare our data entirely safe, but relying on best practices may keep us one step ahead of attackers.</p>
</body></html>