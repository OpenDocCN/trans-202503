- en: '4'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '4'
- en: BUILDING A BINARY LOADER USING LIBBFD
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 使用LIBBFD构建二进制加载器
- en: Now that you have a solid understanding of how binaries work from the previous
    chapters, you’re ready to start building your own analysis tools. Throughout this
    book, you’ll frequently build your own tools that manipulate binaries. Because
    nearly all of these tools will need to parse and (statically) load binary files,
    it makes sense to have a common framework that provides this ability. In this
    chapter, let’s use `libbfd` to design and implement such a framework to reinforce
    what you’ve learned so far about binary formats.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你已经通过前几章对二进制文件有了扎实的理解，准备开始构建自己的分析工具了。在本书中，你将经常构建自己的工具来操作二进制文件。由于几乎所有这些工具都需要解析并（静态地）加载二进制文件，因此拥有一个提供此功能的通用框架是非常有意义的。在这一章中，我们将使用`libbfd`来设计和实现这样的框架，以加深你对二进制格式的理解。
- en: You’ll see the binary loading framework again in [Part III](part3.xhtml) of
    this book, which covers advanced techniques for building your own binary analysis
    tools. Before designing the framework, I’ll briefly introduce `libbfd`.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书的[第三部分](part3.xhtml)中，你将再次看到二进制加载框架，该部分涵盖了构建你自己二进制分析工具的高级技术。在设计框架之前，我将简要介绍`libbfd`。
- en: 4.1 What Is libbfd?
  id: totrans-4
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.1 什么是 libbfd？
- en: The Binary File Descriptor library^([1](footnote.xhtml#ch04fn_1)) (`libbfd`)
    provides a common interface for reading and parsing all popular binary formats,
    compiled for a wide variety of architectures. This includes ELF and PE files for
    x86 and x86-64 machines. By basing your binary loader on `libbfd`, you can automatically
    support all these formats without having to implement any format-specific support.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 二进制文件描述符库^([1](footnote.xhtml#ch04fn_1))（`libbfd`）提供了一个通用接口，用于读取和解析所有流行的二进制格式，并为各种架构编译。这包括针对x86和x86-64机器的ELF和PE文件。通过将二进制加载器基于`libbfd`，你可以自动支持所有这些格式，而无需实现任何格式特定的支持。
- en: The BFD library is part of the GNU project and is used by many applications
    in the `binutils` suite, including `objdump`, `readelf`, and `gdb`. It provides
    generic abstractions for all common components used in binary formats, such as
    headers describing the binary’s target and properties, lists of sections, sets
    of relocations, symbol tables, and so on. On Ubuntu, `libbfd` is part of the `binutils-dev`
    package.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: BFD库是GNU项目的一部分，并被`binutils`套件中的许多应用程序使用，包括`objdump`、`readelf`和`gdb`。它提供了对所有常见二进制格式组件的通用抽象，例如描述二进制目标和属性的头文件、节列表、重定位集合、符号表等。在Ubuntu中，`libbfd`是`binutils-dev`包的一部分。
- en: You can find the core `libbfd` API in */usr/include/bfd.h*.^([2](footnote.xhtml#ch04fn_2))
    Unfortunately, `libbfd` can be a bit unwieldy to use, so instead of trying to
    explain the API here, let’s dive straight in and explore the API while implementing
    the binary-loading framework.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在*/usr/include/bfd.h*中找到核心的`libbfd` API。^([2](footnote.xhtml#ch04fn_2)) 不幸的是，`libbfd`的使用可能有些笨重，因此我们不打算在这里解释它的
    API，而是直接深入探索 API，同时实现二进制加载框架。
- en: 4.2 A Simple Binary-Loading Interface
  id: totrans-8
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.2 一个简单的二进制加载接口
- en: Before implementing the binary loader, let’s design an easy-to-use interface.
    After all, the whole point of the binary loader is to make the process of loading
    binaries as easy as possible for all the binary analysis tools that you’ll implement
    later in this book. It’s intended for use in static analysis tools. Note that
    this is completely different from the dynamic loader provided by the OS, whose
    job it is to load binaries into memory to execute them, as discussed in [Chapter
    1](ch01.xhtml#ch01).
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在实现二进制加载器之前，让我们先设计一个易于使用的接口。毕竟，二进制加载器的整个目的是使加载二进制文件的过程尽可能简单，以便后续所有你将在本书中实现的二进制分析工具都能使用。它主要用于静态分析工具。请注意，这与操作系统提供的动态加载器完全不同，后者的工作是将二进制文件加载到内存中以执行，如[第一章](ch01.xhtml#ch01)中讨论的那样。
- en: Let’s make the binary-loading interface agnostic of the underlying implementation,
    which means it won’t expose any `libbfd` functions or data structures. For simplicity,
    let’s also keep the interface as basic as possible, exposing only those parts
    of the binary that you’ll use frequently in later chapters. For example, the interface
    will omit components such as relocations, which aren’t usually relevant for your
    binary analysis tools.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使二进制加载接口与底层实现无关，这意味着它不会暴露任何`libbfd`函数或数据结构。为了简化，我们还将保持接口尽可能基础，仅暴露你在后续章节中经常使用的二进制部分。例如，接口将省略如重定位之类的组件，这些通常与二进制分析工具无关。
- en: '[Listing 4-1](ch04.xhtml#ch04list1) shows the C++ header file describing the
    basic API that the binary loader will expose. Note that it is located in the *inc*
    directory on the VM, rather than in the *chapter4* directory that contains the
    other code for this chapter. That’s because the loader is shared among all chapters
    in this book.'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: '[清单 4-1](ch04.xhtml#ch04list1) 显示了描述二进制加载器将公开的基本 API 的 C++ 头文件。请注意，它位于 VM 上的
    *inc* 目录中，而不是包含本章其他代码的 *chapter4* 目录中。原因是加载器在本书的所有章节中是共享的。'
- en: '*Listing 4-1:* inc/loader.h'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 4-1:* inc/loader.h'
- en: '[PRE0]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: As you can see, the API exposes a number of classes representing different components
    of a binary. The `Binary` class is the “root” class, representing an abstraction
    of the entire binary ➌. Among other things, it contains a `vector` of `Section`
    objects and a `vector` of `Symbol` objects. The `Section` class ➋ and `Symbol`
    class ➊ represent the sections and symbols contained in the binary, respectively.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，API 暴露了表示二进制不同组件的多个类。`Binary` 类是“根”类，表示整个二进制的抽象 ➌。除此之外，它还包含一个 `Section`
    对象的 `vector` 和一个 `Symbol` 对象的 `vector`。`Section` 类 ➋ 和 `Symbol` 类 ➊ 分别表示二进制文件中包含的节和符号。
- en: At its core, the whole API centers around only two functions. The first of these
    is the `load_binary` function ➍, which takes the name of a binary file to load
    (`fname`), a pointer to a `Binary` object to contain the loaded binary (`bin`),
    and a descriptor of the binary type (`type`). It loads the requested binary into
    the `bin` parameter and returns an integer value of 0 if the loading process was
    successful or a value less than 0 if it was not successful. The second function
    is `unload_binary` ➎, which simply takes a pointer to a previously loaded `Binary`
    object and unloads it.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 从核心来看，整个 API 仅围绕两个函数展开。第一个是 `load_binary` 函数 ➍，它接受一个二进制文件的名称（`fname`）、一个指向 `Binary`
    对象的指针用于存储加载的二进制文件（`bin`），以及一个二进制类型的描述符（`type`）。它将请求的二进制文件加载到 `bin` 参数中，并在加载成功时返回
    0，若加载失败则返回小于 0 的值。第二个函数是 `unload_binary` ➎，它只是接受一个指向先前加载的 `Binary` 对象的指针并将其卸载。
- en: Now that you’re familiar with the binary loader API, let’s take a look at how
    it’s implemented. I’ll start by discussing the implementation of the `Binary`
    class.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经熟悉了二进制加载器的 API，接下来我们来看看它是如何实现的。我将从讨论 `Binary` 类的实现开始。
- en: '*4.2.1 The Binary Class*'
  id: totrans-17
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*4.2.1 Binary 类*'
- en: 'As the name implies, the `Binary` class is an abstraction of a complete binary.
    It contains the binary’s filename, type, architecture, bit width, entry point
    address, and sections and symbols. The binary type has a dual representation:
    the `type` member contains a numeric type identifier, while `type_str` contains
    a string representation of the binary type. The same kind of dual representation
    is used for the architecture.'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 正如其名称所示，`Binary` 类是一个完整二进制文件的抽象。它包含二进制文件的文件名、类型、架构、位宽、入口点地址，以及节和符号。二进制类型具有双重表示：`type`
    成员包含一个数字类型标识符，而 `type_str` 包含二进制类型的字符串表示。同样的双重表示也用于架构。
- en: Valid binary types are enumerated in `enum BinaryType` and include ELF (`BIN_TYPE_ELF`)
    and PE (`BIN_TYPE_PE`). There’s also a `BIN_TYPE_AUTO`, which you can pass to
    the `load_binary` function to ask it to automatically determine whether the binary
    is an ELF or PE file. Similarly, valid architectures are enumerated in `enum BinaryArch`.
    For these purposes, the only valid architecture is `ARCH_X86`. This includes both
    x86 and x86-64; the distinction between the two is made by the `bits` member of
    the `Binary` class, which is set to 32 bits for x86 and to 64 bits for x86-64.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 有效的二进制类型在 `enum BinaryType` 中列举，包括 ELF（`BIN_TYPE_ELF`）和 PE（`BIN_TYPE_PE`）。还有一个
    `BIN_TYPE_AUTO`，你可以将其传递给 `load_binary` 函数，要求它自动判断二进制文件是 ELF 还是 PE 文件。类似地，有效的架构在
    `enum BinaryArch` 中列举。对于这些目的，唯一有效的架构是 `ARCH_X86`。这包括 x86 和 x86-64；两者之间的区别由 `Binary`
    类的 `bits` 成员表示，x86 设置为 32 位，x86-64 设置为 64 位。
- en: Normally, you access sections and symbols in the `Binary` class by iterating
    over the `sections` and `symbols` vectors, respectively. Because binary analysis
    often focuses on the code in the `.text` section, there is also a convenience
    function called `get_text_section` that, as the name implies, automatically looks
    up and returns this section for you.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，你可以通过分别迭代 `Binary` 类中的 `sections` 和 `symbols` 向量来访问节和符号。由于二进制分析通常关注 `.text`
    节中的代码，因此还有一个名为 `get_text_section` 的便捷函数，顾名思义，它会自动查找并返回该节。
- en: '*4.2.2 The Section Class*'
  id: totrans-21
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*4.2.2 Section 类*'
- en: Sections are represented by objects of type `Section`. The `Section` class is
    a simple wrapper around the main properties of a section, including the section’s
    name, type, starting address (the `vma` member), size (in bytes), and raw bytes
    contained in the section. For convenience, there is also a pointer back to the
    `Binary` that contains the `Section` object. The section type is denoted by an
    `enum SectionType` value, which tells you whether the section contains code (`SEC_TYPE_CODE`)
    or data (`SEC_TYPE_DATA`).
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 段由`Section`类型的对象表示。`Section`类是一个简单的包装器，用于表示段的主要属性，包括段的名称、类型、起始地址（`vma`成员）、大小（以字节为单位）以及该段包含的原始字节。为了方便，还提供了一个指向包含`Section`对象的`Binary`的指针。段类型由`enum
    SectionType`值表示，指示该段是包含代码（`SEC_TYPE_CODE`）还是数据（`SEC_TYPE_DATA`）。
- en: During your analyses, you’ll often want to check to which section a particular
    instruction or piece of data belongs. For this reason, the `Section` class has
    a function called `contains`, which takes a code or data address and returns a
    `bool` indicating whether the address is part of the section.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在分析过程中，你通常需要检查特定的指令或数据片段属于哪个段。因此，`Section`类有一个名为`contains`的函数，它接受一个代码或数据地址，并返回一个`bool`值，指示该地址是否属于该段。
- en: '*4.2.3 The Symbol Class*'
  id: totrans-24
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*4.2.3 符号类*'
- en: 'As you now know, binaries contain symbols for many types of components, including
    local and global variables, functions, relocation expressions, objects, and more.
    To keep things simple, the loader interface exposes only one kind of symbol: function
    symbols. These are especially useful because they enable you to easily implement
    function-level binary analysis tools when function symbols are available.'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所知，二进制文件包含许多类型的符号，包括本地和全局变量、函数、重定位表达式、对象等。为了简化，加载器接口只暴露了一种符号类型：函数符号。它们特别有用，因为当函数符号可用时，它们使得你可以轻松地实现函数级别的二进制分析工具。
- en: The loader represents symbols using the `Symbol` class. It contains a symbol
    type, represented as an `enum SymbolType`, for which the only valid value is `SYM_TYPE_FUNC`.
    In addition, the class contains the symbolic name and the start address of the
    function described by the symbol.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 加载器使用`Symbol`类来表示符号。该类包含一个符号类型，表示为`enum SymbolType`，其唯一有效值为`SYM_TYPE_FUNC`。此外，类还包含符号描述的函数的符号名称和起始地址。
- en: 4.3 Implementing the Binary Loader
  id: totrans-27
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.3 实现二进制加载器
- en: Now that the binary loader has a well-defined interface, let’s implement it!
    This is where `libbfd` gets involved. Because the code for the complete loader
    is a bit lengthy, I’ll split it up into chunks, which I’ll discuss one by one.
    In the following code, you can recognize the `libbfd` API functions because they
    all start with `bfd_` (there are also some functions that end with `_bfd`, but
    they are functions defined by the loader).
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 现在二进制加载器有了明确的接口，我们开始实现它吧！这就是`libbfd`发挥作用的地方。由于完整的加载器代码较长，我会将其分成几个部分，一一讨论。在以下代码中，你可以通过`bfd_`前缀识别`libbfd`的API函数（也有一些以`_bfd`结尾的函数，但它们是加载器定义的函数）。
- en: First, you must of course include all the header files you need. I won’t mention
    all of the standard C/C++ headers that the loader uses since they’re not of interest
    here (if you really want, you can look them up in the loader’s source on the VM).
    What is important to mention is that all programs that use `libbfd` must include
    *bfd.h*, as shown in [Listing 4-2](ch04.xhtml#ch04list2), and link against `libbfd`
    by specifying the linker flag `-lbfd`. In addition to *bfd.h*, the loader includes
    the header file that contains the interface created in the previous section.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，你当然需要包含所有需要的头文件。我不会提及加载器使用的所有标准 C/C++ 头文件，因为这些内容在这里不重要（如果你真的需要，可以在虚拟机上查看加载器的源码）。需要特别提到的是，所有使用`libbfd`的程序都必须包含*bfd.h*，如[Listing
    4-2](ch04.xhtml#ch04list2)所示，并通过指定链接器标志`-lbfd`来链接`libbfd`。除了*bfd.h*之外，加载器还包含了前一部分中创建的接口所在的头文件。
- en: '*Listing 4-2:* inc/loader.cc'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '*Listing 4-2:* inc/loader.cc'
- en: '[PRE1]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: With that out of the way, the next logical parts of the code to look at are
    `load_binary` and `unload_binary`, the two entry point functions exposed by the
    loader interface. [Listing 4-3](ch04.xhtml#ch04list3) shows how these functions
    are implemented.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 说到这，接下来要看的代码部分是`load_binary`和`unload_binary`，这是加载器接口暴露的两个入口函数。[Listing 4-3](ch04.xhtml#ch04list3)展示了这两个函数的实现。
- en: '*Listing 4-3:* inc/loader.cc *(continued)*'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '*Listing 4-3:* inc/loader.cc *(续)*'
- en: '[PRE2]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The job of `load_binary` ➊ is to parse a binary file specified by filename and
    load it into the `Binary` object given to it. This is a bit of a tedious process,
    so `load_binary` wisely defers the work to another function, called `load_binary_bfd`
    ➋. I’ll discuss this function shortly.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '`load_binary` ➊ 的工作是解析由文件名指定的二进制文件，并将其加载到传入的 `Binary` 对象中。这是一个有点繁琐的过程，因此 `load_binary`
    明智地将这项工作推迟给另一个函数，叫做 `load_binary_bfd` ➋。稍后我会讨论这个函数。'
- en: 'First, let’s look at `unload_binary` ➌. As with so many things, destroying
    a `Binary` object is a lot easier than creating one. To unload a `Binary` object,
    the loader must release (with `free`) all of the `Binary`’s dynamically allocated
    components. Luckily, there aren’t many of those: only the `bytes` member of each
    `Section` is allocated dynamically (using `malloc`). Thus, `unload_binary` simply
    iterates over all `Section` objects ➍ and deallocates the `bytes` array for each
    of them ➎. Now that you’ve seen how unloading a binary works, let’s take a more
    detailed look at how the loading process is implemented using `libbfd`.'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们看一下 `unload_binary` ➌。和许多事情一样，销毁一个 `Binary` 对象要比创建一个容易得多。为了卸载 `Binary`
    对象，加载器必须释放（使用 `free`）所有 `Binary` 的动态分配组件。幸运的是，这些组件并不多：只有每个 `Section` 的 `bytes`
    成员是动态分配的（使用 `malloc`）。因此，`unload_binary` 只需遍历所有 `Section` 对象 ➍，并为它们逐个释放 `bytes`
    数组 ➎。现在你已经了解了卸载二进制文件的工作原理，让我们更详细地看看如何使用 `libbfd` 实现加载过程。
- en: '*4.3.1 Initializing libbfd and Opening a Binary*'
  id: totrans-37
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*4.3.1 初始化 libbfd 并打开二进制文件*'
- en: In the previous section, I promised to show you `load_binary_bfd`, the function
    that uses `libbfd` to take care of all the work involved in loading the binary.
    Before I do that, I have to get one more prerequisite out of the way. That is,
    to parse and load a binary, you must first open it. The code to open a binary
    is implemented in a function called `open_bfd`, shown in [Listing 4-4](ch04.xhtml#ch04list4).
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，我承诺会向你展示 `load_binary_bfd`，这个函数使用 `libbfd` 来处理加载二进制文件的所有工作。在此之前，我得先处理一个先决条件。也就是说，要解析并加载二进制文件，你首先必须打开它。打开二进制文件的代码实现于一个名为
    `open_bfd` 的函数中，具体代码见 [Listing 4-4](ch04.xhtml#ch04list4)。
- en: '*Listing 4-4:* inc/loader.cc *(continued)*'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '*Listing 4-4:* inc/loader.cc *(续)*'
- en: '[PRE3]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The `open_bfd` function uses `libbfd` to determine the properties of the binary
    specified by the filename (the `fname` parameter), open it, and then return a
    handle to the binary. Before you can use `libbfd`, you must call `bfd_init` ➊
    to initialize `libbfd`’s internal state (or, as the documentation puts it, to
    “initialize magical internal data structures”). Since this needs to be done only
    once, `open_bfd` uses a static variable to keep track of whether the initialization
    has been done already.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '`open_bfd` 函数使用 `libbfd` 来确定由文件名（`fname` 参数）指定的二进制文件的属性，打开它，然后返回一个指向该二进制文件的句柄。在使用
    `libbfd` 之前，你必须调用 `bfd_init` ➊ 来初始化 `libbfd` 的内部状态（或者像文档中所说的那样，初始化“神奇的内部数据结构”）。由于这只需要做一次，`open_bfd`
    使用静态变量来跟踪初始化是否已经完成。'
- en: After initializing `libbfd`, you call the `bfd_openr` function to open the binary
    by filename ➋. The second parameter of `bfd_openr` allows you to specify a target
    (the type of the binary), but in this case, I’ve left it to `NULL` so that `libbfd`
    will automatically determine the binary type. The return value of `bfd_openr`
    is a pointer to a file handle of type `bfd`; this is `libbfd`’s root data structure,
    which you can pass to all other functions in `libbfd` to perform operations on
    the binary. In case of error, `bfd_openr` returns `NULL`.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在初始化 `libbfd` 后，你调用 `bfd_openr` 函数，通过文件名打开二进制文件 ➋。`bfd_openr` 的第二个参数允许你指定目标（二进制文件的类型），但在本例中，我将其设置为
    `NULL`，这样 `libbfd` 会自动确定二进制文件的类型。`bfd_openr` 的返回值是一个指向类型为 `bfd` 的文件句柄的指针；这是 `libbfd`
    的根数据结构，你可以将其传递给所有其他 `libbfd` 函数来对二进制文件执行操作。如果发生错误，`bfd_openr` 会返回 `NULL`。
- en: In general, whenever an error occurs, you can find the type of the most recent
    error by calling `bfd_get_error`. This returns an object of the type `bfd_error_type`,
    which you can compare against predefined error identifiers such as `bfd_error_no_memory`
    or `bfd_error_invalid_target` to figure out how to handle the error. Often, you’ll
    just want to exit with an error message. To accommodate this, the `bfd_errmsg`
    function can translate a `bfd_error_type` into a string describing the error,
    which you can print to the screen ➌.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 一般来说，每当发生错误时，你可以通过调用`bfd_get_error`来找到最近的错误类型。该函数返回一个`bfd_error_type`类型的对象，你可以将其与预定义的错误标识符进行比较，比如`bfd_error_no_memory`或`bfd_error_invalid_target`，从而判断如何处理该错误。通常，你可能只想退出并显示错误信息。为此，`bfd_errmsg`函数可以将`bfd_error_type`转换为描述错误的字符串，供你打印到屏幕上➌。
- en: After getting a handle to the binary, you should check the format of the binary
    using the `bfd_check_format` function ➍. This function takes a `bfd` handle and
    a `bfd_format` value, which can be set to `bfd_object`, `bfd_archive`, or `bfd_core`.
    In this case, the loader sets it to `bfd_object` to verify whether the opened
    file is indeed an object, which in `libbfd` terminology means an executable, a
    relocatable object, or a shared library.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在获得二进制文件的句柄后，你应该使用`bfd_check_format`函数检查二进制文件的格式 ➍。该函数接受一个`bfd`句柄和一个`bfd_format`值，后者可以设置为`bfd_object`、`bfd_archive`或`bfd_core`。在这种情况下，加载器将其设置为`bfd_object`，以验证打开的文件是否确实是一个对象，在`libbfd`术语中，这意味着可执行文件、可重定位对象或共享库。
- en: After confirming that it’s dealing with a `bfd_object`, the loader manually
    sets `libbfd`’s error state to `bfd_error_no_error` ➎. This is a work-around for
    an issue in some versions of `libbfd`, which set a `bfd_error_wrong_format` error
    before detecting the format and leave the error state set even if the format detection
    shows no problems.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在确认处理的是`bfd_object`之后，加载器手动将`libbfd`的错误状态设置为`bfd_error_no_error`➎。这是对一些版本的`libbfd`中的一个问题的变通方法，这些版本在检测格式之前就设置了`bfd_error_wrong_format`错误，并且即使格式检测没有问题，也会保留该错误状态。
- en: Finally, the loader checks that the binary has a known “flavor” by using the
    `bfd_get_flavour` function ➏. This function returns a `bfd_flavour` object, which
    simply indicates the kind of binary (ELF, PE, and so on). Valid `bfd_flavour`
    values include `bfd_target_msdos_flavour`, `bfd_target_coff_flavour`, and `bfd_target_elf_flavour`.
    If the binary format is unknown or there was an error, then `get_bfd_flavour`
    returns `bfd_target_unknown_flavour`, in which case `open_bfd` prints an error
    and returns `NULL`.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，加载器通过使用`bfd_get_flavour`函数检查二进制文件是否具有已知的“风味”➏。该函数返回一个`bfd_flavour`对象，表示二进制文件的类型（如ELF、PE等）。有效的`bfd_flavour`值包括`bfd_target_msdos_flavour`、`bfd_target_coff_flavour`和`bfd_target_elf_flavour`。如果二进制格式未知或发生错误，`get_bfd_flavour`将返回`bfd_target_unknown_flavour`，在这种情况下，`open_bfd`会打印错误并返回`NULL`。
- en: If all checks pass, it means that you have successfully opened a valid binary
    and are ready to start loading its contents! The `open_bfd` function returns the
    `bfd` handle it opened so you can use it later in other `libbfd` API calls, as
    shown in the next few listings.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 如果所有检查都通过，说明你已成功打开一个有效的二进制文件，并准备开始加载其内容！`open_bfd`函数返回它所打开的`bfd`句柄，供你在后续的`libbfd`
    API调用中使用，如下几个清单所示。
- en: '*4.3.2 Parsing Basic Binary Properties*'
  id: totrans-48
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*4.3.2 解析基本二进制属性*'
- en: Now that you’ve seen the necessary code to open a binary, it’s time to take
    a look at the `load_binary_bfd` function, shown in [Listing 4-5](ch04.xhtml#ch04list5).
    Recall that this is the function that handles all the actual parsing and loading
    work on behalf of the `load_binary` function. In this section, the aim is to load
    all of the interesting details about the binary into the `Binary` object pointed
    to by the `bin` parameter.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经看过了打开二进制文件所需的代码，是时候看一下`load_binary_bfd`函数了，见[清单 4-5](ch04.xhtml#ch04list5)。回想一下，这是处理所有实际解析和加载工作的函数，代表`load_binary`函数。在本节中，目的是将有关二进制文件的所有有趣细节加载到由`bin`参数指向的`Binary`对象中。
- en: '*Listing 4-5:* inc/loader.cc *(continued)*'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 4-5:* inc/loader.cc *(续)*'
- en: '[PRE4]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The `load_binary_bfd` function begins by using the just implemented `open_bfd`
    function to open the binary specified in the `fname` parameter and get a `bfd`
    handle to this binary ➊. Then, `load_binary_bfd` sets some of `bin`’s basic properties.
    It starts by copying the name of the binary file and using `libbfd` to find and
    copy the entry point address ➋.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '`load_binary_bfd`函数首先使用刚刚实现的`open_bfd`函数打开`fname`参数指定的二进制文件，并获取一个指向该二进制文件的`bfd`句柄➊。然后，`load_binary_bfd`设置一些`bin`的基本属性。它首先复制二进制文件的名称，并使用`libbfd`查找并复制入口点地址➋。'
- en: To get the entry point address of a binary, you use `bfd_get_start_address`,
    which simply returns the value of the `start_address` field of the `bfd` object.
    The start address is a `bfd_vma`, which is really nothing more than a 64-bit unsigned
    integer.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 要获取二进制文件的入口点地址，可以使用`bfd_get_start_address`，它简单地返回`bfd`对象中`start_address`字段的值。起始地址是一个`bfd_vma`，本质上就是一个64位无符号整数。
- en: 'Next, the loader collects information about the binary type: is it an ELF,
    a PE, or some other, unsupported type of binary? You can find this information
    in the `bfd_target` structure maintained by `libbfd`. To get a pointer to this
    data structure, you just need to access the `xvec` field in the `bfd` handle.
    In other words, `bfd_h->xvec` gives you a pointer to a `bfd_target` structure.'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，加载器收集有关二进制类型的信息：它是ELF、PE格式，还是其他不受支持的类型？你可以在`libbfd`维护的`bfd_target`结构中找到这些信息。要获取指向这个数据结构的指针，只需要访问`bfd`句柄中的`xvec`字段。换句话说，`bfd_h->xvec`给你一个指向`bfd_target`结构的指针。
- en: Among other things, this structure provides a string containing the name of
    the target type. The loader copies this string into the `Binary` object ➌. Next,
    it inspects the `bfd_h->xvec->flavour` field using a switch and sets the type
    of the `Binary` accordingly ➍. The loader supports only ELF and PE, so it emits
    an error if `bfd_h->xvec->flavour` indicates any other type of binary.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 除其他外，这个结构提供了一个包含目标类型名称的字符串。加载器将这个字符串复制到`Binary`对象中 ➌。接下来，它通过`switch`语句检查`bfd_h->xvec->flavour`字段，并根据该字段设置`Binary`的类型
    ➍。加载器仅支持ELF和PE格式，因此如果`bfd_h->xvec->flavour`表示任何其他类型的二进制文件，它将产生错误。
- en: Now you know whether the binary is an ELF or PE, but you don’t yet know the
    architecture. To find this out, you use `libbfd`’s `bfd_get_arch_info` function
    ➎. As the name implies, this function returns a pointer to a data structure that
    provides information about the binary architecture. This data structure is called
    `bfd_arch_info_type`. It provides a convenient printable string describing the
    architecture, which the loader copies into the `Binary` object ➏.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经知道二进制文件是ELF还是PE格式，但还不知道它的架构。要找出这一点，可以使用`libbfd`的`bfd_get_arch_info`函数 ➎。顾名思义，这个函数返回一个指向数据结构的指针，该结构提供有关二进制架构的信息。这个数据结构被称为`bfd_arch_info_type`。它提供了一个方便的可打印字符串，描述了架构，加载器将这个字符串复制到`Binary`对象中
    ➏。
- en: The `bfd_arch_info_type` data structure also contains a field called `mach`
    ➐, which is just an integer identifier for the architecture (called the *machine*
    in `libbfd` terminology). This integer representation of the architecture allows
    for a convenient `switch` to implement architecture-specific handling. If `mach`
    is equal to `bfd_mach_i386_i386`, then it’s a 32-bit x86 binary, and the loader
    sets the fields in the `Binary` accordingly. If `mach` is `bfd_mach_x86_64`, then
    it’s an x86-64 binary, and the loader again sets the appropriate fields. Any other
    type is unsupported and results in an error.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '`bfd_arch_info_type`数据结构还包含一个名为`mach`的字段 ➐，它只是一个表示架构的整数标识符（在`libbfd`术语中称为*machine*）。这种架构的整数表示允许使用方便的`switch`语句来实现特定架构的处理。如果`mach`等于`bfd_mach_i386_i386`，则表示它是一个32位x86二进制文件，加载器将相应地设置`Binary`中的字段。如果`mach`为`bfd_mach_x86_64`，则它是一个x86-64二进制文件，加载器再次设置相应的字段。任何其他类型都不受支持，并会导致错误。'
- en: 'Now that you’ve seen how to parse basic information about the binary type and
    architecture, it’s time to get to the real work: loading the symbols and sections
    contained in the binary. As you might imagine, this is not as simple as what you’ve
    seen so far, so the loader defers the necessary work to specialized functions,
    described in the next sections. The two functions the loader uses to load symbols
    are called `load_symbols_bfd` and `load_dynsym_bfd` ➑. As described in the next
    section, they load symbols from the static and dynamic symbol tables, respectively.
    The loader also implements `load_sections_bfd`, a specialized function to load
    the binary’s sections ➒. I’ll discuss it shortly, in [Section 4.3.4](ch04.xhtml#ch04_3_4).'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经了解了如何解析有关二进制类型和架构的基本信息，是时候进行实际的工作了：加载二进制文件中包含的符号和段。正如你想象的那样，这并不像你到目前为止看到的那么简单，因此加载器将必要的工作推迟到专门的函数中，这些函数将在接下来的章节中描述。加载器用来加载符号的两个函数分别称为`load_symbols_bfd`和`load_dynsym_bfd`
    ➑。正如接下来章节所述，它们分别从静态和动态符号表中加载符号。加载器还实现了`load_sections_bfd`，这是一个专门用于加载二进制文件段的函数
    ➒。我将在[第4.3.4节](ch04.xhtml#ch04_3_4)中详细讨论它。
- en: After loading the symbols and sections, you’ll have copied all the information
    that you’re interested in to your own `Binary` object, which means you’re done
    using `libbfd`. Because the `bfd` handle is no longer needed, the loader closes
    it using `bfd_close` ➓. It also closes the handle if any error happens before
    it’s fully done loading the binary.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在加载完符号和段之后，你将把所有感兴趣的信息复制到你自己的`Binary`对象中，这意味着你已经完成了对`libbfd`的使用。因为`bfd`句柄不再需要，所以加载器使用`bfd_close`
    ➓关闭它。如果在完全加载二进制之前发生任何错误，它也会关闭句柄。
- en: '*4.3.3 Loading Symbols*'
  id: totrans-60
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*4.3.3 加载符号*'
- en: '[Listing 4-6](ch04.xhtml#ch04list6) shows the code for `load_symbols_bfd`,
    the function to load the static symbol table.'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '[清单 4-6](ch04.xhtml#ch04list6)显示了`load_symbols_bfd`函数的代码，用于加载静态符号表。'
- en: '*Listing 4-6:* inc/loader.cc *(continued)*'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 4-6:* inc/loader.cc *(续)*'
- en: '[PRE5]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: In `libbfd`, symbols are represented by the `asymbol` structure, which is just
    a short name for `struct bfd_symbol`. In turn, a symbol table is just an `asymbol**`,
    meaning an array of pointers to symbols. Thus, the job of `load_symbols_bfd` is
    to populate the array of `asymbol` pointers declared at ➊ and then to copy the
    interesting information to the `Binary` object.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在`libbfd`中，符号通过`asymbol`结构表示，实际上它是`struct bfd_symbol`的简称。反过来，符号表只是一个`asymbol**`，意味着一个指向符号的指针数组。因此，`load_symbols_bfd`的工作是填充在➊声明的`asymbol`指针数组，然后将感兴趣的信息复制到`Binary`对象中。
- en: The input parameters to `load_symbols_bfd` are a `bfd` handle and the `Binary`
    object in which to store the symbolic information. Before you can load any symbol
    pointers, you need to allocate enough space to store all of them in. The `bfd_get_symtab_upper_bound`
    function ➋ tells you how many bytes to allocate for this purpose. The number of
    bytes is negative in case of an error, and it can also be zero, meaning that there
    is no symbol table. If there’s no symbol table, `load_symbols_bfd` is done and
    simply returns.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '`load_symbols_bfd`的输入参数是一个`bfd`句柄和一个用于存储符号信息的`Binary`对象。在加载任何符号指针之前，你需要分配足够的空间来存储它们。`bfd_get_symtab_upper_bound`函数
    ➋会告诉你为此分配多少字节。如果出现错误，字节数为负；如果为零，则表示没有符号表。如果没有符号表，`load_symbols_bfd`就会完成并直接返回。'
- en: If all is well and the symbol table contains a positive number of bytes, you
    allocate enough space to keep all the `asymbol` pointers in ➌. If the `malloc`
    succeeds, you’re finally ready to ask `libbfd` to populate your symbol table!
    You do this using the `bfd_canonicalize_symtab` function ➍, which takes as input
    your `bfd` handle and the symbol table that you want to populate (your `asymbol**`).
    As requested, `libbfd` duly populates your symbol table and returns the number
    of symbols it placed in the table (again, if that number is negative, you know
    something went wrong).
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一切正常，且符号表包含正字节数，你会分配足够的空间来存储所有的`asymbol`指针 ➌。如果`malloc`成功，你就可以准备好让`libbfd`来填充你的符号表！你可以通过`bfd_canonicalize_symtab`函数
    ➍来实现，这个函数接受你的`bfd`句柄和你要填充的符号表（即你的`asymbol**`）作为输入。按照要求，`libbfd`将正确填充你的符号表，并返回它在表中放置的符号数量（如果该数字为负，则说明出现了问题）。
- en: Now that you have a populated symbol table, you can loop over all the symbols
    it contains ➎. Recall that for the binary loader, you are interested only in function
    symbols. Thus, for each symbol, you check whether the `BSF_FUNCTION` flag is set,
    which indicates that it is a function symbol ➏. If this is the case, you reserve
    room for a `Symbol` (recall that this is the loader’s own class to store symbols
    in) in the `Binary` object by adding an entry to the `vector` that contains all
    the loaded symbols. You mark the newly created `Symbol` as a function symbol ➐,
    copy the symbolic name ➑, and set the `Symbol`’s address ➒. To get a function
    symbol’s value, which is the function’s start address, you use the `bfd_asymbol_value`
    function provided by `libbfd`.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经有了填充的符号表，你可以遍历它包含的所有符号 ➎。回想一下，对于二进制加载器，你只对函数符号感兴趣。因此，对于每个符号，你检查是否设置了`BSF_FUNCTION`标志，这表示它是一个函数符号
    ➏。若是这样，你就为`Binary`对象中的`Symbol`（回想一下，这是加载器自己用来存储符号的类）预留空间，通过向包含所有已加载符号的`vector`中添加条目来实现。你将新创建的`Symbol`标记为函数符号
    ➐，复制符号名称 ➑，并设置`Symbol`的地址 ➒。要获取函数符号的值，即函数的起始地址，你可以使用`libbfd`提供的`bfd_asymbol_value`函数。
- en: Now that all of the interesting symbols have been copied into `Symbol` objects,
    the loader no longer needs `libbfd`’s representation. Therefore, when `load_symbols_bfd`
    finishes, it deallocates any space reserved to store `libbfd` symbols ➓. After
    that, it returns, and the symbol-loading process is complete.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，所有有趣的符号都已被复制到`Symbol`对象中，加载器不再需要`libbfd`的表示。因此，当`load_symbols_bfd`完成时，它会释放为存储`libbfd`符号所保留的空间➓。之后，它返回，符号加载过程完成。
- en: So, that’s how you load symbols from the static symbol table with `libbfd`.
    But how is it done for the dynamic symbol table? Luckily, the process is almost
    completely identical, as you can see in [Listing 4-7](ch04.xhtml#ch04list7).
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是如何通过`libbfd`从静态符号表加载符号的过程。那么，动态符号表是如何完成的呢？幸运的是，过程几乎完全相同，正如你在[Listing 4-7](ch04.xhtml#ch04list7)中看到的那样。
- en: '*Listing 4-7:* inc/loader.cc *(continued)*'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '*Listing 4-7:* inc/loader.cc *(续)*'
- en: '[PRE6]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The function shown in [Listing 4-7](ch04.xhtml#ch04list7) to load symbols from
    the dynamic symbol table is aptly called `load_dynsym_bfd`. As you can see, `libbfd`
    uses the same data structure (`asymbol`) to represent both static and dynamic
    symbols ➊. The only differences with the previously shown `load_symbols_bfd` function
    are the following. First, to find the number of bytes you need to reserve for
    symbol pointers, you call `bfd_get_dynamic_symtab_upper_bound` ➋ instead of `bfd_get_symtab_upper_bound`.
    Second, to populate the symbol table, you use `bfd_canonicalize_dynamic_symtab`
    ➌ instead of `bfd_canonicalize_symtab`. That’s it! The rest of the dynamic symbol-loading
    process is the same as for static symbols.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在[Listing 4-7](ch04.xhtml#ch04list7)中展示的从动态符号表加载符号的函数被恰当地命名为`load_dynsym_bfd`。如你所见，`libbfd`使用相同的数据结构（`asymbol`）来表示静态和动态符号➊。与之前展示的`load_symbols_bfd`函数的唯一区别如下。首先，为了找到你需要为符号指针保留的字节数，你调用`bfd_get_dynamic_symtab_upper_bound`
    ➋，而不是`bfd_get_symtab_upper_bound`。其次，为了填充符号表，你使用`bfd_canonicalize_dynamic_symtab`
    ➌，而不是`bfd_canonicalize_symtab`。就这些！其余的动态符号加载过程与静态符号的加载过程相同。
- en: '*4.3.4 Loading Sections*'
  id: totrans-73
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*4.3.4 加载节*'
- en: 'After loading the symbols, only one thing remains to be done, though it’s arguably
    the most important step: loading the binary’s sections. [Listing 4-8](ch04.xhtml#ch04list8)
    shows how `load_sections_bfd` implements the functionality to do this.'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 加载符号后，剩下的事情只有一件，尽管这可能是最重要的一步：加载二进制文件的节。[Listing 4-8](ch04.xhtml#ch04list8)展示了`load_sections_bfd`是如何实现这一功能的。
- en: '*Listing 4-8:* inc/loader.cc *(continued)*'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '*Listing 4-8:* inc/loader.cc *(续)*'
- en: '[PRE7]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: To store sections, `libbfd` uses a data structure called `asection`, also known
    as `struct bfd_section`. Internally, `libbfd` keeps a linked list of `asection`
    structures to represent all sections. The loader reserves an `asection*` to iterate
    over this list ➊.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 为了存储节，`libbfd`使用一种叫做`asection`的数据结构，也称为`struct bfd_section`。在内部，`libbfd`保持一个`asection`结构的链表来表示所有节。加载器保留一个`asection*`来遍历这个列表➊。
- en: To iterate over all the sections, you start at the first one (pointed to by
    `bfd_h->sections`, the head of `libbfd`’s section list) and then follow the `next`
    pointer contained in each `asection` object ➋. When the `next` pointer is `NULL`,
    you’ve reached the end of the list.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 要遍历所有的节，你需要从第一个节开始（由`bfd_h->sections`指向，这是`libbfd`的节列表头），然后跟随每个`asection`对象中包含的`next`指针➋。当`next`指针为`NULL`时，你就到达了列表的末尾。
- en: For each section, the loader first checks whether it should be loaded at all.
    Since the loader only loads code and data sections, it starts by getting the section
    flags to check what the type of the section is. To get the flags, it uses `bfd_get_section_flags`
    ➌. Then, it checks whether either the `SEC_CODE` or `SEC_DATA` flag is set ➍.
    If not, then it skips this section and moves on to the next. If either of the
    flags *is* set, then the loader sets the section type for the corresponding `Section`
    object and continues loading the section.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 对于每个节，加载器首先检查是否应该加载它。由于加载器只加载代码和数据节，它首先获取节的标志来检查节的类型。为了获取标志，它使用`bfd_get_section_flags`
    ➌。然后，它检查是否设置了`SEC_CODE`或`SEC_DATA`标志 ➍。如果没有，它就跳过该节，继续处理下一个。如果设置了其中任一标志，则加载器为相应的`Section`对象设置节类型，并继续加载该节。
- en: In addition to the section type, the loader copies the virtual address, size
    (in bytes), name, and raw bytes of each code or data section. To find the virtual
    base address of a `libbfd` section, you use `bfd_section_vma` ➎. Similarly, you
    use `bfd_section_size`➏ and `bfd_section_name` ➐ to get the size and name of the
    section, respectively. It’s possible that the section has no name, in which case
    `bfd_section_name` will return `NULL`.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 除了节类型，加载器还会复制每个代码或数据节的虚拟地址、大小（以字节为单位）、名称和原始字节。要找到`libbfd`节的虚拟基地址，可以使用`bfd_section_vma`
    ➎。类似地，可以使用`bfd_section_size` ➏和`bfd_section_name` ➐分别获取节的大小和名称。如果节没有名称，`bfd_section_name`将返回`NULL`。
- en: The loader now copies the actual contents of the section into a `Section` object.
    To accomplish that, it reserves a `Section` in the `Binary` ➑ and copies all the
    fields it just read. Then, it allocates enough space in the `bytes` member of
    the `Section` to contain all of the bytes in the section ➒. If the `malloc` succeeds,
    it copies all the section bytes from the `libbfd` section object into the `Section`,
    using the `bfd_get_section_contents` function ➓. The arguments it takes are a
    `bfd` handle, a pointer to the `asection` object of interest, a destination array
    to contain the section contents, the offset at which to start copying, and the
    number of bytes to copy into the destination array. To copy all the bytes, the
    start offset is 0 and the number of bytes to copy is equal to the section size.
    If the copy succeeds, `bfd_get_section_contents` returns `true`; otherwise, it
    returns `false`. If all went well, the loading process is now complete!
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，加载器将节的实际内容复制到`Section`对象中。为此，它在`Binary` ➑中保留一个`Section`，并复制它刚刚读取的所有字段。然后，它在`Section`的`bytes`成员中分配足够的空间来容纳节中的所有字节
    ➒。如果`malloc`成功，它会使用`bfd_get_section_contents`函数 ➓将所有节字节从`libbfd`节对象复制到`Section`中。它所接受的参数包括`bfd`句柄、指向相关`asection`对象的指针、用于存储节内容的目标数组、复制的起始偏移量以及要复制的字节数。为了复制所有字节，起始偏移量为0，复制字节的数量等于节的大小。如果复制成功，`bfd_get_section_contents`返回`true`；否则返回`false`。如果一切顺利，加载过程就完成了！
- en: 4.4 Testing the Binary Loader
  id: totrans-82
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.4 测试二进制加载器
- en: Let’s create a simple program to test the new binary loader. The program will
    take the name of a binary as input, use the loader to load that binary, and then
    display some diagnostics about what it loaded. [Listing 4-9](ch04.xhtml#ch04list9)
    shows the code for the test program.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个简单的程序来测试新的二进制加载器。该程序将接受一个二进制文件名作为输入，使用加载器加载该二进制文件，然后显示关于加载内容的一些诊断信息。[清单
    4-9](ch04.xhtml#ch04list9)展示了测试程序的代码。
- en: '*Listing 4-9:* loader_demo.cc'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 4-9:* loader_demo.cc'
- en: '[PRE8]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: This test program loads the binary given to it as its first argument ➊ and then
    displays some basic information about the binary such as the filename, type, architecture,
    and entry point ➋. It then prints the base address, size, name, and type of every
    section ➌ and finally displays all of the symbols that were found ➍. It then unloads
    the binary and returns ➎. Try running the `loader_demo` program in the VM! You
    should see output similar to [Listing 4-10](ch04.xhtml#ch04list10).
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 这个测试程序加载作为第一个参数传递给它的二进制文件 ➊，然后显示一些关于该二进制文件的基本信息，如文件名、类型、架构和入口点 ➋。接着，它会打印每个节的基地址、大小、名称和类型
    ➌，最后显示所有找到的符号 ➍。然后，它会卸载二进制文件并返回 ➎。尝试在虚拟机中运行`loader_demo`程序！你应该看到类似于[清单 4-10](ch04.xhtml#ch04list10)的输出。
- en: '*Listing 4-10: Example output of the loader test program*'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 4-10: 加载器测试程序的示例输出*'
- en: '[PRE9]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 4.5 Summary
  id: totrans-89
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.5 总结
- en: In [Chapters 1](ch01.xhtml#ch01) through [3](ch03.xhtml#ch03), you learned all
    about binary formats. In this chapter, you learned how to load these binaries
    to prepare them for subsequent binary analysis. In the process, you also learned
    about `libbfd`, a commonly used library for loading binaries. Now that you have
    a functioning binary loader, you’re ready to move on to techniques for analyzing
    binaries. After an introduction to fundamental binary analysis techniques in [Part
    II](part2.xhtml) of this book, you’ll use the loader in [Part III](part3.xhtml)
    to implement your own binary analysis tools.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第 1 章](ch01.xhtml#ch01)到[第 3 章](ch03.xhtml#ch03)中，你学习了有关二进制格式的所有内容。在本章中，你学习了如何加载这些二进制文件，为后续的二进制分析做准备。在这个过程中，你还了解了`libbfd`，这是一个常用的二进制加载库。现在你已经拥有了一个功能齐全的二进制加载器，准备继续学习二进制分析技术。在本书的[第二部分](part2.xhtml)中，你将学习一些基本的二进制分析技术，在[第三部分](part3.xhtml)中，你将使用加载器来实现自己的二进制分析工具。
- en: Exercises
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 习题
- en: 1\. Dumping Section Contents
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 1\. 转储节内容
- en: For brevity, the current version of the `loader_demo` program doesn’t display
    section contents. Expand it with the ability to take a binary and the name of
    a section as input. Then dump the contents of that section to the screen in hexadecimal
    format.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简洁，当前版本的`loader_demo`程序没有显示段内容。扩展程序，使其能够接受一个二进制文件和一个段名作为输入，然后以十六进制格式将该段的内容转储到屏幕上。
- en: 2\. Overriding Weak Symbols
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 2\. 覆盖弱符号
- en: Some symbols are *weak*, which means that their value may be overridden by another
    symbol that isn’t weak. Currently, the binary loader doesn’t take this into account
    and simply stores all symbols. Expand the binary loader so that if a weak symbol
    is later overridden by another symbol, only the latest version is kept. Take a
    look at */usr/include/bfd.h* to figure out the flags to check for.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 有些符号是*弱的*，这意味着它们的值可能会被另一个非弱符号覆盖。目前，二进制加载器没有考虑这一点，而是简单地存储所有符号。扩展二进制加载器，使其在弱符号被其他符号覆盖时，仅保留最新版本。查看*/usr/include/bfd.h*以找出需要检查的标志。
- en: 3\. Printing Data Symbols
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 3\. 打印数据符号
- en: Expand the binary loader and the `loader_demo` program so that they can handle
    local and global data symbols as well as function symbols. You’ll need to add
    handling for data symbols in the loader, add a new `SymbolType` in the `Symbol`
    class, and add code to the `loader_demo` program to print the data symbols to
    screen. Be sure to test your modifications on a nonstripped binary to ensure the
    presence of some data symbols. Note that data items are called *objects* in symbol
    terminology. If you’re unsure about the correctness of your output, use `readelf`
    to verify it.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 扩展二进制加载器和`loader_demo`程序，使它们能够处理本地和全局数据符号以及函数符号。你需要在加载器中添加数据符号的处理，向`Symbol`类中添加一个新的`SymbolType`，并在`loader_demo`程序中添加代码，以将数据符号打印到屏幕上。务必在一个未剥离的二进制文件上测试你的修改，以确保数据符号的存在。请注意，数据项在符号术语中被称为*对象*。如果你对输出的正确性有疑问，可以使用`readelf`来验证。
