<html><head></head><body>
<section>
<header>
<h1 class="chapter">
<span class="ChapterNumber"><span epub:type="pagebreak" title="385" id="Page_385"/>16</span><br/>
<span class="ChapterTitle">Introduction to Compiling Software from C Source Code</span></h1>
</header>
<figure class="opener">
<img src="image_fi/book_art/chapterart.png" alt=""/>
</figure>
<p class="ChapterIntro">Most nonproprietary third-party Unix software packages come as source code that you can build and install. One reason for this is that Unix (and Linux itself) has so many different flavors and architectures, it would be difficult to distribute binary packages for all possible platform combinations. The other reason, which is at least as important, is that widespread source code distribution throughout the Unix community encourages users to contribute bug fixes and new features to software, giving meaning to the term <em>open sour</em><em>ce</em>.</p>
<p><span epub:type="pagebreak" title="386" id="Page_386"/>You can get nearly everything you see on a Linux system as source code—from the kernel and C library to the web browsers. It’s even possible to update and augment your entire system by (re-)installing parts of your system from the source code. However, you probably <em>shouldn’t</em> update your machine by installing <em>everything</em> from source code, unless you really enjoy the process or have some other reason. </p>
<p>Linux distributions typically provide easy ways to update core parts of the system, such as the programs in <em>/bin</em>, and one particularly important property of distributions is that they usually fix security problems very quickly. But don’t expect your distribution to provide everything for you. Here are some reasons why you might want to install certain packages yourself:</p>
<ul>
<li>To control configuration options.</li>
<li>To install the software anywhere you like. You can even install several different versions of the same package.</li>
<li>To control the version that you install. Distributions don’t always stay up to date with the latest versions of all packages, particularly add-ons to software packages (such as Python libraries).</li>
<li>To better understand how a package works.</li>
</ul>
<h2 id="h1-500402c16-0001">	16.1	Software Build Systems</h2>
<p class="BodyFirst">Many programming environments exist on Linux, from traditional C to interpreted scripting languages such as Python. Each typically has at least one distinct system for building and installing packages in addition to the tools that a Linux distribution provides.</p>
<p>We’re going to look at compiling and installing C source code in this chapter with only one of these build systems—the configuration scripts generated from the GNU autotools suite. This system is generally considered stable, and many of the basic Linux utilities use it. Because it’s based on existing tools such as <code>make</code>, after you see it in action, you’ll be able to transfer your knowledge to other build systems.</p>
<p>Installing a package from C source code usually involves the following steps: </p>
<ol class="decimal">
<li value="1">Unpack the source code archive. </li>
<li value="2">Configure the package. </li>
<li value="3">Run <code>make</code> or another build command to build the programs. </li>
<li value="4">Run <code>make install</code> or a distribution-specific install command to install the package. </li>
</ol>
<aside epub:type="sidebar">
<div class="top hr"><hr/></div>
<section class="note">
<h2><span class="NoteHead">NOTE</span></h2>
<p>	You should understand the basics in <span class="xref" itemid="xref_target_Chapter 15">Chapter 15</span> before proceeding with this chapter.</p>
<div class="bottom hr"><hr/></div>
</section>
</aside>
<h2 id="h1-500402c16-0002"><span epub:type="pagebreak" title="387" id="Page_387"/>	16.2	Unpacking C Source Packages</h2>
<p class="BodyFirst">A package’s source code distribution usually comes as a <em>.tar.gz</em>, <em>.tar.bz2</em>, or <em>.tar.xz</em> file, and you should unpack the file as described in <span class="xref" itemid="xref_target_Section 2.18">Section 2.18</span>. Before you unpack, though, verify the contents of the archive with <code>tar tvf</code> or <code>tar ztvf</code>, because some packages don’t create their own subdirectories in the directory where you extract the archive. </p>
<p>Output like this means that the package is probably okay to unpack: </p>
<pre><code>package-1.23/Makefile.in
package-1.23/README
package-1.23/main.c
package-1.23/bar.c
--<var>snip</var>--</code></pre>
<p>However, you might find that not all files are in a common directory (like <em>package-1.23</em> in the preceding example): </p>
<pre><code>Makefile
README
main.c
--<var>snip</var>--</code></pre>
<p>Extracting an archive like this one can leave a big mess in your current directory. To avoid that, create a new directory and <code>cd</code> there before extracting the contents of the archive. </p>
<p>Finally, beware of packages that contain files with absolute pathnames like this: </p>
<pre><code>/etc/passwd
/etc/inetd.conf</code></pre>
<p>You likely won’t come across anything like this, but if you do, remove the archive from your system. It probably contains a Trojan horse or some other malicious code. </p>
<p>Once you’ve extracted the contents of a source archive and have a bunch of files in front of you, try to get a feel for the package. In particular, look for the files named something like <em>README</em> and <em>INSTALL</em>. Always look at any <em>README</em> files first because they often contain a description of the package, a short manual, installation hints, and other useful information. Many packages also come with <em>INSTALL</em> files containing instructions on how to compile and install the package. Pay particular attention to special compiler options and definitions. </p>
<p>In addition to <em>README</em> and <em>INSTALL</em> files, you’ll find other package files that roughly fall into three categories:</p>
<ul>
<li>Files relating to the <code>make</code> system, such as <em>Makefile</em>, <em>Makefile.in</em>, <em>configure</em>, and <em>CMakeLists.txt</em>. Some very old packages come with a Makefile that you might need to modify, but most use a configuration utility, such as <span epub:type="pagebreak" title="388" id="Page_388"/>GNU autoconf or CMake. They come with a script or configuration file (such as <em>configure</em> or <em>CMakeLists.txt</em>) to help generate a Makefile from <em>Makefile.in</em> based on your system settings and configuration options. </li>
<li>Source code files ending in <em>.c</em>, <em>.h</em>, or <em>.cc</em>. C source code files may appear just about anywhere in a package directory. C++ source code files usually have <em>.cc</em>, <em>.C</em>, or <em>.cxx</em> suffixes. </li>
<li>Object files ending in <em>.o</em> or binaries. Normally, there aren’t any object files in source code distributions, but you might find some in rare cases when the package maintainer is not permitted to release certain source code and you need to do something special in order to use the object files. In most cases, object (or binary executable) files in a source distribution mean that the package wasn’t put together well, so you should run <code>make clean</code> to make sure that you get a fresh compile. </li>
</ul>
<h2 id="h1-500402c16-0003">	16.3	GNU Autoconf</h2>
<p class="BodyFirst">Even though C source code is usually fairly portable, differences on each platform make it impossible to compile most packages with a single Makefile. Early solutions to this problem were to provide individual Makefiles for every operating system or to provide a Makefile that was easy to modify. This approach evolved into scripts that generate Makefiles based on an analysis of the system used to build the package. </p>
<p>GNU autoconf is a popular system for automatic Makefile generation. Packages using this system come with files named <em>configure</em>, <em>Makefile.in</em>, and <em>config.h.in</em>. The <em>.in</em> files are templates; the idea is to run the <code>configure</code> script in order to discover the characteristics of your system, and then make substitutions in the <em>.in</em> files to create the real build files. For the end user, it’s easy; to generate a Makefile from <em>Makefile.in</em>, run <code>configure</code>: </p>
<pre><code>$ <b>./configure</b></code></pre>
<p>You should get a lot of diagnostic output as the script checks your system for prerequisites. If all goes well, <code>configure</code> creates one or more Makefiles and a <em>config.h</em> file, as well as a cache file (<em>config.cache</em>), so that it doesn’t need to run certain tests again.</p>
<p>Now you can run <code>make</code> to compile the package. A successful <code>configure</code> step doesn’t necessarily mean that the <code>make</code> step will work, but the chances are pretty good. (See <span class="xref" itemid="xref_target_Section 16.6">Section 16.6</span> for tips on troubleshooting failed configures and compiles.)</p>
<p>Let’s get some firsthand experience with the process.</p>
<aside epub:type="sidebar">
<div class="top hr"><hr/></div>
<section class="note">
<h2><span class="NoteHead">NOTE</span></h2>
<p>	At this point, you must have all of the required build tools available on your system. For Debian and Ubuntu, the easiest way to ensure this is to install the <var>build-essential</var> package; in Fedora-like systems, use the “Development Tools” <var>groupinstall</var>. </p>
<div class="bottom hr"><hr/></div>
</section>
</aside>
<h3 id="h2-500402c16-0001"><span epub:type="pagebreak" title="389" id="Page_389"/>16.3.1	 An Autoconf Example</h3>
<p class="BodyFirst">Before discussing how you can change the behavior of autoconf, let’s look at a simple example so that you know what to expect. You’ll install the GNU coreutils package in your own home directory (to make sure that you don’t mess up your system). Get the package from <a href="http://ftp.gnu.org/gnu/coreutils/" class="LinkURL">http://ftp.gnu.org/gnu/coreutils/</a> (the latest version is usually the best), unpack it, change to its directory, and configure it like this:</p>
<pre><code>$ ./<b>configure --prefix=$HOME/mycoreutils</b>
checking for a BSD-compatible install... /usr/bin/install -c
checking whether build environment is sane... yes
--<var>snip</var>--
config.status: executing po-directories commands
config.status: creating po/POTFILES
config.status: creating po/Makefile</code></pre>
<p>Now run <code class="bold">make</code>:</p>
<pre><code>$ <b>make</b>
  GEN      lib/alloca.h
  GEN      lib/c++defs.h
--<var>snip</var>--
make[2]: Leaving directory '/home/juser/coreutils-8.32/gnulib-tests'
make[1]: Leaving directory '/home/juser/coreutils-8.32'</code></pre>
<p>Next, try to run one of the executables you just created, such as <em>./src/ls</em>, and try running <code class="bold">make check</code> to run a series of tests on the package. (This might take a while, but it’s interesting to see.)</p>
<p>Finally, you’re ready to install the package. Do a dry run with <code class="bold">make -n</code> first to see what <code>make install</code> does without actually doing the install:</p>
<pre><code>$ <b>make -n install</b></code></pre>
<p>Browse through the output, and if nothing seems strange (such as the package installing anywhere other than your <em>mycoreutils</em> directory), do the install for real:</p>
<pre><code>$ <b>make install</b></code></pre>
<p>You should now have a subdirectory named <em>mycoreutils</em> in your home directory that contains <em>bin</em>, <em>share</em>, and other subdirectories. Check out some of the programs in <em>bin </em>(you just built many of the basic tools that you learned about in <span class="xref" itemid="xref_target_Chapter 2">Chapter 2</span>). Finally, because you configured the <em>mycoreutils</em> directory to be independent of the rest of your system, you can remove it completely without worrying about causing damage.</p>
<h3 id="h2-500402c16-0002"><span epub:type="pagebreak" title="390" id="Page_390"/>16.3.2	 Installation Using a Packaging Tool</h3>
<p class="BodyFirst">On most distributions, it’s possible to install new software as a package that you can maintain later with your distribution’s packaging tools. Debian-based distributions, such as Ubuntu, are perhaps the easiest; rather than running a plain <code>make install</code>, you install the package with the <code>checkinstall</code> utility, as follows:</p>
<pre><code># <b>checkinstall make install</b></code></pre>
<p>Running this command shows the settings pertaining to the package that you’re about to build, and gives you the opportunity to change them. When you proceed with the installation, <code>checkinstall</code> keeps track of all of the files to be installed on the system and puts them into a <em>.deb</em> file. You can then use <code>dpkg</code> to install (and remove) the new package.</p>
<p>Creating an RPM package is a little more involved, because you must first create a directory tree for your package(s). You can do this with the <code>rpmdev-setuptree</code> command; when complete, you can use the <code>rpmbuild</code> utility to work through the rest of the steps. It’s best to follow an online tutorial for this process.</p>
<h3 id="h2-500402c16-0003">16.3.3	 configure Script Options</h3>
<p class="BodyFirst">You’ve just seen one of the most useful options for the <code>configure</code> script: using <code>--prefix</code> to specify the installation directory. By default, the <code>install</code> target from an autoconf-generated Makefile uses a <em>prefix</em> of <em>/usr/local</em>—that is, binary programs go in <em>/usr/local/bin</em>, libraries go in <em>/usr/local/lib</em>, and so on. You will often want to change that prefix like this:</p>
<pre><code>$ <b>./configure --prefix=</b><var class="bold">new_prefix</var></code></pre>
<p>Most versions of <code>configure</code> have a <code>--help</code> option that lists other configuration options. Unfortunately, the list is usually so long that it’s sometimes hard to figure out what might be important, so here are some essential options: </p>
<ol class="none">
<li><span class="RunInHead"><code class="bold">--bindir=</code><var class="bold">directory</var></span>  Installs executables in <var>directory</var>. </li>
<li><span class="RunInHead"><code class="bold">--sbindir=</code><var class="bold">directory</var></span>  Installs system executables in <var>directory</var>. </li>
<li><span class="RunInHead"><code class="bold">--libdir=</code><var class="bold">directory</var></span>  Installs libraries in <var>directory</var>. </li>
<li><span class="RunInHead"><code class="bold">--disable-shared</code></span>  Prevents the package from building shared libraries. Depending on the library, this can save hassles later on (see <span class="xref" itemid="xref_target_Section 15.1.3">Section 15.1.3</span>). </li>
<li><span class="RunInHead"><code class="bold">--with-</code><var class="bold">package</var><code class="bold">=</code><var class="bold">directory</var></span>  Tells <code>configure</code> that <var>package</var> is in <var>directory</var>. This is handy when a necessary library is in a nonstandard location. Unfortunately, not all <code>configure</code> scripts recognize this type of option, and it can be difficult to determine the exact syntax. </li>
</ol>
<aside epub:type="sidebar">
<div class="top hr"><hr/></div>
<section class="box">
<h2><span epub:type="pagebreak" title="391" id="Page_391"/>Using Separate Build Directories</h2>
<p class="BoxBodyFirst">You can create separate build directories if you want to experiment with some of these options. To do so, create a new directory anywhere on the system and, from that directory, run the <code>configure</code> script in the original package source code directory. You’ll find that <code>configure</code> then makes a symbolic link farm in your new build directory, where all of the links point back to the source tree in the original package directory. (Some developers prefer that you build packages this way, because the original source tree is never modified. This is also useful if you want to build for more than one platform or configuration option set using the same source package.)</p>
<div class="bottom hr"><hr/></div>
</section>
</aside>
<h3 id="h2-500402c16-0004">16.3.4	 Environment Variables</h3>
<p class="BodyFirst">You can influence <code>configure</code> with environment variables that the <code>configure</code> script puts into <code>make</code> variables. The most important ones are <code>CPPFLAGS</code>, <code>CFLAGS</code>, and <code>LDFLAGS</code>. But be aware that <code>configure</code> can be very picky about environment variables. For example, you should normally use <code>CPPFLAGS</code> instead of <code>CFLAGS</code> for header file directories, because <code>configure</code> often runs the preprocessor independently of the compiler. </p>
<p>In <code>bash</code>, the easiest way to send an environment variable to <code>configure</code> is by placing the variable assignment in front of .<code>/configure</code> on the command line. For example, to define a <code>DEBUG</code> macro for the preprocessor, use this command:</p>
<pre><code><b>$ CPPFLAGS=-DDEBUG ./configure</b></code></pre>
<p>You can also pass a variable as an option to <code>configure</code>; for example:</p>
<pre><code><b>$ ./configure CPPFLAGS=-DDEBUG</b></code></pre>
<p>Environment variables are especially handy when <code>configure</code> doesn’t know where to look for third-party include files and libraries. For example, to make the preprocessor search in <var>include_dir</var>, run this command:</p>
<pre><code>$ <b>CPPFLAGS=-I</b><var class="bold">include_dir</var><b> ./configure</b></code></pre>
<p>As shown in <span class="xref" itemid="xref_target_Section 15.2.6">Section 15.2.6</span>, to make the linker look in <var>lib_dir</var>, use this command:</p>
<pre><code>$ <b>LDFLAGS=-L</b><var class="bold">lib_dir</var><b> ./configure</b></code></pre>
<p>If <var>lib_dir </var>has shared libraries (see <span class="xref" itemid="xref_target_Section 15.1.3">Section 15.1.3</span>), the previous command probably won’t set the runtime dynamic linker path. In that case, use the <code>-rpath</code> linker option in addition to <code>-L</code>: </p>
<pre><code>$ <b>LDFLAGS="-L</b><var class="bold">lib_dir</var><b> -Wl,-rpath=</b><var class="bold">lib_dir</var><b>" ./configure</b></code></pre>
<p><span epub:type="pagebreak" title="392" id="Page_392"/>Be careful when setting variables. A small slip can trip up the compiler and cause <code>configure</code> to fail. For example, say you forget the <code>-</code> in <code>-I</code>, as shown here: </p>
<pre><code>$ <b>CPPFLAGS=I</b><var class="bold">include_dir</var><b> ./configure</b></code></pre>
<p>This yields an error like this: </p>
<pre><code>configure: error: C compiler cannot create executables
See 'config.log' for more details</code></pre>
<p>Digging through the <em>config.log</em> generated from this failed attempt yields this: </p>
<pre><code>configure:5037: checking whether the C compiler works
configure:5059: gcc  Iinclude_dir  conftest.c  &gt;&amp;5
gcc: error: Iinclude_dir: No such file or directory
configure:5063: $? = 1
configure:5101: result: no</code></pre>
<h3 id="h2-500402c16-0005">16.3.5	 Autoconf Targets</h3>
<p class="BodyFirst">Once you get <code>configure</code> working, you’ll find that the Makefile it generates has a number of useful targets in addition to the standard <code>all</code> and <code>install</code>: </p>
<ol class="none">
<li><span class="RunInHead"><code class="bold">make clean</code></span>  As described in <span class="xref" itemid="xref_target_Chapter 15">Chapter 15</span>, this removes all object files, executables, and libraries. </li>
<li><span class="RunInHead"><code class="bold">make distclean</code></span>  This is similar to <code>make clean</code> except it removes all automatically generated files, including Makefiles, <em>config.h</em>, <em>config.log</em>, and so on. The idea is that the source tree should look like a newly unpacked distribution after running <code>make distclean</code>. </li>
<li><span class="RunInHead"><code class="bold">make check</code></span>  Some packages come with a battery of tests to verify that the compiled programs work properly; the command <code>make check</code> runs those tests. </li>
<li><span class="RunInHead"><code class="bold">make install-strip</code></span>  This is like <code>make install</code> except it strips the symbol table and other debugging information from executables and libraries when installing. Stripped binaries require much less space. </li>
</ol>
<h3 id="h2-500402c16-0006">16.3.6	 Autoconf Logfiles</h3>
<p class="BodyFirst">If something goes wrong during the configure process and the cause isn’t obvious, you can examine <em>config.log</em> to find the problem. Unfortunately, <em>config.log</em> is often a gigantic file, which can make it difficult to locate the exact source of the issue. </p>
<p>The general approach in this situation is to go to the very end of <em>config.log</em> (for example, by typing a capital <span class="KeyCaps">G</span> in <code>less</code>) and then page back up until you see the problem. However, there’s still a lot of stuff at the end because <code>configure</code> dumps its entire environment there, including output variables, cache variables, and other definitions. So, rather than <span epub:type="pagebreak" title="393" id="Page_393"/>going to the end and paging up, go to the end and search backward for a string, such as <code>for more details</code> or some other fragment of text near the end of the failed <code>configure</code> output. (Remember, you can initiate a reverse search in <code>less</code> with the <code>?</code> command.) There’s a good chance the error will be right above what your search finds.</p>
<h3 id="h2-500402c16-0007">16.3.7	 pkg-config</h3>
<p class="BodyFirst">The multitude of third-party libraries on a system means that keeping all of them in a common location can be messy. However, installing each with a separate prefix can lead to problems with building packages that require those third-party libraries. For example, if you want to compile OpenSSH, you need the OpenSSL library. How do you tell the OpenSSH configuration process the location of the OpenSSL libraries and which ones are required? </p>
<p>Many libraries now use the <code>pkg-config</code> program not only to advertise the locations of their include files and libraries but also to specify the exact flags you need to compile and link a program. The syntax is as follows:</p>
<pre><code>$ <b>pkg-config </b><var class="bold">options package1 package2 ...</var></code></pre>
<p>For example, to find the libraries required for a popular compression library, you can run this command:</p>
<pre><code>$ <b>pkg-config --libs zlib</b></code></pre>
<p>The output should look something like this: </p>
<pre><code>-lz</code></pre>
<p>To see all libraries that <code>pkg-config</code> knows about, including a brief description of each, run this command:</p>
<pre><code>$ <b>pkg-config --list-all</b></code></pre>
<h4 id="h3-500402c16-0001">How pkg-config Works</h4>
<p class="BodyFirst">If you look behind the scenes, you’ll find that <code>pkg-config</code> finds package information by reading configuration files that end with <em>.pc</em>. For example, here’s <em>openssl.pc</em> for the OpenSSL socket library, as seen on an Ubuntu system (located in <em>/usr/lib/x86_64-linux-gnu/pkgconfig</em>):</p>
<pre><code>prefix=/usr
exec_prefix=${prefix}
libdir=${exec_prefix}/lib/x86_64-linux-gnu
includedir=${prefix}/include

Name: OpenSSL
Description: Secure Sockets Layer and cryptography libraries and tools
Version: 1.1.1f
<span epub:type="pagebreak" title="394" id="Page_394"/>Requires: 
Libs: -L${libdir} -lssl -lcrypto
Libs.private: -ldl -lz
Cflags: -I${includedir} exec_prefix=${prefix}</code></pre>
<p>You can change this file, for example, by adding <code>-Wl,-rpath=${libdir}</code> to the library flags to set a runtime library search path. However, the bigger question is how <code>pkg-config</code> finds the <em>.pc</em> files in the first place. By default, <code>pkg-config</code> looks in the <em>lib/pkgconfig</em> directory of its installation prefix. For example, a <code>pkg-config</code> installed with a <em>/usr/local</em> prefix looks in <em>/usr/local/lib/pkgconfig</em>.</p>
<aside epub:type="sidebar">
<div class="top hr"><hr/></div>
<section class="note">
<h2><span class="NoteHead">NOTE</span></h2>
<p>	You won’t see <em>.pc</em> files for many packages unless you install the development packages. For example, to get <em>openssl.pc</em> on an Ubuntu system, you must install the <var>libssl-dev</var> package.</p>
<div class="bottom hr"><hr/></div>
</section>
</aside>
<h4 id="h3-500402c16-0002">How to Install pkg-config Files in Nonstandard Locations</h4>
<p class="BodyFirst">Unfortunately, by default, <code>pkg-config</code> doesn’t read any <em>.pc</em> files outside its installation prefix. This means that a <em>.pc</em> file that’s in a nonstandard location, such as <em>/opt/openssl/lib/pkgconfig/openssl.pc</em>, will be out of the reach of any stock <code>pkg-config</code> installation. There are two basic ways to make <em>.pc</em> files available outside the <code>pkg-config</code> installation prefix:</p>
<ul>
<li>Make symbolic links (or copies) from the actual <em>.pc</em> files to the central <em>pkgconfig</em> directory.</li>
<li>Set your <code>PKG_CONFIG_PATH</code> environment variable to include any extra <em>pkgconfig</em> directories. This strategy does not work well on a systemwide basis.</li>
</ul>
<h2 id="h1-500402c16-0004">	16.4	Installation Practice</h2>
<p class="BodyFirst">Knowing <em>how</em> to build and install software is good, but knowing <em>when</em> and <em>where</em> to install your own packages is even more useful. Linux distributions try to cram in as much software as possible at installation, so you should always check whether it would be better to install a package yourself instead. Here are the advantages of doing installs on your own: </p>
<ul>
<li>You can customize package defaults. </li>
<li>When installing a package, you often get a clearer picture of how to use it. </li>
<li>You control the release that you run. </li>
<li>It’s easier to back up a custom package. </li>
<li>It’s easier to distribute self-installed packages across a network (as long as the architecture is consistent and the installation location is relatively isolated). </li>
</ul>
<p><span epub:type="pagebreak" title="395" id="Page_395"/>Here are the disadvantages: </p>
<ul>
<li>If the package you want to install is already installed on your system, you might overwrite important files, causing problems. Avoid this by using the <em>/usr/local</em> install prefix, described shortly. Even if the package isn’t installed on your system, you should check to see if the distribution has a package available. If it does, you need to remember this in case you accidentally install the distribution package later.</li>
<li>It takes time. </li>
<li>Custom packages do not automatically upgrade themselves. Distributions keep most packages up to date without requiring much work from you. This is a particular concern for packages that interact with the network, because you want to ensure that you always have the latest security updates.</li>
<li>If you don’t actually use the package, you’re wasting your time. </li>
<li>There is a potential for misconfiguring packages. </li>
</ul>
<p>There’s not much point in installing packages such as those in the coreutils package you built earlier in the chapter (<code>ls</code>, <code>cat</code>, and so on) unless you’re building a very custom system. On the other hand, if you have a vital interest in network servers such as Apache, the best way to get complete control is to install the servers yourself. </p>
<h3 id="h2-500402c16-0008">16.4.1	 Where to Install</h3>
<p class="BodyFirst">The default prefix in GNU autoconf and many other packages is <em>/usr/local</em>, the traditional directory for locally installed software. Operating system upgrades ignore <em>/usr/local</em>, so you won’t lose anything installed there during an operating system upgrade, and for small local software installations, <em>/usr/local</em> is fine. The only problem is that if you have a lot of custom software installed, this can turn into a terrible mess. Thousands of odd little files can make their way into the <em>/usr/local</em> hierarchy, and you may have no idea where the files came from.</p>
<p>If things really start to get unruly, you should create your own packages as described in <span class="xref" itemid="xref_target_Section 16.3.2">Section 16.3.2</span>.</p>
<h2 id="h1-500402c16-0005">	16.5	Applying a Patch</h2>
<p class="BodyFirst">Most changes to software source code are available as branches of the developer’s online version of the source code (such as a Git repository). However, every now and then, you might get a <em>patch</em> that you need to apply against source code to fix bugs or add features. You may also see the term <em>diff</em> used as a synonym for patch, because the <code>diff</code> program produces the patch. </p>
<p>The beginning of a patch looks something like this: </p>
<pre><code>--- src/file.c.orig     2015-07-17 14:29:12.000000000 +0100
+++ src/file.c   2015-09-18 10:22:17.000000000 +0100
@@ -2,16 +2,12 @@</code></pre>
<p><span epub:type="pagebreak" title="396" id="Page_396"/>Patches usually contain alterations to more than one file. Search the patch for three dashes in a row (<code>---</code>) to see the files that have alterations and always look at the beginning of a patch to determine the required working directory. Notice that the preceding example refers to <em>src/file.c</em>. Therefore, you should change to the directory that contains <em>src</em> before applying the patch, <em>not</em> to the <em>src</em> directory itself. </p>
<p>To apply the patch, run the <code>patch</code> command: </p>
<pre><code>$ <b>patch -p0 &lt; </b><var class="bold">patch_file</var></code></pre>
<p>If everything goes well, <code>patch</code> exits without a fuss, leaving you with an updated set of files. However, <code>patch</code> might ask you this question: </p>
<pre><code>File to patch: </code></pre>
<p>This usually means you’re not in the correct directory, but it could also indicate that your source code doesn’t match the source code in the patch. In this case, you’re probably out of luck. Even if you could identify some of the files to patch, others would not be properly updated, leaving you with source code that you could not compile. </p>
<p>In some cases, you might come across a patch that refers to a package version like this: </p>
<pre><code>--- package-3.42/src/file.c.orig     2015-07-17 14:29:12.000000000 +0100
+++ package-3.42/src/file.c   2015-09-18 10:22:17.000000000 +0100</code></pre>
<p>If you have a slightly different version number (or you just renamed the directory), you can tell <code>patch</code> to strip leading path components. For example, say you were in the directory that contains <em>src</em> (as before). To tell <code>patch</code> to ignore the <em>package-3.42/</em> part of the path (that is, strip one leading path component), use <code>-p1</code>: </p>
<pre><code>$ <b>patch -p1 &lt; </b><var class="bold">patch_file</var></code></pre>
<h2 id="h1-500402c16-0006">	16.6	Troubleshooting Compiles and Installations</h2>
<p class="BodyFirst">If you understand the difference between compiler errors, compiler warnings, linker errors, and shared library problems as described in <span class="xref" itemid="xref_target_Chapter 15">Chapter 15</span>, you shouldn’t have too much trouble fixing many of the glitches that arise when you’re building software. This section covers some common problems. Although you’re unlikely to run into any of these issues when building using autoconf, it never hurts to know what they look like.</p>
<p>Before covering specifics, make sure that you can read certain kinds of <code>make</code> output. It’s important to know the difference between an error and an ignored error. The following is a real error that you need to investigate: </p>
<pre><code>make: *** [<var>target</var>] Error 1</code></pre>
<p><span epub:type="pagebreak" title="397" id="Page_397"/>However, some Makefiles suspect that an error condition might occur but know that these errors are harmless. You can usually disregard any messages like this: </p>
<pre><code>make: *** [<var>target</var>] Error 1 (ignored)</code></pre>
<p>Furthermore, GNU <code>make</code> often calls itself many times in large packages, with each instance of <code>make</code> in the error message marked with <code>[</code><var>N</var><code>]</code>, where <var>N</var> is a number. You can often quickly find the error by looking at the <code>make</code> error that comes <em>directly</em> after the compiler error message. For example: </p>
<pre><code><var>compiler error message involving </var>file.c
make[3]: *** [file.o] Error 1
make[3]: Leaving directory '/home/src/package-5.0/src'
make[2]: *** [all] Error 2
make[2]: Leaving directory '/home/src/package-5.0/src'
make[1]: *** [all-recursive] Error 1
make[1]: Leaving directory '/home/src/package-5.0/'
make: *** [all] Error 2</code></pre>
<p>The first three lines here give you the information you need. The trouble centers around <em>file.c</em>, located in <em>/home/src/package-5.0/src</em>. Unfortunately, there’s so much extra output that it can be difficult to spot the important details. Learning how to filter out the subsequent <code>make</code> errors goes a long way toward helping you dig out the real cause. </p>
<h3 id="h2-500402c16-0009">16.6.1	 Specific Errors</h3>
<p class="BodyFirst">Here are some common build errors that you might encounter.</p>
<p class="ListHead"><b>Problem</b></p>
<ol class="none">
<li>Compiler error message:
<pre><code>src.c:22: conflicting types for '<var>item</var>'
/usr/include/<var>file</var>.h:47: previous declaration of '<var>item</var>'</code></pre></li>
</ol>
<p class="ListHead"><b>Explanation and fix</b></p>
<ol class="none">
<li>The programmer made an erroneous redeclaration of <var>item</var> on line 22 of <em>src.c</em>. You can usually fix this by removing the offending line (with a comment, an <code>#ifdef</code>, or whatever works).</li>
</ol>
<p class="ListHead"><b>Problem</b></p>
<ol class="none">
<li>Compiler error message: 
<pre><code>src.c:37: 'time_t' undeclared (first use this function)
--<var>snip</var>--
src.c:37: parse error before '...'</code></pre></li>
</ol>
<p class="ListHead"><b><span epub:type="pagebreak" title="398" id="Page_398"/>Explanation and fix</b></p>
<ol class="none">
<li>The programmer forgot a critical header file. The manual pages are the best way to find the missing header file. First, look at the offending line (in this case, line 37 in <em>src.c</em>). It’s probably a variable declaration like the following: 
<pre><code>time_t v1;</code></pre>
<p class="ListBody">Search forward for <code>v1</code> in the program for its use around a function call. For example:</p>
<pre><code>v1 = time(NULL);</code></pre>
<p class="ListBody">Now run <code>man 2 time</code> or <code>man 3 time</code> to look for system and library calls named <code>time()</code>. In this case, the section 2 manual page has what you need: </p>
<pre><code>SYNOPSIS
      #include &lt;time.h&gt;

      time_t time(time_t *t);</code></pre>
<p class="ListBody">This means that <code>time()</code> requires <em>time.h</em>. Place <code>#include &lt;time.h&gt;</code> at the beginning of <em>src.c</em> and try again.</p></li>
</ol>
<p class="ListHead"><b>Problem</b></p>
<ol class="none">
<li>Compiler (preprocessor) error message:
<pre><code>src.c:4: <var>pkg</var>.h: No such file or directory
(long list of errors follows)</code></pre></li>
</ol>
<p class="ListHead"><b>Explanation and fix</b></p>
<ol class="none">
<li>The compiler ran the C preprocessor on <em>src.c</em> but could not find the <em>pkg.h</em> include file. The source code likely depends on a library that you need to install, or you may just need to provide the compiler with the nonstandard include path. Usually, you’ll just need to add a <code>-I</code> include path option to the C preprocessor flags (<code>CPPFLAGS</code>). (Keep in mind that you might also need a <code>-L</code> linker flag to go along with the include files.)
<p class="ListBody">If it doesn’t look as though you’re missing a library, there’s an outside chance you’re attempting a compile for an operating system that this source code does not support. Check the Makefile and <em>README</em> files for details about platforms.</p>
<p class="ListBody">If you’re running a Debian-based distribution, try the <code>apt-file</code> command on the header filename:</p>
<pre><code>$ <code class="bold">apt-file search</code> <var class="bold">pkg.h</var></code></pre>
<p class="ListBody"><span epub:type="pagebreak" title="399" id="Page_399"/>This might find the development package that you need. For distributions that use <code>yum</code>, you can try this instead:</p>
<pre><code>$ <code class="bold">yum provides */</code><var class="bold">pkg.h</var> </code></pre>
</li>
</ol>
<p class="ListHead"><b>Problem</b></p>
<ol class="none">
<li>The <code>make</code> error message: 
<pre><code>make: <var>prog:</var> Command not found</code></pre></li>
</ol>
<p class="ListHead"><b>Explanation and fix</b></p>
<ol class="none">
<li>To build the package, you need <var>prog</var> on your system. If <var>prog</var> is something like <code>cc</code>, <code>gcc</code>, or <code>ld</code>, you don’t have the development utilities installed on your system. On the other hand, if you think <var>prog</var> is already installed on your system, try altering the Makefile to specify the full pathname of <var>prog</var>. 
<p class="ListBody">In rare cases with poorly configured source code, <code>make</code> builds <var>prog</var> and then uses <var>prog</var> immediately, assuming that the current directory (<code>.</code>) is in your command path. If your <code>$PATH</code> does not include the current directory, you can edit the Makefile and change <var>prog</var> to <code>./</code><var>prog</var>. Alternatively, you could append <code>.</code> to your path temporarily. </p></li>
</ol>
<h2 id="h1-500402c16-0007">	16.7	Looking Forward</h2>
<p class="BodyFirst">We’ve touched only on the basics of building software. After you get the hang of your own builds, try the following:</p>
<ul>
<li>Learn how to use build systems other than autoconf, such as CMake and SCons. </li>
<li>Set up builds for your own software. If you’re writing your own software, you want to choose a build system and learn to use it. For GNU autoconf packaging, <em>Autotools</em>, 2nd edition, by John Calcote (No Starch Press, 2019) can help you out.</li>
<li>Compile the Linux kernel. The kernel’s build system is completely different from that of other tools. It has its own configuration system tailored to customizing your own kernel and modules. The procedure is straightforward, though, and if you understand how the bootloader works, you won’t have any trouble with it. However, you should be careful when doing so; make sure that you always keep your old kernel handy in case you can’t boot with a new one.</li>
<li>Explore distribution-specific source packages. Linux distributions maintain their own versions of software source code as special source packages. Sometimes you can find useful patches that expand functionality or fix problems in otherwise unmaintained packages. The source package management systems include tools for automatic builds, such as Debian’s <code>debuild</code> and the RPM-based <code>mock</code>.</li>
</ul>
<p><span epub:type="pagebreak" title="400" id="Page_400"/>Building software is often a stepping stone to learning about programming and software development. The tools you’ve seen in this chapter and the previous chapter take the mystery out of where your system software came from. It’s not difficult to take the next steps of looking inside the source code, making changes, and creating your own software.</p>
</section>
</body></html>