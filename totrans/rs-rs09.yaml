- en: '9'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Unsafe Code
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/chapterart.png)'
  prefs: []
  type: TYPE_IMG
- en: The mere mention of unsafe code often elicits strong responses from many in
    the Rust community, and from many of those watching Rust from the sidelines. While
    some maintain it’s “no big deal,” others decry it as “the reason all of Rust’s
    promises are a lie.” In this chapter, I hope to pull back the curtain a bit to
    explain what `unsafe` is, what it isn’t, and how you should go about using it
    safely. At the time of writing, and likely also when you read this, Rust’s precise
    requirements for unsafe code are still being determined, and even if they were
    all nailed down, the complete description would be beyond the scope of this book.
    Instead, I’ll do my best to arm you with the building blocks, intuition, and tooling
    you’ll need to navigate your way through most unsafe code.
  prefs: []
  type: TYPE_NORMAL
- en: 'Your main takeaway from this chapter should be this: unsafe code is the mechanism
    Rust gives developers for taking advantage of invariants that, for whatever reason,
    the compiler cannot check. We’ll look at the ways in which `unsafe` does that,
    what those invariants may be, and what we can do with it as a result.'
  prefs: []
  type: TYPE_NORMAL
- en: Crucially, unsafe code is not a way to skirt the various rules of Rust, like
    borrow checking, but rather a way to enforce those rules using reasoning that
    is beyond the compiler. When you write unsafe code, the onus is on you to ensure
    that the resulting code is safe. In a way, `unsafe` is misleading as a keyword
    when it is used to allow unsafe operations through `unsafe {}`; it’s not that
    the contained code *is* unsafe, it’s that the code is allowed to perform otherwise
    unsafe operations because in this particular context, those operations *are* safe.
  prefs: []
  type: TYPE_NORMAL
- en: The rest of this chapter is split into four sections. We’ll start with a brief
    examination of how the keyword itself is used, then explore what `unsafe` allows
    you to do. Next, we’ll look at the rules you must follow in order to write safe
    unsafe code. Finally, I’ll give you some advice about how to actually go about
    writing unsafe code safely.
  prefs: []
  type: TYPE_NORMAL
- en: The unsafe Keyword
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Before we discuss the powers that `unsafe` grants you, we need to talk about
    its two different meanings. The `unsafe` keyword serves a dual purpose in Rust:
    it marks a particular function as unsafe to call *and* it enables you to invoke
    unsafe functionality in a particular code block. For example, the method in [Listing
    9-1](#listing9-1) is marked as unsafe, even though it contains no unsafe code.
    Here, the `unsafe` keyword serves as a warning to the caller that there are additional
    guarantees that someone who writes code that invokes `decr` must manually check.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 9-1: An unsafe method that contains only safe code'
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 9-2](#listing9-2) illustrates the second usage. Here, the method itself
    is not marked as unsafe, even though it contains unsafe code.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 9-2: A safe method that contains unsafe code'
  prefs: []
  type: TYPE_NORMAL
- en: These two listings differ in their use of `unsafe` because they embody different
    contracts. `decr` requires the caller to be careful when they call the method,
    whereas `as_ref` assumes that the caller *was* careful when invoking other unsafe
    methods (like `decr`). To see why, imagine that `SomeType` is really a reference-counted
    type like `Rc`. Even though `decr` only decrements a number, that decrement may
    in turn trigger undefined behavior through the safe method `as_ref`. If you call
    `decr` and then drop the second-to-last `Rc` of a given `T`, the reference count
    drops to zero and the `T` will be dropped—but the program might still call `as_ref`
    on the last `Rc`, and end up with a dangling reference.
  prefs: []
  type: TYPE_NORMAL
- en: Conversely, as long as there is no way to corrupt the `Rc` reference count using
    safe code, it is always safe to dereference the pointer inside the `Rc` the way
    the code for `as_ref` does—the fact that `&self` exists is proof that the pointer
    must still be valid. We can use this to give the caller a safe API to an otherwise
    unsafe operation, which is a core piece of how to use `unsafe` responsibly.
  prefs: []
  type: TYPE_NORMAL
- en: For historical reasons, every `unsafe fn` contains an implicit unsafe block
    in Rust today. That is, if you declare an `unsafe fn`, you can always invoke any
    unsafe methods or primitive operations inside that `fn`. However, that decision
    is now considered a mistake, and it’s currently being reverted through the already
    accepted and implemented RFC 2585\. This RFC warns about having an `unsafe fn`
    that performs unsafe operations without an explicit unsafe block inside it. The
    lint will also likely become a hard error in future editions of Rust. The idea
    is to reduce the “footgun radius”—if every `unsafe fn` is one giant unsafe block,
    then you might accidentally perform unsafe operations without realizing it! For
    example, in `decr` in [Listing 9-1](#listing9-1), under the current rules you
    could also have added `*std::ptr::null()` without any `unsafe` annotation.
  prefs: []
  type: TYPE_NORMAL
- en: The distinction between `unsafe` as a marker and unsafe blocks as a mechanism
    to enable unsafe operations is important, because you must think about them differently.
    An `unsafe fn` indicates to the caller that they have to be careful when calling
    the `fn` in question and that they must ensure that the function’s documented
    safety invariants hold.
  prefs: []
  type: TYPE_NORMAL
- en: Meanwhile, an unsafe block implies that whoever wrote that block carefully checked
    that the safety invariants for any unsafe operations performed inside it hold.
    If you want an approximate real-world analogy, `unsafe fn` is an unsigned contract
    that asks the author of calling code to “solemnly swear X, Y, and Z.” Meanwhile,
    `unsafe {}` is the calling code’s author signing off on all the unsafe contracts
    contained within the block. Keep that in mind as we go through the rest of this
    chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Great Power
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: So, once you sign the unsafe contract with `unsafe {}`, what are you allowed
    to do? Honestly, not that much. Or rather, it doesn’t enable that many new features.
    Inside an unsafe block, you are allowed to dereference raw pointers and call `unsafe
    fn`s.
  prefs: []
  type: TYPE_NORMAL
- en: That’s it. Technically, there are a few other things you can do, like accessing
    mutable and external static variables and accessing fields of unions, but those
    don’t change the discussion much. And honestly, that’s enough. Together, these
    powers allow you to wreak all sorts of havoc, like turning types into one another
    with `mem::transmute`, dereferencing raw pointers that point to who knows where,
    casting `&'a` to `&'static`, or making types shareable across thread boundaries
    even though they’re not thread-safe.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we won’t worry too much about what can go wrong with these
    powers. We’ll leave that for the boring, responsible, grown-up section that comes
    after. Instead, we’ll look at these neat shiny new toys and what we can do with
    them.
  prefs: []
  type: TYPE_NORMAL
- en: Juggling Raw Pointers
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'One of the most fundamental reasons to use `unsafe` is to deal with Rust’s
    raw pointer types: `*const T` and `*mut T`. You should think of these as more
    or less analogous to `&T` and `&mut T`, except that they don’t have lifetimes
    and are not subject to the same validity rules as their `&` counterparts, which
    we’ll discuss later in the chapter. These types are interchangeably referred to
    as *pointers* and *raw pointers*,mostly because many developers instinctively
    refer to references as pointers, and calling them raw pointers makes the distinction
    clearer.'
  prefs: []
  type: TYPE_NORMAL
- en: Since fewer rules apply to `*` than `&`, you can cast a reference to a pointer
    even outside an unsafe block. Only if you want to go the other way, from `*` to
    `&`, do you need `unsafe`. You’ll generally turn a pointer back into a reference
    to do useful things with the pointed-to data, such as reading or modifying its
    value. For that reason, a common operation to use on pointers is `unsafe { &*ptr
    }` (or `&mut *`). The `*` there may look strange as the code is just constructing
    a reference, not dereferencing the pointer, but it makes sense if you look at
    the types; if you have a `*mut T` and want a `&mut T`, then `&mut ptr` would just
    give you a `&mut *mut T`. You need the `*` to indicate that you want the mutable
    reference to what `ptr` is a pointer *to*.
  prefs: []
  type: TYPE_NORMAL
- en: Unrepresentable Lifetimes
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: As raw pointers do not have lifetimes, they can be used in circumstances where
    the liveness of the value being pointed to cannot be expressed statically within
    Rust’s lifetime system, such as a self-pointer in a self-referential struct like
    the generators we discussed in Chapter 8. A pointer that points into `self` is
    valid for as long as `self` is around (and doesn’t move, which is what `Pin` is
    for), but that isn’t a lifetime you can generally name. And while the entire self-referential
    type may be `'static`, the self-pointer isn’t—if it were static, then even if
    you gave away that pointer to someone else, they could continue to use it forever,
    even after `self` was gone! Take the type in [Listing 9-3](#listing9-3) as an
    example; here we attempt to store the raw bytes that make up a value alongside
    its stored representation.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 9-3: Trying, and failing, to name the lifetime of a self-referential
    reference'
  prefs: []
  type: TYPE_NORMAL
- en: The reference inside `Person` wants to refer to data stored in `bytes` in `Parsed`,
    but there is no lifetime we can assign to that reference from `Parsed`. It’s not
    `'static` or something like `'self` (which doesn’t exist), because if `Parsed`
    is moved, the reference is no longer valid.
  prefs: []
  type: TYPE_NORMAL
- en: Since pointers do not have lifetimes, they circumvent this problem because you
    don’t have to be able to name the lifetime. Instead, you just have to make sure
    that when you do use the pointer, it’s still valid, which is what you sign off
    on when you write `unsafe { &*ptr }`. In the example in [Listing 9-3](#listing9-3),
    `Person` would instead store a `*const str` and then unsafely turn that into a
    `&str` at the appropriate times when it can guarantee that the pointer is still
    valid.
  prefs: []
  type: TYPE_NORMAL
- en: A similar issue arises with a type like `Arc`, which has a pointer to a value
    that’s shared for some duration, but that duration is known only at runtime when
    the last `Arc` is dropped. The pointer is kind-of, sort-of `'static`, but not
    really—like in the self-referential case, the pointer is no longer valid when
    the last `Arc` reference goes away, so the lifetime is more like `'self`. In `Arc`’s
    cousin, `Weak`, the lifetime is also “when the last `Arc` goes away,” but since
    a `Weak` isn’t an `Arc`, the lifetime isn’t even tied to `self`. So, `Arc` and
    `Weak` both use raw pointers internally.
  prefs: []
  type: TYPE_NORMAL
- en: Pointer Arithmetic
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: With raw pointers, you can do arbitrary pointer arithmetic, just like you can
    in C, by using `.offset()`, `.add()`, and `.sub()` to move the pointer to any
    byte that lives within the same allocation. This is most often used in highly
    space-optimized data structures, like hash tables, where storing an extra pointer
    for each element would add too much overhead and using slices isn’t possible.
    Those are fairly niche use cases, and we won’t be talking more about them in this
    book, but I encourage you to read the code for `hashbrown::RawTable` ([https://github.com/rust-lang/hashbrown/](https://github.com/rust-lang/hashbrown/))
    if you want to learn more!
  prefs: []
  type: TYPE_NORMAL
- en: The pointer arithmetic methods are unsafe to call even if you don’t want to
    turn the pointer into a reference afterwards. There are a couple of reasons for
    this, but the main one is that it is illegal to make a pointer point beyond the
    end of the allocation that it originally pointed to. Doing so triggers undefined
    behavior, and the compiler is allowed to decide to eat your code and replace it
    with arbitrary nonsense that only a compiler could understand. If you do use these
    methods, read the documentation carefully!
  prefs: []
  type: TYPE_NORMAL
- en: To Pointer and Back Again
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Often when you need to use pointers, it’s because you have some normal Rust
    type, like a reference, a slice, or a string, and you have to move to the world
    of pointers for a bit and then go back to the original normal type. Some of the
    key standard library types therefore provide you with a way to turn them into
    their raw constituent parts, such as a pointer and a length for a slice, and a
    way to turn them back into the whole using those same parts. For example, you
    can get a slice’s data pointer with `as_ptr` and its length with `[]::len`. You
    can then reconstruct the slice by providing those same values to `std::slice::from_raw_parts`.
    `Vec`, `Arc`, and `String` have similar methods that return a raw pointer to the
    underlying allocation, and `Box` has `Box::into_raw` and `Box::from_raw`, which
    do the same thing.
  prefs: []
  type: TYPE_NORMAL
- en: Playing Fast and Loose with Types
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Sometimes, you have a type `T` and want to treat it as some other type `U`.
    Whether that’s because you need to do lightning-fast zero-copy parsing or because
    you need to fiddle with some lifetimes, Rust provides you with some (very unsafe)
    tools to do so.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first and by far most widely used of these is pointer casting: you can
    cast a `*const T` to any other `*const U` (and the same for `mut`), and you don’t
    even need `unsafe` to do it. The unsafety comes into play only when you later
    try to use the cast pointer as a reference, as you have to assert that the raw
    pointer can in fact be used as a reference to the type it’s pointing to.'
  prefs: []
  type: TYPE_NORMAL
- en: This kind of pointer type casting comes in particularly handy when working with
    foreign function interfaces (FFI)—you can cast any Rust pointer to a `*const std::ffi::c_void`
    or `*mut std::ffi::c_void`, and then pass that to a C function that expects a
    void pointer. Similarly, if you get a void pointer from C that you previously
    passed in, you can trivially cast it back into its original type.
  prefs: []
  type: TYPE_NORMAL
- en: Pointer casts are also useful when you want to interpret a sequence of bytes
    as plain old data—types like integers, Booleans, characters, and arrays, or `#[repr(C)]`
    structs of these—or write such types directly out as a byte stream without serialization.
    There are a lot of safety invariants to keep in mind if you want to try to do
    that, but we’ll leave that for later.
  prefs: []
  type: TYPE_NORMAL
- en: Calling Unsafe Functions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Arguably `unsafe`’s most commonly used feature is that it enables you to call
    unsafe functions. Deeper down the stack, most of those functions are unsafe because
    they operate on raw pointers at some fundamental level, but higher up the stack
    you tend to interact with unsafety primarily through function calls.
  prefs: []
  type: TYPE_NORMAL
- en: 'There’s really no limit to what calling an unsafe function might enable, as
    it is entirely up to the libraries you interact with. But *in general*, unsafe
    functions can be divided into three camps: those that interact with non-Rust interfaces,
    those that skip safety checks, and those that have custom invariants.'
  prefs: []
  type: TYPE_NORMAL
- en: Foreign Function Interfaces
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Rust lets you declare functions and static variables that are defined in a language
    other than Rust using `extern` blocks (which we’ll discuss at length in Chapter
    11). When you declare such a block, you’re telling Rust that the items appearing
    within it will be implemented by some external source when the final program binary
    is linked, such as a C library you are integrating with. Since `extern`s exist
    outside of Rust’s control, they are inherently unsafe to access. If you call a
    C function from Rust, all bets are off—it might overwrite your entire memory contents
    and clobber all your neatly arranged references into random pointers into the
    kernel somewhere. Similarly, an `extern` static variable could be modified by
    external code at any time, and could be filled with all sorts of bad bytes that
    don’t reflect its declared type at all. In an unsafe block, though, you can access
    `extern`s to your heart’s delight, as long as you’re willing to vouch for the
    other side of the extern behaving according to Rust’s rules.
  prefs: []
  type: TYPE_NORMAL
- en: I’ll Pass on Safety Checks
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Some unsafe operations can be made entirely safe by introducing additional runtime
    checks. For example, accessing an item in a slice is unsafe since you might try
    to access an item beyond the length of the slice. But, given how common the operation
    is, it’d be unfortunate if indexing into a slice was unsafe. Instead, the safe
    implementation includes bounds checks that (depending on the method you use) either
    panic or return an `Option` if the index you provide is out of bounds. That way,
    there is no way to cause undefined behavior even if you pass in an index beyond
    the slice’s length. Another example is in hash tables, which hash the key you
    provide rather than letting you provide the hash yourself; this ensures that you’ll
    never try to access a key using the wrong hash.
  prefs: []
  type: TYPE_NORMAL
- en: However, in the endless pursuit of ultimate performance, some developers may
    find these safety checks add just a little too much overhead in their tightest
    loops. To cater to situations where peak performance is paramount and the caller
    knows that the indexes are in bounds, many data structures provide alternate versions
    of particular methods without these safety checks. Such methods usually include
    the word `unchecked` in the name to indicate that they blindly trust the provided
    arguments to be safe and that they do not do any of those pesky, slow safety checks.
    Some examples are `NonNull::new_unchecked`, `slice::get_unchecked`, `NonZero::new_unchecked`,
    `Arc::get_mut_unchecked`, and `str::from_utf8_unchecked`.
  prefs: []
  type: TYPE_NORMAL
- en: In practice, the safety and performance trade-off forunchecked methods is rarely
    worth it. As always with performance optimization, measure first, then optimize.
  prefs: []
  type: TYPE_NORMAL
- en: Custom Invariants
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Most uses of `unsafe` rely on custom invariants to some degree. That is, they
    rely on invariants beyond those provided by Rust itself, which are specific to
    the particular application or library. Since so many functions fall into this
    category, it’s hard to give a good general summary of this class of unsafe functions.
    Instead, I’ll give some examples of unsafe functions with custom invariants that
    you may come across in practice and want to use:'
  prefs: []
  type: TYPE_NORMAL
- en: '**`MaybeUninit::assume_init`**'
  prefs: []
  type: TYPE_NORMAL
- en: The `MaybeUninit` type is one of the few ways in which you can store values
    that are not valid for their type in Rust. You can think of a `MaybeUninit<T>`
    as a `T` that may not be legal to use as a `T` at the moment. For example, a `MaybeUninit<NonNull>`
    is allowed to hold a null pointer, a `MaybeUninit<Box>` is allowed to hold a dangling
    heap pointer, and a ``MaybeUninit<bool> is allowed to hold the bit pattern for
    the number 3 (normally it must be 0 or 1). This comes in handy if you are constructing
    a value bit by bit or are dealing with zeroed or uninitialized memory that will
    eventually be made valid (such as by being filled through a call to `std::io::Read::read`).
    The `assume_init` function asserts that the `MaybeUninit` now holds a valid value
    for the type `T` and can therefore be used as a `T`.``
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
