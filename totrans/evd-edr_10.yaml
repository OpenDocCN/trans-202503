- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">10</samp> <samp class="SANS_Dogma_OT_Bold_B_11">ANTIMALWARE
    SCAN INTERFACE</samp>
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '![](../images/opener-img.png)'
  prefs: []
  type: TYPE_IMG
- en: As security vendors began building effective tools for detecting the deployment
    and execution of compiled malware, attackers were left searching for alternative
    methods to execute their code. One of the tactics they discovered is the creation
    of script-based, or *fileless*, malware, which relies on the use of tools built
    into the operating system to execute code that will give the attacker control
    over the system.
  prefs: []
  type: TYPE_NORMAL
- en: To help protect users against these novel threats, Microsoft introduced the
    *Antimalware Scan Interface (AMSI)* with the release of Windows 10\. AMSI provides
    an interface that allows application developers to leverage antimalware providers
    registered on the system when determining if the data with which they are working
    is malicious.
  prefs: []
  type: TYPE_NORMAL
- en: AMSI is an omnipresent security feature in today’s operating environments. Microsoft
    has instrumented many of the scripting engines, frameworks, and applications that
    we, as attackers, routinely target. Nearly every EDR vendor ingests events from
    AMSI, and some go so far as to attempt to detect attacks that tamper with the
    registered providers. This chapter covers the history of AMSI, its implementation
    in different Windows components, and the diverse world of AMSI evasions.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">The Challenge of Script-Based Malware</samp>
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Scripting languages offer a large number of advantages over compiled languages.
    They require less development time and overhead, bypass application allow-listing,
    can execute in memory, and are portable. They also provide the ability to use
    the features of frameworks such as .NET and, oftentimes, direct access to the
    Win32 API, which greatly extends the functionality of the scripting language.
  prefs: []
  type: TYPE_NORMAL
- en: While script-based malware existed in the wild prior to AMSI’s creation, the
    2015 release of Empire, a command-and-control framework built around PowerShell,
    made its use mainstream in the offensive world. Because of its ease of use, default
    integration into Windows 7 and above, and large amount of existing documentation,
    PowerShell became the de facto language for offensive tool development for many.
  prefs: []
  type: TYPE_NORMAL
- en: 'This boom in script-based malware caused a large defensive gap. Previous tools
    relied on the fact that malware would be dropped to disk and executed. They fell
    short when faced with malware that ran a Microsoft-signed executable installed
    on the system by default, sometimes referred to as *living-off-the-land*, such
    as PowerShell. Even agents that attempted to detect the invocation of malicious
    scripts struggled, as attackers could easily adapt their payloads and tools to
    evade the detection techniques employed by vendors. Microsoft itself highlights
    this problem in its blog post announcing AMSI, which provides the following example.
    Say that a defensive product searched a script for the string “malware” to determine
    whether it was malicious. It would detect the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Once malware authors became aware of this detection logic, they could bypass
    the detection mechanism using something as simple as string concatenation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: To combat this, developers would attempt some basic type of language emulation.
    For example, they might concatenate strings before scanning the contents of the
    script block. Unfortunately, this approach is prone to error, as languages often
    have many different ways to represent data, and cataloging them all for emulation
    is very difficult. Antimalware developers did have some success with the technique,
    however. As a result, malware developers raised the complexity of their obfuscation
    slightly with techniques such as encoding. The example in [Listing 10-1](#list10-1)
    shows the string “malware” encoded using Base64 in PowerShell.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 10-1: Decoding a Base64 string in PowerShell'
  prefs: []
  type: TYPE_NORMAL
- en: Agents again leveraged language emulation to decode data in the script and scan
    it for malicious content. To combat this success, malware developers moved from
    simple encoding to encryption and algorithmic encoding, such as with exclusive-or
    (XOR). For example, the code in [Listing 10-2](#list10-2) first decodes the Base64-encoded
    data and then uses the two-byte key <samp class="SANS_TheSansMonoCd_W5Regular_11">gg</samp>
    to XOR the decoded bytes.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 10-2: An XOR example in PowerShell'
  prefs: []
  type: TYPE_NORMAL
- en: This trend toward encryption exceeded what the antimalware engines could reasonably
    emulate, so detections based on the presence of the obfuscation techniques themselves
    became commonplace. This presents its own challenges, due to the fact that normal,
    benign scripts sometimes employ what may look like obfuscation. The example Microsoft
    put forward in its post, and one that became the standard for executing PowerShell
    code in memory, is the download cradle in [Listing 10-3](#list10-3).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 10-3: A simple PowerShell download cradle'
  prefs: []
  type: TYPE_NORMAL
- en: In this example, the .NET <samp class="SANS_TheSansMonoCd_W5Regular_11">Net.Webclient</samp>
    class is used to download a PowerShell script from an arbitrary site. When this
    script is downloaded, it isn’t written to disk but rather lives as a string in
    memory tied to the <samp class="SANS_TheSansMonoCd_W5Regular_11">Webclient</samp>
    object. From here, the adversary uses the <samp class="SANS_TheSansMonoCd_W5Regular_11">Invoke-Expression</samp>
    cmdlet to run this string as a PowerShell command. This technique results in whatever
    action the payload may take, such as deploying a new command-and-control agent,
    occurring entirely in memory.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">How AMSI Works</samp>
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: AMSI scans a target, then uses antimalware providers registered on the system
    to determine whether it is malicious. By default, it uses the antimalware provider
    Microsoft Defender IOfficeAntivirus (*MpOav.dll*), but third-party EDR vendors
    may also register their own providers. Duane Michael maintains a list of security
    vendors who register AMSI providers in his “whoamsi” project on GitHub.
  prefs: []
  type: TYPE_NORMAL
- en: You’ll most commonly find AMSI used by applications that include scripting engines
    (for example, those that accept arbitrary scripts and execute them using the associated
    engine), work with untrusted buffers in memory, or interact with non-PE executable
    code, such as *.docx* and *.pdf* files. AMSI is integrated into many Windows components,
    including modern versions of PowerShell, .NET, JavaScript, VBScript, Windows Script
    Host, Office VBA macros, and User Account Control. It is also integrated into
    Microsoft Exchange.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Exploring PowerShell’s
    AMSI Implementation</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Because PowerShell is open source, we can examine its AMSI implementation to
    understand how Windows components use this tool. In this section, we explore how
    AMSI attempts to restrict this application from executing malicious scripts.
  prefs: []
  type: TYPE_NORMAL
- en: Inside *System.Management.Automation.dll*, the DLL that provides the runtime
    for hosting PowerShell code, there exists a non-exported function called <samp
    class="SANS_TheSansMonoCd_W5Regular_11">PerformSecurityChecks()</samp> that is
    responsible for scanning the supplied script block and determining whether it
    is malicious. This function is called by the command processor created by PowerShell
    as part of the execution pipeline just before compilation. The call stack in [Listing
    10-4](#list10-4), captured in dnSpy, demonstrates the path the script block follows
    until it is scanned.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 10-4: The call stack during the scanning of a PowerShell script block'
  prefs: []
  type: TYPE_NORMAL
- en: This function calls an internal utility, <samp class="SANS_TheSansMonoCd_W5Regular_11">AmsiUtils.ScanContent()</samp>,
    passing in the script block or file to be scanned. This utility is a simple wrapper
    for another internal function, <samp class="SANS_TheSansMonoCd_W5Regular_11">AmsiUtils.WinScanContent()</samp>,
    where all the real work takes place.
  prefs: []
  type: TYPE_NORMAL
- en: After checking the script block for the European Institute for Computer Antivirus
    Research (EICAR) test string, which all antiviruses must detect, <samp class="SANS_TheSansMonoCd_W5Regular_11">WinScanContent</samp>’s
    first action is to create a new AMSI session via a call to <samp class="SANS_TheSansMonoCd_W5Regular_11">amsi!AmsiOpenSession()</samp>.
    AMSI sessions are used to correlate multiple scan requests. Next, <samp class="SANS_TheSansMonoCd_W5Regular_11">WinScanContent()</samp>
    calls <samp class="SANS_TheSansMonoCd_W5Regular_11">amsi!AmsiScanBuffer()</samp>,
    the Win32 API function that will invoke the AMSI providers registered on the system
    and return the final determination regarding the maliciousness of the script block.
    [Listing 10-5](#list10-5) shows this implementation in PowerShell, with the irrelevant
    bits trimmed.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 10-5: PowerShell’s AMSI implementation'
  prefs: []
  type: TYPE_NORMAL
- en: In Powershell, the code first calls <samp class="SANS_TheSansMonoCd_W5Regular_11">amsi!AmsiOpenSession()</samp>
    ❶ to create a new AMSI session in which scan requests can be correlated. If the
    session opens successfully, the data to be scanned is passed to <samp class="SANS_TheSansMonoCd_W5Regular_11">amsi!AmsiScanBuffer()</samp>
    ❷, which does the actual evaluation of the data to determine if the contents of
    the buffer appear to be malicious. The result of this call is returned to <samp
    class="SANS_TheSansMonoCd_W5Regular_11">WinScanContent()</samp>.
  prefs: []
  type: TYPE_NORMAL
- en: 'The <samp class="SANS_TheSansMonoCd_W5Regular_11">WinScanContent()</samp> function
    can return one of three values:'
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">AMSI_RESULT_NOT_DETECTED</samp>   A
    neutral result
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">AMSI_RESULT_CLEAN</samp>   A result
    indicating that the script block did not contain malware
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">AMSI_RESULT_DETECTED</samp>   A
    result indicating that the script block contained malware
  prefs: []
  type: TYPE_NORMAL
- en: If either of the first two results is returned, indicating that AMSI could not
    determine the maliciousness of the script block or found it not to be dangerous,
    the script block will be allowed to execute on the system. If, however, the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">AMSI_RESULT_DETECTED</samp> result is
    returned, a <samp class="SANS_TheSansMonoCd_W5Regular_11">ParseException</samp>
    will be thrown, and execution of the script block will be halted. [Listing 10-6](#list10-6)
    shows how this logic is implemented inside PowerShell.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 10-6: Throwing a <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">ParseError</samp>
    on malicious script detection'
  prefs: []
  type: TYPE_NORMAL
- en: Because AMSI threw an exception ❶, the execution of the script halts and the
    error shown in the <samp class="SANS_TheSansMonoCd_W5Regular_11">ParseError</samp>
    will be returned to the user. [Listing 10-7](#list10-7) shows the error the user
    will see in the PowerShell window.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 10-7: The thrown error shown to the user'
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Understanding AMSI
    Under the Hood</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: While understanding how AMSI is instrumented in system components provides useful
    context for how user-supplied input is evaluated, it doesn’t quite tell the whole
    story. What happens when PowerShell calls <samp class="SANS_TheSansMonoCd_W5Regular_11">amsi!AmsiScanBuffer()</samp>?
    To understand this, we must dive deep into the AMSI implementation itself. Because
    the state of C++ decompilers at the time of this writing makes static analysis
    a bit tricky, we’ll need to use some dynamic analysis techniques. Thankfully,
    WinDbg makes this process relatively painless, especially considering that debug
    symbols are available for *amsi.dll*.
  prefs: []
  type: TYPE_NORMAL
- en: When PowerShell starts, it first calls <samp class="SANS_TheSansMonoCd_W5Regular_11">amsi!AmsiInitialize()</samp>.
    As its name suggests, this function is responsible for initializing the AMSI API.
    This initialization primarily centers on the creation of a COM class factory via
    a call to <samp class="SANS_TheSansMonoCd_W5Regular_11">DllGetClassObject()</samp>.
    As an argument, it receives the class identifier correlating to *amsi.dll*, along
    with the interface identified for the <samp class="SANS_TheSansMonoCd_W5Regular_11">IClassFactory</samp>,
    which enables a class of objects to be created. The interface pointer is then
    used to create an instance of the <samp class="SANS_TheSansMonoCd_W5Regular_11">IAntimalware</samp>
    interface (<samp class="SANS_TheSansMonoCd_W5Regular_11">{82d29c2e-f062-44e6-b5c9-3d9a2f24a2df}</samp>),
    shown in [Listing 10-8](#list10-8).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 10-8: Creating an instance of <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">IAntimalware</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: Rather than an explicit call to some functions, you’ll occasionally find references
    to <samp class="SANS_TheSansMonoCd_W5Regular_11">_guard_dispatch_icall_fptr()</samp>.
    This is a component of Control Flow Guard (CFG), an anti-exploit technology that
    attempts to prevent indirect calls, such as in the event of return-oriented programming.
    In short, this function checks the Control Flow Guard bitmap of the source image
    to determine if the function to be called is a valid target. In the context of
    this section, the reader can treat these as simple <samp class="SANS_TheSansMonoCd_W5Regular_11">CALL</samp>
    instructions to reduce confusion.
  prefs: []
  type: TYPE_NORMAL
- en: This call then eventually leads into <samp class="SANS_TheSansMonoCd_W5Regular_11">amsi!AmsiComCreateProviders</samp><samp
    class="SANS_TheSansMonoCd_W5Regular_11"><</samp><samp class="SANS_TheSansMonoCd_W5Regular_11">IAntimalwareProvider></samp>,
    where all the magic happens. [Listing 10-9](#list10-9) shows the call stack for
    this method inside WinDbg.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 10-9: The call stack for the <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">AmsiComCreateProviders</samp>
    function'
  prefs: []
  type: TYPE_NORMAL
- en: The first major action is a call to <samp class="SANS_TheSansMonoCd_W5Regular_11">amsi!CGuidEnum::StartEnum()</samp>.
    This function receives the string <samp class="SANS_TheSansMonoCd_W5Regular_11">"Software\\Microsoft\\AMSI\\Providers"</samp>,
    which it passes into a call to <samp class="SANS_TheSansMonoCd_W5Regular_11">RegOpenKey()</samp>
    and then <samp class="SANS_TheSansMonoCd_W5Regular_11">RegQueryInfoKeyW()</samp>
    in order to get the number of subkeys. Then, <samp class="SANS_TheSansMonoCd_W5Regular_11">amsi!CGuidEnum::NextGuid()</samp>
    iterates through the subkeys and converts the class identifiers of registered
    AMSI providers from strings to UUIDs. After enumerating all the required class
    identifiers, it passes execution to <samp class="SANS_TheSansMonoCd_W5Regular_11">amsi!AmsiComSecureLoadInProcServer()</samp>,
    where the <samp class="SANS_TheSansMonoCd_W5Regular_11">InProcServer32</samp>
    value corresponding to the AMSI provider is queried via <samp class="SANS_TheSansMonoCd_W5Regular_11">RegGetValueW()</samp>.
    [Listing 10-10](#list10-10) shows this process for *MpOav.dll*.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 10-10: The parameters passed to <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">RegGetValueW</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: Next, <samp class="SANS_TheSansMonoCd_W5Regular_11">amsi!CheckTrustLevel()</samp>
    is called to check the value of the registry key *SOFTWARE\Microsoft\AMSI\FeatureBits*.
    This key contains a DWORD, which can be either <samp class="SANS_TheSansMonoCd_W5Regular_11">1</samp>
    (the default) or <samp class="SANS_TheSansMonoCd_W5Regular_11">2</samp> to disable
    or enable Authenticode signing checks for providers. If Authenticode signing checks
    are enabled, the path listed in the <samp class="SANS_TheSansMonoCd_W5Regular_11">InProcServer32</samp>
    registry key is verified. Following a successful check, the path is passed into
    <samp class="SANS_TheSansMonoCd_W5Regular_11">LoadLibraryW()</samp> to load the
    AMSI provider DLL, as demonstrated in [Listing 10-11](#list10-11).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 10-11: The MpOav.dll loaded via <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">LoadLibraryW()</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: 'If the provider DLL loads successfully, its <samp class="SANS_TheSansMonoCd_W5Regular_11">DllRegisterServer()</samp>
    function is called to tell it to create registry entries for all COM classes supported
    by the provider. This cycle repeats calls to <samp class="SANS_TheSansMonoCd_W5Regular_11">amsi!CGuidEnum::NextGuid()</samp>
    until all providers are loaded. [Listing 10-12](#list10-12) shows the final step:
    invoking the <samp class="SANS_TheSansMonoCd_W5Regular_11">QueryInterface()</samp>
    method for each provider in order to get a pointer to the <samp class="SANS_TheSansMonoCd_W5Regular_11">IAntimalware</samp>
    interfaces.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 10-12: Calling <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">QueryInterface</samp>
    on the registered provider'
  prefs: []
  type: TYPE_NORMAL
- en: After <samp class="SANS_TheSansMonoCd_W5Regular_11">AmsiInitialize()</samp>
    returns, AMSI is ready to go. Before PowerShell begins evaluating a script block,
    it calls <samp class="SANS_TheSansMonoCd_W5Regular_11">AmsiOpenSession()</samp>.
    As mentioned previously, this function allows AMSI to correlate multiple scans.
    When this function completes, it returns a <samp class="SANS_TheSansMonoCd_W5Regular_11">HAMSISESSION</samp>
    to the caller, and the caller can choose to pass this value to all subsequent
    calls to AMSI within the current scanning session.
  prefs: []
  type: TYPE_NORMAL
- en: When PowerShell’s AMSI instrumentation receives a script block and an AMSI session
    has been opened, it calls <samp class="SANS_TheSansMonoCd_W5Regular_11">AmsiScanBuffer()</samp>
    with the script block passed as input. This function is defined in [Listing 10-13](#list10-13).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 10-13: The <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">AmsiScanBuffer()</samp>
    definition'
  prefs: []
  type: TYPE_NORMAL
- en: The function’s primary responsibility is to check the validity of the parameters
    passed to it. This includes checks for content in the input buffer and the presence
    of a valid <samp class="SANS_TheSansMonoCd_W5Regular_11">HAMSICONTEXT</samp> handle
    with a tag of <samp class="SANS_TheSansMonoCd_W5Regular_11">AMSI</samp>, as you
    can see in the decompilation in [Listing 10-14](#list10-14). If any of these checks
    fail, the function returns <samp class="SANS_TheSansMonoCd_W5Regular_11">E_INVALIDARG</samp>
    (0x80070057) to the caller.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 10-14: Internal <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">AmsiScanBuffer()</samp>
    sanity checks'
  prefs: []
  type: TYPE_NORMAL
- en: If these checks pass, AMSI invokes <samp class="SANS_TheSansMonoCd_W5Regular_11">amsi!CAmsiAntimalware::Scan()</samp>,
    as shown in the call stack in [Listing 10-15](#list10-15).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 10-15: The <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">Scan()</samp>
    method called'
  prefs: []
  type: TYPE_NORMAL
- en: This method contains a <samp class="SANS_TheSansMonoCd_W5Regular_11">while</samp>
    loop that iterates over every registered AMSI provider (the count of which is
    stored at <samp class="SANS_TheSansMonoCd_W5Regular_11">R14</samp> + <samp class="SANS_TheSansMonoCd_W5Regular_11">0x1c0</samp>).
    In this loop, it calls the <samp class="SANS_TheSansMonoCd_W5Regular_11">IAntimalwareProvider::Scan()</samp>
    function, which the EDR vendor can implement however they wish; it is only expected
    to return an <samp class="SANS_TheSansMonoCd_W5Regular_11">AMSI_RESULT</samp>,
    defined in [Listing 10-16](#list10-16).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 10-16: The <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">CAmsiAntimalware::Scan()</samp>
    function definition'
  prefs: []
  type: TYPE_NORMAL
- en: In the case of the default Microsoft Defender AMSI implementation, *MpOav.dll*,
    this function performs some basic initialization and then hands execution over
    to *MpClient.dll*, the Windows Defender client interface. Note that Microsoft
    doesn’t supply program database files for Defender components, so *MpOav.dll*’s
    function name in the call stack in [Listing 10-17](#list10-17) is incorrect.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 10-17: Execution passed to MpClient.dll from MpOav.dll'
  prefs: []
  type: TYPE_NORMAL
- en: AMSI passes the result of the scan back to <samp class="SANS_TheSansMonoCd_W5Regular_11">amsi!AmsiScanBuffer()</samp>
    via <samp class="SANS_TheSansMonoCd_W5Regular_11">amsi!CAmsiAntimalware::Scan()</samp>,
    which in turn returns the <samp class="SANS_TheSansMonoCd_W5Regular_11">AMSI_RESULT</samp>
    to the caller. If the script block was found to contain malicious content, PowerShell
    throws a <samp class="SANS_TheSansMonoCd_W5Regular_11">ScriptContainedMaliciousContent</samp>
    exception and prevents its execution.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Implementing a Custom
    AMSI Provider</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As mentioned in the previous section, developers can implement the <samp class="SANS_TheSansMonoCd_W5Regular_11">IAntimalwareProvider::Scan()</samp>
    function however they like. For example, they could simply log information about
    the content to be scanned, or they could pass the contents of a buffer through
    a trained machine-learning model to evaluate its maliciousness. To understand
    the shared architecture of all vendors’ AMSI providers, this section steps through
    the design of a simple provider DLL that meets the minimum specifications defined
    by Microsoft.
  prefs: []
  type: TYPE_NORMAL
- en: 'At their core, AMSI providers are nothing more than *COM servers*, or DLLs
    loaded into a host process that expose a function required by the caller: in this
    case, <samp class="SANS_TheSansMonoCd_W5Regular_11">IAntimalwareProvider</samp>.
    This function extends the <samp class="SANS_TheSansMonoCd_W5Regular_11">IUnknown</samp>
    interface by adding three additional methods: <samp class="SANS_TheSansMonoCd_W5Regular_11">CloseSession</samp>
    closes the AMSI session via its <samp class="SANS_TheSansMonoCd_W5Regular_11">HAMSISESSION</samp>
    handle, <samp class="SANS_TheSansMonoCd_W5Regular_11">DisplayName</samp> displays
    the name of the AMSI provider, and <samp class="SANS_TheSansMonoCd_W5Regular_11">Scan</samp>
    scans an <samp class="SANS_TheSansMonoCd_W5Regular_11">IAmsiStream</samp> of content
    and returns an <samp class="SANS_TheSansMonoCd_W5Regular_11">AMSI_RESULT</samp>.'
  prefs: []
  type: TYPE_NORMAL
- en: In C++, a basic class declaration that overrides <samp class="SANS_TheSansMonoCd_W5Regular_11">IAntimalwareProvider</samp>’s
    methods may look something like the code shown in [Listing 10-18](#list10-18).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 10-18: An example <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">IAntimalwareProvider</samp>
    class definition'
  prefs: []
  type: TYPE_NORMAL
- en: Our code makes use of the Windows Runtime C++ Template Library, which reduces
    the amount of code used to create COM components. The <samp class="SANS_TheSansMonoCd_W5Regular_11">CloseSession()</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">DisplayName()</samp> methods
    are simply overridden with our own functions to close the AMSI session and return
    the name of the AMSI provider, respectively. The <samp class="SANS_TheSansMonoCd_W5Regular_11">Scan()</samp>
    function receives the buffer to be scanned as part of an <samp class="SANS_TheSansMonoCd_W5Regular_11">IAmsiStream</samp>,
    which exposes two methods, <samp class="SANS_TheSansMonoCd_W5Regular_11">GetAttribute()</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">Read()</samp>, and is defined
    in [Listing 10-19](#list10-19).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 10-19: The <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">IAmsiStream</samp>
    class definition'
  prefs: []
  type: TYPE_NORMAL
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">GetAttribute()</samp> retrieves
    metadata about the contents to be scanned. Developers request these attributes
    by passing an <samp class="SANS_TheSansMonoCd_W5Regular_11">AMSI_ATTRIBUTE</samp>
    value that indicates what information they would like to retrieve, along with
    an appropriately sized buffer. The <samp class="SANS_TheSansMonoCd_W5Regular_11">AMSI_ATTRIBUTE</samp>
    value is an enumeration defined in [Listing 10-20](#list10-20).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 10-20: The <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">AMSI_ATTRIBUTE</samp>
    enumeration'
  prefs: []
  type: TYPE_NORMAL
- en: 'While there are 10 attributes in the enumeration, Microsoft documents only
    the first five: <samp class="SANS_TheSansMonoCd_W5Regular_11">AMSI_ATTRIBUTE_APP_NAME</samp>
    is a string containing the name, version, or GUID of the calling application;
    <samp class="SANS_TheSansMonoCd_W5Regular_11">AMSI_ATTRIBUTE_CONTENT_NAME</samp>
    is a string containing the filename, URL, script ID, or equivalent identifier
    of the content to be scanned; <samp class="SANS_TheSansMonoCd_W5Regular_11">AMSI_ATTRIBUTE_CONTENT_SIZE</samp>
    is a <samp class="SANS_TheSansMonoCd_W5Regular_11">ULONGLONG</samp> containing
    the size of the data to be scanned; <samp class="SANS_TheSansMonoCd_W5Regular_11">AMSI_ATTRIBUTE_CONTENT_ADDRESS</samp>
    is the memory address of the content, if it has been fully loaded into memory;
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">AMSI_ATTRIBUTE_SESSION</samp>
    contains a pointer to the next portion of the content to be scanned or <samp class="SANS_TheSansMonoCd_W5Regular_11">NULL</samp>
    if the content is self-contained.'
  prefs: []
  type: TYPE_NORMAL
- en: As an example, [Listing 10-21](#list10-21) shows how an AMSI provider might
    use this attribute to retrieve the application name.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 10-21: An implementation of the AMSI scanning function'
  prefs: []
  type: TYPE_NORMAL
- en: When PowerShell calls this example function, <samp class="SANS_TheSansMonoCd_W5Regular_11">pszAppName</samp>
    ❶ will contain the application name as a string, which AMSI can use to enrich
    the scan data. This becomes particularly useful if the script block is deemed
    malicious, as the EDR could use the application name to terminate the calling
    process.
  prefs: []
  type: TYPE_NORMAL
- en: If <samp class="SANS_TheSansMonoCd_W5Regular_11">AMSI_ATTRIBUTE_CONTENT_ADDRESS</samp>
    returns a memory address, we know that the content to be scanned has been fully
    loaded into memory, so we can interact with it directly. Most often, the data
    is provided as a stream, in which case we use the <samp class="SANS_TheSansMonoCd_W5Regular_11">Read()</samp>
    method (defined in [Listing 10-22](#list10-22)) to retrieve the contents of the
    buffer one chunk at a time. We can define the size of these chunks, which get
    passed, along with a buffer of the same size, to the <samp class="SANS_TheSansMonoCd_W5Regular_11">Read()</samp>
    method.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 10-22: The <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">IAmsiStream::Read()</samp>
    method definition'
  prefs: []
  type: TYPE_NORMAL
- en: What the provider does with these chunks of data is completely up to the developer.
    They could scan each chunk, read the full stream, and hash its contents, or simply
    log details about it. The only rule is that, when the <samp class="SANS_TheSansMonoCd_W5Regular_11">Scan()</samp>
    method returns, it must pass an <samp class="SANS_TheSansMonoCd_W5Regular_11">HRESULT</samp>
    and an <samp class="SANS_TheSansMonoCd_W5Regular_11">AMSI_RESULT</samp> to the
    caller.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Evading AMSI</samp>
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: AMSI is one of the most-studied areas when it comes to evasion. This is due
    in no small part to how effective it was in its early days, causing significant
    headaches for offensive teams that used PowerShell heavily. For them, AMSI presented
    an existential crisis that prevented their main agents from functioning.
  prefs: []
  type: TYPE_NORMAL
- en: Attackers can employ a variety of evasion techniques to bypass AMSI. While certain
    vendors have attempted to flag some of these as malicious, the number of evasion
    opportunities present in AMSI is staggering, so vendors usually can’t handle all
    of them. This section covers some of the more popular evasions in today’s operating
    environment, but bear in mind that there are many variations to each of these
    techniques.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">String Obfuscation</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: One of the earliest evasions for AMSI involved simple string obfuscation. If
    an attacker could determine which part of a script block was being flagged as
    malicious, they could often get around the detection by splitting, encoding, or
    otherwise obscuring the string, as in the example in [Listing 10-23](#list10-23).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 10-23: An example of string obfuscation in PowerShell that evades AMSI'
  prefs: []
  type: TYPE_NORMAL
- en: AMSI typically flags the string <samp class="SANS_TheSansMonoCd_W5Regular_11">AmsiScanBuffer</samp>,
    a common component of patching-based evasions, as malicious, but here you can
    see that string concatenation allows us to bypass detection. AMSI implementations
    often receive obfuscated code, which they pass off to providers to determine if
    it is malicious. This means the provider must handle language-emulation functions
    such as string concatenation, decoding, and decrypting. However, many providers,
    including Microsoft, fail to detect even trivial bypasses such as the one shown
    here.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">AMSI Patching</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Because AMSI and its associated providers get mapped into the attacker’s process,
    the attacker has control over this memory. By patching critical values or functions
    inside *amsi.dll*, they can prevent AMSI from functioning inside their process.
    This evasion technique is extremely potent and has been the go-to choice for many
    red teams since around 2016, when Matt Graeber discussed using reflection inside
    PowerShell to patch <samp class="SANS_TheSansMonoCd_W5Regular_11">amsiInitFailed</samp>
    to <samp class="SANS_TheSansMonoCd_W5Regular_11">true</samp>. His code, included
    in [Listing 10-24](#list10-24), fit into a single tweet.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 10-24: A simple <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">AmsiInitFailed</samp>
    patch'
  prefs: []
  type: TYPE_NORMAL
- en: 'When it comes to patching, attackers commonly target <samp class="SANS_TheSansMonoCd_W5Regular_11">AmsiScanBuffer()</samp>,
    the function responsible for passing buffer contents to the providers. Daniel
    Duggan describes this technique in a blog post, “Memory Patching AMSI Bypass,”
    where he outlines the steps an attacker’s code must take before performing any
    truly malicious activity:'
  prefs: []
  type: TYPE_NORMAL
- en: Retrieve the address of <samp class="SANS_TheSansMonoCd_W5Regular_11">AmsiScanBuffer()</samp>
    within the *amsi.dll* currently loaded into the process.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Use <samp class="SANS_TheSansMonoCd_W5Regular_11">kernel32!VirtualProtect()</samp>
    to change the memory protections to read-write, which allows the attacker to place
    the patch.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Copy the patch into the entry point of the <samp class="SANS_TheSansMonoCd_W5Regular_11">AmsiScanBuffer()</samp>
    function.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Use <samp class="SANS_TheSansMonoCd_W5Regular_11">kernel32!VirtualProtect()</samp>
    once again to revert the memory protection back to read-execute.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The patch itself takes advantage of the fact that, internally, <samp class="SANS_TheSansMonoCd_W5Regular_11">AmsiScanBuffer()</samp>
    returns <samp class="SANS_TheSansMonoCd_W5Regular_11">E_INVALIDARG</samp> if its
    initial checks fail. These checks include attempts to validate the address of
    the buffer to be scanned. Duggan’s code adds a byte array that represents the
    assembly code in [Listing 10-25](#list10-25). After this patch, when <samp class="SANS_TheSansMonoCd_W5Regular_11">AmsiScanBuffer()</samp>
    is executed, it will immediately return this error code because the actual instruction
    that made up the original function has been overwritten.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 10-25: Error code returned to the caller of <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">AmsiScanBuffer()</samp>
    after the patch'
  prefs: []
  type: TYPE_NORMAL
- en: There are many variations of this technique, all of which work very similarly.
    For example, an attacker may patch <samp class="SANS_TheSansMonoCd_W5Regular_11">AmsiOpenSession()</samp>
    instead of <samp class="SANS_TheSansMonoCd_W5Regular_11">AmsiScanBuffer()</samp>.
    They may also opt to corrupt one of the parameters passed into <samp class="SANS_TheSansMonoCd_W5Regular_11">AmsiScanBuffer()</samp>,
    such as the buffer length or the context, causing AMSI to return <samp class="SANS_TheSansMonoCd_W5Regular_11">E_INVALIDARG</samp>
    on its own.
  prefs: []
  type: TYPE_NORMAL
- en: Microsoft got wise to this evasion technique pretty quickly and took measures
    to defend against the bypass. One of the detections it implemented is based on
    the sequence of opcodes that make up the patch we’ve described. However, attackers
    can work around these detections in many ways. For example, they can simply modify
    their assembly code to achieve the same result, moving <samp class="SANS_TheSansMonoCd_W5Regular_11">0x80070057</samp>
    into <samp class="SANS_TheSansMonoCd_W5Regular_11">EAX</samp> and returning, in
    a way that is less direct. Consider the example in [Listing 10-26](#list10-26),
    which breaks up the value <samp class="SANS_TheSansMonoCd_W5Regular_11">0x80070057</samp>
    instead of moving it into the register all at once.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 10-26: Breaking up hardcoded values to evade patch detection'
  prefs: []
  type: TYPE_NORMAL
- en: Imagine that the EDR looks for the value <samp class="SANS_TheSansMonoCd_W5Regular_11">0x80070057</samp>
    being moved into the <samp class="SANS_TheSansMonoCd_W5Regular_11">EAX</samp>
    register. This evasion strategy would bypass its detection logic because the value
    is never directly referenced. Instead, it is broken up into two values, which
    happen to add up to the required value.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">A Patchless AMSI
    Bypass</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In April 2022, Ceri Coburn unveiled a technique for bypassing AMSI without patching
    *amsi.dll*, an activity many EDR vendors have begun to monitor. Coburn’s technique
    doesn’t require fork&run either, allowing the attacker to stay in their original
    process.
  prefs: []
  type: TYPE_NORMAL
- en: The technique is quite clever. First, the attacker obtains a function pointer
    to <samp class="SANS_TheSansMonoCd_W5Regular_11">amsi!AmsiScanBuffer()</samp>
    either from the loaded *amsi.dll* or by forcing it to load into the process through
    a call to <samp class="SANS_TheSansMonoCd_W5Regular_11">LoadLibrary()</samp>.
    Next, they register a vectored exception handler via <samp class="SANS_TheSansMonoCd_W5Regular_11">kernel32!AddVectoredExceptionHandler()</samp>.
    This handler allows developers to register a function that monitors and manages
    all exceptions in the application. Finally, they set a hardware breakpoint on
    the address of <samp class="SANS_TheSansMonoCd_W5Regular_11">AmsiScanBuffer()</samp>
    by modifying the current thread’s debug registers (<samp class="SANS_TheSansMonoCd_W5Regular_11">DR0</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">DR6</samp>, and <samp class="SANS_TheSansMonoCd_W5Regular_11">DR7</samp>).
  prefs: []
  type: TYPE_NORMAL
- en: When the attacker executes their .NET code inline, the system will eventually
    call <samp class="SANS_TheSansMonoCd_W5Regular_11">AmsiScanBuffer()</samp>, triggering
    the hardware breakpoint and invoking the vectored exception handler. This function
    takes the current thread context and updates the registers to match the values
    set when AMSI doesn’t detect malicious content, namely a return value of <samp
    class="SANS_TheSansMonoCd_W5Regular_11">0 (S-OK)</samp> in <samp class="SANS_TheSansMonoCd_W5Regular_11">RAX</samp>
    and a result of <samp class="SANS_TheSansMonoCd_W5Regular_11">0 (AMSI_RESULT_CLEAN)</samp>
    in <samp class="SANS_TheSansMonoCd_W5Regular_11">RS</samp><samp class="SANS_TheSansMonoCd_W5Regular_11">P+</samp><samp
    class="SANS_TheSansMonoCd_W5Regular_11">48</samp>.
  prefs: []
  type: TYPE_NORMAL
- en: Additionally, it pulls the return address from the stack (<samp class="SANS_TheSansMonoCd_W5Regular_11">RSP</samp>)
    and points the instruction pointer (<samp class="SANS_TheSansMonoCd_W5Regular_11">RIP</samp>)
    back to the caller of the <samp class="SANS_TheSansMonoCd_W5Regular_11">AmsiScanBuffer()</samp>
    function. Next, it walks the stack pointer back to its position from before the
    call to <samp class="SANS_TheSansMonoCd_W5Regular_11">AmsiScanBuffer()</samp>,
    clears the hardware breakpoint, and returns the <samp class="SANS_TheSansMonoCd_W5Regular_11">EXCEPTION_CONTINUE_EXECUTION</samp>
    code. Execution resumes at the point at which the breakpoint occurred. Now Windows
    will take the attacker’s modified thread context and continue execution with our
    changes in place, passing the falsified values back to the caller and letting
    the malicious code continue undetected.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Conclusion</samp>
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: AMSI is an incredibly important piece of the host-based detection puzzle. Its
    integration into software such as PowerShell, .NET, and Microsoft Office means
    that it sits inline of many adversary activities, from initial access through
    post-exploitation. AMSI has been heavily researched due to its tremendous impact
    on offensive operations at the time of its release. Today, AMSI fills more of
    a supplementary role, as nearly countless evasion strategies exist for it. However,
    vendors have caught on to this and have begun to invest in monitoring for common
    AMSI evasion strategies, then using those as indicators of adversary activity
    themselves.
  prefs: []
  type: TYPE_NORMAL
