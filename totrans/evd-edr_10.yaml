- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">10</samp> <samp class="SANS_Dogma_OT_Bold_B_11">ANTIMALWARE
    SCAN INTERFACE</samp>
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">10</samp> <samp class="SANS_Dogma_OT_Bold_B_11">恶意软件扫描接口</samp>
- en: '![](../images/opener-img.png)'
  id: totrans-1
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/opener-img.png)'
- en: As security vendors began building effective tools for detecting the deployment
    and execution of compiled malware, attackers were left searching for alternative
    methods to execute their code. One of the tactics they discovered is the creation
    of script-based, or *fileless*, malware, which relies on the use of tools built
    into the operating system to execute code that will give the attacker control
    over the system.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 随着安全厂商开始构建有效的工具来检测编译恶意软件的部署和执行，攻击者开始寻找其他方法来执行他们的代码。他们发现的一种战术是创建基于脚本的或*无文件*恶意软件，这依赖于操作系统内置工具的使用，以执行能够让攻击者控制系统的代码。
- en: To help protect users against these novel threats, Microsoft introduced the
    *Antimalware Scan Interface (AMSI)* with the release of Windows 10\. AMSI provides
    an interface that allows application developers to leverage antimalware providers
    registered on the system when determining if the data with which they are working
    is malicious.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 为了帮助保护用户免受这些新型威胁，微软在发布 Windows 10 时引入了*恶意软件扫描接口（AMSI）*。AMSI 提供了一个接口，允许应用程序开发者在确定其处理的数据是否恶意时，利用系统上注册的恶意软件防护提供商。
- en: AMSI is an omnipresent security feature in today’s operating environments. Microsoft
    has instrumented many of the scripting engines, frameworks, and applications that
    we, as attackers, routinely target. Nearly every EDR vendor ingests events from
    AMSI, and some go so far as to attempt to detect attacks that tamper with the
    registered providers. This chapter covers the history of AMSI, its implementation
    in different Windows components, and the diverse world of AMSI evasions.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: AMSI 是当今操作环境中无处不在的安全特性。微软已经为我们这些攻击者经常针对的许多脚本引擎、框架和应用程序进行了相应的配置。几乎所有的 EDR 厂商都会采集
    AMSI 的事件，有些甚至会尝试检测那些篡改注册提供商的攻击。本章将介绍 AMSI 的历史、它在不同 Windows 组件中的实现以及 AMSI 绕过技术的多样性。
- en: <samp class="SANS_Futura_Std_Bold_B_11">The Challenge of Script-Based Malware</samp>
  id: totrans-5
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">基于脚本的恶意软件挑战</samp>
- en: Scripting languages offer a large number of advantages over compiled languages.
    They require less development time and overhead, bypass application allow-listing,
    can execute in memory, and are portable. They also provide the ability to use
    the features of frameworks such as .NET and, oftentimes, direct access to the
    Win32 API, which greatly extends the functionality of the scripting language.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 脚本语言相比编译语言具有许多优势。它们需要更少的开发时间和开销，可以绕过应用程序白名单，能够在内存中执行，并且具有良好的可移植性。它们还提供了使用如 .NET
    等框架特性的能力，并且通常可以直接访问 Win32 API，从而大大扩展了脚本语言的功能。
- en: While script-based malware existed in the wild prior to AMSI’s creation, the
    2015 release of Empire, a command-and-control framework built around PowerShell,
    made its use mainstream in the offensive world. Because of its ease of use, default
    integration into Windows 7 and above, and large amount of existing documentation,
    PowerShell became the de facto language for offensive tool development for many.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管在 AMSI 创建之前就有基于脚本的恶意软件存在，但 2015 年发布的 Empire（一个围绕 PowerShell 构建的命令与控制框架）使其在进攻领域成为主流。由于其易用性、与
    Windows 7 及以上版本的默认集成以及大量现有文档，PowerShell 成为了许多人的进攻工具开发事实标准语言。
- en: 'This boom in script-based malware caused a large defensive gap. Previous tools
    relied on the fact that malware would be dropped to disk and executed. They fell
    short when faced with malware that ran a Microsoft-signed executable installed
    on the system by default, sometimes referred to as *living-off-the-land*, such
    as PowerShell. Even agents that attempted to detect the invocation of malicious
    scripts struggled, as attackers could easily adapt their payloads and tools to
    evade the detection techniques employed by vendors. Microsoft itself highlights
    this problem in its blog post announcing AMSI, which provides the following example.
    Say that a defensive product searched a script for the string “malware” to determine
    whether it was malicious. It would detect the following code:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 脚本式恶意软件的兴起造成了一个巨大的防御漏洞。之前的工具依赖于恶意软件会被写入磁盘并执行的事实。当面对运行在系统中由Microsoft签名并默认安装的可执行文件时，它们显得无能为力，这类恶意软件通常被称为*living-off-the-land*，例如PowerShell。即便是那些试图检测恶意脚本调用的代理，也难以应对，因为攻击者可以轻松地调整其负载和工具，以避开供应商采用的检测技术。Microsoft在其博客中明确指出了这一问题，并在宣布AMSI时给出了以下示例。假设一个防御产品搜索脚本中的字符串“malware”以判断其是否恶意。它会检测到以下代码：
- en: '[PRE0]'
  id: totrans-9
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Once malware authors became aware of this detection logic, they could bypass
    the detection mechanism using something as simple as string concatenation:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦恶意软件作者意识到这种检测逻辑，他们就可以通过像字符串拼接这样简单的方式绕过检测机制：
- en: '[PRE1]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: To combat this, developers would attempt some basic type of language emulation.
    For example, they might concatenate strings before scanning the contents of the
    script block. Unfortunately, this approach is prone to error, as languages often
    have many different ways to represent data, and cataloging them all for emulation
    is very difficult. Antimalware developers did have some success with the technique,
    however. As a result, malware developers raised the complexity of their obfuscation
    slightly with techniques such as encoding. The example in [Listing 10-1](#list10-1)
    shows the string “malware” encoded using Base64 in PowerShell.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 为了应对这一问题，开发人员通常会尝试进行某种基本类型的语言仿真。例如，他们可能会在扫描脚本块内容之前将字符串拼接起来。不幸的是，这种方法容易出错，因为不同的语言常常有多种方式来表示数据，而对它们进行仿真非常困难。然而，反恶意软件开发人员在这一技术上确实取得了一定的成功。因此，恶意软件开发者通过编码等技术略微提高了混淆的复杂度。[Listing
    10-1](#list10-1)中的示例展示了在PowerShell中使用Base64编码的字符串“malware”。
- en: '[PRE2]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Listing 10-1: Decoding a Base64 string in PowerShell'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 'Listing 10-1: 在PowerShell中解码Base64字符串'
- en: Agents again leveraged language emulation to decode data in the script and scan
    it for malicious content. To combat this success, malware developers moved from
    simple encoding to encryption and algorithmic encoding, such as with exclusive-or
    (XOR). For example, the code in [Listing 10-2](#list10-2) first decodes the Base64-encoded
    data and then uses the two-byte key <samp class="SANS_TheSansMonoCd_W5Regular_11">gg</samp>
    to XOR the decoded bytes.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 代理再次利用语言仿真解码脚本中的数据，并扫描其是否包含恶意内容。为了应对这一成功，恶意软件开发者将策略从简单的编码转向了加密和算法编码，例如使用异或（XOR）。例如，[Listing
    10-2](#list10-2)中的代码首先解码Base64编码的数据，然后使用两个字节的密钥<samp class="SANS_TheSansMonoCd_W5Regular_11">gg</samp>对解码后的字节进行XOR运算。
- en: '[PRE3]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Listing 10-2: An XOR example in PowerShell'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 'Listing 10-2: PowerShell中的XOR示例'
- en: This trend toward encryption exceeded what the antimalware engines could reasonably
    emulate, so detections based on the presence of the obfuscation techniques themselves
    became commonplace. This presents its own challenges, due to the fact that normal,
    benign scripts sometimes employ what may look like obfuscation. The example Microsoft
    put forward in its post, and one that became the standard for executing PowerShell
    code in memory, is the download cradle in [Listing 10-3](#list10-3).
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 这种加密趋势超出了反恶意软件引擎能够合理仿真的范围，因此基于混淆技术本身存在的检测变得普遍。这也带来了自身的挑战，因为正常的、无害的脚本有时也会使用看似混淆的技术。Microsoft在其帖子中提出的示例，成为了在内存中执行PowerShell代码的标准之一，即[Listing
    10-3](#list10-3)中的下载框架。
- en: '[PRE4]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Listing 10-3: A simple PowerShell download cradle'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 'Listing 10-3: 一个简单的PowerShell下载框架'
- en: In this example, the .NET <samp class="SANS_TheSansMonoCd_W5Regular_11">Net.Webclient</samp>
    class is used to download a PowerShell script from an arbitrary site. When this
    script is downloaded, it isn’t written to disk but rather lives as a string in
    memory tied to the <samp class="SANS_TheSansMonoCd_W5Regular_11">Webclient</samp>
    object. From here, the adversary uses the <samp class="SANS_TheSansMonoCd_W5Regular_11">Invoke-Expression</samp>
    cmdlet to run this string as a PowerShell command. This technique results in whatever
    action the payload may take, such as deploying a new command-and-control agent,
    occurring entirely in memory.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，.NET 的 <samp class="SANS_TheSansMonoCd_W5Regular_11">Net.Webclient</samp>
    类用于从任意站点下载 PowerShell 脚本。当这个脚本被下载时，它不会写入磁盘，而是作为字符串存在于内存中，与 <samp class="SANS_TheSansMonoCd_W5Regular_11">Webclient</samp>
    对象绑定。接着，攻击者使用 <samp class="SANS_TheSansMonoCd_W5Regular_11">Invoke-Expression</samp>
    cmdlet 将这个字符串作为 PowerShell 命令执行。这种技术使得载荷的任何操作（例如部署新的命令与控制代理）完全在内存中发生。
- en: <samp class="SANS_Futura_Std_Bold_B_11">How AMSI Works</samp>
  id: totrans-22
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">AMSI 的工作原理</samp>
- en: AMSI scans a target, then uses antimalware providers registered on the system
    to determine whether it is malicious. By default, it uses the antimalware provider
    Microsoft Defender IOfficeAntivirus (*MpOav.dll*), but third-party EDR vendors
    may also register their own providers. Duane Michael maintains a list of security
    vendors who register AMSI providers in his “whoamsi” project on GitHub.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: AMSI 扫描一个目标，然后使用系统上注册的反恶意软件提供程序来确定它是否是恶意的。默认情况下，它使用反恶意软件提供程序 Microsoft Defender
    IOfficeAntivirus（*MpOav.dll*），但第三方 EDR 供应商也可以注册他们自己的提供程序。Duane Michael 在他的 GitHub
    项目“whoamsi”中维护了一个注册 AMSI 提供程序的安全供应商列表。
- en: You’ll most commonly find AMSI used by applications that include scripting engines
    (for example, those that accept arbitrary scripts and execute them using the associated
    engine), work with untrusted buffers in memory, or interact with non-PE executable
    code, such as *.docx* and *.pdf* files. AMSI is integrated into many Windows components,
    including modern versions of PowerShell, .NET, JavaScript, VBScript, Windows Script
    Host, Office VBA macros, and User Account Control. It is also integrated into
    Microsoft Exchange.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: AMSI 最常见的应用场景是由包含脚本引擎的应用程序使用（例如，接受任意脚本并使用相关引擎执行它们的应用程序），处理内存中不可信的缓冲区，或与非 PE
    可执行代码（如 *.docx* 和 *.pdf* 文件）交互。AMSI 已集成到许多 Windows 组件中，包括现代版本的 PowerShell、.NET、JavaScript、VBScript、Windows
    脚本宿主、Office VBA 宏和用户帐户控制（UAC）。它还集成到 Microsoft Exchange 中。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Exploring PowerShell’s
    AMSI Implementation</samp>
  id: totrans-25
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">探索 PowerShell 的 AMSI
    实现</samp>
- en: Because PowerShell is open source, we can examine its AMSI implementation to
    understand how Windows components use this tool. In this section, we explore how
    AMSI attempts to restrict this application from executing malicious scripts.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 PowerShell 是开源的，我们可以检查其 AMSI 实现，以了解 Windows 组件如何使用这个工具。在本节中，我们将探讨 AMSI 如何尝试限制应用程序执行恶意脚本。
- en: Inside *System.Management.Automation.dll*, the DLL that provides the runtime
    for hosting PowerShell code, there exists a non-exported function called <samp
    class="SANS_TheSansMonoCd_W5Regular_11">PerformSecurityChecks()</samp> that is
    responsible for scanning the supplied script block and determining whether it
    is malicious. This function is called by the command processor created by PowerShell
    as part of the execution pipeline just before compilation. The call stack in [Listing
    10-4](#list10-4), captured in dnSpy, demonstrates the path the script block follows
    until it is scanned.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *System.Management.Automation.dll* 中，这个 DLL 提供了托管 PowerShell 代码的运行时环境，其中存在一个非导出的函数
    <samp class="SANS_TheSansMonoCd_W5Regular_11">PerformSecurityChecks()</samp>，负责扫描提供的脚本块并确定它是否是恶意的。这个函数由
    PowerShell 创建的命令处理器在编译前的执行管道中调用。[示例 10-4](#list10-4) 中的调用栈，在 dnSpy 中捕获，展示了脚本块在被扫描之前的执行路径。
- en: '[PRE5]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Listing 10-4: The call stack during the scanning of a PowerShell script block'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 10-4：扫描 PowerShell 脚本块时的调用栈
- en: This function calls an internal utility, <samp class="SANS_TheSansMonoCd_W5Regular_11">AmsiUtils.ScanContent()</samp>,
    passing in the script block or file to be scanned. This utility is a simple wrapper
    for another internal function, <samp class="SANS_TheSansMonoCd_W5Regular_11">AmsiUtils.WinScanContent()</samp>,
    where all the real work takes place.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数调用一个内部工具 <samp class="SANS_TheSansMonoCd_W5Regular_11">AmsiUtils.ScanContent()</samp>，将要扫描的脚本块或文件传递给它。这个工具是另一个内部函数
    <samp class="SANS_TheSansMonoCd_W5Regular_11">AmsiUtils.WinScanContent()</samp>
    的简单包装器，所有的实际工作都在这个函数中进行。
- en: After checking the script block for the European Institute for Computer Antivirus
    Research (EICAR) test string, which all antiviruses must detect, <samp class="SANS_TheSansMonoCd_W5Regular_11">WinScanContent</samp>’s
    first action is to create a new AMSI session via a call to <samp class="SANS_TheSansMonoCd_W5Regular_11">amsi!AmsiOpenSession()</samp>.
    AMSI sessions are used to correlate multiple scan requests. Next, <samp class="SANS_TheSansMonoCd_W5Regular_11">WinScanContent()</samp>
    calls <samp class="SANS_TheSansMonoCd_W5Regular_11">amsi!AmsiScanBuffer()</samp>,
    the Win32 API function that will invoke the AMSI providers registered on the system
    and return the final determination regarding the maliciousness of the script block.
    [Listing 10-5](#list10-5) shows this implementation in PowerShell, with the irrelevant
    bits trimmed.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在检查脚本块是否包含欧洲计算机防病毒研究所（EICAR）测试字符串后，所有防病毒软件必须检测该字符串，<samp class="SANS_TheSansMonoCd_W5Regular_11">WinScanContent</samp>
    的第一个操作是通过调用 <samp class="SANS_TheSansMonoCd_W5Regular_11">amsi!AmsiOpenSession()</samp>
    创建一个新的 AMSI 会话。AMSI 会话用于关联多个扫描请求。接下来，<samp class="SANS_TheSansMonoCd_W5Regular_11">WinScanContent()</samp>
    调用 <samp class="SANS_TheSansMonoCd_W5Regular_11">amsi!AmsiScanBuffer()</samp>，这是
    Win32 API 函数，会调用系统上注册的 AMSI 提供程序，并返回最终关于脚本块恶意性的判定。[列表 10-5](#list10-5) 展示了 PowerShell
    中的这一实现，去除了不相关的部分。
- en: '[PRE6]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Listing 10-5: PowerShell’s AMSI implementation'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 10-5：PowerShell 的 AMSI 实现
- en: In Powershell, the code first calls <samp class="SANS_TheSansMonoCd_W5Regular_11">amsi!AmsiOpenSession()</samp>
    ❶ to create a new AMSI session in which scan requests can be correlated. If the
    session opens successfully, the data to be scanned is passed to <samp class="SANS_TheSansMonoCd_W5Regular_11">amsi!AmsiScanBuffer()</samp>
    ❷, which does the actual evaluation of the data to determine if the contents of
    the buffer appear to be malicious. The result of this call is returned to <samp
    class="SANS_TheSansMonoCd_W5Regular_11">WinScanContent()</samp>.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在 PowerShell 中，代码首先调用 <samp class="SANS_TheSansMonoCd_W5Regular_11">amsi!AmsiOpenSession()</samp>
    ❶ 来创建一个新的 AMSI 会话，扫描请求可以在该会话中进行关联。如果会话成功打开，要扫描的数据会传递给 <samp class="SANS_TheSansMonoCd_W5Regular_11">amsi!AmsiScanBuffer()</samp>
    ❷，该函数会实际评估数据，以确定缓冲区的内容是否看起来具有恶意。此调用的结果会返回给 <samp class="SANS_TheSansMonoCd_W5Regular_11">WinScanContent()</samp>。
- en: 'The <samp class="SANS_TheSansMonoCd_W5Regular_11">WinScanContent()</samp> function
    can return one of three values:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">WinScanContent()</samp> 函数可以返回三个值中的一个：
- en: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">AMSI_RESULT_NOT_DETECTED</samp>   A
    neutral result
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">AMSI_RESULT_NOT_DETECTED</samp>   中性结果
- en: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">AMSI_RESULT_CLEAN</samp>   A result
    indicating that the script block did not contain malware
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">AMSI_RESULT_CLEAN</samp>   表示脚本块不包含恶意软件的结果
- en: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">AMSI_RESULT_DETECTED</samp>   A
    result indicating that the script block contained malware
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">AMSI_RESULT_DETECTED</samp>   表示脚本块包含恶意软件的结果
- en: If either of the first two results is returned, indicating that AMSI could not
    determine the maliciousness of the script block or found it not to be dangerous,
    the script block will be allowed to execute on the system. If, however, the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">AMSI_RESULT_DETECTED</samp> result is
    returned, a <samp class="SANS_TheSansMonoCd_W5Regular_11">ParseException</samp>
    will be thrown, and execution of the script block will be halted. [Listing 10-6](#list10-6)
    shows how this logic is implemented inside PowerShell.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 如果返回前两个结果中的任何一个，表示 AMSI 无法确定脚本块是否具有恶意，或者认为它不危险，则该脚本块将被允许在系统上执行。然而，如果返回 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">AMSI_RESULT_DETECTED</samp> 结果，将抛出一个 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">ParseException</samp>，并会停止脚本块的执行。[列表 10-6](#list10-6)
    展示了如何在 PowerShell 中实现此逻辑。
- en: '[PRE7]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Listing 10-6: Throwing a <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">ParseError</samp>
    on malicious script detection'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 10-6：在检测到恶意脚本时抛出 <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">ParseError</samp>
- en: Because AMSI threw an exception ❶, the execution of the script halts and the
    error shown in the <samp class="SANS_TheSansMonoCd_W5Regular_11">ParseError</samp>
    will be returned to the user. [Listing 10-7](#list10-7) shows the error the user
    will see in the PowerShell window.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 AMSI 抛出了一个异常 ❶，脚本的执行被停止，并且在 <samp class="SANS_TheSansMonoCd_W5Regular_11">ParseError</samp>
    中显示的错误将返回给用户。[列表 10-7](#list10-7) 展示了用户在 PowerShell 窗口中看到的错误。
- en: '[PRE8]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Listing 10-7: The thrown error shown to the user'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 10-7：显示给用户的错误
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Understanding AMSI
    Under the Hood</samp>
  id: totrans-45
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">深入了解 AMSI</samp>
- en: While understanding how AMSI is instrumented in system components provides useful
    context for how user-supplied input is evaluated, it doesn’t quite tell the whole
    story. What happens when PowerShell calls <samp class="SANS_TheSansMonoCd_W5Regular_11">amsi!AmsiScanBuffer()</samp>?
    To understand this, we must dive deep into the AMSI implementation itself. Because
    the state of C++ decompilers at the time of this writing makes static analysis
    a bit tricky, we’ll need to use some dynamic analysis techniques. Thankfully,
    WinDbg makes this process relatively painless, especially considering that debug
    symbols are available for *amsi.dll*.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然了解 AMSI 在系统组件中的应用有助于理解用户输入是如何被评估的，但它并没有完全讲述整个故事。当 PowerShell 调用 <samp class="SANS_TheSansMonoCd_W5Regular_11">amsi!AmsiScanBuffer()</samp>
    时会发生什么？要理解这一点，我们必须深入研究 AMSI 实现本身。由于目前 C++ 反编译器的状态使得静态分析有点棘手，我们需要使用一些动态分析技术。幸运的是，WinDbg
    使这个过程相对轻松，特别是考虑到 *amsi.dll* 的调试符号是可用的。
- en: When PowerShell starts, it first calls <samp class="SANS_TheSansMonoCd_W5Regular_11">amsi!AmsiInitialize()</samp>.
    As its name suggests, this function is responsible for initializing the AMSI API.
    This initialization primarily centers on the creation of a COM class factory via
    a call to <samp class="SANS_TheSansMonoCd_W5Regular_11">DllGetClassObject()</samp>.
    As an argument, it receives the class identifier correlating to *amsi.dll*, along
    with the interface identified for the <samp class="SANS_TheSansMonoCd_W5Regular_11">IClassFactory</samp>,
    which enables a class of objects to be created. The interface pointer is then
    used to create an instance of the <samp class="SANS_TheSansMonoCd_W5Regular_11">IAntimalware</samp>
    interface (<samp class="SANS_TheSansMonoCd_W5Regular_11">{82d29c2e-f062-44e6-b5c9-3d9a2f24a2df}</samp>),
    shown in [Listing 10-8](#list10-8).
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 当 PowerShell 启动时，它首先调用 <samp class="SANS_TheSansMonoCd_W5Regular_11">amsi!AmsiInitialize()</samp>。顾名思义，这个函数负责初始化
    AMSI API。此初始化主要集中在通过调用 <samp class="SANS_TheSansMonoCd_W5Regular_11">DllGetClassObject()</samp>
    创建 COM 类工厂。作为参数，它接收与 *amsi.dll* 相关的类标识符，以及为 <samp class="SANS_TheSansMonoCd_W5Regular_11">IClassFactory</samp>
    标识的接口，后者允许创建对象类。接口指针随后用于创建 <samp class="SANS_TheSansMonoCd_W5Regular_11">IAntimalware</samp>
    接口的实例（<samp class="SANS_TheSansMonoCd_W5Regular_11">{82d29c2e-f062-44e6-b5c9-3d9a2f24a2df}</samp>），如
    [示例 10-8](#list10-8) 所示。
- en: '[PRE9]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Listing 10-8: Creating an instance of <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">IAntimalware</samp>'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 10-8：创建 <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">IAntimalware</samp>
    实例
- en: Rather than an explicit call to some functions, you’ll occasionally find references
    to <samp class="SANS_TheSansMonoCd_W5Regular_11">_guard_dispatch_icall_fptr()</samp>.
    This is a component of Control Flow Guard (CFG), an anti-exploit technology that
    attempts to prevent indirect calls, such as in the event of return-oriented programming.
    In short, this function checks the Control Flow Guard bitmap of the source image
    to determine if the function to be called is a valid target. In the context of
    this section, the reader can treat these as simple <samp class="SANS_TheSansMonoCd_W5Regular_11">CALL</samp>
    instructions to reduce confusion.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 与明确调用某些函数不同，你偶尔会发现对 <samp class="SANS_TheSansMonoCd_W5Regular_11">_guard_dispatch_icall_fptr()</samp>
    的引用。这是控制流保护（CFG）的一部分，一种防止利用攻击的技术，旨在防止间接调用，例如在返回导向编程的情况下。简而言之，这个函数检查源映像的控制流保护位图，以确定要调用的函数是否是有效目标。在本节的上下文中，读者可以将这些视为简单的
    <samp class="SANS_TheSansMonoCd_W5Regular_11">CALL</samp> 指令，以减少混淆。
- en: This call then eventually leads into <samp class="SANS_TheSansMonoCd_W5Regular_11">amsi!AmsiComCreateProviders</samp><samp
    class="SANS_TheSansMonoCd_W5Regular_11"><</samp><samp class="SANS_TheSansMonoCd_W5Regular_11">IAntimalwareProvider></samp>,
    where all the magic happens. [Listing 10-9](#list10-9) shows the call stack for
    this method inside WinDbg.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 该调用最终会进入 <samp class="SANS_TheSansMonoCd_W5Regular_11">amsi!AmsiComCreateProviders</samp><samp
    class="SANS_TheSansMonoCd_W5Regular_11"><</samp><samp class="SANS_TheSansMonoCd_W5Regular_11">IAntimalwareProvider></samp>，在那里所有的“魔法”发生。
    [示例 10-9](#list10-9) 显示了在 WinDbg 中此方法的调用堆栈。
- en: '[PRE10]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Listing 10-9: The call stack for the <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">AmsiComCreateProviders</samp>
    function'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 10-9：<samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">AmsiComCreateProviders</samp>
    函数的调用堆栈
- en: The first major action is a call to <samp class="SANS_TheSansMonoCd_W5Regular_11">amsi!CGuidEnum::StartEnum()</samp>.
    This function receives the string <samp class="SANS_TheSansMonoCd_W5Regular_11">"Software\\Microsoft\\AMSI\\Providers"</samp>,
    which it passes into a call to <samp class="SANS_TheSansMonoCd_W5Regular_11">RegOpenKey()</samp>
    and then <samp class="SANS_TheSansMonoCd_W5Regular_11">RegQueryInfoKeyW()</samp>
    in order to get the number of subkeys. Then, <samp class="SANS_TheSansMonoCd_W5Regular_11">amsi!CGuidEnum::NextGuid()</samp>
    iterates through the subkeys and converts the class identifiers of registered
    AMSI providers from strings to UUIDs. After enumerating all the required class
    identifiers, it passes execution to <samp class="SANS_TheSansMonoCd_W5Regular_11">amsi!AmsiComSecureLoadInProcServer()</samp>,
    where the <samp class="SANS_TheSansMonoCd_W5Regular_11">InProcServer32</samp>
    value corresponding to the AMSI provider is queried via <samp class="SANS_TheSansMonoCd_W5Regular_11">RegGetValueW()</samp>.
    [Listing 10-10](#list10-10) shows this process for *MpOav.dll*.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个主要操作是调用<samp class="SANS_TheSansMonoCd_W5Regular_11">amsi!CGuidEnum::StartEnum()</samp>。该函数接收字符串<samp
    class="SANS_TheSansMonoCd_W5Regular_11">"Software\\Microsoft\\AMSI\\Providers"</samp>，并将其传递给<samp
    class="SANS_TheSansMonoCd_W5Regular_11">RegOpenKey()</samp>，然后调用<samp class="SANS_TheSansMonoCd_W5Regular_11">RegQueryInfoKeyW()</samp>以获取子键的数量。接着，<samp
    class="SANS_TheSansMonoCd_W5Regular_11">amsi!CGuidEnum::NextGuid()</samp>遍历子键，并将注册的AMSI提供程序的类标识符从字符串转换为UUID。枚举所有所需的类标识符后，它将执行传递给<samp
    class="SANS_TheSansMonoCd_W5Regular_11">amsi!AmsiComSecureLoadInProcServer()</samp>，在那里通过<samp
    class="SANS_TheSansMonoCd_W5Regular_11">RegGetValueW()</samp>查询与AMSI提供程序对应的<sup
    class="SANS_TheSansMonoCd_W5Regular_11">InProcServer32</sup>值。[Listing 10-10](#list10-10)展示了这一过程，针对
    *MpOav.dll*。
- en: '[PRE11]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Listing 10-10: The parameters passed to <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">RegGetValueW</samp>'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 'Listing 10-10: 传递给<samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">RegGetValueW</samp>的参数'
- en: Next, <samp class="SANS_TheSansMonoCd_W5Regular_11">amsi!CheckTrustLevel()</samp>
    is called to check the value of the registry key *SOFTWARE\Microsoft\AMSI\FeatureBits*.
    This key contains a DWORD, which can be either <samp class="SANS_TheSansMonoCd_W5Regular_11">1</samp>
    (the default) or <samp class="SANS_TheSansMonoCd_W5Regular_11">2</samp> to disable
    or enable Authenticode signing checks for providers. If Authenticode signing checks
    are enabled, the path listed in the <samp class="SANS_TheSansMonoCd_W5Regular_11">InProcServer32</samp>
    registry key is verified. Following a successful check, the path is passed into
    <samp class="SANS_TheSansMonoCd_W5Regular_11">LoadLibraryW()</samp> to load the
    AMSI provider DLL, as demonstrated in [Listing 10-11](#list10-11).
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，调用<samp class="SANS_TheSansMonoCd_W5Regular_11">amsi!CheckTrustLevel()</samp>，检查注册表项*SOFTWARE\Microsoft\AMSI\FeatureBits*的值。此键包含一个DWORD，可以是<samp
    class="SANS_TheSansMonoCd_W5Regular_11">1</samp>（默认值）或<samp class="SANS_TheSansMonoCd_W5Regular_11">2</samp>，用于禁用或启用提供程序的Authenticode签名检查。如果启用了Authenticode签名检查，将验证在<samp
    class="SANS_TheSansMonoCd_W5Regular_11">InProcServer32</samp>注册表项中列出的路径。在成功验证后，该路径将传递给<samp
    class="SANS_TheSansMonoCd_W5Regular_11">LoadLibraryW()</samp>以加载AMSI提供程序DLL，如[Listing
    10-11](#list10-11)所示。
- en: '[PRE12]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Listing 10-11: The MpOav.dll loaded via <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">LoadLibraryW()</samp>'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 'Listing 10-11: 通过<samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">LoadLibraryW()</samp>加载MpOav.dll'
- en: 'If the provider DLL loads successfully, its <samp class="SANS_TheSansMonoCd_W5Regular_11">DllRegisterServer()</samp>
    function is called to tell it to create registry entries for all COM classes supported
    by the provider. This cycle repeats calls to <samp class="SANS_TheSansMonoCd_W5Regular_11">amsi!CGuidEnum::NextGuid()</samp>
    until all providers are loaded. [Listing 10-12](#list10-12) shows the final step:
    invoking the <samp class="SANS_TheSansMonoCd_W5Regular_11">QueryInterface()</samp>
    method for each provider in order to get a pointer to the <samp class="SANS_TheSansMonoCd_W5Regular_11">IAntimalware</samp>
    interfaces.'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 如果提供程序DLL加载成功，将调用其<samp class="SANS_TheSansMonoCd_W5Regular_11">DllRegisterServer()</samp>函数，告知它为提供程序支持的所有COM类创建注册表项。这个循环会重复调用<samp
    class="SANS_TheSansMonoCd_W5Regular_11">amsi!CGuidEnum::NextGuid()</samp>，直到所有提供程序都被加载。[Listing
    10-12](#list10-12)展示了最终步骤：调用每个提供程序的<samp class="SANS_TheSansMonoCd_W5Regular_11">QueryInterface()</samp>方法，以获得指向<samp
    class="SANS_TheSansMonoCd_W5Regular_11">IAntimalware</samp>接口的指针。
- en: '[PRE13]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Listing 10-12: Calling <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">QueryInterface</samp>
    on the registered provider'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 'Listing 10-12: 对已注册提供程序调用<samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">QueryInterface</samp>'
- en: After <samp class="SANS_TheSansMonoCd_W5Regular_11">AmsiInitialize()</samp>
    returns, AMSI is ready to go. Before PowerShell begins evaluating a script block,
    it calls <samp class="SANS_TheSansMonoCd_W5Regular_11">AmsiOpenSession()</samp>.
    As mentioned previously, this function allows AMSI to correlate multiple scans.
    When this function completes, it returns a <samp class="SANS_TheSansMonoCd_W5Regular_11">HAMSISESSION</samp>
    to the caller, and the caller can choose to pass this value to all subsequent
    calls to AMSI within the current scanning session.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在 <samp class="SANS_TheSansMonoCd_W5Regular_11">AmsiInitialize()</samp> 返回之后，AMSI
    已经准备好工作。在 PowerShell 开始评估脚本块之前，它会调用 <samp class="SANS_TheSansMonoCd_W5Regular_11">AmsiOpenSession()</samp>。如前所述，该函数允许
    AMSI 关联多个扫描。当此函数完成时，它会返回一个 <samp class="SANS_TheSansMonoCd_W5Regular_11">HAMSISESSION</samp>
    给调用者，调用者可以选择将此值传递给当前扫描会话中的所有后续 AMSI 调用。
- en: When PowerShell’s AMSI instrumentation receives a script block and an AMSI session
    has been opened, it calls <samp class="SANS_TheSansMonoCd_W5Regular_11">AmsiScanBuffer()</samp>
    with the script block passed as input. This function is defined in [Listing 10-13](#list10-13).
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 当 PowerShell 的 AMSI 插装接收到脚本块并且 AMSI 会话已经打开时，它会调用 <samp class="SANS_TheSansMonoCd_W5Regular_11">AmsiScanBuffer()</samp>，并将脚本块作为输入传递给该函数。该函数在[列表
    10-13](#list10-13)中进行了定义。
- en: '[PRE14]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Listing 10-13: The <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">AmsiScanBuffer()</samp>
    definition'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '列表 10-13: <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">AmsiScanBuffer()</samp>
    定义'
- en: The function’s primary responsibility is to check the validity of the parameters
    passed to it. This includes checks for content in the input buffer and the presence
    of a valid <samp class="SANS_TheSansMonoCd_W5Regular_11">HAMSICONTEXT</samp> handle
    with a tag of <samp class="SANS_TheSansMonoCd_W5Regular_11">AMSI</samp>, as you
    can see in the decompilation in [Listing 10-14](#list10-14). If any of these checks
    fail, the function returns <samp class="SANS_TheSansMonoCd_W5Regular_11">E_INVALIDARG</samp>
    (0x80070057) to the caller.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 该函数的主要职责是检查传递给它的参数的有效性。这包括检查输入缓冲区的内容以及是否存在带有标签<samp class="SANS_TheSansMonoCd_W5Regular_11">AMSI</samp>的有效
    <samp class="SANS_TheSansMonoCd_W5Regular_11">HAMSICONTEXT</samp> 句柄，正如你在[列表 10-14](#list10-14)中的反汇编中看到的。如果这些检查中的任何一个失败，函数会向调用者返回
    <samp class="SANS_TheSansMonoCd_W5Regular_11">E_INVALIDARG</samp> (0x80070057)。
- en: '[PRE15]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Listing 10-14: Internal <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">AmsiScanBuffer()</samp>
    sanity checks'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '列表 10-14: 内部 <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">AmsiScanBuffer()</samp>
    合理性检查'
- en: If these checks pass, AMSI invokes <samp class="SANS_TheSansMonoCd_W5Regular_11">amsi!CAmsiAntimalware::Scan()</samp>,
    as shown in the call stack in [Listing 10-15](#list10-15).
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这些检查通过，AMSI 会调用 <samp class="SANS_TheSansMonoCd_W5Regular_11">amsi!CAmsiAntimalware::Scan()</samp>，正如[列表
    10-15](#list10-15)中的调用栈所示。
- en: '[PRE16]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Listing 10-15: The <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">Scan()</samp>
    method called'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '列表 10-15: 调用的 <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">Scan()</samp>
    方法'
- en: This method contains a <samp class="SANS_TheSansMonoCd_W5Regular_11">while</samp>
    loop that iterates over every registered AMSI provider (the count of which is
    stored at <samp class="SANS_TheSansMonoCd_W5Regular_11">R14</samp> + <samp class="SANS_TheSansMonoCd_W5Regular_11">0x1c0</samp>).
    In this loop, it calls the <samp class="SANS_TheSansMonoCd_W5Regular_11">IAntimalwareProvider::Scan()</samp>
    function, which the EDR vendor can implement however they wish; it is only expected
    to return an <samp class="SANS_TheSansMonoCd_W5Regular_11">AMSI_RESULT</samp>,
    defined in [Listing 10-16](#list10-16).
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 该方法包含一个 <samp class="SANS_TheSansMonoCd_W5Regular_11">while</samp> 循环，循环遍历每个注册的
    AMSI 提供程序（其数量存储在 <samp class="SANS_TheSansMonoCd_W5Regular_11">R14</samp> + <samp
    class="SANS_TheSansMonoCd_W5Regular_11">0x1c0</samp>）。在这个循环中，它调用 <samp class="SANS_TheSansMonoCd_W5Regular_11">IAntimalwareProvider::Scan()</samp>
    函数，EDR 供应商可以根据自己的需求来实现该函数；期望它返回一个 <samp class="SANS_TheSansMonoCd_W5Regular_11">AMSI_RESULT</samp>，该结果在[列表
    10-16](#list10-16)中定义。
- en: '[PRE17]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Listing 10-16: The <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">CAmsiAntimalware::Scan()</samp>
    function definition'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '列表 10-16: <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">CAmsiAntimalware::Scan()</samp>
    函数定义'
- en: In the case of the default Microsoft Defender AMSI implementation, *MpOav.dll*,
    this function performs some basic initialization and then hands execution over
    to *MpClient.dll*, the Windows Defender client interface. Note that Microsoft
    doesn’t supply program database files for Defender components, so *MpOav.dll*’s
    function name in the call stack in [Listing 10-17](#list10-17) is incorrect.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 对于默认的 Microsoft Defender AMSI 实现，即 *MpOav.dll*，该函数执行一些基本初始化工作，然后将执行交给 *MpClient.dll*，Windows
    Defender 客户端接口。请注意，微软并未为 Defender 组件提供程序数据库文件，因此 *MpOav.dll* 在[列表 10-17](#list10-17)中的调用栈中的函数名是错误的。
- en: '[PRE18]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Listing 10-17: Execution passed to MpClient.dll from MpOav.dll'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 列表10-17：从MpOav.dll传递到MpClient.dll的执行过程
- en: AMSI passes the result of the scan back to <samp class="SANS_TheSansMonoCd_W5Regular_11">amsi!AmsiScanBuffer()</samp>
    via <samp class="SANS_TheSansMonoCd_W5Regular_11">amsi!CAmsiAntimalware::Scan()</samp>,
    which in turn returns the <samp class="SANS_TheSansMonoCd_W5Regular_11">AMSI_RESULT</samp>
    to the caller. If the script block was found to contain malicious content, PowerShell
    throws a <samp class="SANS_TheSansMonoCd_W5Regular_11">ScriptContainedMaliciousContent</samp>
    exception and prevents its execution.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: AMSI通过<samp class="SANS_TheSansMonoCd_W5Regular_11">amsi!AmsiScanBuffer()</samp>将扫描结果返回给<samp
    class="SANS_TheSansMonoCd_W5Regular_11">amsi!CAmsiAntimalware::Scan()</samp>，后者又将<samp
    class="SANS_TheSansMonoCd_W5Regular_11">AMSI_RESULT</samp>返回给调用者。如果发现脚本块包含恶意内容，PowerShell将抛出<samp
    class="SANS_TheSansMonoCd_W5Regular_11">ScriptContainedMaliciousContent</samp>异常，并阻止其执行。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Implementing a Custom
    AMSI Provider</samp>
  id: totrans-80
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">实现自定义AMSI提供程序</samp>
- en: As mentioned in the previous section, developers can implement the <samp class="SANS_TheSansMonoCd_W5Regular_11">IAntimalwareProvider::Scan()</samp>
    function however they like. For example, they could simply log information about
    the content to be scanned, or they could pass the contents of a buffer through
    a trained machine-learning model to evaluate its maliciousness. To understand
    the shared architecture of all vendors’ AMSI providers, this section steps through
    the design of a simple provider DLL that meets the minimum specifications defined
    by Microsoft.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 如前一节所述，开发人员可以根据需要实现<samp class="SANS_TheSansMonoCd_W5Regular_11">IAntimalwareProvider::Scan()</samp>函数。例如，他们可以简单地记录要扫描内容的信息，或者将缓冲区的内容传递给训练好的机器学习模型，以评估其恶意性。为了理解所有供应商的AMSI提供程序的共享架构，本节将逐步介绍满足Microsoft定义的最低规格的简单提供程序DLL的设计。
- en: 'At their core, AMSI providers are nothing more than *COM servers*, or DLLs
    loaded into a host process that expose a function required by the caller: in this
    case, <samp class="SANS_TheSansMonoCd_W5Regular_11">IAntimalwareProvider</samp>.
    This function extends the <samp class="SANS_TheSansMonoCd_W5Regular_11">IUnknown</samp>
    interface by adding three additional methods: <samp class="SANS_TheSansMonoCd_W5Regular_11">CloseSession</samp>
    closes the AMSI session via its <samp class="SANS_TheSansMonoCd_W5Regular_11">HAMSISESSION</samp>
    handle, <samp class="SANS_TheSansMonoCd_W5Regular_11">DisplayName</samp> displays
    the name of the AMSI provider, and <samp class="SANS_TheSansMonoCd_W5Regular_11">Scan</samp>
    scans an <samp class="SANS_TheSansMonoCd_W5Regular_11">IAmsiStream</samp> of content
    and returns an <samp class="SANS_TheSansMonoCd_W5Regular_11">AMSI_RESULT</samp>.'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 本质上，AMSI提供程序不过是*COM服务器*，或者是加载到主机进程中的DLL，它们暴露一个调用者所需的函数：在本例中是<samp class="SANS_TheSansMonoCd_W5Regular_11">IAntimalwareProvider</samp>。此函数通过添加三个附加方法扩展了<samp
    class="SANS_TheSansMonoCd_W5Regular_11">IUnknown</samp>接口：<samp class="SANS_TheSansMonoCd_W5Regular_11">CloseSession</samp>通过其<samp
    class="SANS_TheSansMonoCd_W5Regular_11">HAMSISESSION</samp>句柄关闭AMSI会话，<samp class="SANS_TheSansMonoCd_W5Regular_11">DisplayName</samp>显示AMSI提供程序的名称，<samp
    class="SANS_TheSansMonoCd_W5Regular_11">Scan</samp>扫描一个<samp class="SANS_TheSansMonoCd_W5Regular_11">IAmsiStream</samp>内容并返回一个<samp
    class="SANS_TheSansMonoCd_W5Regular_11">AMSI_RESULT</samp>。
- en: In C++, a basic class declaration that overrides <samp class="SANS_TheSansMonoCd_W5Regular_11">IAntimalwareProvider</samp>’s
    methods may look something like the code shown in [Listing 10-18](#list10-18).
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在C++中，重写<samp class="SANS_TheSansMonoCd_W5Regular_11">IAntimalwareProvider</samp>方法的基本类声明可能类似于[列表10-18](#list10-18)中所示的代码。
- en: '[PRE19]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Listing 10-18: An example <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">IAntimalwareProvider</samp>
    class definition'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 列表10-18：一个示例<samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">IAntimalwareProvider</samp>类定义
- en: Our code makes use of the Windows Runtime C++ Template Library, which reduces
    the amount of code used to create COM components. The <samp class="SANS_TheSansMonoCd_W5Regular_11">CloseSession()</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">DisplayName()</samp> methods
    are simply overridden with our own functions to close the AMSI session and return
    the name of the AMSI provider, respectively. The <samp class="SANS_TheSansMonoCd_W5Regular_11">Scan()</samp>
    function receives the buffer to be scanned as part of an <samp class="SANS_TheSansMonoCd_W5Regular_11">IAmsiStream</samp>,
    which exposes two methods, <samp class="SANS_TheSansMonoCd_W5Regular_11">GetAttribute()</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">Read()</samp>, and is defined
    in [Listing 10-19](#list10-19).
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的代码利用了 Windows Runtime C++ 模板库，减少了创建 COM 组件时所需的代码量。<samp class="SANS_TheSansMonoCd_W5Regular_11">CloseSession()</samp>
    和 <samp class="SANS_TheSansMonoCd_W5Regular_11">DisplayName()</samp> 方法被我们自己的函数重写，用于分别关闭
    AMSI 会话和返回 AMSI 提供者的名称。<samp class="SANS_TheSansMonoCd_W5Regular_11">Scan()</samp>
    函数接收要扫描的缓冲区，作为 <samp class="SANS_TheSansMonoCd_W5Regular_11">IAmsiStream</samp>
    的一部分，后者暴露了两个方法，<samp class="SANS_TheSansMonoCd_W5Regular_11">GetAttribute()</samp>
    和 <samp class="SANS_TheSansMonoCd_W5Regular_11">Read()</samp>，并在[清单 10-19](#list10-19)中定义。
- en: '[PRE20]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Listing 10-19: The <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">IAmsiStream</samp>
    class definition'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 10-19：<samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">IAmsiStream</samp>
    类定义
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">GetAttribute()</samp> retrieves
    metadata about the contents to be scanned. Developers request these attributes
    by passing an <samp class="SANS_TheSansMonoCd_W5Regular_11">AMSI_ATTRIBUTE</samp>
    value that indicates what information they would like to retrieve, along with
    an appropriately sized buffer. The <samp class="SANS_TheSansMonoCd_W5Regular_11">AMSI_ATTRIBUTE</samp>
    value is an enumeration defined in [Listing 10-20](#list10-20).
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">GetAttribute()</samp> 用于检索要扫描内容的元数据。开发者通过传递一个表示希望检索信息的
    <samp class="SANS_TheSansMonoCd_W5Regular_11">AMSI_ATTRIBUTE</samp> 值，以及适当大小的缓冲区来请求这些属性。<samp
    class="SANS_TheSansMonoCd_W5Regular_11">AMSI_ATTRIBUTE</samp> 值是一个枚举类型，定义在[清单
    10-20](#list10-20)中。
- en: '[PRE21]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Listing 10-20: The <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">AMSI_ATTRIBUTE</samp>
    enumeration'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 10-20：<samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">AMSI_ATTRIBUTE</samp>
    枚举
- en: 'While there are 10 attributes in the enumeration, Microsoft documents only
    the first five: <samp class="SANS_TheSansMonoCd_W5Regular_11">AMSI_ATTRIBUTE_APP_NAME</samp>
    is a string containing the name, version, or GUID of the calling application;
    <samp class="SANS_TheSansMonoCd_W5Regular_11">AMSI_ATTRIBUTE_CONTENT_NAME</samp>
    is a string containing the filename, URL, script ID, or equivalent identifier
    of the content to be scanned; <samp class="SANS_TheSansMonoCd_W5Regular_11">AMSI_ATTRIBUTE_CONTENT_SIZE</samp>
    is a <samp class="SANS_TheSansMonoCd_W5Regular_11">ULONGLONG</samp> containing
    the size of the data to be scanned; <samp class="SANS_TheSansMonoCd_W5Regular_11">AMSI_ATTRIBUTE_CONTENT_ADDRESS</samp>
    is the memory address of the content, if it has been fully loaded into memory;
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">AMSI_ATTRIBUTE_SESSION</samp>
    contains a pointer to the next portion of the content to be scanned or <samp class="SANS_TheSansMonoCd_W5Regular_11">NULL</samp>
    if the content is self-contained.'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然该枚举中有 10 个属性，但微软只记录了前五个：<samp class="SANS_TheSansMonoCd_W5Regular_11">AMSI_ATTRIBUTE_APP_NAME</samp>
    是一个包含调用应用程序的名称、版本或 GUID 的字符串；<samp class="SANS_TheSansMonoCd_W5Regular_11">AMSI_ATTRIBUTE_CONTENT_NAME</samp>
    是一个包含要扫描内容的文件名、URL、脚本 ID 或等效标识符的字符串；<samp class="SANS_TheSansMonoCd_W5Regular_11">AMSI_ATTRIBUTE_CONTENT_SIZE</samp>
    是一个 <samp class="SANS_TheSansMonoCd_W5Regular_11">ULONGLONG</samp> 类型，表示要扫描数据的大小；<samp
    class="SANS_TheSansMonoCd_W5Regular_11">AMSI_ATTRIBUTE_CONTENT_ADDRESS</samp>
    是内容的内存地址（如果内容已完全加载到内存中）；而 <samp class="SANS_TheSansMonoCd_W5Regular_11">AMSI_ATTRIBUTE_SESSION</samp>
    包含指向下一个要扫描的内容部分的指针，或者如果内容是自包含的，则为 <samp class="SANS_TheSansMonoCd_W5Regular_11">NULL</samp>。
- en: As an example, [Listing 10-21](#list10-21) shows how an AMSI provider might
    use this attribute to retrieve the application name.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 作为示例，[清单 10-21](#list10-21) 展示了 AMIS 提供者如何使用该属性来检索应用程序名称。
- en: '[PRE22]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Listing 10-21: An implementation of the AMSI scanning function'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 10-21：AMSI 扫描功能的实现
- en: When PowerShell calls this example function, <samp class="SANS_TheSansMonoCd_W5Regular_11">pszAppName</samp>
    ❶ will contain the application name as a string, which AMSI can use to enrich
    the scan data. This becomes particularly useful if the script block is deemed
    malicious, as the EDR could use the application name to terminate the calling
    process.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 当PowerShell调用此示例函数时，<samp class="SANS_TheSansMonoCd_W5Regular_11">pszAppName</samp>
    ❶将包含作为字符串的应用程序名称，AMSI可以使用它来丰富扫描数据。如果脚本块被判定为恶意，这尤其有用，因为EDR可以利用应用程序名称终止调用进程。
- en: If <samp class="SANS_TheSansMonoCd_W5Regular_11">AMSI_ATTRIBUTE_CONTENT_ADDRESS</samp>
    returns a memory address, we know that the content to be scanned has been fully
    loaded into memory, so we can interact with it directly. Most often, the data
    is provided as a stream, in which case we use the <samp class="SANS_TheSansMonoCd_W5Regular_11">Read()</samp>
    method (defined in [Listing 10-22](#list10-22)) to retrieve the contents of the
    buffer one chunk at a time. We can define the size of these chunks, which get
    passed, along with a buffer of the same size, to the <samp class="SANS_TheSansMonoCd_W5Regular_11">Read()</samp>
    method.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 如果<samp class="SANS_TheSansMonoCd_W5Regular_11">AMSI_ATTRIBUTE_CONTENT_ADDRESS</samp>返回一个内存地址，我们就知道要扫描的内容已经完全加载到内存中，这样我们就可以直接与之交互。通常情况下，数据是以流的形式提供的，在这种情况下，我们使用<samp
    class="SANS_TheSansMonoCd_W5Regular_11">Read()</samp>方法（在[列表10-22](#list10-22)中定义）逐个块地获取缓冲区的内容。我们可以定义这些块的大小，并将其与大小相同的缓冲区一起传递给<samp
    class="SANS_TheSansMonoCd_W5Regular_11">Read()</samp>方法。
- en: '[PRE23]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Listing 10-22: The <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">IAmsiStream::Read()</samp>
    method definition'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 列表10-22：<samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">IAmsiStream::Read()</samp>方法定义
- en: What the provider does with these chunks of data is completely up to the developer.
    They could scan each chunk, read the full stream, and hash its contents, or simply
    log details about it. The only rule is that, when the <samp class="SANS_TheSansMonoCd_W5Regular_11">Scan()</samp>
    method returns, it must pass an <samp class="SANS_TheSansMonoCd_W5Regular_11">HRESULT</samp>
    and an <samp class="SANS_TheSansMonoCd_W5Regular_11">AMSI_RESULT</samp> to the
    caller.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 服务提供者如何处理这些数据块完全取决于开发人员。他们可以扫描每个数据块，读取完整流并对其内容进行哈希，或者只是记录相关的详细信息。唯一的规则是，当<samp
    class="SANS_TheSansMonoCd_W5Regular_11">Scan()</samp>方法返回时，它必须将<samp class="SANS_TheSansMonoCd_W5Regular_11">HRESULT</samp>和<samp
    class="SANS_TheSansMonoCd_W5Regular_11">AMSI_RESULT</samp>返回给调用者。
- en: <samp class="SANS_Futura_Std_Bold_B_11">Evading AMSI</samp>
  id: totrans-101
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">规避AMSI</samp>
- en: AMSI is one of the most-studied areas when it comes to evasion. This is due
    in no small part to how effective it was in its early days, causing significant
    headaches for offensive teams that used PowerShell heavily. For them, AMSI presented
    an existential crisis that prevented their main agents from functioning.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: AMSI是与规避相关的研究最多的领域之一。这在很大程度上归功于其早期的高效性，曾给大量依赖PowerShell的进攻性团队带来显著的困扰。对于他们来说，AMSI呈现了一种生死存亡的危机，阻止了他们的主要代理正常运行。
- en: Attackers can employ a variety of evasion techniques to bypass AMSI. While certain
    vendors have attempted to flag some of these as malicious, the number of evasion
    opportunities present in AMSI is staggering, so vendors usually can’t handle all
    of them. This section covers some of the more popular evasions in today’s operating
    environment, but bear in mind that there are many variations to each of these
    techniques.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 攻击者可以采用多种规避技术来绕过AMSI。虽然某些厂商曾尝试标记其中一些为恶意，但AMSI中存在的规避机会数量庞大，因此厂商通常无法应对所有的规避手段。本节将介绍一些当前操作环境中较为流行的规避方法，但请记住，每种技术都有许多变种。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">String Obfuscation</samp>
  id: totrans-104
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">字符串混淆</samp>
- en: One of the earliest evasions for AMSI involved simple string obfuscation. If
    an attacker could determine which part of a script block was being flagged as
    malicious, they could often get around the detection by splitting, encoding, or
    otherwise obscuring the string, as in the example in [Listing 10-23](#list10-23).
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: AMSI的最早规避之一是简单的字符串混淆。如果攻击者能够确定脚本块中哪个部分被标记为恶意，他们通常可以通过拆分、编码或以其他方式掩盖字符串，绕过检测，如[列表10-23](#list10-23)中的示例所示。
- en: '[PRE24]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Listing 10-23: An example of string obfuscation in PowerShell that evades AMSI'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 列表10-23：PowerShell中字符串混淆的示例，能够规避AMSI
- en: AMSI typically flags the string <samp class="SANS_TheSansMonoCd_W5Regular_11">AmsiScanBuffer</samp>,
    a common component of patching-based evasions, as malicious, but here you can
    see that string concatenation allows us to bypass detection. AMSI implementations
    often receive obfuscated code, which they pass off to providers to determine if
    it is malicious. This means the provider must handle language-emulation functions
    such as string concatenation, decoding, and decrypting. However, many providers,
    including Microsoft, fail to detect even trivial bypasses such as the one shown
    here.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: AMSI 通常会将字符串 <samp class="SANS_TheSansMonoCd_W5Regular_11">AmsiScanBuffer</samp>
    标记为恶意，这是基于补丁的规避方式中常见的组成部分，但在这里你可以看到字符串拼接可以帮助我们绕过检测。AMSI 实现通常会接收到混淆的代码，然后将其传递给提供程序，以确定其是否为恶意代码。这意味着提供程序必须处理语言模拟函数，如字符串拼接、解码和解密。然而，包括微软在内的许多提供程序甚至无法检测到像这里展示的这种简单绕过。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">AMSI Patching</samp>
  id: totrans-109
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">AMSI 补丁</samp>
- en: Because AMSI and its associated providers get mapped into the attacker’s process,
    the attacker has control over this memory. By patching critical values or functions
    inside *amsi.dll*, they can prevent AMSI from functioning inside their process.
    This evasion technique is extremely potent and has been the go-to choice for many
    red teams since around 2016, when Matt Graeber discussed using reflection inside
    PowerShell to patch <samp class="SANS_TheSansMonoCd_W5Regular_11">amsiInitFailed</samp>
    to <samp class="SANS_TheSansMonoCd_W5Regular_11">true</samp>. His code, included
    in [Listing 10-24](#list10-24), fit into a single tweet.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 AMSI 及其关联的提供程序被映射到攻击者的进程中，攻击者能够控制这些内存。通过补丁 *amsi.dll* 中的关键值或函数，攻击者可以防止 AMSI
    在其进程中正常工作。这种规避技术非常强大，自 2016 年左右 Matt Graeber 讨论在 PowerShell 中使用反射来将 <samp class="SANS_TheSansMonoCd_W5Regular_11">amsiInitFailed</samp>
    补丁设置为 <samp class="SANS_TheSansMonoCd_W5Regular_11">true</samp> 以来，已经成为许多红队的首选方法。他的代码被包含在
    [Listing 10-24](#list10-24) 中，甚至能适配到一条推文中。
- en: '[PRE25]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Listing 10-24: A simple <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">AmsiInitFailed</samp>
    patch'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: Listing 10-24：一个简单的 <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">AmsiInitFailed</samp>
    补丁
- en: 'When it comes to patching, attackers commonly target <samp class="SANS_TheSansMonoCd_W5Regular_11">AmsiScanBuffer()</samp>,
    the function responsible for passing buffer contents to the providers. Daniel
    Duggan describes this technique in a blog post, “Memory Patching AMSI Bypass,”
    where he outlines the steps an attacker’s code must take before performing any
    truly malicious activity:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 在进行补丁时，攻击者通常会针对 <samp class="SANS_TheSansMonoCd_W5Regular_11">AmsiScanBuffer()</samp>
    这个函数，它负责将缓冲区内容传递给提供程序。Daniel Duggan 在一篇博客文章《内存补丁 AMSI 绕过》中描述了这一技巧，在文章中他概述了攻击者的代码在执行任何真正的恶意活动之前必须采取的步骤：
- en: Retrieve the address of <samp class="SANS_TheSansMonoCd_W5Regular_11">AmsiScanBuffer()</samp>
    within the *amsi.dll* currently loaded into the process.
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 获取当前加载到进程中的 *amsi.dll* 中 <samp class="SANS_TheSansMonoCd_W5Regular_11">AmsiScanBuffer()</samp>
    的地址。
- en: Use <samp class="SANS_TheSansMonoCd_W5Regular_11">kernel32!VirtualProtect()</samp>
    to change the memory protections to read-write, which allows the attacker to place
    the patch.
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 <samp class="SANS_TheSansMonoCd_W5Regular_11">kernel32!VirtualProtect()</samp>
    将内存保护更改为可读写模式，这样攻击者就可以放置补丁。
- en: Copy the patch into the entry point of the <samp class="SANS_TheSansMonoCd_W5Regular_11">AmsiScanBuffer()</samp>
    function.
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将补丁复制到 <samp class="SANS_TheSansMonoCd_W5Regular_11">AmsiScanBuffer()</samp>
    函数的入口点。
- en: Use <samp class="SANS_TheSansMonoCd_W5Regular_11">kernel32!VirtualProtect()</samp>
    once again to revert the memory protection back to read-execute.
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再次使用 <samp class="SANS_TheSansMonoCd_W5Regular_11">kernel32!VirtualProtect()</samp>
    恢复内存保护为可读执行模式。
- en: The patch itself takes advantage of the fact that, internally, <samp class="SANS_TheSansMonoCd_W5Regular_11">AmsiScanBuffer()</samp>
    returns <samp class="SANS_TheSansMonoCd_W5Regular_11">E_INVALIDARG</samp> if its
    initial checks fail. These checks include attempts to validate the address of
    the buffer to be scanned. Duggan’s code adds a byte array that represents the
    assembly code in [Listing 10-25](#list10-25). After this patch, when <samp class="SANS_TheSansMonoCd_W5Regular_11">AmsiScanBuffer()</samp>
    is executed, it will immediately return this error code because the actual instruction
    that made up the original function has been overwritten.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 补丁本身利用了一个事实，即在内部，如果其初始检查失败，<samp class="SANS_TheSansMonoCd_W5Regular_11">AmsiScanBuffer()</samp>
    将返回 <samp class="SANS_TheSansMonoCd_W5Regular_11">E_INVALIDARG</samp>。这些检查包括尝试验证要扫描的缓冲区的地址。Duggan
    的代码添加了一个表示 [列表 10-25](#list10-25) 中汇编代码的字节数组。在这个补丁之后，当执行 <samp class="SANS_TheSansMonoCd_W5Regular_11">AmsiScanBuffer()</samp>
    时，它将立即返回这个错误代码，因为构成原始函数的实际指令已被覆盖。
- en: '[PRE26]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Listing 10-25: Error code returned to the caller of <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">AmsiScanBuffer()</samp>
    after the patch'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 10-25：在补丁后返回给 <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">AmsiScanBuffer()</samp>
    的错误代码
- en: There are many variations of this technique, all of which work very similarly.
    For example, an attacker may patch <samp class="SANS_TheSansMonoCd_W5Regular_11">AmsiOpenSession()</samp>
    instead of <samp class="SANS_TheSansMonoCd_W5Regular_11">AmsiScanBuffer()</samp>.
    They may also opt to corrupt one of the parameters passed into <samp class="SANS_TheSansMonoCd_W5Regular_11">AmsiScanBuffer()</samp>,
    such as the buffer length or the context, causing AMSI to return <samp class="SANS_TheSansMonoCd_W5Regular_11">E_INVALIDARG</samp>
    on its own.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 这种技术有许多变体，它们都工作原理非常相似。例如，攻击者可能会修改 <samp class="SANS_TheSansMonoCd_W5Regular_11">AmsiOpenSession()</samp>
    而不是 <samp class="SANS_TheSansMonoCd_W5Regular_11">AmsiScanBuffer()</samp>。他们也可以选择破坏传入
    <samp class="SANS_TheSansMonoCd_W5Regular_11">AmsiScanBuffer()</samp> 的参数之一，如缓冲区长度或上下文，导致
    AMSI 自行返回 <samp class="SANS_TheSansMonoCd_W5Regular_11">E_INVALIDARG</samp>。
- en: Microsoft got wise to this evasion technique pretty quickly and took measures
    to defend against the bypass. One of the detections it implemented is based on
    the sequence of opcodes that make up the patch we’ve described. However, attackers
    can work around these detections in many ways. For example, they can simply modify
    their assembly code to achieve the same result, moving <samp class="SANS_TheSansMonoCd_W5Regular_11">0x80070057</samp>
    into <samp class="SANS_TheSansMonoCd_W5Regular_11">EAX</samp> and returning, in
    a way that is less direct. Consider the example in [Listing 10-26](#list10-26),
    which breaks up the value <samp class="SANS_TheSansMonoCd_W5Regular_11">0x80070057</samp>
    instead of moving it into the register all at once.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 微软很快意识到了这种逃避技术，并采取措施防止绕过。它实施的检测之一基于我们描述的补丁所组成的操作码序列。然而，攻击者可以通过多种方式规避这些检测。例如，他们可以简单地修改他们的汇编代码以达到相同的结果，将
    <samp class="SANS_TheSansMonoCd_W5Regular_11">0x80070057</samp> 移入 <samp class="SANS_TheSansMonoCd_W5Regular_11">EAX</samp>
    并返回，这样的方式不那么直接。请考虑 [第 10-26 列表](#list10-26) 中的示例，该示例将值 <samp class="SANS_TheSansMonoCd_W5Regular_11">0x80070057</samp>
    分解，而不是一次性将其移入寄存器。
- en: '[PRE27]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Listing 10-26: Breaking up hardcoded values to evade patch detection'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 10-26：分解硬编码值以规避补丁检测
- en: Imagine that the EDR looks for the value <samp class="SANS_TheSansMonoCd_W5Regular_11">0x80070057</samp>
    being moved into the <samp class="SANS_TheSansMonoCd_W5Regular_11">EAX</samp>
    register. This evasion strategy would bypass its detection logic because the value
    is never directly referenced. Instead, it is broken up into two values, which
    happen to add up to the required value.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下，EDR 寻找将值 <samp class="SANS_TheSansMonoCd_W5Regular_11">0x80070057</samp>
    移入 <samp class="SANS_TheSansMonoCd_W5Regular_11">EAX</samp> 寄存器的情况。这种逃避策略将绕过其检测逻辑，因为该值从未被直接引用。相反，它被分解成两个值，这两个值恰好加起来等于所需值。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">A Patchless AMSI
    Bypass</samp>
  id: totrans-126
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">无需补丁的 AMSI 绕过</samp>
- en: In April 2022, Ceri Coburn unveiled a technique for bypassing AMSI without patching
    *amsi.dll*, an activity many EDR vendors have begun to monitor. Coburn’s technique
    doesn’t require fork&run either, allowing the attacker to stay in their original
    process.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 在2022年4月，Ceri Coburn 揭示了一种绕过 AMSI 的技术，而无需对 *amsi.dll* 进行补丁，这是许多 EDR 供应商已经开始监控的活动。Coburn
    的技术也不需要分叉和运行，允许攻击者保持在他们的原始进程中。
- en: The technique is quite clever. First, the attacker obtains a function pointer
    to <samp class="SANS_TheSansMonoCd_W5Regular_11">amsi!AmsiScanBuffer()</samp>
    either from the loaded *amsi.dll* or by forcing it to load into the process through
    a call to <samp class="SANS_TheSansMonoCd_W5Regular_11">LoadLibrary()</samp>.
    Next, they register a vectored exception handler via <samp class="SANS_TheSansMonoCd_W5Regular_11">kernel32!AddVectoredExceptionHandler()</samp>.
    This handler allows developers to register a function that monitors and manages
    all exceptions in the application. Finally, they set a hardware breakpoint on
    the address of <samp class="SANS_TheSansMonoCd_W5Regular_11">AmsiScanBuffer()</samp>
    by modifying the current thread’s debug registers (<samp class="SANS_TheSansMonoCd_W5Regular_11">DR0</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">DR6</samp>, and <samp class="SANS_TheSansMonoCd_W5Regular_11">DR7</samp>).
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 这个技术相当巧妙。首先，攻击者从加载的 *amsi.dll* 中获取 <samp class="SANS_TheSansMonoCd_W5Regular_11">amsi!AmsiScanBuffer()</samp>
    的函数指针，或者通过调用 <samp class="SANS_TheSansMonoCd_W5Regular_11">LoadLibrary()</samp>
    强制其加载到进程中。接着，他们通过 <samp class="SANS_TheSansMonoCd_W5Regular_11">kernel32!AddVectoredExceptionHandler()</samp>
    注册一个矢量异常处理程序。这个处理程序允许开发者注册一个函数来监控和管理应用中的所有异常。最后，他们通过修改当前线程的调试寄存器（<samp class="SANS_TheSansMonoCd_W5Regular_11">DR0</samp>、<samp
    class="SANS_TheSansMonoCd_W5Regular_11">DR6</samp> 和 <samp class="SANS_TheSansMonoCd_W5Regular_11">DR7</samp>）在
    <samp class="SANS_TheSansMonoCd_W5Regular_11">AmsiScanBuffer()</samp> 的地址上设置硬件断点。
- en: When the attacker executes their .NET code inline, the system will eventually
    call <samp class="SANS_TheSansMonoCd_W5Regular_11">AmsiScanBuffer()</samp>, triggering
    the hardware breakpoint and invoking the vectored exception handler. This function
    takes the current thread context and updates the registers to match the values
    set when AMSI doesn’t detect malicious content, namely a return value of <samp
    class="SANS_TheSansMonoCd_W5Regular_11">0 (S-OK)</samp> in <samp class="SANS_TheSansMonoCd_W5Regular_11">RAX</samp>
    and a result of <samp class="SANS_TheSansMonoCd_W5Regular_11">0 (AMSI_RESULT_CLEAN)</samp>
    in <samp class="SANS_TheSansMonoCd_W5Regular_11">RS</samp><samp class="SANS_TheSansMonoCd_W5Regular_11">P+</samp><samp
    class="SANS_TheSansMonoCd_W5Regular_11">48</samp>.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 当攻击者执行他们的 .NET 内联代码时，系统最终会调用 <samp class="SANS_TheSansMonoCd_W5Regular_11">AmsiScanBuffer()</samp>，触发硬件断点并调用矢量异常处理程序。这个函数获取当前线程上下文，并更新寄存器以匹配当
    AMSI 未检测到恶意内容时设置的值，即 <samp class="SANS_TheSansMonoCd_W5Regular_11">0 (S-OK)</samp>
    在 <samp class="SANS_TheSansMonoCd_W5Regular_11">RAX</samp> 中，<samp class="SANS_TheSansMonoCd_W5Regular_11">0
    (AMSI_RESULT_CLEAN)</samp> 在 <samp class="SANS_TheSansMonoCd_W5Regular_11">RS</samp><samp
    class="SANS_TheSansMonoCd_W5Regular_11">P+</samp><samp class="SANS_TheSansMonoCd_W5Regular_11">48</samp>
    中。
- en: Additionally, it pulls the return address from the stack (<samp class="SANS_TheSansMonoCd_W5Regular_11">RSP</samp>)
    and points the instruction pointer (<samp class="SANS_TheSansMonoCd_W5Regular_11">RIP</samp>)
    back to the caller of the <samp class="SANS_TheSansMonoCd_W5Regular_11">AmsiScanBuffer()</samp>
    function. Next, it walks the stack pointer back to its position from before the
    call to <samp class="SANS_TheSansMonoCd_W5Regular_11">AmsiScanBuffer()</samp>,
    clears the hardware breakpoint, and returns the <samp class="SANS_TheSansMonoCd_W5Regular_11">EXCEPTION_CONTINUE_EXECUTION</samp>
    code. Execution resumes at the point at which the breakpoint occurred. Now Windows
    will take the attacker’s modified thread context and continue execution with our
    changes in place, passing the falsified values back to the caller and letting
    the malicious code continue undetected.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，它从栈中提取返回地址（<samp class="SANS_TheSansMonoCd_W5Regular_11">RSP</samp>），并将指令指针（<samp
    class="SANS_TheSansMonoCd_W5Regular_11">RIP</samp>）指向 <samp class="SANS_TheSansMonoCd_W5Regular_11">AmsiScanBuffer()</samp>
    函数的调用者。接下来，它将栈指针回退到调用 <samp class="SANS_TheSansMonoCd_W5Regular_11">AmsiScanBuffer()</samp>
    之前的位置，清除硬件断点，并返回 <samp class="SANS_TheSansMonoCd_W5Regular_11">EXCEPTION_CONTINUE_EXECUTION</samp>
    代码。执行从断点处恢复。现在，Windows 将使用攻击者修改的线程上下文继续执行，将伪造的值传回给调用者，并允许恶意代码继续执行而不被发现。
- en: <samp class="SANS_Futura_Std_Bold_B_11">Conclusion</samp>
  id: totrans-131
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">结论</samp>
- en: AMSI is an incredibly important piece of the host-based detection puzzle. Its
    integration into software such as PowerShell, .NET, and Microsoft Office means
    that it sits inline of many adversary activities, from initial access through
    post-exploitation. AMSI has been heavily researched due to its tremendous impact
    on offensive operations at the time of its release. Today, AMSI fills more of
    a supplementary role, as nearly countless evasion strategies exist for it. However,
    vendors have caught on to this and have begun to invest in monitoring for common
    AMSI evasion strategies, then using those as indicators of adversary activity
    themselves.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: AMSI 是基于主机检测中的一个极为重要的组成部分。它与 PowerShell、.NET 和 Microsoft Office 等软件的集成意味着它在许多对抗活动中扮演了关键角色，从初步访问到后期利用。由于其在发布时对攻防作战的巨大影响，AMSI
    曾经受到广泛研究。如今，AMSI 更加充当补充角色，因为几乎存在无数种规避策略。不过，厂商已经意识到这一点，并开始投入资源，监控常见的 AMSI 规避策略，然后将这些作为对抗活动的指示器。
