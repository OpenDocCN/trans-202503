- en: Chapter 6. Processes
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第6章 进程
- en: In this chapter, we look at the structure of a process, paying particular attention
    to the layout and contents of a process’s virtual memory. We also examine some
    of the attributes of a process. In later chapters, we examine further process
    attributes (for example, process credentials in [Chapter 9](ch09.html "Chapter 9. Process
    Credentials"), and process priorities and scheduling in [Chapter 35](ch35.html
    "Chapter 35. Process Priorities and Scheduling")). In [Chapter 24](ch24.html "Chapter 24. Process
    Creation") to [Chapter 27](ch27.html "Chapter 27. Program Execution"), we look
    at how processes are created, how they terminate, and how they can be made to
    execute new programs.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将研究进程的结构，特别关注进程虚拟内存的布局和内容。我们还将检查进程的一些属性。在后续章节中，我们将进一步探讨进程属性（例如，第9章中的进程凭据[Chapter
    9](ch09.html "Chapter 9. Process Credentials")，以及第35章中的进程优先级和调度[Chapter 35](ch35.html
    "Chapter 35. Process Priorities and Scheduling")）。在[第24章](ch24.html "Chapter 24.
    Process Creation")到[第27章](ch27.html "Chapter 27. Program Execution")中，我们将讨论进程是如何创建的、如何终止的，以及如何使其执行新程序。
- en: Processes and Programs
  id: totrans-2
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 进程与程序
- en: A *process* is an instance of an executing program. In this section, we elaborate
    on this definition and clarify the distinction between a program and a process.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: '*进程*是一个执行中的程序实例。在本节中，我们将详细阐述这个定义，并澄清程序与进程之间的区别。'
- en: 'A *program* is a file containing a range of information that describes how
    to construct a process at run time. This information includes the following:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: '*程序*是一个包含各种信息的文件，这些信息描述了如何在运行时构建一个进程。这些信息包括以下内容：'
- en: '*Binary format identification*: Each program file includes metainformation
    describing the format of the executable file. This enables the kernel to interpret
    the remaining information in the file. Historically, two widely used formats for
    UNIX executable files were the original *a.out* (“assembler output”) format and
    the later, more sophisticated *COFF* (Common Object File Format). Nowadays, most
    UNIX implementations (including Linux) employ the Executable and Linking Format
    (ELF), which provides a number of advantages over the older formats.'
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*二进制格式标识*：每个程序文件都包含描述可执行文件格式的元信息。这使得内核能够解释文件中的其他信息。从历史上看，UNIX可执行文件的两种广泛使用的格式是最初的*a.out*（“汇编输出”）格式和后来的、更复杂的*COFF*（公共对象文件格式）。如今，大多数UNIX实现（包括Linux）采用可执行与链接格式（ELF），相比旧格式，ELF提供了多种优势。'
- en: '*Machine-language instructions*: These encode the algorithm of the program.'
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*机器语言指令*：这些指令编码了程序的算法。'
- en: '*Program entry-point address*: This identifies the location of the instruction
    at which execution of the program should commence.'
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*程序入口点地址*：这是标识程序执行应从哪条指令开始的地址。'
- en: '*Data*: The program file contains values used to initialize variables and also
    literal constants used by the program (e.g., strings).'
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*数据*：程序文件包含用于初始化变量的值，以及程序使用的字面常量（例如字符串）。'
- en: '*Symbol and relocation tables:* These describe the locations and names of functions
    and variables within the program. These tables are used for a variety of purposes,
    including debugging and run-time symbol resolution (dynamic linking).'
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*符号和重定位表*：这些表描述了程序中函数和变量的位置和名称。这些表用于多种目的，包括调试和运行时符号解析（动态链接）。'
- en: '*Shared-library and dynamic-linking information*: The program file includes
    fields listing the shared libraries that the program needs to use at run time
    and the pathname of the dynamic linker that should be used to load these libraries.'
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*共享库和动态链接信息*：程序文件包括列出程序在运行时需要使用的共享库的字段，以及应该用于加载这些库的动态链接器的路径名。'
- en: '*Other information*: The program file contains various other information that
    describes how to construct a process.'
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*其他信息*：程序文件包含了描述如何构建进程的各种其他信息。'
- en: One program may be used to construct many processes, or, put conversely, many
    processes may be running the same program.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 一个程序可以用来构建多个进程，或者反过来，多个进程可以运行同一个程序。
- en: 'We can recast the definition of a process given at the start of this section
    as follows: a process is an abstract entity, defined by the kernel, to which system
    resources are allocated in order to execute a program.'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将本节开始时给出的进程定义重新表述如下：进程是一个抽象实体，由内核定义，系统资源被分配给它以执行程序。
- en: From the kernel’s point of view, a process consists of user-space memory containing
    program code and variables used by that code, and a range of kernel data structures
    that maintain information about the state of the process. The information recorded
    in the kernel data structures includes various identifier numbers (IDs) associated
    with the process, virtual memory tables, the table of open file descriptors, information
    relating to signal delivery and handling, process resource usages and limits,
    the current working directory, and a host of other information.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 从内核的角度来看，一个进程由用户空间的内存组成，其中包含程序代码和该代码使用的变量，以及一系列内核数据结构，这些数据结构维护有关进程状态的信息。记录在内核数据结构中的信息包括与进程相关的各种标识符号码（ID），虚拟内存表，打开的文件描述符表，信号传递和处理的信息，进程资源的使用情况和限制，当前工作目录，以及其他一系列信息。
- en: Process ID and Parent Process ID
  id: totrans-15
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 进程ID和父进程ID
- en: 'Each process has a process ID (PID), a positive integer that uniquely identifies
    the process on the system. Process IDs are used and returned by a variety of system
    calls. For example, the *kill()* system call ([Sending Signals: *kill()*](ch20.html#sending_signals_colon_kill_open_parenthe
    "Sending Signals: kill()")) allows the caller to send a signal to a process with
    a specific process ID. The process ID is also useful if we need to build an identifier
    that is unique to a process. A common example of this is the use of the process
    ID as part of a process-unique filename.'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '每个进程都有一个进程ID（PID），它是一个正整数，用来唯一标识系统上的进程。进程ID被各种系统调用使用并返回。例如，*kill()*系统调用（[发送信号：*kill()*](ch20.html#sending_signals_colon_kill_open_parenthe
    "Sending Signals: kill()")）允许调用者向具有特定进程ID的进程发送信号。进程ID在我们需要构建一个唯一标识进程的标识符时也很有用。一个常见的例子是将进程ID作为进程唯一文件名的一部分。'
- en: The *getpid()* system call returns the process ID of the calling process.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '*getpid()*系统调用返回调用进程的进程ID。'
- en: '[PRE0]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Note
  id: totrans-19
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Always successfully returns process ID of caller
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 始终成功返回调用者的进程ID。
- en: The *pid_t* data type used for the return value of *getpid()* is an integer
    type specified by SUSv3 for the purpose of storing process IDs.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 用于*getpid()*返回值的*pid_t*数据类型是一个由SUSv3指定的整数类型，用于存储进程ID。
- en: With the exception of a few system processes such as *init* (process ID 1),
    there is no fixed relationship between a program and the process ID of the process
    that is created to run that program.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 除了一些系统进程，比如*init*（进程ID为1），程序和为运行该程序创建的进程ID之间没有固定的关系。
- en: The Linux kernel limits process IDs to being less than or equal to 32,767\.
    When a new process is created, it is assigned the next sequentially available
    process ID. Each time the limit of 32,767 is reached, the kernel resets its process
    ID counter so that process IDs are assigned starting from low integer values.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: Linux内核将进程ID限制为小于或等于32,767。当创建一个新进程时，它将分配下一个顺序可用的进程ID。每次达到32,767的限制时，内核会重置其进程ID计数器，从而重新分配低整数值作为进程ID。
- en: Note
  id: totrans-24
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Once it has reached 32,767, the process ID counter is reset to 300, rather than
    1\. This is done because many low-numbered process IDs are in permanent use by
    system processes and daemons, and thus time would be wasted searching for an unused
    process ID in this range.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦达到32,767，进程ID计数器将重置为300，而不是1。这是因为许多低编号的进程ID已被系统进程和守护进程永久使用，因此在这个范围内查找未使用的进程ID将浪费时间。
- en: In Linux 2.4 and earlier, the process ID limit of 32,767 is defined by the kernel
    constant `PID_MAX`. With Linux 2.6, things change. While the default upper limit
    for process IDs remains 32,767, this limit is adjustable via the value in the
    Linux-specific `/proc/sys/kernel/pid_max` file (which is one greater than the
    maximum process ID). On 32-bit platforms, the maximum value for this file is 32,768,
    but on 64-bit platforms, it can be adjusted to any value up to 222 (approximately
    4 million), making it possible to accommodate very large numbers of processes.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在Linux 2.4及以前版本中，进程ID的上限32,767由内核常量`PID_MAX`定义。随着Linux 2.6的发布，情况发生了变化。虽然进程ID的默认上限仍然是32,767，但此限制可以通过Linux特有的`/proc/sys/kernel/pid_max`文件中的值进行调整（该值比最大进程ID大1）。在32位平台上，该文件的最大值为32,768，但在64位平台上，它可以调整到任何最大值，最高可达222（大约400万），使得能够容纳非常大的进程数。
- en: Each process has a parent—the process that created it. A process can find out
    the process ID of its parent using the *getppid()* system call.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 每个进程都有一个父进程——即创建它的进程。进程可以通过*getppid()*系统调用来获取父进程的进程ID。
- en: '[PRE1]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Note
  id: totrans-29
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Always successfully returns process ID of parent of caller
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 始终成功返回调用者父进程的进程ID
- en: In effect, the parent process ID attribute of each process represents the tree-like
    relationship of all processes on the system. The parent of each process has its
    own parent, and so on, going all the way back to process 1, *init*, the ancestor
    of all processes. (This “family tree” can be viewed using the *pstree(1)* command.)
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，每个进程的父进程 ID 属性代表了系统上所有进程的树状关系。每个进程的父进程也有自己的父进程，以此类推，直到回溯到进程 1，*init*，它是所有进程的祖先。（这个“家谱”可以通过
    *pstree(1)* 命令查看。）
- en: If a child process becomes orphaned because its “birth” parent terminates, then
    the child is adopted by the *init* process, and subsequent calls to *getppid()*
    in the child return 1 (see [Orphans and Zombies](ch26.html#orphans_and_zombies
    "Orphans and Zombies")).
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个子进程因其“出生”父进程终止而变成孤儿进程，则该子进程会被 *init* 进程收养，之后在子进程中调用 *getppid()* 时会返回 1（见
    [孤儿进程与僵尸进程](ch26.html#orphans_and_zombies "孤儿进程与僵尸进程")）。
- en: The parent of any process can be found by looking at the `PPid` field provided
    in the Linux-specific `/proc/`*`PID`*`/status` file.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过查看 Linux 特有的 `/proc/`*`PID`*`/status` 文件中的 `PPid` 字段来找到任何进程的父进程。
- en: Memory Layout of a Process
  id: totrans-34
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 进程的内存布局
- en: 'The memory allocated to each process is composed of a number of parts, usually
    referred to as *segments*. These segments are as follows:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 分配给每个进程的内存由多个部分组成，通常称为 *段*。这些段如下：
- en: The *text segment* contains the machine-language instructions of the program
    run by the process. The text segment is made read-only so that a process doesn’t
    accidentally modify its own instructions via a bad pointer value. Since many processes
    may be running the same program, the text segment is made sharable so that a single
    copy of the program code can be mapped into the virtual address space of all of
    the processes.
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*文本段*包含程序运行时的机器语言指令。文本段被设为只读，以防止进程通过错误的指针值意外修改自己的指令。由于多个进程可能在运行相同的程序，文本段被设为可共享，从而使得程序代码的单一副本可以映射到所有进程的虚拟地址空间中。'
- en: The *initialized data segment* contains global and static variables that are
    explicitly initialized. The values of these variables are read from the executable
    file when the program is loaded into memory.
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*初始化数据段*包含显式初始化的全局变量和静态变量。这些变量的值在程序加载到内存时从可执行文件中读取。'
- en: The *uninitialized data segment* contains global and static variables that are
    not explicitly initialized. Before starting the program, the system initializes
    all memory in this segment to 0\. For historical reasons, this is often called
    the *bss* segment, a name derived from an old assembler mnemonic for “block started
    by symbol.” The main reason for placing global and static variables that are initialized
    into a separate segment from those that are uninitialized is that, when a program
    is stored on disk, it is not necessary to allocate space for the uninitialized
    data. Instead, the executable merely needs to record the location and size required
    for the uninitialized data segment, and this space is allocated by the program
    loader at run time.
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*未初始化数据段*包含未显式初始化的全局变量和静态变量。在程序启动之前，系统会将该段的所有内存初始化为 0。出于历史原因，这个段通常被称为 *bss*
    段，这是一个源自旧汇编助记符“由符号开始的块”（block started by symbol）的名称。将已初始化的全局和静态变量与未初始化的变量放在不同的段中的主要原因是，当程序存储在磁盘上时，无需为未初始化的数据分配空间。相反，可执行文件仅需要记录未初始化数据段所需的位置和大小，在运行时由程序加载器分配该空间。'
- en: The *stack* is a dynamically growing and shrinking segment containing stack
    frames. One stack frame is allocated for each currently called function. A frame
    stores the function’s local variables (so-called automatic variables), arguments,
    and return value. Stack frames are discussed in more detail in Section 6.5.
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*栈*是一个动态增长和缩小的段，包含栈帧。每调用一个函数，都会为其分配一个栈帧。栈帧存储函数的局部变量（即自动变量）、参数和返回值。栈帧将在第 6.5
    节中进一步讨论。'
- en: The *heap* is an area from which memory (for variables) can be dynamically allocated
    at run time. The top end of the heap is called the *program break*.
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*堆*是一个可以在运行时动态分配内存（用于变量）的区域。堆的顶部被称为 *程序断点*。'
- en: Less commonly used, but more descriptive labels for the initialized and uninitialized
    data segments are *user-initialized data segment* and *zero-initialized data segment*.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 较少使用，但更具描述性的标签用于初始化和未初始化数据段，分别是 *用户初始化数据段* 和 *零初始化数据段*。
- en: The *size(1)* command displays the size of the text, initialized data, and uninitialized
    data (*bss*) segments of a binary executable.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '*size(1)* 命令显示二进制可执行文件中文本段、已初始化数据段和未初始化数据（*bss*）段的大小。'
- en: Note
  id: totrans-43
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注
- en: The term *segment* as used in the main text should not be confused with the
    hardware segmentation used on some hardware architectures such as x86-32\. Rather,
    segments are logical divisions of a process’s virtual memory on UNIX systems.
    Sometimes, the term *section* is used instead of *segment*, since *section* is
    more consistent with the terminology used in the now ubiquitous ELF specification
    for executable file formats.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 文中使用的术语*段*不应与某些硬件架构（如 x86-32）上使用的硬件分段混淆。实际上，段是 UNIX 系统中进程虚拟内存的逻辑划分。有时，术语*区段*会替代*段*使用，因为*区段*与现在广泛使用的
    ELF 可执行文件格式规范中的术语更加一致。
- en: In many places in this book, we note that a library function returns a pointer
    to statically allocated memory. By this, we mean that the memory is allocated
    in either the initialized or the uninitialized data segment. (In some cases, the
    library function may instead do a one-time dynamic allocation of the memory on
    the heap; however, this implementation detail is irrelevant to the semantic point
    we describe here.) It is important to be aware of cases where a library function
    returns information via statically allocated memory, since that memory has an
    existence that is independent of the function invocation, and the memory may be
    overwritten by subsequent calls to the same function (or in some cases, by subsequent
    calls to related functions). The effect of using statically allocated memory is
    to render a function nonreentrant. We say more about reentrancy in [Reentrant
    and Async-Signal-Safe Functions](ch21.html#reentrant_and_async-signal-safe_function
    "Reentrant and Async-Signal-Safe Functions") and [Thread Safety (and Reentrancy
    Revisited)](ch31.html#thread_safety_open_parenthesis_and_reent "Thread Safety
    (and Reentrancy Revisited)").
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 本书中的许多地方都提到，库函数返回指向静态分配内存的指针。这里的意思是，该内存是在已初始化或未初始化的数据段中分配的。（在某些情况下，库函数可能会在堆上进行一次动态内存分配；然而，这一实现细节与我们在这里描述的语义点无关。）需要注意的是，库函数返回的信息通过静态分配的内存传递，因为该内存的存在是独立于函数调用的，并且该内存可能会被后续对同一函数的调用（或在某些情况下，对相关函数的调用）覆盖。使用静态分配内存的效果是使函数变为不可重入。关于重入性，我们在[可重入和异步信号安全函数](ch21.html#reentrant_and_async-signal-safe_function
    "可重入和异步信号安全函数")以及[线程安全（和重入性再探）](ch31.html#thread_safety_open_parenthesis_and_reent
    "线程安全（和重入性再探）")中有更详细的讨论。
- en: '[Example 6-1](ch06.html#locations_of_program_variables_in_proces "Example 6-1. Locations
    of program variables in process memory segments") shows various types of C variables
    along with comments indicating in which segment each variable is located. These
    comments assume a nonoptimizing compiler and an application binary interface in
    which all arguments are passed on the stack. In practice, an optimizing compiler
    may allocate frequently used variables in registers, or optimize a variable out
    of existence altogether. Furthermore, some ABIs require function arguments and
    the function result to be passed via registers, rather than on the stack. Nevertheless,
    this example serves to demonstrate the mapping between C variables and the segments
    of a process.'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 6-1](ch06.html#locations_of_program_variables_in_proces "示例 6-1. 程序变量在进程内存段中的位置")展示了各种类型的
    C 变量，并附有注释指明每个变量所在的段。这些注释假设使用的是非优化编译器，并且应用程序二进制接口中所有参数都通过栈传递。在实践中，优化编译器可能会将频繁使用的变量分配到寄存器中，或完全优化掉某些变量。此外，一些
    ABI 规定函数参数和函数结果应通过寄存器而非栈传递。尽管如此，此示例仍能展示 C 变量与进程段之间的映射关系。'
- en: Example 6-1. Locations of program variables in process memory segments
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 6-1. 程序变量在进程内存段中的位置
- en: '[PRE2]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Note
  id: totrans-49
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注
- en: An *application binary interface* (ABI) is a set of rules specifying how a binary
    executable should exchange information with some service (e.g., the kernel or
    a library) at run time. Among other things, an ABI specifies which registers and
    stack locations are used to exchange this information, and what meaning is attached
    to the exchanged values. Once compiled for a particular ABI, a binary executable
    should be able to run on any system presenting the same ABI. This contrasts with
    a standardized API (such as SUSv3), which guarantees portability only for applications
    compiled from source code.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '*应用二进制接口*（ABI）是一组规则，规定了二进制可执行文件在运行时如何与某些服务（例如内核或库）交换信息。ABI规定了交换这些信息时使用哪些寄存器和栈位置，以及交换值的含义。编译为特定ABI的二进制可执行文件应该能够在任何呈现相同ABI的系统上运行。这与标准化的API（如SUSv3）不同，后者只保证从源代码编译的应用程序的可移植性。'
- en: 'Although not specified in SUSv3, the C program environment on most UNIX implementations
    (including Linux) provides three global symbols: *etext*, *edata*, and *end*.
    These symbols can be used from within a program to obtain the addresses of the
    next byte past, respectively, the end of the program text, the end of the initialized
    data segment, and the end of the uninitialized data segment. To make use of these
    symbols, we must explicitly declare them, as follows:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管在SUSv3中没有规定，但在大多数UNIX实现（包括Linux）中的C程序环境提供了三个全局符号：*etext*、*edata*和*end*。这些符号可以在程序中使用，以分别获取程序文本结束、已初始化数据段结束和未初始化数据段结束之后的下一个字节的地址。为了使用这些符号，我们必须显式声明它们，如下所示：
- en: '[PRE3]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '[Figure 6-1](ch06.html#typical_memory_layout_of_a_process_on_li "Figure 6-1. Typical
    memory layout of a process on Linux/x86-32") shows the arrangement of the various
    memory segments on the x86-32 architecture. The space labeled *argv, environ*
    at the top of this diagram holds the program command-line arguments (available
    in C via the *argv* argument of the *main()* function) and the process environment
    list (which we discuss shortly). The hexadecimal addresses shown in the diagram
    may vary, depending on kernel configuration and program linking options. The grayed-out
    areas represent invalid ranges in the process’s virtual address space; that is,
    areas for which page tables have not been created (see the following discussion
    of virtual memory management).'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '[图6-1](ch06.html#typical_memory_layout_of_a_process_on_li "图6-1. Linux/x86-32架构上进程的典型内存布局")显示了x86-32架构上各种内存段的排列。图中顶部标记为*argv,
    environ*的区域包含程序的命令行参数（可以通过*C语言中的*main()*函数的*argv*参数访问）和进程环境列表（我们稍后讨论）。图中显示的十六进制地址可能会有所不同，具体取决于内核配置和程序链接选项。灰色区域表示进程虚拟地址空间中无效的范围；即，尚未创建页表的区域（参见下面关于虚拟内存管理的讨论）。'
- en: We revisit the topic of process memory layout in a little more detail in [Location
    of Shared Memory in Virtual Memory](ch48.html#location_of_shared_memory_in_virtual_mem
    "Location of Shared Memory in Virtual Memory"), where we consider where shared
    memory and shared libraries are placed in a process’s virtual memory.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在[虚拟内存中共享内存的位置](ch48.html#location_of_shared_memory_in_virtual_mem "虚拟内存中共享内存的位置")中更详细地回顾了进程内存布局的话题，讨论了共享内存和共享库在进程虚拟内存中的位置。
- en: Virtual Memory Management
  id: totrans-55
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 虚拟内存管理
- en: The previous discussion of the memory layout of a process glossed over the fact
    that we were talking about the layout in *virtual memory*. Since an understanding
    of virtual memory is useful later on when we look at topics such as the *fork()*
    system call, shared memory, and mapped files, we now consider some of the details.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 前面讨论的进程内存布局忽略了我们实际上在讨论*虚拟内存*中的布局。由于理解虚拟内存在后续讨论诸如*fork()*系统调用、共享内存和映射文件等话题时非常有用，我们现在来考虑一些细节。
- en: 'Like most modern kernels, Linux employs a technique known as *virtual memory
    management*. The aim of this technique is to make efficient use of both the CPU
    and RAM (physical memory) by exploiting a property that is typical of most programs:
    *locality of reference*. Most programs demonstrate two kinds of locality:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 像大多数现代内核一样，Linux采用了一种称为*虚拟内存管理*的技术。该技术的目的是通过利用大多数程序的典型属性——*局部性*，来高效利用CPU和RAM（物理内存）。大多数程序展示了两种局部性：
- en: '*Spatial locality* is the tendency of a program to reference memory addresses
    that are near those that were recently accessed (because of sequential processing
    of instructions, and, sometimes, sequential processing of data structures).'
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*空间局部性*是程序倾向于引用与最近访问过的内存地址接近的地址的特性（由于指令的顺序处理，有时也包括数据结构的顺序处理）。'
- en: '*Temporal locality* is the tendency of a program to access the same memory
    addresses in the near future that it accessed in the recent past (because of loops).'
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*时间局部性*是程序倾向于在不久的将来访问它最近访问过的相同内存地址的特性（因为存在循环）。'
- en: '![Typical memory layout of a process on Linux/x86-32](figs/web/06-1_PROCESS-memory-layout.png.jpg)Figure 6-1. Typical
    memory layout of a process on Linux/x86-32'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '![Linux/x86-32上的进程典型内存布局](figs/web/06-1_PROCESS-memory-layout.png.jpg)图6-1。Linux/x86-32上的进程典型内存布局'
- en: The upshot of locality of reference is that it is possible to execute a program
    while maintaining only part of its address space in RAM.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 局部性引用的结果是，程序在执行时只需要将其地址空间的一部分保留在RAM中。
- en: A virtual memory scheme splits the memory used by each program into small, fixed-size
    units called *pages*. Correspondingly, RAM is divided into a series of *page frames*
    of the same size. At any one time, only some of the pages of a program need to
    be resident in physical memory page frames; these pages form the so-called *resident
    set*. Copies of the unused pages of a program are maintained in the *swap area*—a
    reserved area of disk space used to supplement the computer’s RAM—and loaded into
    physical memory only as required. When a process references a page that is not
    currently resident in physical memory, a *page fault* occurs, at which point the
    kernel suspends execution of the process while the page is loaded from disk into
    memory.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 一种虚拟内存方案将每个程序使用的内存分割成小的固定大小单元，称为*页面*。相应地，RAM被划分为一系列相同大小的*页框*。在任何时候，程序的某些页面只需要驻留在物理内存页框中；这些页面形成所谓的*常驻集*。程序未使用的页面的副本保存在*交换区*——一个用于补充计算机RAM的磁盘空间保留区域——并且仅在需要时加载到物理内存中。当进程引用一个当前不在物理内存中的页面时，会发生*页面错误*，此时内核暂停进程的执行，直到该页面从磁盘加载到内存中。
- en: Note
  id: totrans-63
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: On x86-32, pages are 4096 bytes in size. Some other Linux implementations use
    larger page sizes. For example, Alpha uses a page size of 8192 bytes, and IA-64
    has a variable page size, with the usual default being 16,384 bytes. A program
    can determine the system virtual memory page size using the call *sysconf(_SC_PAGESIZE)*,
    as described in Section 11.2.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在x86-32上，页面大小为4096字节。其他一些Linux实现使用更大的页面大小。例如，Alpha使用8192字节的页面大小，而IA-64具有可变的页面大小，通常的默认值是16,384字节。程序可以使用调用*sysconf(_SC_PAGESIZE)*来确定系统的虚拟内存页面大小，如第11.2节所述。
- en: '![Overview of virtual memory](figs/web/06-2_PROCESS-virtual-memory.png.jpg)Figure 6-2. Overview
    of virtual memory'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '![虚拟内存概述](figs/web/06-2_PROCESS-virtual-memory.png.jpg)图6-2。虚拟内存概述'
- en: In order to support this organization, the kernel maintains a *page table* for
    each process ([Figure 6-2](ch06.html#overview_of_virtual_memory "Figure 6-2. Overview
    of virtual memory")). The page table describes the location of each page in the
    process’s *virtual address space* (the set of all virtual memory pages available
    to the process). Each entry in the page table either indicates the location of
    a virtual page in RAM or indicates that it currently resides on disk.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 为了支持这种组织方式，内核为每个进程维护一个*页表*（[图6-2](ch06.html#overview_of_virtual_memory "图6-2。虚拟内存概述")）。页表描述了进程*虚拟地址空间*（进程可用的所有虚拟内存页面的集合）中每一页的位置。页表中的每个项要么指示一个虚拟页在RAM中的位置，要么指示该页当前驻留在磁盘上。
- en: Not all address ranges in the process’s virtual address space require page-table
    entries. Typically, large ranges of the potential virtual address space are unused,
    so that it isn’t necessary to maintain corresponding page-table entries. If a
    process tries to access an address for which there is no corresponding page-table
    entry, it receives a `SIGSEGV` signal.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 并非进程虚拟地址空间中的所有地址范围都需要页表项。通常，虚拟地址空间中的大范围是未使用的，因此无需维护相应的页表项。如果进程尝试访问一个没有对应页表项的地址，它会收到一个`SIGSEGV`信号。
- en: 'A process’s range of valid virtual addresses can change over its lifetime,
    as the kernel allocates and deallocates pages (and page-table entries) for the
    process. This can happen in the following circumstances:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 一个进程的有效虚拟地址范围可能会随着其生命周期的变化而变化，因为内核会为进程分配和释放页面（以及页表项）。这种情况可能在以下几种情况下发生：
- en: as the stack grows downward beyond limits previously reached;
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当堆栈向下增长超出之前的限制时；
- en: when memory is allocated or deallocated on the heap, by raising the program
    break using *brk()*, *sbrk()*, or the *malloc* family of functions ([Chapter 7](ch07.html
    "Chapter 7. Memory Allocation"));
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当通过*brk()*、*sbrk()*或*malloc*系列函数在堆上分配或释放内存时（[第7章](ch07.html "第7章。内存分配")）；
- en: when System V shared memory regions are attached using *shmat()* and detached
    using *shmdt()* ([Chapter 48](ch48.html "Chapter 48. System V Shared Memory"));
    and
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当使用*shmat()*附加System V共享内存区域并使用*shmdt()*分离时（[第48章](ch48.html "第48章。System V共享内存")）；以及
- en: when memory mappings are created using *mmap()* and unmapped using *munmap()*
    ([Chapter 49](ch49.html "Chapter 49. Memory Mappings")).
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当使用*mmap()*创建内存映射并使用*munmap()*取消映射时（[第49章](ch49.html "第49章。内存映射")）。
- en: Note
  id: totrans-73
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The implementation of virtual memory requires hardware support in the form of
    a *paged memory management unit* (PMMU). The PMMU translates each virtual memory
    address reference into the corresponding physical memory address and advises the
    kernel of a page fault when a particular virtual memory address corresponds to
    a page that is not resident in RAM.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 虚拟内存的实现需要硬件支持，表现为*分页内存管理单元*（PMMU）。PMMU将每个虚拟内存地址引用转换为相应的物理内存地址，并在特定的虚拟内存地址对应的页面不在RAM中时，通知内核发生页面错误。
- en: 'Virtual memory management separates the virtual address space of a process
    from the physical address space of RAM. This provides many advantages:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 虚拟内存管理将进程的虚拟地址空间与物理内存地址空间分开。这带来了许多优点：
- en: Processes are isolated from one another and from the kernel, so that one process
    can’t read or modify the memory of another process or the kernel. This is accomplished
    by having the page-table entries for each process point to distinct sets of physical
    pages in RAM (or in the swap area).
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 进程之间以及进程与内核之间是相互隔离的，因此一个进程无法读取或修改另一个进程或内核的内存。这是通过为每个进程的页表条目指向RAM中不同的物理页面（或交换区）来实现的。
- en: 'Where appropriate, two or more processes can share memory. The kernel makes
    this possible by having page-table entries in different processes refer to the
    same pages of RAM. Memory sharing occurs in two common circumstances:'
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在适当的情况下，两个或多个进程可以共享内存。内核通过使不同进程中的页表条目引用相同的RAM页面来实现这一点。内存共享通常发生在两种常见情况下：
- en: Multiple processes executing the same program can share a single (read-only)
    copy of the program code. This type of sharing is performed implicitly when multiple
    programs execute the same program file (or load the same shared library).
  id: totrans-78
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 执行相同程序的多个进程可以共享程序代码的单个（只读）副本。当多个程序执行相同的程序文件（或加载相同的共享库）时，便会隐式地执行这种共享。
- en: Processes can use the *shmget()* and *mmap()* system calls to explicitly request
    sharing of memory regions with other processes. This is done for the purpose of
    interprocess communication.
  id: totrans-79
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 进程可以使用*shmget()*和*mmap()*系统调用显式请求与其他进程共享内存区域。这是为了进程间通信的目的。
- en: The implementation of memory protection schemes is facilitated; that is, page-table
    entries can be marked to indicate that the contents of the corresponding page
    are readable, writable, executable, or some combination of these protections.
    Where multiple processes share pages of RAM, it is possible to specify that each
    process has different protections on the memory; for example, one process might
    have read-only access to a page, while another has read-write access.
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 便于实现内存保护方案；也就是说，页表条目可以标记，以指示相应页面的内容是否可读、可写、可执行，或者是这些保护的某种组合。当多个进程共享内存中的页面时，可以指定每个进程对内存的不同保护；例如，一个进程可能对某一页面具有只读访问权限，而另一个进程则具有读写访问权限。
- en: Programmers, and tools such as the compiler and linker, don’t need to be concerned
    with the physical layout of the program in RAM.
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 程序员以及编译器和链接器等工具无需关心程序在RAM中的物理布局。
- en: Because only a part of a program needs to reside in memory, the program loads
    and runs faster. Furthermore, the memory footprint (i.e., virtual size) of a process
    can exceed the capacity of RAM.
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于程序的部分内容不需要驻留在内存中，因此程序加载和运行更快。此外，进程的内存占用（即虚拟大小）可以超出RAM的容量。
- en: One final advantage of virtual memory management is that since each process
    uses less RAM, more processes can simultaneously be held in RAM. This typically
    leads to better CPU utilization, since it increases the likelihood that, at any
    moment in time, there is at least one process that the CPU can execute.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 虚拟内存管理的一个最终优势是，由于每个进程使用的RAM更少，可以同时在RAM中保持更多的进程。这通常会导致更好的CPU利用率，因为它增加了在任何时刻至少有一个进程可以被CPU执行的可能性。
- en: The Stack and Stack Frames
  id: totrans-84
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 栈和栈帧
- en: The stack grows and shrinks linearly as functions are called and return. For
    Linux on the x86-32 architecture (and on most other Linux and UNIX implementations),
    the stack resides at the high end of memory and grows downward (toward the heap).
    A special-purpose register, the *stack pointer*, tracks the current top of the
    stack. Each time a function is called, an additional frame is allocated on the
    stack, and this frame is removed when the function returns.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 栈在函数被调用和返回时线性地增长和缩小。对于Linux上的x86-32架构（以及大多数其他Linux和UNIX实现），栈位于内存的高端，并向下增长（朝向堆）。一个专用寄存器——*栈指针*，用于跟踪栈的当前顶部。每次调用一个函数时，栈上都会分配一个额外的栈帧，而这个栈帧会在函数返回时被移除。
- en: Note
  id: totrans-86
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Even though the stack grows downward, we still call the growing end of the stack
    the *top*, since, in abstract terms, that is what it is. The actual direction
    of stack growth is a (hardware) implementation detail. One Linux implementation,
    the HP PA-RISC, does use an upwardly growing stack.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 即使栈是向下增长的，我们仍然称栈的增长端为*顶部*，因为从抽象的角度来看，它就是这样的。栈增长的实际方向是一个（硬件）实现细节。一种Linux实现——HP
    PA-RISC确实使用了一个向上增长的栈。
- en: In virtual memory terms, the stack segment increases in size as stack frames
    are allocated, but on most implementations, it won’t decrease in size after these
    frames are deallocated (the memory is simply reused when new stack frames are
    allocated). When we talk about the stack segment growing and shrinking, we are
    considering things from the logical perspective of frames being added to and removed
    from the stack.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 从虚拟内存的角度来看，栈段在分配栈帧时会增加大小，但在大多数实现中，栈帧被释放后它的大小不会减少（内存会在分配新栈帧时被重新使用）。当我们谈论栈段增长和缩小时，我们是从栈帧被添加到和从栈中移除的逻辑角度来考虑的。
- en: Sometimes, the term *user stack* is used to distinguish the stack we describe
    here from the *kernel stack*. The kernel stack is a per-process memory region
    maintained in kernel memory that is used as the stack for execution of the functions
    called internally during the execution of a system call. (The kernel can’t employ
    the user stack for this purpose since it resides in unprotected user memory.)
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，术语*用户栈*被用来区分我们在这里描述的栈和*内核栈*。内核栈是一个每个进程的内存区域，保存在内核内存中，用作在执行系统调用时内部调用的函数的栈。（内核不能使用用户栈来执行此目的，因为它位于未受保护的用户内存中。）
- en: 'Each (user) stack frame contains the following information:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 每个（用户）栈帧包含以下信息：
- en: '*Function arguments and local variables*: In C these are referred to as *automatic*
    variables, since they are automatically created when a function is called. These
    variables also automatically disappear when the function returns (since the stack
    frame disappears), and this forms the primary semantic distinction between automatic
    and `static` (and global) variables: the latter have a permanent existence independent
    of the execution of functions.'
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*函数参数和局部变量*：在C语言中，这些被称为*自动*变量，因为它们在函数调用时会自动创建。当函数返回时，这些变量也会自动消失（因为栈帧消失），这就是自动变量与`静态`（和全局）变量的主要语义区别：后者具有独立于函数执行的永久存在性。'
- en: '*Call linkage information*: Each function uses certain CPU registers, such
    as the program counter, which points to the next machine-language instruction
    to be executed. Each time one function calls another, a copy of these registers
    is saved in the called function’s stack frame so that when the function returns,
    the appropriate register values can be restored for the calling function.'
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*调用链接信息*：每个函数使用某些CPU寄存器，例如程序计数器，它指向下一个要执行的机器语言指令。每次一个函数调用另一个函数时，这些寄存器的副本会被保存在被调用函数的栈帧中，以便当函数返回时，可以恢复调用函数的相应寄存器值。'
- en: Since functions can call one another, there may be multiple frames on the stack.
    (If a function calls itself recursively, there will be multiple frames on the
    stack for that function.) Referring to [Example 6-1](ch06.html#locations_of_program_variables_in_proces
    "Example 6-1. Locations of program variables in process memory segments"), during
    the execution of the function *square()*, the stack will contain frames as shown
    in [Figure 6-3](ch06.html#example_of_a_process_stack "Figure 6-3. Example of a
    process stack").
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 由于函数可以相互调用，因此栈上可能会有多个栈帧。（如果一个函数递归调用自身，那么栈上会有多个该函数的栈帧。）参见[示例 6-1](ch06.html#locations_of_program_variables_in_proces
    "示例 6-1. 程序变量在进程内存段中的位置")，在执行函数*square()*时，栈上会包含如[图 6-3](ch06.html#example_of_a_process_stack
    "图 6-3. 进程栈示例")所示的栈帧。
- en: '![Example of a process stack](figs/web/06-3_PROCESS-stack-frames-scale90.png.jpg)Figure 6-3. Example
    of a process stack'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '![进程栈示例](figs/web/06-3_PROCESS-stack-frames-scale90.png.jpg)图 6-3. 进程栈示例'
- en: Command-Line Arguments (*argc, argv*)
  id: totrans-95
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 命令行参数 (*argc, argv*)
- en: Every C program must have a function called *main()*, which is the point where
    execution of the program starts. When the program is executed, the command-line
    arguments (the separate words parsed by the shell) are made available via two
    arguments to the function *main()*. The first argument, *int argc*, indicates
    how many command-line arguments there are. The second argument, *char *argv[]*,
    is an array of pointers to the command-line arguments, each of which is a null-terminated
    character string. The first of these strings, in *argv[0]*, is (conventionally)
    the name of the program itself. The list of pointers in *argv* is terminated by
    a `NULL` pointer (i.e., *argv[argc]* is `NULL`).
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 每个 C 程序必须有一个名为*main()*的函数，这是程序执行的起始点。当程序执行时，命令行参数（由 shell 解析的独立单词）通过两个参数传递给函数*main()*。第一个参数，*int
    argc*，表示命令行参数的数量。第二个参数，*char *argv[]*，是一个指向命令行参数的指针数组，每个参数都是一个以 null 终止的字符字符串。第一个字符串，即*argv[0]*，通常是程序本身的名称。*argv*中的指针列表以`NULL`指针结束（即*argv[argc]*为`NULL`）。
- en: The fact that *argv[0]* contains the name used to invoke the program can be
    employed to perform a useful trick. We can create multiple links to (i.e., names
    for) the same program, and then have the program look at *argv[0]* and take different
    actions depending on the name used to invoke it. An example of this technique
    is provided by the *gzip(1)*, *gunzip(1)*, and *zcat(1)* commands, all of which
    are links to the same executable file. (If we employ this technique, we must be
    careful to handle the possibility that the user might invoke the program via a
    link with a name other than any of those that we expect.)
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '*argv[0]*包含用于调用程序的名称这一事实，可以用来执行一个有用的技巧。我们可以创建多个指向同一个程序的链接（即程序的不同名称），然后让程序查看*argv[0]*，根据调用它时使用的名称执行不同的操作。这个技术的一个示例是*gzip(1)*、*gunzip(1)*和*zcat(1)*命令，它们都是指向同一个可执行文件的链接。（如果我们采用这种技术，就必须小心处理用户可能通过一个名称不同于我们预期的链接来调用程序的情况。）'
- en: '[Figure 6-4](ch06.html#values_of_argc_and_argv_for_the_command "Figure 6-4. Values
    of argc and argv for the command necho hello world") shows an example of the data
    structures associated with *argc* and *argv* when executing the program in [Example 6-2](ch06.html#echoing_command-line_arguments
    "Example 6-2. Echoing command-line arguments"). In this diagram, we show the terminating
    null bytes at the end of each string using the C notation `\0`.'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 6-4](ch06.html#values_of_argc_and_argv_for_the_command "图 6-4. 命令 necho
    hello world 的 argc 和 argv 值")展示了与*argc*和*argv*相关的数据结构示例，当执行[示例 6-2](ch06.html#echoing_command-line_arguments
    "示例 6-2. 回显命令行参数")中的程序时。在此图中，我们使用 C 语言表示法`\0`来表示每个字符串末尾的终止空字节。'
- en: '![Values of argc and argv for the command necho hello world](figs/web/06-4_PROCESS-cmd-line-args-scale90.png)Figure 6-4. Values
    of *argc* and *argv* for the command *necho hello world*'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '![命令 necho hello world 的 argc 和 argv 值](figs/web/06-4_PROCESS-cmd-line-args-scale90.png)图
    6-4. 命令*necho hello world*的*argc*和*argv*值'
- en: The program in [Example 6-2](ch06.html#echoing_command-line_arguments "Example 6-2. Echoing
    command-line arguments") echoes its command-line arguments, one per line of output,
    preceded by a string showing which element of *argv* is being displayed.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 6-2](ch06.html#echoing_command-line_arguments "示例 6-2. 回显命令行参数")中的程序会回显其命令行参数，每行输出一个参数，前面会显示正在显示的*argv*元素。'
- en: Example 6-2. Echoing command-line arguments
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 6-2. 回显命令行参数
- en: '[PRE4]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Since the *argv* list is terminated by a `NULL` value, we could alternatively
    code the body of the program in [Example 6-2](ch06.html#echoing_command-line_arguments
    "Example 6-2. Echoing command-line arguments") as follows, to output just the
    command-line arguments one per line:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 *argv* 列表由 `NULL` 值终止，我们可以按照 [示例 6-2](ch06.html#echoing_command-line_arguments
    "示例 6-2. 输出命令行参数") 的方式编写程序体，以便逐行输出命令行参数：
- en: '[PRE5]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: One limitation of the *argc*/*argv* mechanism is that these variables are available
    only as arguments to *main()*. To portably make the command-line arguments available
    in other functions, we must either pass *argv* as an argument to those functions
    or set a global variable pointing to *argv*.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '*argc*/*argv* 机制的一个限制是，这些变量仅在 *main()* 函数的参数中可用。为了在其他函数中便捷地访问命令行参数，我们必须将 *argv*
    作为参数传递给那些函数，或者设置一个全局变量指向 *argv*。'
- en: 'There are a couple of nonportable methods of accessing part or all of this
    information from anywhere in a program:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 有几种非便携式的方法可以从程序中的任何位置访问部分或全部这些信息：
- en: The command-line arguments of any process can be read via the Linux-specific
    `/proc/`*`PID`*`/cmdline` file, with each argument being terminated by a null
    byte. (A program can access its own command-line arguments via `/proc/self/cmdline`.)
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 任何进程的命令行参数可以通过 Linux 特有的 `/proc/`*`PID`*`/cmdline` 文件读取，每个参数由一个空字节终止。（程序可以通过
    `/proc/self/cmdline` 访问其自身的命令行参数。）
- en: The GNU C library provides two global variables that may be used anywhere in
    a program in order to obtain the name used to invoke the program (i.e., the first
    command-line argument). The first of these, *program_invocation_name*, provides
    the complete pathname used to invoke the program. The second, *program_invocation_short_name*,
    provides a version of this name with any directory prefix stripped off (i.e.,
    the basename component of the pathname). Declarations for these two variables
    can be obtained from `<errno.h>` by defining the macro `_GNU_SOURCE`.
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: GNU C 库提供了两个全局变量，可以在程序的任何地方使用，以获取用于调用程序的名称（即第一个命令行参数）。第一个变量，*program_invocation_name*，提供了调用程序时使用的完整路径名。第二个变量，*program_invocation_short_name*，提供了去除任何目录前缀后的名称版本（即路径名的文件名部分）。这两个变量的声明可以通过在
    `<errno.h>` 中定义宏 `_GNU_SOURCE` 来获得。
- en: As shown in [Figure 6-1](ch06.html#typical_memory_layout_of_a_process_on_li
    "Figure 6-1. Typical memory layout of a process on Linux/x86-32"), the *argv*
    and *environ* arrays, as well as the strings they initially point to, reside in
    a single contiguous area of memory just above the process stack. (We describe
    *environ*, which holds the program’s environment list, in the next section.) There
    is an upper limit on the total number of bytes that can be stored in this area.
    SUSv3 prescribes the use of the `ARG_MAX` constant (defined in `<limits.h>`) or
    the call *sysconf(_SC_ARG_MAX)* to determine this limit. (We describe *sysconf()*
    in Section 11.2.) SUSv3 requires `ARG_MAX` to be at least `_POSIX_ARG_MAX` (4096)
    bytes. Most UNIX implementations allow a considerably higher limit than this.
    SUSv3 leaves it unspecified whether an implementation counts overhead bytes (for
    terminating null bytes, alignment bytes, and the *argv* and *environ* arrays of
    pointers) against the `ARG_MAX` limit.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 如 [图6-1](ch06.html#typical_memory_layout_of_a_process_on_li "图6-1. Linux/x86-32上进程的典型内存布局")
    所示，*argv* 和 *environ* 数组，以及它们最初指向的字符串，位于进程栈上方的一个连续内存区域中。（我们将在下一节中描述 *environ*，它保存了程序的环境列表。）这个区域存储的字节总数有上限。SUSv3
    规定使用 `ARG_MAX` 常量（在 `<limits.h>` 中定义）或调用 *sysconf(_SC_ARG_MAX)* 来确定此限制。（我们将在第
    11.2 节中描述 *sysconf()*。）SUSv3 要求 `ARG_MAX` 至少为 `_POSIX_ARG_MAX`（4096）字节。大多数 UNIX
    实现允许的限制远高于此值。SUSv3 没有规定实现是否将开销字节（用于终止空字节、对齐字节以及 *argv* 和 *environ* 指针数组）计入 `ARG_MAX`
    限制中。
- en: Note
  id: totrans-110
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: On Linux, `ARG_MAX` was historically fixed at 32 pages (i.e., 131,072 bytes
    on Linux/x86-32), and included the space for overhead bytes. Starting with kernel
    2.6.23, the limit on the total space used for *argv* and *environ* can be controlled
    via the `RLIMIT_STACK` resource limit, and a much larger limit is permitted for
    *argv* and *environ*. The limit is calculated as one-quarter of the soft `RLIMIT_STACK`
    resource limit that was in force at the time of the *execve()* call. For further
    details, see the *execve(2)* man page.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Linux 上，`ARG_MAX` 历史上固定为 32 页（即在 Linux/x86-32 上为 131,072 字节），并包括了用于开销字节的空间。从内核版本
    2.6.23 开始，可以通过 `RLIMIT_STACK` 资源限制来控制 *argv* 和 *environ* 使用的总空间限制，并且为 *argv* 和
    *environ* 允许更大的限制。该限制的计算方法是 *execve()* 调用时生效的软 `RLIMIT_STACK` 资源限制的四分之一。更多详细信息，请参见
    *execve(2)* 手册页。
- en: Many programs (including several of the examples in this book) parse command-line
    options (i.e., arguments beginning with a hyphen) using the *getopt()* library
    function. We describe *getopt()* in [Appendix B](apb.html "Appendix B. Parsing
    Command-Line Options").
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 许多程序（包括本书中的几个示例）使用 *getopt()* 库函数解析命令行选项（即以连字符开头的参数）。我们在 [附录 B](apb.html "附录
    B. 解析命令行选项") 中描述了 *getopt()*。
- en: Environment List
  id: totrans-113
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 环境列表
- en: Each process has an associated array of strings called the *environment list*,
    or simply the *environment*. Each of these strings is a definition of the form
    *name=value*. Thus, the environment represents a set of name-value pairs that
    can be used to hold arbitrary information. The names in the list are referred
    to as *environment variables*.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 每个进程都有一个相关的字符串数组，称为 *环境列表*，或简称 *环境*。这些字符串的每一个都以 *name=value* 形式进行定义。因此，环境表示一组可以存储任意信息的名称-值对。列表中的名称被称为
    *环境变量*。
- en: When a new process is created, it inherits a copy of its parent’s environment.
    This is a primitive but frequently used form of interprocess communication—the
    environment provides a way to transfer information from a parent process to its
    child(ren). Since the child gets a copy of its parent’s environment at the time
    it is created, this transfer of information is one-way and once-only. After the
    child process has been created, either process may change its own environment,
    and these changes are not seen by the other process.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个新进程被创建时，它会继承父进程的环境副本。这是一种原始但常用的进程间通信方式——环境提供了一种从父进程向其子进程传递信息的方式。由于子进程在创建时获得父进程环境的副本，因此这种信息传递是单向的且只能进行一次。在子进程创建后，任一进程都可以改变自己的环境，而这些变化不会被另一个进程看到。
- en: A common use of environment variables is in the shell. By placing values in
    its own environment, the shell can ensure that these values are passed to the
    processes that it creates to execute user commands. For example, the environment
    variable `SHELL` is set to be the pathname of the shell program itself. Many programs
    interpret this variable as the name of the shell that should be executed if the
    program needs to execute a shell.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 环境变量的一个常见用途是在 shell 中。通过将值放入自己的环境，shell 可以确保这些值被传递给它创建的执行用户命令的进程。例如，环境变量 `SHELL`
    被设置为 shell 程序本身的路径名。许多程序将这个变量解释为在需要执行 shell 时应该执行的 shell 名称。
- en: Some library functions allow their behavior to be modified by setting environment
    variables. This allows the user to control the behavior of an application using
    the function without needing to change the code of the application or relink it
    against the corresponding library. An example of this technique is provided by
    the *getopt()* function ([Appendix B](apb.html "Appendix B. Parsing Command-Line
    Options")), whose behavior can be modified by setting the `POSIXLY_CORRECT` environment
    variable.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 一些库函数允许通过设置环境变量来修改它们的行为。这使得用户能够控制应用程序的行为，而无需改变应用程序的代码或重新链接到相应的库。这个技术的一个例子由 *getopt()*
    函数提供（见 [附录 B](apb.html "附录 B. 解析命令行选项")），其行为可以通过设置 `POSIXLY_CORRECT` 环境变量来修改。
- en: 'In most shells, a value can be added to the environment using the *export*
    command:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数 shell 中，可以使用 *export* 命令向环境中添加值：
- en: '[PRE6]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'In *bash* and the Korn shell, this can be abbreviated to:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *bash* 和 Korn shell 中，这可以简写为：
- en: '[PRE7]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'In the C shell, the *setenv* command is used instead:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 在 C shell 中，使用 *setenv* 命令来代替：
- en: '[PRE8]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The above commands permanently add a value to the shell’s environment, and this
    environment is then inherited by all child processes that the shell creates. At
    any point, an environment variable can be removed with the *unset* command (*unsetenv*
    in the C shell).
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 上述命令会永久地将值添加到 shell 的环境中，随后所有 shell 创建的子进程都将继承该环境。在任何时候，都可以使用 *unset* 命令（C shell
    中为 *unsetenv*）删除环境变量。
- en: 'In the Bourne shell and its descendants (e.g., *bash* and the Korn shell),
    the following syntax can be used to add values to the environment used to execute
    a single program, without affecting the parent shell (and subsequent commands):'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Bourne shell 及其后代（例如 *bash* 和 Korn shell）中，可以使用以下语法将值添加到用于执行单个程序的环境中，而不影响父
    shell（以及后续命令）：
- en: '[PRE9]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: This adds a definition to the environment of just the child process executing
    the named program. If desired, multiple assignments (delimited by white space)
    can precede the program name.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 这会将定义添加到仅执行命名程序的子进程的环境中。如果需要，可以在程序名称前添加多个赋值（由空格分隔）。
- en: Note
  id: totrans-128
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The *env* command runs a program using a modified copy of the shell’s environment
    list. The environment list can be modified to both add and remove definitions
    from the list copied from the shell. See the *env(1)* manual page for further
    details.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '*env* 命令使用修改过的 shell 环境列表运行程序。可以修改环境列表，以便从 shell 复制的列表中添加或删除定义。有关详细信息，请参阅 *env(1)*
    手册页。'
- en: 'The *printenv* command displays the current environment list. Here is an example
    of its output:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '*printenv* 命令显示当前的环境列表。以下是它的输出示例：'
- en: '[PRE10]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: We describe the purpose of most of the above environment variables at appropriate
    points in later chapters (see also the *environ(7)* manual page).
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在后续章节中的适当位置描述大多数上述环境变量的用途（另见 *environ(7)* 手册页）。
- en: From the above output, we can see that the environment list is not sorted; the
    order of the strings in the list is simply the arrangement that is most convenient
    for the implementation. In general, this is not a problem, since we normally want
    to access individual variables in the environment, rather than some ordered sequence
    of them.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 从上述输出中可以看出，环境列表并未排序；列表中字符串的顺序只是最方便实现的排列方式。通常这不是问题，因为我们通常希望访问环境中的单个变量，而不是它们的有序序列。
- en: The environment list of any process can be examined via the Linux-specific /`proc/`*`PID`*`/environ`
    file, with each *NAME=value* pair being terminated by a null byte.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 任何进程的环境列表可以通过 Linux 特有的 /`proc/`*`PID`*`/environ` 文件进行查看，其中每个 *NAME=value* 对通过空字节结束。
- en: Accessing the environment from a program
  id: totrans-135
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 从程序访问环境
- en: Within a C program, the environment list can be accessed using the global variable
    *char **environ*. (The C run-time startup code defines this variable and assigns
    the location of the environment list to it.) Like *argv*, *environ* points to
    a `NULL`-terminated list of pointers to null-terminated strings. [Figure 6-5](ch06.html#example_of_process_environment_list_data
    "Figure 6-5. Example of process environment list data structures") shows the environment
    list data structures as they would appear for the environment displayed by the
    *printenv* command above.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在 C 程序中，可以使用全局变量 *char **environ* 访问环境列表。（C 运行时启动代码定义了这个变量，并将环境列表的位置分配给它。）像
    *argv* 一样，*environ* 指向一个以 `NULL` 结尾的指针列表，指向以空字符结尾的字符串。[图 6-5](ch06.html#example_of_process_environment_list_data
    "图 6-5. 进程环境列表数据结构示例") 显示了 *printenv* 命令上面显示的环境数据结构。
- en: '![Example of process environment list data structures](figs/web/06-5_PROCESS-environ.png)Figure 6-5. Example
    of process environment list data structures'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '![进程环境列表数据结构示例](figs/web/06-5_PROCESS-environ.png)图 6-5. 进程环境列表数据结构示例'
- en: The program in [Example 6-3](ch06.html#displaying_the_process_environment "Example 6-3. Displaying
    the process environment") accesses *environ* in order to list all of the values
    in the process environment. This program yields the same output as the *printenv*
    command. The loop in this program relies on the use of pointers to walk through
    *environ*. While it would be possible to treat *environ* as an array (as we use
    *argv* in [Example 6-2](ch06.html#echoing_command-line_arguments "Example 6-2. Echoing
    command-line arguments")), this is less natural, since the items in the environment
    list are in no particular order and there is no variable (corresponding to *argc*)
    that specifies the size of the environment list. (For similar reasons, we don’t
    number the elements of the *environ* array in [Figure 6-5](ch06.html#example_of_process_environment_list_data
    "Figure 6-5. Example of process environment list data structures").)
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 6-3](ch06.html#displaying_the_process_environment "示例 6-3. 显示进程环境")中的程序通过访问*environ*列出进程环境中的所有值。该程序产生与*printenv*命令相同的输出。该程序中的循环依赖于使用指针来遍历*environ*。虽然可以将*environ*视为数组（如我们在[示例
    6-2](ch06.html#echoing_command-line_arguments "示例 6-2. 输出命令行参数")中使用*argv*一样），但这不太自然，因为环境变量列表中的项目没有特定的顺序，并且没有与*argc*相对应的变量来指定环境列表的大小。（出于类似的原因，我们在[图
    6-5](ch06.html#example_of_process_environment_list_data "图 6-5. 进程环境列表数据结构示例")中没有对*environ*数组的元素进行编号。）'
- en: Example 6-3. Displaying the process environment
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 6-3. 显示进程环境
- en: '[PRE11]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'An alternative method of accessing the environment list is to declare a third
    argument to the *main()* function:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 访问环境变量列表的另一种方法是为*main()*函数声明一个第三个参数：
- en: '[PRE12]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: This argument can then be treated in the same way as *environ*, with the difference
    that its scope is local to *main()*. Although this feature is widely implemented
    on UNIX systems, its use should be avoided since, in addition to the scope limitation,
    it is not specified in SUSv3.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 该参数可以像处理*environ*一样处理，区别在于其作用范围局限于*main()*。虽然这个特性在UNIX系统上得到了广泛实现，但由于作用范围的限制，它的使用应该避免，因为在SUSv3中并未指定此特性。
- en: The *getenv()* function retrieves individual values from the process environment.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '*getenv()*函数从进程环境中检索单个值。'
- en: '[PRE13]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Note
  id: totrans-146
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Returns pointer to (value) string, or `NULL` if no such variable
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 返回指向（值）字符串的指针，如果没有该变量，则返回`NULL`。
- en: Given the name of an environment variable, *getenv()* returns a pointer to the
    corresponding value string. Thus, in the case of our example environment shown
    earlier, */bin/bash* would be returned if `SHELL` was specified as the *name*
    argument. If no environment variable with the specified name exists, then *getenv()*
    returns `NULL`.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 给定一个环境变量的名称，*getenv()*会返回指向相应值字符串的指针。因此，在我们之前展示的示例环境中，如果指定`SHELL`作为*name*参数，则会返回*/bin/bash*。如果没有与指定名称匹配的环境变量，*getenv()*将返回`NULL`。
- en: 'Note the following portability considerations when using *getenv()*:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 使用*getenv()*时，请注意以下可移植性考虑事项：
- en: SUSv3 stipulates that an application should not modify the string returned by
    *getenv()*. This is because (in most implementations) this string is actually
    part of the environment (i.e., the *value* part of the *name=value* string). If
    we need to change the value of an environment variable, then we can use the *setenv()*
    or *putenv()* functions (described below).
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: SUSv3规定应用程序不应修改*getenv()*返回的字符串。这是因为（在大多数实现中）该字符串实际上是环境的一部分（即*name=value*字符串中的*value*部分）。如果需要更改环境变量的值，则可以使用*setenv()*或*putenv()*函数（下文将描述）。
- en: SUSv3 permits an implementation of *getenv()* to return its result using a statically
    allocated buffer that may be overwritten by subsequent calls to *getenv()*, *setenv()*,
    *putenv()*, or *unsetenv()*. Although the *glibc* implementation of *getenv()*
    doesn’t use a static buffer in this way, a portable program that needs to preserve
    the string returned by a call to *getenv()* should copy it to a different location
    before making a subsequent call to one of these functions.
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: SUSv3允许*getenv()*的实现使用一个静态分配的缓冲区返回结果，该缓冲区可能会被后续的*getenv()*、*setenv()*、*putenv()*或*unsetenv()*调用覆盖。尽管*glibc*的*getenv()*实现没有以这种方式使用静态缓冲区，但需要保持由*getenv()*调用返回的字符串的便携程序，应在再次调用这些函数之前，将字符串复制到另一个位置。
- en: Modifying the environment
  id: totrans-152
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 修改环境变量
- en: Sometimes, it is useful for a process to modify its environment. One reason
    is to make a change that is visible in all child processes subsequently created
    by that process. Another possibility is that we want to set a variable that is
    visible to a new program to be loaded into the memory of this process (“execed”).
    In this sense, the environment is not just a form of interprocess communication,
    but also a method of interprogram communication. (This point will become clearer
    in [Chapter 27](ch27.html "Chapter 27. Program Execution"), where we explain how
    the *exec()* functions permit a program to replace itself by a new program within
    the same process.)
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
- en: The *putenv()* function adds a new variable to the calling process’s environment
    or modifies the value of an existing variable.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Note
  id: totrans-156
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Returns 0 on success, or nonzero on error
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
- en: The *string* argument is a pointer to a string of the form *name=value*. After
    the *putenv()* call, this string is part of the environment. In other words, rather
    than duplicating the string pointed to by *string*, one of the elements of *environ*
    will be set to point to the same location as *string*. Therefore, if we subsequently
    modify the bytes pointed to by *string*, that change will affect the process environment.
    For this reason, *string* should not be an automatic variable (i.e., a character
    array allocated on the stack), since this memory area may be overwritten once
    the function in which the variable is defined returns.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
- en: Note that *putenv()* returns a nonzero value on error, rather than -1.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
- en: The *glibc* implementation of *putenv()* provides a nonstandard extension. If
    *string* doesn’t contain an equal sign (`=`), then the environment variable identified
    by *string* is removed from the environment list.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
- en: The *setenv()* function is an alternative to *putenv()* for adding a variable
    to the environment.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Note
  id: totrans-163
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Returns 0 on success, or -1 on error
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
- en: The *setenv()* function creates a new environment variable by allocating a memory
    buffer for a string of the form *name=value*, and copying the strings pointed
    to by *name* and *value* into that buffer. Note that we don’t need to (in fact,
    must not) supply an equal sign at the end of *name* or the start of *value*, because
    *setenv()* adds this character when it adds the new definition to the environment.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
- en: The *setenv()* function doesn’t change the environment if the variable identified
    by *name* already exists and *overwrite* has the value 0\. If *overwrite* is nonzero,
    the environment is always changed.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
- en: The fact that *setenv()* copies its arguments means that, unlike with *putenv()*,
    we can subsequently modify the contents of the strings pointed to by *name* and
    *value* without affecting the environment. It also means that using automatic
    variables as arguments to *setenv()* doesn’t cause any problems.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
- en: The *unsetenv()* function removes the variable identified by *name* from the
    environment.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Note
  id: totrans-170
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Returns 0 on success, or -1 on error
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
- en: As with *setenv()*, *name* should not include an equal sign.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 与*setenv()*一样，*name*不应包含等号。
- en: Both *setenv()* and *unsetenv()* derive from BSD, and are less widespread than
    *putenv()*. Although not defined in the original POSIX.1 standard or in SUSv2,
    they are included in SUSv3.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: '*setenv()*和*unsetenv()*都源自BSD，并且比*putenv()*的使用范围小。虽然它们没有在原始的POSIX.1标准或SUSv2中定义，但它们被包含在SUSv3中。'
- en: Note
  id: totrans-174
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: In versions of *glibc* before 2.2.2, *unsetenv()* was prototyped as returning
    *void*. This was how *unsetenv()* was prototyped in the original BSD implementation,
    and some UNIX implementations still follow the BSD prototype.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 在*glibc* 2.2.2之前的版本中，*unsetenv()*的原型是返回*void*。这是原始BSD实现中*unsetenv()*的原型，一些UNIX实现仍然遵循BSD原型。
- en: 'On occasion, it is useful to erase the entire environment, and then rebuild
    it with selected values. For example, we might do this in order to execute set-user-ID
    programs in a secure manner ([Don’t Trust Inputs or the Environment](ch38.html#don_apostrophy_t_trust_inputs_or_the_env
    "Don’t Trust Inputs or the Environment")). We can erase the environment by assigning
    `NULL` to *environ*:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，清空整个环境并用选定的值重新构建它是有用的。例如，我们可能会为了以安全的方式执行设置用户ID的程序而这么做（[不要信任输入或环境](ch38.html#don_apostrophy_t_trust_inputs_or_the_env
    "不要信任输入或环境")）。我们可以通过将`NULL`赋值给*environ*来清除环境：
- en: '[PRE17]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: This is exactly the step performed by the *clearenv()* library function.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 这正是*clearenv()*库函数所执行的步骤。
- en: '[PRE18]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Note
  id: totrans-180
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Returns 0 on success, or a nonzero on error
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 成功时返回0，错误时返回非零值
- en: In some circumstances, the use of *setenv()* and *clearenv()* can lead to memory
    leaks in a program. We noted above that *setenv()* allocates a memory buffer that
    is then made part of the environment. When we call *clearenv()*, it doesn’t free
    this buffer (it can’t, since it doesn’t know of the buffer’s existence). A program
    that repeatedly employed these two functions would steadily leak memory. In practice,
    this is unlikely to be a problem, because a program typically calls *clearenv()*
    just once on startup, in order to remove all entries from the environment that
    it inherited from its predecessor (i.e., the program that called *exec()* to start
    this program).
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，使用*setenv()*和*clearenv()*可能会导致程序内存泄漏。我们在上面提到过，*setenv()*会分配一个内存缓冲区，并将其作为环境的一部分。当我们调用*clearenv()*时，它并不会释放这个缓冲区（它不能释放，因为它并不知道缓冲区的存在）。如果一个程序反复使用这两个函数，就会不断泄漏内存。实际上，这通常不会成为问题，因为一个程序通常只会在启动时调用*clearenv()*一次，用以移除从前一个程序（即调用*exec()*启动当前程序的程序）继承的所有环境条目。
- en: Note
  id: totrans-183
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Many UNIX implementations provide *clearenv()*, but it is not specified in SUSv3\.
    SUSv3 specifies that if an application directly modifies *environ*, as is done
    by *clearenv()*, then the behavior of *setenv()*, *unsetenv()*, and *getenv()*
    is undefined. (The rationale behind this is that preventing a conforming application
    from directly modifying the environment allows the implementation full control
    over the data structures that it uses to implement environment variables.) The
    only way that SUSv3 permits an application to clear its environment is to obtain
    a list of all environment variables (by getting the names from *environ*), and
    then using *unsetenv()* to remove each of these names.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 许多UNIX实现提供了*clearenv()*，但它并未在SUSv3中规定。SUSv3规定，如果一个应用程序直接修改了*environ*（如同*clearenv()*所做的那样），则*setenv()*、*unsetenv()*和*getenv()*的行为是未定义的。（这样做的理由是，防止符合标准的应用程序直接修改环境变量，允许实现方完全控制它用来实现环境变量的数据结构。）SUSv3允许应用程序清除其环境的唯一方式是获取所有环境变量的列表（通过从*environ*获取名称），然后使用*unsetenv()*逐一移除这些名称。
- en: Example program
  id: totrans-185
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 示例程序
- en: '[Example 6-4](ch06.html#modifying_the_process_environment "Example 6-4. Modifying
    the process environment") demonstrates the use of all of the functions discussed
    in this section. After first clearing the environment, this program adds any environment
    definitions provided as command-line arguments. It then: adds a definition for
    a variable called `GREET`, if one doesn’t already exist in the environment; removes
    any definition for a variable named `BYE`; and, finally, prints the current environment
    list. Here is an example of the output produced when the program is run:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 6-4](ch06.html#modifying_the_process_environment "示例 6-4. 修改进程环境")展示了本节中讨论的所有函数的使用。该程序首先清除环境，然后添加任何作为命令行参数提供的环境定义。接着，它会：为一个名为`GREET`的变量添加定义（如果环境中尚未存在）；移除任何名为`BYE`的变量的定义；最后，打印当前的环境列表。下面是程序运行时生成的输出示例：'
- en: '[PRE19]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'If we assign `NULL` to *environ* (as is done by the call to *clearenv()* in
    [Example 6-4](ch06.html#modifying_the_process_environment "Example 6-4. Modifying
    the process environment")), then we would expect that a loop of the following
    form (as used in the program) would fail, since **environ* is invalid:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们将 `NULL` 赋值给 *environ*（如在 [示例 6-4](ch06.html#modifying_the_process_environment
    "示例 6-4. 修改进程环境") 中通过调用 *clearenv()* 所做的那样），那么我们会预期以下形式的循环（在程序中使用的那样）会失败，因为 **environ**
    是无效的：
- en: '[PRE20]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: However, if *setenv()* and *putenv()* find that *environ* is `NULL`, they create
    a new environment list and set *environ* pointing to it, with the result that
    the above loop operates correctly.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果 *setenv()* 和 *putenv()* 发现 *environ* 为 `NULL`，它们会创建一个新的环境列表并将 *environ*
    设置为指向该列表，结果使得上述循环能够正确运行。
- en: Example 6-4. Modifying the process environment
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 6-4. 修改进程环境
- en: '[PRE21]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Performing a Nonlocal Goto: *setjmp()* and *long jmp()*'
  id: totrans-193
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 执行非局部跳转：*setjmp()* 和 *longjmp()*
- en: The *setjmp()* and *longjmp()* library functions are used to perform a *nonlocal
    goto*. The term *nonlocal* refers to the fact that the target of the goto is a
    location somewhere outside the currently executing function.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: '*setjmp()* 和 *longjmp()* 库函数用于执行 *非局部跳转*。术语 *非局部* 指的是跳转的目标位置位于当前执行的函数之外。'
- en: Like many programming languages, C includes the `goto` statement, which is open
    to endless abuse in making programs difficult to read and maintain, and is occasionally
    useful to make a program simpler, faster, or both.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 和许多编程语言一样，C 语言包含 `goto` 语句，虽然它可能会被滥用，使程序变得难以阅读和维护，但在某些情况下，它确实有助于使程序更简单、更快速，甚至两者兼备。
- en: 'One restriction of C’s `goto` is that it is not possible to jump out of the
    current function into another function. However, such functionality can occasionally
    be useful. Consider the following common scenario in error handling: during a
    deeply nested function call, we encounter an error that should be handled by abandoning
    the current task, returning through multiple function calls, and then continuing
    execution in some much higher function (perhaps even *main()*). To do this, we
    could have each function return a status value that is checked and appropriately
    handled by its caller. This is perfectly valid, and, in many cases, the desirable
    method for handling this kind of scenario. However, in some cases, coding would
    be simpler if we could jump from the middle of the nested function call back to
    one of the functions that called it (the immediate caller, or the caller of the
    caller, and so on). This is the functionality that *setjmp()* and *longjmp()*
    provide.'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: C 语言的 `goto` 有一个限制，即无法从当前函数跳转到另一个函数。然而，这种功能在某些情况下可能会非常有用。考虑一下错误处理中的常见场景：在一个深度嵌套的函数调用中，我们遇到了一个错误，需要通过放弃当前任务，回溯多个函数调用，然后在某个更高层的函数中继续执行（甚至可能是
    *main()*）。为了实现这一点，我们可以让每个函数返回一个状态值，调用者检查并适当处理这个状态值。这是完全有效的，而且在许多情况下，这种方式是处理此类场景的理想方法。然而，在某些情况下，如果我们能够从嵌套函数调用的中间位置跳回到调用它的某个函数（立即调用者，或者调用者的调用者，依此类推），编程会更加简便。这正是
    *setjmp()* 和 *longjmp()* 提供的功能。
- en: Note
  id: totrans-197
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The restriction that a `goto` can’t be used to jump between functions in C exists
    because all C functions reside at the same scope level (i.e., there is no nesting
    of function declarations in standard C, although *gcc* does permit this as an
    extension). Thus, given two functions, X and Y, the compiler has no way of knowing
    whether a stack frame for function X might be on the stack at the time Y is invoked,
    and thus whether a `goto` from function Y to function X would be possible. In
    languages such as Pascal, where function declarations can be nested, and a `goto`
    from a nested function to a function that encloses it is permitted, the static
    scope of a function allows the compiler to determine some information about the
    dynamic scope of the function. Thus, if function Y is lexically nested within
    function X, then the compiler knows that a stack frame for X must already be on
    the stack at the time Y is invoked, and can generate code for a `goto` from function
    Y to somewhere within function X.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 在 C 语言中，`goto` 不能用于在函数之间跳转的限制存在，是因为所有 C 函数都位于相同的作用域级别（即，标准 C 中没有函数声明的嵌套，虽然 *gcc*
    允许作为扩展）。因此，给定两个函数 X 和 Y，编译器无法知道函数 X 的栈帧是否会在调用 Y 时存在于栈上，因此无法确定从函数 Y 到函数 X 的 `goto`
    是否可能。在像 Pascal 这样的语言中，函数声明可以嵌套，并且允许从嵌套函数跳转到包含它的函数，函数的静态作用域使得编译器能够确定函数的动态作用域的某些信息。因此，如果函数
    Y 在语法上嵌套在函数 X 中，编译器就知道，在调用 Y 时，函数 X 的栈帧已经在栈上，可以为从函数 Y 跳转到函数 X 中的某个位置生成代码。
- en: '[PRE22]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Note
  id: totrans-200
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Returns 0 on initial call, nonzero on return via *longjmp()*
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 初始调用时返回 0，通过 *longjmp()* 返回时返回非零值。
- en: '[PRE23]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Calling *setjmp()* establishes a target for a later jump performed by *longjmp()*.
    This target is exactly the point in the program where the *setjmp()* call occurred.
    From a programming point of view, after the *longjmp()*, it looks exactly as though
    we have just returned from the *setjmp()* call for a second time. The way in which
    we distinguish the second “return” from the initial return is by the integer value
    returned by *setjmp()*. The initial *setjmp()* returns 0, while the later “faked”
    return supplies whatever value is specified in the *val* argument of the *longjmp()*
    call. By using different values for the *val* argument, we can distinguish jumps
    to the same target from different points in the program.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 调用 *setjmp()* 会为后续由 *longjmp()* 执行的跳转建立目标。这个目标正是 *setjmp()* 调用发生的程序位置。从编程角度来看，*longjmp()*
    之后，它看起来就像是我们第二次从 *setjmp()* 调用中返回。我们通过 *setjmp()* 返回的整数值来区分第二次“返回”和第一次返回。初始的 *setjmp()*
    返回 0，而后来的“伪”返回会提供 *longjmp()* 调用中 *val* 参数指定的值。通过为 *val* 参数使用不同的值，我们可以区分从程序中的不同位置跳转到相同目标。
- en: Specifying the *val* argument to *longjmp()* as 0 would, if unchecked, cause
    the faked return from *setjmp()* to look as though it were the initial return.
    For this reason, if *val* is specified as 0, *longjmp()* actually uses the value
    1.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有检查，指定 *val* 参数为 0，会导致伪返回看起来像是初始的返回。因此，如果 *val* 被指定为 0，*longjmp()* 实际上会使用值
    1。
- en: The *env* argument used by both functions supplies the glue enabling the jump
    to be accomplished. The *setjmp()* call saves various information about the current
    process environment into *env*. This allows the *longjmp()* call, which must specify
    the same *env* variable, to perform the fake return. Since the *setjmp()* and
    *longjmp()* calls are in different functions (otherwise, we could use a simple
    `goto`), *env* is declared globally or, less commonly, passed as a function argument.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 两个函数都使用的 *env* 参数提供了使跳转得以实现的连接。*setjmp()* 调用将当前进程环境的各种信息保存到 *env* 中。这使得 *longjmp()*
    调用可以执行伪返回，因为 *longjmp()* 必须指定相同的 *env* 变量。由于 *setjmp()* 和 *longjmp()* 调用位于不同的函数中（否则，我们可以使用简单的
    `goto`），*env* 被声明为全局变量，或者在较少情况下，作为函数参数传递。
- en: 'Along with other information, *env* stores a copy of the *program counter*
    register (which points to the currently executing machine-language instruction)
    and the *stack pointer* register (which marks the top of the stack) at the time
    of the call to *setjmp()*. This information enables the subsequent *longjmp()*
    call to accomplish two key steps:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 除了其他信息外，*env* 还存储了调用 *setjmp()* 时 *程序计数器* 寄存器（指向当前执行的机器语言指令）和 *栈指针* 寄存器（标记栈的顶部）的副本。这些信息使得随后的
    *longjmp()* 调用能够完成两个关键步骤：
- en: Strip off the stack frames for all of the intervening functions on the stack
    between the function calling *longjmp()* and the function that previously called
    *setjmp()*. This procedure is sometimes called “unwinding the stack,” and is accomplished
    by resetting the stack pointer register to the value saved in the *env* argument.
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 去除所有函数调用之间的堆栈帧，这些函数调用位于调用 *longjmp()* 的函数与之前调用 *setjmp()* 的函数之间。这一过程有时被称为“堆栈展开”，通过将堆栈指针寄存器重置为保存在
    *env* 参数中的值来实现。
- en: Reset the program counter register so that the program continues execution from
    the location of the initial *setjmp()* call. Again, this is accomplished using
    the value saved in *env*.
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 重置程序计数器寄存器，使程序从初始的 *setjmp()* 调用位置继续执行。再次，这通过使用保存在 *env* 中的值来实现。
- en: Example program
  id: totrans-209
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 示例程序
- en: '[Example 6-5](ch06.html#demonstrate_the_use_of_setjmp_open_paren "Example 6-5. Demonstrate
    the use of setjmp() and longjmp()") demonstrates the use of *setjmp()* and *longjmp()*.
    This program sets up a jump target with an initial call to *setjmp()*. The subsequent
    `switch` (on the value returned by *setjmp()*) is the means of detecting whether
    we have just completed the initial return from *setjmp()* or whether we have arrived
    back after a *longjmp()*. In the case of a 0 return—meaning we have just done
    the initial *setjmp()*—we call *f1()*, which either immediately calls *longjmp()*
    or goes on to call *f2()*, depending on the value of *argc* (i.e., the number
    of command-line arguments). If *f2()* is reached, it does an immediate *longjmp()*.
    A *longjmp()* from either function takes us back to the point of the *setjmp()*
    call. We use different *val* arguments in the two *longjmp()* calls, so that the
    `switch` statement in *main()* can determine the function from which the jump
    occurred and print a suitable message.'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 6-5](ch06.html#demonstrate_the_use_of_setjmp_open_paren "示例 6-5. 演示 setjmp()
    和 longjmp() 的使用") 演示了如何使用 *setjmp()* 和 *longjmp()*。该程序通过初始调用 *setjmp()* 设置了一个跳转目标。随后通过
    `switch`（根据 *setjmp()* 返回的值）来判断我们是刚刚完成了从 *setjmp()* 的初次返回，还是在经历了 *longjmp()* 后回到了此处。如果返回值为
    0——意味着我们刚刚完成了初次的 *setjmp()*——我们调用 *f1()*，而 *f1()* 会根据 *argc*（即命令行参数的数量）的值，选择是立刻调用
    *longjmp()*，还是继续调用 *f2()*。如果达到了 *f2()*，它会立即执行 *longjmp()*。无论哪种情况，*longjmp()* 都会将程序带回
    *setjmp()* 调用点。我们在两次 *longjmp()* 调用中使用不同的 *val* 参数，因此在 *main()* 中的 `switch` 语句可以判断跳转发生的函数，并打印出相应的信息。'
- en: 'When we run the program in [Example 6-5](ch06.html#demonstrate_the_use_of_setjmp_open_paren
    "Example 6-5. Demonstrate the use of setjmp() and longjmp()") without any command-line
    arguments, this is what we see:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在没有任何命令行参数的情况下运行 [示例 6-5](ch06.html#demonstrate_the_use_of_setjmp_open_paren
    "示例 6-5. 演示 setjmp() 和 longjmp() 的使用") 时，我们看到的是：
- en: '[PRE24]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Specifying a command-line argument causes the jump to occur from *f 2()*:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 指定命令行参数会导致从 *f2()* 发生跳转：
- en: '[PRE25]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Example 6-5. Demonstrate the use of *setjmp()* and *longjmp()*
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 6-5. 演示 *setjmp()* 和 *longjmp()* 的使用
- en: '[PRE26]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Restrictions on the use of *setjmp()*
  id: totrans-217
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 使用 *setjmp()* 的限制
- en: 'SUSv3 and C99 specify that a call to *setjmp()* may appear only in the following
    contexts:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: SUSv3 和 C99 指定，*setjmp()* 的调用只能出现在以下上下文中：
- en: as the entire controlling expression of a selection or iteration statement (`if`,
    `switch`, `while`, and so on);
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 作为选择或迭代语句的整个控制表达式（`if`、`switch`、`while` 等）；
- en: as the operand of a unary `!` (*not*) operator, where the resulting expression
    is the entire controlling expression of a selection or iteration statement;
  id: totrans-220
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 作为一元 `!`（*not*）操作符的操作数，其中结果表达式是选择或迭代语句的整个控制表达式；
- en: as part of a comparison operation (`==`, `!=`, `<`, and so on), where the other
    operand is an integer constant expression and the resulting expression is the
    entire controlling expression of a selection or iteration statement; or
  id: totrans-221
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 作为比较操作（`==`、`!=`、`<` 等）的一部分，其中另一个操作数是一个整数常量表达式，且结果表达式是选择或迭代语句的整个控制表达式；或者
- en: as a free-standing function call that is not embedded inside some larger expression.
  id: totrans-222
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 作为一个独立的函数调用，而不是嵌入在某个更大的表达式中。
- en: 'Note that the C assignment statement doesn’t figure in the list above. A statement
    of the following form is not standards-conformant:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，C 语言中的赋值语句不在上述列表中。以下形式的语句不符合标准：
- en: '[PRE27]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: These restrictions are specified because an implementation of *setjmp()* as
    a conventional function can’t be guaranteed to have enough information to be able
    to save the values of all registers and temporary stack locations used in an enclosing
    expression so that they could then be correctly restored after a *longjmp()*.
    Thus, it is permitted to call *setjmp()* only inside expressions simple enough
    not to require temporary storage.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 这些限制是因为作为常规函数实现的*setjmp()*不能保证有足够的信息来保存所有寄存器和临时堆栈位置的值，以便在执行*longjmp()*之后能够正确恢复它们。因此，允许仅在不需要临时存储的简单表达式中调用*setjmp()*。
- en: Abusing *longjmp()*
  id: totrans-226
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 滥用*longjmp()*
- en: 'If the *env* buffer is declared global to all functions (which is typical),
    then it is possible to execute the following sequence of steps:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 如果*env*缓冲区被声明为全局变量（这在实践中是典型的），那么可能会执行以下步骤：
- en: Call a function *x()* that uses *setjmp()* to establish a jump target in the
    global variable *env*.
  id: totrans-228
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调用一个使用*setjmp()*来在全局变量*env*中建立跳转目标的函数*x()*。
- en: Return from function *x()*.
  id: totrans-229
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从函数*x()*中返回。
- en: Call a function *y()* that does a *longjmp()* using *env*.
  id: totrans-230
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调用一个做*longjmp()*并使用*env*的函数*y()*。
- en: This is a serious error. We can’t do a *longjmp()* into a function that has
    already returned. Considering what *longjmp()* tries to do to the stack—it attempts
    to unwind the stack back to a frame that no longer exists—leads us to realize
    that chaos will result. If we are lucky, our program will simply crash. However,
    depending on the state of the stack, other possibilities include infinite call-return
    loops and the program behaving as though it really did return from a function
    that was not currently executing. (In a multithreaded program, a similar abuse
    is to call *longjmp()* in a different thread from that in which *setjmp()* was
    called.)
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个严重的错误。我们不能在一个已经返回的函数中进行*longjmp()*。考虑到*longjmp()*试图对堆栈做的事情——它试图将堆栈展开回一个已经不存在的帧——我们就会意识到这会导致混乱。如果幸运的话，我们的程序会直接崩溃。然而，依据堆栈的状态，其他可能性包括无限的调用-返回循环，或者程序表现得就像它真的从一个当前没有执行的函数中返回一样。（在多线程程序中，类似的滥用是从与*setjmp()*被调用的线程不同的线程中调用*longjmp()*。）
- en: Note
  id: totrans-232
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: SUSv3 says that if *longjmp()* is called from within a nested signal handler
    (i.e., a handler that was invoked while the handler for another signal was executing),
    then the program behavior is undefined.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: SUSv3规定，如果*longjmp()*在嵌套的信号处理程序内部被调用（即，在处理另一个信号的处理程序执行时被调用），那么程序行为是未定义的。
- en: Problems with optimizing compilers
  id: totrans-234
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 优化编译器的问题
- en: Optimizing compilers may rearrange the order of instructions in a program and
    store certain variables in CPU registers, rather than RAM. Such optimizations
    generally rely on the run-time flow of control reflecting the lexical structure
    of the program. Since jump operations performed via *setjmp()* and *longjmp()*
    are established and executed at run time, and are not reflected in the lexical
    structure of the program, a compiler optimizer is unable to take them into account
    when performing its task. Furthermore, the semantics of some ABI implementations
    require *longjmp()* to restore copies of the CPU registers saved by the earlier
    *setjmp()* call. This means that optimized variables may end up with incorrect
    values as a consequence of a *longjmp()* operation. We can see an example of this
    by examining the behavior of the program in [Example 6-6](ch06.html#a_demonstration_of_the_interaction_of_co
    "Example 6-6. A demonstration of the interaction of compiler optimization and
    longjmp()").
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 优化编译器可能会重新排列程序中指令的顺序，并将某些变量存储在CPU寄存器中，而不是RAM中。这类优化通常依赖于运行时控制流反映程序的词法结构。由于通过*setjmp()*和*longjmp()*执行的跳转操作是在运行时建立和执行的，并且不反映程序的词法结构，因此编译器优化器在执行任务时无法考虑这些跳转操作。此外，一些ABI实现的语义要求*longjmp()*恢复由早期的*setjmp()*调用保存的CPU寄存器的副本。这意味着经过优化的变量可能会因*longjmp()*操作而出现不正确的值。我们可以通过检查[示例6-6](ch06.html#a_demonstration_of_the_interaction_of_co
    "示例6-6。编译器优化与longjmp()交互的演示")中程序的行为来看到这一点。
- en: Example 6-6. A demonstration of the interaction of compiler optimization and
    *longjmp()*
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 示例6-6。编译器优化与*longjmp()*交互的演示
- en: '[PRE28]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'When we compile the program in [Example 6-6](ch06.html#a_demonstration_of_the_interaction_of_co
    "Example 6-6. A demonstration of the interaction of compiler optimization and
    longjmp()") normally, we see the expected output:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们正常编译[示例6-6](ch06.html#a_demonstration_of_the_interaction_of_co "示例6-6。编译器优化与longjmp()交互的演示")中的程序时，我们会看到预期的输出：
- en: '[PRE29]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'However, when we compile with optimization, we get the following unexpected
    results:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，当我们使用优化编译时，得到以下意外结果：
- en: '[PRE30]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Here, we see that after the *longjmp()*, *nvar* and *rvar* have been reset to
    their values at the time of the *setjmp()* call. This has occurred because the
    code reorganization performed by the optimizer has been confused as a consequence
    of the *longjmp()*. Any local variables that are candidates for optimization may
    be subject to this sort of problem; this generally means pointer variables and
    variables of any of the simple types *char*, *int*, *float*, and *long*.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们看到在 *longjmp()* 之后，*nvar* 和 *rvar* 被重置为 *setjmp()* 调用时的值。这是因为优化器执行的代码重组在
    *longjmp()* 的影响下被误解了。任何可能进行优化的局部变量都可能遭遇这种问题；这通常意味着指针变量以及任何简单类型的变量，如 *char*、*int*、*float*
    和 *long*。
- en: We can prevent such code reorganization by declaring variables as `volatile`,
    which tells the optimizer not to optimize them. In the preceding program output,
    we see that the variable *vvar*, which was declared `volatile`, was correctly
    handled, even when we compiled with optimization.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过将变量声明为 `volatile` 来防止代码重组，这会告诉优化器不要对这些变量进行优化。在前面的程序输出中，我们看到变量 *vvar* 被声明为
    `volatile`，即使在启用优化编译的情况下，它也被正确处理。
- en: Since different compilers do different types of optimizations, portable programs
    should employ the `volatile` keyword with all of the local variables of the aforementioned
    types in the function that calls *setjmp()*.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 由于不同的编译器进行不同类型的优化，因此可移植的程序应该在调用 *setjmp()* 的函数中的所有上述类型的局部变量上使用 `volatile` 关键字。
- en: 'If we specify the *-Wextra* (*extra warnings*) option to the GNU C compiler,
    it produces the following helpful warning for the `setjmp_vars.c` program:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们为 GNU C 编译器指定 *-Wextra*（*额外警告*）选项，它会为 `setjmp_vars.c` 程序生成以下有用的警告：
- en: '[PRE31]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Note
  id: totrans-247
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: It is instructive to look at the assembler output produced when compiling the
    `setjmp_vars.c` program both with and without optimization. The *cc -S* command
    produces a file with the extension *.s* containing the generated assembler code
    for a program.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 观察编译 `setjmp_vars.c` 程序时在启用和未启用优化情况下产生的汇编输出是很有指导意义的。*cc -S* 命令会生成一个扩展名为 *.s*
    的文件，包含程序生成的汇编代码。
- en: Avoid *setjmp()* and *long jmp()* where possible
  id: totrans-249
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 尽量避免使用 *setjmp()* 和 *longjmp()*
- en: If `goto` statements are capable of rendering a program difficult to read, then
    nonlocal gotos can make things an order of magnitude worse, since they can transfer
    control between any two functions in a program. For this reason, *setjmp()* and
    *longjmp()* should be used sparingly. It is often worth the extra work in design
    and coding to come up with a program that avoids their use, because the program
    will be more readable and possibly more portable. Having said that, we revisit
    variants of these functions (*sigsetjmp()* and *siglongjmp()*, described in [Performing
    a Nonlocal Goto from a Signal Handler](ch21.html#performing_a_nonlocal_goto_from_a_signal
    "Performing a Nonlocal Goto from a Signal Handler")) when we discuss signals,
    since they are occasionally useful when writing signal handlers.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 `goto` 语句可能使程序难以阅读，那么非局部的 `goto` 语句会使问题更加严重，因为它们可以在程序中的任何两个函数之间转移控制。出于这个原因，*setjmp()*
    和 *longjmp()* 应该谨慎使用。在设计和编码时，通常值得花费额外的工作来设计一个避免使用这些函数的程序，因为这样的程序更易读，并且可能更具可移植性。话虽如此，我们在讨论信号时会重新审视这些函数的变体（*sigsetjmp()*
    和 *siglongjmp()*，在[从信号处理程序执行非局部跳转](ch21.html#performing_a_nonlocal_goto_from_a_signal
    "从信号处理程序执行非局部跳转")中描述），因为它们在编写信号处理程序时偶尔会很有用。
- en: Summary
  id: totrans-251
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 概述
- en: Each process has a unique process ID and maintains a record of its parent’s
    process ID.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 每个进程都有一个独特的进程 ID，并记录其父进程的进程 ID。
- en: 'The virtual memory of a process is logically divided into a number of segments:
    text, (initialized and uninitialized) data, stack, and heap.'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 进程的虚拟内存在逻辑上分为多个段：文本段、（已初始化和未初始化的）数据段、栈段和堆段。
- en: The stack consists of a series of frames, with a new frame being added as a
    function is invoked and removed when the function returns. Each frame contains
    the local variables, function arguments, and call linkage information for a single
    function invocation.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 栈由一系列帧组成，每当函数被调用时，都会添加一个新帧，函数返回时会移除相应的帧。每个帧包含单次函数调用的局部变量、函数参数以及调用链接信息。
- en: The command-line arguments supplied when a program is invoked are made available
    via the *argc* and *argv* arguments to *main()*. By convention, *argv[0]* contains
    the name used to invoke the program.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 程序启动时提供的命令行参数通过*argc*和*argv*参数传递给*main()*函数。按照惯例，*argv[0]*包含用于启动程序的名称。
- en: Each process receives a copy of its parent’s environment list, a set of name-value
    pairs. The global variable *environ* and various library functions allow a process
    to access and modify the variables in its environment list.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 每个进程都会收到其父进程环境列表的副本，这是一组名称-值对。全局变量*environ*和各种库函数允许进程访问和修改其环境列表中的变量。
- en: The *setjmp()* and *longjmp()* functions provide a way to perform a nonlocal
    goto from one function to another (unwinding the stack). In order to avoid problems
    with compiler optimization, we may need to declare variables with the `volatile`
    modifier when making use of these functions. Nonlocal gotos can render a program
    difficult to read and maintain, and should be avoided whenever possible.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: '*setjmp()*和*longjmp()*函数提供了一种从一个函数跳转到另一个函数的非局部goto方式（展开栈）。为了避免编译器优化带来的问题，在使用这些函数时，我们可能需要声明带有`volatile`修饰符的变量。非局部goto会使程序难以阅读和维护，应尽可能避免使用。'
- en: Further information
  id: totrans-258
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 进一步的信息
- en: '[Tanenbaum, 2007] and [Vahalia, 1996] describe virtual memory management in
    detail. The Linux kernel memory management algorithms and code are described in
    detail in [Gorman, 2004].'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: '[Tanenbaum, 2007]和[Vahalia, 1996]详细描述了虚拟内存管理。Linux内核的内存管理算法和代码在[Gorman, 2004]中有详细描述。'
- en: Exercises
  id: totrans-260
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习
- en: Compile the program in [Example 6-1](ch06.html#locations_of_program_variables_in_proces
    "Example 6-1. Locations of program variables in process memory segments") (`mem_segments.c`),
    and list its size using *ls -l*. Although the program contains an array (*mbuf*)
    that is around 10 MB in size, the executable file is much smaller than this. Why
    is this?
  id: totrans-261
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编译[示例6-1](ch06.html#locations_of_program_variables_in_proces "示例6-1. 程序变量在进程内存段中的位置")
    (`mem_segments.c`)中的程序，并使用*ls -l*列出其大小。尽管程序包含一个大约10MB大小的数组（*mbuf*），但可执行文件的大小远小于这个。为什么会这样？
- en: Write a program to see what happens if we try to *longjmp()* into a function
    that has already returned.
  id: totrans-262
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写一个程序，看看如果我们尝试*longjmp()*跳转到一个已经返回的函数会发生什么。
- en: Implement *setenv()* and *unsetenv()* using *getenv()*, *putenv()*, and, where
    necessary, code that directly modifies *environ*. Your version of *unsetenv()*
    should check to see whether there are multiple definitions of an environment variable,
    and remove them all (which is what the *glibc* version of *unsetenv()* does).
  id: totrans-263
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用*getenv()*、*putenv()*以及在必要时直接修改*environ*的代码，来实现*setenv()*和*unsetenv()*。你的*unsetenv()*版本应该检查是否存在多个环境变量的定义，并删除它们所有（这也是*glibc*版本的*unsetenv()*所做的）。
