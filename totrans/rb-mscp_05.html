<html><head></head><body><div class="chapter" title="Chapter&#xA0;5.&#xA0;Objects and Classes"><div class="titlepage"><div><div><h1 class="title"><a id="objects_and_classes"/>Chapter 5. Objects and Classes</h1></div></div></div><div class="blockquote"><blockquote class="blockquote"><div class="informalfigure"><div class="mediaobject"><a id="med_id00106"/><img alt="image with no caption" src="httpatomoreillycomsourcenostarchimages1853819.png.jpg"/></div></div><p><span class="emphasis"><em>Every Ruby object is the combination of a class pointer and an array of instance variables.</em></span></p></blockquote></div><p>We learn early on that Ruby is an object-oriented language, descended from languages like Smalltalk and Simula. Every value is an object, and all Ruby programs consist of a set of objects and the messages sent between them. Typically, we learn about object-oriented programming by looking at how to use objects and what they can do: how they can group together data values and behavior related to those values; how each class should have a single responsibility or purpose; and how different classes can be related to each other through encapsulation or inheritance.</p><p>But what are Ruby objects? What information does an object contain? If we were to look at a Ruby object through a microscope, what would we see? Are there any moving parts inside? And what about Ruby classes? What exactly is a class?</p><p>I’ll answer these questions in this chapter by exploring how Ruby works internally. By looking at how Ruby implements objects and classes, you’ll learn how to use them and how to write object-oriented programs using Ruby.</p><div class="sidebar"><a id="roadmap-id00015"/><p class="title">Roadmap</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p><a class="indexterm" id="iddle1159"/><a class="indexterm" id="iddle1516"/><a class="indexterm" id="iddle1743"/><a class="indexterm" id="iddle1785"/><a class="indexterm" id="iddle1804"/><a class="indexterm" id="iddle1827"/><a class="indexterm" id="iddle1851"/><a class="indexterm" id="iddle1916"/><a class="indexterm" id="iddle2066"/><a class="xref" href="ch05.html#inside_a_ruby_object" title="Inside a Ruby Object">Inside a Ruby Object</a></p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p><a class="xref" href="ch05.html#inspecting_klass_and_ivptr" title="Inspecting klass and ivptr">Inspecting klass and ivptr</a></p></li><li class="listitem"><p><a class="xref" href="ch05.html#visualizing_two_instances_of_one_class" title="Visualizing Two Instances of One Class">Visualizing Two Instances of One Class</a></p></li><li class="listitem"><p><a class="xref" href="ch05.html#generic_objects" title="Generic Objects">Generic Objects</a></p></li><li class="listitem"><p><a class="xref" href="ch05.html#simple_ruby_values_donapostrophet_requir" title="Simple Ruby Values Don’t Require a Structure at All">Simple Ruby Values Don’t Require a Structure at All</a></p></li><li class="listitem"><p><a class="xref" href="ch05.html#do_generic_objects_have_instance_variabl" title="Do Generic Objects Have Instance Variables?">Do Generic Objects Have Instance Variables?</a></p></li><li class="listitem"><p><a class="xref" href="ch05.html#reading_the_rbasic_and_robject_c_structu" title="Reading the RBasic and RObject C Structure Definitions">Reading the RBasic and RObject C Structure Definitions</a></p></li><li class="listitem"><p><a class="xref" href="ch05.html#where_does_ruby_save_instance_variables" title="Where Does Ruby Save Instance Variables for Generic Objects?">Where Does Ruby Save Instance Variables for Generic Objects?</a></p></li></ul></div></li><li class="listitem"><p><span class="strong"><strong><a class="xref" href="ch05.html#experiment_5-1_how_long_does_it_take_to" title="Experiment 5-1: How Long Does It Take to Save a New Instance Variable?">Experiment 5-1: How Long Does It Take to Save a New Instance Variable?</a></strong></span></p></li><li class="listitem"><p><a class="xref" href="ch05.html#whatapostrophes_inside_the_rclass_struct" title="What’s Inside the RClass Structure?">What’s Inside the RClass Structure?</a></p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p><a class="xref" href="ch05.html#inheritance" title="Inheritance">Inheritance</a></p></li><li class="listitem"><p><a class="xref" href="ch05.html#class_instance_variables_vsdot_class_var" title="Class Instance Variables vs. Class Variables">Class Instance Variables vs. Class Variables</a></p></li><li class="listitem"><p><a class="xref" href="ch05.html#getting_and_setting_class_variables" title="Getting and Setting Class Variables">Getting and Setting Class Variables</a></p></li><li class="listitem"><p><a class="xref" href="ch05.html#constants" title="Constants">Constants</a></p></li><li class="listitem"><p><a class="xref" href="ch05.html#actual_rclass_structure" title="The Actual RClass Structure">The Actual RClass Structure</a></p></li><li class="listitem"><p><a class="xref" href="ch05.html#reading_the_rclass_c_structure_definitio" title="Reading the RClass C Structure Definition">Reading the RClass C Structure Definition</a></p></li></ul></div></li><li class="listitem"><p><span class="strong"><strong><a class="xref" href="ch05.html#experiment_5-2_where_does_ruby_save_clas" title="Experiment 5-2: Where Does Ruby Save Class Methods?">Experiment 5-2: Where Does Ruby Save Class Methods?</a></strong></span></p></li><li class="listitem"><p><a class="xref" href="ch05.html#summary-id00017" title="Summary">Summary</a></p></li></ul></div></div><div class="sect1" title="Inside a Ruby Object"><div class="titlepage"><div><div><h1 class="title"><a id="inside_a_ruby_object"/>Inside a Ruby Object</h1></div></div></div><p>Ruby saves each of your custom objects in a C structure called <code class="literal">RObject</code>, which looks like <a class="xref" href="ch05.html#robject_structure" title="Figure 5-1. The RObject structure">Figure 5-1</a> in Ruby 1.9 and 2.0.</p><div class="informalfigure"><a id="med_id00107a"/><div class="mediaobject"><a id="med_id00107"/><img alt="image with no caption" src="httpatomoreillycomsourcenostarchimages1854029.png.jpg"/><div class="caption"><p><span class="emphasis"><em>If I could slice open a Ruby object, what would I see?</em></span></p></div></div></div><p>At the top of the figure is a pointer to the <code class="literal">RObject</code> structure. (Internally, Ruby always refers to any value with a <code class="literal">VALUE</code> pointer.) Below this pointer, the <code class="literal">RObject</code> structure contains an inner <code class="literal">RBasic</code> structure and information specific to custom objects. The <code class="literal">RBasic</code> section contains information that all values use: a set of Boolean values called <code class="literal">flags</code> that store a variety of internal technical values, and a class pointer called <code class="literal">klass</code>. <a class="indexterm" id="iddle1160"/><a class="indexterm" id="iddle1421"/><a class="indexterm" id="iddle1431"/><a class="indexterm" id="iddle1433"/><a class="indexterm" id="iddle1462"/><a class="indexterm" id="iddle1517"/><a class="indexterm" id="iddle1734"/><a class="indexterm" id="iddle1786"/><a class="indexterm" id="iddle1800"/><a class="indexterm" id="iddle1805"/><a class="indexterm" id="iddle1828"/><a class="indexterm" id="iddle1852"/><a class="indexterm" id="iddle1917"/><a class="indexterm" id="iddle2067"/>The class pointer indicates which class an object is an instance of. In the <code class="literal">RObject</code> section, Ruby saves an array of instance variables that each object contains, using <code class="literal">numiv</code>, the instance variable count, and <code class="literal">ivptr</code>, a pointer to an array of values.</p><p>If we were to define the Ruby object structure in technical terms, we could say</p><div class="blockquote"><blockquote class="blockquote"><p>Every Ruby object is the combination of a class pointer and an array of instance variables.</p></blockquote></div><p>At first glance, this definition doesn’t seem very useful because it doesn’t help us understand the meaning or purpose behind objects or how to use them in a Ruby program.</p><div class="figure"><a id="robject_structure"/><div class="figure-contents"><div class="mediaobject"><a id="med_id00108"/><img alt="The RObject structure" src="httpatomoreillycomsourcenostarchimages1854031.png.jpg"/></div></div><p class="title">Figure 5-1. The <code class="literal">RObject</code> structure</p></div><div class="sect2" title="Inspecting klass and ivptr"><div class="titlepage"><div><div><h2 class="title"><a id="inspecting_klass_and_ivptr"/>Inspecting klass and ivptr</h2></div></div></div><p>To understand how Ruby uses <code class="literal">RObject</code> in programs, we’ll create a simple Ruby class and then inspect an instance of this class using IRB. For example, suppose I have the simple Ruby class shown in <a class="xref" href="ch05.html#simple_ruby_class" title="Example 5-1. A simple Ruby class">Example 5-1</a>.</p><div class="example"><a id="simple_ruby_class"/><p class="title">Example 5-1. A simple Ruby class</p><div class="example-contents"><pre class="programlisting">class Mathematician
  attr_accessor :first_name
  attr_accessor :last_name
end</pre></div></div><p>Ruby needs to save the class pointer in <code class="literal">RObject</code> because every object must track the class you used to create it. When you create an instance of a class, Ruby internally saves a pointer to that class inside <code class="literal">RObject</code>, as shown in <a class="xref" href="ch05.html#creating_an_object_instance_in_irb" title="Example 5-2. Creating an object instance in IRB">Example 5-2</a>.</p><div class="example"><a id="creating_an_object_instance_in_irb"/><p class="title">Example 5-2. Creating an object instance in IRB</p><div class="example-contents"><pre class="programlisting">    $ <span class="strong"><strong>irb</strong></span>
    &gt; <span class="strong"><strong>euler = Mathematician.new</strong></span>
<img alt="" src="httpatomoreillycomsourcenostarchimages1853843.png.jpg"/>  =&gt; #&lt;Mathematician:0x007fbd738608c0&gt;</pre></div></div><p>By displaying the class name <code class="literal">#&lt;Mathematician</code> at <span class="inlinemediaobject"><a id="inline_id00111"/><img alt="" src="httpatomoreillycomsourcenostarchimages1853843.png.jpg"/></span>, Ruby displays the value of the class pointer for the <code class="literal">euler</code> object. The hex string that follows is actually the <code class="literal">VALUE</code> pointer for the object. (This will differ for every instance of <code class="literal">Mathematician</code>.)</p><p>Ruby also uses the instance variable array to track the values you save in an object, as shown in <a class="xref" href="ch05.html#inspecting_instance_variables_in_irb" title="Example 5-3. Inspecting instance variables in IRB">Example 5-3</a>.</p><div class="example"><a id="inspecting_instance_variables_in_irb"/><p class="title">Example 5-3. Inspecting instance variables in IRB</p><div class="example-contents"><pre class="programlisting">    &gt; <span class="strong"><strong>euler.first_name = 'Leonhard'</strong></span>
     =&gt; "Leonhard"
    &gt; <span class="strong"><strong>euler.last_name  = 'Euler'</strong></span>
     =&gt; "Euler"
    &gt; <span class="strong"><strong>euler</strong></span>
<img alt="" src="httpatomoreillycomsourcenostarchimages1853843.png.jpg"/>  =&gt; #&lt;Mathematician:0x007fbd738608c0 @first_name="Leonhard", @last_name="Euler"&gt;</pre></div></div><p><a class="indexterm" id="iddle1432"/><a class="indexterm" id="iddle1877"/><a class="indexterm" id="iddle2092"/>As you can see, in IRB Ruby also displays the instance variable array for <code class="literal">euler</code> at <span class="inlinemediaobject"><a id="inline_id00113"/><img alt="" src="httpatomoreillycomsourcenostarchimages1853843.png.jpg"/></span>. Ruby needs to save this array of values in each object because every object instance can have different values for the same instance variables, as shown at <span class="inlinemediaobject"><a id="inline_id00114"/><img alt="" src="httpatomoreillycomsourcenostarchimages1853843.png.jpg"/></span> in <a class="xref" href="ch05.html#different_instance_of_the_mathematicia" title="Example 5-4. A different instance of the Mathematician class">Example 5-4</a>.</p><div class="example"><a id="different_instance_of_the_mathematicia"/><p class="title">Example 5-4. A different instance of the <code class="literal">Mathematician</code> class</p><div class="example-contents"><pre class="programlisting">    &gt; <span class="strong"><strong>euclid = Mathematician.new</strong></span>
    &gt; <span class="strong"><strong>euclid.first_name = 'Euclid'</strong></span>
    &gt; <span class="strong"><strong>euclid</strong></span>
<img alt="" src="httpatomoreillycomsourcenostarchimages1853843.png.jpg"/>  =&gt; #&lt;Mathematician:0x007fabdb850690 @first_name="Euclid"&gt;</pre></div></div></div><div class="sect2" title="Visualizing Two Instances of One Class"><div class="titlepage"><div><div><h2 class="title"><a id="visualizing_two_instances_of_one_class"/>Visualizing Two Instances of One Class</h2></div></div></div><p>Let’s look at Ruby’s C structures in a bit more detail. When you run the Ruby code shown in <a class="xref" href="ch05.html#creating_two_instances_of_one_class" title="Figure 5-2. Creating two instances of one class">Figure 5-2</a>, Ruby creates one <code class="literal">RClass</code> structure and two <code class="literal">RObject</code> structures.</p><div class="figure"><a id="creating_two_instances_of_one_class"/><div class="figure-contents"><div class="mediaobject"><a id="med_id00109"/><img alt="Creating two instances of one class" src="httpatomoreillycomsourcenostarchimages1854033.png.jpg"/></div></div><p class="title">Figure 5-2. Creating two instances of one class</p></div><p>I’ll discuss how Ruby implements classes with the <code class="literal">RClass</code> structure in the next section. For now, let’s look at <a class="xref" href="ch05.html#visualizing_two_instances_of_one-id00016" title="Figure 5-3. Visualizing two instances of one class">Figure 5-3</a>, which shows how Ruby saves the <code class="literal">Mathematician</code> information in the two <code class="literal">RObject</code> structures.</p><div class="figure"><a id="visualizing_two_instances_of_one-id00016"/><div class="figure-contents"><div class="mediaobject"><a id="med_id00110"/><img alt="Visualizing two instances of one class" src="httpatomoreillycomsourcenostarchimages1854035.png.jpg"/></div></div><p class="title">Figure 5-3. Visualizing two instances of one class</p></div><p><a class="indexterm" id="iddle1161"/><a class="indexterm" id="iddle1353"/><a class="indexterm" id="iddle1463"/><a class="indexterm" id="iddle1518"/><a class="indexterm" id="iddle1735"/><a class="indexterm" id="iddle1744"/><a class="indexterm" id="iddle1787"/><a class="indexterm" id="iddle1801"/><a class="indexterm" id="iddle1806"/><a class="indexterm" id="iddle1847"/><a class="indexterm" id="iddle1853"/><a class="indexterm" id="iddle1918"/><a class="indexterm" id="iddle1921"/><a class="indexterm" id="iddle1923"/>As you can see, each <code class="literal">klass</code> value points to the <code class="literal">Mathematician RClass</code> structure, and each <code class="literal">RObject</code> structure has a separate array of instance variables. Both arrays contain <code class="literal">VALUE</code> pointers—the same pointer that Ruby uses to refer to the <code class="literal">RObject</code> structure. (Notice that one of the objects contains two instance variables, while the other contains only one.)</p></div><div class="sect2" title="Generic Objects"><div class="titlepage"><div><div><h2 class="title"><a id="generic_objects"/>Generic Objects</h2></div></div></div><p>Now you know how Ruby saves custom classes, like the <code class="literal">Mathematician</code> class, in <code class="literal">RObject</code> structures. But remember that every Ruby value—including basic data types such as integers, strings, and symbols—is an object. The Ruby source code internally refers to these built-in types as “generic” types. How does Ruby store these generic objects? Do they also use the <code class="literal">RObject</code> structure?</p><p>The answer is no. Internally, Ruby uses a different C structure, not <code class="literal">RObject</code>, to save values for each of its generic data types. For example, Ruby saves string values in <code class="literal">RString</code> structures, arrays in <code class="literal">RArray</code> structures, regular expressions in <code class="literal">RRegexp</code> structures, and so on. Ruby uses <code class="literal">RObject</code> only to save instances of custom object classes that you create and a few custom object classes that Ruby creates internally. However, all of these different structures share the same <code class="literal">RBasic</code> information that we saw in <code class="literal">RObject</code>, as shown in <a class="xref" href="ch05.html#different_ruby_object_structures_all_use" title="Figure 5-4. Different Ruby object structures all use the RBasic structure.">Figure 5-4</a>.</p><p>Since the <code class="literal">RBasic</code> structure contains the class pointer, each of these generic data types is also an object. Each is an instance of some Ruby class, as indicated by the class pointer saved inside <code class="literal">RBasic</code>.</p><div class="figure"><a id="different_ruby_object_structures_all_use"/><div class="figure-contents"><div class="mediaobject"><a id="med_id00111"/><img alt="Different Ruby object structures all use the RBasic structure." src="httpatomoreillycomsourcenostarchimages1854037.png"/></div></div><p class="title">Figure 5-4. Different Ruby object structures all use the <code class="literal">RBasic</code> structure.</p></div></div><div class="sect2" title="Simple Ruby Values Don’t Require a Structure at All"><div class="titlepage"><div><div><h2 class="title"><a id="simple_ruby_values_donapostrophet_requir"/>Simple Ruby Values Don’t Require a Structure at All</h2></div></div></div><p><a class="indexterm" id="iddle1127"/><a class="indexterm" id="iddle1291"/><a class="indexterm" id="iddle1296"/><a class="indexterm" id="iddle1297"/><a class="indexterm" id="iddle1720"/><a class="indexterm" id="iddle1829"/><a class="indexterm" id="iddle1848"/><a class="indexterm" id="iddle1854"/><a class="indexterm" id="iddle1922"/><a class="indexterm" id="iddle1924"/><a class="indexterm" id="iddle1992"/><a class="indexterm" id="iddle2057"/><a class="indexterm" id="iddle2068"/><a class="indexterm" id="iddle2073"/><a class="indexterm" id="iddle2074"/><a class="indexterm" id="iddle2075"/><a class="indexterm" id="iddle2076"/><a class="indexterm" id="iddle2080"/>As a performance optimization, Ruby saves small integers, symbols, and a few other simple values without any structure at all, placing them right inside the <code class="literal">VALUE</code> pointer, as shown in <a class="xref" href="ch05.html#ruby_saves_integers_in_the_value_pointer" title="Figure 5-5. Ruby saves integers in the VALUE pointer.">Figure 5-5</a>.</p><div class="figure"><a id="ruby_saves_integers_in_the_value_pointer"/><div class="figure-contents"><div class="mediaobject"><a id="med_id00112"/><img alt="Ruby saves integers in the VALUE pointer." src="httpatomoreillycomsourcenostarchimages1854039.png.jpg"/></div></div><p class="title">Figure 5-5. Ruby saves integers in the <code class="literal">VALUE</code> pointer.</p></div><p>These <code class="literal">VALUE</code>s are not pointers at all; they’re values themselves. For these simple data types, there is no class pointer. Instead, Ruby remembers the class using a series of bit flags saved in the first few bits of the <code class="literal">VALUE</code>. For example, all small integers have the <code class="literal">FIXNUM_FLAG</code> bit set, as shown in <a class="xref" href="ch05.html#fixnumunderscoreflag_indicates_this_is_a" title="Figure 5-6. FIXNUM_FLAG indicates this is an instance of the Fixnum class.">Figure 5-6</a>.</p><div class="figure"><a id="fixnumunderscoreflag_indicates_this_is_a"/><div class="figure-contents"><div class="mediaobject"><a id="med_id00113"/><img alt="FIXNUM_FLAG indicates this is an instance of the Fixnum class." src="httpatomoreillycomsourcenostarchimages1854041.png.jpg"/></div></div><p class="title">Figure 5-6. <code class="literal">FIXNUM_FLAG</code> indicates this is an instance of the <code class="literal">Fixnum</code> class.</p></div><p>Whenever the <code class="literal">FIXNUM_FLAG</code> is set, Ruby knows that this <code class="literal">VALUE</code> is really a small integer, an instance of the <code class="literal">Fixnum</code> class, and not a pointer to a value structure. (A similar bit flag indicates whether the <code class="literal">VALUE</code> is a symbol, and values such as <code class="literal">nil</code>, <code class="literal">true</code>, and <code class="literal">false</code> also have their own flags.)</p><p>It’s easy to see that integers, strings, and other generic values are all objects by using IRB, as you can see in <a class="xref" href="ch05.html#inspecting_classes_for_some_generic_valu" title="Example 5-5. Inspecting classes for some generic values">Example 5-5</a>.</p><div class="example"><a id="inspecting_classes_for_some_generic_valu"/><p class="title">Example 5-5. Inspecting classes for some generic values</p><div class="example-contents"><pre class="programlisting">$ <span class="strong"><strong>irb</strong></span>
&gt; "string".class
 =&gt; String
&gt; <span class="strong"><strong>1.class</strong></span>
 =&gt; Fixnum
&gt; <span class="strong"><strong>:symbol.class</strong></span>
 =&gt; Symbol</pre></div></div><p><a class="indexterm" id="iddle1153"/><a class="indexterm" id="iddle1354"/><a class="indexterm" id="iddle1436"/><a class="indexterm" id="iddle1439"/><a class="indexterm" id="iddle1440"/><a class="indexterm" id="iddle1618"/><a class="indexterm" id="iddle1639"/><a class="indexterm" id="iddle1640"/><a class="indexterm" id="iddle1745"/><a class="indexterm" id="iddle2086"/>Here, we see that Ruby saves a class pointer or the equivalent bit flag for all values by calling the <code class="literal">class</code> method on each. In turn, the <code class="literal">class</code> method returns the class pointer, or at least the name of the class that each <code class="literal">klass</code> pointer refers to.</p></div><div class="sect2" title="Do Generic Objects Have Instance Variables?"><div class="titlepage"><div><div><h2 class="title"><a id="do_generic_objects_have_instance_variabl"/>Do Generic Objects Have Instance Variables?</h2></div></div></div><p>Let’s go back to our definition of a Ruby object:</p><div class="blockquote"><blockquote class="blockquote"><p>Every Ruby object is the combination of a class pointer and an array of instance variables.</p></blockquote></div><p>What about instance variables for generic objects? Do integers, strings, and other generic data values have instance variables? That would seem odd, but if integers and strings are objects, this must be true! And if it is true, where does Ruby save these values if it doesn’t use the <code class="literal">RObject</code> structure?</p><p>Using the <code class="literal">instance_variables</code> method, shown in <a class="xref" href="ch05.html#saving_instance_variables_in_a_ruby_stri" title="Example 5-6. Saving instance variables in a Ruby string object">Example 5-6</a>, you can see that each of these basic values can also contain an array of instance variables, strange as that may seem.</p><div class="example"><a id="saving_instance_variables_in_a_ruby_stri"/><p class="title">Example 5-6. Saving instance variables in a Ruby string object</p><div class="example-contents"><pre class="programlisting">$ <span class="strong"><strong>irb</strong></span>
&gt; <span class="strong"><strong>str = "some string value"</strong></span>
 =&gt; "some string value"
&gt; <span class="strong"><strong>str.instance_variables</strong></span>
 =&gt; []
&gt; <span class="strong"><strong>str.instance_variable_set("@val1", "value one")</strong></span>
 =&gt; "value one"
&gt; <span class="strong"><strong>str.instance_variables</strong></span>
 =&gt; [:@val1]
&gt; <span class="strong"><strong>str.instance_variable_set("@val2", "value two")</strong></span>
 =&gt; "value two"
&gt; <span class="strong"><strong>str.instance_variables</strong></span>
 =&gt; [:@val1, :@val2]</pre></div></div><p>Repeat this exercise using symbols, arrays, or any Ruby value, and you’ll find that every Ruby value is an object and every object contains a class pointer and an array of instance variables.</p><div class="sidebar"><a id="reading_the_rbasic_and_robject_c_structu"/><p class="title">Reading the RBasic and RObject C Structure Definitions</p><p><a class="indexterm" id="iddle1855"/><a class="indexterm" id="iddle1887"/><a class="indexterm" id="iddle1919"/><a class="xref" href="ch05.html#definitions_of_the_rbasic_and_robjec" title="Example 5-7. The definitions of the RBasic and RObject C structures">Example 5-7</a> shows the definitions of the <code class="literal">RBasic</code> and <code class="literal">RObject</code> C structures. (You can find this code in the <span class="emphasis"><em>include/ruby/ruby.h</em></span> header file.)</p><div class="example"><a id="definitions_of_the_rbasic_and_robjec"/><p class="title">Example 5-7. The definitions of the <code class="literal">RBasic</code> and <code class="literal">RObject</code> C structures</p><div class="example-contents"><pre class="programlisting">    struct RBasic {
<img alt="" src="httpatomoreillycomsourcenostarchimages1853843.png.jpg"/>   VALUE flags;
<img alt="" src="httpatomoreillycomsourcenostarchimages1853845.png.jpg"/>   VALUE klass;
    };

    #define ROBJECT_EMBED_LEN_MAX 3
    struct RObject {
<img alt="" src="httpatomoreillycomsourcenostarchimages1853847.png.jpg"/>   struct RBasic basic;
      union {
        struct {
<img alt="" src="httpatomoreillycomsourcenostarchimages1853937.png.jpg"/>       long numiv;
<img alt="" src="httpatomoreillycomsourcenostarchimages1854043.png.jpg"/>       VALUE *ivptr;
<img alt="" src="httpatomoreillycomsourcenostarchimages1854045.png.jpg"/>       struct st_table *iv_index_tbl;
<img alt="" src="httpatomoreillycomsourcenostarchimages1854047.png.jpg"/>     } heap;
<img alt="" src="httpatomoreillycomsourcenostarchimages1854049.png.jpg"/>     VALUE ary[ROBJECT_EMBED_LEN_MAX];
      } as;
    };</pre></div></div><p>At the top, you see the definition of <code class="literal">RBasic</code>. This definition contains the two values: <code class="literal">flags</code> <span class="inlinemediaobject"><a id="inline_id00124"/><img alt="" src="httpatomoreillycomsourcenostarchimages1853843.png.jpg"/></span> and <code class="literal">klass</code> <span class="inlinemediaobject"><a id="inline_id00125"/><img alt="" src="httpatomoreillycomsourcenostarchimages1853845.png.jpg"/></span>. Below, you see the <code class="literal">RObject</code> definition. Notice that it contains a copy of the <code class="literal">RBasic</code> structure at <span class="inlinemediaobject"><a id="inline_id00126"/><img alt="" src="httpatomoreillycomsourcenostarchimages1853847.png.jpg"/></span>. Following this, the <code class="literal">union</code> keyword contains a structure called <code class="literal">heap</code> at <span class="inlinemediaobject"><a id="inline_id00127"/><img alt="" src="httpatomoreillycomsourcenostarchimages1854047.png.jpg"/></span>, followed by an array called <code class="literal">ary</code> at <span class="inlinemediaobject"><a id="inline_id00128"/><img alt="" src="httpatomoreillycomsourcenostarchimages1854049.png.jpg"/></span>.</p><p>The <code class="literal">heap</code> structure at <span class="inlinemediaobject"><a id="inline_id00129"/><img alt="" src="httpatomoreillycomsourcenostarchimages1854047.png.jpg"/></span> contains the following values:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>First, the value <code class="literal">numiv</code> at <span class="inlinemediaobject"><a id="inline_id00130"/><img alt="" src="httpatomoreillycomsourcenostarchimages1853937.png.jpg"/></span> tracks the number of instance variables contained in this object.</p></li><li class="listitem"><p>Next, <code class="literal">ivptr</code> at <span class="inlinemediaobject"><a id="inline_id00131"/><img alt="" src="httpatomoreillycomsourcenostarchimages1854043.png.jpg"/></span> is a pointer to an array containing the values of this object’s instance variables. Notice that the names, or IDs, of the instance variables are not stored here; only the values are stored.</p></li><li class="listitem"><p><code class="literal">iv_index_tbl</code> at <span class="inlinemediaobject"><a id="inline_id00132"/><img alt="" src="httpatomoreillycomsourcenostarchimages1854045.png.jpg"/></span> points to a hash table that maps between the name, or ID, of each instance variable and its location in the <code class="literal">ivptr</code> array. This value is actually stored in the <code class="literal">RClass</code> structure for this object’s class; this pointer is simply a cache, or shortcut, that Ruby uses to obtain that hash table quickly. (The <code class="literal">st_table</code> type refers to Ruby’s implementation of hash tables, which I’ll discuss in <a class="xref" href="ch07.html" title="Chapter 7. The Hash Table: The Workhorse of Ruby Internals">Chapter 7</a>.)</p></li></ul></div><p>The last member of the <code class="literal">RObject</code> structure, <code class="literal">ary</code> at <span class="inlinemediaobject"><a id="inline_id00133"/><img alt="" src="httpatomoreillycomsourcenostarchimages1854049.png.jpg"/></span>, occupies the same memory space as all previous values because of the <code class="literal">union</code> keyword at the top. Using this <code class="literal">ary</code> value, Ruby can save all of the instance variables right inside the <code class="literal">RObject</code> structure—if they’ll fit. This eliminates the need to call <code class="literal">malloc</code> to allocate extra memory to hold the instance variable value array. (Ruby also uses this sort of optimization for the <code class="literal">RString</code>, <code class="literal">RArray</code>, <code class="literal">RStruct</code>, and <code class="literal">RBignum</code> structures.)</p></div></div><div class="sect2" title="Where Does Ruby Save Instance Variables for Generic Objects?"><div class="titlepage"><div><div><h2 class="title"><a id="where_does_ruby_save_instance_variables"/>Where Does Ruby Save Instance Variables for Generic Objects?</h2></div></div></div><p><a class="indexterm" id="iddle1158"/><a class="indexterm" id="iddle1276"/><a class="indexterm" id="iddle1342"/><a class="indexterm" id="iddle1352"/><a class="indexterm" id="iddle1355"/><a class="indexterm" id="iddle1437"/><a class="indexterm" id="iddle1438"/><a class="indexterm" id="iddle1622"/><a class="indexterm" id="iddle1746"/><a class="indexterm" id="iddle1961"/><a class="indexterm" id="iddle2087"/><a class="indexterm" id="iddle2088"/>Internally, Ruby uses a bit of a hack to save instance variables for generic objects—that is, for objects that don’t use an <code class="literal">RObject</code> structure. When you save an instance variable in a generic object, Ruby saves it in a special hash called <code class="literal">generic_iv_tbl</code>. This hash maintains a map between generic objects and pointers to other hashes that contain each object’s instance variables. <a class="xref" href="ch05.html#genericunderscoreivunderscoretbl_stores" title="Figure 5-7. generic_iv_tbl stores instance variables for generic objects.">Figure 5-7</a> shows how this would look for the <code class="literal">str</code> string example in <a class="xref" href="ch05.html#saving_instance_variables_in_a_ruby_stri" title="Example 5-6. Saving instance variables in a Ruby string object">Example 5-6</a>.</p><div class="figure"><a id="genericunderscoreivunderscoretbl_stores"/><div class="figure-contents"><div class="mediaobject"><a id="med_id00114"/><img alt="generic_iv_tbl stores instance variables for generic objects." src="httpatomoreillycomsourcenostarchimages1854051.png.jpg"/></div></div><p class="title">Figure 5-7. <code class="literal">generic_iv_tbl</code> stores instance variables for generic objects.</p></div></div></div><div class="sect1" title="Experiment 5-1: How Long Does It Take to Save a New Instance Variable?"><div class="titlepage"><div><div><h1 class="title"><a id="experiment_5-1_how_long_does_it_take_to"/>Experiment 5-1: How Long Does It Take to Save a New Instance Variable?</h1></div></div></div><p>To learn more about how Ruby saves instance variables internally, let’s measure how long it takes Ruby to save one in an object. To do this, I’ll create a large number of test objects, as shown in <a class="xref" href="ch05.html#creating_test_objects_using_classdotnew" title="Example 5-8. Creating test objects using Class.new">Example 5-8</a>.</p><div class="example"><a id="creating_test_objects_using_classdotnew"/><p class="title">Example 5-8. Creating test objects using <code class="literal">Class.new</code></p><div class="example-contents"><pre class="programlisting">ITERATIONS = 100000
<img alt="" src="httpatomoreillycomsourcenostarchimages1853843.png.jpg"/> GC.disable
<img alt="" src="httpatomoreillycomsourcenostarchimages1853845.png.jpg"/> obj = ITERATIONS.times.map { Class.new.new }</pre></div></div><p>Here, I’m using <code class="literal">Class.new</code> at <span class="inlinemediaobject"><a id="inline_id00136"/><img alt="" src="httpatomoreillycomsourcenostarchimages1853845.png.jpg"/></span> to create a unique class for each new object in order to make sure they’re all independent. I’ve also disabled garbage collection at <span class="inlinemediaobject"><a id="inline_id00137"/><img alt="" src="httpatomoreillycomsourcenostarchimages1853843.png.jpg"/></span> to avoid skewing the results with GC operations. Then, in <a class="xref" href="ch05.html#adding_instance_variables_to_each_test_o" title="Example 5-9. Adding instance variables to each test object">Example 5-9</a>, I add instance variables to each.</p><div class="example"><a id="adding_instance_variables_to_each_test_o"/><p class="title">Example 5-9. Adding instance variables to each test object</p><div class="example-contents"><pre class="programlisting">Benchmark.bm do |bench|
  20.times do |count|
    bench.report("adding instance variable number #{count+1}") do
      ITERATIONS.times do |n|
        obj[n].instance_variable_set("@var#{count}", "value")
      end
    end
  end
end</pre></div></div><p><a class="indexterm" id="iddle1464"/><a class="indexterm" id="iddle1802"/><a class="xref" href="ch05.html#adding_instance_variables_to_each_test_o" title="Example 5-9. Adding instance variables to each test object">Example 5-9</a> iterates 20 times, repeatedly saving one more new instance variable to each of the objects. <a class="xref" href="ch05.html#time_to_add_one_more_instance_variable_l" title="Figure 5-8. Time to add one more instance variable (in seconds x 100,000) vs. instance variable count">Figure 5-8</a> shows the time that it takes Ruby 2.0 to add each variable: The first bar on the left is the time it takes to save the first instance variable in all the objects, and each subsequent bar is the additional time taken to save one more instance variable in each object.</p><div class="figure"><a id="time_to_add_one_more_instance_variable_l"/><div class="figure-contents"><div class="mediaobject"><a id="med_id00115"/><img alt="Time to add one more instance variable (in seconds x 100,000) vs. instance variable count" src="httpatomoreillycomsourcenostarchimages1854053.png"/></div></div><p class="title">Figure 5-8. Time to add one more instance variable (in seconds x 100,000) vs. instance variable count</p></div><p><a class="xref" href="ch05.html#time_to_add_one_more_instance_variable_l" title="Figure 5-8. Time to add one more instance variable (in seconds x 100,000) vs. instance variable count">Figure 5-8</a> shows a strange pattern. Sometimes it takes Ruby longer to add a new instance variable. What’s going on here?</p><p>The reason for this behavior has to do with the <code class="literal">ivptr</code> array where Ruby stores the instance variables, as shown in <a class="xref" href="ch05.html#two_instance_variables_saved_in_an_objec" title="Figure 5-9. Two instance variables saved in an object">Figure 5-9</a>.</p><div class="figure"><a id="two_instance_variables_saved_in_an_objec"/><div class="figure-contents"><div class="mediaobject"><a id="med_id00116"/><img alt="Two instance variables saved in an object" src="httpatomoreillycomsourcenostarchimages1854055.png.jpg"/></div></div><p class="title">Figure 5-9. Two instance variables saved in an object</p></div><p><a class="indexterm" id="iddle1878"/>In Ruby 1.8 this array is a hash table containing both the variable names (the hash keys) and the values, which will automatically expand to accommodate any number of elements.</p><p>Ruby 1.9 and 2.0 speed things up a bit by saving the values in a simple array. The instance variable names are saved in the object’s class instead, because they’re the same for all instances of a class. As a result, Ruby 1.9 and 2.0 need to either preallocate a large array to handle any number of instance variables or repeatedly increase the size of this array as you save more variables.</p><p>In fact, as you can see in <a class="xref" href="ch05.html#time_to_add_one_more_instance_variable_l" title="Figure 5-8. Time to add one more instance variable (in seconds x 100,000) vs. instance variable count">Figure 5-8</a>, Ruby 1.9 and 2.0 repeatedly increase the array size. For example, suppose you have seven instance variables in a given object, as shown in <a class="xref" href="ch05.html#seven_instance_variables_in_an_object" title="Figure 5-10. Seven instance variables in an object">Figure 5-10</a>.</p><div class="figure"><a id="seven_instance_variables_in_an_object"/><div class="figure-contents"><div class="mediaobject"><a id="med_id00117"/><img alt="Seven instance variables in an object" src="httpatomoreillycomsourcenostarchimages1854057.png.jpg"/></div></div><p class="title">Figure 5-10. Seven instance variables in an object</p></div><p>When you add the eighth variable—bar 8 in <a class="xref" href="ch05.html#time_to_add_one_more_instance_variable_l" title="Figure 5-8. Time to add one more instance variable (in seconds x 100,000) vs. instance variable count">Figure 5-8</a>—Ruby 1.9 and 2.0 increase the array size by three, anticipating that you will soon add more variables, as shown in <a class="xref" href="ch05.html#adding_an_eighth_value_allocates_extra_s" title="Figure 5-11. Adding an eighth value allocates extra space.">Figure 5-11</a>.</p><div class="figure"><a id="adding_an_eighth_value_allocates_extra_s"/><div class="figure-contents"><div class="mediaobject"><a id="med_id00118"/><img alt="Adding an eighth value allocates extra space." src="httpatomoreillycomsourcenostarchimages1854059.png.jpg"/></div></div><p class="title">Figure 5-11. Adding an eighth value allocates extra space.</p></div><p>Allocating more memory takes extra time, which is why bar 8 is higher. Now if you add two more instance variables, Ruby 1.9 and 2.0 won’t need to reallocate memory for this array because the space will already be available. This explains the shorter times for bars 9 and 10.</p></div><div class="sect1" title="What’s Inside the RClass Structure?"><div class="titlepage"><div><div><h1 class="title"><a id="whatapostrophes_inside_the_rclass_struct"/>What’s Inside the RClass Structure?</h1></div></div></div><p>Every object remembers its class by saving a pointer to an <code class="literal">RClass</code> structure. What information does each <code class="literal">RClass</code> structure contain? What would we see if we could look inside a Ruby class? Let’s build a model of the information that must be present in <code class="literal">RClass</code>. This model will give us a technical definition of what a Ruby class is, based on what we know classes can do.</p><div class="informalfigure"><a id="med_id00119a"/><div class="mediaobject"><a id="med_id00119"/><img alt="image with no caption" src="httpatomoreillycomsourcenostarchimages1854061.png.jpg"/><div class="caption"><p><span class="emphasis"><em>Two objects, one class</em></span></p></div></div></div><p><a class="indexterm" id="iddle1052"/><a class="indexterm" id="iddle1055"/><a class="indexterm" id="iddle1608"/><a class="indexterm" id="iddle1659"/>Every Ruby developer knows how to write a class: You type the <code class="literal">class</code> keyword, specify a name for the new class, and then type in the class’s methods. <a class="xref" href="ch05.html#same_simple_ruby_class_we_saw_in_lis" title="Example 5-10. The same simple Ruby class we saw in Example 5-1">Example 5-10</a> shows a familiar example.</p><div class="example"><a id="same_simple_ruby_class_we_saw_in_lis"/><p class="title">Example 5-10. The same simple Ruby class we saw in <a class="xref" href="ch05.html#simple_ruby_class" title="Example 5-1. A simple Ruby class">Example 5-1</a></p><div class="example-contents"><pre class="programlisting">class Mathematician
  attr_accessor :first_name
  attr_accessor :last_name
end</pre></div></div><p><code class="literal">attr_accessor</code> is shorthand for defining get and set methods for an attribute. (The methods defined by <code class="literal">attr_accessor</code> also check for <code class="literal">nil</code> values). <a class="xref" href="ch05.html#same_class_written_without_attrunder" title="Example 5-11. The same class written without attr_accessor">Example 5-11</a> shows a more verbose way of defining the same <code class="literal">Mathematician</code> class.</p><div class="example"><a id="same_class_written_without_attrunder"/><p class="title">Example 5-11. The same class written without <code class="literal">attr_accessor</code></p><div class="example-contents"><pre class="programlisting">class Mathematician
  def first_name
    @first_name
  end
  def first_name=(value)
    @first_name = value
  end
  def last_name
    @last_name
  end
  def last_name=(value)
    @last_name = value
  end
end</pre></div></div><p>It appears that this class—and every Ruby class—is just a group of method definitions. You can assign behavior to an object by adding methods to its class, and when you call a method on an object, Ruby looks for the method in the object’s class. This leads to our first definition of a Ruby class:</p><div class="blockquote"><blockquote class="blockquote"><p>A Ruby class is a group of method definitions.</p></blockquote></div><p>Therefore, the <code class="literal">RClass</code> structure for <code class="literal">Mathematician</code> must save a list of all the methods defined in the class, as shown in <a class="xref" href="ch05.html#ruby_classes_contain_a_method_tabledot" title="Figure 5-12. Ruby classes contain a method table.">Figure 5-12</a>.</p><p>Notice in <a class="xref" href="ch05.html#same_class_written_without_attrunder" title="Example 5-11. The same class written without attr_accessor">Example 5-11</a> that I’ve also created two instance variables: <code class="literal">@first_name</code> and <code class="literal">@last_name</code>. We saw earlier how Ruby stores these values in each <code class="literal">RObject</code> structure, but you may have noticed that only the <span class="emphasis"><em>values</em></span> of these variables are stored in <code class="literal">RObject</code>, not their names. (Ruby 1.8 does store the names in <code class="literal">RObject</code>.) Ruby must store the attribute names in <code class="literal">RClass</code>, which makes sense because the names will be the same for every <code class="literal">Mathematician</code> instance.</p><div class="figure"><a id="ruby_classes_contain_a_method_tabledot"/><div class="figure-contents"><div class="mediaobject"><a id="med_id00120"/><img alt="Ruby classes contain a method table." src="httpatomoreillycomsourcenostarchimages1854063.png.jpg"/></div></div><p class="title">Figure 5-12. Ruby classes contain a method table.</p></div><p><a class="indexterm" id="iddle1120"/><a class="indexterm" id="iddle1660"/>Let’s redraw <code class="literal">RClass</code> again and include a table of attribute names this time, as shown in <a class="xref" href="ch05.html#ruby_classes_also_contain_a_table_of_att" title="Figure 5-13. Ruby classes also contain a table of attribute names.">Figure 5-13</a>.</p><div class="figure"><a id="ruby_classes_also_contain_a_table_of_att"/><div class="figure-contents"><div class="mediaobject"><a id="med_id00121"/><img alt="Ruby classes also contain a table of attribute names." src="httpatomoreillycomsourcenostarchimages1854065.png"/></div></div><p class="title">Figure 5-13. Ruby classes also contain a table of attribute names.</p></div><p>Now our definition of a Ruby class is as follows:</p><div class="blockquote"><blockquote class="blockquote"><p>A Ruby class is a group of method definitions and a table of attribute names.</p></blockquote></div><p>At the beginning of this chapter, I mentioned that every value in Ruby is an object. This might be true for classes, too. Let’s prove this using IRB.</p><a id="pro_id00022"/><pre class="programlisting">&gt; <span class="strong"><strong>p Mathematician.class</strong></span>
 =&gt; Class</pre><p>As you can see, Ruby classes are all instances of the <code class="literal">Class</code> class; therefore, classes are also objects. Now to update our definition of a Ruby class again:</p><div class="blockquote"><blockquote class="blockquote"><p>A Ruby class is a Ruby object that also contains method definitions and attribute names.</p></blockquote></div><p><a class="indexterm" id="iddle1417"/><a class="indexterm" id="iddle1430"/>Because Ruby classes are objects, we know that the <code class="literal">RClass</code> structure must also contain a class pointer and an instance variable array, the values that we know every Ruby object contains, as shown in <a class="xref" href="ch05.html#ruby_classes_also_contain_a_class_pointe" title="Figure 5-14. Ruby classes also contain a class pointer and instance variables.">Figure 5-14</a>.</p><div class="figure"><a id="ruby_classes_also_contain_a_class_pointe"/><div class="figure-contents"><div class="mediaobject"><a id="med_id00122"/><img alt="Ruby classes also contain a class pointer and instance variables." src="httpatomoreillycomsourcenostarchimages1854067.png.jpg"/></div></div><p class="title">Figure 5-14. Ruby classes also contain a class pointer and instance variables.</p></div><p>As you can see, I’ve added a pointer to the <code class="literal">Class</code> class, which is in theory the class of every Ruby class object. However, in <a class="xref" href="ch05.html#experiment_5-2_where_does_ruby_save_clas" title="Experiment 5-2: Where Does Ruby Save Class Methods?">Experiment 5-2: Where Does Ruby Save Class Methods?</a>, I’ll show that this diagram is in fact not accurate—that <code class="literal">klass</code> actually points to something else! I’ve also added a table of instance variables.</p><div class="note" title="Note"><h3 class="title"><a id="ch05note01"/>Note</h3><p><span class="emphasis"><em>These are the class-level instance variables. Don’t confuse these with the table of attribute names for the object-level instance variables.</em></span></p></div><p>This is rapidly getting out of control! The <code class="literal">RClass</code> structure seems to be much more complex than the <code class="literal">RObject</code> structure. But don’t worry—we’re getting close to an accurate picture of the <code class="literal">RClass</code> structure. Next we need to consider two more important types of information contained in each Ruby class.</p><div class="sect2" title="Inheritance"><div class="titlepage"><div><div><h2 class="title"><a id="inheritance"/>Inheritance</h2></div></div></div><p>Inheritance is an essential feature of object-oriented programming. Ruby implements single inheritance by allowing us to optionally specify one superclass when we create a class. If we don’t specify a superclass, Ruby assigns the <code class="literal">Object</code> class as the superclass. For example, we could rewrite the <code class="literal">Mathematician</code> class using a superclass like this:</p><a id="pro_id00023"/><pre class="programlisting">class Mathematician &lt; Person
--<span class="emphasis"><em>snip</em></span>--</pre><p>Now every instance of <code class="literal">Mathematician</code> will include the same methods that instances of <code class="literal">Person</code> have. In this example, we might want to move the <code class="literal">first_name</code> and <code class="literal">last_name</code> accessor methods into <code class="literal">Person</code>. We could also move <a class="indexterm" id="iddle1822"/><a class="indexterm" id="iddle2029"/>the <code class="literal">@first_name</code> and <code class="literal">@last_name</code> attributes into the <code class="literal">Person</code> class. Every instance of <code class="literal">Mathematician</code> will contain these methods and attributes, even though we moved them to the <code class="literal">Person</code> class.</p><p>The <code class="literal">Mathematician</code> class must contain a reference to the <code class="literal">Person</code> class (its superclass) so that Ruby can find any methods or attributes defined in the superclass.</p><p>Let’s update our definition again, assuming that Ruby tracks the superclass using another pointer similar to <code class="literal">klass</code>:</p><div class="blockquote"><blockquote class="blockquote"><p>A Ruby class is a Ruby object that also contains method definitions, attribute names, and a superclass pointer.</p></blockquote></div><p>And let’s redraw the <code class="literal">RClass</code> structure to include the new superclass pointer, as shown in <a class="xref" href="ch05.html#ruby_classes_also_contain_a_superclass_p" title="Figure 5-15. Ruby classes also contain a superclass pointer.">Figure 5-15</a>.</p><div class="figure"><a id="ruby_classes_also_contain_a_superclass_p"/><div class="figure-contents"><div class="mediaobject"><a id="med_id00123"/><img alt="Ruby classes also contain a superclass pointer." src="httpatomoreillycomsourcenostarchimages1854069.png.jpg"/></div></div><p class="title">Figure 5-15. Ruby classes also contain a superclass pointer.</p></div><p>At this point, it is critical to understand the difference between the <code class="literal">klass</code> pointer and the <code class="literal">super</code> pointer. The <code class="literal">klass</code> pointer indicates which class the Ruby class object is an instance of. This will always be the <code class="literal">Class</code> class:</p><a id="pro_id00024"/><pre class="programlisting">&gt; <span class="strong"><strong>p Mathematician.class</strong></span>
 =&gt; Class</pre><p>Ruby uses the <code class="literal">klass</code> pointer to find the methods of the <code class="literal">Mathematician</code> class object, such as the <code class="literal">new</code> method that every Ruby class implements. However, the <code class="literal">super</code> pointer records the class’s superclass:</p><a id="pro_id00025"/><pre class="programlisting">&gt; <span class="strong"><strong>p Mathematician.superclass</strong></span>
 =&gt; Person</pre><p><a class="indexterm" id="iddle1151"/><a class="indexterm" id="iddle1163"/><a class="indexterm" id="iddle2084"/><a class="indexterm" id="iddle2085"/>Ruby uses the <code class="literal">super</code> pointer to help find methods contained in each <code class="literal">Mathematician</code> instance, such as <code class="literal">first_name=</code> or <code class="literal">last_name</code>. As we’ll see next, Ruby also uses the <code class="literal">super</code> pointer when getting or setting class variables.</p></div><div class="sect2" title="Class Instance Variables vs. Class Variables"><div class="titlepage"><div><div><h2 class="title"><a id="class_instance_variables_vsdot_class_var"/>Class Instance Variables vs. Class Variables</h2></div></div></div><p>One confusing bit of Ruby syntax is the concept of <span class="emphasis"><em>class variables</em></span>. You might think that these are simply the instance variables of a class (the class-level instance variables from <a class="xref" href="ch05.html#ruby_classes_also_contain_a_class_pointe" title="Figure 5-14. Ruby classes also contain a class pointer and instance variables.">Figure 5-14</a>), but class instance variables and class variables are distinctly different.</p><p>To create a class instance variable, you simply create an instance variable using the <code class="literal">@</code> symbol, but in the context of a class rather than an object. For example, <a class="xref" href="ch05.html#creating_a_class-level_instance_variable" title="Example 5-12. Creating a class-level instance variable">Example 5-12</a> shows how we could use an instance variable of <code class="literal">Mathematician</code> to indicate a branch of mathematics this class corresponds to. We create the <code class="literal">@type</code> instance variable at <span class="inlinemediaobject"><a id="inline_id00138"/><img alt="" src="httpatomoreillycomsourcenostarchimages1853843.png.jpg"/></span>.</p><div class="example"><a id="creating_a_class-level_instance_variable"/><p class="title">Example 5-12. Creating a class-level instance variable</p><div class="example-contents"><pre class="programlisting">    class Mathematician
<img alt="" src="httpatomoreillycomsourcenostarchimages1853843.png.jpg"/>   @type = "General"
      def self.type
        @type
      end
    end

    puts Mathematician.type
     =&gt; General</pre></div></div><p>In contrast, to create a class variable, you would use the <code class="literal">@@</code> notation. <a class="xref" href="ch05.html#creating_a_class_variable" title="Example 5-13. Creating a class variable">Example 5-13</a> shows the same example, with the class variable <code class="literal">@@type</code> <span class="inlinemediaobject"><a id="inline_id00140"/><img alt="" src="httpatomoreillycomsourcenostarchimages1853843.png.jpg"/></span> created.</p><div class="example"><a id="creating_a_class_variable"/><p class="title">Example 5-13. Creating a class variable</p><div class="example-contents"><pre class="programlisting">    class Mathematician
<img alt="" src="httpatomoreillycomsourcenostarchimages1853843.png.jpg"/>   @@type = "General"
      def self.type
        @@type
      end
    end

    puts Mathematician.type
     =&gt; General</pre></div></div><p>What’s the difference? When you create a class variable, Ruby creates a single value for you to use in that class and in any subclasses you might define. On the other hand, using a class <span class="emphasis"><em>instance</em></span> variable causes Ruby to create a separate value for each class or subclass.</p><p>Let’s review <a class="xref" href="ch05.html#each_class_and_subclass_has_its_own_inst" title="Example 5-14. Each class and subclass has its own instance variables.">Example 5-14</a> to see how Ruby handles these two types of variables differently. First, I define a class instance variable called <code class="literal">@type</code> in the <code class="literal">Mathematician</code> class and set its value to the string <code class="literal">General</code>. Next, I create a second class called <code class="literal">Statistician</code>, which is a subclass of <code class="literal">Mathematician</code>, and change the value of <code class="literal">@type</code> to the string <code class="literal">Statistics</code>.</p><div class="example"><a id="each_class_and_subclass_has_its_own_inst"/><p class="title">Example 5-14. Each class and subclass has its own instance variables.</p><div class="example-contents"><pre class="programlisting">    class Mathematician
      @type = "General"
      def self.type
        @type
      end
    end
    
    class Statistician &lt; Mathematician
      @type = "Statistics"
    end
    
    puts Statistician.type
<img alt="" src="httpatomoreillycomsourcenostarchimages1853843.png.jpg"/>  =&gt; Statistics
    puts Mathematician.type
<img alt="" src="httpatomoreillycomsourcenostarchimages1853845.png.jpg"/>  =&gt; General</pre></div></div><p>Notice that the values of <code class="literal">@type</code> in <code class="literal">Statistician</code> at <span class="inlinemediaobject"><a id="inline_id00144"/><img alt="" src="httpatomoreillycomsourcenostarchimages1853843.png.jpg"/></span> and <code class="literal">Mathematician</code> at <span class="inlinemediaobject"><a id="inline_id00145"/><img alt="" src="httpatomoreillycomsourcenostarchimages1853845.png.jpg"/></span> are different. Each class has its own separate copy of <code class="literal">@type</code>.</p><p>However, if I use a class variable instead, Ruby shares that value between <code class="literal">Mathematician</code> and <code class="literal">Statistician</code>, as demonstrated in <a class="xref" href="ch05.html#ruby_shares_class_variables_among_a_clas" title="Example 5-15. Ruby shares class variables among a class and all of its subclasses.">Example 5-15</a>.</p><div class="example"><a id="ruby_shares_class_variables_among_a_clas"/><p class="title">Example 5-15. Ruby shares class variables among a class and all of its subclasses.</p><div class="example-contents"><pre class="programlisting">    class Mathematician
      @@type = "General"
      def self.type
        @@type
      end
    end
    
    class Statistician &lt; Mathematician
      @@type = "Statistics"
    end
    
    puts Statistician.type
<img alt="" src="httpatomoreillycomsourcenostarchimages1853843.png.jpg"/>  =&gt; Statistics
    puts Mathematician.type
<img alt="" src="httpatomoreillycomsourcenostarchimages1853845.png.jpg"/>  =&gt; Statistics</pre></div></div><p>Here, Ruby shows the same value for <code class="literal">@@type</code> in <code class="literal">Statistician</code> at <span class="inlinemediaobject"><a id="inline_id00148"/><img alt="" src="httpatomoreillycomsourcenostarchimages1853843.png.jpg"/></span> and in <code class="literal">Mathematician</code> at <span class="inlinemediaobject"><a id="inline_id00149"/><img alt="" src="httpatomoreillycomsourcenostarchimages1853845.png.jpg"/></span>.</p><p><a class="indexterm" id="iddle1359"/><a class="indexterm" id="iddle1986"/>Internally, however, Ruby actually saves both class variables and class instance variables in the same table inside the <code class="literal">RClass</code> structure. <a class="xref" href="ch05.html#ruby_saves_class_variables_and_class_ins" title="Figure 5-16. Ruby saves class variables and class instance variables in the same table.">Figure 5-16</a> shows how the <code class="literal">Mathematician</code> class would save the <code class="literal">@type</code> and <code class="literal">@@type</code> values if you created both of them. The extra <code class="literal">@</code> symbol in the name allows Ruby to distinguish between the two types of variables.</p><div class="figure"><a id="ruby_saves_class_variables_and_class_ins"/><div class="figure-contents"><div class="mediaobject"><a id="med_id00124"/><img alt="Ruby saves class variables and class instance variables in the same table." src="httpatomoreillycomsourcenostarchimages1854071.png.jpg"/></div></div><p class="title">Figure 5-16. Ruby saves class variables and class instance variables in the same table.</p></div></div><div class="sect2" title="Getting and Setting Class Variables"><div class="titlepage"><div><div><h2 class="title"><a id="getting_and_setting_class_variables"/>Getting and Setting Class Variables</h2></div></div></div><p>It’s true: Ruby saves both class variables and class instance variables in the same table. However, the ways Ruby gets or sets these two types of variables are quite different.</p><p>When you get or set a class instance variable, Ruby looks up the variable in the <code class="literal">RClass</code> structure corresponding to the target class and either saves or retrieves the value. <a class="xref" href="ch05.html#ruby_saves_class_instance_variables_in_t" title="Figure 5-17. Ruby saves class instance variables in the RClass structure of the target class.">Figure 5-17</a> shows how Ruby saves the class instance variables from <a class="xref" href="ch05.html#each_class_and_subclass_has_its_own_inst" title="Example 5-14. Each class and subclass has its own instance variables.">Example 5-14</a>.</p><div class="figure"><a id="ruby_saves_class_instance_variables_in_t"/><div class="figure-contents"><div class="mediaobject"><a id="med_id00125"/><img alt="Ruby saves class instance variables in the RClass structure of the target class." src="httpatomoreillycomsourcenostarchimages1854073.png.jpg"/></div></div><p class="title">Figure 5-17. Ruby saves class instance variables in the <code class="literal">RClass</code> structure of the target class.</p></div><p>At the top of the figure, you can see a line of code that saves a class instance variable in <code class="literal">Mathematician</code>. Below that is a similar line of code that saves a value in <code class="literal">Statistician</code>. In both cases, Ruby saves the class instance variable in the <code class="literal">RClass</code> structure for the current class.</p><p>Ruby uses a more complex algorithm for class variables. To produce the behavior we saw in <a class="xref" href="ch05.html#ruby_shares_class_variables_among_a_clas" title="Example 5-15. Ruby shares class variables among a class and all of its subclasses.">Example 5-15</a>, Ruby needs to search through all the superclasses to see whether any of them define the same class variable. <a class="xref" href="ch05.html#before_saving_itcomma_ruby_checks_whethe" title="Figure 5-18. Before saving it, Ruby checks whether the class variable exists in the target class or any of its superclasses.">Figure 5-18</a> shows an example.</p><div class="figure"><a id="before_saving_itcomma_ruby_checks_whethe"/><div class="figure-contents"><div class="mediaobject"><a id="med_id00126"/><img alt="Before saving it, Ruby checks whether the class variable exists in the target class or any of its superclasses." src="httpatomoreillycomsourcenostarchimages1854075.png.jpg"/></div></div><p class="title">Figure 5-18. Before saving it, Ruby checks whether the class variable exists in the target class or any of its superclasses.</p></div><p>When you save a class variable, Ruby looks in the target class and all of its superclasses for an existing variable. It will use the copy found in the highest superclass. In <a class="xref" href="ch05.html#before_saving_itcomma_ruby_checks_whethe" title="Figure 5-18. Before saving it, Ruby checks whether the class variable exists in the target class or any of its superclasses.">Figure 5-18</a> you can see Ruby checks both the <code class="literal">Statistician</code> and <code class="literal">Mathematician</code> classes when saving the <code class="literal">@@type</code> class variable in <code class="literal">Statistician</code>. Because I already saved the same class variable in <code class="literal">Mathematician</code> (<a class="xref" href="ch05.html#ruby_shares_class_variables_among_a_clas" title="Example 5-15. Ruby shares class variables among a class and all of its subclasses.">Example 5-15</a>), Ruby will use that and overwrite it with the new value, as shown in <a class="xref" href="ch05.html#ruby_uses_the_class_variable_copy_found" title="Figure 5-19. Ruby uses the class variable copy found in the highest superclass.">Figure 5-19</a>.</p><div class="figure"><a id="ruby_uses_the_class_variable_copy_found"/><div class="figure-contents"><div class="mediaobject"><a id="med_id00127"/><img alt="Ruby uses the class variable copy found in the highest superclass." src="httpatomoreillycomsourcenostarchimages1854077.png.jpg"/></div></div><p class="title">Figure 5-19. Ruby uses the class variable copy found in the highest superclass.</p></div></div><div class="sect2" title="Constants"><div class="titlepage"><div><div><h2 class="title"><a id="constants"/>Constants</h2></div></div></div><p><a class="indexterm" id="iddle1192"/>We have one more feature of Ruby classes to cover: <span class="emphasis"><em>constants</em></span>. As you may know, Ruby allows you to define constant values inside a class, like this:</p><a id="pro_id00026"/><pre class="programlisting">class Mathematician &lt; Person
  AREA_OF_EXPERTISE = "Mathematics"
  --<span class="emphasis"><em>snip</em></span>--</pre><p>Constant values must start with a capital letter, and they are valid within the scope of the current class. (Curiously, Ruby allows you to change a constant value, but it will display a warning when you do so.) Let’s add a constant table to our <code class="literal">RClass</code> structure, because Ruby must save these values inside each class, as shown in <a class="xref" href="ch05.html#ruby_classes_also_contain_a_constants_ta" title="Figure 5-20. Ruby classes also contain a constants table.">Figure 5-20</a>.</p><p>Now we can write a complete, technical definition of a Ruby class:</p><div class="blockquote"><blockquote class="blockquote"><p>A Ruby class is a Ruby object that also contains method definitions, attribute names, a superclass pointer, and a constants table.</p></blockquote></div><p>Granted, this isn’t as concise as the simple definition we had for a Ruby object, but each Ruby class contains much more information than each Ruby object. Ruby classes are obviously fundamental to the language.</p><div class="figure"><a id="ruby_classes_also_contain_a_constants_ta"/><div class="figure-contents"><div class="mediaobject"><a id="med_id00128"/><img alt="Ruby classes also contain a constants table." src="httpatomoreillycomsourcenostarchimages1854079.png.jpg"/></div></div><p class="title">Figure 5-20. Ruby classes also contain a constants table.</p></div></div><div class="sect2" title="The Actual RClass Structure"><div class="titlepage"><div><div><h2 class="title"><a id="actual_rclass_structure"/>The Actual RClass Structure</h2></div></div></div><p><a class="indexterm" id="iddle1056"/><a class="indexterm" id="iddle1198"/><a class="indexterm" id="iddle1460"/><a class="indexterm" id="iddle1562"/><a class="indexterm" id="iddle1661"/><a class="indexterm" id="iddle1798"/><a class="indexterm" id="iddle1808"/><a class="indexterm" id="iddle1823"/><a class="indexterm" id="iddle1862"/><a class="indexterm" id="iddle1879"/><a class="indexterm" id="iddle2030"/>Having built up a conceptual model for what information must be stored in <code class="literal">RClass</code>, let’s look at the actual structure that Ruby uses to represent classes, as shown in <a class="xref" href="ch05.html#how_ruby_actually_represents_a_class" title="Figure 5-21. How Ruby actually represents a class">Figure 5-21</a>.</p><p>As you can see, Ruby uses two separate structures to represent each class: <code class="literal">RClass</code> and <code class="literal">rb_classext_struct</code>. But these two structures act as one large structure because each <code class="literal">RClass</code> always contains a pointer (<code class="literal">ptr</code>) to a corresponding <code class="literal">rb_classext_struct</code>. You might guess that the Ruby core team decided to use two different structures because there are so many different values to save, but in fact they probably created <code class="literal">rb_classext_struct</code> to save internal values that they didn’t want to expose in the public Ruby C extension API.</p><p>Like <code class="literal">RObject</code>, <code class="literal">RClass</code> has a <code class="literal">VALUE</code> pointer (shown on the left of <a class="xref" href="ch05.html#how_ruby_actually_represents_a_class" title="Figure 5-21. How Ruby actually represents a class">Figure 5-21</a>). Ruby always accesses classes using these <code class="literal">VALUE</code> pointers. The right side of the figure shows the technical names for the fields:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p><code class="literal">flags</code> and <code class="literal">klass</code> are the same <code class="literal">RBasic</code> values that every Ruby value contains.</p></li><li class="listitem"><p><code class="literal">m_tbl</code> is the method table, a hash whose keys are the names, or IDs, of each method and whose values are pointers to the definition of each method, including the compiled YARV instructions.</p></li><li class="listitem"><p><code class="literal">iv_index_tbl</code> is the attribute names table, a hash that maps each instance variable name to the index of the attribute’s value in each <code class="literal">RObject</code> instance variable array.</p></li><li class="listitem"><p><code class="literal">super</code> is a pointer to the <code class="literal">RClass</code> structure for this class’s superclass.</p><div class="figure"><a id="how_ruby_actually_represents_a_class"/><div class="figure-contents"><div class="mediaobject"><a id="med_id00129"/><img alt="How Ruby actually represents a class" src="httpatomoreillycomsourcenostarchimages1854081.png.jpg"/></div></div><p class="title">Figure 5-21. How Ruby actually represents a class</p></div></li><li class="listitem"><p><a class="indexterm" id="iddle1012"/><a class="indexterm" id="iddle1200"/><a class="indexterm" id="iddle1461"/><a class="indexterm" id="iddle1465"/><a class="indexterm" id="iddle1563"/><a class="indexterm" id="iddle1662"/><a class="indexterm" id="iddle1764"/><a class="indexterm" id="iddle1792"/><a class="indexterm" id="iddle1799"/><a class="indexterm" id="iddle1803"/><a class="indexterm" id="iddle1809"/><a class="indexterm" id="iddle1814"/><a class="indexterm" id="iddle1816"/><a class="indexterm" id="iddle1824"/><a class="indexterm" id="iddle1863"/><a class="indexterm" id="iddle1898"/><a class="indexterm" id="iddle2031"/><code class="literal">iv_tbl</code> contains the class-level instance variables and class variables, including both their names and values.</p></li><li class="listitem"><p><code class="literal">const_tbl</code> is a hash containing all of the constants (names and values) defined in this class’s scope. You can see that Ruby implements <code class="literal">iv_tbl</code> and <code class="literal">const_tbl</code> in the same way: Class-level instance variables and constants are almost the same thing.</p></li><li class="listitem"><p>Ruby uses <code class="literal">origin</code> to implement the <code class="literal">Module#prepend</code> feature. I’ll discuss what <code class="literal">prepend</code> does and how Ruby implements it in <a class="xref" href="ch06.html" title="Chapter 6. Method Lookup and Constant Lookup">Chapter 6</a>.</p></li><li class="listitem"><p>Ruby uses the <code class="literal">refined_class</code> pointer to implement the new experimental refinements feature, which I’ll discuss further in <a class="xref" href="ch09.html" title="Chapter 9. Metaprogramming">Chapter 9</a>.</p></li><li class="listitem"><p>Finally, Ruby uses <code class="literal">allocator</code> internally to allocate memory for new instances of this class.</p></li></ul></div><div class="sidebar"><a id="reading_the_rclass_c_structure_definitio"/><p class="title">Reading the RClass C Structure Definition</p><p><a class="indexterm" id="iddle1057"/><a class="indexterm" id="iddle1154"/><a class="indexterm" id="iddle1267"/><a class="indexterm" id="iddle1620"/><a class="indexterm" id="iddle1880"/><a class="indexterm" id="iddle1888"/>Now for a quick look at the actual <code class="literal">RClass</code> structure definition, as shown in <a class="xref" href="ch05.html#definition_of_the_rclass_c_structure" title="Example 5-16. The definition of the RClass C structure">Example 5-16</a>.</p><div class="example"><a id="definition_of_the_rclass_c_structure"/><p class="title">Example 5-16. The definition of the <code class="literal">RClass</code> C structure</p><div class="example-contents"><pre class="programlisting">typedef struct rb_classext_struct rb_classext_t;
struct RClass {
    struct RBasic basic;
    rb_classext_t *ptr;
    struct st_table *m_tbl;
    struct st_table *iv_index_tbl;
};</pre></div></div><p>Like the <code class="literal">RObject</code> definition we saw in <a class="xref" href="ch05.html#definitions_of_the_rbasic_and_robjec" title="Example 5-7. The definitions of the RBasic and RObject C structures">Example 5-7</a>, this structure definition—including all of the values shown in <a class="xref" href="ch05.html#how_ruby_actually_represents_a_class" title="Figure 5-21. How Ruby actually represents a class">Figure 5-21</a>—can be found in the <span class="emphasis"><em><code class="literal">include/ruby/ruby.h</code></em></span> file.</p><p>The <code class="literal">rb_classext_struct</code> structure definition, on the other hand, can be found in the <span class="emphasis"><em>internal.h</em></span> C header file, as shown in <a class="xref" href="ch05.html#definition_of_the_rbunderscoreclasse" title="Example 5-17. The definition of the rb_classext_struct C structure">Example 5-17</a>.</p><div class="example"><a id="definition_of_the_rbunderscoreclasse"/><p class="title">Example 5-17. The definition of the <code class="literal">rb_classext_struct</code> C structure</p><div class="example-contents"><pre class="programlisting">struct rb_classext_struct {
    VALUE super;
    struct st_table *iv_tbl;
    struct st_table *const_tbl;
    VALUE origin;
    VALUE refined_class;
    rb_alloc_func_t allocator;
};</pre></div></div><p>Again, you can see the values from <a class="xref" href="ch05.html#how_ruby_actually_represents_a_class" title="Figure 5-21. How Ruby actually represents a class">Figure 5-21</a>. Notice that the <code class="literal">st_table</code> C type appears four times in <a class="xref" href="ch05.html#definition_of_the_rclass_c_structure" title="Example 5-16. The definition of the RClass C structure">Example 5-16</a> and <a class="xref" href="ch05.html#definition_of_the_rbunderscoreclasse" title="Example 5-17. The definition of the rb_classext_struct C structure">Example 5-17</a>; this is Ruby’s hash table data structure. Internally, Ruby saves much of the information for each class using hash tables: the attribute names table, the method table, the class-level instance variable table, and the constants table.</p></div></div></div><div class="sect1" title="Experiment 5-2: Where Does Ruby Save Class Methods?"><div class="titlepage"><div><div><h1 class="title"><a id="experiment_5-2_where_does_ruby_save_clas"/>Experiment 5-2: Where Does Ruby Save Class Methods?</h1></div></div></div><p>We’ve seen how each <code class="literal">RClass</code> structure saves all methods defined in a certain class. In this example, Ruby stores information about the <code class="literal">first_name</code> method inside the <code class="literal">RClass</code> structure for <code class="literal">Mathematician</code> using the method table:</p><a id="pro_id00027"/><pre class="programlisting">class Mathematician
  def first_name
    @first_name
  end
end</pre><p>But what about class methods? It’s common in Ruby to save methods in a class directly, using the syntax shown in <a class="xref" href="ch05.html#defining_a_class_method_using_def_self" title="Example 5-18. Defining a class method using def self">Example 5-18</a>.</p><div class="example"><a id="defining_a_class_method_using_def_self"/><p class="title">Example 5-18. Defining a class method using <code class="literal">def self</code></p><div class="example-contents"><pre class="programlisting">class Mathematician
  def self.class_method
    puts "This is a class method."
  end
end</pre></div></div><p>Alternatively, you can use the syntax shown in <a class="xref" href="ch05.html#defining_a_class_method_using_class_less" title="Example 5-19. Defining a class method using class &lt;&lt; self">Example 5-19</a>.</p><div class="example"><a id="defining_a_class_method_using_class_less"/><p class="title">Example 5-19. Defining a class method using <code class="literal">class &lt;&lt; self</code></p><div class="example-contents"><pre class="programlisting">class Mathematician
  class &lt;&lt; self
    def class_method
      puts "This is a class method."
    end
  end
end</pre></div></div><p>Are they saved in the <code class="literal">RClass</code> structure along with the normal methods for each class, perhaps with a flag to indicate they are class methods and not normal methods? Or are they saved somewhere else? Let’s find out!</p><p>It’s easy to see where class methods are <span class="emphasis"><em>not</em></span> saved. They are obviously not saved in the <code class="literal">RClass</code> method table along with normal methods, because instances of <code class="literal">Mathematician</code> cannot call them, as demonstrated here:</p><a id="pro_id00028"/><pre class="programlisting">&gt; <span class="strong"><strong>obj = Mathematician.new</strong></span>
&gt; <span class="strong"><strong>obj.class_method</strong></span>
 =&gt; undefined method `class_method' for
#&lt; Mathematician:0x007fdd8384d1c8 (NoMethodError)</pre><p>Now, keeping in mind that <code class="literal">Mathematician</code> is also a Ruby object, recall the following definition:</p><div class="blockquote"><blockquote class="blockquote"><p>A Ruby class is a Ruby object that also contains method definitions, attribute names, a superclass pointer, and a constants table.</p></blockquote></div><p>We assume that Ruby should save methods for <code class="literal">Mathematician</code> just as it saves them for any object: in the method table for the object’s class. In other words, Ruby should get <code class="literal">Mathematician</code>’s class using the <code class="literal">klass</code> pointer and save the method in the method table in that <code class="literal">RClass</code> structure, as shown in <a class="xref" href="ch05.html#shouldnapostrophet_ruby_save_class_metho" title="Figure 5-22. Shouldn’t Ruby save class methods in the method table for the class’s class?">Figure 5-22</a>.</p><div class="figure"><a id="shouldnapostrophet_ruby_save_class_metho"/><div class="figure-contents"><div class="mediaobject"><a id="med_id00130"/><img alt="Shouldn’t Ruby save class methods in the method table for the class’s class?" src="httpatomoreillycomsourcenostarchimages1854083.png.jpg"/></div></div><p class="title">Figure 5-22. Shouldn’t Ruby save class methods in the method table for the class’s class?</p></div><p><a class="indexterm" id="iddle1212"/><a class="indexterm" id="iddle1587"/><a class="indexterm" id="iddle1625"/><a class="indexterm" id="iddle1647"/><a class="indexterm" id="iddle1749"/>But Ruby doesn’t actually do this, as you can discover by creating another class and trying to call the new method:</p><a id="pro_id00029"/><pre class="programlisting">&gt; <span class="strong"><strong>class AnotherClass; end</strong></span>
&gt; <span class="strong"><strong>AnotherClass.class_method</strong></span>
 =&gt; undefined method `class_method' for AnotherClass:Class (NoMethodError)</pre><p>If Ruby had added the class method to the method table in the <code class="literal">Class</code> class, all classes in your application would have the method. Obviously this isn’t what we intended by writing a class method, and thankfully Ruby doesn’t implement class methods this way.</p><p>Then where do the class methods go? For a clue, use the method <code class="literal">ObjectSpace.count_objects</code>,<code class="literal"/> shown in <a class="xref" href="ch05.html#using_objectspacedotcountunderscoreobjec" title="Example 5-20. Using ObjectSpace.count_objects with :T_CLASS">Example 5-20</a>:</p><div class="example"><a id="using_objectspacedotcountunderscoreobjec"/><p class="title">Example 5-20. Using <code class="literal">ObjectSpace.count_objects</code> with <code class="literal">:T_CLASS</code></p><div class="example-contents"><pre class="programlisting">    $ <span class="strong"><strong>irb</strong></span>
<img alt="" src="httpatomoreillycomsourcenostarchimages1853843.png.jpg"/> &gt; <span class="strong"><strong>ObjectSpace.count_objects[:T_CLASS]</strong></span>
<img alt="" src="httpatomoreillycomsourcenostarchimages1853845.png.jpg"/>  =&gt; 859
    &gt; class Mathematician; end
     =&gt; nil
    &gt; <span class="strong"><strong>ObjectSpace.count_objects[:T_CLASS]</strong></span>
<img alt="" src="httpatomoreillycomsourcenostarchimages1853847.png.jpg"/>  =&gt; 861</pre></div></div><p><code class="literal">ObjectSpace.count_objects</code> at <span class="inlinemediaobject"><a id="inline_id00153"/><img alt="" src="httpatomoreillycomsourcenostarchimages1853843.png.jpg"/></span> returns the number of objects of a given type that exist. In this test, I’m passing the :<code class="literal">T_CLASS</code> symbol to get the count of class objects that exist in my IRB session. Before I create <code class="literal">Mathematician</code>, there are 859 classes at <span class="inlinemediaobject"><a id="inline_id00154"/><img alt="" src="httpatomoreillycomsourcenostarchimages1853845.png.jpg"/></span>. After I declare <code class="literal">Mathematician</code>, there are 861 at <span class="inlinemediaobject"><a id="inline_id00155"/><img alt="" src="httpatomoreillycomsourcenostarchimages1853847.png.jpg"/></span>—two more. That’s odd. I declared one new class, but Ruby actually created two! What is the second one for and where is it?</p><p>It turns out that whenever you create a new class, internally Ruby creates two classes! The first class is your new class: Ruby creates a new <code class="literal">RClass</code> structure to represent your class, as described above. But internally Ruby also creates a second, hidden class called the <span class="emphasis"><em>metaclass</em></span>. Why? To save any class methods that you might later create for your new class. In fact, Ruby sets the metaclass to be the class of your new class: It sets the <code class="literal">klass</code> pointer of your new <code class="literal">RClass</code> structure to point to the metaclass.</p><p><a class="indexterm" id="iddle1147"/><a class="indexterm" id="iddle1993"/>Without writing C code, there’s no easy way to see the metaclass or the <code class="literal">klass</code> pointer value, but you can obtain the metaclass as a Ruby object like this:</p><a id="pro_id00030"/><pre class="programlisting">class Mathematician
end

p Mathematician
 =&gt; Mathematician

p Mathematician.singleton_class
 =&gt; #&lt;Class:Mathematician&gt;</pre><p>The first print statement displays the object’s class, while the second displays the object’s metaclass. The odd <code class="literal">#&lt;Class:Mathematician&gt;</code> syntax indicates that the second class is the metaclass for <code class="literal">Mathematician</code>. This is the second <code class="literal">RClass</code> structure that Ruby automatically created for me when I declared the <code class="literal">Mathematician</code> class. And this second <code class="literal">RClass</code> structure is where Ruby saves my class method, as shown in <a class="xref" href="ch05.html#objectcomma_its_classcomma_and_its_me" title="Figure 5-23. An object, its class, and its metaclass">Figure 5-23</a>.</p><div class="figure"><a id="objectcomma_its_classcomma_and_its_me"/><div class="figure-contents"><div class="mediaobject"><a id="med_id00131"/><img alt="An object, its class, and its metaclass" src="httpatomoreillycomsourcenostarchimages1854085.png.jpg"/></div></div><p class="title">Figure 5-23. An object, its class, and its metaclass</p></div><p>If we now display the methods for the metaclass, we’ll see all the methods of the <code class="literal">Class</code> class, along with the new class method for <code class="literal">Mathematician</code>:</p><a id="pro_id00031"/><pre class="programlisting">p obj.singleton_class.methods
 =&gt; [ ... :class_method, ...  ]</pre></div><div class="sect1" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="summary-id00017"/>Summary</h1></div></div></div><p>In this chapter we’ve seen how Ruby represents objects and classes internally: Ruby uses the <code class="literal">RObject</code> structure to represent instances of any custom classes you define in your code and of some classes predefined by Ruby itself. The <code class="literal">RObject</code> structure is remarkably simple, containing just a pointer to the object’s class and a table of instance variable values, along with a count of the variables. The simplicity of its structure leads us to a very simple definition of a Ruby object:</p><div class="blockquote"><blockquote class="blockquote"><p>Every Ruby object is the combination of a class pointer and an array of instance variables.</p></blockquote></div><p>This definition is powerful and useful because everything in Ruby is an object: Whenever you use a value in your Ruby program, regardless of what it is, remember that it will be an object and will therefore have a class pointer and instance variables.</p><p>We also saw that Ruby uses special C structures to represent instances of many commonly used, built-in Ruby classes called “generic” objects. For example, Ruby uses the <code class="literal">RString</code> structure to represent an instance of the <code class="literal">String</code> class, <code class="literal">RArray</code> for an instance of the <code class="literal">Array</code> class, or <code class="literal">RRegexp</code> for an instance of the <code class="literal">Regexp</code> class. While these structures are different, Ruby also saves a class pointer and an array of instance variables for each of these generic objects. Finally, we saw that Ruby saves some simple values, such as small integers and symbols, without using a C structure at all. Ruby saves these values right inside the <code class="literal">VALUE</code> pointers that otherwise would point to the structure holding the value.</p><p>While Ruby objects are simple, we learned in this chapter that Ruby classes aren’t quite so simple. The <code class="literal">RClass</code> structure working with the <code class="literal">rb_classext_struct</code> structure saves a large set of information. Learning this forced us to write a more complex definition for Ruby classes:</p><div class="blockquote"><blockquote class="blockquote"><p>A Ruby class is a Ruby object that also contains method definitions, attribute names, a superclass pointer, and a constants table.</p></blockquote></div><p>Looking inside <code class="literal">RClass</code> and <code class="literal">rb_classext_struct</code>, we saw that Ruby classes are also Ruby objects, which therefore also contain instance variables and a class pointer. We looked at the difference between a class’s instance variables and class variables and learned that Ruby saves both of these variable types in the same hash table. We discovered how classes also contain a series of hash tables that store their methods, the names of the object-level instance variables, and constants defined within the class. Finally, we saw how each Ruby class records its superclass using the <code class="literal">super</code> pointer.</p></div></div></body></html>