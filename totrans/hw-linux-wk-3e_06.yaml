- en: '6'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: How User Space Starts
  prefs: []
  type: TYPE_NORMAL
- en: '![](image_fi/book_art/chapterart.png)'
  prefs: []
  type: TYPE_IMG
- en: The point where the kernel starts init, its first user-space process, is significant—not
    just because the memory and CPU are finally ready for normal system operation,
    but because that’s where you can see how the rest of the system builds up as a
    whole. Prior to this point, the kernel follows a well-controlled path of execution
    defined by a relatively small number of software developers. User space is far
    more modular and customizable, and it’s also quite easy to see what goes into
    the user-space startup and operation. If you’re feeling a little adventurous,
    you can use this to an advantage, because understanding and changing the user-space
    startup requires no low-level programming.
  prefs: []
  type: TYPE_NORMAL
- en: 'User space starts in roughly this order:'
  prefs: []
  type: TYPE_NORMAL
- en: init
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Essential low-level services, such as udevd and syslogd
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Network configuration
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Mid- and high-level services (cron, printing, and so on)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Login prompts, GUIs, and high-level applications, such as web servers
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 6.1 Introduction to init
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*init* is a user-space program like any other program on the Linux system,
    and you’ll find it in */sbin* along with many of the other system binaries. Its
    main purpose is to start and stop the essential service processes on the system.'
  prefs: []
  type: TYPE_NORMAL
- en: On all current releases of major Linux distributions, the standard implementation
    of init is systemd. This chapter focuses on how systemd works and how to interact
    with it.
  prefs: []
  type: TYPE_NORMAL
- en: There are two other varieties of init that you may encounter on older systems.
    System V init is a traditional sequenced init (Sys V, usually pronounced “sys-five,”
    with origins in Unix System V), found on Red Hat Enterprise Linux (RHEL) prior
    to version 7.0 and Debian 8\. Upstart is the init on Ubuntu distributions prior
    to version 15.04.
  prefs: []
  type: TYPE_NORMAL
- en: Other versions of init exist, especially on embedded platforms. For example,
    Android has its own init, and a version called *runit* is popular on lightweight
    systems. The BSDs also have their own version of init, but you’re unlikely to
    see them on a contemporary Linux machine. (Some distributions have also modified
    the System V init configuration to resemble the BSD style.)
  prefs: []
  type: TYPE_NORMAL
- en: Different implementations of init have been developed to address several shortcomings
    in System V init. To understand the problems, consider the inner workings of a
    traditional init. It’s basically a series of scripts that init runs, in sequence,
    one at a time. Each script usually starts one service or configures an individual
    piece of the system. In most cases, it’s relatively easy to resolve dependencies,
    plus there’s a lot of flexibility to accommodate unusual startup requirements
    by modifying scripts.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, this scheme suffers from some significant limitations. These can be
    grouped into “performance problems” and “system management hassles.” The most
    important of these are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Performance suffers because two parts of the boot sequence cannot normally run
    at once.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Managing a running system can be difficult. Startup scripts are expected to
    start service daemons. To find the PID of a service daemon, you need to use `ps`,
    some other mechanism specific to the service, or a semistandardized system of
    recording the PID, such as */var/run/myservice.pid*.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Startup scripts tend to include a lot of standard “boilerplate” code, sometimes
    making it difficult to read and understand what they do.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There is little notion of on-demand services and configuration. Most services
    start at boot time; system configuration is largely set at that time as well.
    At one time, the traditional inetd daemon was able to handle on-demand network
    services, but it has largely fallen out of use.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Contemporary init systems have dealt with these problems by changing how services
    start, how they are supervised, and how the dependencies are configured. You’ll
    soon see how this works in systemd, but first, you should make sure that you’re
    running it.
  prefs: []
  type: TYPE_NORMAL
- en: 6.2 Identifying Your init
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Determining your system’s version of init usually isn’t difficult. Viewing
    the init(1) manual page normally tells you right away, but if you’re not sure,
    check your system as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: If your system has */usr/lib/systemd* and */etc/systemd* directories, you have
    systemd.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you have an */etc/init* directory that contains several *.conf* files, you’re
    probably running Upstart (unless you’re running Debian 7 or older, in which case
    you probably have System V init). We won’t cover Upstart in this book because
    it has been widely supplanted by systemd.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If neither of the above is true, but you have an */etc/inittab* file, you’re
    probably running System V init. Go to Section 6.5.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 6.3 systemd
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The systemd init is one of the newest init implementations on Linux. In addition
    to handling the regular boot process, systemd aims to incorporate the functionality
    of a number of standard Unix services, such as cron and inetd. It takes some inspiration
    from Apple’s launchd.
  prefs: []
  type: TYPE_NORMAL
- en: Where systemd really stands out from its predecessors is its advanced service
    management capabilities. Unlike a traditional init, systemd can track individual
    service daemons after they start, and group together multiple processes associated
    with a service, giving you more power and insight into exactly what is running
    on the system.
  prefs: []
  type: TYPE_NORMAL
- en: systemd is goal-oriented. At the top level, you can think of defining a goal,
    called a *unit*, for some system task. A unit can contain instructions for common
    startup tasks, such as starting a daemon, and it also has dependencies, which
    are other units. When starting (or *activating*) a unit, systemd attempts to activate
    its dependencies and then moves on to the details of the unit.
  prefs: []
  type: TYPE_NORMAL
- en: When starting services, systemd does not follow a rigid sequence; instead, it
    activates units whenever they are ready. After boot, systemd can react to system
    events (such as the uevents outlined in Chapter 3) by activating additional units.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s start by looking at a top-level view of units, activation, and the initial
    boot process. Then you’ll be ready to see the specifics of unit configuration
    and the many varieties of unit dependencies. Along the way, you’ll get a grip
    on how to view and control a running system.
  prefs: []
  type: TYPE_NORMAL
- en: 6.3.1 Units and Unit Types
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: One way that systemd is more ambitious than previous versions of init is that
    it doesn’t just operate processes and services; it can also manage filesystem
    mounts, monitor network connection requests, run timers, and more. Each capability
    is called a *unit type*, and each specific function (such as a service) is called
    a *unit*. When you turn on a unit, you *activate* it. Each unit has its own configuration
    file; we’ll explore those files in Section 6.3.3.
  prefs: []
  type: TYPE_NORMAL
- en: 'These are the most significant unit types that perform the boot-time tasks
    on a typical Linux system:'
  prefs: []
  type: TYPE_NORMAL
- en: Service units Control the service daemons found on a Unix system.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Target units Control other units, usually by grouping them.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Socket units Represent incoming network connection request locations.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Mount units Represent the attachment of filesystems to the system.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Of these, service and target units are the most common and the easiest to understand.
    Let’s take a look at how they fit together when you boot a system.
  prefs: []
  type: TYPE_NORMAL
- en: 6.3.2 Booting and Unit Dependency Graphs
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When you boot a system, you’re activating a default unit, normally a target
    unit called *default.target* that groups together a number of service and mount
    units as dependencies. As a result, it’s somewhat easy to get a partial picture
    of what’s going to happen when you boot. You might expect the unit dependencies
    to form a tree—with one unit at the top, branching into several units below for
    later stages of the boot process—but they actually form a graph. A unit that comes
    late in the boot process can depend on several previous units, making earlier
    branches of a dependency tree join back together. You can even create a dependency
    graph with the `systemd-analyze dot` command. The entire graph is quite large
    on a typical system (requiring significant computing power to render), and it’s
    hard to read, but there are ways to filter units and zero in on individual portions.
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 6-1](#figure6-1) shows a very small part of the dependency graph for
    the *default.target* unit found on a typical system. When you activate that unit,
    all of the units below it also activate.'
  prefs: []
  type: TYPE_NORMAL
- en: '![f06001_new](image_fi/500402c06/f06001_new.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6-1: Unit dependency graph'
  prefs: []
  type: TYPE_NORMAL
- en: This figure is a greatly simplified view. On your own system, you won’t find
    it feasible to sketch out the dependencies just by looking at the unit configuration
    file at the top and working your way down. We’ll take a closer look at how dependencies
    work in Section 6.3.6.
  prefs: []
  type: TYPE_NORMAL
- en: 6.3.3 systemd Configuration
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The systemd configuration files are spread among many directories across the
    system, so you might need to do a little hunting when you’re looking for a particular
    file. There are two main directories for systemd configuration: the *system unit*
    directory (global configuration; usually */lib/systemd/system* or */usr/lib/systemd/system*)
    and the *system configuration* directory (local definitions; usually */etc/systemd/system*).'
  prefs: []
  type: TYPE_NORMAL
- en: 'To prevent confusion, stick to this rule: avoid making changes to the system
    unit directory, because your distribution will maintain it for you. Make your
    local changes to the system configuration directory. This general rule also applies
    systemwide. When given the choice between modifying something in */usr* and */etc*,
    always change */etc*.'
  prefs: []
  type: TYPE_NORMAL
- en: 'You can check the current systemd configuration search path (including precedence)
    with this command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'To see the system unit and configuration directories on your system, use the
    following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Unit Files
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The format for unit files is derived from the XDG Desktop Entry specification
    (used for *.desktop* files, which are very similar to *.ini* files on Microsoft
    systems), with section names in square brackets (`[]`) and variable and value
    assignments (options) in each section.
  prefs: []
  type: TYPE_NORMAL
- en: 'As an example, consider the *dbus-daemon.service* unit file for the desktop
    bus daemon:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: There are two sections, `[Unit]` and `[Service]`. The `[Unit]` section gives
    some details about the unit and contains description and dependency information.
    In particular, this unit requires the *dbus.socket* unit as a dependency.
  prefs: []
  type: TYPE_NORMAL
- en: In a service unit such as this, you’ll find the details about the service in
    the `[Service]` section, including how to prepare, start, and reload the service.
    You’ll find a complete listing in the systemd.service(5) and systemd.exec(5) manual
    pages, as well as in the discussion of process tracking in Section 6.3.5.
  prefs: []
  type: TYPE_NORMAL
- en: Many other unit configuration files are similarly straightforward. For example,
    the service unit file *sshd.service* enables remote secure shell logins by starting
    sshd.
  prefs: []
  type: TYPE_NORMAL
- en: Variables
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You’ll often find variables inside unit files. Here’s a section from a different
    unit file, this one for the secure shell that you’ll learn about in Chapter 10:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Everything that starts with a dollar sign (`$`) is a variable. Although these
    variables have the same syntax, their origins are different. The `$OPTIONS` and
    `$CRYPTO_POLICY` options, which you can pass to sshd upon unit activation, are
    defined in the file specified by the `EnvironmentFile` setting. In this particular
    case, you can look at */etc/sysconfig/sshd* to determine if the variables are
    set and, if so, what their values are.
  prefs: []
  type: TYPE_NORMAL
- en: In comparison, `$MAINPID` contains the ID of the *tracked process* of the service
    (see Section 6.3.5). Upon unit activation, systemd records and stores this PID
    so that you can use it to manipulate a service-specific process later on. The
    *sshd.service* unit file uses `$MAINPID` to send a hangup (HUP) signal to sshd
    when you want to reload the configuration (this is a very common technique for
    dealing with reloads and restarting Unix daemons).
  prefs: []
  type: TYPE_NORMAL
- en: Specifiers
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: A *specifier* is a variable-like feature often found in unit files. Specifiers
    start with a percent sign (`%`). For example, the `%n` specifier is the current
    unit name, and the `%H` specifier is the current hostname.
  prefs: []
  type: TYPE_NORMAL
- en: You can also use specifiers to create multiple copies of a unit from a single
    unit file. One example is the set of `getty` processes that control the login
    prompts on virtual consoles, such as *tty1* and *tty2*. To use this feature, add
    an @ symbol to the end of the unit name, before the dot in the unit filename.
  prefs: []
  type: TYPE_NORMAL
- en: For example, the `getty` unit filename is *getty@.service* in most distributions,
    allowing for the dynamic creation of units, such as *getty@tty1* and *getty@tty2*.
    Anything after the @ is called the *instance*. When you look at one of these unit
    files, you may also see a `%I` or `%i` specifier. When activating a service from
    a unit file with instances, systemd replaces the `%I` or `%i` specifier with the
    instance to create the new service name.
  prefs: []
  type: TYPE_NORMAL
- en: 6.3.4 systemd Operation
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You’ll interact with systemd primarily through the `systemctl` command, which
    allows you to activate and deactivate services, list status, reload the configuration,
    and much more.
  prefs: []
  type: TYPE_NORMAL
- en: The most essential commands help you to obtain unit information. For example,
    to view a list of active units on your system, issue a `list-units` command. (This
    is the default command for `systemctl`, so technically you don’t need the `list-units`
    argument.)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'The output format is typical of a Unix information-listing command. For example,
    the header and the line for *-.mount* (the root filesystem) looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: By default, `systemctl list-units` produces a lot of output, because a typical
    system has numerous active units, but it’s still an abridged form because `systemctl`
    truncates any really large unit names. To see the full names of the units, use
    the `--full` option, and to see all units (not just those that are active), use
    the `--all` option.
  prefs: []
  type: TYPE_NORMAL
- en: 'A particularly useful `systemctl` operation is getting the status of a specific
    unit. For example, here’s a typical `status` command and some of its output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: A number of log messages may also follow this output. If you’re used to a traditional
    init system, you might be surprised by the amount of useful information available
    from this one command. You get not only the state of the unit but also the processes
    associated with the service, when the unit started, and a number of log messages,
    if available.
  prefs: []
  type: TYPE_NORMAL
- en: The output for other unit types includes similar useful information; for example,
    the output from mount units includes when the mount happened, the exact command
    line used for it, and its exit status.
  prefs: []
  type: TYPE_NORMAL
- en: One interesting piece of the output is the control group (cgroup) name. In the
    preceding example, the control group is `/system.slice/sshd.service`, and the
    processes in the cgroup are shown below it. However, you may also see control
    groups named starting with `systemd:/system` if the processes of a unit (for example,
    a mount unit) have already terminated. You can view systemd-related cgroups without
    the rest of the unit status with the `systemd-cgls` command. You’ll learn more
    about how systemd uses cgroups in Section 6.3.5, and how cgroups work in Section
    8.6.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `status` command also displays only the most recent diagnostic log messages
    for the unit. You can view all of a unit’s messages like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: You’ll learn much more about `journalctl` in Chapter 7.
  prefs: []
  type: TYPE_NORMAL
- en: How Jobs Relate to Starting, Stopping, and Reloading Units
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'To activate, deactivate, and restart units, you use the commands `systemctl
    start`, `systemctl stop`, and `systemctl restart`. However, if you’ve changed
    a unit configuration file, you can tell systemd to reload the file in one of two
    ways:'
  prefs: []
  type: TYPE_NORMAL
- en: '`systemctl reload` `unit` Reloads just the configuration for `unit`.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`systemctl daemon-reload` Reloads all unit configurations.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Requests to activate, reactivate, and restart units are called *jobs* in systemd,
    and they are essentially unit state changes. You can check the current jobs on
    a system with:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'If a system has been up for some time, you can reasonably expect there to be
    no active jobs because all activations required to start the system should be
    complete. However, at boot time, you can sometimes log in fast enough to see jobs
    for units that start very slowly. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: In this case, job 76, the *sendmail.service* unit startup, is taking a really
    long time. The other listed jobs are in a waiting state, most likely because they’re
    all waiting for job 76\. When *sendmail.service* finishes starting and is fully
    active, job 76 will complete, the rest of the jobs will also complete, and the
    job list will be empty.
  prefs: []
  type: TYPE_NORMAL
- en: See Section 6.6 to learn how to shut down and reboot the system.
  prefs: []
  type: TYPE_NORMAL
- en: Adding Units to systemd
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Adding units to systemd is primarily a matter of creating, then activating and
    possibly enabling, unit files. You should normally put your own unit files in
    the system configuration directory (*/etc/systemd/system*)so that you won’t confuse
    them with anything that came with your distribution and so that the distribution
    won’t overwrite them when you upgrade.
  prefs: []
  type: TYPE_NORMAL
- en: 'Because it’s easy to create target units that don’t actually do anything or
    interfere with your system, give it a try. To create two targets, one with a dependency
    on the other, follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a unit file named *test1.target* in */etc/systemd/system*:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create a *test2.target* file with a dependency on *test1.target*:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The `Wants` keyword here defines a dependency that causes *test1.target* to
    activate when you activate *test2.target*. Activate the *test2.target* unit to
    see it in action:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Verify that both units are active:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'If your unit file has an `[Install]` section, you need to “enable” the unit
    before activating it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `[Install]` section is another way to create a dependency. We’ll look at
    it (and dependencies as a whole) in more detail in Section 6.3.6.
  prefs: []
  type: TYPE_NORMAL
- en: Removing Units from systemd
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'To remove a unit, follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Deactivate the unit if necessary:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'If the unit has an `[Install]` section, disable the unit to remove any symbolic
    links created by the dependency system:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: You can then remove the unit file if you like.
  prefs: []
  type: TYPE_NORMAL
- en: 6.3.5 systemd Process Tracking and Synchronization
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: systemd wants a reasonable amount of information and control over every process
    it starts. This has been difficult historically. A service can start in different
    ways; it could fork new instances of itself or even daemonize and detach itself
    from the original process. There’s also no telling how many subprocesses the server
    can spawn.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to manage activated units easily, systemd uses the previously mentioned
    cgroups, a Linux kernel feature that allows for finer tracking of a process hierarchy.
    The use of cgroups also helps minimize the work that a package developer or administrator
    needs to do in order to create a working unit file. In systemd, you don’t have
    to worry about accounting for every possible startup behavior; all you need to
    know is whether a service startup process forks. Use the `Type` option in your
    service unit file to indicate startup behavior. There are two basic startup styles:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Type=simple` The service process doesn’t fork and terminate; it remains the
    main service process.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`Type=forking` The service forks, and systemd expects the original service
    process to terminate. Upon this termination, systemd assumes the service is ready.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The `Type=simple` option doesn’t account for the fact that a service may take
    some time to initiate, and as a result systemd doesn’t know when to start any
    dependent units that absolutely require such a service to be ready. One way to
    deal with this is to use delayed startup (see Section 6.3.7). However, some `Type`
    startup styles can indicate that the service itself will notify systemd when it’s
    ready:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Type=notify` When ready, the service sends a notification specific to systemd
    with a special function call.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`Type=dbus` When ready, the service registers itself on the D-Bus (Desktop
    Bus).'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Another service startup style is specified with `Type=oneshot`; here the service
    process terminates completely with no child processes after starting. It’s like
    `Type=simple`, except that systemd does not consider the service to be started
    until the service process terminates. Any strict dependencies (which you’ll see
    soon) will not start until that termination. A service using `Type=oneshot` also
    gets a default `RemainAfterExit=yes` directive so that systemd regards a service
    as active even after its processes terminate.
  prefs: []
  type: TYPE_NORMAL
- en: A final option is `Type=idle`. This works like the `simple` style, but it instructs
    systemd not to start the service until all active jobs finish. The idea here is
    just to delay a service start until other services have started to keep services
    from stepping on one another’s output. Remember, once a service has started, the
    systemd job that started it terminates, so waiting for all other jobs to finish
    ensures that nothing else is starting.
  prefs: []
  type: TYPE_NORMAL
- en: If you’re interested in how cgroups work, we’ll explore them in more detail
    in Section 8.6.
  prefs: []
  type: TYPE_NORMAL
- en: 6.3.6 systemd Dependencies
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A flexible system for boot-time and operational dependencies requires some degree
    of complexity, because overly strict rules can cause poor system performance and
    instability. For example, say you want to display a login prompt after starting
    a database server, so you define a strict dependency from the login prompt to
    the database server. This means if the database server fails, the login prompt
    will also fail, and you won’t even be able to log in to your machine to fix the
    issue!
  prefs: []
  type: TYPE_NORMAL
- en: Unix boot-time tasks are fairly fault tolerant and can often fail without causing
    serious problems for standard services. For example, if you removed a system’s
    data disk but left its */etc/fstab* entry (or mount unit in systemd), the boot-time
    filesystem mount would fail. Though this failure might affect application servers
    (such as web servers), it typically wouldn’t affect standard system operation.
  prefs: []
  type: TYPE_NORMAL
- en: 'To accommodate the need for flexibility and fault tolerance, systemd offers
    several dependency types and styles. Let’s first look at the basic types, labeled
    by their keyword syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Requires  ` Strict dependencies. When activating a unit with a `Requires`
    dependency unit, systemd attempts to activate the dependency unit. If the dependency
    unit fails, systemd also deactivates the dependent unit.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`Wants`  Dependencies for activation only. Upon activating a unit, systemd
    activates the unit’s `Wants` dependencies, but it doesn’t care if those dependencies
    fail.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`Requisite` Units that must already be active. Before activating a unit with
    a `Requisite` dependency, systemd first checks the status of the dependency. If
    the dependency hasn’t been activated, systemd fails on activation of the unit
    with the dependency.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`Conflicts`  Negative dependencies. When activating a unit with a `Conflict`
    dependency, systemd automatically deactivates the opposing dependency if it’s
    active. Simultaneous activation of conflicting units fails.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `Wants` dependency type is especially significant because it doesn’t propagate
    failures to other units. The systemd.service(5) manual page states that this is
    how you should specify dependencies if possible, and it’s easy to see why. This
    behavior produces a much more robust system, giving you the benefit of a traditional
    init, where the failure of an earlier startup component doesn’t necessarily prohibit
    later components from starting.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can view a unit’s dependencies with the `systemctl` command, as long as
    you specify a type of dependency, such as `Wants` or `Requires`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Ordering
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: So far, the dependency syntax you’ve seen hasn’t explicitly specified order.
    For example, activating most service units with `Requires` or `Wants` dependencies
    causes these units to start at the same time. This is optimal, because you want
    to start as many services as possible as quickly as possible to reduce boot time.
    However, there are situations when one unit must start after another. For instance,
    in the system that [Figure 6-1](#figure6-1) is based on, the *default.target*
    unit is set to start after *multi-user.target* (this order distinction is not
    shown in the figure).
  prefs: []
  type: TYPE_NORMAL
- en: 'To activate units in a particular order, use the following dependency modifiers:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Before`  The current unit will activate before the listed unit(s). For example,
    if `Before=bar.target` appears in *foo.target*, systemd activates *foo.target*
    before *bar.target*.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`After`  The current unit activates after the listed unit(s).'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When you use ordering, systemd waits until a unit has an active status before
    activating its dependent units.
  prefs: []
  type: TYPE_NORMAL
- en: Default and Implicit Dependencies
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: As you explore dependencies (especially with `systemd-analyze`), you might start
    to notice that some units acquire dependencies that aren’t explicitly stated in
    unit files or other visible mechanisms. You’re most likely to encounter this in
    target units with `Wants` dependencies—you’ll find that systemd adds an `After`
    modifier alongside any unit listed as a `Wants` dependency. These additional dependencies
    are internal to systemd, calculated at boot time, and not stored in configuration
    files.
  prefs: []
  type: TYPE_NORMAL
- en: The added `After` modifier is called a *default dependency*, an automatic addition
    to the unit configuration meant to avoid common mistakes and keep unit files small.
    These dependencies vary according to the type of unit. For example, systemd doesn’t
    add the same default dependencies for target units as it does for service units.
    These differences are listed in the DEFAULT DEPENDENCIES sections of the unit
    configuration manual pages, such as systemd.service(5) and systemd.target(5).
  prefs: []
  type: TYPE_NORMAL
- en: You can disable a default dependency in a unit by adding `DefaultDependencies=no`
    to its configuration file.
  prefs: []
  type: TYPE_NORMAL
- en: Conditional Dependencies
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You can use several *conditional dependency* parameters to test various operating
    system states rather than systemd units. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '`ConditionPathExists=p`  True if the (file) path *p* exists in the system.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`ConditionPathIsDirectory=p`  True if *p* is a directory.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`ConditionFileNotEmpty=p`  True if *p* is a file and it’s not zero-length.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If a conditional dependency in a unit is false when systemd tries to activate
    the unit, the unit does not activate, although this applies only to the unit in
    which it appears. That is, if you activate a unit that has a conditional dependency
    and some unit dependencies, systemd attempts to activate those unit dependencies
    regardless of whether the condition is true or false.
  prefs: []
  type: TYPE_NORMAL
- en: Other dependencies are primarily variations on the preceding ones. For example,
    the `RequiresOverridable` dependency is just like `Requires` when running normally,
    but it acts like a `Wants` dependency if a unit is manually activated. For a full
    list, see the systemd.unit(5) manual page.
  prefs: []
  type: TYPE_NORMAL
- en: The [Install] Section and Enabling Units
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: So far, we’ve been looking at how to define dependencies in a dependent unit’s
    configuration file. It’s also possible to do this “in reverse”—that is, by specifying
    the dependent unit in a dependency’s unit file. You can do this by adding a `WantedBy`
    or `RequiredBy` parameter in the `[Install]` section. This mechanism allows you
    to alter when a unit should start without modifying additional configuration files
    (for example, when you’d rather not edit a system unit file).
  prefs: []
  type: TYPE_NORMAL
- en: 'To see how this works, consider the example units back in Section 6.3.4. We
    had two units, *test1.target* and *test2.target*, with *test2.target* having a
    `Wants` dependency on *test1.target*. We can change them so that *test1.target*
    looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'And *test2.target* is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Because you now have a unit with an `[Install]` section, you need to *enable*
    the unit with `systemctl` before you can start it. Here’s how that works with
    *test1.target*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Notice the output here—the effect of enabling a unit is to create a symbolic
    link in a *.wants* subdirectory corresponding to the dependent unit (*test2.target*
    in this case). You can now start both units at the same time with `systemctl start
    test2.target` because the dependency is in place.
  prefs: []
  type: TYPE_NORMAL
- en: 'To disable the unit (and remove the symbolic link), use `systemctl` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: The two units in this example also give you a chance to experiment with different
    startup scenarios. For example, see what happens when you try to start only *test1.target*,
    or when you try to start *test2.target* without enabling *test1.target*. Or, try
    changing `WantedBy` to `RequiredBy`. (Remember, you can check the status of a
    unit with `systemctl status`.)
  prefs: []
  type: TYPE_NORMAL
- en: During normal operation, systemd ignores the `[Install]` section in a unit but
    notes its presence and, by default, considers the unit to be disabled. Enabling
    a unit survives reboots.
  prefs: []
  type: TYPE_NORMAL
- en: The `[Install]` section is usually responsible for the *.wants* and *.requires*
    directories in the system configuration directory (*/etc/systemd/system*). However,
    the unit configuration directory (*[/usr]/lib/systemd/system*) also contains *.wants*
    directories, and you may also add links that don’t correspond to `[Install]` sections
    in the unit files. These manual additions are a simple way to add a dependency
    without modifying a unit file that may be overwritten in the future (by a software
    upgrade, for instance), but they’re not particularly encouraged because a manual
    addition is difficult to trace.
  prefs: []
  type: TYPE_NORMAL
- en: 6.3.7 systemd On-Demand and Resource-Parallelized Startup
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'One of systemd’s features is the ability to delay a unit startup until it is
    absolutely needed. The setup typically works like this:'
  prefs: []
  type: TYPE_NORMAL
- en: You create a systemd unit (call it Unit A) for the system service you’d like
    to provide.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You identify a system resource, such as a network port/socket, file, or device,
    that Unit A uses to offer its services.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You create another systemd unit, Unit R, to represent that resource. These units
    are classified into types, such as socket units, path units, and device units.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You define the relationship between Unit A and Unit R. Normally, this is implicit
    based on the units’ names, but it can also be explicit, as we’ll see shortly.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Once in place, the operation proceeds as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Upon activation of Unit R, systemd monitors the resource.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When anything tries to access the resource, systemd blocks the resource, and
    the input to the resource is buffered.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: systemd activates Unit A.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When ready, the service from Unit A takes control of the resource, reads the
    buffered input, and runs normally.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'There are a few concerns here:'
  prefs: []
  type: TYPE_NORMAL
- en: You must make sure that your resource unit covers every resource that the service
    provides. This normally isn’t a problem, because most services have just one point
    of access.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You need to make sure your resource unit is tied to the service unit that it
    represents. This can be implicit or explicit, and in some cases, many options
    represent different ways for systemd to perform the handoff to the service unit.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Not all servers know how to interface with the resource units systemd can provide.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you already know what traditional utilities like inetd, xinetd, and automount
    do, you’ll see many similarities. Indeed, the concept is nothing new; systemd
    even includes support for automount units.
  prefs: []
  type: TYPE_NORMAL
- en: An Example Socket Unit and Service
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Let’s look at an example, a simple network echo service. This is somewhat advanced
    material, and you might not fully understand it until you’ve read the discussion
    of TCP, ports, and listening in Chapter 9 and sockets in Chapter 10, but you should
    be able to get the basic idea.
  prefs: []
  type: TYPE_NORMAL
- en: 'The idea of an echo service is to repeat anything that a network client sends
    after connecting; ours will listen on TCP port 22222\. We’ll start building it
    with a *socket unit* to represent the port, as shown in the following *echo.socket*
    unit file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Note that there’s no mention of the service unit that this socket supports inside
    the unit file. So, what is that corresponding service unit file?
  prefs: []
  type: TYPE_NORMAL
- en: 'Its name is *echo@.service*. The link is established by naming convention;
    if a service unit file has the same prefix as a *.socket* file (in this case,
    *echo*), systemd knows to activate that service unit when there’s activity on
    the socket unit. In this case, systemd creates an instance of *echo@.service*
    when there’s activity on *echo.socket*. Here’s the *echo@.service* unit file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'To get this example unit running, you need to start the *echo.socket* unit:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Now you can test the service by connecting to your local TCP port 22222 with
    a utility such as `telnet`. The service repeats what you enter; here’s an example
    interaction:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'When you’re bored with this and want to get back to your shell, press ctrl-]
    on a line by itself and then press ctrl-D. To stop the service, stop the socket
    unit like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Instances and Handoff
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Because the *echo@.service* unit supports multiple simultaneous instances, there’s
    an *@* in the name (recall that the *@* specifier signifies parameterization).
    Why would you want multiple instances? Say you have more than one network client
    connecting to the service at the same time, and you want each connection to have
    its own instance. In this case, the service unit *must* support multiple instances
    because we included the `Accept=true` option in *echo.socket*. That option instructs
    systemd not only to listen on the port, but also to accept incoming connections
    on behalf of the service unit and pass it to them, creating a separate instance
    for each connection. Each instance reads data from the connection as standard
    input, but it doesn’t necessarily need to know that the data is coming from a
    network connection.
  prefs: []
  type: TYPE_NORMAL
- en: If a service unit can do the work of accepting a connection, don’t put an *@*
    in its unit filename, and don’t put `Accept=true` in the socket unit. In this
    case, the service unit takes complete control of the socket from systemd, which
    in turn does not attempt to listen on the network port again until the service
    unit finishes.
  prefs: []
  type: TYPE_NORMAL
- en: The many different resources and options for handoff to service units make it
    difficult to provide a categorical summary. Not only that, but the documentation
    for the options is spread out over several manual pages. For the resource-oriented
    units, check systemd.socket(5), systemd.path(5), and systemd.device(5). One document
    that’s often overlooked for service units is systemd.exec(5), which contains information
    about how the service unit can expect to receive a resource upon activation.
  prefs: []
  type: TYPE_NORMAL
- en: Boot Optimization with Auxiliary Units
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: An overall goal of systemd is to simplify dependency order and speed up boot
    time. Resource units such as socket units provide a way to do this that’s similar
    to on-demand startup. We’ll still have a service unit and an auxiliary unit representing
    the service unit’s offered resource, except that in this case, systemd starts
    the service unit as soon as it activates the auxiliary unit rather than waiting
    around for a request.
  prefs: []
  type: TYPE_NORMAL
- en: The reason for this scheme is that essential boot-time service units such as
    *systemd-journald.service* take some time to start, and many other units depend
    on them. However, systemd can offer the essential resource of a unit (such as
    a socket unit) very quickly, and then it can immediately activate not only the
    essential unit but also any units that depend on it. Once the essential unit is
    ready, it takes control of the resource.
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 6-2](#figure6-2) shows how this might work in a traditional sequential
    system. In this boot timeline, Service E provides an essential Resource R. Services
    A, B, and C depend on this resource (but not on each other) and must wait until
    Service E has started. Because the system will not start a new service until it’s
    done starting the preceding one, it takes quite a long time to get around to starting
    Service C.'
  prefs: []
  type: TYPE_NORMAL
- en: '![f06002](image_fi/500402c06/f06002.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6-2: Sequential boot timeline with a resource dependency'
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 6-3](#figure6-3) shows a possible equivalent systemd boot configuration.
    The services are represented by Units A, B, C, and E, with a new Unit R representing
    the resource that Unit E provides. Because systemd can provide an interface for
    Unit R while Unit E starts, Units A, B, C, and E can all be started at the same
    time. When ready, Unit E takes over for Unit R. An interesting point here is that
    Unit A, B, or C may not need to access the resource that Unit R provides before
    finishing startup. What we’re doing is providing them with the *option* to start
    accessing the resource as soon as possible.'
  prefs: []
  type: TYPE_NORMAL
- en: '![f06003](image_fi/500402c06/f06003.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6-3: systemd boot timeline with a resource unit'
  prefs: []
  type: TYPE_NORMAL
- en: The takeaway is that, although you’re not creating an on-demand unit startup
    in this case, you’re using the same features that make on-demand startup possible.
    For common real-world examples, see the journald and D-Bus configuration units
    on a machine running systemd; they’re very likely to be parallelized in this way.
  prefs: []
  type: TYPE_NORMAL
- en: 6.3.8 systemd Auxiliary Components
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As systemd has grown in popularity, it has grown to include support for a few
    tasks not related to startup and service management, both directly and through
    auxiliary compatibility layers. You may notice the numerous programs in */lib/systemd*;
    these are the executables related to those functions.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are a few specific system services:'
  prefs: []
  type: TYPE_NORMAL
- en: udevd You learned about this in Chapter 3; it’s part of systemd.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: journald A logging service that handles a few different logging mechanisms,
    including the traditional Unix `syslog` service. You’ll read more about this in
    Chapter 7.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: resolved A name service caching daemon for DNS; you’ll learn about that in Chapter
    9.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: All of the executables for these services are prefixed with `systemd-`. For
    example, the systemd-integrated udevd is called `systemd-udevd`.
  prefs: []
  type: TYPE_NORMAL
- en: If you dig deeper, you’ll find that some of these programs are relatively simple
    wrappers. Their function is to run standard system utilities and notify systemd
    of the results. One example is `systemd-fsck`.
  prefs: []
  type: TYPE_NORMAL
- en: If you see a program in */lib/systemd* that you can’t identify, check for a
    manual page. There’s a good chance that it will describe not only the utility
    but also the type of unit it’s meant to augment.
  prefs: []
  type: TYPE_NORMAL
- en: 6.4 System V Runlevels
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now that you’ve learned about systemd and how it works, let’s shift gears and
    look at some aspects of the traditional System V init. At any given time on a
    Linux system, a certain base set of processes (such as crond and udevd) is running.
    In System V init, this state of the machine is called its *runlevel*, which is
    denoted by a number from 0 through 6\. A system spends most of its time in a single
    runlevel, but when you shut down the machine, init switches to a different runlevel
    in order to terminate the system services in an orderly fashion and tell the kernel
    to stop.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can check your system’s runlevel with the `who -r` command like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: This output tells us that the current runlevel is 5, as well as the date and
    time that the runlevel was established.
  prefs: []
  type: TYPE_NORMAL
- en: Runlevels serve various purposes, but the most common one is to distinguish
    between system startup, shutdown, single-user mode, and console mode states. For
    example, most systems traditionally used runlevels 2 through 4 for the text console;
    a runlevel of 5 means that the system starts a GUI login.
  prefs: []
  type: TYPE_NORMAL
- en: But runlevels are becoming a thing of the past. Even though systemd supports
    them, it considers runlevels obsolete as end states for the system, preferring
    target units instead. To systemd, runlevels exist primarily to start services
    that support only the System V init scripts.
  prefs: []
  type: TYPE_NORMAL
- en: 6.5 System V init
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The System V init implementation is among the oldest used on Linux; its core
    idea is to support an orderly bootup to different runlevels with a carefully constructed
    startup sequence. System V init is now uncommon on most server and desktop installations,
    but you may encounter it in versions of RHEL prior to version 7.0, as well as
    in embedded Linux environments, such as routers and phones. In addition, some
    older packages may only provide startup scripts designed for System V init; systemd
    can handle those with a compatibility mode that we’ll discuss in Section 6.5.5.
    We’ll look at the basics here, but keep in mind that you might not actually encounter
    anything covered in this section.
  prefs: []
  type: TYPE_NORMAL
- en: 'A typical System V init installation has two components: a central configuration
    file and a large set of boot scripts augmented by a symbolic link farm. The configuration
    file */etc/inittab* is where it all starts. If you have System V init, look for
    a line like the following in your *inittab* file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: This indicates that the default runlevel is 5\.
  prefs: []
  type: TYPE_NORMAL
- en: 'All lines in *inittab* take the following form, with four fields separated
    by colons in this order:'
  prefs: []
  type: TYPE_NORMAL
- en: A unique identifier (a short string, such as `id` in the previous example).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The applicable runlevel number(s).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The action that init should take (default runlevel to 5 in the previous example).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A command to execute (optional).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'To see how commands work in an *inittab* file, consider this line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'This particular line is important because it triggers most of the system configuration
    and services. Here, the `wait` action determines when and how System V init runs
    the command: run `/etc/rc.d/rc 5` once when entering runlevel 5 and then wait
    for this command to finish before doing anything else. The `rc 5` command executes
    anything in */etc/rc5.d* that starts with a number (in numeric order). We’ll cover
    this in more detail shortly.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following are some of the most common *inittab* actions in addition to
    `initdefault` and `wait`:'
  prefs: []
  type: TYPE_NORMAL
- en: '`respawn`'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `respawn` action tells init to run the command that follows and, if the
    command finishes executing, to run it again. You’re likely to see something like
    this in an *inittab* file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `getty` programs provide login prompts. The preceding line is used for the
    first virtual console (*/dev/tty1*), which is the one you see when you press alt-F1
    or ctrl-alt-F1 (see Section 3.4.7). The `respawn` action brings the login prompt
    back after you log out.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`ctrlaltdel`'
  prefs: []
  type: TYPE_NORMAL
- en: The `ctrlaltdel` action controls what the system does when you press ctrl-alt-del
    on a virtual console. On most systems, this is some sort of reboot command using
    the `shutdown` command (discussed in Section 6.6).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`sysinit`'
  prefs: []
  type: TYPE_NORMAL
- en: The `sysinit` action is the first thing that init should run when starting,
    before entering any runlevels.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '6.5.1 System V init: Startup Command Sequence'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Now let’s look at how System V init starts system services, just before it
    lets you log in. Recall this *inittab* line from earlier:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: This short line triggers many other programs. In fact, `rc` stands for *run
    commands*, which many people refer to as *scripts*, *programs*, or *services*.
    But where are these commands?
  prefs: []
  type: TYPE_NORMAL
- en: 'The `5` in this line tells us that we’re talking about runlevel 5\. The commands
    are probably in either */etc/rc.d/rc5.d* or */etc/rc5.d*. (Runlevel 1 uses *rc1.d*,
    runlevel 2 uses *rc2.d*, and so on.) For example, you might find the following
    items in the *rc5.d* directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'The `rc 5` command starts programs in the *rc5.d* directory by executing the
    following commands in this sequence:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Notice the `start` argument in each command. The capital *S* in a command name
    means that the command should run in *start* mode, and the number (00 through
    99) determines where in the sequence `rc` starts the command. The *rc*.d* commands
    are usually shell scripts that start programs in */sbin* or */usr/sbin*.
  prefs: []
  type: TYPE_NORMAL
- en: Normally, you can figure out what a particular command does by viewing the script
    with `less` or another pager program.
  prefs: []
  type: TYPE_NORMAL
- en: You can run these commands by hand; however, normally you’ll want to do so through
    the *init.d* directory instead of the *rc*.d* directories, which we’ll look at
    next.
  prefs: []
  type: TYPE_NORMAL
- en: 6.5.2 The System V init Link Farm
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The contents of the *rc*.d* directories are actually symbolic links to files
    in yet another directory, *init.d*. If your goal is to interact with, add, delete,
    or modify services in the *rc*.d* directories, you need to understand these symbolic
    links. A long listing of a directory such as *rc5.d* reveals a structure like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: A large number of symbolic links across several subdirectories like this is
    called a *link farm*. Linux distributions contain these links so that they can
    use the same startup scripts for all runlevels. This is a convention, not a requirement,
    but it simplifies organization.
  prefs: []
  type: TYPE_NORMAL
- en: Starting and Stopping Services
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: To start and stop services by hand, use the script in the *init.d* directory.
    For example, one way to start the httpd web server program manually is to run
    `init.d/httpd start`. Similarly, to kill a running service, you can use the `stop`
    argument (`httpd stop`, for instance).
  prefs: []
  type: TYPE_NORMAL
- en: Modifying the Boot Sequence
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Changing the boot sequence in System V init is normally done by modifying the
    link farm. The most common change is to prevent one of the commands in the *init.d*
    directory from running in a particular runlevel. You have to be careful about
    how you do this, however. For example, you might consider removing the symbolic
    link in the appropriate *rc*.d* directory. But if you ever need to put the link
    back, you might have trouble remembering its exact name. One of the best approaches
    is to add an underscore (`_`) at the beginning of the link name, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: This change causes `rc` to ignore *_S99httpd* because the filename no longer
    starts with *S* or *K*, but the original name still indicates its purpose.
  prefs: []
  type: TYPE_NORMAL
- en: To add a service, create a script like those in the *init.d* directory and then
    create a symbolic link in the correct *rc*.d* directory. The easiest way to do
    this is to copy and modify one of the scripts already in *init.d* that you understand
    (see Chapter 11 for more information on shell scripts).
  prefs: []
  type: TYPE_NORMAL
- en: When adding a service, choose an appropriate place in the boot sequence to start
    it. If the service starts too soon, it may not work due to a dependency on some
    other service. For nonessential services, most systems administrators prefer numbers
    in the 90s, which puts the services after most of the services that came with
    the system.
  prefs: []
  type: TYPE_NORMAL
- en: 6.5.3 run-parts
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The mechanism that System V init uses to run the *init.d* scripts has found
    its way into many Linux systems, regardless of whether they use System V init.
    It’s a utility called `run-parts`, and the only thing it does is run a bunch of
    executable programs in a given directory, in some kind of predictable order. You
    can think of `run-parts` as almost like a person who enters the `ls` command in
    some directory and then just runs whatever programs are listed in the output.
  prefs: []
  type: TYPE_NORMAL
- en: The default behavior is to run all programs in a directory, but you often have
    the option to select certain programs and ignore others. In some distributions,
    you don’t need much control over the programs that run. For example, Fedora ships
    with a very simple `run-parts` utility.
  prefs: []
  type: TYPE_NORMAL
- en: Other distributions, such as Debian and Ubuntu, have a more complicated `run-parts`
    program. Their features include the ability to run programs based on a regular
    expression (for example, using the `S[0-9]{2}` expression for running all “start”
    scripts in an */etc/init.d* runleveldirectory) and to pass arguments to the programs.
    These capabilities allow you to start and stop System V runlevels with a single
    command.
  prefs: []
  type: TYPE_NORMAL
- en: You don’t really need to understand the details of how to use `run-parts`; in
    fact, most people don’t know that it even exists. The main things to remember
    are that it shows up in scripts from time to time and that it exists solely to
    run the programs in a given directory.
  prefs: []
  type: TYPE_NORMAL
- en: 6.5.4 System V init Control
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Occasionally, you’ll need to give init a little kick to tell it to switch runlevels,
    to reread its configuration, or to shut down the system. To control System V init,
    you use `telinit`. For example, to switch to runlevel 3, enter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: When switching runlevels, init tries to kill off any processes not in the *inittab*
    file for the new runlevel, so be careful when changing runlevels.
  prefs: []
  type: TYPE_NORMAL
- en: 'When you need to add or remove jobs, or make any other change to the *inittab*
    file, you must tell init about the change and have it reload the file. The `telinit`
    command for this is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: You can also use `telinit s` to switch to single-user mode.
  prefs: []
  type: TYPE_NORMAL
- en: 6.5.5 systemd System V Compatibility
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'One feature that sets systemd apart from other newer-generation init systems
    is that it tries to do a more complete job of tracking services started by System
    V–compatible init scripts. It works like this:'
  prefs: []
  type: TYPE_NORMAL
- en: First, systemd activates *runlevel<N>.target*, where *N* is the runlevel.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: For each symbolic link in */etc/rc<N>.d*, systemd identifies the script in */etc/init.d*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: systemd associates the script name with a service unit (for example, */etc/init.d/foo*
    would be *foo.service*).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: systemd activates the service unit and runs the script with either a `start`
    or `stop` argument, based on its name in *rc<N>.d*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: systemd attempts to associate any processes from the script with the service
    unit.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Because systemd makes the association with a service unit name, you can use
    `systemctl` to restart the service or view its status. But don’t expect any miracles
    from System V compatibility mode; it still must run the init scripts serially,
    for example.
  prefs: []
  type: TYPE_NORMAL
- en: 6.6 Shutting Down Your System
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: init controls how the system shuts down and reboots. The commands to shut down
    the system are the same regardless of which version of init you run. The proper
    way to shut down a Linux machine is to use the `shutdown` command.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two basic ways to use `shutdown`. If you *halt* the system, it shuts
    the machine down and keeps it down. To make the machine halt immediately, run
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: On most machines and versions of Linux, a halt cuts the power to the machine.
    You can also *reboot* the machine. For a reboot, use `-r` instead of `-h`.
  prefs: []
  type: TYPE_NORMAL
- en: The shutdown process takes several seconds. You should avoid resetting or powering
    off a machine during a shutdown.
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding example, `now` is the time to shut down. Including a time argument
    is mandatory, but there are many ways to specify it. For example, if you want
    the machine to shut down sometime in the future, you can use `+``n`, where `n`
    is the number of minutes `shutdown` should wait before proceeding. See the shutdown(8)
    manual page for other options.
  prefs: []
  type: TYPE_NORMAL
- en: 'To make the system reboot in 10 minutes, enter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: On Linux, `shutdown` notifies anyone logged on that the machine is going down,
    but it does little real work. If you specify a time other than `now`, the `shutdown`
    command creates a file called */etc/nologin*. When this file is present, the system
    prohibits logins by anyone except the superuser.
  prefs: []
  type: TYPE_NORMAL
- en: 'When the system shutdown time finally arrives, `shutdown` tells init to begin
    the shutdown process. On systemd, this means activating the shutdown units, and
    on System V init, it means changing the runlevel to 0 (halt) or 6 (reboot). Regardless
    of the init implementation or configuration, the procedure generally goes like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: init asks every process to shut down cleanly.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If a process doesn’t respond after a while, init kills it, first trying a TERM
    signal.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If the TERM signal doesn’t work, init uses the KILL signal on any stragglers.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The system locks system files into place and makes other preparations for shutdown.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The system unmounts all filesystems other than the root.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The system remounts the root filesystem read-only.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The system writes all buffered data out to the filesystem with the `sync` program.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The final step is to tell the kernel to reboot or stop with the `reboot(2)`
    system call. This can be done by init or an auxiliary program, such as `reboot`,
    `halt`, or `poweroff`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `reboot` and `halt` programs behave differently depending on how they’re
    called, which may cause confusion. By default, these programs call `shutdown`
    with the `-r` or `-h` options. However, if the system is already at a halt or
    reboot runlevel, the programs tell the kernel to shut itself off immediately.
    If you really want to shut down your machine in a hurry, regardless of any potential
    damage from a disorderly shutdown, use the `-f` (force) option.
  prefs: []
  type: TYPE_NORMAL
- en: 6.7 The Initial RAM Filesystem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The Linux boot process is, for the most part, fairly straightforward. However,
    one component has always been somewhat confounding: *initramfs*, or the *initial
    RAM filesystem*. Think of it as a little user-space wedge that goes in front of
    the normal user mode start. But first, let’s talk about why it exists.'
  prefs: []
  type: TYPE_NORMAL
- en: The problem stems from the availability of many different kinds of storage hardware.
    Remember, the Linux kernel does not talk to the PC BIOS interface or EFI to get
    data from disks, so in order to mount its root filesystem, it needs driver support
    for the underlying storage mechanism. For example, if the root is on a RAID array
    connected to a third-party controller, the kernel needs the driver for that controller
    first. Unfortunately, there are so many storage controller drivers that distributions
    can’t include all of them in their kernels, so many drivers are shipped as loadable
    modules. But loadable modules are files, and if your kernel doesn’t have a filesystem
    mounted in the first place, it can’t load the driver modules that it needs.
  prefs: []
  type: TYPE_NORMAL
- en: The workaround is to gather a small collection of kernel driver modules along
    with a few other utilities into an archive. The boot loader loads this archive
    into memory before running the kernel. Upon start, the kernel reads the contents
    of the archive into a temporary RAM filesystem (the initramfs), mounts it at */*,
    and performs the user-mode handoff to the init on the initramfs. Then, the utilities
    included in the initramfs allow the kernel to load the necessary driver modules
    for the real root filesystem. Finally, the utilities mount the real root filesystem
    and start the true init.
  prefs: []
  type: TYPE_NORMAL
- en: Implementations vary and are ever-evolving. On some distributions, the init
    on the initramfs is a fairly simple shell script that starts a udevd to load drivers,
    and then mounts the real root and executes the init there. On distributions that
    use systemd, you’ll typically see an entire systemd installation there with no
    unit configuration files and just a few udevd configuration files.
  prefs: []
  type: TYPE_NORMAL
- en: One basic characteristic of the initial RAM filesystem that has (so far) remained
    unchanged since its inception is the ability to bypass it if you don’t need it.
    That is, if your kernel has all the drivers it needs to mount your root filesystem,
    you can omit the initial RAM filesystem in your boot loader configuration. When
    successful, eliminating the initial RAM filesystem slightly shortens boot time.
    Try it yourself at boot time by using the GRUB menu editor to remove the `initrd`
    line. (It’s best not to experiment by changing the GRUB configuration file, as
    you can make a mistake that will be difficult to repair.) It has gradually become
    a little more difficult to bypass the initial RAM filesystem because features
    such as mount-by-UUID may not be available with generic distribution kernels.
  prefs: []
  type: TYPE_NORMAL
- en: You can check the contents of your initial RAM filesystem, but you’ll need to
    do a little bit of detective work. Most systems now use archives created by `mkinitramfs`
    that you can unpack with `unmkinitramfs`. Others might be older compressed `cpio`
    archives (see the cpio(1) manual page).
  prefs: []
  type: TYPE_NORMAL
- en: One particular piece of interest is the “pivot” near the very end of the init
    process on the initial RAM filesystem. This part is responsible for removing the
    contents of the temporary filesystem (to save memory) and permanently switch to
    the real root.
  prefs: []
  type: TYPE_NORMAL
- en: You won’t typically create your own initial RAM filesystem, as it’s a painstaking
    process. There are a number of utilities for creating initial RAM filesystem images,
    and your distribution likely comes with one. Two of the most common are `mkinitramfs`
    and `dracut`.
  prefs: []
  type: TYPE_NORMAL
- en: 6.8 Emergency Booting and Single-User Mode
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When something goes wrong with the system, your first recourse is usually to
    boot the system with a distribution’s “live” image or with a dedicated rescue
    image, such as SystemRescueCD, that you can put on removable media. A live image
    is simply a Linux system that can boot and run without an installation process;
    most distributions’ installation images double as live images. Common tasks for
    fixing a system include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Checking filesystems after a system crash.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Resetting a forgotten password.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fixing problems in critical files, such as */etc/fstab* and */etc/passwd.*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Restoring from backups after a system crash.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Another option for booting quickly to a usable state is *single-user mode*.
    The idea is that the system quickly boots to a root shell instead of going through
    the whole mess of services. In the System V init, single-user mode is usually
    runlevel 1\. In systemd, it’s represented by *rescue.target*. You normally enter
    the mode with the `-s` parameter to the boot loader. You may need to type the
    root password to enter single-user mode.
  prefs: []
  type: TYPE_NORMAL
- en: The biggest problem with single-user mode is that it doesn’t offer many amenities.
    The network almost certainly won’t be available (and if it is, it will be hard
    to use), you won’t have a GUI, and your terminal may not even work correctly.
    For this reason, live images are nearly always considered preferable.
  prefs: []
  type: TYPE_NORMAL
- en: 6.9 Looking Forward
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You’ve now seen the kernel and user-space startup phases of a Linux system,
    and how systemd tracks services once they’ve started. Next we’ll go a little deeper
    into user space. There are two areas to explore, starting with a number of system
    configuration files that all Linux programs use when interacting with certain
    elements of user space. Then we’ll see essential services that systemd starts.
  prefs: []
  type: TYPE_NORMAL
