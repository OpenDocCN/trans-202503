- en: Chapter 9. Process Credentials
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第9章. 进程凭证
- en: 'Every process has a set of associated numeric user identifiers (UIDs) and group
    identifiers (GIDs). Sometimes, these are referred to as process credentials. These
    identifiers are as follows:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 每个进程都有一组关联的数字用户标识符（UIDs）和组标识符（GIDs）。有时，这些被称为进程凭证。它们的定义如下：
- en: real user ID and group ID;
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实际用户ID和组ID；
- en: effective user ID and group ID;
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有效用户ID和组ID；
- en: saved set-user-ID and saved set-group-ID;
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 保存的设置用户ID和保存的设置组ID；
- en: file-system user ID and group ID (Linux-specific); and
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 文件系统用户ID和组ID（Linux特有）；以及
- en: supplementary group IDs.
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 补充组ID。
- en: In this chapter, we look in detail at the purpose of these process identifiers
    and describe the system calls and library functions that can be used to retrieve
    and change them. We also discuss the notion of privileged and unprivileged processes,
    and the use of the set-user-ID and set-group-ID mechanisms, which allow the creation
    of programs that run with the privileges of a specified user or group.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中，我们详细探讨这些进程标识符的作用，并描述可以用来检索和更改它们的系统调用和库函数。我们还讨论了特权进程和非特权进程的概念，以及使用设置用户ID和设置组ID机制，允许创建具有指定用户或组权限的程序。
- en: Real User ID and Real Group ID
  id: totrans-8
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实际用户ID和实际组ID
- en: 'The real user ID and group ID identify the user and group to which the process
    belongs. As part of the login process, a login shell gets its real user and group
    IDs from the third and fourth fields of the user’s password record in the `/etc/passwd`
    file ([The Password File: `/etc/passwd`](ch08.html#the_password_file_colon__solidus_etc_sol
    "The Password File: /etc/passwd")). When a new process is created (e.g., when
    the shell executes a program), it inherits these identifiers from its parent.'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 实际的用户ID和组ID标识了进程所属的用户和组。作为登录过程的一部分，登录Shell从用户密码记录的第三和第四字段中获取其实际的用户ID和组ID，这些记录存储在`/etc/passwd`文件中（[密码文件：`/etc/passwd`](ch08.html#the_password_file_colon__solidus_etc_sol
    "密码文件：/etc/passwd")）。当一个新进程被创建时（例如，当Shell执行一个程序时），它会从其父进程继承这些标识符。
- en: Effective User ID and Effective Group ID
  id: totrans-10
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 有效用户ID和有效组ID
- en: 'On most UNIX implementations (Linux is a little different, as explained in
    [File-System User ID and File-System Group ID](ch09.html#file-system_user_id_and_file-system_grou
    "File-System User ID and File-System Group ID")), the effective user ID and group
    ID, in conjunction with the supplementary group IDs, are used to determine the
    permissions granted to a process when it tries to perform various operations (i.e.,
    system calls). For example, these identifiers determine the permissions granted
    to a process when it accesses resources such as files and System V interprocess
    communication (IPC) objects, which themselves have associated user and group IDs
    determining to whom they belong. As we’ll see in [Sending Signals: *kill()*](ch20.html#sending_signals_colon_kill_open_parenthe
    "Sending Signals: kill()"), the effective user ID is also used by the kernel to
    determine whether one process can send a signal to another.'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数UNIX实现中（Linux有所不同，如在[文件系统用户ID和文件系统组ID](ch09.html#file-system_user_id_and_file-system_grou
    "文件系统用户ID和文件系统组ID")中所述），有效用户ID和组ID，与补充组ID一起，用于确定当进程尝试执行各种操作（即系统调用）时赋予它的权限。例如，这些标识符决定了当进程访问文件和System
    V进程间通信（IPC）对象等资源时赋予它的权限，这些资源本身也有与之相关联的用户和组ID，决定了它们属于谁。正如我们在[发送信号：*kill()*](ch20.html#sending_signals_colon_kill_open_parenthe
    "发送信号：kill()")中看到的，有效用户ID还被内核用来判断一个进程是否可以向另一个进程发送信号。
- en: A process whose effective user ID is 0 (the user ID of *root*) has all of the
    privileges of the superuser. Such a process is referred to as a *privileged process*.
    Certain system calls can be executed only by privileged processes.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 一个有效用户ID为0（即*root*用户ID）的进程拥有超级用户的所有权限。这样的进程被称为*特权进程*。某些系统调用只能由特权进程执行。
- en: Note
  id: totrans-13
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: In [Chapter 39](ch39.html "Chapter 39. Capabilities"), we describe Linux’s implementation
    of capabilities, a scheme that divides the privileges granted to the superuser
    into a number of distinct units that can be independently enabled and disabled.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第39章](ch39.html "第39章. 能力")中，我们描述了Linux对能力的实现，这是一种将超级用户的权限划分为多个独立单元的机制，这些单元可以单独启用或禁用。
- en: Normally, the effective user and group IDs have the same values as the corresponding
    real IDs, but there are two ways in which the effective IDs can assume different
    values. One way is through the use of system calls that we discuss in Section
    9.7\. The second way is through the execution of set-user-ID and set-group-ID
    programs.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，进程的有效用户ID和组ID与相应的真实ID值相同，但有两种方式可以使有效ID具有不同的值。一种方式是通过我们在9.7节中讨论的系统调用。第二种方式是通过执行设置用户ID和设置组ID的程序。
- en: Set-User-ID and Set-Group-ID Programs
  id: totrans-16
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设置用户ID和设置组ID程序
- en: A set-user-ID program allows a process to gain privileges it would not normally
    have, by setting the process’s effective user ID to the same value as the user
    ID (owner) of the executable file. A set-group-ID program performs the analogous
    task for the process’s effective group ID. (The terms *set-user-ID program* and
    *set-group-ID* program are sometimes abbreviated as *set-UID program* and *set-GID
    program*.)
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 设置用户ID的程序允许进程通过将进程的有效用户ID设置为与可执行文件的用户ID（所有者）相同的值，来获得通常无法拥有的权限。设置组ID的程序为进程的有效组ID执行类似的任务。（术语*设置用户ID程序*和*设置组ID程序*有时简写为*set-UID程序*和*set-GID程序*。）
- en: 'Like any other file, an executable program file has an associated user ID and
    group ID that define the ownership of the file. In addition, an executable file
    has two special permission bits: the set-user-ID and set-group-ID bits. (In fact,
    every file has these two permission bits, but it is their use with executable
    files that interests us here.) These permission bits are set using the *chmod*
    command. An unprivileged user can set these bits for files that they own. A privileged
    user (`CAP_FOWNER`) can set these bits for any file. Here’s an example:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 与其他文件一样，可执行程序文件具有一个关联的用户ID和组ID，用于定义文件的所有权。此外，可执行文件有两个特殊的权限位：设置用户ID和设置组ID位。（实际上，每个文件都有这两个权限位，但我们在这里关注的是它们与可执行文件的使用。）这些权限位是通过*chmod*命令设置的。一个非特权用户可以为他们拥有的文件设置这些位。一个特权用户（`CAP_FOWNER`）可以为任何文件设置这些位。下面是一个例子：
- en: '[PRE0]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'As shown in this example, it is possible for a program to have both of these
    bits set, although this is uncommon. When *ls -l* is used to list the permissions
    for a program that has the set-user-ID or set-group-ID permission bit set, then
    the *x* that is normally used to indicate that execute permission is set is replaced
    by an *s*:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 如本示例所示，程序可以同时设置这两个位，尽管这种情况不常见。当使用*ls -l*列出具有设置用户ID或设置组ID权限位的程序的权限时，通常用于表示已设置执行权限的*x*会被*s*替代：
- en: '[PRE1]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: When a set-user-ID program is run (i.e., loaded into a process’s memory by an
    *exec()*), the kernel sets the effective user ID of the process to be the same
    as the user ID of the executable file. Running a set-group-ID program has an analogous
    effect for the effective group ID of the process. Changing the effective user
    or group ID in this way gives a process (in other words, the user executing the
    program) privileges it would not normally have. For example, if an executable
    file is owned by *root* (superuser) and has the set-user-ID permission bit enabled,
    then the process gains superuser privileges when that program is run.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 当运行设置用户ID的程序时（即通过*exec()*将程序加载到进程的内存中），内核会将进程的有效用户ID设置为与可执行文件的用户ID相同。运行设置组ID的程序对进程的有效组ID有类似的影响。以这种方式更改有效用户或组ID赋予进程（换句话说，执行程序的用户）通常无法拥有的权限。例如，如果一个可执行文件由*root*（超级用户）所有，并且启用了设置用户ID权限位，则运行该程序时进程将获得超级用户权限。
- en: Set-user-ID and set-group-ID programs can also be designed to change the effective
    IDs of a process to something other than *root*. For example, to provide access
    to a protected file (or other system resource), it may suffice to create a special-purpose
    user (group) ID that has the privileges required to access the file, and create
    a set-user-ID (set-group-ID) program that changes the effective user (group) ID
    of a process to that ID. This permits the program to access the file without allowing
    it all of the privileges of the superuser.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 设置用户ID和设置组ID的程序也可以设计成将进程的有效ID更改为其他值，而不是*root*。例如，为了提供对受保护文件（或其他系统资源）的访问，可能只需创建一个特殊用途的用户（组）ID，该ID拥有访问文件所需的权限，并创建一个设置用户ID（设置组ID）程序，将进程的有效用户（组）ID更改为该ID。这使得程序可以访问文件，而不授予其超级用户的所有权限。
- en: Sometimes, we’ll use the term set-user-ID-*root* to distinguish a set-user-ID
    program that is owned by *root* from one owned by another user, which merely gives
    a process the privileges accorded to that user.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，我们会使用术语设置用户ID-*root*，以区分由*root*拥有的设置用户ID程序和由其他用户拥有的程序，后者仅授予进程该用户所拥有的特权。
- en: Note
  id: totrans-25
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'We have now started using the term *privileged* in two different senses. One
    is the sense defined earlier: a process with an effective user ID of 0, which
    has all of the privileges accorded to *root*. However, when we are talking about
    a set-user-ID program owned by a user other than *root*, we’ll sometimes refer
    to a process as gaining the privileges accorded to the user ID of the set-user-ID
    program. Which sense of the term *privileged* we mean in each case should be clear
    from the context.'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在开始在两种不同的意义上使用术语*特权*。一种是前面定义的意义：具有有效用户ID为0的进程，拥有授予*root*的所有特权。然而，当我们谈论由非*root*用户拥有的设置用户ID程序时，我们有时会提到一个进程获得了授予设置用户ID程序的用户ID的特权。每次我们使用*特权*这个术语时，具体指哪种意义应该从上下文中可以清楚地辨别。
- en: For reasons that we explain in [Be Careful When Executing a Program](ch38.html#be_careful_when_executing_a_program
    "Be Careful When Executing a Program"), the set-user-ID and set-group-ID permission
    bits don’t have any effect for shell scripts on Linux.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 出于我们在[执行程序时需小心](ch38.html#be_careful_when_executing_a_program "执行程序时需小心")中解释的原因，设置用户ID和设置组ID权限位对Linux上的shell脚本没有任何影响。
- en: 'Examples of commonly used set-user-ID programs on Linux include: *passwd(1)*,
    which changes a user’s password; *mount(8)* and *umount(8)*, which mount and unmount
    file systems; and *su(1)*, which allows a user to run a shell under a different
    user ID. An example of a set-group-ID program is *wall(1)*, which writes a message
    to all terminals owned by the *tty* group (normally, every terminal is owned by
    this group).'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在Linux上常用的设置用户ID程序的示例包括：*passwd(1)*，用于更改用户密码；*mount(8)* 和 *umount(8)*，用于挂载和卸载文件系统；以及
    *su(1)*，允许用户以不同的用户ID运行一个shell。一个设置组ID程序的示例是 *wall(1)*，它将消息写入所有属于*tty*组的终端（通常每个终端都由该组拥有）。
- en: 'In [Password Encryption and User Authentication](ch08.html#password_encryption_and_user_authenticat
    "Password Encryption and User Authentication"), we noted that the program in [Example 8-2](ch08.html#authenticating_a_user_against_the_shadow
    "Example 8-2. Authenticating a user against the shadow password file") needed
    to be run from a *root* login so that it could access the `/etc/shadow` file.
    We could make this program runnable by any user by making it a set-user-ID-*root*
    program, as follows:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在[密码加密与用户认证](ch08.html#password_encryption_and_user_authenticat "密码加密与用户认证")中，我们提到过[示例
    8-2](ch08.html#authenticating_a_user_against_the_shadow "示例 8-2. 对用户进行影子密码文件认证")中的程序需要从*root*登录运行，以便访问
    `/etc/shadow` 文件。我们可以通过将该程序设为设置用户ID-*root*程序，使其可以由任何用户运行，具体如下：
- en: '[PRE2]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The set-user-ID/set-group-ID technique is a useful and powerful tool, but one
    that can result in security breaches in applications that are poorly designed.
    In [Chapter 38](ch38.html "Chapter 38. Writing Secure Privileged Programs"), we
    list a set of good practices that should be observed when writing set-user-ID
    and set-group-ID programs.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 设置用户ID/设置组ID技术是一个有用且强大的工具，但如果应用程序设计不当，可能会导致安全漏洞。在[第38章](ch38.html "第38章. 编写安全的特权程序")中，我们列出了编写设置用户ID和设置组ID程序时应该遵循的一系列良好实践。
- en: Saved Set-User-ID and Saved Set-Group-ID
  id: totrans-32
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 已保存的设置用户ID和已保存的设置组ID
- en: 'The saved set-user-ID and saved set-group-ID are designed for use with set-user-ID
    and set-group-ID programs. When a program is executed, the following steps (among
    many others) occur:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 已保存的设置用户ID和已保存的设置组ID是为设置用户ID和设置组ID程序设计的。当程序执行时，以下步骤（以及许多其他步骤）会发生：
- en: If the set-user-ID (set-group-ID) permission bit is enabled on the executable,
    then the effective user (group) ID of the process is made the same as the owner
    of the executable. If the set-user-ID (set-group-ID) bit is not set, then no change
    is made to the effective user (group) ID of the process.
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果可执行文件上启用了设置用户ID（设置组ID）权限位，那么进程的有效用户（组）ID将与可执行文件的所有者相同。如果没有设置设置用户ID（设置组ID）位，则不会更改进程的有效用户（组）ID。
- en: The values for the saved set-user-ID and saved set-group-ID are copied from
    the corresponding effective IDs. This copying occurs regardless of whether the
    set-user-ID or set-group-ID bit is set on the file being executed.
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 已保存的设置用户ID和已保存的设置组ID的值将从相应的有效ID复制。这种复制发生在不管文件是否设置了设置用户ID或设置组ID位的情况下。
- en: 'As an example of the effect of the above steps, suppose that a process whose
    real user ID, effective user ID, and saved set-user-ID are all 1000 execs a set-user-ID
    program owned by *root* (user ID 0). After the exec, the user IDs of the process
    will be changed as follows:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 作为上述步骤效果的示例，假设一个进程，其实际用户ID、有效用户ID和保存的设置用户ID均为1000，并执行一个由*root*（用户ID 0）拥有的设置用户ID程序。执行后，进程的用户ID将按如下方式更改：
- en: '[PRE3]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Various system calls allow a set-user-ID program to switch its effective user
    ID between the values of the real user ID and the saved set-user-ID. Analogous
    system calls allow a set-group-ID program to modify its effective group ID. In
    this manner, the program can temporarily drop and regain whatever privileges are
    associated with the user (group) ID of the execed file. (In other words, the program
    can move between the states of potentially being privileged and actually operating
    with privilege.) As we’ll elaborate in [Operate with Least Privilege](ch38.html#operate_with_least_privilege
    "Operate with Least Privilege"), it is secure programming practice for set-user-ID
    and set-group-ID programs to operate under the unprivileged (i.e., real) ID whenever
    the program doesn’t actually need to perform any operations associated with the
    privileged (i.e., saved set) ID.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 各种系统调用允许设置用户ID的程序在实际用户ID和保存的设置用户ID之间切换其有效用户ID。类似的系统调用允许设置组ID的程序修改其有效组ID。通过这种方式，程序可以暂时丢失并恢复与执行的文件的用户（组）ID相关的任何特权。（换句话说，程序可以在潜在特权状态和实际操作特权状态之间切换。）正如我们将在[以最小特权操作](ch38.html#operate_with_least_privilege
    "以最小特权操作")中详细说明的那样，对于设置用户ID和设置组ID的程序，在程序不实际需要执行与特权（即保存的设置）ID相关的任何操作时，在不具特权的（即实际）ID下操作是一种安全的编程实践。
- en: Note
  id: totrans-39
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The saved set-user-ID and saved set-group-ID are sometimes synonymously referred
    to as the *saved user ID* and *saved group ID*.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 保存的设置用户ID和保存的设置组ID有时被同义地称为*保存的用户ID*和*保存的组ID*。
- en: The saved set IDs are a System V invention adopted by POSIX. They were not provided
    on releases of BSD prior to 4.4\. The initial POSIX.1 standard made support for
    these IDs optional, but later standards (starting with FIPS 151-1 in 1988) made
    support mandatory.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 保存的设置ID是System V发明的，并被POSIX采用。在BSD的4.4之前的版本中没有提供这些ID。最初的POSIX.1标准将对这些ID的支持设为可选，但后来的标准（从1988年FIPS
    151-1开始）将支持设置为强制性。
- en: File-System User ID and File-System Group ID
  id: totrans-42
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 文件系统用户ID和文件系统组ID
- en: On Linux, it is the file-system user and group IDs, rather than the effective
    user and group IDs, that are used (in conjunction with the supplementary group
    IDs) to determine permissions when performing file-system operations such as opening
    files, changing file ownership, and modifying file permissions. (The effective
    IDs are still used, as on other UNIX implementations, for the other purposes described
    earlier.)
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在Linux上，使用的是文件系统的用户和组ID，而不是有效的用户和组ID（与附加组ID结合使用），用于在执行文件系统操作时（如打开文件、修改文件所有权和修改文件权限）确定权限。（有效ID仍然用于其他目的，正如在其他UNIX实现中所描述的那样。）
- en: Normally, the file-system user and group IDs have the same values as the corresponding
    effective IDs (and thus typically are the same as the corresponding real IDs).
    Furthermore, whenever the effective user or group ID is changed, either by a system
    call or by execution of a set-user-ID or set-group-ID program, the corresponding
    file-system ID is also changed to the same value. Since the file-system IDs follow
    the effective IDs in this way, this means that Linux effectively behaves just
    like any other UNIX implementation when privileges and permissions are being checked.
    The file-system IDs differ from the corresponding effective IDs, and hence Linux
    differs from other UNIX implementations, only when we use two Linux-specific system
    calls, *setfsuid()* and *setfsgid()*, to explicitly make them different.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，文件系统的用户和组ID与相应的有效ID具有相同的值（因此通常与相应的实际ID相同）。此外，每当有效用户ID或组ID发生变化时，无论是通过系统调用还是执行设置用户ID或设置组ID的程序，相应的文件系统ID也会更改为相同的值。由于文件系统ID以这种方式跟随有效ID，这意味着Linux在检查权限和权限时实际上表现得与任何其他UNIX实现相同。只有当我们使用两个Linux特定的系统调用，*setfsuid()*和*setfsgid()*，显式地使它们不同，Linux才与其他UNIX实现有所不同。
- en: Why does Linux provide the file-system IDs and in what circumstances would we
    want the effective and file-system IDs to differ? The reasons are primarily historical.
    The file-system IDs first appeared in Linux 1.2\. In that kernel version, one
    process could send a signal to another if the effective user ID of the sender
    matched the real or effective user ID of the target process. This affected certain
    programs such as the Linux NFS (Network File System) server program, which needed
    to be able to access files as though it had the effective IDs of the corresponding
    client process. However, if the NFS server changed its effective user ID, it would
    be vulnerable to signals from unprivileged user processes. To prevent this possibility,
    the separate file-system user and group IDs were devised. By leaving its effective
    IDs unchanged, but changing its file-system IDs, the NFS server could masquerade
    as another user for the purpose of accessing files without being vulnerable to
    signals from user processes.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么 Linux 提供文件系统 ID，在哪些情况下我们希望有效 ID 和文件系统 ID 不同？原因主要是历史性的。文件系统 ID 首次出现在 Linux
    1.2 中。在那个内核版本中，如果发送者的有效用户 ID 与目标进程的真实用户 ID 或有效用户 ID 匹配，一个进程可以向另一个进程发送信号。这影响了某些程序，比如
    Linux NFS（网络文件系统）服务器程序，它需要能够以相应客户端进程的有效 ID 来访问文件。然而，如果 NFS 服务器改变了其有效用户 ID，它就会面临来自非特权用户进程的信号攻击。为防止这种情况，设计了单独的文件系统用户
    ID 和组 ID。通过保持其有效 ID 不变，但更改其文件系统 ID，NFS 服务器可以伪装成另一个用户来访问文件，而不易受到用户进程的信号攻击。
- en: 'From kernel 2.0 onward, Linux adopted the SUSv3-mandated rules regarding permission
    for sending signals, and these rules don’t involve the effective user ID of the
    target process (refer to [Sending Signals: *kill()*](ch20.html#sending_signals_colon_kill_open_parenthe
    "Sending Signals: kill()")). Thus, the file-system ID feature is no longer strictly
    necessary (a process can nowadays achieve the desired results by making judicious
    use of the system calls described later in this chapter to change the value of
    the effective user ID to and from an unprivileged value, as required), but it
    remains for compatibility with existing software.'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 从 2.0 内核版本开始，Linux 采用了 SUSv3 规定的发送信号权限规则，这些规则不涉及目标进程的有效用户 ID（参考[发送信号：*kill()*](ch20.html#sending_signals_colon_kill_open_parenthe
    "发送信号：kill()")）。因此，文件系统 ID 功能不再严格必要（如今，进程可以通过合理使用本章后续描述的系统调用来更改有效用户 ID 的值，达到所需的效果），但它仍然保留以兼容现有的软件。
- en: Since the file-system IDs are something of an oddity, and they normally have
    the same values as the corresponding effective IDs, in the remainder of this book,
    we’ll generally describe various file permission checks, as well as the setting
    of the ownership of new files, in terms of the effective IDs of a process. Even
    though the process’s file-system IDs are really used for these purposes on Linux,
    in practice, their presence seldom makes an effective difference.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 由于文件系统 ID 是一种特殊的存在，且它们通常与相应的有效 ID 具有相同的值，在本书的其余部分，我们将通常以进程的有效 ID 来描述各种文件权限检查以及新文件的所有权设置。尽管在
    Linux 上，进程的文件系统 ID 确实用于这些目的，但在实践中，它们的存在很少产生实质性的影响。
- en: Supplementary Group IDs
  id: totrans-48
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 补充组 ID
- en: The supplementary group IDs are a set of additional groups to which a process
    belongs. A new process inherits these IDs from its parent. A login shell obtains
    its supplementary group IDs from the system group file. As noted above, these
    IDs are used in conjunction with the effective and file-system IDs to determine
    permissions for accessing files, System V IPC objects, and other system resources.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 补充组 ID 是一组附加的组，表示一个进程所属的组。一个新进程会从其父进程继承这些 ID。登录 shell 会从系统组文件中获取其补充组 ID。如上所述，这些
    ID 会与有效 ID 和文件系统 ID 一起使用，用于确定访问文件、System V IPC 对象以及其他系统资源的权限。
- en: Retrieving and Modifying Process Credentials
  id: totrans-50
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 检索和修改进程凭证
- en: Linux provides a range of system calls and library functions for retrieving
    and changing the various user and group IDs that we have described in this chapter.
    Only some of these APIs are specified in SUSv3\. Of the remainder, several are
    widely available on other UNIX implementations and a few are Linux-specific. We
    note portability issues as we describe each interface. Toward the end of this
    chapter, [Table 9-1](ch09.html#summary_of_interfaces_used_to_change_pro "Table 9-1. Summary
    of interfaces used to change process credentials") summarizes the operation of
    all of the interfaces used to change process credentials.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: Linux 提供了一系列系统调用和库函数，用于检索和更改本章中描述的各种用户和组ID。只有其中一些API在SUSv3中有明确规定，其余的有些在其他UNIX实现中广泛可用，有些是Linux特有的。我们在描述每个接口时会指出可移植性问题。在本章的最后，[表
    9-1](ch09.html#summary_of_interfaces_used_to_change_pro "表 9-1. 用于更改进程凭证的接口汇总")总结了所有用于更改进程凭证的接口的操作。
- en: As an alternative to using the system calls described in the following pages,
    the credentials of any process can be found by examining the `Uid`, `Gid`, and
    `Groups` lines provided in the Linux-specific `/proc/`*`PID`*`/status` file. The
    `Uid` and `Gid` lines list the identifiers in the order real, effective, saved
    set, and file system.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 作为使用以下页面中描述的系统调用的替代方法，可以通过检查Linux特有的`/proc/`*`PID`*`/status`文件中的`Uid`、`Gid`和`Groups`行来查找任何进程的凭证。`Uid`和`Gid`行按顺序列出标识符，包括真实、有效、保存集合和文件系统。
- en: 'In the following sections, we use the traditional definition of a privileged
    process as one whose effective user ID is 0\. However, Linux divides the notion
    of superuser privileges into distinct capabilities, as described in [Chapter 39](ch39.html
    "Chapter 39. Capabilities"). Two capabilities are relevant for our discussion
    of all of the system calls used to change process user and group IDs:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下章节中，我们使用传统的特权进程定义，即有效用户ID为0的进程。然而，Linux将超级用户权限划分为不同的能力，如[第39章](ch39.html
    "第39章. 能力")所述。两项能力与我们讨论所有用于更改进程用户和组ID的系统调用相关：
- en: The `CAP_SETUID` capability allows a process to make arbitrary changes to its
    user IDs.
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CAP_SETUID`能力允许进程对其用户ID进行任意修改。'
- en: The `CAP_SETGID` capability allows a process to make arbitrary changes to its
    group IDs.
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CAP_SETGID`能力允许进程对其组ID进行任意修改。'
- en: Retrieving and Modifying Real, Effective, and Saved Set IDs
  id: totrans-56
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 检索和修改真实、有效和保存的ID集合
- en: In the following paragraphs, we describe the system calls that retrieve and
    modify the real, effective, and saved set IDs. There are several system calls
    that perform these tasks, and in some cases their functionality overlaps, reflecting
    the fact that the various system calls originated on different UNIX implementations.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的段落中，我们将描述检索和修改真实、有效和保存的ID集合的系统调用。有几个系统调用执行这些任务，在某些情况下，它们的功能重叠，反映了这些系统调用起源于不同的UNIX实现。
- en: Retrieving real and effective IDs
  id: totrans-58
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 检索真实和有效的ID
- en: The *getuid()* and *getgid()* system calls return, respectively, the real user
    ID and real group ID of the calling process. The *geteuid()* and *getegid()* system
    calls perform the corresponding tasks for the effective IDs. These system calls
    are always successful.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '*getuid()*和*getgid()*系统调用分别返回调用进程的真实用户ID和真实组ID。*geteuid()*和*getegid()*系统调用执行对应的任务，用于有效ID。这些系统调用始终成功。'
- en: '[PRE4]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Note
  id: totrans-61
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Returns real user ID of calling process
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 返回调用进程的真实用户ID
- en: '[PRE5]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Note
  id: totrans-64
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Returns effective user ID of calling process
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 返回调用进程的有效用户ID
- en: '[PRE6]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Note
  id: totrans-67
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Returns real group ID of calling process
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 返回调用进程的真实组ID
- en: '[PRE7]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Note
  id: totrans-70
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Returns effective group ID of calling process
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 返回调用进程的有效组ID
- en: Modifying effective IDs
  id: totrans-72
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 修改有效ID
- en: The *setuid()* system call changes the effective user ID—and possibly the real
    user ID and the saved set-user-ID—of the calling process to the value given by
    the *uid* argument. The *setgid()* system call performs the analogous task for
    the corresponding group IDs.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '*setuid()*系统调用将调用进程的有效用户ID—以及可能的真实用户ID和保存的用户ID集合—修改为*uid*参数给定的值。*setgid()*系统调用执行对应的任务，用于修改组ID。'
- en: '[PRE8]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Note
  id: totrans-75
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Both return 0 on success, or -1 on error
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 成功时返回0，出错时返回-1
- en: 'The rules about what changes a process can make to its credentials using *setuid()*
    and *setgid()* depend on whether the process is privileged (i.e., has an effective
    user ID equal to 0). The following rules apply to *setuid()*:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 使用*setuid()*和*setgid()*修改进程凭证的规则取决于进程是否具有特权（即，其有效用户ID为0）。以下规则适用于*setuid()*：
- en: 'When an unprivileged process calls *setuid()*, only the effective user ID of
    the process is changed. Furthermore, it can be changed only to the same value
    as either the real user ID or saved set-user-ID. (Attempts to violate this constraint
    yield the error `EPERM`.) This means that, for unprivileged users, this call is
    useful only when executing a set-user-ID program, since, for the execution of
    normal programs, the process’s real user ID, effective user ID, and saved set-user-ID
    all have the same value. On some BSD-derived implementations, calls to *setuid()*
    or *setgid()* by an unprivileged process have different semantics from other UNIX
    implementations: the calls change the real, effective, and saved set IDs (to the
    value of the current real or effective ID).'
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When a privileged process executes *setuid()* with a nonzero argument, then
    the real user ID, effective user ID, and saved set-user-ID are all set to the
    value specified in the *uid* argument. This is a one-way trip, in that once a
    privileged process has changed its identifiers in this way, it loses all privileges
    and therefore can’t subsequently use *setuid()* to reset the identifiers back
    to 0\. If this is not desired, then either *seteuid()* or *setreuid()*, which
    we describe shortly, should be used instead of *setuid()*.
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The rules governing the changes that may be made to group IDs using *setgid()*
    are similar, but with *setgid()* substituted for *setuid()* and *group* for *user*.
    With these changes, rule 1 applies exactly as stated. In rule 2, since changing
    the group IDs doesn’t cause a process to lose privileges (which are determined
    by the effective *user* ID), privileged programs can use *setgid()* to freely
    change the group IDs to any desired values.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
- en: 'The following call is the preferred method for a set-user-ID-*root* program
    whose effective user ID is currently 0 to irrevocably drop all privileges (by
    setting both the effective user ID and saved set-user-ID to the same value as
    the real user ID):'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: A set-user-ID program owned by a user other than *root* can use *setuid()* to
    switch the effective user ID between the values of the real user ID and saved
    set-user-ID for the security reasons described in Section 9.4\. However, *seteuid()*
    is preferable for this purpose, since it has the same effect, regardless of whether
    the set-user-ID program is owned by *root*.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
- en: A process can use *seteuid()* to change its effective user ID (to the value
    specified by *euid*), and *setegid()* to change its effective group ID (to the
    value specified by *egid*).
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Note
  id: totrans-86
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Both return 0 on success, or -1 on error
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
- en: 'The following rules govern the changes that a process may make to its effective
    IDs using *seteuid()* and *setegid()*:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
- en: An unprivileged process can change an effective ID only to the same value as
    the corresponding real or saved set ID. (In other words, for an unprivileged process,
    *seteuid()* and *setegid()* have the same effect as *setuid()* and *setgid()*,
    respectively, except for the BSD portability issues noted earlier.)
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 非特权进程只能将有效ID更改为与相应的实际ID或保存的ID相同的值。（换句话说，对于非特权进程，*seteuid()*和*setegid()*的作用与*setuid()*和*setgid()*相同，除了前面提到的BSD可移植性问题。）
- en: A privileged process can change an effective ID to any value. If a privileged
    process uses *seteuid()* to change its effective user ID to a nonzero value, then
    it ceases to be privileged (but may be able to regain privilege via the previous
    rule).
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 特权进程可以将有效ID更改为任何值。如果特权进程使用*seteuid()*将其有效用户ID更改为非零值，那么它将不再是特权进程（但可以通过前述规则恢复特权）。
- en: 'Using *seteuid()* is the preferred method for set-user-ID and set-group-ID
    programs to temporarily drop and later regain privileges. Here’s an example:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 使用*seteuid()*是设置用户ID和组ID程序临时丧失特权然后再恢复特权的首选方法。以下是一个示例：
- en: '[PRE11]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Originally derived from BSD, *seteuid()* and *setegid()* are now specified in
    SUSv3 and appear on most UNIX implementations.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '*seteuid()*和*setegid()*最初源自BSD，现在已在SUSv3中指定，并且在大多数UNIX实现中都有提供。'
- en: Note
  id: totrans-94
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: In older versions of the GNU C library (*glibc* 2.0 and earlier), *seteuid(euid)*
    is implemented as *setreuid(-1, euid)*. In modern versions of *glibc, seteuid(euid)*
    is implemented as *setresuid(-1, euid, -1)*. (We describe *setreuid()*, *setresuid()*,
    and their group analogs shortly.) Both implementations permit us to specify *euid*
    as the same value as the current effective user ID (i.e., no change). However,
    SUSv3 doesn’t specify this behavior for *seteuid()*, and it is not possible on
    some other UNIX implementations. Generally, this potential variation across implementations
    is not apparent, since, in normal circumstances, the effective user ID has the
    same value as either the real user ID or the saved set-user-ID. (The only way
    in which we can make the effective user ID differ from both the real user ID and
    the saved set-user-ID on Linux is via the use of the nonstandard *setresuid()*
    system call.)
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在较旧版本的GNU C库（*glibc* 2.0及更早版本）中，*seteuid(euid)*的实现方式是*setreuid(-1, euid)*。在现代版本的*glibc*中，*seteuid(euid)*的实现方式是*setresuid(-1,
    euid, -1)*。（我们稍后会描述*setreuid()*、*setresuid()*及其组ID的类似方法。）这两种实现都允许我们将*euid*指定为与当前有效用户ID相同的值（即不做更改）。然而，SUSv3并未对*seteuid()*规定此行为，并且在某些其他UNIX实现中是不可行的。通常情况下，这种实现差异并不明显，因为在正常情况下，实际用户ID和保存的用户ID与有效用户ID的值是相同的。（在Linux中，唯一能够使有效用户ID与实际用户ID和保存的用户ID不同的方式是通过使用非标准的*setresuid()*系统调用。）
- en: In all versions of *glibc* (including modern ones), *setegid(egid)* is implemented
    as *setregid(-1, egid)*. As with *seteuid()*, this means that we can specify *egid*
    as the same value as the current effective group ID, although this behavior is
    not specified in SUSv3\. It also means that *setegid()* changes the saved set-group-ID
    if the effective group ID is set to a value other than the current real group
    ID. (A similar remark applies for the older implementation of *seteuid()* using
    *setreuid()*.) Again, this behavior is not specified in SUSv3.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在所有版本的*glibc*（包括现代版本）中，*setegid(egid)*的实现方式是*setregid(-1, egid)*。与*seteuid()*类似，这意味着我们可以将*egid*指定为与当前有效组ID相同的值，尽管这种行为在SUSv3中并没有明文规定。这也意味着，如果将有效组ID设置为与当前实际组ID不同的值，*setegid()*将会更改保存的组ID。（对于使用*setreuid()*实现的旧版*seteuid()*，也有类似的说明。）同样，这种行为在SUSv3中并没有明确规定。
- en: Modifying real and effective IDs
  id: totrans-97
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 修改实际和有效ID
- en: The *setreuid()* system call allows the calling process to independently change
    the values of its real and effective user IDs. The *setregid()* system call performs
    the analogous task for the real and effective group IDs.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '*setreuid()*系统调用允许调用进程独立地更改其实际和有效用户ID的值。*setregid()*系统调用则执行类似的任务，用于实际和有效组ID。'
- en: '[PRE12]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Note
  id: totrans-100
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Both return 0 on success, or -1 on error
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 成功时返回0，错误时返回-1
- en: The first argument to each of these system calls is the new real ID. The second
    argument is the new effective ID. If we want to change only one of the identifiers,
    then we can specify -1 for the other argument.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 每个系统调用的第一个参数是新的实际ID，第二个参数是新的有效ID。如果我们只想更改其中一个标识符，那么可以为另一个参数指定-1。
- en: Originally derived from BSD, *setreuid()* and *setregid()* are now specified
    in SUSv3 and are available on most UNIX implementations.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '*setreuid()*和*setregid()*最初源自BSD，现在已在SUSv3中指定，并且在大多数UNIX实现中都有提供。'
- en: 'As with the other system calls described in this section, rules govern the
    changes that we can make using *setreuid()* and *setregid()*. We describe these
    rules from the point of view of *setreuid()*, with the understanding that *setregid()*
    is similar, except as noted:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
- en: An unprivileged process can set the real user ID only to the current value of
    the real (i.e., no change) or effective user ID. The effective user ID can be
    set only to the current value of the real user ID, effective user ID (i.e., no
    change), or saved set-user-ID.
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note
  id: totrans-106
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: SUSv3 says that it is unspecified whether an unprivileged process can use *setreuid()*
    to change the value of the real user ID to the current value of the real user
    ID, effective user ID, or saved set-user-ID, and the details of precisely what
    changes can be made to the real user ID vary across implementations.
  id: totrans-107
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'SUSv3 describes slightly different behavior for *setregid()*: an unprivileged
    process can set the real group ID to the current value of the saved set-group-ID
    or set the effective group ID to the current value of either the real group ID
    or the saved set-group-ID. Again, the details of precisely what changes can be
    made vary across implementations.'
  id: totrans-108
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: A privileged process can make any changes to the IDs.
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'For both privileged and unprivileged processes, the saved set-user-ID is also
    set to the same value as the (new) effective user ID if either of the following
    is true:'
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*ruid* is not -1 (i.e., the real user ID is being set, even to the same value
    it already had), or'
  id: totrans-111
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: the effective user ID is being set to a value other than the value of the real
    user ID prior to the call.
  id: totrans-112
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Put conversely, if a process uses *setreuid()* only to change the effective
    user ID to the same value as the current real user ID, then the saved set-user-ID
    is left unchanged, and a later call to *setreuid()* (or *seteuid()*) can restore
    the effective user ID to the saved set-user-ID value. (SUSv3 doesn’t specify the
    effect of *setreuid()* and *setregid()* on the saved set IDs, but SUSv4 specifies
    the behavior described here.)
  id: totrans-113
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'The third rule provides a way for a set-user-ID program to permanently drop
    its privilege, using a call such as the following:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: A set-user-ID-*root* process that wants to change both its user and group credentials
    to arbitrary values should first call *setregid()* and then call *setreuid()*.
    If the calls are made in the opposite order, then the *setregid()* call will fail,
    because the program will no longer be privileged after the call to *setreuid()*.
    Similar remarks apply if we are using *setresuid()* and *setresgid()* (described
    below) for this purpose.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-117
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: BSD releases up to and including 4.3BSD did not have the saved set-user-ID and
    saved set-group-ID (which are nowadays mandated by SUSv3). Instead, on BSD, *setreuid()*
    and *setregid()* permitted a process to drop and regain privilege by swapping
    the values of the real and effective IDs back and forth. This had the undesirable
    side effect of changing the real user ID in order to change the effective user
    ID.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
- en: Retrieving real, effective, and saved set IDs
  id: totrans-119
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'On most UNIX implementations, a process can’t directly retrieve (or update)
    its saved set-user-ID and saved set-group-ID. However, Linux provides two (nonstandard)
    system calls allowing us to do just that: *getresuid()* and *getresgid()*.'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Note
  id: totrans-122
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Both return 0 on success, or -1 on error
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
- en: The *getresuid()* system call returns the current values of the calling process’s
    real user ID, effective user ID, and saved set-user-ID in the locations pointed
    by its three arguments. The *getresgid()* system call does the same for the corresponding
    group IDs.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
- en: Modifying real, effective, and saved set IDs
  id: totrans-125
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The *setresuid()* system call allows the calling process to independently change
    the values of all three of its user IDs. The new values for each of the user IDs
    are specified by the three arguments to the system call. The *setresgid()* system
    call performs the analogous task for the group IDs.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Note
  id: totrans-128
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Both return 0 on success, or -1 on error
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
- en: 'If we don’t want to change all of the identifiers, then specifying -1 for an
    argument leaves the corresponding identifier unchanged. For example, the following
    call is equivalent to *seteuid(x)*:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The rules about what changes may be made by *setresuid()* (*setresgid()* is
    similar) are as follows:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
- en: An unprivileged process can set any of its real user ID, effective user ID,
    and saved set-user-ID to any of the values currently in its current real user
    ID, effective user ID, or saved set-user-ID.
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A privileged process can make arbitrary changes to its real user ID, effective
    user ID, and saved set-user-ID.
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Regardless of whether the call makes any changes to other IDs, the file-system
    user ID is always set to the same value as the (possibly new) effective user ID.
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Calls to *setresuid()* and *setresgid()* have an all-or-nothing effect. Either
    all of the requested identifiers are successfully changed or none are changed.
    (The same comment applies with respect to the other system calls described in
    this chapter that change multiple identifiers.)
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
- en: Although *setresuid()* and *setresgid()* provide the most straightforward API
    for changing process credentials, we can’t portably employ them in applications;
    they are not specified in SUSv3 and are available on only a few other UNIX implementations.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
- en: Retrieving and Modifying File-System IDs
  id: totrans-138
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'All of the previously described system calls that change the process’s effective
    user or group ID also always change the corresponding file-system ID. To change
    the file-system IDs independently of the effective IDs, we must employ two Linux-specific
    system calls: *setfsuid()* and *setfsgid()*.'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Note
  id: totrans-141
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Always returns the previous file-system user ID
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Note
  id: totrans-144
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Always returns the previous file-system group ID
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
- en: The *setfsuid()* system call changes the file-system user ID of a process to
    the value specified by *fsuid*. The *setfsgid()* system call changes the file
    system group ID to the value specified by *fsgid*.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
- en: 'Again, there are rules about the kind of changes that can be made. The rules
    for *setfsgid()* are similar to the rules for *setfsuid()*, which are as follows:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
- en: An unprivileged process can set the file-system user ID to the current value
    of the real user ID, effective user ID, file-system user ID (i.e., no change),
    or saved set-user-ID.
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A privileged process can set the file-system user ID to any value.
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The implementation of these calls is somewhat unpolished. To begin with, there
    are no corresponding system calls that retrieve the current value of the file-system
    IDs. In addition, the system calls do no error checking; if an unprivileged process
    attempts to set its file-system ID to an unacceptable value, the attempt is silently
    ignored. The return value from each of these system calls is the previous value
    of the corresponding file-system ID, *whether the call succeeds or fails*. Thus,
    we do have a way of finding out the current values of the file-system IDs, but
    only at the same time as we try (either successfully or unsuccessfully) to change
    them.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
- en: Use of the *setfsuid()* and *setfsgid()* system calls is no longer necessary
    on Linux and should be avoided in applications designed to be ported to other
    UNIX implementations.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
- en: Retrieving and Modifying Supplementary Group IDs
  id: totrans-152
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The *getgroups()* system call returns the set of groups of which the calling
    process is currently a member, in the array pointed to by *grouplist*.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Note
  id: totrans-155
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Returns number of group IDs placed in *grouplist* on success, or -1 on error
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
- en: On Linux, as on most UNIX implementations, *getgroups()* simply returns the
    calling process’s supplementary group IDs. However, SUSv3 also allows an implementation
    to include the calling process’s effective group ID in the returned *grouplist*.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
- en: The calling program must allocate the *grouplist* array and specify its length
    in the argument *gidsetsize*. On successful completion, *getgroups()* returns
    the number of group IDs placed in *grouplist*.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
- en: 'If the number of groups of which a process is a member exceeds *gidsetsize*,
    *getgroups()* returns an error (`EINVAL`). To avoid this possibility, we can size
    the *grouplist* array to be one greater (to portably allow for the possible inclusion
    of the effective group ID) than the constant `NGROUPS_MAX` (defined in `<limits.h>`),
    which defines the maximum number of supplementary groups of which a process may
    be a member. Thus, we could declare *grouplist* as follows:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: In Linux kernels prior to 2.6.4, `NGROUPS_MAX` has the value 32\. From kernel
    2.6.4 onward, `NGROUPS_MAX` has the value 65,536.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
- en: 'An application can also determine the `NGROUPS_MAX` limit at run time in the
    following ways:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
- en: Call *sysconf(_SC_NGROUPS_MAX)*. (We explain the use of *sysconf ()* in Section
    11.2.)
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Read the limit from the read-only, Linux-specific `/proc/sys/kernel/ngroups_max`
    file. This file is provided since kernel 2.6.4.
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Alternatively, an application can make a call to *getgroups()* specifying *gidtsetsize*
    as 0\. In this case, *grouplist* is not modified, but the return value of the
    call gives the number of groups of which the process is a member.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
- en: The value obtained by any of these run-time techniques can then be used to dynamically
    allocate a *grouplist* array for a future *getgroups()* call.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
- en: A privileged process can use *setgroups()* and *initgroups()* to change its
    set of supplementary group IDs.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Note
  id: totrans-169
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Both return 0 on success, or -1 on error
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
- en: The *setgroups()* system call replaces the calling process’s supplementary group
    IDs with the set given in the array *grouplist*. The *gidsetsize* argument specifies
    the number of group IDs in the array argument *grouplist*.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
- en: The *initgroups()* function initializes the calling process’s supplementary
    group IDs by scanning `/etc/groups` and building a list of all groups of which
    the named *user* is a member. In addition, the group ID specified in *group* is
    also added to the process’s set of supplementary group IDs.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
- en: The primary users of *initgroups()* are programs that create login sessions—for
    example, *login(1)*, which sets various process attributes prior to executing
    the user’s login shell. Such programs typically obtain the value to be used for
    the *group* argument by reading the group ID field from the user’s record in the
    password file. This is slightly confusing, since the group ID from the password
    file is not really a supplementary group, Instead, it defines the initial real
    group ID, effective group ID, and saved set-group-ID of the login shell. Nevertheless,
    this is how *initgroups()* is usually employed.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
- en: Although not part of SUSv3, *setgroups()* and *initgroups()* are available on
    all UNIX implementations.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
- en: Summary of Calls for Modifying Process Credentials
  id: totrans-175
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[Table 9-1](ch09.html#summary_of_interfaces_used_to_change_pro "Table 9-1. Summary
    of interfaces used to change process credentials") summarizes the effects of the
    various system calls and library functions used to change process credentials.'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 9-1](ch09.html#effect_of_credential-changing_functions "Figure 9-1. Effect
    of credential-changing functions on process user IDs") provides a graphical overview
    of the same information given in [Table 9-1](ch09.html#summary_of_interfaces_used_to_change_pro
    "Table 9-1. Summary of interfaces used to change process credentials"). This diagram
    shows things from the perspective of the calls that change the user IDs, but the
    rules for changes to the group IDs are similar.'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
- en: '![Effect of credential-changing functions on process user IDs](figs/web/09-1_PROCCRED-uid-functions.png.jpg)Figure 9-1. Effect
    of credential-changing functions on process user IDsTable 9-1. Summary of interfaces
    used to change process credentials'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
- en: '| Interface | Purpose and effect within: | Portability |'
  id: totrans-179
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  id: totrans-180
  prefs: []
  type: TYPE_TB
- en: '| unprivileged process | privileged process |'
  id: totrans-181
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  id: totrans-182
  prefs: []
  type: TYPE_TB
- en: '| *setuid(u) setgid(g)* | Change effective ID to the same value as current
    real or saved set ID | Change real, effective, and saved set IDs to any (single)
    value | Specified in SUSv3; BSD derivatives have different semantics |'
  id: totrans-183
  prefs: []
  type: TYPE_TB
- en: '| *seteuid(e) setegid(e)* | Change effective ID to the same value as current
    real or saved set ID | Change effective ID to any value | Specified in SUSv3 |'
  id: totrans-184
  prefs: []
  type: TYPE_TB
- en: '| *setreuid(r, e) setregid(r, e)* | (Independently) change real ID to same
    value as current real or effective ID, and effective ID to same value as current
    real, effective, or saved set ID | (Independently) change real and effective IDs
    to any values | Specified in SUSv3, but operation varies across implementations
    |'
  id: totrans-185
  prefs: []
  type: TYPE_TB
- en: '| *setresuid(r, e, s) setresgid(r, e, s)* | (Independently) change real, effective,
    and saved set IDs to same value as current real, effective, or saved set ID |
    (Independently) change real, effective, and saved set IDs to any values | Not
    in SUSv3 and present on few other UNIX implementations |'
  id: totrans-186
  prefs: []
  type: TYPE_TB
- en: '| *setfsuid(u) setfsgid(u)* | Change file-system ID to same value as current
    real, effective, file system, or saved set ID | Change file-system ID to any value
    | Linux-specific |'
  id: totrans-187
  prefs: []
  type: TYPE_TB
- en: '| *setgroups(n, l)* | Can’t be called from an unprivileged process | Set supplementary
    group IDs to any values | Not in SUSv3, but available on all UNIX implementations
    |'
  id: totrans-188
  prefs: []
  type: TYPE_TB
- en: 'Note the following supplementary information to [Table 9-1](ch09.html#summary_of_interfaces_used_to_change_pro
    "Table 9-1. Summary of interfaces used to change process credentials"):'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
- en: The *glibc* implementations of *seteuid()* (as *setresuid(-1, e, -1)*) and *setegid()*
    (as *setregid(-1, e)*) also allow the effective ID to be set to the same value
    it already has, but this is not specified in SUSv3\. The *setegid()* implementation
    also changes the saved set-group-ID if the effective group ID is set to a value
    other than that of the current real group ID. (SUSv3 doesn’t specify that *setegid()*
    makes changes to the saved set-group-ID.)
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For calls to *setreuid()* and *setregid()* by both privileged and unprivileged
    processes, if *r* is not -1, or *e* is specified as a value different from the
    real ID prior to the call, then the saved set-user-ID or saved set-group-ID is
    also set to the same value as the (new) effective ID. (SUSv3 doesn’t specify that
    *setreuid()* and *setregid()* make changes to the saved set IDs.)
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Whenever the effective user (group) ID is changed, the Linux-specific file-system
    user (group) ID is changed to the same value.
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Calls to *setresuid()* always modify the file-system user ID to have the same
    value as the effective user ID, regardless of whether the effective user ID is
    changed by the call. Calls to *setresgid()* have an analogous effect on the file-system
    group ID.
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Example: Displaying Process Credentials'
  id: totrans-194
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The program in [Example 9-1](ch09.html#display_all_process_user_and_group_ids
    "Example 9-1. Display all process user and group IDs") uses the system calls and
    library functions described in the preceding pages to retrieve all of the process’s
    user and group IDs, and then displays them.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
- en: Example 9-1. Display all process user and group IDs
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Summary
  id: totrans-198
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Each process has a number of associated user and group IDs (credentials). The
    real IDs define the ownership of the process. On most UNIX implementations, the
    effective IDs are used to determine a process’s permissions when accessing resources
    such as files. On Linux, however, the file-system IDs are used for determining
    permissions for accessing files, while the effective IDs are used for other permission
    checks. (Because the file-system IDs normally have the same values as the corresponding
    effective IDs, Linux behaves in the same way as other UNIX implementations when
    checking file permissions.) A process’s supplementary group IDs are a further
    set of groups of which the process is considered to be a member for the purpose
    of permission checking. Various system calls and library functions allow a process
    to retrieve and change its user and group IDs.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
- en: When a set-user-ID program is run, the effective user ID of the process is set
    to that of the owner of the file. This mechanism allows a user to assume the identity,
    and thus the privileges, of another user while running a particular program. Correspondingly,
    set-group-ID programs change the effective group ID of the process running a program.
    The saved set-user-ID and saved set-group-ID allow set-user-ID and set-group-ID
    programs to temporarily drop and then later reassume privileges.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
- en: The user ID 0 is special. Normally, a single user account, named *root*, has
    this user ID. Processes with an effective user ID of 0 are privileged—that is,
    they are exempt from many of the permission checks normally performed when a process
    makes various system calls (such as those used to arbitrarily change the various
    process user and group IDs).
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
- en: Exercises
  id: totrans-202
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Assume in each of the following cases that the initial set of process user IDs
    is *real=1000 effective=0 saved=0 file-system=0*. What would be the state of the
    user IDs after the following calls?
  id: totrans-203
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*setuid(2000);*'
  id: totrans-204
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '*setreuid(-1, 2000);*'
  id: totrans-205
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '*seteuid(2000);*'
  id: totrans-206
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '*setfsuid(2000);*'
  id: totrans-207
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '*setresuid(-1, 2000, 3000);*'
  id: totrans-208
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Is a process with the following user IDs privileged? Explain your answer.
  id: totrans-209
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-210
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Implement *initgroups()* using *setgroups()* and library functions for retrieving
    information from the password and group files ([Retrieving User and Group Information](ch08.html#retrieving_user_and_group_information
    "Retrieving User and Group Information")). Remember that a process must be privileged
    in order to be able to call *setgroups()*.
  id: totrans-211
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'If a process whose user IDs all have the value *X* executes a set-user-ID program
    whose user ID, *Y*, is nonzero, then the process credentials are set as follows:'
  id: totrans-212
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-213
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '(We ignore the file-system user ID, since it tracks the effective user ID.)
    Show the *setuid()*, *seteuid()*, *setreuid()*, and *setresuid()* calls, respectively,
    that would be used to perform the following operations:'
  id: totrans-214
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Suspend and resume the set-user-ID identity (i.e., switch the effective user
    ID to the value of the real user ID and then back to the saved set-user-ID).
  id: totrans-215
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Permanently drop the set-user-ID identity (i.e., ensure that the effective user
    ID and the saved set-user-ID are set to the value of the real user ID).
  id: totrans-216
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: (This exercise also requires the use of *getuid()* and *geteuid()* to retrieve
    the process’s real and effective user IDs.) Note that for certain of the system
    calls listed above, some of these operations can’t be performed.
  id: totrans-217
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Repeat the previous exercise for a process executing a set-user-ID-*root* program,
    which has the following initial set of process credentials:'
  id: totrans-218
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-219
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
