["```\napp.add_url_rule('/graphql', view_func=GraphQLView.as_view(\n  'graphql',\n  schema=schema\n))\n\napp.add_url_rule('/graphiql', view_func=GraphQLView.as_view(\n  'graphiql',\n  schema = schema,\n  graphiql = True\n))\n```", "```\n**query {**\n **pastes {**\n **id**\n **}**\n**}**\n```", "```\n \"data\": {\n     \"pastes\": [\n      {\n \"id\": \"1\"\n      }\n    ]\n  }\n```", "```\n**query {**\n **badfield {**\n **id**\n **}**\n**}**\n```", "```\n{\n   \"errors\": [\n    {\n       \"message\": \"Cannot query field \\\"badfield\\\" on type \\\"Query\\\".\",\n      \"locations\": [\n        {\n          \"line\": 2,\n          \"column\": 3\n        }\n      ]\n    },\n  ]\n}\n```", "```\n# **curl -X GET http://localhost:5013/graphql**\n\n{\"errors\":[{\"message\":\"Must provide query string.\"}]}\n```", "```\n# **nmap -p 5013 -sV --script=http-grep**\n**--script-args='match=\"Must provide query string\",** ❶ **http-grep.url=\"/graphql\"' localhost** ❷\n\nPORT     STATE SERVICE VERSION\n5013/tcp open  http    Werkzeug httpd\n| http-grep:\n|   (1) http://localhost:5013/graphql:\n|       (1) User Pattern 1:\n|       + Must provide query string\n```", "```\nquery {\n  pastes {\n    __typename\n  }\n}\n```", "```\n \"data\": {\n    \"pastes\": [\n      {\n        \"__typename\": \"PasteObject\"\n      }\n    ]\n  }\n```", "```\nquery {\n  __typename\n}\n```", "```\n# **nmap -p 5013 -sV --script=http-grep --script-args='match=\"__typename\",**\n**http-grep.url=\"/graphql?query=\\{__typename\\}\"' localhost**\n\nPORT     STATE SERVICE VERSION\n5013/tcp open  http    Werkzeug httpd\n| http-grep:\n|   (1) http://localhost:5013/graphql?query=\\{__typename\\}:\n|     (1) User Pattern 1:\n|_      + __typename\n```", "```\n# **nmap -p 5013 -iL hosts.txt -sV --script=http-grep**\n**--script-args='match=\"__typename\", http-grep.url=\"/graphql?query=\\{__typename\\}\"'**\n```", "```\n# **curl -X POST http://localhost:5013/graphql -d '{\"query\":\"{__typename }\"}'**\n**-H \"Content-Type: application/json\"**\n```", "```\n# **for host in $(cat hosts.txt); do**\n **curl -X POST \"$host\" -d '{\"query\":\"{__typename }\"}' -H \"Content-Type: application/json\"**\n**done**\n```", "```\ndef possible_graphql_paths():\n    return [\n        '/graphql',\n  `--snip--`\n        '/console',\n        '/playground',\n        '/gql',\n        '/query',\n `--snip--`\n    ]\n```", "```\n# **cd ~/graphw00f**\n# **python3 main.py -d -t http://localhost:5013**\n\n                      graphw00f\n          The fingerprinting tool for GraphQL\n\n [*] Checking http://localhost:5013/\n [*] Checking http://localhost:5013/graphql\n [!] Found GraphQL at http://localhost:5013/graphql\n```", "```\n# **cat wordlist.txt**\n\n/app/graphql\n/dev/graphql\n/v5/graphql\n\n# **python3 main.py -d -t http://localhost:5013 -w wordlist.txt**\n\n[*] Checking http://localhost:5013/app/graphql\n[*] Checking http://localhost:5013/dev/graphql\n[*] Checking http://localhost:5013/v5/graphql\n```", "```\n# **eyewitness --web --single http://localhost:5013/graphiql -d dvga-report**\n\nAttempting to screenshot http://localhost:5013/graphiql\n\n [*] Done! Report written in the dvga-report folder!\n Would you like to open the report now? [Y/n]\n```", "```\n# **ls -l dvga-report/**\ntotal 112\n-rw-r--r-- 1 kali kali 95957 Dec 15 15:19 jquery.min.js\n-rw-r--r-- 1 kali kali  2356 Feb 11 15:10 report.html\ndrwxr-xr-x 2 kali kali  4096 Feb 11 15:09 screens\ndrwxr-xr-x 2 kali kali  4096 Feb 11 15:09 source\n-rw-r--r-- 1 kali kali   684 Feb 11 15:09 style.css\n```", "```\n# **grep -Hnio \"graphiql|graphql-playground\" dvga-report/source/***\nsource/http.localhost.5013.graphiql.txt:18:graphiql\nsource/http.localhost.5013.graphiql.txt:18:graphiql\nsource/http.localhost.5013.graphiql.txt:18:graphiql\n```", "```\n# **echo 'http://localhost:5013/graphiql' > urls.txt**\n# **eyewitness --web -f urls.txt -d dvga-report**\n\nStarting Web Requests (1 Hosts)\nAttempting to screenshot http://localhost:5013/graphiql\nFinished in 8 seconds\n\n[*] Done! Report written in the dvga-report folder!\n```", "```\n# **for i in $(cat /usr/share/wordlists/dirbuster/directory-list-2.3-small.txt);**\n**do echo http://localhost:5013/$i >> urls.txt; done**\n\n# **cat urls.txt**\n\nhttp://localhost:5013/api\nhttp://localhost:5013/apis\nhttp://localhost:5013/apidocs\nhttp://localhost:5013/apilist\n```", "```\n**query {**\n **__schema {**\n **types {**\n **name**\n **}**\n **}**\n**}**\n```", "```\n{\n  \"data\": {\n    \"__schema\": {\n      \"types\": [\n`--snip--`\n        {\n          \"name\": \"PasteObject\"\n        },\n        {\n          \"name\": \"CreatePaste\"\n        },\n        {\n          \"name\": \"DeletePaste\"\n        },\n        {\n          \"name\": \"UploadPaste\"\n        },\n        {\n          \"name\": \"ImportPaste\"\n        },\n`--snip--`\n      ]\n    }\n  }\n}\n```", "``` and `Boolean``), and so on. These are important, because queries that accept arguments could be prone to vulnerabilities, such as injections, server-side request forgeries, and so on.` ```", "````` ````We can craft a more specialized introspection query that would give us more data about the target application’s schema. A useful introspection query is one that will give us information on the entry points into the application, such as queries, mutations, subscriptions, and the type of data that can be injected into them. Consider the introspection query shown in [Listing 4-18](#listing4-18).    ``` query IntrospectionQuery {    __schema {   ❶ queryType { name }     mutationType { name }     subscriptionType { name }   ❷ types {       kind       name     ❸ fields {        name         ❹ args {           name         }       }     }   } } ```    Listing 4-18: A more useful introspection query    The introspection query in [Listing 4-18](#listing4-18) gives us a bit more insight into the API. At ❶ we get the `name` of all queries (`queryType`), mutations (`mutationType`), and subscriptions (`subscriptionType`) available in the GraphQL API. These names are typically self-explanatory, to make it easier for clients to use the API, so knowing these query names gives us an idea of the information we could receive.    At ❷ we get all the `types` in the schema, along with their `kind` (such as an object) and name (such as `PasteObject`). At ❸ we get the `fields` along with the `name` of each one, which will allow us to know the types of fields we can fetch when we use different GraphQL objects. Next, we get the arguments (`args`) of these fields along with their `name` ❹. Arguments could be any information the API is expecting the client to supply when it queries the API (typically, dynamic data). For example, when a client creates a new paste, it will supply an arbitrary `title` argument and a `content` argument containing the body of the paste, which might be a code snippet or other text.    In penetration tests, you may want to run an introspection query against an entire network, assuming a GraphQL server may be present. In this case, you would either need to write your own script or use the Nmap NSE script *graphql-introspection.nse* we installed in Chapter 2. This script is simple: it queries GraphQL by using the `__schema` meta-field to determine if it’s fetchable.    Say you have a list of IP addresses in a text file such as *hosts.txt*. Using Nmap’s `-iL` flag, you can tell Nmap to use it as its list of targets. Using the `--script` flag, you can then tell Nmap to run the *graphql-introspection* NSE script against any host that has port `5013` open (`-p` flag). The `-sV` flag performs a service and version scan. The command in [Listing 4-19](#listing4-19) shows how this is accomplished.    ``` # **nmap --script=graphql-introspection -iL hosts.txt -sV -p 5013**  PORT     STATE SERVICE VERSION 5013/tcp open  http    Ajenti http control panel | graphql-introspection: |   VULNERABLE: |   GraphQL Server allows Introspection queries at endpoint: |   Endpoint: /graphql is vulnerable to introspection queries! |     State: VULNERABLE |       Checks if GraphQL allows Introspection Queries. | |     References: |_      https://graphql.org/learn/introspection/ ```    Listing 4-19: A GraphQL introspection detection with the Nmap NSE    Using `nmap` to detect when introspection is enabled is just the first step. The next step is to extract all possible schema information by using a more robust query.    In the book’s GitHub repository, you can find a comprehensive introspection query that, when executed, will extract a lot of useful information about the target’s schema: [https://github.com/dolevf/Black-Hat-GraphQL/blob/master/queries/introspection_query.txt](https://github.com/dolevf/Black-Hat-GraphQL/blob/master/queries/introspection_query.txt). This query will return information such as queries, mutations, and subscriptions names, with the arguments they accept; names of objects and fields, along with their types; names and descriptions of GraphQL directives; and object relationships. If you run that query in Altair, the server should return a fairly large response, as shown in [Figure 4-6](#figure4-6).  ![](image_fi/502840c04/f04006.png)    Figure 4-6: An introspection in Altair      The response is large enough (containing approximately 2,000 lines) that it would be challenging for any human to go through it manually and make sense of it without investing a significant amount of time. This is where GraphQL visualizers such as *GraphQL Voyager* come in handy.    ### Visualizing Introspection with GraphQL Voyager    GraphQL Voyager, which can be found at either [https://ivangoncharov.github.io/graphql-voyager](https://ivangoncharov.github.io/graphql-voyager) or [http://lab.blackhatgraphql.com:9000](http://lab.blackhatgraphql.com:9000), is an open source tool that processes either introspection query responses or GraphQL SDL files and visualizes them, making it easy to identify the various queries, mutations, and subscriptions and the relationships between them.    The tool’s introspection query option is most suitable for scenarios such as black-box penetration tests, in which the application’s code base is not accessible to us. The SDL option is useful when we might have direct access to the GraphQL schema files, such as during a white-box penetration test in which the company provides us with full access to the source code.    Try visualizing the introspection query response you just received in Altair and importing it into GraphQL Voyager. Copy the response and then open your browser and navigate to GraphQL Voyager. Click the **Change Schema** button located at the top-left corner. Select the **Introspection** tab, paste in the response, and click the **Display** button. You should see a visualization similar to the one shown in [Figure 4-7](#figure4-7).  ![](image_fi/502840c04/f04007.png)    Figure 4-7: The schema view in Voyager      The visualization we receive from Voyager represents the queries, mutations, and subscriptions available in our target application and how they relate to the different objects and fields that exist in the schema.    Under Query, you can see that the application supports 12 queries. The arrows in the view represent the mapping between these queries and the schema objects. For example, when you use the `pastes` query, it will return an array of `[PasteObject]` objects, which is also the reason you’re seeing an arrow pointing to the `PasteObject` table. The `system` queries (update, diagnostics, debug, and health) are not tied to any other schema objects; they simply return a string whenever you use them.    You can also see that we have relationships (edges) between fields. For example, the `owner` field in the `PasteObject` object is linked to `OwnerObject`, and the `paste` field in `OwnerObject` is linked back to `PasteObject`. This circular condition could lead to DoS conditions, as you will learn in Chapter 5.    Now that we’ve experimented with visualizing an introspection response in Voyager, let’s do the same with SDL files. Voyager accepts SDL files and can process them just as well as it does introspection responses. To see this in action, click the **Change Schema** button located at the top-left corner in Voyager, select the **SDL** tab, and paste in the SDL file located at [https://github.com/dolevf/Black-Hat-GraphQL/blob/master/ch04/sdl.graphql](https://github.com/dolevf/Black-Hat-GraphQL/blob/master/ch04/sdl.graphql). Then click the **Display** button. You should see a similar visualization to the one generated in the Introspection tab.    ### Generating Introspection Documentation with SpectaQL    *SpectaQL* ([https://github.com/anvilco/spectaql](https://github.com/anvilco/spectaql)) is an open source project that allows you to generate static documentation based on an SDL file. The document that gets generated will include information about how to construct queries, mutations, and subscriptions; the different types; and their fields. We’ve hosted an example SpectaQL-generated schema of DVGA at [http://lab.blackhatgraphql.com:9001](http://lab.blackhatgraphql.com:9001) so you can see how SpectaQL looks when it’s functional.    ### Exploring Disabled Introspection    At some point, you’ll probably encounter a GraphQL API that has introspection disabled. To see what this looks like, let’s use one of the neat features of our vulnerable GraphQL server: turning on its hardened mode.    The DVGA works in two modes, a Beginner mode and an Expert (hardened) mode. Both versions are vulnerable; the only difference is that the Expert mode has a few security mechanisms to protect the application from any dangerous queries.    To change the application’s mode, open the Altair client and ensure that the address points to *http://localhost:5013/graphql*. In the left sidebar, click the Set Headers icon, which looks like a small sun symbol. Set **Header Key** to **X-DVGA-MODE** and set **Header Value** to **Expert**. This HTTP header set instructs DVGA to perform security checks on any incoming queries that include the headers as part of the request. Alternatively, you can toggle on Expert mode from within DVGA’s web interface by using the drop-down menu located at the top-right corner (the cubes icon).    Now attempt a simple introspection query using Altair:    ``` **query {**  **__schema {**  **__typename**  **}** **}** ```    You should see an error response indicating that introspection is disabled, causing the query to fail ([Listing 4-20](#listing4-20)).    ``` {   \"errors\": [     {       \"message\": \"400 Bad Request: Introspection is Disabled\",       \"locations\": [         {           \"line\": 2,           \"column\": 7         }       ],       \"path\": [         \"__schema\"       ]     }   ],   \"data\": null } ```    Listing 4-20: An error returned when introspection is disabled    In cases like this one, you’ll need a plan B. In Chapter 6, you’ll learn how to discover information about the GraphQL application even if introspection data isn’t available.    ## Fingerprinting GraphQL    Earlier in this chapter, we highlighted the many GraphQL implementations available. How can we tell which one is running on the server we’re trying to hack? The answer is *server* *fingerprinting*, the operation of identifying information about the target’s running services and their versions. For example, a common and simple technique for fingerprinting web servers is to make an HTTP HEAD request using a tool like cURL and observe the HTTP response headers that are returned.    Once we know the specific technology and version running an application, we can perform a more accurate vulnerability assessment against the service. For example, we can look for publicly available exploits to run against the target’s version or read the software’s documentation to identify weaknesses.    Popular web servers such as Apache or Nginx are great examples of services that are easy to fingerprint, since both typically set the `server` HTTP response header when a client makes a request to them. [Listing 4-21](#listing4-21) shows an example of how the web server behind the Apache Software Foundation website identifies itself by using the `server` header:    ``` # **curl -I https://apache.org/**  HTTP/2 200 server: Apache vary: Accept-Encoding content-length: 73190 ```    Listing 4-21: The Apache web server fingerprinting using a HEAD request    As expected, the Apache Software Foundation’s website is, in fact, running on the Apache web server. (It would have been a little odd if this were not the case!)    Fingerprinting services in a penetration test won’t always be this easy; sometimes accurate fingerprinting requires looking closely at the details, as not all software self-identifies, including GraphQL servers. The techniques used to fingerprint GraphQL implementations are relatively new in the security industry. We (the authors of this book) have developed several strategies for doing so, based on our research, and incorporated them into Graphw00f.    GraphQL fingerprinting relies on the observation of various discrepancies between implementations of GraphQL servers. Here are a few examples:    *   Inconsistencies in error messages *   Inconsistencies in response outputs to malformed GraphQL queries *   Inconsistencies in response outputs to properly structured queries *   Inconsistencies in response outputs to queries deviating from the GraphQL specification    Using all four of these factors, we can uniquely identify the implementation behind a GraphQL-backed application.    Let’s examine how two GraphQL server implementations respond to a malformed query. This query, shown in [Listing 4-22](#listing4-22), introduces an additional `y` character in the word `queryy`, which is not compliant with the GraphQL specification. We want to see how two GraphQL implementations respond to it. The first implementation is Sangria, a Scala-based GraphQL server.    ``` queryy {    __typename } ```    Listing 4-22: A malformed GraphQL query    [Listing 4-23](#listing4-23) shows Sangria’s response to the malformed query.    ``` {   \"syntaxError\": \"Syntax error while parsing GraphQL query.   Invalid input \\\"queryy\\\", expected ExecutableDefinition or   TypeSystemDefinition (line 1, column 1):\\nqueryy {\\n^\",   \"locations\": [     {       \"line\": 1,       \"column\": 1     }   ] } ```    Listing 4-23: Sangria’s response to the malformed query    The second implementation is HyperGraphQL, a Java-based GraphQL server. [Listing 4-24](#listing4-24) shows how it responds to the malformed query.    ``` {   \"extensions\": {},   \"errors\": [     {       \"message\": \"Validation error of type InvalidSyntax: Invalid query syntax.\",       \"locations\": [         {           \"line\": 0,           \"column\": 0,           \"sourceName\": null         }       ],       \"description\": \"Invalid query syntax.\",       \"validationErrorType\": \"InvalidSyntax\",       \"queryPath\": null,       \"errorType\": \"ValidationError\",       \"extensions\": null,       \"path\": null     }   ] } ```    Listing 4-24: HyperGraphQL’s response to the malformed query    As you can observe, the two responses are different in every possible way, and we can distinguish between these implementations based solely on their responses.    Next, we’ll attempt the same malformed query in our lab against the DVGA to see the kind of response we get. Open the Altair client and send the GraphQL query. You should see output similar to [Figure 4-8](#figure4-8).    As you can see, the output is different from both the Sangria and HyperGraphQL responses. This is because DVGA is based on Graphene, a Python GraphQL implementation.  ![](image_fi/502840c04/f04008.png)    Figure 4-8: Sending a malformed query with Altair      Running queries manually and analyzing the discrepancies between implementations doesn’t really scale well, which is why we built a server fingerprinting capability into Graphw00f. In the next section, we’ll use it for server fingerprinting purposes.    ### Detecting Servers with Graphw00f    Graphw00f is currently the only tool available for GraphQL server fingerprinting. It can detect many of the popular GraphQL server implementations and provide meaningful information whenever it successfully fingerprints a server.    In your lab, open the terminal emulator. If you enter the *graphw00f* directory and run `python3 main.py -l`, you’ll see that Graphw00f is capable of fingerprinting over 24 GraphQL implementations. This list comprises the majority of GraphQL targets currently in use.    Let’s use it to fingerprint the DVGA. We’ll run Graphw00f with the `-f` flag to enable fingerprint mode and the `-t` flag to specify the target ([Listing 4-25](#listing4-25)). You could combine the `-f` flag with the `-d` flag (covered earlier in this chapter) if you wanted to detect GraphQL and fingerprint at the same time. Here, we’ll use the `-f` flag on its own, as we already know the path to GraphQL on the server.    ``` # **cd ~/graphw00f** # **python3 main.py -f -t http://localhost:5013/graphql**    [*] Checking if GraphQL is available at http://localhost:5013/graphql...   [!] Found GraphQL.   [*] Attempting to fingerprint...  [*] Discovered GraphQL Engine: (Graphene)   [!] Attack Surface Matrix: https://github.com/nicholasaleks   /graphql-threat-matrix/blob/master/implementations/graphene.md   [!] Technologies: Python   [!] Homepage: https://graphene-python.org   [*] Completed. ```    Listing 4-25: The fingerprinting of a GraphQL server    The tool first checks whether the target is, in fact, a GraphQL server. It does so by sending a few queries and inspecting their responses against its own database of signatures. As you can see, it is able to discover a GraphQL server running on Graphene and provides us with an attack surface matrix link. The *attack surface matrix* is essentially knowledge about the security posture of the various GraphQL implementations that Graphw00f can fingerprint. Graphw00f uses the GraphQL Threat Matrix we discussed in Chapter 3 as its implementation security posture database.    Since we now know that DVGA runs Graphene, we need to analyze Graphene’s weaknesses to determine which attacks we can run against this specific implementation. Some implementations have been around longer than others. Thus, they are more mature, stable, and offer more security features than others. This is why knowing the backend implementation is an advantage when we hack a GraphQL target.    ### Analyzing Results    Take a look at the attack surface threat matrix, which provides information about the implementation’s default behavior and the security controls available for it (for example, the settings that are enabled by default, the security controls that exist, and other useful features we can leverage for hacking purposes). [Figure 4-9](#figure4-9) shows the attack surface matrix for Graphene. You can also find it on GitHub at [https://github.com/nicholasaleks/graphql-threat-matrix/blob/master/implementations/graphene.md](https://github.com/nicholasaleks/graphql-threat-matrix/blob/master/implementations/graphene.md).  ![](image_fi/502840c04/f04009.png)    Figure 4-9: Graphene’s attack surface matrix      The table under Security Considerations shows various GraphQL features and whether they are available in Graphene. If they do exist, the table lists whether they are enabled or disabled by default. Some of the items in the table are security controls, while others are native GraphQL features:    *   *Field Suggestions* informs a client whenever they send a query with a spelling mistake and suggests alternative options. This can be leveraged for information disclosure. *   *Query Depth Limit* is a security control to prevent DoS attacks that may abuse conditions such as cyclical node relationships in schemas. *   *Query Cost Analysis* is a security control to prevent DoS attacks that stem from computationally complex queries. *   *Automatic Persisted Queries* is a caching mechanism. It allows the client to pass a hash representing a query as a way to save bandwidth and can be used as a security control with an allow list of safe queries. *   *Introspection* provides access to information about queries, mutations, subscriptions, fields, objects, and so on through the __`schema` meta-field. This can be abused to disclose information about the application’s schema. *   *Debug Mode* is a mode in GraphQL that provides additional information in the response for debugging purposes. This can potentially introduce information disclosure issues. *   *Batch Requests* is a feature that provides clients with the ability to send a sequence of queries in a single HTTP request. Batch queries are a great vector for DoS attacks.    In later chapters, you’ll learn how each of these features can make our hacking lives easier (or harder).    ## Summary    In this chapter, you learned the art of performing reconnaissance against GraphQL servers by using a variety of security tools. We discussed how to detect and fingerprint GraphQL servers deployed in standard and nonstandard locations, as well as how to find GraphQL IDE clients by using the EyeWitness security tool. We also visualized an introspection query and SDL files by using GraphQL Voyager to better understand queries, mutations, and object relationships.```` `````"]