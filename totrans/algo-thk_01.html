<html><head></head><body>
<h2 class="h2" id="ch01"><span epub:type="pagebreak" id="page_1"/><strong><span class="big">1</span><br/>HASH TABLES</strong></h2>
<div class="image1"><img alt="Image" src="../images/common01.jpg"/></div>
<p class="noindent">It’s amazing how often computer programs need to search for information, whether it’s to find a user’s profile in a database or to retrieve a customer’s orders. No one likes waiting for a slow search to complete.</p>
<p class="indent">In this chapter, we’ll solve two problems whose solutions hinge on being able to perform efficient searches. The first problem is determining whether or not all snowflakes in a collection are identical. The second is determining how many passwords can be used to log in to someone’s account. We want to solve these problems correctly, but we’ll see that some correct approaches are simply too slow. We’ll be able to achieve enormous performance increases using a data structure known as a hash table, which we’ll explore at length.</p>
<p class="indent">We’ll end the chapter by looking at a third problem: determining how many ways a letter can be deleted from one word to arrive at another. Here we’ll see the risks of uncritically using a new data structure—when learning something new, it’s tempting to try to use it everywhere!</p>
<h3 class="h3" id="lev11">Problem 1: Unique Snowflakes</h3>
<p class="noindent">This is DMOJ problem <code>cco07p2</code>.</p>
<h4 class="h4" id="sec7"><span epub:type="pagebreak" id="page_2"/><em>The Problem</em></h4>
<p class="noindent">We’re given a collection of snowflakes, and we have to determine whether any of the snowflakes in the collection are identical.</p>
<p class="indent">A snowflake is represented by six integers, where each integer gives the length of one of the snowflake’s arms. For example, this is a snowflake:</p>
<pre>3, 9, 15, 2, 1, 10</pre>
<p class="indent">Snowflakes can also have repeated integers, such as</p>
<pre>8, 4, 8, 9, 2, 8</pre>
<p class="indent">What does it mean for two snowflakes to be identical? Let’s work up to that definition through a few examples.</p>
<p class="indent">First, we’ll look at these two snowflakes:</p>
<pre>1, 2, 3, 4, 5, 6</pre>
<p class="noindent">and</p>
<pre>1, 2, 3, 4, 5, 6</pre>
<p class="indent">These are clearly identical because the integers in one snowflake match the integers in their corresponding positions in the other snowflake.</p>
<p class="indent">Here’s our second example:</p>
<pre>1, 2, 3, 4, 5, 6</pre>
<p class="noindent">and</p>
<pre>4, 5, 6, 1, 2, 3</pre>
<p class="noindent">These are also identical. We can see this by starting at the <code>1</code> in the second snowflake and moving right. We see the integers <code>1</code>, <code>2</code>, and <code>3</code> and then, wrapping around to the left, we see <code>4</code>, <code>5</code>, and <code>6</code>. These two pieces together give us the first snowflake.</p>
<p class="indent">We can think of each snowflake as a circle as in <a href="ch01.xhtml#ch01fig01">Figure 1-1</a>.</p>
<div class="image"><img alt="Image" id="ch01fig01" src="../images/ch01fig01.jpg"/></div>
<p class="figcap"><em>Figure 1-1: Two identical snowflakes</em></p>
<p class="indent">The two snowflakes are identical because we can start at the <code>1</code> in the second snowflake and follow it clockwise to get the first snowflake.</p>
<p class="indent">Let’s try a different kind of example:</p>
<pre>1, 2, 3, 4, 5, 6</pre>
<p class="noindent"><span epub:type="pagebreak" id="page_3"/>and</p>
<pre>3, 2, 1, 6, 5, 4</pre>
<p class="indent">From what we’ve seen so far, we would deduce that these are not identical. If we start with the <code>1</code> in the second snowflake and move right (wrapping around to the left when we hit the right end), we get <code>1, 6, 5, 4, 3, 2</code>. That’s not even close to the <code>1, 2, 3, 4, 5, 6</code> in the first snowflake.</p>
<p class="indent">However, if we begin at the <code>1</code> in the second snowflake and move left instead of right, then we do get exactly <code>1, 2, 3, 4, 5, 6</code>! Moving left from the <code>1</code> gives us <code>1, 2, 3</code>, and wrapping around to the right, we can proceed leftward to collect <code>4, 5, 6</code>. In <a href="ch01.xhtml#ch01fig02">Figure 1-2</a>, this corresponds to starting at the <code>1</code> in the second snowflake and moving counterclockwise.</p>
<div class="image"><img alt="Image" id="ch01fig02" src="../images/ch01fig02.jpg"/></div>
<p class="figcap"><em>Figure 1-2: Two other identical snowflakes</em></p>
<p class="indent">That’s our third way for two snowflakes to be identical: two snowflakes are identical if they match when we move counterclockwise through the numbers.</p>
<p class="indent">Putting it all together, we can conclude that two snowflakes are identical if they are the same, if we can make them the same by moving rightward through one of the snowflakes (moving clockwise), or if we can make them the same by moving leftward through one of the snowflakes (moving counterclockwise).</p>
<h5 class="h5">Input</h5>
<p class="noindent">The first line of input is an integer <em>n</em>, the number of snowflakes that we’ll be processing. The value <em>n</em> will be between 1 and 100,000. Each of the following <em>n</em> lines represents one snowflake: each line has six integers, where each integer is at least 0 and at most 10,000,000.</p>
<h5 class="h5">Output</h5>
<p class="noindent">Our output will be a single line of text:</p>
<ul>
<li class="noindent">If there are no identical snowflakes, output exactly <code>No two snowflakes are alike.</code></li>
<li class="noindent">If there are at least two identical snowflakes, output exactly <code>Twin snowflakes found.</code></li></ul>
<p class="indent">The time limit for solving the test cases is one second.</p>
<h4 class="h4" id="sec8"><span epub:type="pagebreak" id="page_4"/><em>Simplifying the Problem</em></h4>
<p class="noindent">One general strategy for solving competitive programming challenges is to first work with a simpler version of the problem. Let’s warm up by eliminating some of the complexity from this problem.</p>
<p class="indent">Suppose that instead of working with snowflakes made of multiple integers, we’re working with single integers. We have a collection of integers, and we want to know whether any are identical. We can test whether two integers are identical with C’s <code>==</code> operator. We can test all pairs of integers, and if we find even one pair of identical integers, we’ll stop and output</p>
<pre>Twin integers found.</pre>
<p class="indent">If no identical integers are found, we’ll output</p>
<pre>No two integers are alike.</pre>
<p class="indent">Let’s make an <code>identify_identical</code> function with two nested loops to compare pairs of integers, as shown in <a href="ch01.xhtml#ch01ex01">Listing 1-1</a>.</p>
<pre>void identify_identical(int values[], int n) {
  int i, j;
  for (i = 0; i &lt; n; i++) {
  <span class="ent">❶</span> for (j = i + 1; j &lt; n; j++) {
       if (values[i] == values[j]) {
         printf("Twin integers found.\n");
         return;
       }
     }
 }
 printf("No two integers are alike.\n");
}</pre>
<p class="excap" id="ch01ex01"><em>Listing 1-1: Finding identical integers</em></p>
<p class="indent">We feed the integers to the function through the <code>values</code> array. We also pass in <code>n</code>, the number of integers in the array.</p>
<p class="indent">Notice that we start the inner loop at <code>i + 1</code> and not <code>0</code> <span class="ent">❶</span>. If we started at <code>0</code>, then eventually <code>j</code> would equal <code>i</code>, and we’d compare an element to itself, giving us a false positive result.</p>
<p class="indent">Let’s test <code>identify_identical</code> using this small <code>main</code> function:</p>
<pre>int main(void) {
  int a[5] = {1, 2, 3, 1, 5};
  identify_identical(a, 5);
  return 0;
}</pre>
<p class="indent">Run the code and you will see from the output that our function correctly identified a matching pair of <code>1</code>s. In general, I won’t provide much test <span epub:type="pagebreak" id="page_5"/>code in this book, but it’s important that you play with and test the code yourself as we go along.</p>
<h4 class="h4" id="sec9"><em>Solving the Core Problem</em></h4>
<p class="noindent">Let’s take our <code>identify_identical</code> function and try to modify it to solve the Snowflake problem. To do so, we need to make two extensions to our code:</p>
<ol>
<li class="noindent">We have to work with six integers at a time, not one. A two-dimensional array should work nicely here: each row will be a snowflake with six columns (one column per element).</li>
<li class="noindent">As we saw earlier, there are multiple ways for two snowflakes to be identical. Unfortunately, this means we can’t just use <code>==</code> to compare snowflakes. We need to take into account our “moving right” and “moving left” criteria (not to mention that <code>==</code> in C doesn’t compare contents of arrays anyway!). Correctly comparing snowflakes will be the major update to our algorithm.</li>
</ol>
<p class="indent">To begin, let’s write a pair of helper functions: one for checking “moving right” and one for checking “moving left.” Each of these helpers takes three parameters: the first snowflake, the second snowflake, and the starting point for the second snowflake.</p>
<h5 class="h5">Checking to the Right</h5>
<p class="noindent">Here is the function signature for <code>identical_right</code>:</p>
<pre>int identical_right(int snow1[], int snow2[], int start)</pre>
<p class="indent">To determine whether the snowflakes are the same by “moving right,” we scan <code>snow1</code> from index <code>0</code> and <code>snow2</code> from index <code>start</code>. If we find corresponding elements that are not equal, then we return <code>0</code> to signify that we haven’t found identical snowflakes. If all the corresponding elements do match, then we return <code>1</code>. Think of <code>0</code> as representing false and <code>1</code> as representing true.</p>
<p class="indent">In <a href="ch01.xhtml#ch01ex02">Listing 1-2</a> we make a first attempt at writing this function’s code.</p>
<pre>// bugged!
int identical_right(int snow1[], int snow2[], int start) {
  int offset;
  for (offset = 0; offset &lt; 6; offset++) {
 <span class="ent">❶</span> if (snow1[offset] != snow2[start + offset])
      return 0;
 }
 return 1;
}</pre>
<p class="excap" id="ch01ex02"><em>Listing 1-2: Identifying identical snowflakes moving right (bugged!)</em></p>
<p class="indent">As you may notice, this code won’t work as we hope. The problem is <code>start + offset</code> <span class="ent">❶</span>. If we have <code>start = 4</code> and <code>offset = 3</code>, then <code>start + offset = 7</code>. <span epub:type="pagebreak" id="page_6"/>The trouble is <code>snow2[7]</code>, as <code>snow2[5]</code> is the farthest index to which we are allowed to go.</p>
<p class="indent">This code doesn’t take into account that we must wrap around to the left of <code>snow2</code>. If our code is about to use an erroneous index of <code>6</code> or greater, we should reset our index by subtracting six. This will let us continue with index <code>0</code> instead of index <code>6</code>, index <code>1</code> instead of index <code>7</code>, and so on. Let’s try again with <a href="ch01.xhtml#ch01ex03">Listing 1-3</a>.</p>
<pre>int identical_right(int snow1[], int snow2[], int start) {
  int offset, snow2_index;
  for (offset = 0; offset &lt; 6; offset++) {
    snow2_index = start + offset;
    if (snow2_index &gt;= 6)
      snow2_index = snow2_index - 6;
        if (snow1[offset] != snow2[snow2_index])
      return 0;
  }
  return 1;
}</pre>
<p class="excap" id="ch01ex03"><em>Listing 1-3: Identifying identical snowflakes moving right</em></p>
<p class="indent">This works, but we can still improve it. One change that many programmers would consider making at this point involves using <code>%</code>, the mod operator. The <code>%</code> operator computes remainders, so <code>x % y</code> returns the remainder of integer-dividing <code>x</code> by <code>y</code>. For example, <code>9 % 3</code> is 0, because there is no remainder when dividing 9 by 3. <code>10 % 4</code> is 2, because 2 is left over when dividing 10 by 4.</p>
<p class="indent">We can use mod here to help with the wraparound behavior. Notice that <code>0 % 6</code> is 0, <code>1 % 6</code> is 1, . . . , <code>5 % 6</code> is 5. Each of these numbers is smaller than 6, and so will itself be the remainder when dividing 6. The numbers 0 to 5 correspond to the legal indices of <code>snow2</code>, so it’s good that <code>%</code> leaves them alone. For our problematic index <code>6</code>, <code>6 % 6</code> is 0: 6 divides 6 evenly, with no remainder at all, wrapping us around to the start. That’s precisely the wraparound behavior we wanted.</p>
<p class="indent">Let’s update <code>identical_right</code> to use the <code>%</code> operator. <a href="ch01.xhtml#ch01ex04">Listing 1-4</a> shows the new function.</p>
<pre>int identical_right(int snow1[], int snow2[], int start) {
  int offset;
  for (offset = 0; offset &lt; 6; offset++) {
    if (snow1[offset] != snow2[(start + offset) % 6])
      return 0;
  }
  return 1;
}</pre>
<p class="excap" id="ch01ex04"><em>Listing 1-4: Identifying identical snowflakes moving right using mod</em><span epub:type="pagebreak" id="page_7"/></p>
<p class="indent">Whether you use this “mod trick” is up to you. It saves a line of code and is a common pattern that many programmers will be able to identify. However, it doesn’t always easily apply, even in cases that exhibit similar wraparound behavior, such as <code>identical_left</code>. Let’s turn to this now.</p>
<h5 class="h5">Checking to the Left</h5>
<p class="noindent">The function <code>identical_left</code> is very similar to <code>identical_right</code>, except that we need to move left and then wrap around to the right. When traversing right, we had to be wary of erroneously accessing index 6 or greater; this time, we have to be wary of accessing index –1 or less.</p>
<p class="indent">Unfortunately, our mod solution won’t directly work here. In C, <code>-1 / 6</code> is 0, leaving a remainder of –1, and so <code>-1 % 6</code> is –1. We’d need <code>-1 % 6</code> to be 5.</p>
<p class="indent">Let’s just do this without using mod. In <a href="ch01.xhtml#ch01ex05">Listing 1-5</a>, we provide the code for the <code>identical_left</code> function.</p>
<pre>int identical_left(int snow1[], int snow2[], int start) {
  int offset, snow2_index;
  for (offset = 0; offset &lt; 6; offset++) {
    snow2_index = start - offset;
    if (snow2_index &lt;= -1)
      snow2_index = snow2_index + 6;
    if (snow1[offset] != snow2[snow2_index])
      return 0;
  }
  return 1;
}</pre>
<p class="excap" id="ch01ex05"><em>Listing 1-5: Identifying identical snowflakes moving left</em></p>
<p class="indent">Notice the similarity between this function and that of <a href="ch01.xhtml#ch01ex03">Listing 1-3</a>. All we did was subtract the offset instead of adding it and change the bounds check at <code>6</code> to a bounds check at <code>-1</code>.</p>
<h5 class="h5">Putting It Together</h5>
<p class="noindent">With these two helper functions, <code>identical_right</code> and <code>identical_left</code>, we can finally write a function that tells us whether two snowflakes are identical. <a href="ch01.xhtml#ch01ex06">Listing 1-6</a> gives the code for an <code>are_identical</code> function that does this. We simply test moving right and moving left for each of the possible starting points in <code>snow2</code>.</p>
<pre>int are_identical(int snow1[], int snow2[]) {
  int start;
  for (start = 0; start &lt; 6; start++) {
 <span class="ent">❶</span> if (identical_right(snow1, snow2, start))
      return 1;
 <span class="ent">➋</span> if (identical_left(snow1, snow2, start))
      return 1;
  }
  return 0;
}</pre>
<p class="excap" id="ch01ex06"><span epub:type="pagebreak" id="page_8"/><em>Listing 1-6: Identifying identical snowflakes</em></p>
<p class="indent">We test whether <code>snow1</code> and <code>snow2</code> are the same by moving right in <code>snow2</code> <span class="ent">➊</span>. If they are identical according to that criterion, we return <code>1</code> (true). We then similarly check the moving-left criterion <span class="ent">➋</span>.</p>
<p class="indent">It’s worth pausing here to test the <code>are_identical</code> function on a few sample snowflake pairs. Please do that before continuing!</p>
<h4 class="h4" id="sec10"><em>Solution 1: Pairwise Comparisons</em></h4>
<p class="noindent">When we need to compare two snowflakes, we just deploy our <code>are_identical</code> function instead of <code>==</code>. Comparing two snowflakes is now as easy as comparing two integers.</p>
<p class="indent">Let’s revise our earlier <code>identify_identical</code> function (<a href="ch01.xhtml#ch01ex01">Listing 1-1</a>) to work with snowflakes using the new <code>are_identical</code> function (<a href="ch01.xhtml#ch01ex06">Listing 1-6</a>). We’ll make pairwise comparisons between snowflakes, printing out one of two messages depending on whether we find identical snowflakes. The code is given in <a href="ch01.xhtml#ch01ex07">Listing 1-7</a>.</p>
<pre>void identify_identical(int snowflakes[][6], int n) {
  int i, j;
  for (i = 0; i &lt; n; i++) {
    for (j = i + 1; j &lt; n; j++) {
      if (are_identical(snowflakes[i], snowflakes[j])) {
        printf("Twin snowflakes found.\n");
        return;
      }
    }
  }
  printf("No two snowflakes are alike.\n");
}</pre>
<p class="excap" id="ch01ex07"><em>Listing 1-7: Finding identical snowflakes</em></p>
<p class="indent">This <code>identify_identical</code> function on snowflakes is almost, symbol for symbol, the same as the <code>identify_identical</code> function on integers in <a href="ch01.xhtml#ch01ex01">Listing 1-1</a>. All we’ve done is swap <code>==</code> for a function that compares snowflakes.</p>
<h5 class="h5">Reading the Input</h5>
<p class="noindent">We’re not quite ready to submit to our judge. We haven’t yet written the code to read the snowflakes from standard input. Revisit the problem description at the start of the chapter. We need to read a line containing integer <em>n</em> that tells us how many snowflakes there are and then read each of the following <em>n</em> lines as an individual snowflake.</p>
<p class="indent"><a href="ch01.xhtml#ch01ex08">Listing 1-8</a> is a <code>main</code> function that processes the input and then calls <code>identify_identical</code> from <a href="ch01.xhtml#ch01ex07">Listing 1-7</a>.<span epub:type="pagebreak" id="page_9"/></p>
<pre>#define SIZE 100000

int main(void) {
<span class="ent">❶</span> static int snowflakes[SIZE][6];
   int n, i, j;
   scanf("%d", &amp;n);
   for (i = 0; i &lt; n; i++)
     for (j = 0; j &lt; 6; j++)
       scanf("%d", &amp;snowflakes[i][j]);
   identify_identical(snowflakes, n);
   return 0;
}</pre>
<p class="excap" id="ch01ex08"><em>Listing 1-8: The</em> <span class="codeitalic1">main</span> <em>function for Solution 1</em></p>
<p class="indent">Notice that the <code>snowflakes</code> array is a <code>static</code> array <span class="ent">➊</span>. This is because the array is huge; without using such a <code>static</code> array, the amount of space needed would likely outstrip the amount of memory available to the function. We use <code>static</code> to place the array in its own, separate piece of memory, where space is not a concern. Be careful with <code>static</code>, though. Regular local variables are initialized on each call of a function, but <code>static</code> ones retain whatever value they had on the previous function call (see “Static Keyword” on page xxvi).</p>
<p class="indent">Also notice that we’ve allocated an array of 100,000 snowflakes <span class="ent">➊</span>. You might be concerned that this is a waste of memory. What if the input has only a few snowflakes? For competitive programming problems, it’s generally okay to hardcode the memory requirements for the largest problem instance: the test cases are likely to stress test your submission on the maximum size anyway!</p>
<p class="indent">The rest of the function is straightforward. We read the number of snow-flakes using <code>scanf</code>, and we use that number to determine the number of iterations of the outer <code>for</code> loop. For each such iteration, we loop six times in the inner <code>for</code> loop, each time reading one integer. We then call <code>identify_identical</code> to produce the appropriate output.</p>
<p class="indent">Putting this <code>main</code> function together with the other functions we have written gives us a complete program that we can submit to the judge. Try it out . . . and you should get a “Time-Limit Exceeded” error. It looks like we have more work to do!</p>
<h5 class="h5" id="ch01lev1">Diagnosing the Problem</h5>
<p class="noindent">Our first solution was too slow, so we got a “Time-Limit Exceeded” error. Let’s understand why.</p>
<p class="indent">For our discussion here, we’ll assume that there are no identical snow-flakes. This is the worst-case scenario for our code, since then it doesn’t stop processing early.</p>
<p class="indent">The reason that our first solution is slow is because of the two nested <code>for</code> loops in <a href="ch01.xhtml#ch01ex07">Listing 1-7</a>. Those loops compare each snowflake to every other <span epub:type="pagebreak" id="page_10"/>snowflake, resulting in a huge number of comparisons when the number of snowflakes <em>n</em> is large.</p>
<p class="indent">Let’s figure out the number of snowflake comparisons our program makes. Since we might compare each pair of snowflakes, we can restate this question as asking for the total number of snowflake pairs. For example, if we have four snowflakes numbered 1, 2, 3, and 4, then our scheme performs six snowflake comparisons: Snowflakes 1 and 2, 1 and 3, 1 and 4, 2 and 3, 2 and 4, and 3 and 4. Each pair is formed by choosing one of the <em>n</em> snowflakes as the first snowflake and then choosing one of the remaining <em>n</em> – 1 snow-flakes as the second snowflake.</p>
<p class="indent">For each of <em>n</em> decisions for the first snowflake, we have <em>n</em> – 1 decisions for the second snowflake. This gives a total of <em>n</em>(<em>n</em> – 1) decisions. However, <em>n</em>(<em>n</em> – 1) double-counts the true number of snowflake comparisons that we make—it includes both of the comparisons 1 and 2 and 2 and 1, for example. Our solution compares these only once, so we can divide by 2, giving <em>n</em>(<em>n</em> – 1)/2 snowflake comparisons for <em>n</em> snowflakes.</p>
<p class="indent">This might not seem so bad, but let’s substitute some values of <em>n</em> into <em>n</em>(<em>n</em> – 1)/2 and see what happens. Substituting 10 gives 10(9)/2 = 45. Performing 45 comparisons is a piece of cake for any computer and can be done in milliseconds. How about <em>n</em> = 100? That gives 4,950: still no problem. It looks like we’re okay for a small <em>n</em>, but the problem statement says that we can have up to 100,000 snowflakes. Go ahead and substitute 100,000 for <em>n</em> in <em>n</em>(<em>n</em> – 1)/2: this gives 4,999,950,000 snowflake comparisons. If you run a test case with 100,000 snowflakes on a typical laptop, it will take something like three minutes. That’s far too slow—we need at most one second, not several minutes! As a conservative rule of thumb for today’s computers, think of the number of steps that we can perform per second as about 30 million. Trying to make nearly 5 billion snowflake comparisons in one second is not doable.</p>
<p class="indent">If we expand <em>n</em>(<em>n</em> – 1)/2, we get <em>n</em><sup>2</sup>/2 – <em>n</em>/2. The largest exponent there is 2. Algorithm developers therefore call this an <em>O</em>(<em>n</em><sup>2</sup>) algorithm, or a <em>quadratic-time algorithm</em>. <em>O</em>(<em>n</em><sup>2</sup>) is pronounced “big O of <em>n</em> squared,” and you can think of it as telling you that the rate at which the amount of work grows is quadratic relative to the problem size. For a brief introduction to big O, see <a href="app01.xhtml">Appendix A</a>.</p>
<p class="indent">We need to make such a large number of comparisons because identical snowflakes could show up anywhere in the array. If there were a way to get identical snowflakes close together in the array, we could quickly determine whether a particular snowflake was part of an identical pair. Maybe we can try sorting the array to get the identical snowflakes close together?</p>
<h5 class="h5">Sorting Snowflakes</h5>
<p class="noindent">C has a library function called <code>qsort</code> that we can use to sort an array. The key requirement is a comparison function: it takes pointers to two elements to sort, and it returns a negative integer if the first element is less than the second, <code>0</code> if they are equal, and a positive integer if the first is greater than <span epub:type="pagebreak" id="page_11"/>the second. We can use <code>are_identical</code> to determine whether two snowflakes are equal; if they are, we return <code>0</code>.</p>
<p class="indent">What does it mean, though, for one snowflake to be less than or greater than another? It’s tempting to just agree on some arbitrary rule here. We might say, for example, that the snowflake that is “less” is the one whose first differing element is smaller than the corresponding element in the other snowflake. We do that in <a href="ch01.xhtml#ch01ex09">Listing 1-9</a>.</p>
<pre>int compare(const void *first, const void *second) {
  int i;
  const int *snowflake1 = first;
  const int *snowflake2 = second;
  if (are_identical(snowflake1, snowflake2))
    return 0;
  for (i = 0; i &lt; 6; i++)
    if (snowflake1[i] &lt; snowflake2[i])
      return -1;
  return 1;
}</pre>
<p class="excap" id="ch01ex09"><em>Listing 1-9: A comparison function for sorting</em></p>
<p class="indent">Unfortunately, sorting in this way will not help us solve our problem. You might try writing a program that uses sorting to put identical snow-flakes next to each other so that you can find them quickly. But here’s a four-snowflake test case that would likely fail on your laptop:</p>
<pre>4
3 4 5 6 1 2
2 3 4 5 6 7
4 5 6 7 8 9
1 2 3 4 5 6</pre>
<p class="indent">The first and fourth snowflakes are identical—but the message <code>No two snowflakes are alike.</code> may be output. What’s going wrong?</p>
<p class="indent">Here are two facts that <code>qsort</code> might learn as it executes:</p>
<ol>
<li class="noindent">Snowflake 4 is less than Snowflake 2.</li>
<li class="noindent">Snowflake 2 is less than Snowflake 1.</li>
</ol>
<p class="noindent">From this, <code>qsort</code> could conclude that Snowflake 4 is less than Snowflake 1, without ever directly comparing Snowflake 4 and Snowflake 1! Here it’s relying on the transitive property of less than. If <em>a</em> is less than <em>b</em>, and <em>b</em> is less than <em>c</em>, then surely <em>a</em> should be less than <em>c</em>. It seems like our definitions of “less” and “greater” matter after all.</p>
<p class="indent">Unfortunately, it isn’t clear how one would define “less” and “greater” on snowflakes so as to satisfy transitivity. If you’re disappointed, perhaps you can take solace in the fact that we’ll be able to develop a faster solution without using sorting at all.<span epub:type="pagebreak" id="page_12"/></p>
<p class="indent">In general, collecting similar values with sorting can be a useful data-processing technique. As a bonus, good sorting algorithms run quickly— certainly faster than <em>O</em>(<em>n</em><sup>2</sup>), but we aren’t going to be able to use sorting here.</p>
<h4 class="h4" id="sec11"><em>Solution 2: Doing Less Work</em></h4>
<p class="noindent">Comparing all pairs of snowflakes and trying to sort the snowflakes proved to be too much work. To work up to our next, and ultimate, solution, let’s pursue the idea of trying to avoid comparing snowflakes that are obviously not identical. For example, if we have snowflakes</p>
<pre>1, 2, 3, 4, 5, 6</pre>
<p class="noindent">and</p>
<pre>82, 100, 3, 1, 2, 999</pre>
<p class="noindent">there’s no way that these snowflakes can be identical. We shouldn’t even waste our time comparing them.</p>
<p class="indent">The numbers in the second snowflake are very different from the numbers in the first snowflake. To devise a way to detect that two snowflakes are different without having to directly compare them, we might begin by comparing the snowflake’s first elements, because 1 is very different from 82. But now consider these two snowflakes:</p>
<pre>3, 1, 2, 999, 82, 100</pre>
<p class="noindent">and</p>
<pre>82, 100, 3, 1, 2, 999</pre>
<p class="indent">These two snowflakes <em>are</em> identical even though 3 is very different from 82. We need to do more than just look at first elements.</p>
<p class="indent">A quick litmus test for determining whether two snowflakes might be identical is to use the <em>sum</em> of their elements. When we sum our two example snowflakes, for <code>1, 2, 3, 4, 5, 6</code>, we get a total of 21, and for <code>82, 100, 3, 1, 2, 999</code>, we get 1,187. We say that the <em>code</em> for the former snowflake is 21 and the code for the latter is 1,187.</p>
<p class="indent">Our hope is that we can throw the “21 snowflakes” in one bin and throw the “1,187 snowflakes” in another, and then we never have to compare the 21s to the 1,187s. We can do this binning for each snowflake: add up its elements, get a code of <em>x</em>, and then store it along with all of the other snow-flakes with code <em>x</em>.</p>
<p class="indent">Of course, finding two snowflakes with a code of 21 does not guarantee they are identical. For example, both <code>1, 2, 3, 4, 5, 6</code> and <code>16, 1, 1, 1, 1, 1</code> have a code of 21, and they are surely not identical.</p>
<p class="indent">That’s okay, because our “sum” rule is designed to weed out snowflakes that are clearly not identical. This allows us to avoid comparing all pairs—the source of the inefficiency in Solution 1—and only compare pairs that have not been filtered out as obviously nonidentical.<span epub:type="pagebreak" id="page_13"/></p>
<p class="indent">In Solution 1, we stored each snowflake consecutively in the array: the first snowflake at index <code>0</code>, the second at index <code>1</code>, and so on. Here, our storage strategy is different: sum codes determine snowflakes’ locations in the array! That is, for each snowflake, we calculate its code and use that code as the index for where to store the snowflake.</p>
<p class="indent">We have to solve two problems:</p>
<ol>
<li class="noindent">Given a snowflake, how do we calculate its code?</li>
<li class="noindent">What do we do when multiple snowflakes have the same code?</li>
</ol>
<p class="indent">Let’s deal with calculating the code first.</p>
<h5 class="h5">Calculating Sum Codes</h5>
<p class="noindent">At first glance, calculating the code seems easy. We could just sum all of the numbers within each snowflake like so:</p>
<pre>int code(int snowflake[]) {
  return (snowflake[0] + snowflake[1] + snowflake[2]
          + snowflake[3] + snowflake[4] + snowflake[5]);
}</pre>
<p class="indent">This works fine for many snowflakes, such as <code>1, 2, 3, 4, 5, 6</code>, and <code>82, 100, 3, 1, 2, 999</code>, but consider a snowflake with huge numbers, such as</p>
<pre>1000000, 2000000, 3000000, 4000000, 5000000, 6000000</pre>
<p class="indent">The code that we calculate is <code>21000000</code>. We plan to use that code as the <em>index</em> in an array that holds the snowflakes, so to accommodate this, we’d have to declare an array with room for 21 million elements. As we’re using at most 100,000 elements (one for each snowflake), this is an outrageous waste of memory.</p>
<p class="indent">We’re going to stick with an array that has room for 100,000 elements. We’ll need to calculate a snowflake’s code as before, but then we must force that code to be a number between <code>0</code> and <code>99999</code> (the minimum and maximum index in our array). One way to do this is to break out the <code>%</code> (mod) operator again. Taking a nonnegative integer mod <em>x</em> yields an integer between 0 and <em>x</em> – 1. No matter the sum of a snowflake, if we take it mod 100,000, we’ll get a valid index in our array.</p>
<p class="indent">This method has one downside: taking the mod like this will force <em>more</em> nonidentical snowflakes to end up with the same code. For example, the sums for <code>1, 1, 1, 1, 1, 1</code> and <code>100001, 1, 1, 1, 1, 1</code> are different—<code>6</code> and <code>100006</code>—but once we take them mod 100,000, we get <code>6</code> in both cases. This is an acceptable risk to take: we’ll just hope that this doesn’t happen much; when it does, we’ll perform the necessary pairwise comparisons.</p>
<p class="indent">We’ll calculate the sum code for a snowflake and mod it, as displayed in <a href="ch01.xhtml#ch01ex010">Listing 1-10</a>.<span epub:type="pagebreak" id="page_14"/></p>
<pre>#define SIZE 100000

int code(int snowflake[]) {
  return (snowflake[0] + snowflake[1] + snowflake[2]
          + snowflake[3] + snowflake[4] + snowflake[5]) % SIZE;
}</pre>
<p class="excap" id="ch01ex010"><em>Listing 1-10: Calculating the snowflake code</em></p>
<h5 class="h5">Snowflake Collisions</h5>
<p class="noindent">In Solution 1, we used the following fragment to store a snowflake at index <code>i</code> in the <code>snowflakes</code> array:</p>
<pre>    for (j = 0; j &lt; 6; j++)
      scanf("%d", &amp;snowflakes[i][j]);</pre>
<p class="indent">This worked because exactly one snowflake was stored in each row of the two-dimensional array.</p>
<p class="indent">However, now we have to contend with the <code>1, 1, 1, 1, 1, 1</code> and <code>100001, 1, 1, 1, 1, 1</code> kind of collision, where, because they’ll end up with the same mod code and that code serves as the snowflakes index in the array, we need to store multiple snowflakes in the same array element. That is, each array element will no longer be one snowflake but a collection of zero or more snowflakes.</p>
<p class="indent">One way to store multiple elements at the same array index is to use a <em>linked list</em>, a data structure that links each element to the next. Here, each element in the snowflakes array will point to the first snowflake in the linked list; the remainder of the snowflakes can be accessed through <code>next</code> pointers.</p>
<p class="indent">We’ll use a typical linked list implementation. Each <code>snowflake_node</code> contains both a snowflake and a pointer to the next snowflake. To collect these two components, we’ll use a struct. We’ll also make use of <code>typedef</code>, which allows us to later use <code>snowflake_node</code> instead of the full <code>struct snowflake_node</code>:</p>
<pre>typedef struct snowflake_node {
  int snowflake[6];
  struct snowflake_node *next;
} snowflake_node;</pre>
<p class="indent">This change necessitates updates to two functions, <code>main</code> and <code>identify_identical</code>, because those functions use our old two-dimensional array.</p>
<h5 class="h5">The New main Function</h5>
<p class="noindent">You can see the updated <code>main</code> code in <a href="ch01.xhtml#ch01ex011">Listing 1-11</a>.</p>
<pre>int main(void) {
<span class="ent">❶</span> static snowflake_node *snowflakes[SIZE] = {NULL};
<span class="ent">➋</span> snowflake_node *snow;
   int n, i, j, snowflake_code;
   scanf("%d", &amp;n);
   for (i = 0; i &lt; n; i++) {
  <span class="ent">➌</span> snow = malloc(sizeof(snowflake_node));
    if (snow == NULL) {
      fprintf(stderr, "malloc error\n");
      exit(1);
    }
    for (j = 0; j &lt; 6; j++)
   <span class="ent">➍</span> scanf("%d", &amp;snow-&gt;snowflake[j]);
  <span class="ent">➎</span> snowflake_code = code(snow-&gt;snowflake);
  <span class="ent">➏</span> snow-&gt;next = snowflakes[snowflake_code];
  <span class="ent">❼</span> snowflakes[snowflake_code] = snow;
  }
  identify_identical(snowflakes);
  // deallocate all malloc'd memory, if you want to be good
  return 0;
}</pre>
<p class="excap" id="ch01ex011"><span epub:type="pagebreak" id="page_15"/><em>Listing 1-11: The</em> <span class="codeitalic1">main</span> <em>function for Solution 2</em></p>
<p class="indent">Let’s walk through this code. First, notice that we changed the type of our array from a two-dimensional array of numbers to a one-dimensional array of pointers to snowflake nodes <span class="ent">➊</span>. We also declare <code>snow</code> <span class="ent">➋</span>, which will point to snowflake nodes that we allocate.</p>
<p class="indent">We use <code>malloc</code> to allocate memory for each <code>snowflake_node</code> <span class="ent">➌</span>. Once we have read in and stored the six numbers for a snowflake <span class="ent">➍</span>, we use <code>snowflake_code</code> to hold the snowflake’s code <span class="ent">➎</span>, calculated using the function we wrote in <a href="ch01.xhtml#ch01ex010">Listing 1-10</a>.</p>
<p class="indent">The last thing to do is to add the snowflake to the <code>snowflakes</code> array, which amounts to adding a node to a linked list. We do this by inserting the snow-flake at the beginning of the linked list. We first point the inserted node’s <code>next</code> pointer to the first node in the list <span class="ent">➏</span>, and then we set the start of the list to point to the inserted node <span class="ent">❼</span>. The order matters here: if we had reversed the order of these two lines, we would lose access to the elements already in the linked list!</p>
<p class="indent">Notice that, in terms of correctness, it doesn’t matter where in the linked list we add the new node. It could go at the beginning, the end, or somewhere in the middle—it’s our choice. So we should do whatever is fastest, and adding to the beginning is fastest because it doesn’t require us to traverse the list at all. If we instead chose to add an element to the end of a linked list, we’d have to traverse the entire list. If that list had a million elements, we’d have to follow the next pointers a million times until we got to the end—that would be very slow!</p>
<p class="indent">Let’s work on a quick example of how this <code>main</code> function works. Here’s the test case:</p>
<pre>4
1 2 3 4 5 6
8 3 9 10 15 4
16 1 1 1 1 1
100016 1 1 1 1 1</pre>
<p class="indent"><span epub:type="pagebreak" id="page_16"/>Each element of <code>snowflakes</code> begins as <code>NULL</code>, the empty linked list. As we add to <code>snowflakes</code>, elements will begin to point at snowflake nodes. The numbers in the first snowflake add up to 21, so it goes into index <code>21</code>. The second snowflake goes into index <code>49</code>. The third snowflake goes into index <code>21</code>. At this point, index <code>21</code> is a linked list of <em>two</em> snowflakes: <code>16, 1, 1, 1, 1, 1</code> followed by <code>1, 2, 3, 4, 5, 6</code>.</p>
<p class="indent">How about the fourth snowflake? That goes into index <code>21</code> again, and now we have a linked list of three snowflakes there. See <a href="ch01.xhtml#ch01fig03">Figure 1-3</a> for the hash table that we’ve built.</p>
<div class="image"><img alt="Image" id="ch01fig03" src="../images/ch01fig03.jpg"/></div>
<p class="figcap"><em>Figure 1-3: A hash table with four snowflakes</em></p>
<p class="indent">There are multiple snowflakes in index <code>21</code>. Does this mean that we have identical snowflakes? No! This emphasizes the fact that a linked list with multiple elements is not sufficient evidence to claim that we have identical snowflakes. We have to compare each pair of those elements to correctly state our conclusion. That’s the final piece of the puzzle.</p>
<h5 class="h5">The New identify_identical Function</h5>
<p class="noindent">We need <code>identify_identical</code> to make all pairwise comparisons of snowflakes within each linked list. <a href="ch01.xhtml#ch01ex012">Listing 1-12</a> shows the code to do so.</p>
<pre>void identify_identical(snowflake_node *snowflakes[]) {
  snowflake_node *node1, *node2;
  int i;
  for (i = 0; i &lt; SIZE; i++) {
 <span class="ent">❶</span> node1 = snowflakes[i];
    while (node1 != NULL) {
   <span class="ent">➋</span> node2 = node1-&gt;next;
      while (node2 != NULL) {
        if (are_identical(node1-&gt;snowflake, node2-&gt;snowflake)) {
          printf("Twin snowflakes found.\n");
          return;
        }
        node2 = node2-&gt;next;
      }
   <span class="ent">➌</span> node1 = node1-&gt;next;
    }
  }
  printf("No two snowflakes are alike.\n");
}</pre>
<p class="excap" id="ch01ex012"><span epub:type="pagebreak" id="page_17"/><em>Listing 1-12: Identifying identical snowflakes in linked lists</em></p>
<p class="indent">We begin with <code>node1</code> at the first node in a linked list <span class="ent">➊</span>. We use <code>node2</code> to traverse from the node to the right of <code>node1</code> <span class="ent">➋</span> all the way to the end of the linked list. This compares the first snowflake in the linked list to all other snowflakes in that linked list. We then advance <code>node1</code> to the second node <span class="ent">➌</span>, and we compare that second snowflake to each snowflake to its right. We repeat this until <code>node1</code> reaches the end of the linked list.</p>
<p class="indent">This code is dangerously similar to <code>identify_identical</code> from Solution 1 (<a href="ch01.xhtml#ch01ex07">Listing 1-7</a>), which made all pairwise comparisons between any two snow-flakes. By contrast, our new code only makes pairwise comparisons within a single linked list. But what if someone crafts a test case where all snowflakes end up in the same linked list? Wouldn’t the performance then be as bad as in Solution 1? It would, yes, but absent such nefarious data, we’re in great shape. Take a minute to submit Solution 2 to the judge and see for yourself. You should see that we’ve discovered a much more efficient solution! What we’ve done is use a data structure called a hash table. We’ll learn more about hash tables next.</p>
<h3 class="h3" id="lev12">Hash Tables</h3>
<p class="noindent">A <em>hash table</em> consists of two things:</p>
<ol>
<li class="noindent">An array. Locations in the array are referred to as <em>buckets</em>.</li>
<li class="noindent">A <em>hash function</em>, which takes an object and returns its code as an index into the array.</li>
</ol>
<p class="noindent">The code returned by the hash function is referred to as a <em>hashcode</em>; that code determines at which index an object is stored or <em>hashed</em>.</p>
<p class="indent">Look closely at what we did in <a href="ch01.xhtml#ch01ex010">Listings 1-10</a> and <a href="ch01.xhtml#ch01ex011">1-11</a> and you’ll see that we already have both of these things. That <code>code</code> function, which took a snow-flake and produced its code (a number between 0 and 99,999), is a hash function; and that <code>snowflakes</code> array is the array of buckets, where each bucket contains a linked list.</p>
<h4 class="h4" id="sec12"><em>Hash Table Design</em></h4>
<p class="noindent">Designing a hash table involves many design decisions. Let’s talk about three of them here.</p>
<p class="indent">The first decision concerns size. In Unique Snowflakes, we used an array size of 100,000. We could have instead used a smaller or larger array. A <span epub:type="pagebreak" id="page_18"/>smaller array saves memory. For example, on initialization, a 50,000-element array stores half as many <code>NULL</code> values as does a 100,000-element array. However, a smaller array leads to more objects ending up in the same bucket. When objects end up in the same bucket, we say that a <em>collision</em> has occurred. The problem with having many collisions is that they lead to long linked lists. Ideally, all of the linked lists would be short so that we wouldn’t have to walk through and do work on many elements. A larger array avoids some of these collisions.</p>
<p class="indent">To summarize, we have a memory–time tradeoff here. Make the hash table too small and collisions run rampant. Make the hash table too big and memory waste becomes a concern. In general, try to choose an array size that’s a reasonable percentage—such as 20 percent or 50 percent or 100 percent—of the maximum number of elements you expect to insert into the hash table.</p>
<p class="indent">In Unique Snowflakes, we used an array size of 100,000 to match the maximum number of snowflakes; had we been constrained to use less memory, smaller arrays would have worked just fine as well.</p>
<p class="indent">The second consideration is our hash function. In Unique Snowflakes, our hash function adds up a snowflake’s numbers mod 100,000. Importantly, this hash function guarantees that, if two snowflakes are identical, they will end up in the same bucket. (They might also end up in the same bucket if they are not identical, of course.) This is the reason why we can search within linked lists, and not between them, for identical snowflakes.</p>
<p class="indent">When solving a problem with a hash table, the hash function that we use should take into account what it means for two objects to be identical. If two objects are identical, then the hash function must hash them to the same bucket. In the case in which two objects must be exactly equal to be considered “identical,” we can scramble things so extensively that the mapping between object and bucket is far more intricate than what we did with the snowflakes. Check out the <code>oaat</code> (one-at-a-time) hash function in <a href="ch01.xhtml#ch01ex013">Listing 1-13</a> for an example.</p>
<pre>#define hashsize(n) ((unsigned long)1 &lt;&lt; (n))
#define hashmask(n) (hashsize(n) - 1)

unsigned long oaat(char *key, unsigned long len, unsigned long bits) {
  unsigned long hash, i;
  for (hash = 0, i = 0; i &lt; len; i++) {
    hash += key[i];
    hash += (hash &lt;&lt; 10);
    hash ^= (hash &gt;&gt; 6);
  }
  hash += (hash &lt;&lt; 3);
  hash ^= (hash &gt;&gt; 11);
  hash += (hash &lt;&lt; 15);
  return hash &amp; hashmask(bits);
}

int main(void) { // sample call of oaat
  char word[] = "hello";
  // 2^17 is the smallest power of 2 that is at least 100000
<span class="ent">❶</span> unsigned long code = oaat(word, strlen(word), 17);
   printf("%u\n", code);
   return 0;
}</pre>
<p class="excap" id="ch01ex013"><span epub:type="pagebreak" id="page_19"/><em>Listing 1-13: An intricate hash function</em></p>
<p class="indent">To call <code>oaat</code> <span class="ent">➊</span> as we do in the <code>main</code> function, we pass three parameters:</p>
<p class="block"><span class="codestrong">key</span>   The data that we want to hash (here, we’re hashing the <code>word</code> string)</p>
<p class="block"><span class="codestrong">len</span>   The length of those data (here, the length of the <code>word</code> string)</p>
<p class="block"><span class="codestrong">bits</span>   The number of bits that we want in the resulting hashcode (here, 17)</p>
<p class="noindent">The maximum value that a hashcode could have is one less than 2 to the power of <code>bits</code>. For example, if we choose 17, then 2<sup>17</sup> – 1 = 131,071 is the maximum that a hashcode could be.</p>
<p class="indent">How does <code>oaat</code> work? Inside the <code>for</code> loop, it starts by adding the current byte of the key. That part is similar to what we did when adding up the numbers in a snowflake (<a href="ch01.xhtml#ch01ex010">Listing 1-10</a>). Those left shifts and exclusive ors are in there to put the key through a blender. Hash functions do this blending to implement an <em>avalanche effect</em>, which means that a small change in the key’s bits makes a huge change to the key’s hashcode. Unless you intentionally created pathological data for this hash function or inserted a huge number of keys, it would be unlikely that you’d get many collisions. This highlights an important point: with a single hash function, there is <em>always</em> a collection of data that will lead to collisions galore and subsequently horrible performance. A fancy hash function like <code>oaat</code> can’t protect against that. Unless we’re concerned about malicious input, though, we can often get away with using a reasonably good hash function and can assume that it will spread the data around.</p>
<p class="indent">Indeed, this is why using our hash table solution (Solution 2) for Unique Snowflakes was so successful. We used a good hash function that distributes many nonidentical snowflakes into different buckets. Since we’re not securing our code from attack, we don’t have to worry about some evil person studying our code and figuring out a way to cause millions of collisions.</p>
<p class="indent">For our third and final design decision, we have to think about what we want to use as our buckets. In Unique Snowflakes, we used a linked list as each bucket. Using linked lists like this is known as a <em>chaining</em> scheme.</p>
<p class="indent">In another approach, known as <em>open-addressing</em>, each bucket holds at most one element, and there are no linked lists. To deal with collisions, we search through buckets until we find one that is empty. For example, suppose that we try to insert an object into bucket number 50, but Bucket 50 is already occupied. We might then try Bucket 51, then 52, then 53, stopping when we find an empty bucket. Unfortunately, this simple sequence can lead <span epub:type="pagebreak" id="page_20"/>to poor performance when a hash table has many elements stored in it, so more nuanced search schemes are often used in practice.</p>
<p class="indent">Chaining is generally easier to implement than open-addressing, which is why we used chaining for Unique Snowflakes. However, open-addressing does have some benefits, including saving memory by not using linked list nodes.</p>
<h4 class="h4" id="sec13"><em>Why Use Hash Tables?</em></h4>
<p class="noindent">Using a hash table turbocharges our solution to Unique Snowflakes. On a typical laptop, a test case with 100,000 elements will take only a fraction of a second to run! No pairwise comparisons of all elements and no sorting is needed, just a little processing on a bunch of linked lists.</p>
<p class="indent">Recall that we used an array size of 100,000. The maximum number of snowflakes that can be presented to our program is also 100,000. If we’re given 100,000 snowflakes and assume the perfect scenario of each one going into its own bucket, then we’d have only one snowflake per linked list. If we have a little bad luck, then maybe a few of those snowflakes will collide and end up in the same bucket. In the absence of pathological data, though, we expect that each linked list will have at most a few elements. As such, making all pairwise comparisons within a bucket will take only a small, constant number of steps. We expect hash tables to give us a <em>linear-time</em> solution, because we take a constant number of steps in each of the <em>n</em> buckets. So we take something like <em>n</em> steps, in comparison to the <em>n</em>(<em>n</em> – 1)/2 formula we had for Solution 1. In terms of big O, we’d say that we expect an <em>O</em>(<em>n</em>) solution.</p>
<p class="indent">Whenever you’re working on a problem and you find yourself repeatedly searching for some element, consider using a hash table. A hash table takes a slow array search and converts it into a fast lookup. For some problems, you may be able to sort an array rather than use a hash table. A technique called binary search (discussed in <a href="ch07.xhtml">Chapter 7</a>) could then be used to quickly search for elements in the sorted array. But often—such as in Unique Snowflakes and the problem we’ll solve next—that won’t work. Hash tables to the rescue!</p>
<h3 class="h3" id="lev13">Problem 2: Login Mayhem</h3>
<p class="noindent">Let’s go through another problem and pay attention to where a naive solution would rely on a slow search. We’ll then drop in a hash table to cause a dramatic speedup. We’ll go a little more quickly than we did for Unique Snowflakes because now we know what to look for.</p>
<p class="indent">This is DMOJ problem <code>coci17c1p3hard</code>.</p>
<h4 class="h4" id="sec14"><em>The Problem</em></h4>
<p class="noindent">To log in to your account on a social network website, you’d expect that only your password would work—no one should be able to use a different password to get into your account. For example, let’s say that your password <span epub:type="pagebreak" id="page_21"/>is <code>dish</code>. (That’s a terribly weak password—don’t actually use that anywhere!) To log in to your account, someone would need to enter exactly <code>dish</code> as the password. That’s just how logins work.</p>
<p class="indent">But now imagine that you are wanting to join a (hopefully theoretical) social network website that has a major security concern: other passwords besides yours can be used to get into your account! Specifically, if someone tries a password that has your password as a substring, then they’re in. If your password were <code>dish</code>, for example, then passwords like <code>brandish</code> and <code>radishes</code> would work to get into your account because the string <code>dish</code> is in them. You don’t know what password to choose for your account—so at various points you will ask: “If I chose this password, how many current users’ passwords would get in to my account?”</p>
<p class="indent">We need to support two types of operations:</p>
<p class="block"><strong>Add</strong>   Sign up a new user with the given password.</p>
<p class="block"><strong>Query</strong>   Given a proposed password <em>p</em>, return the number of current users’ passwords that could be used to get into an account whose password is <em>p</em>.</p>
<h5 class="h5">Input</h5>
<p class="noindent">The input consists of the following lines:</p>
<ul>
<li class="noindents">A line containing <em>q</em>, the number of operations to be performed. <em>q</em> is between 1 and 100,000.</li>
<li class="noindents"><em>q</em> lines, each giving one add or query operation to be performed.</li>
</ul>
<p class="indent">Here are the operations that can be performed in those <em>q</em> lines:</p>
<ul>
<li class="noindents">An add operation is specified as the number <code>1</code>, a space, and then the new user’s password. It indicates that a new user has joined with the provided password. This operation doesn’t result in any output.</li>
<li class="noindents">A query operation is specified as the number <code>2</code>, a space, and then a proposed password <em>p</em>. It indicates that we should output the number of current users’ passwords that could be used to get into an account whose password is <em>p</em>.</li>
</ul>
<p class="indent">All passwords provided in these operations are between 1 and 10 lowercase characters.</p>
<h5 class="h5">Output</h5>
<p class="noindent">Output the result of each query operation, one per line.</p>
<p class="indent">The time limit for solving the test case is three seconds.</p>
<h4 class="h4" id="sec15"><em>Solution 1: Looking at All Passwords</em></h4>
<p class="noindent">Let’s work through a test case to make sure that we know exactly what we’re being asked to do.<span epub:type="pagebreak" id="page_22"/></p>
<pre><span class="ent">❶</span> 6
<span class="ent">➋</span> 2 dish
   1 brandish
   1 radishes
   1 aaa
<span class="ent">➌</span> 2 dish
<span class="ent">➍</span> 2 a</pre>
<p class="indent">We can tell from the first line <span class="ent">➊</span> that there are 6 operations for us to perform. The first operation <span class="ent">➋</span> asks us how many of the existing users’ passwords would get into an account whose password is <code>dish</code>. Well, there are no existing users, so the answer is <code>0</code>!</p>
<p class="indent">Next, we add three user passwords, and then we get to our next query operation <span class="ent">➌</span>. Now we’re being asked about <code>dish</code> in the context of these three passwords. You might be thinking that we need to search through the existing passwords to count up the ones that have <code>dish</code> in them. (Hmmm, searching! That’s our first inkling that a hash table may be needed here.) If you do that, you’ll find that two of the passwords—<code>brandish</code> and <code>radishes</code>—have <code>dish</code> in them. The answer is therefore <code>2</code>.</p>
<p class="indent">And what about the final query <span class="ent">➍</span>? We’re looking for passwords that have an <code>a</code> in them. If you search through the three existing passwords, you’ll find that all three of them do! The answer is therefore <code>3</code>.</p>
<p class="indent">We’re done! The correct output for the full test case is:</p>
<pre>0
2
3</pre>
<p class="indent">If we implement the solution strategy that we just used, we might arrive at something like <a href="ch01.xhtml#ch01ex014">Listing 1-14</a>.</p>
<pre><span class="ent">❶</span> #define MAX_USERS 100000
  #define MAX_PASSWORD 10

  int main(void) {
    static char users[MAX_USERS][MAX_PASSWORD + 1];
    int num_ops, op, op_type, total, j;
    char password[MAX_PASSWORD + 1];
    int num_users = 0;
    scanf("%d", &amp;num_ops);
    for (op = 0; op &lt; num_ops; op++) {
      scanf("%d%s", &amp;op_type, password);

   <span class="ent">➋</span> if (op_type == 1) {
        strcpy(users[num_users], password);
        num_users++;

   <span class="ent">➌</span> } else {
        total = 0;
        for (j = 0; j &lt; num_users; j++)
          if (strstr(users[j], password))
            total++;
        printf("%d\n", total);
      }
    }
    return 0;
}</pre>
<p class="excap" id="ch01ex014"><span epub:type="pagebreak" id="page_23"/><em>Listing 1-14: Solution 1</em></p>
<p class="indent">The problem description says that we’ll have at most 100,000 operations. If each is an add operation, then we get 100,000 users <span class="ent">➊</span>, and we can’t have any more than that.</p>
<p class="indent">For each add operation <span class="ent">➋</span>, we copy the new password into our users array. And for each query operation <span class="ent">➌</span>, we loop through all of the existing user passwords, checking how many of them have the proposed password as a substring.</p>
<p class="indent">Like our first solution to Unique Snowflakes, this solution is not fast enough to pass the test cases in time. That’s because we have an <em>O</em>(<em>n</em><sup>2</sup>) algorithm here, where <em>n</em> is the number of queries.</p>
<p class="indent">We are able to quickly add user passwords to our array—no problem there. What slows us down are the query operations, because each of them has to scan through all existing user passwords. That’s where the quadratic-time behavior comes from. Suppose, for example, that a test case starts by adding 50,000 user passwords, and then hammers us with 50,000 queries. Taken together, that would require about 50,000 × 50,000 = 2,500,000,000 steps. That’s over 2 billion steps; there’s no way that we can do that many in our allowed time limit of three seconds.</p>
<h4 class="h4" id="sec16"><em>Solution 2: Using a Hash Table</em></h4>
<p class="noindent">We need to speed up the query operations. And we’re going to use a hash table to do so. But how? Isn’t it just a fact of life that we need to compare each query password with each existing password? No! Read on as we turn the problem on its head.</p>
<h5 class="h5">How to Use the Hash Table</h5>
<p class="noindent">For each query operation, it would be nice if we could just look up the needed password in a hash table to determine how many existing user passwords could get into its account. For example, once we add the users with passwords <code>brandish</code>, <code>radishes</code>, and <code>aaa</code>, then it would be nice to be able to look up <code>dish</code> in the hash table and get a value of <code>2</code>. But while we’re adding those three user passwords, how are we supposed to know to be keeping track of what’s going on with <code>dish</code>? We don’t know which passwords are going to be queried later.<span epub:type="pagebreak" id="page_24"/></p>
<p class="indent">Well, since we don’t know the future, let’s just add one to the total for every single substring of each user password. That way we’ll be ready if we ever need to look any of them up.</p>
<p class="indent">Focus on the <code>brandish</code> password. If we consider each substring, then we’ll increment the total for <code>b</code>, <code>br</code>, <code>bra</code>, <code>bran</code>, <code>brand</code>, <code>brandi</code>, <code>brandis</code>, <code>brandish</code>, <code>r</code>, <code>ra</code>, and so on. Don’t worry: if we process them all, we’ll definitely hit <code>dish</code> and increment it. We’ll increment <code>dish</code> again when we do the same kind of substring processing on <code>radishes</code>. So, <code>dish</code> will end up with a total of 2, as needed.</p>
<p class="indent">You might worry that we’re being excessive here, processing a ton of substring passwords, the vast majority of which are not going to be queried. However, remember from the problem description that passwords can be at most 10 characters. Each substring has a starting point and an ending point. In a password of 10 characters, there are only 10 possible starting points and 10 possible ending points, so an upper bound on the number of substrings in a password is 10 × 10 = 100. As we have at most 100,000 user passwords, each of which has at most 100 substrings, we’ll store at most 100,000 × 100 = 10,000,000 substrings in our hash table. That’ll take up a few megabytes of memory, for sure, but that’s nothing to worry about. We’re trading a little memory for the ability to look up any password’s total when we need it.</p>
<p class="indent">As with Unique Snowflakes, our solution will use a hash table of linked lists. We also need a hash function. We won’t use something like the snow-flake hash function here, because it would lead to collisions between passwords like <code>cat</code> and <code>act</code> that are anagrams. Unlike in the Unique Snowflakes problem, passwords should be distinguished not just by their letters but by the locations of those letters. Some collisions are inevitable, of course, but we should do what we can to limit their prevalence. To that end, we’ll wield that wild <code>oaat</code> hash function from <a href="ch01.xhtml#ch01ex013">Listing 1-13</a>.</p>
<h5 class="h5">Searching the Hash Table</h5>
<p class="noindent">We’ll use the following node to store passwords in our hash table:</p>
<pre>#define MAX_PASSWORD 10

typedef struct password_node {
  char password[MAX_PASSWORD + 1];
  int total;
  struct password_node *next;
} password_node;</pre>
<p class="indent">This node is similar to <code>snowflake_node</code> from Unique Snowflakes, but we now also have a <code>total</code> member to keep track of the total count for this password.</p>
<p class="indent">Now we can write a helper function to search the hash table for a given password. See <a href="ch01.xhtml#ch01ex015">Listing 1-15</a> for the code.<span epub:type="pagebreak" id="page_25"/></p>
<pre>#define NUM_BITS 20

password_node *in_hash_table(password_node *hash_table[], char *find) {
  unsigned password_code;
  password_node *password_ptr;
<span class="ent">❶</span> password_code = oaat(find, strlen(find), NUM_BITS);
<span class="ent">➋</span> password_ptr = hash_table[password_code];
   while (password_ptr) {
  <span class="ent">➌</span> if (strcmp(password_ptr-&gt;password, find) == 0)
       return password_ptr;
     password_ptr = password_ptr-&gt;next;
  }
  return NULL;
}</pre>
<p class="excap" id="ch01ex015"><em>Listing 1-15: Searching for a password</em></p>
<p class="indent">This <code>in_hash_table</code> function takes a hash table and a password to find in the hash table. If the password is found, the function returns a pointer to the corresponding <code>password_node</code>; otherwise, it returns <code>NULL</code>.</p>
<p class="indent">The function works by calculating the hashcode of the password <span class="ent">➊</span> and using that hashcode to find the appropriate linked list to search <span class="ent">➋</span>. It then checks each password in the list, looking for a match <span class="ent">➌</span>.</p>
<h5 class="h5">Adding to the Hash Table</h5>
<p class="noindent">We also need a function that will add one to a given password in the hash table. See <a href="ch01.xhtml#ch01ex016">Listing 1-16</a> for the code.</p>
<pre>void add_to_hash_table(password_node *hash_table[], char *find) {
  unsigned password_code;
  password_node *password_ptr;
<span class="ent">❶</span> password_ptr = in_hash_table(hash_table, find);
   if (!password_ptr) {
     password_code = oaat(find, strlen(find), NUM_BITS);
     password_ptr = malloc(sizeof(password_node));
     if (password_ptr == NULL) {
       fprintf(stderr, "malloc error\n");
       exit(1);
    }
    strcpy(password_ptr-&gt;password, find);
 <span class="ent">➋</span> password_ptr-&gt;total = 0;
    password_ptr-&gt;next = hash_table[password_code];
    hash_table[password_code] = password_ptr;
  }
<span class="ent">➌</span> password_ptr-&gt;total++;
}</pre>
<p class="excap" id="ch01ex016"><em>Listing 1-16: Adding one to a password’s total</em><span epub:type="pagebreak" id="page_26"/></p>
<p class="indent">We use our <code>in_hash_table</code> function <span class="ent">➊</span> to determine whether the password is already in the hash table. If it isn’t, we add it to the hash table and give it a count of 0 for now <span class="ent">➋</span>. The technique for adding each password to the hash table is the same as for the Unique Snowflakes problem: each bucket is a linked list, and we add each password to the beginning of one of those lists.</p>
<p class="indent">Next, whether the password was already in there or not, we increment its total <span class="ent">➌</span>. In that way, a password that we just added will have its <code>total</code> increased from 0 to 1, whereas existing passwords will simply have their <code>total</code> incremented.</p>
<h5 class="h5">The main Function, Take 1</h5>
<p class="noindent">Ready for the <code>main</code> function? Our first attempt is in <a href="ch01.xhtml#ch01ex017">Listing 1-17</a>.</p>
<pre>// bugged!
int main(void) {
<span class="ent">❶</span> static password_node *hash_table[1 &lt;&lt; NUM_BITS] = {NULL};
   int num_ops, op, op_type, i, j;
   char password[MAX_PASSWORD + 1], substring[MAX_PASSWORD + 1];
   password_node *password_ptr;
   scanf("%d", &amp;num_ops);
   for (op = 0; op &lt; num_ops; op++) {
     scanf("%d%s", &amp;op_type, password);

  <span class="ent">➋</span> if (op_type == 1) {
       for (i = 0; i &lt; strlen(password); i++)
         for (j = i; j &lt; strlen(password); j++) {
           strncpy(substring, &amp;password[i], j - i + 1);
           substring[j - i + 1] = '\0';
        <span class="ent">➌</span> add_to_hash_table(hash_table, substring);
        }

  <span class="ent">➍</span> } else {
    <span class="ent">➎</span> password_ptr = in_hash_table(hash_table, password);
    <span class="ent">➏</span> if (!password_ptr)
         printf("0\n");
       else
         printf("%d\n", password_ptr-&gt;total);
    }
  }
  return 0;
}</pre>
<p class="excap" id="ch01ex017"><em>Listing 1-17: The</em> <span class="codeitalic1">main</span> <em>function (bugged!)</em></p>
<p class="indent">To determine the size of the hash table, we’ve used this strange bit of code: <code>1 &lt;&lt; NUM_BITS</code> <span class="ent">➊</span>. We set <code>NUM_BITS</code> to 20 in <a href="ch01.xhtml#ch01ex015">Listing 1-15</a>; <code>1 &lt;&lt; 20</code> is a shortcut for computing 2<sup>20</sup>, which is 1,048,576. (The <code>oaat</code> hash function requires that the hash table have a number of elements that is a power of 2.) Remember that the maximum number of users we’ll have is 100,000; the hash table <span epub:type="pagebreak" id="page_27"/>size that I chose is about 10 times this maximum to account for the fact that we insert multiple strings for each password. Smaller or larger hash tables would have worked fine, too.</p>
<p class="indent">For each add operation <span class="ent">➋</span>, we increment the total for each substring by using our <code>add_to_hash_table</code> helper function <span class="ent">➌</span>. And for each query operation <span class="ent">➍</span>, we use our <code>in_hash_table</code> helper function <span class="ent">➎</span> to retrieve the total for the password; if the password isn’t in the hash table <span class="ent">➏</span> then we output <code>0</code>.</p>
<p class="indent">Put all of our functions together and let’s try running our code! Remember this test case?</p>
<pre>6
2 dish
1 brandish
1 radishes
1 aaa
2 dish
2 a</pre>
<p class="indent">The output is supposed to be:</p>
<pre>0
2
3</pre>
<p class="indent">Unfortunately, our code gives this instead:</p>
<pre>0
2
5</pre>
<p class="noindent">Wait, <code>5</code>? Where’s that <code>5</code> coming from?</p>
<p class="indent">Look at the password <code>aaa</code>. How many <code>a</code> substrings are in there? There are three! And we’re going to find each of them, resulting in three increments to the total for <code>a</code>. But that doesn’t make sense: <code>aaa</code> should be able to bump up the total for <code>a</code> at most once, not multiple times. After all, <code>aaa</code> is only one password.</p>
<h5 class="h5">The main Function, Take 2</h5>
<p class="noindent">What we need to do is make sure that, for each password, each of its substrings counts only once. To do that, we’ll maintain an array of all of the substrings that we’ve generated for the current password. Prior to using a substring, we’ll search to make sure that we haven’t used that substring yet.</p>
<p class="indent">We’re introducing a new search here, so it’s worth thinking about whether we need a new hash table of substrings. While we could indeed add another hash table for that, we don’t need to: as we already argued, each password won’t have too many substrings, so a <em>linear search</em> (that is, an element-by-element search) through them is going to be fast enough.</p>
<p class="indent">Check out <a href="ch01.xhtml#ch01ex018">Listing 1-18</a> for the finishing touch.<span epub:type="pagebreak" id="page_28"/></p>
<pre><span class="ent">❶</span> int already_added(char all_substrings[][MAX_PASSWORD + 1],
                     int total_substrings, char *find) {
     int i;
     for (i = 0; i &lt; total_substrings; i++)
       if (strcmp(all_substrings[i], find) == 0)
         return 1;
     return 0;
  }

  int main(void) {
    static password_node *hash_table[1 &lt;&lt; NUM_BITS] = {NULL};
    int num_ops, op, op_type, i, j;
    char password[MAX_PASSWORD + 1], substring[MAX_PASSWORD + 1];
    password_node *password_ptr;
    int total_substrings;
    char all_substrings[MAX_PASSWORD * MAX_PASSWORD][MAX_PASSWORD + 1];
    scanf("%d", &amp;num_ops);
    for (op = 0; op &lt; num_ops; op++) {
      scanf("%d%s", &amp;op_type, password);

      if (op_type == 1) {
        total_substrings = 0;
        for (i = 0; i &lt; strlen(password); i++)
          for (j = i; j &lt; strlen(password); j++) {
            strncpy(substring, &amp;password[i], j - i + 1);
            substring[j - i + 1] = '\0';
          <span class="ent">➋</span> if (!already_added(all_substrings, total_substrings, substring)) {
               add_to_hash_table(hash_table, substring);
               strcpy(all_substrings[total_substrings], substring);
               total_substrings++;
             }
          }


      } else {
        password_ptr = in_hash_table(hash_table, password);
        if (!password_ptr)
          printf("0\n");
        else
          printf("%d\n", password_ptr-&gt;total);
  }
 }
 return 0;
}</pre>
<p class="excap" id="ch01ex018"><em>Listing 1-18: A new helper function and fixed</em> <span class="codeitalic1">main</span> <em>function</em><span epub:type="pagebreak" id="page_29"/></p>
<p class="indent">We have a new <code>already_added</code> helper function here <span class="ent">➊</span> that we’ll use to tell us whether the <code>find</code> substring is already in the <code>all_substrings</code> array for the current password.</p>
<p class="indent">In the <code>main</code> function itself, notice now that we check whether we’ve seen the current substring <span class="ent">➋</span>. If we have not, only then do we add it to the hash table.</p>
<p class="indent">It’s time to submit our code to the judge. Go for it! As with Unique Snowflakes, the speedup from using a hash table amounts to an improvement from <em>O</em>(<em>n</em><sup>2</sup>) to <em>O</em>(<em>n</em>), which is plenty fast for the three-second time limit.</p>
<h3 class="h3" id="lev14">Problem 3: Spelling Check</h3>
<p class="noindent">Sometimes, problems look like they can be solved in a particular way because they bear resemblance to other problems. Here’s a problem where it seems that a hash table is appropriate, but on further reflection we see that hash tables vastly overcomplicate what is required.</p>
<p class="indent">This is Codeforces problem <code>39J</code> (Spelling Check). (The easiest way to find it is to search online for <em>Codeforces 39J</em>.)</p>
<h4 class="h4" id="sec17"><em>The Problem</em></h4>
<p class="noindent">In this problem, we are given two strings where the first string has one more character than the second. Our task is to determine the number of ways in which one character can be deleted from the first string to arrive at the second string. For example, there is one way to get from <code>favour</code> to <code>favor</code>: we can remove the <code>u</code> from the first string.</p>
<p class="indent">There are three ways to get from <code>abcdxxxef</code> to <code>abcdxxef</code>: we can remove any of the <code>x</code> characters from the first string.</p>
<p class="indent">The context for the problem is a spellchecker. The first string might be <code>bizzarre</code> (a misspelled word) and the second might be <code>bizarre</code> (a correct spelling). In this case, there are two ways to fix the misspelling—by removing either one of the two <code>z</code>s from the first string. The problem is more general, though, having nothing to do with actual English words or spelling mistakes.</p>
<h5 class="h5">Input</h5>
<p class="noindent">The input is two lines, with the first string on the first line and the second string on the second line. Each string can be up to one million characters.</p>
<h5 class="h5">Output</h5>
<p class="noindent">If there is no way to remove a character from the first string to get the second string, output <code>0</code>. Otherwise, output two lines:</p>
<ul>
<li class="noindents">On the first line, output the number of ways in which a character can be deleted from the first string to get the second string.</li>
<li class="noindents">On the second line, output a space-separated list of the indices of the characters in the first string that can be removed to get the <span epub:type="pagebreak" id="page_30"/>second string. The problem requires we index a string from <code>1</code>, not <code>0</code>. (That’s a bit annoying, but we’ll be careful.)</li>
</ul>
<p class="indent">For example, for this input:</p>
<pre>abcdxxxef
abcdxxef</pre>
<p class="noindent">we would output:</p>
<pre>3
5 6 7</pre>
<p class="indent">The <code>5 6 7</code> are the indices of the three <code>x</code> characters in the first string, since we are counting from one (not zero).</p>
<p class="indent">The time limit for solving the test cases is two seconds.</p>
<h4 class="h4" id="sec18"><em>Thinking About Hash Tables</em></h4>
<p class="noindent">I spent a truly embarrassing number of hours searching for the problems that drive the chapters in this book. The problems dictate what I can teach you about the relevant data structure or algorithm. I need the problem solutions to be algorithmically complex, but the problems themselves need to be sufficiently simple so that we can understand what is being asked and keep the relevant details at hand. I really thought I had found exactly that kind of hash table problem I needed for this section. Then I went to solve it.</p>
<p class="indent">In Problem 2, Login Mayhem, we were given the passwords as part of the input. That was nice, because we just jammed each substring from the passwords into a hash table and then used the hash table to search for them as needed. Here, in Problem 3, we’re not given any such list of strings to insert. Unfazed, when I first tried solving this problem, I created a hash table and I inserted into it each prefix of the second (that is, shorter) string. For example, for the word <code>abc</code>, I would have inserted <code>a</code>, <code>ab</code>, and <code>abc</code>. I also created another hash table for the suffixes of the second string. For the word <code>abc</code>, I would have inserted <code>c</code>, <code>bc</code>, and <code>abc</code>. Armed with those hash tables, I proceeded to consider each character of the first string. Removing each character is tantamount to splitting the string into a prefix and a suffix. We can just use the hash tables to check whether both the prefix and suffix are present. If they are, then removing that character is one of the ways in which we can transform the first string into the second.</p>
<p class="indent">This technique is tempting, right? Want to give it a try?</p>
<p class="indent">The thing I had failed to keep in mind was that each string could be up to a million characters long. We certainly can’t store all of the prefixes and suffixes themselves in the hash table—that would take up way too much memory. I played around with using pointers in the hash table to point to both the start and end of the prefixes and suffixes. That solves the concerns of memory use, but it doesn’t free us from having to compare these extra-long strings whenever we perform a search using the hash table. In Unique Snowflakes and Login Mayhem, the elements in the hash table were small: <span epub:type="pagebreak" id="page_31"/>6 integers for a snowflake and 10 characters for a password. That’s nothing. However, here, the situation is different: we might have strings of a million characters! Comparing such long strings is very time-consuming.</p>
<p class="indent">Another timesink here is computing the hashcode of prefixes and suffixes of these strings. We might call <code>oaat</code> on a string of length 900,000, and then call it again on a string with one additional character. That duplicates all of the work from the first <code>oaat</code> call, when all we wanted was to incorporate one more character into the string being hashed.</p>
<p class="indent">Yet, I persisted. I had it in my mind that a hash table was the way to go here, and I failed to consider alternatives. At this point, I probably should have taken a fresh look at the problem. Instead, I learned about <em>incremental hash functions</em>, hash functions that are very fast when generating the hash-code for an element that is very similar to the previously hashed element. For example, if I already have the hashcode for <code>abcde</code>, then computing the hashcode for <code>abcdef</code> using an incremental hash function will be very fast, because it can lean on the work already done for <code>abcde</code> rather than starting from scratch.</p>
<p class="indent">Another insight was that, if it is too costly to compare extra-long strings, we should try to avoid comparing them at all. We could just hope that our hash function is good enough and that we’re lucky enough with the test cases so that no collisions occur. If we look for some element in the hash table, and we find a match . . . well, let’s hope it was an actual match and not us getting unlucky with a false positive. If we’re willing to make this concession, then we can use a structure that’s simpler than the hash table array that we used up to this point in the chapter. In array <code>prefix1</code>, each index <code>i</code> gives the hashcode for the prefix of length <code>i</code> from the first string. In array <code>prefix2</code>, each index <code>i</code> gives the hashcode for the prefix of length <code>i</code> from the second string. In each of two other arrays, we can do similarly for the suffixes of the first string and suffixes of the second string.</p>
<p class="indent">Here is some code that shows how the <code>prefix1</code> array can be built:</p>
<pre>// long long is a very large integer type in C99
unsigned long long prefix1[1000001];
prefix1[0] = 0;
for (i = 1; i &lt;= strlen(first_string); i++)
<span class="ent">❶</span> prefix1[i] = prefix1[i - 1] * 39 + first_string[i];</pre>
<p class="indent">The other arrays can be built similarly.</p>
<p class="indent">It’s important that we use unsigned integers here. In C, overflow is well defined on unsigned integers but not signed integers. If a word is long enough, we’ll definitely get overflow, so we don’t want to allow undefined behavior.</p>
<p class="indent">Now we can use these arrays to determine whether prefixes or suffixes match. For example, to determine whether the first <code>i</code> characters of the first string equal the first <code>i</code> characters of the second string, just check whether <code>prefix1[i]</code> and <code>prefix2[i]</code> are equal.</p>
<p class="indent">Note how little work it takes to calculate the hashcode for <code>prefix1[i]</code> given the hashcode for <code>prefix1[i - 1]</code>: it’s just a multiplication, followed by <span epub:type="pagebreak" id="page_32"/>adding the new character <span class="ent">➊</span>. Why multiply by 39 and add the character? Why not use something else for the hash function? Honestly, because what I chose didn’t lead to any collisions in the Codeforces test cases. Yes, I know, it’s unsatisfying.</p>
<p class="indent">Not to worry, though: there’s a better way! To get there, we’ll stare at the problem a little more closely, instead of just jumping to a hash table solution.</p>
<h4 class="h4" id="sec19"><em>An Ad Hoc Solution</em></h4>
<p class="noindent">Let’s think more carefully through an earlier example:</p>
<pre>abcdxxxef
abcdxxef</pre>
<p class="indent">Suppose that we remove the <code>f</code> from the first string (index <code>9</code>). Does this make the first string equal the second? No, so <code>9</code> will not show up in our space-separated list of indices. The strings have a long prefix of matching characters. There are six such characters to be exact: <code>abcdxx</code>. After that, the two strings diverge, where the first string has an <code>x</code> and the second has an <code>e</code>. If we don’t fix that, then we have no hope that the two strings will be equal. The <code>f</code> is too far to the right for its deletion to produce equal strings.</p>
<p class="indent">That leads to our first observation: if the length of the <em>longest common prefix</em> (in our example, six, the length of <code>abcdxx</code>) is <em>p</em>, then our only options for deleting characters are those with indices of <em>≤</em> <em>p</em> + 1. In our example, we should consider deleting the characters whose indices are <em>≤</em> 7: <code>a</code>, <code>b</code>, <code>c</code>, <code>d</code>, the first <code>x</code>, the second <code>x</code>, and the third <code>x</code>. Deleting anything to the right of index <em>p</em> + 1 doesn’t fix the diverging character at index <em>p</em> + 1 and hence can’t make the strings equal.</p>
<p class="indent">Notice that only some of these deletions actually work. For example, deleting the <code>a</code>, <code>b</code>, <code>c</code>, or <code>d</code> from the first string does not give us the second string. Only each of the three deletions of <code>x</code> gives us the second string. So, while we’ve got an upper bound for indices to consider (<em>≤</em> <em>p</em> + 1), we also need a lower bound.</p>
<p class="indent">To think about a lower bound, consider removing the <code>a</code> from the first string. Does that make the two strings equal? Nope. The reasoning is similar to that in the previous paragraph: there are diverging characters to the right of the <code>a</code> that can’t possibly be fixed by removing the <code>a</code>. If the length of the <em>longest common suffix</em> (in our example, four, the length of <code>xxef</code>) is <em>s</em>, then we should consider deleting each of the final <em>s</em> + 1 characters of the first string. In terms of indices, we’re interested only in those that are ≥ <em>n</em> – <em>s</em>, where <em>n</em> is the length of the first string. In our example, this tells us to consider only indices that are <em>≥</em> 9 – 4 = 5. In the above paragraph, we argued that we should look at only indices that are <em>≤</em> 7. Together, we see that indices <code>5</code>, <code>6</code>, and <code>7</code> are the ones whose deletion transforms the first string into the second. As can be seen in <a href="ch01.xhtml#ch01fig04">Figure 1-4</a>, what matters here are the indices that are included in both the prefixes and suffixes: each of those characters is a valid deletion.<span epub:type="pagebreak" id="page_33"/></p>
<div class="image"><img alt="Image" id="ch01fig04" src="../images/ch01fig04.jpg"/></div>
<p class="figcap"><em>Figure 1-4: Overlap between the longest prefix and longest suffix</em></p>
<p class="indent">In general, the indices of interest go from <em>n</em> – <em>s</em> to <em>p</em> + 1. For any index in this range, we know from <em>p</em> + 1 that the two strings are the same prior to the index. We also know from <em>n</em> – <em>s</em> that the two strings are the same after the index. Therefore, once we remove the index, the two strings are identical. If the range is empty, then there are <em>no</em> indices whose deletion transforms the first string into the second, so <code>0</code> is output in this case. Otherwise, we use a <code>for</code> loop to loop through the indices and <code>printf</code> to produce the space-separated list. Let’s take a look at the code!</p>
<h5 class="h5">Longest Common Prefix</h5>
<p class="noindent">We have a helper function in <a href="ch01.xhtml#ch01ex019">Listing 1-19</a> to calculate the length of the longest common prefix of two strings.</p>
<pre>int prefix_length(char s1[], char s2[]) {
  int i = 1;
  while (s1[i] == s2[i])
    i++;
  return i - 1;
}</pre>
<p class="excap" id="ch01ex019"><em>Listing 1-19: Calculating the longest common prefix</em></p>
<p class="indent">Here <code>s1</code> is the first string and <code>s2</code> is the second string. We use <code>1</code> as the starting index of the strings. Starting at index <code>1</code>, the loop continues as long as corresponding characters are equal. (In a case such as <code>abcde</code> and <code>abcd</code>, the <code>e</code> will fail to match the null terminator at the end of <code>abcd</code>, so <code>i</code> will correctly end up with value <code>5</code>.) When the loop terminates, index <code>i</code> is the index of the first mismatched character; therefore, <code>i - 1</code> is the length of the longest common prefix.</p>
<h5 class="h5">Longest Common Suffix</h5>
<p class="noindent">Now, to calculate the longest common suffix, we use <a href="ch01.xhtml#ch01ex020">Listing 1-20</a>.<span epub:type="pagebreak" id="page_34"/></p>
<pre>int suffix_length(char s1[], char s2[], int len) {
  int i = len;
  while (i &gt;= 2 &amp;&amp; s1[i] == s2[i - 1])
    i--;
  return len - i;
}</pre>
<p class="excap" id="ch01ex020"><em>Listing 1-20: Calculating the longest common suffix</em></p>
<p class="indent">The code is quite similar to <a href="ch01.xhtml#ch01ex019">Listing 1-19</a>. This time, however, we compare from right to left, rather than left to right. For this reason, we need the <code>len</code> parameter, which gives us the length of the first string. The final comparison that we’re allowed to make is <code>i == 2</code>. If we had <code>i == 1</code>, then we’d be accessing <code>s2[0]</code>, which is not a valid element of the string!</p>
<h5 class="h5">The main Function</h5>
<p class="noindent">Finally, we have our <code>main</code> function in <a href="ch01.xhtml#ch01ex021">Listing 1-21</a>.</p>
<pre> #define SIZE 1000000

 int main(void) {
<span class="ent">❶</span> static char s1[SIZE + 2], s2[SIZE + 2];
   int len, prefix, suffix, total;
<span class="ent">➋</span> gets(&amp;s1[1]);
<span class="ent">➌</span> gets(&amp;s2[1]);

   len = strlen(&amp;s1[1]);
   prefix = prefix_length(s1, s2);
   suffix = suffix_length(s1, s2, len);
<span class="ent">➍</span> total = (prefix + 1) - (len - suffix) + 1;
<span class="ent">➎</span> if (total &lt; 0)
  <span class="ent">➏</span> total = 0;

<span class="ent">❼</span> printf("%d\n", total);
<span class="ent">❽</span> for (int i = 0; i &lt; total; i++) {
     printf("%d", i + len - suffix);
     if (i &lt; total - 1)
       printf(" ");
     else
       printf("\n");
  }
  return 0;
}</pre>
<p class="excap" id="ch01ex021"><em>Listing 1-21: The</em> <span class="codeitalic1">main</span> <em>function</em></p>
<p class="indent">We use <code>SIZE + 2</code> as the size of our two character arrays <span class="ent">➊</span>. The maximum number of characters that we’re required to read is one million, but we need <span epub:type="pagebreak" id="page_35"/>an extra element for the null terminator. And we need one element on top of that because we start indexing our strings at index <code>1</code>, “wasting” index <code>0</code>.</p>
<p class="indent">We read the first <span class="ent">➋</span> and second string <span class="ent">➌</span>. Notice we pass a pointer to index <code>1</code> of each string: <code>gets</code> therefore starts storing characters at index <code>1</code> rather than index <code>0</code>. After calling our helper functions, we calculate the number of indices that can be deleted from <code>s1</code> to give us <code>s2</code> <span class="ent">➍</span>. If this number is negative <span class="ent">➎</span>, then we set it to <code>0</code> <span class="ent">➏</span>. This makes the <code>printf</code> call correct <span class="ent">❼</span>. We use a <code>for</code> loop <span class="ent">❽</span> to print the correct indices. We want to start printing at <code>len - suffix</code>, so we add <code>len - suffix</code> to each integer <code>i</code>.</p>
<p class="indent">When submitting to the judge, you may need to choose GNU G++ rather than GNU GCC.</p>
<p class="indent">There we have it: a linear-time solution. We had to perform some tough analysis, but after that we were able to proceed without complex code and without the need for a hash table. Before considering a hash table, ask yourself, is there anything about the problem that would make hash tables unwieldy? Is a search really necessary, or are there features of the problem that obviate such searching in the first place?</p>
<h3 class="h3" id="lev15">Summary</h3>
<p class="noindent">A hash table is a data structure: a way to organize data so that certain operations are fast. Hash tables speed up the search for some specified element. To speed up other operations, we need other data structures. For example, in <a href="ch08.xhtml">Chapter 8</a>, we’ll learn about a heap, which is a data structure that can be used when we need to quickly identify the maximum or minimum element in an array.</p>
<p class="indent">Data structures are general approaches to organizing and manipulating data. Hash tables apply to all kinds of problems beyond what is shown here; I hope that you now have good intuition for when a hash table can be used. Be on the lookout for other problems where otherwise efficient solutions are hampered by repeated, slow searches.</p>
<h3 class="h3" id="lev16">Notes</h3>
<p class="noindent">Unique Snowflakes is originally from the 2007 Canadian Computing Olympiad.</p>
<p class="indent">Login Mayhem is based on a problem from the 2017 Croatian Open Competition in Informatics, Round 1.</p>
<p class="indent">Spelling Check is originally from the 2010 School Team Contest #1, hosted by Codeforces. The prefix-suffix solution (used after I finally gave up on a hash table solution) originates from a note posted at <a href="https://codeforces.com/blog/entry/786"><em>https://codeforces.com/blog/entry/786</em></a>.</p>
<p class="indent">In our hash table code, we used <code>malloc</code> to allocate nodes of our linked lists. It’s sometimes possible to avoid using <code>malloc</code> and node structures altogether. See “Unique Snowflakes: Implicit Linked Lists” in <a href="app02.xhtml">Appendix B</a> if you’re interested in how that can be done.<span epub:type="pagebreak" id="page_36"/></p>
<p class="indent">The <code>oaat</code> hash function is by Bob Jenkins (see <a href="http://burtleburtle.net/bob/hash/doobs.html"><em>http://burtleburtle.net/bob/hash/doobs.html</em></a>).</p>
<p class="indent">For additional information about hash table applications and implementations, see <em>Algorithms Illuminated (Part 2): Graph Algorithms and Data Structures</em> by Tim Roughgarden (2018).</p>
</body></html>