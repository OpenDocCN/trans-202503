- en: <hgroup>
  id: totrans-0
  prefs: []
  type: TYPE_NORMAL
  zh: <hgroup>
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">5</samp> <samp class="SANS_Dogma_OT_Bold_B_11">FUNCTIONS</samp>
  id: totrans-1
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">5</samp> <samp class="SANS_Dogma_OT_Bold_B_11">函数</samp>
- en: </hgroup>
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: </hgroup>
- en: '![](../images/opener.png)'
  id: totrans-3
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/opener.png)'
- en: As you learned in [Chapter 1](chapter1.xhtml), a *function* is a self-contained
    block of code for performing a certain task. We’ve already used some of JavaScript’s
    built-in functions, such as alert and console.log, but you can also create your
    own custom functions to perform the tasks particular to your application. Then
    you can *call* these functions to run the associated code. Packaging code into
    functions in this way makes your programming more effective, as you don’t have
    to repeat the code every time you want to use it.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你在[第1章](chapter1.xhtml)中学到的，*函数*是一个自包含的代码块，用于执行特定任务。我们已经使用了一些JavaScript的内置函数，例如alert和console.log，但你也可以创建自己的自定义函数来执行应用程序中特定的任务。然后，你可以*调用*这些函数来运行关联的代码。以这种方式将代码封装成函数，可以使你的编程更加高效，因为你不必每次使用代码时都重复它。
- en: In this chapter, you’ll learn different techniques for writing your own functions.
    You’ll see how to provide input to functions and receive output from them. You’ll
    also see how functions can be treated as ordinary values, just like a number or
    a string. In particular, we’ll explore how functions can serve as input or output
    for other, higher-order functions.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章中，你将学习编写自己函数的不同技巧。你将看到如何向函数提供输入并从中接收输出。你还将看到函数如何作为普通值处理，就像数字或字符串一样。特别是，我们将探索函数如何作为其他高阶函数的输入或输出。
- en: <samp class="SANS_Futura_Std_Bold_B_11">Declaring and Calling Functions</samp>
  id: totrans-6
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">声明和调用函数</samp>
- en: 'Before you can use a custom function, you have to establish what the function
    is called and what it does. One way is to use a *function declaration*, a block
    of code that defines a function. To illustrate, we’ll declare a simple function
    called sayHello that takes in someone’s name and logs a custom greeting for that
    person to the console. Open the JavaScript console in Chrome and enter the following:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用自定义函数之前，你必须先定义函数的名称和它的功能。一种方法是使用*函数声明*，这是一个定义函数的代码块。为了说明这一点，我们将声明一个简单的函数，名为sayHello，它接受某人的名字并在控制台中记录一条个性化的问候信息。在Chrome中打开JavaScript控制台并输入以下内容：
- en: '[PRE0]'
  id: totrans-8
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: A function declaration has four parts. First, we use the function keyword to
    tell JavaScript we’re creating a function. Next, we give the function a name—in
    this case, sayHello. After that, we provide a comma-separated list of the function’s
    parameters, surrounded by parentheses. *Parameters* are pieces of information
    that the function needs to do its job. In this case, our function has one parameter,
    name, indicating that the function needs to be supplied with someone’s name in
    order to create a greeting. (If a function has no parameters, we simply write
    an empty set of parentheses.) Finally, we write the function’s body, surrounded
    by braces. This is the code that should be executed when the function is called.
    In our example, the body consists of a call to console.log to print out a greeting,
    with the value of the name parameter inserted via a template literal.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 函数声明有四个部分。首先，我们使用function关键字来告诉JavaScript我们正在创建一个函数。接下来，我们给函数命名——在本例中为sayHello。然后，我们提供一个由逗号分隔的函数参数列表，参数用括号括起来。*参数*是函数执行任务所需要的信息。在这个例子中，我们的函数有一个参数name，表示该函数需要提供某人的名字来创建问候语。（如果函数没有参数，我们只需写一个空的括号。）最后，我们写出函数体，用大括号括起来。这是当调用函数时应该执行的代码。在我们的示例中，函数体包含一个console.log调用，用于打印问候语，并通过模板字符串插入name参数的值。
- en: 'Now that we’ve declared our sayHello function, we can call it whenever we want
    to greet someone. Each time we call the function, we’ll need to provide a value
    for the name parameter. That value is called an *argument*, and it’s specified
    in parentheses when the function is called. By passing the function different
    arguments, we can create different custom greetings. For example:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经声明了sayHello函数，我们可以在任何时候调用它来问候某人。每次调用函数时，我们需要为name参数提供一个值。这个值叫做*参数*，并在调用函数时通过括号指定。通过传递不同的参数，我们可以创建不同的个性化问候语。例如：
- en: '[PRE1]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The first time we call our sayHello function, we pass "Nick" as an argument
    in the parentheses after the function name. As a result, the message Hello, Nick!
    is logged to the console. The second time we call the function, we pass "Mei"
    as an argument, so the message Hello, Mei! is logged. In each case, the value
    of the argument is bound to the function’s name parameter, and the function body
    runs with the name parameter set to that value. Essentially, you can think of
    name as a variable within the function that takes on the value of the corresponding
    argument (such as "Nick" or "Mei") when the function is called.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 第一次调用我们的 sayHello 函数时，我们在函数名后面的括号中传入 "Nick" 作为参数。因此，消息 Hello, Nick! 被打印到控制台。第二次调用函数时，我们传入
    "Mei" 作为参数，因此消息 Hello, Mei! 被打印。每次调用时，参数的值会绑定到函数的名称参数上，函数体根据该参数值执行。实际上，你可以将 name
    理解为函数内部的一个变量，当函数被调用时，它会根据相应的参数（如 "Nick" 或 "Mei"）赋值。
- en: 'The distinction between parameters and arguments is subtle but important. Parameters
    are generic names for a function’s inputs, whereas arguments are the actual input
    values passed to the function when you call it. Each function has only one set
    of parameters, but every time you call the function it can have a new set of arguments.
    In this way, parameters make your functions highly customizable. The sayHello
    function, for example, has one parameter, name, but it can be called with a different
    argument each time. We’ve seen it called with sayHello("Nick") and sayHello("Mei"),
    but the possibilities are endless: sayHello("Kitty"), sayHello("Dolly"), sayHello("world"),
    and so on.'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 参数和实参之间的区别微妙但重要。参数是函数输入的通用名称，而实参是在调用函数时传递给函数的实际输入值。每个函数只有一组参数，但每次调用函数时，它可以有一组新的实参。通过这种方式，参数使得函数具有高度的可定制性。例如，sayHello
    函数有一个参数 name，但每次调用时都可以传入不同的实参。我们见过它被这样调用：sayHello("Nick") 和 sayHello("Mei")，但可能性是无穷的：sayHello("Kitty")、sayHello("Dolly")、sayHello("world")
    等等。
- en: Notice that each call to sayHello outputs undefined as well as the custom greeting.
    This extra line of output is the function’s return value. sayHello returns undefined
    because we didn’t explicitly give it a return value; we’ll look at how to do that
    next.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，每次调用 sayHello 时，它会输出 undefined 以及自定义的问候语。这个额外的输出行就是函数的返回值。sayHello 返回 undefined，因为我们没有显式给它返回值；接下来我们将学习如何做到这一点。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Return Values</samp>
  id: totrans-15
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">返回值</samp>
- en: 'A *return value* is a value that a function produces for use elsewhere in your
    code. In many cases, you’ll want a function to take in some inputs using parameters,
    process those inputs in some way, and output the result. That output is the return
    value. For example, let’s declare a function that takes in two numbers and returns
    their sum:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '*返回值* 是一个函数产生的值，可以在代码的其他地方使用。在许多情况下，你希望一个函数使用参数接收一些输入，处理这些输入并输出结果。这个输出就是返回值。例如，假设我们声明一个函数，接收两个数字并返回它们的和：'
- en: '[PRE2]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'This add function has two parameters, x and y. The function body consists of
    the return keyword followed by the expression x + y. When the function is called,
    JavaScript will evaluate this expression, adding x and y together, and return
    the result, as shown here:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 这个 add 函数有两个参数，x 和 y。函数体由 return 关键字和表达式 x + y 组成。当调用该函数时，JavaScript 会计算这个表达式，将
    x 和 y 相加，并返回结果，如下所示：
- en: '[PRE3]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: We call add with the arguments 1 and 2, which become the values for parameters
    x and y, respectively. (The arguments are matched with the parameters in the order
    in which they’re given.) The function sums the two arguments and returns the resulting
    value, 3.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 我们用 1 和 2 作为实参调用 add，它们分别成为参数 x 和 y 的值。（实参按给定的顺序与参数一一对应。）该函数将两个实参相加并返回结果 3。
- en: When we call a function in the Chrome console, its return value is automatically
    printed out—but it’s important to distinguish between a function explicitly logging
    text to the console, as we saw sayHello do earlier, and a function returning a
    value, as add is doing here. When a function logs a value using console.log, the
    only place that value exists is in the log; we can’t make further use of it later.
    By contrast, when a function returns a value, we can then use that value later
    in our code. The fact that the return value is also displayed in the console is
    largely irrelevant. It helps us see what the function is doing, but logging to
    the console isn’t the add function’s main purpose, unlike the sayHello function.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在Chrome控制台中调用一个函数时，它的返回值会自动打印出来——但需要注意区分函数显式将文本记录到控制台（就像我们之前看到的sayHello做的那样）和函数返回值（就像这里的add）。当函数使用console.log记录一个值时，这个值只存在于日志中；我们无法在后续代码中进一步使用它。相反，当一个函数返回一个值时，我们可以在代码中稍后使用该值。尽管返回值也会在控制台中显示，但这基本上是无关紧要的。它帮助我们看到函数的行为，但记录到控制台并不是add函数的主要目的，而sayHello函数则不同。
- en: 'One way to make use of a function’s return value is to call the function as
    part of an assignment expression, so the return value will be stored in a variable.
    Then we can work with that variable later in the code. For example:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 使用函数的返回值的一种方式是将函数调用作为赋值表达式的一部分，这样返回值就会被存储在一个变量中。然后，我们可以在代码中稍后使用这个变量。例如：
- en: '[PRE4]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Here we declare the variable sum and initialize it to the return value of the
    add function, which we call with the arguments 500 and 500. The console shows
    undefined even though add has a return value because, as discussed in [Chapter
    2](chapter2.xhtml), declaring a variable always prints undefined. We then use
    the function’s return value by incorporating sum into a template literal to create
    the string "I walked 1000 miles".
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们声明了变量sum，并将其初始化为add函数的返回值，我们用500和500作为参数调用add。尽管add函数有返回值，控制台显示的是undefined，因为正如在[第二章](chapter2.xhtml)中讨论的那样，声明变量时总是打印undefined。然后，我们通过将sum嵌入到模板字面量中，利用该函数的返回值，生成字符串"I
    walked 1000 miles"。
- en: Notice that it wouldn’t be possible to do something similar with our sayHello
    function as it’s currently written. For example, we can’t use it to generate the
    greeting "Hello, Nick!" and then write some code to incorporate that greeting
    into a longer string. The sayHello function returns undefined, because we didn’t
    use the return keyword to explicitly give it a return value. It merely logs the
    greeting to the console, and there’s no way to access the greeting once it’s been
    logged.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，像当前写法的sayHello函数，我们无法做类似的事情。例如，我们不能用它来生成问候语"Hello, Nick!"，然后编写一些代码将该问候语嵌入到一个更长的字符串中。sayHello函数返回的是undefined，因为我们没有使用return关键字显式地给它返回值。它只是将问候语记录到控制台，而一旦记录完毕，就无法再次访问该问候语。
- en: 'It’s not necessary to store a function’s return value in a variable to use
    it. A function call that returns a value can be used anywhere a value can be used,
    just as you can use variables and literal values interchangeably. For instance,
    the previous example could be rewritten like so:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 使用函数的返回值时，并不一定要将其存储在变量中。返回值的函数调用可以在任何可以使用值的地方使用，就像你可以交换使用变量和字面量值一样。例如，前面的示例可以这样重写：
- en: '[PRE5]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Here, instead of calling add separately and storing the result in a variable,
    we call the function from within the template literal. Its return value is inserted
    directly into the resulting string, producing the same message as before. It’s
    often more readable to store the return value in a variable, but both approaches
    are equally valid.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们不是单独调用add并将结果存储在一个变量中，而是从模板字面量内调用该函数。它的返回值直接插入到生成的字符串中，产生与之前相同的消息。通常将返回值存储在变量中会更易读，但两种方式都是有效的。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Parameter Types</samp>
  id: totrans-29
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">参数类型</samp>
- en: The data types of function parameters in JavaScript are not fixed. This is because
    JavaScript is a *dynamically typed* programming language, in which the types of
    variables and parameters can change while the program is running, as opposed to
    a *statically typed* language, in which the types of variables and parameters
    are determined before the program is run.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript中的函数参数的数据类型是动态变化的。这是因为JavaScript是一种*动态类型*的编程语言，其中变量和参数的类型可以在程序运行时发生变化，而与此相对的是*静态类型*语言，其中变量和参数的类型在程序运行之前就已确定。
- en: 'To illustrate, so far we’ve been using the add function to add numbers together,
    but there’s nothing stopping us from using it to concatenate two strings:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 举个例子，到目前为止我们一直在使用add函数来相加数字，但没有什么能阻止我们将其用来连接两个字符串：
- en: '[PRE6]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Here we pass the function two strings as arguments, so the + operator in the
    function body is interpreted to mean string concatenation rather than numerical
    addition. The function therefore combines the strings and returns the result.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将两个字符串作为参数传递给函数，因此函数体内的+运算符会被解释为字符串连接，而不是数字加法。因此，函数会将两个字符串合并并返回结果。
- en: 'By extension, we could also pass arguments of other types, or even mix data
    types within the same function call:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 从这个角度看，我们也可以传递其他类型的参数，甚至在同一个函数调用中混合数据类型：
- en: '[PRE7]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: In these cases, JavaScript’s rules around type coercion, discussed in [Chapter
    2](chapter2.xhtml), come into play. When we try to add two Booleans with add(true,
    false), JavaScript converts the Booleans to the numbers 1 and 0 before the addition,
    producing the number 1. When we try to add a number and a string with add(1, "1"),
    JavaScript converts both of the operands to strings and concatenates them, producing
    the string "11".
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些情况下，JavaScript 关于类型强制转换的规则（在[第二章](chapter2.xhtml)中讨论过）会起作用。当我们尝试使用add(true,
    false)将两个布尔值相加时，JavaScript会在加法前将布尔值转换为数字1和0，从而得到数字1。当我们尝试使用add(1, "1")将数字和字符串相加时，JavaScript会将两个操作数都转换为字符串并将它们连接起来，得到字符串"11"。
- en: Dynamic typing brings a lot of flexibility to JavaScript, but if you aren’t
    careful, it can also open the way for some confusing bugs. It’s essential to have
    a good idea of the types you’re using, to make sure you’re not passing a string
    to a function that expects a number, for example.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 动态类型为JavaScript带来了很大的灵活性，但如果不小心，它也可能引发一些令人困惑的bug。了解你使用的类型非常重要，以确保你没有向期望数字的函数传递字符串类型的参数。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Side Effects</samp>
  id: totrans-38
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">副作用</samp>
- en: A *side effect* is anything a function does that makes a difference outside
    of the function itself, apart from returning a value. Side effects can be intended
    or unintended, and include updating the value of a variable declared outside the
    function, modifying an array or object declared outside the function, or outputting
    a string to the console.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '*副作用*是指函数执行时，除了返回值外，会对函数外部产生影响的任何操作。副作用可以是有意的，也可以是无意的，包括更新函数外部声明的变量值、修改函数外部声明的数组或对象，或者向控制台输出字符串。'
- en: 'Some functions, like our add function, have no side effects and are called
    only for their return value. Other functions, like sayHello, have no return value
    and are called only for their side effects. It’s also possible to write functions
    that return a value *and* have side effects. For example, we can redefine add
    to log some information to the console and update a variable, in addition to returning
    the sum of its arguments:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 一些函数，比如我们的add函数，没有副作用，仅仅因为返回值而被调用。另一些函数，比如sayHello，没有返回值，仅仅因为副作用而被调用。也可以编写同时返回值*并*具有副作用的函数。例如，我们可以重新定义add函数，除了返回参数和外，还可以将一些信息记录到控制台并更新一个变量：
- en: '[PRE8]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Here we declare the variable addCalls, which we’ll use to keep track of how
    often the add function is called. Then we write our updated add function declaration.
    The function now increments addCalls and logs the values of its parameters to
    the console, before returning the sum of the parameters, as before.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们声明了变量addCalls，用于跟踪add函数被调用的次数。然后，我们编写了更新后的add函数声明。现在该函数会先递增addCalls，并将参数值记录到控制台中，然后像之前一样返回参数的和。
- en: 'Let’s try calling the revised function:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试调用修改后的函数：
- en: '[PRE9]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The function call has the side effect of logging the two values to the console
    before adding them together. It also has the side effect of updating the addCalls
    variable, changing its value from 0 to 1. Additionally, the function has the (non–side
    effect) result of returning the sum of its arguments, which we’ve stored in the
    sum variable.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 该函数调用具有副作用，即在将两个值相加之前，将它们记录到控制台中。它还有一个副作用，就是更新了addCalls变量，将其值从0改为1。此外，函数还有一个（非副作用）结果，即返回其参数的和，我们已将其存储在sum变量中。
- en: If we made further calls to add, the variable addCalls would keep incrementing
    each time, giving us a running count of the number of times the function is called.
    You don’t typically need to keep track of the number of times a function is called
    like this, although you could use such a mechanism to restrict how often a program
    is allowed to call some function that requires a lot of processing power (a technique
    known as *rate limiting*). You could achieve this by periodically resetting the
    counter—perhaps every minute—and skipping the function call if the counter goes
    over some threshold.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们进一步调用 add，变量 addCalls 将每次递增，从而提供一个函数被调用次数的实时计数。通常，你不需要像这样跟踪函数的调用次数，尽管你可以使用这种机制来限制程序调用某些需要大量处理能力的函数的频率（这种技术被称为*速率限制*）。你可以通过定期重置计数器来实现这一点——也许每分钟一次——并且当计数器超过某个阈值时跳过函数调用。
- en: <samp class="SANS_Futura_Std_Bold_B_11">Passing a Function as an Argument</samp>
  id: totrans-47
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">将函数作为参数传递</samp>
- en: In JavaScript, functions are *first-class citizens*, which means they can be
    used like any other value, such as a number or a string. For example, you can
    store a function in a variable or pass a function as an argument to another function.
    The latter is especially common, as there are many functions that delegate work
    to other functions. When a function is passed as an argument, it’s often referred
    to as a *callback* because the function it’s passed to is said to “call it back”
    by executing it.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在 JavaScript 中，函数是*一等公民*，这意味着它们可以像其他值一样使用，例如数字或字符串。例如，你可以将函数存储在变量中，或者将函数作为参数传递给另一个函数。后一种情况尤其常见，因为有许多函数将工作委托给其他函数。当一个函数作为参数传递时，它通常被称为*回调函数*，因为传递它的函数会“回调”它并执行它。
- en: 'We’ll illustrate this with JavaScript’s built-in setTimeout function, which
    allows you to delay the calling of another function. It takes two arguments: a
    function to call, and a time in milliseconds (ms) to wait before calling that
    function. Here’s how it works:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将通过 JavaScript 内置的 setTimeout 函数来说明这一点，setTimeout 允许你延迟调用另一个函数。它需要两个参数：一个要调用的函数，和一个等待时间（以毫秒为单位），即在调用该函数之前需要等待的时间。以下是它的工作原理：
- en: '[PRE10]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: First we create a simple function with no arguments, sayHi, which just calls
    console.log. We then call setTimeout, passing the sayHi function and the number
    2000 (indicating 2,000 ms, or 2 seconds) as arguments. Once you press ENTER, setTimeout
    should immediately return a *timeout ID*—in this case, 1—which is a unique identifier
    you could use to cancel the delayed function call if desired. Then, after two
    seconds, the sayHi function is called, and the string "Hi!" is logged to the console.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们创建一个没有参数的简单函数 sayHi，它只调用 console.log。然后我们调用 setTimeout，传递 sayHi 函数和数字 2000（表示
    2000 毫秒，即 2 秒）作为参数。一旦按下 ENTER，setTimeout 应立即返回一个*超时 ID*——在这种情况下是 1——这是一个唯一的标识符，你可以用它来取消延迟的函数调用（如果需要的话）。然后，经过两秒钟，sayHi
    函数被调用，字符串 "Hi!" 被记录到控制台。
- en: <samp class="SANS_Dogma_OT_Bold_B_21">NOTE</samp>
  id: totrans-52
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: <samp class="SANS_Dogma_OT_Bold_B_21">注意</samp>
- en: '*To cancel a function call delayed with setTimeout, call the clearTimeout function,
    passing the timeout ID as an argument.*'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '*要取消通过 setTimeout 延迟的函数调用，请调用 clearTimeout 函数，并将超时 ID 作为参数传递。*'
- en: 'Notice that when we pass a function as an argument, we write its name without
    parentheses: in this case, sayHi rather than sayHi(). A function name without
    parentheses simply *refers* to the function, while a function name with parentheses
    actually *calls* the function. We can see this distinction in the JavaScript console:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，当我们将函数作为参数传递时，我们写下的是它的名字而不带括号：在这种情况下是 sayHi 而不是 sayHi()。没有括号的函数名仅仅是*引用*该函数，而带括号的函数名则实际*调用*该函数。我们可以在
    JavaScript 控制台中看到这种区别：
- en: '[PRE11]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Executing just plain sayHi; without parentheses ❶ prints the function’s definition
    but doesn’t call it. However, executing sayHi(); with parentheses ❷ calls the
    sayHi function, printing the string "Hi!" and returning undefined.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 仅仅执行 sayHi; 不带括号 ❶ 会打印出函数的定义，但不会调用它。然而，执行 sayHi(); 带括号 ❷ 会调用 sayHi 函数，打印字符串
    "Hi!" 并返回 undefined。
- en: <samp class="SANS_Futura_Std_Bold_B_11">Other Function Syntaxes</samp>
  id: totrans-57
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">其他函数语法</samp>
- en: So far in this chapter we’ve focused on creating functions using function declarations,
    but JavaScript also supports other ways to create functions. Function declarations
    follow a straightforward format and use a similar syntax to how functions are
    defined in many other languages, like C++ and Python. They’re perfectly fine when
    you’re writing functions that you intend to call directly, like the sayHello and
    add functions that we’ve discussed. However, once you start treating functions
    as values by passing them as arguments and the like, the other styles of creating
    functions become more useful. We’ll turn to those now, starting with function
    expressions.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们在本章中主要关注了使用函数声明来创建函数，但 JavaScript 也支持其他创建函数的方法。函数声明遵循简洁的格式，并使用类似于许多其他编程语言（如
    C++ 和 Python）中定义函数的语法。当你编写函数并打算直接调用时，像我们讨论过的 sayHello 和 add 函数，使用函数声明完全没问题。然而，一旦你开始将函数作为值来传递（例如作为参数），其他的创建函数的方式就会变得更加有用。接下来我们将介绍这些方式，首先从函数表达式开始。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Function Expressions</samp>
  id: totrans-59
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">函数表达式</samp>
- en: A *function expression*, also known as a *function literal*, is a code literal
    whose value is a function, just as 123 is a literal whose value is the number
    123\. Whereas a function declaration creates a function and binds it to a name,
    a function expression is an expression that evaluates to (returns) a function,
    for you to do with what you will.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '*函数表达式*，也称为*函数字面量*，是一种其值为函数的代码字面量，就像123是一个其值为数字123的字面量一样。而函数声明创建一个函数并将其绑定到一个名称上，函数表达式则是一个求值为（返回）函数的表达式，供你自由使用。'
- en: Syntactically, a function expression looks very similar to a function declaration,
    with two main differences. First, a function expression doesn’t have to include
    a name, although you can include one if you want. Function expressions without
    names are also called *anonymous functions*. Second, a function expression can’t
    be written at the start of a line of code, or JavaScript will think it’s a function
    declaration; there has to be some code before the function keyword. This is why
    function expressions are often used in contexts where functions need to be treated
    as values.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 从语法上看，函数表达式与函数声明非常相似，主要有两个不同之处。首先，函数表达式不需要包括名称，尽管你可以根据需要添加名称。没有名称的函数表达式也被称为*匿名函数*。其次，函数表达式不能写在代码行的开头，否则
    JavaScript 会认为它是一个函数声明；在 `function` 关键字之前必须有一些代码。这也是为什么函数表达式通常用于函数需要作为值来处理的上下文。
- en: 'For example, you can define a function expression and assign it as the value
    of a variable, all in one statement, as shown here:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，你可以定义一个函数表达式并将其赋值为一个变量的值，所有操作都在一条语句中完成，如下所示：
- en: '[PRE12]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The function keyword appears on the right side of an assignment statement, rather
    than at the start of a line, so JavaScript treats this as a function expression.
    In this case, we’re assigning the function expression to the addExpression variable.
    The function itself is anonymous, since we don’t provide a name after the function
    keyword (you’ll see an example where we do this in the “Named Function Expressions”
    box on the following page). It has two parameters, x and y, specified in parentheses,
    just like our original add function. The body returns the sum of the parameters
    and is enclosed in braces, much like the body of a function declaration, but notice
    that we need to put a semicolon after the closing brace to signify the end of
    the statement assigning the function to a variable.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在赋值语句的右侧出现`function`关键字，而不是在行首，因此 JavaScript 会将其视为一个函数表达式。在这种情况下，我们将函数表达式赋值给了
    `addExpression` 变量。函数本身是匿名的，因为我们没有在`function`关键字后提供一个名称（在接下来的“命名函数表达式”框中，你会看到我们如何这样做的例子）。它有两个参数，x
    和 y，括号中指定，就像我们最初的 add 函数一样。函数体返回这两个参数的和，并用大括号括起来，类似于函数声明的函数体，但请注意，我们需要在大括号闭合后加上分号，以表示将函数赋值给变量的语句结束。
- en: 'Although the function itself is technically anonymous, it’s now bound to the
    addExpression variable. We can therefore call the function by putting a pair of
    parentheses containing the necessary arguments after the variable name, just like
    calling any named function:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管函数本身在技术上是匿名的，但它现在已绑定到 `addExpression` 变量。因此，我们可以通过在变量名后加上一对括号并传入必要的参数来调用该函数，就像调用任何命名函数一样：
- en: '[PRE13]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Entering addExpression(1, 2) calls the function, returning the sum of the two
    arguments.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 输入 `addExpression(1, 2)` 会调用该函数，返回两个参数的和。
- en: 'In many respects, function expressions and function declarations are interchangeable,
    so choosing between the two approaches is often just a matter of style. For example,
    defining our function for adding two numbers as a function expression and assigning
    it to a variable is largely equivalent to defining it using a function declaration,
    as we did originally. When it comes to passing functions as arguments, however,
    function expressions offer certain advantages. Earlier, for example, we declared
    the sayHi function, then passed its name to setTimeout as an argument. A more
    common way to do this is to write an equivalent function expression directly in
    the setTimeout function’s arguments list, without first assigning it to a variable:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在许多方面，函数表达式和函数声明是可以互换的，所以选择这两种方法中的任何一种通常只是风格问题。例如，将我们的两个数字相加函数定义为函数表达式并将其赋值给一个变量，在大多数情况下等同于最初使用函数声明的方式。不过，当涉及将函数作为参数传递时，函数表达式提供了一些优势。例如，之前我们声明了sayHi函数，然后将它的名字传递给setTimeout作为参数。更常见的做法是直接在setTimeout函数的参数列表中写出一个等效的函数表达式，而不是先将其赋值给一个变量：
- en: '[PRE14]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Previously we called setTimeout(sayHi, 2000), passing the name of a function
    as the first argument, but this time we’re passing a function expression instead.
    The function expression defines an anonymous function for logging "Hi!" to the
    console (the equivalent of the sayHi function we declared earlier). Notice that
    the function keyword isn’t the first thing in the line of code, a requirement
    for function expressions, and that the closing brace is followed by a comma, since
    the function expression is part of a list of arguments.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 之前我们调用了setTimeout(sayHi, 2000)，将一个函数名作为第一个参数传递，但这次我们传递的是一个函数表达式。该函数表达式定义了一个匿名函数，用于向控制台打印"Hi!"（这与我们之前声明的sayHi函数等效）。注意，`function`关键字不是代码行中的第一个元素，这是函数表达式的一个要求，并且闭括号后跟着一个逗号，因为这个函数表达式是参数列表的一部分。
- en: As before, calling setTimeout returns a timeout ID, this time 2. Then, when
    our anonymous function is called two seconds later, Hi! appears in the console.
    Using a function expression in this case is more concise, since we don’t have
    to separately define the delayed function before passing it to setTimeout.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，调用setTimeout会返回一个超时ID，这次是2。然后，当我们的匿名函数在两秒钟后被调用时，"Hi!" 会出现在控制台中。在这种情况下，使用函数表达式更简洁，因为我们不需要在传递给setTimeout之前单独定义延迟函数。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Arrow Functions</samp>
  id: totrans-72
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">箭头函数</samp>
- en: 'JavaScript has yet another syntax for defining functions, called *arrow function
    expressions*, or *arrow functions* for short. An arrow function is a more compact
    version of a function expression, and in most cases the choice between the two
    is purely stylistic. You can use an arrow function anywhere a normal function
    expression would work, and save yourself a bit of typing in the process. For example,
    here’s how to make a function that adds two numbers using arrow function syntax:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript还有另一种定义函数的语法，称为*箭头函数表达式*，或简称*箭头函数*。箭头函数是函数表达式的一种更简洁的版本，在大多数情况下，选择使用哪一种完全是风格上的问题。你可以在任何适用普通函数表达式的地方使用箭头函数，并在此过程中节省一些输入。例如，下面是使用箭头函数语法编写一个将两个数字相加的函数：
- en: '[PRE15]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'An arrow function doesn’t use the function keyword. Instead, it begins with
    the arguments list—in this case, (x, y)—followed by an arrow (=>) and the function
    body. Here we’re assigning the arrow function to the addArrow variable, which
    lets us call it just like other functions:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 箭头函数不使用`function`关键字。相反，它以参数列表开始——在这个例子中是(x, y)——后面跟着一个箭头（=>）和函数体。在这里，我们将箭头函数赋值给addArrow变量，这样我们就可以像调用其他函数一样调用它：
- en: '[PRE16]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'We defined addArrow using *block body* syntax, where the body is placed between
    braces and each statement within the body is written on its own indented line.
    If the body consists of just a single statement, however, there’s an even simpler
    syntax, called *concise body*:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用*块体*语法定义了addArrow，其中函数体被放置在大括号之间，每个语句都写在自己缩进的一行上。然而，如果函数体仅包含一个语句，还有一种更简单的语法，称为*简洁体*：
- en: '[PRE17]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Here the body is written on the same line as the rest of the statement, and
    it isn’t surrounded by braces. Also, the return keyword is implied, meaning the
    expression in the body (in this case, x + y) is automatically understood to be
    the function’s return value. This concise body syntax is great for writing simple
    functions, but if your function body involves multiple statements, you’ll have
    to use the block body syntax (and include the return keyword if the function has
    an explicit return value).
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，函数体与其余的语句写在同一行，并且没有被大括号包围。同时，`return`关键字是隐式的，这意味着函数体中的表达式（在此例中为x + y）自动被理解为函数的返回值。这种简洁的函数体语法非常适合编写简单的函数，但如果你的函数体涉及多个语句，你就必须使用块体语法（如果函数有显式的返回值，还需要包含`return`关键字）。
- en: 'If the arrow function has exactly one parameter, you can further simplify the
    syntax by omitting the parentheses around the parameter name:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 如果箭头函数只有一个参数，你可以通过省略参数名周围的圆括号进一步简化语法：
- en: '[PRE18]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: This arrow function takes in a number, x, and returns its square (x * x). Since
    x is the function’s only parameter, we don’t need to put it in parentheses. This
    works for both block body and concise body syntax.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 这个箭头函数接受一个数字x，并返回它的平方（x * x）。由于x是函数的唯一参数，我们不需要将其放在圆括号中。这对于块体和简洁体语法都适用。
- en: 'Like function expressions, arrow functions provide an efficient way to define
    functions that are passed as arguments. To illustrate, we’ll consider JavaScript’s
    built-in setInterval function. Like setTimeout, it takes another function and
    a time in milliseconds as arguments, but unlike setTimeout, it repeatedly calls
    the provided function, waiting the specified amount of time between each call.
    Here, for example, we pass setInterval an arrow function that logs the string
    "Beep" to the console:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 像函数表达式一样，箭头函数提供了一种高效的方式来定义作为参数传递的函数。为了说明这一点，我们将考虑 JavaScript 内置的 setInterval
    函数。像 setTimeout 一样，它接受另一个函数和一个时间（以毫秒为单位）作为参数，但与 setTimeout 不同的是，它会重复调用提供的函数，在每次调用之间等待指定的时间。例如，在这里，我们传递给
    setInterval 一个箭头函数，它会将字符串 "Beep" 打印到控制台：
- en: '[PRE19]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Our arrow function takes no arguments, so it begins with an empty set of parentheses
    for the parameter list. The closing brace at the end of the body is followed by
    a comma to separate the arrow function from the next argument to setInterval,
    which specifies a one-second pause (1,000 ms) between repetitions.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的箭头函数不接受任何参数，因此它以一对空圆括号开始作为参数列表。函数体末尾的闭合大括号后面跟着一个逗号，用来将箭头函数与传递给 setInterval
    的下一个参数分隔开，这个参数指定了每次重复之间的暂停时间（1,000 毫秒，即一秒钟）。
- en: When we execute this code, it first returns an interval ID for canceling the
    repetition—in this case, 3. Then, after a one-second delay, the first "Beep" is
    logged. After that, a number should appear on the left of the console output and
    increment every second to show how many times console.log("Beep") has been called.
    Chrome uses this trick to keep the console from filling up with duplicate lines
    of output. When you’re ready for the code to stop Beep-ing, refresh the browser
    page, or call the clearInterval function, passing the interval ID. In our example,
    that would be clearInterval(3).
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们执行这段代码时，它首先返回一个用于取消重复的间隔ID——在本例中为3。然后，在一秒钟的延迟后，第一个 "Beep" 会被打印出来。之后，控制台输出的左侧应该会显示一个数字，每秒递增，表示
    console.log("Beep") 被调用的次数。Chrome使用这个技巧来避免控制台中重复输出的行数过多。当你准备好停止 Beep 时，只需刷新浏览器页面，或者调用
    clearInterval 函数并传入间隔 ID。在我们的例子中，应该是 clearInterval(3)。
- en: <samp class="SANS_Futura_Std_Bold_B_11">Rest Parameters</samp>
  id: totrans-87
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">剩余参数</samp>
- en: Sometimes you want your function to accept a variable number of arguments. For
    example, say you want to make a function that takes someone’s name and their favorite
    colors, and prints them out in a sentence. You don’t know ahead of time how many
    favorite colors the user will enter, so you want to make your function flexible
    enough to handle however many colors are passed in. In JavaScript, you can do
    this with a *rest parameter*, a special type of parameter that collects a variable
    number of arguments into an array.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 有时你希望你的函数能够接受可变数量的参数。例如，假设你想编写一个函数，它接受某人的名字和他们最喜欢的颜色，并将它们打印成一个句子。你事先并不知道用户会输入多少个最喜欢的颜色，因此你希望让你的函数足够灵活，以处理传入的任意数量的颜色。在
    JavaScript 中，你可以使用 *剩余参数* 来实现这一点，剩余参数是一种特殊类型的参数，它将可变数量的参数收集到一个数组中。
- en: 'Rest parameters work with any style of function definition. Here we use one
    to create an arrow function that lists the user’s favorite colors:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 剩余参数可以与任何样式的函数定义一起使用。这里我们使用一个剩余参数来创建一个箭头函数，用于列出用户的最爱颜色：
- en: '[PRE20]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: A rest parameter looks like an ordinary parameter preceded by three periods,
    and it always has to be the last parameter listed in the function definition.
    When the function is called, any regular parameters, listed first, are matched
    to the first provided arguments, in order. Then, the rest parameter bundles the
    remaining arguments into an array. In our example, name is a regular parameter,
    and favoriteColors is the rest parameter. When we call the function, the argument
    "Nick" is assigned to the name parameter. The remaining arguments, "blue", "green",
    and "orange", are gathered into a single array and assigned to the favoriteColors
    parameter. Because favoriteColors is an array, we can use the join method to convert
    it into a string, separating each color by a comma and a space. Then we incorporate
    the color string into a larger string using a template literal and use console
    .log to print it.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 一个 rest 参数看起来像是一个普通参数，前面有三个点，它必须始终是函数定义中列出的最后一个参数。当调用函数时，任何常规参数（按顺序列出）都会与第一个提供的参数匹配。然后，rest
    参数将其余的参数捆绑成一个数组。在我们的示例中，name 是一个常规参数，favoriteColors 是 rest 参数。当我们调用函数时，"Nick"
    参数会被分配给 name 参数，其余的参数 "blue"、"green" 和 "orange" 会被收集到一个数组中，并分配给 favoriteColors
    参数。因为 favoriteColors 是一个数组，我们可以使用 join 方法将其转换为一个字符串，用逗号和空格分隔每个颜色。然后，我们使用模板字面量将颜色字符串融入到一个更大的字符串中，并使用
    console.log 打印出来。
- en: 'Since favoriteColors is a rest parameter, we can use the function with as few
    or as many colors as we want:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 favoriteColors 是一个 rest 参数，我们可以根据需要使用任意数量的颜色：
- en: '[PRE21]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: No matter how many arguments we provide, the function still works.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 无论我们提供多少个参数，函数仍然能够正常工作。
- en: 'Here’s another example of using a rest parameter, this time to sum all the
    numbers provided as arguments:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 这是另一个使用 rest 参数的示例，这次是将所有作为参数提供的数字相加：
- en: '[PRE22]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: This time we’ve used a function declaration instead of an arrow function, and
    the function’s only parameter is the rest parameter. Because there are no other
    parameters, all the arguments are collected into an array and assigned to the
    numbers rest parameter. Then we use a for…of loop to add the numbers together.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 这次我们使用了一个函数声明，而不是箭头函数，且函数的唯一参数是 rest 参数。由于没有其他参数，所有参数都被收集到一个数组中，并分配给 numbers
    rest 参数。然后，我们使用 for…of 循环将这些数字加起来。
- en: <samp class="SANS_Futura_Std_Bold_B_11">Higher-Order Functions</samp>
  id: totrans-98
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">高阶函数</samp>
- en: 'A *higher-order function* is a function that takes another function as an argument,
    or that outputs another function as its return value. You’ve already seen two
    higher-order functions in this chapter: setTimeout and setInterval, which both
    take a callback function to execute later as an argument. JavaScript has many
    other built-in higher-order functions as well. We’ll consider some here, and discuss
    how to write your own higher-order functions.'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '*高阶函数* 是一种接受另一个函数作为参数，或者输出另一个函数作为返回值的函数。在本章中，你已经见过了两个高阶函数：setTimeout 和 setInterval，它们都接受一个回调函数作为参数，稍后执行。JavaScript
    还有许多其他内置的高阶函数。我们将在这里考虑一些，并讨论如何编写你自己的高阶函数。'
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Array Methods That
    Take Callbacks</samp>
  id: totrans-100
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">接受回调的数组方法</samp>
- en: There are a number of built-in methods for working with arrays that take a callback
    function. Remember, a method is a type of function that operates on an object,
    such as an array. In most cases, the callback passed to these higher-order array
    methods is called once for each item in the array. Let’s take a look at a few
    examples.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多内置的方法用于处理数组，这些方法接受一个回调函数。记住，方法是一种对对象（如数组）操作的函数。在大多数情况下，传递给这些高阶数组方法的回调函数会为数组中的每一项执行一次。让我们看几个示例。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Finding an Array Element</samp>
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">查找数组元素</samp>
- en: 'The find array method finds the first element in an array that matches some
    criterion. You specify the criterion with a callback function that returns a Boolean
    true/false value. For example, if we wanted to find the first item in our shopping
    list with more than six characters, we could do the following:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: find 数组方法用于查找数组中第一个符合某些条件的元素。你可以通过回调函数指定条件，回调函数返回一个布尔值 true/false。例如，如果我们想查找购物清单中第一个字符数大于六的项，可以这样做：
- en: '[PRE23]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The callback function we pass to find is item => item.length > 6. This callback
    takes advantage of two useful syntactic features of arrow functions. First, because
    our function has only one parameter, item, we can leave off the parentheses around
    the parameter list. Second, because the function body involves only one statement,
    item.length > 6, we can use concise body syntax, leaving off the return keyword
    and the braces around the body. These features let us define the logic for finding
    the element as compactly as possible, making arrow functions ideal for writing
    simple callbacks.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 我们传递给 find 的回调函数是 item => item.length > 6。这个回调函数利用了箭头函数的两个有用的语法特性。首先，由于我们的函数只有一个参数
    item，我们可以省略括号。其次，由于函数体仅包含一个语句 item.length > 6，我们可以使用简洁的函数体语法，省略 return 关键字和大括号。这些特性让我们能够尽可能简洁地定义查找元素的逻辑，使得箭头函数非常适合编写简单的回调函数。
- en: The find method runs the callback for each element in the array in turn. The
    callback takes in the element and returns true or false based on whether the element
    has more than six characters. If the callback returns true for a given element,
    the find method returns that element and halts the search. In this case, the method
    returns "Bananas" rather than "Ice Cream" since "Bananas" comes earlier in the
    array.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: find 方法依次对数组中的每个元素执行回调函数。回调函数接受元素并根据该元素是否包含超过六个字符来返回 true 或 false。如果回调函数对某个元素返回
    true，find 方法将返回该元素并停止搜索。在这种情况下，方法返回 "Bananas" 而不是 "Ice Cream"，因为 "Bananas" 在数组中出现得更早。
- en: 'If no item is found that meets the criterion, the find method returns undefined:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有找到符合条件的项，find 方法将返回 undefined：
- en: '[PRE24]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: This time we pass find a callback that checks if an element starts with the
    letter *A*. None of the shopping list items do, so the method returns undefined.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 这次我们给 find 传递一个回调函数，该函数检查元素是否以字母 *A* 开头。购物清单中的项目没有任何一个以字母 A 开头，因此方法返回 undefined。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Filtering the Elements of
    an Array</samp>
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">过滤数组中的元素</samp>
- en: 'The filter method returns a new array containing all the elements from the
    original array that satisfy some criterion. As with the find method, the criterion
    is specified using a callback. To illustrate, we’ll update our original find example
    by changing the method name to filter. This will give us a list of *all* items
    with more than six characters, rather than just the first item that passes this
    test:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: filter 方法返回一个新数组，其中包含原数组中所有满足某些条件的元素。与 find 方法一样，条件是通过回调函数来指定的。为了说明这一点，我们将更新原来的
    find 示例，将方法名改为 filter。这样，我们将得到一个包含所有超过六个字符的项目的列表，而不仅仅是通过测试的第一个项目：
- en: '[PRE25]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: This filters out the array elements whose character lengths are too short, while
    leaving both "Bananas" and "Ice Cream" in the resulting array.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 这将过滤掉字符长度太短的数组元素，同时将 "Bananas" 和 "Ice Cream" 保留在结果数组中。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Transforming Each Element
    of an Array</samp>
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">转换数组中的每个元素</samp>
- en: 'Sometimes you’ll want to transform each element in an array and store the results
    in a new array. For instance, you might have an array of numbers that all need
    to be operated on in the same way. You could do this using a for…of loop, as we
    discussed in [Chapter 4](chapter4.xhtml), but a more concise technique is to use
    the map array method. It applies the same callback to each element of an array
    and returns a new array containing the results. Here, for example, we use map
    to take in an array of numbers and produce an array of those numbers’ cubes:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 有时你可能希望转换数组中的每个元素，并将结果存储在一个新数组中。例如，你可能有一个包含数字的数组，这些数字需要以相同的方式进行操作。你可以使用我们在[第
    4 章](chapter4.xhtml)中讨论的 for…of 循环来实现，但更简洁的方法是使用 map 数组方法。它将相同的回调应用于数组中的每个元素，并返回一个包含结果的新数组。例如，在这里，我们使用
    map 来接受一个数字数组并生成一个包含这些数字立方的新数组：
- en: '[PRE26]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Our callback function, x => x * x * x, takes an array element and cubes it.
    The map method applies this callback to each element in the numbers array, returning
    a new array of the first 10 perfect cubes while leaving the original array unchanged.
    Compare the concise syntax of passing map an arrow function with the equivalent
    code using a for…of loop:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的回调函数 x => x * x * x 接受数组元素并将其立方。map 方法将这个回调应用到 numbers 数组的每个元素，返回一个包含前 10
    个完美立方数的新数组，同时保持原数组不变。将 map 与箭头函数的简洁语法进行比较，看看使用 for…of 循环的等效代码：
- en: '[PRE27]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: The result is the same, but with map we’re able to declare and populate the
    cubes array in a single line of code, instead of first declaring cubes as an empty
    array and then filling it up within the body of the for…of loop.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 结果是相同的，但使用 map 时，我们能够在一行代码中声明并填充 cubes 数组，而不需要先声明 cubes 为一个空数组，然后在 for…of 循环体内填充它。
- en: 'The map method is also useful if you have an array of similar objects and you
    want to extract the same piece of information from each one. For example, say
    you have an array of objects that represent items in a store, each with a name
    and a price property, and you want to get an array of just the prices. You can
    pass map a callback function accessing each object’s price property, like so:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你有一个包含相似对象的数组，并且你想从每个对象中提取相同的信息，map 方法也很有用。例如，假设你有一个表示商店商品的对象数组，每个对象都有一个名称和价格属性，而你想要获取一个仅包含价格的数组。你可以传递给
    map 一个回调函数，访问每个对象的价格属性，像这样：
- en: '[PRE28]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Here, the callback function is item => item.price, which takes an item and returns
    the value of that item’s price property. The map function applies the callback
    to each object in the original array in turn, and creates a new array with all
    the prices.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，回调函数是 item => item.price，它接收一个 item 并返回该 item 的 price 属性的值。map 函数将回调依次应用于原始数组中的每个对象，并创建一个包含所有价格的新数组。
- en: In general, it’s preferable to use map rather than the equivalent loop whenever
    possible, both for the map method’s conciseness and for the code’s *self-documenting*
    nature (the method name map implies that you’re making a new array that copies
    and modifies elements from another array, without the need for further comment).
    A loop would be more appropriate when your needs are more custom, for example,
    if the number of elements in the output array doesn’t match the number in the
    original array.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 一般来说，尽可能使用 map 而不是等效的循环，因为 map 方法简洁，而且代码具有 *自文档化* 特性（map 方法的名称暗示你正在创建一个新数组，该数组从另一个数组中复制并修改元素，无需进一步注释）。当你的需求更加定制时，使用循环会更合适，例如，当输出数组中的元素数量与原始数组中的元素数量不匹配时。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Custom Functions
    That Take Callbacks</samp>
  id: totrans-124
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">接受回调函数的自定义函数</samp>
- en: 'To create your own higher-order function that takes a callback as an argument,
    simply include a name for the callback in the function’s list of parameters, just
    as you’d name any other parameter. Then, when you want to call the callback within
    the function body, add parentheses after the parameter name, just like calling
    any other function. Let’s illustrate this by declaring a doubler function that
    takes in a callback and calls it twice:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个接受回调作为参数的高阶函数，只需像命名其他参数一样，在函数的参数列表中包含回调的名称。然后，当你想在函数体内调用回调时，在参数名称后添加括号，就像调用任何其他函数一样。让我们通过声明一个接受回调并调用它两次的
    doubler 函数来说明这一点：
- en: '[PRE29]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: When we define the doubler function, we give it a callback parameter. Then,
    in the function body, we write callback() twice to make two calls to the function
    passed to this parameter. When we call doubler, we pass it a function that logs
    "Hi there!" to the console, so this message gets logged twice. Notice that this
    callback function doesn’t require any arguments, so we’ve written an empty set
    of parentheses before the arrow symbol.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们定义 doubler 函数时，我们给它一个回调参数。然后，在函数体内，我们写两次 callback()，以对传递给该参数的函数进行两次调用。当我们调用
    doubler 时，我们传递给它一个将 "Hi there!" 打印到控制台的函数，因此该消息会被打印两次。请注意，这个回调函数不需要任何参数，因此我们在箭头符号之前写了一个空的括号。
- en: 'As we’ve discussed, JavaScript has no conception of set data types for function
    parameters, so there’s nothing stopping us from trying to pass a value that isn’t
    a function as an argument to doubler. If we do, though, we’ll get an error when
    JavaScript tries to call the non-function:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所讨论的，JavaScript 对函数参数的集合数据类型没有概念，因此没有任何东西阻止我们尝试传递一个不是函数的值作为 doubler 的参数。但是，如果我们这样做，当
    JavaScript 尝试调用非函数时，会出现错误：
- en: '[PRE30]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Here we pass doubler a string instead of a function, so we get a TypeError.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们传递给 doubler 一个字符串，而不是一个函数，因此我们会得到一个 TypeError 错误。
- en: 'The callback we passed to doubler didn’t require any arguments, but you can
    also set up a higher-order function so its callback takes arguments. Here, for
    example, we create a function that calls another function some number of times,
    passing the current number of times into the callback:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 我们传递给 doubler 的回调函数不需要任何参数，但你也可以设置一个高阶函数，使其回调函数接受参数。例如，在这里，我们创建一个函数，该函数调用另一个函数若干次，将当前调用次数传递给回调函数：
- en: '[PRE31]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'We declare the callMultipleTimes function to have two parameters: a function
    to call (callback) and a number of times to call it (times). (Note that unlike
    setTimeout and setInterval, where the callback is the first parameter, our function
    here follows the more common JavaScript convention of having the callback be the
    last parameter.) The function body consists of a for loop in which we call callback(i),
    passing the looping variable i as an argument to the callback.'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 我们声明 `callMultipleTimes` 函数有两个参数：一个要调用的函数（`callback`）和调用次数（`times`）。（注意，与 `setTimeout`
    和 `setInterval` 中回调函数是第一个参数不同，我们这里的函数遵循更常见的 JavaScript 约定，将回调函数放在最后一个参数。）函数体由一个
    `for` 循环组成，在该循环中我们调用 `callback(i)`，将循环变量 `i` 作为参数传递给回调函数。
- en: 'Because the callback function is passed a single argument, we know that the
    callback function we pass to callMultipleTimes should have a single parameter.
    For example:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 因为回调函数只接收一个参数，我们知道传递给 `callMultipleTimes` 的回调函数应该有一个参数。例如：
- en: '[PRE32]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Here we pass an arrow function as a callback. It has a single time parameter.
    The function incorporates time into a message that gets logged to the console.
    Each time this callback is executed, time takes on the current value of looping
    variable i, inserting the numbers 0, 1, and 2 into the logged message, respectively.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 这里我们传递了一个箭头函数作为回调函数。它有一个 `time` 参数。这个函数将时间信息整合到一条消息中，并将其记录到控制台。每次执行这个回调时，`time`
    都会取循环变量 `i` 的当前值，分别将 0、1 和 2 插入到记录的消息中。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Functions That Return
    Functions</samp>
  id: totrans-137
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">返回函数的函数</samp>
- en: 'So far we’ve focused on higher-order functions that take in functions as arguments,
    but a higher-order function can also output a function as its return value. For
    example, say you want to create various functions that add a suffix to the end
    of a string, such as adding "!!!" at the end to make the string seem more exciting,
    or "???" to make it seem more puzzling. Rather than manually defining a separate
    function for adding each possible suffix, or making a function with text and suffix
    parameters and having to supply the suffix every time you call it, you can define
    a higher-order function that takes in a suffix and returns a function that will
    append that suffix to a string:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们关注的是将函数作为参数的高阶函数，但高阶函数也可以输出一个函数作为返回值。例如，假设你想创建多个函数，将一个后缀添加到字符串的末尾，比如添加
    "!!!" 使字符串看起来更激动人心，或者 "???" 使它看起来更加迷惑。与其为每个可能的后缀手动定义一个单独的函数，或者为文本和后缀定义一个函数，每次调用时都必须提供后缀，不如定义一个高阶函数，它接收一个后缀并返回一个将该后缀附加到字符串的函数：
- en: '[PRE33]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: There are two return keywords here. The first ❶ is used by the higher-order
    makeAppender function to return an anonymous function. It’s followed by the function
    keyword, indicating that we’re defining a function to be returned. The second
    return keyword ❷ is inside the anonymous function itself. When *that* function
    is called, it returns the value of the anonymous function’s text parameter concatenated
    with the makeAppender function’s suffix parameter.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有两个 `return` 关键字。第一个 ❶ 被高阶函数 `makeAppender` 使用，用来返回一个匿名函数。后面跟着 `function`
    关键字，表示我们正在定义一个将被返回的函数。第二个 `return` 关键字 ❷ 出现在匿名函数内部。当*那个*函数被调用时，它会返回匿名函数的 `text`
    参数与 `makeAppender` 函数的 `suffix` 参数连接后的值。
- en: 'To be able to call the inner function, we first have to get access to it by
    calling the outer function:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 为了能够调用内部函数，我们首先必须通过调用外部函数来访问它：
- en: '[PRE34]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Calling makeAppender("!!!") returns a new function, which we assign to the exciting
    variable. This variable now contains the function expression that was returned
    from makeAppender, which takes a string as an argument. When we call exciting("Hello"),
    we get the string "Hello!!!", the result of concatenating the "Hello" and "!!!"
    strings together.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 调用 `makeAppender("!!!")` 返回一个新的函数，我们将其赋值给 `exciting` 变量。这个变量现在包含了从 `makeAppender`
    返回的函数表达式，它接受一个字符串作为参数。当我们调用 `exciting("Hello")` 时，我们得到字符串 "Hello!!!"，这是将 "Hello"
    和 "!!!" 两个字符串连接起来的结果。
- en: 'The benefit of our higher-order makeAppender function is that we can use it
    to generate additional functions for appending other suffixes besides "!!!". For
    example:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的高阶函数 `makeAppender` 的好处在于，我们可以利用它生成用于附加其他后缀的函数，而不仅仅是 "!!!"。例如：
- en: '[PRE35]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Here makeAppender returns two more functions, which we assign as values to
    the puzzling and winking variables. We had to define only a single higher-order
    function, but we now have three different suffix-appending functions to choose
    from, and we can reuse them as much as we like:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，makeAppender 返回了两个额外的函数，我们将它们分别赋值给了 puzzling 和 winking 变量。我们只需要定义一个高阶函数，但现在我们有了三个不同的后缀附加函数可以选择，并且可以随意重复使用它们：
- en: '[PRE36]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Notice that each function we returned from makeAppender remembers the value
    of suffix that we passed in, which is how it can keep appending the same suffix.
    Each of these functions was defined within the scope of makeAppender, so even
    though the call to makeAppender has completed, the inner function it returned
    is able to hold onto other values from that same scope, including suffix.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们从 makeAppender 返回的每个函数都记住了我们传入的 suffix 值，这就是它能够不断地附加相同后缀的原因。每个函数都是在 makeAppender
    的作用域内定义的，因此即使 makeAppender 的调用已经完成，它返回的内部函数仍然能够保持对该作用域中其他值的访问，包括 suffix。
- en: We discussed scope in [Chapter 4](chapter4.xhtml), noting, for example, how
    variables defined within a while or for loop can’t be accessed outside of the
    loop. Similarly, variables defined inside a function have scope only within that
    function, so they typically disappear once the function call ends. Scope gets
    more interesting with nested functions, however, as in the example at hand. You
    might expect the scope of the outer makeAppender function to “disappear” after
    we call it, but the inner function retains access to the variables and arguments
    from that scope, as long as we keep a reference to the inner function (which we
    do through the variables exciting, puzzling, and winking). Functions that hold
    onto variables and parameters from their enclosing scopes are known as *closures*
    because they “close over” their environments. (Imagine that the inner function
    has a dome over it that preserves all the variables in its scope.)
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在[第4章](chapter4.xhtml)讨论了作用域，例如，如何定义在 while 或 for 循环中的变量无法在循环外部访问。类似地，在函数内部定义的变量只在该函数内部有效，因此通常在函数调用结束后就会消失。然而，作用域在嵌套函数中变得更加有趣，如当前示例所示。你可能会认为外部的
    makeAppender 函数在调用后会“消失”，但内部函数保留了对来自该作用域的变量和参数的访问，只要我们保持对内部函数的引用（我们通过变量 exciting、puzzling
    和 winking 来实现）。那些保留对其所在作用域中的变量和参数访问的函数被称为*闭包*，因为它们“封闭”了它们的环境。（可以想象，内部函数有一个罩子，能够保持作用域中的所有变量。）
- en: <samp class="SANS_Futura_Std_Bold_B_11">Summary</samp>
  id: totrans-150
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">总结</samp>
- en: In this chapter, you learned how to make your code more readable and concise
    by creating and working with your own custom functions. You saw the three main
    styles of defining functions—function declarations, function expressions, and
    arrow functions—and experimented with block body and concise body syntax. You
    learned how to provide input to a function by passing values to its parameters
    as arguments, and you learned how to take advantage of a function’s work, either
    through its return value, its side effects, or both. You also saw how functions
    can be assigned as values to variables, and how they can be passed to or returned
    from higher-order functions.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中，你学到了如何通过创建和使用自定义函数使你的代码更加易读和简洁。你了解了定义函数的三种主要方式——函数声明、函数表达式和箭头函数，并且实验了块体语法和简洁体语法。你学会了如何通过传递参数值来向函数提供输入，并了解了如何利用函数的工作成果，无论是通过其返回值、其副作用，还是两者兼有。你还看到了如何将函数赋值给变量，以及如何将函数传递给高阶函数或从高阶函数返回。
