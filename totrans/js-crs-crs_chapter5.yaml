- en: <hgroup>
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">5</samp> <samp class="SANS_Dogma_OT_Bold_B_11">FUNCTIONS</samp>
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: </hgroup>
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/opener.png)'
  prefs: []
  type: TYPE_IMG
- en: As you learned in [Chapter 1](chapter1.xhtml), a *function* is a self-contained
    block of code for performing a certain task. We’ve already used some of JavaScript’s
    built-in functions, such as alert and console.log, but you can also create your
    own custom functions to perform the tasks particular to your application. Then
    you can *call* these functions to run the associated code. Packaging code into
    functions in this way makes your programming more effective, as you don’t have
    to repeat the code every time you want to use it.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, you’ll learn different techniques for writing your own functions.
    You’ll see how to provide input to functions and receive output from them. You’ll
    also see how functions can be treated as ordinary values, just like a number or
    a string. In particular, we’ll explore how functions can serve as input or output
    for other, higher-order functions.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Declaring and Calling Functions</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Before you can use a custom function, you have to establish what the function
    is called and what it does. One way is to use a *function declaration*, a block
    of code that defines a function. To illustrate, we’ll declare a simple function
    called sayHello that takes in someone’s name and logs a custom greeting for that
    person to the console. Open the JavaScript console in Chrome and enter the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: A function declaration has four parts. First, we use the function keyword to
    tell JavaScript we’re creating a function. Next, we give the function a name—in
    this case, sayHello. After that, we provide a comma-separated list of the function’s
    parameters, surrounded by parentheses. *Parameters* are pieces of information
    that the function needs to do its job. In this case, our function has one parameter,
    name, indicating that the function needs to be supplied with someone’s name in
    order to create a greeting. (If a function has no parameters, we simply write
    an empty set of parentheses.) Finally, we write the function’s body, surrounded
    by braces. This is the code that should be executed when the function is called.
    In our example, the body consists of a call to console.log to print out a greeting,
    with the value of the name parameter inserted via a template literal.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we’ve declared our sayHello function, we can call it whenever we want
    to greet someone. Each time we call the function, we’ll need to provide a value
    for the name parameter. That value is called an *argument*, and it’s specified
    in parentheses when the function is called. By passing the function different
    arguments, we can create different custom greetings. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The first time we call our sayHello function, we pass "Nick" as an argument
    in the parentheses after the function name. As a result, the message Hello, Nick!
    is logged to the console. The second time we call the function, we pass "Mei"
    as an argument, so the message Hello, Mei! is logged. In each case, the value
    of the argument is bound to the function’s name parameter, and the function body
    runs with the name parameter set to that value. Essentially, you can think of
    name as a variable within the function that takes on the value of the corresponding
    argument (such as "Nick" or "Mei") when the function is called.
  prefs: []
  type: TYPE_NORMAL
- en: 'The distinction between parameters and arguments is subtle but important. Parameters
    are generic names for a function’s inputs, whereas arguments are the actual input
    values passed to the function when you call it. Each function has only one set
    of parameters, but every time you call the function it can have a new set of arguments.
    In this way, parameters make your functions highly customizable. The sayHello
    function, for example, has one parameter, name, but it can be called with a different
    argument each time. We’ve seen it called with sayHello("Nick") and sayHello("Mei"),
    but the possibilities are endless: sayHello("Kitty"), sayHello("Dolly"), sayHello("world"),
    and so on.'
  prefs: []
  type: TYPE_NORMAL
- en: Notice that each call to sayHello outputs undefined as well as the custom greeting.
    This extra line of output is the function’s return value. sayHello returns undefined
    because we didn’t explicitly give it a return value; we’ll look at how to do that
    next.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Return Values</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'A *return value* is a value that a function produces for use elsewhere in your
    code. In many cases, you’ll want a function to take in some inputs using parameters,
    process those inputs in some way, and output the result. That output is the return
    value. For example, let’s declare a function that takes in two numbers and returns
    their sum:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'This add function has two parameters, x and y. The function body consists of
    the return keyword followed by the expression x + y. When the function is called,
    JavaScript will evaluate this expression, adding x and y together, and return
    the result, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: We call add with the arguments 1 and 2, which become the values for parameters
    x and y, respectively. (The arguments are matched with the parameters in the order
    in which they’re given.) The function sums the two arguments and returns the resulting
    value, 3.
  prefs: []
  type: TYPE_NORMAL
- en: When we call a function in the Chrome console, its return value is automatically
    printed out—but it’s important to distinguish between a function explicitly logging
    text to the console, as we saw sayHello do earlier, and a function returning a
    value, as add is doing here. When a function logs a value using console.log, the
    only place that value exists is in the log; we can’t make further use of it later.
    By contrast, when a function returns a value, we can then use that value later
    in our code. The fact that the return value is also displayed in the console is
    largely irrelevant. It helps us see what the function is doing, but logging to
    the console isn’t the add function’s main purpose, unlike the sayHello function.
  prefs: []
  type: TYPE_NORMAL
- en: 'One way to make use of a function’s return value is to call the function as
    part of an assignment expression, so the return value will be stored in a variable.
    Then we can work with that variable later in the code. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Here we declare the variable sum and initialize it to the return value of the
    add function, which we call with the arguments 500 and 500. The console shows
    undefined even though add has a return value because, as discussed in [Chapter
    2](chapter2.xhtml), declaring a variable always prints undefined. We then use
    the function’s return value by incorporating sum into a template literal to create
    the string "I walked 1000 miles".
  prefs: []
  type: TYPE_NORMAL
- en: Notice that it wouldn’t be possible to do something similar with our sayHello
    function as it’s currently written. For example, we can’t use it to generate the
    greeting "Hello, Nick!" and then write some code to incorporate that greeting
    into a longer string. The sayHello function returns undefined, because we didn’t
    use the return keyword to explicitly give it a return value. It merely logs the
    greeting to the console, and there’s no way to access the greeting once it’s been
    logged.
  prefs: []
  type: TYPE_NORMAL
- en: 'It’s not necessary to store a function’s return value in a variable to use
    it. A function call that returns a value can be used anywhere a value can be used,
    just as you can use variables and literal values interchangeably. For instance,
    the previous example could be rewritten like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Here, instead of calling add separately and storing the result in a variable,
    we call the function from within the template literal. Its return value is inserted
    directly into the resulting string, producing the same message as before. It’s
    often more readable to store the return value in a variable, but both approaches
    are equally valid.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Parameter Types</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The data types of function parameters in JavaScript are not fixed. This is because
    JavaScript is a *dynamically typed* programming language, in which the types of
    variables and parameters can change while the program is running, as opposed to
    a *statically typed* language, in which the types of variables and parameters
    are determined before the program is run.
  prefs: []
  type: TYPE_NORMAL
- en: 'To illustrate, so far we’ve been using the add function to add numbers together,
    but there’s nothing stopping us from using it to concatenate two strings:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Here we pass the function two strings as arguments, so the + operator in the
    function body is interpreted to mean string concatenation rather than numerical
    addition. The function therefore combines the strings and returns the result.
  prefs: []
  type: TYPE_NORMAL
- en: 'By extension, we could also pass arguments of other types, or even mix data
    types within the same function call:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: In these cases, JavaScript’s rules around type coercion, discussed in [Chapter
    2](chapter2.xhtml), come into play. When we try to add two Booleans with add(true,
    false), JavaScript converts the Booleans to the numbers 1 and 0 before the addition,
    producing the number 1. When we try to add a number and a string with add(1, "1"),
    JavaScript converts both of the operands to strings and concatenates them, producing
    the string "11".
  prefs: []
  type: TYPE_NORMAL
- en: Dynamic typing brings a lot of flexibility to JavaScript, but if you aren’t
    careful, it can also open the way for some confusing bugs. It’s essential to have
    a good idea of the types you’re using, to make sure you’re not passing a string
    to a function that expects a number, for example.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Side Effects</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: A *side effect* is anything a function does that makes a difference outside
    of the function itself, apart from returning a value. Side effects can be intended
    or unintended, and include updating the value of a variable declared outside the
    function, modifying an array or object declared outside the function, or outputting
    a string to the console.
  prefs: []
  type: TYPE_NORMAL
- en: 'Some functions, like our add function, have no side effects and are called
    only for their return value. Other functions, like sayHello, have no return value
    and are called only for their side effects. It’s also possible to write functions
    that return a value *and* have side effects. For example, we can redefine add
    to log some information to the console and update a variable, in addition to returning
    the sum of its arguments:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Here we declare the variable addCalls, which we’ll use to keep track of how
    often the add function is called. Then we write our updated add function declaration.
    The function now increments addCalls and logs the values of its parameters to
    the console, before returning the sum of the parameters, as before.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s try calling the revised function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The function call has the side effect of logging the two values to the console
    before adding them together. It also has the side effect of updating the addCalls
    variable, changing its value from 0 to 1. Additionally, the function has the (non–side
    effect) result of returning the sum of its arguments, which we’ve stored in the
    sum variable.
  prefs: []
  type: TYPE_NORMAL
- en: If we made further calls to add, the variable addCalls would keep incrementing
    each time, giving us a running count of the number of times the function is called.
    You don’t typically need to keep track of the number of times a function is called
    like this, although you could use such a mechanism to restrict how often a program
    is allowed to call some function that requires a lot of processing power (a technique
    known as *rate limiting*). You could achieve this by periodically resetting the
    counter—perhaps every minute—and skipping the function call if the counter goes
    over some threshold.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Passing a Function as an Argument</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In JavaScript, functions are *first-class citizens*, which means they can be
    used like any other value, such as a number or a string. For example, you can
    store a function in a variable or pass a function as an argument to another function.
    The latter is especially common, as there are many functions that delegate work
    to other functions. When a function is passed as an argument, it’s often referred
    to as a *callback* because the function it’s passed to is said to “call it back”
    by executing it.
  prefs: []
  type: TYPE_NORMAL
- en: 'We’ll illustrate this with JavaScript’s built-in setTimeout function, which
    allows you to delay the calling of another function. It takes two arguments: a
    function to call, and a time in milliseconds (ms) to wait before calling that
    function. Here’s how it works:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: First we create a simple function with no arguments, sayHi, which just calls
    console.log. We then call setTimeout, passing the sayHi function and the number
    2000 (indicating 2,000 ms, or 2 seconds) as arguments. Once you press ENTER, setTimeout
    should immediately return a *timeout ID*—in this case, 1—which is a unique identifier
    you could use to cancel the delayed function call if desired. Then, after two
    seconds, the sayHi function is called, and the string "Hi!" is logged to the console.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Dogma_OT_Bold_B_21">NOTE</samp>
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*To cancel a function call delayed with setTimeout, call the clearTimeout function,
    passing the timeout ID as an argument.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Notice that when we pass a function as an argument, we write its name without
    parentheses: in this case, sayHi rather than sayHi(). A function name without
    parentheses simply *refers* to the function, while a function name with parentheses
    actually *calls* the function. We can see this distinction in the JavaScript console:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Executing just plain sayHi; without parentheses ❶ prints the function’s definition
    but doesn’t call it. However, executing sayHi(); with parentheses ❷ calls the
    sayHi function, printing the string "Hi!" and returning undefined.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Other Function Syntaxes</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: So far in this chapter we’ve focused on creating functions using function declarations,
    but JavaScript also supports other ways to create functions. Function declarations
    follow a straightforward format and use a similar syntax to how functions are
    defined in many other languages, like C++ and Python. They’re perfectly fine when
    you’re writing functions that you intend to call directly, like the sayHello and
    add functions that we’ve discussed. However, once you start treating functions
    as values by passing them as arguments and the like, the other styles of creating
    functions become more useful. We’ll turn to those now, starting with function
    expressions.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Function Expressions</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: A *function expression*, also known as a *function literal*, is a code literal
    whose value is a function, just as 123 is a literal whose value is the number
    123\. Whereas a function declaration creates a function and binds it to a name,
    a function expression is an expression that evaluates to (returns) a function,
    for you to do with what you will.
  prefs: []
  type: TYPE_NORMAL
- en: Syntactically, a function expression looks very similar to a function declaration,
    with two main differences. First, a function expression doesn’t have to include
    a name, although you can include one if you want. Function expressions without
    names are also called *anonymous functions*. Second, a function expression can’t
    be written at the start of a line of code, or JavaScript will think it’s a function
    declaration; there has to be some code before the function keyword. This is why
    function expressions are often used in contexts where functions need to be treated
    as values.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, you can define a function expression and assign it as the value
    of a variable, all in one statement, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: The function keyword appears on the right side of an assignment statement, rather
    than at the start of a line, so JavaScript treats this as a function expression.
    In this case, we’re assigning the function expression to the addExpression variable.
    The function itself is anonymous, since we don’t provide a name after the function
    keyword (you’ll see an example where we do this in the “Named Function Expressions”
    box on the following page). It has two parameters, x and y, specified in parentheses,
    just like our original add function. The body returns the sum of the parameters
    and is enclosed in braces, much like the body of a function declaration, but notice
    that we need to put a semicolon after the closing brace to signify the end of
    the statement assigning the function to a variable.
  prefs: []
  type: TYPE_NORMAL
- en: 'Although the function itself is technically anonymous, it’s now bound to the
    addExpression variable. We can therefore call the function by putting a pair of
    parentheses containing the necessary arguments after the variable name, just like
    calling any named function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Entering addExpression(1, 2) calls the function, returning the sum of the two
    arguments.
  prefs: []
  type: TYPE_NORMAL
- en: 'In many respects, function expressions and function declarations are interchangeable,
    so choosing between the two approaches is often just a matter of style. For example,
    defining our function for adding two numbers as a function expression and assigning
    it to a variable is largely equivalent to defining it using a function declaration,
    as we did originally. When it comes to passing functions as arguments, however,
    function expressions offer certain advantages. Earlier, for example, we declared
    the sayHi function, then passed its name to setTimeout as an argument. A more
    common way to do this is to write an equivalent function expression directly in
    the setTimeout function’s arguments list, without first assigning it to a variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Previously we called setTimeout(sayHi, 2000), passing the name of a function
    as the first argument, but this time we’re passing a function expression instead.
    The function expression defines an anonymous function for logging "Hi!" to the
    console (the equivalent of the sayHi function we declared earlier). Notice that
    the function keyword isn’t the first thing in the line of code, a requirement
    for function expressions, and that the closing brace is followed by a comma, since
    the function expression is part of a list of arguments.
  prefs: []
  type: TYPE_NORMAL
- en: As before, calling setTimeout returns a timeout ID, this time 2. Then, when
    our anonymous function is called two seconds later, Hi! appears in the console.
    Using a function expression in this case is more concise, since we don’t have
    to separately define the delayed function before passing it to setTimeout.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Arrow Functions</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'JavaScript has yet another syntax for defining functions, called *arrow function
    expressions*, or *arrow functions* for short. An arrow function is a more compact
    version of a function expression, and in most cases the choice between the two
    is purely stylistic. You can use an arrow function anywhere a normal function
    expression would work, and save yourself a bit of typing in the process. For example,
    here’s how to make a function that adds two numbers using arrow function syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'An arrow function doesn’t use the function keyword. Instead, it begins with
    the arguments list—in this case, (x, y)—followed by an arrow (=>) and the function
    body. Here we’re assigning the arrow function to the addArrow variable, which
    lets us call it just like other functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'We defined addArrow using *block body* syntax, where the body is placed between
    braces and each statement within the body is written on its own indented line.
    If the body consists of just a single statement, however, there’s an even simpler
    syntax, called *concise body*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Here the body is written on the same line as the rest of the statement, and
    it isn’t surrounded by braces. Also, the return keyword is implied, meaning the
    expression in the body (in this case, x + y) is automatically understood to be
    the function’s return value. This concise body syntax is great for writing simple
    functions, but if your function body involves multiple statements, you’ll have
    to use the block body syntax (and include the return keyword if the function has
    an explicit return value).
  prefs: []
  type: TYPE_NORMAL
- en: 'If the arrow function has exactly one parameter, you can further simplify the
    syntax by omitting the parentheses around the parameter name:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: This arrow function takes in a number, x, and returns its square (x * x). Since
    x is the function’s only parameter, we don’t need to put it in parentheses. This
    works for both block body and concise body syntax.
  prefs: []
  type: TYPE_NORMAL
- en: 'Like function expressions, arrow functions provide an efficient way to define
    functions that are passed as arguments. To illustrate, we’ll consider JavaScript’s
    built-in setInterval function. Like setTimeout, it takes another function and
    a time in milliseconds as arguments, but unlike setTimeout, it repeatedly calls
    the provided function, waiting the specified amount of time between each call.
    Here, for example, we pass setInterval an arrow function that logs the string
    "Beep" to the console:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Our arrow function takes no arguments, so it begins with an empty set of parentheses
    for the parameter list. The closing brace at the end of the body is followed by
    a comma to separate the arrow function from the next argument to setInterval,
    which specifies a one-second pause (1,000 ms) between repetitions.
  prefs: []
  type: TYPE_NORMAL
- en: When we execute this code, it first returns an interval ID for canceling the
    repetition—in this case, 3. Then, after a one-second delay, the first "Beep" is
    logged. After that, a number should appear on the left of the console output and
    increment every second to show how many times console.log("Beep") has been called.
    Chrome uses this trick to keep the console from filling up with duplicate lines
    of output. When you’re ready for the code to stop Beep-ing, refresh the browser
    page, or call the clearInterval function, passing the interval ID. In our example,
    that would be clearInterval(3).
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Rest Parameters</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Sometimes you want your function to accept a variable number of arguments. For
    example, say you want to make a function that takes someone’s name and their favorite
    colors, and prints them out in a sentence. You don’t know ahead of time how many
    favorite colors the user will enter, so you want to make your function flexible
    enough to handle however many colors are passed in. In JavaScript, you can do
    this with a *rest parameter*, a special type of parameter that collects a variable
    number of arguments into an array.
  prefs: []
  type: TYPE_NORMAL
- en: 'Rest parameters work with any style of function definition. Here we use one
    to create an arrow function that lists the user’s favorite colors:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: A rest parameter looks like an ordinary parameter preceded by three periods,
    and it always has to be the last parameter listed in the function definition.
    When the function is called, any regular parameters, listed first, are matched
    to the first provided arguments, in order. Then, the rest parameter bundles the
    remaining arguments into an array. In our example, name is a regular parameter,
    and favoriteColors is the rest parameter. When we call the function, the argument
    "Nick" is assigned to the name parameter. The remaining arguments, "blue", "green",
    and "orange", are gathered into a single array and assigned to the favoriteColors
    parameter. Because favoriteColors is an array, we can use the join method to convert
    it into a string, separating each color by a comma and a space. Then we incorporate
    the color string into a larger string using a template literal and use console
    .log to print it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Since favoriteColors is a rest parameter, we can use the function with as few
    or as many colors as we want:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: No matter how many arguments we provide, the function still works.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s another example of using a rest parameter, this time to sum all the
    numbers provided as arguments:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: This time we’ve used a function declaration instead of an arrow function, and
    the function’s only parameter is the rest parameter. Because there are no other
    parameters, all the arguments are collected into an array and assigned to the
    numbers rest parameter. Then we use a for…of loop to add the numbers together.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Higher-Order Functions</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'A *higher-order function* is a function that takes another function as an argument,
    or that outputs another function as its return value. You’ve already seen two
    higher-order functions in this chapter: setTimeout and setInterval, which both
    take a callback function to execute later as an argument. JavaScript has many
    other built-in higher-order functions as well. We’ll consider some here, and discuss
    how to write your own higher-order functions.'
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Array Methods That
    Take Callbacks</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: There are a number of built-in methods for working with arrays that take a callback
    function. Remember, a method is a type of function that operates on an object,
    such as an array. In most cases, the callback passed to these higher-order array
    methods is called once for each item in the array. Let’s take a look at a few
    examples.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Finding an Array Element</samp>
  prefs: []
  type: TYPE_NORMAL
- en: 'The find array method finds the first element in an array that matches some
    criterion. You specify the criterion with a callback function that returns a Boolean
    true/false value. For example, if we wanted to find the first item in our shopping
    list with more than six characters, we could do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: The callback function we pass to find is item => item.length > 6. This callback
    takes advantage of two useful syntactic features of arrow functions. First, because
    our function has only one parameter, item, we can leave off the parentheses around
    the parameter list. Second, because the function body involves only one statement,
    item.length > 6, we can use concise body syntax, leaving off the return keyword
    and the braces around the body. These features let us define the logic for finding
    the element as compactly as possible, making arrow functions ideal for writing
    simple callbacks.
  prefs: []
  type: TYPE_NORMAL
- en: The find method runs the callback for each element in the array in turn. The
    callback takes in the element and returns true or false based on whether the element
    has more than six characters. If the callback returns true for a given element,
    the find method returns that element and halts the search. In this case, the method
    returns "Bananas" rather than "Ice Cream" since "Bananas" comes earlier in the
    array.
  prefs: []
  type: TYPE_NORMAL
- en: 'If no item is found that meets the criterion, the find method returns undefined:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: This time we pass find a callback that checks if an element starts with the
    letter *A*. None of the shopping list items do, so the method returns undefined.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Filtering the Elements of
    an Array</samp>
  prefs: []
  type: TYPE_NORMAL
- en: 'The filter method returns a new array containing all the elements from the
    original array that satisfy some criterion. As with the find method, the criterion
    is specified using a callback. To illustrate, we’ll update our original find example
    by changing the method name to filter. This will give us a list of *all* items
    with more than six characters, rather than just the first item that passes this
    test:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: This filters out the array elements whose character lengths are too short, while
    leaving both "Bananas" and "Ice Cream" in the resulting array.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Transforming Each Element
    of an Array</samp>
  prefs: []
  type: TYPE_NORMAL
- en: 'Sometimes you’ll want to transform each element in an array and store the results
    in a new array. For instance, you might have an array of numbers that all need
    to be operated on in the same way. You could do this using a for…of loop, as we
    discussed in [Chapter 4](chapter4.xhtml), but a more concise technique is to use
    the map array method. It applies the same callback to each element of an array
    and returns a new array containing the results. Here, for example, we use map
    to take in an array of numbers and produce an array of those numbers’ cubes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Our callback function, x => x * x * x, takes an array element and cubes it.
    The map method applies this callback to each element in the numbers array, returning
    a new array of the first 10 perfect cubes while leaving the original array unchanged.
    Compare the concise syntax of passing map an arrow function with the equivalent
    code using a for…of loop:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: The result is the same, but with map we’re able to declare and populate the
    cubes array in a single line of code, instead of first declaring cubes as an empty
    array and then filling it up within the body of the for…of loop.
  prefs: []
  type: TYPE_NORMAL
- en: 'The map method is also useful if you have an array of similar objects and you
    want to extract the same piece of information from each one. For example, say
    you have an array of objects that represent items in a store, each with a name
    and a price property, and you want to get an array of just the prices. You can
    pass map a callback function accessing each object’s price property, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Here, the callback function is item => item.price, which takes an item and returns
    the value of that item’s price property. The map function applies the callback
    to each object in the original array in turn, and creates a new array with all
    the prices.
  prefs: []
  type: TYPE_NORMAL
- en: In general, it’s preferable to use map rather than the equivalent loop whenever
    possible, both for the map method’s conciseness and for the code’s *self-documenting*
    nature (the method name map implies that you’re making a new array that copies
    and modifies elements from another array, without the need for further comment).
    A loop would be more appropriate when your needs are more custom, for example,
    if the number of elements in the output array doesn’t match the number in the
    original array.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Custom Functions
    That Take Callbacks</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'To create your own higher-order function that takes a callback as an argument,
    simply include a name for the callback in the function’s list of parameters, just
    as you’d name any other parameter. Then, when you want to call the callback within
    the function body, add parentheses after the parameter name, just like calling
    any other function. Let’s illustrate this by declaring a doubler function that
    takes in a callback and calls it twice:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: When we define the doubler function, we give it a callback parameter. Then,
    in the function body, we write callback() twice to make two calls to the function
    passed to this parameter. When we call doubler, we pass it a function that logs
    "Hi there!" to the console, so this message gets logged twice. Notice that this
    callback function doesn’t require any arguments, so we’ve written an empty set
    of parentheses before the arrow symbol.
  prefs: []
  type: TYPE_NORMAL
- en: 'As we’ve discussed, JavaScript has no conception of set data types for function
    parameters, so there’s nothing stopping us from trying to pass a value that isn’t
    a function as an argument to doubler. If we do, though, we’ll get an error when
    JavaScript tries to call the non-function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Here we pass doubler a string instead of a function, so we get a TypeError.
  prefs: []
  type: TYPE_NORMAL
- en: 'The callback we passed to doubler didn’t require any arguments, but you can
    also set up a higher-order function so its callback takes arguments. Here, for
    example, we create a function that calls another function some number of times,
    passing the current number of times into the callback:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'We declare the callMultipleTimes function to have two parameters: a function
    to call (callback) and a number of times to call it (times). (Note that unlike
    setTimeout and setInterval, where the callback is the first parameter, our function
    here follows the more common JavaScript convention of having the callback be the
    last parameter.) The function body consists of a for loop in which we call callback(i),
    passing the looping variable i as an argument to the callback.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Because the callback function is passed a single argument, we know that the
    callback function we pass to callMultipleTimes should have a single parameter.
    For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Here we pass an arrow function as a callback. It has a single time parameter.
    The function incorporates time into a message that gets logged to the console.
    Each time this callback is executed, time takes on the current value of looping
    variable i, inserting the numbers 0, 1, and 2 into the logged message, respectively.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Functions That Return
    Functions</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'So far we’ve focused on higher-order functions that take in functions as arguments,
    but a higher-order function can also output a function as its return value. For
    example, say you want to create various functions that add a suffix to the end
    of a string, such as adding "!!!" at the end to make the string seem more exciting,
    or "???" to make it seem more puzzling. Rather than manually defining a separate
    function for adding each possible suffix, or making a function with text and suffix
    parameters and having to supply the suffix every time you call it, you can define
    a higher-order function that takes in a suffix and returns a function that will
    append that suffix to a string:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: There are two return keywords here. The first ❶ is used by the higher-order
    makeAppender function to return an anonymous function. It’s followed by the function
    keyword, indicating that we’re defining a function to be returned. The second
    return keyword ❷ is inside the anonymous function itself. When *that* function
    is called, it returns the value of the anonymous function’s text parameter concatenated
    with the makeAppender function’s suffix parameter.
  prefs: []
  type: TYPE_NORMAL
- en: 'To be able to call the inner function, we first have to get access to it by
    calling the outer function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Calling makeAppender("!!!") returns a new function, which we assign to the exciting
    variable. This variable now contains the function expression that was returned
    from makeAppender, which takes a string as an argument. When we call exciting("Hello"),
    we get the string "Hello!!!", the result of concatenating the "Hello" and "!!!"
    strings together.
  prefs: []
  type: TYPE_NORMAL
- en: 'The benefit of our higher-order makeAppender function is that we can use it
    to generate additional functions for appending other suffixes besides "!!!". For
    example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Here makeAppender returns two more functions, which we assign as values to
    the puzzling and winking variables. We had to define only a single higher-order
    function, but we now have three different suffix-appending functions to choose
    from, and we can reuse them as much as we like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: Notice that each function we returned from makeAppender remembers the value
    of suffix that we passed in, which is how it can keep appending the same suffix.
    Each of these functions was defined within the scope of makeAppender, so even
    though the call to makeAppender has completed, the inner function it returned
    is able to hold onto other values from that same scope, including suffix.
  prefs: []
  type: TYPE_NORMAL
- en: We discussed scope in [Chapter 4](chapter4.xhtml), noting, for example, how
    variables defined within a while or for loop can’t be accessed outside of the
    loop. Similarly, variables defined inside a function have scope only within that
    function, so they typically disappear once the function call ends. Scope gets
    more interesting with nested functions, however, as in the example at hand. You
    might expect the scope of the outer makeAppender function to “disappear” after
    we call it, but the inner function retains access to the variables and arguments
    from that scope, as long as we keep a reference to the inner function (which we
    do through the variables exciting, puzzling, and winking). Functions that hold
    onto variables and parameters from their enclosing scopes are known as *closures*
    because they “close over” their environments. (Imagine that the inner function
    has a dome over it that preserves all the variables in its scope.)
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Summary</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to make your code more readable and concise
    by creating and working with your own custom functions. You saw the three main
    styles of defining functions—function declarations, function expressions, and
    arrow functions—and experimented with block body and concise body syntax. You
    learned how to provide input to a function by passing values to its parameters
    as arguments, and you learned how to take advantage of a function’s work, either
    through its return value, its side effects, or both. You also saw how functions
    can be assigned as values to variables, and how they can be passed to or returned
    from higher-order functions.
  prefs: []
  type: TYPE_NORMAL
