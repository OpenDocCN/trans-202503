- en: <hgroup>
  id: totrans-0
  prefs: []
  type: TYPE_NORMAL
- en: 31 WORKING WITH DATES AND TIMES
  id: totrans-1
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: </hgroup>
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/opener.jpg)'
  id: totrans-3
  prefs: []
  type: TYPE_IMG
- en: 'Web applications use dates and times in many ways: to maintain calendars, log
    when invoices are created, record when a message has been sent, and so on. In
    this chapter, we’ll explore PHP’s built-in resources for storing and manipulating
    dates and times, including ways to handle complexities such as time zones and
    daylight saving time. We’ll also look at how to send date-time information back
    and forth between PHP and a database system like MySQL, which has its own, separate
    way of storing that information.'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
- en: '### The ISO 8601 Standard'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
- en: Countries have varying conventions for representing dates and times in day-to-day
    life. For example, people in the United States write 11/2 for November 2, but
    people in Ireland and the United Kingdom write 2/11 for that date. Likewise, some
    countries use 24-hour time, while others use 12-hour time with AM and PM designations.
    Computer programs have no room for such ambiguity when storing and manipulating
    dates and times, so it’s important to agree on a standard. These days, pretty
    much everyone in computing uses the date-time formats declared in *ISO 8601*,
    a standard originally published in 1988 and updated several times since.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
- en: Two key principles of ISO 8601 are that dates and times are represented with
    numbers and that they’re ordered from most to least significant. Dates therefore
    start with the year, then the month, then the day. For example, November 22, 1968,
    would typically be written as 1968-11-22, with four digits for the year, two for
    the month, and two for the day, adding leading zeros if required (such as 03 for
    March rather than just 3). Following the same principle of most to least significance,
    times are written as hours, then minutes, then seconds. For example, 5 minutes
    and 30 seconds past 9 AM would be written as 09:05:30. You can add a decimal point
    and more digits for fractions of a second if needed, so 09:05:30.01 is one-hundredth
    of a second after 09:05:30. The standard uses 24-hour time, so 11 PM is given
    as 23:00:00.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
- en: NOTE
  id: totrans-8
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*The creator of PHP, Rasmus Lerdorf, was born on November 22, 1968\. The web
    doesn’t say what time he was born, so I’ve made up the time of 9:05* *AM* *and
    30 seconds for the examples in this chapter.*'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
- en: These examples illustrate the *extended version* of ISO 8601’s date and time
    formatting, which adds dashes between the fields in the date, and colons between
    the fields in the time, to aid with human readability. Internally, the computer
    might not use these separators, but it’s recommended to always use them when presenting
    a date or time to a human, since something like 1968-11-22 is a lot easier for
    a human to interpret than 19681122.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
- en: When combining a date and a time, ISO 8601 calls for a capital T between the
    date and time components. Therefore 5 minutes and 30 seconds past 9 AM on November
    22, 1968, would be written as 1968-11-22T09:05:30. That said, the original ISO
    8601 standard allowed the use of a space between the date and time rather than
    a T, so many computer implementations will also accept 1968-22-22 09:05:30 as
    a valid format.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
- en: NOTE
  id: totrans-12
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*A concept found in most programming languages is* date-time*. So while we
    humans think about dates and times separately, or might talk about a* date and
    time*, in computer programming we typically work with objects that store data
    about a date and time all together. If we’re interested in only the date, we ignore
    the time components in our code, often defaulting to a zeroed time component for
    the beginning of a new day (*00:00:00*). If we’re interested in only the time,
    we ignore the date components in our code and often default to the current date.*'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
- en: Time-zone characters or time offsets can be added to the end of a date-time
    string; we’ll look at how this works in “Formatting the Date-Time Information”
    on [page 634](#pg_634). ISO 8601 also defines other date and time components (such
    as week numbers), but the components I’ve described cover 99 percent of the date
    and time formatting needed to create and work with temporal data in PHP programs.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
- en: Creating Dates and Times
  id: totrans-15
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The fundamental PHP class for working with individual dates and times is DateTimeImmutable.
    If you create a DateTimeImmutable object without providing arguments to the constructor,
    the new object defaults to the current time and day at the moment of its creation,
    based on the local time-zone settings for your computer system. [Listing 31-1](#lis31-1)
    illustrates how to instantiate this class.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Listing 31-1: Creating a DateTimeImmutable object for the current date and
    time'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
- en: 'We create a new DateTimeImmutable object without any arguments and output its
    value by using the var_dump() function. If you execute this script at the command
    line, you should see something similar to the following:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The var_dump() function returns the object’s internal date value as a date-time
    string. Notice that this string output uses a space rather than a T between the
    date and the time to aid in human readability, and that the time component uses
    six decimal places to capture the time down to the nearest microsecond (millionth
    of a second). The object’s remaining properties pertain to the time zone (I’m
    in Dublin, Ireland, for example), as we’ll discuss in detail in “Time Zones” on
    [page 641](#pg_641).
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
- en: NOTE
  id: totrans-22
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*To get the current date and time, you can also use* new DateTimeImmutable(''now'')*.
    The* ''now'' *argument is useful if you need to provide a second argument specifying
    a different time zone from the default.*'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
- en: 'To create a DateTimeImmutable object holding another (noncurrent) date and
    time, pass a string containing the desired date and time to the constructor, like
    this:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This creates a new DateTimeImmutable object holding the date November 22, 1968,
    and the time 9:05 and 30 seconds.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
- en: Formatting the Date-Time Information
  id: totrans-27
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The DateTimeImmutable class’s format() method makes it possible to adjust the
    output style for dates and times in different ways. For example, [Listing 31-2](#lis31-2)
    shows how to format a date-time string to the ISO 8601 standard.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Listing 31-2: Formatting a DateTimeImmutable object constant'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
- en: 'We instantiate $now as a default DateTimeImmutable object, then call its format()
    method, passing in the ATOM constant from DateTimeInterface (the DateTimeImmutable
    class is an implementation of this interface). This constant indicates that the
    date and time should be formatted according to the ISO 8601 standard. The format()
    method returns a string, which we store in $atomDateString and print. The output
    should look something like this:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Notice that the output follows ISO 8601 format, including the T between the
    date and the time. The +00:00 at the end has to do with time zones, which we’ll
    discuss later.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
- en: The format() method can also take in a string specifying custom formatting.
    This allows you to create more readable date-time output. For example, you can
    tell format() to spell out the name of the month, include the day of the week,
    convert from 24-hour to 12-hour time, add a suffix to the date number (as in *1st*,
    *2nd*, or *23rd*), and so on. [Listing 31-3](#lis31-3) illustrates how it’s done.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Listing 31-3: Customizing the output string format for a date-time'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
- en: 'This time, we provide a string to format() that defines a custom format for
    the date-time information. The string uses letter codes, such as l, j, and S,
    to stand in for parts of the date and time. Here’s what the letters in [Listing
    31-3](#lis31-3) mean:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
- en: l   The full name of the day of the week (Monday, Tuesday, and so on)
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
- en: j   The day of the month as an integer with no leading space (1, 4, 20, 31,
    and so on)
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
- en: S   A two-letter suffix for the numeric date of the month (*st* for 1st, *nd*
    for 2nd, and so on)
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
- en: F   The full name of the month (January, May, and so on)
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
- en: Y   The four-digit year (2000, 2019, 2025, and so on)
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
- en: i   Minutes with leading zeros (00 through 59)
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
- en: g   The hour in 12-hour format without leading zeros (1 through 12)
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
- en: a   The appropriate AM or PM abbreviation
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
- en: The case of each character is important, since several characters represent
    different values depending on whether they’re upper- or lowercase. For example,
    a lowercase d represents the date of the month (with a leading zero if required
    to ensure that it’s two digits), while an uppercase D is the three-letter abbreviation
    of the day of the week (Mon, Tue, and so on).
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
- en: NOTE
  id: totrans-47
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*The PHP documentation provides a full list of all these special formatting
    characters at* [https://www.php.net/manual/en/datetime.format.php](https://www.php.net/manual/en/datetime.format.php)*.*'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
- en: 'Any text that you want to be included verbatim in the formatted string needs
    to be escaped (preceded by a backslash), character by character. Thus, the string
    argument to format() in [Listing 31-3](#lis31-3) includes character sequences
    like \t\h\e (the word *the*) and \o\f (the word *of*). [Listing 31-3](#lis31-3)
    should output something like this:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'You can also use letter codes with the createFromFormat() static method to
    create new DateTimeImmutable objects based on formatted strings. Consider this
    example:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The createFromFormat() method takes two arguments. The first is a formatter
    string built using the letter codes we’ve discussed. The second is a string that
    follows the indicated format and sets the value for the new DateTimeImmutable
    object.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
- en: Using DateTimeImmutable vs. DateTime
  id: totrans-54
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Our focus has been on the DateTimeImmutable class, but PHP also offers the similar
    DateTime class. The only difference (but an important one) is that once created,
    a DateTimeImmutable object won’t change the values it contains, whereas a DateTime
    object’s value can be updated. One consequence is that DateTimeImmutable methods
    that might change the date or time return a new DateTimeImmutable object rather
    than modifying the original object’s values.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
- en: Use DateTimeImmutable whenever possible rather than DateTime to avoid the unexpected
    behavior of an object changing and returning a reference to itself. To see why,
    look at [Listing 31-4](#lis31-4).
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Listing 31-4: Creating a DateTime object and modifying it'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
- en: 'We create a new DateTime (rather than DateTimeImmutable) object called $today
    and print its value (in year-month-day format). Then we invoke the object’s modify()
    method to move the date one day forward, storing the result in the $tomorrow variable.
    Rather than creating a new DateTime object for the next day, however, calling
    modify() changes the original DateTime object and returns a reference to that
    same object. To confirm this, we print both $today and $tomorrow. The output will
    look something like this:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Initially, the value of $today indicates November 22\. After calling modify(),
    both $today and $tomorrow indicate November 23\. Both variables reference the
    same DateTime object, whose value was changed by the modify() method.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
- en: While having changeable date-time information may sometimes be desirable, it’s
    important to make sure that’s what you want before using DateTime over DateTimeImmutable.
    The example also illustrates how inappropriate variable names can make code hard
    to understand and debug. If we deliberately create a mutable DateTime object and
    make a change to its date, that object shouldn’t be named for a particular date
    (like $today or $tomorrow), since at some point the name of the variable won’t
    correctly refer to its value.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
- en: 'To really see the difference between the two PHP date-time classes, try changing
    the class from DateTime to DateTimeImmutable in [Listing 31-4](#lis31-4) and then
    run the script again. Here’s the output:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: This time, the value of $today remains the same, even as $tomorrow moves one
    day ahead. This is because the modify() method of a DateTimeImmutable object creates
    and returns a completely new DateTimeImmutable object with the modified value
    while leaving the original object unchanged. Therefore, $today and $tomorrow refer
    to two different DateTimeImmutable objects, and both variable names are reasonable,
    since they always correctly refer to the values of the object they reference.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
- en: Manipulating Dates and Times
  id: totrans-66
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: PHP’s DateTimeImmutable class features several methods that create a new DateTimeImmutable
    object based on the value of an existing one. These methods make it possible to
    programmatically manipulate date and time information.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
- en: You already saw one example, the modify() method, in [Listing 31-4](#lis31-4).
    This method takes a string argument indicating how to set a new date or time relative
    to the current DateTimeImmutable object’s value. For instance, the strings 'yesterday'
    and 'tomorrow' yield midnight (time 00:00:00) on the previous or next day; the
    'noon' and 'midnight' strings yield noon (12:00:00) or midnight on the current
    day; and 'first day of this month' or 'last day of this month' change the date
    as appropriate while leaving the time the same. These modifier strings can be
    combined; for example, 'tomorrow noon' and 'first day of this month midnight'
    are both valid.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
- en: Other modifier strings use + or - followed by a quantity and unit of time to
    give more granular control over the new DateTimeImmutable object’s value, as in
    '+1 day', '-2 hours', or '+30 seconds'. These can also be combined into longer
    strings, such as '+1 day +30 seconds'. [Listing 31-5](#lis31-5) shows some of
    these modifiers in action.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Listing 31-5: Passing relative date-time strings to the modify() method'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
- en: 'To help show the date-times before and after modification, we first declare
    a showModify() function that takes in a modifier string as an argument. The function
    prints the modifier string itself, creates a new DateTimeImmutable object with
    the current time, and passes the string to the modify() method to create another,
    modified DateTimeImmutable object. Then it prints both objects in ISO 8601 format.
    Next, we make a series of showModify() calls to demonstrate various modifier strings.
    The output should be something like this:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The value of $date1 is the same for each function call, November 22, 1968, at
    9:05 and 30 seconds. With the 'first day of this month' modifier, the date component
    of $date2 ends up as November 1, but the time component is left unchanged ❶. With
    '+1 day', the date component moves forward to November 23, but again the time
    component is unchanged ❷. The '+30 seconds' and '-10 seconds' strings move the
    time component forward and backward without changing the date component, while
    '+1 month +3 days +1 seconds' changes both the date and time.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
- en: If you provide a date to the modify() method, that date will replace the original
    one in the new DateTimeImmutable object created, leaving the time unchanged. For
    example, the '2000-12-31' string applied to an object holding 1968-11-22T09:05:30
    would result in a new object of 2000-12-31 T09:05:30, the same time but for December
    31, 2000\. Likewise, providing a time results in a new object with the original
    date but the new time.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你向 modify() 方法提供一个日期，该日期将替换新创建的 DateTimeImmutable 对象中的原始日期，而时间保持不变。例如，将字符串
    '2000-12-31' 应用于一个包含 1968-11-22T09:05:30 的对象，将导致创建一个新的对象，日期为 2000-12-31 T09:05:30，时间保持不变，只是日期变为
    2000 年 12 月 31 日。同样，提供一个时间会导致一个新的对象，其日期不变，但时间更新为新值。
- en: 'That said, modifying just the date or time component of a DateTime Immutable
    object can be accomplished more easily using the setDate() and setTime() methods.
    For example, if $date1 is a DateTimeImmutable object, both the following statements
    result in the same new object being created:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 也就是说，仅修改 DateTimeImmutable 对象的日期或时间组件可以通过使用 setDate() 和 setTime() 方法更轻松地实现。例如，如果
    $date1 是一个 DateTimeImmutable 对象，以下两个语句会创建相同的新的对象：
- en: '[PRE13]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Notice that the setDate() method takes three separate integers as arguments,
    rather than a single string. These integers represent the desired year, month,
    and day. Similarly, the setTime() method takes four integers for the new hour,
    minute, second, and microsecond. The latter two default to 0.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，setDate() 方法接受三个独立的整数作为参数，而不是一个字符串。这些整数分别表示期望的年份、月份和日期。类似地，setTime() 方法接受四个整数，表示新的小时、分钟、秒和微秒。后两个默认值为
    0。
- en: '#### Using Date-Time Intervals'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '#### 使用日期时间间隔'
- en: The DateInterval class represents a span of time rather than a specific date-time.
    This class provides another useful way of manipulating date-time information and
    of thinking about the relationship between different date-times. For example,
    the add() and sub() methods of the DateTimeImmutable class take in a DateInterval
    object and return a new DateTimeImmutable object offset forward or backward in
    time from the original object by the specified interval. [Listing 31-6](#lis31-6)
    illustrates how this works.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: DateInterval 类表示一段时间跨度，而不是特定的日期时间。这个类提供了另一种处理日期时间信息以及思考不同日期时间之间关系的有用方法。例如，DateTimeImmutable
    类的 add() 和 sub() 方法接受一个 DateInterval 对象，并返回一个新的 DateTimeImmutable 对象，该对象在时间上根据指定的时间间隔向前或向后偏移。[清单
    31-6](#lis31-6) 说明了它是如何工作的。
- en: '[PRE14]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Listing 31-6: Creating new DateTimeImmutable objects offset by time intervals'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 31-6：创建由时间间隔偏移的新的 DateTimeImmutable 对象
- en: 'First, we use the createFromDateString() static method to create two Date Interval
    objects. With this method, we can express the desired interval by using strings
    like ''30 seconds'' or ''1 day''. Next, we create a DateTimeImmutable object for
    the current date and time, then call its add() and sub() methods, passing in the
    DateInterval objects. This creates two more DateTimeImmutable objects, offset
    according to the given time intervals. The three date-time strings in the output
    should look something like this:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们使用 createFromDateString() 静态方法创建两个 DateInterval 对象。通过此方法，我们可以使用像 '30 seconds'
    或 '1 day' 这样的字符串来表示期望的时间间隔。接着，我们创建一个表示当前日期和时间的 DateTimeImmutable 对象，然后调用它的 add()
    和 sub() 方法，传入 DateInterval 对象。这会创建两个新的 DateTimeImmutable 对象，根据给定的时间间隔进行偏移。输出中的三个日期时间字符串应该类似于这样：
- en: '[PRE15]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Notice that $date2 has the same date, but its time is 09:06:00, 30 seconds
    later than $date1. Meanwhile, $date3 has the same time, but its date is one day
    earlier: November 21 instead of November 22\. Note that we can create negative
    as well as positive DateInterval objects. For example, we could create a DateInterval
    by using the string ''-1 day''.'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，$date2 拥有相同的日期，但其时间是 09:06:00，比 $date1 晚了 30 秒。与此同时，$date3 拥有相同的时间，但日期早了
    1 天：是 11 月 21 日，而不是 11 月 22 日。注意，我们可以创建负的 DateInterval 对象，也可以创建正的。例如，我们可以通过使用字符串
    '-1 day' 来创建一个 DateInterval。
- en: A more common way of creating a DateInterval object is to use the diff() method
    of the DateTimeImmutable class. Given one DateTimeImmutable object, you call its
    diff() method, passing in a second DateTimeImmutable object, and the method returns
    a DateInterval object representing the difference between those two date-times.
    This is useful when a user has provided a start and end date, and some logic or
    calculation needs to be performed based on the size of the date interval between
    them. For example, a hotel-booking web application might calculate the cost of
    a stay based on the number of days between the desired start and end date. [Listing
    31-7](#lis31-7) shows how this mechanism works.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 创建 `DateInterval` 对象的一个更常见方法是使用 `DateTimeImmutable` 类的 `diff()` 方法。给定一个 `DateTimeImmutable`
    对象，调用它的 `diff()` 方法并传入另一个 `DateTimeImmutable` 对象，方法会返回一个表示这两个日期时间差异的 `DateInterval`
    对象。当用户提供了开始日期和结束日期，并且需要根据这两个日期间的间隔大小进行某些逻辑或计算时，这个方法非常有用。例如，酒店预订网页应用程序可能会根据所选的开始和结束日期之间的天数来计算住宿费用。[清单
    31-7](#lis31-7)展示了这个机制是如何工作的。
- en: '[PRE16]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Listing 31-7: Obtaining the interval between two DateTimeImmutable objects'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 31-7：获取两个 `DateTimeImmutable` 对象之间的间隔
- en: 'We create two DateTimeImmutable objects, $date1 and $date2, specifying just
    the date for each; the objects are six days apart. Then we call the diff()method
    on $date1, passing $date2 as an argument. This produces a DateInterval object
    holding the difference between the two dates, which we format and print. Here’s
    the result:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了两个 `DateTimeImmutable` 对象，`$date1` 和 `$date2`，每个对象仅指定了日期，这两个对象相隔六天。然后我们调用
    `$date1` 上的 `diff()` 方法，并将 `$date2` 作为参数传入。这会生成一个 `DateInterval` 对象，保存两个日期之间的差异，我们对其进行格式化并打印。结果如下：
- en: '[PRE17]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: As expected, the DateInterval object indicates that the two dates are four days
    apart. Note that the format() method of the DateInterval class works differently
    from formatting actual dates. It takes in a string using the percent character
    (%) to indicate where values from the DateInterval object should be inserted.
    For example, %d is replaced by the number of days (6) in the output string.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 如预期的那样，`DateInterval` 对象表示两个日期之间相隔四天。注意，`DateInterval` 类的 `format()` 方法与格式化实际日期的方式不同。它接收一个字符串，使用百分号（%）表示
    `DateInterval` 对象中应该插入的值的位置。例如，%d 会被输出字符串中的天数（6）替代。
- en: Looping at Regular Intervals
  id: totrans-92
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 按规律间隔循环
- en: For displaying a series of date-time values, updating calendars, or generating
    historical reports, it’s often useful to loop at a regular interval between two
    dates. PHP’s DatePeriod class makes this possible. An object of this class can
    be iterated through with a foreach loop, just like an array. Each iteration turns
    up a new DateTimeImmutable object, with all the objects evenly spaced in time.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 对于显示一系列日期时间值、更新日历或生成历史报告，通常需要在两个日期之间按规律间隔进行循环。PHP 的 `DatePeriod` 类可以实现这一点。该类的对象可以像数组一样使用
    `foreach` 循环进行迭代。每次迭代都会产生一个新的 `DateTimeImmutable` 对象，所有对象在时间上均匀分布。
- en: To create a DatePeriod object, you must provide a start and end date, plus a
    DateInterval object defining the rate of iteration. [Listing 31-8](#lis31-8) shows
    an example of using this class to automatically list the first seven days of a
    month.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建 `DatePeriod` 对象，必须提供起始和结束日期，以及定义迭代速率的 `DateInterval` 对象。[清单 31-8](#lis31-8)
    展示了如何使用此类自动列出一个月的前七天。
- en: '[PRE18]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Listing 31-8: Iterating through a DatePeriod object'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 31-8：迭代 `DatePeriod` 对象
- en: 'First, we create and print a DateTimeImmutable object for the current day ($today).
    Then we use the modify() method to create two more DateTimeImmutable objects,
    $firstOfMonth for the first day of the current month, and $oneWeekLater for a
    week after that. These will be the start and end points for the iteration. Next,
    we create a one-day DateInterval object, which we use, along with the start and
    end points, to create a DatePeriod object ❶. The order of arguments is the start
    date, the interval, and then the end date. Finally, we run a foreach loop to iterate
    through the DatePeriod object ❷, printing a formatted string for each date as
    it comes up. The output should look something like the following:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们创建并打印当前日期的 `DateTimeImmutable` 对象（`$today`）。然后，我们使用 `modify()` 方法创建两个新的
    `DateTimeImmutable` 对象，`$firstOfMonth` 表示当前月的第一天，`$oneWeekLater` 表示一周后的日期。这些将作为迭代的起始和结束点。接着，我们创建一个一天的
    `DateInterval` 对象，将它与起始和结束日期一起，用来创建一个 `DatePeriod` 对象 ❶。参数的顺序是起始日期、间隔和结束日期。最后，我们运行一个
    `foreach` 循环来迭代 `DatePeriod` 对象 ❷，并为每个日期打印格式化的字符串。输出应如下所示：
- en: '[PRE19]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Based on a start day of November 22, 1968, the script successfully looped through
    and displayed the first seven days of that month.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 基于1968年11月22日作为开始日期，脚本成功地循环并显示了该月的前七天。
- en: Rather than a start and end date, another way to create DatePeriod objects is
    to give the start date, the interval, and the number of recurrences. This third
    argument doesn’t count the start date itself, so to list the first seven days
    of a month, the number of recurrences would be 6. The DatePeriod constructor also
    has an optional parameter to exclude the start date by passing a fourth argument
    of the constant DatePeriod::EXCLUDE_START_DATE.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 创建DatePeriod对象的另一种方式是给定开始日期、时间间隔和重复次数，而不是开始和结束日期。这个第三个参数不计算开始日期本身，因此，要列出一个月的前七天，重复次数应为6。DatePeriod构造函数还有一个可选参数，通过传递常量DatePeriod::EXCLUDE_START_DATE作为第四个参数来排除开始日期。
- en: NOTE
  id: totrans-101
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 注意
- en: '*At present,* DatePeriod *works only for positive* DateInterval *objects, so
    loops have to move forward in time.*'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '*目前，* DatePeriod *仅适用于正向的* DateInterval *对象，因此循环必须按时间向前推进。*'
- en: Time Zones
  id: totrans-103
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 时区
- en: A *time zone* is a geographical area that observes the same time. These days,
    all time zones worldwide are defined relative to the time standard of *Coordinated
    Universal Time (UTC)*. This is the time at the International Reference Meridian
    (0° longitude), which passes through Greenwich, England. For example, UTC +3 and
    UTC –2 indicate three hours ahead and two hours behind UTC, respectively. UTC
    is also nicknamed *Zulu time*, with *Zulu* being the standard codeword for the
    letter *Z* in the NATO phonetic alphabet. (The *Z* is for *zero*.) [Table 31-1](#tab31-1)
    lists some example UTC offsets and their associated time zones.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '*时区*是一个地理区域，遵循相同的时间。如今，全球所有时区都相对于*协调世界时（UTC）*来定义。这是国际参考子午线（0°经度）上的时间，经过英国格林威治。例如，UTC
    +3和UTC –2分别表示比UTC提前三小时和滞后两小时。UTC也被昵称为*Zulu时间*，*Zulu*是北约音标字母表中字母*Z*的标准代码词。（*Z*代表*零*。）[表31-1](#tab31-1)列出了某些示例UTC偏移量及其相关的时区。'
- en: 'Table 31-1: Example Time Zones'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 表31-1：示例时区
- en: '| UTC offset | Abbreviation | Common name |'
  id: totrans-106
  prefs: []
  type: TYPE_TB
  zh: '| UTC偏移量 | 缩写 | 常用名称 |'
- en: '| --- | --- | --- |'
  id: totrans-107
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| UTC +0 | GMT | Greenwich Mean Time |'
  id: totrans-108
  prefs: []
  type: TYPE_TB
  zh: '| UTC +0 | GMT | 格林威治标准时间 |'
- en: '| UTC +1 | BST | British Summer Time |'
  id: totrans-109
  prefs: []
  type: TYPE_TB
  zh: '| UTC +1 | BST | 英国夏令时 |'
- en: '| UTC +1 | IST | Irish Standard Time |'
  id: totrans-110
  prefs: []
  type: TYPE_TB
  zh: '| UTC +1 | IST | 爱尔兰标准时间 |'
- en: '| UTC +11 | AEDT | Australian Eastern Daylight Time (Tasmania is where my twin
    brother lives) |'
  id: totrans-111
  prefs: []
  type: TYPE_TB
  zh: '| UTC +11 | AEDT | 澳大利亚东部夏令时（塔斯马尼亚是我双胞胎兄弟的居住地） |'
- en: '| UTC –5 | EST | Eastern Standard Time |'
  id: totrans-112
  prefs: []
  type: TYPE_TB
  zh: '| UTC –5 | EST | 美国东部标准时间 |'
- en: '| UTC +2 | CEST | Central European Summer Time |'
  id: totrans-113
  prefs: []
  type: TYPE_TB
  zh: '| UTC +2 | CEST | 中欧夏令时 |'
- en: You can set the default time zone for your system’s PHP setup in the *php.ini*
    configuration file. The time zone itself is given with a *time-zone identifier*,
    a string that includes a region (such as America, Europe, or Pacific) and a city
    located in the desired time zone, separated by a forward slash. [Listing 31-9](#lis31-9),
    for example, shows I’ve set up my system to the Europe/Dublin time zone.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在*php.ini*配置文件中设置系统的默认时区。时区本身通过*时区标识符*来表示，这是一个包含区域（如美国、欧洲或太平洋）和位于目标时区的城市的字符串，中间用斜杠分隔。例如，[清单31-9](#lis31-9)显示了我已经将我的系统设置为欧洲/都柏林时区。
- en: '[PRE20]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Listing 31-9: An excerpt of a php.ini file setting the default time zone to
    Europe/Dublin'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 清单31-9：一个将默认时区设置为欧洲/都柏林的php.ini文件片段
- en: You use date.timezone to set a time-zone identifier for the PHP engine. To verify
    that your system’s time zone has been set correctly, use the date _default_timezone_get()
    function. This returns Europe/Dublin for me.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用date.timezone设置PHP引擎的时区标识符。要验证系统的时区是否已正确设置，可以使用date_default_timezone_get()函数。这对于我来说返回的是欧洲/都柏林。
- en: NOTE
  id: totrans-118
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 注意
- en: '*You can find a full list of acceptable time-zone identifiers in the PHP documentation
    at* [https://www.php.net/manual/en/timezones.php](https://www.php.net/manual/en/timezones.php)*.
    However, avoid using any of the identifiers listed in the Others region, apart
    from* UTC*. These identifiers are for backward compatibility only and may be changed
    in the future.*'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '*你可以在PHP文档中找到接受的完整时区标识符列表，网址是* [https://www.php.net/manual/en/timezones.php](https://www.php.net/manual/en/timezones.php)*。但是，除了*
    UTC*之外，避免使用“其他”区域列出的任何标识符。这些标识符仅用于向后兼容，未来可能会更改。*'
- en: When you create a DateTimeImmutable object in a PHP script, it defaults to the
    time zone of your system. My preferred way to specify a time zone is to pass a
    DateTimeZone object as a second argument to the DateTimeImmutable constructor.
    Another common method is to append a UTC offset to the end of an ISO 8601 string.
    For example, adding +03:00 to the end of the string indicates that the date-time
    is three hours ahead of UTC. [Listing 31-10](#lis31-10) illustrates each of these
    methods.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Listing 31-10: Creating DateTimeImmutable objects with different time zones'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
- en: We declare a prettyPrintDatetime() function to nicely print out a DateTimeImmutable
    object and its time zone, along with a string label passed in as the $name parameter.
    The time zone is accessed using the DateTimeImmutable object’s getTimezone() method,
    which returns a DateTimeZone object. Then we have to call the DateTimeZone object’s
    getName() method, which returns the name of the time zone as a string.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
- en: Next, we declare a series of DateTimeImmutable objects with different time zones,
    all for the date August 2, 2009 (2009-08-02), the first occurrence of National
    Ice Cream Sandwich Day in the United States. The $localDatetime object ❶ holds
    the date according to the system’s default time zone (Europe/Dublin for me, per
    my *php.ini* file). Since we didn’t specify a time, the time will default to midnight.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
- en: 'The $utcDatetime object ❷ is set to UTC by passing two arguments to the DateTimeImmutable
    constructor: $iceCreamDay to specify the date, and a DateTimeZone object set to
    ''UTC'' to specify the time zone. We use this same technique to create objects
    for the time in London, Paris, and Hobart. The $threeHoursAhead object ❸ is created
    by appending the UTC offset +03:00 to the date-time string 2000-01-01T10:00:00
    passed to the DateTimeImmutable constructor, indicating the time is three hours
    ahead of UTC.'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
- en: 'We print confirmation of the computer system’s time-zone setting by using the
    date_default_timezone_get() built-in function ❹. Then we pass our DateTimeImmutable
    objects one at a time to the prettyPrintDatetime() function ❺. The output should
    look something like this:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The first data printed is the system’s time-zone setting, Europe/Dublin for
    me ❶. Then as each of our DateTimeImmutable objects is printed, its time-zone
    information is visible in the output in two ways: in the UTC offset at the end
    of the date-time string (for example, +01:00 for London and Dublin, and +10:00
    for Hobart), and in the separate time-zone string we extract as part of the prettyPrintDatetime()
    function. Notice, however, that when we specify the time zone by using a generic
    UTC offset like +03:00 rather than a more specific time-zone identifier, that’s
    how the DateTimeImmutable object records the time zone ❷. This is because PHP
    doesn’t know which region and city to associate with the offset. For example,
    +03:00 could be Europe/Moscow, Asia/Riyadh, or Africa/Mogadishu.'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
- en: Daylight Saving Time
  id: totrans-129
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Around a quarter of all countries worldwide operate a system of daylight saving
    time: clocks are set forward by one hour in the spring (“spring forward”), then
    set back by one hour in the autumn (“fall back”). PHP’s DateTimeImmutable objects
    automatically account for these changes if the location designated by an object’s
    time-zone identifier observes daylight saving time.'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
- en: 'The format() method of the DateTimeImmutable class has a special value for
    identifying whether daylight saving time is in effect for that object: an uppercase
    letter I. Calling format(''I'') returns 1 (true) if daylight saving time applies,
    or 0 (false) if not. [Listing 31-11](#lis31-11) shows an updated version of the
    time-zone script from [Listing 31-10](#lis31-10), with an expanded prettyPrintDatetime()
    function that displays additional information about daylight saving time.'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Listing 31-11: An updated prettyPrintDatetime() function to output a message
    about daylight saving time'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
- en: 'We call format(''I'') on the DateTimeImmutable object passed into the prettyPrintDatetime()
    function, storing the resulting 1 or 0 in the $isDaylight Saving variable ❶. Then
    we use an if...else statement to create an appropriate true/false message about
    daylight saving time based on this variable. All the DateTimeImmutable objects
    have again been created for National Ice Cream Sandwich Day, a useful summertime
    date in the northern hemisphere for demonstrating whether daylight saving applies
    in different time zones. Here’s the output when this updated script is executed:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Daylight saving time never applies to UTC, so the UTC line is shown as FALSE.
    The United Kingdom and France observe daylight saving time starting in late March,
    so London and Paris both show TRUE.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
- en: 'Strangely, while the clocks in Ireland do shift forward as well, Dublin is
    shown to be FALSE. This appears to be due to the way the Republic of Ireland’s
    time zone is legally defined as being GMT in the winter and IST (Irish Standard
    Time) in the summer. By contrast, the United Kingdom and France are defined as
    being in a *summer* time rather than a *standard* time when daylight saving is
    in effect (BST, or British Summer Time, for London, and CEST, or Central European
    Summer Time, for Paris). Therefore, while the UTC+01:00 offset is correct in the
    summer for the time zones identified by Europe/Dublin and Europe/London, one is
    considered daylight saving time and the other is not by the format(''I'') method.  ###
    Epochs and Unix Time'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
- en: Many computer systems measure time relative to an *epoch*, a fixed point in
    time that’s treated as time 0\. For example, Unix systems (including macOS) use
    the *time_t* format, commonly known as *Unix time*, which represents time in terms
    of the number of seconds that have elapsed since the beginning (00:00:00) of Thursday,
    January 1, 1970\. [Table 31-2](#tab31-2) shows a few Unix timestamps and their
    equivalent ISO 8601 date-times. Notice that timestamps before 1970 are represented
    as negative values.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
- en: 'Table 31-2: Example Unix Timestamps'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
- en: '| Date | Timestamp |'
  id: totrans-140
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  id: totrans-141
  prefs: []
  type: TYPE_TB
- en: '| 1969-12-31 23:59:00 | –60 |'
  id: totrans-142
  prefs: []
  type: TYPE_TB
- en: '| 1970-01-01 00:00:00 | 0 |'
  id: totrans-143
  prefs: []
  type: TYPE_TB
- en: '| 1970-01-01 00:02:00 | 120 |'
  id: totrans-144
  prefs: []
  type: TYPE_TB
- en: '| 2009-08-02 00:00:00 | 1249171200 |'
  id: totrans-145
  prefs: []
  type: TYPE_TB
- en: PHP’s built-in time() function returns the current date and time as a Unix timestamp.
    While modern PHP programmers typically use DateTimeImmutable objects, you may
    encounter the time() function in older code or code from non-object-oriented programmers.
    Therefore, it’s useful to be able to work with code that stores these Unix timestamps.
    If you have a DateTimeImmutable object, you can get its equivalent Unix timestamp
    by using the object’s getTimestamp() method. [Listing 31-12](#lis31-12) shows
    a script to create objects and print the corresponding timestamps for each row
    in [Table 31-2](#tab31-2).
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Listing 31-12: Converting DateTimeImmutable objects to Unix timestamps'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we declare a print_timestamp() function that takes in a date-time string,
    creates a DateTimeImmutable object for that string, and prints the equivalent
    timestamp (along with a custom-formatted, human-readable version of the date-time)
    by using the getTimestamp() method. Then we invoke the function four times, once
    for each row from [Table 31-2](#tab31-2). Here’s the result:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'The reverse of getTimestamp() is the setTimeStamp() method, which creates a
    new DateTimeImmutable object corresponding to a given Unix timestamp, as shown
    here:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Notice the extra set of parentheses around (new DateTimeImmutable()). This
    creates a new default DateTimeImmutable object, which we then use to call the
    setTimeStamp() method, passing the relevant timestamp in the $timestamp variable.
    This in turn creates another new DateTimeImmutable object set to correspond with
    the timestamp, which we store in the $datetime variable. Without the extra parentheses,
    the statement would look as follows, and the PHP engine wouldn’t understand the
    syntax:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: When working with code that uses Unix timestamps, I recommend refactoring the
    code to use setTimeStamp() to create an equivalent DateTimeImmutable object, then
    do all the logic with that object. You can then use the getTime stamp() method
    to convert the final result back to a timestamp. Or, better still, refactor all
    the code to use DateTimeImmutable objects with no reference whatsoever to timestamps.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
- en: NOTE
  id: totrans-156
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*Unix timestamps were originally stored using 32-bit integers, a shortsighted
    scheme. The last timestamp that can be correctly stored in the original 32-bit
    format will be* +2147483647 *(2**^(31)* *– 1), the equivalent of 3:14* *AM* *and
    7 seconds on January 19, 2038\. Ticking forward one more second would result in
    an overflow error and a timestamp of* -2147483648*, or 8:45* *PM* *and 52 seconds
    on December 13, 1901\. Fortunately, most systems have already been upgraded to
    use 64 bits for Unix timestamps, which postpones the overflow error by 292 billion
    years.*'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
- en: Date-Time Information in a Web Application
  id: totrans-158
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this section, we’ll build a simple web application to synthesize what we’ve
    covered so far about working with date-time information in PHP. The application
    will provide a form for the user to enter an address and a date, and it will display
    the sunrise and sunset times for that day and location, along with the total duration
    of daylight for that day as determined by the DateInterval class.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
- en: As it happens, PHP has a built-in date_sun_info() function that reports the
    sunrise and sunset times (along with other information) for a given date and location.
    The function requires the location to be specified as latitude and longitude coordinates
    rather than a street address, however. Our application will therefore also demonstrate
    how to obtain data from an external API, as we’ll rely on OpenStreetMap to convert
    the address to coordinates. We’ll use a popular open source PHP library called
    Guzzle to communicate with OpenStreetMap. Guzzle provides an HTTP client, allowing
    code to send and receive HTTP requests. This makes it straightforward to integrate
    PHP web applications with external web services.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 31-1](#fig31-1) features screenshots of the pages we’ll create.'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/figure31-1.jpg)'
  id: totrans-162
  prefs: []
  type: TYPE_IMG
- en: 'Figure 31-1: Screenshots of the sunrise-sunset web application'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
- en: The home page allows the user to submit a street address and a date. This leads
    to a results page showing the calculated information. The results page will also
    have a link to view the specified location in OpenStreetMap.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
- en: To get started, create a new project with the usual *composer.json* file and
    *public/index.php* script that creates an Application object and calls its run()
    method. Then enter composer require guzzlehttp/guzzle at the command line to add
    the third-party Guzzle library to the project. Since we’re running Composer and
    have created the *composer.json* file for our namespace, Composer will also create
    our namespaced class autoloader at this time.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
- en: The Application Class
  id: totrans-166
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Now we’ll declare the Application class for our site in *src/Application.php*.
    The class will handle requests by either displaying the home page or processing
    data from the application’s web form. [Listing 31-13](#lis31-13) shows the code.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Listing 31-13: The Application class declaring two routes'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
- en: As usual, the class’s run() method uses a switch statement to handle incoming
    requests. First, we declare the case for when $action is 'processForm' ❶. For
    this case, we attempt to extract the address and date variables from the POST
    data in the request. If either is empty ❷, we invoke the homepage() method, passing
    in an error message. Otherwise, we pass along the address and date to the processForm()
    method.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
- en: The only other case in the switch statement is the default route ❸, which simply
    invokes the homepage() method without any arguments. The homepage() method itself
    ❹ uses require_once to display the *homepage.php* template (we’re using regular
    PHP files for templating rather than Twig for simplicity). The method has an $errorMessage
    parameter with a default value of an empty string. This variable will be in the
    scope of the template for printing.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
- en: The meat of this class is the processForm() method, which takes in the submitted
    address and date as strings and uses them to obtain sunrise and sunset times,
    along with a total duration of daylight. We first need to convert the address
    into latitude and longitude coordinates. For that, we create a new StreetMap object
    (we’ll look at this class shortly) and invoke its getOpenStreetMapData() method
    ❺, passing in the $address string. The result, in the $latLongArray variable,
    is an array with 'latitude' and 'longitude' keys holding the necessary coordinates,
    which we extract into separate variables.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
- en: Next, we use the date string submitted through the web form to create a corresponding
    DateTimeImmutable object called $date. We then create a new SunData object (another
    class we’ll look at shortly), passing $date, $latitude, and $longitude as arguments
    ❻. The SunData object uses the provided information to calculate the sunrise and
    sunset times and the daylight duration. We extract this data into individual variables
    via the appropriate getter methods, which are chained with calls to format() to
    convert the date-time information into strings. The $sunrise and $sunset variables
    are given in the form 8.35am. The $hoursDaylight variable is a DateInterval object
    presented in the form 16 hours 39 minutes, using %h for the hours and %i for minutes
    ❼. With all these variables in scope, we display the *result.php* template ❽.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
- en: All this activity in the processForm() method is embedded inside a try block.
    If something goes wrong, such as a failure to connect to OpenStreetMap, the catch
    statement at the end of the method ❾ displays an error message along with a link
    back to the home page.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
- en: The Supporting Classes
  id: totrans-175
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: We’ll next declare the supporting classes for the application, starting with
    StreetMap, which manages working with the OpenStreetMap web server. Create *src/StreetMap.php*
    as shown in [Listing 31-14](#lis31-14).
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Listing 31-14: The StreetMap class for accessing the OpenStreetMap server'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
- en: First, the use statement allows us to draw on the Guzzle library’s Client class,
    which is in the GuzzleHttp namespace. This class will manage the details of making
    an HTTP request to an external site. We then declare the client instance variable
    and initialize it as a Client object in the constructor. We provide various Guzzle
    Client parameters, such as the time-out (the amount of time to wait for a response)
    and the sending agent name ('matt smith demo' is fine for this project). We take
    care to configure the Client to accept JSON data ❶, since that’s the format returned
    by the OpenStreetMap API.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
- en: Next, we declare the getOpenStreetMapData() method. It takes in an address (I’ve
    provided a default value for testing purposes) and uses it to build an appropriate
    query string via the buildQueryString() method. Then it uses the request() method
    of the Client object to send the request to the OpenStreetMap API and store the
    received response ❷. If the response code is valid (200), the received data is
    decoded into a $jsonData array ❸. If either the response code isn’t 200 or an
    empty array is received, we throw an exception to signal to the calling code that
    there has been a problem getting data from the OpenStreetMap API ❹. If the code
    gets through the if...else statement without throwing an exception, the latitude
    and longitude are extracted from the received $jsonData and returned as an array
    ❺.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we declare the buildQueryString() method. It uses PHP’s built-in http_build_query()
    function to encode the address and other details into an appropriate query string
    for the Nominatim OpenStreetMap API ❻. We provide the query information to http_build_query()
    as key/value pairs in an array, then attach the encoded query string, in variable
    $query, to the end of a $url.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
- en: NOTE
  id: totrans-182
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*For more about the requirements of the Nominatim OpenStreetMap API, see* [https://nominatim.org](https://nominatim.org)*.*
    Nominatim *(Latin for “by name”) is an open source software project that offers
    searching of OpenStreetMap data. It facilitates both* geocoding *(location from
    a given name and address) and* reverse geocoding *(address from a given location).*'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
- en: Now we’ll look at the SunData class, which is designed to simplify the process
    of working with PHP’s built-in date_sun_info() function. Declare the class in
    *src/SunData.php* as in [Listing 31-15](#lis31-15).
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Listing 31-15: The SunData class for working with the date_sun_info() function'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
- en: 'We give the SunData class three instance variables: sunrise and sunset are
    DateTimeImmutable objects for the sunrise and sunset times, and hoursDaylight
    is a DateInterval object for the duration of daylight. The SunData constructor
    takes in three arguments: the date (a DateTimeImmutable object) and the latitude
    and longitude of the location of interest. These are the pieces of information
    the date_sun_info() function needs, although the date must be in the form of a
    Unix timestamp, so the constructor starts by calling getTime stamp() to make the
    conversion ❶.'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
- en: Then we call date_sun_info(), storing the result, an array of information, in
    the $data variable ❷. We extract the sunrise and sunset times from the $data array,
    storing them in the appropriate instance variables. Because date_sun_info() returns
    date-time information as Unix timestamps, we use the dateFromTimestamp() helper
    method to convert back from timestamps to DateTimeImmutable objects. (In this
    method, notice once again that we have to add extra parentheses around the creation
    of the new DateTimeImmutable object before we can call its setTimeStamp() method
    ❹.)
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
- en: For the duration of daylight, we simply take the difference between the sunset
    and sunrise times ❸. The remainder of the SunData class consists of simple getter
    methods to return the three instance variables.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
- en: The Templates
  id: totrans-190
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: We’re now ready to create the templates for the home page (with the web form)
    and the results page. We’ll start with the Home page template in *templates/homepage.php*.
    [Listing 31-16](#lis31-16) shows the code.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Listing 31-16: The form to input an address and date from the user'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
- en: In the body of the page, we first use the alternative if statement syntax to
    display a pink-styled paragraph containing an error message string, provided the
    $errorMessage variable isn’t empty ❶. Then we create a form with an action of
    processForm and fields for the address and date. For the latter, we use an <input>
    element of type date ❷, which most web browsers display as a user-friendly calendar
    date-picker widget, as shown earlier in [Figure 31-1](#fig31-1).
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
- en: The second template is for displaying the results to the user. Create *templates/result.php*
    with the code in [Listing 31-17](#lis31-17).
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Listing 31-17: The template to present sun data results to the user'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
- en: In this template, we first offer the user a link back the home page ❶. Then
    we display the provided date and the latitude and longitude corresponding to the
    provided address.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
- en: Next, we offer a link to view the location in OpenStreetMap, with the values
    of the $latitude and $longitude variables inserted into the link for the mlat
    and mlon query fields ❷. We then output the sunrise, sunset, and hours of daylight
    values, along with appropriate images next to the sunrise and sunset times (*sunrise.png*
    and *sunset.png*, from user Mehwish at *[https://www.flaticon.com](https://www.flaticon.com)*).
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
- en: Links to these images, with acknowledgment to the publisher, are provided in
    the page’s footer element ❸. Download these images and copy them into the *public/images*
    directory to complete the creation of the web application. Then try running the
    web server and testing out the application with different dates and addresses.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
- en: This project has brought together lots of the concepts from this chapter, demonstrating
    a practical use for the DateInterval class and showing how to juggle between DateTimeImmutable
    objects and Unix timestamps. It also illustrates the power of open source libraries,
    in this case showing how Guzzle makes it easy to send requests to external APIs
    and process the returned JSON data.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
- en: MySQL Dates
  id: totrans-202
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When working in PHP, using native PHP date and time objects and functions makes
    sense. When storing temporal data in a database, however, it’s best to use the
    database system’s native format. This way, database queries can be performed on
    the fields, and applications written in other programming languages can also work
    with the stored database data. It’s therefore important to understand the database
    formats for date-time information and learn how to convert between PHP and the
    relevant database formats when reading and writing to the database system. In
    this section, we’ll look at how MySQL handles date-time information, but the principles
    are the same for any DBMS.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
- en: MySQL can store dates, date-times, and timestamps, but we’ll focus on date-times
    here. The basic individual date and time formats for MySQL are the same as ISO
    8601, with dates in the form YYYY-MM-DD and times in the form HH:MM:SS. However,
    MySQL uses a space rather than the letter T as the separator between the date
    and time components, so 1968-11-22T09:05:30 in ISO 8601 format would appear as
    1968-11-22 09:05:30 when stored in MySQL. Like PHP, MySQL can add decimal places
    to the time component to store fractions of seconds, down to microseconds (six
    decimal places).
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
- en: To specify that you want a column in a MySQL table to store date-times, declare
    the column with the DATETIME data type. Modern MySQL systems default to zero decimal
    places for the time component (whole seconds). To include fractions of a second,
    add the desired number of decimal places in parentheses after the data type. For
    example, to store date-times down to the microsecond, you’d declare a column of
    type DATETIME(6).
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
- en: MySQL stores date-time data as UTC values. Therefore, if the MySQL server is
    set to a time zone that isn’t UTC, it will convert any date-times to UTC for storage
    and then convert them back from UTC upon retrieval. In practice, it’s common to
    create UTC DateTimeImmutable objects for storage in the database, and to have
    the web application logic convert retrieved date-times to any other desired time
    zone.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
- en: NOTE
  id: totrans-207
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*If you’re using the* TIMESTAMP *data type in MySQL, be aware that MySQL will
    automatically convert it to UTC, using the time-zone settings of your MySQL server.*'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
- en: To create a MySQL datetime string for insertion into a table from a PHP script,
    start with a DateTimeImmutable object and use its format() method, with the format
    string 'Y-m-d H:i:s' for whole seconds or 'Y-m-d H:i:s.u' for fractional seconds.
    Notice in particular the space between the d and the H. Likewise, having retrieved
    a date-time string from MySQL, you can use the createFromFormat() static method
    of the DateTimeImmutable class to get an equivalent DateTimeImmutable object for
    that MySQL data.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
- en: To demonstrate how to go back and forth between DateTimeImmutable objects and
    MySQL DATETIME fields, let’s create a project with an Appointment entity class
    and a corresponding appointment database table to hold the names and date-times
    of appointments. Start a new project with the usual *composer.json* file, and
    enter composer dump-autoload at the command line to generate the autoloader. Then
    create a new MySQL database schema called date1, and create an appointment table
    in that schema by using the SQL statement in [Listing 31-18](#lis31-18). (See
    “Setting Up the Database Schema” on [page 543](chapter28.xhtml#pg_543) to review
    how to integrate this SQL statement into a PHP script.)
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Listing 31-18: The SQL to create the appointment MySQL database table'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
- en: The table has an auto-incrementing id field for the primary key, a title field
    for a description of the appointment, and a startdatetime field for when it begins.
    We declare the startdatetime field to be of type datetime(6) to illustrate working
    with fractions of a second, but note that MySQL’s default of zero decimal places
    would be sufficient for the majority of real-world meeting or appointment applications.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
- en: Now we’ll declare the Appointment class corresponding to this table. Enter the
    contents of [Listing 31-19](#lis31-19) into *src/Appointment.php*.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Listing 31-19: The Appointment entity class, containing a DateTimeImmutable
    property'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
- en: The Appointment class has id, title, and startDateTime properties to match the
    columns in the appointment table. Notice that the startDateTime property is a
    DateTimeImmutable object ❶. We give each property appropriate getter and setter
    methods. This includes a special setter method for the startDateTime property
    that uses the union type DateTimeImmutable|string to allow either a DateTimeImmutable
    object or a string to be provided as an argument ❷.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
- en: If the received argument is a string, we convert it to a DateTimeImmutable object
    by using the public constant MYSQL_DATE_FORMAT_STRING to help with the formatting.
    (We’ll declare this constant later in the AppointmentRepository class.) This mechanism
    allows the same setter method to work with PHP DateTimeImmutable objects as well
    as the MySQL date-time strings received from the database. The extra logic could
    be avoided by using an ORM library such as Doctrine, which would seamlessly convert
    between PHP data types and their database equivalents.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
- en: We’ll next create an AppointmentRepository class with methods to insert a new
    appointment into the appointments table and fetch all the appointments. For simplicity,
    we’ll combine the database connection and repository methods into this one class,
    but see [Chapter 28](chapter28.xhtml) for examples of managing the database connection
    in a separate Database class. Create *src/AppointmentRepository.php* containing
    the code in [Listing 31-20](#lis31-20).
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Listing 31-20: The AppointmentRepository class for MySQL database interaction'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
- en: We declare a public MYSQL_DATE_FORMAT_STRING constant holding the string with
    the necessary formatting for compatibility between MySQL datetimes and PHP DateTimeImmutable
    objects ❶. We then declare more constants for the database credentials (be sure
    to fill in your own values for these), along with a private connection property
    to hold the PDO database connection object. In the constructor, we create the
    database connection and store it in the connection property ❷, using a try...catch
    structure to handle any problems.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
- en: We next declare the insert() method, which takes in an Appointment object and
    extracts its title and startDateTime properties into individual variables. To
    create the MySQL date string $dateString, we pass the MYSQL _DATE_FORMAT_STRING
    constant to the DateTimeImmutable object’s format() method to get the proper string
    formatting ❸. We then prepare a SQL INSERT statement, populate it with values,
    and execute the statement to add a new row into the appointment table.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
- en: In the findAll() method, we use PDO’s fetchAll() method to retrieve all the
    entries from the appointment table as an associative array of keys and values
    ❹. The method then loops through this array, creating an Appointment object from
    each element and adding it to the $appointments array, which is then returned.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we’ll create an index script that we can run at the command line to
    create a few sample Appointment objects, add their data to the database, and then
    retrieve the entries back out of the database as an array of Appointment objects.
    Create *public/index.php* as in [Listing 31-21](#lis31-21).
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Listing 31-21: The index script /public/index.php testing our MySQL date example'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
- en: We require the autoloader and declare use statements for the Mattsmithdev namespaced
    AppointmentRepository and Appointment classes. Then we create an AppointmentRepository
    object called $appointmentRepository, along with two sample Appointment objects,
    which we insert into the database by using the $appointmentRepository object’s
    insert() method. Each object is given a time with a fractional second component
    and is specified using ISO 8601 formatting, including the T separator between
    the date and the time. This formatting doesn’t matter, however, since we’ve written
    the AppointmentRepository class with logic to convert to MySQL date-time formatting.
    We finish the script by calling the findAll() method of the repository object
    to retrieve all database rows as an array of Appointment objects, which we loop
    through and pass to var_dump().
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s the output when the index script is executed:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Two appointments have been retrieved from the database and output to the console.
    The first is the 'get an ice cream sandwich' appointment, with a start date-time
    of 2009-08-02 11:00:00.500000. The second is the 'celebrate birthday' appointment,
    with a start date-time of 2025-11-22 09:05:30.770000. The date components for
    both have been stored to six decimal places for fractions of a second. Notice
    that the time zones are Europe/Dublin, the setting for my PHP setup that is applied
    by default when new DateTimeImmutable objects are created. If the web application
    was working with dates from different time zones, one solution would be to store
    the time zone along with the UTC version of each date-time in the database, then
    convert the retrieved date-times back to that time zone upon retrieval.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-232
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Manipulating dates and times is often a necessary part of developing applications,
    since date-time information provides useful functionality to users (such as maintaining
    a calendar) and is valuable for recording data about when actions and requests
    have occurred. In this chapter, we explored the most useful PHP classes and functions
    relating to dates and times, including the DateTimeImmutable and DateInterval
    classes.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
- en: We put these language features to work in a web application that reported sunrise
    and sunset information, which relied on the Guzzle library to make HTTP requests
    to an external site. We also looked at how to move date-time information back
    and forth between PHP scripts and MySQL database tables, converting formats as
    appropriate.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
- en: Exercises
  id: totrans-235
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '1.   Write a script to create (and var_dump) DateTimeImmutable objects in UTC
    (Zulu time), Irish Standard Time, and Eastern Standard Time for the following:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
- en: '2025-01-01 10:00:00'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
- en: '2025-01-02 12:00:00.05'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
- en: '2.   Write a script to create (and var_dump) DateInterval objects between 2000-01-01
    22:00:00 and the following:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
- en: '2000-01-02 22:00:00'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
- en: '2010-05-06 00:00:00'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
- en: '2010-05-06 00:00:30'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
- en: '2020-01-01 22:00:00'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
- en: '3.   Develop a project to create, store, and retrieve patient meetings with
    doctors. The project should use a MySQL database for storing the records. Base
    your project around a Consultation entity class containing the following properties:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
- en: Patient name (string)
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
- en: Doctor name (string)
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
- en: Consultation date and time (DateTimeImmutable)
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
- en: Duration in minutes (integer)
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s a SQL statement to create a database table for such records:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 4.   Create a new project to find the hours of daylight in New York and Dublin
    on the last day of the previous millennium, December 31, 1999.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
