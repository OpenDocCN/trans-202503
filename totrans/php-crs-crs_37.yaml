- en: <hgroup>
  id: totrans-0
  prefs: []
  type: TYPE_NORMAL
  zh: <hgroup>
- en: 31 WORKING WITH DATES AND TIMES
  id: totrans-1
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 31 处理日期和时间
- en: </hgroup>
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: </hgroup>
- en: '![](../images/opener.jpg)'
  id: totrans-3
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/opener.jpg)'
- en: 'Web applications use dates and times in many ways: to maintain calendars, log
    when invoices are created, record when a message has been sent, and so on. In
    this chapter, we’ll explore PHP’s built-in resources for storing and manipulating
    dates and times, including ways to handle complexities such as time zones and
    daylight saving time. We’ll also look at how to send date-time information back
    and forth between PHP and a database system like MySQL, which has its own, separate
    way of storing that information.'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 网络应用程序以多种方式使用日期和时间：如维护日历、记录发票创建时间、记录消息发送时间等等。本章将探讨PHP内置的日期和时间存储及处理资源，包括处理时区和夏令时等复杂性的方法。我们还将了解如何在PHP和像MySQL这样的数据库系统之间传递日期时间信息，后者有自己独立的存储方式。
- en: '### The ISO 8601 Standard'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: '### ISO 8601标准'
- en: Countries have varying conventions for representing dates and times in day-to-day
    life. For example, people in the United States write 11/2 for November 2, but
    people in Ireland and the United Kingdom write 2/11 for that date. Likewise, some
    countries use 24-hour time, while others use 12-hour time with AM and PM designations.
    Computer programs have no room for such ambiguity when storing and manipulating
    dates and times, so it’s important to agree on a standard. These days, pretty
    much everyone in computing uses the date-time formats declared in *ISO 8601*,
    a standard originally published in 1988 and updated several times since.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 各国在日常生活中有不同的日期和时间表示习惯。例如，美国人写11/2表示11月2日，而爱尔兰和英国则写作2/11表示该日期。同样，有些国家使用24小时制，而有些国家则使用12小时制，并加上AM和PM标识。计算机程序在存储和处理日期与时间时不能容忍这种歧义，因此达成一致的标准非常重要。如今，几乎所有计算机领域的人都使用*ISO
    8601*定义的日期时间格式，这一标准最初发布于1988年，之后经过了多次更新。
- en: Two key principles of ISO 8601 are that dates and times are represented with
    numbers and that they’re ordered from most to least significant. Dates therefore
    start with the year, then the month, then the day. For example, November 22, 1968,
    would typically be written as 1968-11-22, with four digits for the year, two for
    the month, and two for the day, adding leading zeros if required (such as 03 for
    March rather than just 3). Following the same principle of most to least significance,
    times are written as hours, then minutes, then seconds. For example, 5 minutes
    and 30 seconds past 9 AM would be written as 09:05:30. You can add a decimal point
    and more digits for fractions of a second if needed, so 09:05:30.01 is one-hundredth
    of a second after 09:05:30. The standard uses 24-hour time, so 11 PM is given
    as 23:00:00.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: ISO 8601的两个关键原则是：日期和时间用数字表示，并且它们按从最重要到最不重要的顺序排列。因此，日期从年份开始，然后是月份，再到日期。例如，1968年11月22日通常写作1968-11-22，年份用四位数表示，月份和日期用两位数表示，如果需要，则会加上前导零（例如，3月应该写作03而不是3）。遵循相同的原则，时间按小时、分钟、秒的顺序书写。例如，上午9:05:30就是9点5分30秒。若需要表示秒的小数部分，可以加上小数点和更多数字，所以09:05:30.01表示比09:05:30多出百分之一秒。该标准使用24小时制，因此晚上11点会写作23:00:00。
- en: NOTE
  id: totrans-8
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 注意
- en: '*The creator of PHP, Rasmus Lerdorf, was born on November 22, 1968\. The web
    doesn’t say what time he was born, so I’ve made up the time of 9:05* *AM* *and
    30 seconds for the examples in this chapter.*'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: '*PHP的创造者，拉斯穆斯·勒多夫（Rasmus Lerdorf），于1968年11月22日出生。网络上并没有提到他出生的具体时间，因此我为本章的示例编造了9:05*
    *AM* *和30秒。*'
- en: These examples illustrate the *extended version* of ISO 8601’s date and time
    formatting, which adds dashes between the fields in the date, and colons between
    the fields in the time, to aid with human readability. Internally, the computer
    might not use these separators, but it’s recommended to always use them when presenting
    a date or time to a human, since something like 1968-11-22 is a lot easier for
    a human to interpret than 19681122.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 这些示例展示了ISO 8601日期和时间格式的*扩展版本*，它在日期字段之间加上了破折号，在时间字段之间加上了冒号，以提高人类可读性。计算机内部可能不会使用这些分隔符，但建议在向人类展示日期或时间时始终使用它们，因为像1968-11-22这样的格式比19681122更容易为人理解。
- en: When combining a date and a time, ISO 8601 calls for a capital T between the
    date and time components. Therefore 5 minutes and 30 seconds past 9 AM on November
    22, 1968, would be written as 1968-11-22T09:05:30. That said, the original ISO
    8601 standard allowed the use of a space between the date and time rather than
    a T, so many computer implementations will also accept 1968-22-22 09:05:30 as
    a valid format.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在组合日期和时间时，ISO 8601 规范要求日期和时间部分之间使用大写字母 T。因此，1968 年 11 月 22 日上午 9:05:30 应写作 1968-11-22T09:05:30。值得注意的是，原始的
    ISO 8601 标准允许在日期和时间之间使用空格而不是 T，因此许多计算机实现也会接受 1968-11-22 09:05:30 作为有效格式。
- en: NOTE
  id: totrans-12
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 注意
- en: '*A concept found in most programming languages is* date-time*. So while we
    humans think about dates and times separately, or might talk about a* date and
    time*, in computer programming we typically work with objects that store data
    about a date and time all together. If we’re interested in only the date, we ignore
    the time components in our code, often defaulting to a zeroed time component for
    the beginning of a new day (*00:00:00*). If we’re interested in only the time,
    we ignore the date components in our code and often default to the current date.*'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '*在大多数编程语言中都有一个概念是* 日期时间*。因此，尽管我们人类把日期和时间看作分开处理，或者可能会说到一个* 日期和时间*，但在计算机编程中，我们通常使用存储日期和时间数据的对象。如果我们只关心日期，在代码中就忽略时间部分，通常将时间部分默认设置为一天的起始时间（*00:00:00*）。如果我们只关心时间，则忽略日期部分，通常将日期部分默认为当前日期。*'
- en: Time-zone characters or time offsets can be added to the end of a date-time
    string; we’ll look at how this works in “Formatting the Date-Time Information”
    on [page 634](#pg_634). ISO 8601 also defines other date and time components (such
    as week numbers), but the components I’ve described cover 99 percent of the date
    and time formatting needed to create and work with temporal data in PHP programs.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 可以将时区字符或时区偏移量添加到日期时间字符串的末尾；我们将在“格式化日期时间信息”部分（见 [第634页](#pg_634)）讨论这一操作。ISO 8601
    还定义了其他日期和时间组件（例如，周数），但我描述的这些组件涵盖了99%的日期和时间格式化需求，适用于在 PHP 程序中创建和处理时间数据。
- en: Creating Dates and Times
  id: totrans-15
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建日期和时间
- en: The fundamental PHP class for working with individual dates and times is DateTimeImmutable.
    If you create a DateTimeImmutable object without providing arguments to the constructor,
    the new object defaults to the current time and day at the moment of its creation,
    based on the local time-zone settings for your computer system. [Listing 31-1](#lis31-1)
    illustrates how to instantiate this class.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: PHP 中用于处理单独日期和时间的基础类是 DateTimeImmutable。如果你在创建 DateTimeImmutable 对象时没有向构造函数提供参数，则新对象会默认使用创建时刻的当前日期和时间，并根据计算机系统的本地时区设置来确定时间。[示例
    31-1](#lis31-1) 展示了如何实例化此类。
- en: '[PRE0]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Listing 31-1: Creating a DateTimeImmutable object for the current date and
    time'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 31-1：为当前日期和时间创建一个 DateTimeImmutable 对象
- en: 'We create a new DateTimeImmutable object without any arguments and output its
    value by using the var_dump() function. If you execute this script at the command
    line, you should see something similar to the following:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建一个没有任何参数的 DateTimeImmutable 对象，并使用 var_dump() 函数输出它的值。如果你在命令行中执行这个脚本，你应该看到类似下面的输出：
- en: '[PRE1]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The var_dump() function returns the object’s internal date value as a date-time
    string. Notice that this string output uses a space rather than a T between the
    date and the time to aid in human readability, and that the time component uses
    six decimal places to capture the time down to the nearest microsecond (millionth
    of a second). The object’s remaining properties pertain to the time zone (I’m
    in Dublin, Ireland, for example), as we’ll discuss in detail in “Time Zones” on
    [page 641](#pg_641).
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '`var_dump()` 函数返回对象的内部日期值，以日期时间字符串的形式输出。请注意，这个字符串输出在日期和时间之间使用空格而不是“T”，以便提高人类可读性，并且时间部分使用六个小数位来精确到微秒（百万分之一秒）。对象的其他属性与时区有关（例如，我在爱尔兰都柏林），我们将在“时区”部分（见
    [第641页](#pg_641)）详细讨论。'
- en: NOTE
  id: totrans-22
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 注意
- en: '*To get the current date and time, you can also use* new DateTimeImmutable(''now'')*.
    The* ''now'' *argument is useful if you need to provide a second argument specifying
    a different time zone from the default.*'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '*要获取当前日期和时间，你也可以使用* new DateTimeImmutable(''now'')*。* ''now'' *参数如果你需要提供第二个参数，指定不同于默认时区的时间，这时非常有用。*'
- en: 'To create a DateTimeImmutable object holding another (noncurrent) date and
    time, pass a string containing the desired date and time to the constructor, like
    this:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个 DateTimeImmutable 对象来存储另一个（非当前的）日期和时间，可以将包含所需日期和时间的字符串传递给构造函数，像这样：
- en: '[PRE2]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This creates a new DateTimeImmutable object holding the date November 22, 1968,
    and the time 9:05 and 30 seconds.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 这将创建一个新的 DateTimeImmutable 对象，表示日期 1968 年 11 月 22 日，时间为 9:05:30。
- en: Formatting the Date-Time Information
  id: totrans-27
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 格式化日期时间信息
- en: The DateTimeImmutable class’s format() method makes it possible to adjust the
    output style for dates and times in different ways. For example, [Listing 31-2](#lis31-2)
    shows how to format a date-time string to the ISO 8601 standard.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: DateTimeImmutable 类的 format() 方法使得可以以不同方式调整日期和时间的输出格式。例如，[Listing 31-2](#lis31-2)
    展示了如何将日期时间字符串格式化为 ISO 8601 标准。
- en: '[PRE3]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Listing 31-2: Formatting a DateTimeImmutable object constant'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: Listing 31-2：格式化一个 DateTimeImmutable 对象常量
- en: 'We instantiate $now as a default DateTimeImmutable object, then call its format()
    method, passing in the ATOM constant from DateTimeInterface (the DateTimeImmutable
    class is an implementation of this interface). This constant indicates that the
    date and time should be formatted according to the ISO 8601 standard. The format()
    method returns a string, which we store in $atomDateString and print. The output
    should look something like this:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 我们实例化 $now 作为一个默认的 DateTimeImmutable 对象，然后调用它的 format() 方法，传入 DateTimeInterface
    的 ATOM 常量（DateTimeImmutable 类是此接口的实现）。这个常量表示日期和时间应根据 ISO 8601 标准进行格式化。format()
    方法返回一个字符串，我们将其存储在 $atomDateString 中并打印。输出应该类似如下：
- en: '[PRE4]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Notice that the output follows ISO 8601 format, including the T between the
    date and the time. The +00:00 at the end has to do with time zones, which we’ll
    discuss later.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，输出遵循 ISO 8601 格式，包括日期和时间之间的 T。结尾的 +00:00 与时区有关，我们稍后会讨论。
- en: The format() method can also take in a string specifying custom formatting.
    This allows you to create more readable date-time output. For example, you can
    tell format() to spell out the name of the month, include the day of the week,
    convert from 24-hour to 12-hour time, add a suffix to the date number (as in *1st*,
    *2nd*, or *23rd*), and so on. [Listing 31-3](#lis31-3) illustrates how it’s done.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: format() 方法也可以接受一个字符串来指定自定义格式。这允许你创建更易读的日期时间输出。例如，你可以告诉 format() 拼出月份的名称，包含星期几，转换为
    12 小时制，给日期数字添加后缀（如 *1st*、*2nd* 或 *23rd*），等等。[Listing 31-3](#lis31-3) 展示了如何实现这一点。
- en: '[PRE5]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Listing 31-3: Customizing the output string format for a date-time'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: Listing 31-3：自定义日期时间输出字符串格式
- en: 'This time, we provide a string to format() that defines a custom format for
    the date-time information. The string uses letter codes, such as l, j, and S,
    to stand in for parts of the date and time. Here’s what the letters in [Listing
    31-3](#lis31-3) mean:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 这一次，我们向 format() 提供一个字符串，定义日期时间信息的自定义格式。这个字符串使用字母代码，如 l、j 和 S，来代表日期和时间的各个部分。下面是
    [Listing 31-3](#lis31-3) 中字母的含义：
- en: l   The full name of the day of the week (Monday, Tuesday, and so on)
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: l   星期几的全名（如星期一、星期二等）
- en: j   The day of the month as an integer with no leading space (1, 4, 20, 31,
    and so on)
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: j   月份的日期，以整数形式表示，不带前导空格（如 1、4、20、31 等）
- en: S   A two-letter suffix for the numeric date of the month (*st* for 1st, *nd*
    for 2nd, and so on)
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: S   表示月份日期的两字母后缀（*st* 表示 1st，*nd* 表示 2nd，依此类推）
- en: F   The full name of the month (January, May, and so on)
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: F   月份的全名（如一月、五月等）
- en: Y   The four-digit year (2000, 2019, 2025, and so on)
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: Y   四位数的年份（如 2000、2019、2025 等）
- en: i   Minutes with leading zeros (00 through 59)
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: i   带前导零的分钟数（00 到 59）
- en: g   The hour in 12-hour format without leading zeros (1 through 12)
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: g   12 小时制的小时数，不带前导零（1 到 12）
- en: a   The appropriate AM or PM abbreviation
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: a   适当的 AM 或 PM 缩写
- en: The case of each character is important, since several characters represent
    different values depending on whether they’re upper- or lowercase. For example,
    a lowercase d represents the date of the month (with a leading zero if required
    to ensure that it’s two digits), while an uppercase D is the three-letter abbreviation
    of the day of the week (Mon, Tue, and so on).
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 每个字符的大小写非常重要，因为不同的字符代表不同的值，具体取决于它们是大写还是小写。例如，小写的 d 表示月份的日期（如果需要，前面会有零以确保两位数），而大写的
    D 是星期几的三字母缩写（如 Mon、Tue 等）。
- en: NOTE
  id: totrans-47
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 注意
- en: '*The PHP documentation provides a full list of all these special formatting
    characters at* [https://www.php.net/manual/en/datetime.format.php](https://www.php.net/manual/en/datetime.format.php)*.*'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '*PHP 文档提供了所有这些特殊格式字符的完整列表，详见* [https://www.php.net/manual/en/datetime.format.php](https://www.php.net/manual/en/datetime.format.php)*。*'
- en: 'Any text that you want to be included verbatim in the formatted string needs
    to be escaped (preceded by a backslash), character by character. Thus, the string
    argument to format() in [Listing 31-3](#lis31-3) includes character sequences
    like \t\h\e (the word *the*) and \o\f (the word *of*). [Listing 31-3](#lis31-3)
    should output something like this:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 任何希望在格式化字符串中原样包含的文本都需要逐字符转义（在前面加上反斜杠）。因此，[示例 31-3](#lis31-3) 中 format() 方法的字符串参数包含了像
    \t\h\e（单词 *the*）和 \o\f（单词 *of*）这样的字符序列。[示例 31-3](#lis31-3) 应输出类似以下内容：
- en: '[PRE6]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'You can also use letter codes with the createFromFormat() static method to
    create new DateTimeImmutable objects based on formatted strings. Consider this
    example:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以使用字母代码与 createFromFormat() 静态方法，根据格式化字符串创建新的 DateTimeImmutable 对象。参考这个例子：
- en: '[PRE7]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The createFromFormat() method takes two arguments. The first is a formatter
    string built using the letter codes we’ve discussed. The second is a string that
    follows the indicated format and sets the value for the new DateTimeImmutable
    object.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: createFromFormat() 方法接受两个参数。第一个是使用我们讨论过的字母代码构建的格式化字符串。第二个是一个遵循指定格式的字符串，为新的 DateTimeImmutable
    对象设置值。
- en: Using DateTimeImmutable vs. DateTime
  id: totrans-54
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 使用 DateTimeImmutable 与 DateTime
- en: Our focus has been on the DateTimeImmutable class, but PHP also offers the similar
    DateTime class. The only difference (but an important one) is that once created,
    a DateTimeImmutable object won’t change the values it contains, whereas a DateTime
    object’s value can be updated. One consequence is that DateTimeImmutable methods
    that might change the date or time return a new DateTimeImmutable object rather
    than modifying the original object’s values.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的重点是 DateTimeImmutable 类，但 PHP 还提供了类似的 DateTime 类。唯一的区别（但至关重要）是，DateTimeImmutable
    对象一旦创建，其包含的值不会发生变化，而 DateTime 对象的值可以被更新。一个后果是，可能会更改日期或时间的 DateTimeImmutable 方法将返回一个新的
    DateTimeImmutable 对象，而不是修改原始对象的值。
- en: Use DateTimeImmutable whenever possible rather than DateTime to avoid the unexpected
    behavior of an object changing and returning a reference to itself. To see why,
    look at [Listing 31-4](#lis31-4).
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 尽可能使用 DateTimeImmutable 而非 DateTime，以避免对象发生意外变化并返回对其自身的引用。要了解原因，请参见 [示例 31-4](#lis31-4)。
- en: '[PRE8]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Listing 31-4: Creating a DateTime object and modifying it'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 31-4：创建一个 DateTime 对象并修改它
- en: 'We create a new DateTime (rather than DateTimeImmutable) object called $today
    and print its value (in year-month-day format). Then we invoke the object’s modify()
    method to move the date one day forward, storing the result in the $tomorrow variable.
    Rather than creating a new DateTime object for the next day, however, calling
    modify() changes the original DateTime object and returns a reference to that
    same object. To confirm this, we print both $today and $tomorrow. The output will
    look something like this:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了一个新的 DateTime（而不是 DateTimeImmutable）对象，命名为 $today，并打印其值（以年-月-日格式）。然后，我们调用该对象的
    modify() 方法将日期向前推一天，并将结果存储在 $tomorrow 变量中。然而，调用 modify() 方法并没有为第二天创建一个新的 DateTime
    对象，而是更改了原始的 DateTime 对象并返回了对该对象的引用。为确认这一点，我们打印了 $today 和 $tomorrow。输出结果大致如下：
- en: '[PRE9]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Initially, the value of $today indicates November 22\. After calling modify(),
    both $today and $tomorrow indicate November 23\. Both variables reference the
    same DateTime object, whose value was changed by the modify() method.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 最初，$today 的值表示 11 月 22 日。调用 modify() 方法后，$today 和 $tomorrow 都表示 11 月 23 日。两个变量都引用同一个
    DateTime 对象，该对象的值被 modify() 方法更改。
- en: While having changeable date-time information may sometimes be desirable, it’s
    important to make sure that’s what you want before using DateTime over DateTimeImmutable.
    The example also illustrates how inappropriate variable names can make code hard
    to understand and debug. If we deliberately create a mutable DateTime object and
    make a change to its date, that object shouldn’t be named for a particular date
    (like $today or $tomorrow), since at some point the name of the variable won’t
    correctly refer to its value.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然在某些情况下，具有可变日期时间信息可能是可取的，但在使用 DateTime 而非 DateTimeImmutable 之前，务必确认这是你想要的。这个例子也展示了不恰当的变量命名如何使代码难以理解和调试。如果我们故意创建了一个可变的
    DateTime 对象并对其日期进行更改，那么该对象的命名就不应与特定的日期（如 $today 或 $tomorrow）相关，因为在某些时候，变量的名称将不再准确地反映其值。
- en: 'To really see the difference between the two PHP date-time classes, try changing
    the class from DateTime to DateTimeImmutable in [Listing 31-4](#lis31-4) and then
    run the script again. Here’s the output:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 为了真正看到这两个 PHP 日期时间类之间的区别，尝试将 [示例 31-4](#lis31-4) 中的类从 DateTime 更改为 DateTimeImmutable，然后再次运行脚本。以下是输出结果：
- en: '[PRE10]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: This time, the value of $today remains the same, even as $tomorrow moves one
    day ahead. This is because the modify() method of a DateTimeImmutable object creates
    and returns a completely new DateTimeImmutable object with the modified value
    while leaving the original object unchanged. Therefore, $today and $tomorrow refer
    to two different DateTimeImmutable objects, and both variable names are reasonable,
    since they always correctly refer to the values of the object they reference.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 这次，$today的值保持不变，而$tomorrow则提前一天。这是因为DateTimeImmutable对象的modify()方法创建并返回一个全新的DateTimeImmutable对象，修改了值，但原始对象保持不变。因此，$today和$tomorrow指代的是两个不同的DateTimeImmutable对象，两个变量名都是合理的，因为它们始终正确地指代它们所引用的对象的值。
- en: Manipulating Dates and Times
  id: totrans-66
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 操作日期和时间
- en: PHP’s DateTimeImmutable class features several methods that create a new DateTimeImmutable
    object based on the value of an existing one. These methods make it possible to
    programmatically manipulate date and time information.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: PHP的DateTimeImmutable类提供了多个方法，这些方法可以基于现有对象的值创建一个新的DateTimeImmutable对象。这些方法使得程序可以对日期和时间信息进行操作。
- en: You already saw one example, the modify() method, in [Listing 31-4](#lis31-4).
    This method takes a string argument indicating how to set a new date or time relative
    to the current DateTimeImmutable object’s value. For instance, the strings 'yesterday'
    and 'tomorrow' yield midnight (time 00:00:00) on the previous or next day; the
    'noon' and 'midnight' strings yield noon (12:00:00) or midnight on the current
    day; and 'first day of this month' or 'last day of this month' change the date
    as appropriate while leaving the time the same. These modifier strings can be
    combined; for example, 'tomorrow noon' and 'first day of this month midnight'
    are both valid.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经看到了一个示例，即[示例31-4](#lis31-4)中的modify()方法。这个方法接受一个字符串参数，表示如何相对于当前DateTimeImmutable对象的值设置新的日期或时间。例如，字符串“yesterday”和“tomorrow”会返回前一天或次日的午夜（时间为00:00:00）；“noon”和“midnight”字符串会返回当天的中午（12:00:00）或午夜；“本月的第一天”或“本月的最后一天”会根据需要更改日期，同时保持时间不变。这些修饰符字符串可以组合使用，例如，“明天中午”和“本月的第一天午夜”都是有效的。
- en: Other modifier strings use + or - followed by a quantity and unit of time to
    give more granular control over the new DateTimeImmutable object’s value, as in
    '+1 day', '-2 hours', or '+30 seconds'. These can also be combined into longer
    strings, such as '+1 day +30 seconds'. [Listing 31-5](#lis31-5) shows some of
    these modifiers in action.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 其他修饰符字符串使用+或-后跟数量和时间单位，以更精细地控制新的DateTimeImmutable对象的值，例如“+1天”、“-2小时”或“+30秒”。这些修饰符也可以组合成更长的字符串，例如“+1天+30秒”。[示例31-5](#lis31-5)展示了这些修饰符的实际应用。
- en: '[PRE11]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Listing 31-5: Passing relative date-time strings to the modify() method'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 示例31-5：将相对日期时间字符串传递给modify()方法
- en: 'To help show the date-times before and after modification, we first declare
    a showModify() function that takes in a modifier string as an argument. The function
    prints the modifier string itself, creates a new DateTimeImmutable object with
    the current time, and passes the string to the modify() method to create another,
    modified DateTimeImmutable object. Then it prints both objects in ISO 8601 format.
    Next, we make a series of showModify() calls to demonstrate various modifier strings.
    The output should be something like this:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 为了帮助展示修改前后的日期时间，我们首先声明一个showModify()函数，它接受一个修饰符字符串作为参数。该函数打印修饰符字符串本身，创建一个当前时间的DateTimeImmutable对象，并将该字符串传递给modify()方法，以创建另一个修改过的DateTimeImmutable对象。然后它以ISO
    8601格式打印两个对象。接着，我们通过一系列showModify()调用来演示不同的修饰符字符串。输出应该像这样：
- en: '[PRE12]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The value of $date1 is the same for each function call, November 22, 1968, at
    9:05 and 30 seconds. With the 'first day of this month' modifier, the date component
    of $date2 ends up as November 1, but the time component is left unchanged ❶. With
    '+1 day', the date component moves forward to November 23, but again the time
    component is unchanged ❷. The '+30 seconds' and '-10 seconds' strings move the
    time component forward and backward without changing the date component, while
    '+1 month +3 days +1 seconds' changes both the date and time.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: $date1的值对于每次函数调用都是相同的，时间为1968年11月22日9点05分30秒。使用“本月的第一天”修饰符时，$date2的日期部分变为11月1日，但时间部分保持不变❶。使用“+1天”时，日期部分移动到11月23日，但时间部分同样保持不变❷。“+30秒”和“-10秒”字符串分别使时间部分前后移动，而不改变日期部分，类似地，“+1个月+3天+1秒”则同时更改日期和时间。
- en: If you provide a date to the modify() method, that date will replace the original
    one in the new DateTimeImmutable object created, leaving the time unchanged. For
    example, the '2000-12-31' string applied to an object holding 1968-11-22T09:05:30
    would result in a new object of 2000-12-31 T09:05:30, the same time but for December
    31, 2000\. Likewise, providing a time results in a new object with the original
    date but the new time.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你向 modify() 方法提供一个日期，该日期将替换新创建的 DateTimeImmutable 对象中的原始日期，而时间保持不变。例如，将字符串
    '2000-12-31' 应用于一个包含 1968-11-22T09:05:30 的对象，将导致创建一个新的对象，日期为 2000-12-31 T09:05:30，时间保持不变，只是日期变为
    2000 年 12 月 31 日。同样，提供一个时间会导致一个新的对象，其日期不变，但时间更新为新值。
- en: 'That said, modifying just the date or time component of a DateTime Immutable
    object can be accomplished more easily using the setDate() and setTime() methods.
    For example, if $date1 is a DateTimeImmutable object, both the following statements
    result in the same new object being created:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 也就是说，仅修改 DateTimeImmutable 对象的日期或时间组件可以通过使用 setDate() 和 setTime() 方法更轻松地实现。例如，如果
    $date1 是一个 DateTimeImmutable 对象，以下两个语句会创建相同的新的对象：
- en: '[PRE13]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Notice that the setDate() method takes three separate integers as arguments,
    rather than a single string. These integers represent the desired year, month,
    and day. Similarly, the setTime() method takes four integers for the new hour,
    minute, second, and microsecond. The latter two default to 0.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，setDate() 方法接受三个独立的整数作为参数，而不是一个字符串。这些整数分别表示期望的年份、月份和日期。类似地，setTime() 方法接受四个整数，表示新的小时、分钟、秒和微秒。后两个默认值为
    0。
- en: '#### Using Date-Time Intervals'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '#### 使用日期时间间隔'
- en: The DateInterval class represents a span of time rather than a specific date-time.
    This class provides another useful way of manipulating date-time information and
    of thinking about the relationship between different date-times. For example,
    the add() and sub() methods of the DateTimeImmutable class take in a DateInterval
    object and return a new DateTimeImmutable object offset forward or backward in
    time from the original object by the specified interval. [Listing 31-6](#lis31-6)
    illustrates how this works.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: DateInterval 类表示一段时间跨度，而不是特定的日期时间。这个类提供了另一种处理日期时间信息以及思考不同日期时间之间关系的有用方法。例如，DateTimeImmutable
    类的 add() 和 sub() 方法接受一个 DateInterval 对象，并返回一个新的 DateTimeImmutable 对象，该对象在时间上根据指定的时间间隔向前或向后偏移。[清单
    31-6](#lis31-6) 说明了它是如何工作的。
- en: '[PRE14]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Listing 31-6: Creating new DateTimeImmutable objects offset by time intervals'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 31-6：创建由时间间隔偏移的新的 DateTimeImmutable 对象
- en: 'First, we use the createFromDateString() static method to create two Date Interval
    objects. With this method, we can express the desired interval by using strings
    like ''30 seconds'' or ''1 day''. Next, we create a DateTimeImmutable object for
    the current date and time, then call its add() and sub() methods, passing in the
    DateInterval objects. This creates two more DateTimeImmutable objects, offset
    according to the given time intervals. The three date-time strings in the output
    should look something like this:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们使用 createFromDateString() 静态方法创建两个 DateInterval 对象。通过此方法，我们可以使用像 '30 seconds'
    或 '1 day' 这样的字符串来表示期望的时间间隔。接着，我们创建一个表示当前日期和时间的 DateTimeImmutable 对象，然后调用它的 add()
    和 sub() 方法，传入 DateInterval 对象。这会创建两个新的 DateTimeImmutable 对象，根据给定的时间间隔进行偏移。输出中的三个日期时间字符串应该类似于这样：
- en: '[PRE15]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Notice that $date2 has the same date, but its time is 09:06:00, 30 seconds
    later than $date1. Meanwhile, $date3 has the same time, but its date is one day
    earlier: November 21 instead of November 22\. Note that we can create negative
    as well as positive DateInterval objects. For example, we could create a DateInterval
    by using the string ''-1 day''.'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，$date2 拥有相同的日期，但其时间是 09:06:00，比 $date1 晚了 30 秒。与此同时，$date3 拥有相同的时间，但日期早了
    1 天：是 11 月 21 日，而不是 11 月 22 日。注意，我们可以创建负的 DateInterval 对象，也可以创建正的。例如，我们可以通过使用字符串
    '-1 day' 来创建一个 DateInterval。
- en: A more common way of creating a DateInterval object is to use the diff() method
    of the DateTimeImmutable class. Given one DateTimeImmutable object, you call its
    diff() method, passing in a second DateTimeImmutable object, and the method returns
    a DateInterval object representing the difference between those two date-times.
    This is useful when a user has provided a start and end date, and some logic or
    calculation needs to be performed based on the size of the date interval between
    them. For example, a hotel-booking web application might calculate the cost of
    a stay based on the number of days between the desired start and end date. [Listing
    31-7](#lis31-7) shows how this mechanism works.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 创建 `DateInterval` 对象的一个更常见方法是使用 `DateTimeImmutable` 类的 `diff()` 方法。给定一个 `DateTimeImmutable`
    对象，调用它的 `diff()` 方法并传入另一个 `DateTimeImmutable` 对象，方法会返回一个表示这两个日期时间差异的 `DateInterval`
    对象。当用户提供了开始日期和结束日期，并且需要根据这两个日期间的间隔大小进行某些逻辑或计算时，这个方法非常有用。例如，酒店预订网页应用程序可能会根据所选的开始和结束日期之间的天数来计算住宿费用。[清单
    31-7](#lis31-7)展示了这个机制是如何工作的。
- en: '[PRE16]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Listing 31-7: Obtaining the interval between two DateTimeImmutable objects'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 31-7：获取两个 `DateTimeImmutable` 对象之间的间隔
- en: 'We create two DateTimeImmutable objects, $date1 and $date2, specifying just
    the date for each; the objects are six days apart. Then we call the diff()method
    on $date1, passing $date2 as an argument. This produces a DateInterval object
    holding the difference between the two dates, which we format and print. Here’s
    the result:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了两个 `DateTimeImmutable` 对象，`$date1` 和 `$date2`，每个对象仅指定了日期，这两个对象相隔六天。然后我们调用
    `$date1` 上的 `diff()` 方法，并将 `$date2` 作为参数传入。这会生成一个 `DateInterval` 对象，保存两个日期之间的差异，我们对其进行格式化并打印。结果如下：
- en: '[PRE17]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: As expected, the DateInterval object indicates that the two dates are four days
    apart. Note that the format() method of the DateInterval class works differently
    from formatting actual dates. It takes in a string using the percent character
    (%) to indicate where values from the DateInterval object should be inserted.
    For example, %d is replaced by the number of days (6) in the output string.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 如预期的那样，`DateInterval` 对象表示两个日期之间相隔四天。注意，`DateInterval` 类的 `format()` 方法与格式化实际日期的方式不同。它接收一个字符串，使用百分号（%）表示
    `DateInterval` 对象中应该插入的值的位置。例如，%d 会被输出字符串中的天数（6）替代。
- en: Looping at Regular Intervals
  id: totrans-92
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 按规律间隔循环
- en: For displaying a series of date-time values, updating calendars, or generating
    historical reports, it’s often useful to loop at a regular interval between two
    dates. PHP’s DatePeriod class makes this possible. An object of this class can
    be iterated through with a foreach loop, just like an array. Each iteration turns
    up a new DateTimeImmutable object, with all the objects evenly spaced in time.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 对于显示一系列日期时间值、更新日历或生成历史报告，通常需要在两个日期之间按规律间隔进行循环。PHP 的 `DatePeriod` 类可以实现这一点。该类的对象可以像数组一样使用
    `foreach` 循环进行迭代。每次迭代都会产生一个新的 `DateTimeImmutable` 对象，所有对象在时间上均匀分布。
- en: To create a DatePeriod object, you must provide a start and end date, plus a
    DateInterval object defining the rate of iteration. [Listing 31-8](#lis31-8) shows
    an example of using this class to automatically list the first seven days of a
    month.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建 `DatePeriod` 对象，必须提供起始和结束日期，以及定义迭代速率的 `DateInterval` 对象。[清单 31-8](#lis31-8)
    展示了如何使用此类自动列出一个月的前七天。
- en: '[PRE18]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Listing 31-8: Iterating through a DatePeriod object'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 31-8：迭代 `DatePeriod` 对象
- en: 'First, we create and print a DateTimeImmutable object for the current day ($today).
    Then we use the modify() method to create two more DateTimeImmutable objects,
    $firstOfMonth for the first day of the current month, and $oneWeekLater for a
    week after that. These will be the start and end points for the iteration. Next,
    we create a one-day DateInterval object, which we use, along with the start and
    end points, to create a DatePeriod object ❶. The order of arguments is the start
    date, the interval, and then the end date. Finally, we run a foreach loop to iterate
    through the DatePeriod object ❷, printing a formatted string for each date as
    it comes up. The output should look something like the following:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们创建并打印当前日期的 `DateTimeImmutable` 对象（`$today`）。然后，我们使用 `modify()` 方法创建两个新的
    `DateTimeImmutable` 对象，`$firstOfMonth` 表示当前月的第一天，`$oneWeekLater` 表示一周后的日期。这些将作为迭代的起始和结束点。接着，我们创建一个一天的
    `DateInterval` 对象，将它与起始和结束日期一起，用来创建一个 `DatePeriod` 对象 ❶。参数的顺序是起始日期、间隔和结束日期。最后，我们运行一个
    `foreach` 循环来迭代 `DatePeriod` 对象 ❷，并为每个日期打印格式化的字符串。输出应如下所示：
- en: '[PRE19]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Based on a start day of November 22, 1968, the script successfully looped through
    and displayed the first seven days of that month.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 基于1968年11月22日作为开始日期，脚本成功地循环并显示了该月的前七天。
- en: Rather than a start and end date, another way to create DatePeriod objects is
    to give the start date, the interval, and the number of recurrences. This third
    argument doesn’t count the start date itself, so to list the first seven days
    of a month, the number of recurrences would be 6. The DatePeriod constructor also
    has an optional parameter to exclude the start date by passing a fourth argument
    of the constant DatePeriod::EXCLUDE_START_DATE.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 创建DatePeriod对象的另一种方式是给定开始日期、时间间隔和重复次数，而不是开始和结束日期。这个第三个参数不计算开始日期本身，因此，要列出一个月的前七天，重复次数应为6。DatePeriod构造函数还有一个可选参数，通过传递常量DatePeriod::EXCLUDE_START_DATE作为第四个参数来排除开始日期。
- en: NOTE
  id: totrans-101
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 注意
- en: '*At present,* DatePeriod *works only for positive* DateInterval *objects, so
    loops have to move forward in time.*'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '*目前，* DatePeriod *仅适用于正向的* DateInterval *对象，因此循环必须按时间向前推进。*'
- en: Time Zones
  id: totrans-103
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 时区
- en: A *time zone* is a geographical area that observes the same time. These days,
    all time zones worldwide are defined relative to the time standard of *Coordinated
    Universal Time (UTC)*. This is the time at the International Reference Meridian
    (0° longitude), which passes through Greenwich, England. For example, UTC +3 and
    UTC –2 indicate three hours ahead and two hours behind UTC, respectively. UTC
    is also nicknamed *Zulu time*, with *Zulu* being the standard codeword for the
    letter *Z* in the NATO phonetic alphabet. (The *Z* is for *zero*.) [Table 31-1](#tab31-1)
    lists some example UTC offsets and their associated time zones.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '*时区*是一个地理区域，遵循相同的时间。如今，全球所有时区都相对于*协调世界时（UTC）*来定义。这是国际参考子午线（0°经度）上的时间，经过英国格林威治。例如，UTC
    +3和UTC –2分别表示比UTC提前三小时和滞后两小时。UTC也被昵称为*Zulu时间*，*Zulu*是北约音标字母表中字母*Z*的标准代码词。（*Z*代表*零*。）[表31-1](#tab31-1)列出了某些示例UTC偏移量及其相关的时区。'
- en: 'Table 31-1: Example Time Zones'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 表31-1：示例时区
- en: '| UTC offset | Abbreviation | Common name |'
  id: totrans-106
  prefs: []
  type: TYPE_TB
  zh: '| UTC偏移量 | 缩写 | 常用名称 |'
- en: '| --- | --- | --- |'
  id: totrans-107
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| UTC +0 | GMT | Greenwich Mean Time |'
  id: totrans-108
  prefs: []
  type: TYPE_TB
  zh: '| UTC +0 | GMT | 格林威治标准时间 |'
- en: '| UTC +1 | BST | British Summer Time |'
  id: totrans-109
  prefs: []
  type: TYPE_TB
  zh: '| UTC +1 | BST | 英国夏令时 |'
- en: '| UTC +1 | IST | Irish Standard Time |'
  id: totrans-110
  prefs: []
  type: TYPE_TB
  zh: '| UTC +1 | IST | 爱尔兰标准时间 |'
- en: '| UTC +11 | AEDT | Australian Eastern Daylight Time (Tasmania is where my twin
    brother lives) |'
  id: totrans-111
  prefs: []
  type: TYPE_TB
  zh: '| UTC +11 | AEDT | 澳大利亚东部夏令时（塔斯马尼亚是我双胞胎兄弟的居住地） |'
- en: '| UTC –5 | EST | Eastern Standard Time |'
  id: totrans-112
  prefs: []
  type: TYPE_TB
  zh: '| UTC –5 | EST | 美国东部标准时间 |'
- en: '| UTC +2 | CEST | Central European Summer Time |'
  id: totrans-113
  prefs: []
  type: TYPE_TB
  zh: '| UTC +2 | CEST | 中欧夏令时 |'
- en: You can set the default time zone for your system’s PHP setup in the *php.ini*
    configuration file. The time zone itself is given with a *time-zone identifier*,
    a string that includes a region (such as America, Europe, or Pacific) and a city
    located in the desired time zone, separated by a forward slash. [Listing 31-9](#lis31-9),
    for example, shows I’ve set up my system to the Europe/Dublin time zone.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在*php.ini*配置文件中设置系统的默认时区。时区本身通过*时区标识符*来表示，这是一个包含区域（如美国、欧洲或太平洋）和位于目标时区的城市的字符串，中间用斜杠分隔。例如，[清单31-9](#lis31-9)显示了我已经将我的系统设置为欧洲/都柏林时区。
- en: '[PRE20]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Listing 31-9: An excerpt of a php.ini file setting the default time zone to
    Europe/Dublin'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 清单31-9：一个将默认时区设置为欧洲/都柏林的php.ini文件片段
- en: You use date.timezone to set a time-zone identifier for the PHP engine. To verify
    that your system’s time zone has been set correctly, use the date _default_timezone_get()
    function. This returns Europe/Dublin for me.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用date.timezone设置PHP引擎的时区标识符。要验证系统的时区是否已正确设置，可以使用date_default_timezone_get()函数。这对于我来说返回的是欧洲/都柏林。
- en: NOTE
  id: totrans-118
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 注意
- en: '*You can find a full list of acceptable time-zone identifiers in the PHP documentation
    at* [https://www.php.net/manual/en/timezones.php](https://www.php.net/manual/en/timezones.php)*.
    However, avoid using any of the identifiers listed in the Others region, apart
    from* UTC*. These identifiers are for backward compatibility only and may be changed
    in the future.*'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '*你可以在PHP文档中找到接受的完整时区标识符列表，网址是* [https://www.php.net/manual/en/timezones.php](https://www.php.net/manual/en/timezones.php)*。但是，除了*
    UTC*之外，避免使用“其他”区域列出的任何标识符。这些标识符仅用于向后兼容，未来可能会更改。*'
- en: When you create a DateTimeImmutable object in a PHP script, it defaults to the
    time zone of your system. My preferred way to specify a time zone is to pass a
    DateTimeZone object as a second argument to the DateTimeImmutable constructor.
    Another common method is to append a UTC offset to the end of an ISO 8601 string.
    For example, adding +03:00 to the end of the string indicates that the date-time
    is three hours ahead of UTC. [Listing 31-10](#lis31-10) illustrates each of these
    methods.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在 PHP 脚本中创建一个 DateTimeImmutable 对象时，它默认使用你系统的时区。我更倾向于通过将一个 DateTimeZone 对象作为第二个参数传递给
    DateTimeImmutable 构造函数来指定时区。另一种常见的方法是将 UTC 偏移量附加到 ISO 8601 字符串的末尾。例如，向字符串末尾添加
    +03:00 表示该日期时间比 UTC 提前三个小时。[示例 31-10](#lis31-10) 展示了这两种方法。
- en: '[PRE21]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Listing 31-10: Creating DateTimeImmutable objects with different time zones'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 31-10：创建具有不同时区的 DateTimeImmutable 对象
- en: We declare a prettyPrintDatetime() function to nicely print out a DateTimeImmutable
    object and its time zone, along with a string label passed in as the $name parameter.
    The time zone is accessed using the DateTimeImmutable object’s getTimezone() method,
    which returns a DateTimeZone object. Then we have to call the DateTimeZone object’s
    getName() method, which returns the name of the time zone as a string.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 我们声明了一个 prettyPrintDatetime() 函数，用于漂亮地打印出 DateTimeImmutable 对象及其时区，并将作为 $name
    参数传递的字符串标签一起打印。时区通过 DateTimeImmutable 对象的 getTimezone() 方法访问，该方法返回一个 DateTimeZone
    对象。然后，我们必须调用 DateTimeZone 对象的 getName() 方法，该方法返回时区的名称作为字符串。
- en: Next, we declare a series of DateTimeImmutable objects with different time zones,
    all for the date August 2, 2009 (2009-08-02), the first occurrence of National
    Ice Cream Sandwich Day in the United States. The $localDatetime object ❶ holds
    the date according to the system’s default time zone (Europe/Dublin for me, per
    my *php.ini* file). Since we didn’t specify a time, the time will default to midnight.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们声明了一系列不同时区的 DateTimeImmutable 对象，所有对象都指向 2009 年 8 月 2 日（2009-08-02），即美国的第一个国家冰淇淋三明治日。$localDatetime
    对象 ❶ 持有根据系统默认时区（对于我来说是欧洲/都柏林，依据我的 *php.ini* 文件）设置的日期。由于我们没有指定时间，时间将默认为午夜。
- en: 'The $utcDatetime object ❷ is set to UTC by passing two arguments to the DateTimeImmutable
    constructor: $iceCreamDay to specify the date, and a DateTimeZone object set to
    ''UTC'' to specify the time zone. We use this same technique to create objects
    for the time in London, Paris, and Hobart. The $threeHoursAhead object ❸ is created
    by appending the UTC offset +03:00 to the date-time string 2000-01-01T10:00:00
    passed to the DateTimeImmutable constructor, indicating the time is three hours
    ahead of UTC.'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: $utcDatetime 对象 ❷ 通过向 DateTimeImmutable 构造函数传递两个参数来设置为 UTC：$iceCreamDay 用于指定日期，DateTimeZone
    对象设置为 'UTC' 用于指定时区。我们使用相同的技术为伦敦、巴黎和霍巴特的时间创建对象。$threeHoursAhead 对象 ❸ 是通过将 UTC 偏移量
    +03:00 附加到传递给 DateTimeImmutable 构造函数的日期时间字符串 2000-01-01T10:00:00 来创建的，表示该时间比 UTC
    提前三个小时。
- en: 'We print confirmation of the computer system’s time-zone setting by using the
    date_default_timezone_get() built-in function ❹. Then we pass our DateTimeImmutable
    objects one at a time to the prettyPrintDatetime() function ❺. The output should
    look something like this:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用内置函数 date_default_timezone_get() ❹ 打印出计算机系统的时区设置。然后，我们将我们的 DateTimeImmutable
    对象逐个传递给 prettyPrintDatetime() 函数 ❺。输出应该类似于下面的内容：
- en: '[PRE22]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The first data printed is the system’s time-zone setting, Europe/Dublin for
    me ❶. Then as each of our DateTimeImmutable objects is printed, its time-zone
    information is visible in the output in two ways: in the UTC offset at the end
    of the date-time string (for example, +01:00 for London and Dublin, and +10:00
    for Hobart), and in the separate time-zone string we extract as part of the prettyPrintDatetime()
    function. Notice, however, that when we specify the time zone by using a generic
    UTC offset like +03:00 rather than a more specific time-zone identifier, that’s
    how the DateTimeImmutable object records the time zone ❷. This is because PHP
    doesn’t know which region and city to associate with the offset. For example,
    +03:00 could be Europe/Moscow, Asia/Riyadh, or Africa/Mogadishu.'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个打印的数据是系统的时区设置，对于我来说是欧洲/都柏林 ❶。然后，当每个 DateTimeImmutable 对象被打印时，其时区信息通过两种方式出现在输出中：通过日期时间字符串末尾的
    UTC 偏移量（例如，伦敦和都柏林是 +01:00，霍巴特是 +10:00），以及我们在 prettyPrintDatetime() 函数中提取的单独时区字符串。然而，请注意，当我们使用类似
    +03:00 这样的通用 UTC 偏移量而不是更具体的时区标识符来指定时区时，DateTimeImmutable 对象会记录为这种方式 ❷。这是因为 PHP
    不知道应该将该偏移量与哪个区域和城市相关联。例如，+03:00 可能是欧洲/莫斯科、亚洲/利雅得或非洲/摩加迪沙。
- en: Daylight Saving Time
  id: totrans-129
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 夏令时
- en: 'Around a quarter of all countries worldwide operate a system of daylight saving
    time: clocks are set forward by one hour in the spring (“spring forward”), then
    set back by one hour in the autumn (“fall back”). PHP’s DateTimeImmutable objects
    automatically account for these changes if the location designated by an object’s
    time-zone identifier observes daylight saving time.'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 全球约四分之一的国家实行夏令时制度：春季时钟向前拨动一小时（“春季前进”），秋季时钟向后拨动一小时（“秋季后退”）。如果对象的时区标识符所指定的位置观察夏令时，PHP的DateTimeImmutable对象会自动考虑这些变化。
- en: 'The format() method of the DateTimeImmutable class has a special value for
    identifying whether daylight saving time is in effect for that object: an uppercase
    letter I. Calling format(''I'') returns 1 (true) if daylight saving time applies,
    or 0 (false) if not. [Listing 31-11](#lis31-11) shows an updated version of the
    time-zone script from [Listing 31-10](#lis31-10), with an expanded prettyPrintDatetime()
    function that displays additional information about daylight saving time.'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: DateTimeImmutable类的format()方法有一个特殊值用于识别该对象是否处于夏令时：大写字母I。调用format('I')会返回1（true），如果适用夏令时，或者返回0（false），如果不适用。[清单31-11](#lis31-11)显示了从[清单31-10](#lis31-10)更新后的时区脚本，其中扩展了prettyPrintDatetime()函数，以显示关于夏令时的额外信息。
- en: '[PRE23]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Listing 31-11: An updated prettyPrintDatetime() function to output a message
    about daylight saving time'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 清单31-11：更新后的prettyPrintDatetime()函数，输出关于夏令时的消息
- en: 'We call format(''I'') on the DateTimeImmutable object passed into the prettyPrintDatetime()
    function, storing the resulting 1 or 0 in the $isDaylight Saving variable ❶. Then
    we use an if...else statement to create an appropriate true/false message about
    daylight saving time based on this variable. All the DateTimeImmutable objects
    have again been created for National Ice Cream Sandwich Day, a useful summertime
    date in the northern hemisphere for demonstrating whether daylight saving applies
    in different time zones. Here’s the output when this updated script is executed:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在传递给prettyPrintDatetime()函数的DateTimeImmutable对象上调用format('I')，将结果1或0存储在$isDaylightSaving变量中❶。然后，我们使用if...else语句，根据此变量创建一个关于夏令时的适当的真/假消息。所有的DateTimeImmutable对象都已经为国家冰淇淋三明治日创建，这个日期是北半球夏季的一个有用日期，用来演示不同时间区是否适用夏令时。执行此更新脚本时的输出如下：
- en: '[PRE24]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Daylight saving time never applies to UTC, so the UTC line is shown as FALSE.
    The United Kingdom and France observe daylight saving time starting in late March,
    so London and Paris both show TRUE.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 夏令时从不适用于UTC，因此UTC行显示为FALSE。英国和法国从3月底开始实施夏令时，因此伦敦和巴黎都显示为TRUE。
- en: 'Strangely, while the clocks in Ireland do shift forward as well, Dublin is
    shown to be FALSE. This appears to be due to the way the Republic of Ireland’s
    time zone is legally defined as being GMT in the winter and IST (Irish Standard
    Time) in the summer. By contrast, the United Kingdom and France are defined as
    being in a *summer* time rather than a *standard* time when daylight saving is
    in effect (BST, or British Summer Time, for London, and CEST, or Central European
    Summer Time, for Paris). Therefore, while the UTC+01:00 offset is correct in the
    summer for the time zones identified by Europe/Dublin and Europe/London, one is
    considered daylight saving time and the other is not by the format(''I'') method.  ###
    Epochs and Unix Time'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 奇怪的是，尽管爱尔兰的时钟也会向前拨动，但都柏林显示为FALSE。这似乎是因为爱尔兰共和国的时区在法律上定义为冬季使用GMT，夏季使用IST（爱尔兰标准时间）。相比之下，英国和法国在夏令时生效时被定义为*夏季*时间，而不是*标准*时间（伦敦使用BST，即英国夏令时，巴黎使用CEST，即中欧夏令时）。因此，尽管欧洲/都柏林和欧洲/伦敦的时区在夏季的UTC+01:00偏移是正确的，一个被视为夏令时，另一个则不是，通过format('I')方法来区分。
- en: Many computer systems measure time relative to an *epoch*, a fixed point in
    time that’s treated as time 0\. For example, Unix systems (including macOS) use
    the *time_t* format, commonly known as *Unix time*, which represents time in terms
    of the number of seconds that have elapsed since the beginning (00:00:00) of Thursday,
    January 1, 1970\. [Table 31-2](#tab31-2) shows a few Unix timestamps and their
    equivalent ISO 8601 date-times. Notice that timestamps before 1970 are represented
    as negative values.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 许多计算机系统以*纪元*为基准来测量时间，纪元是一个固定的时间点，被视为时间0。例如，Unix系统（包括macOS）使用*time_t*格式，通常称为*Unix时间*，它表示自1970年1月1日（星期四，00:00:00）以来经过的秒数。[表31-2](#tab31-2)显示了几个Unix时间戳及其对应的ISO
    8601日期时间。注意，1970年之前的时间戳表示为负值。
- en: 'Table 31-2: Example Unix Timestamps'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 表 31-2：示例 Unix 时间戳
- en: '| Date | Timestamp |'
  id: totrans-140
  prefs: []
  type: TYPE_TB
  zh: '| 日期 | 时间戳 |'
- en: '| --- | --- |'
  id: totrans-141
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| 1969-12-31 23:59:00 | –60 |'
  id: totrans-142
  prefs: []
  type: TYPE_TB
  zh: '| 1969-12-31 23:59:00 | –60 |'
- en: '| 1970-01-01 00:00:00 | 0 |'
  id: totrans-143
  prefs: []
  type: TYPE_TB
  zh: '| 1970-01-01 00:00:00 | 0 |'
- en: '| 1970-01-01 00:02:00 | 120 |'
  id: totrans-144
  prefs: []
  type: TYPE_TB
  zh: '| 1970-01-01 00:02:00 | 120 |'
- en: '| 2009-08-02 00:00:00 | 1249171200 |'
  id: totrans-145
  prefs: []
  type: TYPE_TB
  zh: '| 2009-08-02 00:00:00 | 1249171200 |'
- en: PHP’s built-in time() function returns the current date and time as a Unix timestamp.
    While modern PHP programmers typically use DateTimeImmutable objects, you may
    encounter the time() function in older code or code from non-object-oriented programmers.
    Therefore, it’s useful to be able to work with code that stores these Unix timestamps.
    If you have a DateTimeImmutable object, you can get its equivalent Unix timestamp
    by using the object’s getTimestamp() method. [Listing 31-12](#lis31-12) shows
    a script to create objects and print the corresponding timestamps for each row
    in [Table 31-2](#tab31-2).
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: PHP 的内置 `time()` 函数返回当前的日期和时间，以 Unix 时间戳的形式表示。虽然现代 PHP 程序员通常使用 `DateTimeImmutable`
    对象，但你可能会在旧代码或非面向对象编程的代码中遇到 `time()` 函数。因此，能够处理存储这些 Unix 时间戳的代码是很有用的。如果你有一个 `DateTimeImmutable`
    对象，可以通过使用该对象的 `getTimestamp()` 方法获取其对应的 Unix 时间戳。[清单 31-12](#lis31-12) 显示了一个脚本，用于创建对象并打印
    [表 31-2](#tab31-2) 中每一行的相应时间戳。
- en: '[PRE25]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Listing 31-12: Converting DateTimeImmutable objects to Unix timestamps'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 31-12：将 `DateTimeImmutable` 对象转换为 Unix 时间戳
- en: 'First, we declare a print_timestamp() function that takes in a date-time string,
    creates a DateTimeImmutable object for that string, and prints the equivalent
    timestamp (along with a custom-formatted, human-readable version of the date-time)
    by using the getTimestamp() method. Then we invoke the function four times, once
    for each row from [Table 31-2](#tab31-2). Here’s the result:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们声明一个 `print_timestamp()` 函数，传入一个日期时间字符串，创建一个 `DateTimeImmutable` 对象，并使用
    `getTimestamp()` 方法打印出对应的时间戳（以及格式化过的、易于阅读的人类版日期时间）。然后，我们调用这个函数四次，每次处理 [表 31-2](#tab31-2)
    中的一行。结果如下：
- en: '[PRE26]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'The reverse of getTimestamp() is the setTimeStamp() method, which creates a
    new DateTimeImmutable object corresponding to a given Unix timestamp, as shown
    here:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: '`getTimestamp()` 的逆操作是 `setTimeStamp()` 方法，它会创建一个与给定 Unix 时间戳相对应的新 `DateTimeImmutable`
    对象，如下所示：'
- en: '[PRE27]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Notice the extra set of parentheses around (new DateTimeImmutable()). This
    creates a new default DateTimeImmutable object, which we then use to call the
    setTimeStamp() method, passing the relevant timestamp in the $timestamp variable.
    This in turn creates another new DateTimeImmutable object set to correspond with
    the timestamp, which we store in the $datetime variable. Without the extra parentheses,
    the statement would look as follows, and the PHP engine wouldn’t understand the
    syntax:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意 `(new DateTimeImmutable())` 周围的额外括号。这会创建一个新的默认 `DateTimeImmutable` 对象，我们接着用它来调用
    `setTimeStamp()` 方法，传入 `$timestamp` 变量中的相关时间戳。这样就创建了另一个新的 `DateTimeImmutable`
    对象，并与该时间戳相对应，我们将其存储在 `$datetime` 变量中。如果没有额外的括号，语句将如下所示，PHP 引擎将无法理解该语法：
- en: '[PRE28]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: When working with code that uses Unix timestamps, I recommend refactoring the
    code to use setTimeStamp() to create an equivalent DateTimeImmutable object, then
    do all the logic with that object. You can then use the getTime stamp() method
    to convert the final result back to a timestamp. Or, better still, refactor all
    the code to use DateTimeImmutable objects with no reference whatsoever to timestamps.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理使用 Unix 时间戳的代码时，我建议重构代码，使用 `setTimeStamp()` 方法创建一个等效的 `DateTimeImmutable`
    对象，然后使用该对象处理所有逻辑。之后，你可以使用 `getTimeStamp()` 方法将最终结果转换回时间戳。或者，更好的做法是，将所有代码重构为使用
    `DateTimeImmutable` 对象，并完全不涉及时间戳。
- en: NOTE
  id: totrans-156
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 注意
- en: '*Unix timestamps were originally stored using 32-bit integers, a shortsighted
    scheme. The last timestamp that can be correctly stored in the original 32-bit
    format will be* +2147483647 *(2**^(31)* *– 1), the equivalent of 3:14* *AM* *and
    7 seconds on January 19, 2038\. Ticking forward one more second would result in
    an overflow error and a timestamp of* -2147483648*, or 8:45* *PM* *and 52 seconds
    on December 13, 1901\. Fortunately, most systems have already been upgraded to
    use 64 bits for Unix timestamps, which postpones the overflow error by 292 billion
    years.*'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: '*Unix 时间戳最初是使用 32 位整数存储的，这是一种短视的方案。能够正确存储在原始 32 位格式中的最后一个时间戳是* +2147483647
    *(2**^(31)* *– 1)，即 2038 年 1 月 19 日凌晨 3:14 和 7 秒。再往前推进一秒将会导致溢出错误，时间戳为* -2147483648*，即
    1901 年 12 月 13 日晚上 8:45 和 52 秒。幸运的是，大多数系统已经升级为使用 64 位存储 Unix 时间戳，这使得溢出错误推迟了 2920
    亿年。*'
- en: Date-Time Information in a Web Application
  id: totrans-158
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Web 应用中的日期时间信息
- en: In this section, we’ll build a simple web application to synthesize what we’ve
    covered so far about working with date-time information in PHP. The application
    will provide a form for the user to enter an address and a date, and it will display
    the sunrise and sunset times for that day and location, along with the total duration
    of daylight for that day as determined by the DateInterval class.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将构建一个简单的Web应用程序，总结我们迄今为止在PHP中处理日期时间信息的知识。该应用程序将提供一个表单，供用户输入地址和日期，并显示该日期和地点的日出和日落时间，以及通过DateInterval类确定的该天白昼的总时长。
- en: As it happens, PHP has a built-in date_sun_info() function that reports the
    sunrise and sunset times (along with other information) for a given date and location.
    The function requires the location to be specified as latitude and longitude coordinates
    rather than a street address, however. Our application will therefore also demonstrate
    how to obtain data from an external API, as we’ll rely on OpenStreetMap to convert
    the address to coordinates. We’ll use a popular open source PHP library called
    Guzzle to communicate with OpenStreetMap. Guzzle provides an HTTP client, allowing
    code to send and receive HTTP requests. This makes it straightforward to integrate
    PHP web applications with external web services.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，PHP有一个内置的date_sun_info()函数，用于报告给定日期和位置的日出和日落时间（以及其他信息）。然而，该函数需要将位置指定为纬度和经度坐标，而不是街道地址。因此，我们的应用程序还将演示如何从外部API获取数据，因为我们将依赖OpenStreetMap将地址转换为坐标。我们将使用一个流行的开源PHP库Guzzle与OpenStreetMap进行通信。Guzzle提供了一个HTTP客户端，允许代码发送和接收HTTP请求。这使得将PHP
    Web应用程序与外部Web服务集成变得非常简单。
- en: '[Figure 31-1](#fig31-1) features screenshots of the pages we’ll create.'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: '[图31-1](#fig31-1)展示了我们将要创建的页面的截图。'
- en: '![](../images/figure31-1.jpg)'
  id: totrans-162
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/figure31-1.jpg)'
- en: 'Figure 31-1: Screenshots of the sunrise-sunset web application'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 图31-1：日出日落Web应用程序的截图
- en: The home page allows the user to submit a street address and a date. This leads
    to a results page showing the calculated information. The results page will also
    have a link to view the specified location in OpenStreetMap.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 主页允许用户提交一个街道地址和日期。这样就会跳转到一个结果页面，显示计算出来的信息。结果页面还会有一个链接，用于在OpenStreetMap中查看指定位置。
- en: To get started, create a new project with the usual *composer.json* file and
    *public/index.php* script that creates an Application object and calls its run()
    method. Then enter composer require guzzlehttp/guzzle at the command line to add
    the third-party Guzzle library to the project. Since we’re running Composer and
    have created the *composer.json* file for our namespace, Composer will also create
    our namespaced class autoloader at this time.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始，请创建一个新的项目，并包括常规的*composer.json*文件和*public/index.php*脚本，该脚本会创建一个Application对象并调用其run()方法。然后在命令行中输入`composer
    require guzzlehttp/guzzle`，将第三方Guzzle库添加到项目中。由于我们正在运行Composer，并且已经为我们的命名空间创建了*composer.json*文件，Composer此时还会为我们的命名空间类生成自动加载器。
- en: The Application Class
  id: totrans-166
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: Application类
- en: Now we’ll declare the Application class for our site in *src/Application.php*.
    The class will handle requests by either displaying the home page or processing
    data from the application’s web form. [Listing 31-13](#lis31-13) shows the code.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将在*src/Application.php*中声明我们网站的Application类。该类将处理请求，通过显示主页或处理来自应用程序网页表单的数据来响应请求。[列表31-13](#lis31-13)显示了相关代码。
- en: '[PRE29]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Listing 31-13: The Application class declaring two routes'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 列表31-13：声明两个路由的Application类
- en: As usual, the class’s run() method uses a switch statement to handle incoming
    requests. First, we declare the case for when $action is 'processForm' ❶. For
    this case, we attempt to extract the address and date variables from the POST
    data in the request. If either is empty ❷, we invoke the homepage() method, passing
    in an error message. Otherwise, we pass along the address and date to the processForm()
    method.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 和往常一样，类的run()方法使用一个switch语句来处理传入的请求。首先，我们声明当$action为'processForm'时的情况❶。对于这种情况，我们尝试从请求的POST数据中提取地址和日期变量。如果其中任何一个为空❷，我们调用homepage()方法，并传入错误信息。否则，我们将地址和日期传递给processForm()方法。
- en: The only other case in the switch statement is the default route ❸, which simply
    invokes the homepage() method without any arguments. The homepage() method itself
    ❹ uses require_once to display the *homepage.php* template (we’re using regular
    PHP files for templating rather than Twig for simplicity). The method has an $errorMessage
    parameter with a default value of an empty string. This variable will be in the
    scope of the template for printing.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: switch 语句中的唯一其他情况是默认路由 ❸，它仅调用 homepage() 方法且不传入任何参数。homepage() 方法本身 ❹ 使用 require_once
    显示 *homepage.php* 模板（我们为了简单起见使用普通的 PHP 文件作为模板，而不是 Twig）。该方法有一个名为 $errorMessage
    的参数，默认值为空字符串。这个变量将在模板的作用域内打印出来。
- en: The meat of this class is the processForm() method, which takes in the submitted
    address and date as strings and uses them to obtain sunrise and sunset times,
    along with a total duration of daylight. We first need to convert the address
    into latitude and longitude coordinates. For that, we create a new StreetMap object
    (we’ll look at this class shortly) and invoke its getOpenStreetMapData() method
    ❺, passing in the $address string. The result, in the $latLongArray variable,
    is an array with 'latitude' and 'longitude' keys holding the necessary coordinates,
    which we extract into separate variables.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 该类的核心是 processForm() 方法，它接受提交的地址和日期字符串，并利用它们获取日出和日落时间，以及白昼的总时长。我们首先需要将地址转换为纬度和经度坐标。为此，我们创建一个新的
    StreetMap 对象（稍后我们会查看这个类），并调用它的 getOpenStreetMapData() 方法 ❺，传入 $address 字符串。返回的结果存储在
    $latLongArray 变量中，它是一个包含 'latitude' 和 'longitude' 键的数组，保存了必要的坐标，我们将其提取到单独的变量中。
- en: Next, we use the date string submitted through the web form to create a corresponding
    DateTimeImmutable object called $date. We then create a new SunData object (another
    class we’ll look at shortly), passing $date, $latitude, and $longitude as arguments
    ❻. The SunData object uses the provided information to calculate the sunrise and
    sunset times and the daylight duration. We extract this data into individual variables
    via the appropriate getter methods, which are chained with calls to format() to
    convert the date-time information into strings. The $sunrise and $sunset variables
    are given in the form 8.35am. The $hoursDaylight variable is a DateInterval object
    presented in the form 16 hours 39 minutes, using %h for the hours and %i for minutes
    ❼. With all these variables in scope, we display the *result.php* template ❽.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们使用通过网页表单提交的日期字符串，创建一个相应的 DateTimeImmutable 对象，命名为 $date。接着我们创建一个新的 SunData
    对象（另一个我们稍后会查看的类），将 $date、$latitude 和 $longitude 作为参数 ❻ 传入。SunData 对象使用提供的信息来计算日出和日落时间以及白昼时长。我们通过相应的
    getter 方法提取这些数据，并通过链式调用 format() 方法将日期时间信息转换为字符串。$sunrise 和 $sunset 变量的格式为 8.35am。$hoursDaylight
    变量是一个 DateInterval 对象，格式为 16 小时 39 分钟，使用 %h 表示小时，%i 表示分钟 ❼。在这些变量都有了作用域后，我们显示 *result.php*
    模板 ❽。
- en: All this activity in the processForm() method is embedded inside a try block.
    If something goes wrong, such as a failure to connect to OpenStreetMap, the catch
    statement at the end of the method ❾ displays an error message along with a link
    back to the home page.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 所有在 processForm() 方法中的活动都嵌套在一个 try 块中。如果出现问题，例如无法连接到 OpenStreetMap，方法末尾的 catch
    语句 ❾ 会显示错误信息，并提供一个返回主页的链接。
- en: The Supporting Classes
  id: totrans-175
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 辅助类
- en: We’ll next declare the supporting classes for the application, starting with
    StreetMap, which manages working with the OpenStreetMap web server. Create *src/StreetMap.php*
    as shown in [Listing 31-14](#lis31-14).
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们声明应用程序的辅助类，从 StreetMap 开始，它负责与 OpenStreetMap 网络服务器的交互。创建 *src/StreetMap.php*
    文件，如 [Listing 31-14](#lis31-14) 所示。
- en: '[PRE30]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Listing 31-14: The StreetMap class for accessing the OpenStreetMap server'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: Listing 31-14：用于访问 OpenStreetMap 服务器的 StreetMap 类
- en: First, the use statement allows us to draw on the Guzzle library’s Client class,
    which is in the GuzzleHttp namespace. This class will manage the details of making
    an HTTP request to an external site. We then declare the client instance variable
    and initialize it as a Client object in the constructor. We provide various Guzzle
    Client parameters, such as the time-out (the amount of time to wait for a response)
    and the sending agent name ('matt smith demo' is fine for this project). We take
    care to configure the Client to accept JSON data ❶, since that’s the format returned
    by the OpenStreetMap API.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，使用语句允许我们调用位于GuzzleHttp命名空间中的Guzzle库的Client类。该类将负责处理向外部站点发起HTTP请求的细节。然后，我们声明客户端实例变量，并在构造函数中将其初始化为Client对象。我们提供了各种Guzzle
    Client参数，如超时设置（等待响应的时间）和发送代理名称（对于这个项目，“matt smith demo”就可以）。我们特别配置Client以接受JSON数据❶，因为OpenStreetMap
    API返回的数据格式就是JSON。
- en: Next, we declare the getOpenStreetMapData() method. It takes in an address (I’ve
    provided a default value for testing purposes) and uses it to build an appropriate
    query string via the buildQueryString() method. Then it uses the request() method
    of the Client object to send the request to the OpenStreetMap API and store the
    received response ❷. If the response code is valid (200), the received data is
    decoded into a $jsonData array ❸. If either the response code isn’t 200 or an
    empty array is received, we throw an exception to signal to the calling code that
    there has been a problem getting data from the OpenStreetMap API ❹. If the code
    gets through the if...else statement without throwing an exception, the latitude
    and longitude are extracted from the received $jsonData and returned as an array
    ❺.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们声明getOpenStreetMapData()方法。它接收一个地址（为了测试，我提供了一个默认值），并通过buildQueryString()方法将其转化为适当的查询字符串。然后，它使用Client对象的request()方法向OpenStreetMap
    API发送请求，并存储收到的响应❷。如果响应代码有效（200），则将接收到的数据解码为$jsonData数组❸。如果响应代码不是200或收到的是空数组，我们会抛出一个异常，提示调用代码从OpenStreetMap
    API获取数据时出现了问题❹。如果代码通过if...else语句没有抛出异常，则从接收到的$jsonData中提取出纬度和经度，并以数组形式返回❺。
- en: Finally, we declare the buildQueryString() method. It uses PHP’s built-in http_build_query()
    function to encode the address and other details into an appropriate query string
    for the Nominatim OpenStreetMap API ❻. We provide the query information to http_build_query()
    as key/value pairs in an array, then attach the encoded query string, in variable
    $query, to the end of a $url.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们声明了buildQueryString()方法。该方法使用PHP内置的http_build_query()函数，将地址和其他细节编码成适用于Nominatim
    OpenStreetMap API❻的查询字符串。我们将查询信息作为键/值对的数组提供给http_build_query()，然后将编码后的查询字符串（保存在变量$query中）附加到$url的末尾。
- en: NOTE
  id: totrans-182
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 注意
- en: '*For more about the requirements of the Nominatim OpenStreetMap API, see* [https://nominatim.org](https://nominatim.org)*.*
    Nominatim *(Latin for “by name”) is an open source software project that offers
    searching of OpenStreetMap data. It facilitates both* geocoding *(location from
    a given name and address) and* reverse geocoding *(address from a given location).*'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: '*关于Nominatim OpenStreetMap API的更多要求，见* [https://nominatim.org](https://nominatim.org)*。Nominatim*（拉丁语意思为“按名称”）是一个开源软件项目，提供OpenStreetMap数据的搜索功能。它支持*地理编码*（根据给定的名称和地址获取位置）和*反向地理编码*（根据给定的位置获取地址）。'
- en: Now we’ll look at the SunData class, which is designed to simplify the process
    of working with PHP’s built-in date_sun_info() function. Declare the class in
    *src/SunData.php* as in [Listing 31-15](#lis31-15).
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将看看SunData类，它旨在简化与PHP内置的date_sun_info()函数一起使用的过程。在[src/SunData.php]中声明该类，如[列表31-15](#lis31-15)所示。
- en: '[PRE31]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Listing 31-15: The SunData class for working with the date_sun_info() function'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 列表31-15：用于处理date_sun_info()函数的SunData类
- en: 'We give the SunData class three instance variables: sunrise and sunset are
    DateTimeImmutable objects for the sunrise and sunset times, and hoursDaylight
    is a DateInterval object for the duration of daylight. The SunData constructor
    takes in three arguments: the date (a DateTimeImmutable object) and the latitude
    and longitude of the location of interest. These are the pieces of information
    the date_sun_info() function needs, although the date must be in the form of a
    Unix timestamp, so the constructor starts by calling getTime stamp() to make the
    conversion ❶.'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 我们为 SunData 类提供了三个实例变量：sunrise 和 sunset 是用于日出和日落时间的 DateTimeImmutable 对象，hoursDaylight
    是一个 DateInterval 对象，表示白昼持续时间。SunData 的构造函数接受三个参数：日期（一个 DateTimeImmutable 对象）以及感兴趣位置的纬度和经度。这些是
    date_sun_info() 函数所需要的信息，尽管日期必须是 Unix 时间戳格式，因此构造函数开始时调用 getTimeStamp() 方法来进行转换
    ❶。
- en: Then we call date_sun_info(), storing the result, an array of information, in
    the $data variable ❷. We extract the sunrise and sunset times from the $data array,
    storing them in the appropriate instance variables. Because date_sun_info() returns
    date-time information as Unix timestamps, we use the dateFromTimestamp() helper
    method to convert back from timestamps to DateTimeImmutable objects. (In this
    method, notice once again that we have to add extra parentheses around the creation
    of the new DateTimeImmutable object before we can call its setTimeStamp() method
    ❹.)
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们调用 date_sun_info()，并将结果存储在 $data 变量中，这个结果是一个信息数组 ❷。我们从 $data 数组中提取日出和日落时间，并将它们存储到相应的实例变量中。由于
    date_sun_info() 返回的是 Unix 时间戳形式的日期时间信息，我们使用 dateFromTimestamp() 辅助方法将时间戳转换回 DateTimeImmutable
    对象。（在这个方法中，请注意，我们必须在创建新的 DateTimeImmutable 对象时，额外加上括号，才能调用它的 setTimeStamp() 方法
    ❹。）
- en: For the duration of daylight, we simply take the difference between the sunset
    and sunrise times ❸. The remainder of the SunData class consists of simple getter
    methods to return the three instance variables.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 对于白昼时长，我们只需计算日落和日出时间的差值 ❸。SunData 类的其余部分由简单的 getter 方法组成，用于返回三个实例变量。
- en: The Templates
  id: totrans-190
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 模板
- en: We’re now ready to create the templates for the home page (with the web form)
    and the results page. We’ll start with the Home page template in *templates/homepage.php*.
    [Listing 31-16](#lis31-16) shows the code.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在准备好创建首页（包含网页表单）和结果页的模板。我们将从 *templates/homepage.php* 中的首页模板开始。代码见 [列表 31-16](#lis31-16)。
- en: '[PRE32]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Listing 31-16: The form to input an address and date from the user'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 31-16：从用户输入地址和日期的表单
- en: In the body of the page, we first use the alternative if statement syntax to
    display a pink-styled paragraph containing an error message string, provided the
    $errorMessage variable isn’t empty ❶. Then we create a form with an action of
    processForm and fields for the address and date. For the latter, we use an <input>
    element of type date ❷, which most web browsers display as a user-friendly calendar
    date-picker widget, as shown earlier in [Figure 31-1](#fig31-1).
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 在页面主体中，我们首先使用替代的 if 语句语法显示一个粉色样式的段落，包含错误信息字符串，前提是 $errorMessage 变量不为空 ❶。然后我们创建一个
    action 为 processForm 的表单，表单中包含地址和日期字段。对于日期字段，我们使用一个 type 为 date 的 <input> 元素 ❷，大多数网页浏览器将其显示为一个用户友好的日历日期选择器控件，如
    [图31-1](#fig31-1) 所示。
- en: The second template is for displaying the results to the user. Create *templates/result.php*
    with the code in [Listing 31-17](#lis31-17).
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个模板用于向用户显示结果。创建 *templates/result.php*，并使用 [列表 31-17](#lis31-17) 中的代码。
- en: '[PRE33]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Listing 31-17: The template to present sun data results to the user'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 31-17：向用户呈现太阳数据结果的模板
- en: In this template, we first offer the user a link back the home page ❶. Then
    we display the provided date and the latitude and longitude corresponding to the
    provided address.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个模板中，我们首先提供一个链接，让用户返回首页 ❶。然后我们显示提供的日期以及与提供的地址对应的纬度和经度。
- en: Next, we offer a link to view the location in OpenStreetMap, with the values
    of the $latitude and $longitude variables inserted into the link for the mlat
    and mlon query fields ❷. We then output the sunrise, sunset, and hours of daylight
    values, along with appropriate images next to the sunrise and sunset times (*sunrise.png*
    and *sunset.png*, from user Mehwish at *[https://www.flaticon.com](https://www.flaticon.com)*).
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们提供一个链接以在 OpenStreetMap 中查看位置，将 $latitude 和 $longitude 变量的值插入到链接中，用于 mlat
    和 mlon 查询字段 ❷。然后，我们输出日出、日落和白昼时长的数值，并在日出和日落时间旁边显示相应的图像（*sunrise.png* 和 *sunset.png*，由用户
    Mehwish 提供，图像来源于 *[https://www.flaticon.com](https://www.flaticon.com)*）。
- en: Links to these images, with acknowledgment to the publisher, are provided in
    the page’s footer element ❸. Download these images and copy them into the *public/images*
    directory to complete the creation of the web application. Then try running the
    web server and testing out the application with different dates and addresses.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 这些图片的链接及其出版者的致谢已在页面底部的元素❸中提供。下载这些图片并将它们复制到*public/images*目录中，以完成Web应用程序的创建。然后尝试运行Web服务器，并使用不同的日期和地址测试应用程序。
- en: This project has brought together lots of the concepts from this chapter, demonstrating
    a practical use for the DateInterval class and showing how to juggle between DateTimeImmutable
    objects and Unix timestamps. It also illustrates the power of open source libraries,
    in this case showing how Guzzle makes it easy to send requests to external APIs
    and process the returned JSON data.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 这个项目汇集了本章的许多概念，展示了DateInterval类的实际应用，并展示了如何在DateTimeImmutable对象和Unix时间戳之间进行转换。它还说明了开源库的强大功能，本文展示了Guzzle如何使发送请求到外部API并处理返回的JSON数据变得轻松。
- en: MySQL Dates
  id: totrans-202
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: MySQL 日期
- en: When working in PHP, using native PHP date and time objects and functions makes
    sense. When storing temporal data in a database, however, it’s best to use the
    database system’s native format. This way, database queries can be performed on
    the fields, and applications written in other programming languages can also work
    with the stored database data. It’s therefore important to understand the database
    formats for date-time information and learn how to convert between PHP and the
    relevant database formats when reading and writing to the database system. In
    this section, we’ll look at how MySQL handles date-time information, but the principles
    are the same for any DBMS.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 在PHP中工作时，使用原生的PHP日期和时间对象及函数是很有意义的。然而，在数据库中存储时间数据时，最好使用数据库系统的原生格式。这样，数据库查询可以直接在这些字段上执行，而且用其他编程语言编写的应用程序也可以处理存储在数据库中的数据。因此，了解数据库的日期时间格式并学习如何在读写数据库时在PHP和相关数据库格式之间进行转换非常重要。在本节中，我们将探讨MySQL如何处理日期时间信息，但这些原则适用于任何数据库管理系统（DBMS）。
- en: MySQL can store dates, date-times, and timestamps, but we’ll focus on date-times
    here. The basic individual date and time formats for MySQL are the same as ISO
    8601, with dates in the form YYYY-MM-DD and times in the form HH:MM:SS. However,
    MySQL uses a space rather than the letter T as the separator between the date
    and time components, so 1968-11-22T09:05:30 in ISO 8601 format would appear as
    1968-11-22 09:05:30 when stored in MySQL. Like PHP, MySQL can add decimal places
    to the time component to store fractions of seconds, down to microseconds (six
    decimal places).
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: MySQL可以存储日期、日期时间和时间戳，但我们这里重点讨论日期时间。MySQL的基本日期和时间格式与ISO 8601相同，日期格式为YYYY-MM-DD，时间格式为HH:MM:SS。不过，MySQL在日期和时间之间使用空格而不是字母T作为分隔符，因此ISO
    8601格式中的1968-11-22T09:05:30会在MySQL中存储为1968-11-22 09:05:30。像PHP一样，MySQL可以为时间组件添加小数位，以存储秒的小数部分，精确到微秒（六位小数）。
- en: To specify that you want a column in a MySQL table to store date-times, declare
    the column with the DATETIME data type. Modern MySQL systems default to zero decimal
    places for the time component (whole seconds). To include fractions of a second,
    add the desired number of decimal places in parentheses after the data type. For
    example, to store date-times down to the microsecond, you’d declare a column of
    type DATETIME(6).
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 要指定你希望MySQL表中的某个列存储日期时间，请使用DATETIME数据类型声明该列。现代MySQL系统默认为时间组件的零小数位（即整秒）。要包含秒的小数部分，可以在数据类型后面加上括号并指定所需的小数位数。例如，要存储精确到微秒的日期时间，可以声明DATETIME(6)类型的列。
- en: MySQL stores date-time data as UTC values. Therefore, if the MySQL server is
    set to a time zone that isn’t UTC, it will convert any date-times to UTC for storage
    and then convert them back from UTC upon retrieval. In practice, it’s common to
    create UTC DateTimeImmutable objects for storage in the database, and to have
    the web application logic convert retrieved date-times to any other desired time
    zone.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: MySQL将日期时间数据存储为UTC值。因此，如果MySQL服务器设置为非UTC的时区，它将把任何日期时间转换为UTC进行存储，然后在检索时再从UTC转换回来。实际上，常见做法是创建UTC
    DateTimeImmutable对象以存储到数据库中，之后由Web应用程序逻辑将检索到的日期时间转换为其他所需的时区。
- en: NOTE
  id: totrans-207
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 注意
- en: '*If you’re using the* TIMESTAMP *data type in MySQL, be aware that MySQL will
    automatically convert it to UTC, using the time-zone settings of your MySQL server.*'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: '*如果你使用的是* TIMESTAMP *数据类型，需注意MySQL会根据你的MySQL服务器的时区设置自动将其转换为UTC。*'
- en: To create a MySQL datetime string for insertion into a table from a PHP script,
    start with a DateTimeImmutable object and use its format() method, with the format
    string 'Y-m-d H:i:s' for whole seconds or 'Y-m-d H:i:s.u' for fractional seconds.
    Notice in particular the space between the d and the H. Likewise, having retrieved
    a date-time string from MySQL, you can use the createFromFormat() static method
    of the DateTimeImmutable class to get an equivalent DateTimeImmutable object for
    that MySQL data.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 为了从 PHP 脚本中将 MySQL datetime 字符串插入到表中，首先使用 DateTimeImmutable 对象，并使用它的 format()
    方法，格式字符串为 'Y-m-d H:i:s'（表示整秒）或 'Y-m-d H:i:s.u'（表示带小数秒）。特别注意 d 和 H 之间的空格。同样，当从
    MySQL 获取日期时间字符串时，可以使用 DateTimeImmutable 类的 createFromFormat() 静态方法来获取该 MySQL 数据的等效
    DateTimeImmutable 对象。
- en: To demonstrate how to go back and forth between DateTimeImmutable objects and
    MySQL DATETIME fields, let’s create a project with an Appointment entity class
    and a corresponding appointment database table to hold the names and date-times
    of appointments. Start a new project with the usual *composer.json* file, and
    enter composer dump-autoload at the command line to generate the autoloader. Then
    create a new MySQL database schema called date1, and create an appointment table
    in that schema by using the SQL statement in [Listing 31-18](#lis31-18). (See
    “Setting Up the Database Schema” on [page 543](chapter28.xhtml#pg_543) to review
    how to integrate this SQL statement into a PHP script.)
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 为了演示如何在 DateTimeImmutable 对象和 MySQL DATETIME 字段之间来回转换，我们将创建一个包含 Appointment
    实体类的项目，并创建一个相应的预约数据库表来存储预约的名称和日期时间。首先创建一个包含常规 *composer.json* 文件的新项目，并在命令行输入 composer
    dump-autoload 来生成自动加载器。接着，创建一个名为 date1 的新的 MySQL 数据库架构，并使用 [Listing 31-18](#lis31-18)
    中的 SQL 语句在该架构中创建一个预约表。（参见 [第 543 页](chapter28.xhtml#pg_543) 的“设置数据库架构”部分，回顾如何将此
    SQL 语句集成到 PHP 脚本中。）
- en: '[PRE34]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Listing 31-18: The SQL to create the appointment MySQL database table'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: Listing 31-18：创建预约 MySQL 数据库表的 SQL 语句
- en: The table has an auto-incrementing id field for the primary key, a title field
    for a description of the appointment, and a startdatetime field for when it begins.
    We declare the startdatetime field to be of type datetime(6) to illustrate working
    with fractions of a second, but note that MySQL’s default of zero decimal places
    would be sufficient for the majority of real-world meeting or appointment applications.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 表中有一个自增的 id 字段作为主键，一个 title 字段用于描述预约，以及一个 startdatetime 字段表示预约开始的时间。我们将 startdatetime
    字段声明为 datetime(6) 类型，以说明如何处理秒的小数部分，但请注意，MySQL 默认的零小数位对于大多数实际的会议或预约应用程序来说已足够。
- en: Now we’ll declare the Appointment class corresponding to this table. Enter the
    contents of [Listing 31-19](#lis31-19) into *src/Appointment.php*.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将声明与此表对应的 Appointment 类。将 [Listing 31-19](#lis31-19) 的内容输入到 *src/Appointment.php*
    文件中。
- en: '[PRE35]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Listing 31-19: The Appointment entity class, containing a DateTimeImmutable
    property'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: Listing 31-19：Appointment 实体类，包含一个 DateTimeImmutable 属性
- en: The Appointment class has id, title, and startDateTime properties to match the
    columns in the appointment table. Notice that the startDateTime property is a
    DateTimeImmutable object ❶. We give each property appropriate getter and setter
    methods. This includes a special setter method for the startDateTime property
    that uses the union type DateTimeImmutable|string to allow either a DateTimeImmutable
    object or a string to be provided as an argument ❷.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: Appointment 类具有 id、title 和 startDateTime 属性，以匹配预约表中的列。请注意，startDateTime 属性是一个
    DateTimeImmutable 对象 ❶。我们为每个属性提供了适当的 getter 和 setter 方法。这包括一个特殊的 setter 方法，它使用联合类型
    DateTimeImmutable|string，允许提供 DateTimeImmutable 对象或字符串作为参数 ❷。
- en: If the received argument is a string, we convert it to a DateTimeImmutable object
    by using the public constant MYSQL_DATE_FORMAT_STRING to help with the formatting.
    (We’ll declare this constant later in the AppointmentRepository class.) This mechanism
    allows the same setter method to work with PHP DateTimeImmutable objects as well
    as the MySQL date-time strings received from the database. The extra logic could
    be avoided by using an ORM library such as Doctrine, which would seamlessly convert
    between PHP data types and their database equivalents.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 如果接收到的参数是字符串，我们将使用公共常量 MYSQL_DATE_FORMAT_STRING 来帮助格式化，并将其转换为 DateTimeImmutable
    对象。（我们将在稍后的 AppointmentRepository 类中声明此常量。）此机制允许同一个 setter 方法既能处理 PHP 的 DateTimeImmutable
    对象，也能处理从数据库接收到的 MySQL 日期时间字符串。如果使用像 Doctrine 这样的 ORM 库，就可以避免额外的逻辑，它能无缝地在 PHP 数据类型和其数据库等效物之间进行转换。
- en: We’ll next create an AppointmentRepository class with methods to insert a new
    appointment into the appointments table and fetch all the appointments. For simplicity,
    we’ll combine the database connection and repository methods into this one class,
    but see [Chapter 28](chapter28.xhtml) for examples of managing the database connection
    in a separate Database class. Create *src/AppointmentRepository.php* containing
    the code in [Listing 31-20](#lis31-20).
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将创建一个AppointmentRepository类，该类包含将新预约插入到appointments表中的方法，并获取所有预约。为了简化，我们将数据库连接和仓库方法结合在这个类中，但请参阅[第28章](chapter28.xhtml)以了解如何在单独的数据库类中管理数据库连接的示例。创建*src/AppointmentRepository.php*，并包含[列表31-20](#lis31-20)中的代码。
- en: '[PRE36]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Listing 31-20: The AppointmentRepository class for MySQL database interaction'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 列表31-20：用于MySQL数据库交互的AppointmentRepository类
- en: We declare a public MYSQL_DATE_FORMAT_STRING constant holding the string with
    the necessary formatting for compatibility between MySQL datetimes and PHP DateTimeImmutable
    objects ❶. We then declare more constants for the database credentials (be sure
    to fill in your own values for these), along with a private connection property
    to hold the PDO database connection object. In the constructor, we create the
    database connection and store it in the connection property ❷, using a try...catch
    structure to handle any problems.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 我们声明一个公共的MYSQL_DATE_FORMAT_STRING常量，它包含了必要的格式化字符串，用于确保MySQL日期时间与PHP的DateTimeImmutable对象之间的兼容性❶。接着，我们声明更多常量来保存数据库凭证（请务必填写您自己的值），并定义一个私有的连接属性来保存PDO数据库连接对象。在构造函数中，我们创建数据库连接并将其存储在连接属性中❷，同时使用try...catch结构来处理可能出现的问题。
- en: We next declare the insert() method, which takes in an Appointment object and
    extracts its title and startDateTime properties into individual variables. To
    create the MySQL date string $dateString, we pass the MYSQL _DATE_FORMAT_STRING
    constant to the DateTimeImmutable object’s format() method to get the proper string
    formatting ❸. We then prepare a SQL INSERT statement, populate it with values,
    and execute the statement to add a new row into the appointment table.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们声明insert()方法，它接收一个Appointment对象并将其title和startDateTime属性提取到单独的变量中。为了创建MySQL日期字符串$dateString，我们将MYSQL_DATE_FORMAT_STRING常量传递给DateTimeImmutable对象的format()方法，以获取正确的字符串格式❸。接着，我们准备一个SQL
    INSERT语句，将其填充为适当的值，并执行该语句以向预约表中添加一行数据。
- en: In the findAll() method, we use PDO’s fetchAll() method to retrieve all the
    entries from the appointment table as an associative array of keys and values
    ❹. The method then loops through this array, creating an Appointment object from
    each element and adding it to the $appointments array, which is then returned.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 在findAll()方法中，我们使用PDO的fetchAll()方法从预约表中检索所有条目，返回一个包含键值对的关联数组❹。然后，方法会遍历这个数组，从每个元素创建一个Appointment对象，并将其添加到$appointments数组中，最后返回该数组。
- en: Finally, we’ll create an index script that we can run at the command line to
    create a few sample Appointment objects, add their data to the database, and then
    retrieve the entries back out of the database as an array of Appointment objects.
    Create *public/index.php* as in [Listing 31-21](#lis31-21).
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将创建一个可以在命令行运行的索引脚本，用于创建几个示例的Appointment对象，将它们的数据添加到数据库中，然后从数据库中检索这些条目并返回为Appointment对象的数组。创建*public/index.php*，如[列表31-21](#lis31-21)所示。
- en: '[PRE37]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Listing 31-21: The index script /public/index.php testing our MySQL date example'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 列表31-21：在/public/index.php中测试我们的MySQL日期示例的索引脚本
- en: We require the autoloader and declare use statements for the Mattsmithdev namespaced
    AppointmentRepository and Appointment classes. Then we create an AppointmentRepository
    object called $appointmentRepository, along with two sample Appointment objects,
    which we insert into the database by using the $appointmentRepository object’s
    insert() method. Each object is given a time with a fractional second component
    and is specified using ISO 8601 formatting, including the T separator between
    the date and the time. This formatting doesn’t matter, however, since we’ve written
    the AppointmentRepository class with logic to convert to MySQL date-time formatting.
    We finish the script by calling the findAll() method of the repository object
    to retrieve all database rows as an array of Appointment objects, which we loop
    through and pass to var_dump().
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要加载自动加载器并声明 Mattsmithdev 命名空间中的 AppointmentRepository 和 Appointment 类。接着，我们创建一个名为
    $appointmentRepository 的 AppointmentRepository 对象，并创建两个示例 Appointment 对象，通过 $appointmentRepository
    对象的 insert() 方法将其插入数据库。每个对象都被赋予带有小数秒部分的时间，并使用 ISO 8601 格式指定，包括日期和时间之间的 T 分隔符。然而，这种格式并不重要，因为我们已经编写了
    AppointmentRepository 类，其中包含将其转换为 MySQL 日期时间格式的逻辑。最后，我们通过调用 repository 对象的 findAll()
    方法来检索所有数据库行作为 Appointment 对象的数组，然后遍历这些对象并将其传递给 var_dump()。
- en: 'Here’s the output when the index script is executed:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是当索引脚本执行时的输出：
- en: '[PRE38]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Two appointments have been retrieved from the database and output to the console.
    The first is the 'get an ice cream sandwich' appointment, with a start date-time
    of 2009-08-02 11:00:00.500000. The second is the 'celebrate birthday' appointment,
    with a start date-time of 2025-11-22 09:05:30.770000. The date components for
    both have been stored to six decimal places for fractions of a second. Notice
    that the time zones are Europe/Dublin, the setting for my PHP setup that is applied
    by default when new DateTimeImmutable objects are created. If the web application
    was working with dates from different time zones, one solution would be to store
    the time zone along with the UTC version of each date-time in the database, then
    convert the retrieved date-times back to that time zone upon retrieval.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 从数据库中检索并输出到控制台的有两个约会。第一个是“去吃冰淇淋三明治”约会，开始时间为 2009-08-02 11:00:00.500000。第二个是“庆祝生日”约会，开始时间为
    2025-11-22 09:05:30.770000。两个日期组件都存储到了小数点后六位，精确到秒的分数部分。注意，时区为 Europe/Dublin，这是我
    PHP 设置的时区，在创建新的 DateTimeImmutable 对象时默认应用。如果 Web 应用程序需要处理来自不同时区的日期，解决方案之一是将时区与每个日期时间的
    UTC 版本一起存储在数据库中，然后在检索时将获取到的日期时间转换回该时区。
- en: Summary
  id: totrans-232
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 总结
- en: Manipulating dates and times is often a necessary part of developing applications,
    since date-time information provides useful functionality to users (such as maintaining
    a calendar) and is valuable for recording data about when actions and requests
    have occurred. In this chapter, we explored the most useful PHP classes and functions
    relating to dates and times, including the DateTimeImmutable and DateInterval
    classes.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 操作日期和时间通常是开发应用程序中必不可少的一部分，因为日期和时间信息为用户提供了有用的功能（例如，维护日历）并且在记录动作和请求发生的时间方面非常重要。在本章中，我们探讨了与日期和时间相关的最有用的
    PHP 类和函数，包括 DateTimeImmutable 和 DateInterval 类。
- en: We put these language features to work in a web application that reported sunrise
    and sunset information, which relied on the Guzzle library to make HTTP requests
    to an external site. We also looked at how to move date-time information back
    and forth between PHP scripts and MySQL database tables, converting formats as
    appropriate.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在一个 Web 应用程序中使用这些语言特性，该应用程序报告日出和日落信息，并依赖 Guzzle 库来发起 HTTP 请求访问外部站点。我们还探讨了如何在
    PHP 脚本和 MySQL 数据库表之间来回移动日期时间信息，并根据需要转换格式。
- en: Exercises
  id: totrans-235
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 练习
- en: '1.   Write a script to create (and var_dump) DateTimeImmutable objects in UTC
    (Zulu time), Irish Standard Time, and Eastern Standard Time for the following:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 1.   编写一个脚本来创建（并使用 var_dump）UTC（Zulu 时间）、爱尔兰标准时间和东部标准时间的 DateTimeImmutable 对象，时间为：
- en: '2025-01-01 10:00:00'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: '2025-01-01 10:00:00'
- en: '2025-01-02 12:00:00.05'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: '2025-01-02 12:00:00.05'
- en: '2.   Write a script to create (and var_dump) DateInterval objects between 2000-01-01
    22:00:00 and the following:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 2.   编写一个脚本来创建（并使用 var_dump）2000-01-01 22:00:00 和以下时间之间的 DateInterval 对象：
- en: '2000-01-02 22:00:00'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: '2000-01-02 22:00:00'
- en: '2010-05-06 00:00:00'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: '2010-05-06 00:00:00'
- en: '2010-05-06 00:00:30'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: '2010-05-06 00:00:30'
- en: '2020-01-01 22:00:00'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: '2020-01-01 22:00:00'
- en: '3.   Develop a project to create, store, and retrieve patient meetings with
    doctors. The project should use a MySQL database for storing the records. Base
    your project around a Consultation entity class containing the following properties:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 3.   开发一个项目，用于创建、存储和检索患者与医生的会面记录。该项目应使用MySQL数据库存储记录。将项目围绕一个名为Consultation的实体类进行设计，包含以下属性：
- en: Patient name (string)
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 患者姓名（字符串）
- en: Doctor name (string)
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 医生姓名（字符串）
- en: Consultation date and time (DateTimeImmutable)
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 会诊日期和时间（DateTimeImmutable）
- en: Duration in minutes (integer)
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 持续时间（分钟）（整数）
- en: 'Here’s a SQL statement to create a database table for such records:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是创建此类记录的数据库表的SQL语句：
- en: '[PRE39]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 4.   Create a new project to find the hours of daylight in New York and Dublin
    on the last day of the previous millennium, December 31, 1999.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 4.   创建一个新项目，用于查找1999年12月31日，即上一千年的最后一天，纽约和都柏林的日照时间。
