- en: Chapter 8. Managing Data in the Browser
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: So far in the book, we’ve looked at a lot of visual ization tools and techniques,
    but we haven’t spent much time considering the data part of data visualization.
    The emphasis on visualization is appropriate in many cases. Especially if the
    data is static, we can take all the time we need to clean and organize it before
    it’s even represented in JavaScript. But what if the data is dynamic and we have
    no choice but to import the raw source directly into our JavaScript application?
    We have much less control over data from third-party REST APIs, Google Docs spreadsheets,
    or automatically generated CSV files. With those types of data sources, we often
    need to validate, reformat, recalculate, or otherwise manipulate the data in the
    browser.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter considers a JavaScript library that is particularly helpful for
    managing large data sets in the web browser: Underscore.js (*[http://underscorejs.org/](http://underscorejs.org/)*).
    We’ll cover the following aspects of Underscore.js:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: Functional programming, the programming style that Underscore.js encourages
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with simple arrays using Underscore.js utilities
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Enhancing JavaScript objects
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Manipulating collections of objects
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The format of this chapter differs from the other chapters in the book. Instead
    of covering a few examples of moderate complexity, we’ll look at a lot of simple,
    short examples. Each section collects several related examples together, but each
    of the short examples is independent. The first section differs even further.
    It’s a brief introduction to functional programming cast as a step-by-step migration
    from the more common imperative programming style. Understanding functional programming
    is very helpful, as its philosophy underlies almost all of the Underscore.js utilities.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
- en: This chapter serves as a tour of the Underscore.js library with a special focus
    on managing data. (As a concession to the book’s overall focus on data visualization,
    it also includes several illustrations.) We’ll see many of the Underscore.js utilities
    covered here at work in a larger web application project in the subsequent chapters.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
- en: Using Functional Programming
  id: totrans-9
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When we’re working with data that’s part of a visualization, we often have
    to iterate through the data one item at a time to transform, extract, or otherwise
    manipulate it to fit our application. Using only the core JavaScript language,
    our code may rely on a `for` loop like the following:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Although this style, known as *imperative programming*, is a common JavaScript
    idiom, it can present a few problems in large, complex applications. In particular,
    it might result in code that’s harder than necessary to debug, test, and maintain.
    This section introduces a different programming style—*functional programming*—that
    eliminates many of those problems. As you’ll see, functional programming can result
    in code that’s much more concise and readable, and therefore often much less error
    prone.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
- en: 'To compare these two programming styles, let’s consider a simple programming
    problem: writing a function to calculate the Fibonacci numbers. The first two
    Fibonacci numbers are 0 and 1, and subsequent numbers are the sum of the two preceding
    values. The sequence starts like this:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
- en: 0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, . . .
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Step 1: Start with an Imperative Version'
  id: totrans-15
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To begin, let’s consider a traditional, imperative approach to the problem.
    Here’s a first attempt:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: This `fib()` function takes as its input a parameter *n* and returns as its
    output the *n*th Fibonacci number. (By convention, the 0th and 1st Fibonacci numbers
    are 0 and 1.)
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
- en: 'Step 2: Debug the Imperative Code'
  id: totrans-19
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you aren’t checking closely, you might be surprised to find that the preceding
    trivial example contains three bugs. Of course, it’s a contrived example and the
    bugs are deliberate, but can you find all of them without reading any further?
    More to the point, if even a trivial example can hide so many bugs, can you imagine
    what might be lurking in a complex web application?
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
- en: To understand why imperative programming can introduce these bugs, let’s fix
    them one at a time.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
- en: 'One bug is in the `for` loop:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The conditional that determines the loop termination checks for a less-than-or-equal
    (`<=`) value; instead, it should check for a less-than (`<`) value.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
- en: 'A second bug occurs in this line:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Although we think and read left to right (at least in English), JavaScript
    executes multiple assignments from right to left. Instead of shifting the values
    in our variables, this statement simply assigns the value of `f` to all three.
    We need to break the single statement into two:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The final bug is the most subtle, and it’s also in the `for` loop. We’re using
    the local variable `i`, but we haven’t declared it. As a result, JavaScript will
    treat it as a global variable. That won’t cause our function to return incorrect
    results, but it could well introduce a conflict—and a hard-to-find bug—elsewhere
    in our application. The correct code declares the variable as local:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Step 3: Understand the Problems Imperative Programming May Introduce'
  id: totrans-31
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The bugs in this short and straightforward piece of code are meant to demonstrate
    some problematic features of imperative programming in general. In particular,
    conditional logic and state variables, by their very nature, tend to invite certain
    errors.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
- en: Consider the first bug. Its error was using an incorrect test (`<=` instead
    of `<`) for the conditional that terminates the loop. Precise conditional logic
    is critical for computer programs, but such precision doesn’t always come naturally
    to most people, including programmers. Conditional logic has to be perfect, and
    sometimes making it perfect is tricky.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
- en: The other two errors both relate to state variables, `f0` and `f1` in the first
    case and `i` in the second. Here again there’s a difference between how programmers
    think and how programs operate. When programmers write the code to iterate through
    the numbers, they’re probably concentrating on the specific problem at hand. It
    may be easy to neglect the potential effect on other areas of the application.
    More technically, state variables can introduce side effects into a program, and
    side effects may result in bugs.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 另外两个错误都与状态变量有关，第一种情况是`f0`和`f1`，第二种情况是`i`。这里再次体现了程序员的思维方式与程序实际操作之间的差异。当程序员编写代码以迭代数字时，他们可能集中精力处理当前特定的问题，可能会忽视对应用程序其他部分的潜在影响。从技术上讲，状态变量会在程序中引入副作用，副作用可能导致程序中的错误。
- en: 'Step 4: Rewrite Using Functional Programming Style'
  id: totrans-35
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '步骤 4: 使用函数式编程风格重写'
- en: Proponents of functional programming claim that by eliminating conditionals
    and state variables, a functional programming style can produce code that’s more
    concise, more maintainable, and less prone to errors than imperative programming.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 函数式编程的支持者认为，通过消除条件语句和状态变量，函数式编程风格可以生成比命令式编程更加简洁、易于维护且更不容易出错的代码。
- en: The “functional” in “functional programming” does not refer to functions in
    programming languages but rather to mathematical functions such as *y*=*f*(*x*).
    Functional programming attempts to emulate mathematical functions in the context
    of computer programming. Instead of iterating over values by using a `for` loop,
    functional programming often uses recursion, where a function calls itself multiple
    times to make a calculation or manipulate values.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: “函数式”在“函数式编程”中的含义并不是指编程语言中的函数，而是指像*y*=*f*(*x*)这样的数学函数。函数式编程试图在计算机编程的背景下模仿数学函数。它通常使用递归来代替通过`for`循环迭代值，在递归中，一个函数会多次调用自身来进行计算或操作值。
- en: 'Here’s how we can implement the Fibonacci algorithm with functional programming:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是我们如何用函数式编程实现斐波那契算法：
- en: '[PRE6]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Notice that this version has no state variables and, except for the edge case
    to handle 0 or 1, no conditional statements. It’s much more concise, and notice
    how the code mirrors almost word-for-word the statement of the original problem:
    “The first two Fibonacci numbers are 0 and 1” corresponds to `n < 2 ? n`, and
    “subsequent numbers are the sum of the two preceding values” corresponds to `fib(n-1)
    + fib(n-2)`.'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，这个版本没有状态变量，除了处理 0 或 1 的边界情况外，也没有条件语句。它简洁得多，而且请注意代码几乎逐字镜像了原问题的陈述：“前两个斐波那契数是
    0 和 1”对应于`n < 2 ? n`，而“后续的数字是前两个值的和”对应于`fib(n-1) + fib(n-2)`。
- en: Functional programming implementations often express the desired outcome directly.
    They can therefore minimize the chance of misinterpretations or errors in an intermediate
    algorithm.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 函数式编程的实现通常直接表达所需的结果。因此，它们可以最大限度地减少中间算法中误解或错误的可能性。
- en: 'Step 5: Evaluate Performance'
  id: totrans-42
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '步骤 5: 评估性能'
- en: From what we’ve seen so far, it may seem that we should always adopt a functional
    programming style. Certainly functional programming has its advantages, but it
    can have some significant disadvantages as well. The Fibonacci code is a perfect
    example. Since functional programming eschews the notion of loops, our example
    relies instead on recursion.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 从我们目前所见，似乎我们应该始终采用函数式编程风格。毫无疑问，函数式编程有其优势，但它也可能有一些显著的缺点。斐波那契代码就是一个完美的例子。由于函数式编程避免使用循环的概念，我们的示例改用递归。
- en: In our specific case the `fib()` function calls itself twice at every level
    until the recursion reaches 0 or 1\. Since each intermediate call itself results
    in more intermediate calls, the number of calls to `fib()` increases exponentially.
    Finding the 28th Fibonacci number by executing `fib(28)` results in over one million
    calls to the `fib()` function.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的特定案例中，`fib()`函数在每一层都会调用自己两次，直到递归达到 0 或 1。由于每次中间调用都会导致更多的中间调用，`fib()`的调用次数呈指数增长。通过执行`fib(28)`来找出第
    28 个斐波那契数时，将导致超过一百万次对`fib()`函数的调用。
- en: As you might imagine, the resulting performance is simply unacceptable. [Table 8-1](ch08.html#execution_times_for_fibleft_parenthesisr
    "Table 8-1. Execution Times for fib()") shows the execution times for both the
    functional and the imperative versions of `fib()`.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你想象的那样，最终的性能是完全无法接受的。[表 8-1](ch08.html#execution_times_for_fibleft_parenthesisr
    "表 8-1. `fib()`的执行时间")展示了`fib()`函数的函数式版本和命令式版本的执行时间。
- en: Table 8-1. Execution Times for fib()
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 表 8-1. `fib()`的执行时间
- en: '| Version | Parameter | Execution time (ms) |'
  id: totrans-47
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  id: totrans-48
  prefs: []
  type: TYPE_TB
- en: '| Imperative | `28` | 0.231 |'
  id: totrans-49
  prefs: []
  type: TYPE_TB
- en: '| Functional | `28` | 296.9 |'
  id: totrans-50
  prefs: []
  type: TYPE_TB
- en: As you can see, the functional programming version is over a thousand times
    slower. In the real world, such performance is rarely acceptable.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
- en: 'Step 6: Fix the Performance Problem'
  id: totrans-52
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Fortunately, we can reap the benefits of functional programming without suffering
    the performance penalty. We simply turn to the tiny but powerful Underscore.js
    library. As the library’s web page explains,
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
- en: Underscore is a utility-belt library for JavaScript that provides . . . functional
    programming support.
  id: totrans-54
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Of course, we need to include that library in our web pages. If you’re including
    libraries individually, Underscore.js is available on many content distribution
    networks, such as CloudFlare.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: With Underscore.js in place, we can now optimize the performance of our Fibonacci
    implementation.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
- en: The problem with the recursive implementation is that it results in many unnecessary
    calls to `fib()`. For example, executing `fib(28)` requires more than 100,000
    calls to `fib(3)`. And each time `fib(3)` is called, the return value is re calculated
    from scratch. It would be better if the implementation called `fib(3)` only once,
    and every subsequent time it needed to know the value of `fib(3)` it reused the
    previous result instead of recalculating it from scratch. In effect, we’d like
    to implement a cache in front of the `fib()` function. The cache could eliminate
    the repetitive calculations.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
- en: 'This approach is known as *memoizing*, and the Underscore.js library has a
    simple method to automatically and transparently memoize JavaScript functions.
    Not surprisingly, that method is called `memoize()`. To use it, we first wrap
    the function we want to memoize within the Underscore object. Just as jQuery uses
    the dollar sign (`$`) for wrapping, Underscore.js uses the underscore character
    (`_`). After wrapping our function, we simply call the `memoize()` method. Here’s
    the complete code:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: As you can see, we haven’t really lost any of the readability or conciseness
    of functional programming. And it would still be a challenge to introduce a bug
    in this implementation. The only real change is performance, and it’s substantially
    better, as shown in [Table 8-2](ch08.html#execution_times_for_fibleft_pare-id00041
    "Table 8-2. Execution Times for fib(), Continued").
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
- en: Table 8-2. Execution Times for fib(), Continued
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
- en: '| Version | Parameter | Execution time (ms) |'
  id: totrans-63
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  id: totrans-64
  prefs: []
  type: TYPE_TB
- en: '| Imperative `fib()` | `28` | 0.231 |'
  id: totrans-65
  prefs: []
  type: TYPE_TB
- en: '| Functional `fib()` | `28` | 296.9 |'
  id: totrans-66
  prefs: []
  type: TYPE_TB
- en: '| Memoized `fib()` | `28` | 0.352 |'
  id: totrans-67
  prefs: []
  type: TYPE_TB
- en: Just by including the Underscore.js library and using one of its methods, our
    functional implementation has nearly the same performance as the imperative version.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
- en: For the rest of this chapter, we’ll look at many of the other improvements and
    utilities that Underscore.js provides. With its support for functional programming,
    Underscore.js makes it significantly easier to work with data in the browser.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
- en: Working with Arrays
  id: totrans-70
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If your visualization relies on a significant amount of data, that data is most
    likely contained in arrays. Unfortunately, it’s very tempting to resort to imperative
    programming when you are working with arrays. Arrays suggest the use of programming
    loops, and, as we saw earlier, programming loops are an imperative construct that
    often causes errors. If we can avoid loops and rely on functional programming
    instead, we can improve the quality of our JavaScript. The core JavaScript language
    includes a few utilities and methods to help applications cope with arrays in
    a functional style, but Underscore.js adds many others. This section describes
    many of the Underscore.js array utilities that are most helpful for data visualizations.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
- en: Extracting Elements by Position
  id: totrans-72
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you need only a subset of an array for your visualization, Underscore.js
    has many utilities that make it easy to extract the right one. For the following
    examples, we’ll consider a simple array (shown in [Figure 8-1](ch08.html#underscoredotjs_has_many_utilities_to_ma
    "Figure 8-1. Underscore.js has many utilities to make working with arrays easy.")).
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '![Underscore.js has many utilities to make working with arrays easy.](figs/web/08fig01.png)Figure 8-1. Underscore.js
    has many utilities to make working with arrays easy.'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
- en: 'Underscore.js’s `first()` method provides a simple way to extract the first
    element of an array, or the first *n* elements (see [Figure 8-2](ch08.html#firstleft_parenthesisright_parenthesis_f
    "Figure 8-2. The first() function returns the first element or the first n elements
    in an array.")):'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '![The first() function returns the first element or the first n elements in
    an array.](figs/web/08fig02.png.jpg)Figure 8-2. The `first()` function returns
    the first element or the first n elements in an array.'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
- en: Notice that `first()` (without any parameter) returns a simple element, while
    `first(n)` returns an array of elements. That means, for example, that `first()`
    and `first(1)` have different return values (`1` versus `[1]` in the example).
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
- en: As you might expect, Underscore.js also has a `last()` method to extract elements
    from the end of an array (see [Figure 8-3](ch08.html#lastleft_parenthesisright_parenthesis_fu
    "Figure 8-3. The last() function returns the last element or the last n elements
    in an array.")).
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '![The last() function returns the last element or the last n elements in an
    array.](figs/web/08fig03.png.jpg)Figure 8-3. The `last()` function returns the
    last element or the last n elements in an array.'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
- en: Without any parameters, `last()` returns the last element in the array. With
    a parameter `n`, it returns a new array with the last *n* elements from the original.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
- en: The more general versions of both of these functions (`.first(3)` and `.last(3)`)
    would require some potentially tricky (and error-prone) code to implement in an
    imperative style. In the functional style that Underscore.js supports, however,
    our code is clean and simple.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
- en: What if you want to extract from the beginning of the array, but instead of
    knowing how many elements you want to include in the result, you know only how
    many elements you want to omit? In other words, you need “all but the last *n*”
    elements. The `initial()` method performs this extraction (see [Figure 8-4](ch08.html#initialleft_parenthesisright_parenthesis
    "Figure 8-4. The initial() function returns all but the last element or all but
    the last n elements in an array.")). As with all of these methods, if you omit
    the optional parameter, Underscore.js assumes a value of `1`.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '![The initial() function returns all but the last element or all but the last
    n elements in an array.](figs/web/08fig04.png.jpg)Figure 8-4. The `initial()`
    function returns all but the last element or all but the last n elements in an
    array.'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
- en: Finally, you may need the opposite of `initial()`. The `rest()` method skips
    past a defined number of elements in the beginning of the array and returns whatever
    remains (see [Figure 8-5](ch08.html#restleft_parenthesisright_parenthesis_fu "Figure 8-5. The
    rest() function returns all but the first element or all but the first n elements
    in an array.")).
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '![The rest() function returns all but the first element or all but the first
    n elements in an array.](figs/web/08fig05.png.jpg)Figure 8-5. The `rest()` function
    returns all but the first element or all but the first n elements in an array.'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
- en: Again, these functions would be tricky to implement using traditional, imperative
    programming, but they are a breeze with Underscore.js.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
- en: Combining Arrays
  id: totrans-92
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Underscore.js includes another set of utilities for combining two or more arrays.
    These include functions that mimic standard mathematical *set* operations, as
    well as more-sophisticated combinations. For the next few examples, we’ll use
    two arrays, one containing the first few Fibonacci numbers and the other containing
    the first five even integers (see [Figure 8-6](ch08.html#underscoredotjs_also_has_many_utilities
    "Figure 8-6. Underscore.js also has many utilities to work with multiple arrays.")).
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '![Underscore.js also has many utilities to work with multiple arrays.](figs/web/08fig06.png)Figure 8-6. Underscore.js
    also has many utilities to work with multiple arrays.'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
- en: The `union()` method is a straightforward combination of multiple arrays. It
    returns an array containing all elements that are in any of the inputs, and it
    removes any duplicates ([Figure 8-7](ch08.html#unionleft_parenthesisright_parenthesis_f
    "Figure 8-7. The union() function creates the union of multiple arrays, removing
    any duplicates.")).
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '![The union() function creates the union of multiple arrays, removing any duplicates.](figs/web/08fig07.png.jpg)Figure 8-7. The
    `union()` function creates the union of multiple arrays, removing any duplicates.'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '![union() 函数创建多个数组的并集，去除重复元素。](figs/web/08fig07.png.jpg)图 8-7. `union()` 函数创建多个数组的并集，去除重复元素。'
- en: Notice that `union()` removes duplicates whether they appear in separate inputs
    (`0`, `2`, and `8`) or in the same array (`1`).
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`union()` 会去除重复元素，无论它们是出现在不同的输入中（如 `0`、`2` 和 `8`），还是出现在同一个数组中（如 `1`）。
- en: Note
  id: totrans-100
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '**Although this chapter considers combinations of just two arrays, most Underscore.js
    methods can accept an unlimited number of parameters. For example, `_.union(a,b,c,d,e)`
    returns the union of five different arrays. You can even find the union of an
    array of arrays with the JavaScript `apply()` function with something like `_.union.prototype.apply(this,
    arrOfArrs)`.**'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '**尽管本章只讨论了两个数组的组合，但大多数 Underscore.js 方法都能接受无限数量的参数。例如，`_.union(a,b,c,d,e)`
    返回五个不同数组的并集。你甚至可以使用 JavaScript 的 `apply()` 函数来查找数组的数组的并集，方法是像 `_.union.prototype.apply(this,
    arrOfArrs)` 这样。**'
- en: The `intersection()` method acts just as you would expect, returning only those
    elements that appear in all of the input arrays ([Figure 8-8](ch08.html#intersectionleft_parenthesisright_parent
    "Figure 8-8. The intersection() function returns elements in common among multiple
    arrays.")).
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '`intersection()` 方法的作用正如你所预期的，返回所有输入数组中都出现的元素（[图 8-8](ch08.html#intersectionleft_parenthesisright_parent
    "图 8-8. intersection() 函数返回多个数组中共有的元素。")）。'
- en: '[PRE16]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '![The intersection() function returns elements in common among multiple arrays.](figs/web/08fig08.png.jpg)Figure 8-8. The
    `intersection()` function returns elements in common among multiple arrays.'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '![intersection() 函数返回多个数组中共有的元素。](figs/web/08fig08.png.jpg)图 8-8. `intersection()`
    函数返回多个数组中共有的元素。'
- en: The `difference()` method is the opposite of `intersection()`. It returns those
    elements in the first input array that are *not* present in the other inputs ([Figure 8-9](ch08.html#differenceleft_parenthesisright_parenthe
    "Figure 8-9. The difference() function returns elements that are present only
    in the first of multiple arrays.")).
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '`difference()` 方法是 `intersection()` 的反操作。它返回那些仅存在于第一个输入数组中、而不在其他输入数组中的元素（[图
    8-9](ch08.html#differenceleft_parenthesisright_parenthe "图 8-9. difference() 函数返回仅存在于多个数组中的第一个数组的元素。")）。'
- en: '[PRE17]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '![The difference() function returns elements that are present only in the first
    of multiple arrays.](figs/web/08fig09.png.jpg)Figure 8-9. The `difference()` function
    returns elements that are present only in the first of multiple arrays.'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '![difference() 函数返回仅存在于多个数组中的第一个数组的元素。](figs/web/08fig09.png.jpg)图 8-9. `difference()`
    函数返回仅存在于多个数组中的第一个数组的元素。'
- en: If you need to eliminate duplicate elements but have only one array—making `union()`
    inappropriate—then you can use the `uniq()` method ([Figure 8-10](ch08.html#uniqleft_parenthesisright_parenthesis_fu
    "Figure 8-10. The uniq() function removes duplicate elements from an array.")).
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你需要消除重复元素，但只有一个数组—这使得 `union()` 不适用—那么你可以使用 `uniq()` 方法（[图 8-10](ch08.html#uniqleft_parenthesisright_parenthesis_fu
    "图 8-10. uniq() 函数从数组中去除重复元素。")）。
- en: '[PRE18]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '![The uniq() function removes duplicate elements from an array.](figs/web/08fig10.png.jpg)Figure 8-10. The
    `uniq()` function removes duplicate elements from an array.'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '![uniq() 函数从数组中去除重复元素。](figs/web/08fig10.png.jpg)图 8-10. `uniq()` 函数从数组中去除重复元素。'
- en: Finally, Underscore.js has a `zip()` method. Its name doesn’t come from the
    popular compression algorithm but rather because it acts a bit like a zipper.
    It takes multiple input arrays and combines them, element by element, into an
    output array. That output is an array of arrays, where the inner arrays are the
    combined elements.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，Underscore.js 还有一个 `zip()` 方法。它的名字并非来源于流行的压缩算法，而是因为它的作用有点像拉链。它接受多个输入数组，并将它们按元素逐个组合成一个输出数组。该输出是一个数组的数组，其中内层数组是组合后的元素。
- en: '[PRE19]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The operation is perhaps most clearly understood through a picture; see [Figure 8-11](ch08.html#zipleft_parenthesisright_parenthesis_fun
    "Figure 8-11. The zip() function pairs elements from multiple arrays together
    into a single array.").
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 通过图示理解这一操作可能最为清晰；请参见[图 8-11](ch08.html#zipleft_parenthesisright_parenthesis_fun
    "图 8-11. zip() 函数将多个数组的元素配对，组合成一个单一的数组。")。
- en: '![The zip() function pairs elements from multiple arrays together into a single
    array.](figs/web/08fig11.png.jpg)Figure 8-11. The *zip()* function pairs elements
    from multiple arrays together into a single array.'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '![zip()函数将多个数组中的元素配对成一个单一的数组。](figs/web/08fig11.png.jpg)图 8-11. *zip()* 函数将多个数组中的元素配对成一个单一的数组。'
- en: This example demonstrates an alternative style for Underscore.js. Instead of
    wrapping an array within the `_` object as we’ve done so far, we call the `zip()`
    method on the `_` object itself. The alternative style seems a better fit for
    the underlying functionality in this case, but if you prefer `_(naturals).zip(prime)`,
    you’ll get the exact same result.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子展示了Underscore.js的另一种风格。与之前将数组包装在`_`对象中不同，我们直接在`_`对象本身上调用`zip()`方法。在这种情况下，这种替代风格似乎更适合底层功能，但如果你更喜欢`_(naturals).zip(prime)`，你也会得到完全相同的结果。
- en: Removing Invalid Data Values
  id: totrans-116
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 移除无效数据值
- en: One of the banes of visualization applications is invalid data values. Although
    we’d like to think that our data sources ensure that all the data they provide
    is scrupulously correct, that is, unfortunately, rarely the case. More seriously,
    if JavaScript encounters an invalid value, the most common result is an *unhandled
    exception*, which halts all further JavaScript execution on the page.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 可视化应用程序的一个大问题是无效数据值。虽然我们希望数据源能够确保所有提供的数据都是严格正确的，但遗憾的是，情况往往并非如此。更严重的是，如果JavaScript遇到无效值，最常见的结果是一个*未处理的异常*，这将停止页面上所有后续的JavaScript执行。
- en: To avoid such an unpleasant error, we should validate all data sets and remove
    invalid values before we pass the data to graphing or charting libraries. Underscore.js
    has several utilities to help.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免出现这种令人不愉快的错误，我们应该验证所有数据集，并在将数据传递给图表或图形库之前移除无效值。Underscore.js提供了多个工具来帮助完成这项工作。
- en: The simplest of these Underscore.js methods is `compact()`. This function removes
    any data values that JavaScript treats as `false` from the input arrays. Eliminated
    values include the Boolean value `false`, the numeric value `0`, an empty string,
    and the special values `NaN` (not a number; for example, `1/0`), `undefined`,
    and `null`.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 这些Underscore.js方法中最简单的是`compact()`。此函数会从输入数组中移除JavaScript视为`false`的任何数据值。被移除的值包括布尔值`false`、数字值`0`、空字符串以及特殊值`NaN`（非数字，例如`1/0`）、`undefined`和`null`。
- en: '[PRE20]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: It is worth emphasizing that `compact()` removes elements with a value of `0`.
    If you use `compact()` to clean a data array, be sure that `0` isn’t a valid data
    value in your data set.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 值得强调的是，`compact()`会移除值为`0`的元素。如果你使用`compact()`来清理数据数组，请确保`0`在你的数据集中不是有效的数据值。
- en: Another common problem with raw data is excessively nested arrays. If you want
    to eliminate extra nesting levels from a data set, the `flatten()` method is available
    to help.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 原始数据的另一个常见问题是过度嵌套的数组。如果你想从数据集中消除额外的嵌套层级，可以使用`flatten()`方法。
- en: '[PRE21]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: By default, `flatten()` removes all nesting, even multiple levels of nesting,
    from arrays. If you set the `shallow` parameter to `true`, however, it removes
    only a single level of nesting.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，`flatten()`会移除所有的嵌套层级，包括多级嵌套。如果你将`shallow`参数设置为`true`，它只会移除单一层级的嵌套。
- en: '[PRE22]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Finally, if you have specific values that you want to eliminate from an array,
    you can use the `without()` method. Its parameters provide a list of values that
    the function should remove from the input array.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，如果你有特定的值想从数组中删除，可以使用`without()`方法。它的参数提供了一个值的列表，函数应该从输入数组中移除这些值。
- en: '[PRE23]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Finding Elements in an Array
  id: totrans-128
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在数组中查找元素
- en: JavaScript has always defined the `indexOf()` method for strings. It returns
    the position of a given substring within a larger string. Recent versions of JavaScript
    have added this method to array objects, so you can easily find the first occurrence
    of a given value in an array. Unfortunately, older browsers (specifically IE8
    and earlier) don’t support this method.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript一直为字符串定义了`indexOf()`方法。它返回给定子字符串在更大字符串中的位置。JavaScript的最新版本已将此方法添加到数组对象中，因此你可以轻松找到数组中给定值的第一次出现。不幸的是，旧版浏览器（特别是IE8及更早版本）不支持此方法。
- en: Underscore.js provides its own `indexOf()` method to fill the gap those older
    browsers create. If Underscore.js finds itself running in an environment with
    native support for array `indexOf`, then it defers to the native method to avoid
    any performance penalty.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: Underscore.js提供了自己的`indexOf()`方法，以填补旧浏览器造成的空白。如果Underscore.js发现自己运行在支持原生数组`indexOf`方法的环境中，那么它会调用原生方法，以避免性能上的损失。
- en: '[PRE24]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: To begin your search somewhere in the middle of the array, you can specify that
    starting position as the second argument to `indexOf()`.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: You can also search backward from the end of an array using the `lastIndexOf()`
    method.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: If you don’t want to start at the very end of the array, you can pass in the
    starting index as an optional parameter.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
- en: Underscore.js provides a few helpful optimizations for sorted arrays. Both the
    `uniq()` and the `indexOf()` methods accept an optional Boolean parameter. If
    that parameter is `true`, then the functions assume that the array is sorted.
    The performance improvements this assumption allows can be especially significant
    for large data sets.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
- en: The library also includes the special `sortedIndex()` function. This function
    also assumes that the input array is sorted. It finds the position at which a
    specific value *should* be inserted to maintain the array’s sort order.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: If you have a custom sorting function, you can pass that to `sortedIndex()`
    as well.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
- en: Generating Arrays
  id: totrans-141
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The final array utility I’ll mention is a convenient method to generate arrays.
    The `range()` method tells Underscore.js to create an array with the specified
    number of elements. You may also specify a starting value (the default is `0`)
    and the increment between adjacent values (the default is `1`).
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: The `range()` function can be quite useful if you need to generate x-axis values
    to match an array of y-axis values.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Here we use `range()` to generate the matching x-axis values, and use `zip()`
    to combine them with the y-values.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
- en: Enhancing Objects
  id: totrans-147
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Although the previous section’s examples show numeric arrays, often our visualization
    data consists of JavaScript objects instead of simple numbers. That’s especially
    likely if we get the data via a REST interface, because such interfaces almost
    always deliver data in JavaScript Object Notation (JSON). If we need to enhance
    or transform objects without resorting to imperative constructs, Underscore.js
    has another set of utilities that can help. For the following examples, we can
    use a simple `pizza` object (see [Figure 8-12](ch08.html#underscoredotjs_has_many_utilities_for_w
    "Figure 8-12. Underscore.js has many utilities for working with arbitrary JavaScript
    objects.")).
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '![Underscore.js has many utilities for working with arbitrary JavaScript objects.](figs/web/08fig12.png)Figure 8-12. Underscore.js
    has many utilities for working with arbitrary JavaScript objects.'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
- en: Working with Keys and Values
  id: totrans-151
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Underscore.js includes several methods to work with the keys and values that
    make up objects. For example, the `keys()` function creates an array consisting
    solely of an object’s keys (see [Figure 8-13](ch08.html#keysleft_parenthesisright_parenthesis_fu
    "Figure 8-13. The keys() function returns the keys of an object as an array.")).
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: '![The keys() function returns the keys of an object as an array.](figs/web/08fig13.png.jpg)Figure 8-13. The
    `keys()` function returns the keys of an object as an array.'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
- en: Similarly, the `values()` function creates an array consisting solely of an
    object’s values ([Figure 8-14](ch08.html#valuesleft_parenthesisright_parenthesis
    "Figure 8-14. The values() function returns just the values of an object as an
    array.")).
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: '![The values() function returns just the values of an object as an array.](figs/web/08fig14.png.jpg)Figure 8-14. The
    `values()` function returns just the values of an object as an array.'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
- en: The `pairs()` function creates a two-dimensional array. Each element of the
    outer array is itself an array that contains an object’s key and its corresponding
    value ([Figure 8-15](ch08.html#pairsleft_parenthesisright_parenthesis_f "Figure 8-15. The
    pairs() function converts an object into an array of array pairs.")).
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: '![The pairs() function converts an object into an array of array pairs.](figs/web/08fig15.png)Figure 8-15. The
    `pairs()` function converts an object into an array of array pairs.'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
- en: To reverse this transformation and convert an array into an object, we can use
    the `object()` function.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Finally, we can swap the roles of keys and values in an object with the `invert()`
    function ([Figure 8-16](ch08.html#invertleft_parenthesisright_parenthesis "Figure 8-16. The
    invert() function swaps keys and values in an object.")).
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: '![The invert() function swaps keys and values in an object.](figs/web/08fig16.png)Figure 8-16. The
    `invert()` function swaps keys and values in an object.'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
- en: As the preceding example shows, Underscore.js can even invert an object if the
    value isn’t a simple type. In this case it takes an array, `["pepperoni","sausage"]`,
    and converts it to a value by joining the individual array elements with commas,
    creating the key `"pepperoni,sausage"`.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
- en: 'Note also that JavaScript requires that all of an object’s keys are unique.
    That’s not necessarily the case for values. If you have an object in which multiple
    keys have the same value, then `invert()` keeps only the last of those keys in
    the inverted object. For example, `_({key1: value, key2: value}).invert()` returns
    `{value: key2}`.'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
- en: Cleaning Up Object Subsets
  id: totrans-168
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When you want to clean up an object by eliminating unnecessary attributes, you
    can use Underscore.js’s `pick()` function. Simply pass it a list of attributes
    that you want to retain ([Figure 8-17](ch08.html#pickleft_parenthesisright_parenthesis_fu
    "Figure 8-17. The pick() function selects specific properties from an object.")).
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: '![The pick() function selects specific properties from an object.](figs/web/08fig17.png.jpg)Figure 8-17. The
    `pick()` function selects specific properties from an object.'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
- en: We can also do the opposite of `pick()` by using `omit()` and listing the attributes
    that we want to delete ([Figure 8-18](ch08.html#omitleft_parenthesisright_parenthesis_fu
    "Figure 8-18. The omit() function removes properties from an object.")). Underscore.js
    keeps all the other attributes in the object.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: '![The omit() function removes properties from an object.](figs/web/08fig18.png.jpg)Figure 8-18. The
    `omit()` function removes properties from an object.'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
- en: Updating Attributes
  id: totrans-175
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When you are updating objects, a common requirement is to make sure that an
    object includes certain attributes and that those attributes have appropriate
    default values. Underscore.js includes two utilities for this purpose.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
- en: 'The two utilities, `extend()` and `defaults()`, both start with one object
    and adjust its properties based on those of other objects. If the secondary objects
    include attributes that the original object lacks, these utilities add those properties
    to the original. The utilities differ in how they handle properties that are already
    present in the original. The `extend()` function overrides the original properties
    with new values (see [Figure 8-19](ch08.html#extendleft_parenthesisright_parenthesis
    "Figure 8-19. The extend() function updates and adds missing properties to an
    object.")):'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Meanwhile, `defaults()` leaves the original properties unchanged ([Figure 8-20](ch08.html#defaultsleft_parenthesisright_parenthesi
    "Figure 8-20. The defaults() function adds missing properties to an object.")):'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: '![The extend() function updates and adds missing properties to an object.](figs/web/08fig19.png.jpg)Figure 8-19. The
    `extend()` function updates and adds missing properties to an object.![The defaults()
    function adds missing properties to an object.](figs/web/08fig20.png.jpg)Figure 8-20. The
    `defaults()` function adds missing properties to an object.'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that both `extend()` and `defaults()` modify the original object directly;
    they do not make a copy of that object and return the copy. Consider, for example,
    the following:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: This code sets the `pizza` variable as you would expect, but it also sets the
    `standard` variable to that same object. More specifically, the code modifies
    `standard` with the properties from `order`, and then it sets a new variable `pizza`
    equal to `standard`. The modification of `standard` is probably not intended.
    If you need to use either `extend()` or `defaults()` in a way that does not modify
    input parameters, start with an empty object.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: This version gets us the desired `pizza` object without modifying `standard`.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
- en: Manipulating Collections
  id: totrans-187
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: So far we’ve seen various Underscore.js tools that are suited specifically for
    either arrays or objects. Next, we’ll see some tools for manipulating collections
    in general. In Underscore.js both arrays and objects are *collections*, so the
    tools in this section can be applied to pure arrays, pure objects, or data structures
    that combine both. In this section, we’ll try out these utilities on an array
    of objects, since that’s the data structure we most often deal with in the context
    of data visualization.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
- en: Here’s a small data set we can use for the examples that follow. It contains
    a few statistics from the 2012 Major League Baseball season.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Working with Iteration Utilities
  id: totrans-191
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In the first section, we saw some of the pitfalls of traditional JavaScript
    iteration loops as well as the improvements that functional programming can provide.
    Our Fibonacci example eliminated iteration by using recursion, but many algorithms
    don’t lend themselves to a recursive implementation. In those cases, we can still
    use a functional programming style, however, by taking advantage of the iteration
    utilities in Underscore.js.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
- en: The most basic Underscore utility is `each()`. It executes an arbitrary function
    on every element in a collection and often serves as a direct functional replacement
    for the traditional `for (i=0; i<len; i++)` loop.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: If you’re familiar with the jQuery library, you may know that jQuery includes
    a similar `$.each()` utility. There are two important differences between the
    Underscore .js and jQuery versions, however. First, the parameters passed to the
    iterator function differ between the two. Underscore.js passes `(element, index,
    list)` for arrays and `(value, key, list)` for simple objects, while jQuery passes
    `(index, value)`. Secondly, at least as of this writing, the Underscore.js implementation
    can execute much faster than the jQuery version, depending on the browser. (jQuery
    also includes a `$.map()` function that’s similar to the Underscore.js method.)
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
- en: 'The Underscore.js `map()` method iterates through a collection and transforms
    each element with an arbitrary function. It returns a new collection containing
    the transformed elements. Here, for example, is how to create an array of all
    the teams’ winning percentages:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: The `reduce()` method iterates through a collection and returns a single value.
    One parameter initializes this value, and the other parameter is an arbitrary
    function that updates the value for each element in the collection. We can use
    `reduce()`, for example, to calculate how many teams have a winning percentage
    over 500.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: As the comment at ➊ indicates, we start our count at 0\. That value is passed
    as the first parameter to the function at ➋, and the function returns an updated
    value at ➌.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-201
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**If you’ve followed the development of “big data” implementations such as
    Hadoop or Google’s search, you may know that the fundamental algorithm behind
    those technologies is MapReduce. Although the context differs, the same concepts
    underlie the `map()` and `reduce()` utilities in Underscore.js.**'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
- en: Finding Elements in a Collection
  id: totrans-203
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Underscore.js has several methods to help us find elements or sets of elements
    in a collection. We can, for example, use `find()` to get a team with more than
    90 wins.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: The `find()` function returns the first element in the array that meets the
    criterion. To find all elements that meet our criterion, use the `filter()` function.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: The opposite of the `filter()` function is `reject()`. It returns an array of
    elements that don’t meet the criterion.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'If your criterion can be described as a property value, you can use a simpler
    version of `filter()`: the `where()` function. Instead of an arbitrary function
    to check for a match, `where()` takes for its parameter a set of properties that
    must match. We can use it to extract all the teams in the Eastern Division.'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: The `findWhere()` method combines the functionality of `find()` with the simplicity
    of `where()`. It returns the first element in a collection with properties that
    match specific values.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Another Underscore.js utility that’s especially handy is `pluck()`. This function
    creates an array by extracting only the specified property from a collection.
    We could use it to extract an array of nothing but team names, for example.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: Testing a Collection
  id: totrans-216
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Sometimes we don’t necessarily need to transform a collection; we simply want
    to check some aspect of it. Underscore.js provides several utilities to help with
    these tests.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
- en: The `every()` function tells us whether all elements in a collection pass an
    arbitrary test. We could use it to check if every team in our data set had at
    least 70 wins.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: Perhaps we’d like to know if *any* team had at least 70 wins. In that case,
    the `any()` function provides an answer.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: Underscore.js also lets us use arbitrary functions to find the maximum and minimum
    elements in a collection. If our criteria is number of wins, we use `max()` to
    find the “maximum” team.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: Not surprisingly, the `min()` function works the same way.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: Rearranging Collections
  id: totrans-226
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To sort a collection, we can use the `sortBy()` method and supply an arbitrary
    function to provide sortable values. Here’s how to reorder our collection in order
    of increasing wins.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: We could also reorganize our collection by grouping its elements according to
    a property. The Underscore.js function that helps in this case is `groupBy()`.
    One possibility is reorganizing the teams according to their division.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: We can also use the `countBy()` function to simply count the number of elements
    in each group.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: Note
  id: totrans-233
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Although we’ve used a property value (`"division"`) for `groupBy()` and `countBy()`,
    both methods also accept an arbitrary function if the criteria for grouping isn’t
    a simple property.**'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
- en: As a final trick, Underscore.js lets us randomly reorder a collection using
    the `shuffle()` function.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: Summing Up
  id: totrans-237
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Although this chapter takes a different approach than the rest of the book,
    its ultimate focus is still on data visualizations. As we’ve seen in earlier chapters
    (and as you’ll certainly encounter in your own projects), the raw data for our
    visualizations isn’t always perfect as delivered. Sometimes we need to clean the
    data by removing invalid values, and other times we need to rearrange or transform
    it so that it’s appropriate for our visualization libraries.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
- en: The Underscore.js library contains a wealth of tools and utilities to help with
    those tasks. It lets us easily manage arrays, modify objects, and transform collections.
    Furthermore, Underscore.js supports an underlying philosophy based on functional
    programming, so our code that uses Underscore.js remains highly readable and resistant
    to bugs and defects.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
