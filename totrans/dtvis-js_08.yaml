- en: Chapter 8. Managing Data in the Browser
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: So far in the book, we’ve looked at a lot of visual ization tools and techniques,
    but we haven’t spent much time considering the data part of data visualization.
    The emphasis on visualization is appropriate in many cases. Especially if the
    data is static, we can take all the time we need to clean and organize it before
    it’s even represented in JavaScript. But what if the data is dynamic and we have
    no choice but to import the raw source directly into our JavaScript application?
    We have much less control over data from third-party REST APIs, Google Docs spreadsheets,
    or automatically generated CSV files. With those types of data sources, we often
    need to validate, reformat, recalculate, or otherwise manipulate the data in the
    browser.
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter considers a JavaScript library that is particularly helpful for
    managing large data sets in the web browser: Underscore.js (*[http://underscorejs.org/](http://underscorejs.org/)*).
    We’ll cover the following aspects of Underscore.js:'
  prefs: []
  type: TYPE_NORMAL
- en: Functional programming, the programming style that Underscore.js encourages
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with simple arrays using Underscore.js utilities
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Enhancing JavaScript objects
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Manipulating collections of objects
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The format of this chapter differs from the other chapters in the book. Instead
    of covering a few examples of moderate complexity, we’ll look at a lot of simple,
    short examples. Each section collects several related examples together, but each
    of the short examples is independent. The first section differs even further.
    It’s a brief introduction to functional programming cast as a step-by-step migration
    from the more common imperative programming style. Understanding functional programming
    is very helpful, as its philosophy underlies almost all of the Underscore.js utilities.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter serves as a tour of the Underscore.js library with a special focus
    on managing data. (As a concession to the book’s overall focus on data visualization,
    it also includes several illustrations.) We’ll see many of the Underscore.js utilities
    covered here at work in a larger web application project in the subsequent chapters.
  prefs: []
  type: TYPE_NORMAL
- en: Using Functional Programming
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When we’re working with data that’s part of a visualization, we often have
    to iterate through the data one item at a time to transform, extract, or otherwise
    manipulate it to fit our application. Using only the core JavaScript language,
    our code may rely on a `for` loop like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Although this style, known as *imperative programming*, is a common JavaScript
    idiom, it can present a few problems in large, complex applications. In particular,
    it might result in code that’s harder than necessary to debug, test, and maintain.
    This section introduces a different programming style—*functional programming*—that
    eliminates many of those problems. As you’ll see, functional programming can result
    in code that’s much more concise and readable, and therefore often much less error
    prone.
  prefs: []
  type: TYPE_NORMAL
- en: 'To compare these two programming styles, let’s consider a simple programming
    problem: writing a function to calculate the Fibonacci numbers. The first two
    Fibonacci numbers are 0 and 1, and subsequent numbers are the sum of the two preceding
    values. The sequence starts like this:'
  prefs: []
  type: TYPE_NORMAL
- en: 0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, . . .
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Step 1: Start with an Imperative Version'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To begin, let’s consider a traditional, imperative approach to the problem.
    Here’s a first attempt:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: This `fib()` function takes as its input a parameter *n* and returns as its
    output the *n*th Fibonacci number. (By convention, the 0th and 1st Fibonacci numbers
    are 0 and 1.)
  prefs: []
  type: TYPE_NORMAL
- en: 'Step 2: Debug the Imperative Code'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you aren’t checking closely, you might be surprised to find that the preceding
    trivial example contains three bugs. Of course, it’s a contrived example and the
    bugs are deliberate, but can you find all of them without reading any further?
    More to the point, if even a trivial example can hide so many bugs, can you imagine
    what might be lurking in a complex web application?
  prefs: []
  type: TYPE_NORMAL
- en: To understand why imperative programming can introduce these bugs, let’s fix
    them one at a time.
  prefs: []
  type: TYPE_NORMAL
- en: 'One bug is in the `for` loop:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The conditional that determines the loop termination checks for a less-than-or-equal
    (`<=`) value; instead, it should check for a less-than (`<`) value.
  prefs: []
  type: TYPE_NORMAL
- en: 'A second bug occurs in this line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Although we think and read left to right (at least in English), JavaScript
    executes multiple assignments from right to left. Instead of shifting the values
    in our variables, this statement simply assigns the value of `f` to all three.
    We need to break the single statement into two:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'The final bug is the most subtle, and it’s also in the `for` loop. We’re using
    the local variable `i`, but we haven’t declared it. As a result, JavaScript will
    treat it as a global variable. That won’t cause our function to return incorrect
    results, but it could well introduce a conflict—and a hard-to-find bug—elsewhere
    in our application. The correct code declares the variable as local:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Step 3: Understand the Problems Imperative Programming May Introduce'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The bugs in this short and straightforward piece of code are meant to demonstrate
    some problematic features of imperative programming in general. In particular,
    conditional logic and state variables, by their very nature, tend to invite certain
    errors.
  prefs: []
  type: TYPE_NORMAL
- en: Consider the first bug. Its error was using an incorrect test (`<=` instead
    of `<`) for the conditional that terminates the loop. Precise conditional logic
    is critical for computer programs, but such precision doesn’t always come naturally
    to most people, including programmers. Conditional logic has to be perfect, and
    sometimes making it perfect is tricky.
  prefs: []
  type: TYPE_NORMAL
- en: The other two errors both relate to state variables, `f0` and `f1` in the first
    case and `i` in the second. Here again there’s a difference between how programmers
    think and how programs operate. When programmers write the code to iterate through
    the numbers, they’re probably concentrating on the specific problem at hand. It
    may be easy to neglect the potential effect on other areas of the application.
    More technically, state variables can introduce side effects into a program, and
    side effects may result in bugs.
  prefs: []
  type: TYPE_NORMAL
- en: 'Step 4: Rewrite Using Functional Programming Style'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Proponents of functional programming claim that by eliminating conditionals
    and state variables, a functional programming style can produce code that’s more
    concise, more maintainable, and less prone to errors than imperative programming.
  prefs: []
  type: TYPE_NORMAL
- en: The “functional” in “functional programming” does not refer to functions in
    programming languages but rather to mathematical functions such as *y*=*f*(*x*).
    Functional programming attempts to emulate mathematical functions in the context
    of computer programming. Instead of iterating over values by using a `for` loop,
    functional programming often uses recursion, where a function calls itself multiple
    times to make a calculation or manipulate values.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s how we can implement the Fibonacci algorithm with functional programming:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Notice that this version has no state variables and, except for the edge case
    to handle 0 or 1, no conditional statements. It’s much more concise, and notice
    how the code mirrors almost word-for-word the statement of the original problem:
    “The first two Fibonacci numbers are 0 and 1” corresponds to `n < 2 ? n`, and
    “subsequent numbers are the sum of the two preceding values” corresponds to `fib(n-1)
    + fib(n-2)`.'
  prefs: []
  type: TYPE_NORMAL
- en: Functional programming implementations often express the desired outcome directly.
    They can therefore minimize the chance of misinterpretations or errors in an intermediate
    algorithm.
  prefs: []
  type: TYPE_NORMAL
- en: 'Step 5: Evaluate Performance'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: From what we’ve seen so far, it may seem that we should always adopt a functional
    programming style. Certainly functional programming has its advantages, but it
    can have some significant disadvantages as well. The Fibonacci code is a perfect
    example. Since functional programming eschews the notion of loops, our example
    relies instead on recursion.
  prefs: []
  type: TYPE_NORMAL
- en: In our specific case the `fib()` function calls itself twice at every level
    until the recursion reaches 0 or 1\. Since each intermediate call itself results
    in more intermediate calls, the number of calls to `fib()` increases exponentially.
    Finding the 28th Fibonacci number by executing `fib(28)` results in over one million
    calls to the `fib()` function.
  prefs: []
  type: TYPE_NORMAL
- en: As you might imagine, the resulting performance is simply unacceptable. [Table 8-1](ch08.html#execution_times_for_fibleft_parenthesisr
    "Table 8-1. Execution Times for fib()") shows the execution times for both the
    functional and the imperative versions of `fib()`.
  prefs: []
  type: TYPE_NORMAL
- en: Table 8-1. Execution Times for fib()
  prefs: []
  type: TYPE_NORMAL
- en: '| Version | Parameter | Execution time (ms) |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| Imperative | `28` | 0.231 |'
  prefs: []
  type: TYPE_TB
- en: '| Functional | `28` | 296.9 |'
  prefs: []
  type: TYPE_TB
- en: As you can see, the functional programming version is over a thousand times
    slower. In the real world, such performance is rarely acceptable.
  prefs: []
  type: TYPE_NORMAL
- en: 'Step 6: Fix the Performance Problem'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Fortunately, we can reap the benefits of functional programming without suffering
    the performance penalty. We simply turn to the tiny but powerful Underscore.js
    library. As the library’s web page explains,
  prefs: []
  type: TYPE_NORMAL
- en: Underscore is a utility-belt library for JavaScript that provides . . . functional
    programming support.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Of course, we need to include that library in our web pages. If you’re including
    libraries individually, Underscore.js is available on many content distribution
    networks, such as CloudFlare.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: With Underscore.js in place, we can now optimize the performance of our Fibonacci
    implementation.
  prefs: []
  type: TYPE_NORMAL
- en: The problem with the recursive implementation is that it results in many unnecessary
    calls to `fib()`. For example, executing `fib(28)` requires more than 100,000
    calls to `fib(3)`. And each time `fib(3)` is called, the return value is re calculated
    from scratch. It would be better if the implementation called `fib(3)` only once,
    and every subsequent time it needed to know the value of `fib(3)` it reused the
    previous result instead of recalculating it from scratch. In effect, we’d like
    to implement a cache in front of the `fib()` function. The cache could eliminate
    the repetitive calculations.
  prefs: []
  type: TYPE_NORMAL
- en: 'This approach is known as *memoizing*, and the Underscore.js library has a
    simple method to automatically and transparently memoize JavaScript functions.
    Not surprisingly, that method is called `memoize()`. To use it, we first wrap
    the function we want to memoize within the Underscore object. Just as jQuery uses
    the dollar sign (`$`) for wrapping, Underscore.js uses the underscore character
    (`_`). After wrapping our function, we simply call the `memoize()` method. Here’s
    the complete code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, we haven’t really lost any of the readability or conciseness
    of functional programming. And it would still be a challenge to introduce a bug
    in this implementation. The only real change is performance, and it’s substantially
    better, as shown in [Table 8-2](ch08.html#execution_times_for_fibleft_pare-id00041
    "Table 8-2. Execution Times for fib(), Continued").
  prefs: []
  type: TYPE_NORMAL
- en: Table 8-2. Execution Times for fib(), Continued
  prefs: []
  type: TYPE_NORMAL
- en: '| Version | Parameter | Execution time (ms) |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| Imperative `fib()` | `28` | 0.231 |'
  prefs: []
  type: TYPE_TB
- en: '| Functional `fib()` | `28` | 296.9 |'
  prefs: []
  type: TYPE_TB
- en: '| Memoized `fib()` | `28` | 0.352 |'
  prefs: []
  type: TYPE_TB
- en: Just by including the Underscore.js library and using one of its methods, our
    functional implementation has nearly the same performance as the imperative version.
  prefs: []
  type: TYPE_NORMAL
- en: For the rest of this chapter, we’ll look at many of the other improvements and
    utilities that Underscore.js provides. With its support for functional programming,
    Underscore.js makes it significantly easier to work with data in the browser.
  prefs: []
  type: TYPE_NORMAL
- en: Working with Arrays
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If your visualization relies on a significant amount of data, that data is most
    likely contained in arrays. Unfortunately, it’s very tempting to resort to imperative
    programming when you are working with arrays. Arrays suggest the use of programming
    loops, and, as we saw earlier, programming loops are an imperative construct that
    often causes errors. If we can avoid loops and rely on functional programming
    instead, we can improve the quality of our JavaScript. The core JavaScript language
    includes a few utilities and methods to help applications cope with arrays in
    a functional style, but Underscore.js adds many others. This section describes
    many of the Underscore.js array utilities that are most helpful for data visualizations.
  prefs: []
  type: TYPE_NORMAL
- en: Extracting Elements by Position
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you need only a subset of an array for your visualization, Underscore.js
    has many utilities that make it easy to extract the right one. For the following
    examples, we’ll consider a simple array (shown in [Figure 8-1](ch08.html#underscoredotjs_has_many_utilities_to_ma
    "Figure 8-1. Underscore.js has many utilities to make working with arrays easy.")).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: '![Underscore.js has many utilities to make working with arrays easy.](figs/web/08fig01.png)Figure 8-1. Underscore.js
    has many utilities to make working with arrays easy.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Underscore.js’s `first()` method provides a simple way to extract the first
    element of an array, or the first *n* elements (see [Figure 8-2](ch08.html#firstleft_parenthesisright_parenthesis_f
    "Figure 8-2. The first() function returns the first element or the first n elements
    in an array.")):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: '![The first() function returns the first element or the first n elements in
    an array.](figs/web/08fig02.png.jpg)Figure 8-2. The `first()` function returns
    the first element or the first n elements in an array.'
  prefs: []
  type: TYPE_NORMAL
- en: Notice that `first()` (without any parameter) returns a simple element, while
    `first(n)` returns an array of elements. That means, for example, that `first()`
    and `first(1)` have different return values (`1` versus `[1]` in the example).
  prefs: []
  type: TYPE_NORMAL
- en: As you might expect, Underscore.js also has a `last()` method to extract elements
    from the end of an array (see [Figure 8-3](ch08.html#lastleft_parenthesisright_parenthesis_fu
    "Figure 8-3. The last() function returns the last element or the last n elements
    in an array.")).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: '![The last() function returns the last element or the last n elements in an
    array.](figs/web/08fig03.png.jpg)Figure 8-3. The `last()` function returns the
    last element or the last n elements in an array.'
  prefs: []
  type: TYPE_NORMAL
- en: Without any parameters, `last()` returns the last element in the array. With
    a parameter `n`, it returns a new array with the last *n* elements from the original.
  prefs: []
  type: TYPE_NORMAL
- en: The more general versions of both of these functions (`.first(3)` and `.last(3)`)
    would require some potentially tricky (and error-prone) code to implement in an
    imperative style. In the functional style that Underscore.js supports, however,
    our code is clean and simple.
  prefs: []
  type: TYPE_NORMAL
- en: What if you want to extract from the beginning of the array, but instead of
    knowing how many elements you want to include in the result, you know only how
    many elements you want to omit? In other words, you need “all but the last *n*”
    elements. The `initial()` method performs this extraction (see [Figure 8-4](ch08.html#initialleft_parenthesisright_parenthesis
    "Figure 8-4. The initial() function returns all but the last element or all but
    the last n elements in an array.")). As with all of these methods, if you omit
    the optional parameter, Underscore.js assumes a value of `1`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: '![The initial() function returns all but the last element or all but the last
    n elements in an array.](figs/web/08fig04.png.jpg)Figure 8-4. The `initial()`
    function returns all but the last element or all but the last n elements in an
    array.'
  prefs: []
  type: TYPE_NORMAL
- en: Finally, you may need the opposite of `initial()`. The `rest()` method skips
    past a defined number of elements in the beginning of the array and returns whatever
    remains (see [Figure 8-5](ch08.html#restleft_parenthesisright_parenthesis_fu "Figure 8-5. The
    rest() function returns all but the first element or all but the first n elements
    in an array.")).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: '![The rest() function returns all but the first element or all but the first
    n elements in an array.](figs/web/08fig05.png.jpg)Figure 8-5. The `rest()` function
    returns all but the first element or all but the first n elements in an array.'
  prefs: []
  type: TYPE_NORMAL
- en: Again, these functions would be tricky to implement using traditional, imperative
    programming, but they are a breeze with Underscore.js.
  prefs: []
  type: TYPE_NORMAL
- en: Combining Arrays
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Underscore.js includes another set of utilities for combining two or more arrays.
    These include functions that mimic standard mathematical *set* operations, as
    well as more-sophisticated combinations. For the next few examples, we’ll use
    two arrays, one containing the first few Fibonacci numbers and the other containing
    the first five even integers (see [Figure 8-6](ch08.html#underscoredotjs_also_has_many_utilities
    "Figure 8-6. Underscore.js also has many utilities to work with multiple arrays.")).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: '![Underscore.js also has many utilities to work with multiple arrays.](figs/web/08fig06.png)Figure 8-6. Underscore.js
    also has many utilities to work with multiple arrays.'
  prefs: []
  type: TYPE_NORMAL
- en: The `union()` method is a straightforward combination of multiple arrays. It
    returns an array containing all elements that are in any of the inputs, and it
    removes any duplicates ([Figure 8-7](ch08.html#unionleft_parenthesisright_parenthesis_f
    "Figure 8-7. The union() function creates the union of multiple arrays, removing
    any duplicates.")).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: '![The union() function creates the union of multiple arrays, removing any duplicates.](figs/web/08fig07.png.jpg)Figure 8-7. The
    `union()` function creates the union of multiple arrays, removing any duplicates.'
  prefs: []
  type: TYPE_NORMAL
- en: Notice that `union()` removes duplicates whether they appear in separate inputs
    (`0`, `2`, and `8`) or in the same array (`1`).
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Although this chapter considers combinations of just two arrays, most Underscore.js
    methods can accept an unlimited number of parameters. For example, `_.union(a,b,c,d,e)`
    returns the union of five different arrays. You can even find the union of an
    array of arrays with the JavaScript `apply()` function with something like `_.union.prototype.apply(this,
    arrOfArrs)`.**'
  prefs: []
  type: TYPE_NORMAL
- en: The `intersection()` method acts just as you would expect, returning only those
    elements that appear in all of the input arrays ([Figure 8-8](ch08.html#intersectionleft_parenthesisright_parent
    "Figure 8-8. The intersection() function returns elements in common among multiple
    arrays.")).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: '![The intersection() function returns elements in common among multiple arrays.](figs/web/08fig08.png.jpg)Figure 8-8. The
    `intersection()` function returns elements in common among multiple arrays.'
  prefs: []
  type: TYPE_NORMAL
- en: The `difference()` method is the opposite of `intersection()`. It returns those
    elements in the first input array that are *not* present in the other inputs ([Figure 8-9](ch08.html#differenceleft_parenthesisright_parenthe
    "Figure 8-9. The difference() function returns elements that are present only
    in the first of multiple arrays.")).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: '![The difference() function returns elements that are present only in the first
    of multiple arrays.](figs/web/08fig09.png.jpg)Figure 8-9. The `difference()` function
    returns elements that are present only in the first of multiple arrays.'
  prefs: []
  type: TYPE_NORMAL
- en: If you need to eliminate duplicate elements but have only one array—making `union()`
    inappropriate—then you can use the `uniq()` method ([Figure 8-10](ch08.html#uniqleft_parenthesisright_parenthesis_fu
    "Figure 8-10. The uniq() function removes duplicate elements from an array.")).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: '![The uniq() function removes duplicate elements from an array.](figs/web/08fig10.png.jpg)Figure 8-10. The
    `uniq()` function removes duplicate elements from an array.'
  prefs: []
  type: TYPE_NORMAL
- en: Finally, Underscore.js has a `zip()` method. Its name doesn’t come from the
    popular compression algorithm but rather because it acts a bit like a zipper.
    It takes multiple input arrays and combines them, element by element, into an
    output array. That output is an array of arrays, where the inner arrays are the
    combined elements.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: The operation is perhaps most clearly understood through a picture; see [Figure 8-11](ch08.html#zipleft_parenthesisright_parenthesis_fun
    "Figure 8-11. The zip() function pairs elements from multiple arrays together
    into a single array.").
  prefs: []
  type: TYPE_NORMAL
- en: '![The zip() function pairs elements from multiple arrays together into a single
    array.](figs/web/08fig11.png.jpg)Figure 8-11. The *zip()* function pairs elements
    from multiple arrays together into a single array.'
  prefs: []
  type: TYPE_NORMAL
- en: This example demonstrates an alternative style for Underscore.js. Instead of
    wrapping an array within the `_` object as we’ve done so far, we call the `zip()`
    method on the `_` object itself. The alternative style seems a better fit for
    the underlying functionality in this case, but if you prefer `_(naturals).zip(prime)`,
    you’ll get the exact same result.
  prefs: []
  type: TYPE_NORMAL
- en: Removing Invalid Data Values
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: One of the banes of visualization applications is invalid data values. Although
    we’d like to think that our data sources ensure that all the data they provide
    is scrupulously correct, that is, unfortunately, rarely the case. More seriously,
    if JavaScript encounters an invalid value, the most common result is an *unhandled
    exception*, which halts all further JavaScript execution on the page.
  prefs: []
  type: TYPE_NORMAL
- en: To avoid such an unpleasant error, we should validate all data sets and remove
    invalid values before we pass the data to graphing or charting libraries. Underscore.js
    has several utilities to help.
  prefs: []
  type: TYPE_NORMAL
- en: The simplest of these Underscore.js methods is `compact()`. This function removes
    any data values that JavaScript treats as `false` from the input arrays. Eliminated
    values include the Boolean value `false`, the numeric value `0`, an empty string,
    and the special values `NaN` (not a number; for example, `1/0`), `undefined`,
    and `null`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: It is worth emphasizing that `compact()` removes elements with a value of `0`.
    If you use `compact()` to clean a data array, be sure that `0` isn’t a valid data
    value in your data set.
  prefs: []
  type: TYPE_NORMAL
- en: Another common problem with raw data is excessively nested arrays. If you want
    to eliminate extra nesting levels from a data set, the `flatten()` method is available
    to help.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: By default, `flatten()` removes all nesting, even multiple levels of nesting,
    from arrays. If you set the `shallow` parameter to `true`, however, it removes
    only a single level of nesting.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Finally, if you have specific values that you want to eliminate from an array,
    you can use the `without()` method. Its parameters provide a list of values that
    the function should remove from the input array.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Finding Elements in an Array
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: JavaScript has always defined the `indexOf()` method for strings. It returns
    the position of a given substring within a larger string. Recent versions of JavaScript
    have added this method to array objects, so you can easily find the first occurrence
    of a given value in an array. Unfortunately, older browsers (specifically IE8
    and earlier) don’t support this method.
  prefs: []
  type: TYPE_NORMAL
- en: Underscore.js provides its own `indexOf()` method to fill the gap those older
    browsers create. If Underscore.js finds itself running in an environment with
    native support for array `indexOf`, then it defers to the native method to avoid
    any performance penalty.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: To begin your search somewhere in the middle of the array, you can specify that
    starting position as the second argument to `indexOf()`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: You can also search backward from the end of an array using the `lastIndexOf()`
    method.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: If you don’t want to start at the very end of the array, you can pass in the
    starting index as an optional parameter.
  prefs: []
  type: TYPE_NORMAL
- en: Underscore.js provides a few helpful optimizations for sorted arrays. Both the
    `uniq()` and the `indexOf()` methods accept an optional Boolean parameter. If
    that parameter is `true`, then the functions assume that the array is sorted.
    The performance improvements this assumption allows can be especially significant
    for large data sets.
  prefs: []
  type: TYPE_NORMAL
- en: The library also includes the special `sortedIndex()` function. This function
    also assumes that the input array is sorted. It finds the position at which a
    specific value *should* be inserted to maintain the array’s sort order.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: If you have a custom sorting function, you can pass that to `sortedIndex()`
    as well.
  prefs: []
  type: TYPE_NORMAL
- en: Generating Arrays
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The final array utility I’ll mention is a convenient method to generate arrays.
    The `range()` method tells Underscore.js to create an array with the specified
    number of elements. You may also specify a starting value (the default is `0`)
    and the increment between adjacent values (the default is `1`).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: The `range()` function can be quite useful if you need to generate x-axis values
    to match an array of y-axis values.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Here we use `range()` to generate the matching x-axis values, and use `zip()`
    to combine them with the y-values.
  prefs: []
  type: TYPE_NORMAL
- en: Enhancing Objects
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Although the previous section’s examples show numeric arrays, often our visualization
    data consists of JavaScript objects instead of simple numbers. That’s especially
    likely if we get the data via a REST interface, because such interfaces almost
    always deliver data in JavaScript Object Notation (JSON). If we need to enhance
    or transform objects without resorting to imperative constructs, Underscore.js
    has another set of utilities that can help. For the following examples, we can
    use a simple `pizza` object (see [Figure 8-12](ch08.html#underscoredotjs_has_many_utilities_for_w
    "Figure 8-12. Underscore.js has many utilities for working with arbitrary JavaScript
    objects.")).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: '![Underscore.js has many utilities for working with arbitrary JavaScript objects.](figs/web/08fig12.png)Figure 8-12. Underscore.js
    has many utilities for working with arbitrary JavaScript objects.'
  prefs: []
  type: TYPE_NORMAL
- en: Working with Keys and Values
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Underscore.js includes several methods to work with the keys and values that
    make up objects. For example, the `keys()` function creates an array consisting
    solely of an object’s keys (see [Figure 8-13](ch08.html#keysleft_parenthesisright_parenthesis_fu
    "Figure 8-13. The keys() function returns the keys of an object as an array.")).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: '![The keys() function returns the keys of an object as an array.](figs/web/08fig13.png.jpg)Figure 8-13. The
    `keys()` function returns the keys of an object as an array.'
  prefs: []
  type: TYPE_NORMAL
- en: Similarly, the `values()` function creates an array consisting solely of an
    object’s values ([Figure 8-14](ch08.html#valuesleft_parenthesisright_parenthesis
    "Figure 8-14. The values() function returns just the values of an object as an
    array.")).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: '![The values() function returns just the values of an object as an array.](figs/web/08fig14.png.jpg)Figure 8-14. The
    `values()` function returns just the values of an object as an array.'
  prefs: []
  type: TYPE_NORMAL
- en: The `pairs()` function creates a two-dimensional array. Each element of the
    outer array is itself an array that contains an object’s key and its corresponding
    value ([Figure 8-15](ch08.html#pairsleft_parenthesisright_parenthesis_f "Figure 8-15. The
    pairs() function converts an object into an array of array pairs.")).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: '![The pairs() function converts an object into an array of array pairs.](figs/web/08fig15.png)Figure 8-15. The
    `pairs()` function converts an object into an array of array pairs.'
  prefs: []
  type: TYPE_NORMAL
- en: To reverse this transformation and convert an array into an object, we can use
    the `object()` function.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Finally, we can swap the roles of keys and values in an object with the `invert()`
    function ([Figure 8-16](ch08.html#invertleft_parenthesisright_parenthesis "Figure 8-16. The
    invert() function swaps keys and values in an object.")).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: '![The invert() function swaps keys and values in an object.](figs/web/08fig16.png)Figure 8-16. The
    `invert()` function swaps keys and values in an object.'
  prefs: []
  type: TYPE_NORMAL
- en: As the preceding example shows, Underscore.js can even invert an object if the
    value isn’t a simple type. In this case it takes an array, `["pepperoni","sausage"]`,
    and converts it to a value by joining the individual array elements with commas,
    creating the key `"pepperoni,sausage"`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Note also that JavaScript requires that all of an object’s keys are unique.
    That’s not necessarily the case for values. If you have an object in which multiple
    keys have the same value, then `invert()` keeps only the last of those keys in
    the inverted object. For example, `_({key1: value, key2: value}).invert()` returns
    `{value: key2}`.'
  prefs: []
  type: TYPE_NORMAL
- en: Cleaning Up Object Subsets
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When you want to clean up an object by eliminating unnecessary attributes, you
    can use Underscore.js’s `pick()` function. Simply pass it a list of attributes
    that you want to retain ([Figure 8-17](ch08.html#pickleft_parenthesisright_parenthesis_fu
    "Figure 8-17. The pick() function selects specific properties from an object.")).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: '![The pick() function selects specific properties from an object.](figs/web/08fig17.png.jpg)Figure 8-17. The
    `pick()` function selects specific properties from an object.'
  prefs: []
  type: TYPE_NORMAL
- en: We can also do the opposite of `pick()` by using `omit()` and listing the attributes
    that we want to delete ([Figure 8-18](ch08.html#omitleft_parenthesisright_parenthesis_fu
    "Figure 8-18. The omit() function removes properties from an object.")). Underscore.js
    keeps all the other attributes in the object.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: '![The omit() function removes properties from an object.](figs/web/08fig18.png.jpg)Figure 8-18. The
    `omit()` function removes properties from an object.'
  prefs: []
  type: TYPE_NORMAL
- en: Updating Attributes
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When you are updating objects, a common requirement is to make sure that an
    object includes certain attributes and that those attributes have appropriate
    default values. Underscore.js includes two utilities for this purpose.
  prefs: []
  type: TYPE_NORMAL
- en: 'The two utilities, `extend()` and `defaults()`, both start with one object
    and adjust its properties based on those of other objects. If the secondary objects
    include attributes that the original object lacks, these utilities add those properties
    to the original. The utilities differ in how they handle properties that are already
    present in the original. The `extend()` function overrides the original properties
    with new values (see [Figure 8-19](ch08.html#extendleft_parenthesisright_parenthesis
    "Figure 8-19. The extend() function updates and adds missing properties to an
    object.")):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'Meanwhile, `defaults()` leaves the original properties unchanged ([Figure 8-20](ch08.html#defaultsleft_parenthesisright_parenthesi
    "Figure 8-20. The defaults() function adds missing properties to an object.")):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: '![The extend() function updates and adds missing properties to an object.](figs/web/08fig19.png.jpg)Figure 8-19. The
    `extend()` function updates and adds missing properties to an object.![The defaults()
    function adds missing properties to an object.](figs/web/08fig20.png.jpg)Figure 8-20. The
    `defaults()` function adds missing properties to an object.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that both `extend()` and `defaults()` modify the original object directly;
    they do not make a copy of that object and return the copy. Consider, for example,
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: This code sets the `pizza` variable as you would expect, but it also sets the
    `standard` variable to that same object. More specifically, the code modifies
    `standard` with the properties from `order`, and then it sets a new variable `pizza`
    equal to `standard`. The modification of `standard` is probably not intended.
    If you need to use either `extend()` or `defaults()` in a way that does not modify
    input parameters, start with an empty object.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: This version gets us the desired `pizza` object without modifying `standard`.
  prefs: []
  type: TYPE_NORMAL
- en: Manipulating Collections
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: So far we’ve seen various Underscore.js tools that are suited specifically for
    either arrays or objects. Next, we’ll see some tools for manipulating collections
    in general. In Underscore.js both arrays and objects are *collections*, so the
    tools in this section can be applied to pure arrays, pure objects, or data structures
    that combine both. In this section, we’ll try out these utilities on an array
    of objects, since that’s the data structure we most often deal with in the context
    of data visualization.
  prefs: []
  type: TYPE_NORMAL
- en: Here’s a small data set we can use for the examples that follow. It contains
    a few statistics from the 2012 Major League Baseball season.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: Working with Iteration Utilities
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In the first section, we saw some of the pitfalls of traditional JavaScript
    iteration loops as well as the improvements that functional programming can provide.
    Our Fibonacci example eliminated iteration by using recursion, but many algorithms
    don’t lend themselves to a recursive implementation. In those cases, we can still
    use a functional programming style, however, by taking advantage of the iteration
    utilities in Underscore.js.
  prefs: []
  type: TYPE_NORMAL
- en: The most basic Underscore utility is `each()`. It executes an arbitrary function
    on every element in a collection and often serves as a direct functional replacement
    for the traditional `for (i=0; i<len; i++)` loop.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: If you’re familiar with the jQuery library, you may know that jQuery includes
    a similar `$.each()` utility. There are two important differences between the
    Underscore .js and jQuery versions, however. First, the parameters passed to the
    iterator function differ between the two. Underscore.js passes `(element, index,
    list)` for arrays and `(value, key, list)` for simple objects, while jQuery passes
    `(index, value)`. Secondly, at least as of this writing, the Underscore.js implementation
    can execute much faster than the jQuery version, depending on the browser. (jQuery
    also includes a `$.map()` function that’s similar to the Underscore.js method.)
  prefs: []
  type: TYPE_NORMAL
- en: 'The Underscore.js `map()` method iterates through a collection and transforms
    each element with an arbitrary function. It returns a new collection containing
    the transformed elements. Here, for example, is how to create an array of all
    the teams’ winning percentages:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: The `reduce()` method iterates through a collection and returns a single value.
    One parameter initializes this value, and the other parameter is an arbitrary
    function that updates the value for each element in the collection. We can use
    `reduce()`, for example, to calculate how many teams have a winning percentage
    over 500.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: As the comment at ➊ indicates, we start our count at 0\. That value is passed
    as the first parameter to the function at ➋, and the function returns an updated
    value at ➌.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**If you’ve followed the development of “big data” implementations such as
    Hadoop or Google’s search, you may know that the fundamental algorithm behind
    those technologies is MapReduce. Although the context differs, the same concepts
    underlie the `map()` and `reduce()` utilities in Underscore.js.**'
  prefs: []
  type: TYPE_NORMAL
- en: Finding Elements in a Collection
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Underscore.js has several methods to help us find elements or sets of elements
    in a collection. We can, for example, use `find()` to get a team with more than
    90 wins.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: The `find()` function returns the first element in the array that meets the
    criterion. To find all elements that meet our criterion, use the `filter()` function.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: The opposite of the `filter()` function is `reject()`. It returns an array of
    elements that don’t meet the criterion.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'If your criterion can be described as a property value, you can use a simpler
    version of `filter()`: the `where()` function. Instead of an arbitrary function
    to check for a match, `where()` takes for its parameter a set of properties that
    must match. We can use it to extract all the teams in the Eastern Division.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: The `findWhere()` method combines the functionality of `find()` with the simplicity
    of `where()`. It returns the first element in a collection with properties that
    match specific values.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: Another Underscore.js utility that’s especially handy is `pluck()`. This function
    creates an array by extracting only the specified property from a collection.
    We could use it to extract an array of nothing but team names, for example.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: Testing a Collection
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Sometimes we don’t necessarily need to transform a collection; we simply want
    to check some aspect of it. Underscore.js provides several utilities to help with
    these tests.
  prefs: []
  type: TYPE_NORMAL
- en: The `every()` function tells us whether all elements in a collection pass an
    arbitrary test. We could use it to check if every team in our data set had at
    least 70 wins.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: Perhaps we’d like to know if *any* team had at least 70 wins. In that case,
    the `any()` function provides an answer.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: Underscore.js also lets us use arbitrary functions to find the maximum and minimum
    elements in a collection. If our criteria is number of wins, we use `max()` to
    find the “maximum” team.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: Not surprisingly, the `min()` function works the same way.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: Rearranging Collections
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To sort a collection, we can use the `sortBy()` method and supply an arbitrary
    function to provide sortable values. Here’s how to reorder our collection in order
    of increasing wins.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: We could also reorganize our collection by grouping its elements according to
    a property. The Underscore.js function that helps in this case is `groupBy()`.
    One possibility is reorganizing the teams according to their division.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: We can also use the `countBy()` function to simply count the number of elements
    in each group.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Although we’ve used a property value (`"division"`) for `groupBy()` and `countBy()`,
    both methods also accept an arbitrary function if the criteria for grouping isn’t
    a simple property.**'
  prefs: []
  type: TYPE_NORMAL
- en: As a final trick, Underscore.js lets us randomly reorder a collection using
    the `shuffle()` function.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: Summing Up
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Although this chapter takes a different approach than the rest of the book,
    its ultimate focus is still on data visualizations. As we’ve seen in earlier chapters
    (and as you’ll certainly encounter in your own projects), the raw data for our
    visualizations isn’t always perfect as delivered. Sometimes we need to clean the
    data by removing invalid values, and other times we need to rearrange or transform
    it so that it’s appropriate for our visualization libraries.
  prefs: []
  type: TYPE_NORMAL
- en: The Underscore.js library contains a wealth of tools and utilities to help with
    those tasks. It lets us easily manage arrays, modify objects, and transform collections.
    Furthermore, Underscore.js supports an underlying philosophy based on functional
    programming, so our code that uses Underscore.js remains highly readable and resistant
    to bugs and defects.
  prefs: []
  type: TYPE_NORMAL
