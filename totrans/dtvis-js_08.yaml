- en: Chapter 8. Managing Data in the Browser
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第8章. 在浏览器中管理数据
- en: So far in the book, we’ve looked at a lot of visual ization tools and techniques,
    but we haven’t spent much time considering the data part of data visualization.
    The emphasis on visualization is appropriate in many cases. Especially if the
    data is static, we can take all the time we need to clean and organize it before
    it’s even represented in JavaScript. But what if the data is dynamic and we have
    no choice but to import the raw source directly into our JavaScript application?
    We have much less control over data from third-party REST APIs, Google Docs spreadsheets,
    or automatically generated CSV files. With those types of data sources, we often
    need to validate, reformat, recalculate, or otherwise manipulate the data in the
    browser.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，在本书中，我们已经探讨了许多可视化工具和技术，但我们并未花太多时间考虑数据可视化中的数据部分。在许多情况下，侧重可视化是合适的。尤其是当数据是静态时，我们可以在其呈现在
    JavaScript 中之前，花费大量时间进行清理和组织。但如果数据是动态的，我们别无选择，只能将原始数据源直接导入到我们的 JavaScript 应用程序中？对于来自第三方
    REST API、Google Docs 表格或自动生成的 CSV 文件的数据，我们的控制能力要小得多。在这些类型的数据源中，我们常常需要在浏览器中验证、重新格式化、重新计算或以其他方式操作数据。
- en: 'This chapter considers a JavaScript library that is particularly helpful for
    managing large data sets in the web browser: Underscore.js (*[http://underscorejs.org/](http://underscorejs.org/)*).
    We’ll cover the following aspects of Underscore.js:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章探讨了一个特别有助于在 Web 浏览器中管理大型数据集的 JavaScript 库：Underscore.js (*[http://underscorejs.org/](http://underscorejs.org/)*).
    我们将覆盖 Underscore.js 的以下方面：
- en: Functional programming, the programming style that Underscore.js encourages
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数式编程，Underscore.js 推崇的编程风格
- en: Working with simple arrays using Underscore.js utilities
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Underscore.js 工具操作简单数组
- en: Enhancing JavaScript objects
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 增强 JavaScript 对象
- en: Manipulating collections of objects
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 操作对象集合
- en: The format of this chapter differs from the other chapters in the book. Instead
    of covering a few examples of moderate complexity, we’ll look at a lot of simple,
    short examples. Each section collects several related examples together, but each
    of the short examples is independent. The first section differs even further.
    It’s a brief introduction to functional programming cast as a step-by-step migration
    from the more common imperative programming style. Understanding functional programming
    is very helpful, as its philosophy underlies almost all of the Underscore.js utilities.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的格式与本书的其他章节有所不同。我们不会覆盖几个中等复杂度的示例，而是会看许多简单而简短的示例。每个部分将几个相关的示例放在一起，但每个短小的示例都是独立的。第一部分则更加不同，它是一个简短的函数式编程介绍，呈现为从更常见的命令式编程风格逐步迁移的过程。理解函数式编程非常有帮助，因为它的哲学基础贯穿于几乎所有
    Underscore.js 的工具。
- en: This chapter serves as a tour of the Underscore.js library with a special focus
    on managing data. (As a concession to the book’s overall focus on data visualization,
    it also includes several illustrations.) We’ll see many of the Underscore.js utilities
    covered here at work in a larger web application project in the subsequent chapters.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将带领我们深入了解 Underscore.js 库，特别关注数据管理。（作为本书整体专注于数据可视化的妥协，它还包括了一些插图。）在随后的章节中，我们将看到许多本章介绍的
    Underscore.js 工具在一个更大的 Web 应用项目中的实际应用。
- en: Using Functional Programming
  id: totrans-9
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用函数式编程
- en: 'When we’re working with data that’s part of a visualization, we often have
    to iterate through the data one item at a time to transform, extract, or otherwise
    manipulate it to fit our application. Using only the core JavaScript language,
    our code may rely on a `for` loop like the following:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们处理作为可视化一部分的数据时，我们通常需要逐项遍历数据，进行转换、提取或其他方式的操作，以使其适应我们的应用程序。仅使用核心的 JavaScript
    语言时，我们的代码可能会依赖以下的`for`循环：
- en: '[PRE0]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Although this style, known as *imperative programming*, is a common JavaScript
    idiom, it can present a few problems in large, complex applications. In particular,
    it might result in code that’s harder than necessary to debug, test, and maintain.
    This section introduces a different programming style—*functional programming*—that
    eliminates many of those problems. As you’ll see, functional programming can result
    in code that’s much more concise and readable, and therefore often much less error
    prone.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管这种风格，称为 *命令式编程*，是 JavaScript 中常见的习惯用法，但在大型复杂应用程序中，它可能会带来一些问题。特别是，它可能导致调试、测试和维护起来比必要的更加困难。本节介绍了一种不同的编程风格——*函数式编程*，它消除了许多这些问题。正如你将看到的，函数式编程可以使代码更加简洁和可读，因此通常更不容易出错。
- en: 'To compare these two programming styles, let’s consider a simple programming
    problem: writing a function to calculate the Fibonacci numbers. The first two
    Fibonacci numbers are 0 and 1, and subsequent numbers are the sum of the two preceding
    values. The sequence starts like this:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 为了比较这两种编程风格，我们来考虑一个简单的编程问题：编写一个函数来计算斐波那契数列。前两个斐波那契数是 0 和 1，后续的数是前两个数的和。这个数列如下所示：
- en: 0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, . . .
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 0，1，1，2，3，5，8，13，21，34，55，89，...
- en: 'Step 1: Start with an Imperative Version'
  id: totrans-15
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 第 1 步：从命令式版本开始
- en: 'To begin, let’s consider a traditional, imperative approach to the problem.
    Here’s a first attempt:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们来考虑一个传统的命令式方法来解决这个问题。以下是第一次尝试：
- en: '[PRE1]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: This `fib()` function takes as its input a parameter *n* and returns as its
    output the *n*th Fibonacci number. (By convention, the 0th and 1st Fibonacci numbers
    are 0 and 1.)
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 这个 `fib()` 函数的输入是一个参数 *n*，输出是第 *n* 个斐波那契数。（按照惯例，第 0 个和第 1 个斐波那契数是 0 和 1。）
- en: 'Step 2: Debug the Imperative Code'
  id: totrans-19
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 第 2 步：调试命令式代码
- en: If you aren’t checking closely, you might be surprised to find that the preceding
    trivial example contains three bugs. Of course, it’s a contrived example and the
    bugs are deliberate, but can you find all of them without reading any further?
    More to the point, if even a trivial example can hide so many bugs, can you imagine
    what might be lurking in a complex web application?
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你没有仔细检查，可能会惊讶地发现，上面的简单例子中包含了三个错误。当然，这只是一个人为构造的例子，错误是故意设置的，但你能在不继续阅读的情况下找到所有错误吗？更重要的是，如果连一个简单的例子都能隐藏这么多错误，那么你能想象复杂的
    Web 应用程序中可能潜伏着什么问题吗？
- en: To understand why imperative programming can introduce these bugs, let’s fix
    them one at a time.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 为了理解为什么命令式编程会引入这些错误，我们来逐个修复它们。
- en: 'One bug is in the `for` loop:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 一个错误出现在 `for` 循环中：
- en: '[PRE2]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The conditional that determines the loop termination checks for a less-than-or-equal
    (`<=`) value; instead, it should check for a less-than (`<`) value.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 决定循环终止条件的条件检查了一个小于或等于 (`<=`) 的值；但它应该检查一个小于 (`<`) 的值。
- en: 'A second bug occurs in this line:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个错误出现在这一行：
- en: '[PRE3]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Although we think and read left to right (at least in English), JavaScript
    executes multiple assignments from right to left. Instead of shifting the values
    in our variables, this statement simply assigns the value of `f` to all three.
    We need to break the single statement into two:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们从左到右思考和阅读（至少在英语中是这样），但 JavaScript 的赋值是从右到左执行的。这个语句并没有在我们的变量中移位，而是将 `f` 的值赋给了所有三个变量。我们需要将这个单一的语句分成两个：
- en: '[PRE4]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The final bug is the most subtle, and it’s also in the `for` loop. We’re using
    the local variable `i`, but we haven’t declared it. As a result, JavaScript will
    treat it as a global variable. That won’t cause our function to return incorrect
    results, but it could well introduce a conflict—and a hard-to-find bug—elsewhere
    in our application. The correct code declares the variable as local:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 最终的错误是最微妙的，且也出现在 `for` 循环中。我们使用了局部变量 `i`，但并没有声明它。因此，JavaScript 会将其视为全局变量。这样虽然不会导致函数返回错误结果，但可能会在我们应用程序的其他部分引入冲突——并且这是一个难以发现的
    bug。正确的代码应该将该变量声明为局部变量：
- en: '[PRE5]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Step 3: Understand the Problems Imperative Programming May Introduce'
  id: totrans-31
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 第 3 步：理解命令式编程可能引入的问题
- en: The bugs in this short and straightforward piece of code are meant to demonstrate
    some problematic features of imperative programming in general. In particular,
    conditional logic and state variables, by their very nature, tend to invite certain
    errors.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 这段简短而直接的代码中的错误旨在展示命令式编程中一些常见的有问题的特性。特别是，条件逻辑和状态变量，由于其固有特性，往往会引入某些错误。
- en: Consider the first bug. Its error was using an incorrect test (`<=` instead
    of `<`) for the conditional that terminates the loop. Precise conditional logic
    is critical for computer programs, but such precision doesn’t always come naturally
    to most people, including programmers. Conditional logic has to be perfect, and
    sometimes making it perfect is tricky.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑第一个错误。它的错误在于使用了不正确的条件测试（`<=` 而不是 `<`）来终止循环。精确的条件逻辑对于计算机程序至关重要，但这种精确度并非每个人，甚至包括程序员，都会自然掌握。条件逻辑必须是完美的，而有时做到这一点并不容易。
- en: The other two errors both relate to state variables, `f0` and `f1` in the first
    case and `i` in the second. Here again there’s a difference between how programmers
    think and how programs operate. When programmers write the code to iterate through
    the numbers, they’re probably concentrating on the specific problem at hand. It
    may be easy to neglect the potential effect on other areas of the application.
    More technically, state variables can introduce side effects into a program, and
    side effects may result in bugs.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 另外两个错误都与状态变量有关，第一种情况是`f0`和`f1`，第二种情况是`i`。这里再次体现了程序员的思维方式与程序实际操作之间的差异。当程序员编写代码以迭代数字时，他们可能集中精力处理当前特定的问题，可能会忽视对应用程序其他部分的潜在影响。从技术上讲，状态变量会在程序中引入副作用，副作用可能导致程序中的错误。
- en: 'Step 4: Rewrite Using Functional Programming Style'
  id: totrans-35
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '步骤 4: 使用函数式编程风格重写'
- en: Proponents of functional programming claim that by eliminating conditionals
    and state variables, a functional programming style can produce code that’s more
    concise, more maintainable, and less prone to errors than imperative programming.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 函数式编程的支持者认为，通过消除条件语句和状态变量，函数式编程风格可以生成比命令式编程更加简洁、易于维护且更不容易出错的代码。
- en: The “functional” in “functional programming” does not refer to functions in
    programming languages but rather to mathematical functions such as *y*=*f*(*x*).
    Functional programming attempts to emulate mathematical functions in the context
    of computer programming. Instead of iterating over values by using a `for` loop,
    functional programming often uses recursion, where a function calls itself multiple
    times to make a calculation or manipulate values.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: “函数式”在“函数式编程”中的含义并不是指编程语言中的函数，而是指像*y*=*f*(*x*)这样的数学函数。函数式编程试图在计算机编程的背景下模仿数学函数。它通常使用递归来代替通过`for`循环迭代值，在递归中，一个函数会多次调用自身来进行计算或操作值。
- en: 'Here’s how we can implement the Fibonacci algorithm with functional programming:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是我们如何用函数式编程实现斐波那契算法：
- en: '[PRE6]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Notice that this version has no state variables and, except for the edge case
    to handle 0 or 1, no conditional statements. It’s much more concise, and notice
    how the code mirrors almost word-for-word the statement of the original problem:
    “The first two Fibonacci numbers are 0 and 1” corresponds to `n < 2 ? n`, and
    “subsequent numbers are the sum of the two preceding values” corresponds to `fib(n-1)
    + fib(n-2)`.'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，这个版本没有状态变量，除了处理 0 或 1 的边界情况外，也没有条件语句。它简洁得多，而且请注意代码几乎逐字镜像了原问题的陈述：“前两个斐波那契数是
    0 和 1”对应于`n < 2 ? n`，而“后续的数字是前两个值的和”对应于`fib(n-1) + fib(n-2)`。
- en: Functional programming implementations often express the desired outcome directly.
    They can therefore minimize the chance of misinterpretations or errors in an intermediate
    algorithm.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 函数式编程的实现通常直接表达所需的结果。因此，它们可以最大限度地减少中间算法中误解或错误的可能性。
- en: 'Step 5: Evaluate Performance'
  id: totrans-42
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '步骤 5: 评估性能'
- en: From what we’ve seen so far, it may seem that we should always adopt a functional
    programming style. Certainly functional programming has its advantages, but it
    can have some significant disadvantages as well. The Fibonacci code is a perfect
    example. Since functional programming eschews the notion of loops, our example
    relies instead on recursion.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 从我们目前所见，似乎我们应该始终采用函数式编程风格。毫无疑问，函数式编程有其优势，但它也可能有一些显著的缺点。斐波那契代码就是一个完美的例子。由于函数式编程避免使用循环的概念，我们的示例改用递归。
- en: In our specific case the `fib()` function calls itself twice at every level
    until the recursion reaches 0 or 1\. Since each intermediate call itself results
    in more intermediate calls, the number of calls to `fib()` increases exponentially.
    Finding the 28th Fibonacci number by executing `fib(28)` results in over one million
    calls to the `fib()` function.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的特定案例中，`fib()`函数在每一层都会调用自己两次，直到递归达到 0 或 1。由于每次中间调用都会导致更多的中间调用，`fib()`的调用次数呈指数增长。通过执行`fib(28)`来找出第
    28 个斐波那契数时，将导致超过一百万次对`fib()`函数的调用。
- en: As you might imagine, the resulting performance is simply unacceptable. [Table 8-1](ch08.html#execution_times_for_fibleft_parenthesisr
    "Table 8-1. Execution Times for fib()") shows the execution times for both the
    functional and the imperative versions of `fib()`.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你想象的那样，最终的性能是完全无法接受的。[表 8-1](ch08.html#execution_times_for_fibleft_parenthesisr
    "表 8-1. `fib()`的执行时间")展示了`fib()`函数的函数式版本和命令式版本的执行时间。
- en: Table 8-1. Execution Times for fib()
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 表 8-1. `fib()`的执行时间
- en: '| Version | Parameter | Execution time (ms) |'
  id: totrans-47
  prefs: []
  type: TYPE_TB
  zh: '| 版本 | 参数 | 执行时间（毫秒） |'
- en: '| --- | --- | --- |'
  id: totrans-48
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| Imperative | `28` | 0.231 |'
  id: totrans-49
  prefs: []
  type: TYPE_TB
  zh: '| 命令式 | `28` | 0.231 |'
- en: '| Functional | `28` | 296.9 |'
  id: totrans-50
  prefs: []
  type: TYPE_TB
  zh: '| 函数式 | `28` | 296.9 |'
- en: As you can see, the functional programming version is over a thousand times
    slower. In the real world, such performance is rarely acceptable.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，函数式编程版本的执行速度比命令式版本慢了超过一千倍。在实际应用中，这样的性能通常是不可接受的。
- en: 'Step 6: Fix the Performance Problem'
  id: totrans-52
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 步骤 6：解决性能问题
- en: Fortunately, we can reap the benefits of functional programming without suffering
    the performance penalty. We simply turn to the tiny but powerful Underscore.js
    library. As the library’s web page explains,
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，我们可以在不牺牲性能的情况下，享受函数式编程的好处。我们只需要借助小巧却强大的 Underscore.js 库。正如该库的网页所解释的，
- en: Underscore is a utility-belt library for JavaScript that provides . . . functional
    programming support.
  id: totrans-54
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: Underscore 是一个为 JavaScript 提供功能编程支持的工具库。
- en: Of course, we need to include that library in our web pages. If you’re including
    libraries individually, Underscore.js is available on many content distribution
    networks, such as CloudFlare.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，我们需要在网页中包含这个库。如果你是单独引入库，Underscore.js 可以通过许多内容分发网络提供，例如 CloudFlare。
- en: '[PRE7]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: With Underscore.js in place, we can now optimize the performance of our Fibonacci
    implementation.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Underscore.js 后，我们现在可以优化我们的 Fibonacci 实现的性能。
- en: The problem with the recursive implementation is that it results in many unnecessary
    calls to `fib()`. For example, executing `fib(28)` requires more than 100,000
    calls to `fib(3)`. And each time `fib(3)` is called, the return value is re calculated
    from scratch. It would be better if the implementation called `fib(3)` only once,
    and every subsequent time it needed to know the value of `fib(3)` it reused the
    previous result instead of recalculating it from scratch. In effect, we’d like
    to implement a cache in front of the `fib()` function. The cache could eliminate
    the repetitive calculations.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 递归实现的问题在于它会导致很多不必要的 `fib()` 调用。例如，执行 `fib(28)` 会需要超过 100,000 次对 `fib(3)` 的调用。而每次调用
    `fib(3)` 时，返回值都会从头开始重新计算。如果实现只在第一次调用时调用 `fib(3)`，然后每次需要知道 `fib(3)` 的值时都能重用之前的结果，而不是重新计算，这将会更好。实际上，我们希望在
    `fib()` 函数前实现一个缓存。这个缓存可以消除重复计算。
- en: 'This approach is known as *memoizing*, and the Underscore.js library has a
    simple method to automatically and transparently memoize JavaScript functions.
    Not surprisingly, that method is called `memoize()`. To use it, we first wrap
    the function we want to memoize within the Underscore object. Just as jQuery uses
    the dollar sign (`$`) for wrapping, Underscore.js uses the underscore character
    (`_`). After wrapping our function, we simply call the `memoize()` method. Here’s
    the complete code:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法被称为 *记忆化*，而 Underscore.js 库提供了一个简单的方法来自动透明地记忆化 JavaScript 函数。毫不奇怪，这个方法叫做
    `memoize()`。为了使用它，我们首先将想要记忆化的函数包裹在 Underscore 对象内。就像 jQuery 使用美元符号（`$`）进行包装一样，Underscore.js
    使用下划线字符（`_`）。在包装好函数后，我们只需调用 `memoize()` 方法。以下是完整代码：
- en: '[PRE8]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: As you can see, we haven’t really lost any of the readability or conciseness
    of functional programming. And it would still be a challenge to introduce a bug
    in this implementation. The only real change is performance, and it’s substantially
    better, as shown in [Table 8-2](ch08.html#execution_times_for_fibleft_pare-id00041
    "Table 8-2. Execution Times for fib(), Continued").
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，我们实际上并没有失去函数式编程的可读性或简洁性。而且，在这个实现中引入一个 bug 依然会是一个挑战。唯一真正的变化是性能，它明显更好，如[表
    8-2](ch08.html#execution_times_for_fibleft_pare-id00041 "表 8-2. fib() 执行时间，续")所示。
- en: Table 8-2. Execution Times for fib(), Continued
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 表 8-2. fib() 执行时间，续
- en: '| Version | Parameter | Execution time (ms) |'
  id: totrans-63
  prefs: []
  type: TYPE_TB
  zh: '| 版本 | 参数 | 执行时间（毫秒） |'
- en: '| --- | --- | --- |'
  id: totrans-64
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| Imperative `fib()` | `28` | 0.231 |'
  id: totrans-65
  prefs: []
  type: TYPE_TB
  zh: '| 命令式 `fib()` | `28` | 0.231 |'
- en: '| Functional `fib()` | `28` | 296.9 |'
  id: totrans-66
  prefs: []
  type: TYPE_TB
  zh: '| 函数式 `fib()` | `28` | 296.9 |'
- en: '| Memoized `fib()` | `28` | 0.352 |'
  id: totrans-67
  prefs: []
  type: TYPE_TB
  zh: '| 记忆化 `fib()` | `28` | 0.352 |'
- en: Just by including the Underscore.js library and using one of its methods, our
    functional implementation has nearly the same performance as the imperative version.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 只需包含 Underscore.js 库并使用它的其中一个方法，我们的函数式实现就几乎与命令式版本的性能相同。
- en: For the rest of this chapter, we’ll look at many of the other improvements and
    utilities that Underscore.js provides. With its support for functional programming,
    Underscore.js makes it significantly easier to work with data in the browser.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的剩余部分，我们将介绍 Underscore.js 提供的许多其他改进和实用工具。通过对函数式编程的支持，Underscore.js 使得在浏览器中处理数据变得更加容易。
- en: Working with Arrays
  id: totrans-70
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 处理数组
- en: If your visualization relies on a significant amount of data, that data is most
    likely contained in arrays. Unfortunately, it’s very tempting to resort to imperative
    programming when you are working with arrays. Arrays suggest the use of programming
    loops, and, as we saw earlier, programming loops are an imperative construct that
    often causes errors. If we can avoid loops and rely on functional programming
    instead, we can improve the quality of our JavaScript. The core JavaScript language
    includes a few utilities and methods to help applications cope with arrays in
    a functional style, but Underscore.js adds many others. This section describes
    many of the Underscore.js array utilities that are most helpful for data visualizations.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的可视化依赖大量数据，那么这些数据很可能存储在数组中。不幸的是，当你处理数组时，很容易陷入命令式编程的陷阱。数组暗示着使用编程循环，而正如我们之前所看到的，编程循环是一种命令式构造，通常会导致错误。如果我们能避免使用循环，转而依赖函数式编程，我们就能提高
    JavaScript 的质量。核心的 JavaScript 语言包含一些用于以函数式风格处理数组的工具和方法，但 Underscore.js 增加了许多其他工具。本节将介绍许多
    Underscore.js 中最有助于数据可视化的数组工具。
- en: Extracting Elements by Position
  id: totrans-72
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 按位置提取元素
- en: If you need only a subset of an array for your visualization, Underscore.js
    has many utilities that make it easy to extract the right one. For the following
    examples, we’ll consider a simple array (shown in [Figure 8-1](ch08.html#underscoredotjs_has_many_utilities_to_ma
    "Figure 8-1. Underscore.js has many utilities to make working with arrays easy.")).
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你只需要数组中的一部分元素来进行可视化，Underscore.js 提供了许多工具，使得提取合适的元素变得简单。在接下来的例子中，我们将考虑一个简单的数组（如
    [图 8-1](ch08.html#underscoredotjs_has_many_utilities_to_ma "图 8-1. Underscore.js
    提供了许多实用工具，使得处理数组变得更加容易。")）所示。
- en: '[PRE9]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '![Underscore.js has many utilities to make working with arrays easy.](figs/web/08fig01.png)Figure 8-1. Underscore.js
    has many utilities to make working with arrays easy.'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '![Underscore.js 提供了许多实用工具，使得处理数组变得更加容易。](figs/web/08fig01.png)图 8-1. Underscore.js
    提供了许多实用工具，使得处理数组变得更加容易。'
- en: 'Underscore.js’s `first()` method provides a simple way to extract the first
    element of an array, or the first *n* elements (see [Figure 8-2](ch08.html#firstleft_parenthesisright_parenthesis_f
    "Figure 8-2. The first() function returns the first element or the first n elements
    in an array.")):'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: Underscore.js 的 `first()` 方法提供了一种简单的方法来提取数组中的第一个元素，或前 *n* 个元素（参见 [图 8-2](ch08.html#firstleft_parenthesisright_parenthesis_f
    "图 8-2. `first()` 函数返回数组中的第一个元素或前 n 个元素。")）：
- en: '[PRE10]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '![The first() function returns the first element or the first n elements in
    an array.](figs/web/08fig02.png.jpg)Figure 8-2. The `first()` function returns
    the first element or the first n elements in an array.'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '![first() 函数返回数组中的第一个元素或前 n 个元素。](figs/web/08fig02.png.jpg)图 8-2. `first()`
    函数返回数组中的第一个元素或前 n 个元素。'
- en: Notice that `first()` (without any parameter) returns a simple element, while
    `first(n)` returns an array of elements. That means, for example, that `first()`
    and `first(1)` have different return values (`1` versus `[1]` in the example).
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，`first()`（不传递任何参数）返回一个简单的元素，而 `first(n)` 返回一个元素数组。这意味着，例如，`first()` 和 `first(1)`
    返回的值是不同的（在例子中分别是 `1` 和 `[1]`）。
- en: As you might expect, Underscore.js also has a `last()` method to extract elements
    from the end of an array (see [Figure 8-3](ch08.html#lastleft_parenthesisright_parenthesis_fu
    "Figure 8-3. The last() function returns the last element or the last n elements
    in an array.")).
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你可能预期的那样，Underscore.js 也有一个 `last()` 方法，用于从数组的末尾提取元素（参见 [图 8-3](ch08.html#lastleft_parenthesisright_parenthesis_fu
    "图 8-3. `last()` 函数返回数组中的最后一个元素或最后 n 个元素。")）。
- en: '[PRE11]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '![The last() function returns the last element or the last n elements in an
    array.](figs/web/08fig03.png.jpg)Figure 8-3. The `last()` function returns the
    last element or the last n elements in an array.'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '![last() 函数返回数组中的最后一个元素或最后 n 个元素。](figs/web/08fig03.png.jpg)图 8-3. `last()`
    函数返回数组中的最后一个元素或最后 n 个元素。'
- en: Without any parameters, `last()` returns the last element in the array. With
    a parameter `n`, it returns a new array with the last *n* elements from the original.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 如果不传递任何参数，`last()` 返回数组中的最后一个元素。传递参数 `n` 时，它返回一个包含原数组中最后 *n* 个元素的新数组。
- en: The more general versions of both of these functions (`.first(3)` and `.last(3)`)
    would require some potentially tricky (and error-prone) code to implement in an
    imperative style. In the functional style that Underscore.js supports, however,
    our code is clean and simple.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个函数（`.first(3)`和`.last(3)`）的更通用版本在命令式编程风格中可能需要编写一些复杂（且容易出错）的代码。然而，在Underscore.js支持的函数式编程风格中，我们的代码简洁且清晰。
- en: What if you want to extract from the beginning of the array, but instead of
    knowing how many elements you want to include in the result, you know only how
    many elements you want to omit? In other words, you need “all but the last *n*”
    elements. The `initial()` method performs this extraction (see [Figure 8-4](ch08.html#initialleft_parenthesisright_parenthesis
    "Figure 8-4. The initial() function returns all but the last element or all but
    the last n elements in an array.")). As with all of these methods, if you omit
    the optional parameter, Underscore.js assumes a value of `1`.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想从数组的开头提取元素，但不是通过知道要包含多少个元素来决定，而是知道你想要跳过多少个元素呢？换句话说，你需要“除去最后 *n* 个”元素。`initial()`方法可以执行这个提取操作（见[图8-4](ch08.html#initialleft_parenthesisright_parenthesis
    "图8-4. `initial()`函数返回数组中除了最后一个元素或除了最后n个元素的所有元素。")）。与所有这些方法一样，如果你省略了可选参数，Underscore.js会假定其值为`1`。
- en: '[PRE12]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '![The initial() function returns all but the last element or all but the last
    n elements in an array.](figs/web/08fig04.png.jpg)Figure 8-4. The `initial()`
    function returns all but the last element or all but the last n elements in an
    array.'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '![`initial()`函数返回数组中除了最后一个元素或除了最后n个元素的所有元素。](figs/web/08fig04.png.jpg)图8-4.
    `initial()`函数返回数组中除了最后一个元素或除了最后n个元素的所有元素。'
- en: Finally, you may need the opposite of `initial()`. The `rest()` method skips
    past a defined number of elements in the beginning of the array and returns whatever
    remains (see [Figure 8-5](ch08.html#restleft_parenthesisright_parenthesis_fu "Figure 8-5. The
    rest() function returns all but the first element or all but the first n elements
    in an array.")).
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，你可能需要`initial()`的相反操作。`rest()`方法跳过数组开头的定义数量的元素，返回剩余的元素（见[图8-5](ch08.html#restleft_parenthesisright_parenthesis_fu
    "图8-5. `rest()`函数返回数组中除了第一个元素或除了前n个元素的所有元素。")）。
- en: '[PRE13]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '![The rest() function returns all but the first element or all but the first
    n elements in an array.](figs/web/08fig05.png.jpg)Figure 8-5. The `rest()` function
    returns all but the first element or all but the first n elements in an array.'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '![`rest()`函数返回数组中除了第一个元素或除了前n个元素的所有元素。](figs/web/08fig05.png.jpg)图8-5. `rest()`函数返回数组中除了第一个元素或除了前n个元素的所有元素。'
- en: Again, these functions would be tricky to implement using traditional, imperative
    programming, but they are a breeze with Underscore.js.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，使用传统的命令式编程实现这些功能会很棘手，但在Underscore.js中，这些操作非常简单。
- en: Combining Arrays
  id: totrans-92
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 合并数组
- en: Underscore.js includes another set of utilities for combining two or more arrays.
    These include functions that mimic standard mathematical *set* operations, as
    well as more-sophisticated combinations. For the next few examples, we’ll use
    two arrays, one containing the first few Fibonacci numbers and the other containing
    the first five even integers (see [Figure 8-6](ch08.html#underscoredotjs_also_has_many_utilities
    "Figure 8-6. Underscore.js also has many utilities to work with multiple arrays.")).
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: Underscore.js包含了一组用于合并两个或更多数组的工具。这些工具包括模拟标准数学*集合*运算的函数，以及更复杂的合并方式。在接下来的几个例子中，我们将使用两个数组，一个包含前几个斐波那契数，另一个包含前五个偶数（见[图8-6](ch08.html#underscoredotjs_also_has_many_utilities
    "图8-6. Underscore.js 还拥有许多用于处理多个数组的工具.")））。
- en: '[PRE14]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '![Underscore.js also has many utilities to work with multiple arrays.](figs/web/08fig06.png)Figure 8-6. Underscore.js
    also has many utilities to work with multiple arrays.'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '![Underscore.js 还拥有许多用于处理多个数组的工具。](figs/web/08fig06.png)图8-6. Underscore.js
    还拥有许多用于处理多个数组的工具。'
- en: The `union()` method is a straightforward combination of multiple arrays. It
    returns an array containing all elements that are in any of the inputs, and it
    removes any duplicates ([Figure 8-7](ch08.html#unionleft_parenthesisright_parenthesis_f
    "Figure 8-7. The union() function creates the union of multiple arrays, removing
    any duplicates.")).
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '`union()`方法是一个直接的多个数组合并方式。它返回一个包含所有输入元素的数组，并移除任何重复的元素（见[图8-7](ch08.html#unionleft_parenthesisright_parenthesis_f
    "图8-7. `union()`函数创建多个数组的并集，移除任何重复项。")）。'
- en: '[PRE15]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '![The union() function creates the union of multiple arrays, removing any duplicates.](figs/web/08fig07.png.jpg)Figure 8-7. The
    `union()` function creates the union of multiple arrays, removing any duplicates.'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '![union() 函数创建多个数组的并集，去除重复元素。](figs/web/08fig07.png.jpg)图 8-7. `union()` 函数创建多个数组的并集，去除重复元素。'
- en: Notice that `union()` removes duplicates whether they appear in separate inputs
    (`0`, `2`, and `8`) or in the same array (`1`).
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`union()` 会去除重复元素，无论它们是出现在不同的输入中（如 `0`、`2` 和 `8`），还是出现在同一个数组中（如 `1`）。
- en: Note
  id: totrans-100
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '**Although this chapter considers combinations of just two arrays, most Underscore.js
    methods can accept an unlimited number of parameters. For example, `_.union(a,b,c,d,e)`
    returns the union of five different arrays. You can even find the union of an
    array of arrays with the JavaScript `apply()` function with something like `_.union.prototype.apply(this,
    arrOfArrs)`.**'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '**尽管本章只讨论了两个数组的组合，但大多数 Underscore.js 方法都能接受无限数量的参数。例如，`_.union(a,b,c,d,e)`
    返回五个不同数组的并集。你甚至可以使用 JavaScript 的 `apply()` 函数来查找数组的数组的并集，方法是像 `_.union.prototype.apply(this,
    arrOfArrs)` 这样。**'
- en: The `intersection()` method acts just as you would expect, returning only those
    elements that appear in all of the input arrays ([Figure 8-8](ch08.html#intersectionleft_parenthesisright_parent
    "Figure 8-8. The intersection() function returns elements in common among multiple
    arrays.")).
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '`intersection()` 方法的作用正如你所预期的，返回所有输入数组中都出现的元素（[图 8-8](ch08.html#intersectionleft_parenthesisright_parent
    "图 8-8. intersection() 函数返回多个数组中共有的元素。")）。'
- en: '[PRE16]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '![The intersection() function returns elements in common among multiple arrays.](figs/web/08fig08.png.jpg)Figure 8-8. The
    `intersection()` function returns elements in common among multiple arrays.'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '![intersection() 函数返回多个数组中共有的元素。](figs/web/08fig08.png.jpg)图 8-8. `intersection()`
    函数返回多个数组中共有的元素。'
- en: The `difference()` method is the opposite of `intersection()`. It returns those
    elements in the first input array that are *not* present in the other inputs ([Figure 8-9](ch08.html#differenceleft_parenthesisright_parenthe
    "Figure 8-9. The difference() function returns elements that are present only
    in the first of multiple arrays.")).
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '`difference()` 方法是 `intersection()` 的反操作。它返回那些仅存在于第一个输入数组中、而不在其他输入数组中的元素（[图
    8-9](ch08.html#differenceleft_parenthesisright_parenthe "图 8-9. difference() 函数返回仅存在于多个数组中的第一个数组的元素。")）。'
- en: '[PRE17]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '![The difference() function returns elements that are present only in the first
    of multiple arrays.](figs/web/08fig09.png.jpg)Figure 8-9. The `difference()` function
    returns elements that are present only in the first of multiple arrays.'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '![difference() 函数返回仅存在于多个数组中的第一个数组的元素。](figs/web/08fig09.png.jpg)图 8-9. `difference()`
    函数返回仅存在于多个数组中的第一个数组的元素。'
- en: If you need to eliminate duplicate elements but have only one array—making `union()`
    inappropriate—then you can use the `uniq()` method ([Figure 8-10](ch08.html#uniqleft_parenthesisright_parenthesis_fu
    "Figure 8-10. The uniq() function removes duplicate elements from an array.")).
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你需要消除重复元素，但只有一个数组—这使得 `union()` 不适用—那么你可以使用 `uniq()` 方法（[图 8-10](ch08.html#uniqleft_parenthesisright_parenthesis_fu
    "图 8-10. uniq() 函数从数组中去除重复元素。")）。
- en: '[PRE18]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '![The uniq() function removes duplicate elements from an array.](figs/web/08fig10.png.jpg)Figure 8-10. The
    `uniq()` function removes duplicate elements from an array.'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '![uniq() 函数从数组中去除重复元素。](figs/web/08fig10.png.jpg)图 8-10. `uniq()` 函数从数组中去除重复元素。'
- en: Finally, Underscore.js has a `zip()` method. Its name doesn’t come from the
    popular compression algorithm but rather because it acts a bit like a zipper.
    It takes multiple input arrays and combines them, element by element, into an
    output array. That output is an array of arrays, where the inner arrays are the
    combined elements.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，Underscore.js 还有一个 `zip()` 方法。它的名字并非来源于流行的压缩算法，而是因为它的作用有点像拉链。它接受多个输入数组，并将它们按元素逐个组合成一个输出数组。该输出是一个数组的数组，其中内层数组是组合后的元素。
- en: '[PRE19]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The operation is perhaps most clearly understood through a picture; see [Figure 8-11](ch08.html#zipleft_parenthesisright_parenthesis_fun
    "Figure 8-11. The zip() function pairs elements from multiple arrays together
    into a single array.").
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 通过图示理解这一操作可能最为清晰；请参见[图 8-11](ch08.html#zipleft_parenthesisright_parenthesis_fun
    "图 8-11. zip() 函数将多个数组的元素配对，组合成一个单一的数组。")。
- en: '![The zip() function pairs elements from multiple arrays together into a single
    array.](figs/web/08fig11.png.jpg)Figure 8-11. The *zip()* function pairs elements
    from multiple arrays together into a single array.'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '![zip()函数将多个数组中的元素配对成一个单一的数组。](figs/web/08fig11.png.jpg)图 8-11. *zip()* 函数将多个数组中的元素配对成一个单一的数组。'
- en: This example demonstrates an alternative style for Underscore.js. Instead of
    wrapping an array within the `_` object as we’ve done so far, we call the `zip()`
    method on the `_` object itself. The alternative style seems a better fit for
    the underlying functionality in this case, but if you prefer `_(naturals).zip(prime)`,
    you’ll get the exact same result.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子展示了Underscore.js的另一种风格。与之前将数组包装在`_`对象中不同，我们直接在`_`对象本身上调用`zip()`方法。在这种情况下，这种替代风格似乎更适合底层功能，但如果你更喜欢`_(naturals).zip(prime)`，你也会得到完全相同的结果。
- en: Removing Invalid Data Values
  id: totrans-116
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 移除无效数据值
- en: One of the banes of visualization applications is invalid data values. Although
    we’d like to think that our data sources ensure that all the data they provide
    is scrupulously correct, that is, unfortunately, rarely the case. More seriously,
    if JavaScript encounters an invalid value, the most common result is an *unhandled
    exception*, which halts all further JavaScript execution on the page.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 可视化应用程序的一个大问题是无效数据值。虽然我们希望数据源能够确保所有提供的数据都是严格正确的，但遗憾的是，情况往往并非如此。更严重的是，如果JavaScript遇到无效值，最常见的结果是一个*未处理的异常*，这将停止页面上所有后续的JavaScript执行。
- en: To avoid such an unpleasant error, we should validate all data sets and remove
    invalid values before we pass the data to graphing or charting libraries. Underscore.js
    has several utilities to help.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免出现这种令人不愉快的错误，我们应该验证所有数据集，并在将数据传递给图表或图形库之前移除无效值。Underscore.js提供了多个工具来帮助完成这项工作。
- en: The simplest of these Underscore.js methods is `compact()`. This function removes
    any data values that JavaScript treats as `false` from the input arrays. Eliminated
    values include the Boolean value `false`, the numeric value `0`, an empty string,
    and the special values `NaN` (not a number; for example, `1/0`), `undefined`,
    and `null`.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 这些Underscore.js方法中最简单的是`compact()`。此函数会从输入数组中移除JavaScript视为`false`的任何数据值。被移除的值包括布尔值`false`、数字值`0`、空字符串以及特殊值`NaN`（非数字，例如`1/0`）、`undefined`和`null`。
- en: '[PRE20]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: It is worth emphasizing that `compact()` removes elements with a value of `0`.
    If you use `compact()` to clean a data array, be sure that `0` isn’t a valid data
    value in your data set.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 值得强调的是，`compact()`会移除值为`0`的元素。如果你使用`compact()`来清理数据数组，请确保`0`在你的数据集中不是有效的数据值。
- en: Another common problem with raw data is excessively nested arrays. If you want
    to eliminate extra nesting levels from a data set, the `flatten()` method is available
    to help.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 原始数据的另一个常见问题是过度嵌套的数组。如果你想从数据集中消除额外的嵌套层级，可以使用`flatten()`方法。
- en: '[PRE21]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: By default, `flatten()` removes all nesting, even multiple levels of nesting,
    from arrays. If you set the `shallow` parameter to `true`, however, it removes
    only a single level of nesting.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，`flatten()`会移除所有的嵌套层级，包括多级嵌套。如果你将`shallow`参数设置为`true`，它只会移除单一层级的嵌套。
- en: '[PRE22]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Finally, if you have specific values that you want to eliminate from an array,
    you can use the `without()` method. Its parameters provide a list of values that
    the function should remove from the input array.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，如果你有特定的值想从数组中删除，可以使用`without()`方法。它的参数提供了一个值的列表，函数应该从输入数组中移除这些值。
- en: '[PRE23]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Finding Elements in an Array
  id: totrans-128
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在数组中查找元素
- en: JavaScript has always defined the `indexOf()` method for strings. It returns
    the position of a given substring within a larger string. Recent versions of JavaScript
    have added this method to array objects, so you can easily find the first occurrence
    of a given value in an array. Unfortunately, older browsers (specifically IE8
    and earlier) don’t support this method.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript一直为字符串定义了`indexOf()`方法。它返回给定子字符串在更大字符串中的位置。JavaScript的最新版本已将此方法添加到数组对象中，因此你可以轻松找到数组中给定值的第一次出现。不幸的是，旧版浏览器（特别是IE8及更早版本）不支持此方法。
- en: Underscore.js provides its own `indexOf()` method to fill the gap those older
    browsers create. If Underscore.js finds itself running in an environment with
    native support for array `indexOf`, then it defers to the native method to avoid
    any performance penalty.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: Underscore.js提供了自己的`indexOf()`方法，以填补旧浏览器造成的空白。如果Underscore.js发现自己运行在支持原生数组`indexOf`方法的环境中，那么它会调用原生方法，以避免性能上的损失。
- en: '[PRE24]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: To begin your search somewhere in the middle of the array, you can specify that
    starting position as the second argument to `indexOf()`.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想从数组的中间某个位置开始搜索，可以将起始位置作为第二个参数传递给 `indexOf()`。
- en: '[PRE25]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: You can also search backward from the end of an array using the `lastIndexOf()`
    method.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以使用 `lastIndexOf()` 方法从数组的末尾反向搜索。
- en: '[PRE26]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: If you don’t want to start at the very end of the array, you can pass in the
    starting index as an optional parameter.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不想从数组的末尾开始，可以将起始索引作为可选参数传入。
- en: Underscore.js provides a few helpful optimizations for sorted arrays. Both the
    `uniq()` and the `indexOf()` methods accept an optional Boolean parameter. If
    that parameter is `true`, then the functions assume that the array is sorted.
    The performance improvements this assumption allows can be especially significant
    for large data sets.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: Underscore.js 提供了一些对排序数组有帮助的优化。`uniq()` 和 `indexOf()` 方法都接受一个可选的布尔参数。如果该参数为
    `true`，那么这两个函数会假设数组是已排序的。这种假设带来的性能提升，对于大数据集来说尤其显著。
- en: The library also includes the special `sortedIndex()` function. This function
    also assumes that the input array is sorted. It finds the position at which a
    specific value *should* be inserted to maintain the array’s sort order.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 该库还包含了一个特殊的 `sortedIndex()` 函数。该函数同样假设输入的数组是已排序的。它会找到一个位置，在该位置插入特定值，以保持数组的排序顺序。
- en: '[PRE27]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: If you have a custom sorting function, you can pass that to `sortedIndex()`
    as well.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你有一个自定义的排序函数，也可以将其传递给 `sortedIndex()`。
- en: Generating Arrays
  id: totrans-141
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 生成数组
- en: The final array utility I’ll mention is a convenient method to generate arrays.
    The `range()` method tells Underscore.js to create an array with the specified
    number of elements. You may also specify a starting value (the default is `0`)
    and the increment between adjacent values (the default is `1`).
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 我将提到的最后一个数组工具是一个生成数组的便捷方法。`range()` 方法会告诉 Underscore.js 创建一个具有指定数量元素的数组。你还可以指定一个起始值（默认值为
    `0`）和相邻值之间的增量（默认值为 `1`）。
- en: '[PRE28]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: The `range()` function can be quite useful if you need to generate x-axis values
    to match an array of y-axis values.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '`range()` 函数在你需要生成与 y 轴值数组匹配的 x 轴值时，非常有用。'
- en: '[PRE29]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Here we use `range()` to generate the matching x-axis values, and use `zip()`
    to combine them with the y-values.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用 `range()` 来生成匹配的 x 轴值，并使用 `zip()` 将它们与 y 值组合。
- en: Enhancing Objects
  id: totrans-147
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 增强对象
- en: Although the previous section’s examples show numeric arrays, often our visualization
    data consists of JavaScript objects instead of simple numbers. That’s especially
    likely if we get the data via a REST interface, because such interfaces almost
    always deliver data in JavaScript Object Notation (JSON). If we need to enhance
    or transform objects without resorting to imperative constructs, Underscore.js
    has another set of utilities that can help. For the following examples, we can
    use a simple `pizza` object (see [Figure 8-12](ch08.html#underscoredotjs_has_many_utilities_for_w
    "Figure 8-12. Underscore.js has many utilities for working with arbitrary JavaScript
    objects.")).
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管前面章节的示例展示了数字数组，但我们可视化的数据通常是 JavaScript 对象，而非简单的数字。如果我们通过 REST 接口获取数据，这种情况尤其常见，因为这些接口几乎总是以
    JavaScript 对象表示法（JSON）形式传递数据。如果我们需要增强或转换对象，而不使用命令式的构造，Underscore.js 还提供了另一组工具可以帮助我们。以下示例中，我们可以使用一个简单的
    `pizza` 对象（见 [图 8-12](ch08.html#underscoredotjs_has_many_utilities_for_w "图 8-12.
    Underscore.js 提供了许多用于处理任意 JavaScript 对象的工具。")）。
- en: '[PRE30]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '![Underscore.js has many utilities for working with arbitrary JavaScript objects.](figs/web/08fig12.png)Figure 8-12. Underscore.js
    has many utilities for working with arbitrary JavaScript objects.'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '![Underscore.js 提供了许多用于处理任意 JavaScript 对象的工具。](figs/web/08fig12.png)图 8-12.
    Underscore.js 提供了许多用于处理任意 JavaScript 对象的工具。'
- en: Working with Keys and Values
  id: totrans-151
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 操作键和值
- en: Underscore.js includes several methods to work with the keys and values that
    make up objects. For example, the `keys()` function creates an array consisting
    solely of an object’s keys (see [Figure 8-13](ch08.html#keysleft_parenthesisright_parenthesis_fu
    "Figure 8-13. The keys() function returns the keys of an object as an array.")).
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: Underscore.js 包含了多个方法用于操作构成对象的键和值。例如，`keys()` 函数会创建一个仅包含对象键的数组（见 [图 8-13](ch08.html#keysleft_parenthesisright_parenthesis_fu
    "图 8-13. `keys()` 函数将对象的键作为数组返回。")）。
- en: '[PRE31]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: '![The keys() function returns the keys of an object as an array.](figs/web/08fig13.png.jpg)Figure 8-13. The
    `keys()` function returns the keys of an object as an array.'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '![`keys()` 函数将对象的键作为数组返回。](figs/web/08fig13.png.jpg)图 8-13. `keys()` 函数将对象的键作为数组返回。'
- en: Similarly, the `values()` function creates an array consisting solely of an
    object’s values ([Figure 8-14](ch08.html#valuesleft_parenthesisright_parenthesis
    "Figure 8-14. The values() function returns just the values of an object as an
    array.")).
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，`values()` 函数创建一个只包含对象值的数组（[图 8-14](ch08.html#valuesleft_parenthesisright_parenthesis
    "图 8-14. `values()` 函数返回对象的值作为数组")）。
- en: '[PRE32]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: '![The values() function returns just the values of an object as an array.](figs/web/08fig14.png.jpg)Figure 8-14. The
    `values()` function returns just the values of an object as an array.'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: '![values()函数返回对象的值作为数组](figs/web/08fig14.png.jpg)图 8-14. `values()` 函数返回对象的值作为数组。'
- en: The `pairs()` function creates a two-dimensional array. Each element of the
    outer array is itself an array that contains an object’s key and its corresponding
    value ([Figure 8-15](ch08.html#pairsleft_parenthesisright_parenthesis_f "Figure 8-15. The
    pairs() function converts an object into an array of array pairs.")).
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: '`pairs()` 函数创建一个二维数组。外层数组的每个元素本身就是一个数组，包含对象的键及其对应的值（[图 8-15](ch08.html#pairsleft_parenthesisright_parenthesis_f
    "图 8-15. `pairs()` 函数将对象转换为数组对")）。'
- en: '[PRE33]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: '![The pairs() function converts an object into an array of array pairs.](figs/web/08fig15.png)Figure 8-15. The
    `pairs()` function converts an object into an array of array pairs.'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '![pairs()函数将对象转换为数组对](figs/web/08fig15.png)图 8-15. `pairs()` 函数将对象转换为数组对。'
- en: To reverse this transformation and convert an array into an object, we can use
    the `object()` function.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 要反转这个转换并将数组转换为对象，我们可以使用 `object()` 函数。
- en: '[PRE34]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Finally, we can swap the roles of keys and values in an object with the `invert()`
    function ([Figure 8-16](ch08.html#invertleft_parenthesisright_parenthesis "Figure 8-16. The
    invert() function swaps keys and values in an object.")).
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们可以使用 `invert()` 函数交换对象中键和值的角色（[图 8-16](ch08.html#invertleft_parenthesisright_parenthesis
    "图 8-16. `invert()` 函数交换对象中的键和值")）。
- en: '[PRE35]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: '![The invert() function swaps keys and values in an object.](figs/web/08fig16.png)Figure 8-16. The
    `invert()` function swaps keys and values in an object.'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: '![invert()函数交换对象中的键和值](figs/web/08fig16.png)图 8-16. `invert()` 函数交换对象中的键和值。'
- en: As the preceding example shows, Underscore.js can even invert an object if the
    value isn’t a simple type. In this case it takes an array, `["pepperoni","sausage"]`,
    and converts it to a value by joining the individual array elements with commas,
    creating the key `"pepperoni,sausage"`.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 如前面的示例所示，Underscore.js 甚至可以反转一个对象，即使其值不是简单类型。在这种情况下，它将一个数组 `["pepperoni","sausage"]`
    转换为值，通过用逗号连接各个数组元素，生成键 `"pepperoni,sausage"`。
- en: 'Note also that JavaScript requires that all of an object’s keys are unique.
    That’s not necessarily the case for values. If you have an object in which multiple
    keys have the same value, then `invert()` keeps only the last of those keys in
    the inverted object. For example, `_({key1: value, key2: value}).invert()` returns
    `{value: key2}`.'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: '还需注意，JavaScript 要求对象的所有键必须是唯一的，但这不一定适用于值。如果一个对象中有多个键具有相同的值，则 `invert()` 只会保留反转对象中最后一个键。例如，`_({key1:
    value, key2: value}).invert()` 返回 `{value: key2}`。'
- en: Cleaning Up Object Subsets
  id: totrans-168
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 清理对象子集
- en: When you want to clean up an object by eliminating unnecessary attributes, you
    can use Underscore.js’s `pick()` function. Simply pass it a list of attributes
    that you want to retain ([Figure 8-17](ch08.html#pickleft_parenthesisright_parenthesis_fu
    "Figure 8-17. The pick() function selects specific properties from an object.")).
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 当你想通过删除不必要的属性来清理对象时，可以使用 Underscore.js 的 `pick()` 函数。只需传递一个你想保留的属性列表（[图 8-17](ch08.html#pickleft_parenthesisright_parenthesis_fu
    "图 8-17. `pick()` 函数从对象中选择特定的属性")）。
- en: '[PRE36]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: '![The pick() function selects specific properties from an object.](figs/web/08fig17.png.jpg)Figure 8-17. The
    `pick()` function selects specific properties from an object.'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: '![pick()函数从对象中选择特定属性](figs/web/08fig17.png.jpg)图 8-17. `pick()` 函数从对象中选择特定属性。'
- en: We can also do the opposite of `pick()` by using `omit()` and listing the attributes
    that we want to delete ([Figure 8-18](ch08.html#omitleft_parenthesisright_parenthesis_fu
    "Figure 8-18. The omit() function removes properties from an object.")). Underscore.js
    keeps all the other attributes in the object.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以通过使用 `omit()` 来执行 `pick()` 的相反操作，并列出我们想删除的属性（[图 8-18](ch08.html#omitleft_parenthesisright_parenthesis_fu
    "图 8-18. `omit()` 函数从对象中移除属性")）。Underscore.js 会保留对象中的其他所有属性。
- en: '[PRE37]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: '![The omit() function removes properties from an object.](figs/web/08fig18.png.jpg)Figure 8-18. The
    `omit()` function removes properties from an object.'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: '![omit()函数从对象中移除属性。](figs/web/08fig18.png.jpg)图8-18. `omit()`函数从对象中移除属性。'
- en: Updating Attributes
  id: totrans-175
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 更新属性
- en: When you are updating objects, a common requirement is to make sure that an
    object includes certain attributes and that those attributes have appropriate
    default values. Underscore.js includes two utilities for this purpose.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 在更新对象时，一个常见的需求是确保一个对象包含某些属性，并且这些属性有合适的默认值。Underscore.js为此目的提供了两个工具。
- en: 'The two utilities, `extend()` and `defaults()`, both start with one object
    and adjust its properties based on those of other objects. If the secondary objects
    include attributes that the original object lacks, these utilities add those properties
    to the original. The utilities differ in how they handle properties that are already
    present in the original. The `extend()` function overrides the original properties
    with new values (see [Figure 8-19](ch08.html#extendleft_parenthesisright_parenthesis
    "Figure 8-19. The extend() function updates and adds missing properties to an
    object.")):'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个工具，`extend()`和`defaults()`，都以一个对象开始，并根据其他对象的属性调整它的属性。如果次要对象包含原始对象缺少的属性，这些工具会将这些属性添加到原始对象中。这些工具的区别在于它们如何处理原始对象中已存在的属性。`extend()`函数会用新值覆盖原始属性（见[图8-19](ch08.html#extendleft_parenthesisright_parenthesis
    "图8-19. extend()函数更新并添加缺失的属性到对象中")）：
- en: '[PRE38]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Meanwhile, `defaults()` leaves the original properties unchanged ([Figure 8-20](ch08.html#defaultsleft_parenthesisright_parenthesi
    "Figure 8-20. The defaults() function adds missing properties to an object.")):'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 与此同时，`defaults()`保持原始属性不变（见[图8-20](ch08.html#defaultsleft_parenthesi "图8-20.
    defaults()函数将缺失的属性添加到对象中")）：
- en: '[PRE39]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: '![The extend() function updates and adds missing properties to an object.](figs/web/08fig19.png.jpg)Figure 8-19. The
    `extend()` function updates and adds missing properties to an object.![The defaults()
    function adds missing properties to an object.](figs/web/08fig20.png.jpg)Figure 8-20. The
    `defaults()` function adds missing properties to an object.'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: '![extend()函数更新并添加缺失的属性到对象中。](figs/web/08fig19.png.jpg)图8-19. `extend()`函数更新并添加缺失的属性到对象中。![defaults()函数将缺失的属性添加到对象中。](figs/web/08fig20.png.jpg)图8-20.
    `defaults()`函数将缺失的属性添加到对象中。'
- en: 'Note that both `extend()` and `defaults()` modify the original object directly;
    they do not make a copy of that object and return the copy. Consider, for example,
    the following:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，`extend()`和`defaults()`都会直接修改原始对象；它们不会创建该对象的副本并返回副本。考虑以下情况：
- en: '[PRE40]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: This code sets the `pizza` variable as you would expect, but it also sets the
    `standard` variable to that same object. More specifically, the code modifies
    `standard` with the properties from `order`, and then it sets a new variable `pizza`
    equal to `standard`. The modification of `standard` is probably not intended.
    If you need to use either `extend()` or `defaults()` in a way that does not modify
    input parameters, start with an empty object.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码按照预期设置了`pizza`变量，但它也将`standard`变量设置为相同的对象。更具体地说，代码通过`order`中的属性修改了`standard`，然后将一个新的变量`pizza`设置为`standard`。对`standard`的修改可能并非故意为之。如果你需要以不修改输入参数的方式使用`extend()`或`defaults()`，可以从一个空对象开始。
- en: '[PRE41]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: This version gets us the desired `pizza` object without modifying `standard`.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 这个版本可以获得我们期望的`pizza`对象，而不会修改`standard`。
- en: Manipulating Collections
  id: totrans-187
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 操作集合
- en: So far we’ve seen various Underscore.js tools that are suited specifically for
    either arrays or objects. Next, we’ll see some tools for manipulating collections
    in general. In Underscore.js both arrays and objects are *collections*, so the
    tools in this section can be applied to pure arrays, pure objects, or data structures
    that combine both. In this section, we’ll try out these utilities on an array
    of objects, since that’s the data structure we most often deal with in the context
    of data visualization.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经看过了各种专门适用于数组或对象的Underscore.js工具。接下来，我们将看到一些用于操作集合的工具。在Underscore.js中，数组和对象都是*集合*，因此本节中的工具可以应用于纯数组、纯对象或结合两者的数据结构。在本节中，我们将尝试在一个对象数组上使用这些工具，因为这是我们在数据可视化上下文中最常处理的数据结构。
- en: Here’s a small data set we can use for the examples that follow. It contains
    a few statistics from the 2012 Major League Baseball season.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个小数据集，我们可以在接下来的示例中使用。它包含了2012年美国职棒大联盟赛季的一些统计数据。
- en: '[PRE42]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Working with Iteration Utilities
  id: totrans-191
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用迭代工具
- en: In the first section, we saw some of the pitfalls of traditional JavaScript
    iteration loops as well as the improvements that functional programming can provide.
    Our Fibonacci example eliminated iteration by using recursion, but many algorithms
    don’t lend themselves to a recursive implementation. In those cases, we can still
    use a functional programming style, however, by taking advantage of the iteration
    utilities in Underscore.js.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一部分，我们看到了一些传统JavaScript迭代循环的陷阱以及函数式编程可以提供的改进。我们的斐波那契例子通过使用递归消除了迭代，但许多算法并不适合递归实现。在这些情况下，我们仍然可以通过利用Underscore.js中的迭代工具，采用函数式编程风格。
- en: The most basic Underscore utility is `each()`. It executes an arbitrary function
    on every element in a collection and often serves as a direct functional replacement
    for the traditional `for (i=0; i<len; i++)` loop.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 最基本的Underscore工具是`each()`。它在集合中的每个元素上执行一个任意的函数，并且通常作为传统的`for (i=0; i<len; i++)`循环的直接函数式替代。
- en: '[PRE43]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: If you’re familiar with the jQuery library, you may know that jQuery includes
    a similar `$.each()` utility. There are two important differences between the
    Underscore .js and jQuery versions, however. First, the parameters passed to the
    iterator function differ between the two. Underscore.js passes `(element, index,
    list)` for arrays and `(value, key, list)` for simple objects, while jQuery passes
    `(index, value)`. Secondly, at least as of this writing, the Underscore.js implementation
    can execute much faster than the jQuery version, depending on the browser. (jQuery
    also includes a `$.map()` function that’s similar to the Underscore.js method.)
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你熟悉jQuery库，你可能知道jQuery包括一个类似的`$.each()`工具。然而，Underscore.js和jQuery版本之间有两个重要的区别。首先，传递给迭代函数的参数在两者之间有所不同。Underscore.js为数组传递`(element,
    index, list)`，为简单对象传递`(value, key, list)`，而jQuery传递`(index, value)`。其次，至少在撰写本文时，Underscore.js的实现可能比jQuery版本执行得更快，具体取决于浏览器。（jQuery也包括一个类似于Underscore.js方法的`$.map()`函数。）
- en: 'The Underscore.js `map()` method iterates through a collection and transforms
    each element with an arbitrary function. It returns a new collection containing
    the transformed elements. Here, for example, is how to create an array of all
    the teams’ winning percentages:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: Underscore.js的`map()`方法遍历集合，并通过一个任意的函数转换每个元素。它返回一个包含转换后元素的新集合。例如，以下是如何创建一个所有团队胜率的数组：
- en: '[PRE44]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: The `reduce()` method iterates through a collection and returns a single value.
    One parameter initializes this value, and the other parameter is an arbitrary
    function that updates the value for each element in the collection. We can use
    `reduce()`, for example, to calculate how many teams have a winning percentage
    over 500.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: '`reduce()`方法遍历集合并返回一个单一的值。一个参数初始化该值，另一个参数是一个任意的函数，用于更新集合中每个元素的值。例如，我们可以使用`reduce()`来计算有多少个团队的胜率超过500。'
- en: '[PRE45]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: As the comment at ➊ indicates, we start our count at 0\. That value is passed
    as the first parameter to the function at ➋, and the function returns an updated
    value at ➌.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 如➊处的注释所示，我们从0开始计数。该值作为第一个参数传递给➋处的函数，函数返回一个更新后的值，位于➌处。
- en: Note
  id: totrans-201
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '**If you’ve followed the development of “big data” implementations such as
    Hadoop or Google’s search, you may know that the fundamental algorithm behind
    those technologies is MapReduce. Although the context differs, the same concepts
    underlie the `map()` and `reduce()` utilities in Underscore.js.**'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: '**如果你关注过“大数据”技术的开发，比如Hadoop或谷歌的搜索，你可能知道这些技术背后的基本算法是MapReduce。尽管背景不同，但`map()`和`reduce()`工具在Underscore.js中的原理是相同的。**'
- en: Finding Elements in a Collection
  id: totrans-203
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在集合中查找元素
- en: Underscore.js has several methods to help us find elements or sets of elements
    in a collection. We can, for example, use `find()` to get a team with more than
    90 wins.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: Underscore.js有几个方法可以帮助我们在集合中查找元素或元素集合。例如，我们可以使用`find()`来获取一个超过90场胜利的团队。
- en: '[PRE46]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: The `find()` function returns the first element in the array that meets the
    criterion. To find all elements that meet our criterion, use the `filter()` function.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: '`find()`函数返回数组中第一个符合标准的元素。要查找所有符合标准的元素，可以使用`filter()`函数。'
- en: '[PRE47]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: The opposite of the `filter()` function is `reject()`. It returns an array of
    elements that don’t meet the criterion.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: '`filter()`函数的反义函数是`reject()`。它返回一个不符合标准的元素数组。'
- en: '[PRE48]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'If your criterion can be described as a property value, you can use a simpler
    version of `filter()`: the `where()` function. Instead of an arbitrary function
    to check for a match, `where()` takes for its parameter a set of properties that
    must match. We can use it to extract all the teams in the Eastern Division.'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的标准可以用属性值来描述，你可以使用`filter()`的简化版本：`where()`函数。`where()`的参数是一组必须匹配的属性，而不是一个用于检查匹配的任意函数。我们可以用它来提取所有属于东区的队伍。
- en: '[PRE49]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: The `findWhere()` method combines the functionality of `find()` with the simplicity
    of `where()`. It returns the first element in a collection with properties that
    match specific values.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: '`findWhere()`方法将`find()`的功能与`where()`的简洁性结合在一起。它返回集合中第一个具有匹配特定值的属性的元素。'
- en: '[PRE50]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Another Underscore.js utility that’s especially handy is `pluck()`. This function
    creates an array by extracting only the specified property from a collection.
    We could use it to extract an array of nothing but team names, for example.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个特别方便的Underscore.js工具是`pluck()`。这个函数通过从集合中提取指定的属性来创建一个数组。例如，我们可以用它来提取一个仅包含队名的数组。
- en: '[PRE51]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: Testing a Collection
  id: totrans-216
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 测试集合
- en: Sometimes we don’t necessarily need to transform a collection; we simply want
    to check some aspect of it. Underscore.js provides several utilities to help with
    these tests.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 有时我们不一定需要转换一个集合；我们只是想检查它的某个方面。Underscore.js提供了几种工具来帮助进行这些测试。
- en: The `every()` function tells us whether all elements in a collection pass an
    arbitrary test. We could use it to check if every team in our data set had at
    least 70 wins.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: '`every()`函数告诉我们集合中的所有元素是否通过了一个任意的测试。我们可以用它来检查数据集中每支队伍是否至少有70场胜利。'
- en: '[PRE52]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: Perhaps we’d like to know if *any* team had at least 70 wins. In that case,
    the `any()` function provides an answer.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 也许我们想知道是否有*任何*队伍至少有70场胜利。在这种情况下，`any()`函数可以提供答案。
- en: '[PRE53]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: Underscore.js also lets us use arbitrary functions to find the maximum and minimum
    elements in a collection. If our criteria is number of wins, we use `max()` to
    find the “maximum” team.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: Underscore.js还允许我们使用任意函数来查找集合中的最大和最小元素。如果我们的标准是胜场数，我们可以使用`max()`来找到“最大”队伍。
- en: '[PRE54]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: Not surprisingly, the `min()` function works the same way.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 不出所料，`min()`函数的工作方式与此相同。
- en: '[PRE55]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: Rearranging Collections
  id: totrans-226
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 重排集合
- en: To sort a collection, we can use the `sortBy()` method and supply an arbitrary
    function to provide sortable values. Here’s how to reorder our collection in order
    of increasing wins.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 要对集合进行排序，我们可以使用`sortBy()`方法，并提供一个任意函数来提供可排序的值。下面是如何按胜场数升序重新排列我们的集合。
- en: '[PRE56]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: We could also reorganize our collection by grouping its elements according to
    a property. The Underscore.js function that helps in this case is `groupBy()`.
    One possibility is reorganizing the teams according to their division.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以通过根据某个属性对元素进行分组来重新组织我们的集合。Underscore.js在这种情况下提供的函数是`groupBy()`。一种可能性是按分区重新组织队伍。
- en: '[PRE57]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: We can also use the `countBy()` function to simply count the number of elements
    in each group.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以使用`countBy()`函数来简单地计算每个组中元素的数量。
- en: '[PRE58]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: Note
  id: totrans-233
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '**Although we’ve used a property value (`"division"`) for `groupBy()` and `countBy()`,
    both methods also accept an arbitrary function if the criteria for grouping isn’t
    a simple property.**'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: '**虽然我们在`groupBy()`和`countBy()`中使用了一个属性值（`"division"`），但这两个方法也接受一个任意函数，如果分组的标准不是简单的属性。**'
- en: As a final trick, Underscore.js lets us randomly reorder a collection using
    the `shuffle()` function.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一个最终技巧，Underscore.js允许我们使用`shuffle()`函数随机重新排列一个集合。
- en: '[PRE59]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: Summing Up
  id: totrans-237
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 总结
- en: Although this chapter takes a different approach than the rest of the book,
    its ultimate focus is still on data visualizations. As we’ve seen in earlier chapters
    (and as you’ll certainly encounter in your own projects), the raw data for our
    visualizations isn’t always perfect as delivered. Sometimes we need to clean the
    data by removing invalid values, and other times we need to rearrange or transform
    it so that it’s appropriate for our visualization libraries.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管本章采用了与书中其余部分不同的方法，但其最终焦点仍然是数据可视化。正如我们在前几章中所见（并且你在自己的项目中肯定也会遇到），我们的可视化所用的原始数据并不总是完美的。我们有时需要通过移除无效值来清理数据，有时则需要重新排列或转换数据，以便它适用于我们的可视化库。
- en: The Underscore.js library contains a wealth of tools and utilities to help with
    those tasks. It lets us easily manage arrays, modify objects, and transform collections.
    Furthermore, Underscore.js supports an underlying philosophy based on functional
    programming, so our code that uses Underscore.js remains highly readable and resistant
    to bugs and defects.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: Underscore.js 库包含了丰富的工具和实用程序，帮助完成这些任务。它使我们能够轻松管理数组、修改对象和转换集合。此外，Underscore.js
    支持基于函数式编程的底层哲学，因此我们使用 Underscore.js 编写的代码保持高度可读，并能有效抵御错误和缺陷。
