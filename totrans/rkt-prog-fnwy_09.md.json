["```\n#lang racket\n\n(define state-table\n  (vector\n   ;        H  E  L  O\n   (vector  1 #f #f #f) ; state 0\n   (vector #f  2 #f #f) ; state 1\n   (vector #f #f  3 #f) ; state 2\n   (vector #f #f  3  4) ; state 3\n   (vector #f #f #f  4) ; state 4\n   ))\n```", "```\n(define chr->ndx\n  (make-hash '[(#\\H . 0) (#\\E . 1) (#\\L . 2) (#\\O . 3)] ))\n```", "```\n(define (next-state i chr)\n  (if (hash-has-key? chr->ndx chr)\n      (vector-ref (vector-ref state-table i)\n                  (hash-ref chr->ndx chr) )\n      #f))\n```", "```\n  (define (hello-dfa str)\n➊ (let ([chrs (string->list str)])\n    (let loop ([state 0] [chrs chrs])\n   ➋ (if (equal? chrs '()) ; end of string\n       ➌ (if (= state 4) \n              #t ;if 4, accepting\n              #f ;not 4, not accepting\n              )\n       ➍ (let ([state (next-state state (car chrs))]\n                [tail (cdr chrs)])\n            (if (equal? state #f) #f ; invalid\n             ➎ (loop state tail)))))))\n```", "```\n> (hello-dfa \"HELP\")\n#f\n\n> (hello-dfa \"HELLO\")\n#t\n\n> (hello-dfa \"HELLLLLOOOO\")\n#t\n\n> (hello-dfa \"HELLOS\")\n#f\n```", "```\n#lang racket\n\n(define tape (vector 1 1 1 0 1 1 0 0 0 0))\n\n(define head 0)\n\n(struct act (write move next))\n\n(define state-table\n  (vector\n   (vector (act 0 #f 0) (act 0 'R 1)) ; state 0\n   (vector (act 0 'R 2) (act 1 'R 1)) ; state 1\n   (vector (act 1 'L 3) (act 1 'R 2)) ; state 2\n   (vector (act 0 'L 4) (act 1 'L 3)) ; state 3\n   (vector (act 0 'R 6) (act 1 'L 5)) ; state 4\n   (vector (act 0 'R 0) (act 1 'L 5)) ; state 5\n   (vector (act 0 'R 7) (act 1 #f 0)) ; state 6\n   (vector (act 0 #f 0) (act 1 'H 0)) ; state 7\n   ))\n\n(define state 0)\n```", "```\n(define (state-ref s i) (vector-ref (vector-ref state-table s) i))\n(define (head-val) (vector-ref tape head))\n(define (tape-set! v) (vector-set! tape head v))\n```", "```\n(define (run-machine)\n  (let* ([sym (head-val)] ; current input\n      ➊ [actions (state-ref state sym)]\n         [move (act-move actions)])\n    (cond [(equal? #f move)\n           (printf \"Failure in state ~a, head: ~a\\n~a\" state head tape)]\n       ➋ [(equal? 'H move)\n           (printf \"Done!\\n\")]\n          [else\n        ➌ (let* ([write (act-write actions)]\n               ➍ [changed (not (equal? sym write))])\n             (tape-set! write)\n          ➎ (set! head (if (equal? move 'L) (sub1 head) (add1 head)))\n          ➏ (when changed (printf \"~a\\n\" tape))\n          ➐ (set! state (act-next actions))\n             (run-machine))])))\n```", "```\n#(1 1 1 0 1 1 0 0 0 0)\n#(0 1 1 0 1 1 0 0 0 0)\n#(0 1 1 0 1 1 1 0 0 0)\n#(0 0 1 0 1 1 1 0 0 0)\n#(0 0 1 0 1 1 1 1 0 0)\n#(0 0 0 0 1 1 1 1 0 0)\n#(0 0 0 0 1 1 1 1 1 0)\nDone!\n```", "```\n(define (make-reader input)\n  (define (read)\n    (if (null? input) 'ϵ ; return empty string indicator\n        (let ([sym (car input)])\n          (set! input (cdr input))\n          sym)))\n  read)\n```", "```\n> (define read (make-reader '(1 0 1)))\n> (read)\n1\n> (read)\n0\n> (read)\n1\n> (read)\nϵ\n```", "```\n(define stack '(ω)) ; ω is the bottom of stack marker\n\n(define (pop)\n  (let ([s (car stack)])\n    (set! stack (cdr stack))\n    s))\n\n(define (push s)\n  (set! stack (cons s stack)))\n\n(define (peek) (car stack))\n```", "```\n(define (run-pda input)\n  (let ([read (make-reader input)]) ; initialize the reader\n    (set! stack '(ω)) ; initialize stack\n    (define (pda)\n      (let ([symbol (read)]\n            [top (peek)])\n        (match (cons symbol top)\n          [(cons 'ϵ 'ω ) #t] ; accept input\n          [(cons  0 'ω)   (begin (push 0) (pda))]\n          [(cons  0  0)  (begin (push 0) (pda))]\n          [(cons  1 'ω)   (begin (push 1) (pda))]\n          [(cons  1  1)  (begin (push 1) (pda))]\n          [(cons  0  1)  (begin (pop)    (pda))]\n          [(cons  1  0)  (begin (pop)    (pda))]\n          [_ #f]))) ; reject input\n    (pda)))\n```", "```\n> (run-pda '(1))\n#f\n\n> (run-pda '(1 0))\n#t\n\n> (run-pda '(1 0 0 1 1 0))\n#t\n\n> (run-pda '(0 1 0 0 1 1 0))\n#f\n\n> (run-pda '(1 0 0 1 1 0 0 0 1 1 1))\n#f\n\n> (run-pda '(1 0 0 1 1 0 0 0 1 1 1 0))\n#t\n```"]