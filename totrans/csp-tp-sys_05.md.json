["```\nint x = 10;\nint y = x;\nAssert.That(x == y, Is.True);\n```", "```\n❶ <samp class=\"SANS_TheSansMonoCd_W5Regular_11\">L_0001: ldc.i4.s 10</samp>\nL_0003: stloc.0  // x\n❷ L_0004: ldloc.0  // x\nL_0006: stloc.1  // y\n❸ L_0007: ldloc.0  // x\nL_0008: ldloc.1  // y\n❹ L_0009: ceq\n```", "```\ndouble x = 0.3;\ndouble y = 0.1 + 0.2;\nAssert.That(x == y, Is.True);\n```", "```\npublic static bool ApproximatelyEqual(double x, double y)\n    => Math.Round(Math.Abs(x - y), 7) == 0;\n```", "```\npublic static bool ApproximatelyEqual(double x, double y)\n    => Math.Abs(x - y) < Tolerance;\n```", "```\nprivate const double Tolerance = 1E-15;\npublic static bool ApproximatelyEqual(double x, double y)\n    => Math.Abs(x - y) <\n       Math.Max(Tolerance, Math.Min(x, y)) * Tolerance;\n```", "```\nvar x = 0.0 / 0.0;\nAssert.That(x == double.NaN, Is.True);\n```", "```\nAssert.That(double.IsNaN(x), Is.True);\n```", "```\nAssert.That(x is double.NaN, Is.True);\n```", "```\nvar x = 0.0 / 0.0;\nAssert.That(x.Equals(Double.NaN), Is.True);\n```", "```\npublic sealed class MusicTrack\n{\n}\nvar x = new MusicTrack();\nvar y = new MusicTrack();\nAssert.That(x == y, Is.False);\n```", "```\nIL_0001:  newobj    instance void MusicTrack::.ctor()\nIL_0006:  stloc.0   // x\nIL_0007:  newobj    instance void MusicTrack::.ctor()\nIL_000c:  stloc.1   // y\nIL_000d:  ldloc.0\nIL_000e:  ldloc.1\nIL_000f:  ceq\n```", "```\nvar x = new MusicTrack();\nAssert.That(x == null, Is.False);\n```", "```\nIL_0016: newobj    instance void MusicTrack::.ctor()\nIL_001c: ldloc.1   // x\nIL_001d: ldnull\nIL_001e: ceq\n```", "```\nint[] x = {10, 20};\nint[] y = {10, 20};\nAssert.That(x == y, Is.False);\n```", "```\nvar monarch = \"Henry\";\nvar number = \"IV\";\nvar x = $\"{monarch} the {number}\";\nvar y = $\"{monarch} the {number}\";\nAssert.That(x == y, Is.True);\nAssert.That(x.Equals(y), Is.True);\nAssert.That(ReferenceEquals(x, y), Is.False);\n```", "```\nvar x = \"Henry the IV\";\nvar y = \"Henry the IV\";\nAssert.That(ReferenceEquals(x, y), Is.True);\n```", "```\npublic sealed class MusicTrack\n{\n    public MusicTrack(string artist, string name)\n        => (Artist, Name) = (artist, name);\n    public string Artist {get;}\n    public string Name {get;}\n    **public override bool Equals(object? obj)**\n        **=>** **obj is MusicTrack other &&**\n            **this.Artist** **==** **other.Artist &&**\n            **this.Name** **==** **other.Name;**\n}\n```", "```\npublic static bool operator==(MusicTrack? left, MusicTrack? right)\n{\n    if(left is null)\n    {\n        return right is null;\n    }\n    else\n    {\n        return left.Equals(right);\n    }\n}\npublic static bool operator!=(MusicTrack? left, MusicTrack? right)\n    => !(left == right);\n```", "```\npublic static bool operator==(MusicTrack? left, MusicTrack? right)\n{\n    return left is null ? right is null : left.Equals(right);\n}\n```", "```\npublic static bool operator==(MusicTrack? left, MusicTrack? right)\n    => left?.Equals(right) ?? right is null;\n```", "```\npublic bool **Equals(MusicTrack? other)**\n    => other is not null &&\n        this.Artist == other.Artist &&\n        this.Name == other.Name;\n```", "```\npublic override bool Equals(object? obj)\n    => Equals(obj as MusicTrack);\n```", "```\npublic sealed class Character\n{\n    public Character(string name)\n            => Name = name;\n    public string Name {get;}\n}\nvar cast = new HashSet<Character>\n    {\n        new Character(\"MacReady\")\n    };\n**var key** **=** **new Character(\"MacReady\");**\n**Assert.That(cast.Contains(key), Is.True);**\n```", "```\npublic override int GetHashCode()\n    => HashCode.Combine(Artist, Name);\n```", "```\nvar history = new HashSet<double>();\nvar rate = 0.1 + 0.2;\n**history.Add(rate);**\nAssert.That(history.Contains(0.3));\n```", "```\npublic readonly struct Color\n{\n    public Color(int r, int g, int b)\n        => (Red, Green, Blue) = (r, g, b);\n    public int Red {get;}\n    public int Green {get;}\n    public int Blue {get;}\n    public bool Equals(Color other)\n        => Red == other.Red &&\n           Green == other.Green &&\n           Blue == other.Blue;\n public override bool Equals(object? obj)\n        => obj is Color color && Equals(color);\n    public override int GetHashCode()\n        => HashCode.Combine(Red, Green, Blue);\n}\n```", "```\npublic static bool operator==(Color left, Color right)\n    => left.Equals(right);\npublic static bool operator!=(Color left, Color right)\n    => !left.Equals(right);\n```", "```\nobject x = new Color(0xFF, 0xA0, 0);\nobject y = new Color(0xFF, 0xA0, 0);\nAssert.That(x == y, Is.False);\n```", "```\nAssert.That(x.Equals(y), Is.True);\n```", "```\nvar color = new Color(0xFF, 0xA0, 0);\nobject x = color;\nobject y = x;\nAssert.That(x == y, Is.True);\nAssert.That(x.Equals(y), Is.True);\n```", "```\nColor x = new Color();\nAssert.That(object.ReferenceEquals(x, x), Is.False);\n```", "```\nobject a = x;\nobject b = x;\nAssert.That(object.ReferenceEquals(a, b), Is.False);\n```", "```\nobject x = new Color();\nAssert.That(object.ReferenceEquals(x, x), Is.True);\n```", "```\npublic readonly struct Angle : IFormattable\n{\n    `--snip--`\n}\nIFormattable x = new Angle();\nIFormattable y = new Angle();\nAssert.That(x == y, Is.False);\n```", "```\npublic class Playlist<T>\n{\n    public void PlayNow(T item)\n    {\n        **if(item** **==** **current)**\n        {\n           `--snip--`\n        }\n    }\n    private T current;\n}\n```", "```\nvar colors = new HashSet<Color>();\nvar orange = new Color(0xFF, 0xA0, 0);\ncolors.Add(orange);\nAssert.That(**colors.Contains(orange)**, Is.True);\n```", "```\npublic readonly struct Color **: IEquatable<Color>**\n{\n    `--snip--`\n    public bool Equals(Color other)\n        => other.Red == Red &&\n           other.Green == Green &&\n           other.Blue == Blue;\n    `--snip--`\n}\n```", "```\npublic void PlayNow(T item)\n{\n    var comparer = EqualityComparer<T>.Default;\n    if(!comparer.Equals(Current, item))\n        Current = item;\n}\n```", "```\npublic sealed record Color(int Red, int Green, int Blue);\n```", "```\npublic bool Equals(Color? other)\n    => (object?)other != null &&\n       GetType() == other.GetType() &&\n       EqualityComparer<int>.Default.Equals(Red, other.Red) &&\n       EqualityComparer<int>.Default.Equals(Green, other.Green) &&\n       EqualityComparer<int>.Default.Equals(Blue, other.Blue);\npublic override bool Equals(object? obj)\n    => Equals(obj as Color);\n```", "```\nvar red1 = new Color(0xFF, 0, 0);\nvar red2 = new Color(0xFF, 0, 0);\nAssert.That(red1 == red2, Is.True);\nAssert.That(ReferenceEquals(red1, red2), Is.False);\n```", "```\n[CS0111] Type 'Color' already defines a member called 'op_Equality' with the same parameter\ntypes\n```", "```\npublic static bool operator==(Color left, Color right)\n{\n    if((object)left == (object)right) return true;\n    return (object)left != null && left.Equals(right);\n}\npublic static bool operator!=(Color left, Color right)\n    => !(left == right);\n```", "```\npublic readonly struct Color\n{\n    `--snip--`\n    public static bool operator==(Color left, Color right)\n        => left.Equals(right);\n    public static bool operator!=(Color left, Color right)\n        => !left.Equals(right);\n}\nColor? fg = new Color(0xFF, 0xA0, 0);\nColor? bg = null;\nAssert.That(fg == bg, Is.False);\n```", "```\nbool lifted_op_Equality(Color? fg, Color? bg)\n{\n    if(fg.HasValue && bg.HasValue)\n        return fg.Value == bg.Value; // uses Color.operator==\n    else\n        return !fg.HasValue && !bg.HasValue;\n}\n```", "```\nAssert.That(\n    fg.HasValue == bg.HasValue &&\n    (!fg.HasValue || fg.GetValueOrDefault() == bg.GetValueOrDefault()),\nIs.False);\n```", "```\nvar x = (10, \"October\");\nvar y = (ShortMonth: 10, LongMonth: \"October\");\nAssert.That(x == y, Is.True);\n```", "```\nIL_0021: ldloc.2    // V_2\nIL_0022: ldfld      !0/*int32*/ valuetype System.ValueTuple`2<int32, string>::Item1\nIL_0027: ldloc.3    // V_3\nIL_0028: ldfld      !0/*int32*/ valuetype System.ValueTuple`2<int32, string>::Item1\nIL_002d: **bne.un.s   IL_0042**\n```", "```\nIL_002f: ldloc.2   // V_2\nIL_0030: ldfld     !1/*string*/ valuetype System.ValueTuple`2<int32, string>::Item2\nIL_0035: ldloc.3   // V_3\nIL_0036: ldfld     !1/*string*/ valuetype System.ValueTuple`2<int32, string>::Item2\nIL_003b: call      bool [System.Runtime] **System.String::op_Equality(string, string)**\n```"]