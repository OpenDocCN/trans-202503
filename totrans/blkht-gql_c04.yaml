- en: '4'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Reconnaissance
  prefs: []
  type: TYPE_NORMAL
- en: '![](image_fi/book_art/chapterart.png)'
  prefs: []
  type: TYPE_IMG
- en: All security tests start with a *reconnaissance phase*. In this phase, we attempt
    to collect as much information as possible about our target. This information
    will prepare us to make informed decisions about how to attack the application
    and increase our chances of success.
  prefs: []
  type: TYPE_NORMAL
- en: You might be asking yourself, what is there to know about GraphQL, seeing as
    it’s just an API layer? You’ll learn that we can gather a lot of information,
    through experimentation and the use of specialized tooling, about the application
    running behind a GraphQL API, as well as the GraphQL implementation itself. While
    the GraphQL query structure is consistent across all GraphQL implementations,
    irrespective of the programming language they are written in, you will likely
    see differences in the available operations, fields, arguments, directives, security
    controls, responses to specially crafted queries, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are a few key questions we should strive to answer during our reconnaissance
    phase: Does the web server even have a GraphQL API? On which endpoint is GraphQL
    configured to receive queries? What language is the GraphQL implementation written
    in? What implementation of GraphQL is running on the target server? Is the implementation
    known to be vulnerable to certain attacks? What types of defenses exist for the
    specific GraphQL implementation? What are some of the out-of-the-box default configuration
    settings of this implementation? Does the GraphQL server have any additional security
    protection layers in place? Being able to answer these questions will allow us
    to plan a more focused attack against our target server and uncover gaps in its
    defense.'
  prefs: []
  type: TYPE_NORMAL
- en: Detecting GraphQL
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To detect GraphQL in a penetration test, it’s important to first familiarize
    yourself with the GraphQL server implementations that exist in the wild today.
    GraphQL has many implementations written in a variety of programming languages,
    each of which could have different default configurations or known weaknesses.
    [Table 4-1](#table4-1) lists several GraphQL implementations and the languages
    in which they are written.
  prefs: []
  type: TYPE_NORMAL
- en: 'Table 4-1: GraphQL Server Implementations and Their Programming Languages'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Server implementation** | **Language** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| Apollo | TypeScript |'
  prefs: []
  type: TYPE_TB
- en: '| Graphene | Python |'
  prefs: []
  type: TYPE_TB
- en: '| Yoga | TypeScript |'
  prefs: []
  type: TYPE_TB
- en: '| Ariadne | Python |'
  prefs: []
  type: TYPE_TB
- en: '| graphql-ruby | Ruby |'
  prefs: []
  type: TYPE_TB
- en: '| graphql-php | PHP |'
  prefs: []
  type: TYPE_TB
- en: '| graphql-go | Go |'
  prefs: []
  type: TYPE_TB
- en: '| graphql-java | Java |'
  prefs: []
  type: TYPE_TB
- en: '| Sangria | Scala |'
  prefs: []
  type: TYPE_TB
- en: '| Juniper | Rust |'
  prefs: []
  type: TYPE_TB
- en: '| HyperGraphQL | Java |'
  prefs: []
  type: TYPE_TB
- en: '| Strawberry | Python |'
  prefs: []
  type: TYPE_TB
- en: '| Tartiflette | Python |'
  prefs: []
  type: TYPE_TB
- en: These are some of the most popular implementations in use today, as well as
    more niche implementations, such as Sangria for Scala, Juniper for Rust, and HyperGraphQL
    for Java. Later in this chapter, we will discuss how to distinguish between them
    during a penetration test.
  prefs: []
  type: TYPE_NORMAL
- en: 'Detection of GraphQL APIs can be done in several ways: either manually, which
    is typically harder to scale if you have more than a few hosts on a network, or
    automatically, using various web scanners. The advantage of using web-scanning
    tools is that they are scalable. They are threaded, and often have the ability
    to read external files as program input, such as text files with a list of hostnames
    to scan. These tools already have the logic to detect web interfaces built into
    them, and using scripting languages (such as Bash or Python), you can programmatically
    run them against hundreds of IP addresses or subdomains. In this chapter, we will
    use popular scanners such as Nmap, as well as GraphQL-oriented scanning tools,
    such as Graphw00f, for reconnaissance.'
  prefs: []
  type: TYPE_NORMAL
- en: Common Endpoints
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In Chapter 1, we highlighted some of the differences between REST and GraphQL
    APIs. One of these differences, relevant to the reconnaissance phase, is that
    a GraphQL API endpoint is typically static, and most commonly */graphql*.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, although */graphql* is often the default GraphQL endpoint, the GraphQL
    implementation can be reconfigured to use a completely different path. In those
    cases, what can we do to detect it? One way is to manually attempt a few common
    alternative paths to the GraphQL API, such as versioned endpoints:'
  prefs: []
  type: TYPE_NORMAL
- en: '*/v1/graphql*'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*/v2/graphql*'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*/v3/graphql*'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You’ll typically see these versioned API endpoints when the application needs
    to support multiple versions of its API, either for backward compatibility or
    for the introduction of a new feature in a way that doesn’t conflict with the
    stable API version that customers might still be using.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another way to find a GraphQL implementation is through IDEs, such as GraphQL
    Playground or GraphiQL Explorer, which we used in Chapter 1 to experiment with
    GraphQL queries. When either of these interfaces is enabled, it often uses an
    additional, dedicated endpoint. This means GraphQL can potentially exist under
    the following endpoints as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '*/graphiql*'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*/playground*'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If these endpoints happen to also be versioned, they may have a version number
    prepended to their path, such as */v1/graphiql*, */v2/graphiql*, */v1/playground*,
    */v2/playground*, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 4-1](#listing4-1) shows how Graphene, a Python-based implementation
    of GraphQL, can expose two endpoints, one for GraphQL, and the other for GraphiQL
    Explorer, which is built into Graphene:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 4-1: Graphene’s endpoint definition'
  prefs: []
  type: TYPE_NORMAL
- en: Graphene defines the */graphql* endpoint as its main GraphQL query endpoint.
    It then defines */graphiql* as a second endpoint that GraphiQL Explorer will query
    against. Lastly, it enables the GraphiQL Explorer interface. The GraphQL server
    will render the IDE to the client when it browses to the */graphiql* endpoint.
  prefs: []
  type: TYPE_NORMAL
- en: Keep in mind that each endpoint could have different security settings. One
    could be stricter than the other, for example. When you find two endpoints serving
    GraphQL queries on the same target host, you will want to test them separately.
  prefs: []
  type: TYPE_NORMAL
- en: The most important takeaway here is that, while the GraphQL endpoint is typically
    located at a predictable path, the developer can still customize it to fit their
    needs, perhaps in an attempt to hide it from curious eyes or to simply conform
    to internal application deployment standards.
  prefs: []
  type: TYPE_NORMAL
- en: Common Responses
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Now that you have an idea of the endpoints from which GraphQL typically receives
    queries, the next step is to learn how GraphQL APIs respond to packets. GraphQL
    is fairly easy to identify on a network. This is particularly helpful whenever
    you are performing a zero-knowledge penetration test or bug bounty hunt.
  prefs: []
  type: TYPE_NORMAL
- en: 'The GraphQL specification describes how a query response structure should be
    formatted. This allows API consumers to expect a predetermined format when they
    parse the GraphQL response. The following excerpt from the GraphQL specification
    describes how the response to a query should look:'
  prefs: []
  type: TYPE_NORMAL
- en: If the operation is a query, the result of the operation is the result of executing
    the operation’s top-level selection set with the query root operation type.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'An initial value may be provided when executing a query operation:'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`ExecuteQuery(``query``,` `schema``,` `variableValues``,` `initialValue``)`'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Let `queryType` be the root `Query` type in the schema.
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Assert: `queryType` is an `Object` type.'
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
- en: Let `selectionSet` be the top-level selection set in the query.
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
- en: Let `data` be the result of running `ExecuteSelectionSet(selectionSet, queryType,
    initialValue, variableValues)` normally (allowing parallelization).
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
- en: Let `errors` be any field errors produced while executing the selection set.
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
- en: Return an unordered map containing data and errors.
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
- en: In practice, this means a GraphQL API will return a `data` JSON field when there
    is a result to return to a client’s query. It will also return an `errors` JSON
    field whenever errors occur during the execution of a client query.
  prefs: []
  type: TYPE_NORMAL
- en: 'Knowing these two pieces of information ahead of time is valuable. To put it
    simply, we now have two conditions that a response must meet before we can say
    that it came from a GraphQL API:'
  prefs: []
  type: TYPE_NORMAL
- en: A valid query response should *always* have the `data` field populated with
    query response information.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: An invalid query response should *always* have the `errors` field populated
    with information about what went wrong.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now we can leverage these as part of scanning and detection logic to automate
    the discovery of GraphQL servers on a network. All we need to do is send a valid
    or malformed query and observe the response we receive.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s run a simple GraphQL query using the HTTP POST method against the DVGA
    to see these response structures in action. Open the Altair GraphQL client and
    ensure that the address bar has the *http://localhost:5013/graphql* address set;
    then run the following query by entering it in Altair’s left pane:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, click the play button to send the query to the GraphQL server. This should
    return the `id` field of the `pastes` object. You should be able to see a response
    similar to the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, GraphQL returns the query response as part of the `data` JSON
    field, exactly as described in the GraphQL specification. We get the `pastes`
    object and the `id` field we specified in the query. Don’t worry if you see a
    different `id` string returned in your lab than the one shown here; this is expected.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let’s run another query to explore what happens when an invalid query
    is sent to GraphQL. This will demonstrate that the `errors` JSON field is returned
    by the GraphQL server when it encounters issues during query execution. The following
    query is malformed, and GraphQL won’t be able to process it. Run it in Altair
    and observe the response:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Notice that we specify a top-level field with the name of `badfield`. Because
    this field does not exist, the GraphQL server can’t fulfill the query. The GraphQL
    response can be seen here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, the GraphQL server isn’t able to process our query successfully.
    It returns a response containing the `errors` JSON field. The `message` JSON field
    indicates to us that the server couldn’t query the field named `badfield`, because
    it does not exist in the GraphQL schema.
  prefs: []
  type: TYPE_NORMAL
- en: Nmap Scans
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Imagine that you need to conduct a penetration test against a network containing
    thousands of hosts; it would be fairly difficult to manually go through each host
    to find ones that are potentially serving interesting content, such as an API
    or a vulnerable commercial application. In these cases, penetration testers often
    use web application scanners or custom scripts to automatically grab information
    from the hosts. For example, information such as the `<title>` HyperText Markup
    Language (HTML) tag, the entire `<body>` tag, and even the `server` HTTP response
    header could all hint at specific applications that the remote server is running.
  prefs: []
  type: TYPE_NORMAL
- en: It’s important to note that web applications may not always have a user interface,
    meaning they may not serve any HTML content related to the application or even
    expose HTTP headers by which we can detect them. They will often act as standalone
    API servers that expose data only through designated APIs. So, how can we detect
    GraphQL in those cases? Luckily, GraphQL APIs often return predictable responses
    under certain conditions, such as the HTTP method in use or the payload sent to
    the server. [Listing 4-2](#listing4-2) shows a common GraphQL response returned
    when a client makes a GET request.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 4-2: A GraphQL response to an HTTP GET request'
  prefs: []
  type: TYPE_NORMAL
- en: 'The string `Must provide query string` is often used in GraphQL implementations,
    such as Python- and Node.js-based ones. (Keep in mind that GET-based queries are
    often not supported by GraphQL servers. Rest assured: we have many other ways
    of detecting GraphQL should we run into such a situation.)'
  prefs: []
  type: TYPE_NORMAL
- en: With this information, we now have the ability to automate a scan and pick up
    any other GraphQL servers that may exist on a network. [Listing 4-3](#listing4-3)
    shows how to do this with Nmap, using the *http-grep* NSE script, which uses pattern
    matching to look for keywords in a given web page.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 4-3: A GraphQL response to word-matching using Nmap’s *http-grep*'
  prefs: []
  type: TYPE_NORMAL
- en: At ❶ we specify a script argument to *http-grep* called `match` with a value
    of `Must` `provide` `query` `string` (the message we received in our GraphQL response).
    At ❷ we define another argument, called `http-grep.url`, with a value of `/graphql`,
    which instructs Nmap to search a specific page within the web application. Under
    the hood, Nmap will make an HTTP GET request to `localhost` and use the argument
    string value we defined as the pattern for its search within the text it extracts
    from the web server’s response. In its output, Nmap shows that a pattern was found
    on the web page and indicates the string for which it found a match.
  prefs: []
  type: TYPE_NORMAL
- en: You may have noticed that we’re passing a specific port to Nmap (`-p`)—namely,
    port `5013`. Like any web server, GraphQL servers could run on any port, but a
    few are quite common, such as 80–89, 443, 4000–4005, 8443, 8000, and 8080\. We
    recommend scanning both common and uncommon port ranges when possible.
  prefs: []
  type: TYPE_NORMAL
- en: The __typename Field
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: So far, we’ve known exactly which fields to ask for in our queries, such as
    `pastes` with a selection set of `id`, as we requested earlier. You might be wondering,
    what if we don’t know what fields exist on the GraphQL API? How can we go about
    identifying GraphQL without this information? Luckily, there is a quick way to
    query GraphQL and return a valid response without knowing anything about the application’s
    schema.
  prefs: []
  type: TYPE_NORMAL
- en: '*Meta-fields* are built-in fields that GraphQL APIs expose to clients. One
    example is `__schema` (part of introspection in GraphQL). Another example of a
    meta-field is `__typename`. When used, it returns the name of the object type
    being queried. [Listing 4-4](#listing4-4) shows a query that uses this meta-field.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 4-4: A GraphQL query with the `__typename` meta-field'
  prefs: []
  type: TYPE_NORMAL
- en: 'When you run this query with Altair, the response will be the name of the `pastes`
    object type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, GraphQL tells us that the `pastes` object’s type name is `PasteObject`.
    The real hack here is that the `__typename` meta-field can be used against the
    query root type as well, as shown in [Listing 4-5](#listing4-5).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 4-5: A GraphQL meta-field used with the query root type'
  prefs: []
  type: TYPE_NORMAL
- en: This query uses `__typename` to describe the query root type and will work against
    pretty much any GraphQL implementation, since `__typename` is part of the official
    specification.
  prefs: []
  type: TYPE_NORMAL
- en: 'When you’re attempting to query GraphQL from the command line, GraphQL servers
    expect a certain request structure. For HTTP GET-based queries, a request should
    have the following HTTP query parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '`query` for the GraphQL query (mandatory parameter).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`operationName` for the operation name, used when multiple queries are sent
    in a single document. This parameter tells the GraphQL server which specific operation
    to run when more than one is present (optional parameter).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`variables` for query variables (optional parameter).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For HTTP POST-based queries, the same parameters should be passed in the HTTP
    body in JSON.
  prefs: []
  type: TYPE_NORMAL
- en: When GraphQL servers accept queries using GET, you can pass the `query` parameter
    along with the GraphQL query (in this case, the query `{__typename}`) by using
    shorthand syntax. With this in mind, we can automate the detection of GraphQL
    by using Nmap fairly easily. [Listing 4-6](#listing4-6) shows how to run a `__typename`
    query with Nmap.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 4-6: Detecting GraphQL by using GET-based queries with Nmap'
  prefs: []
  type: TYPE_NORMAL
- en: In this example, the Nmap script *http-grep* uses the GET method under the hood
    to do its work.
  prefs: []
  type: TYPE_NORMAL
- en: If you have more than a handful of hosts to scan, you may want to leverage Nmap’s
    `-iL` flag to point to a file that contains a list of hostnames, as shown in [Listing
    4-7](#listing4-7).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 4-7: Scanning multiple targets defined in a file with Nmap'
  prefs: []
  type: TYPE_NORMAL
- en: The *hosts.txt* file in this example would contain IP addresses or Domain Name
    System (DNS) hostnames listed on separate lines.
  prefs: []
  type: TYPE_NORMAL
- en: If the GraphQL server does not support GET-based queries, we can use cURL and
    the `__typename` field to make a POST request to detect GraphQL, as shown in [Listing
    4-8](#listing4-8).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 4-8: Sending a POST-based query using cURL'
  prefs: []
  type: TYPE_NORMAL
- en: To use this detection method against a list of hosts, you can use Bash scripting,
    as shown in [Listing 4-9](#listing4-9).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 4-9: A Bash script to automate a POST-based GraphQL detection using
    cURL'
  prefs: []
  type: TYPE_NORMAL
- en: The *hosts.txt* file in this example would contain a list of full target URLs
    on separate lines (including their protocol schemes, domains, ports, and endpoints).
  prefs: []
  type: TYPE_NORMAL
- en: Graphw00f
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In Chapter 2, we briefly discussed Graphw00f, a GraphQL tool based on Python
    for detecting GraphQL and performing implementation-level fingerprinting. In this
    section, we will use it to detect DVGA in our lab, walking you through how it
    does its detection magic.
  prefs: []
  type: TYPE_NORMAL
- en: We mentioned earlier in this chapter that GraphQL servers are found at the endpoint
    */graphql* by default. When this is not the case, we might need an automated way
    to iterate through known endpoints in order to figure out where queries are served
    from. Graphw00f allows you to specify a custom list of endpoints when running
    a scan. If you don’t provide a list, Graphw00f will use its hardcoded list of
    common endpoints whenever it is tasked with detecting GraphQL, as shown in [Listing
    4-10](#listing4-10).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 4-10: A list of common GraphQL endpoints in Graphw00f’s source code'
  prefs: []
  type: TYPE_NORMAL
- en: To see Graphw00f in action, open your terminal and execute the command in [Listing
    4-11](#listing4-11). We use command line parameters `-t` (target) and `-d` (detection).
    The `-t` flag in this case will be the remote URL *http://localhost:5013*, and
    the `-d` flag will turn on detection mode, which indicates to Graphw00f that it
    should run a GraphQL detection check against the target URL. If you have questions
    about Graphw00f’s arguments, use the `-h` flag to read more about its options.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 4-11: A GraphQL detection with Graphw00f'
  prefs: []
  type: TYPE_NORMAL
- en: Run in detect mode, Graphw00f iterates through various web paths. It checks
    for the existence of GraphQL in the main web root folder and the */graphql* folder.
    Then it signals to us that it found GraphQL under */graphql* based on the HTTP
    response heuristics we discussed earlier.
  prefs: []
  type: TYPE_NORMAL
- en: To use your own list of endpoints, you can pass the `-w` (wordlist) flag and
    point it at a file containing your endpoints, as shown in [Listing 4-12](#listing4-12).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 4-12: Using a custom endpoint list with Graphw00f'
  prefs: []
  type: TYPE_NORMAL
- en: Detecting GraphiQL Explorer and GraphQL Playground
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The GraphiQL Explorer and GraphQL Playground IDEs are built using the JavaScript
    library React. Yet when performing reconnaissance, we will often rely on tools
    that are incapable of rendering web pages containing JavaScript, such as command
    line HTTP clients like cURL or web application scanners like Nikto. In the process,
    we might miss interesting web interfaces.
  prefs: []
  type: TYPE_NORMAL
- en: In general, you’ll find it beneficial to look for any signs of web interfaces
    available on the network, such as administration, debugging, or configuration
    panels, all of which are great candidates to hack. These panels tend to be data
    rich and often become a way to pivot to other networks or to escalate privileges.
    They also tend to be far less hardened than publicly facing applications. Companies
    assume that the external space (the internet) is riskier than the internal space
    (the corporate network). As such, they often have guidelines for securing publicly
    facing servers and applications via aggressive patching policies, configuration
    reviews, and frequent vulnerability scanning. Unfortunately, internal applications
    rarely get the same treatment, which often makes them an easier target for hackers.
  prefs: []
  type: TYPE_NORMAL
- en: An interesting and often overlooked technique to scan for graphical web interfaces
    is through the use of tools such as headless browsers. *Headless browsers* are
    fully functional command line web browsers that the user can program for a variety
    of purposes, such as retrieving page contents, submitting forms, or simulating
    real user behavior on a web page. For example, the headless browsers Selenium
    and PhantomJS can be handy when you need to render web pages containing JavaScript
    code.
  prefs: []
  type: TYPE_NORMAL
- en: 'One security tool in particular has incorporated a headless browser to solve
    this gap: *EyeWitness*. This web scanner is capable of taking screenshots of web
    pages by leveraging the Selenium headless browser driver engine behind the scenes.
    EyeWitness then generates a nice report, along with a screen capture of the page.'
  prefs: []
  type: TYPE_NORMAL
- en: Scanning for Graphical Interfaces with EyeWitness
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Since the two GraphQL IDEs use JavaScript code, we need a capable scanner to
    help us identify them when we perform network-wide scans. Let’s use EyeWitness
    to identify these graphical interfaces.
  prefs: []
  type: TYPE_NORMAL
- en: EyeWitness offers many options for customizing its scanner behavior, and you
    can see them by running the tool with the `-h` option. To detect GraphQL IDE panels,
    we’ll use the `--web` option, which will attempt a screen capture of the scanned
    site with the headless browser engine, together with the `--single` option, which
    is suitable when you need to scan only a single target URL. We will then use the
    `-d` flag to indicate to EyeWitness the folder in which it should dump the report
    (in this case, the *dvga-report* folder). [Listing 4-13](#listing4-13) puts everything
    together.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 4-13: The runtime output of EyeWitness'
  prefs: []
  type: TYPE_NORMAL
- en: In the output, EyeWitness indicates that it saved the collected web page source
    files in the *dvga-report* folder and asks us whether to open the report. Press
    Y and ENTER to open a web browser displaying the HTML report, including the screenshot
    it took during the scan. [Figure 4-1](#figure4-1) shows the report.
  prefs: []
  type: TYPE_NORMAL
- en: '![](image_fi/502840c04/f04001.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4-1: An HTML report produced by EyeWitness'
  prefs: []
  type: TYPE_NORMAL
- en: 'Additionally, the *dvga-report* will contain several folders, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: The *report.html* file includes information about the target, such as the HTTP
    response headers it sent back to the client, a screen capture of the application
    running on the target, and a link to the web page’s source code. While you can
    visually identify the GraphiQL IDE by using the screen capture taken by EyeWitness,
    you can also confirm your finding by searching the *source* folder, where the
    source code files reside. Run the command shown in [Listing 4-14](#listing4-14)
    to search for any GraphiQL Explorer or GraphQL Playground strings within the source
    code.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 4-14: Keyword matches in the web page source code'
  prefs: []
  type: TYPE_NORMAL
- en: Let’s break down the command to explain what’s happening here. We run a case-insensitive
    search using `grep` by passing it the `i` flag to find any instances of the words
    *graphql* or *graphql-playground* in the *source* folder. Using the `-H` flag,
    we tell `grep` to print the names of files containing any pattern matches. The
    `-n` flag indicates the line number at which the match is located (in this case,
    18). The `-o` flag prints only the parts of matching lines that yielded positive
    results. As you can see, the search found multiple instances of the string *graphiql*
    at line number 18.
  prefs: []
  type: TYPE_NORMAL
- en: EyeWitness can run the same type of scan against a list of URLs, as opposed
    to a single URL, using the `-f` (file) flag. When you use this flag, EyeWitness
    will expect a text file containing a list of target URLs to scan. [Listing 4-15](#listing4-15)
    shows how to write a single URL (*http://localhost:5013/graphiql*) to a text file
    (*urls.txt*) and pass it on to EyeWitness as its custom URL list.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 4-15: Scanning multiple URLs with EyeWitness'
  prefs: []
  type: TYPE_NORMAL
- en: EyeWitness iterates over the URLs specified in the file, scans them, and saves
    its output into the *dvga-report* folder for further inspection.
  prefs: []
  type: TYPE_NORMAL
- en: In this example, we used a file that contains only a single URL. Often, you
    may want to search for any additional web paths beyond the */graphql* endpoint
    to check whether GraphQL lives in an alternative location, particularly one that’s
    obscure. You could create a list of URLs to use with EyeWitness in multiple ways.
    The first option is to use the list of common GraphQL endpoints mentioned in “Common
    Endpoints” on page 73.
  prefs: []
  type: TYPE_NORMAL
- en: Alternatively, use one of Kali’s built-in directory wordlists, located at */usr/share/wordlists*.
    One such example is the *dirbuster* wordlist. EyeWitness needs full URLs, and
    this wordlist contains only web paths, so we’d first need to format it using a
    Bash script, as shown in [Listing 4-16](#listing4-16).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 4-16: Using Bash and a directory wordlist to build a list of URLs'
  prefs: []
  type: TYPE_NORMAL
- en: This Bash `for` loop ensures that the directories in the wordlist *directory-list-2.3-small.txt*
    are appended to our target host (*http://localhost:5013*) so EyeWitness can use
    them in its scan. All that’s left is to run EyeWitness with our new wordlist file,
    *urls.txt*.
  prefs: []
  type: TYPE_NORMAL
- en: Attempting a Query Using Graphical Clients
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Finding instances of GraphiQL Explorer or GraphQL Playground in a penetration
    test doesn’t guarantee that the GraphQL API itself will allow you to make unauthorized
    queries. Because both GraphiQL Explorer and GraphQL Playground are simply frontend
    interfaces to a GraphQL API, they are effectively HTTP clients that interact with
    a GraphQL server.
  prefs: []
  type: TYPE_NORMAL
- en: In some cases, these graphical interfaces might fail to query the API for multiple
    reasons. An authentication or authorization layer might be implemented in the
    GraphQL API that prevents unauthorized queries. The API might also restrict queries
    based on client properties, such as geographical location or an IP address–based
    allow list. Client-side mitigations could also prevent clients from running queries
    through GraphiQL Explorer or GraphQL Playground.
  prefs: []
  type: TYPE_NORMAL
- en: To confirm that we can use the interface to query the GraphQL server, we will
    need to send some form of an unauthenticated GraphQL query. The query must be
    one that will work on any GraphQL API. Think of this query as a way to confirm
    that the remote GraphQL API is accepting unauthenticated queries from clients.
    We might call it a *canary* *GraphQL query*.
  prefs: []
  type: TYPE_NORMAL
- en: Open the Firefox web browser in your lab machine and navigate to ***http://localhost:5013/***
    to access the DVGA. You should see the DVGA’s main page. Next, browse to the GraphiQL
    Explorer panel we discovered earlier at *http://localhost:5013/graphiql*. You
    will notice that we get an immediate error, indicating that our access was rejected,
    with the message `400` `Bad` `Request:` `GraphiQL` `Access` `Rejected`, as shown
    in [Figure 4-2](#figure4-2).
  prefs: []
  type: TYPE_NORMAL
- en: '![](image_fi/502840c04/f04002.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4-2: The GraphiQL Explorer rejecting client access'
  prefs: []
  type: TYPE_NORMAL
- en: As hackers, it’s important to look at how things work under the hood. Click
    the **Docs** button located at the top right of the window. You should see an
    error message, `No Schema Available`. This error means that GraphiQL Explorer
    wasn’t able to retrieve schema information from the API. Because GraphiQL Explorer
    automatically sends an introspection query to the GraphQL API to populate the
    documentation section with schema information on every page load, it relies on
    this documentation being available.
  prefs: []
  type: TYPE_NORMAL
- en: You can see this behavior by using the Developer Tools in Firefox. Press SHIFT-F9
    or right-click anywhere in the web page and select **Inspect Element** to open
    the Developer Tools console. Click the **Network** tab; then reload the page by
    pressing F5.
  prefs: []
  type: TYPE_NORMAL
- en: You should be able to see a POST request sent to the */graphiql* endpoint. [Figure
    4-3](#figure4-3) shows this introspection query.
  prefs: []
  type: TYPE_NORMAL
- en: '![](image_fi/502840c04/f04003.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4-3: A GraphiQL Explorer introspection query shown in Firefox Developer
    Tools'
  prefs: []
  type: TYPE_NORMAL
- en: If the introspection query was successfully sent, what could possibly be rejecting
    our access to GraphiQL Explorer? Let’s continue to explore the Developer Tools
    in Firefox for clues. Click the **Storage** tab, shown in [Figure 4-4](#figure4-4).
  prefs: []
  type: TYPE_NORMAL
- en: '![](image_fi/502840c04/f04004.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4-4: The Developer Tools Storage tab in Firefox'
  prefs: []
  type: TYPE_NORMAL
- en: The Storage tab gives us a view of the HTTP cookies that were set up by the
    application, as well as access to the browser’s local and session storage. On
    the left pane, click the **Cookies** drop-down menu and select **http://localhost:5013**
    to see the specific cookies for the domain, as shown in [Figure 4-5](#figure4-5).
  prefs: []
  type: TYPE_NORMAL
- en: '![](image_fi/502840c04/f04005.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4-5: HTTP cookies'
  prefs: []
  type: TYPE_NORMAL
- en: 'You’ll notice that, in the right pane, we have two keys set in our HTTP cookies:
    `env` and `session`. The `env` key in particular is interesting, because it appears
    to have the string `graphiql:disable` set as its value. As hackers, this should
    ring a bell or two. Is it possible that this cookie value is responsible for GraphiQL
    Explorer’s denying access? We can find out by tampering with its value.'
  prefs: []
  type: TYPE_NORMAL
- en: Double-click the text `graphiql:disable`, which will allow you to modify it;
    then simply remove `disable` and replace it with `enable`. Next, refresh the web
    page. You’ll notice that we no longer see the rejection message in GraphiQL Explorer.
    To confirm that tampering with the cookie actually works, attempt to run a GraphQL
    query. You should be able to get a response from the GraphQL API! This is an example
    of a weak client-side security control that can easily be circumvented.
  prefs: []
  type: TYPE_NORMAL
- en: Developers often create web applications with the mindset that clients are to
    be trusted, but not everyone will play by the rules. Threat actors who are interested
    in finding loopholes will tamper with applications and attempt to defeat any countermeasures
    in place. It’s important to remember that anything an attacker can directly control
    can potentially be circumvented. Yet controls implemented on the client are not
    a rare thing to see; you may find applications implementing input validation or
    file upload validation only on the client side. These can often be bypassed. In
    Chapter 7, you’ll learn more about defeating GraphQL authorization and authentication
    mechanisms.
  prefs: []
  type: TYPE_NORMAL
- en: Querying GraphQL by Using Introspection
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Introspection is one of GraphQL’s key features, as it provides information about
    the various types and fields the GraphQL schema supports. A self-documenting API
    is very useful for anyone who needs to consume it, such as third-party businesses
    or other clients.
  prefs: []
  type: TYPE_NORMAL
- en: As hackers, one of the first things we want to test when we run into a GraphQL
    application is whether its introspection mechanism is enabled. Many GraphQL implementations
    enable introspection by default. Some implementations might have an option to
    disable introspection, but others might not. For example, the Python GraphQL implementation
    Graphene does not provide the option to disable introspection. To do so, the consumer
    would have to dig into the code and identify ways to prevent introspection queries
    from being processed. On the other hand, the GraphQL PHP implementation graphql-php
    enables introspection by default but also documents how to completely disable
    this feature. [Table 4-2](#table4-2) shows the state of introspection in some
    of the popular GraphQL server implementations.
  prefs: []
  type: TYPE_NORMAL
- en: 'Table 4-2: The State of Introspection in GraphQL Implementations'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Language** | **Implementation** | **Introspection configuration** | **Disable
    introspection option** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| Python | Graphene | Enabled by default | Not available |'
  prefs: []
  type: TYPE_TB
- en: '| Python | Ariadne | Enabled by default | Available |'
  prefs: []
  type: TYPE_TB
- en: '| PHP | graphql-php | Enabled by default | Available |'
  prefs: []
  type: TYPE_TB
- en: '| Go | graphql-go | Enabled by default | Not available |'
  prefs: []
  type: TYPE_TB
- en: '| Ruby | graphql-ruby | Enabled by default | Available |'
  prefs: []
  type: TYPE_TB
- en: '| Java | graphql-java | Enabled by default | Not available |'
  prefs: []
  type: TYPE_TB
- en: Any default setting that directly impacts security is always good news for hackers.
    Application maintainers rarely change these default settings. (Some maintainers
    may not even be aware of them.) In [Table 4-2](#table4-2), you can see that in
    some cases—such as in graphql-go, graphql-java, and Graphene—introspection can
    be disabled only if the application maintainers code the solution into the GraphQL
    API themselves; there is no official, vendor-vetted solution to disable it.
  prefs: []
  type: TYPE_NORMAL
- en: While opinions on this matter vary, especially in security circles, introspection
    in GraphQL is widely considered a feature and not a vulnerability. Companies that
    adopt GraphQL may choose to keep it enabled, while others may disable it to avoid
    disclosing information that could be leveraged in attacks. If no external consumers
    integrate with a GraphQL API, it’s possible that developers could disable introspection
    altogether without impacting normal application flows.
  prefs: []
  type: TYPE_NORMAL
- en: Depending on your target, the response to an introspection query could be fairly
    large. Also, if you’re attacking a target with a mature security program, these
    queries may be monitored for any attempts from untrusted clients, such as those
    in new geographical locations or with new IP addresses.
  prefs: []
  type: TYPE_NORMAL
- en: To experiment with the introspection query by using our vulnerable server, open
    the Altair client in your lab and ensure that the address bar is set to *http://localhost:5013/graphql*.
    Next, enter the introspection query shown in [Listing 4-17](#listing4-17) and
    execute it in Altair.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 4-17: An introspection query in its simplest form'
  prefs: []
  type: TYPE_NORMAL
- en: 'This query uses the meta-field `__schema`, which is the type name of the GraphQL
    schema introspection system. It then requests the `name` of all `types` available
    in the GraphQL server. The following output shows the server’s response to the
    query:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: While we receive a valid response, this query in its current form gives us only
    a partial view of the features available through the API. The response is missing
    key information, such as query and mutation names, information about which queries
    allow arguments to be passed by clients, the data types of arguments (such as
    scalar types like `String` [PRE24]
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
