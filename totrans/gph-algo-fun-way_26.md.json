["```\nclass HeapItem: \n    def __init__(self, value, priority: float):\n        self.value = value\n        self.priority = priority\n\n  ❶ def __lt__(self, other):\n        return self.priority < other.priority\n\n  ❷ def __gt__(self, other):\n        return self.priority > other.priority \n```", "```\nclass PriorityQueue:\n    def __init__(self, size: int = 100, min_heap: bool = False): \n        self.array_size: int = size\n      ❶ self.heap_array: list = [None] * size\n        self.last_index: int = 0\n        self.is_min_heap: bool = min_heap\n        self.indices: dict = {}\n\n    def size(self) -> int: \n        return self.last_index\n\n    def is_empty(self) -> bool: \n        return self.last_index == 0\n\n    def in_queue(self, value) -> bool: \n        return value in self.indices\n\n    def get_priority(self, value) -> Union[float, None]: \n        if not value in self.indices:\n            return None\n        ind: int = self.indices[value]\n        return self.heap_array[ind].priority \n```", "```\ndef _elements_inverted(self, parent: int, child: int) -> bool: \n  ❶ if parent < 1 or parent > self.last_index:\n        return False\n    if child < 1 or child > self.last_index:\n        return False\n\n  ❷ if self.is_min_heap:\n        return self.heap_array[parent] > self.heap_array[child]\n    else:\n        return self.heap_array[parent] < self.heap_array[child] \n```", "```\ndef _swap_elements(self, index1: int, index2: int): \n  ❶ if index1 < 1 or index1 > self.last_index:\n        return\n    if index2 < 1 or index2 > self.last_index:\n        return\n\n    item1: HeapItem = self.heap_array[index1]\n    item2: HeapItem = self.heap_array[index2]\n    self.heap_array[index1] = item2\n    self.heap_array[index2] = item1\n\n  ❷ self.indices[item1.value] = index2\n    self.indices[item2.value] = index1 \n```", "```\ndef _propagate_up(self, index: int): \n    parent: int = int(index / 2)\n  ❶ while self._elements_inverted(parent, index):\n        self._swap_elements(parent, index)\n        index = parent\n        parent = int(index / 2) \n```", "```\ndef _propagate_down(self, index: int): \n    while index <= self.last_index:\n        swap: int = index\n        if self._elements_inverted(swap, 2*index):\n            swap = 2*index\n        if self._elements_inverted(swap, 2*index+1):\n            swap = 2*index + 1\n\n      ❶ if index != swap:\n            self._swap_elements(index, swap)\n            index = swap\n        else:\n          ❷ break \n```", "```\ndef enqueue(self, value, priority: float): \n  ❶ if value in self.indices:\n        self.update_priority(value, priority)\n        return\n\n  ❷ if self.last_index == self.array_size - 1:\n        old_array: list = self.heap_array\n        self.heap_array = [None] * self.array_size * 2\n        for i in range(self.last_index + 1):\n            self.heap_array[i] = old_array[i]\n        self.array_size = self.array_size * 2\n\n    self.last_index = self.last_index + 1\n    self.heap_array[self.last_index] = HeapItem(value, priority)\n    self.indices[value] = self.last_index\n    self._propagate_up(self.last_index) \n```", "```\ndef dequeue(self): \n    if self.last_index == 0:\n        return None\n\n  ❶ result: HeapItem = self.heap_array[1]\n    new_top: HeapItem = self.heap_array[self.last_index]\n    self.heap_array[1] = new_top\n    self.indices[new_top.value] = 1\n\n    self.heap_array[self.last_index] = None\n    self.indices.pop(result.value)\n    self.last_index = self.last_index - 1\n\n    self._propagate_down(1)\n    return result.value \n```", "```\ndef update_priority(self, value, priority: float): \n    if not value in self.indices:\n        return\n\n    index: int = self.indices[value]\n    old_priority: float = self.heap_array[index].priority\n    self.heap_array[index].priority = priority\n\n    if self.is_min_heap:\n        if old_priority > priority:\n            self._propagate_up(index)\n        else:\n            self._propagate_down(index)\n    else:\n        if old_priority > priority:\n            self._propagate_down(index)\n        else:\n            self._propagate_up(index) \n```", "```\ndef peak_top(self) -> Union[HeapItem, None]: \n    if self.is_empty():\n        return None\n    return self.heap_array[1]\n\ndef peek_top_priority(self) -> Union[float, None]: \n    obj: Union[HeapItem, None] = self.peak_top()\n    if not obj:\n        return None\n    return obj.priority\n\ndef peek_top_value(self): \n    obj: Union[HeapItem, None] = self.peak_top()\n    if not obj:\n        return None\n    return obj.value \n```"]