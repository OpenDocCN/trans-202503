<html><head></head><body>
<h2 class="h2" id="ch13"><span epub:type="pagebreak" id="page_406"/><span epub:type="pagebreak" id="page_407"/><strong><span class="big">13</span><br/>CONTAINERS</strong></h2>&#13;
<p class="quote"><em>Fixing bugs in <code>std::vector</code> is equal parts delight (it is the bestest data structure) and terror (if I mess it up, the world explodes).<br/>—Stephan T. Lavavej (Principal Developer, Visual C++ Libraries). Tweet dated 3:11 am on August 22, 2016.</em></p>&#13;
<div class="image1"><img src="../images/common.jpg" alt="Image"/></div>&#13;
<p class="noindent">The <em>standard template library</em> (<em>STL</em>) is the portion of the stdlib that provides containers and the algorithms to manipulate them, with iterators serving as the interface between the two. In the next three chapters, you’ll learn more about each of these components.</p>&#13;
<p class="indent">A <em>container</em> is a special data structure that stores objects in an organized way that follows specific access rules. There are three kinds of containers:</p>&#13;
<ul>&#13;
<li class="noindent">Sequence containers store elements consecutively, as in an array.</li>&#13;
<li class="noindent">Associative containers store sorted elements.</li>&#13;
<li class="noindent">Unordered associative containers store hashed objects.</li>&#13;
</ul>&#13;
<p class="indent">Associative and unordered associative containers offer rapid search for individual elements. All containers are RAII wrappers around their contained objects, so they manage the storage durations and lifetimes of the elements they own. Additionally, each container provides some set of member functions that perform various operations on the object collection.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_408"/>Modern C++ programs use containers all the time. Which container you choose for a particular application depends on the required operations, the contained objects’ characteristics, and efficiencies under particular access patterns. This chapter surveys the vast container landscape covered between the STL and Boost. Because there are so many containers in these libraries, you’ll explore the most popular ones.</p>&#13;
<h3 class="h3" id="ch13lev1sec1"><strong>Sequence Containers</strong></h3>&#13;
<p class="noindent"><em>Sequence containers</em> are STL containers that allow sequential member access. That is, you can start from one end of the container and iterate through to the other end. But except for this commonality, sequence containers are a varied and motley crew. Some containers have a fixed length; others can shrink and grow as program needs dictate. Some allow indexing directly into the container, whereas you can only access others sequentially. Additionally, each sequence container has unique performance characteristics that make it desirable in some situations and undesirable in others.</p>&#13;
<p class="indent">Working with sequence containers should feel intuitive because you’ve been acquainted with a primitive one since “Arrays” on <a href="ch02.xhtml#page_42">page 42</a>, where you saw the built-in or “C-style” array <code>T[]</code>. You’ll begin the survey of sequence containers by looking at the built-in array’s more sophisticated, cooler younger brother <code>std::array</code>.</p>&#13;
<h4 class="h4" id="ch13lev2sec1"><strong><em>Arrays</em></strong></h4>&#13;
<p class="noindent">The STL provides <code>std::array</code> in the <code>&lt;array&gt;</code> header. An <code>array</code> is a sequential container that holds a fixed-size, contiguous series of elements. It combines the sheer performance and efficiency of built-in arrays with the modern conveniences of supporting copy/move construction/assignment, knowing its own size, providing bounds-checked member access, and other advanced features.</p>&#13;
<p class="indent">You should use <code>array</code> instead of built-in arrays in virtually all situations. It supports almost all the same usage patterns as <code>operator[]</code> to access elements, so there aren’t many situations in which you’ll need a built-in array instead.</p>&#13;
<div class="note">&#13;
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>&#13;
<p class="notep"><em>Boost also offers a <code>boost::array</code> in Boost Array’s <code>&lt;boost/array.hpp&gt;</code>. You shouldn’t need to use the Boost version unless you have a very old C++ tool chain.</em></p>&#13;
</div>&#13;
<h5 class="h5" id="ch13lev3sec1"><strong>Constructing</strong></h5>&#13;
<p class="noindent">The <code>array&lt;</code><span class="codeitalic">T, S &gt;</span> class template takes two template parameters:</p>&#13;
<ul>&#13;
<li class="noindent">The contained type <span class="codeitalic">T</span></li>&#13;
<li class="noindent">The fixed size of the array <span class="codeitalic">S</span></li>&#13;
</ul>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_409"/>You can construct an <code>array</code> and built-in arrays using the same rules. To summarize these rules from “Arrays” on <a href="ch02.xhtml#page_42">page 42</a>, the preferred method is to use braced initialization to construct an <code>array</code>. Braced initialization fills the <code>array</code> with the values contained in the braces and fills the remaining elements with zeros. If you omit initialization braces, the <code>array</code> contains uninitialized values depending on its storage duration. <a href="ch13.xhtml#ch13ex01">Listing 13-1</a> illustrates braced initialization with several <code>array</code> declarations.</p>&#13;
<pre>#include &lt;array&gt;&#13;
&#13;
std::array&lt;int, 10&gt; static_array{} <span class="ent">➊</span>&#13;
&#13;
TEST_CASE("std::array") {&#13;
  REQUIRE(static_array[0] == 0); <span class="ent">➋</span>&#13;
&#13;
  SECTION("uninitialized without braced initializers") {&#13;
    std::array&lt;int, 10&gt; local_array; <span class="ent">➌</span>&#13;
    REQUIRE(local_array[0] != 0); <span class="ent">➍</span>&#13;
  }&#13;
&#13;
  SECTION("initialized with braced initializers") {&#13;
    std::array&lt;int, 10&gt; local_array{ 1, 1, 2, 3 }; <span class="ent">➎</span>&#13;
    REQUIRE(local_array[0] == 1);&#13;
    REQUIRE(local_array[1] == 1);&#13;
    REQUIRE(local_array[2] == 2);&#13;
    REQUIRE(local_array[3] == 3);&#13;
    REQUIRE(local_array[4] == 0); <span class="ent">➏</span>&#13;
  }&#13;
}</pre>&#13;
&#13;
<p class="listing"><a id="ch13ex01"/><em>Listing 13-1: Initializing a <code>std::array</code>. You might get compiler warnings from <code>REQUIRE(local_array[0] != 0);</code> <span class="ent">➍</span>, since <code>local_array</code> has uninitialized elements.</em></p>&#13;
<p class="indent">You declare an <code>array</code> of 10 <code>int</code> objects called <code>static_array</code> with static storage duration <span class="ent">➊</span>. You haven’t used braced initialization, but its elements initialize to zero anyway <span class="ent">➋</span>, thanks to the initialization rules covered in “Arrays” on <a href="ch02.xhtml#page_42">page 42</a>.</p>&#13;
<p class="indent">Next, you try declaring another <code>array</code> of 10 <code>int</code> objects, this time with automatic storage duration <span class="ent">➌</span>. Because you haven’t used braced initialization, <code>local_array</code> contains uninitialized elements (that have an extremely low probability of equaling zero <span class="ent">➍</span>).</p>&#13;
<p class="indent">Finally, you use braced initialization to declare another <code>array</code> and to fill the first four elements <span class="ent">➎</span>. All remaining elements get set to zero <span class="ent">➏</span>.</p>&#13;
<h5 class="h5" id="ch13lev3sec2"><strong>Element Access</strong></h5>&#13;
<p class="noindent">The three main methods by which you can access arbitrary <code>array</code> elements are:</p>&#13;
<ul>&#13;
<li class="noindent"><code>operator[]</code></li>&#13;
<li class="noindent"><code>at</code></li>&#13;
<li class="noindent"><code>get</code></li>&#13;
</ul>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_410"/>The <code>operator[]</code> and <code>at</code> methods take a single <code>size_t</code> argument corresponding to the index of the desired element. The difference between these two lies in bounds checking: if the index argument is out of bounds, <code>at</code> will throw a <code>std::out_of_range</code> exception, whereas <code>operator[]</code> will cause undefined behavior. The function template <code>get</code> takes a template parameter of the same specification. Because it’s a template, the index must be known at compile time.</p>&#13;
<div class="note">&#13;
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>&#13;
<p class="notep"><em>Recall from “The <code>size_t</code> Type” on <a href="ch02.xhtml#page_41">page 41</a> that a <code>size_t</code> object guarantees that its maximum value is sufficient to represent the maximum size in bytes of all objects. It is for this reason that <code>operator[]</code> and <code>at</code> take a <code>size_t</code> rather than an <code>int</code>, which makes no such guarantee.</em></p>&#13;
</div>&#13;
<p class="indent">A major bonus of using <code>get</code> is that you get compile-time bounds checking, as illustrated in <a href="ch13.xhtml#ch13ex02">Listing 13-2</a>.</p>&#13;
<pre>TEST_CASE("std::array access") {&#13;
   std::array&lt;int, 4&gt; fib{ 1, 1, 0, 3}; <span class="ent">➊</span>&#13;
&#13;
  SECTION("operator[] can get and set elements") {&#13;
    fib[2] = 2; <span class="ent">➋</span>&#13;
    REQUIRE(fib[2] == 2); <span class="ent">➌</span>&#13;
    // fib[4] = 5; <span class="ent">➍</span>&#13;
  }&#13;
&#13;
  SECTION("at() can get and set elements") {&#13;
    fib.at(2) = 2; <span class="ent">➎</span>&#13;
    REQUIRE(fib.at(2) == 2); <span class="ent">➏</span>&#13;
    REQUIRE_THROWS_AS(fib.at(4), std::out_of_range); <span class="ent">➐</span>&#13;
  }&#13;
  SECTION("get can get and set elements") {&#13;
    std::get&lt;2&gt;(fib) = 2; <span class="ent">➑</span>&#13;
    REQUIRE(std::get&lt;2&gt;(fib) == 2); <span class="ent">➒</span>&#13;
    // std::get&lt;4&gt;(fib); <span class="ent">➓</span>&#13;
  }&#13;
}</pre>&#13;
<p class="listing"><a id="ch13ex02"/><em>Listing 13-2: Accessing elements of an <code>array</code>. Uncommenting <code>// fib[4] = 5;</code></em> <span class="ent">➍</span> <em>will cause undefined behavior, whereas uncommenting <code>// std::get&lt;4&gt;(fib);</code></em> <span class="ent">➓</span> <em>will cause compilation failure.</em></p>&#13;
<p class="indent">You declare an array of length 4 called <code>fib</code> <span class="ent">➊</span>. Using <code>operator[]</code> <span class="ent">➋</span> you can set elements and retrieve them <span class="ent">➌</span>. The out of bounds write you’ve commented out would cause undefined behavior; there is no bounds checking with <code>operator[]</code> <span class="ent">➍</span>.</p>&#13;
<p class="indent">You can use <code>at</code> for the same read <span class="ent">➎</span> and write <span class="ent">➏</span> operations, and you can safely perform an out-of-bounds operation thanks to bounds checking <span class="ent">➐</span>.</p>&#13;
<p class="indent">Finally, you can use <code>std::get</code> to <code>set</code> <span class="ent">➑</span> and <code>get</code> <span class="ent">➒</span> elements. The <code>get</code> element also performs bounds checking, so <code>// std::get&lt;4&gt;(fib);</code> <span class="ent">➓</span> will fail to compile if uncommented.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_411"/>You’ve also have a <code>front</code> and a <code>back</code> method, which return references to the first and last elements of the array. You’ll get undefined behavior if you call one of these methods if the array has zero length, as <a href="ch13.xhtml#ch13ex03">Listing 13-3</a> illustrates.</p>&#13;
<pre>TEST_CASE("std::array has convenience methods") {&#13;
  std::array&lt;int, 4&gt; fib{ 0, 1, 2, 0 };&#13;
&#13;
  SECTION("front") {&#13;
    fib.front() = 1; <span class="ent">➊</span>&#13;
    REQUIRE(fib.front() == 1); <span class="ent">➋</span>&#13;
    REQUIRE(fib.front() == fib[0]); <span class="ent">➌</span>&#13;
  }&#13;
&#13;
  SECTION("back") {&#13;
    fib.back() = 3; <span class="ent">➍</span>&#13;
    REQUIRE(fib.back() == 3); <span class="ent">➎</span>&#13;
    REQUIRE(fib.back() == fib[3]); <span class="ent">➏</span>&#13;
  }&#13;
}</pre>&#13;
<p class="listing"><a id="ch13ex03"/><em>Listing 13-3: Using the convenience methods <code>front</code> and <code>back</code> on a <code>std::array</code></em></p>&#13;
<p class="indent">You can use the <code>front</code> and <code>back</code> methods to set <span class="ent">➊</span><span class="ent">➍</span> and get <span class="ent">➋</span><span class="ent">➎</span> the first and last elements of an <code>array</code>. Of course, <code>fib[0]</code> is identical to <code>fib.front()</code> <span class="ent">➌</span>, and <code>fib[3]</code> is identical to <code>fib.back()</code> <span class="ent">➏</span>. The <code>front()</code> and <code>back()</code> methods are simply convenience methods. Additionally, if you’re writing generic code, some containers will offer <code>front</code> and <code>back</code> but not <code>operator[]</code>, so it’s best to use the <code>front</code> and <code>back</code> methods.</p>&#13;
<h5 class="h5" id="ch13lev3sec3"><strong>Storage Model</strong></h5>&#13;
<p class="noindent">An <code>array</code> doesn’t make allocations; rather, like a built-in array, it contains all of its elements. This means copies will generally be expensive, because each constituent element needs to be copied. Moves can be expensive, depending on whether the underlying type of the <code>array</code> also has move construction and move assignment, which are relatively inexpensive.</p>&#13;
<p class="indent">Each <code>array</code> is just a built-in array underneath. In fact, you can extract a pointer to the first element of an <code>array</code> using four distinct methods:</p>&#13;
<ul>&#13;
<li class="noindent">The go-to method is to use the <code>data</code> method. As advertised, this returns a pointer to the first element.</li>&#13;
<li class="noindent">The other three methods involve using the address-of operator <code>&amp;</code> on the first element, which you can obtain using <code>operator[]</code>, <code>at</code>, and <code>front</code>.</li>&#13;
</ul>&#13;
<p class="indent">You should use <code>data</code>. If the <code>array</code> is empty, the address-of-based approaches will return undefined behavior.</p><p class="indent"><a href="ch13.xhtml#ch13ex04">Listing 13-4</a> illustrates how to obtain a pointer using these four methods.</p>&#13;
<pre><span epub:type="pagebreak" id="page_412"/>TEST_CASE("We can obtain a pointer to the first element using") {&#13;
  std::array&lt;char, 9&gt; color{ 'o',  'c', 't', 'a', 'r', 'i', 'n', 'e' };&#13;
  const auto* color_ptr = color.data(); <span class="ent">➊</span>&#13;
&#13;
  SECTION("data") {&#13;
    REQUIRE(*color_ptr == 'o'); <span class="ent">➋</span>&#13;
  }&#13;
  SECTION("address-of front") {&#13;
    REQUIRE(&amp;color.front() == color_ptr); <span class="ent">➌</span>&#13;
  }&#13;
  SECTION("address-of at(0)") {&#13;
    REQUIRE(&amp;color.at(0) == color_ptr); <span class="ent">➍</span>&#13;
  }&#13;
  SECTION("address-of [0]") {&#13;
    REQUIRE(&amp;color[0] == color_ptr); <span class="ent">➎</span>&#13;
  }&#13;
}</pre>&#13;
<p class="listing"><a id="ch13ex04"/><em>Listing 13-4: Obtaining a pointer to the first element of a <code>std::array</code></em></p>&#13;
<p class="indent">After initializing the <code>array color</code>, you obtain a pointer to the first element, the letter <code>o</code>, using the <code>data</code> method <span class="ent">➊</span>. When you dereference the resulting <code>color_ptr</code>, you obtain the letter <code>o</code> as expected <span class="ent">➋</span>. This pointer is identical to the pointer obtained from the <code>address-of-</code>plus-<code>front</code> <span class="ent">➌</span>, -<code>at</code> <span class="ent">➍</span>, and -<code>operator[]</code> <span class="ent">➎</span> approaches.</p>&#13;
<p class="indent">To conclude arrays, you can query the size of an <code>array</code> using either the <code>size</code> or <code>max_size</code> methods. (These are identical for an <code>array</code>.) Because an <code>array</code> has a fixed size, these method’s values are static and known at compile time.</p>&#13;
<h5 class="h5" id="ch13lev3sec4"><strong>A Crash Course in Iterators</strong></h5>&#13;
<p class="noindent">The interface between containers and algorithms is the iterator. An iterator is a type that knows the internal structure of a container and exposes simple, pointer-like operations to a container’s elements. <a href="ch14.xhtml#ch14">Chapter 14</a> is dedicated entirely to iterators, but you need to know the very basics here so you can explore how to use iterators to manipulate containers and how containers expose iterators to users.</p>&#13;
<p class="indent">Iterators come in various flavors, but they all support at least the following operations:</p>&#13;
<ol>&#13;
<li class="noindent">Get the current element (<code>operator*</code>)</li>&#13;
<li class="noindent">Go to the next element (<code>operator++</code>)</li>&#13;
<li class="noindent">Assign an iterator equal to another iterator (<code>operator=</code>)</li>&#13;
</ol>&#13;
<p class="indent">You can extract iterators from all STL containers (including <code>array</code>) using their <code>begin</code> and <code>end</code> methods. The <code>begin</code> method returns an iterator pointing to the first element, and the <code>end</code> method returns a pointer to one element past the last element. <a href="ch13.xhtml#ch13fig01">Figure 13-1</a> illustrates where the <code>begin</code> and <code>end</code> iterators point in an array of three elements.</p>&#13;
<div class="image"><span epub:type="pagebreak" id="page_413"/><img src="../images/fig13_1.jpg" alt="image"/></div>&#13;
<p class="figcap" id="ch13fig01"><em>Figure 13-1: A half-open range over an <code>array</code> of three elements</em></p>&#13;
<p class="indent">The arrangement in <a href="ch13.xhtml#ch13fig01">Figure 13-1</a>, where <code>end()</code> points after the last element, is called a <em>half-open range</em>. It might seem counterintuitive at first—why not have a closed range where <code>end()</code> points to the last element—but a half-open range has some advantages. For example, if a container is empty, <code>begin()</code> will return the same value as <code>end()</code>. This allows you to know that, regardless of whether the container is empty, if the iterator equals <code>end()</code>, you’ve traversed the container.</p>&#13;
<p class="indent"><a href="ch13.xhtml#ch13ex05">Listing 13-5</a> illustrates what happens with half-open range iterators and empty containers.</p>&#13;
<pre>TEST_CASE("std::array begin/end form a half-open range") {&#13;
  std::array&lt;int, 0&gt; e{}; <span class="ent">➊</span>&#13;
  REQUIRE(e.begin()<span class="ent">➋</span> == e.end()<span class="ent">➌</span>);&#13;
}</pre>&#13;
<p class="listing"><a id="ch13ex05"/><em>Listing 13-5: With an empty <code>array</code>, the <code>begin</code> iterator equals the <code>end</code> iterator.</em></p>&#13;
<p class="indent">Here, you construct an empty array <code>e</code> <span class="ent">➊</span>, and the <code>begin</code> <span class="ent">➋</span> and <code>end</code> <span class="ent">➌</span> iterators are equal.</p>&#13;
<p class="indent"><a href="ch13.xhtml#ch13ex06">Listing 13-6</a> examines how to use iterators to perform pointer-like operations over a non-empty <code>array</code>.</p>&#13;
<pre>TEST_CASE("std::array iterators are pointer-like") {&#13;
  std::array&lt;int, 3&gt; easy_as{ 1, 2, 3 }; <span class="ent">➊</span>&#13;
  auto iter = easy_as.begin(); <span class="ent">➋</span>&#13;
  REQUIRE(*iter == 1); <span class="ent">➌</span>&#13;
  ++iter; <span class="ent">➍</span>&#13;
  REQUIRE(*iter == 2);&#13;
  ++iter;&#13;
  REQUIRE(*iter == 3); <span class="ent">➎</span>&#13;
  ++iter; <span class="ent">➏</span>&#13;
  REQUIRE(iter == easy_as.end()); <span class="ent">➐</span>&#13;
}</pre>&#13;
<p class="listing"><a id="ch13ex06"/><em>Listing 13-6: Basic <code>array</code> iterator operations</em></p>&#13;
<p class="indent">The <code>array easy_as</code> contains the elements 1, 2, and 3 <span class="ent">➊</span>. You invoke <code>begin</code> on <code>easy_as</code> to obtain an iterator <code>iter</code> pointing to the first element <span class="ent">➋</span>. The dereference operator yields the first element 1, because this is the first element in the <code>array</code> <span class="ent">➌</span>. Next, you increment <code>iter</code> so it points to the next element <span class="ent">➍</span>. You continue in this fashion until you reach the last element <span class="ent">➎</span>. Incrementing the pointer one last time puts you 1 past the last element <span class="ent">➏</span>, so <code>iter</code> equals <code>easy_as.end()</code>, indicating that you’ve traversed the <code>array</code> <span class="ent">➐</span>.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_414"/>Recall from “Range Expressions” on <a href="ch08.xhtml#page_235">page 235</a> that you can build your own types for use in range expressions by exposing a <code>begin</code> and an <code>end</code> method, as implemented in the <code>FibonacciIterator</code> in <a href="ch08.xhtml#ch08ex29">Listing 8-29</a>. Well, containers already do all this work for you, meaning you can use any STL container as a range expression. <a href="ch13.xhtml#ch13ex07">Listing 13-7</a> illustrates by iterating over an <code>array</code>.</p>&#13;
<pre>TEST_CASE("std::array can be used as a range expression") {&#13;
  std::array&lt;int, 5&gt; fib{ 1, 1, 2, 3, 5 }; <span class="ent">➊</span>&#13;
  int sum{}; <span class="ent">➋</span>&#13;
  for (const auto element : fib) <span class="ent">➌</span>&#13;
    sum += element; <span class="ent">➍</span>&#13;
  REQUIRE(sum == 12);&#13;
}</pre>&#13;
<p class="listing"><a id="ch13ex07"/><em>Listing 13-7: Range-based <code>for</code> loops and <code>array</code>s</em></p>&#13;
<p class="indent">You initialize an <code>array</code> <span class="ent">➊</span> and a <code>sum</code> variable <span class="ent">➋</span>. Because <code>array</code> is a valid range, you can use it in a ranged-based <code>for</code> loop <span class="ent">➌</span>. This enables you to accumulate the <code>sum</code> of each <code>element</code> <span class="ent">➍</span>.</p>&#13;
<h5 class="h5" id="ch13lev3sec5"><strong>A Partial List of Supported Operations</strong></h5>&#13;
<p class="noindent"><a href="ch13.xhtml#ch13tab01">Table 13-1</a> provides a partial list of <code>array</code> operations. In this table, <code>a</code>, <code>a1</code>, and <code>a2</code> are of type <code>std::array&lt;T, S&gt;</code>, <code>t</code> is of type <code>T</code>, <code>S</code> is the fixed length of the array, and <code>i</code> is of type <code>size_t</code>.</p>&#13;
<p class="tabcap"><a id="ch13tab01"/><strong>Table 13-1:</strong> A Partial List of <code>std::array</code> Operations</p>&#13;
<table class="topbot-d">&#13;
<colgroup>&#13;
<col style="width:30%"/>&#13;
<col style="width:70%"/>&#13;
</colgroup>&#13;
<tbody>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-h"><p class="tab_th"><strong>Operation</strong></p></td>&#13;
<td style="vertical-align: top;" class="table-h"><p class="tab_th"><strong>Notes</strong></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><code>array&lt;</code><span class="codestrong">T</span><code>,</code> <span class="codestrong">S</span><code>&gt;{</code> <span class="codestrong">...</span> <code>}</code></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">Performs braced initialization of a newly constructed array.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><code>~array</code></p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba">Destructs all elements contained by the array.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><span class="codestrong">a1</span> <code>=</code> <span class="codestrong">a2</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">Copy-assigns all the members of <span class="codestrong">a1</span> with the members of <span class="codestrong">a2</span>.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><span class="codestrong">a.</span><code>at</code>(<span class="codestrong">i</span>)</p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba">Returns a reference to element <span class="codestrong">i</span> of <span class="codestrong">a</span>. Throws <code>std::out_of_range</code> if out of bounds.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><span class="codestrong">a</span><code>[</code><span class="codestrong">i</span><code>]</code></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">Returns a reference to element <span class="codestrong">i</span> of <span class="codestrong">a</span>. Undefined behavior if out of bounds.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><code>get&lt;</code><span class="codestrong">i</span><code>&gt;</code><code>(</code><span class="codestrong">a</span><code>)</code></p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba">Returns a reference to element <span class="codestrong">i</span> of <span class="codestrong">a</span>. Fails to compile if out of bounds.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><span class="codestrong">a</span><code>.front()</code></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">Returns a reference to first element.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><span class="codestrong">a</span><code>.back()</code></p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba">Returns a reference to last element.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><span class="codestrong">a</span><code>.data()</code></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">Returns a raw pointer to the first element if the array is non-empty. For empty arrays, returns a valid but non-dereferencable pointer.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><span class="codestrong">a</span><code>.empty()</code></p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba">Returns <code>true</code> if the array’s size is zero; otherwise <code>false</code>.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><span class="codestrong">a</span>.<code>size()</code></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">Returns the size of the array.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><span class="codestrong">a</span><code>.max_size()</code></p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba">Identical to <span class="codestrong">a</span><code>.size()</code>.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><span class="codestrong">a</span>.<code>fill(</code><span class="codestrong">t</span><code>)</code></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">Copy-assigns <span class="codestrong">t</span> to every element of <span class="codestrong">a</span>.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><span epub:type="pagebreak" id="page_415"/><span class="codestrong">a1</span><code>.swap(</code><span class="codestrong">a2</span><code>)</code></p>&#13;
<p class="taba"><code>swap(</code><span class="codestrong">a1</span><code>,</code> <span class="codestrong">a2</span><code>)</code></p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba">Exchanges each element of <span class="codestrong">a1</span> with those of <span class="codestrong">a2</span>.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><span class="codestrong">a</span><code>.begin()</code></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">Returns an iterator pointing to the first element.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><span class="codestrong">a</span><code>.cbegin()</code></p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba">Returns a <code>const</code> iterator pointing to the first element.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><span class="codestrong">a</span><code>.end()</code></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">Returns an iterator pointing to 1 past the last element.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><span class="codestrong">a</span><code>.cend()</code></p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba">Returns a <code>const</code> iterator pointing to 1 past the last element.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-ba"><p class="taba"><span class="codestrong">a1</span> <code>==</code> <span class="codestrong">a2</span></p>&#13;
<p class="taba"><span class="codestrong">a1</span> <code>!=</code> <span class="codestrong">a2</span></p>&#13;
<p class="taba"><span class="codestrong">a1</span> <code>&gt;</code> <span class="codestrong">a2</span></p>&#13;
<p class="taba"><span class="codestrong">a1</span> <code>&gt;=</code> <span class="codestrong">a2</span></p>&#13;
<p class="taba"><span class="codestrong">a1</span> <code>&lt;</code> <span class="codestrong">a2</span></p>&#13;
<p class="taba"><span class="codestrong">a1</span> <code>&lt;=</code> <span class="codestrong">a2</span></p></td>&#13;
<td style="vertical-align: top;" class="table-ba"><p class="taba">Equal if all elements are equal.</p>&#13;
<p class="taba">Greater than/less than comparisons proceed from first element to last.</p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<div class="note">&#13;
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>&#13;
<p class="notep"><em>The partial operations in <a href="ch13.xhtml#ch13tab01">Table 13-1</a> function as quick, reasonably comprehensive references. For gritty details, refer to the freely available online references <a href="https://cppreference.com/">https://cppreference.com/</a> and <a href="http://cplusplus.com/">http://cplusplus.com/</a>, as well as Chapter 31 of  The C++ Programming Language, 4th Edition, by Bjarne Stroustrup and <a href="ch07.xhtml#ch07">Chapters 7</a>, <a href="ch08.xhtml#ch08">8</a>, and <a href="ch12.xhtml#ch12">12</a> of  The C++ Standard Library, 2nd Edition, by Nicolai M. Josuttis.</em></p>&#13;
</div>&#13;
<h4 class="h4" id="ch13lev2sec2"><strong><em>Vectors</em></strong></h4>&#13;
<p class="noindent">The <code>std::vector</code> available in the STL’s <code>&lt;vector&gt;</code> header is a sequential container that holds a dynamically sized, contiguous series of elements. A <code>vector</code> manages its storage dynamically, requiring no outside help from the programmer.</p>&#13;
<p class="indent">The <code>vector</code> is the workhorse of the sequential-data-structure stable. For a very modest overhead, you gain substantial flexibility over the <code>array</code>. Plus, <code>vector</code> supports almost all of the same operations as an <code>array</code> and adds a slew of others. If you have a fixed number of elements on hand, you should strongly consider an <code>array</code> because you’ll get some small reductions in overhead versus a <code>vector</code>. In all other situations, your go-to sequential container is the <code>vector</code>.</p>&#13;
<div class="note">&#13;
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>&#13;
<p class="notep"><em>The Boost Container library also contains a <code>boost::container::vector</code> in the <code>&lt;boost/container/vector.hpp&gt;</code> header.</em></p>&#13;
</div>&#13;
<h5 class="h5" id="ch13lev3sec6"><strong>Constructing</strong></h5>&#13;
<p class="noindent">The class template <code>std::vector&lt;T, Allocator&gt;</code> takes two template parameters. The first is the contained type <code>T</code>, and the second is the allocator type <code>Allocator</code>, which is optional and defaults to <code>std::allocator&lt;T&gt;</code>.</p>&#13;
<p class="indent">You have much more flexibility in constructing <code>vector</code>s than you do with arrays. A <code>vector</code> supports user-defined allocators because vectors need to allocate dynamic memory. You can default construct a <code>vector</code> so it contains no elements. You might want to construct an empty vector so you can fill it with a variable number of elements depending on what happens during <span epub:type="pagebreak" id="page_416"/>runtime. <a href="ch13.xhtml#ch13ex08">Listing 13-8</a> illustrates default constructing a <code>vector</code> and checking that it contains no elements.</p>&#13;
<pre>#include &lt;vector&gt;&#13;
TEST_CASE("std::vector supports default construction") {&#13;
  std::vector&lt;const char*<span class="ent">➊</span>&gt; vec; <span class="ent">➋</span>&#13;
  REQUIRE(vec.empty()); <span class="ent">➌</span>&#13;
}</pre>&#13;
<p class="listing"><a id="ch13ex08"/><em>Listing 13-8: A <code>vector</code> supports default construction.</em></p>&#13;
<p class="indent">You declare a <code>vector</code> containing elements of type <code>const char*</code> <span class="ent">➊</span> called <code>vec</code>. Because it’s been default constructed <span class="ent">➋</span>, the <code>vector</code> contains no elements, and the <code>empty</code> method returns <code>true</code> <span class="ent">➌</span>.</p>&#13;
<p class="indent">You can use braced initialization with a <code>vector</code>. Similar to how you brace initialize an array, this fills the vector with the specified elements, as <a href="ch13.xhtml#ch13ex09">Listing 13-9</a> illustrates.</p>&#13;
<pre>TEST_CASE("std::vector supports braced initialization ") {&#13;
    std::vector&lt;int&gt; fib{ 1, 1, 2, 3, 5 }; <span class="ent">➊</span>&#13;
    REQUIRE(fib[4] == 5); <span class="ent">➋</span>&#13;
}</pre>&#13;
<p class="listing"><a id="ch13ex09"/><em>Listing 13-9: A <code>vector</code> supports braced initializers.</em></p>&#13;
<p class="indent">Here, you construct a <code>vector</code> called <code>fib</code> and use braced initializers <span class="ent">➊</span>. After initialization, the <code>vector</code> contains the five elements 1, 1, 2, 3, and 5 <span class="ent">➋</span>.</p>&#13;
<p class="indent">If you want to populate a <code>vector</code> with many identical values, you can use one of the <em>fill constructors</em>. To fill construct a <code>vector</code>, you first pass a <code>size_t</code> corresponding to the number of elements you want to fill. Optionally, you can pass a <code>const</code> reference to an object to copy. Sometimes you want to initialize all your elements to the same value, for example, to keep track of counts related to particular indices. You might also have a <code>vector</code> of some user-defined type that keeps track of program state, and you might need to keep track of such state by index.</p>&#13;
<p class="indent">Unfortunately, the general rule to use braced initialization to construct objects breaks down here. With <code>vector</code>, you must use parentheses to invoke these constructors. To the compiler, <code>std::vector&lt;int&gt;{ 99, 100 }</code> specifies an initialization list with the elements 99 and 100, which will construct a vector with the two elements 99 and 100. What if you want a vector with 99 copies of the number 100?</p>&#13;
<p class="indent">In general, the compiler will try very hard to treat the initializer list as elements to fill the vector with. You can try to memorize the rules (refer to Item 7 of <em>Effective Modern C++</em> by Scott Meyers) or just commit to using parentheses for stdlib container constructors.</p>&#13;
<p class="indent"><a href="ch13.xhtml#ch13ex10">Listing 13-10</a> highlights the initializer list/braced initialization general rule for STL containers.</p>&#13;
<pre>TEST_CASE("std::vector supports") {&#13;
  SECTION("braced initialization") {&#13;
    std::vector&lt;int&gt; five_nine{ 5, 9 }; <span class="ent">➊</span>&#13;
<span epub:type="pagebreak" id="page_417"/>    REQUIRE(five_nine[0] == 5); <span class="ent">➋</span>&#13;
    REQUIRE(five_nine[1] == 9); <span class="ent">➌</span>&#13;
  }&#13;
  SECTION("fill constructor") {&#13;
    std::vector&lt;int&gt; five_nines(5, 9); <span class="ent">➍</span>&#13;
    REQUIRE(five_nines[0] == 9); <span class="ent">➎</span>&#13;
    REQUIRE(five_nines[4] == 9); <span class="ent">➏</span>&#13;
  }&#13;
}</pre>&#13;
<p class="listing"><a id="ch13ex10"/><em>Listing 13-10: A <code>vector</code> supports braced initializers and fill constructors.</em></p>&#13;
<p class="indent">The first example uses braced initialization to construct a vector with two elements <span class="ent">➊</span>: 5 at index 0 <span class="ent">➋</span> and 9 at index 1 <span class="ent">➌</span>. The second example uses parentheses to invoke the fill constructor <span class="ent">➍</span>, which fills the vector with five copies of the number 9, so the first <span class="ent">➎</span> and last <span class="ent">➏</span> elements are both 9.</p>&#13;
<div class="note">&#13;
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>&#13;
<p class="notep"><em>This notational clash is unfortunate and isn’t the result of some well-thought-out trade-off. The reasons are purely historical and related to backward compatibility.</em></p>&#13;
</div>&#13;
<p class="indent">You can also construct <code>vector</code>s from a half-open range by passing in the <code>begin</code> and <code>end</code> iterators of the range you want to copy. In various programming contexts, you might want to splice out a subset of some range and copy it into a <code>vector</code> for further processing. For example, you could construct a <code>vector</code> that copies all the elements contained by an <code>array</code>, as in <a href="ch13.xhtml#ch13ex11">Listing 13-11</a>.</p>&#13;
<pre>TEST_CASE("std::vector supports construction from iterators") {&#13;
  std::array&lt;int, 5&gt; fib_arr{ 1, 1, 2, 3, 5 }; <span class="ent">➊</span>&#13;
  std::vector&lt;int&gt; fib_vec(fib_arr.begin(), fib_arr.end()); <span class="ent">➋</span>&#13;
  REQUIRE(fib_vec[4] == 5); <span class="ent">➌</span>&#13;
  REQUIRE(fib_vec.size() == fib_arr.size()); <span class="ent">➍</span>&#13;
}</pre>&#13;
<p class="listing"><a id="ch13ex11"/><em>Listing 13-11: Constructing a <code>vector</code> from a range</em></p>&#13;
<p class="indent">You construct the array <code>fib_arr</code> with five elements <span class="ent">➊</span>. To construct the vector <code>fib_vec</code> with the elements contained in <code>fib_arr</code>, you invoke the <code>begin</code> and <code>end</code> methods on <code>fib_arr</code> <span class="ent">➋</span>. The resulting <code>vector</code> has copies of the <code>array</code>’s elements <span class="ent">➌</span> and has the same <code>size</code> <span class="ent">➍</span>.</p>&#13;
<p class="indent">At a high level, you can think of this constructor as taking pointers to the beginning and the end of some target sequence. It will then copy that target sequence.</p>&#13;
<h5 class="h5" id="ch13lev3sec7"><strong>Move and Copy Semantics</strong></h5>&#13;
<p class="noindent">With <code>vector</code>s, you have full copy/move construction/assignment support. Any <code>vector</code> copy operation is potentially very expensive, because these are element-wise or deep copies. Move operations, on the other hand, are usually very fast, because the contained elements reside in dynamic memory and the moved-from <code>vector</code> can simply pass ownership to the moved-into <code>vector</code>; there’s no need to move the contained elements.</p>&#13;
<h5 class="h5" id="ch13lev3sec8"><span epub:type="pagebreak" id="page_418"/><strong>Element Access</strong></h5>&#13;
<p class="noindent">A <code>vector</code> supports most of the same element access operations as <code>array</code>: <code>at</code>, <code>operator[]</code>, <code>front</code>, <code>back</code>, and <code>data</code>.</p>&#13;
<p class="indent">As with an <code>array</code>, you can query the number of contained elements in a <code>vector</code> using the <code>size</code> method. This method’s return value can vary at runtime. You can also determine whether a <code>vector</code> contains any elements with the <code>empty</code> method, which returns <code>true</code> if the <code>vector</code> contains no elements; otherwise, it returns <code>false</code>.</p>&#13;
<h5 class="h5" id="ch13lev3sec9"><strong>Adding Elements</strong></h5>&#13;
<p class="noindent">You can use various methods to insert elements into a <code>vector</code>. If you want to replace all the elements in a <code>vector</code>, you can use the <code>assign</code> method, which takes an initialization list and replaces all the existing elements. If needed, the <code>vector</code> will resize to accommodate a larger list of elements, as <a href="ch13.xhtml#ch13ex12">Listing 13-12</a> illustrates.</p>&#13;
<pre>TEST_CASE("std::vector assign replaces existing elements") {&#13;
  std::vector&lt;int&gt; message{ 13, 80, 110, 114, 102, 110, 101 }; <span class="ent">➊</span>&#13;
  REQUIRE(message.size() == 7); <span class="ent">➋</span>&#13;
  message.assign({ 67, 97, 101, 115, 97, 114 }); <span class="ent">➌</span>&#13;
  REQUIRE(message[5] == 114); <span class="ent">➍</span>&#13;
  REQUIRE(message.size() == 6); <span class="ent">➎</span>&#13;
}</pre>&#13;
<p class="listing"><a id="ch13ex12"/><em>Listing 13-12: The <code>assign</code> method of a <code>vector</code></em></p>&#13;
<p class="indent">Here, you construct a <code>vector</code> <span class="ent">➊</span> with seven elements <span class="ent">➋</span>. When you assign a new, smaller initializer list <span class="ent">➌</span>, all the elements get replaced <span class="ent">➍</span>, and the vector’s <code>size</code> updates to reflect the new contents <span class="ent">➎</span>.</p>&#13;
<p class="indent">If you want to insert a single new element into a vector, you can use the <code>insert</code> method, which expects two arguments: an iterator and an element to insert. It will insert a copy of the given element just before the existing element pointed to by the iterator, as shown in <a href="ch13.xhtml#ch13ex13">Listing 13-13</a>.</p>&#13;
<pre>TEST_CASE("std::vector insert places new elements") {&#13;
  std::vector&lt;int&gt; zeros(3, 0); <span class="ent">➊</span>&#13;
  auto third_element = zeros.begin() + 2; <span class="ent">➋</span>&#13;
  zeros.insert(third_element, 10); <span class="ent">➌</span>&#13;
  REQUIRE(zeros[2] == 10); <span class="ent">➍</span>&#13;
  REQUIRE(zeros.size() == 4); <span class="ent">➎</span>&#13;
}</pre>&#13;
<p class="listing"><a id="ch13ex13"/><em>Listing 13-13: The <code>insert</code> method of a <code>vector</code></em></p>&#13;
<p class="indent">You initialize a vector with three zeros <span class="ent">➊</span> and generate an iterator pointing to the third element of <code>zeros</code> <span class="ent">➋</span>. Next, you insert the value 10 immediately before the third element by passing the iterator and the value 10 <span class="ent">➌</span>. The third element of <code>zeros</code> is now 10 <span class="ent">➍</span>. The <code>zeros</code> vector now contains four elements <span class="ent">➎</span>.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_419"/>Any time you use <code>insert</code>, existing iterators become invalid. For example, in <a href="ch13.xhtml#ch13ex13">Listing 13-13</a> you must not reuse <code>third_element</code>: the vector could have resized and relocated in memory, leaving the old iterator dangling in garbage memory.</p>&#13;
<p class="indent">To insert an element to the end of a <code>vector</code>, you use the <code>push_back</code> method. Unlike <code>insert</code>, <code>push_back</code> doesn’t require an iterator argument. You simply provide the element to copy into the <code>vector</code>, as shown in <a href="ch13.xhtml#ch13ex14">Listing 13-14</a>.</p>&#13;
<pre>TEST_CASE("std::vector push_back places new elements") {&#13;
  std::vector&lt;int&gt; zeros(3, 0); <span class="ent">➊</span>&#13;
  zeros.push_back(10); <span class="ent">➋</span>&#13;
  REQUIRE(zeros[3] == 10); <span class="ent">➌</span>&#13;
}</pre>&#13;
<p class="listing"><a id="ch13ex14"/><em>Listing 13-14: The <code>push_back</code> method of a <code>vector</code></em></p>&#13;
<p class="indent">Again, you initialize a <code>vector</code> with three zeros <span class="ent">➊</span>, but this time you insert the element 10 to the back of the <code>vector</code> using the <code>push_back</code> method <span class="ent">➋</span>. The <code>vector</code> now contains four elements, the last of which equals 10 <span class="ent">➌</span>.</p>&#13;
<p class="indent">You can construct new elements in place using the <code>emplace</code> and <code>emplace_back</code> methods. The <code>emplace</code> method is a variadic template that, like <code>insert</code>, accepts an iterator as its first argument. The remaining arguments get forwarded to the appropriate constructor. The <code>emplace_back</code> method is also a variadic template, but like <code>push_back</code>, it doesn’t require an iterator. It accepts any number of arguments and forwards those to the appropriate constructor. <a href="ch13.xhtml#ch13ex15">Listing 13-15</a> illustrates these two methods by emplacing a few <code>pair</code>s into a <code>vector</code>.</p>&#13;
<pre>#include &lt;utility&gt;&#13;
&#13;
TEST_CASE("std::vector emplace methods forward arguments") {&#13;
  std::vector&lt;std::pair&lt;int, int&gt;&gt; factors; <span class="ent">➊</span>&#13;
  factors.emplace_back(2, 30); <span class="ent">➋</span>&#13;
  factors.emplace_back(3, 20); <span class="ent">➌</span>&#13;
  factors.emplace_back(4, 15); <span class="ent">➍</span>&#13;
  factors.emplace(factors.begin()<span class="ent">➎</span>, 1, 60);&#13;
  REQUIRE(factors[0].first == 1); <span class="ent">➏</span>&#13;
  REQUIRE(factors[0].second == 60); <span class="ent">➐</span>&#13;
}</pre>&#13;
<p class="listing"><a id="ch13ex15"/><em>Listing 13-15: The <code>emplace_back</code> and <code>emplace</code> methods of a <code>vector</code></em></p>&#13;
<p class="indent">Here, you default construct a <code>vector</code> containing <code>pair</code>s of <code>int</code>s <span class="ent">➊</span>. Using the <code>emplace_back</code> method, you push three pairs onto the vector: 2, 30 <span class="ent">➋</span>; 3, 20 <span class="ent">➌</span>; and 4, 15 <span class="ent">➍</span>. These values get forwarded directly to the constructor of <code>pair</code>, which gets constructed in place. Next, you use <code>emplace</code> to insert a new <code>pair</code> at the beginning of the vector by passing the result of <code>factors.begin()</code> as the first argument <span class="ent">➎</span>. This causes all the elements in the vector to shift down to make room for the new <code>pair</code> (1 <span class="ent">➏</span>, 60 <span class="ent">➐</span>).</p>&#13;
<div class="note">&#13;
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>&#13;
<p class="notep"><span epub:type="pagebreak" id="page_420"/><em>There’s absolutely nothing special about a <code>std::vector&lt;std::pair&lt;int, int&gt;&gt;</code>. It’s just like any other <code>vector</code>. The individual elements in this sequential container just happen to be a <code>pair</code>. Because <code>pair</code> has a constructor that accepts two arguments, one for <code>first</code> and one for <code>second</code>, <code>emplace_back</code> can add a new element by simply passing the two values it should write into the newly created <code>pair</code>.</em></p>&#13;
</div>&#13;
<p class="indent">Because the emplacement methods can construct elements in place, it seems they should be more efficient than the insertion methods. This intuition is often correct, but for complicated and unsatisfying reasons it’s not always faster. As a general rule, use the emplacement methods. If you determine a performance bottleneck, also try the insertion methods. See Item 42 of <em>Effective Modern C++</em> by Scott Meyers for a treatise.</p>&#13;
<h5 class="h5" id="ch13lev3sec10"><strong>Storage Model</strong></h5>&#13;
<p class="noindent">Although <code>vector</code> elements are contiguous in memory, like an <code>array</code>, the similarities stop there. A <code>vector</code> has dynamic size, so it must be able to resize. The allocator of a <code>vector</code> manages the dynamic memory underpinning the <code>vector</code>.</p>&#13;
<p class="indent">Because allocations are expensive, a <code>vector</code> will request more memory than it needs to contain the current number of elements. Once it can no longer add any more elements, it will request additional memory. The memory for a <code>vector</code> is always contiguous, so if there isn’t enough space at the end of the existing vector, it will allocate a whole new region of memory and move all the elements of the <code>vector</code> into the new region. The number of elements a <code>vector</code> holds is called its <em>size</em>, and the number of elements it could theoretically hold before having to resize is called its <em>capacity</em>. <a href="ch13.xhtml#ch13fig02">Figure 13-2</a> illustrates a <code>vector</code> containing three elements with additional capacity for three more.</p>&#13;
<div class="image"><img src="../images/fig13_2.jpg" alt="image"/></div>&#13;
<p class="figcap" id="ch13fig02"><em>Figure 13-2: The <code>vector</code> storage model</em></p>&#13;
<p class="indent">As <a href="ch13.xhtml#ch13fig02">Figure 13-2</a> shows, the <code>vector</code> continues past the last element. The capacity determines how many elements the <code>vector</code> could hold in this space. In this figure, the size is three and the capacity is six. You can think of the memory in a <code>vector</code> as an auditorium: it might have a capacity of 500 but a crowd size of only 250.</p>&#13;
<p class="indent">The upshot of this design is that inserting at the end of a <code>vector</code> is extremely fast (unless the <code>vector</code> needs to resize). Inserting anywhere else incurs additional cost, because the <code>vector</code> needs to move elements around to make room.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_421"/>You can obtain the vector’s current capacity via the <code>capacity</code> method, and you can obtain the absolute maximum capacity that a <code>vector</code> could resize to with the <code>max_size</code> method.</p>&#13;
<p class="indent">If you know ahead of time that you’ll need a certain capacity, you can use the <code>reserve</code> method, which takes a single <code>size_t</code> argument corresponding to the number of elements you want capacity for. On the other hand, if you’ve just removed several elements and want to return memory to the allocator, you can use the <code>shrink_to_fit</code> method, which declares that you have excess capacity. The allocator can decide to reduce capacity or not (it’s a non-binding call).</p>&#13;
<p class="indent">Additionally, you can delete all the elements in a vector and set its size to zero using the <code>clear</code> method.</p>&#13;
<p class="indent"><a href="ch13.xhtml#ch13ex16">Listing 13-16</a> demonstrates all these storage-related methods in a cohesive story: you create an empty vector, reserve a bunch of space, add some elements, release excess capacity, and finally empty the vector.</p>&#13;
<pre>#include &lt;cstdint&gt;&#13;
#include &lt;array&gt;&#13;
&#13;
TEST_CASE("std::vector exposes size management methods") {&#13;
  std::vector&lt;std::array&lt;uint8_t, 1024&gt;&gt; kb_store; <span class="ent">➊</span>&#13;
  REQUIRE(kb_store.max_size() &gt; 0);&#13;
  REQUIRE(kb_store.empty()); <span class="ent">➋</span>&#13;
&#13;
  size_t elements{ 1024 };&#13;
  kb_store.reserve(elements); <span class="ent">➌</span>&#13;
  REQUIRE(kb_store.empty());&#13;
  REQUIRE(kb_store.capacity() == elements); <span class="ent">➍</span>&#13;
&#13;
  kb_store.emplace_back();&#13;
  kb_store.emplace_back();&#13;
  kb_store.emplace_back();&#13;
  REQUIRE(kb_store.size() == 3); <span class="ent">➎</span>&#13;
&#13;
  kb_store.shrink_to_fit();&#13;
  REQUIRE(kb_store.capacity() &gt;= 3); <span class="ent">➏</span>&#13;
&#13;
  kb_store.clear(); <span class="ent">➐</span>&#13;
  REQUIRE(kb_store.empty());&#13;
  REQUIRE(kb_store.capacity() &gt;= 3); <span class="ent">➑</span>&#13;
}</pre>&#13;
<p class="listing"><a id="ch13ex16"/><em>Listing 13-16: The storage management functions of a <code>vector</code>. (Strictly speaking, <code>kb_store.capacity() &gt;= 3</code> <span class="ent">➏ ➑</span> is not guaranteed because the call is non-binding.)</em></p>&#13;
<p class="indent">You construct a <code>vector</code> of <code>array</code> objects called <code>kb_store</code>, which stores 1 KiB chunks <span class="ent">➊</span>. Unless you’re using a peculiar platform with no dynamic memory, <code>kb_store.max_size()</code> will be greater than zero; because you default initialize the <code>vector</code>, it’s empty <span class="ent">➋</span>.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_422"/>Next, you reserve 1,024 elements <span class="ent">➌</span>, which doesn’t change the vector’s empty status but increases its capacity to match <span class="ent">➍</span>. The <code>vector</code> now has 1,024 × 1 KiB = 1 MiB of contiguous space reserved. After reserving space, you emplace three arrays and check that <code>kb_store.size()</code> increased accordingly <span class="ent">➎</span>.</p>&#13;
<p class="indent">You’ve reserved space for 1,024 elements. To release the 1,024 – 3 = 1,021 elements you aren’t using back to the allocator, you call <code>shrink_to_fit</code>, which reduces the capacity to 3 <span class="ent">➏</span>.</p>&#13;
<p class="indent">Finally, you invoke <code>clear</code> on the <code>vector</code> <span class="ent">➐</span>, which destructs all elements and reduces its size to zero. However, the capacity remains unchanged because you haven’t made another call to <code>shrink_to_fit</code> <span class="ent">➑</span>. This is significant because the vector doesn’t want to do extra work if you’re going to add elements again.</p>&#13;
<h5 class="h5" id="ch13lev3sec11"><strong>A Partial List of Supported Operations</strong></h5>&#13;
<p class="noindent"><a href="ch13.xhtml#ch13tab02">Table 13-2</a> provides a partial list of <code>vector</code> operations. In this table, <code>v</code>, <code>v1</code>, and <code>v2</code> are of type <code>std::vector&lt;T&gt;</code>, <code>t</code> is of type <code>T</code>, <code>alc</code> is an appropriate allocator, and <code>itr</code> is an iterator. An asterisk (*) indicates that this operation invalidates raw pointers and iterators to <code>v</code>’s elements in at least some circumstances.</p>&#13;
<p class="tabcap"><span epub:type="pagebreak" id="page_423"/><a id="ch13tab02"/><strong>Table 13-2:</strong> A Partial List of <code>std::vector</code> Operations</p>&#13;
<table class="topbot-d">&#13;
<colgroup>&#13;
<col style="width:30%"/>&#13;
<col style="width:70%"/>&#13;
</colgroup>&#13;
<tbody>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-h"><p class="tab_th"><strong>Operation</strong></p></td>&#13;
<td style="vertical-align: top;" class="table-h"><p class="tab_th"><strong>Notes</strong></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><code>vector&lt;</code><span class="codestrong">T</span><code>&gt;{ ...,</code> [<span class="codestrong">alc</span>]}</p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">Performs braced initialization of a newly constructed vector. Uses <span class="codestrong">alc</span><code>=std::allocator&lt;</code><span class="codestrong">T</span><code>&gt;</code> by default.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><code>vector&lt;</code><span class="codestrong">T</span><code>&gt;(</code><span class="codestrong">s</span><code>,[</code><span class="codestrong">t</span><code>], [</code><span class="codestrong">alc</span><code>])</code></p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba">Fills the newly constructed vector with <span class="codestrong">s</span> number of copies of <span class="codestrong">t</span>. If no <span class="codestrong">t</span> is provided, default constructs <span class="codestrong">T</span> instances.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><code>vector&lt;</code><span class="codestrong">T</span><code>&gt;(</code><span class="codestrong">v</span><code>)</code></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">Deep copy of <span class="codestrong">v</span>; allocates new memory.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><code>vector&lt;</code><span class="codestrong">T</span><code>&gt;(move(</code><span class="codestrong">v</span><code>))</code></p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba">Takes ownership of memory, elements in <span class="codestrong">v</span>. No allocations.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><code>~vector</code></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">Destructs all elements contained by the vector and releases dynamic memory.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><span class="codestrong">v</span><code>.begin()</code></p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba">Returns an iterator pointing to the first element.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><span class="codestrong">v</span><code>.cbegin()</code></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">Returns a <code>const</code> iterator pointing to the first element.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><span class="codestrong">v</span><code>.end()</code></p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba">Returns an iterator pointing to 1 past the last element.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><span class="codestrong">v</span><code>.cend()</code></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">Returns a <code>const</code> iterator pointing to 1 past the last element.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><span class="codestrong">v1</span> <code>=</code> <span class="codestrong">v2</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><span class="codestrong">v1</span> destructs its elements; copies each <span class="codestrong">v2</span> element. Only allocates if it needs to resize to fit <span class="codestrong">v2</span>’s elements.*</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><span class="codestrong">v1</span> <code>=</code> <code>move(</code><span class="codestrong">v2</span><code>)</code></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><span class="codestrong">v1</span> destructs its elements; moves each <span class="codestrong">v2</span> element. Only allocates if it needs to resize to fit <span class="codestrong">v2</span>’s elements.*</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><span class="codestrong">v</span><code>.at(</code><span class="codestrong">0</span><code>)</code></p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba">Accesses element <span class="codestrong">0</span> of <span class="codestrong">v</span>. Throws <code>std::out_of_range</code> if out of bounds.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><span class="codestrong">v</span><code>[</code><span class="codestrong">0</span><code>]</code></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">Accesses element <span class="codestrong">0</span> of <span class="codestrong">v</span>. Undefined behavior if out of bounds.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><span class="codestrong">v</span><code>.front()</code></p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba">Accesses first element.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><span class="codestrong">v</span><code>.back()</code></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">Accesses last element.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><span class="codestrong">v</span><code>.data()</code></p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba">Returns a raw pointer to the first element if array is non-empty. For empty arrays, returns a valid but non-dereferencable pointer.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><span class="codestrong">v</span><code>.assign({</code> <span class="codestrong">...</span> <code>})</code></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">Replaces the contents of <span class="codestrong">v</span> with the elements <span class="codestrong">...</span>.*</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><span class="codestrong">v</span><code>.assign(</code><span class="codestrong">s</span><code>,</code> <span class="codestrong">t</span><code>)</code></p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba">Replaces the contents of <span class="codestrong">v</span> with <span class="codestrong">s</span> number of copies of <span class="codestrong">t</span>.*</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><span class="codestrong">v</span><code>.empty()</code></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">Returns <code>true</code> if vector’s size is zero; otherwise <code>false</code>.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><span class="codestrong">v</span><code>.size()</code></p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba">Returns the number of elements in the vector.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><span class="codestrong">v</span><code>.capacity()</code></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">Returns the maximum number of elements the vector could hold without having to resize.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><span class="codestrong">v</span><code>.shrink_to_fit()</code></p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba">Might reduce the vector’s storage so <code>capacity()</code> equals <code>size()</code>.*</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><span class="codestrong">v</span><code>.resize(</code><span class="codestrong">s</span><code>, [</code><span class="codestrong">t</span><code>])</code></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">Resizes <span class="codestrong">v</span> to contain <span class="codestrong">s</span> elements. If this shrinks <span class="codestrong">v</span>, destructs elements at the end. If this grows <span class="codestrong">v</span>, inserts default constructed <span class="codestrong">T</span>s or copies of <span class="codestrong">t</span> if provided.*</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><span class="codestrong">v</span><code>.reserve(</code><span class="codestrong">s</span><code>)</code></p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba">Increases the vector’s storage so it can contain at least <span class="codestrong">s</span> elements.*</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><span class="codestrong">v</span><code>.max_size()</code></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">Returns the maximum possible size the vector can resize to.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><span class="codestrong">v</span><code>.clear()</code></p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba">Removes all elements in <span class="codestrong">v</span>, but capacity remains.*</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><span class="codestrong">v</span><code>.insert(</code><span class="codestrong">itr</span><code>,</code> <span class="codestrong">t</span><code>)</code></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">Inserts a copy of <span class="codestrong">t</span> just before the element pointed to by <span class="codestrong">itr</span>; <span class="codestrong">v</span>’s range must contain <span class="codestrong">itr</span>.*</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><span class="codestrong">v</span><code>.push_back(</code><span class="codestrong">t</span><code>)</code></p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba">Inserts a copy of <span class="codestrong">t</span> at the end of <span class="codestrong">v</span>.*</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><span class="codestrong">v</span><code>.emplace(</code><span class="codestrong">itr</span><code>,</code> <span class="codestrong">...</span><code>)</code></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">Constructs a <span class="codestrong">T</span> in place by forwarding the arguments <span class="codestrong">...</span> to the appropriate constructor. Element inserted just before the element pointed to by <span class="codestrong">itr</span>.*</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><span class="codestrong">v</span><code>.emplace_back(</code><span class="codestrong">...</span><code>)</code></p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba">Constructs a <span class="codestrong">T</span> in place by forwarding the arguments <span class="codestrong">...</span> to the appropriate constructor. Element inserted at the end of <span class="codestrong">v</span>.*</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><span class="codestrong">v1</span><code>.swap(</code><span class="codestrong">v2</span><code>)</code></p>&#13;
<p class="taba"><code>swap(</code><span class="codestrong">v1</span><code>,</code> <span class="codestrong">v2</span><code>)</code></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">Exchanges each element of <span class="codestrong">v1</span> with those of <span class="codestrong">v2</span>.*</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b2"><p class="taba"><span class="codestrong">v1</span> <code>==</code> <span class="codestrong">v2</span></p>&#13;
<p class="taba"><span class="codestrong">v1</span> <code>!=</code> <span class="codestrong">v2</span></p>&#13;
<p class="taba"><span class="codestrong">v1</span> <code>&gt;</code> <span class="codestrong">v2</span></p>&#13;
<p class="taba"><span class="codestrong">v1</span> <code>&gt;=</code> <span class="codestrong">v2</span></p>&#13;
<p class="taba"><span class="codestrong">v1</span> <code>&lt;</code> <span class="codestrong">v2</span></p>&#13;
<p class="taba"><span class="codestrong">v1</span> <code>&lt;=</code> <span class="codestrong">v2</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b2"><p class="taba">Equal if all elements are equal.</p>&#13;
<p class="taba">Greater than/less than comparisons proceed from first element to last.</p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<h4 class="h4" id="ch13lev2sec3"><strong><em>Niche Sequential Containers</em></strong></h4>&#13;
<p class="noindent">The <code>vector</code> and <code>array</code> containers are the clear choice in most situations in which you need a sequential data structure. If you know the number of elements you’ll need ahead of time, use an <code>array</code>. If you don’t, use a <code>vector</code>.</p>&#13;
<p class="indent">You might find yourself in a niche situation where <code>vector</code> and <code>array</code> don’t have the performance characteristics you desire. This section highlights a number of alternative sequential containers that might offer superior performance characteristics in such a situation.</p>&#13;
<h5 class="h5" id="ch13lev3sec12"><span epub:type="pagebreak" id="page_424"/><strong>Deque</strong></h5>&#13;
<p class="noindent">A <em>deque</em> (pronounced “deck”) is a sequential container with fast insert and remove operations from the front and back. Deque is a portmanteau of <strong>d</strong>ouble<em>-</em><strong>e</strong>nded <strong>que</strong>ue. The STL implementation <code>std::deque</code> is available from the <code>&lt;deque&gt;</code> header.</p>&#13;
<div class="note">&#13;
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>&#13;
<p class="notep"><em>The Boost Container library also contains a <code>boost::container::deque</code> in the <code>&lt;boost/container/deque.hpp&gt;</code> header.</em></p>&#13;
</div>&#13;
<p class="indent">A <code>vector</code> and a <code>deque</code> have very similar interfaces, but internally their storage models are totally different. A <code>vector</code> guarantees that all elements are sequential in memory, whereas a <code>deque</code>’s memory is usually scattered about, like a hybrid between a <code>vector</code> and a <code>list</code>. This makes large resizing operations more efficient and enables fast element insertion/deletion at the container’s front.</p>&#13;
<p class="indent">Constructing and accessing members are identical operations for <code>vector</code>s and <code>deque</code>s.</p>&#13;
<p class="indent">Because the internal structure of <code>deque</code> is complex, it doesn’t expose a <code>data</code> method. In exchange, you gain access to <code>push_front</code> and <code>emplace_front</code>, which mirror the <code>push_back</code> and <code>emplace_back</code> that you’re familiar with from <code>vector</code>. <a href="ch13.xhtml#ch13ex17">Listing 13-17</a> illustrates how to use <code>push_back</code> and <code>push_front</code> to insert values into a <code>deque</code> of <code>char</code>s.</p>&#13;
<pre>#include &lt;deque&gt;&#13;
&#13;
TEST_CASE("std::deque supports front insertion") {&#13;
  std::deque&lt;char&gt; deckard;&#13;
  deckard.push_front('a'); <span class="ent">➊</span> //  a&#13;
  deckard.push_back('i'); <span class="ent">➋</span> //  ai&#13;
  deckard.push_front('c');   // cai&#13;
  deckard.push_back('n');    // cain&#13;
  REQUIRE(deckard[0] == 'c'); <span class="ent">➌</span>&#13;
  REQUIRE(deckard[1] == 'a');&#13;
  REQUIRE(deckard[2] == 'i');&#13;
  REQUIRE(deckard[3] == 'n');&#13;
}</pre>&#13;
<p class="listing"><a id="ch13ex17"/><em>Listing 13-17: A <code>deque</code> supports <code>push_front</code> and <code>push_back</code>.</em></p>&#13;
<p class="indent">After constructing an empty <code>deque</code>, you push alternating letters to the front <span class="ent">➊</span> and back <span class="ent">➋</span> of the <code>deque</code> so it contains the elements <code>c</code>, <code>a</code>, <code>i</code>, and <code>n</code> <span class="ent">➌</span>.</p>&#13;
<div class="note">&#13;
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>&#13;
<p class="notep"><em>It would be a very bad idea to attempt to extract a string here, for example, <code>&amp;deckard[0]</code>, because <code>deque</code> makes no guarantees about internal layout.</em></p>&#13;
</div>&#13;
<p class="indent">The <code>vector</code> methods not implemented by <code>deque</code>, along with an explanation for their absence, are as follows:</p>&#13;
<p class="bq"><strong><code>capacity</code>, <code>reserve</code></strong> Because the internal structure is complicated, it might not be efficient to compute capacity. Also, <code>deque</code> allocations are <span epub:type="pagebreak" id="page_425"/>relatively fast because a <code>deque</code> doesn’t relocate existing elements, so reserving memory ahead of time is unnecessary.</p>&#13;
<p class="bq"><strong><code>data</code></strong> The elements of <code>deque</code> are not contiguous.</p>&#13;
<p class="indent"><a href="ch13.xhtml#ch13tab03">Table 13-3</a> summarizes the additional operators offered by a <code>deque</code> but not by a <code>vector</code>. In this table, <code>d</code> is of type <code>std::deque&lt;T&gt;</code> and <code>t</code> is of type <code>T</code>. An asterisk (*) indicates that this operation invalidates iterators to <code>v</code>’s elements in at least some circumstances. (Pointers to existing elements remain valid.)</p>&#13;
<p class="tabcap"><a id="ch13tab03"/><strong>Table 13-3:</strong> A Partial List of <code>std::deque</code> Operations</p>&#13;
<table class="topbot-d">&#13;
<colgroup>&#13;
<col style="width:30%"/>&#13;
<col style="width:70%"/>&#13;
</colgroup>&#13;
<tbody>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-h"><p class="tab_th"><strong>Operation</strong></p></td>&#13;
<td style="vertical-align: top;" class="table-h"><p class="tab_th"><strong>Notes</strong></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><span class="codestrong">d</span><code>.emplace_front(</code><span class="codestrong">...</span><code>)</code></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">Constructs an element in place at the front of the <span class="codestrong">d</span> by forwarding all arguments to the appropriate constructor.*</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><span class="codestrong">d</span><code>.push_front(</code><span class="codestrong">t</span><code>)</code></p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba">Constructs an element in place at the front of the <span class="codestrong">d</span> by copying <span class="codestrong">t</span>.*</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-ba"><p class="taba"><span class="codestrong">d</span><code>.pop_front()</code></p></td>&#13;
<td style="vertical-align: top;" class="table-ba"><p class="taba">Removes the element at the front of <span class="codestrong">d</span>.*</p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<h3 class="h3" id="ch13lev1sec2"><strong>List</strong></h3>&#13;
<p class="noindent">A <em>list</em> is a sequence container with fast insert/remove operations everywhere but with no random element access. The STL implementation <code>std::list</code> is available from the <code>&lt;list&gt;</code> header.</p>&#13;
<div class="note">&#13;
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>&#13;
<p class="notep"><em>The Boost Container library also contains a <code>boost::container::list</code> in the <code>&lt;boost/container/list.hpp&gt;</code> header.</em></p>&#13;
</div>&#13;
<p class="indent">The <code>list</code> is implemented as a doubly linked list, a data structure composed of <em>nodes</em>. Each node contains an element, a forward link (“flink”), and a backward link (“blink”). This is completely different from a <code>vector</code>, which stores elements in contiguous memory. As a result, you cannot use <code>operator[]</code> or <code>at</code> to access arbitrary elements in a <code>list</code>, because such operations would be very inefficient. (These methods are simply not available in <code>list</code> because of their horrible performance characteristics.) The trade-off is that inserting and removing elements in a <code>list</code> is much faster. All you need to update are the flinks and blinks of an element’s neighbors rather than shuffling potentially large, contiguous element ranges.</p>&#13;
<p class="indent">The <code>list</code> container supports the same constructor patterns as <code>vector</code>.</p>&#13;
<p class="indent">You can perform special operations on lists, such as splicing elements from one list into another using the <code>splice</code> method, removing consecutive duplicate elements using the <code>unique</code> method, and even sorting the elements of a container using the <code>sort</code> method. Consider, for example, the <code>remove_if</code> method. The <code>remove_if</code> method accepts a function object as a parameter, and it traverses the <code>list</code> while invoking the function object on each element. If the result is <code>true</code>, <code>remove_if</code> removes the element. <a href="ch13.xhtml#ch13ex18">Listing 13-18</a> illustrates how to use the <code>remove_if</code> method to eliminate all the even numbers of a <code>list</code> with a lambda predicate.</p>&#13;
<pre><span epub:type="pagebreak" id="page_426"/>#include &lt;list&gt;&#13;
&#13;
TEST_CASE("std::list supports front insertion") {&#13;
  std::list&lt;int&gt; odds{ 11, 22, 33, 44, 55 }; <span class="ent">➊</span>&#13;
  odds.remove_if([](int x) { return x % 2 == 0; }); <span class="ent">➋</span>&#13;
  auto odds_iter = odds.begin(); <span class="ent">➌</span>&#13;
  REQUIRE(*odds_iter == 11); <span class="ent">➍</span>&#13;
  ++odds_iter; <span class="ent">➎</span>&#13;
  REQUIRE(*odds_iter == 33);&#13;
  ++odds_iter;&#13;
  REQUIRE(*odds_iter == 55);&#13;
  ++odds_iter;&#13;
  REQUIRE(odds_iter == odds.end()); <span class="ent">➏</span>&#13;
}</pre>&#13;
<p class="listing"><a id="ch13ex18"/><em>Listing 13-18: A <code>list</code> supports <code>remove_if</code>.</em></p>&#13;
<p class="indent">Here, you use braced initialization to fill a <code>list</code> of <code>int</code> objects <span class="ent">➊</span>. Next, you use the <code>remove_if</code> method to remove all the even numbers <span class="ent">➋</span>. Because only even numbers modulo 2 equal zero, this lambda tests whether a number is even. To establish that <code>remove_if</code> has extracted the even elements 22 and 44, you create an iterator pointing at the beginning of the list <span class="ent">➌</span>, check its value <span class="ent">➍</span>, and increment <span class="ent">➎</span> until you reach the end of the list <span class="ent">➏</span>.</p>&#13;
<p class="indent">All the <code>vector</code> methods not implemented by <code>list</code>, along with an explanation for their absence, are as follows:</p>&#13;
<p class="bq"><strong><code>capacity</code>, <code>reserve</code>, <code>shrink_to_fit</code></strong> Because <code>list</code> acquires memory incrementally, it doesn’t require periodic resizing.</p>&#13;
<p class="bq"><strong><code>operator[]</code>, <code>at</code></strong> Random element access is prohibitively expensive on <code>list</code>s.</p>&#13;
<p class="bq"><strong><code>data</code></strong> Unneeded because <code>list</code> elements are not contiguous.</p>&#13;
<p class="indent"><a href="ch13.xhtml#ch13tab04">Table 13-4</a> summarizes the additional operators offered by a <code>list</code> but not by a <code>vector</code>. In this table, <code>lst</code>, <code>lst1</code>, and <code>lst2</code> are of type <code>std::list&lt;T&gt;</code>, and <code>t</code> is of type <code>T</code>. The arguments <code>itr1</code>, <code>itr2a</code>, and <code>itr2b</code> are <code>list</code> iterators. An asterisk (*) indicates that the operation invalidates iterators to <code>v</code>’s elements in at least some circumstances. (Pointers to existing elements remain valid.)</p>&#13;
<p class="tabcap"><a id="ch13tab04"/><strong>Table 13-4:</strong> A Partial List of <code>std::list</code> Operations</p>&#13;
<table class="topbot-d">&#13;
<colgroup>&#13;
<col style="width:30%"/>&#13;
<col style="width:70%"/>&#13;
</colgroup>&#13;
<tbody>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-h"><p class="tab_th"><strong>Operation</strong></p></td>&#13;
<td style="vertical-align: top;" class="table-h"><p class="tab_th"><strong>Notes</strong></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><span class="codestrong">lst</span><code>.emplace_front(</code><span class="codestrong">...</span><code>)</code></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">Constructs an element in place at the front of the <code>d</code> by forwarding all arguments to the appropriate constructor.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><span class="codestrong">lst</span><code>.push_front(</code><span class="codestrong">t</span><code>)</code></p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba">Constructs an element in place at the front of <span class="codestrong">d</span> by copying <span class="codestrong">t</span>.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><span class="codestrong">lst</span><code>.pop_front()</code></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">Removes the element at the front of <span class="codestrong">d</span>.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><span class="codestrong">lst</span><code>.push_back(</code><span class="codestrong">t</span><code>)</code></p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba">Constructs an element in place at the back of <span class="codestrong">d</span> by copying <span class="codestrong">t</span>.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><span class="codestrong">lst</span><code>.pop_back()</code></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">Removes the element at the back of <span class="codestrong">d</span>.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><span class="codestrong">lst1</span><code>.splice(</code><span class="codestrong">itr1</span><code>,</code><span class="codestrong">lst2</span><code>,</code> <span class="codestrong">[itr2a]</span><code>, </code><span class="codestrong">[itr2b]</span><code>)</code></p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba">Transfers items from <span class="codestrong">lst2</span> into <span class="codestrong">lst1</span> at position <span class="codestrong">itr1</span>. Optionally, only transfer the element at <span class="codestrong">itr2a</span> or the elements within the half-open range <span class="codestrong">itr2a</span> to <span class="codestrong">itr2b</span>.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><span epub:type="pagebreak" id="page_427"/><p class="taba"><span class="codestrong">lst</span><code>.remove(</code><span class="codestrong">t</span><code>)</code></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">Removes all elements in <span class="codestrong">lst</span> equal to <span class="codestrong">t</span>.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><span class="codestrong">lst</span><code>.remove_if(</code><span class="codestrong">pred</span><code>)</code></p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba">Eliminates elements in <span class="codestrong">lst</span> where <span class="codestrong">pred</span> returns true; <span class="codestrong">pred</span> accepts a single <span class="codestrong">T</span> argument.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><span class="codestrong">lst</span><code>.unique(</code><span class="codestrong">pred</span><code>)</code></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">Eliminates duplicate consecutive elements in <span class="codestrong">lst</span> according to the function object <span class="codestrong">pred</span>, which accepts two <span class="codestrong">T</span> arguments and returns <span class="codestrong">t1</span>  <code>==</code>  <span class="codestrong">t2</span>.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><span class="codestrong">lst1</span><code>.merge(</code><span class="codestrong">lst2</span><code>,</code> <span class="codestrong">comp</span><code>)</code></p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba">Merges <span class="codestrong">lst1</span> and <span class="codestrong">lst2</span> according to the function object <span class="codestrong">comp</span>, which accepts two <span class="codestrong">T</span> arguments and returns <span class="codestrong">t1</span>  <code>&lt;</code>  <span class="codestrong">t2</span>.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><span class="codestrong">lst</span><code>.sort(</code><span class="codestrong">comp</span><code>)</code></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">Sorts <span class="codestrong">lst</span> according to the function object <span class="codestrong">comp</span>.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b2"><p class="taba"><span class="codestrong">lst</span><code>.reverse()</code></p></td>&#13;
<td style="vertical-align: top;" class="table-b2"><p class="taba">Reverses the order of <span class="codestrong">lst</span>’s elements (mutates <span class="codestrong">lst</span>).</p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<div class="note">&#13;
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>&#13;
<p class="notep"><em>The STL also offers a <code>std::forward_list</code> in the <code>&lt;forward_list&gt;</code> header, which is a singly linked list that only allows iteration in one direction. The <code>forward_list</code> is slightly more efficient than <code>list</code>, and it’s optimized for situations in which you need to store very few (or no) elements.</em></p>&#13;
</div>&#13;
<h5 class="h5" id="ch13lev3sec13"><strong>Stacks</strong></h5>&#13;
<p class="noindent">The STL provides three <em>container adapters</em> that encapsulate other STL containers and expose special interfaces for tailored situations. The adapters are the stack, the queue, and the priority queue.</p>&#13;
<p class="indent">A <em>stack</em> is a data structure with two fundamental operations: push and pop. When you <em>push</em> an element onto a stack, you insert the element onto the stack’s end. When you <em>pop</em> an element off a stack, you remove the element from the stack’s end. This arrangement is called <em>last-in</em>, <em>first-out</em>: the last element to be pushed onto a stack is the first to be popped off.</p>&#13;
<p class="indent">The STL offers the <code>std::stack</code> in the <code>&lt;stack&gt;</code> header. The class template <code>stack</code> takes two template parameters. The first is the underlying type of the wrapped container, such as <code>int</code>, and the second is the type of the wrapped container, such as <code>deque</code> or <code>vector</code>. This second argument is optional and defaults to <code>deque</code>.</p>&#13;
<p class="indent">To construct a <code>stack</code>, you can pass a reference to a <code>deque</code>, a <code>vector</code>, or a <code>list</code> to encapsulate. This way, the <code>stack</code> translates its operations, such as <code>push</code> and <code>pop</code>, into methods that the underlying container understands, like <code>push_back</code> and <code>pop_back</code>. If you provide no constructor argument, the <code>stack</code> uses a <code>deque</code> by default. The second template parameter must match this container’s type.</p>&#13;
<p class="indent">To obtain a reference to the element on top of a <code>stack</code>, you use the <code>top</code> method.</p>&#13;
<p class="indent"><a href="ch13.xhtml#ch13ex19">Listing 13-19</a> illustrates how to use a <code>stack</code> to wrap a <code>vector</code>.</p>&#13;
<pre>#include &lt;stack&gt;&#13;
&#13;
TEST_CASE("std::stack supports push/pop/top operations") {&#13;
  std::vector&lt;int&gt; vec{ 1, 3 }; <span class="ent">➊</span>  // 1 3&#13;
<span epub:type="pagebreak" id="page_428"/>  std::stack&lt;int, decltype(vec)&gt; easy_as(vec); <span class="ent">➋</span>&#13;
  REQUIRE(easy_as.top() == 3); <span class="ent">➌</span>&#13;
  easy_as.pop(); <span class="ent">➍</span>                 // 1&#13;
  easy_as.push(2); <span class="ent">➎</span>               // 1 2&#13;
  REQUIRE(easy_as.top() == 2); <span class="ent">➏</span>&#13;
  easy_as.pop();                 // 1&#13;
  REQUIRE(easy_as.top() == 1);&#13;
  easy_as.pop();                 //&#13;
  REQUIRE(easy_as.empty()); <span class="ent">➐</span>&#13;
}</pre>&#13;
<p class="listing"><a id="ch13ex19"/><em>Listing 13-19: Using a <code>stack</code> to wrap a <code>vector</code></em></p>&#13;
<p class="indent">You construct a <code>vector</code> of <code>int</code>s called <code>vec</code> containing the elements 1 and 3 <span class="ent">➊</span>. Next, you pass <code>vec</code> into the constructor of a new <code>stack</code>, making sure to supply the second template parameter <code>decltype(vec)</code> <span class="ent">➋</span>. The top element in <code>stack</code> is now 3, because this is the last element in <code>vec</code> <span class="ent">➌</span>. After the first <code>pop</code> <span class="ent">➍</span>, you push a new element 2 onto the <code>stack</code> <span class="ent">➎</span>. Now, the <code>top</code> element is 2 <span class="ent">➏</span>. After another <code>pop</code>-<code>top</code>-<code>pop</code> series, the <code>stack</code> is empty <span class="ent">➐</span>.</p>&#13;
<p class="indent"><a href="ch13.xhtml#ch13tab05">Table 13-5</a> summarizes the operations of <code>stack</code>. In this table, <code>s</code>, <code>s1</code>, and <code>s2</code> are of type <code>std::stack&lt;T&gt;</code>; <code>t</code> is of type <code>T</code>; and <code>ctr</code> is a container of type <code>ctr_type&lt;T&gt;</code>.</p>&#13;
<p class="tabcap"><a id="ch13tab05"/><strong>Table 13-5:</strong> A Summary of <code>std::stack</code> Operations</p>&#13;
<table class="topbot-d">&#13;
<colgroup>&#13;
<col style="width:30%"/>&#13;
<col style="width:70%"/>&#13;
</colgroup>&#13;
<tbody>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-h"><p class="tab_th"><strong>Operation</strong></p></td>&#13;
<td style="vertical-align: top;" class="table-h"><p class="tab_th"><strong>Notes</strong></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><code>stack&lt;</code><span class="codestrong">T,</span> <code>[</code><span class="codestrong">ctr_type</span><span class="codestrong">&lt;T&gt;</span><code>]&gt;([</code><span class="codestrong">ctr</span><code>])</code></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">Constructs a <span class="codestrong">stack</span> of <span class="codestrong">T</span>s using <span class="codestrong">ctr</span> as its internal container reference. If no container is provided, constructs an empty <span class="codestrong">deque</span>.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><span class="codestrong">s</span><code>.empty()</code></p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba">Returns <code>true</code> if container is empty.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><span class="codestrong">s</span><code>.size()</code></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">Returns number of elements in container.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><span class="codestrong">s</span><code>.top()</code></p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba">Returns a reference to the element on top of the <code>stack</code>.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><span class="codestrong">s</span><code>.push(t)</code></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">Puts a copy of <span class="codestrong">t</span> onto the end of the container.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><span class="codestrong">s</span><code>.emplace(</code><span class="codestrong">...</span><code>)</code></p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba">Constructs a <span class="codestrong">T</span> in place by forwarding <span class="codestrong">...</span> to the appropriate constructor.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><span class="codestrong">s</span><code>.pop()</code></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">Removes the element at the end of the container.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b2"><p class="taba"><span class="codestrong">s1</span><code>.swap(</code><span class="codestrong">s2</span><code>)</code></p>&#13;
<p class="taba"><code>swap(</code><span class="codestrong">s1</span><code>,</code> <span class="codestrong">s2</span><code>)</code></p></td>&#13;
<td style="vertical-align: top;" class="table-b2"><p class="taba">Exchanges the contents of <span class="codestrong">s2</span> with <span class="codestrong">s1</span>.</p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<h3 class="h3" id="ch13lev1sec3"><strong>Queues</strong></h3>&#13;
<p class="noindent">A <em>queue</em> is a data structure that, like a stack, has push and pop as its fundamental operations. Unlike a stack, a queue is <em>first-in</em>, <em>first-out</em>. When you push an element into a queue, you insert onto the queue’s end. When you pop an element off the queue, you remove from the queue’s beginning. This way, the element that has been in the queue the longest is the one to get popped off.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_429"/>The STL offers the <code>std::queue</code> in the <code>&lt;queue&gt;</code> header. Like <code>stack</code>, <code>queue</code> takes two template parameters. The first parameter is the underlying type of the wrapped container, and the optional second parameter is the type of the wrapped container, which also defaults to <code>deque</code>.</p>&#13;
<p class="indent">Among STL containers, you can only use <code>deque</code> or <code>list</code> as the underlying container for a <code>queue</code>, because pushing and popping from the front of a <code>vector</code> is inefficient.</p>&#13;
<p class="indent">You can access the element at the front or back of a queue using the <code>front</code> and <code>back</code> methods.</p>&#13;
<p class="indent"><a href="ch13.xhtml#ch13ex20">Listing 13-20</a> shows how to use a <code>queue</code> to wrap a <code>deque</code>.</p>&#13;
<pre>#include &lt;queue&gt;&#13;
&#13;
TEST_CASE("std::queue supports push/pop/front/back") {&#13;
  std::deque&lt;int&gt; deq{ 1, 2 }; <span class="ent">➊</span>&#13;
  std::queue&lt;int&gt; easy_as(deq); <span class="ent">➋</span> // 1 2&#13;
&#13;
  REQUIRE(easy_as.front() == 1); <span class="ent">➌</span>&#13;
  REQUIRE(easy_as.back() == 2); <span class="ent">➍</span>&#13;
  easy_as.pop(); <span class="ent">➎</span>                // 2&#13;
  easy_as.push(3); <span class="ent">➏</span>              // 2 3&#13;
  REQUIRE(easy_as.front() == 2); <span class="ent">➐</span>&#13;
  REQUIRE(easy_as.back() == 3); <span class="ent">➑</span>&#13;
  easy_as.pop();                   // 3&#13;
  REQUIRE(easy_as.front() == 3);&#13;
  easy_as.pop();                   //&#13;
  REQUIRE(easy_as.empty()); <span class="ent">➒</span>&#13;
}</pre>&#13;
<p class="listing"><a id="ch13ex20"/><em>Listing 13-20: Using a <code>queue</code> to wrap a <code>deque</code></em></p>&#13;
<p class="indent">You start with a <code>deque</code> containing the elements 1 and 2 <span class="ent">➊</span>, which you pass into a queue called <code>easy_as</code> <span class="ent">➋</span>. Using the <code>front</code> and <code>back</code> methods, you can validate that the queue begins with a 1 <span class="ent">➌</span> and ends with a 2 <span class="ent">➍</span>. When you <code>pop</code> the first element, 1, you’re left with a queue containing just the single element 2 <span class="ent">➎</span>. You then <code>push</code> 3 <span class="ent">➏</span>, so the method <code>front</code> yields 2 <span class="ent">➐</span> and <code>back</code> yields 3 <span class="ent">➑</span>. After two more iterations of <code>pop</code>-<code>front</code>, you’re left with an empty <code>queue</code> <span class="ent">➒</span>.</p>&#13;
<p class="indent"><a href="ch13.xhtml#ch13tab06">Table 13-6</a> summarizes the operations of <code>queue</code>. In this table, <code>q</code>, <code>q1</code>, and <code>q2</code> are of type <code>std::queue&lt;T&gt;</code>; <code>t</code> is of type <code>T</code>; and <code>ctr</code> is a container of type <code>ctr_type&lt;T&gt;</code>.</p>&#13;
<p class="tabcap"><a id="ch13tab06"/><strong>Table 13-6:</strong> A Summary of <code>std::queue</code> Operations</p>&#13;
<table class="topbot-d">&#13;
<colgroup>&#13;
<col style="width:30%"/>&#13;
<col style="width:70%"/>&#13;
</colgroup>&#13;
<tbody>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-h"><p class="tab_th"><strong>Operation</strong></p></td>&#13;
<td style="vertical-align: top;" class="table-h"><p class="tab_th"><strong>Notes</strong></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><code>queue&lt;</code><span class="codestrong">T</span><code>, [</code><span class="codestrong">ctr_type&lt;T&gt;</span><code>]&gt;([</code><span class="codestrong">ctr</span><code>])</code></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">Constructs a <span class="codestrong">queue</span> of <span class="codestrong">T</span>s using <span class="codestrong">ctr</span> as its internal container. If no container is provided, constructs an empty <code>deque</code>.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><span class="codestrong">q</span><code>.empty()</code></p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba">Returns <code>true</code> if container is empty.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><span class="codestrong">q</span><code>.size()</code></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">Returns number of elements in container.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b"><span epub:type="pagebreak" id="page_430"/><p class="taba"><span class="codestrong">q</span><code>.front()</code></p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba">Returns a reference to the element in front of the <code>queue</code>.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><span class="codestrong">q</span><code>.back()</code></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">Returns a reference to the element in back of the <code>queue</code>.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><span class="codestrong">q</span><code>.push(</code><span class="codestrong">t</span><code>)</code></p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba">Puts a copy of <span class="codestrong">t</span> onto the end of the container.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><span class="codestrong">q</span><code>.emplace(</code><span class="codestrong">...</span><code>)</code></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">Constructs a <span class="codestrong">T</span> in place by forwarding <span class="codestrong">...</span> to the appropriate constructor.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><span class="codestrong">q</span><code>.pop()</code></p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba">Removes the element at the front of the container.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-ba"><p class="taba"><span class="codestrong">q1</span><code>.swap(</code><span class="codestrong">q2</span><code>)</code>&#13;
<br/><code>swap(</code><span class="codestrong">q1</span><code>,</code> <span class="codestrong">q2</span><code>)</code></p></td>&#13;
<td style="vertical-align: top;" class="table-ba"><p class="taba">Exchanges the contents of <span class="codestrong">q2</span> with <span class="codestrong">q1</span>.</p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<h3 class="h3" id="ch13lev1sec4"><strong>Priority Queues (Heaps)</strong></h3>&#13;
<p class="noindent">A <em>priority queue</em> (also called a heap) is a data structure that supports <code>push</code> and <code>pop</code> operations and keeps elements sorted according to some user-specified <em>comparator object</em>. The comparator object is a function object invokable with two parameters, returning <code>true</code> if the first argument is less than the second. When you <code>pop</code> an element from a priority queue, you remove the element that is greatest, according to the comparator object.</p>&#13;
<p class="indent">The STL offers the <code>std::priority_queue</code> in the <code>&lt;queue&gt;</code> header. A <code>priority_queue</code> has three template parameters:</p>&#13;
<ul>&#13;
<li class="noindent">The underlying type of the wrapped container</li>&#13;
<li class="noindent">The type of the wrapped container</li>&#13;
<li class="noindent">The type of the comparator object</li>&#13;
</ul>&#13;
<p class="indent">Only the underlying type is mandatory. The wrapped container type defaults to <code>vector</code> (probably because it’s the most widely used sequential container), and the comparator object type defaults to <code>std::less</code>.</p>&#13;
<div class="note">&#13;
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>&#13;
<p class="notep"><em>The <code>std::less</code> class template is available from the <code>&lt;functional&gt;</code> header, and it returns <code>true</code> if the first argument is less than the second.</em></p>&#13;
</div>&#13;
<p class="indent">The <code>priority_queue</code> has an identical interface to a <code>stack</code>. The only difference is that stacks <code>pop</code> elements according to the last-in, first-out arrangement, whereas priority queues <code>pop</code> elements according to the comparator object criteria.</p>&#13;
<p class="indent"><a href="ch13.xhtml#ch13ex21">Listing 13-21</a> illustrates the basic usage of <code>priority_queue</code>.</p>&#13;
<pre>#include &lt;queue&gt;&#13;
&#13;
TEST_CASE("std::priority_queue supports push/pop") {&#13;
  std::priority_queue&lt;double&gt; prique; <span class="ent">➊</span>&#13;
  prique.push(1.0); // 1.0&#13;
  prique.push(2.0); // 2.0 1.0&#13;
  prique.push(1.5); // 2.0 1.5 1.0&#13;
<span epub:type="pagebreak" id="page_431"/>&#13;
  REQUIRE(prique.top() == Approx(2.0)); <span class="ent">➋</span>&#13;
  prique.pop();     // 1.5 1.0&#13;
  prique.push(1.0); // 1.5 1.0 1.0&#13;
  REQUIRE(prique.top() == Approx(1.5)); <span class="ent">➌</span>&#13;
  prique.pop();     // 1.0 1.0&#13;
  REQUIRE(prique.top() == Approx(1.0)); <span class="ent">➍</span>&#13;
  prique.pop();     // 1.0&#13;
  REQUIRE(prique.top() == Approx(1.0)); <span class="ent">➎</span>&#13;
  prique.pop();     //&#13;
  REQUIRE(prique.empty()); <span class="ent">➏</span>&#13;
}</pre>&#13;
<p class="listing"><a id="ch13ex21"/><em>Listing 13-21: Basic <code>priority_queue</code> usage</em></p>&#13;
<p class="indent">Here, you default construct a <code>priority_queue</code> <span class="ent">➊</span>, which internally initializes an empty <code>vector</code> to hold its elements. You push the elements 1.0, 2.0, and 1.5 into the <code>priority_queue</code>, which sorts the elements in descending order so the container represents them in the order 2.0 1.5 1.0.</p>&#13;
<p class="indent">You assert that <code>top</code> yields 2.0 <span class="ent">➋</span>, pop this element off the <code>priority_queue</code>, and then invoke <code>push</code> with the new element 1.0. The container now represents them in the order 1.5 <span class="ent">➌</span> 1.0 <span class="ent">➍</span> 1.0 <span class="ent">➎</span>, which you verify with a series of <code>top</code>-<code>pop</code> operations until the container is empty <span class="ent">➏</span>.</p>&#13;
<div class="note">&#13;
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>&#13;
<p class="notep"><em>A <code>priority_queue</code> holds its elements in a tree structure, so if you peered into its underlying container, the memory ordering wouldn’t match the orders implied by <a href="ch13.xhtml#ch13ex21">Listing 13-21</a>.</em></p>&#13;
</div>&#13;
<p class="indent"><a href="ch13.xhtml#ch13tab07">Table 13-7</a> summarizes the operations of <code>priority_queue</code>. In this table, <code>pq</code>, <code>pq1</code>, and <code>pq2</code> are of type <code>std::priority_queue&lt;T&gt;</code>; <code>t</code> is of type <code>T</code>; <code>ctr</code> is a container of type <code>ctr_type&lt;T&gt;</code>; and <code>srt</code> is a container of type <code>srt_type&lt;T&gt;</code>.</p>&#13;
<p class="tabcap"><a id="ch13tab07"/><strong>Table 13-7:</strong> A Summary of <code>std::priority_queue</code> Operations</p>&#13;
<table class="topbot-d">&#13;
<colgroup>&#13;
<col style="width:30%"/>&#13;
<col style="width:70%"/>&#13;
</colgroup>&#13;
<tbody>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-h"><p class="tab_th"><strong>Operation</strong></p></td>&#13;
<td style="vertical-align: top;" class="table-h"><p class="tab_th"><strong>Notes</strong></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><code>priority_queue &lt;</code><span class="codestrong">T</span><code>,</code> <code>[</code><span class="codestrong">ctr_type&lt;T&gt;</span><code>],</code> <code>[</code><span class="codestrong">cmp_type</span><code>]&gt;([</code><span class="codestrong">cmp</span><code>], [</code><span class="codestrong">ctr</span><code>])</code></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">Constructs a <code>priority_queue</code> of <span class="codestrong">T</span>s using <span class="codestrong">ctr</span> as its internal container and <span class="codestrong">srt</span> as its comparator object. If no container is provided, constructs an empty <code>deque</code>. Uses <code>std::less</code> as default sorter.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><span class="codestrong">pq</span><code>.empty()</code></p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba">Returns <code>true</code> if container is empty.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><span class="codestrong">pq</span><code>.size()</code></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">Returns number of elements in container.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><span class="codestrong">pq</span><code>.top()</code></p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba">Returns a reference to the greatest element in the container.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><span class="codestrong">pq</span><code>.push(</code><span class="codestrong">t</span><code>)</code></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">Puts a copy of <span class="codestrong">t</span> onto the end of the container.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><span class="codestrong">pq</span><code>.emplace(</code><span class="codestrong">...</span><code>)</code></p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba">Constructs a <span class="codestrong">T</span> in place by forwarding <span class="codestrong">...</span> to the appropriate constructor.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><span class="codestrong">pq</span><code>.pop()</code></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">Removes the element at the end of the container.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b2"><p class="taba"><span class="codestrong">pq1</span><code>.swap(</code><span class="codestrong">pq2</span><code>)<br/>swap(</code><span class="codestrong">pq1</span><code>,</code> <span class="codestrong">pq2</span><code>)</code></p></td>&#13;
<td style="vertical-align: top;" class="table-b2"><p class="taba">Exchanges the contents of <span class="codestrong">s2</span> with <span class="codestrong">s1</span>.</p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<h3 class="h3" id="ch13lev1sec5"><span epub:type="pagebreak" id="page_432"/><strong>Bitsets</strong></h3>&#13;
<p class="noindent">A <em>bitset</em> is a data structure that stores a fixed-size bit sequence. You can manipulate each bit.</p>&#13;
<p class="indent">The STL offers the <code>std::bitset</code> in the <code>&lt;bitset&gt;</code> header. The class template <code>bitset</code> takes a single template parameter corresponding to the desired size. You could achieve similar functionality using a <code>bool array</code>, but <code>bitset</code> is optimized for space efficiency and provides some special convenience operations.</p>&#13;
<div class="note">&#13;
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>&#13;
<p class="notep"><em>The STL specializes <code>std::vector&lt;bool&gt;</code>, so it might benefit from the same space efficiencies as <code>bitset</code>. (Recall from “Template Specialization” on <a href="ch06.xhtml#page_178">page 178</a> that template specialization is the process of making certain kinds of template instantiations more efficient.) Boost offers <code>boost::dynamic_bitset</code>, which provides dynamic sizing at runtime.</em></p>&#13;
</div>&#13;
<p class="indent">A default constructed <code>bitset</code> contains all zero (false) bits. To initialize bitsets with other contents, you can provide an <code>unsigned long long</code> value. This integer’s bitwise representation sets the value of <code>bitset</code>. You can access individual bits in the <code>bitset</code> using <code>operator[]</code>. <a href="ch13.xhtml#ch13ex22">Listing 13-22</a> demonstrates how to initialize a <code>bitset</code> with an integer literal and extract its elements.</p>&#13;
<pre>#include &lt;bitset&gt;&#13;
&#13;
TEST_CASE("std::bitset supports integer initialization") {&#13;
  std::bitset&lt;4&gt; bs(0b1010); <span class="ent">➊</span>&#13;
  REQUIRE_FALSE(bs[0]); <span class="ent">➋</span>&#13;
  REQUIRE(bs[1]); <span class="ent">➌</span>&#13;
  REQUIRE_FALSE(bs[2]); <span class="ent">➍</span>&#13;
  REQUIRE(bs[3]); <span class="ent">➎</span>&#13;
}</pre>&#13;
<p class="listing"><a id="ch13ex22"/><em>Listing 13-22: Initializing a <code>bitset</code> with an integer</em></p>&#13;
<p class="indent">You initialize a <code>bitset</code> with the 4-bit <em>nybble</em> <code>0101</code> <span class="ent">➊</span>. So, the first <span class="ent">➋</span> and third <span class="ent">➍</span> elements are zero, and the second <span class="ent">➌</span> and fourth <span class="ent">➎</span> elements are 1.</p>&#13;
<p class="indent">You can also provide a string representation of the desired <code>bitset</code>, as shown in <a href="ch13.xhtml#ch13ex23">Listing 13-23</a>.</p>&#13;
<pre>TEST_CASE("std::bitset supports string initialization") {&#13;
  std::bitset&lt;4&gt; bs1(0b0110); <span class="ent">➊</span>&#13;
  std::bitset&lt;4&gt; bs2("0110"); <span class="ent">➋</span>&#13;
  REQUIRE(bs1 == bs2); <span class="ent">➌</span>&#13;
}</pre>&#13;
<p class="listing"><a id="ch13ex23"/><em>Listing 13-23: Initializing a <code>bitset</code> with a string</em></p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_433"/>Here, you construct a <code>bitset</code> called <code>bs1</code> using the same integer nybble <code>0b0110</code> <span class="ent">➊</span> and another <code>bitset</code> called <code>bs2</code> using the string literal <code>0110</code> <span class="ent">➋</span>. Both of these initialization approaches produce identical <code>bitset</code> objects <span class="ent">➌</span>.</p>&#13;
<p class="indent"><a href="ch13.xhtml#ch13tab08">Table 13-8</a> summarizes the operations of <code>bitset</code>. In this table, <code>bs</code>, <code>bs 1</code>, and <code>bs 2</code> are of type <code>std::bitset&lt;N&gt;</code>, and <code>i</code> is a <code>size_t</code>.</p>&#13;
<p class="tabcap"><a id="ch13tab08"/><strong>Table 13-8:</strong> A Summary of <code>std::bitset</code> Operations</p>&#13;
<table class="topbot-d">&#13;
<colgroup>&#13;
<col style="width:30%"/>&#13;
<col style="width:70%"/>&#13;
</colgroup>&#13;
<tbody>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-h"><p class="tab_th"><strong>Operation</strong></p></td>&#13;
<td style="vertical-align: top;" class="table-h"><p class="tab_th"><strong>Notes</strong></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><code>bitset&lt;</code><span class="codestrong">N</span><code>&gt;([</code><span class="codestrong">val</span><code>])</code></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">Constructs a <code>bitset</code> with initial value <span class="codestrong">val</span>, which can be either a string of <span class="codestrong">0</span>s and <span class="codestrong">1</span>s or an <code>unsigned long long</code>. Default constructor initializes all bits to zero.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><span class="codestrong">bs</span><code>[</code><span class="codestrong">i</span><code>]</code></p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba">Returns the value of the <span class="codestrong">i</span>-th bit: 1 returns true; 0 returns false.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><span class="codestrong">bs</span><code>.test(</code><span class="codestrong">i</span><code>)</code></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">Returns the value of the <span class="codestrong">i</span>-th bit: 1 returns true; 0 returns false. Performs bounds checking; throws <code>std::out_of_range</code>.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><span class="codestrong">bs</span><code>.set()</code></p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba">Sets all bits to 1.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><span class="codestrong">bs</span><code>.set(</code><span class="codestrong">i</span><code>,</code> <span class="codestrong">val</span><code>)</code></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">Sets the <span class="codestrong">i</span>-th bit to <span class="codestrong">val</span>. Performs bounds checking; throws <code>std::out_of_range</code>.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><span class="codestrong">bs</span><code>.reset()</code></p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba">Sets all bits to 0.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><span class="codestrong">bs</span><code>.reset(</code><span class="codestrong">i</span><code>)</code></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">Sets the <span class="codestrong">i</span>-th bit to zero. Performs bounds checking; throws <code>std::out_of_range</code>.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><span class="codestrong">bs</span><code>.flip()</code></p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba">Flips all the bits: (0 becomes 1; 1 becomes 0).</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><span class="codestrong">bs</span><code>.flip(</code><span class="codestrong">i</span><code>)</code></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">Flips the <span class="codestrong">i</span>-th bit. Performs bounds checking; throws <code>std::out_of_range</code>.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><span class="codestrong">bs</span><code>.count()</code></p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba">Returns the number of bits set to 1.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><span class="codestrong">bs</span><code>.size()</code></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">Returns the size <span class="codestrong">N</span> of the bitset.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><span class="codestrong">bs</span><code>.any()</code></p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba">Returns <code>true</code> if any bits are set to 1.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><span class="codestrong">bs</span><code>.none()</code></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">Returns <code>true</code> if all bits are set to 0.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><span class="codestrong">bs</span><code>.all()</code></p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba">Returns <code>true</code> if all bits are set to 1.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><span class="codestrong">bs</span><code>.to_string()</code></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">Returns the <code>string</code> representation of the <span class="codestrong">bitset</span>.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><span class="codestrong">bs</span><code>.to_ulong()</code></p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba">Returns the <code>unsigned long</code> representation of the <span class="codestrong">bitset</span>.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-ba"><p class="taba"><span class="codestrong">bs</span><code>.to_ullong()</code></p></td>&#13;
<td style="vertical-align: top;" class="table-ba"><p class="taba">Returns the <code>unsigned long long</code> representation of the <span class="codestrong">bitset</span>.</p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<h3 class="h3" id="ch13lev1sec6"><strong>Special Sequential Boost Containers</strong></h3>&#13;
<p class="noindent">Boost provides an abundance of special containers, and there simply isn’t enough room to explore all their features here. <a href="ch13.xhtml#ch13tab09">Table 13-9</a> provides the names, headers, and brief descriptions of a number of them.</p>&#13;
<div class="note">&#13;
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>&#13;
<p class="notep"><em>Refer to the Boost Container documentation for more information.</em></p>&#13;
</div>&#13;
<p class="tabcap"><span epub:type="pagebreak" id="page_434"/><a id="ch13tab09"/><strong>Table 13-9:</strong> Special Boost Containers</p>&#13;
<table class="topbot-d">&#13;
<colgroup>&#13;
<col style="width:30%"/>&#13;
<col style="width:70%"/>&#13;
</colgroup>&#13;
<tbody>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-h"><p class="tab_th"><strong>Class/Header</strong></p></td>&#13;
<td style="vertical-align: top;" class="table-h"><p class="tab_th"><strong>Description</strong></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><code>boost::intrusive::*</code></p>&#13;
<p class="taba"><code>&lt;boost/intrusive/*.hpp&gt;</code></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">Intrusive containers impose requirements on the elements they contain (such as inheriting from a particular base class). In exchange, they offer substantial performance gains.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><code>boost::container::stable_vector</code></p>&#13;
<p class="taba"><code>&lt;boost/container/stable_vector.hpp&gt;</code></p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba">A vector without contiguous elements but guarantees that iterators and references to elements remain valid as long as the element isn’t erased (as with <code>list</code>).</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><code>boost::container::slist</code></p>&#13;
<p class="taba"><code>&lt;boost/container/slist.hpp&gt;</code></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">A <code>forward_list</code> with a fast <code>size</code> method.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><code>boost::container::static_vector</code></p>&#13;
<p class="taba"><code>&lt;boost/container/static_vector.hpp&gt;</code></p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba">A hybrid between array and vector that stores a dynamic number of elements up to a fixed size. Elements are stored within the memory of <code>stable_vector</code>, like an <code>array</code>.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><code>boost::container::small_vector</code></p>&#13;
<p class="taba"><code>&lt;boost/container/small_vector.hpp&gt;</code></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">A <code>vector</code>-like container optimized for holding a small number of elements. Contains some preallocated space, avoiding dynamic allocation.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><code>boost::circular_buffer</code></p>&#13;
<p class="taba"><code>&lt;boost/circular_buffer.hpp&gt;</code></p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba">A fixed-capacity, queue-like container that fills elements in a circular fashion; a new element overwrites the oldest element once capacity is reached.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><code>boost::multi_array</code></p>&#13;
<p class="taba"><code>&lt;boost/multi_array.hpp&gt;</code></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">An array-like container that accepts multiple dimensions. Rather than having, for example, an array of arrays of arrays, you can specify a three-dimensional <code>multi_array</code> <span class="codestrong">x</span> that allows element access, such as <span class="codestrong">x</span><code>[5][1][2]</code>.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b2"><p class="taba"><code>boost::ptr_vector</code></p>&#13;
<p class="taba"><code>boost::ptr_list</code></p>&#13;
<p class="taba"><code>&lt;boost/ptr_container/*.hpp&gt;</code></p></td>&#13;
<td style="vertical-align: top;" class="table-b2"><p class="taba">Having a collection of smart pointers can be suboptimal. Pointer vectors manage a collection of dynamic objects in a more efficient and user-friendly way.</p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<div class="note">&#13;
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>&#13;
<p class="notep"><em>Boost Intrusive also contains some specialized containers that provide performance benefits in certain situations. These are primarily useful for library implementers.</em></p>&#13;
</div>&#13;
<h3 class="h3" id="ch13lev1sec7"><strong>Associative Containers</strong></h3>&#13;
<p class="noindent"><em>Associative containers</em> allow for very fast element search. Sequential containers have some natural ordering that allows you to iterate from the beginning of the container to the end in a well-specified order. Associative containers are a bit different. This container family splits along three axes:</p>&#13;
<ul>&#13;
<li class="noindent">Whether elements contain keys (a set) or key-value pairs (a map)</li>&#13;
<li class="noindent">Whether elements are ordered</li>&#13;
<li class="noindent">Whether keys are <em>unique</em></li>&#13;
</ul>&#13;
<h4 class="h4" id="ch13lev2sec4"><strong><em><span epub:type="pagebreak" id="page_435"/>Sets</em></strong></h4>&#13;
<p class="noindent">The <code>std::set</code> available in the STL’s <code>&lt;set&gt;</code> header is an associative container that contains sorted, unique elements called <em>keys</em>. Because <code>set</code> stores sorted elements, you can insert, remove, and search efficiently. In addition, <code>set</code> supports sorted iteration over its elements, and you have complete control over how keys sort using comparator objects.</p>&#13;
<div class="note">&#13;
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>&#13;
<p class="notep"><em>Boost also provides a <code>boost::container::set</code> in the <code>&lt;boost/container/set.hpp&gt;</code> header.</em></p>&#13;
</div>&#13;
<h5 class="h5" id="ch13lev3sec14"><strong>Constructing</strong></h5>&#13;
<p class="noindent">The class template <code>set&lt;T, Comparator, Allocator&gt;</code> takes three template parameters:</p>&#13;
<ul>&#13;
<li class="noindent">The key type <code>T</code></li>&#13;
<li class="noindent">The comparator type that defaults to <code>std::less</code></li>&#13;
<li class="noindent">The allocator type that defaults to <code>std::allocator&lt;T&gt;</code></li>&#13;
</ul>&#13;
<p class="indent">You have a lot of flexibility when constructing <code>set</code>s. Each of the following constructors accepts an optional comparator and allocator (whose types must match their corresponding template parameters):</p>&#13;
<ul>&#13;
<li class="noindent">A default constructor that initializes an empty <code>set</code></li>&#13;
<li class="noindent">Move and copy constructors with the usual behavior</li>&#13;
<li class="noindent">A range constructor that copies the elements from the range into the set</li>&#13;
<li class="noindent">A braced initializer</li>&#13;
</ul>&#13;
<p class="indent"><a href="ch13.xhtml#ch13ex24">Listing 13-24</a> showcases each of these constructors.</p>&#13;
<pre>#include &lt;set&gt;&#13;
&#13;
TEST_CASE("std::set supports") {&#13;
  std::set&lt;int&gt; emp; <span class="ent">➊</span>&#13;
  std::set&lt;int&gt; fib{ 1, 1, 2, 3, 5 }; <span class="ent">➋</span>&#13;
  SECTION("default construction") {&#13;
    REQUIRE(emp.empty()); <span class="ent">➌</span>&#13;
  }&#13;
  SECTION("braced initialization") {&#13;
    REQUIRE(fib.size() == 4); <span class="ent">➍</span>&#13;
  }&#13;
  SECTION("copy construction") {&#13;
    auto fib_copy(fib);&#13;
    REQUIRE(fib.size() == 4); <span class="ent">➎</span>&#13;
    REQUIRE(fib_copy.size() == 4); <span class="ent">➏</span>&#13;
  }&#13;
  SECTION("move construction") {&#13;
    auto fib_moved(std::move(fib));&#13;
    REQUIRE(fib.empty()); <span class="ent">➐</span>&#13;
    REQUIRE(fib_moved.size() == 4); <span class="ent">➑</span>&#13;
<span epub:type="pagebreak" id="page_436"/>  }&#13;
  SECTION("range construction") {&#13;
    std::array&lt;int, 5&gt; fib_array{ 1, 1, 2, 3, 5 };&#13;
    std::set&lt;int&gt; fib_set(fib_array.cbegin(), fib_array.cend());&#13;
    REQUIRE(fib_set.size() == 4); <span class="ent">➒</span>&#13;
  }&#13;
}</pre>&#13;
<p class="listing"><a id="ch13ex24"/><em>Listing 13-24: The constructors of a <code>set</code></em></p>&#13;
<p class="indent">You default construct <span class="ent">➊</span> and brace initialize <span class="ent">➋</span> two different <code>set</code>s. The default constructed <code>set</code> called <code>emp</code> is empty <span class="ent">➌</span>, and the braced initialized <code>set</code> called <code>fib</code> has four elements <span class="ent">➍</span>. You include five elements in the braced initializer, so why only four elements? Recall that <code>set</code> elements are unique, so the 1 enters only once.</p>&#13;
<p class="indent">Next, you copy construct <code>fib</code>, which results in two <code>set</code>s with size 4 <span class="ent">➎ ➏</span>. On the other hand, the move constructor empties the moved-from set <span class="ent">➐</span> and transfers the elements to the new <code>set</code> <span class="ent">➑</span>.</p>&#13;
<p class="indent">Then you can initialize a <code>set</code> from a range. You construct an <code>array</code> with five elements and then pass it as a range to a <code>set</code> constructor using the <code>cbegin</code> and <code>cend</code> methods. As with the braced initialization earlier in the code, the <code>set</code> contains only four elements because duplicates are discarded <span class="ent">➒</span>.</p>&#13;
<h5 class="h5" id="ch13lev3sec15"><strong>Move and Copy Semantics</strong></h5>&#13;
<p class="noindent">In addition to move/copy constructors, move/copy assignment operators are also available. As with other container copy operations, <code>set</code> copies are potentially very slow because each element needs to get copied, and move operations are usually fast because elements reside in dynamic memory. A <code>set</code> can simply pass ownership without disturbing the elements.</p>&#13;
<h5 class="h5" id="ch13lev3sec16"><strong>Element Access</strong></h5>&#13;
<p class="noindent">You have several options for extracting elements from a <code>set</code>. The basic method is <code>find</code>, which takes a <code>const</code> reference to a key and returns an iterator. If the <code>set</code> contains an element-matching key, <code>find</code> will return an iterator pointing to the found element. If the <code>set</code> does not, it will return an iterator pointing to <code>end</code>. The <code>lower_bound</code> method returns an iterator to the first element <em>not less than</em> the key argument, whereas the <code>upper_bound</code> method returns the first element <em>greater than</em> the given key.</p>&#13;
<p class="indent">The <code>set</code> class supports two additional lookup methods, mainly for compatibility of non-unique associative containers:</p>&#13;
<ul>&#13;
<li class="noindent">The <code>count</code> method returns the number of elements matching the key. Because <code>set</code> elements are unique, <code>count</code> returns either 0 or 1.</li>&#13;
<li class="noindent">The <code>equal_range</code> method returns a half-open range containing all the elements matching the given key. The range returns a <code>std::pair</code> of iterators with <code>first</code> pointing to the matching element and <code>second</code> pointing to <span epub:type="pagebreak" id="page_437"/>the element after <code>first</code>. If <code>equal_range</code> finds no matching element, <code>first</code> and <code>second</code> both point to the first element greater than the given key. In other words, the pair returned by <code>equal_range</code> is equivalent to a <code>pair</code> of <code>lower_bound</code> as <code>first</code> and <code>upper_bound</code> as <code>second</code>.</li>&#13;
</ul>&#13;
<p class="indent"><a href="ch13.xhtml#ch13ex25">Listing 13-25</a> illustrates these two access methods.</p>&#13;
<pre>TEST_CASE("std::set allows access") {&#13;
  std::set&lt;int&gt; fib{ 1, 1, 2, 3, 5 }; <span class="ent">➊</span>&#13;
  SECTION("with find") { <span class="ent">➋</span>&#13;
    REQUIRE(*fib.find(3) == 3);&#13;
    REQUIRE(fib.find(100) == fib.end());&#13;
  }&#13;
  SECTION("with count") { <span class="ent">➌</span>&#13;
    REQUIRE(fib.count(3) == 1);&#13;
    REQUIRE(fib.count(100) == 0);&#13;
  }&#13;
  SECTION("with lower_bound") { <span class="ent">➍</span>&#13;
    auto itr = fib.lower_bound(3);&#13;
    REQUIRE(*itr == 3);&#13;
  }&#13;
  SECTION("with upper_bound") { <span class="ent">➎</span>&#13;
    auto itr = fib.upper_bound(3);&#13;
    REQUIRE(*itr == 5);&#13;
  }&#13;
  SECTION("with equal_range") { <span class="ent">➏</span>&#13;
    auto pair_itr = fib.equal_range(3);&#13;
    REQUIRE(*pair_itr.first == 3);&#13;
    REQUIRE(*pair_itr.second == 5);&#13;
  }&#13;
}</pre>&#13;
<p class="listing"><a id="ch13ex25"/><em>Listing 13-25: A <code>set</code> member access</em></p>&#13;
<p class="indent">First, you construct a <code>set</code> with the four elements 1 2 3 5 <span class="ent">➊</span>. Using <code>find</code>, you can extract an iterator to the element 3. You can also determine that 8 isn’t in the <code>set</code>, because <code>find</code> returns an iterator pointing to <code>end</code> <span class="ent">➋</span>. You can determine similar information with <code>count</code>, which returns 1 when you give the key 3 and 0 when you give the key 8 <span class="ent">➌</span>. When you pass 3 to the <code>lower_bound</code> method, it returns an iterator pointing to 3 because this is the first element that’s not less than the argument <span class="ent">➍</span>. When you pass this to <code>upper_bound</code>, on the other hand, you obtain a pointer to the element 5, because this is the first element greater than the argument <span class="ent">➎</span>. Finally, when you pass 3 to the <code>equal_range</code> method, you obtain a <code>pair</code> of iterators. The <code>first</code> iterator points to 3, and the <code>second</code> iterator points to 5, the element just after 3 <span class="ent">➏</span>.</p>&#13;
<p class="indent">A <code>set</code> also exposes iterators through its <code>begin</code> and <code>end</code> methods, so you can use range-based <code>for</code> loops to iterate through the <code>set</code> from least element to greatest.</p>&#13;
<h3 class="h3" id="ch13lev1sec8"><span epub:type="pagebreak" id="page_438"/><strong>Adding Elements</strong></h3>&#13;
<p class="noindent">You have three options when adding elements to a <code>set</code>:</p>&#13;
<ul>&#13;
<li class="noindent"><code>insert</code> to copy an existing element into the <code>set</code></li>&#13;
<li class="noindent"><code>emplace</code> to in-place construct a new element into the <code>set</code></li>&#13;
<li class="noindent"><code>emplace_hint</code> to in-place construct a new element, just like <code>emplace</code> (because adding an element requires sorting). The difference is the <code>emplace_hint</code> method takes an iterator as its first argument. This iterator is the search’s starting point (a hint). If the iterator is close to the correct position for the newly inserted element, this can provide a substantial speedup. <p class="indent"><a href="ch13.xhtml#ch13ex26">Listing 13-26</a> illustrates the several ways to insert elements into a <code>set</code>.</p></li>&#13;
</ul>&#13;
<pre>TEST_CASE("std::set allows insertion") {&#13;
  std::set&lt;int&gt; fib{ 1, 1, 2, 3, 5 };&#13;
  SECTION("with insert") { <span class="ent">➊</span>&#13;
    fib.insert(8);&#13;
    REQUIRE(fib.find(8) != fib.end());&#13;
  }&#13;
  SECTION("with emplace") { <span class="ent">➋</span>&#13;
    fib.emplace(8);&#13;
    REQUIRE(fib.find(8) != fib.end());&#13;
  }&#13;
  SECTION("with emplace_hint") { <span class="ent">➌</span>&#13;
    fib.emplace_hint(fib.end(), 8);&#13;
    REQUIRE(fib.find(8) != fib.end());&#13;
  }&#13;
}</pre>&#13;
<p class="listing"><a id="ch13ex26"/><em>Listing 13-26: Inserting into a <code>set</code></em></p>&#13;
<p class="indent">Both <code>insert</code> <span class="ent">➊</span> and <code>emplace</code> <span class="ent">➋</span> add the element 8 into <code>fib</code>, so when you invoke <code>find</code> with 8, you get an iterator pointing to the new element. You can achieve the same effect a bit more efficiently with <code>emplace_hint</code> <span class="ent">➌</span>. Because you know ahead of time that the new element 8 is greater than all the other elements in the <code>set</code>, you can use <code>end</code> as the hint.</p>&#13;
<p class="indent">If you attempt to <code>insert</code>, <code>emplace</code>, or <code>emplace_hint</code> a key that’s already present in the <code>set</code>, the operation has no effect. All three of these methods return a <code>std::pair&lt;Iterator, bool&gt;</code> where the <code>second</code> element indicates whether the operation resulted in insertion (<code>true</code>) or not (<code>false</code>). The iterator at <code>first</code> points to either the newly inserted element or the existing element that prevented insertion.</p>&#13;
<h5 class="h5" id="ch13lev3sec17"><strong>Removing Elements</strong></h5>&#13;
<p class="noindent">You can remove elements from a set using <code>erase</code>, which is overloaded to accept a key, an iterator, or a half-open range, as shown in <a href="ch13.xhtml#ch13ex27">Listing 13-27</a>.</p>&#13;
<pre>TEST_CASE("std::set allows removal") {&#13;
  std::set&lt;int&gt; fib{ 1, 1, 2, 3, 5 };&#13;
  SECTION("with erase") { <span class="ent">➊</span>&#13;
<span epub:type="pagebreak" id="page_439"/>    fib.erase(3);&#13;
    REQUIRE(fib.find(3) == fib.end());&#13;
  }&#13;
  SECTION("with clear") { <span class="ent">➋</span>&#13;
    fib.clear();&#13;
    REQUIRE(fib.empty());&#13;
  }&#13;
}</pre>&#13;
<p class="listing"><a id="ch13ex27"/><em>Listing 13-27: Removing from a <code>set</code></em></p>&#13;
<p class="indent">In the first test, you call <code>erase</code> with the key 3, which removes the corresponding element from the <code>set</code>. When you invoke <code>find</code> on 3, you get an iterator pointing to the <code>end</code>, indicating that no matching element was found <span class="ent">➊</span>. In the second test, you invoke <code>clear</code>, which eliminates all the elements from the <code>set</code> <span class="ent">➋</span>.</p>&#13;
<h5 class="h5" id="ch13lev3sec18"><strong>Storage Model</strong></h5>&#13;
<p class="noindent">Set operations are fast because sets are typically implemented as <em>red-black trees</em>. These structures treat each element as a node. Each node has one parent and up to two children, its left and right legs. Each node’s children are sorted so all children to the left are less than the children to the right. This way, you can perform searches much quicker than with linear iteration, as long as a tree’s branches are roughly balanced (equal in length). Red-black trees have additional facilities for rebalancing branches after insertions and deletions.</p>&#13;
<div class="note">&#13;
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>&#13;
<p class="notep"><em>For details on red-black trees, refer to <em>Data Structures and Algorithms in C++</em> by Adam Drozdek.</em></p>&#13;
</div>&#13;
<h5 class="h5" id="ch13lev3sec19"><strong>A Partial List of Supported Operations</strong></h5>&#13;
<p class="noindent"><a href="ch13.xhtml#ch13tab10">Table 13-10</a> summarizes the operations of <code>set</code>. Operations <code>s</code>, <code>s1</code>, and <code>s2</code> are of type <code>std::set&lt;T,[cmp_type&lt;T&gt;]&gt;</code>. <code>T</code> is the contained element/key type, and <code>itr</code>, <code>beg</code>, and <code>end</code> are <code>set</code> iterators. The variable <code>t</code> is a <code>T</code>. A dagger ()denotes a method that returns a <code>std::pair&lt;Iterator, bool&gt;</code>, where the iterator points to the resulting element and the <code>bool</code> equals <code>true</code> if the method inserted an element and <code>false</code> if the element already existed.</p>&#13;
<p class="tabcap"><a id="ch13tab10"/><strong>Table 13-10:</strong> A Summary of <code>std::set</code></p>&#13;
<table class="topbot-d">&#13;
<colgroup>&#13;
<col style="width:30%"/>&#13;
<col style="width:70%"/>&#13;
</colgroup>&#13;
<tbody>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-h"><p class="tab_th"><strong>Operation</strong></p></td>&#13;
<td style="vertical-align: top;" class="table-h"><p class="tab_th"><strong>Notes</strong></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><code>set&lt;</code><span class="codestrong">T</span><code>&gt;{</code> <span class="codestrong">...</span><code>, [</code><span class="codestrong">cmp</span><code>], [</code><span class="codestrong">alc</span><code>] }</code></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">Performs braced initialization of a newly constructed set. Uses <span class="codestrong">cmp</span><code>=std::less&lt;</code><span class="codestrong">T</span><code>&gt;</code> and <span class="codestrong">alc</span><code>=std::allocator&lt;</code><span class="codestrong">T</span><code>&gt;</code> by default.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><code>set&lt;</code><span class="codestrong">T</span><code>&gt;{</code> <span class="codestrong">beg</span><code>,</code> <span class="codestrong">end</span><code>,</code> <code>[</code><span class="codestrong">cmp</span><code>], [</code><span class="codestrong">alc</span><code>] }</code></p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba">Range constructor that copies elements from the half-open range <span class="codestrong">beg</span> to <span class="codestrong">end</span>. Uses <span class="codestrong">cmp</span><code>=std::less&lt;</code><span class="codestrong">T</span><code>&gt;</code> and <span class="codestrong">alc</span><code>=std::allocator&lt;</code><span class="codestrong">T</span><code>&gt;</code> by default.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><code>set</code><code>&lt;</code><span class="codestrong">T</span><code>&gt;(</code><span class="codestrong">s</span><code>)</code></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">Deep copy of <span class="codestrong">s</span>; allocates new memory.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><span epub:type="pagebreak" id="page_440"/><code>set&lt;</code><span class="codestrong">T</span><code>&gt;(move(</code><span class="codestrong">s</span><code>))</code></p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba">Takes ownership of memory; elements in <span class="codestrong">s</span>. No allocations.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><code>~set</code></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">Destructs all elements contained by the set and releases dynamic memory.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><span class="codestrong">s1</span> <code>=</code> <span class="codestrong">s2</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><span class="codestrong">s1</span> destructs its elements; copies each <span class="codestrong">s2</span> element. Only allocates if it needs to resize to fit <span class="codestrong">s2</span>’s elements.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><span class="codestrong">s1</span> <code>= move(</code><span class="codestrong">s2</span><code>)</code></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><span class="codestrong">s1</span> destructs its elements; moves each <span class="codestrong">s2</span> element. Only allocates if it needs to resize to fit <span class="codestrong">s2</span>’s elements.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><span class="codestrong">s</span><code>.begin()</code></p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba">Returns an iterator pointing to the first element.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><span class="codestrong">s</span><code>.cbegin()</code></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">Returns a <code>const</code> iterator pointing to the first element.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><span class="codestrong">s</span><code>.end()</code></p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba">Returns an iterator pointing to 1 past the last element.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><span class="codestrong">s</span><code>.cend()</code></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">Returns a <code>const</code> iterator pointing to 1 past the last element.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><span class="codestrong">s</span><code>.find(</code><span class="codestrong">t</span><code>)</code></p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba">Returns an iterator pointing to the element matching <span class="codestrong">t</span> or <span class="codestrong">s</span>.<code>end()</code> if no such element exists.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><span class="codestrong">s</span><code>.count(</code><span class="codestrong">t</span><code>)</code></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">Returns 1 if set contains <span class="codestrong">t</span>; otherwise 0.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><span class="codestrong">s</span><code>.equal_range(</code><span class="codestrong">t</span><code>)</code></p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba">Returns a <code>pair</code> of iterators corresponding to the half-open range of elements matching <span class="codestrong">t</span>.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><span class="codestrong">s</span><code>.lower_bound(</code><span class="codestrong">t</span><code>)</code></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">Returns an iterator pointing to the first element not less than <span class="codestrong">t</span> or <span class="codestrong">s</span>.<code>end()</code> if no such element exists.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><span class="codestrong">s</span><code>.upper_bound(</code><span class="codestrong">t</span><code>)</code></p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba">Returns an iterator pointing to the first element greater than <span class="codestrong">t</span> or <span class="codestrong">s</span>.<code>end()</code> if no such element exists.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><span class="codestrong">s</span><code>.clear()</code></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">Removes all elements from the set.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><span class="codestrong">s</span><code>.erase(</code><span class="codestrong">t</span><code>)</code></p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba">Removes the element equal to <span class="codestrong">t</span>.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><span class="codestrong">s</span><code>.erase(</code><span class="codestrong">itr</span><code>)</code></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">Removes the element pointed to by <span class="codestrong">itr</span>.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><span class="codestrong">s</span><code>.erase(</code><span class="codestrong">beg</span><code>,</code> <span class="codestrong">end</span><code>)</code></p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba">Removes all elements on the half-open range from <span class="codestrong">beg</span> to <span class="codestrong">end</span>.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><span class="codestrong">s</span><code>.insert(</code><span class="codestrong">t</span><code>)</code></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">Inserts a copy of <span class="codestrong">t</span> into the set.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><span class="codestrong">s</span><code>.emplace(</code><span class="codestrong">...</span><code>)</code></p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba">Constructs a <span class="codestrong">T</span> in place by forwarding the arguments <span class="codestrong">...</span>.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><span class="codestrong">s</span><code>.emplace_hint(</code><span class="codestrong">itr</span><code>,</code> <span class="codestrong">...</span><code>)</code></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">Constructs a <span class="codestrong">T</span> in place by forwarding the arguments <span class="codestrong">...</span>. Uses <span class="codestrong">itr</span> as a hint for where to insert the new element.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><span class="codestrong">s</span><code>.empty()</code></p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba">Returns <code>true</code> if set’s size is zero; otherwise <code>false</code>.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><span class="codestrong">s</span><code>.size()</code></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">Returns the number of elements in the set.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><span class="codestrong">s</span><code>.max_size()</code></p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba">Returns the maximum number of elements in the set.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><span class="codestrong">s</span><code>.extract(</code><span class="codestrong">t</span><code>)</code></p>&#13;
<p class="taba"><span class="codestrong">s</span><code>.extract(</code><span class="codestrong">itr</span><code>)</code></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">Obtains a node handle that owns the element matching <span class="codestrong">t</span> or pointed to by <span class="codestrong">itr</span>. (This is the only way to remove a move-only element.)</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><span class="codestrong">s1</span><code>.merge(</code><span class="codestrong">s2</span><code>)</code></p>&#13;
<p class="taba"><span class="codestrong">s1</span><code>.merge(move(</code><span class="codestrong">s2</span><code>))</code></p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba">Splices each element of <span class="codestrong">s2</span> into <span class="codestrong">s1</span>. If argument is an rvalue, will move the elements into <span class="codestrong">s1</span>.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-ba"><p class="taba"><span class="codestrong">s1</span><code>.swap(</code><span class="codestrong">s2</span><code>)</code></p>&#13;
<p class="taba"><code>swap(</code><span class="codestrong">s1</span><code>,</code> <span class="codestrong">s2</span><code>)</code></p></td>&#13;
<td style="vertical-align: top;" class="table-ba"><p class="taba">Exchanges each element of <span class="codestrong">s1</span> with those of <span class="codestrong">s2</span>.</p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<h5 class="h5" id="ch13lev3sec20"><span epub:type="pagebreak" id="page_441"/><strong>Multisets</strong></h5>&#13;
<p class="noindent">The <code>std::multiset</code> available in the STL’s <code>&lt;set&gt;</code> header is an associative container that contains sorted, <em>non-unique</em> keys. A <code>multiset</code> supports the same operations as a <code>set</code>, but it will store redundant elements. This has important ramifications for two methods:</p>&#13;
<ul>&#13;
<li class="noindent">The method <code>count</code> can return values other than 0 or 1. The <code>count</code> method of <code>multiset</code> will tell you how many elements matched the given key.</li>&#13;
<li class="noindent">The method <code>equal_range</code> can return half-open ranges containing more than one element. The <code>equal_range</code> method of <code>multiset</code> will return a range containing all the elements matching the given key.</li>&#13;
</ul>&#13;
<p class="indent">You might want to use a <code>multiset</code> rather than a <code>set</code> if it’s important that you store multiple elements with the same key. For example, you could store all of an address’s occupants by treating the address as a key and each member of the house as an element. If you used a <code>set</code>, you’d be stuck having only a single occupant.</p><p class="indent"><a href="ch13.xhtml#ch13ex28">Listing 13-28</a> illustrates using a <code>multiset</code>.</p>&#13;
<pre>TEST_CASE("std::multiset handles non-unique elements") {&#13;
  std::multiset&lt;int&gt; fib{ 1, 1, 2, 3, 5 };&#13;
  SECTION("as reflected by size") {&#13;
    REQUIRE(fib.size() == 5); <span class="ent">➊</span>&#13;
  }&#13;
  SECTION("and count returns values greater than 1") {&#13;
    REQUIRE(fib.count(1) == 2); <span class="ent">➋</span>&#13;
  }&#13;
  SECTION("and equal_range returns non-trivial ranges") {&#13;
    auto [begin, end] = fib.equal_range(1); <span class="ent">➌</span>&#13;
    REQUIRE(*begin == 1); <span class="ent">➍</span>&#13;
    ++begin;&#13;
    REQUIRE(*begin == 1); <span class="ent">➎</span>&#13;
    ++begin;&#13;
    REQUIRE(begin == end); <span class="ent">➏</span>&#13;
  }&#13;
}</pre>&#13;
<p class="listing"><a id="ch13ex28"/><em>Listing 13-28: Accessing <code>multiset</code> elements</em></p>&#13;
<p class="indent">Unlike <code>set</code> in <a href="ch13.xhtml#ch13ex24">Listing 13-24</a>, <code>multiset</code> permits multiple 1s, so size returns 5, the number of elements you provided in the braced initializers <span class="ent">➊</span>. When you count the number of 1s, you get 2 <span class="ent">➋</span>. You can use <code>equal_range</code> to iterate over these elements. Using structured binding syntax, you obtain a <code>begin</code> and <code>end</code> iterator <span class="ent">➌</span>. You iterate over the two 1s <span class="ent">➍ ➎</span> and arrive at the end of the half-open range <span class="ent">➏</span>.</p>&#13;
<p class="indent">Every operation in <a href="ch13.xhtml#ch13tab10">Table 13-10</a> works for <code>multiset</code>.</p>&#13;
<div class="note">&#13;
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>&#13;
<p class="notep"><em>Boost also provides a <code>boost::container::multiset</code> in the <code>&lt;boost/container/set.hpp&gt;</code> header.</em></p>&#13;
</div>&#13;
<h4 class="h4" id="ch13lev2sec5"><strong><em><span epub:type="pagebreak" id="page_442"/>Unordered Sets</em></strong></h4>&#13;
<p class="noindent">The <code>std::unordered_set</code> available in the STL’s <code>&lt;unordered_set&gt;</code> header is an associative container that contains <em>unsorted</em>, unique keys. The <code>unordered_set</code> supports most of the same operations as <code>set</code> and <code>multiset</code>, but its internal storage model is completely different.</p>&#13;
<div class="note">&#13;
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>&#13;
<p class="notep"><em>Boost also provides a <code>boost::unordered_set</code> in the <code>&lt;boost/unordered_set.hpp&gt;</code> header.</em></p>&#13;
</div>&#13;
<p class="indent">Rather than using a comparator to sort elements into a red-black tree, an <code>unordered_set</code> is usually implemented as a hash table. You might want to use an <code>unordered_set</code> in a situation in which there is no natural ordering among the keys and you don’t need to iterate through the collection in such an order. You might find that in many situations, you could use either a <code>set</code> or an <code>unordered_set</code>. Although they appear quite similar, their internal representations are fundamentally different, so they’ll have different performance characteristics. If performance is an issue, measure how both perform and use the one that’s more appropriate.</p>&#13;
<h5 class="h5" id="ch13lev3sec21"><strong>Storage Model: Hash Tables</strong></h5>&#13;
<p class="noindent">A hash function, or a <em>hasher</em>, is a function that accepts a key and returns a unique <code>size_t</code> value called a hash code. The <code>unordered_set</code> organizes its elements into a hash table, which associates a hash code with a collection of one or more elements called a <em>bucket</em>. To find an element, an <code>unordered_set</code> computes its hash code and then searches through the corresponding bucket in the hash table.</p>&#13;
<p class="indent">If you’ve never seen a hash table before, this information might be a lot to take in, so let’s look at an example. Imagine you had a large group of people that you needed to sort into some kind of sensible groups to find an individual easily. You could group people by birthday, which would give you 365 groups (well, 366 if you count February 29 for leap years). The birthday is like a hash function that returns one of 365 values for each person. Each value forms a bucket, and all people in the same bucket have the same birthday. In this example, to find a person, you first determine their birthday, which gives you the correct bucket. Then you can search through the bucket to find the person you’re looking for.</p>&#13;
<p class="indent">As long as the hash function is quick and there aren’t too many elements per bucket, <code>unordered_set</code>s have even more impressive performance than their ordered counterparts: the contained element count doesn’t increase insertion, search, and deletion times. When two different keys have the same hash code, it’s called a <em>hash collision</em>. When you have a hash collision, it means that the two keys will reside in the same bucket. In the preceding birthday example, many people will have the same birthday, so there will be a lot of hash collisions. The more hash collisions there are, the larger the buckets will be, and the more time you’ll spend searching through a bucket for the correct element.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_443"/>A hash function has several requirements:</p>&#13;
<ul>&#13;
<li class="noindent">It accepts a <code>Key</code> and returns a <code>size_t</code> hash code.</li>&#13;
<li class="noindent">It doesn’t throw exceptions.</li>&#13;
<li class="noindent">Equal keys yield equal hash codes.</li>&#13;
<li class="noindent">Unequal keys yield unequal hash codes with high probability. (There is a low probability of a hash collision.)</li>&#13;
</ul>&#13;
<p class="indent">The STL provides the hasher class template <code>std::hash&lt;T&gt;</code> in the <code>&lt;functional&gt;</code> header, which contains specializations for fundamental types, enumeration types, pointer types, <code>optional</code>, <code>variant</code>, smart pointers, and more. As an example, <a href="ch13.xhtml#ch13ex29">Listing 13-29</a> illustrates how <code>std::hash&lt;long&gt;</code> meets the equivalence criteria.</p>&#13;
<pre>#include &lt;functional&gt;&#13;
TEST_CASE("std::hash&lt;long&gt; returns") {&#13;
  std::hash&lt;long&gt; hasher; <span class="ent">➊</span>&#13;
  auto hash_code_42 = hasher(42); <span class="ent">➋</span>&#13;
  SECTION("equal hash codes for equal keys") {&#13;
    REQUIRE(hash_code_42 == hasher(42)); <span class="ent">➌</span>&#13;
  }&#13;
  SECTION("unequal hash codes for unequal keys") {&#13;
    REQUIRE(hash_code_42 != hasher(43)); <span class="ent">➍</span>&#13;
  }&#13;
}</pre>&#13;
<p class="listing"><a id="ch13ex29"/><em>Listing 13-29: The <code>std::hash&lt;long&gt;</code> returns equal hash codes for equal keys and unequal hash codes for unequal keys.</em></p>&#13;
<p class="indent">You construct a hasher of type <code>std::hash&lt;long&gt;</code> <span class="ent">➊</span> and use it to compute the hash code of 42, storing the result into <code>size_t hash_code_42</code> <span class="ent">➋</span>. When you invoke <code>hasher</code> with 42 again, you obtain the same value <span class="ent">➌</span>. When you invoke hasher with <code>43</code> instead, you obtain a different value <span class="ent">➍</span>.</p>&#13;
<p class="indent">Once an <code>unordered_set</code> hashes a key, it can obtain a bucket. Because the bucket is a list of possible matching elements, you need a function object that determines equality between a key and a bucket element. The STL provides the class template <code>std::equal_to&lt;T&gt;</code> in the <code>&lt;functional&gt;</code> header, which simply invokes <code>operator==</code> on its arguments, as <a href="ch13.xhtml#ch13ex30">Listing 13-30</a> illustrates.</p>&#13;
<pre>#include &lt;functional&gt;&#13;
TEST_CASE("std::equal_to&lt;long&gt; returns") {&#13;
  std::equal_to&lt;long&gt; long_equal_to; <span class="ent">➊</span>&#13;
  SECTION("true when arguments equal") {&#13;
    REQUIRE(long_equal_to(42, 42)); <span class="ent">➋</span>&#13;
  }&#13;
  SECTION("false when arguments unequal") {&#13;
    REQUIRE_FALSE(long_equal_to(42, 43)); <span class="ent">➌</span>&#13;
  }&#13;
}</pre>&#13;
<p class="listing"><a id="ch13ex30"/><em>Listing 13-30: The <code>std::equal_to&lt;long&gt;</code> calls <code>operator==</code> on its arguments to determine equality.</em></p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_444"/>Here, you’ve initialized an <code>equal_to&lt;long&gt;</code> called <code>long_equal_to</code> <span class="ent">➊</span>. When you invoke <code>long_equal_to</code> with equal arguments, it returns <code>true</code> <span class="ent">➋</span>. When you invoke it with unequal arguments, it returns <code>false</code> <span class="ent">➌</span>.</p>&#13;
<div class="note">&#13;
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>&#13;
<p class="notep"><em>For brevity, this chapter won’t cover implementing your own hashing and equivalence functions, which you’ll need if you want to construct unordered containers given user-defined key types. See <a href="ch07.xhtml#ch07">Chapter 7</a> of  <em>The C++ Standard Library</em>, 2nd Edition, by Nicolai Josuttis.</em></p>&#13;
</div>&#13;
<h5 class="h5" id="ch13lev3sec22"><strong>Constructing</strong></h5>&#13;
<p class="noindent">The class template <code>std::unordered_set&lt;T, Hash, KeyEqual, Allocator&gt;</code> takes four template parameters:</p>&#13;
<ul>&#13;
<li class="noindent">Key type <code>T</code></li>&#13;
<li class="noindent">The <code>Hash</code> hash function type, which defaults to <code>std::hash&lt;T&gt;</code></li>&#13;
<li class="noindent">The <code>KeyEqual</code> equality function type, which defaults to <code>std::equal_to&lt;T&gt;</code></li>&#13;
<li class="noindent">The <code>Allocator</code> allocator type, which defaults to <code>std::allocator&lt;T&gt;</code></li>&#13;
</ul>&#13;
<p class="indent">An <code>unordered_set</code> supports equivalent constructors to <code>set</code> with adjustments for the different template parameters (<code>set</code> needs a <code>Comparator</code>, whereas <code>unordered_set</code> needs a <code>Hash</code> and a <code>KeyEqual</code>). For example, you can use <code>unordered_set</code> as a drop-in replacement for <code>set</code> in <a href="ch13.xhtml#ch13ex24">Listing 13-24</a>, because <code>unordered_set</code> has range constructors and copy/move constructors and supports braced initialization.</p>&#13;
<h5 class="h5" id="ch13lev3sec23"><strong>Supported set Operations</strong></h5>&#13;
<p class="noindent">An <code>unordered_set</code> supports all <code>set</code> operations in <a href="ch13.xhtml#ch13tab10">Table 13-10</a> except for <code>lower_bound</code> and <code>upper_bound</code>, because <code>unordered_set</code> doesn’t sort its elements.</p>&#13;
<h5 class="h5" id="ch13lev3sec24"><strong>Bucket Management</strong></h5>&#13;
<p class="noindent">Generally, the reason you reach for an <code>unordered_set</code> is its high performance. Unfortunately, this performance comes at a cost: <code>unordered_set</code> objects have a somewhat complicated interior structure. You have various knobs and dials you can use to inspect and modify this internal structure at runtime.</p>&#13;
<p class="indent">The first control measure you have is to customize the bucket count of the <code>unordered_set</code> (that is, the number of buckets, not the number of elements in a particular bucket). Each <code>unordered_set</code> constructor takes a <code>size_t bucket_count</code> as its first argument, which defaults to some implementation-defined value. <a href="ch13.xhtml#ch13tab11">Table 13-11</a> lists the main <code>unordered_set</code> constructors.</p>&#13;
<p class="tabcap"><a id="ch13tab11"/><strong>Table 13-11:</strong> The <code>unordered_set</code> Constructors</p>&#13;
<table class="topbot-d">&#13;
<colgroup>&#13;
<col style="width:30%"/>&#13;
<col style="width:70%"/>&#13;
</colgroup>&#13;
<tbody>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-h"><p class="tab_th"><strong>Operation</strong></p></td>&#13;
<td style="vertical-align: top;" class="table-h"><p class="tab_th"><strong>Notes</strong></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><code>unordered_set&lt;</code><span class="codestrong">T</span><code>&gt;(</code><code>[</code><span class="codestrong">bck</span><code>], [</code><span class="codestrong">hsh</span><code>], [</code><span class="codestrong">keq</span><code>], [</code><span class="codestrong">alc</span><code>])</code></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">Bucket size <span class="codestrong">bck</span> has an implementation-defined default value. Uses <span class="codestrong">hsh</span><code>=std::hash&lt;</code><span class="codestrong">T</span><code>&gt;</code>, <span class="codestrong">keq</span><code>=std::equal_to&lt;</code><span class="codestrong">T</span><code>&gt;</code>, and <span class="codestrong">alc</span><code>=std::allocator&lt;</code><span class="codestrong">T</span><code>&gt;</code> by default.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><span epub:type="pagebreak" id="page_445"/><code>unordered_set&lt;</code><span class="codestrong">T</span><code>&gt;(</code><span class="codestrong">...</span><code>,</code> <code>[</code><span class="codestrong">bck</span><code>], [</code><span class="codestrong">hsh</span><code>], [</code><span class="codestrong">keq</span><code>], [</code><span class="codestrong">alc</span><code>])</code></p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba">Performs braced initialization of a newly constructed unordered set.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><code>unordered_set&lt;</code><span class="codestrong">T</span><code>&gt;(</code><span class="codestrong">beg</span><code>,</code> <span class="codestrong">end</span> <code>[</code><span class="codestrong">bck</span><code>],</code> <code>[</code><span class="codestrong">hsh</span><code>], [</code><span class="codestrong">keq</span><code>], [</code><span class="codestrong">alc</span><code>])</code></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">Constructs an unordered set with the elements on the half-open range from <span class="codestrong">beg</span> to <span class="codestrong">end</span>.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><code>unordered_set&lt;</code><span class="codestrong">T</span><code>&gt;(</code><span class="codestrong">s</span><code>)</code></p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba">Deep copy of <span class="codestrong">s</span>; allocates new memory.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-ba"><p class="taba"><code>unordered_set&lt;</code><span class="codestrong">T</span><code>&gt;(move(</code><span class="codestrong">s</span><code>))</code></p></td>&#13;
<td style="vertical-align: top;" class="table-ba"><p class="taba">Takes ownership of memory; elements in <span class="codestrong">s</span>. No allocations.</p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<p class="indent">You can inspect the number of buckets in an <code>unordered_set</code> using the <code>bucket_count</code> method. You can also obtain the maximum bucket count using the <code>max_bucket_count</code> method.</p>&#13;
<p class="indent">An important concept in the runtime performance of <code>unordered_set</code> is its <em>load factor</em>, the average number of elements per bucket. You can obtain the load factor of an <code>unordered_set</code> using the <code>load_factor</code> method, which is equivalent to <code>size()</code> divided by <code>bucket_count()</code>. Each <code>unordered_set</code> has a maximum load factor, which triggers an increase in the bucket count and a potentially expensive rehashing of all the contained elements. A <em>rehashing</em> is an operation where elements get reorganized into new buckets. This requires that you generate new hashes for each element, which can be a relatively computationally expensive operation.</p>&#13;
<p class="indent">You can obtain the maximum load factor using the <code>max_load_factor</code>, which is overloaded, so you can set a new maximum load factor (it defaults to 1.0).</p>&#13;
<p class="indent">To avoid expensive rehashing at inopportune times, you can manually trigger a rehashing using the <code>rehash</code> method, which accepts a <code>size_t</code> argument for the desired bucket count. You can also use the <code>reserve</code> method, which instead accepts a <code>size_t</code> argument for the desired <em>element</em> count.</p>&#13;
<p class="indent"><a href="ch13.xhtml#ch13ex31">Listing 13-31</a> illustrates some of these basic bucket management operations.</p>&#13;
<pre>#include &lt;unordered_set&gt;&#13;
TEST_CASE("std::unordered_set") {&#13;
  std::unordered_set&lt;unsigned long&gt; sheep(100); <span class="ent">➊</span>&#13;
  SECTION("allows bucket count specification on construction") {&#13;
    REQUIRE(sheep.bucket_count() &gt;= 100); <span class="ent">➋</span>&#13;
    REQUIRE(sheep.bucket_count() &lt;= sheep.max_bucket_count()); <span class="ent">➌</span>&#13;
    REQUIRE(sheep.max_load_factor() == Approx(1.0)); <span class="ent">➍</span>&#13;
  }&#13;
  SECTION("allows us to reserve space for elements") {&#13;
    sheep.reserve(100'000); <span class="ent">➎</span>&#13;
    sheep.insert(0);&#13;
    REQUIRE(sheep.load_factor() &lt;= 0.00001); <span class="ent">➏</span>&#13;
    while(sheep.size() &lt; 100'000)&#13;
      sheep.insert(sheep.size()); <span class="ent">➐</span>&#13;
    REQUIRE(sheep.load_factor() &lt;= 1.0); <span class="ent">➑</span>&#13;
  }&#13;
}</pre>&#13;
<p class="listing"><a id="ch13ex31"/><em>Listing 13-31: The <code>unordered_set</code> bucket management</em></p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_446"/>You construct an <code>unordered_set</code> and specify a bucket count of 100 <span class="ent">➊</span>. This results in a <code>bucket_count</code> of at least 100 <span class="ent">➋</span>, which must be less than or equal to the <code>max_bucket_count</code> <span class="ent">➌</span>. By default, the <code>max_load_factor</code> is 1.0 <span class="ent">➍</span>.</p>&#13;
<p class="indent">In the next test, you invoke <code>reserve</code> with enough space for a hundred thousand elements <span class="ent">➎</span>. After inserting an element, the <code>load_factor</code> should be less than or equal to one one-hundred-thousandth (0.00001) <span class="ent">➏</span> because you’ve reserved enough space for a hundred thousand elements. As long as you stay below this threshold, you won’t need a rehashing. After inserting a hundred thousand elements <span class="ent">➐</span>, the <code>load_factor</code> should still be less than or equal to 1 <span class="ent">➑</span>. This demonstrates that you needed no rehashing, thanks to <code>reserve</code>.</p>&#13;
<h5 class="h5" id="ch13lev3sec25"><strong>Unordered Multisets</strong></h5>&#13;
<p class="noindent">The <code>std::unordered_multiset</code> available in the STL’s <code>&lt;unordered_set&gt;</code> header is an associative container that contains unsorted, <em>non-unique</em> keys. An <code>unordered_multiset</code> supports all the same constructors and operations as an <code>unordered_set</code>, but it will store redundant elements. This relationship is analogous to <code>unordered_set</code>s and <code>set</code>s: both <code>equal_range</code> and <code>count</code> have slightly different behavior to account for the non-uniqueness of keys.</p>&#13;
<div class="note">&#13;
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>&#13;
<p class="notep"><em>Boost also provides a <code>boost::unordered_multiset</code> in the <code>&lt;boost/unordered_set.hpp&gt;</code> header.</em></p>&#13;
</div>&#13;
<h4 class="h4" id="ch13lev2sec6"><strong><em>Maps</em></strong></h4>&#13;
<p class="noindent">The <code>std::map</code> available in the STL’s <code>&lt;map&gt;</code> header is an associative container that contains key-value pairs. The keys of a <code>map</code> are sorted and unique, and <code>map</code> supports all the same operations as <code>set</code>. In fact, you can think of a <code>set</code> as a special kind of <code>map</code> containing keys and empty values. Accordingly, <code>map</code> supports efficient insertion, removal, and search, and you have control over sorting with comparator objects.</p>&#13;
<p class="indent">The major advantage of working with a map instead of a set of pairs is that <code>map</code> works as an <em>associative array</em>. An associative array takes a key rather than an integer-valued index. Think of how you use the <code>at</code> and <code>operator[]</code> methods to access indices in sequential containers. Because sequential containers have a natural ordering of elements, you use an integer to refer to them. The associative array allows you to use types other than integers to refer to elements. For example, you could use a string or a <code>float</code> as a key.</p>&#13;
<p class="indent">To enable associative array operations, <code>map</code> supports a number of useful operations; for example, allowing you to insert, modify, and retrieve values by their associated keys.</p>&#13;
<h5 class="h5" id="ch13lev3sec26"><strong>Constructing</strong></h5>&#13;
<p class="noindent">The class template <code>map&lt;Key, Value, Comparator, Allocator&gt;</code> takes four template parameters. The first is the key type <code>Key</code>. The second is the value type <code>Value</code>. The third is the comparator type, which defaults to <code>std::less</code>. The fourth parameter is the allocator type, which defaults to <code>std::allocator&lt;T&gt;</code>.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_447"/>The map constructors are direct analogues to the constructors of <code>set</code>: a default constructor that initializes an empty <code>map</code>; move and copy constructors with the usual behavior; a range constructor that copies the elements from the range into the map; and a braced initializer. The main difference is in the braced initializer, because you need to initialize key-value pairs instead of just keys. To achieve this nested initialization, you use nested initializer lists, as <a href="ch13.xhtml#ch13ex32">Listing 13-32</a> illustrates.</p>&#13;
<pre>#include &lt;map&gt;&#13;
&#13;
auto colour_of_magic = "Colour of Magic";&#13;
auto the_light_fantastic = "The Light Fantastic";&#13;
auto equal_rites = "Equal Rites";&#13;
auto mort = "Mort";&#13;
&#13;
TEST_CASE("std::map supports") {&#13;
  SECTION("default construction") {&#13;
    std::map&lt;const char*, int&gt; emp; <span class="ent">➊</span>&#13;
    REQUIRE(emp.empty()); <span class="ent">➋</span>&#13;
  }&#13;
  SECTION("braced initialization") {&#13;
    std::map&lt;const char*, int&gt; pub_year { <span class="ent">➌</span>&#13;
      { colour_of_magic, 1983 }, <span class="ent">➍</span>&#13;
      { the_light_fantastic, 1986 },&#13;
      { equal_rites, 1987 },&#13;
      { mort, 1987 },&#13;
    };&#13;
    REQUIRE(pub_year.size() == 4); <span class="ent">➎</span>&#13;
  }&#13;
}</pre>&#13;
<p class="listing"><a id="ch13ex32"/><em>Listing 13-32: A <code>std::map</code> supports default construction and braced initialization.</em></p>&#13;
<p class="indent">Here, you default construct a <code>map</code> with keys of type <code>const char*</code> and values of type <code>int</code> <span class="ent">➊</span>. This results in an empty <code>map</code> <span class="ent">➋</span>. In the second test, you again have a <code>map</code> with keys of type <code>const char*</code> and values of type <code>int</code> <span class="ent">➌</span>, but this time you use braced initialization <span class="ent">➍</span> to pack four elements into the <code>map</code> <span class="ent">➎</span>.</p>&#13;
<h5 class="h5" id="ch13lev3sec27"><strong>Move and Copy Semantics</strong></h5>&#13;
<p class="noindent">The move and copy semantics of <code>map</code> are identical to those of <code>set</code>.</p>&#13;
<h5 class="h5" id="ch13lev3sec28"><strong>Storage Model</strong></h5>&#13;
<p class="noindent">Both <code>map</code> and <code>set</code> use the same red-black tree internal structure.</p>&#13;
<h5 class="h5" id="ch13lev3sec29"><strong>Element Access</strong></h5>&#13;
<p class="noindent">The major advantage to using a <code>map</code> instead of a <code>set</code> of <code>pair</code> objects is that <code>map</code> offers two associative array operations: <code>operator[]</code> and <code>at</code>. Unlike the sequential containers supporting these operations, like <code>vector</code> and <code>array</code>, which take a <code>size_t</code> index argument, <code>map</code> takes a <code>Key</code> argument and returns <span epub:type="pagebreak" id="page_448"/>a reference to the corresponding value. As with sequential containers, <code>at</code> will throw a <code>std::out_of_range</code> exception if the given <code>key</code> doesn’t exist in the <code>map</code>. Unlike with sequential containers, <code>operator[]</code> won’t cause undefined behavior if the <code>key</code> doesn’t exist; instead, it will (silently) default construct a <code>Value</code> and insert the corresponding key-value pair into the map, even if you only intended to perform a read, as <a href="ch13.xhtml#ch13ex33">Listing 13-33</a> illustrates.</p>&#13;
<pre>TEST_CASE("std::map is an associative array with") {&#13;
  std::map&lt;const char*, int&gt; pub_year { <span class="ent">➊</span>&#13;
    { colour_of_magic, 1983 },&#13;
    { the_light_fantastic, 1986 },&#13;
  };&#13;
  SECTION("operator[]") {&#13;
    REQUIRE(pub_year[colour_of_magic] == 1983); <span class="ent">➋</span>&#13;
&#13;
    pub_year[equal_rites] = 1987; <span class="ent">➌</span>&#13;
    REQUIRE(pub_year[equal_rites] == 1987); <span class="ent">➍</span>&#13;
&#13;
    REQUIRE(pub_year[mort] == 0); <span class="ent">➎</span>&#13;
  }&#13;
  SECTION("an at method") {&#13;
    REQUIRE(pub_year.at(colour_of_magic) == 1983); <span class="ent">➏</span>&#13;
&#13;
    REQUIRE_THROWS_AS(pub_year.at(equal_rites), std::out_of_range); <span class="ent">➐</span>&#13;
  }&#13;
}</pre>&#13;
<p class="listing"><a id="ch13ex33"/><em>Listing 13-33: A <code>std::map</code> is an associative array with several access methods.</em></p>&#13;
<p class="indent">You construct a <code>map</code> called <code>pub_year</code> containing two elements <span class="ent">➊</span>. Next, you use <code>operator[]</code> to extract the value corresponding to the key <code>colour_of_magic</code> <span class="ent">➋</span>. You also use <code>operator[]</code> to insert the new key-value pair <code>equal_rites</code>, <code>1987</code> <span class="ent">➌</span> and then retrieve it <span class="ent">➍</span>. Notice that when you attempt to retrieve an element with the key <code>mort</code> (which doesn’t exist), the map has silently default-initialized an <code>int</code> for you <span class="ent">➎</span>.</p>&#13;
<p class="indent">Using <code>at</code>, you can still set and retrieve <span class="ent">➏</span> elements, but if you attempt to access a key that doesn’t exist, you get a <code>std::out_of_range</code> exception <span class="ent">➐</span>.</p>&#13;
<p class="indent">A <code>map</code> supports all the <code>set</code>-like, element-retrieval operations. For example, <code>map</code> supports <code>find</code>, which accepts a <code>key</code> argument and returns an iterator pointing to the key-value <code>pair</code> or, if no matching key is found, to the end of <code>map</code>. Also similarly supported are <code>count</code>, <code>equal_range</code>, <code>lower_bound</code>, and <code>upper_bound</code>.</p>&#13;
<h5 class="h5" id="ch13lev3sec30"><strong>Adding Elements</strong></h5>&#13;
<p class="noindent">In addition to the element access methods <code>operator[]</code> and <code>at</code>, you also have all the <code>insert</code> and <code>emplace</code> methods available from <code>set</code>. You simply need to treat each key-value pair as a <code>std::pair&lt;Key, Value&gt;</code>. As with <code>set</code>, <code>insert</code> returns a pair containing an iterator and a <code>bool</code>. The iterator points to the inserted element, and the <code>bool</code> answers whether <code>insert</code> added a new element (<code>true</code>) or not (<code>false</code>), as <a href="ch13.xhtml#ch13ex34">Listing 13-34</a> illustrates.</p>&#13;
<pre><span epub:type="pagebreak" id="page_449"/>TEST_CASE("std::map supports insert") {&#13;
  std::map&lt;const char*, int&gt; pub_year; <span class="ent">➊</span>&#13;
  pub_year.insert({ colour_of_magic, 1983 }); <span class="ent">➋</span>&#13;
  REQUIRE(pub_year.size() == 1); <span class="ent">➌</span>&#13;
&#13;
  std::pair&lt;const char*, int&gt; tlfp{ the_light_fantastic, 1986 }; <span class="ent">➍</span>&#13;
  pub_year.insert(tlfp); <span class="ent">➎</span>&#13;
  REQUIRE(pub_year.size() == 2); <span class="ent">➏</span>&#13;
&#13;
  auto [itr, is_new] = pub_year.insert({ the_light_fantastic, 9999 }); <span class="ent">➐</span>&#13;
  REQUIRE(itr-&gt;first == the_light_fantastic);&#13;
  REQUIRE(itr-&gt;second == 1986); <span class="ent">➑</span>&#13;
  REQUIRE_FALSE(is_new); <span class="ent">➒</span>&#13;
  REQUIRE(pub_year.size() == 2); <span class="ent">➓</span>&#13;
}</pre>&#13;
<p class="listing"><a id="ch13ex34"/><em>Listing 13-34: A <code>std::map</code> supports <code>insert</code> to add new elements.</em></p>&#13;
<p class="indent">You default construct a <code>map</code> <span class="ent">➊</span> and use the <code>insert</code> method with a braced initializer for a <code>pair</code> <span class="ent">➋</span>. This construction is roughly equivalent to the following:</p>&#13;
<pre>pub_year.insert(std::pair&lt;const char*, int&gt;{ colour_of_magic, 1983 });</pre>&#13;
<p class="indent">After insertion, the <code>map</code> now contains one element <span class="ent">➌</span>. Next, you create a stand-alone <code>pair</code> <span class="ent">➍</span> and then pass it as an argument to <code>insert</code> <span class="ent">➎</span>. This inserts a copy into the <code>map</code>, so it now contains two elements <span class="ent">➏</span>.</p>&#13;
<p class="indent">When you attempt to invoke <code>insert</code> with a new element with the same <code>the_light_fantastic</code> key <span class="ent">➐</span>, you get an iterator pointing to the element you already inserted <span class="ent">➎</span>. The key (<code>first</code>) and the value (<code>second</code>) match <span class="ent">➑</span>. The return value <code>is_new</code> indicates that no new element was inserted <span class="ent">➒</span>, and you still have two elements <span class="ent">➓</span>. This behavior mirrors the <code>insert</code> behavior of <code>set</code>.</p>&#13;
<p class="indent">A <code>map</code> also offers an <code>insert_or_assign</code> method, which, unlike <code>insert</code>, will overwrite an existing value. Also unlike <code>insert</code>, <code>insert_or_assign</code> accepts separate key and value arguments, as <a href="ch13.xhtml#ch13ex35">Listing 13-35</a> illustrates.</p>&#13;
<pre>TEST_CASE("std::map supports insert_or_assign") {&#13;
  std::map&lt;const char*, int&gt; pub_year{ <span class="ent">➊</span>&#13;
    { the_light_fantastic, 9999 }&#13;
  };&#13;
  auto [itr, is_new] = pub_year.insert_or_assign(the_light_fantastic, 1986); <span class="ent">➋</span>&#13;
  REQUIRE(itr-&gt;second == 1986); <span class="ent">➌</span>&#13;
  REQUIRE_FALSE(is_new); <span class="ent">➍</span>&#13;
}</pre>&#13;
<p class="listing"><a id="ch13ex35"/><em>Listing 13-35: A <code>std::map</code> supports <code>insert_or_assign</code> to overwrite existing elements.</em></p>&#13;
<p class="indent">You construct a <code>map</code> with a single element <span class="ent">➊</span> and then call <code>insert_or _assign</code> to reassign the value associated with the key <code>the_light_fantastic</code> to 1986 <span class="ent">➋</span>. The iterator points to the existing element, and when you query the corresponding value with <code>second</code>, you see the value updated to 1986 <span class="ent">➌</span>. The <code>is_new</code> return value also indicates that you’ve updated an existing element rather than inserting a new one <span class="ent">➍</span>.</p>&#13;
<h5 class="h5" id="ch13lev3sec31"><span epub:type="pagebreak" id="page_450"/><strong>Removing Elements</strong></h5>&#13;
<p class="noindent">Like <code>set</code>, <code>map</code> supports <code>erase</code> and <code>clear</code> to remove elements, as shown in <a href="ch13.xhtml#ch13ex36">Listing 13-36</a>.</p>&#13;
<pre>TEST_CASE("We can remove std::map elements using") {&#13;
    std::map&lt;const char*, int&gt; pub_year {&#13;
      { colour_of_magic, 1983 },&#13;
      { mort, 1987 },&#13;
    }; <span class="ent">➊</span>&#13;
  SECTION("erase") {&#13;
    pub_year.erase(mort); <span class="ent">➋</span>&#13;
    REQUIRE(pub_year.find(mort) == pub_year.end()); <span class="ent">➌</span>&#13;
  }&#13;
  SECTION("clear") {&#13;
    pub_year.clear(); <span class="ent">➍</span>&#13;
    REQUIRE(pub_year.empty()); <span class="ent">➎</span>&#13;
  }&#13;
}</pre>&#13;
<p class="listing"><a id="ch13ex36"/><em>Listing 13-36: A <code>std::map</code> supports element removal.</em></p>&#13;
<p class="indent">You construct a <code>map</code> with two elements <span class="ent">➊</span>. In the first test, you invoke <code>erase</code> on the element with key <code>mort</code> <span class="ent">➋</span>, so when you try to <code>find</code> it, you get back <code>end</code> <span class="ent">➌</span>. In the second test, you clear <code>map</code> <span class="ent">➍</span>, which causes <code>empty</code> to return <code>true</code> <span class="ent">➎</span>.</p>&#13;
<h5 class="h5" id="ch13lev3sec32"><strong>List of Supported Operations</strong></h5>&#13;
<p class="noindent"><a href="ch13.xhtml#ch13tab12">Table 13-12</a> summarizes the supported operations of <code>map</code>. A key <code>k</code> has type <code>K</code>. A value <code>v</code> has type <code>V</code>. <code>P</code> is the type <code>pair&lt;K, V&gt;</code>, and <code>p</code> is of type <code>P</code>. The map <code>m</code> is <code>map&lt;K, V&gt;</code>. A dagger () denotes a method that returns a <code>std::pair&lt;Iterator, bool&gt;</code>, where the iterator points to the resulting element and the <code>bool</code> equals <code>true</code> if the method inserted an element and <code>false</code> if the element already existed.</p>&#13;
<p class="tabcap"><a id="ch13tab12"/><strong>Table 13-12:</strong> A Partial List of Supported <code>map</code> Operations</p>&#13;
<table class="topbot-d">&#13;
<colgroup>&#13;
<col style="width:30%"/>&#13;
<col style="width:70%"/>&#13;
</colgroup>&#13;
<tbody>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-h"><p class="tab_th"><strong>Operation</strong></p></td>&#13;
<td style="vertical-align: top;" class="table-h"><p class="tab_th"><strong>Notes</strong></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><code>map&lt;</code><span class="codestrong">T</span><code>&gt;{</code> <span class="codestrong">...</span><code>, [</code><span class="codestrong">cmp</span><code>], [</code><span class="codestrong">alc</span><code>] }</code></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">Performs braced initialization of a newly constructed map. Uses <span class="codestrong">cmp</span><code>=std::less&lt;</code><span class="codestrong">T</span><code>&gt;</code> and <span class="codestrong">alc</span><code>=std::allocator&lt;</code><span class="codestrong">T</span><code>&gt;</code> by default.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><code>map&lt;</code><span class="codestrong">T</span><code>&gt;{</code>  <span class="codestrong">beg</span><code>,</code> <span class="codestrong">end</span><code>, [</code><span class="codestrong">cmp</span><code>], [</code><span class="codestrong">alc</span><code>] }</code></p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba">Range constructor that copies elements from the half-open range <span class="codestrong">beg</span> to <span class="codestrong">end</span>. Uses <span class="codestrong">cmp</span><code>=std::less&lt;</code><span class="codestrong">T</span><code>&gt;</code> and <span class="codestrong">alc</span><code>=std::allocator&lt;</code><span class="codestrong">T</span><code>&gt;</code> by default.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><code>map&lt;</code><span class="codestrong">T</span><code>&gt;(</code><span class="codestrong">m</span><code>)</code></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">Deep copy of <span class="codestrong">m</span>; allocates new memory.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><span class="codestrong">map</span><code>&lt;</code><span class="codestrong">T</span><code>&gt;(move(</code><span class="codestrong">m</span><code>))</code></p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba">Takes ownership of memory; elements in <span class="codestrong">m</span>. No allocations.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><code>~map</code></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">Destructs all elements contained by the map and releases dynamic memory.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><span class="codestrong">m1</span> <code>=</code> <span class="codestrong">m2</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><span class="codestrong">m1</span> destructs its elements; copies each <span class="codestrong">m2</span> element. Only allocates if it needs to resize to fit <span class="codestrong">m2</span>’s elements.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><span epub:type="pagebreak" id="page_451"/><span class="codestrong">m1</span>  <code>= move(</code><span class="codestrong">m2</span><code>)</code></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><span class="codestrong">m1</span> destructs its elements; moves each <span class="codestrong">m2</span> element. Only allocates if it needs to resize to fit <span class="codestrong">m2</span>’s elements.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><span class="codestrong">m</span><code>.at(</code><span class="codestrong">k</span><code>)</code></p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba">Accesses the value corresponding to the key <span class="codestrong">k</span>. Throws <code>std::out_of_bounds</code> if key not found.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><span class="codestrong">m</span><code>[</code><span class="codestrong">k</span><code>]</code></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">Accesses the value corresponding to the key <span class="codestrong">k</span>. If the key is not found, inserts a new key-value pair using <span class="codestrong">k</span> and a default initialized value.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><span class="codestrong">m</span><code>.begin()</code></p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba">Returns an iterator pointing to the first element.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><span class="codestrong">m</span><code>.cbegin()</code></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">Returns a <code>const</code> iterator pointing to the first element.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><span class="codestrong">m</span><code>.end()</code></p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba">Returns an iterator pointing to 1 past the last element.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><span class="codestrong">m</span><code>.cend()</code></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">Returns a <code>const</code> iterator pointing to 1 past the last element.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><span class="codestrong">m</span><code>.find(</code><span class="codestrong">k</span><code>)</code></p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba">Returns an iterator pointing to the element matching <span class="codestrong">k</span>, or <span class="codestrong">m</span><code>.end()</code> if no such element exists.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><span class="codestrong">m</span><code>.count(</code><span class="codestrong">k</span><code>)</code></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">Returns 1 if the map contains <span class="codestrong">k</span>; otherwise 0.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><span class="codestrong">m</span><code>.equal_range(</code><span class="codestrong">k</span><code>)</code></p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba">Returns a <code>pair</code> of iterators corresponding to the half-open range of elements matching <span class="codestrong">k</span>.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><span class="codestrong">m</span><code>.lower_bound(</code><span class="codestrong">k</span><code>)</code></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">Returns an iterator pointing to the first element not less than <span class="codestrong">k</span>, or <span class="codestrong">t</span>.<code>end()</code> if no such element exists.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><span class="codestrong">m</span><code>.upper_bound(</code><span class="codestrong">k</span><code>)</code></p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba">Returns an iterator pointing to the first element greater than <span class="codestrong">k</span>, or <span class="codestrong">t</span><code>.end()</code> if no such element exists.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><span class="codestrong">m</span><code>.clear()</code></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">Removes all elements from the map.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><span class="codestrong">m</span><code>.erase(</code><span class="codestrong">k</span><code>)</code></p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba">Removes the element with key <span class="codestrong">k</span>.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><span class="codestrong">m</span><code>.erase(</code><span class="codestrong">itr</span><code>)</code></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">Removes the element pointed to by <span class="codestrong">itr</span>.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><span class="codestrong">m</span><code>.erase(</code><span class="codestrong">beg</span><code>,</code> <span class="codestrong">end</span><code>)</code></p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba">Removes all elements on the half-open range from <span class="codestrong">beg</span> to <span class="codestrong">end</span>.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><span class="codestrong">m</span><code>.insert(</code><span class="codestrong">p</span><code>)</code></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">Inserts a copy of the pair <span class="codestrong">p</span> into the map.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><span class="codestrong">m</span><code>.insert_or_assign(</code><span class="codestrong">k</span><code>,</code> <span class="codestrong">v</span><code>)</code></p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba">If <span class="codestrong">k</span> exists, overwrites the corresponding value with <span class="codestrong">v</span>. If <span class="codestrong">k</span> doesn’t exist, inserts the pair <span class="codestrong">k</span>, <span class="codestrong">v</span> into the map.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><span class="codestrong">m</span><code>.emplace(</code><span class="codestrong">...</span><code>)</code></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">Constructs a <span class="codestrong">P</span> in place by forwarding the arguments <span class="codestrong">...</span>.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><span class="codestrong">m</span><code>.emplace_hint(</code><span class="codestrong">k</span><code>,  ...)</code></p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba">Constructs a <span class="codestrong">P</span> in place by forwarding the arguments<code>...</code>. Uses <span class="codestrong">itr</span> as a hint for where to insert the new element.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><span class="codestrong">m</span><code>.try_emplace(</code><span class="codestrong">itr</span><code>,</code> <span class="codestrong">...</span><code>)</code></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">If key <span class="codestrong">k</span> exists, does nothing. If <span class="codestrong">k</span> doesn’t exist, constructs a <span class="codestrong">V</span> in place by forwarding the arguments <span class="codestrong">...</span>.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><span class="codestrong">m</span><code>.empty()</code></p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba">Returns <code>true</code> if map’s size is zero; otherwise <code>false</code>.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><span class="codestrong">m</span><code>.size()</code></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">Returns the number of elements in the map.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><span class="codestrong">m</span><code>.max_size()</code></p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba">Returns the maximum number of elements in the map.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><span epub:type="pagebreak" id="page_452"/><span class="codestrong">m</span><code>.extract(</code><span class="codestrong">k</span><code>)</code></p>&#13;
<p class="taba"><span class="codestrong">m</span><code>.extract(</code><span class="codestrong">itr</span><code>)</code></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">Obtains a node handle that owns the element matching <span class="codestrong">k</span> or pointed to by <span class="codestrong">itr</span>. (This is the only way to remove a move-only element.)</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><span class="codestrong">m1</span><code>.merge(</code><span class="codestrong">m2</span><code>)</code></p>&#13;
<p class="taba"><span class="codestrong">m1</span><code>.merge(move(</code><span class="codestrong">m2</span><code>))</code></p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba">Splices each element of <span class="codestrong">m2</span> into <span class="codestrong">m1</span>. If argument is an rvalue, will move the elements into <span class="codestrong">m1</span>.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-ba"><p class="taba"><span class="codestrong">m1</span><code>.swap(</code><span class="codestrong">m2</span><code>)</code></p>&#13;
<p class="taba"><code>swap(</code><span class="codestrong">m1</span><code>,</code> <span class="codestrong">m2</span><code>)</code></p></td>&#13;
<td style="vertical-align: top;" class="table-ba"><p class="taba">Exchanges each element of <span class="codestrong">m1</span> with those of <span class="codestrong">m2</span>.</p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<h3 class="h3" id="ch13lev1sec9"><strong>Multimaps</strong></h3>&#13;
<p class="noindent">The <code>std::multimap</code> available in the STL’s <code>&lt;map&gt;</code> header is an associative container that contains key-value pairs with <em>non-unique</em> keys. Because the keys are not unique, <code>multimap</code> doesn’t support the associative array features that <code>map</code> does. Namely, <code>operator[]</code> and <code>at</code> aren’t supported. As with <code>multiset</code>, <code>multimap</code> offers element access primarily through the <code>equal_range</code> method, as <a href="ch13.xhtml#ch13ex37">Listing 13-37</a> illustrates.</p>&#13;
<pre>TEST_CASE("std::multimap supports non-unique keys") {&#13;
  std::array&lt;char, 64&gt; far_out {&#13;
    "Far out in the uncharted backwaters of the unfashionable end..."&#13;
  }; <span class="ent">➊</span>&#13;
  std::multimap&lt;char, size_t&gt; indices; <span class="ent">➋</span>&#13;
  for(size_t index{}; index&lt;far_out.size(); index++)&#13;
    indices.emplace(far_out[index], index); <span class="ent">➌</span>&#13;
&#13;
  REQUIRE(indices.count('a') == 6); <span class="ent">➍</span>&#13;
&#13;
  auto [itr, end] = indices.equal_range('d'); <span class="ent">➎</span>&#13;
  REQUIRE(itr-&gt;second == 23); <span class="ent">➏</span>&#13;
  itr++;&#13;
  REQUIRE(itr-&gt;second == 59); <span class="ent">➐</span>&#13;
  itr++;&#13;
  REQUIRE(itr == end);&#13;
}</pre>&#13;
<p class="listing"><a id="ch13ex37"/><em>Listing 13-37: A <code>std::multimap</code> supports non-unique keys.</em></p>&#13;
<p class="indent">You construct an <code>array</code> containing a message <span class="ent">➊</span>. You also default construct a <code>multimap&lt;char, size_t&gt;</code> called <code>indices</code> that you’ll use to store the index of every character in the message <span class="ent">➋</span>. By looping through the array, you can store each character in the message along with its index as a new element in <code>multimap</code> <span class="ent">➌</span>. Because you’re allowed to have non-unique keys, you can use the <code>count</code> method to reveal how many indices you insert with the key <code>a</code> <span class="ent">➍</span>. You can also use the <code>equal_range</code> method to obtain the half-open range of indices with the key <code>d</code> <span class="ent">➎</span>. Using the resulting <code>begin</code> and <code>end</code> iterators, you can see that the message has the letter <code>d</code> at indices 23 <span class="ent">➏</span> and 59 <span class="ent">➐</span>.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_453"/>Aside from <code>operator[]</code> and <code>at</code>, every operation in <a href="ch13.xhtml#ch13tab12">Table 13-12</a> works for <code>multimap</code> as well. (Note that the <code>count</code> method can take on values other than 0 and 1.)</p>&#13;
<h5 class="h5" id="ch13lev3sec33"><strong>Unordered Maps and Unordered Multimaps</strong></h5>&#13;
<p class="noindent">Unordered maps and unordered multimaps are completely analogous to unordered sets and unordered multisets. The <code>std::unordered_map</code> and <code>std::unordered_multimap</code> are available in the STL’s <code>&lt;unordered_map&gt;</code> header. These associative containers typically use a red-black tree like their <code>set</code> counterparts. They also require a hash function and an equivalence function, and they support the bucket interface.</p>&#13;
<div class="note">&#13;
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>&#13;
<p class="notep"><em>Boost offers the <code>boost::unordered_map</code> and <code>boost::unordered_multimap</code> in the <code>&lt;boost/unordered_map.hpp&gt;</code> header.</em></p>&#13;
</div>&#13;
<h4 class="h4" id="ch13lev2sec7"><strong><em>Niche Associative Containers</em></strong></h4>&#13;
<p class="noindent">Use <code>set</code>, <code>map</code>, and their associated non-unique and unordered counterparts as the default choices when you need associative data structures. When special needs arise, Boost libraries offer a number of specialized associative containers, as highlighted in <a href="ch13.xhtml#ch13tab13">Table 13-13</a>.</p>&#13;
<p class="tabcap"><a id="ch13tab13"/><strong>Table 13-13:</strong> Special Boost Containers</p>&#13;
<table class="topbot-d">&#13;
<colgroup>&#13;
<col style="width:30%"/>&#13;
<col style="width:70%"/>&#13;
</colgroup>&#13;
<tbody>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-h"><p class="tab_th"><strong>Class/Header</strong></p></td>&#13;
<td style="vertical-align: top;" class="table-h"><p class="tab_th"><strong>Description</strong></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><code>boost::container::flat_map</code></p>&#13;
<p class="taba"><code>&lt;boost/container/flat_map.hpp&gt;</code></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">Similar to an STL <code>map</code>, but it’s implemented like an ordered vector. This means fast random element access.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><code>boost::container::flat_set</code></p>&#13;
<p class="taba"><code>&lt;boost/container/flat_set.hpp&gt;</code></p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba">Similar to an STL <code>set</code>, but it’s implemented like an ordered vector. This means fast random element access.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><code>boost::intrusive::*</code></p>&#13;
<p class="taba"><code>&lt;boost/intrusive/*.hpp&gt;</code></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">Intrusive containers impose requirements on the elements they contain (such as inheriting from a particular base class). In exchange, they offer substantial performance gains.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><code>boost::multi_index_container</code></p>&#13;
<p class="taba"><code>&lt;boost/multi_index_container.hpp&gt;</code></p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba">Permits you to create associative arrays taking multiple indices rather than just one (like a map).</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><code>boost::ptr_set</code></p>&#13;
<p class="taba"><code>boost::ptr_unordered_map</code></p>&#13;
<p class="taba"><code>boost::ptr_unordered_set</code></p>&#13;
<p class="taba"><code>&lt;boost/ptr_container/*.hpp&gt;</code></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">Having a collection of smart pointers can be suboptimal. Pointer vectors manage a collection of dynamic objects in a more efficient and user-friendly way.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><code>boost::bimap</code></p>&#13;
<p class="taba"><code>&lt;</code> <code>boost/bimap.hpp&gt;</code></p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba">A bimap is an associative container that allows both types to be used as a key.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-ba"><p class="taba"><code>boost::heap::binomial_heap</code></p>&#13;
<p class="taba"><code>boost::heap::d_ary_heap</code></p>&#13;
<p class="taba"><code>boost::heap::fibonacci_heap</code></p>&#13;
<p class="taba"><code>boost::heap::pairing_heap</code></p>&#13;
<p class="taba"><code>boost::heap::priority_queue</code></p>&#13;
<p class="taba"><code>boost::heap::skew_heap</code></p>&#13;
<p class="taba"><code>&lt;boost/heap/*.hpp&gt;</code></p></td>&#13;
<td style="vertical-align: top;" class="table-ba"><p class="taba">The Boost Heap containers implement more advanced, featureful versions of <code>priority_queue</code>.</p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<h3 class="h3" id="ch13lev1sec10"><span epub:type="pagebreak" id="page_454"/><strong>Graphs and Property Trees</strong></h3>&#13;
<p class="noindent">This section discusses two specialized Boost libraries that serve niche but valuable purposes: modeling graphs and property trees. A <em>graph</em> is a set of objects in which some have a pairwise relation. The objects are called <em>verti</em><em>ces,</em>and their relations are called <em>edges</em>. <a href="ch13.xhtml#ch13fig03">Figure 13-3</a> illustrates a graph containing four vertices and five edges.</p>&#13;
<div class="image"><img src="../images/fig13_3.jpg" alt="image"/></div>&#13;
<p class="figcap" id="ch13fig03"><em>Figure 13-3:A graph containing four vertices and five edges</em></p>&#13;
<p class="indent">Each square represents a vertex, and each arrow represents an edge.</p>&#13;
<p class="indent">A <em>property tree</em> is a tree structure storing nested key-value pairs. The hierarchical nature of a property tree’s key-value pairs makes it a hybrid between a map and a graph; each key-value pair has a relation to other key-value pairs. <a href="ch13.xhtml#ch13fig04">Figure 13-4</a> illustrates an example property tree containing nested key-value pairs.</p>&#13;
<div class="image"><img src="../images/fig13_4.jpg" alt="image"/></div>&#13;
<p class="figcap" id="ch13fig04"><em>Figure 13-4: An example property tree</em></p>&#13;
<p class="indent">The root element has three children: name, year, and features. In <a href="ch13.xhtml#ch13fig04">Figure 13-4</a>, name has a value finfisher, year has a value 2014, and features has three children: process with value LSASS, driver with value mssounddx.sys, and arch with value 32.</p>&#13;
<h3 class="h3" id="ch13lev1sec11"><span epub:type="pagebreak" id="page_455"/><strong>The Boost Graph Library</strong></h3>&#13;
<p class="noindent">The <em>Boost Graph Library</em> (BGL) is a set of collections and algorithms for storing and manipulating graphs. The BGL offers three containers that represent graphs:</p>&#13;
<ul>&#13;
<li class="noindent">The <code>boost::adjacency_list</code> in the <code>&lt;boost/graph/adjacency_list.hpp&gt;</code> header</li>&#13;
<li class="noindent">The <code>boost::adjacency_matrix</code> in the <code>&lt;boost/graph/adjacency_matrix.hpp&gt;</code> header</li>&#13;
<li class="noindent">The <code>boost::edge_list</code> in the <code>&lt;boost/graph/ edge_list.hpp&gt;</code> header</li>&#13;
</ul>&#13;
<p class="indent">You use two non-member functions to build graphs: <code>boost::add_vertex</code> and <code>boost::add_edge</code>. To add a vertex to one of the BGL graph containers, you pass the graph object to <code>add_vertex</code>, which will return reference to the new vertex object. To add an edge, we pass the source vertex, the destination vertex, then the graph to <code>add_edge</code>.</p>&#13;
<p class="indent">BGL contains a number of graph-specific algorithms. You can count the number of vertices in a graph object by passing it to the non-member function <code>boost::num_vertices</code> and the number of edges using <code>boost::num_edges</code>. You can also query a graph for adjacent vertices. Two vertices are <em>adjacent</em> if they share an edge. To get the vertices adjacent to a particular vertex, you can pass it and the graph object to the non-member function <code>boost::adjacent_ vertices</code>. This returns a half-open range as a <code>std::pair</code> of iterators.</p>&#13;
<p class="indent"><a href="ch13.xhtml#ch13ex38">Listing 13-38</a> illustrates how you can build the graph represented in <a href="ch13.xhtml#ch13fig03">Figure 13-3</a>, count its vertices and edges, and compute adjacent vertices.</p>&#13;
<pre>#include &lt;set&gt;&#13;
#include &lt;boost/graph/adjacency_list.hpp&gt;&#13;
&#13;
TEST_CASE("boost::adjacency_list stores graph data") {&#13;
  boost::adjacency_list&lt;&gt; graph{}; <span class="ent">➊</span>&#13;
  auto vertex_1 = boost::add_vertex(graph);&#13;
  auto vertex_2 = boost::add_vertex(graph);&#13;
  auto vertex_3 = boost::add_vertex(graph);&#13;
  auto vertex_4 = boost::add_vertex(graph); <span class="ent">➋</span>&#13;
  auto edge_12 = boost::add_edge(vertex_1, vertex_2, graph);&#13;
  auto edge_13 = boost::add_edge(vertex_1, vertex_3, graph);&#13;
  auto edge_21 = boost::add_edge(vertex_2, vertex_1, graph);&#13;
  auto edge_24 = boost::add_edge(vertex_2, vertex_4, graph);&#13;
  auto edge_43 = boost::add_edge(vertex_4, vertex_3, graph); <span class="ent">➌</span>&#13;
&#13;
  REQUIRE(boost::num_vertices(graph) == 4); <span class="ent">➍</span>&#13;
  REQUIRE(boost::num_edges(graph) == 5); <span class="ent">➎</span>&#13;
&#13;
  auto [begin, end] = boost::adjacent_vertices(vertex_1, graph); <span class="ent">➏</span>&#13;
  std::set&lt;decltype(vertex_1)&gt; neighboors_1 { begin, end }; <span class="ent">➐</span>&#13;
  REQUIRE(neighboors_1.count(vertex_2) == 1); <span class="ent">➑</span>&#13;
  REQUIRE(neighboors_1.count(vertex_3) == 1); <span class="ent">➒</span>&#13;
  REQUIRE(neighboors_1.count(vertex_4) == 0); <span class="ent">➓</span>&#13;
}</pre>&#13;
<p class="listing"><a id="ch13ex38"/><em>Listing 13-38: The <code>boost::adjacency_list</code> stores graph data.</em></p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_456"/>Here, you’ve constructed an <code>adjacency_list</code> called <code>graph</code> <span class="ent">➊</span>, then added four vertices using <code>add_vertex</code> <span class="ent">➋</span>. Next, you add all the edges represented in <a href="ch13.xhtml#ch13fig03">Figure 13-3</a> using <code>add_edge</code> <span class="ent">➌</span>. Then <code>num_vertices</code> shows you that you’ve added four vertices <span class="ent">➍</span>, and <code>num_edges</code> tells you that you’ve added five edges <span class="ent">➎</span>.</p>&#13;
<p class="indent">Finally, you’ve determined the <code>adjacent_vertices</code> to <code>vertex_1</code>, which you unpack into the iterators <code>begin</code> and <code>end</code> <span class="ent">➏</span>. You use these iterators to construct a <code>std::set</code> <span class="ent">➐</span>, which you use to show that <code>vertex_2</code> <span class="ent">➑</span> and <code>vertex_3</code> <span class="ent">➒</span> are adjacent, but <code>vertex_4</code> is not <span class="ent">➓</span>.</p>&#13;
<h3 class="h3" id="ch13lev1sec12"><strong>Boost Property Trees</strong></h3>&#13;
<p class="noindent">Boost offers the <code>boost::property_tree::ptree</code> in the <code>&lt;boost/property_tree/ptree.hpp&gt;</code> header. This is a property tree that permits us to build and query property trees, as well as some limited serialization into various formats.</p>&#13;
<p class="indent">The tree <code>ptree</code> is default constructible. Default constructing will build an empty <code>ptree</code>.</p>&#13;
<p class="indent">You can insert elements into a <code>ptree</code> using its <code>put</code> method, which takes a path and a value argument. A <em>path</em> is a sequence of one or more nested keys separated by a period (<strong>.</strong>), and a <em>value</em> is an arbitrarily typed object.</p>&#13;
<p class="indent">You can get subtrees from a <code>ptree</code> using the <code>get_child</code> method, which takes the path of the desired subtree. If the subtree does not have any children (a so-called <em>leaf node</em>), you can also use the method template <code>get_value</code> to extract the corresponding value from the key-value pair; <code>get_value</code> takes a single template parameter corresponding to the desired output type.</p>&#13;
<p class="indent">Finally, <code>ptree</code> supports serialization and deserialization to several formats including Javascript object notation (JSON), the Windows initialization file (INI) format, the extensible markup language (XML), and a custom, <code>ptree</code>-specific format called INFO. For example, to write a <code>ptree</code> into a file in JSON format, you could use the <code>boost::property_tree::write_json</code> function from the <code>&lt;boost/property_tree/json_parser.hpp&gt;</code> header. The function <code>write_json</code> accepts two arguments: the path to the desired output file and a <code>ptree</code> reference.</p>&#13;
<p class="indent"><a href="ch13.xhtml#ch13ex39">Listing 13-39</a> highlights these basic <code>ptree</code> functions by building a <code>ptree</code> representing the property tree in <a href="ch13.xhtml#ch13fig04">Figure 13-4</a>, writing the <code>ptree</code> to file as JSON, and reading it back.</p>&#13;
<pre>#include &lt;boost/property_tree/ptree.hpp&gt;&#13;
#include &lt;boost/property_tree/json_parser.hpp&gt;&#13;
&#13;
TEST_CASE("boost::property_tree::ptree stores tree data") {&#13;
  using namespace boost::property_tree;&#13;
  ptree p; <span class="ent">➊</span>&#13;
  p.put("name", "finfisher");&#13;
  p.put("year", 2014);&#13;
  p.put("features.process", "LSASS");&#13;
  p.put("features.driver", "mssounddx.sys");&#13;
  p.put("features.arch", 32); <span class="ent">➋</span>&#13;
<span epub:type="pagebreak" id="page_457"/>  REQUIRE(p.get_child("year").get_value&lt;int&gt;() == 2014); <span class="ent">➌</span>&#13;
&#13;
  const auto file_name = "rootkit.json";&#13;
  write_json(file_name, p); <span class="ent">➍</span>&#13;
&#13;
  ptree p_copy;&#13;
  read_json(file_name, p_copy); <span class="ent">➎</span>&#13;
  REQUIRE(p_copy == p); <span class="ent">➏</span>&#13;
}&#13;
--------------------------------------------------------------------------&#13;
<span class="color1">{</span>&#13;
    <span class="color1">"name": "finfisher",</span>&#13;
    <span class="color1">"year": "2014",</span>&#13;
    <span class="color1">"features": {</span>&#13;
        <span class="color1">"process": "LSASS",</span>&#13;
        <span class="color1">"driver": "mssounddx.sys",</span>&#13;
        <span class="color1">"arch": "32"</span>&#13;
    <span class="color1">}</span>&#13;
<span class="color1">}</span> <span class="ent">➍</span></pre>&#13;
<p class="listing"><a id="ch13ex39"/><em>Listing 13-39: The <code>boost::property_tree::ptree</code> method stores tree data. Output shows the contents of <code>rootkit.json</code>.</em></p>&#13;
<p class="indent">Here, you’ve default constructed a <code>ptree</code> <span class="ent">➊</span>, which you populate with the key values shown in <a href="ch13.xhtml#ch13fig04">Figure 13-4</a>. Keys with parents, such as <code>arch</code> <span class="ent">➋</span>, use periods to show the appropriate path. Using <code>get_child</code>, you’ve extracted the subtree for key <code>year</code>. Because it’s a leaf node (having no children), you also invoke <code>get_value</code>, specifying the output type as <code>int</code> <span class="ent">➌</span>.</p>&#13;
<p class="indent">Next, you write the <code>ptree</code>’s JSON representation to the file <code>rootkit.json</code> <span class="ent">➍</span>. To ensure that you get the same property tree back, you default construct another <code>ptree</code> called <code>p_copy</code> and pass it into <code>read_json</code> <span class="ent">➎</span>. This copy is equivalent to the original <span class="ent">➏</span>, illustrating that the serialization-deserialization operation is successful.</p>&#13;
<h3 class="h3" id="ch13lev1sec13"><strong>Initializer Lists</strong></h3>&#13;
<p class="noindent">You can accept initializer lists in your user-defined types by incorporating the <code>std::initializer_list</code> container available in the STL’s <code>&lt;initializer_list&gt;</code> header. The <code>initializer_list</code> is a class template that takes a single template parameter corresponding to the underlying type contained in the initializer list. This template serves as a simple proxy for accessing the elements of an initializer list.</p>&#13;
<p class="indent">The <code>initializer_list</code> is immutable and supports three operations:</p>&#13;
<ul>&#13;
<li class="noindent">The <code>size</code> method returns the number of elements in the <code>initializer_list</code>.</li>&#13;
<li class="noindent">The <code>begin</code> and <code>end</code> methods return the usual half-open-range iterators.</li>&#13;
</ul>&#13;
<p class="indent">Generally, you should design functions to accept an <code>initializer_list</code> by value.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_458"/><a href="ch13.xhtml#ch13ex40">Listing 13-40</a> implements a <code>SquareMatrix</code> class that stores a matrix with equal numbers of rows and columns. Internally, the class will hold elements in a <code>vector</code> of <code>vector</code>s.</p>&#13;
<pre>#include &lt;cmath&gt;&#13;
#include &lt;stdexcept&gt;&#13;
#include &lt;initializer_list&gt;&#13;
#include &lt;vector&gt;&#13;
&#13;
size_t square_root(size_t x) { <span class="ent">➊</span>&#13;
  const auto result = static_cast&lt;size_t&gt;(sqrt(x));&#13;
  if (result * result != x) throw std::logic_error{ "Not a perfect square." };&#13;
  return result;&#13;
}&#13;
&#13;
template &lt;typename T&gt;&#13;
struct SquareMatrix {&#13;
  SquareMatrix(std::initializer_list&lt;T&gt; val) <span class="ent">➋</span>&#13;
    : dim{ square_root(val.size()) }, <span class="ent">➌</span>&#13;
      data(dim, std::vector&lt;T&gt;{}) { <span class="ent">➍</span>&#13;
    auto itr = val.begin(); <span class="ent">➎</span>&#13;
    for(size_t row{}; row&lt;dim; row++){&#13;
      data[row].assign(itr, itr+dim); <span class="ent">➏</span>&#13;
      itr += dim; <span class="ent">➐</span>&#13;
    }&#13;
  }&#13;
  T&amp; at(size_t row, size_t col) {&#13;
    if (row &gt;= dim || col &gt;= dim)&#13;
      throw std::out_of_range{ "Index invalid." }; <span class="ent">➑</span>&#13;
    return data[row][col]; <span class="ent">➒</span>&#13;
  }&#13;
  const size_t dim;&#13;
private:&#13;
  std::vector&lt;std::vector&lt;T&gt;&gt; data;&#13;
};</pre>&#13;
<p class="listing"><a id="ch13ex40"/><em>Listing 13-40: An implementation of a <code>SquareMatrix</code></em></p>&#13;
<p class="indent">Here, you declare a convenience <code>square_root</code> function that finds the square root of a <code>size_t</code>, throwing an exception if the argument isn’t a perfect square <span class="ent">➊</span>. The <code>SquareMatrix</code> class template defines a single constructor that accepts a <code>std::initializer</code> called <code>val</code> <span class="ent">➋</span>. This permits braced initialization.</p>&#13;
<p class="indent">First, you need to determine the dimensions of <code>SquareMatrix</code>. Use the <code>square_root</code> function to compute the square root of <code>val.size()</code> <span class="ent">➌</span> and store this into the <code>dim</code> field, which represents the number of rows and columns of the <code>SquareMatrix</code> instance. You can then use <code>dim</code> to initialize the vector of vectors <code>data</code> using its fill constructor <span class="ent">➍</span>. Each of these <code>vector</code>s will correspond to a row in <code>SquareMatrix</code>. Next, you extract an iterator pointing to the first element in <code>initializer_list</code> <span class="ent">➎</span>. You iterate over each row in <code>SquareMatrix</code>, assigning the corresponding <code>vector</code> to the appropriate half-open range <span class="ent">➏</span>. You increment the iterator on each iteration to point to the next row <span class="ent">➐</span>.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_459"/>Finally, you implement an <code>at</code> method to permit element access. You perform bounds checking <span class="ent">➑</span> and then return a reference to the desired element by extracting the appropriate <code>vector</code> and element <span class="ent">➒</span>.</p>&#13;
<p class="indent"><a href="ch13.xhtml#ch13ex41">Listing 13-41</a> illustrates how to use braced initialization to generate a <code>SquareMatrix</code> object.</p>&#13;
<pre>TEST_CASE("SquareMatrix and std::initializer_list") {&#13;
  SquareMatrix&lt;int&gt; mat { <span class="ent">➊</span>&#13;
     1,  2,  3,  4,&#13;
     5,  0,  7,  8,&#13;
     9, 10, 11, 12,&#13;
    13, 14, 15, 16&#13;
  };&#13;
  REQUIRE(mat.dim == 4); <span class="ent">➋</span>&#13;
  mat.at(1, 1) = 6; <span class="ent">➌</span>&#13;
  REQUIRE(mat.at(1, 1) == 6); <span class="ent">➍</span>&#13;
  REQUIRE(mat.at(0, 2) ==  3); <span class="ent">➎</span>&#13;
}</pre>&#13;
<p class="listing"><a id="ch13ex41"/><em>Listing 13-41: Using braced initializers with a <code>SquareMatrix</code></em></p>&#13;
<p class="indent">You use braced initializers to set up <code>SquareMatrix</code> <span class="ent">➊</span>. Because the initializer list contains 16 elements, you end up with a <code>dim</code> of 4 <span class="ent">➋</span>. You can use <code>at</code> to obtain a reference to any element, meaning you can set <span class="ent">➌</span> and get <span class="ent">➍</span><span class="ent">➎</span> elements.</p>&#13;
<h3 class="h3" id="ch13lev1sec14"><strong>Summary</strong></h3>&#13;
<p class="noindent">This chapter began with a discussion of the two go-to sequence containers, <code>array</code> and <code>vector</code>, which offer you a great balance between performance and features in a wide range of applications. Next, you learned about several sequence containers—<code>deque</code>, <code>list</code>, <code>stack</code>, <code>queue</code>, <code>priority_queue</code>, and <code>bitset</code>—that fill in when <code>vector</code> doesn’t meet the demands of a particular application. Then you explored the major associative containers, <code>set</code> and <code>map</code>, and their unordered/multipermutations. You also learned about two niche Boost containers, <code>graph</code> and <code>ptree</code>. The chapter wrapped up with a brief discussion of incorporating <code>initializer_list</code>s into user-defined types.</p>&#13;
<div class="box5" id="bm01">&#13;
<p class="boxtitle-d"><strong>EXERCISES</strong></p>&#13;
<p class="noindent"><strong>13-1.</strong> Write a program that default constructs a <code>std::vector</code> of unsigned longs. Print the <code>capacity</code> of <code>vector</code> and then <code>reserve</code> 10 elements. Next, append the first 20 elements of the Fibonacci series to the vector. Print <code>capacity</code> again. Does <code>capacity</code> match the number of elements in the vector? Why or why not? Print the elements of <code>vector</code> using a range-based <code>for</code> loop.</p>&#13;
<p class="noindent"><span epub:type="pagebreak" id="page_460"/><strong>13-2.</strong> Rewrite <a href="ch02.xhtml#ch02ex09">Listings 2-9</a>, <a href="ch02.xhtml#ch02ex10">2-10</a>, and <a href="ch02.xhtml#ch02ex11">2-11</a> in <a href="ch02.xhtml#ch02">Chapter 2</a> using <code>std::array</code>.</p>&#13;
<p class="noindent"><strong>13-3.</strong> Write a program that accepts any number of command line arguments and prints them in alphanumerically sorted order. Use a <code>std::set&lt;const char*&gt;</code> to store the elements, then iterate over the <code>set</code> to obtain the sorted result. You’ll need to implement a custom comparator that compares two C-style strings.</p>&#13;
<p class="noindent"><strong>13-4.</strong> Write a program that default constructs a <code>std::vector</code> of unsigned longs. Print the <code>capacity</code> of <code>vector</code> and then <code>reserve</code> 10 elements. Next, append the first 20 elements of the Fibonacci series to the vector. Print <code>capacity</code> again. Does <code>capacity</code> match the number of elements in the vector? Why or why not? Print the elements of <code>vector</code> using a range-based <code>for</code> loop.</p>&#13;
<p class="noindent"><strong>13-5.</strong> Consider the following program that profiles the performance of a function summing a Fibonacci series:</p>&#13;
<pre>#include &lt;chrono&gt;&#13;
#include &lt;cstdio&gt;&#13;
#include &lt;random&gt;&#13;
&#13;
long fib_sum(size_t n) { <span class="ent">➊</span>&#13;
  // TODO: Adapt code from Exercise 12.1&#13;
  return 0;&#13;
}&#13;
&#13;
long random() { <span class="ent">➋</span>&#13;
  static std::mt19937_64 mt_engine{ 102787 };&#13;
  static std::uniform_int_distribution&lt;long&gt; int_d{ 1000, 2000 };&#13;
  return int_d(mt_engine);&#13;
}&#13;
&#13;
struct Stopwatch { <span class="ent">➌</span>&#13;
  Stopwatch(std::chrono::nanoseconds&amp; result)&#13;
    : result{ result },&#13;
    start{ std::chrono::system_clock::now() } { }&#13;
  ~Stopwatch() {&#13;
    result = std::chrono::system_clock::now() - start;&#13;
  }&#13;
private:&#13;
  std::chrono::nanoseconds&amp; result;&#13;
  const std::chrono::time_point&lt;std::chrono::system_clock&gt; start;&#13;
};&#13;
&#13;
long cached_fib_sum(const size_t&amp; n) { <span class="ent">➍</span>&#13;
  static std::map&lt;long, long&gt; cache;&#13;
  // TODO: Implement me&#13;
  return 0;&#13;
}&#13;
&#13;
int main() {&#13;
&#13;
  size_t samples{ 1'000'000 };&#13;
  std::chrono::nanoseconds elapsed;&#13;
<span epub:type="pagebreak" id="page_461"/>&#13;
  {&#13;
    Stopwatch stopwatch{elapsed};&#13;
    volatile double answer;&#13;
    while(samples--) {&#13;
      answer = fib_sum(random()); <span class="ent">➎</span>&#13;
      //answer = cached_fib_sum(random()); <span class="ent">➏</span>&#13;
    }&#13;
  }&#13;
  printf("Elapsed: %g s.\n", elapsed.count() / 1'000'000'000.); <span class="ent">➐</span>&#13;
}</pre>&#13;
<p class="indent">This program contains a computationally intensive function <code>fib_sum</code> <span class="ent">➊</span> that computes the sum of a Fibonacci series with a given length. Adapt your code from Exercise 13-1 by (a) generating the appropriate vector and (b) summing over the result with a range-based <code>for</code> loop. The <code>random</code> function <span class="ent">➋</span> returns a random number between 1,000 and 2,000, and the <code>Stopwatch</code> class <span class="ent">➌</span> adopted from <a href="ch12.xhtml#ch12ex25">Listing 12-25</a> in <a href="ch12.xhtml#ch12">Chapter 12</a> helps you determine elapsed time. In the program’s <code>main</code>, you perform a million evaluations of the <code>fib_sum</code> function using random input <span class="ent">➎</span>. You time how long this takes and print the result before exiting the program <span class="ent">➐</span>. Compile the program and run it a few times to get an idea of how long your program takes to run. (This is called a <em>baseline</em>.)</p>&#13;
<p class="noindent"><strong>13-6.</strong> Next, comment out <span class="ent">➎</span> and uncomment <span class="ent">➏</span>. Implement the function <code>cached_fib_sum</code> <span class="ent">➍</span> so you first check whether you’ve computed <code>fib_sum</code> for the given length yet. (Treat the length <code>n</code> as a key into the cache.) If the key is present in the cache, simply return the result. If the key isn’t present, compute the correct answer with <code>fib_sum</code>, store the new key-value entry into <code>cache</code>, and return the result. Run the program again. Is it faster? Try <code>unordered_map</code> instead of <code>map</code>. Could you use a <code>vector</code> instead? How fast can you get the program to run?</p>&#13;
<p class="noindent">Implement a  Matrix class like  <code>SquareMatrix</code> in <a href="ch13.xhtml#ch13ex38">Listing 13-38</a>. Your  <code>Matrix</code> should allow unequal numbers of rows and columns. Accept as your constructor’s first argument the number of rows in  <code>Matrix</code>.</p>&#13;
</div>&#13;
<div class="box6" id="bm02">&#13;
<p class="boxtitle-d"><strong>FURTHER READING</strong></p>&#13;
<ul>&#13;
<li class="noindent"><em>ISO International Standard ISO/IEC (2017) — Programming Language C++</em> (International Organization for Standardization; Geneva, Switzerland;  <em><a href="https://isocpp.org/std/the-standard/">https://isocpp.org/std/the-standard/</a></em>)</li>&#13;
<li class="noindent"><em>The Boost C++ Libraries</em>, 2nd Edition, by Boris Schäling (XML Press, 2014)</li>&#13;
<li class="noindent"><em>The C++ Standard Library: A Tutorial and Reference</em>, 2nd Edition, by Nicolai M. Josuttis (Addison-Wesley Professional, 2012)</li>&#13;
</ul>&#13;
</div>&#13;
</body></html>