<html><head></head><body>
<h2 class="h2" id="ch13"><span epub:type="pagebreak" id="page_406"/><span epub:type="pagebreak" id="page_407"/><strong><span class="big">13</span><br/>CONTAINERS</strong></h2>&#13;
<p class="quote"><em>Fixing bugs in <span class="literal">std::vector</span> is equal parts delight (it is the bestest data structure) and terror (if I mess it up, the world explodes).<br/>—Stephan T. Lavavej (Principal Developer, Visual C++ Libraries). Tweet dated 3:11 am on August 22, 2016.</em></p>&#13;
<div class="image1"><img src="../images/common.jpg" alt="Image"/></div>&#13;
<p class="noindent">The <em>standard template library</em> (<em>STL</em>) is the portion of the stdlib that provides containers and the algorithms to manipulate them, with iterators serving as the interface between the two. In the next three chapters, you’ll learn more about each of these components.</p>&#13;
<p class="indent">A <em>container</em> is a special data structure that stores objects in an organized way that follows specific access rules. There are three kinds of containers:</p>&#13;
<ul>&#13;
<li class="noindent">Sequence containers store elements consecutively, as in an array.</li>&#13;
<li class="noindent">Associative containers store sorted elements.</li>&#13;
<li class="noindent">Unordered associative containers store hashed objects.</li>&#13;
</ul>&#13;
<p class="indent">Associative and unordered associative containers offer rapid search for individual elements. All containers are RAII wrappers around their contained objects, so they manage the storage durations and lifetimes of the elements they own. Additionally, each container provides some set of member functions that perform various operations on the object collection.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_408"/>Modern C++ programs use containers all the time. Which container you choose for a particular application depends on the required operations, the contained objects’ characteristics, and efficiencies under particular access patterns. This chapter surveys the vast container landscape covered between the STL and Boost. Because there are so many containers in these libraries, you’ll explore the most popular ones.</p>&#13;
<h3 class="h3" id="ch13lev1sec1"><strong>Sequence Containers</strong></h3>&#13;
<p class="noindent"><em>Sequence containers</em> are STL containers that allow sequential member access. That is, you can start from one end of the container and iterate through to the other end. But except for this commonality, sequence containers are a varied and motley crew. Some containers have a fixed length; others can shrink and grow as program needs dictate. Some allow indexing directly into the container, whereas you can only access others sequentially. Additionally, each sequence container has unique performance characteristics that make it desirable in some situations and undesirable in others.</p>&#13;
<p class="indent">Working with sequence containers should feel intuitive because you’ve been acquainted with a primitive one since “Arrays” on <a href="ch02.xhtml#page_42">page 42</a>, where you saw the built-in or “C-style” array <span class="literal">T[]</span>. You’ll begin the survey of sequence containers by looking at the built-in array’s more sophisticated, cooler younger brother <span class="literal">std::array</span>.</p>&#13;
<h4 class="h4" id="ch13lev2sec1"><strong><em>Arrays</em></strong></h4>&#13;
<p class="noindent">The STL provides <span class="literal">std::array</span> in the <span class="literal">&lt;array&gt;</span> header. An <span class="literal">array</span> is a sequential container that holds a fixed-size, contiguous series of elements. It combines the sheer performance and efficiency of built-in arrays with the modern conveniences of supporting copy/move construction/assignment, knowing its own size, providing bounds-checked member access, and other advanced features.</p>&#13;
<p class="indent">You should use <span class="literal">array</span> instead of built-in arrays in virtually all situations. It supports almost all the same usage patterns as <span class="literal">operator[]</span> to access elements, so there aren’t many situations in which you’ll need a built-in array instead.</p>&#13;
<div class="note">&#13;
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>&#13;
<p class="notep"><em>Boost also offers a <span class="literal">boost::array</span> in Boost Array’s <span class="literal">&lt;boost/array.hpp&gt;</span>. You shouldn’t need to use the Boost version unless you have a very old C++ tool chain.</em></p>&#13;
</div>&#13;
<h5 class="h5" id="ch13lev3sec1"><strong>Constructing</strong></h5>&#13;
<p class="noindent">The <span class="literal">array&lt;</span><span class="codeitalic">T, S &gt;</span> class template takes two template parameters:</p>&#13;
<ul>&#13;
<li class="noindent">The contained type <span class="codeitalic">T</span></li>&#13;
<li class="noindent">The fixed size of the array <span class="codeitalic">S</span></li>&#13;
</ul>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_409"/>You can construct an <span class="literal">array</span> and built-in arrays using the same rules. To summarize these rules from “Arrays” on <a href="ch02.xhtml#page_42">page 42</a>, the preferred method is to use braced initialization to construct an <span class="literal">array</span>. Braced initialization fills the <span class="literal">array</span> with the values contained in the braces and fills the remaining elements with zeros. If you omit initialization braces, the <span class="literal">array</span> contains uninitialized values depending on its storage duration. <a href="ch13.xhtml#ch13ex01">Listing 13-1</a> illustrates braced initialization with several <span class="literal">array</span> declarations.</p>&#13;
<pre>#include &lt;array&gt;&#13;
&#13;
std::array&lt;int, 10&gt; static_array{} <span class="ent">➊</span>&#13;
&#13;
TEST_CASE("std::array") {&#13;
  REQUIRE(static_array[0] == 0); <span class="ent">➋</span>&#13;
&#13;
  SECTION("uninitialized without braced initializers") {&#13;
    std::array&lt;int, 10&gt; local_array; <span class="ent">➌</span>&#13;
    REQUIRE(local_array[0] != 0); <span class="ent">➍</span>&#13;
  }&#13;
&#13;
  SECTION("initialized with braced initializers") {&#13;
    std::array&lt;int, 10&gt; local_array{ 1, 1, 2, 3 }; <span class="ent">➎</span>&#13;
    REQUIRE(local_array[0] == 1);&#13;
    REQUIRE(local_array[1] == 1);&#13;
    REQUIRE(local_array[2] == 2);&#13;
    REQUIRE(local_array[3] == 3);&#13;
    REQUIRE(local_array[4] == 0); <span class="ent">➏</span>&#13;
  }&#13;
}</pre>&#13;
&#13;
<p class="listing"><a id="ch13ex01"/><em>Listing 13-1: Initializing a <span class="literal">std::array</span>. You might get compiler warnings from <span class="literal">REQUIRE(local_array[0] != 0);</span> <span class="ent">➍</span>, since <span class="literal">local_array</span> has uninitialized elements.</em></p>&#13;
<p class="indent">You declare an <span class="literal">array</span> of 10 <span class="literal">int</span> objects called <span class="literal">static_array</span> with static storage duration <span class="ent">➊</span>. You haven’t used braced initialization, but its elements initialize to zero anyway <span class="ent">➋</span>, thanks to the initialization rules covered in “Arrays” on <a href="ch02.xhtml#page_42">page 42</a>.</p>&#13;
<p class="indent">Next, you try declaring another <span class="literal">array</span> of 10 <span class="literal">int</span> objects, this time with automatic storage duration <span class="ent">➌</span>. Because you haven’t used braced initialization, <span class="literal">local_array</span> contains uninitialized elements (that have an extremely low probability of equaling zero <span class="ent">➍</span>).</p>&#13;
<p class="indent">Finally, you use braced initialization to declare another <span class="literal">array</span> and to fill the first four elements <span class="ent">➎</span>. All remaining elements get set to zero <span class="ent">➏</span>.</p>&#13;
<h5 class="h5" id="ch13lev3sec2"><strong>Element Access</strong></h5>&#13;
<p class="noindent">The three main methods by which you can access arbitrary <span class="literal">array</span> elements are:</p>&#13;
<ul>&#13;
<li class="noindent"><span class="literal">operator[]</span></li>&#13;
<li class="noindent"><span class="literal">at</span></li>&#13;
<li class="noindent"><span class="literal">get</span></li>&#13;
</ul>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_410"/>The <span class="literal">operator[]</span> and <span class="literal">at</span> methods take a single <span class="literal">size_t</span> argument corresponding to the index of the desired element. The difference between these two lies in bounds checking: if the index argument is out of bounds, <span class="literal">at</span> will throw a <span class="literal">std::out_of_range</span> exception, whereas <span class="literal">operator[]</span> will cause undefined behavior. The function template <span class="literal">get</span> takes a template parameter of the same specification. Because it’s a template, the index must be known at compile time.</p>&#13;
<div class="note">&#13;
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>&#13;
<p class="notep"><em>Recall from “The <span class="literal">size_t</span> Type” on <a href="ch02.xhtml#page_41">page 41</a> that a <span class="literal">size_t</span> object guarantees that its maximum value is sufficient to represent the maximum size in bytes of all objects. It is for this reason that <span class="literal">operator[]</span> and <span class="literal">at</span> take a <span class="literal">size_t</span> rather than an <span class="literal">int</span>, which makes no such guarantee.</em></p>&#13;
</div>&#13;
<p class="indent">A major bonus of using <span class="literal">get</span> is that you get compile-time bounds checking, as illustrated in <a href="ch13.xhtml#ch13ex02">Listing 13-2</a>.</p>&#13;
<pre>TEST_CASE("std::array access") {&#13;
   std::array&lt;int, 4&gt; fib{ 1, 1, 0, 3}; <span class="ent">➊</span>&#13;
&#13;
  SECTION("operator[] can get and set elements") {&#13;
    fib[2] = 2; <span class="ent">➋</span>&#13;
    REQUIRE(fib[2] == 2); <span class="ent">➌</span>&#13;
    // fib[4] = 5; <span class="ent">➍</span>&#13;
  }&#13;
&#13;
  SECTION("at() can get and set elements") {&#13;
    fib.at(2) = 2; <span class="ent">➎</span>&#13;
    REQUIRE(fib.at(2) == 2); <span class="ent">➏</span>&#13;
    REQUIRE_THROWS_AS(fib.at(4), std::out_of_range); <span class="ent">➐</span>&#13;
  }&#13;
  SECTION("get can get and set elements") {&#13;
    std::get&lt;2&gt;(fib) = 2; <span class="ent">➑</span>&#13;
    REQUIRE(std::get&lt;2&gt;(fib) == 2); <span class="ent">➒</span>&#13;
    // std::get&lt;4&gt;(fib); <span class="ent">➓</span>&#13;
  }&#13;
}</pre>&#13;
<p class="listing"><a id="ch13ex02"/><em>Listing 13-2: Accessing elements of an <span class="literal">array</span>. Uncommenting <span class="literal">// fib[4] = 5;</span></em> <span class="ent">➍</span> <em>will cause undefined behavior, whereas uncommenting <span class="literal">// std::get&lt;4&gt;(fib);</span></em> <span class="ent">➓</span> <em>will cause compilation failure.</em></p>&#13;
<p class="indent">You declare an array of length 4 called <span class="literal">fib</span> <span class="ent">➊</span>. Using <span class="literal">operator[]</span> <span class="ent">➋</span> you can set elements and retrieve them <span class="ent">➌</span>. The out of bounds write you’ve commented out would cause undefined behavior; there is no bounds checking with <span class="literal">operator[]</span> <span class="ent">➍</span>.</p>&#13;
<p class="indent">You can use <span class="literal">at</span> for the same read <span class="ent">➎</span> and write <span class="ent">➏</span> operations, and you can safely perform an out-of-bounds operation thanks to bounds checking <span class="ent">➐</span>.</p>&#13;
<p class="indent">Finally, you can use <span class="literal">std::get</span> to <span class="literal">set</span> <span class="ent">➑</span> and <span class="literal">get</span> <span class="ent">➒</span> elements. The <span class="literal">get</span> element also performs bounds checking, so <span class="literal">// std::get&lt;4&gt;(fib);</span> <span class="ent">➓</span> will fail to compile if uncommented.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_411"/>You’ve also have a <span class="literal">front</span> and a <span class="literal">back</span> method, which return references to the first and last elements of the array. You’ll get undefined behavior if you call one of these methods if the array has zero length, as <a href="ch13.xhtml#ch13ex03">Listing 13-3</a> illustrates.</p>&#13;
<pre>TEST_CASE("std::array has convenience methods") {&#13;
  std::array&lt;int, 4&gt; fib{ 0, 1, 2, 0 };&#13;
&#13;
  SECTION("front") {&#13;
    fib.front() = 1; <span class="ent">➊</span>&#13;
    REQUIRE(fib.front() == 1); <span class="ent">➋</span>&#13;
    REQUIRE(fib.front() == fib[0]); <span class="ent">➌</span>&#13;
  }&#13;
&#13;
  SECTION("back") {&#13;
    fib.back() = 3; <span class="ent">➍</span>&#13;
    REQUIRE(fib.back() == 3); <span class="ent">➎</span>&#13;
    REQUIRE(fib.back() == fib[3]); <span class="ent">➏</span>&#13;
  }&#13;
}</pre>&#13;
<p class="listing"><a id="ch13ex03"/><em>Listing 13-3: Using the convenience methods <span class="literal">front</span> and <span class="literal">back</span> on a <span class="literal">std::array</span></em></p>&#13;
<p class="indent">You can use the <span class="literal">front</span> and <span class="literal">back</span> methods to set <span class="ent">➊</span><span class="ent">➍</span> and get <span class="ent">➋</span><span class="ent">➎</span> the first and last elements of an <span class="literal">array</span>. Of course, <span class="literal">fib[0]</span> is identical to <span class="literal">fib.front()</span> <span class="ent">➌</span>, and <span class="literal">fib[3]</span> is identical to <span class="literal">fib.back()</span> <span class="ent">➏</span>. The <span class="literal">front()</span> and <span class="literal">back()</span> methods are simply convenience methods. Additionally, if you’re writing generic code, some containers will offer <span class="literal">front</span> and <span class="literal">back</span> but not <span class="literal">operator[]</span>, so it’s best to use the <span class="literal">front</span> and <span class="literal">back</span> methods.</p>&#13;
<h5 class="h5" id="ch13lev3sec3"><strong>Storage Model</strong></h5>&#13;
<p class="noindent">An <span class="literal">array</span> doesn’t make allocations; rather, like a built-in array, it contains all of its elements. This means copies will generally be expensive, because each constituent element needs to be copied. Moves can be expensive, depending on whether the underlying type of the <span class="literal">array</span> also has move construction and move assignment, which are relatively inexpensive.</p>&#13;
<p class="indent">Each <span class="literal">array</span> is just a built-in array underneath. In fact, you can extract a pointer to the first element of an <span class="literal">array</span> using four distinct methods:</p>&#13;
<ul>&#13;
<li class="noindent">The go-to method is to use the <span class="literal">data</span> method. As advertised, this returns a pointer to the first element.</li>&#13;
<li class="noindent">The other three methods involve using the address-of operator <span class="literal">&amp;</span> on the first element, which you can obtain using <span class="literal">operator[]</span>, <span class="literal">at</span>, and <span class="literal">front</span>.</li>&#13;
</ul>&#13;
<p class="indent">You should use <span class="literal">data</span>. If the <span class="literal">array</span> is empty, the address-of-based approaches will return undefined behavior.</p><p class="indent"><a href="ch13.xhtml#ch13ex04">Listing 13-4</a> illustrates how to obtain a pointer using these four methods.</p>&#13;
<pre><span epub:type="pagebreak" id="page_412"/>TEST_CASE("We can obtain a pointer to the first element using") {&#13;
  std::array&lt;char, 9&gt; color{ 'o',  'c', 't', 'a', 'r', 'i', 'n', 'e' };&#13;
  const auto* color_ptr = color.data(); <span class="ent">➊</span>&#13;
&#13;
  SECTION("data") {&#13;
    REQUIRE(*color_ptr == 'o'); <span class="ent">➋</span>&#13;
  }&#13;
  SECTION("address-of front") {&#13;
    REQUIRE(&amp;color.front() == color_ptr); <span class="ent">➌</span>&#13;
  }&#13;
  SECTION("address-of at(0)") {&#13;
    REQUIRE(&amp;color.at(0) == color_ptr); <span class="ent">➍</span>&#13;
  }&#13;
  SECTION("address-of [0]") {&#13;
    REQUIRE(&amp;color[0] == color_ptr); <span class="ent">➎</span>&#13;
  }&#13;
}</pre>&#13;
<p class="listing"><a id="ch13ex04"/><em>Listing 13-4: Obtaining a pointer to the first element of a <span class="literal">std::array</span></em></p>&#13;
<p class="indent">After initializing the <span class="literal">array color</span>, you obtain a pointer to the first element, the letter <span class="literal">o</span>, using the <span class="literal">data</span> method <span class="ent">➊</span>. When you dereference the resulting <span class="literal">color_ptr</span>, you obtain the letter <span class="literal">o</span> as expected <span class="ent">➋</span>. This pointer is identical to the pointer obtained from the <span class="literal">address-of-</span>plus-<span class="literal">front</span> <span class="ent">➌</span>, -<span class="literal">at</span> <span class="ent">➍</span>, and -<span class="literal">operator[]</span> <span class="ent">➎</span> approaches.</p>&#13;
<p class="indent">To conclude arrays, you can query the size of an <span class="literal">array</span> using either the <span class="literal">size</span> or <span class="literal">max_size</span> methods. (These are identical for an <span class="literal">array</span>.) Because an <span class="literal">array</span> has a fixed size, these method’s values are static and known at compile time.</p>&#13;
<h5 class="h5" id="ch13lev3sec4"><strong>A Crash Course in Iterators</strong></h5>&#13;
<p class="noindent">The interface between containers and algorithms is the iterator. An iterator is a type that knows the internal structure of a container and exposes simple, pointer-like operations to a container’s elements. <a href="ch14.xhtml#ch14">Chapter 14</a> is dedicated entirely to iterators, but you need to know the very basics here so you can explore how to use iterators to manipulate containers and how containers expose iterators to users.</p>&#13;
<p class="indent">Iterators come in various flavors, but they all support at least the following operations:</p>&#13;
<ol>&#13;
<li class="noindent">Get the current element (<span class="literal">operator*</span>)</li>&#13;
<li class="noindent">Go to the next element (<span class="literal">operator++</span>)</li>&#13;
<li class="noindent">Assign an iterator equal to another iterator (<span class="literal">operator=</span>)</li>&#13;
</ol>&#13;
<p class="indent">You can extract iterators from all STL containers (including <span class="literal">array</span>) using their <span class="literal">begin</span> and <span class="literal">end</span> methods. The <span class="literal">begin</span> method returns an iterator pointing to the first element, and the <span class="literal">end</span> method returns a pointer to one element past the last element. <a href="ch13.xhtml#ch13fig01">Figure 13-1</a> illustrates where the <span class="literal">begin</span> and <span class="literal">end</span> iterators point in an array of three elements.</p>&#13;
<div class="image"><span epub:type="pagebreak" id="page_413"/><img src="../images/fig13_1.jpg" alt="image"/></div>&#13;
<p class="figcap" id="ch13fig01"><em>Figure 13-1: A half-open range over an <span class="literal">array</span> of three elements</em></p>&#13;
<p class="indent">The arrangement in <a href="ch13.xhtml#ch13fig01">Figure 13-1</a>, where <span class="literal">end()</span> points after the last element, is called a <em>half-open range</em>. It might seem counterintuitive at first—why not have a closed range where <span class="literal">end()</span> points to the last element—but a half-open range has some advantages. For example, if a container is empty, <span class="literal">begin()</span> will return the same value as <span class="literal">end()</span>. This allows you to know that, regardless of whether the container is empty, if the iterator equals <span class="literal">end()</span>, you’ve traversed the container.</p>&#13;
<p class="indent"><a href="ch13.xhtml#ch13ex05">Listing 13-5</a> illustrates what happens with half-open range iterators and empty containers.</p>&#13;
<pre>TEST_CASE("std::array begin/end form a half-open range") {&#13;
  std::array&lt;int, 0&gt; e{}; <span class="ent">➊</span>&#13;
  REQUIRE(e.begin()<span class="ent">➋</span> == e.end()<span class="ent">➌</span>);&#13;
}</pre>&#13;
<p class="listing"><a id="ch13ex05"/><em>Listing 13-5: With an empty <span class="literal">array</span>, the <span class="literal">begin</span> iterator equals the <span class="literal">end</span> iterator.</em></p>&#13;
<p class="indent">Here, you construct an empty array <span class="literal">e</span> <span class="ent">➊</span>, and the <span class="literal">begin</span> <span class="ent">➋</span> and <span class="literal">end</span> <span class="ent">➌</span> iterators are equal.</p>&#13;
<p class="indent"><a href="ch13.xhtml#ch13ex06">Listing 13-6</a> examines how to use iterators to perform pointer-like operations over a non-empty <span class="literal">array</span>.</p>&#13;
<pre>TEST_CASE("std::array iterators are pointer-like") {&#13;
  std::array&lt;int, 3&gt; easy_as{ 1, 2, 3 }; <span class="ent">➊</span>&#13;
  auto iter = easy_as.begin(); <span class="ent">➋</span>&#13;
  REQUIRE(*iter == 1); <span class="ent">➌</span>&#13;
  ++iter; <span class="ent">➍</span>&#13;
  REQUIRE(*iter == 2);&#13;
  ++iter;&#13;
  REQUIRE(*iter == 3); <span class="ent">➎</span>&#13;
  ++iter; <span class="ent">➏</span>&#13;
  REQUIRE(iter == easy_as.end()); <span class="ent">➐</span>&#13;
}</pre>&#13;
<p class="listing"><a id="ch13ex06"/><em>Listing 13-6: Basic <span class="literal">array</span> iterator operations</em></p>&#13;
<p class="indent">The <span class="literal">array easy_as</span> contains the elements 1, 2, and 3 <span class="ent">➊</span>. You invoke <span class="literal">begin</span> on <span class="literal">easy_as</span> to obtain an iterator <span class="literal">iter</span> pointing to the first element <span class="ent">➋</span>. The dereference operator yields the first element 1, because this is the first element in the <span class="literal">array</span> <span class="ent">➌</span>. Next, you increment <span class="literal">iter</span> so it points to the next element <span class="ent">➍</span>. You continue in this fashion until you reach the last element <span class="ent">➎</span>. Incrementing the pointer one last time puts you 1 past the last element <span class="ent">➏</span>, so <span class="literal">iter</span> equals <span class="literal">easy_as.end()</span>, indicating that you’ve traversed the <span class="literal">array</span> <span class="ent">➐</span>.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_414"/>Recall from “Range Expressions” on <a href="ch08.xhtml#page_235">page 235</a> that you can build your own types for use in range expressions by exposing a <span class="literal">begin</span> and an <span class="literal">end</span> method, as implemented in the <span class="literal">FibonacciIterator</span> in <a href="ch08.xhtml#ch08ex29">Listing 8-29</a>. Well, containers already do all this work for you, meaning you can use any STL container as a range expression. <a href="ch13.xhtml#ch13ex07">Listing 13-7</a> illustrates by iterating over an <span class="literal">array</span>.</p>&#13;
<pre>TEST_CASE("std::array can be used as a range expression") {&#13;
  std::array&lt;int, 5&gt; fib{ 1, 1, 2, 3, 5 }; <span class="ent">➊</span>&#13;
  int sum{}; <span class="ent">➋</span>&#13;
  for (const auto element : fib) <span class="ent">➌</span>&#13;
    sum += element; <span class="ent">➍</span>&#13;
  REQUIRE(sum == 12);&#13;
}</pre>&#13;
<p class="listing"><a id="ch13ex07"/><em>Listing 13-7: Range-based <span class="literal">for</span> loops and <span class="literal">array</span>s</em></p>&#13;
<p class="indent">You initialize an <span class="literal">array</span> <span class="ent">➊</span> and a <span class="literal">sum</span> variable <span class="ent">➋</span>. Because <span class="literal">array</span> is a valid range, you can use it in a ranged-based <span class="literal">for</span> loop <span class="ent">➌</span>. This enables you to accumulate the <span class="literal">sum</span> of each <span class="literal">element</span> <span class="ent">➍</span>.</p>&#13;
<h5 class="h5" id="ch13lev3sec5"><strong>A Partial List of Supported Operations</strong></h5>&#13;
<p class="noindent"><a href="ch13.xhtml#ch13tab01">Table 13-1</a> provides a partial list of <span class="literal">array</span> operations. In this table, <span class="literal">a</span>, <span class="literal">a1</span>, and <span class="literal">a2</span> are of type <span class="literal">std::array&lt;T, S&gt;</span>, <span class="literal">t</span> is of type <span class="literal">T</span>, <span class="literal">S</span> is the fixed length of the array, and <span class="literal">i</span> is of type <span class="literal">size_t</span>.</p>&#13;
<p class="tabcap"><a id="ch13tab01"/><strong>Table 13-1:</strong> A Partial List of <span class="literal">std::array</span> Operations</p>&#13;
<table class="topbot-d">&#13;
<colgroup>&#13;
<col style="width:30%"/>&#13;
<col style="width:70%"/>&#13;
</colgroup>&#13;
<tbody>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-h"><p class="tab_th"><strong>Operation</strong></p></td>&#13;
<td style="vertical-align: top;" class="table-h"><p class="tab_th"><strong>Notes</strong></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><span class="literal">array&lt;</span><span class="codestrong">T</span><span class="literal">,</span> <span class="codestrong">S</span><span class="literal">&gt;{</span> <span class="codestrong">...</span> <span class="literal">}</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">Performs braced initialization of a newly constructed array.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><span class="literal">~array</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba">Destructs all elements contained by the array.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><span class="codestrong">a1</span> <span class="literal">=</span> <span class="codestrong">a2</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">Copy-assigns all the members of <span class="codestrong">a1</span> with the members of <span class="codestrong">a2</span>.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><span class="codestrong">a.</span><span class="literal">at</span>(<span class="codestrong">i</span>)</p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba">Returns a reference to element <span class="codestrong">i</span> of <span class="codestrong">a</span>. Throws <span class="literal">std::out_of_range</span> if out of bounds.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><span class="codestrong">a</span><span class="literal">[</span><span class="codestrong">i</span><span class="literal">]</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">Returns a reference to element <span class="codestrong">i</span> of <span class="codestrong">a</span>. Undefined behavior if out of bounds.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><span class="literal">get&lt;</span><span class="codestrong">i</span><span class="literal">&gt;</span><span class="literal">(</span><span class="codestrong">a</span><span class="literal">)</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba">Returns a reference to element <span class="codestrong">i</span> of <span class="codestrong">a</span>. Fails to compile if out of bounds.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><span class="codestrong">a</span><span class="literal">.front()</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">Returns a reference to first element.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><span class="codestrong">a</span><span class="literal">.back()</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba">Returns a reference to last element.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><span class="codestrong">a</span><span class="literal">.data()</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">Returns a raw pointer to the first element if the array is non-empty. For empty arrays, returns a valid but non-dereferencable pointer.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><span class="codestrong">a</span><span class="literal">.empty()</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba">Returns <span class="literal">true</span> if the array’s size is zero; otherwise <span class="literal">false</span>.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><span class="codestrong">a</span>.<span class="literal">size()</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">Returns the size of the array.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><span class="codestrong">a</span><span class="literal">.max_size()</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba">Identical to <span class="codestrong">a</span><span class="literal">.size()</span>.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><span class="codestrong">a</span>.<span class="literal">fill(</span><span class="codestrong">t</span><span class="literal">)</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">Copy-assigns <span class="codestrong">t</span> to every element of <span class="codestrong">a</span>.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><span epub:type="pagebreak" id="page_415"/><span class="codestrong">a1</span><span class="literal">.swap(</span><span class="codestrong">a2</span><span class="literal">)</span></p>&#13;
<p class="taba"><span class="literal">swap(</span><span class="codestrong">a1</span><span class="literal">,</span> <span class="codestrong">a2</span><span class="literal">)</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba">Exchanges each element of <span class="codestrong">a1</span> with those of <span class="codestrong">a2</span>.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><span class="codestrong">a</span><span class="literal">.begin()</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">Returns an iterator pointing to the first element.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><span class="codestrong">a</span><span class="literal">.cbegin()</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba">Returns a <span class="literal">const</span> iterator pointing to the first element.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><span class="codestrong">a</span><span class="literal">.end()</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">Returns an iterator pointing to 1 past the last element.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><span class="codestrong">a</span><span class="literal">.cend()</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba">Returns a <span class="literal">const</span> iterator pointing to 1 past the last element.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-ba"><p class="taba"><span class="codestrong">a1</span> <span class="literal">==</span> <span class="codestrong">a2</span></p>&#13;
<p class="taba"><span class="codestrong">a1</span> <span class="literal">!=</span> <span class="codestrong">a2</span></p>&#13;
<p class="taba"><span class="codestrong">a1</span> <span class="literal">&gt;</span> <span class="codestrong">a2</span></p>&#13;
<p class="taba"><span class="codestrong">a1</span> <span class="literal">&gt;=</span> <span class="codestrong">a2</span></p>&#13;
<p class="taba"><span class="codestrong">a1</span> <span class="literal">&lt;</span> <span class="codestrong">a2</span></p>&#13;
<p class="taba"><span class="codestrong">a1</span> <span class="literal">&lt;=</span> <span class="codestrong">a2</span></p></td>&#13;
<td style="vertical-align: top;" class="table-ba"><p class="taba">Equal if all elements are equal.</p>&#13;
<p class="taba">Greater than/less than comparisons proceed from first element to last.</p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<div class="note">&#13;
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>&#13;
<p class="notep"><em>The partial operations in <a href="ch13.xhtml#ch13tab01">Table 13-1</a> function as quick, reasonably comprehensive references. For gritty details, refer to the freely available online references <a href="https://cppreference.com/">https://cppreference.com/</a> and <a href="http://cplusplus.com/">http://cplusplus.com/</a>, as well as Chapter 31 of  The C++ Programming Language, 4th Edition, by Bjarne Stroustrup and <a href="ch07.xhtml#ch07">Chapters 7</a>, <a href="ch08.xhtml#ch08">8</a>, and <a href="ch12.xhtml#ch12">12</a> of  The C++ Standard Library, 2nd Edition, by Nicolai M. Josuttis.</em></p>&#13;
</div>&#13;
<h4 class="h4" id="ch13lev2sec2"><strong><em>Vectors</em></strong></h4>&#13;
<p class="noindent">The <span class="literal">std::vector</span> available in the STL’s <span class="literal">&lt;vector&gt;</span> header is a sequential container that holds a dynamically sized, contiguous series of elements. A <span class="literal">vector</span> manages its storage dynamically, requiring no outside help from the programmer.</p>&#13;
<p class="indent">The <span class="literal">vector</span> is the workhorse of the sequential-data-structure stable. For a very modest overhead, you gain substantial flexibility over the <span class="literal">array</span>. Plus, <span class="literal">vector</span> supports almost all of the same operations as an <span class="literal">array</span> and adds a slew of others. If you have a fixed number of elements on hand, you should strongly consider an <span class="literal">array</span> because you’ll get some small reductions in overhead versus a <span class="literal">vector</span>. In all other situations, your go-to sequential container is the <span class="literal">vector</span>.</p>&#13;
<div class="note">&#13;
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>&#13;
<p class="notep"><em>The Boost Container library also contains a <span class="literal">boost::container::vector</span> in the <span class="literal">&lt;boost/container/vector.hpp&gt;</span> header.</em></p>&#13;
</div>&#13;
<h5 class="h5" id="ch13lev3sec6"><strong>Constructing</strong></h5>&#13;
<p class="noindent">The class template <span class="literal">std::vector&lt;T, Allocator&gt;</span> takes two template parameters. The first is the contained type <span class="literal">T</span>, and the second is the allocator type <span class="literal">Allocator</span>, which is optional and defaults to <span class="literal">std::allocator&lt;T&gt;</span>.</p>&#13;
<p class="indent">You have much more flexibility in constructing <span class="literal">vector</span>s than you do with arrays. A <span class="literal">vector</span> supports user-defined allocators because vectors need to allocate dynamic memory. You can default construct a <span class="literal">vector</span> so it contains no elements. You might want to construct an empty vector so you can fill it with a variable number of elements depending on what happens during <span epub:type="pagebreak" id="page_416"/>runtime. <a href="ch13.xhtml#ch13ex08">Listing 13-8</a> illustrates default constructing a <span class="literal">vector</span> and checking that it contains no elements.</p>&#13;
<pre>#include &lt;vector&gt;&#13;
TEST_CASE("std::vector supports default construction") {&#13;
  std::vector&lt;const char*<span class="ent">➊</span>&gt; vec; <span class="ent">➋</span>&#13;
  REQUIRE(vec.empty()); <span class="ent">➌</span>&#13;
}</pre>&#13;
<p class="listing"><a id="ch13ex08"/><em>Listing 13-8: A <span class="literal">vector</span> supports default construction.</em></p>&#13;
<p class="indent">You declare a <span class="literal">vector</span> containing elements of type <span class="literal">const char*</span> <span class="ent">➊</span> called <span class="literal">vec</span>. Because it’s been default constructed <span class="ent">➋</span>, the <span class="literal">vector</span> contains no elements, and the <span class="literal">empty</span> method returns <span class="literal">true</span> <span class="ent">➌</span>.</p>&#13;
<p class="indent">You can use braced initialization with a <span class="literal">vector</span>. Similar to how you brace initialize an array, this fills the vector with the specified elements, as <a href="ch13.xhtml#ch13ex09">Listing 13-9</a> illustrates.</p>&#13;
<pre>TEST_CASE("std::vector supports braced initialization ") {&#13;
    std::vector&lt;int&gt; fib{ 1, 1, 2, 3, 5 }; <span class="ent">➊</span>&#13;
    REQUIRE(fib[4] == 5); <span class="ent">➋</span>&#13;
}</pre>&#13;
<p class="listing"><a id="ch13ex09"/><em>Listing 13-9: A <span class="literal">vector</span> supports braced initializers.</em></p>&#13;
<p class="indent">Here, you construct a <span class="literal">vector</span> called <span class="literal">fib</span> and use braced initializers <span class="ent">➊</span>. After initialization, the <span class="literal">vector</span> contains the five elements 1, 1, 2, 3, and 5 <span class="ent">➋</span>.</p>&#13;
<p class="indent">If you want to populate a <span class="literal">vector</span> with many identical values, you can use one of the <em>fill constructors</em>. To fill construct a <span class="literal">vector</span>, you first pass a <span class="literal">size_t</span> corresponding to the number of elements you want to fill. Optionally, you can pass a <span class="literal">const</span> reference to an object to copy. Sometimes you want to initialize all your elements to the same value, for example, to keep track of counts related to particular indices. You might also have a <span class="literal">vector</span> of some user-defined type that keeps track of program state, and you might need to keep track of such state by index.</p>&#13;
<p class="indent">Unfortunately, the general rule to use braced initialization to construct objects breaks down here. With <span class="literal">vector</span>, you must use parentheses to invoke these constructors. To the compiler, <span class="literal">std::vector&lt;int&gt;{ 99, 100 }</span> specifies an initialization list with the elements 99 and 100, which will construct a vector with the two elements 99 and 100. What if you want a vector with 99 copies of the number 100?</p>&#13;
<p class="indent">In general, the compiler will try very hard to treat the initializer list as elements to fill the vector with. You can try to memorize the rules (refer to Item 7 of <em>Effective Modern C++</em> by Scott Meyers) or just commit to using parentheses for stdlib container constructors.</p>&#13;
<p class="indent"><a href="ch13.xhtml#ch13ex10">Listing 13-10</a> highlights the initializer list/braced initialization general rule for STL containers.</p>&#13;
<pre>TEST_CASE("std::vector supports") {&#13;
  SECTION("braced initialization") {&#13;
    std::vector&lt;int&gt; five_nine{ 5, 9 }; <span class="ent">➊</span>&#13;
<span epub:type="pagebreak" id="page_417"/>    REQUIRE(five_nine[0] == 5); <span class="ent">➋</span>&#13;
    REQUIRE(five_nine[1] == 9); <span class="ent">➌</span>&#13;
  }&#13;
  SECTION("fill constructor") {&#13;
    std::vector&lt;int&gt; five_nines(5, 9); <span class="ent">➍</span>&#13;
    REQUIRE(five_nines[0] == 9); <span class="ent">➎</span>&#13;
    REQUIRE(five_nines[4] == 9); <span class="ent">➏</span>&#13;
  }&#13;
}</pre>&#13;
<p class="listing"><a id="ch13ex10"/><em>Listing 13-10: A <span class="literal">vector</span> supports braced initializers and fill constructors.</em></p>&#13;
<p class="indent">The first example uses braced initialization to construct a vector with two elements <span class="ent">➊</span>: 5 at index 0 <span class="ent">➋</span> and 9 at index 1 <span class="ent">➌</span>. The second example uses parentheses to invoke the fill constructor <span class="ent">➍</span>, which fills the vector with five copies of the number 9, so the first <span class="ent">➎</span> and last <span class="ent">➏</span> elements are both 9.</p>&#13;
<div class="note">&#13;
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>&#13;
<p class="notep"><em>This notational clash is unfortunate and isn’t the result of some well-thought-out trade-off. The reasons are purely historical and related to backward compatibility.</em></p>&#13;
</div>&#13;
<p class="indent">You can also construct <span class="literal">vector</span>s from a half-open range by passing in the <span class="literal">begin</span> and <span class="literal">end</span> iterators of the range you want to copy. In various programming contexts, you might want to splice out a subset of some range and copy it into a <span class="literal">vector</span> for further processing. For example, you could construct a <span class="literal">vector</span> that copies all the elements contained by an <span class="literal">array</span>, as in <a href="ch13.xhtml#ch13ex11">Listing 13-11</a>.</p>&#13;
<pre>TEST_CASE("std::vector supports construction from iterators") {&#13;
  std::array&lt;int, 5&gt; fib_arr{ 1, 1, 2, 3, 5 }; <span class="ent">➊</span>&#13;
  std::vector&lt;int&gt; fib_vec(fib_arr.begin(), fib_arr.end()); <span class="ent">➋</span>&#13;
  REQUIRE(fib_vec[4] == 5); <span class="ent">➌</span>&#13;
  REQUIRE(fib_vec.size() == fib_arr.size()); <span class="ent">➍</span>&#13;
}</pre>&#13;
<p class="listing"><a id="ch13ex11"/><em>Listing 13-11: Constructing a <span class="literal">vector</span> from a range</em></p>&#13;
<p class="indent">You construct the array <span class="literal">fib_arr</span> with five elements <span class="ent">➊</span>. To construct the vector <span class="literal">fib_vec</span> with the elements contained in <span class="literal">fib_arr</span>, you invoke the <span class="literal">begin</span> and <span class="literal">end</span> methods on <span class="literal">fib_arr</span> <span class="ent">➋</span>. The resulting <span class="literal">vector</span> has copies of the <span class="literal">array</span>’s elements <span class="ent">➌</span> and has the same <span class="literal">size</span> <span class="ent">➍</span>.</p>&#13;
<p class="indent">At a high level, you can think of this constructor as taking pointers to the beginning and the end of some target sequence. It will then copy that target sequence.</p>&#13;
<h5 class="h5" id="ch13lev3sec7"><strong>Move and Copy Semantics</strong></h5>&#13;
<p class="noindent">With <span class="literal">vector</span>s, you have full copy/move construction/assignment support. Any <span class="literal">vector</span> copy operation is potentially very expensive, because these are element-wise or deep copies. Move operations, on the other hand, are usually very fast, because the contained elements reside in dynamic memory and the moved-from <span class="literal">vector</span> can simply pass ownership to the moved-into <span class="literal">vector</span>; there’s no need to move the contained elements.</p>&#13;
<h5 class="h5" id="ch13lev3sec8"><span epub:type="pagebreak" id="page_418"/><strong>Element Access</strong></h5>&#13;
<p class="noindent">A <span class="literal">vector</span> supports most of the same element access operations as <span class="literal">array</span>: <span class="literal">at</span>, <span class="literal">operator[]</span>, <span class="literal">front</span>, <span class="literal">back</span>, and <span class="literal">data</span>.</p>&#13;
<p class="indent">As with an <span class="literal">array</span>, you can query the number of contained elements in a <span class="literal">vector</span> using the <span class="literal">size</span> method. This method’s return value can vary at runtime. You can also determine whether a <span class="literal">vector</span> contains any elements with the <span class="literal">empty</span> method, which returns <span class="literal">true</span> if the <span class="literal">vector</span> contains no elements; otherwise, it returns <span class="literal">false</span>.</p>&#13;
<h5 class="h5" id="ch13lev3sec9"><strong>Adding Elements</strong></h5>&#13;
<p class="noindent">You can use various methods to insert elements into a <span class="literal">vector</span>. If you want to replace all the elements in a <span class="literal">vector</span>, you can use the <span class="literal">assign</span> method, which takes an initialization list and replaces all the existing elements. If needed, the <span class="literal">vector</span> will resize to accommodate a larger list of elements, as <a href="ch13.xhtml#ch13ex12">Listing 13-12</a> illustrates.</p>&#13;
<pre>TEST_CASE("std::vector assign replaces existing elements") {&#13;
  std::vector&lt;int&gt; message{ 13, 80, 110, 114, 102, 110, 101 }; <span class="ent">➊</span>&#13;
  REQUIRE(message.size() == 7); <span class="ent">➋</span>&#13;
  message.assign({ 67, 97, 101, 115, 97, 114 }); <span class="ent">➌</span>&#13;
  REQUIRE(message[5] == 114); <span class="ent">➍</span>&#13;
  REQUIRE(message.size() == 6); <span class="ent">➎</span>&#13;
}</pre>&#13;
<p class="listing"><a id="ch13ex12"/><em>Listing 13-12: The <span class="literal">assign</span> method of a <span class="literal">vector</span></em></p>&#13;
<p class="indent">Here, you construct a <span class="literal">vector</span> <span class="ent">➊</span> with seven elements <span class="ent">➋</span>. When you assign a new, smaller initializer list <span class="ent">➌</span>, all the elements get replaced <span class="ent">➍</span>, and the vector’s <span class="literal">size</span> updates to reflect the new contents <span class="ent">➎</span>.</p>&#13;
<p class="indent">If you want to insert a single new element into a vector, you can use the <span class="literal">insert</span> method, which expects two arguments: an iterator and an element to insert. It will insert a copy of the given element just before the existing element pointed to by the iterator, as shown in <a href="ch13.xhtml#ch13ex13">Listing 13-13</a>.</p>&#13;
<pre>TEST_CASE("std::vector insert places new elements") {&#13;
  std::vector&lt;int&gt; zeros(3, 0); <span class="ent">➊</span>&#13;
  auto third_element = zeros.begin() + 2; <span class="ent">➋</span>&#13;
  zeros.insert(third_element, 10); <span class="ent">➌</span>&#13;
  REQUIRE(zeros[2] == 10); <span class="ent">➍</span>&#13;
  REQUIRE(zeros.size() == 4); <span class="ent">➎</span>&#13;
}</pre>&#13;
<p class="listing"><a id="ch13ex13"/><em>Listing 13-13: The <span class="literal">insert</span> method of a <span class="literal">vector</span></em></p>&#13;
<p class="indent">You initialize a vector with three zeros <span class="ent">➊</span> and generate an iterator pointing to the third element of <span class="literal">zeros</span> <span class="ent">➋</span>. Next, you insert the value 10 immediately before the third element by passing the iterator and the value 10 <span class="ent">➌</span>. The third element of <span class="literal">zeros</span> is now 10 <span class="ent">➍</span>. The <span class="literal">zeros</span> vector now contains four elements <span class="ent">➎</span>.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_419"/>Any time you use <span class="literal">insert</span>, existing iterators become invalid. For example, in <a href="ch13.xhtml#ch13ex13">Listing 13-13</a> you must not reuse <span class="literal">third_element</span>: the vector could have resized and relocated in memory, leaving the old iterator dangling in garbage memory.</p>&#13;
<p class="indent">To insert an element to the end of a <span class="literal">vector</span>, you use the <span class="literal">push_back</span> method. Unlike <span class="literal">insert</span>, <span class="literal">push_back</span> doesn’t require an iterator argument. You simply provide the element to copy into the <span class="literal">vector</span>, as shown in <a href="ch13.xhtml#ch13ex14">Listing 13-14</a>.</p>&#13;
<pre>TEST_CASE("std::vector push_back places new elements") {&#13;
  std::vector&lt;int&gt; zeros(3, 0); <span class="ent">➊</span>&#13;
  zeros.push_back(10); <span class="ent">➋</span>&#13;
  REQUIRE(zeros[3] == 10); <span class="ent">➌</span>&#13;
}</pre>&#13;
<p class="listing"><a id="ch13ex14"/><em>Listing 13-14: The <span class="literal">push_back</span> method of a <span class="literal">vector</span></em></p>&#13;
<p class="indent">Again, you initialize a <span class="literal">vector</span> with three zeros <span class="ent">➊</span>, but this time you insert the element 10 to the back of the <span class="literal">vector</span> using the <span class="literal">push_back</span> method <span class="ent">➋</span>. The <span class="literal">vector</span> now contains four elements, the last of which equals 10 <span class="ent">➌</span>.</p>&#13;
<p class="indent">You can construct new elements in place using the <span class="literal">emplace</span> and <span class="literal">emplace_back</span> methods. The <span class="literal">emplace</span> method is a variadic template that, like <span class="literal">insert</span>, accepts an iterator as its first argument. The remaining arguments get forwarded to the appropriate constructor. The <span class="literal">emplace_back</span> method is also a variadic template, but like <span class="literal">push_back</span>, it doesn’t require an iterator. It accepts any number of arguments and forwards those to the appropriate constructor. <a href="ch13.xhtml#ch13ex15">Listing 13-15</a> illustrates these two methods by emplacing a few <span class="literal">pair</span>s into a <span class="literal">vector</span>.</p>&#13;
<pre>#include &lt;utility&gt;&#13;
&#13;
TEST_CASE("std::vector emplace methods forward arguments") {&#13;
  std::vector&lt;std::pair&lt;int, int&gt;&gt; factors; <span class="ent">➊</span>&#13;
  factors.emplace_back(2, 30); <span class="ent">➋</span>&#13;
  factors.emplace_back(3, 20); <span class="ent">➌</span>&#13;
  factors.emplace_back(4, 15); <span class="ent">➍</span>&#13;
  factors.emplace(factors.begin()<span class="ent">➎</span>, 1, 60);&#13;
  REQUIRE(factors[0].first == 1); <span class="ent">➏</span>&#13;
  REQUIRE(factors[0].second == 60); <span class="ent">➐</span>&#13;
}</pre>&#13;
<p class="listing"><a id="ch13ex15"/><em>Listing 13-15: The <span class="literal">emplace_back</span> and <span class="literal">emplace</span> methods of a <span class="literal">vector</span></em></p>&#13;
<p class="indent">Here, you default construct a <span class="literal">vector</span> containing <span class="literal">pair</span>s of <span class="literal">int</span>s <span class="ent">➊</span>. Using the <span class="literal">emplace_back</span> method, you push three pairs onto the vector: 2, 30 <span class="ent">➋</span>; 3, 20 <span class="ent">➌</span>; and 4, 15 <span class="ent">➍</span>. These values get forwarded directly to the constructor of <span class="literal">pair</span>, which gets constructed in place. Next, you use <span class="literal">emplace</span> to insert a new <span class="literal">pair</span> at the beginning of the vector by passing the result of <span class="literal">factors.begin()</span> as the first argument <span class="ent">➎</span>. This causes all the elements in the vector to shift down to make room for the new <span class="literal">pair</span> (1 <span class="ent">➏</span>, 60 <span class="ent">➐</span>).</p>&#13;
<div class="note">&#13;
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>&#13;
<p class="notep"><span epub:type="pagebreak" id="page_420"/><em>There’s absolutely nothing special about a <span class="literal">std::vector&lt;std::pair&lt;int, int&gt;&gt;</span>. It’s just like any other <span class="literal">vector</span>. The individual elements in this sequential container just happen to be a <span class="literal">pair</span>. Because <span class="literal">pair</span> has a constructor that accepts two arguments, one for <span class="literal">first</span> and one for <span class="literal">second</span>, <span class="literal">emplace_back</span> can add a new element by simply passing the two values it should write into the newly created <span class="literal">pair</span>.</em></p>&#13;
</div>&#13;
<p class="indent">Because the emplacement methods can construct elements in place, it seems they should be more efficient than the insertion methods. This intuition is often correct, but for complicated and unsatisfying reasons it’s not always faster. As a general rule, use the emplacement methods. If you determine a performance bottleneck, also try the insertion methods. See Item 42 of <em>Effective Modern C++</em> by Scott Meyers for a treatise.</p>&#13;
<h5 class="h5" id="ch13lev3sec10"><strong>Storage Model</strong></h5>&#13;
<p class="noindent">Although <span class="literal">vector</span> elements are contiguous in memory, like an <span class="literal">array</span>, the similarities stop there. A <span class="literal">vector</span> has dynamic size, so it must be able to resize. The allocator of a <span class="literal">vector</span> manages the dynamic memory underpinning the <span class="literal">vector</span>.</p>&#13;
<p class="indent">Because allocations are expensive, a <span class="literal">vector</span> will request more memory than it needs to contain the current number of elements. Once it can no longer add any more elements, it will request additional memory. The memory for a <span class="literal">vector</span> is always contiguous, so if there isn’t enough space at the end of the existing vector, it will allocate a whole new region of memory and move all the elements of the <span class="literal">vector</span> into the new region. The number of elements a <span class="literal">vector</span> holds is called its <em>size</em>, and the number of elements it could theoretically hold before having to resize is called its <em>capacity</em>. <a href="ch13.xhtml#ch13fig02">Figure 13-2</a> illustrates a <span class="literal">vector</span> containing three elements with additional capacity for three more.</p>&#13;
<div class="image"><img src="../images/fig13_2.jpg" alt="image"/></div>&#13;
<p class="figcap" id="ch13fig02"><em>Figure 13-2: The <span class="literal">vector</span> storage model</em></p>&#13;
<p class="indent">As <a href="ch13.xhtml#ch13fig02">Figure 13-2</a> shows, the <span class="literal">vector</span> continues past the last element. The capacity determines how many elements the <span class="literal">vector</span> could hold in this space. In this figure, the size is three and the capacity is six. You can think of the memory in a <span class="literal">vector</span> as an auditorium: it might have a capacity of 500 but a crowd size of only 250.</p>&#13;
<p class="indent">The upshot of this design is that inserting at the end of a <span class="literal">vector</span> is extremely fast (unless the <span class="literal">vector</span> needs to resize). Inserting anywhere else incurs additional cost, because the <span class="literal">vector</span> needs to move elements around to make room.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_421"/>You can obtain the vector’s current capacity via the <span class="literal">capacity</span> method, and you can obtain the absolute maximum capacity that a <span class="literal">vector</span> could resize to with the <span class="literal">max_size</span> method.</p>&#13;
<p class="indent">If you know ahead of time that you’ll need a certain capacity, you can use the <span class="literal">reserve</span> method, which takes a single <span class="literal">size_t</span> argument corresponding to the number of elements you want capacity for. On the other hand, if you’ve just removed several elements and want to return memory to the allocator, you can use the <span class="literal">shrink_to_fit</span> method, which declares that you have excess capacity. The allocator can decide to reduce capacity or not (it’s a non-binding call).</p>&#13;
<p class="indent">Additionally, you can delete all the elements in a vector and set its size to zero using the <span class="literal">clear</span> method.</p>&#13;
<p class="indent"><a href="ch13.xhtml#ch13ex16">Listing 13-16</a> demonstrates all these storage-related methods in a cohesive story: you create an empty vector, reserve a bunch of space, add some elements, release excess capacity, and finally empty the vector.</p>&#13;
<pre>#include &lt;cstdint&gt;&#13;
#include &lt;array&gt;&#13;
&#13;
TEST_CASE("std::vector exposes size management methods") {&#13;
  std::vector&lt;std::array&lt;uint8_t, 1024&gt;&gt; kb_store; <span class="ent">➊</span>&#13;
  REQUIRE(kb_store.max_size() &gt; 0);&#13;
  REQUIRE(kb_store.empty()); <span class="ent">➋</span>&#13;
&#13;
  size_t elements{ 1024 };&#13;
  kb_store.reserve(elements); <span class="ent">➌</span>&#13;
  REQUIRE(kb_store.empty());&#13;
  REQUIRE(kb_store.capacity() == elements); <span class="ent">➍</span>&#13;
&#13;
  kb_store.emplace_back();&#13;
  kb_store.emplace_back();&#13;
  kb_store.emplace_back();&#13;
  REQUIRE(kb_store.size() == 3); <span class="ent">➎</span>&#13;
&#13;
  kb_store.shrink_to_fit();&#13;
  REQUIRE(kb_store.capacity() &gt;= 3); <span class="ent">➏</span>&#13;
&#13;
  kb_store.clear(); <span class="ent">➐</span>&#13;
  REQUIRE(kb_store.empty());&#13;
  REQUIRE(kb_store.capacity() &gt;= 3); <span class="ent">➑</span>&#13;
}</pre>&#13;
<p class="listing"><a id="ch13ex16"/><em>Listing 13-16: The storage management functions of a <span class="literal">vector</span>. (Strictly speaking, <span class="literal">kb_store.capacity() &gt;= 3</span> <span class="ent">➏ ➑</span> is not guaranteed because the call is non-binding.)</em></p>&#13;
<p class="indent">You construct a <span class="literal">vector</span> of <span class="literal">array</span> objects called <span class="literal">kb_store</span>, which stores 1 KiB chunks <span class="ent">➊</span>. Unless you’re using a peculiar platform with no dynamic memory, <span class="literal">kb_store.max_size()</span> will be greater than zero; because you default initialize the <span class="literal">vector</span>, it’s empty <span class="ent">➋</span>.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_422"/>Next, you reserve 1,024 elements <span class="ent">➌</span>, which doesn’t change the vector’s empty status but increases its capacity to match <span class="ent">➍</span>. The <span class="literal">vector</span> now has 1,024 × 1 KiB = 1 MiB of contiguous space reserved. After reserving space, you emplace three arrays and check that <span class="literal">kb_store.size()</span> increased accordingly <span class="ent">➎</span>.</p>&#13;
<p class="indent">You’ve reserved space for 1,024 elements. To release the 1,024 – 3 = 1,021 elements you aren’t using back to the allocator, you call <span class="literal">shrink_to_fit</span>, which reduces the capacity to 3 <span class="ent">➏</span>.</p>&#13;
<p class="indent">Finally, you invoke <span class="literal">clear</span> on the <span class="literal">vector</span> <span class="ent">➐</span>, which destructs all elements and reduces its size to zero. However, the capacity remains unchanged because you haven’t made another call to <span class="literal">shrink_to_fit</span> <span class="ent">➑</span>. This is significant because the vector doesn’t want to do extra work if you’re going to add elements again.</p>&#13;
<h5 class="h5" id="ch13lev3sec11"><strong>A Partial List of Supported Operations</strong></h5>&#13;
<p class="noindent"><a href="ch13.xhtml#ch13tab02">Table 13-2</a> provides a partial list of <span class="literal">vector</span> operations. In this table, <span class="literal">v</span>, <span class="literal">v1</span>, and <span class="literal">v2</span> are of type <span class="literal">std::vector&lt;T&gt;</span>, <span class="literal">t</span> is of type <span class="literal">T</span>, <span class="literal">alc</span> is an appropriate allocator, and <span class="literal">itr</span> is an iterator. An asterisk (*) indicates that this operation invalidates raw pointers and iterators to <span class="literal">v</span>’s elements in at least some circumstances.</p>&#13;
<p class="tabcap"><span epub:type="pagebreak" id="page_423"/><a id="ch13tab02"/><strong>Table 13-2:</strong> A Partial List of <span class="literal">std::vector</span> Operations</p>&#13;
<table class="topbot-d">&#13;
<colgroup>&#13;
<col style="width:30%"/>&#13;
<col style="width:70%"/>&#13;
</colgroup>&#13;
<tbody>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-h"><p class="tab_th"><strong>Operation</strong></p></td>&#13;
<td style="vertical-align: top;" class="table-h"><p class="tab_th"><strong>Notes</strong></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><span class="literal">vector&lt;</span><span class="codestrong">T</span><span class="literal">&gt;{ ...,</span> [<span class="codestrong">alc</span>]}</p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">Performs braced initialization of a newly constructed vector. Uses <span class="codestrong">alc</span><span class="literal">=std::allocator&lt;</span><span class="codestrong">T</span><span class="literal">&gt;</span> by default.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><span class="literal">vector&lt;</span><span class="codestrong">T</span><span class="literal">&gt;(</span><span class="codestrong">s</span><span class="literal">,[</span><span class="codestrong">t</span><span class="literal">], [</span><span class="codestrong">alc</span><span class="literal">])</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba">Fills the newly constructed vector with <span class="codestrong">s</span> number of copies of <span class="codestrong">t</span>. If no <span class="codestrong">t</span> is provided, default constructs <span class="codestrong">T</span> instances.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><span class="literal">vector&lt;</span><span class="codestrong">T</span><span class="literal">&gt;(</span><span class="codestrong">v</span><span class="literal">)</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">Deep copy of <span class="codestrong">v</span>; allocates new memory.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><span class="literal">vector&lt;</span><span class="codestrong">T</span><span class="literal">&gt;(move(</span><span class="codestrong">v</span><span class="literal">))</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba">Takes ownership of memory, elements in <span class="codestrong">v</span>. No allocations.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><span class="literal">~vector</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">Destructs all elements contained by the vector and releases dynamic memory.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><span class="codestrong">v</span><span class="literal">.begin()</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba">Returns an iterator pointing to the first element.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><span class="codestrong">v</span><span class="literal">.cbegin()</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">Returns a <span class="literal">const</span> iterator pointing to the first element.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><span class="codestrong">v</span><span class="literal">.end()</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba">Returns an iterator pointing to 1 past the last element.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><span class="codestrong">v</span><span class="literal">.cend()</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">Returns a <span class="literal">const</span> iterator pointing to 1 past the last element.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><span class="codestrong">v1</span> <span class="literal">=</span> <span class="codestrong">v2</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><span class="codestrong">v1</span> destructs its elements; copies each <span class="codestrong">v2</span> element. Only allocates if it needs to resize to fit <span class="codestrong">v2</span>’s elements.*</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><span class="codestrong">v1</span> <span class="literal">=</span> <span class="literal">move(</span><span class="codestrong">v2</span><span class="literal">)</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><span class="codestrong">v1</span> destructs its elements; moves each <span class="codestrong">v2</span> element. Only allocates if it needs to resize to fit <span class="codestrong">v2</span>’s elements.*</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><span class="codestrong">v</span><span class="literal">.at(</span><span class="codestrong">0</span><span class="literal">)</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba">Accesses element <span class="codestrong">0</span> of <span class="codestrong">v</span>. Throws <span class="literal">std::out_of_range</span> if out of bounds.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><span class="codestrong">v</span><span class="literal">[</span><span class="codestrong">0</span><span class="literal">]</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">Accesses element <span class="codestrong">0</span> of <span class="codestrong">v</span>. Undefined behavior if out of bounds.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><span class="codestrong">v</span><span class="literal">.front()</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba">Accesses first element.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><span class="codestrong">v</span><span class="literal">.back()</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">Accesses last element.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><span class="codestrong">v</span><span class="literal">.data()</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba">Returns a raw pointer to the first element if array is non-empty. For empty arrays, returns a valid but non-dereferencable pointer.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><span class="codestrong">v</span><span class="literal">.assign({</span> <span class="codestrong">...</span> <span class="literal">})</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">Replaces the contents of <span class="codestrong">v</span> with the elements <span class="codestrong">...</span>.*</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><span class="codestrong">v</span><span class="literal">.assign(</span><span class="codestrong">s</span><span class="literal">,</span> <span class="codestrong">t</span><span class="literal">)</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba">Replaces the contents of <span class="codestrong">v</span> with <span class="codestrong">s</span> number of copies of <span class="codestrong">t</span>.*</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><span class="codestrong">v</span><span class="literal">.empty()</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">Returns <span class="literal">true</span> if vector’s size is zero; otherwise <span class="literal">false</span>.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><span class="codestrong">v</span><span class="literal">.size()</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba">Returns the number of elements in the vector.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><span class="codestrong">v</span><span class="literal">.capacity()</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">Returns the maximum number of elements the vector could hold without having to resize.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><span class="codestrong">v</span><span class="literal">.shrink_to_fit()</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba">Might reduce the vector’s storage so <span class="literal">capacity()</span> equals <span class="literal">size()</span>.*</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><span class="codestrong">v</span><span class="literal">.resize(</span><span class="codestrong">s</span><span class="literal">, [</span><span class="codestrong">t</span><span class="literal">])</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">Resizes <span class="codestrong">v</span> to contain <span class="codestrong">s</span> elements. If this shrinks <span class="codestrong">v</span>, destructs elements at the end. If this grows <span class="codestrong">v</span>, inserts default constructed <span class="codestrong">T</span>s or copies of <span class="codestrong">t</span> if provided.*</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><span class="codestrong">v</span><span class="literal">.reserve(</span><span class="codestrong">s</span><span class="literal">)</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba">Increases the vector’s storage so it can contain at least <span class="codestrong">s</span> elements.*</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><span class="codestrong">v</span><span class="literal">.max_size()</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">Returns the maximum possible size the vector can resize to.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><span class="codestrong">v</span><span class="literal">.clear()</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba">Removes all elements in <span class="codestrong">v</span>, but capacity remains.*</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><span class="codestrong">v</span><span class="literal">.insert(</span><span class="codestrong">itr</span><span class="literal">,</span> <span class="codestrong">t</span><span class="literal">)</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">Inserts a copy of <span class="codestrong">t</span> just before the element pointed to by <span class="codestrong">itr</span>; <span class="codestrong">v</span>’s range must contain <span class="codestrong">itr</span>.*</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><span class="codestrong">v</span><span class="literal">.push_back(</span><span class="codestrong">t</span><span class="literal">)</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba">Inserts a copy of <span class="codestrong">t</span> at the end of <span class="codestrong">v</span>.*</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><span class="codestrong">v</span><span class="literal">.emplace(</span><span class="codestrong">itr</span><span class="literal">,</span> <span class="codestrong">...</span><span class="literal">)</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">Constructs a <span class="codestrong">T</span> in place by forwarding the arguments <span class="codestrong">...</span> to the appropriate constructor. Element inserted just before the element pointed to by <span class="codestrong">itr</span>.*</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><span class="codestrong">v</span><span class="literal">.emplace_back(</span><span class="codestrong">...</span><span class="literal">)</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba">Constructs a <span class="codestrong">T</span> in place by forwarding the arguments <span class="codestrong">...</span> to the appropriate constructor. Element inserted at the end of <span class="codestrong">v</span>.*</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><span class="codestrong">v1</span><span class="literal">.swap(</span><span class="codestrong">v2</span><span class="literal">)</span></p>&#13;
<p class="taba"><span class="literal">swap(</span><span class="codestrong">v1</span><span class="literal">,</span> <span class="codestrong">v2</span><span class="literal">)</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">Exchanges each element of <span class="codestrong">v1</span> with those of <span class="codestrong">v2</span>.*</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b2"><p class="taba"><span class="codestrong">v1</span> <span class="literal">==</span> <span class="codestrong">v2</span></p>&#13;
<p class="taba"><span class="codestrong">v1</span> <span class="literal">!=</span> <span class="codestrong">v2</span></p>&#13;
<p class="taba"><span class="codestrong">v1</span> <span class="literal">&gt;</span> <span class="codestrong">v2</span></p>&#13;
<p class="taba"><span class="codestrong">v1</span> <span class="literal">&gt;=</span> <span class="codestrong">v2</span></p>&#13;
<p class="taba"><span class="codestrong">v1</span> <span class="literal">&lt;</span> <span class="codestrong">v2</span></p>&#13;
<p class="taba"><span class="codestrong">v1</span> <span class="literal">&lt;=</span> <span class="codestrong">v2</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b2"><p class="taba">Equal if all elements are equal.</p>&#13;
<p class="taba">Greater than/less than comparisons proceed from first element to last.</p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<h4 class="h4" id="ch13lev2sec3"><strong><em>Niche Sequential Containers</em></strong></h4>&#13;
<p class="noindent">The <span class="literal">vector</span> and <span class="literal">array</span> containers are the clear choice in most situations in which you need a sequential data structure. If you know the number of elements you’ll need ahead of time, use an <span class="literal">array</span>. If you don’t, use a <span class="literal">vector</span>.</p>&#13;
<p class="indent">You might find yourself in a niche situation where <span class="literal">vector</span> and <span class="literal">array</span> don’t have the performance characteristics you desire. This section highlights a number of alternative sequential containers that might offer superior performance characteristics in such a situation.</p>&#13;
<h5 class="h5" id="ch13lev3sec12"><span epub:type="pagebreak" id="page_424"/><strong>Deque</strong></h5>&#13;
<p class="noindent">A <em>deque</em> (pronounced “deck”) is a sequential container with fast insert and remove operations from the front and back. Deque is a portmanteau of <strong>d</strong>ouble<em>-</em><strong>e</strong>nded <strong>que</strong>ue. The STL implementation <span class="literal">std::deque</span> is available from the <span class="literal">&lt;deque&gt;</span> header.</p>&#13;
<div class="note">&#13;
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>&#13;
<p class="notep"><em>The Boost Container library also contains a <span class="literal">boost::container::deque</span> in the <span class="literal">&lt;boost/container/deque.hpp&gt;</span> header.</em></p>&#13;
</div>&#13;
<p class="indent">A <span class="literal">vector</span> and a <span class="literal">deque</span> have very similar interfaces, but internally their storage models are totally different. A <span class="literal">vector</span> guarantees that all elements are sequential in memory, whereas a <span class="literal">deque</span>’s memory is usually scattered about, like a hybrid between a <span class="literal">vector</span> and a <span class="literal">list</span>. This makes large resizing operations more efficient and enables fast element insertion/deletion at the container’s front.</p>&#13;
<p class="indent">Constructing and accessing members are identical operations for <span class="literal">vector</span>s and <span class="literal">deque</span>s.</p>&#13;
<p class="indent">Because the internal structure of <span class="literal">deque</span> is complex, it doesn’t expose a <span class="literal">data</span> method. In exchange, you gain access to <span class="literal">push_front</span> and <span class="literal">emplace_front</span>, which mirror the <span class="literal">push_back</span> and <span class="literal">emplace_back</span> that you’re familiar with from <span class="literal">vector</span>. <a href="ch13.xhtml#ch13ex17">Listing 13-17</a> illustrates how to use <span class="literal">push_back</span> and <span class="literal">push_front</span> to insert values into a <span class="literal">deque</span> of <span class="literal">char</span>s.</p>&#13;
<pre>#include &lt;deque&gt;&#13;
&#13;
TEST_CASE("std::deque supports front insertion") {&#13;
  std::deque&lt;char&gt; deckard;&#13;
  deckard.push_front('a'); <span class="ent">➊</span> //  a&#13;
  deckard.push_back('i'); <span class="ent">➋</span> //  ai&#13;
  deckard.push_front('c');   // cai&#13;
  deckard.push_back('n');    // cain&#13;
  REQUIRE(deckard[0] == 'c'); <span class="ent">➌</span>&#13;
  REQUIRE(deckard[1] == 'a');&#13;
  REQUIRE(deckard[2] == 'i');&#13;
  REQUIRE(deckard[3] == 'n');&#13;
}</pre>&#13;
<p class="listing"><a id="ch13ex17"/><em>Listing 13-17: A <span class="literal">deque</span> supports <span class="literal">push_front</span> and <span class="literal">push_back</span>.</em></p>&#13;
<p class="indent">After constructing an empty <span class="literal">deque</span>, you push alternating letters to the front <span class="ent">➊</span> and back <span class="ent">➋</span> of the <span class="literal">deque</span> so it contains the elements <span class="literal">c</span>, <span class="literal">a</span>, <span class="literal">i</span>, and <span class="literal">n</span> <span class="ent">➌</span>.</p>&#13;
<div class="note">&#13;
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>&#13;
<p class="notep"><em>It would be a very bad idea to attempt to extract a string here, for example, <span class="literal">&amp;deckard[0]</span>, because <span class="literal">deque</span> makes no guarantees about internal layout.</em></p>&#13;
</div>&#13;
<p class="indent">The <span class="literal">vector</span> methods not implemented by <span class="literal">deque</span>, along with an explanation for their absence, are as follows:</p>&#13;
<p class="bq"><strong><span class="literal">capacity</span>, <span class="literal">reserve</span></strong> Because the internal structure is complicated, it might not be efficient to compute capacity. Also, <span class="literal">deque</span> allocations are <span epub:type="pagebreak" id="page_425"/>relatively fast because a <span class="literal">deque</span> doesn’t relocate existing elements, so reserving memory ahead of time is unnecessary.</p>&#13;
<p class="bq"><strong><span class="literal">data</span></strong> The elements of <span class="literal">deque</span> are not contiguous.</p>&#13;
<p class="indent"><a href="ch13.xhtml#ch13tab03">Table 13-3</a> summarizes the additional operators offered by a <span class="literal">deque</span> but not by a <span class="literal">vector</span>. In this table, <span class="literal">d</span> is of type <span class="literal">std::deque&lt;T&gt;</span> and <span class="literal">t</span> is of type <span class="literal">T</span>. An asterisk (*) indicates that this operation invalidates iterators to <span class="literal">v</span>’s elements in at least some circumstances. (Pointers to existing elements remain valid.)</p>&#13;
<p class="tabcap"><a id="ch13tab03"/><strong>Table 13-3:</strong> A Partial List of <span class="literal">std::deque</span> Operations</p>&#13;
<table class="topbot-d">&#13;
<colgroup>&#13;
<col style="width:30%"/>&#13;
<col style="width:70%"/>&#13;
</colgroup>&#13;
<tbody>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-h"><p class="tab_th"><strong>Operation</strong></p></td>&#13;
<td style="vertical-align: top;" class="table-h"><p class="tab_th"><strong>Notes</strong></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><span class="codestrong">d</span><span class="literal">.emplace_front(</span><span class="codestrong">...</span><span class="literal">)</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">Constructs an element in place at the front of the <span class="codestrong">d</span> by forwarding all arguments to the appropriate constructor.*</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><span class="codestrong">d</span><span class="literal">.push_front(</span><span class="codestrong">t</span><span class="literal">)</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba">Constructs an element in place at the front of the <span class="codestrong">d</span> by copying <span class="codestrong">t</span>.*</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-ba"><p class="taba"><span class="codestrong">d</span><span class="literal">.pop_front()</span></p></td>&#13;
<td style="vertical-align: top;" class="table-ba"><p class="taba">Removes the element at the front of <span class="codestrong">d</span>.*</p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<h3 class="h3" id="ch13lev1sec2"><strong>List</strong></h3>&#13;
<p class="noindent">A <em>list</em> is a sequence container with fast insert/remove operations everywhere but with no random element access. The STL implementation <span class="literal">std::list</span> is available from the <span class="literal">&lt;list&gt;</span> header.</p>&#13;
<div class="note">&#13;
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>&#13;
<p class="notep"><em>The Boost Container library also contains a <span class="literal">boost::container::list</span> in the <span class="literal">&lt;boost/container/list.hpp&gt;</span> header.</em></p>&#13;
</div>&#13;
<p class="indent">The <span class="literal">list</span> is implemented as a doubly linked list, a data structure composed of <em>nodes</em>. Each node contains an element, a forward link (“flink”), and a backward link (“blink”). This is completely different from a <span class="literal">vector</span>, which stores elements in contiguous memory. As a result, you cannot use <span class="literal">operator[]</span> or <span class="literal">at</span> to access arbitrary elements in a <span class="literal">list</span>, because such operations would be very inefficient. (These methods are simply not available in <span class="literal">list</span> because of their horrible performance characteristics.) The trade-off is that inserting and removing elements in a <span class="literal">list</span> is much faster. All you need to update are the flinks and blinks of an element’s neighbors rather than shuffling potentially large, contiguous element ranges.</p>&#13;
<p class="indent">The <span class="literal">list</span> container supports the same constructor patterns as <span class="literal">vector</span>.</p>&#13;
<p class="indent">You can perform special operations on lists, such as splicing elements from one list into another using the <span class="literal">splice</span> method, removing consecutive duplicate elements using the <span class="literal">unique</span> method, and even sorting the elements of a container using the <span class="literal">sort</span> method. Consider, for example, the <span class="literal">remove_if</span> method. The <span class="literal">remove_if</span> method accepts a function object as a parameter, and it traverses the <span class="literal">list</span> while invoking the function object on each element. If the result is <span class="literal">true</span>, <span class="literal">remove_if</span> removes the element. <a href="ch13.xhtml#ch13ex18">Listing 13-18</a> illustrates how to use the <span class="literal">remove_if</span> method to eliminate all the even numbers of a <span class="literal">list</span> with a lambda predicate.</p>&#13;
<pre><span epub:type="pagebreak" id="page_426"/>#include &lt;list&gt;&#13;
&#13;
TEST_CASE("std::list supports front insertion") {&#13;
  std::list&lt;int&gt; odds{ 11, 22, 33, 44, 55 }; <span class="ent">➊</span>&#13;
  odds.remove_if([](int x) { return x % 2 == 0; }); <span class="ent">➋</span>&#13;
  auto odds_iter = odds.begin(); <span class="ent">➌</span>&#13;
  REQUIRE(*odds_iter == 11); <span class="ent">➍</span>&#13;
  ++odds_iter; <span class="ent">➎</span>&#13;
  REQUIRE(*odds_iter == 33);&#13;
  ++odds_iter;&#13;
  REQUIRE(*odds_iter == 55);&#13;
  ++odds_iter;&#13;
  REQUIRE(odds_iter == odds.end()); <span class="ent">➏</span>&#13;
}</pre>&#13;
<p class="listing"><a id="ch13ex18"/><em>Listing 13-18: A <span class="literal">list</span> supports <span class="literal">remove_if</span>.</em></p>&#13;
<p class="indent">Here, you use braced initialization to fill a <span class="literal">list</span> of <span class="literal">int</span> objects <span class="ent">➊</span>. Next, you use the <span class="literal">remove_if</span> method to remove all the even numbers <span class="ent">➋</span>. Because only even numbers modulo 2 equal zero, this lambda tests whether a number is even. To establish that <span class="literal">remove_if</span> has extracted the even elements 22 and 44, you create an iterator pointing at the beginning of the list <span class="ent">➌</span>, check its value <span class="ent">➍</span>, and increment <span class="ent">➎</span> until you reach the end of the list <span class="ent">➏</span>.</p>&#13;
<p class="indent">All the <span class="literal">vector</span> methods not implemented by <span class="literal">list</span>, along with an explanation for their absence, are as follows:</p>&#13;
<p class="bq"><strong><span class="literal">capacity</span>, <span class="literal">reserve</span>, <span class="literal">shrink_to_fit</span></strong> Because <span class="literal">list</span> acquires memory incrementally, it doesn’t require periodic resizing.</p>&#13;
<p class="bq"><strong><span class="literal">operator[]</span>, <span class="literal">at</span></strong> Random element access is prohibitively expensive on <span class="literal">list</span>s.</p>&#13;
<p class="bq"><strong><span class="literal">data</span></strong> Unneeded because <span class="literal">list</span> elements are not contiguous.</p>&#13;
<p class="indent"><a href="ch13.xhtml#ch13tab04">Table 13-4</a> summarizes the additional operators offered by a <span class="literal">list</span> but not by a <span class="literal">vector</span>. In this table, <span class="literal">lst</span>, <span class="literal">lst1</span>, and <span class="literal">lst2</span> are of type <span class="literal">std::list&lt;T&gt;</span>, and <span class="literal">t</span> is of type <span class="literal">T</span>. The arguments <span class="literal">itr1</span>, <span class="literal">itr2a</span>, and <span class="literal">itr2b</span> are <span class="literal">list</span> iterators. An asterisk (*) indicates that the operation invalidates iterators to <span class="literal">v</span>’s elements in at least some circumstances. (Pointers to existing elements remain valid.)</p>&#13;
<p class="tabcap"><a id="ch13tab04"/><strong>Table 13-4:</strong> A Partial List of <span class="literal">std::list</span> Operations</p>&#13;
<table class="topbot-d">&#13;
<colgroup>&#13;
<col style="width:30%"/>&#13;
<col style="width:70%"/>&#13;
</colgroup>&#13;
<tbody>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-h"><p class="tab_th"><strong>Operation</strong></p></td>&#13;
<td style="vertical-align: top;" class="table-h"><p class="tab_th"><strong>Notes</strong></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><span class="codestrong">lst</span><span class="literal">.emplace_front(</span><span class="codestrong">...</span><span class="literal">)</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">Constructs an element in place at the front of the <span class="literal">d</span> by forwarding all arguments to the appropriate constructor.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><span class="codestrong">lst</span><span class="literal">.push_front(</span><span class="codestrong">t</span><span class="literal">)</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba">Constructs an element in place at the front of <span class="codestrong">d</span> by copying <span class="codestrong">t</span>.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><span class="codestrong">lst</span><span class="literal">.pop_front()</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">Removes the element at the front of <span class="codestrong">d</span>.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><span class="codestrong">lst</span><span class="literal">.push_back(</span><span class="codestrong">t</span><span class="literal">)</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba">Constructs an element in place at the back of <span class="codestrong">d</span> by copying <span class="codestrong">t</span>.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><span class="codestrong">lst</span><span class="literal">.pop_back()</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">Removes the element at the back of <span class="codestrong">d</span>.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><span class="codestrong">lst1</span><span class="literal">.splice(</span><span class="codestrong">itr1</span><span class="literal">,</span><span class="codestrong">lst2</span><span class="literal">,</span> <span class="codestrong">[itr2a]</span><span class="literal">, </span><span class="codestrong">[itr2b]</span><span class="literal">)</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba">Transfers items from <span class="codestrong">lst2</span> into <span class="codestrong">lst1</span> at position <span class="codestrong">itr1</span>. Optionally, only transfer the element at <span class="codestrong">itr2a</span> or the elements within the half-open range <span class="codestrong">itr2a</span> to <span class="codestrong">itr2b</span>.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><span epub:type="pagebreak" id="page_427"/><p class="taba"><span class="codestrong">lst</span><span class="literal">.remove(</span><span class="codestrong">t</span><span class="literal">)</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">Removes all elements in <span class="codestrong">lst</span> equal to <span class="codestrong">t</span>.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><span class="codestrong">lst</span><span class="literal">.remove_if(</span><span class="codestrong">pred</span><span class="literal">)</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba">Eliminates elements in <span class="codestrong">lst</span> where <span class="codestrong">pred</span> returns true; <span class="codestrong">pred</span> accepts a single <span class="codestrong">T</span> argument.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><span class="codestrong">lst</span><span class="literal">.unique(</span><span class="codestrong">pred</span><span class="literal">)</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">Eliminates duplicate consecutive elements in <span class="codestrong">lst</span> according to the function object <span class="codestrong">pred</span>, which accepts two <span class="codestrong">T</span> arguments and returns <span class="codestrong">t1</span>  <span class="literal">==</span>  <span class="codestrong">t2</span>.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><span class="codestrong">lst1</span><span class="literal">.merge(</span><span class="codestrong">lst2</span><span class="literal">,</span> <span class="codestrong">comp</span><span class="literal">)</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba">Merges <span class="codestrong">lst1</span> and <span class="codestrong">lst2</span> according to the function object <span class="codestrong">comp</span>, which accepts two <span class="codestrong">T</span> arguments and returns <span class="codestrong">t1</span>  <span class="literal">&lt;</span>  <span class="codestrong">t2</span>.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><span class="codestrong">lst</span><span class="literal">.sort(</span><span class="codestrong">comp</span><span class="literal">)</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">Sorts <span class="codestrong">lst</span> according to the function object <span class="codestrong">comp</span>.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b2"><p class="taba"><span class="codestrong">lst</span><span class="literal">.reverse()</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b2"><p class="taba">Reverses the order of <span class="codestrong">lst</span>’s elements (mutates <span class="codestrong">lst</span>).</p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<div class="note">&#13;
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>&#13;
<p class="notep"><em>The STL also offers a <span class="literal">std::forward_list</span> in the <span class="literal">&lt;forward_list&gt;</span> header, which is a singly linked list that only allows iteration in one direction. The <span class="literal">forward_list</span> is slightly more efficient than <span class="literal">list</span>, and it’s optimized for situations in which you need to store very few (or no) elements.</em></p>&#13;
</div>&#13;
<h5 class="h5" id="ch13lev3sec13"><strong>Stacks</strong></h5>&#13;
<p class="noindent">The STL provides three <em>container adapters</em> that encapsulate other STL containers and expose special interfaces for tailored situations. The adapters are the stack, the queue, and the priority queue.</p>&#13;
<p class="indent">A <em>stack</em> is a data structure with two fundamental operations: push and pop. When you <em>push</em> an element onto a stack, you insert the element onto the stack’s end. When you <em>pop</em> an element off a stack, you remove the element from the stack’s end. This arrangement is called <em>last-in</em>, <em>first-out</em>: the last element to be pushed onto a stack is the first to be popped off.</p>&#13;
<p class="indent">The STL offers the <span class="literal">std::stack</span> in the <span class="literal">&lt;stack&gt;</span> header. The class template <span class="literal">stack</span> takes two template parameters. The first is the underlying type of the wrapped container, such as <span class="literal">int</span>, and the second is the type of the wrapped container, such as <span class="literal">deque</span> or <span class="literal">vector</span>. This second argument is optional and defaults to <span class="literal">deque</span>.</p>&#13;
<p class="indent">To construct a <span class="literal">stack</span>, you can pass a reference to a <span class="literal">deque</span>, a <span class="literal">vector</span>, or a <span class="literal">list</span> to encapsulate. This way, the <span class="literal">stack</span> translates its operations, such as <span class="literal">push</span> and <span class="literal">pop</span>, into methods that the underlying container understands, like <span class="literal">push_back</span> and <span class="literal">pop_back</span>. If you provide no constructor argument, the <span class="literal">stack</span> uses a <span class="literal">deque</span> by default. The second template parameter must match this container’s type.</p>&#13;
<p class="indent">To obtain a reference to the element on top of a <span class="literal">stack</span>, you use the <span class="literal">top</span> method.</p>&#13;
<p class="indent"><a href="ch13.xhtml#ch13ex19">Listing 13-19</a> illustrates how to use a <span class="literal">stack</span> to wrap a <span class="literal">vector</span>.</p>&#13;
<pre>#include &lt;stack&gt;&#13;
&#13;
TEST_CASE("std::stack supports push/pop/top operations") {&#13;
  std::vector&lt;int&gt; vec{ 1, 3 }; <span class="ent">➊</span>  // 1 3&#13;
<span epub:type="pagebreak" id="page_428"/>  std::stack&lt;int, decltype(vec)&gt; easy_as(vec); <span class="ent">➋</span>&#13;
  REQUIRE(easy_as.top() == 3); <span class="ent">➌</span>&#13;
  easy_as.pop(); <span class="ent">➍</span>                 // 1&#13;
  easy_as.push(2); <span class="ent">➎</span>               // 1 2&#13;
  REQUIRE(easy_as.top() == 2); <span class="ent">➏</span>&#13;
  easy_as.pop();                 // 1&#13;
  REQUIRE(easy_as.top() == 1);&#13;
  easy_as.pop();                 //&#13;
  REQUIRE(easy_as.empty()); <span class="ent">➐</span>&#13;
}</pre>&#13;
<p class="listing"><a id="ch13ex19"/><em>Listing 13-19: Using a <span class="literal">stack</span> to wrap a <span class="literal">vector</span></em></p>&#13;
<p class="indent">You construct a <span class="literal">vector</span> of <span class="literal">int</span>s called <span class="literal">vec</span> containing the elements 1 and 3 <span class="ent">➊</span>. Next, you pass <span class="literal">vec</span> into the constructor of a new <span class="literal">stack</span>, making sure to supply the second template parameter <span class="literal">decltype(vec)</span> <span class="ent">➋</span>. The top element in <span class="literal">stack</span> is now 3, because this is the last element in <span class="literal">vec</span> <span class="ent">➌</span>. After the first <span class="literal">pop</span> <span class="ent">➍</span>, you push a new element 2 onto the <span class="literal">stack</span> <span class="ent">➎</span>. Now, the <span class="literal">top</span> element is 2 <span class="ent">➏</span>. After another <span class="literal">pop</span>-<span class="literal">top</span>-<span class="literal">pop</span> series, the <span class="literal">stack</span> is empty <span class="ent">➐</span>.</p>&#13;
<p class="indent"><a href="ch13.xhtml#ch13tab05">Table 13-5</a> summarizes the operations of <span class="literal">stack</span>. In this table, <span class="literal">s</span>, <span class="literal">s1</span>, and <span class="literal">s2</span> are of type <span class="literal">std::stack&lt;T&gt;</span>; <span class="literal">t</span> is of type <span class="literal">T</span>; and <span class="literal">ctr</span> is a container of type <span class="literal">ctr_type&lt;T&gt;</span>.</p>&#13;
<p class="tabcap"><a id="ch13tab05"/><strong>Table 13-5:</strong> A Summary of <span class="literal">std::stack</span> Operations</p>&#13;
<table class="topbot-d">&#13;
<colgroup>&#13;
<col style="width:30%"/>&#13;
<col style="width:70%"/>&#13;
</colgroup>&#13;
<tbody>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-h"><p class="tab_th"><strong>Operation</strong></p></td>&#13;
<td style="vertical-align: top;" class="table-h"><p class="tab_th"><strong>Notes</strong></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><span class="literal">stack&lt;</span><span class="codestrong">T,</span> <span class="literal">[</span><span class="codestrong">ctr_type</span><span class="codestrong">&lt;T&gt;</span><span class="literal">]&gt;([</span><span class="codestrong">ctr</span><span class="literal">])</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">Constructs a <span class="codestrong">stack</span> of <span class="codestrong">T</span>s using <span class="codestrong">ctr</span> as its internal container reference. If no container is provided, constructs an empty <span class="codestrong">deque</span>.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><span class="codestrong">s</span><span class="literal">.empty()</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba">Returns <span class="literal">true</span> if container is empty.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><span class="codestrong">s</span><span class="literal">.size()</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">Returns number of elements in container.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><span class="codestrong">s</span><span class="literal">.top()</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba">Returns a reference to the element on top of the <span class="literal">stack</span>.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><span class="codestrong">s</span><span class="literal">.push(t)</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">Puts a copy of <span class="codestrong">t</span> onto the end of the container.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><span class="codestrong">s</span><span class="literal">.emplace(</span><span class="codestrong">...</span><span class="literal">)</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba">Constructs a <span class="codestrong">T</span> in place by forwarding <span class="codestrong">...</span> to the appropriate constructor.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><span class="codestrong">s</span><span class="literal">.pop()</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">Removes the element at the end of the container.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b2"><p class="taba"><span class="codestrong">s1</span><span class="literal">.swap(</span><span class="codestrong">s2</span><span class="literal">)</span></p>&#13;
<p class="taba"><span class="literal">swap(</span><span class="codestrong">s1</span><span class="literal">,</span> <span class="codestrong">s2</span><span class="literal">)</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b2"><p class="taba">Exchanges the contents of <span class="codestrong">s2</span> with <span class="codestrong">s1</span>.</p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<h3 class="h3" id="ch13lev1sec3"><strong>Queues</strong></h3>&#13;
<p class="noindent">A <em>queue</em> is a data structure that, like a stack, has push and pop as its fundamental operations. Unlike a stack, a queue is <em>first-in</em>, <em>first-out</em>. When you push an element into a queue, you insert onto the queue’s end. When you pop an element off the queue, you remove from the queue’s beginning. This way, the element that has been in the queue the longest is the one to get popped off.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_429"/>The STL offers the <span class="literal">std::queue</span> in the <span class="literal">&lt;queue&gt;</span> header. Like <span class="literal">stack</span>, <span class="literal">queue</span> takes two template parameters. The first parameter is the underlying type of the wrapped container, and the optional second parameter is the type of the wrapped container, which also defaults to <span class="literal">deque</span>.</p>&#13;
<p class="indent">Among STL containers, you can only use <span class="literal">deque</span> or <span class="literal">list</span> as the underlying container for a <span class="literal">queue</span>, because pushing and popping from the front of a <span class="literal">vector</span> is inefficient.</p>&#13;
<p class="indent">You can access the element at the front or back of a queue using the <span class="literal">front</span> and <span class="literal">back</span> methods.</p>&#13;
<p class="indent"><a href="ch13.xhtml#ch13ex20">Listing 13-20</a> shows how to use a <span class="literal">queue</span> to wrap a <span class="literal">deque</span>.</p>&#13;
<pre>#include &lt;queue&gt;&#13;
&#13;
TEST_CASE("std::queue supports push/pop/front/back") {&#13;
  std::deque&lt;int&gt; deq{ 1, 2 }; <span class="ent">➊</span>&#13;
  std::queue&lt;int&gt; easy_as(deq); <span class="ent">➋</span> // 1 2&#13;
&#13;
  REQUIRE(easy_as.front() == 1); <span class="ent">➌</span>&#13;
  REQUIRE(easy_as.back() == 2); <span class="ent">➍</span>&#13;
  easy_as.pop(); <span class="ent">➎</span>                // 2&#13;
  easy_as.push(3); <span class="ent">➏</span>              // 2 3&#13;
  REQUIRE(easy_as.front() == 2); <span class="ent">➐</span>&#13;
  REQUIRE(easy_as.back() == 3); <span class="ent">➑</span>&#13;
  easy_as.pop();                   // 3&#13;
  REQUIRE(easy_as.front() == 3);&#13;
  easy_as.pop();                   //&#13;
  REQUIRE(easy_as.empty()); <span class="ent">➒</span>&#13;
}</pre>&#13;
<p class="listing"><a id="ch13ex20"/><em>Listing 13-20: Using a <span class="literal">queue</span> to wrap a <span class="literal">deque</span></em></p>&#13;
<p class="indent">You start with a <span class="literal">deque</span> containing the elements 1 and 2 <span class="ent">➊</span>, which you pass into a queue called <span class="literal">easy_as</span> <span class="ent">➋</span>. Using the <span class="literal">front</span> and <span class="literal">back</span> methods, you can validate that the queue begins with a 1 <span class="ent">➌</span> and ends with a 2 <span class="ent">➍</span>. When you <span class="literal">pop</span> the first element, 1, you’re left with a queue containing just the single element 2 <span class="ent">➎</span>. You then <span class="literal">push</span> 3 <span class="ent">➏</span>, so the method <span class="literal">front</span> yields 2 <span class="ent">➐</span> and <span class="literal">back</span> yields 3 <span class="ent">➑</span>. After two more iterations of <span class="literal">pop</span>-<span class="literal">front</span>, you’re left with an empty <span class="literal">queue</span> <span class="ent">➒</span>.</p>&#13;
<p class="indent"><a href="ch13.xhtml#ch13tab06">Table 13-6</a> summarizes the operations of <span class="literal">queue</span>. In this table, <span class="literal">q</span>, <span class="literal">q1</span>, and <span class="literal">q2</span> are of type <span class="literal">std::queue&lt;T&gt;</span>; <span class="literal">t</span> is of type <span class="literal">T</span>; and <span class="literal">ctr</span> is a container of type <span class="literal">ctr_type&lt;T&gt;</span>.</p>&#13;
<p class="tabcap"><a id="ch13tab06"/><strong>Table 13-6:</strong> A Summary of <span class="literal">std::queue</span> Operations</p>&#13;
<table class="topbot-d">&#13;
<colgroup>&#13;
<col style="width:30%"/>&#13;
<col style="width:70%"/>&#13;
</colgroup>&#13;
<tbody>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-h"><p class="tab_th"><strong>Operation</strong></p></td>&#13;
<td style="vertical-align: top;" class="table-h"><p class="tab_th"><strong>Notes</strong></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><span class="literal">queue&lt;</span><span class="codestrong">T</span><span class="literal">, [</span><span class="codestrong">ctr_type&lt;T&gt;</span><span class="literal">]&gt;([</span><span class="codestrong">ctr</span><span class="literal">])</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">Constructs a <span class="codestrong">queue</span> of <span class="codestrong">T</span>s using <span class="codestrong">ctr</span> as its internal container. If no container is provided, constructs an empty <span class="literal">deque</span>.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><span class="codestrong">q</span><span class="literal">.empty()</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba">Returns <span class="literal">true</span> if container is empty.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><span class="codestrong">q</span><span class="literal">.size()</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">Returns number of elements in container.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b"><span epub:type="pagebreak" id="page_430"/><p class="taba"><span class="codestrong">q</span><span class="literal">.front()</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba">Returns a reference to the element in front of the <span class="literal">queue</span>.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><span class="codestrong">q</span><span class="literal">.back()</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">Returns a reference to the element in back of the <span class="literal">queue</span>.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><span class="codestrong">q</span><span class="literal">.push(</span><span class="codestrong">t</span><span class="literal">)</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba">Puts a copy of <span class="codestrong">t</span> onto the end of the container.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><span class="codestrong">q</span><span class="literal">.emplace(</span><span class="codestrong">...</span><span class="literal">)</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">Constructs a <span class="codestrong">T</span> in place by forwarding <span class="codestrong">...</span> to the appropriate constructor.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><span class="codestrong">q</span><span class="literal">.pop()</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba">Removes the element at the front of the container.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-ba"><p class="taba"><span class="codestrong">q1</span><span class="literal">.swap(</span><span class="codestrong">q2</span><span class="literal">)</span>&#13;
<br/><span class="literal">swap(</span><span class="codestrong">q1</span><span class="literal">,</span> <span class="codestrong">q2</span><span class="literal">)</span></p></td>&#13;
<td style="vertical-align: top;" class="table-ba"><p class="taba">Exchanges the contents of <span class="codestrong">q2</span> with <span class="codestrong">q1</span>.</p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<h3 class="h3" id="ch13lev1sec4"><strong>Priority Queues (Heaps)</strong></h3>&#13;
<p class="noindent">A <em>priority queue</em> (also called a heap) is a data structure that supports <span class="literal">push</span> and <span class="literal">pop</span> operations and keeps elements sorted according to some user-specified <em>comparator object</em>. The comparator object is a function object invokable with two parameters, returning <span class="literal">true</span> if the first argument is less than the second. When you <span class="literal">pop</span> an element from a priority queue, you remove the element that is greatest, according to the comparator object.</p>&#13;
<p class="indent">The STL offers the <span class="literal">std::priority_queue</span> in the <span class="literal">&lt;queue&gt;</span> header. A <span class="literal">priority_queue</span> has three template parameters:</p>&#13;
<ul>&#13;
<li class="noindent">The underlying type of the wrapped container</li>&#13;
<li class="noindent">The type of the wrapped container</li>&#13;
<li class="noindent">The type of the comparator object</li>&#13;
</ul>&#13;
<p class="indent">Only the underlying type is mandatory. The wrapped container type defaults to <span class="literal">vector</span> (probably because it’s the most widely used sequential container), and the comparator object type defaults to <span class="literal">std::less</span>.</p>&#13;
<div class="note">&#13;
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>&#13;
<p class="notep"><em>The <span class="literal">std::less</span> class template is available from the <span class="literal">&lt;functional&gt;</span> header, and it returns <span class="literal">true</span> if the first argument is less than the second.</em></p>&#13;
</div>&#13;
<p class="indent">The <span class="literal">priority_queue</span> has an identical interface to a <span class="literal">stack</span>. The only difference is that stacks <span class="literal">pop</span> elements according to the last-in, first-out arrangement, whereas priority queues <span class="literal">pop</span> elements according to the comparator object criteria.</p>&#13;
<p class="indent"><a href="ch13.xhtml#ch13ex21">Listing 13-21</a> illustrates the basic usage of <span class="literal">priority_queue</span>.</p>&#13;
<pre>#include &lt;queue&gt;&#13;
&#13;
TEST_CASE("std::priority_queue supports push/pop") {&#13;
  std::priority_queue&lt;double&gt; prique; <span class="ent">➊</span>&#13;
  prique.push(1.0); // 1.0&#13;
  prique.push(2.0); // 2.0 1.0&#13;
  prique.push(1.5); // 2.0 1.5 1.0&#13;
<span epub:type="pagebreak" id="page_431"/>&#13;
  REQUIRE(prique.top() == Approx(2.0)); <span class="ent">➋</span>&#13;
  prique.pop();     // 1.5 1.0&#13;
  prique.push(1.0); // 1.5 1.0 1.0&#13;
  REQUIRE(prique.top() == Approx(1.5)); <span class="ent">➌</span>&#13;
  prique.pop();     // 1.0 1.0&#13;
  REQUIRE(prique.top() == Approx(1.0)); <span class="ent">➍</span>&#13;
  prique.pop();     // 1.0&#13;
  REQUIRE(prique.top() == Approx(1.0)); <span class="ent">➎</span>&#13;
  prique.pop();     //&#13;
  REQUIRE(prique.empty()); <span class="ent">➏</span>&#13;
}</pre>&#13;
<p class="listing"><a id="ch13ex21"/><em>Listing 13-21: Basic <span class="literal">priority_queue</span> usage</em></p>&#13;
<p class="indent">Here, you default construct a <span class="literal">priority_queue</span> <span class="ent">➊</span>, which internally initializes an empty <span class="literal">vector</span> to hold its elements. You push the elements 1.0, 2.0, and 1.5 into the <span class="literal">priority_queue</span>, which sorts the elements in descending order so the container represents them in the order 2.0 1.5 1.0.</p>&#13;
<p class="indent">You assert that <span class="literal">top</span> yields 2.0 <span class="ent">➋</span>, pop this element off the <span class="literal">priority_queue</span>, and then invoke <span class="literal">push</span> with the new element 1.0. The container now represents them in the order 1.5 <span class="ent">➌</span> 1.0 <span class="ent">➍</span> 1.0 <span class="ent">➎</span>, which you verify with a series of <span class="literal">top</span>-<span class="literal">pop</span> operations until the container is empty <span class="ent">➏</span>.</p>&#13;
<div class="note">&#13;
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>&#13;
<p class="notep"><em>A <span class="literal">priority_queue</span> holds its elements in a tree structure, so if you peered into its underlying container, the memory ordering wouldn’t match the orders implied by <a href="ch13.xhtml#ch13ex21">Listing 13-21</a>.</em></p>&#13;
</div>&#13;
<p class="indent"><a href="ch13.xhtml#ch13tab07">Table 13-7</a> summarizes the operations of <span class="literal">priority_queue</span>. In this table, <span class="literal">pq</span>, <span class="literal">pq1</span>, and <span class="literal">pq2</span> are of type <span class="literal">std::priority_queue&lt;T&gt;</span>; <span class="literal">t</span> is of type <span class="literal">T</span>; <span class="literal">ctr</span> is a container of type <span class="literal">ctr_type&lt;T&gt;</span>; and <span class="literal">srt</span> is a container of type <span class="literal">srt_type&lt;T&gt;</span>.</p>&#13;
<p class="tabcap"><a id="ch13tab07"/><strong>Table 13-7:</strong> A Summary of <span class="literal">std::priority_queue</span> Operations</p>&#13;
<table class="topbot-d">&#13;
<colgroup>&#13;
<col style="width:30%"/>&#13;
<col style="width:70%"/>&#13;
</colgroup>&#13;
<tbody>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-h"><p class="tab_th"><strong>Operation</strong></p></td>&#13;
<td style="vertical-align: top;" class="table-h"><p class="tab_th"><strong>Notes</strong></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><span class="literal">priority_queue &lt;</span><span class="codestrong">T</span><span class="literal">,</span> <span class="literal">[</span><span class="codestrong">ctr_type&lt;T&gt;</span><span class="literal">],</span> <span class="literal">[</span><span class="codestrong">cmp_type</span><span class="literal">]&gt;([</span><span class="codestrong">cmp</span><span class="literal">], [</span><span class="codestrong">ctr</span><span class="literal">])</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">Constructs a <span class="literal">priority_queue</span> of <span class="codestrong">T</span>s using <span class="codestrong">ctr</span> as its internal container and <span class="codestrong">srt</span> as its comparator object. If no container is provided, constructs an empty <span class="literal">deque</span>. Uses <span class="literal">std::less</span> as default sorter.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><span class="codestrong">pq</span><span class="literal">.empty()</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba">Returns <span class="literal">true</span> if container is empty.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><span class="codestrong">pq</span><span class="literal">.size()</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">Returns number of elements in container.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><span class="codestrong">pq</span><span class="literal">.top()</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba">Returns a reference to the greatest element in the container.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><span class="codestrong">pq</span><span class="literal">.push(</span><span class="codestrong">t</span><span class="literal">)</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">Puts a copy of <span class="codestrong">t</span> onto the end of the container.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><span class="codestrong">pq</span><span class="literal">.emplace(</span><span class="codestrong">...</span><span class="literal">)</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba">Constructs a <span class="codestrong">T</span> in place by forwarding <span class="codestrong">...</span> to the appropriate constructor.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><span class="codestrong">pq</span><span class="literal">.pop()</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">Removes the element at the end of the container.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b2"><p class="taba"><span class="codestrong">pq1</span><span class="literal">.swap(</span><span class="codestrong">pq2</span><span class="literal">)<br/>swap(</span><span class="codestrong">pq1</span><span class="literal">,</span> <span class="codestrong">pq2</span><span class="literal">)</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b2"><p class="taba">Exchanges the contents of <span class="codestrong">s2</span> with <span class="codestrong">s1</span>.</p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<h3 class="h3" id="ch13lev1sec5"><span epub:type="pagebreak" id="page_432"/><strong>Bitsets</strong></h3>&#13;
<p class="noindent">A <em>bitset</em> is a data structure that stores a fixed-size bit sequence. You can manipulate each bit.</p>&#13;
<p class="indent">The STL offers the <span class="literal">std::bitset</span> in the <span class="literal">&lt;bitset&gt;</span> header. The class template <span class="literal">bitset</span> takes a single template parameter corresponding to the desired size. You could achieve similar functionality using a <span class="literal">bool array</span>, but <span class="literal">bitset</span> is optimized for space efficiency and provides some special convenience operations.</p>&#13;
<div class="note">&#13;
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>&#13;
<p class="notep"><em>The STL specializes <span class="literal">std::vector&lt;bool&gt;</span>, so it might benefit from the same space efficiencies as <span class="literal">bitset</span>. (Recall from “Template Specialization” on <a href="ch06.xhtml#page_178">page 178</a> that template specialization is the process of making certain kinds of template instantiations more efficient.) Boost offers <span class="literal">boost::dynamic_bitset</span>, which provides dynamic sizing at runtime.</em></p>&#13;
</div>&#13;
<p class="indent">A default constructed <span class="literal">bitset</span> contains all zero (false) bits. To initialize bitsets with other contents, you can provide an <span class="literal">unsigned long long</span> value. This integer’s bitwise representation sets the value of <span class="literal">bitset</span>. You can access individual bits in the <span class="literal">bitset</span> using <span class="literal">operator[]</span>. <a href="ch13.xhtml#ch13ex22">Listing 13-22</a> demonstrates how to initialize a <span class="literal">bitset</span> with an integer literal and extract its elements.</p>&#13;
<pre>#include &lt;bitset&gt;&#13;
&#13;
TEST_CASE("std::bitset supports integer initialization") {&#13;
  std::bitset&lt;4&gt; bs(0b1010); <span class="ent">➊</span>&#13;
  REQUIRE_FALSE(bs[0]); <span class="ent">➋</span>&#13;
  REQUIRE(bs[1]); <span class="ent">➌</span>&#13;
  REQUIRE_FALSE(bs[2]); <span class="ent">➍</span>&#13;
  REQUIRE(bs[3]); <span class="ent">➎</span>&#13;
}</pre>&#13;
<p class="listing"><a id="ch13ex22"/><em>Listing 13-22: Initializing a <span class="literal">bitset</span> with an integer</em></p>&#13;
<p class="indent">You initialize a <span class="literal">bitset</span> with the 4-bit <em>nybble</em> <span class="literal">0101</span> <span class="ent">➊</span>. So, the first <span class="ent">➋</span> and third <span class="ent">➍</span> elements are zero, and the second <span class="ent">➌</span> and fourth <span class="ent">➎</span> elements are 1.</p>&#13;
<p class="indent">You can also provide a string representation of the desired <span class="literal">bitset</span>, as shown in <a href="ch13.xhtml#ch13ex23">Listing 13-23</a>.</p>&#13;
<pre>TEST_CASE("std::bitset supports string initialization") {&#13;
  std::bitset&lt;4&gt; bs1(0b0110); <span class="ent">➊</span>&#13;
  std::bitset&lt;4&gt; bs2("0110"); <span class="ent">➋</span>&#13;
  REQUIRE(bs1 == bs2); <span class="ent">➌</span>&#13;
}</pre>&#13;
<p class="listing"><a id="ch13ex23"/><em>Listing 13-23: Initializing a <span class="literal">bitset</span> with a string</em></p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_433"/>Here, you construct a <span class="literal">bitset</span> called <span class="literal">bs1</span> using the same integer nybble <span class="literal">0b0110</span> <span class="ent">➊</span> and another <span class="literal">bitset</span> called <span class="literal">bs2</span> using the string literal <span class="literal">0110</span> <span class="ent">➋</span>. Both of these initialization approaches produce identical <span class="literal">bitset</span> objects <span class="ent">➌</span>.</p>&#13;
<p class="indent"><a href="ch13.xhtml#ch13tab08">Table 13-8</a> summarizes the operations of <span class="literal">bitset</span>. In this table, <span class="literal">bs</span>, <span class="literal">bs 1</span>, and <span class="literal">bs 2</span> are of type <span class="literal">std::bitset&lt;N&gt;</span>, and <span class="literal">i</span> is a <span class="literal">size_t</span>.</p>&#13;
<p class="tabcap"><a id="ch13tab08"/><strong>Table 13-8:</strong> A Summary of <span class="literal">std::bitset</span> Operations</p>&#13;
<table class="topbot-d">&#13;
<colgroup>&#13;
<col style="width:30%"/>&#13;
<col style="width:70%"/>&#13;
</colgroup>&#13;
<tbody>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-h"><p class="tab_th"><strong>Operation</strong></p></td>&#13;
<td style="vertical-align: top;" class="table-h"><p class="tab_th"><strong>Notes</strong></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><span class="literal">bitset&lt;</span><span class="codestrong">N</span><span class="literal">&gt;([</span><span class="codestrong">val</span><span class="literal">])</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">Constructs a <span class="literal">bitset</span> with initial value <span class="codestrong">val</span>, which can be either a string of <span class="codestrong">0</span>s and <span class="codestrong">1</span>s or an <span class="literal">unsigned long long</span>. Default constructor initializes all bits to zero.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><span class="codestrong">bs</span><span class="literal">[</span><span class="codestrong">i</span><span class="literal">]</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba">Returns the value of the <span class="codestrong">i</span>-th bit: 1 returns true; 0 returns false.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><span class="codestrong">bs</span><span class="literal">.test(</span><span class="codestrong">i</span><span class="literal">)</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">Returns the value of the <span class="codestrong">i</span>-th bit: 1 returns true; 0 returns false. Performs bounds checking; throws <span class="literal">std::out_of_range</span>.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><span class="codestrong">bs</span><span class="literal">.set()</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba">Sets all bits to 1.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><span class="codestrong">bs</span><span class="literal">.set(</span><span class="codestrong">i</span><span class="literal">,</span> <span class="codestrong">val</span><span class="literal">)</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">Sets the <span class="codestrong">i</span>-th bit to <span class="codestrong">val</span>. Performs bounds checking; throws <span class="literal">std::out_of_range</span>.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><span class="codestrong">bs</span><span class="literal">.reset()</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba">Sets all bits to 0.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><span class="codestrong">bs</span><span class="literal">.reset(</span><span class="codestrong">i</span><span class="literal">)</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">Sets the <span class="codestrong">i</span>-th bit to zero. Performs bounds checking; throws <span class="literal">std::out_of_range</span>.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><span class="codestrong">bs</span><span class="literal">.flip()</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba">Flips all the bits: (0 becomes 1; 1 becomes 0).</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><span class="codestrong">bs</span><span class="literal">.flip(</span><span class="codestrong">i</span><span class="literal">)</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">Flips the <span class="codestrong">i</span>-th bit. Performs bounds checking; throws <span class="literal">std::out_of_range</span>.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><span class="codestrong">bs</span><span class="literal">.count()</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba">Returns the number of bits set to 1.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><span class="codestrong">bs</span><span class="literal">.size()</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">Returns the size <span class="codestrong">N</span> of the bitset.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><span class="codestrong">bs</span><span class="literal">.any()</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba">Returns <span class="literal">true</span> if any bits are set to 1.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><span class="codestrong">bs</span><span class="literal">.none()</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">Returns <span class="literal">true</span> if all bits are set to 0.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><span class="codestrong">bs</span><span class="literal">.all()</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba">Returns <span class="literal">true</span> if all bits are set to 1.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><span class="codestrong">bs</span><span class="literal">.to_string()</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">Returns the <span class="literal">string</span> representation of the <span class="codestrong">bitset</span>.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><span class="codestrong">bs</span><span class="literal">.to_ulong()</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba">Returns the <span class="literal">unsigned long</span> representation of the <span class="codestrong">bitset</span>.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-ba"><p class="taba"><span class="codestrong">bs</span><span class="literal">.to_ullong()</span></p></td>&#13;
<td style="vertical-align: top;" class="table-ba"><p class="taba">Returns the <span class="literal">unsigned long long</span> representation of the <span class="codestrong">bitset</span>.</p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<h3 class="h3" id="ch13lev1sec6"><strong>Special Sequential Boost Containers</strong></h3>&#13;
<p class="noindent">Boost provides an abundance of special containers, and there simply isn’t enough room to explore all their features here. <a href="ch13.xhtml#ch13tab09">Table 13-9</a> provides the names, headers, and brief descriptions of a number of them.</p>&#13;
<div class="note">&#13;
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>&#13;
<p class="notep"><em>Refer to the Boost Container documentation for more information.</em></p>&#13;
</div>&#13;
<p class="tabcap"><span epub:type="pagebreak" id="page_434"/><a id="ch13tab09"/><strong>Table 13-9:</strong> Special Boost Containers</p>&#13;
<table class="topbot-d">&#13;
<colgroup>&#13;
<col style="width:30%"/>&#13;
<col style="width:70%"/>&#13;
</colgroup>&#13;
<tbody>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-h"><p class="tab_th"><strong>Class/Header</strong></p></td>&#13;
<td style="vertical-align: top;" class="table-h"><p class="tab_th"><strong>Description</strong></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><span class="literal">boost::intrusive::*</span></p>&#13;
<p class="taba"><span class="literal">&lt;boost/intrusive/*.hpp&gt;</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">Intrusive containers impose requirements on the elements they contain (such as inheriting from a particular base class). In exchange, they offer substantial performance gains.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><span class="literal">boost::container::stable_vector</span></p>&#13;
<p class="taba"><span class="literal">&lt;boost/container/stable_vector.hpp&gt;</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba">A vector without contiguous elements but guarantees that iterators and references to elements remain valid as long as the element isn’t erased (as with <span class="literal">list</span>).</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><span class="literal">boost::container::slist</span></p>&#13;
<p class="taba"><span class="literal">&lt;boost/container/slist.hpp&gt;</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">A <span class="literal">forward_list</span> with a fast <span class="literal">size</span> method.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><span class="literal">boost::container::static_vector</span></p>&#13;
<p class="taba"><span class="literal">&lt;boost/container/static_vector.hpp&gt;</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba">A hybrid between array and vector that stores a dynamic number of elements up to a fixed size. Elements are stored within the memory of <span class="literal">stable_vector</span>, like an <span class="literal">array</span>.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><span class="literal">boost::container::small_vector</span></p>&#13;
<p class="taba"><span class="literal">&lt;boost/container/small_vector.hpp&gt;</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">A <span class="literal">vector</span>-like container optimized for holding a small number of elements. Contains some preallocated space, avoiding dynamic allocation.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><span class="literal">boost::circular_buffer</span></p>&#13;
<p class="taba"><span class="literal">&lt;boost/circular_buffer.hpp&gt;</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba">A fixed-capacity, queue-like container that fills elements in a circular fashion; a new element overwrites the oldest element once capacity is reached.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><span class="literal">boost::multi_array</span></p>&#13;
<p class="taba"><span class="literal">&lt;boost/multi_array.hpp&gt;</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">An array-like container that accepts multiple dimensions. Rather than having, for example, an array of arrays of arrays, you can specify a three-dimensional <span class="literal">multi_array</span> <span class="codestrong">x</span> that allows element access, such as <span class="codestrong">x</span><span class="literal">[5][1][2]</span>.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b2"><p class="taba"><span class="literal">boost::ptr_vector</span></p>&#13;
<p class="taba"><span class="literal">boost::ptr_list</span></p>&#13;
<p class="taba"><span class="literal">&lt;boost/ptr_container/*.hpp&gt;</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b2"><p class="taba">Having a collection of smart pointers can be suboptimal. Pointer vectors manage a collection of dynamic objects in a more efficient and user-friendly way.</p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<div class="note">&#13;
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>&#13;
<p class="notep"><em>Boost Intrusive also contains some specialized containers that provide performance benefits in certain situations. These are primarily useful for library implementers.</em></p>&#13;
</div>&#13;
<h3 class="h3" id="ch13lev1sec7"><strong>Associative Containers</strong></h3>&#13;
<p class="noindent"><em>Associative containers</em> allow for very fast element search. Sequential containers have some natural ordering that allows you to iterate from the beginning of the container to the end in a well-specified order. Associative containers are a bit different. This container family splits along three axes:</p>&#13;
<ul>&#13;
<li class="noindent">Whether elements contain keys (a set) or key-value pairs (a map)</li>&#13;
<li class="noindent">Whether elements are ordered</li>&#13;
<li class="noindent">Whether keys are <em>unique</em></li>&#13;
</ul>&#13;
<h4 class="h4" id="ch13lev2sec4"><strong><em><span epub:type="pagebreak" id="page_435"/>Sets</em></strong></h4>&#13;
<p class="noindent">The <span class="literal">std::set</span> available in the STL’s <span class="literal">&lt;set&gt;</span> header is an associative container that contains sorted, unique elements called <em>keys</em>. Because <span class="literal">set</span> stores sorted elements, you can insert, remove, and search efficiently. In addition, <span class="literal">set</span> supports sorted iteration over its elements, and you have complete control over how keys sort using comparator objects.</p>&#13;
<div class="note">&#13;
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>&#13;
<p class="notep"><em>Boost also provides a <span class="literal">boost::container::set</span> in the <span class="literal">&lt;boost/container/set.hpp&gt;</span> header.</em></p>&#13;
</div>&#13;
<h5 class="h5" id="ch13lev3sec14"><strong>Constructing</strong></h5>&#13;
<p class="noindent">The class template <span class="literal">set&lt;T, Comparator, Allocator&gt;</span> takes three template parameters:</p>&#13;
<ul>&#13;
<li class="noindent">The key type <span class="literal">T</span></li>&#13;
<li class="noindent">The comparator type that defaults to <span class="literal">std::less</span></li>&#13;
<li class="noindent">The allocator type that defaults to <span class="literal">std::allocator&lt;T&gt;</span></li>&#13;
</ul>&#13;
<p class="indent">You have a lot of flexibility when constructing <span class="literal">set</span>s. Each of the following constructors accepts an optional comparator and allocator (whose types must match their corresponding template parameters):</p>&#13;
<ul>&#13;
<li class="noindent">A default constructor that initializes an empty <span class="literal">set</span></li>&#13;
<li class="noindent">Move and copy constructors with the usual behavior</li>&#13;
<li class="noindent">A range constructor that copies the elements from the range into the set</li>&#13;
<li class="noindent">A braced initializer</li>&#13;
</ul>&#13;
<p class="indent"><a href="ch13.xhtml#ch13ex24">Listing 13-24</a> showcases each of these constructors.</p>&#13;
<pre>#include &lt;set&gt;&#13;
&#13;
TEST_CASE("std::set supports") {&#13;
  std::set&lt;int&gt; emp; <span class="ent">➊</span>&#13;
  std::set&lt;int&gt; fib{ 1, 1, 2, 3, 5 }; <span class="ent">➋</span>&#13;
  SECTION("default construction") {&#13;
    REQUIRE(emp.empty()); <span class="ent">➌</span>&#13;
  }&#13;
  SECTION("braced initialization") {&#13;
    REQUIRE(fib.size() == 4); <span class="ent">➍</span>&#13;
  }&#13;
  SECTION("copy construction") {&#13;
    auto fib_copy(fib);&#13;
    REQUIRE(fib.size() == 4); <span class="ent">➎</span>&#13;
    REQUIRE(fib_copy.size() == 4); <span class="ent">➏</span>&#13;
  }&#13;
  SECTION("move construction") {&#13;
    auto fib_moved(std::move(fib));&#13;
    REQUIRE(fib.empty()); <span class="ent">➐</span>&#13;
    REQUIRE(fib_moved.size() == 4); <span class="ent">➑</span>&#13;
<span epub:type="pagebreak" id="page_436"/>  }&#13;
  SECTION("range construction") {&#13;
    std::array&lt;int, 5&gt; fib_array{ 1, 1, 2, 3, 5 };&#13;
    std::set&lt;int&gt; fib_set(fib_array.cbegin(), fib_array.cend());&#13;
    REQUIRE(fib_set.size() == 4); <span class="ent">➒</span>&#13;
  }&#13;
}</pre>&#13;
<p class="listing"><a id="ch13ex24"/><em>Listing 13-24: The constructors of a <span class="literal">set</span></em></p>&#13;
<p class="indent">You default construct <span class="ent">➊</span> and brace initialize <span class="ent">➋</span> two different <span class="literal">set</span>s. The default constructed <span class="literal">set</span> called <span class="literal">emp</span> is empty <span class="ent">➌</span>, and the braced initialized <span class="literal">set</span> called <span class="literal">fib</span> has four elements <span class="ent">➍</span>. You include five elements in the braced initializer, so why only four elements? Recall that <span class="literal">set</span> elements are unique, so the 1 enters only once.</p>&#13;
<p class="indent">Next, you copy construct <span class="literal">fib</span>, which results in two <span class="literal">set</span>s with size 4 <span class="ent">➎ ➏</span>. On the other hand, the move constructor empties the moved-from set <span class="ent">➐</span> and transfers the elements to the new <span class="literal">set</span> <span class="ent">➑</span>.</p>&#13;
<p class="indent">Then you can initialize a <span class="literal">set</span> from a range. You construct an <span class="literal">array</span> with five elements and then pass it as a range to a <span class="literal">set</span> constructor using the <span class="literal">cbegin</span> and <span class="literal">cend</span> methods. As with the braced initialization earlier in the code, the <span class="literal">set</span> contains only four elements because duplicates are discarded <span class="ent">➒</span>.</p>&#13;
<h5 class="h5" id="ch13lev3sec15"><strong>Move and Copy Semantics</strong></h5>&#13;
<p class="noindent">In addition to move/copy constructors, move/copy assignment operators are also available. As with other container copy operations, <span class="literal">set</span> copies are potentially very slow because each element needs to get copied, and move operations are usually fast because elements reside in dynamic memory. A <span class="literal">set</span> can simply pass ownership without disturbing the elements.</p>&#13;
<h5 class="h5" id="ch13lev3sec16"><strong>Element Access</strong></h5>&#13;
<p class="noindent">You have several options for extracting elements from a <span class="literal">set</span>. The basic method is <span class="literal">find</span>, which takes a <span class="literal">const</span> reference to a key and returns an iterator. If the <span class="literal">set</span> contains an element-matching key, <span class="literal">find</span> will return an iterator pointing to the found element. If the <span class="literal">set</span> does not, it will return an iterator pointing to <span class="literal">end</span>. The <span class="literal">lower_bound</span> method returns an iterator to the first element <em>not less than</em> the key argument, whereas the <span class="literal">upper_bound</span> method returns the first element <em>greater than</em> the given key.</p>&#13;
<p class="indent">The <span class="literal">set</span> class supports two additional lookup methods, mainly for compatibility of non-unique associative containers:</p>&#13;
<ul>&#13;
<li class="noindent">The <span class="literal">count</span> method returns the number of elements matching the key. Because <span class="literal">set</span> elements are unique, <span class="literal">count</span> returns either 0 or 1.</li>&#13;
<li class="noindent">The <span class="literal">equal_range</span> method returns a half-open range containing all the elements matching the given key. The range returns a <span class="literal">std::pair</span> of iterators with <span class="literal">first</span> pointing to the matching element and <span class="literal">second</span> pointing to <span epub:type="pagebreak" id="page_437"/>the element after <span class="literal">first</span>. If <span class="literal">equal_range</span> finds no matching element, <span class="literal">first</span> and <span class="literal">second</span> both point to the first element greater than the given key. In other words, the pair returned by <span class="literal">equal_range</span> is equivalent to a <span class="literal">pair</span> of <span class="literal">lower_bound</span> as <span class="literal">first</span> and <span class="literal">upper_bound</span> as <span class="literal">second</span>.</li>&#13;
</ul>&#13;
<p class="indent"><a href="ch13.xhtml#ch13ex25">Listing 13-25</a> illustrates these two access methods.</p>&#13;
<pre>TEST_CASE("std::set allows access") {&#13;
  std::set&lt;int&gt; fib{ 1, 1, 2, 3, 5 }; <span class="ent">➊</span>&#13;
  SECTION("with find") { <span class="ent">➋</span>&#13;
    REQUIRE(*fib.find(3) == 3);&#13;
    REQUIRE(fib.find(100) == fib.end());&#13;
  }&#13;
  SECTION("with count") { <span class="ent">➌</span>&#13;
    REQUIRE(fib.count(3) == 1);&#13;
    REQUIRE(fib.count(100) == 0);&#13;
  }&#13;
  SECTION("with lower_bound") { <span class="ent">➍</span>&#13;
    auto itr = fib.lower_bound(3);&#13;
    REQUIRE(*itr == 3);&#13;
  }&#13;
  SECTION("with upper_bound") { <span class="ent">➎</span>&#13;
    auto itr = fib.upper_bound(3);&#13;
    REQUIRE(*itr == 5);&#13;
  }&#13;
  SECTION("with equal_range") { <span class="ent">➏</span>&#13;
    auto pair_itr = fib.equal_range(3);&#13;
    REQUIRE(*pair_itr.first == 3);&#13;
    REQUIRE(*pair_itr.second == 5);&#13;
  }&#13;
}</pre>&#13;
<p class="listing"><a id="ch13ex25"/><em>Listing 13-25: A <span class="literal">set</span> member access</em></p>&#13;
<p class="indent">First, you construct a <span class="literal">set</span> with the four elements 1 2 3 5 <span class="ent">➊</span>. Using <span class="literal">find</span>, you can extract an iterator to the element 3. You can also determine that 8 isn’t in the <span class="literal">set</span>, because <span class="literal">find</span> returns an iterator pointing to <span class="literal">end</span> <span class="ent">➋</span>. You can determine similar information with <span class="literal">count</span>, which returns 1 when you give the key 3 and 0 when you give the key 8 <span class="ent">➌</span>. When you pass 3 to the <span class="literal">lower_bound</span> method, it returns an iterator pointing to 3 because this is the first element that’s not less than the argument <span class="ent">➍</span>. When you pass this to <span class="literal">upper_bound</span>, on the other hand, you obtain a pointer to the element 5, because this is the first element greater than the argument <span class="ent">➎</span>. Finally, when you pass 3 to the <span class="literal">equal_range</span> method, you obtain a <span class="literal">pair</span> of iterators. The <span class="literal">first</span> iterator points to 3, and the <span class="literal">second</span> iterator points to 5, the element just after 3 <span class="ent">➏</span>.</p>&#13;
<p class="indent">A <span class="literal">set</span> also exposes iterators through its <span class="literal">begin</span> and <span class="literal">end</span> methods, so you can use range-based <span class="literal">for</span> loops to iterate through the <span class="literal">set</span> from least element to greatest.</p>&#13;
<h3 class="h3" id="ch13lev1sec8"><span epub:type="pagebreak" id="page_438"/><strong>Adding Elements</strong></h3>&#13;
<p class="noindent">You have three options when adding elements to a <span class="literal">set</span>:</p>&#13;
<ul>&#13;
<li class="noindent"><span class="literal">insert</span> to copy an existing element into the <span class="literal">set</span></li>&#13;
<li class="noindent"><span class="literal">emplace</span> to in-place construct a new element into the <span class="literal">set</span></li>&#13;
<li class="noindent"><span class="literal">emplace_hint</span> to in-place construct a new element, just like <span class="literal">emplace</span> (because adding an element requires sorting). The difference is the <span class="literal">emplace_hint</span> method takes an iterator as its first argument. This iterator is the search’s starting point (a hint). If the iterator is close to the correct position for the newly inserted element, this can provide a substantial speedup. <p class="indent"><a href="ch13.xhtml#ch13ex26">Listing 13-26</a> illustrates the several ways to insert elements into a <span class="literal">set</span>.</p></li>&#13;
</ul>&#13;
<pre>TEST_CASE("std::set allows insertion") {&#13;
  std::set&lt;int&gt; fib{ 1, 1, 2, 3, 5 };&#13;
  SECTION("with insert") { <span class="ent">➊</span>&#13;
    fib.insert(8);&#13;
    REQUIRE(fib.find(8) != fib.end());&#13;
  }&#13;
  SECTION("with emplace") { <span class="ent">➋</span>&#13;
    fib.emplace(8);&#13;
    REQUIRE(fib.find(8) != fib.end());&#13;
  }&#13;
  SECTION("with emplace_hint") { <span class="ent">➌</span>&#13;
    fib.emplace_hint(fib.end(), 8);&#13;
    REQUIRE(fib.find(8) != fib.end());&#13;
  }&#13;
}</pre>&#13;
<p class="listing"><a id="ch13ex26"/><em>Listing 13-26: Inserting into a <span class="literal">set</span></em></p>&#13;
<p class="indent">Both <span class="literal">insert</span> <span class="ent">➊</span> and <span class="literal">emplace</span> <span class="ent">➋</span> add the element 8 into <span class="literal">fib</span>, so when you invoke <span class="literal">find</span> with 8, you get an iterator pointing to the new element. You can achieve the same effect a bit more efficiently with <span class="literal">emplace_hint</span> <span class="ent">➌</span>. Because you know ahead of time that the new element 8 is greater than all the other elements in the <span class="literal">set</span>, you can use <span class="literal">end</span> as the hint.</p>&#13;
<p class="indent">If you attempt to <span class="literal">insert</span>, <span class="literal">emplace</span>, or <span class="literal">emplace_hint</span> a key that’s already present in the <span class="literal">set</span>, the operation has no effect. All three of these methods return a <span class="literal">std::pair&lt;Iterator, bool&gt;</span> where the <span class="literal">second</span> element indicates whether the operation resulted in insertion (<span class="literal">true</span>) or not (<span class="literal">false</span>). The iterator at <span class="literal">first</span> points to either the newly inserted element or the existing element that prevented insertion.</p>&#13;
<h5 class="h5" id="ch13lev3sec17"><strong>Removing Elements</strong></h5>&#13;
<p class="noindent">You can remove elements from a set using <span class="literal">erase</span>, which is overloaded to accept a key, an iterator, or a half-open range, as shown in <a href="ch13.xhtml#ch13ex27">Listing 13-27</a>.</p>&#13;
<pre>TEST_CASE("std::set allows removal") {&#13;
  std::set&lt;int&gt; fib{ 1, 1, 2, 3, 5 };&#13;
  SECTION("with erase") { <span class="ent">➊</span>&#13;
<span epub:type="pagebreak" id="page_439"/>    fib.erase(3);&#13;
    REQUIRE(fib.find(3) == fib.end());&#13;
  }&#13;
  SECTION("with clear") { <span class="ent">➋</span>&#13;
    fib.clear();&#13;
    REQUIRE(fib.empty());&#13;
  }&#13;
}</pre>&#13;
<p class="listing"><a id="ch13ex27"/><em>Listing 13-27: Removing from a <span class="literal">set</span></em></p>&#13;
<p class="indent">In the first test, you call <span class="literal">erase</span> with the key 3, which removes the corresponding element from the <span class="literal">set</span>. When you invoke <span class="literal">find</span> on 3, you get an iterator pointing to the <span class="literal">end</span>, indicating that no matching element was found <span class="ent">➊</span>. In the second test, you invoke <span class="literal">clear</span>, which eliminates all the elements from the <span class="literal">set</span> <span class="ent">➋</span>.</p>&#13;
<h5 class="h5" id="ch13lev3sec18"><strong>Storage Model</strong></h5>&#13;
<p class="noindent">Set operations are fast because sets are typically implemented as <em>red-black trees</em>. These structures treat each element as a node. Each node has one parent and up to two children, its left and right legs. Each node’s children are sorted so all children to the left are less than the children to the right. This way, you can perform searches much quicker than with linear iteration, as long as a tree’s branches are roughly balanced (equal in length). Red-black trees have additional facilities for rebalancing branches after insertions and deletions.</p>&#13;
<div class="note">&#13;
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>&#13;
<p class="notep"><em>For details on red-black trees, refer to <em>Data Structures and Algorithms in C++</em> by Adam Drozdek.</em></p>&#13;
</div>&#13;
<h5 class="h5" id="ch13lev3sec19"><strong>A Partial List of Supported Operations</strong></h5>&#13;
<p class="noindent"><a href="ch13.xhtml#ch13tab10">Table 13-10</a> summarizes the operations of <span class="literal">set</span>. Operations <span class="literal">s</span>, <span class="literal">s1</span>, and <span class="literal">s2</span> are of type <span class="literal">std::set&lt;T,[cmp_type&lt;T&gt;]&gt;</span>. <span class="literal">T</span> is the contained element/key type, and <span class="literal">itr</span>, <span class="literal">beg</span>, and <span class="literal">end</span> are <span class="literal">set</span> iterators. The variable <span class="literal">t</span> is a <span class="literal">T</span>. A dagger ()denotes a method that returns a <span class="literal">std::pair&lt;Iterator, bool&gt;</span>, where the iterator points to the resulting element and the <span class="literal">bool</span> equals <span class="literal">true</span> if the method inserted an element and <span class="literal">false</span> if the element already existed.</p>&#13;
<p class="tabcap"><a id="ch13tab10"/><strong>Table 13-10:</strong> A Summary of <span class="literal">std::set</span></p>&#13;
<table class="topbot-d">&#13;
<colgroup>&#13;
<col style="width:30%"/>&#13;
<col style="width:70%"/>&#13;
</colgroup>&#13;
<tbody>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-h"><p class="tab_th"><strong>Operation</strong></p></td>&#13;
<td style="vertical-align: top;" class="table-h"><p class="tab_th"><strong>Notes</strong></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><span class="literal">set&lt;</span><span class="codestrong">T</span><span class="literal">&gt;{</span> <span class="codestrong">...</span><span class="literal">, [</span><span class="codestrong">cmp</span><span class="literal">], [</span><span class="codestrong">alc</span><span class="literal">] }</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">Performs braced initialization of a newly constructed set. Uses <span class="codestrong">cmp</span><span class="literal">=std::less&lt;</span><span class="codestrong">T</span><span class="literal">&gt;</span> and <span class="codestrong">alc</span><span class="literal">=std::allocator&lt;</span><span class="codestrong">T</span><span class="literal">&gt;</span> by default.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><span class="literal">set&lt;</span><span class="codestrong">T</span><span class="literal">&gt;{</span> <span class="codestrong">beg</span><span class="literal">,</span> <span class="codestrong">end</span><span class="literal">,</span> <span class="literal">[</span><span class="codestrong">cmp</span><span class="literal">], [</span><span class="codestrong">alc</span><span class="literal">] }</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba">Range constructor that copies elements from the half-open range <span class="codestrong">beg</span> to <span class="codestrong">end</span>. Uses <span class="codestrong">cmp</span><span class="literal">=std::less&lt;</span><span class="codestrong">T</span><span class="literal">&gt;</span> and <span class="codestrong">alc</span><span class="literal">=std::allocator&lt;</span><span class="codestrong">T</span><span class="literal">&gt;</span> by default.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><span class="literal">set</span><span class="literal">&lt;</span><span class="codestrong">T</span><span class="literal">&gt;(</span><span class="codestrong">s</span><span class="literal">)</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">Deep copy of <span class="codestrong">s</span>; allocates new memory.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><span epub:type="pagebreak" id="page_440"/><span class="literal">set&lt;</span><span class="codestrong">T</span><span class="literal">&gt;(move(</span><span class="codestrong">s</span><span class="literal">))</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba">Takes ownership of memory; elements in <span class="codestrong">s</span>. No allocations.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><span class="literal">~set</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">Destructs all elements contained by the set and releases dynamic memory.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><span class="codestrong">s1</span> <span class="literal">=</span> <span class="codestrong">s2</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><span class="codestrong">s1</span> destructs its elements; copies each <span class="codestrong">s2</span> element. Only allocates if it needs to resize to fit <span class="codestrong">s2</span>’s elements.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><span class="codestrong">s1</span> <span class="literal">= move(</span><span class="codestrong">s2</span><span class="literal">)</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><span class="codestrong">s1</span> destructs its elements; moves each <span class="codestrong">s2</span> element. Only allocates if it needs to resize to fit <span class="codestrong">s2</span>’s elements.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><span class="codestrong">s</span><span class="literal">.begin()</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba">Returns an iterator pointing to the first element.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><span class="codestrong">s</span><span class="literal">.cbegin()</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">Returns a <span class="literal">const</span> iterator pointing to the first element.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><span class="codestrong">s</span><span class="literal">.end()</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba">Returns an iterator pointing to 1 past the last element.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><span class="codestrong">s</span><span class="literal">.cend()</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">Returns a <span class="literal">const</span> iterator pointing to 1 past the last element.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><span class="codestrong">s</span><span class="literal">.find(</span><span class="codestrong">t</span><span class="literal">)</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba">Returns an iterator pointing to the element matching <span class="codestrong">t</span> or <span class="codestrong">s</span>.<span class="literal">end()</span> if no such element exists.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><span class="codestrong">s</span><span class="literal">.count(</span><span class="codestrong">t</span><span class="literal">)</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">Returns 1 if set contains <span class="codestrong">t</span>; otherwise 0.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><span class="codestrong">s</span><span class="literal">.equal_range(</span><span class="codestrong">t</span><span class="literal">)</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba">Returns a <span class="literal">pair</span> of iterators corresponding to the half-open range of elements matching <span class="codestrong">t</span>.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><span class="codestrong">s</span><span class="literal">.lower_bound(</span><span class="codestrong">t</span><span class="literal">)</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">Returns an iterator pointing to the first element not less than <span class="codestrong">t</span> or <span class="codestrong">s</span>.<span class="literal">end()</span> if no such element exists.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><span class="codestrong">s</span><span class="literal">.upper_bound(</span><span class="codestrong">t</span><span class="literal">)</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba">Returns an iterator pointing to the first element greater than <span class="codestrong">t</span> or <span class="codestrong">s</span>.<span class="literal">end()</span> if no such element exists.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><span class="codestrong">s</span><span class="literal">.clear()</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">Removes all elements from the set.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><span class="codestrong">s</span><span class="literal">.erase(</span><span class="codestrong">t</span><span class="literal">)</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba">Removes the element equal to <span class="codestrong">t</span>.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><span class="codestrong">s</span><span class="literal">.erase(</span><span class="codestrong">itr</span><span class="literal">)</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">Removes the element pointed to by <span class="codestrong">itr</span>.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><span class="codestrong">s</span><span class="literal">.erase(</span><span class="codestrong">beg</span><span class="literal">,</span> <span class="codestrong">end</span><span class="literal">)</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba">Removes all elements on the half-open range from <span class="codestrong">beg</span> to <span class="codestrong">end</span>.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><span class="codestrong">s</span><span class="literal">.insert(</span><span class="codestrong">t</span><span class="literal">)</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">Inserts a copy of <span class="codestrong">t</span> into the set.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><span class="codestrong">s</span><span class="literal">.emplace(</span><span class="codestrong">...</span><span class="literal">)</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba">Constructs a <span class="codestrong">T</span> in place by forwarding the arguments <span class="codestrong">...</span>.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><span class="codestrong">s</span><span class="literal">.emplace_hint(</span><span class="codestrong">itr</span><span class="literal">,</span> <span class="codestrong">...</span><span class="literal">)</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">Constructs a <span class="codestrong">T</span> in place by forwarding the arguments <span class="codestrong">...</span>. Uses <span class="codestrong">itr</span> as a hint for where to insert the new element.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><span class="codestrong">s</span><span class="literal">.empty()</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba">Returns <span class="literal">true</span> if set’s size is zero; otherwise <span class="literal">false</span>.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><span class="codestrong">s</span><span class="literal">.size()</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">Returns the number of elements in the set.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><span class="codestrong">s</span><span class="literal">.max_size()</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba">Returns the maximum number of elements in the set.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><span class="codestrong">s</span><span class="literal">.extract(</span><span class="codestrong">t</span><span class="literal">)</span></p>&#13;
<p class="taba"><span class="codestrong">s</span><span class="literal">.extract(</span><span class="codestrong">itr</span><span class="literal">)</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">Obtains a node handle that owns the element matching <span class="codestrong">t</span> or pointed to by <span class="codestrong">itr</span>. (This is the only way to remove a move-only element.)</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><span class="codestrong">s1</span><span class="literal">.merge(</span><span class="codestrong">s2</span><span class="literal">)</span></p>&#13;
<p class="taba"><span class="codestrong">s1</span><span class="literal">.merge(move(</span><span class="codestrong">s2</span><span class="literal">))</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba">Splices each element of <span class="codestrong">s2</span> into <span class="codestrong">s1</span>. If argument is an rvalue, will move the elements into <span class="codestrong">s1</span>.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-ba"><p class="taba"><span class="codestrong">s1</span><span class="literal">.swap(</span><span class="codestrong">s2</span><span class="literal">)</span></p>&#13;
<p class="taba"><span class="literal">swap(</span><span class="codestrong">s1</span><span class="literal">,</span> <span class="codestrong">s2</span><span class="literal">)</span></p></td>&#13;
<td style="vertical-align: top;" class="table-ba"><p class="taba">Exchanges each element of <span class="codestrong">s1</span> with those of <span class="codestrong">s2</span>.</p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<h5 class="h5" id="ch13lev3sec20"><span epub:type="pagebreak" id="page_441"/><strong>Multisets</strong></h5>&#13;
<p class="noindent">The <span class="literal">std::multiset</span> available in the STL’s <span class="literal">&lt;set&gt;</span> header is an associative container that contains sorted, <em>non-unique</em> keys. A <span class="literal">multiset</span> supports the same operations as a <span class="literal">set</span>, but it will store redundant elements. This has important ramifications for two methods:</p>&#13;
<ul>&#13;
<li class="noindent">The method <span class="literal">count</span> can return values other than 0 or 1. The <span class="literal">count</span> method of <span class="literal">multiset</span> will tell you how many elements matched the given key.</li>&#13;
<li class="noindent">The method <span class="literal">equal_range</span> can return half-open ranges containing more than one element. The <span class="literal">equal_range</span> method of <span class="literal">multiset</span> will return a range containing all the elements matching the given key.</li>&#13;
</ul>&#13;
<p class="indent">You might want to use a <span class="literal">multiset</span> rather than a <span class="literal">set</span> if it’s important that you store multiple elements with the same key. For example, you could store all of an address’s occupants by treating the address as a key and each member of the house as an element. If you used a <span class="literal">set</span>, you’d be stuck having only a single occupant.</p><p class="indent"><a href="ch13.xhtml#ch13ex28">Listing 13-28</a> illustrates using a <span class="literal">multiset</span>.</p>&#13;
<pre>TEST_CASE("std::multiset handles non-unique elements") {&#13;
  std::multiset&lt;int&gt; fib{ 1, 1, 2, 3, 5 };&#13;
  SECTION("as reflected by size") {&#13;
    REQUIRE(fib.size() == 5); <span class="ent">➊</span>&#13;
  }&#13;
  SECTION("and count returns values greater than 1") {&#13;
    REQUIRE(fib.count(1) == 2); <span class="ent">➋</span>&#13;
  }&#13;
  SECTION("and equal_range returns non-trivial ranges") {&#13;
    auto [begin, end] = fib.equal_range(1); <span class="ent">➌</span>&#13;
    REQUIRE(*begin == 1); <span class="ent">➍</span>&#13;
    ++begin;&#13;
    REQUIRE(*begin == 1); <span class="ent">➎</span>&#13;
    ++begin;&#13;
    REQUIRE(begin == end); <span class="ent">➏</span>&#13;
  }&#13;
}</pre>&#13;
<p class="listing"><a id="ch13ex28"/><em>Listing 13-28: Accessing <span class="literal">multiset</span> elements</em></p>&#13;
<p class="indent">Unlike <span class="literal">set</span> in <a href="ch13.xhtml#ch13ex24">Listing 13-24</a>, <span class="literal">multiset</span> permits multiple 1s, so size returns 5, the number of elements you provided in the braced initializers <span class="ent">➊</span>. When you count the number of 1s, you get 2 <span class="ent">➋</span>. You can use <span class="literal">equal_range</span> to iterate over these elements. Using structured binding syntax, you obtain a <span class="literal">begin</span> and <span class="literal">end</span> iterator <span class="ent">➌</span>. You iterate over the two 1s <span class="ent">➍ ➎</span> and arrive at the end of the half-open range <span class="ent">➏</span>.</p>&#13;
<p class="indent">Every operation in <a href="ch13.xhtml#ch13tab10">Table 13-10</a> works for <span class="literal">multiset</span>.</p>&#13;
<div class="note">&#13;
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>&#13;
<p class="notep"><em>Boost also provides a <span class="literal">boost::container::multiset</span> in the <span class="literal">&lt;boost/container/set.hpp&gt;</span> header.</em></p>&#13;
</div>&#13;
<h4 class="h4" id="ch13lev2sec5"><strong><em><span epub:type="pagebreak" id="page_442"/>Unordered Sets</em></strong></h4>&#13;
<p class="noindent">The <span class="literal">std::unordered_set</span> available in the STL’s <span class="literal">&lt;unordered_set&gt;</span> header is an associative container that contains <em>unsorted</em>, unique keys. The <span class="literal">unordered_set</span> supports most of the same operations as <span class="literal">set</span> and <span class="literal">multiset</span>, but its internal storage model is completely different.</p>&#13;
<div class="note">&#13;
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>&#13;
<p class="notep"><em>Boost also provides a <span class="literal">boost::unordered_set</span> in the <span class="literal">&lt;boost/unordered_set.hpp&gt;</span> header.</em></p>&#13;
</div>&#13;
<p class="indent">Rather than using a comparator to sort elements into a red-black tree, an <span class="literal">unordered_set</span> is usually implemented as a hash table. You might want to use an <span class="literal">unordered_set</span> in a situation in which there is no natural ordering among the keys and you don’t need to iterate through the collection in such an order. You might find that in many situations, you could use either a <span class="literal">set</span> or an <span class="literal">unordered_set</span>. Although they appear quite similar, their internal representations are fundamentally different, so they’ll have different performance characteristics. If performance is an issue, measure how both perform and use the one that’s more appropriate.</p>&#13;
<h5 class="h5" id="ch13lev3sec21"><strong>Storage Model: Hash Tables</strong></h5>&#13;
<p class="noindent">A hash function, or a <em>hasher</em>, is a function that accepts a key and returns a unique <span class="literal">size_t</span> value called a hash code. The <span class="literal">unordered_set</span> organizes its elements into a hash table, which associates a hash code with a collection of one or more elements called a <em>bucket</em>. To find an element, an <span class="literal">unordered_set</span> computes its hash code and then searches through the corresponding bucket in the hash table.</p>&#13;
<p class="indent">If you’ve never seen a hash table before, this information might be a lot to take in, so let’s look at an example. Imagine you had a large group of people that you needed to sort into some kind of sensible groups to find an individual easily. You could group people by birthday, which would give you 365 groups (well, 366 if you count February 29 for leap years). The birthday is like a hash function that returns one of 365 values for each person. Each value forms a bucket, and all people in the same bucket have the same birthday. In this example, to find a person, you first determine their birthday, which gives you the correct bucket. Then you can search through the bucket to find the person you’re looking for.</p>&#13;
<p class="indent">As long as the hash function is quick and there aren’t too many elements per bucket, <span class="literal">unordered_set</span>s have even more impressive performance than their ordered counterparts: the contained element count doesn’t increase insertion, search, and deletion times. When two different keys have the same hash code, it’s called a <em>hash collision</em>. When you have a hash collision, it means that the two keys will reside in the same bucket. In the preceding birthday example, many people will have the same birthday, so there will be a lot of hash collisions. The more hash collisions there are, the larger the buckets will be, and the more time you’ll spend searching through a bucket for the correct element.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_443"/>A hash function has several requirements:</p>&#13;
<ul>&#13;
<li class="noindent">It accepts a <span class="literal">Key</span> and returns a <span class="literal">size_t</span> hash code.</li>&#13;
<li class="noindent">It doesn’t throw exceptions.</li>&#13;
<li class="noindent">Equal keys yield equal hash codes.</li>&#13;
<li class="noindent">Unequal keys yield unequal hash codes with high probability. (There is a low probability of a hash collision.)</li>&#13;
</ul>&#13;
<p class="indent">The STL provides the hasher class template <span class="literal">std::hash&lt;T&gt;</span> in the <span class="literal">&lt;functional&gt;</span> header, which contains specializations for fundamental types, enumeration types, pointer types, <span class="literal">optional</span>, <span class="literal">variant</span>, smart pointers, and more. As an example, <a href="ch13.xhtml#ch13ex29">Listing 13-29</a> illustrates how <span class="literal">std::hash&lt;long&gt;</span> meets the equivalence criteria.</p>&#13;
<pre>#include &lt;functional&gt;&#13;
TEST_CASE("std::hash&lt;long&gt; returns") {&#13;
  std::hash&lt;long&gt; hasher; <span class="ent">➊</span>&#13;
  auto hash_code_42 = hasher(42); <span class="ent">➋</span>&#13;
  SECTION("equal hash codes for equal keys") {&#13;
    REQUIRE(hash_code_42 == hasher(42)); <span class="ent">➌</span>&#13;
  }&#13;
  SECTION("unequal hash codes for unequal keys") {&#13;
    REQUIRE(hash_code_42 != hasher(43)); <span class="ent">➍</span>&#13;
  }&#13;
}</pre>&#13;
<p class="listing"><a id="ch13ex29"/><em>Listing 13-29: The <span class="literal">std::hash&lt;long&gt;</span> returns equal hash codes for equal keys and unequal hash codes for unequal keys.</em></p>&#13;
<p class="indent">You construct a hasher of type <span class="literal">std::hash&lt;long&gt;</span> <span class="ent">➊</span> and use it to compute the hash code of 42, storing the result into <span class="literal">size_t hash_code_42</span> <span class="ent">➋</span>. When you invoke <span class="literal">hasher</span> with 42 again, you obtain the same value <span class="ent">➌</span>. When you invoke hasher with <span class="literal">43</span> instead, you obtain a different value <span class="ent">➍</span>.</p>&#13;
<p class="indent">Once an <span class="literal">unordered_set</span> hashes a key, it can obtain a bucket. Because the bucket is a list of possible matching elements, you need a function object that determines equality between a key and a bucket element. The STL provides the class template <span class="literal">std::equal_to&lt;T&gt;</span> in the <span class="literal">&lt;functional&gt;</span> header, which simply invokes <span class="literal">operator==</span> on its arguments, as <a href="ch13.xhtml#ch13ex30">Listing 13-30</a> illustrates.</p>&#13;
<pre>#include &lt;functional&gt;&#13;
TEST_CASE("std::equal_to&lt;long&gt; returns") {&#13;
  std::equal_to&lt;long&gt; long_equal_to; <span class="ent">➊</span>&#13;
  SECTION("true when arguments equal") {&#13;
    REQUIRE(long_equal_to(42, 42)); <span class="ent">➋</span>&#13;
  }&#13;
  SECTION("false when arguments unequal") {&#13;
    REQUIRE_FALSE(long_equal_to(42, 43)); <span class="ent">➌</span>&#13;
  }&#13;
}</pre>&#13;
<p class="listing"><a id="ch13ex30"/><em>Listing 13-30: The <span class="literal">std::equal_to&lt;long&gt;</span> calls <span class="literal">operator==</span> on its arguments to determine equality.</em></p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_444"/>Here, you’ve initialized an <span class="literal">equal_to&lt;long&gt;</span> called <span class="literal">long_equal_to</span> <span class="ent">➊</span>. When you invoke <span class="literal">long_equal_to</span> with equal arguments, it returns <span class="literal">true</span> <span class="ent">➋</span>. When you invoke it with unequal arguments, it returns <span class="literal">false</span> <span class="ent">➌</span>.</p>&#13;
<div class="note">&#13;
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>&#13;
<p class="notep"><em>For brevity, this chapter won’t cover implementing your own hashing and equivalence functions, which you’ll need if you want to construct unordered containers given user-defined key types. See <a href="ch07.xhtml#ch07">Chapter 7</a> of  <em>The C++ Standard Library</em>, 2nd Edition, by Nicolai Josuttis.</em></p>&#13;
</div>&#13;
<h5 class="h5" id="ch13lev3sec22"><strong>Constructing</strong></h5>&#13;
<p class="noindent">The class template <span class="literal">std::unordered_set&lt;T, Hash, KeyEqual, Allocator&gt;</span> takes four template parameters:</p>&#13;
<ul>&#13;
<li class="noindent">Key type <span class="literal">T</span></li>&#13;
<li class="noindent">The <span class="literal">Hash</span> hash function type, which defaults to <span class="literal">std::hash&lt;T&gt;</span></li>&#13;
<li class="noindent">The <span class="literal">KeyEqual</span> equality function type, which defaults to <span class="literal">std::equal_to&lt;T&gt;</span></li>&#13;
<li class="noindent">The <span class="literal">Allocator</span> allocator type, which defaults to <span class="literal">std::allocator&lt;T&gt;</span></li>&#13;
</ul>&#13;
<p class="indent">An <span class="literal">unordered_set</span> supports equivalent constructors to <span class="literal">set</span> with adjustments for the different template parameters (<span class="literal">set</span> needs a <span class="literal">Comparator</span>, whereas <span class="literal">unordered_set</span> needs a <span class="literal">Hash</span> and a <span class="literal">KeyEqual</span>). For example, you can use <span class="literal">unordered_set</span> as a drop-in replacement for <span class="literal">set</span> in <a href="ch13.xhtml#ch13ex24">Listing 13-24</a>, because <span class="literal">unordered_set</span> has range constructors and copy/move constructors and supports braced initialization.</p>&#13;
<h5 class="h5" id="ch13lev3sec23"><strong>Supported set Operations</strong></h5>&#13;
<p class="noindent">An <span class="literal">unordered_set</span> supports all <span class="literal">set</span> operations in <a href="ch13.xhtml#ch13tab10">Table 13-10</a> except for <span class="literal">lower_bound</span> and <span class="literal">upper_bound</span>, because <span class="literal">unordered_set</span> doesn’t sort its elements.</p>&#13;
<h5 class="h5" id="ch13lev3sec24"><strong>Bucket Management</strong></h5>&#13;
<p class="noindent">Generally, the reason you reach for an <span class="literal">unordered_set</span> is its high performance. Unfortunately, this performance comes at a cost: <span class="literal">unordered_set</span> objects have a somewhat complicated interior structure. You have various knobs and dials you can use to inspect and modify this internal structure at runtime.</p>&#13;
<p class="indent">The first control measure you have is to customize the bucket count of the <span class="literal">unordered_set</span> (that is, the number of buckets, not the number of elements in a particular bucket). Each <span class="literal">unordered_set</span> constructor takes a <span class="literal">size_t bucket_count</span> as its first argument, which defaults to some implementation-defined value. <a href="ch13.xhtml#ch13tab11">Table 13-11</a> lists the main <span class="literal">unordered_set</span> constructors.</p>&#13;
<p class="tabcap"><a id="ch13tab11"/><strong>Table 13-11:</strong> The <span class="literal">unordered_set</span> Constructors</p>&#13;
<table class="topbot-d">&#13;
<colgroup>&#13;
<col style="width:30%"/>&#13;
<col style="width:70%"/>&#13;
</colgroup>&#13;
<tbody>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-h"><p class="tab_th"><strong>Operation</strong></p></td>&#13;
<td style="vertical-align: top;" class="table-h"><p class="tab_th"><strong>Notes</strong></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><span class="literal">unordered_set&lt;</span><span class="codestrong">T</span><span class="literal">&gt;(</span><span class="literal">[</span><span class="codestrong">bck</span><span class="literal">], [</span><span class="codestrong">hsh</span><span class="literal">], [</span><span class="codestrong">keq</span><span class="literal">], [</span><span class="codestrong">alc</span><span class="literal">])</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">Bucket size <span class="codestrong">bck</span> has an implementation-defined default value. Uses <span class="codestrong">hsh</span><span class="literal">=std::hash&lt;</span><span class="codestrong">T</span><span class="literal">&gt;</span>, <span class="codestrong">keq</span><span class="literal">=std::equal_to&lt;</span><span class="codestrong">T</span><span class="literal">&gt;</span>, and <span class="codestrong">alc</span><span class="literal">=std::allocator&lt;</span><span class="codestrong">T</span><span class="literal">&gt;</span> by default.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><span epub:type="pagebreak" id="page_445"/><span class="literal">unordered_set&lt;</span><span class="codestrong">T</span><span class="literal">&gt;(</span><span class="codestrong">...</span><span class="literal">,</span> <span class="literal">[</span><span class="codestrong">bck</span><span class="literal">], [</span><span class="codestrong">hsh</span><span class="literal">], [</span><span class="codestrong">keq</span><span class="literal">], [</span><span class="codestrong">alc</span><span class="literal">])</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba">Performs braced initialization of a newly constructed unordered set.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><span class="literal">unordered_set&lt;</span><span class="codestrong">T</span><span class="literal">&gt;(</span><span class="codestrong">beg</span><span class="literal">,</span> <span class="codestrong">end</span> <span class="literal">[</span><span class="codestrong">bck</span><span class="literal">],</span> <span class="literal">[</span><span class="codestrong">hsh</span><span class="literal">], [</span><span class="codestrong">keq</span><span class="literal">], [</span><span class="codestrong">alc</span><span class="literal">])</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">Constructs an unordered set with the elements on the half-open range from <span class="codestrong">beg</span> to <span class="codestrong">end</span>.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><span class="literal">unordered_set&lt;</span><span class="codestrong">T</span><span class="literal">&gt;(</span><span class="codestrong">s</span><span class="literal">)</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba">Deep copy of <span class="codestrong">s</span>; allocates new memory.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-ba"><p class="taba"><span class="literal">unordered_set&lt;</span><span class="codestrong">T</span><span class="literal">&gt;(move(</span><span class="codestrong">s</span><span class="literal">))</span></p></td>&#13;
<td style="vertical-align: top;" class="table-ba"><p class="taba">Takes ownership of memory; elements in <span class="codestrong">s</span>. No allocations.</p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<p class="indent">You can inspect the number of buckets in an <span class="literal">unordered_set</span> using the <span class="literal">bucket_count</span> method. You can also obtain the maximum bucket count using the <span class="literal">max_bucket_count</span> method.</p>&#13;
<p class="indent">An important concept in the runtime performance of <span class="literal">unordered_set</span> is its <em>load factor</em>, the average number of elements per bucket. You can obtain the load factor of an <span class="literal">unordered_set</span> using the <span class="literal">load_factor</span> method, which is equivalent to <span class="literal">size()</span> divided by <span class="literal">bucket_count()</span>. Each <span class="literal">unordered_set</span> has a maximum load factor, which triggers an increase in the bucket count and a potentially expensive rehashing of all the contained elements. A <em>rehashing</em> is an operation where elements get reorganized into new buckets. This requires that you generate new hashes for each element, which can be a relatively computationally expensive operation.</p>&#13;
<p class="indent">You can obtain the maximum load factor using the <span class="literal">max_load_factor</span>, which is overloaded, so you can set a new maximum load factor (it defaults to 1.0).</p>&#13;
<p class="indent">To avoid expensive rehashing at inopportune times, you can manually trigger a rehashing using the <span class="literal">rehash</span> method, which accepts a <span class="literal">size_t</span> argument for the desired bucket count. You can also use the <span class="literal">reserve</span> method, which instead accepts a <span class="literal">size_t</span> argument for the desired <em>element</em> count.</p>&#13;
<p class="indent"><a href="ch13.xhtml#ch13ex31">Listing 13-31</a> illustrates some of these basic bucket management operations.</p>&#13;
<pre>#include &lt;unordered_set&gt;&#13;
TEST_CASE("std::unordered_set") {&#13;
  std::unordered_set&lt;unsigned long&gt; sheep(100); <span class="ent">➊</span>&#13;
  SECTION("allows bucket count specification on construction") {&#13;
    REQUIRE(sheep.bucket_count() &gt;= 100); <span class="ent">➋</span>&#13;
    REQUIRE(sheep.bucket_count() &lt;= sheep.max_bucket_count()); <span class="ent">➌</span>&#13;
    REQUIRE(sheep.max_load_factor() == Approx(1.0)); <span class="ent">➍</span>&#13;
  }&#13;
  SECTION("allows us to reserve space for elements") {&#13;
    sheep.reserve(100'000); <span class="ent">➎</span>&#13;
    sheep.insert(0);&#13;
    REQUIRE(sheep.load_factor() &lt;= 0.00001); <span class="ent">➏</span>&#13;
    while(sheep.size() &lt; 100'000)&#13;
      sheep.insert(sheep.size()); <span class="ent">➐</span>&#13;
    REQUIRE(sheep.load_factor() &lt;= 1.0); <span class="ent">➑</span>&#13;
  }&#13;
}</pre>&#13;
<p class="listing"><a id="ch13ex31"/><em>Listing 13-31: The <span class="literal">unordered_set</span> bucket management</em></p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_446"/>You construct an <span class="literal">unordered_set</span> and specify a bucket count of 100 <span class="ent">➊</span>. This results in a <span class="literal">bucket_count</span> of at least 100 <span class="ent">➋</span>, which must be less than or equal to the <span class="literal">max_bucket_count</span> <span class="ent">➌</span>. By default, the <span class="literal">max_load_factor</span> is 1.0 <span class="ent">➍</span>.</p>&#13;
<p class="indent">In the next test, you invoke <span class="literal">reserve</span> with enough space for a hundred thousand elements <span class="ent">➎</span>. After inserting an element, the <span class="literal">load_factor</span> should be less than or equal to one one-hundred-thousandth (0.00001) <span class="ent">➏</span> because you’ve reserved enough space for a hundred thousand elements. As long as you stay below this threshold, you won’t need a rehashing. After inserting a hundred thousand elements <span class="ent">➐</span>, the <span class="literal">load_factor</span> should still be less than or equal to 1 <span class="ent">➑</span>. This demonstrates that you needed no rehashing, thanks to <span class="literal">reserve</span>.</p>&#13;
<h5 class="h5" id="ch13lev3sec25"><strong>Unordered Multisets</strong></h5>&#13;
<p class="noindent">The <span class="literal">std::unordered_multiset</span> available in the STL’s <span class="literal">&lt;unordered_set&gt;</span> header is an associative container that contains unsorted, <em>non-unique</em> keys. An <span class="literal">unordered_multiset</span> supports all the same constructors and operations as an <span class="literal">unordered_set</span>, but it will store redundant elements. This relationship is analogous to <span class="literal">unordered_set</span>s and <span class="literal">set</span>s: both <span class="literal">equal_range</span> and <span class="literal">count</span> have slightly different behavior to account for the non-uniqueness of keys.</p>&#13;
<div class="note">&#13;
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>&#13;
<p class="notep"><em>Boost also provides a <span class="literal">boost::unordered_multiset</span> in the <span class="literal">&lt;boost/unordered_set.hpp&gt;</span> header.</em></p>&#13;
</div>&#13;
<h4 class="h4" id="ch13lev2sec6"><strong><em>Maps</em></strong></h4>&#13;
<p class="noindent">The <span class="literal">std::map</span> available in the STL’s <span class="literal">&lt;map&gt;</span> header is an associative container that contains key-value pairs. The keys of a <span class="literal">map</span> are sorted and unique, and <span class="literal">map</span> supports all the same operations as <span class="literal">set</span>. In fact, you can think of a <span class="literal">set</span> as a special kind of <span class="literal">map</span> containing keys and empty values. Accordingly, <span class="literal">map</span> supports efficient insertion, removal, and search, and you have control over sorting with comparator objects.</p>&#13;
<p class="indent">The major advantage of working with a map instead of a set of pairs is that <span class="literal">map</span> works as an <em>associative array</em>. An associative array takes a key rather than an integer-valued index. Think of how you use the <span class="literal">at</span> and <span class="literal">operator[]</span> methods to access indices in sequential containers. Because sequential containers have a natural ordering of elements, you use an integer to refer to them. The associative array allows you to use types other than integers to refer to elements. For example, you could use a string or a <span class="literal">float</span> as a key.</p>&#13;
<p class="indent">To enable associative array operations, <span class="literal">map</span> supports a number of useful operations; for example, allowing you to insert, modify, and retrieve values by their associated keys.</p>&#13;
<h5 class="h5" id="ch13lev3sec26"><strong>Constructing</strong></h5>&#13;
<p class="noindent">The class template <span class="literal">map&lt;Key, Value, Comparator, Allocator&gt;</span> takes four template parameters. The first is the key type <span class="literal">Key</span>. The second is the value type <span class="literal">Value</span>. The third is the comparator type, which defaults to <span class="literal">std::less</span>. The fourth parameter is the allocator type, which defaults to <span class="literal">std::allocator&lt;T&gt;</span>.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_447"/>The map constructors are direct analogues to the constructors of <span class="literal">set</span>: a default constructor that initializes an empty <span class="literal">map</span>; move and copy constructors with the usual behavior; a range constructor that copies the elements from the range into the map; and a braced initializer. The main difference is in the braced initializer, because you need to initialize key-value pairs instead of just keys. To achieve this nested initialization, you use nested initializer lists, as <a href="ch13.xhtml#ch13ex32">Listing 13-32</a> illustrates.</p>&#13;
<pre>#include &lt;map&gt;&#13;
&#13;
auto colour_of_magic = "Colour of Magic";&#13;
auto the_light_fantastic = "The Light Fantastic";&#13;
auto equal_rites = "Equal Rites";&#13;
auto mort = "Mort";&#13;
&#13;
TEST_CASE("std::map supports") {&#13;
  SECTION("default construction") {&#13;
    std::map&lt;const char*, int&gt; emp; <span class="ent">➊</span>&#13;
    REQUIRE(emp.empty()); <span class="ent">➋</span>&#13;
  }&#13;
  SECTION("braced initialization") {&#13;
    std::map&lt;const char*, int&gt; pub_year { <span class="ent">➌</span>&#13;
      { colour_of_magic, 1983 }, <span class="ent">➍</span>&#13;
      { the_light_fantastic, 1986 },&#13;
      { equal_rites, 1987 },&#13;
      { mort, 1987 },&#13;
    };&#13;
    REQUIRE(pub_year.size() == 4); <span class="ent">➎</span>&#13;
  }&#13;
}</pre>&#13;
<p class="listing"><a id="ch13ex32"/><em>Listing 13-32: A <span class="literal">std::map</span> supports default construction and braced initialization.</em></p>&#13;
<p class="indent">Here, you default construct a <span class="literal">map</span> with keys of type <span class="literal">const char*</span> and values of type <span class="literal">int</span> <span class="ent">➊</span>. This results in an empty <span class="literal">map</span> <span class="ent">➋</span>. In the second test, you again have a <span class="literal">map</span> with keys of type <span class="literal">const char*</span> and values of type <span class="literal">int</span> <span class="ent">➌</span>, but this time you use braced initialization <span class="ent">➍</span> to pack four elements into the <span class="literal">map</span> <span class="ent">➎</span>.</p>&#13;
<h5 class="h5" id="ch13lev3sec27"><strong>Move and Copy Semantics</strong></h5>&#13;
<p class="noindent">The move and copy semantics of <span class="literal">map</span> are identical to those of <span class="literal">set</span>.</p>&#13;
<h5 class="h5" id="ch13lev3sec28"><strong>Storage Model</strong></h5>&#13;
<p class="noindent">Both <span class="literal">map</span> and <span class="literal">set</span> use the same red-black tree internal structure.</p>&#13;
<h5 class="h5" id="ch13lev3sec29"><strong>Element Access</strong></h5>&#13;
<p class="noindent">The major advantage to using a <span class="literal">map</span> instead of a <span class="literal">set</span> of <span class="literal">pair</span> objects is that <span class="literal">map</span> offers two associative array operations: <span class="literal">operator[]</span> and <span class="literal">at</span>. Unlike the sequential containers supporting these operations, like <span class="literal">vector</span> and <span class="literal">array</span>, which take a <span class="literal">size_t</span> index argument, <span class="literal">map</span> takes a <span class="literal">Key</span> argument and returns <span epub:type="pagebreak" id="page_448"/>a reference to the corresponding value. As with sequential containers, <span class="literal">at</span> will throw a <span class="literal">std::out_of_range</span> exception if the given <span class="literal">key</span> doesn’t exist in the <span class="literal">map</span>. Unlike with sequential containers, <span class="literal">operator[]</span> won’t cause undefined behavior if the <span class="literal">key</span> doesn’t exist; instead, it will (silently) default construct a <span class="literal">Value</span> and insert the corresponding key-value pair into the map, even if you only intended to perform a read, as <a href="ch13.xhtml#ch13ex33">Listing 13-33</a> illustrates.</p>&#13;
<pre>TEST_CASE("std::map is an associative array with") {&#13;
  std::map&lt;const char*, int&gt; pub_year { <span class="ent">➊</span>&#13;
    { colour_of_magic, 1983 },&#13;
    { the_light_fantastic, 1986 },&#13;
  };&#13;
  SECTION("operator[]") {&#13;
    REQUIRE(pub_year[colour_of_magic] == 1983); <span class="ent">➋</span>&#13;
&#13;
    pub_year[equal_rites] = 1987; <span class="ent">➌</span>&#13;
    REQUIRE(pub_year[equal_rites] == 1987); <span class="ent">➍</span>&#13;
&#13;
    REQUIRE(pub_year[mort] == 0); <span class="ent">➎</span>&#13;
  }&#13;
  SECTION("an at method") {&#13;
    REQUIRE(pub_year.at(colour_of_magic) == 1983); <span class="ent">➏</span>&#13;
&#13;
    REQUIRE_THROWS_AS(pub_year.at(equal_rites), std::out_of_range); <span class="ent">➐</span>&#13;
  }&#13;
}</pre>&#13;
<p class="listing"><a id="ch13ex33"/><em>Listing 13-33: A <span class="literal">std::map</span> is an associative array with several access methods.</em></p>&#13;
<p class="indent">You construct a <span class="literal">map</span> called <span class="literal">pub_year</span> containing two elements <span class="ent">➊</span>. Next, you use <span class="literal">operator[]</span> to extract the value corresponding to the key <span class="literal">colour_of_magic</span> <span class="ent">➋</span>. You also use <span class="literal">operator[]</span> to insert the new key-value pair <span class="literal">equal_rites</span>, <span class="literal">1987</span> <span class="ent">➌</span> and then retrieve it <span class="ent">➍</span>. Notice that when you attempt to retrieve an element with the key <span class="literal">mort</span> (which doesn’t exist), the map has silently default-initialized an <span class="literal">int</span> for you <span class="ent">➎</span>.</p>&#13;
<p class="indent">Using <span class="literal">at</span>, you can still set and retrieve <span class="ent">➏</span> elements, but if you attempt to access a key that doesn’t exist, you get a <span class="literal">std::out_of_range</span> exception <span class="ent">➐</span>.</p>&#13;
<p class="indent">A <span class="literal">map</span> supports all the <span class="literal">set</span>-like, element-retrieval operations. For example, <span class="literal">map</span> supports <span class="literal">find</span>, which accepts a <span class="literal">key</span> argument and returns an iterator pointing to the key-value <span class="literal">pair</span> or, if no matching key is found, to the end of <span class="literal">map</span>. Also similarly supported are <span class="literal">count</span>, <span class="literal">equal_range</span>, <span class="literal">lower_bound</span>, and <span class="literal">upper_bound</span>.</p>&#13;
<h5 class="h5" id="ch13lev3sec30"><strong>Adding Elements</strong></h5>&#13;
<p class="noindent">In addition to the element access methods <span class="literal">operator[]</span> and <span class="literal">at</span>, you also have all the <span class="literal">insert</span> and <span class="literal">emplace</span> methods available from <span class="literal">set</span>. You simply need to treat each key-value pair as a <span class="literal">std::pair&lt;Key, Value&gt;</span>. As with <span class="literal">set</span>, <span class="literal">insert</span> returns a pair containing an iterator and a <span class="literal">bool</span>. The iterator points to the inserted element, and the <span class="literal">bool</span> answers whether <span class="literal">insert</span> added a new element (<span class="literal">true</span>) or not (<span class="literal">false</span>), as <a href="ch13.xhtml#ch13ex34">Listing 13-34</a> illustrates.</p>&#13;
<pre><span epub:type="pagebreak" id="page_449"/>TEST_CASE("std::map supports insert") {&#13;
  std::map&lt;const char*, int&gt; pub_year; <span class="ent">➊</span>&#13;
  pub_year.insert({ colour_of_magic, 1983 }); <span class="ent">➋</span>&#13;
  REQUIRE(pub_year.size() == 1); <span class="ent">➌</span>&#13;
&#13;
  std::pair&lt;const char*, int&gt; tlfp{ the_light_fantastic, 1986 }; <span class="ent">➍</span>&#13;
  pub_year.insert(tlfp); <span class="ent">➎</span>&#13;
  REQUIRE(pub_year.size() == 2); <span class="ent">➏</span>&#13;
&#13;
  auto [itr, is_new] = pub_year.insert({ the_light_fantastic, 9999 }); <span class="ent">➐</span>&#13;
  REQUIRE(itr-&gt;first == the_light_fantastic);&#13;
  REQUIRE(itr-&gt;second == 1986); <span class="ent">➑</span>&#13;
  REQUIRE_FALSE(is_new); <span class="ent">➒</span>&#13;
  REQUIRE(pub_year.size() == 2); <span class="ent">➓</span>&#13;
}</pre>&#13;
<p class="listing"><a id="ch13ex34"/><em>Listing 13-34: A <span class="literal">std::map</span> supports <span class="literal">insert</span> to add new elements.</em></p>&#13;
<p class="indent">You default construct a <span class="literal">map</span> <span class="ent">➊</span> and use the <span class="literal">insert</span> method with a braced initializer for a <span class="literal">pair</span> <span class="ent">➋</span>. This construction is roughly equivalent to the following:</p>&#13;
<pre>pub_year.insert(std::pair&lt;const char*, int&gt;{ colour_of_magic, 1983 });</pre>&#13;
<p class="indent">After insertion, the <span class="literal">map</span> now contains one element <span class="ent">➌</span>. Next, you create a stand-alone <span class="literal">pair</span> <span class="ent">➍</span> and then pass it as an argument to <span class="literal">insert</span> <span class="ent">➎</span>. This inserts a copy into the <span class="literal">map</span>, so it now contains two elements <span class="ent">➏</span>.</p>&#13;
<p class="indent">When you attempt to invoke <span class="literal">insert</span> with a new element with the same <span class="literal">the_light_fantastic</span> key <span class="ent">➐</span>, you get an iterator pointing to the element you already inserted <span class="ent">➎</span>. The key (<span class="literal">first</span>) and the value (<span class="literal">second</span>) match <span class="ent">➑</span>. The return value <span class="literal">is_new</span> indicates that no new element was inserted <span class="ent">➒</span>, and you still have two elements <span class="ent">➓</span>. This behavior mirrors the <span class="literal">insert</span> behavior of <span class="literal">set</span>.</p>&#13;
<p class="indent">A <span class="literal">map</span> also offers an <span class="literal">insert_or_assign</span> method, which, unlike <span class="literal">insert</span>, will overwrite an existing value. Also unlike <span class="literal">insert</span>, <span class="literal">insert_or_assign</span> accepts separate key and value arguments, as <a href="ch13.xhtml#ch13ex35">Listing 13-35</a> illustrates.</p>&#13;
<pre>TEST_CASE("std::map supports insert_or_assign") {&#13;
  std::map&lt;const char*, int&gt; pub_year{ <span class="ent">➊</span>&#13;
    { the_light_fantastic, 9999 }&#13;
  };&#13;
  auto [itr, is_new] = pub_year.insert_or_assign(the_light_fantastic, 1986); <span class="ent">➋</span>&#13;
  REQUIRE(itr-&gt;second == 1986); <span class="ent">➌</span>&#13;
  REQUIRE_FALSE(is_new); <span class="ent">➍</span>&#13;
}</pre>&#13;
<p class="listing"><a id="ch13ex35"/><em>Listing 13-35: A <span class="literal">std::map</span> supports <span class="literal">insert_or_assign</span> to overwrite existing elements.</em></p>&#13;
<p class="indent">You construct a <span class="literal">map</span> with a single element <span class="ent">➊</span> and then call <span class="literal">insert_or _assign</span> to reassign the value associated with the key <span class="literal">the_light_fantastic</span> to 1986 <span class="ent">➋</span>. The iterator points to the existing element, and when you query the corresponding value with <span class="literal">second</span>, you see the value updated to 1986 <span class="ent">➌</span>. The <span class="literal">is_new</span> return value also indicates that you’ve updated an existing element rather than inserting a new one <span class="ent">➍</span>.</p>&#13;
<h5 class="h5" id="ch13lev3sec31"><span epub:type="pagebreak" id="page_450"/><strong>Removing Elements</strong></h5>&#13;
<p class="noindent">Like <span class="literal">set</span>, <span class="literal">map</span> supports <span class="literal">erase</span> and <span class="literal">clear</span> to remove elements, as shown in <a href="ch13.xhtml#ch13ex36">Listing 13-36</a>.</p>&#13;
<pre>TEST_CASE("We can remove std::map elements using") {&#13;
    std::map&lt;const char*, int&gt; pub_year {&#13;
      { colour_of_magic, 1983 },&#13;
      { mort, 1987 },&#13;
    }; <span class="ent">➊</span>&#13;
  SECTION("erase") {&#13;
    pub_year.erase(mort); <span class="ent">➋</span>&#13;
    REQUIRE(pub_year.find(mort) == pub_year.end()); <span class="ent">➌</span>&#13;
  }&#13;
  SECTION("clear") {&#13;
    pub_year.clear(); <span class="ent">➍</span>&#13;
    REQUIRE(pub_year.empty()); <span class="ent">➎</span>&#13;
  }&#13;
}</pre>&#13;
<p class="listing"><a id="ch13ex36"/><em>Listing 13-36: A <span class="literal">std::map</span> supports element removal.</em></p>&#13;
<p class="indent">You construct a <span class="literal">map</span> with two elements <span class="ent">➊</span>. In the first test, you invoke <span class="literal">erase</span> on the element with key <span class="literal">mort</span> <span class="ent">➋</span>, so when you try to <span class="literal">find</span> it, you get back <span class="literal">end</span> <span class="ent">➌</span>. In the second test, you clear <span class="literal">map</span> <span class="ent">➍</span>, which causes <span class="literal">empty</span> to return <span class="literal">true</span> <span class="ent">➎</span>.</p>&#13;
<h5 class="h5" id="ch13lev3sec32"><strong>List of Supported Operations</strong></h5>&#13;
<p class="noindent"><a href="ch13.xhtml#ch13tab12">Table 13-12</a> summarizes the supported operations of <span class="literal">map</span>. A key <span class="literal">k</span> has type <span class="literal">K</span>. A value <span class="literal">v</span> has type <span class="literal">V</span>. <span class="literal">P</span> is the type <span class="literal">pair&lt;K, V&gt;</span>, and <span class="literal">p</span> is of type <span class="literal">P</span>. The map <span class="literal">m</span> is <span class="literal">map&lt;K, V&gt;</span>. A dagger () denotes a method that returns a <span class="literal">std::pair&lt;Iterator, bool&gt;</span>, where the iterator points to the resulting element and the <span class="literal">bool</span> equals <span class="literal">true</span> if the method inserted an element and <span class="literal">false</span> if the element already existed.</p>&#13;
<p class="tabcap"><a id="ch13tab12"/><strong>Table 13-12:</strong> A Partial List of Supported <span class="literal">map</span> Operations</p>&#13;
<table class="topbot-d">&#13;
<colgroup>&#13;
<col style="width:30%"/>&#13;
<col style="width:70%"/>&#13;
</colgroup>&#13;
<tbody>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-h"><p class="tab_th"><strong>Operation</strong></p></td>&#13;
<td style="vertical-align: top;" class="table-h"><p class="tab_th"><strong>Notes</strong></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><span class="literal">map&lt;</span><span class="codestrong">T</span><span class="literal">&gt;{</span> <span class="codestrong">...</span><span class="literal">, [</span><span class="codestrong">cmp</span><span class="literal">], [</span><span class="codestrong">alc</span><span class="literal">] }</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">Performs braced initialization of a newly constructed map. Uses <span class="codestrong">cmp</span><span class="literal">=std::less&lt;</span><span class="codestrong">T</span><span class="literal">&gt;</span> and <span class="codestrong">alc</span><span class="literal">=std::allocator&lt;</span><span class="codestrong">T</span><span class="literal">&gt;</span> by default.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><span class="literal">map&lt;</span><span class="codestrong">T</span><span class="literal">&gt;{</span>  <span class="codestrong">beg</span><span class="literal">,</span> <span class="codestrong">end</span><span class="literal">, [</span><span class="codestrong">cmp</span><span class="literal">], [</span><span class="codestrong">alc</span><span class="literal">] }</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba">Range constructor that copies elements from the half-open range <span class="codestrong">beg</span> to <span class="codestrong">end</span>. Uses <span class="codestrong">cmp</span><span class="literal">=std::less&lt;</span><span class="codestrong">T</span><span class="literal">&gt;</span> and <span class="codestrong">alc</span><span class="literal">=std::allocator&lt;</span><span class="codestrong">T</span><span class="literal">&gt;</span> by default.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><span class="literal">map&lt;</span><span class="codestrong">T</span><span class="literal">&gt;(</span><span class="codestrong">m</span><span class="literal">)</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">Deep copy of <span class="codestrong">m</span>; allocates new memory.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><span class="codestrong">map</span><span class="literal">&lt;</span><span class="codestrong">T</span><span class="literal">&gt;(move(</span><span class="codestrong">m</span><span class="literal">))</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba">Takes ownership of memory; elements in <span class="codestrong">m</span>. No allocations.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><span class="literal">~map</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">Destructs all elements contained by the map and releases dynamic memory.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><span class="codestrong">m1</span> <span class="literal">=</span> <span class="codestrong">m2</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><span class="codestrong">m1</span> destructs its elements; copies each <span class="codestrong">m2</span> element. Only allocates if it needs to resize to fit <span class="codestrong">m2</span>’s elements.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><span epub:type="pagebreak" id="page_451"/><span class="codestrong">m1</span>  <span class="literal">= move(</span><span class="codestrong">m2</span><span class="literal">)</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><span class="codestrong">m1</span> destructs its elements; moves each <span class="codestrong">m2</span> element. Only allocates if it needs to resize to fit <span class="codestrong">m2</span>’s elements.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><span class="codestrong">m</span><span class="literal">.at(</span><span class="codestrong">k</span><span class="literal">)</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba">Accesses the value corresponding to the key <span class="codestrong">k</span>. Throws <span class="literal">std::out_of_bounds</span> if key not found.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><span class="codestrong">m</span><span class="literal">[</span><span class="codestrong">k</span><span class="literal">]</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">Accesses the value corresponding to the key <span class="codestrong">k</span>. If the key is not found, inserts a new key-value pair using <span class="codestrong">k</span> and a default initialized value.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><span class="codestrong">m</span><span class="literal">.begin()</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba">Returns an iterator pointing to the first element.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><span class="codestrong">m</span><span class="literal">.cbegin()</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">Returns a <span class="literal">const</span> iterator pointing to the first element.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><span class="codestrong">m</span><span class="literal">.end()</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba">Returns an iterator pointing to 1 past the last element.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><span class="codestrong">m</span><span class="literal">.cend()</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">Returns a <span class="literal">const</span> iterator pointing to 1 past the last element.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><span class="codestrong">m</span><span class="literal">.find(</span><span class="codestrong">k</span><span class="literal">)</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba">Returns an iterator pointing to the element matching <span class="codestrong">k</span>, or <span class="codestrong">m</span><span class="literal">.end()</span> if no such element exists.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><span class="codestrong">m</span><span class="literal">.count(</span><span class="codestrong">k</span><span class="literal">)</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">Returns 1 if the map contains <span class="codestrong">k</span>; otherwise 0.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><span class="codestrong">m</span><span class="literal">.equal_range(</span><span class="codestrong">k</span><span class="literal">)</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba">Returns a <span class="literal">pair</span> of iterators corresponding to the half-open range of elements matching <span class="codestrong">k</span>.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><span class="codestrong">m</span><span class="literal">.lower_bound(</span><span class="codestrong">k</span><span class="literal">)</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">Returns an iterator pointing to the first element not less than <span class="codestrong">k</span>, or <span class="codestrong">t</span>.<span class="literal">end()</span> if no such element exists.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><span class="codestrong">m</span><span class="literal">.upper_bound(</span><span class="codestrong">k</span><span class="literal">)</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba">Returns an iterator pointing to the first element greater than <span class="codestrong">k</span>, or <span class="codestrong">t</span><span class="literal">.end()</span> if no such element exists.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><span class="codestrong">m</span><span class="literal">.clear()</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">Removes all elements from the map.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><span class="codestrong">m</span><span class="literal">.erase(</span><span class="codestrong">k</span><span class="literal">)</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba">Removes the element with key <span class="codestrong">k</span>.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><span class="codestrong">m</span><span class="literal">.erase(</span><span class="codestrong">itr</span><span class="literal">)</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">Removes the element pointed to by <span class="codestrong">itr</span>.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><span class="codestrong">m</span><span class="literal">.erase(</span><span class="codestrong">beg</span><span class="literal">,</span> <span class="codestrong">end</span><span class="literal">)</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba">Removes all elements on the half-open range from <span class="codestrong">beg</span> to <span class="codestrong">end</span>.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><span class="codestrong">m</span><span class="literal">.insert(</span><span class="codestrong">p</span><span class="literal">)</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">Inserts a copy of the pair <span class="codestrong">p</span> into the map.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><span class="codestrong">m</span><span class="literal">.insert_or_assign(</span><span class="codestrong">k</span><span class="literal">,</span> <span class="codestrong">v</span><span class="literal">)</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba">If <span class="codestrong">k</span> exists, overwrites the corresponding value with <span class="codestrong">v</span>. If <span class="codestrong">k</span> doesn’t exist, inserts the pair <span class="codestrong">k</span>, <span class="codestrong">v</span> into the map.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><span class="codestrong">m</span><span class="literal">.emplace(</span><span class="codestrong">...</span><span class="literal">)</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">Constructs a <span class="codestrong">P</span> in place by forwarding the arguments <span class="codestrong">...</span>.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><span class="codestrong">m</span><span class="literal">.emplace_hint(</span><span class="codestrong">k</span><span class="literal">,  ...)</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba">Constructs a <span class="codestrong">P</span> in place by forwarding the arguments<span class="literal">...</span>. Uses <span class="codestrong">itr</span> as a hint for where to insert the new element.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><span class="codestrong">m</span><span class="literal">.try_emplace(</span><span class="codestrong">itr</span><span class="literal">,</span> <span class="codestrong">...</span><span class="literal">)</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">If key <span class="codestrong">k</span> exists, does nothing. If <span class="codestrong">k</span> doesn’t exist, constructs a <span class="codestrong">V</span> in place by forwarding the arguments <span class="codestrong">...</span>.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><span class="codestrong">m</span><span class="literal">.empty()</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba">Returns <span class="literal">true</span> if map’s size is zero; otherwise <span class="literal">false</span>.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><span class="codestrong">m</span><span class="literal">.size()</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">Returns the number of elements in the map.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><span class="codestrong">m</span><span class="literal">.max_size()</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba">Returns the maximum number of elements in the map.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><span epub:type="pagebreak" id="page_452"/><span class="codestrong">m</span><span class="literal">.extract(</span><span class="codestrong">k</span><span class="literal">)</span></p>&#13;
<p class="taba"><span class="codestrong">m</span><span class="literal">.extract(</span><span class="codestrong">itr</span><span class="literal">)</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">Obtains a node handle that owns the element matching <span class="codestrong">k</span> or pointed to by <span class="codestrong">itr</span>. (This is the only way to remove a move-only element.)</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><span class="codestrong">m1</span><span class="literal">.merge(</span><span class="codestrong">m2</span><span class="literal">)</span></p>&#13;
<p class="taba"><span class="codestrong">m1</span><span class="literal">.merge(move(</span><span class="codestrong">m2</span><span class="literal">))</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba">Splices each element of <span class="codestrong">m2</span> into <span class="codestrong">m1</span>. If argument is an rvalue, will move the elements into <span class="codestrong">m1</span>.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-ba"><p class="taba"><span class="codestrong">m1</span><span class="literal">.swap(</span><span class="codestrong">m2</span><span class="literal">)</span></p>&#13;
<p class="taba"><span class="literal">swap(</span><span class="codestrong">m1</span><span class="literal">,</span> <span class="codestrong">m2</span><span class="literal">)</span></p></td>&#13;
<td style="vertical-align: top;" class="table-ba"><p class="taba">Exchanges each element of <span class="codestrong">m1</span> with those of <span class="codestrong">m2</span>.</p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<h3 class="h3" id="ch13lev1sec9"><strong>Multimaps</strong></h3>&#13;
<p class="noindent">The <span class="literal">std::multimap</span> available in the STL’s <span class="literal">&lt;map&gt;</span> header is an associative container that contains key-value pairs with <em>non-unique</em> keys. Because the keys are not unique, <span class="literal">multimap</span> doesn’t support the associative array features that <span class="literal">map</span> does. Namely, <span class="literal">operator[]</span> and <span class="literal">at</span> aren’t supported. As with <span class="literal">multiset</span>, <span class="literal">multimap</span> offers element access primarily through the <span class="literal">equal_range</span> method, as <a href="ch13.xhtml#ch13ex37">Listing 13-37</a> illustrates.</p>&#13;
<pre>TEST_CASE("std::multimap supports non-unique keys") {&#13;
  std::array&lt;char, 64&gt; far_out {&#13;
    "Far out in the uncharted backwaters of the unfashionable end..."&#13;
  }; <span class="ent">➊</span>&#13;
  std::multimap&lt;char, size_t&gt; indices; <span class="ent">➋</span>&#13;
  for(size_t index{}; index&lt;far_out.size(); index++)&#13;
    indices.emplace(far_out[index], index); <span class="ent">➌</span>&#13;
&#13;
  REQUIRE(indices.count('a') == 6); <span class="ent">➍</span>&#13;
&#13;
  auto [itr, end] = indices.equal_range('d'); <span class="ent">➎</span>&#13;
  REQUIRE(itr-&gt;second == 23); <span class="ent">➏</span>&#13;
  itr++;&#13;
  REQUIRE(itr-&gt;second == 59); <span class="ent">➐</span>&#13;
  itr++;&#13;
  REQUIRE(itr == end);&#13;
}</pre>&#13;
<p class="listing"><a id="ch13ex37"/><em>Listing 13-37: A <span class="literal">std::multimap</span> supports non-unique keys.</em></p>&#13;
<p class="indent">You construct an <span class="literal">array</span> containing a message <span class="ent">➊</span>. You also default construct a <span class="literal">multimap&lt;char, size_t&gt;</span> called <span class="literal">indices</span> that you’ll use to store the index of every character in the message <span class="ent">➋</span>. By looping through the array, you can store each character in the message along with its index as a new element in <span class="literal">multimap</span> <span class="ent">➌</span>. Because you’re allowed to have non-unique keys, you can use the <span class="literal">count</span> method to reveal how many indices you insert with the key <span class="literal">a</span> <span class="ent">➍</span>. You can also use the <span class="literal">equal_range</span> method to obtain the half-open range of indices with the key <span class="literal">d</span> <span class="ent">➎</span>. Using the resulting <span class="literal">begin</span> and <span class="literal">end</span> iterators, you can see that the message has the letter <span class="literal">d</span> at indices 23 <span class="ent">➏</span> and 59 <span class="ent">➐</span>.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_453"/>Aside from <span class="literal">operator[]</span> and <span class="literal">at</span>, every operation in <a href="ch13.xhtml#ch13tab12">Table 13-12</a> works for <span class="literal">multimap</span> as well. (Note that the <span class="literal">count</span> method can take on values other than 0 and 1.)</p>&#13;
<h5 class="h5" id="ch13lev3sec33"><strong>Unordered Maps and Unordered Multimaps</strong></h5>&#13;
<p class="noindent">Unordered maps and unordered multimaps are completely analogous to unordered sets and unordered multisets. The <span class="literal">std::unordered_map</span> and <span class="literal">std::unordered_multimap</span> are available in the STL’s <span class="literal">&lt;unordered_map&gt;</span> header. These associative containers typically use a red-black tree like their <span class="literal">set</span> counterparts. They also require a hash function and an equivalence function, and they support the bucket interface.</p>&#13;
<div class="note">&#13;
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>&#13;
<p class="notep"><em>Boost offers the <span class="literal">boost::unordered_map</span> and <span class="literal">boost::unordered_multimap</span> in the <span class="literal">&lt;boost/unordered_map.hpp&gt;</span> header.</em></p>&#13;
</div>&#13;
<h4 class="h4" id="ch13lev2sec7"><strong><em>Niche Associative Containers</em></strong></h4>&#13;
<p class="noindent">Use <span class="literal">set</span>, <span class="literal">map</span>, and their associated non-unique and unordered counterparts as the default choices when you need associative data structures. When special needs arise, Boost libraries offer a number of specialized associative containers, as highlighted in <a href="ch13.xhtml#ch13tab13">Table 13-13</a>.</p>&#13;
<p class="tabcap"><a id="ch13tab13"/><strong>Table 13-13:</strong> Special Boost Containers</p>&#13;
<table class="topbot-d">&#13;
<colgroup>&#13;
<col style="width:30%"/>&#13;
<col style="width:70%"/>&#13;
</colgroup>&#13;
<tbody>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-h"><p class="tab_th"><strong>Class/Header</strong></p></td>&#13;
<td style="vertical-align: top;" class="table-h"><p class="tab_th"><strong>Description</strong></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><span class="literal">boost::container::flat_map</span></p>&#13;
<p class="taba"><span class="literal">&lt;boost/container/flat_map.hpp&gt;</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">Similar to an STL <span class="literal">map</span>, but it’s implemented like an ordered vector. This means fast random element access.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><span class="literal">boost::container::flat_set</span></p>&#13;
<p class="taba"><span class="literal">&lt;boost/container/flat_set.hpp&gt;</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba">Similar to an STL <span class="literal">set</span>, but it’s implemented like an ordered vector. This means fast random element access.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><span class="literal">boost::intrusive::*</span></p>&#13;
<p class="taba"><span class="literal">&lt;boost/intrusive/*.hpp&gt;</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">Intrusive containers impose requirements on the elements they contain (such as inheriting from a particular base class). In exchange, they offer substantial performance gains.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><span class="literal">boost::multi_index_container</span></p>&#13;
<p class="taba"><span class="literal">&lt;boost/multi_index_container.hpp&gt;</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba">Permits you to create associative arrays taking multiple indices rather than just one (like a map).</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><span class="literal">boost::ptr_set</span></p>&#13;
<p class="taba"><span class="literal">boost::ptr_unordered_map</span></p>&#13;
<p class="taba"><span class="literal">boost::ptr_unordered_set</span></p>&#13;
<p class="taba"><span class="literal">&lt;boost/ptr_container/*.hpp&gt;</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">Having a collection of smart pointers can be suboptimal. Pointer vectors manage a collection of dynamic objects in a more efficient and user-friendly way.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><span class="literal">boost::bimap</span></p>&#13;
<p class="taba"><span class="literal">&lt;</span> <span class="literal">boost/bimap.hpp&gt;</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba">A bimap is an associative container that allows both types to be used as a key.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-ba"><p class="taba"><span class="literal">boost::heap::binomial_heap</span></p>&#13;
<p class="taba"><span class="literal">boost::heap::d_ary_heap</span></p>&#13;
<p class="taba"><span class="literal">boost::heap::fibonacci_heap</span></p>&#13;
<p class="taba"><span class="literal">boost::heap::pairing_heap</span></p>&#13;
<p class="taba"><span class="literal">boost::heap::priority_queue</span></p>&#13;
<p class="taba"><span class="literal">boost::heap::skew_heap</span></p>&#13;
<p class="taba"><span class="literal">&lt;boost/heap/*.hpp&gt;</span></p></td>&#13;
<td style="vertical-align: top;" class="table-ba"><p class="taba">The Boost Heap containers implement more advanced, featureful versions of <span class="literal">priority_queue</span>.</p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<h3 class="h3" id="ch13lev1sec10"><span epub:type="pagebreak" id="page_454"/><strong>Graphs and Property Trees</strong></h3>&#13;
<p class="noindent">This section discusses two specialized Boost libraries that serve niche but valuable purposes: modeling graphs and property trees. A <em>graph</em> is a set of objects in which some have a pairwise relation. The objects are called <em>verti</em><em>ces,</em>and their relations are called <em>edges</em>. <a href="ch13.xhtml#ch13fig03">Figure 13-3</a> illustrates a graph containing four vertices and five edges.</p>&#13;
<div class="image"><img src="../images/fig13_3.jpg" alt="image"/></div>&#13;
<p class="figcap" id="ch13fig03"><em>Figure 13-3:A graph containing four vertices and five edges</em></p>&#13;
<p class="indent">Each square represents a vertex, and each arrow represents an edge.</p>&#13;
<p class="indent">A <em>property tree</em> is a tree structure storing nested key-value pairs. The hierarchical nature of a property tree’s key-value pairs makes it a hybrid between a map and a graph; each key-value pair has a relation to other key-value pairs. <a href="ch13.xhtml#ch13fig04">Figure 13-4</a> illustrates an example property tree containing nested key-value pairs.</p>&#13;
<div class="image"><img src="../images/fig13_4.jpg" alt="image"/></div>&#13;
<p class="figcap" id="ch13fig04"><em>Figure 13-4: An example property tree</em></p>&#13;
<p class="indent">The root element has three children: name, year, and features. In <a href="ch13.xhtml#ch13fig04">Figure 13-4</a>, name has a value finfisher, year has a value 2014, and features has three children: process with value LSASS, driver with value mssounddx.sys, and arch with value 32.</p>&#13;
<h3 class="h3" id="ch13lev1sec11"><span epub:type="pagebreak" id="page_455"/><strong>The Boost Graph Library</strong></h3>&#13;
<p class="noindent">The <em>Boost Graph Library</em> (BGL) is a set of collections and algorithms for storing and manipulating graphs. The BGL offers three containers that represent graphs:</p>&#13;
<ul>&#13;
<li class="noindent">The <span class="literal">boost::adjacency_list</span> in the <span class="literal">&lt;boost/graph/adjacency_list.hpp&gt;</span> header</li>&#13;
<li class="noindent">The <span class="literal">boost::adjacency_matrix</span> in the <span class="literal">&lt;boost/graph/adjacency_matrix.hpp&gt;</span> header</li>&#13;
<li class="noindent">The <span class="literal">boost::edge_list</span> in the <span class="literal">&lt;boost/graph/ edge_list.hpp&gt;</span> header</li>&#13;
</ul>&#13;
<p class="indent">You use two non-member functions to build graphs: <span class="literal">boost::add_vertex</span> and <span class="literal">boost::add_edge</span>. To add a vertex to one of the BGL graph containers, you pass the graph object to <span class="literal">add_vertex</span>, which will return reference to the new vertex object. To add an edge, we pass the source vertex, the destination vertex, then the graph to <span class="literal">add_edge</span>.</p>&#13;
<p class="indent">BGL contains a number of graph-specific algorithms. You can count the number of vertices in a graph object by passing it to the non-member function <span class="literal">boost::num_vertices</span> and the number of edges using <span class="literal">boost::num_edges</span>. You can also query a graph for adjacent vertices. Two vertices are <em>adjacent</em> if they share an edge. To get the vertices adjacent to a particular vertex, you can pass it and the graph object to the non-member function <span class="literal">boost::adjacent_ vertices</span>. This returns a half-open range as a <span class="literal">std::pair</span> of iterators.</p>&#13;
<p class="indent"><a href="ch13.xhtml#ch13ex38">Listing 13-38</a> illustrates how you can build the graph represented in <a href="ch13.xhtml#ch13fig03">Figure 13-3</a>, count its vertices and edges, and compute adjacent vertices.</p>&#13;
<pre>#include &lt;set&gt;&#13;
#include &lt;boost/graph/adjacency_list.hpp&gt;&#13;
&#13;
TEST_CASE("boost::adjacency_list stores graph data") {&#13;
  boost::adjacency_list&lt;&gt; graph{}; <span class="ent">➊</span>&#13;
  auto vertex_1 = boost::add_vertex(graph);&#13;
  auto vertex_2 = boost::add_vertex(graph);&#13;
  auto vertex_3 = boost::add_vertex(graph);&#13;
  auto vertex_4 = boost::add_vertex(graph); <span class="ent">➋</span>&#13;
  auto edge_12 = boost::add_edge(vertex_1, vertex_2, graph);&#13;
  auto edge_13 = boost::add_edge(vertex_1, vertex_3, graph);&#13;
  auto edge_21 = boost::add_edge(vertex_2, vertex_1, graph);&#13;
  auto edge_24 = boost::add_edge(vertex_2, vertex_4, graph);&#13;
  auto edge_43 = boost::add_edge(vertex_4, vertex_3, graph); <span class="ent">➌</span>&#13;
&#13;
  REQUIRE(boost::num_vertices(graph) == 4); <span class="ent">➍</span>&#13;
  REQUIRE(boost::num_edges(graph) == 5); <span class="ent">➎</span>&#13;
&#13;
  auto [begin, end] = boost::adjacent_vertices(vertex_1, graph); <span class="ent">➏</span>&#13;
  std::set&lt;decltype(vertex_1)&gt; neighboors_1 { begin, end }; <span class="ent">➐</span>&#13;
  REQUIRE(neighboors_1.count(vertex_2) == 1); <span class="ent">➑</span>&#13;
  REQUIRE(neighboors_1.count(vertex_3) == 1); <span class="ent">➒</span>&#13;
  REQUIRE(neighboors_1.count(vertex_4) == 0); <span class="ent">➓</span>&#13;
}</pre>&#13;
<p class="listing"><a id="ch13ex38"/><em>Listing 13-38: The <span class="literal">boost::adjacency_list</span> stores graph data.</em></p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_456"/>Here, you’ve constructed an <span class="literal">adjacency_list</span> called <span class="literal">graph</span> <span class="ent">➊</span>, then added four vertices using <span class="literal">add_vertex</span> <span class="ent">➋</span>. Next, you add all the edges represented in <a href="ch13.xhtml#ch13fig03">Figure 13-3</a> using <span class="literal">add_edge</span> <span class="ent">➌</span>. Then <span class="literal">num_vertices</span> shows you that you’ve added four vertices <span class="ent">➍</span>, and <span class="literal">num_edges</span> tells you that you’ve added five edges <span class="ent">➎</span>.</p>&#13;
<p class="indent">Finally, you’ve determined the <span class="literal">adjacent_vertices</span> to <span class="literal">vertex_1</span>, which you unpack into the iterators <span class="literal">begin</span> and <span class="literal">end</span> <span class="ent">➏</span>. You use these iterators to construct a <span class="literal">std::set</span> <span class="ent">➐</span>, which you use to show that <span class="literal">vertex_2</span> <span class="ent">➑</span> and <span class="literal">vertex_3</span> <span class="ent">➒</span> are adjacent, but <span class="literal">vertex_4</span> is not <span class="ent">➓</span>.</p>&#13;
<h3 class="h3" id="ch13lev1sec12"><strong>Boost Property Trees</strong></h3>&#13;
<p class="noindent">Boost offers the <span class="literal">boost::property_tree::ptree</span> in the <span class="literal">&lt;boost/property_tree/ptree.hpp&gt;</span> header. This is a property tree that permits us to build and query property trees, as well as some limited serialization into various formats.</p>&#13;
<p class="indent">The tree <span class="literal">ptree</span> is default constructible. Default constructing will build an empty <span class="literal">ptree</span>.</p>&#13;
<p class="indent">You can insert elements into a <span class="literal">ptree</span> using its <span class="literal">put</span> method, which takes a path and a value argument. A <em>path</em> is a sequence of one or more nested keys separated by a period (<strong>.</strong>), and a <em>value</em> is an arbitrarily typed object.</p>&#13;
<p class="indent">You can get subtrees from a <span class="literal">ptree</span> using the <span class="literal">get_child</span> method, which takes the path of the desired subtree. If the subtree does not have any children (a so-called <em>leaf node</em>), you can also use the method template <span class="literal">get_value</span> to extract the corresponding value from the key-value pair; <span class="literal">get_value</span> takes a single template parameter corresponding to the desired output type.</p>&#13;
<p class="indent">Finally, <span class="literal">ptree</span> supports serialization and deserialization to several formats including Javascript object notation (JSON), the Windows initialization file (INI) format, the extensible markup language (XML), and a custom, <span class="literal">ptree</span>-specific format called INFO. For example, to write a <span class="literal">ptree</span> into a file in JSON format, you could use the <span class="literal">boost::property_tree::write_json</span> function from the <span class="literal">&lt;boost/property_tree/json_parser.hpp&gt;</span> header. The function <span class="literal">write_json</span> accepts two arguments: the path to the desired output file and a <span class="literal">ptree</span> reference.</p>&#13;
<p class="indent"><a href="ch13.xhtml#ch13ex39">Listing 13-39</a> highlights these basic <span class="literal">ptree</span> functions by building a <span class="literal">ptree</span> representing the property tree in <a href="ch13.xhtml#ch13fig04">Figure 13-4</a>, writing the <span class="literal">ptree</span> to file as JSON, and reading it back.</p>&#13;
<pre>#include &lt;boost/property_tree/ptree.hpp&gt;&#13;
#include &lt;boost/property_tree/json_parser.hpp&gt;&#13;
&#13;
TEST_CASE("boost::property_tree::ptree stores tree data") {&#13;
  using namespace boost::property_tree;&#13;
  ptree p; <span class="ent">➊</span>&#13;
  p.put("name", "finfisher");&#13;
  p.put("year", 2014);&#13;
  p.put("features.process", "LSASS");&#13;
  p.put("features.driver", "mssounddx.sys");&#13;
  p.put("features.arch", 32); <span class="ent">➋</span>&#13;
<span epub:type="pagebreak" id="page_457"/>  REQUIRE(p.get_child("year").get_value&lt;int&gt;() == 2014); <span class="ent">➌</span>&#13;
&#13;
  const auto file_name = "rootkit.json";&#13;
  write_json(file_name, p); <span class="ent">➍</span>&#13;
&#13;
  ptree p_copy;&#13;
  read_json(file_name, p_copy); <span class="ent">➎</span>&#13;
  REQUIRE(p_copy == p); <span class="ent">➏</span>&#13;
}&#13;
--------------------------------------------------------------------------&#13;
<span class="color1">{</span>&#13;
    <span class="color1">"name": "finfisher",</span>&#13;
    <span class="color1">"year": "2014",</span>&#13;
    <span class="color1">"features": {</span>&#13;
        <span class="color1">"process": "LSASS",</span>&#13;
        <span class="color1">"driver": "mssounddx.sys",</span>&#13;
        <span class="color1">"arch": "32"</span>&#13;
    <span class="color1">}</span>&#13;
<span class="color1">}</span> <span class="ent">➍</span></pre>&#13;
<p class="listing"><a id="ch13ex39"/><em>Listing 13-39: The <span class="literal">boost::property_tree::ptree</span> method stores tree data. Output shows the contents of <span class="literal">rootkit.json</span>.</em></p>&#13;
<p class="indent">Here, you’ve default constructed a <span class="literal">ptree</span> <span class="ent">➊</span>, which you populate with the key values shown in <a href="ch13.xhtml#ch13fig04">Figure 13-4</a>. Keys with parents, such as <span class="literal">arch</span> <span class="ent">➋</span>, use periods to show the appropriate path. Using <span class="literal">get_child</span>, you’ve extracted the subtree for key <span class="literal">year</span>. Because it’s a leaf node (having no children), you also invoke <span class="literal">get_value</span>, specifying the output type as <span class="literal">int</span> <span class="ent">➌</span>.</p>&#13;
<p class="indent">Next, you write the <span class="literal">ptree</span>’s JSON representation to the file <span class="literal">rootkit.json</span> <span class="ent">➍</span>. To ensure that you get the same property tree back, you default construct another <span class="literal">ptree</span> called <span class="literal">p_copy</span> and pass it into <span class="literal">read_json</span> <span class="ent">➎</span>. This copy is equivalent to the original <span class="ent">➏</span>, illustrating that the serialization-deserialization operation is successful.</p>&#13;
<h3 class="h3" id="ch13lev1sec13"><strong>Initializer Lists</strong></h3>&#13;
<p class="noindent">You can accept initializer lists in your user-defined types by incorporating the <span class="literal">std::initializer_list</span> container available in the STL’s <span class="literal">&lt;initializer_list&gt;</span> header. The <span class="literal">initializer_list</span> is a class template that takes a single template parameter corresponding to the underlying type contained in the initializer list. This template serves as a simple proxy for accessing the elements of an initializer list.</p>&#13;
<p class="indent">The <span class="literal">initializer_list</span> is immutable and supports three operations:</p>&#13;
<ul>&#13;
<li class="noindent">The <span class="literal">size</span> method returns the number of elements in the <span class="literal">initializer_list</span>.</li>&#13;
<li class="noindent">The <span class="literal">begin</span> and <span class="literal">end</span> methods return the usual half-open-range iterators.</li>&#13;
</ul>&#13;
<p class="indent">Generally, you should design functions to accept an <span class="literal">initializer_list</span> by value.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_458"/><a href="ch13.xhtml#ch13ex40">Listing 13-40</a> implements a <span class="literal">SquareMatrix</span> class that stores a matrix with equal numbers of rows and columns. Internally, the class will hold elements in a <span class="literal">vector</span> of <span class="literal">vector</span>s.</p>&#13;
<pre>#include &lt;cmath&gt;&#13;
#include &lt;stdexcept&gt;&#13;
#include &lt;initializer_list&gt;&#13;
#include &lt;vector&gt;&#13;
&#13;
size_t square_root(size_t x) { <span class="ent">➊</span>&#13;
  const auto result = static_cast&lt;size_t&gt;(sqrt(x));&#13;
  if (result * result != x) throw std::logic_error{ "Not a perfect square." };&#13;
  return result;&#13;
}&#13;
&#13;
template &lt;typename T&gt;&#13;
struct SquareMatrix {&#13;
  SquareMatrix(std::initializer_list&lt;T&gt; val) <span class="ent">➋</span>&#13;
    : dim{ square_root(val.size()) }, <span class="ent">➌</span>&#13;
      data(dim, std::vector&lt;T&gt;{}) { <span class="ent">➍</span>&#13;
    auto itr = val.begin(); <span class="ent">➎</span>&#13;
    for(size_t row{}; row&lt;dim; row++){&#13;
      data[row].assign(itr, itr+dim); <span class="ent">➏</span>&#13;
      itr += dim; <span class="ent">➐</span>&#13;
    }&#13;
  }&#13;
  T&amp; at(size_t row, size_t col) {&#13;
    if (row &gt;= dim || col &gt;= dim)&#13;
      throw std::out_of_range{ "Index invalid." }; <span class="ent">➑</span>&#13;
    return data[row][col]; <span class="ent">➒</span>&#13;
  }&#13;
  const size_t dim;&#13;
private:&#13;
  std::vector&lt;std::vector&lt;T&gt;&gt; data;&#13;
};</pre>&#13;
<p class="listing"><a id="ch13ex40"/><em>Listing 13-40: An implementation of a <span class="literal">SquareMatrix</span></em></p>&#13;
<p class="indent">Here, you declare a convenience <span class="literal">square_root</span> function that finds the square root of a <span class="literal">size_t</span>, throwing an exception if the argument isn’t a perfect square <span class="ent">➊</span>. The <span class="literal">SquareMatrix</span> class template defines a single constructor that accepts a <span class="literal">std::initializer</span> called <span class="literal">val</span> <span class="ent">➋</span>. This permits braced initialization.</p>&#13;
<p class="indent">First, you need to determine the dimensions of <span class="literal">SquareMatrix</span>. Use the <span class="literal">square_root</span> function to compute the square root of <span class="literal">val.size()</span> <span class="ent">➌</span> and store this into the <span class="literal">dim</span> field, which represents the number of rows and columns of the <span class="literal">SquareMatrix</span> instance. You can then use <span class="literal">dim</span> to initialize the vector of vectors <span class="literal">data</span> using its fill constructor <span class="ent">➍</span>. Each of these <span class="literal">vector</span>s will correspond to a row in <span class="literal">SquareMatrix</span>. Next, you extract an iterator pointing to the first element in <span class="literal">initializer_list</span> <span class="ent">➎</span>. You iterate over each row in <span class="literal">SquareMatrix</span>, assigning the corresponding <span class="literal">vector</span> to the appropriate half-open range <span class="ent">➏</span>. You increment the iterator on each iteration to point to the next row <span class="ent">➐</span>.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_459"/>Finally, you implement an <span class="literal">at</span> method to permit element access. You perform bounds checking <span class="ent">➑</span> and then return a reference to the desired element by extracting the appropriate <span class="literal">vector</span> and element <span class="ent">➒</span>.</p>&#13;
<p class="indent"><a href="ch13.xhtml#ch13ex41">Listing 13-41</a> illustrates how to use braced initialization to generate a <span class="literal">SquareMatrix</span> object.</p>&#13;
<pre>TEST_CASE("SquareMatrix and std::initializer_list") {&#13;
  SquareMatrix&lt;int&gt; mat { <span class="ent">➊</span>&#13;
     1,  2,  3,  4,&#13;
     5,  0,  7,  8,&#13;
     9, 10, 11, 12,&#13;
    13, 14, 15, 16&#13;
  };&#13;
  REQUIRE(mat.dim == 4); <span class="ent">➋</span>&#13;
  mat.at(1, 1) = 6; <span class="ent">➌</span>&#13;
  REQUIRE(mat.at(1, 1) == 6); <span class="ent">➍</span>&#13;
  REQUIRE(mat.at(0, 2) ==  3); <span class="ent">➎</span>&#13;
}</pre>&#13;
<p class="listing"><a id="ch13ex41"/><em>Listing 13-41: Using braced initializers with a <span class="literal">SquareMatrix</span></em></p>&#13;
<p class="indent">You use braced initializers to set up <span class="literal">SquareMatrix</span> <span class="ent">➊</span>. Because the initializer list contains 16 elements, you end up with a <span class="literal">dim</span> of 4 <span class="ent">➋</span>. You can use <span class="literal">at</span> to obtain a reference to any element, meaning you can set <span class="ent">➌</span> and get <span class="ent">➍</span><span class="ent">➎</span> elements.</p>&#13;
<h3 class="h3" id="ch13lev1sec14"><strong>Summary</strong></h3>&#13;
<p class="noindent">This chapter began with a discussion of the two go-to sequence containers, <span class="literal">array</span> and <span class="literal">vector</span>, which offer you a great balance between performance and features in a wide range of applications. Next, you learned about several sequence containers—<span class="literal">deque</span>, <span class="literal">list</span>, <span class="literal">stack</span>, <span class="literal">queue</span>, <span class="literal">priority_queue</span>, and <span class="literal">bitset</span>—that fill in when <span class="literal">vector</span> doesn’t meet the demands of a particular application. Then you explored the major associative containers, <span class="literal">set</span> and <span class="literal">map</span>, and their unordered/multipermutations. You also learned about two niche Boost containers, <span class="literal">graph</span> and <span class="literal">ptree</span>. The chapter wrapped up with a brief discussion of incorporating <span class="literal">initializer_list</span>s into user-defined types.</p>&#13;
<div class="box5" id="bm01">&#13;
<p class="boxtitle-d"><strong>EXERCISES</strong></p>&#13;
<p class="noindent"><strong>13-1.</strong> Write a program that default constructs a <span class="literal">std::vector</span> of unsigned longs. Print the <span class="literal">capacity</span> of <span class="literal">vector</span> and then <span class="literal">reserve</span> 10 elements. Next, append the first 20 elements of the Fibonacci series to the vector. Print <span class="literal">capacity</span> again. Does <span class="literal">capacity</span> match the number of elements in the vector? Why or why not? Print the elements of <span class="literal">vector</span> using a range-based <span class="literal">for</span> loop.</p>&#13;
<p class="noindent"><span epub:type="pagebreak" id="page_460"/><strong>13-2.</strong> Rewrite <a href="ch02.xhtml#ch02ex09">Listings 2-9</a>, <a href="ch02.xhtml#ch02ex10">2-10</a>, and <a href="ch02.xhtml#ch02ex11">2-11</a> in <a href="ch02.xhtml#ch02">Chapter 2</a> using <span class="literal">std::array</span>.</p>&#13;
<p class="noindent"><strong>13-3.</strong> Write a program that accepts any number of command line arguments and prints them in alphanumerically sorted order. Use a <span class="literal">std::set&lt;const char*&gt;</span> to store the elements, then iterate over the <span class="literal">set</span> to obtain the sorted result. You’ll need to implement a custom comparator that compares two C-style strings.</p>&#13;
<p class="noindent"><strong>13-4.</strong> Write a program that default constructs a <span class="literal">std::vector</span> of unsigned longs. Print the <span class="literal">capacity</span> of <span class="literal">vector</span> and then <span class="literal">reserve</span> 10 elements. Next, append the first 20 elements of the Fibonacci series to the vector. Print <span class="literal">capacity</span> again. Does <span class="literal">capacity</span> match the number of elements in the vector? Why or why not? Print the elements of <span class="literal">vector</span> using a range-based <span class="literal">for</span> loop.</p>&#13;
<p class="noindent"><strong>13-5.</strong> Consider the following program that profiles the performance of a function summing a Fibonacci series:</p>&#13;
<pre>#include &lt;chrono&gt;&#13;
#include &lt;cstdio&gt;&#13;
#include &lt;random&gt;&#13;
&#13;
long fib_sum(size_t n) { <span class="ent">➊</span>&#13;
  // TODO: Adapt code from Exercise 12.1&#13;
  return 0;&#13;
}&#13;
&#13;
long random() { <span class="ent">➋</span>&#13;
  static std::mt19937_64 mt_engine{ 102787 };&#13;
  static std::uniform_int_distribution&lt;long&gt; int_d{ 1000, 2000 };&#13;
  return int_d(mt_engine);&#13;
}&#13;
&#13;
struct Stopwatch { <span class="ent">➌</span>&#13;
  Stopwatch(std::chrono::nanoseconds&amp; result)&#13;
    : result{ result },&#13;
    start{ std::chrono::system_clock::now() } { }&#13;
  ~Stopwatch() {&#13;
    result = std::chrono::system_clock::now() - start;&#13;
  }&#13;
private:&#13;
  std::chrono::nanoseconds&amp; result;&#13;
  const std::chrono::time_point&lt;std::chrono::system_clock&gt; start;&#13;
};&#13;
&#13;
long cached_fib_sum(const size_t&amp; n) { <span class="ent">➍</span>&#13;
  static std::map&lt;long, long&gt; cache;&#13;
  // TODO: Implement me&#13;
  return 0;&#13;
}&#13;
&#13;
int main() {&#13;
&#13;
  size_t samples{ 1'000'000 };&#13;
  std::chrono::nanoseconds elapsed;&#13;
<span epub:type="pagebreak" id="page_461"/>&#13;
  {&#13;
    Stopwatch stopwatch{elapsed};&#13;
    volatile double answer;&#13;
    while(samples--) {&#13;
      answer = fib_sum(random()); <span class="ent">➎</span>&#13;
      //answer = cached_fib_sum(random()); <span class="ent">➏</span>&#13;
    }&#13;
  }&#13;
  printf("Elapsed: %g s.\n", elapsed.count() / 1'000'000'000.); <span class="ent">➐</span>&#13;
}</pre>&#13;
<p class="indent">This program contains a computationally intensive function <span class="literal">fib_sum</span> <span class="ent">➊</span> that computes the sum of a Fibonacci series with a given length. Adapt your code from Exercise 13-1 by (a) generating the appropriate vector and (b) summing over the result with a range-based <span class="literal">for</span> loop. The <span class="literal">random</span> function <span class="ent">➋</span> returns a random number between 1,000 and 2,000, and the <span class="literal">Stopwatch</span> class <span class="ent">➌</span> adopted from <a href="ch12.xhtml#ch12ex25">Listing 12-25</a> in <a href="ch12.xhtml#ch12">Chapter 12</a> helps you determine elapsed time. In the program’s <span class="literal">main</span>, you perform a million evaluations of the <span class="literal">fib_sum</span> function using random input <span class="ent">➎</span>. You time how long this takes and print the result before exiting the program <span class="ent">➐</span>. Compile the program and run it a few times to get an idea of how long your program takes to run. (This is called a <em>baseline</em>.)</p>&#13;
<p class="noindent"><strong>13-6.</strong> Next, comment out <span class="ent">➎</span> and uncomment <span class="ent">➏</span>. Implement the function <span class="literal">cached_fib_sum</span> <span class="ent">➍</span> so you first check whether you’ve computed <span class="literal">fib_sum</span> for the given length yet. (Treat the length <span class="literal">n</span> as a key into the cache.) If the key is present in the cache, simply return the result. If the key isn’t present, compute the correct answer with <span class="literal">fib_sum</span>, store the new key-value entry into <span class="literal">cache</span>, and return the result. Run the program again. Is it faster? Try <span class="literal">unordered_map</span> instead of <span class="literal">map</span>. Could you use a <span class="literal">vector</span> instead? How fast can you get the program to run?</p>&#13;
<p class="noindent">Implement a  Matrix class like  <span class="literal">SquareMatrix</span> in <a href="ch13.xhtml#ch13ex38">Listing 13-38</a>. Your  <span class="literal">Matrix</span> should allow unequal numbers of rows and columns. Accept as your constructor’s first argument the number of rows in  <span class="literal">Matrix</span>.</p>&#13;
</div>&#13;
<div class="box6" id="bm02">&#13;
<p class="boxtitle-d"><strong>FURTHER READING</strong></p>&#13;
<ul>&#13;
<li class="noindent"><em>ISO International Standard ISO/IEC (2017) — Programming Language C++</em> (International Organization for Standardization; Geneva, Switzerland;  <em><a href="https://isocpp.org/std/the-standard/">https://isocpp.org/std/the-standard/</a></em>)</li>&#13;
<li class="noindent"><em>The Boost C++ Libraries</em>, 2nd Edition, by Boris Schäling (XML Press, 2014)</li>&#13;
<li class="noindent"><em>The C++ Standard Library: A Tutorial and Reference</em>, 2nd Edition, by Nicolai M. Josuttis (Addison-Wesley Professional, 2012)</li>&#13;
</ul>&#13;
</div>&#13;
</body></html>