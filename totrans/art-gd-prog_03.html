<html><head></head><body><div id="sbo-rt-content"><section>
<header>
<h1 class="chapter">
<span class="ChapterNumber"><span epub:type="pagebreak" title="57" id="Page_57"/>3</span><br/>
<span class="ChapterTitle">2D Graphics and Animation</span></h1>
</header><figure class="opener">
<img src="Images/chapterart.png" alt="" width="206" height="206"/>
</figure>
<h2 id="h1-501645c03-0001" class="HeadProject"><span><span epub:type="pagebreak" title="58" id="Page_58"/>Sketch 27: Saving an Image and Adjusting Transparency</span></h2>
<p class="BodyFirst">We are going to write a sketch that will allow the user to select a color in an image that will become transparent, and then save the image as a GIF. We can save any <code>PImage</code> in a file, just as most image files can be read into a <code>PImage</code>. If <code>img</code> is a <code>PImage</code> variable, we can save it as a file using this function call:</p>
<pre><code>img.save ("image.jpg");</code></pre>
<p>The parameter is the name of the file to be created. In the situation above, it will create a file named <em>image.jpg</em> and save the pixels of the <code>PImage</code> in JPEG format. The format is conveniently determined by the last three letters of the filename: <em>.jpg</em> for a JPEG file, <em>.gif</em> for a GIF file, <em>.png</em> for a PNG file, and so on. If no <code>PImage</code> variable is given, Processing saves the image that appears in the sketch window. </p>
<p>For this sketch, the first step is to read and display the image. Next, we position the mouse over a pixel with the color we want to make transparent, and click the button. Finally, we save the image in a format that allows transparency (GIF).</p>
<p>In Sketch 2 I mentioned <span class="KeyTerm">transparent</span> colors. We can set a fourth color component, referred to as <span class="KeyTerm">alpha</span>, to a value between 0 (completely transparent) and 255 (completely opaque), as long as the <code>PImage</code> color format allows transparency; the format that does this is <code>ARGB</code>. In this sketch, when the image is read in, we make a copy as in the previous sketch, but using <code>ARGB</code> as the color format. When we click the mouse button, the program looks at the pixel at the cursor’s coordinates and adds an alpha value of 0 to the color coordinates. Then the color in the <code>PImage</code> is updated with the new alpha value.</p>
<p>The original image that we read from the file is a variable named <code>img1</code>; the copy that includes alpha values is <code>img2</code>. Processing makes a copy of the image using the following statement, as we do at <span class="CodeAnnotation" aria-label="annotation2">2</span>:</p>
<pre><code>img2 = createImage (img1.width, img1.height, ARGB);</code></pre>
<p>This creates an empty image of the correct size, and now we must copy all of the pixels from <code>img1</code> into <code>img2</code>. When we do so, the pixels in <code>img2</code> have the alpha component, because it was specified in the <code>createImage()</code> call. When a mouse click specifies a background color, all pixels of that color are given an alpha value of 0 <span class="CodeAnnotation" aria-label="annotation1">1</span>. Then <code>img2</code> is saved in a file named <em>out.gif</em>. </p>
<p>The program ends with a call to <code>exit()</code>, because otherwise it would continue to save the same file again and again.</p>
<p>Why is it important to set a transparent background for an image? Computer games!</p>
<aside epub:type="sidebar">
<div class="top hr"><hr/></div>
<section class="note">
<h2><span class="NoteHead">NOTE</span></h2>
<p>	The string parameter in<code> </code><code>img.save</code><code> (</code><code>"</code><code>image.jpg</code><code>"</code><code>);</code> can include a full path name, so the file can be saved in any directory on your PC.</p>
<div class="bottom hr"><hr/></div>
</section>
</aside>
<aside epub:type="sidebar">
<div class="top hr"><hr/></div>
<section class="boxcustom1">

<pre><code><span epub:type="pagebreak" title="59" id="Page_59"/>PImage img1, img2;
color c=color(0,0,0);
void setup ()
{
  size(100,100);
  surface.setResizable(true);
  img1 = loadImage ("image.bmp");
  surface.setSize (img1.width, img1.height);
  img2 = duplicate (img1);
}
void draw ()
{
  color c1;
  background (255);
  image (img1, 0, 0);
  if (mousePressed)
  {
    c = get(mouseX, mouseY);
    for (int i=0; i&lt;width; i++)
      for (int j=0; j&lt;height; j++)
      {
        c1 = img1.get(i,j);
        if (c1 == c)
        {
          <span class="CodeAnnotationHang" aria-label="annotation1">1</span> c1 = color(red(c1), green(c1), blue(c1), 0);
          img2.set (i,j,c1);
        }
      }
    img2.save ("out.gif");
    exit();
  }
}
PImage duplicate (PImage from)
{
  PImage newImage;
  color pixel;
  if (from == null) return from;
  <span class="CodeAnnotationHang" aria-label="annotation2">2</span> newImage = createImage (from.width, from.height, ARGB);
  for (int i=0; i&lt;from.width; i++)
    for (int j=0; j&lt;from.height; j++)
    {
      pixel = from.get (i,j);
      newImage.set(i,j,pixel);
    }
  return newImage;
}</code></pre>
<figure class="graphic"><img src="Images/g27001.png" alt="g27001" width="558" height="249"/></figure>
<div class="bottom hr"><hr/></div>
</section>
</aside>
<h2 id="h1-501645c03-0002" class="HeadProject"><span><span epub:type="pagebreak" title="60" id="Page_60"/>Sketch 28: Bouncing an Object in a Window</span></h2>
<p class="BodyFirst">This sketch illustrates a good way to check whether an object is within a sketch window (though it is only completely accurate when the object is circular). The object here is a circle, or a ball if you prefer. The program moves the ball, and when the ball reaches the window boundary (the “wall”), it bounces, or reverses direction. </p>
<p>A simple test establishes whether the ball has exceeded the boundary. In the case of the right boundary wall, for example, it’s whether <code>x + radius &gt; width</code> <span class="CodeAnnotation" aria-label="annotation2">2</span>, where <code>x</code> is the ball’s center position, <code>radius</code> is the ball’s radius, and <code>width</code> is the width of the window. If the ball is moving slowly enough, we can simply reverse the direction of motion when the ball passes this test by changing <code>dx</code> (the amount the ball moves horizontally between each frame) to <code>-dx</code>. However, this approach isn’t completely accurate, and it gets worse when the ball moves at high speeds. Why? Because the ball will move past the boundary before the program determines that it has reached the boundary. Consider the situation in <a href="#figure28-1" id="figureanchor28-1">Figure 28-1</a>. </p>
<figure>
<img src="Images/f28001.png" alt="f28001" class="" width="563" height="341"/>
<figcaption><p><a id="figure28-1">Figure 28-1</a>: A fast-moving ball might overshoot a boundary before you can tell it to bounce back.</p></figcaption>
</figure>
<p>If the chosen <code>dx</code> value has the ball moving several diameters per frame, it can easily be on the left of the wall in one frame and on the right of the wall in the next. At some time in between, it must have collided with the wall. In that case, the amount the ball has overshot the wall should be found, and the ball should be placed an equivalent distance to the left of the wall, to simulate a bounce. We calculate that distance as <code>delta</code> (Δ), and it equals <code>(x + radius) - width</code> <span class="CodeAnnotation" aria-label="annotation1">1</span> for a circle. Given this distance, the ball’s new, post-bounce x position is <code>width - delta - radius</code> <span class="CodeAnnotation" aria-label="annotation3">3</span>, as shown at the bottom of <a href="#figure28-1">Figure 28-1</a>. </p>
<p>At the left side of the window, we know the ball has overshot the boundary when <code>x &lt; radius </code><span class="CodeAnnotation" aria-label="annotation4">4</span>. In this case, we reposition the ball by setting <code>x</code> to <code>(2 * radius) - x</code> <span class="CodeAnnotation" aria-label="annotation5">5</span>, and we reverse the ball’s direction of motion.</p>
<p>The vertical (<em>y</em>) situation is symmetrical <span class="CodeAnnotation" aria-label="annotation6">6</span>.</p>
<aside epub:type="sidebar">
<div class="top hr"><hr/></div>
<section class="note">
<h2><span class="NoteHead">NOTE</span></h2>
<p>	Most objects are not circular but can have a (virtual, invisible) circle drawn around them, and we can use this circle to detect collisions against the boundary.</p>
<div class="bottom hr"><hr/></div>
</section>
</aside>
<aside epub:type="sidebar">
<div class="top hr"><hr/></div>
<section class="boxcustom1">
<pre><code>int x=320, y=240;   // Coordinates of the circle (ball)
int radius=20;      // Size of the circle (ball)
int dx=42, dy=22;   // Speed of the circle (ball)

void setup ()
{
  size (640, 480);       // Typical window size
  fill (255, 0, 255);    // Magenta fill
  noStroke();            // Don't draw outlines
}

void draw ()
{
  background (255);                    // White background
  ellipse (x, y, radius*2, radius*2);  // Draw the ball
  x = x + dx;  y = y + dy;             // Move
  xbounce();
  ybounce();
}

void xbounce ()
{
  int delta = 0;
  <span class="CodeAnnotationHang" aria-label="annotation1">1</span> delta = (x+radius) - width;
  <span class="CodeAnnotationHang" aria-label="annotation2">2</span> if (x+radius &gt; width)  // right side
  {
    <span class="CodeAnnotationHang" aria-label="annotation3">3</span> x = width-delta-radius;
    dx = -dx;
  <span class="CodeAnnotationHang" aria-label="annotation4">4</span> } else if (x &lt; radius) // left side
  {
    <span class="CodeAnnotationHang" aria-label="annotation5">5</span> x = (2*radius)-x;
    dx = -dx;            // Reverse x-direction
  }
}
  <span class="CodeAnnotationHang" aria-label="annotation6">6</span> void ybounce ()
{
  int delta = 0;
  delta = (y+radius) - height;
  if (y &lt; radius)               // top side
  {
    y = (2*radius)-y;
    dy = -dy; 
  } else if (y+radius &gt; height) // bottom side
  {
    y = height-delta-radius;
    dy = -dy;                   // Reverse y-direction
  }
}</code></pre>
<span epub:type="pagebreak" title="61" id="Page_61"/><figure class="graphic"><img src="Images/g028002.png" alt="g028002" width="346" height="1062"/></figure>
<div class="bottom hr"><hr/></div>
</section>
</aside>
<h2 id="h1-501645c03-0003" class="HeadProject"><span><span epub:type="pagebreak" title="62" id="Page_62"/>Sketch 29: Basic Sprite Graphics</span></h2>
<p class="BodyFirst">We can combine the previous two sketches to show how programmers move sprites about in computer games. A <span class="KeyTerm">sprite</span> is a relatively low-resolution graphic that represents an object in a game. Sprites are usually primitive shapes or imported images. If the latter, the sprite image must have a transparent color so that we can see the background behind the sprite; otherwise the sprite would look like a rectangle of solid color with an image within it.</p>
<p>This sketch uses the rocket of Sketch 27 as the sprite and the code of Sketch 28 to move it about in the window. The rocket will move over a background image of stars to complete the game-like appearance.</p>
<p>The test to see whether the rocket has reached a side differs from the circle example because the sprite is a rectangular image drawn from the upper-left corner, and the distance to the boundary differs between left/right and up/down. The test against the left edge is nearly the same as before, but the offset by the radius is missing because the x-coordinate is on the left side of the sprite and not at its center <span class="CodeAnnotation" aria-label="annotation2">2</span>:</p>
<pre><code>if (px &lt; 0) // left side
{
  px = -px;
  dx = -dx;         // Reverse x-direction
}</code></pre>
<p>The test on the right is different because the entire width of the sprite is also to the right of the coordinate <code>px</code> <span class="CodeAnnotation" aria-label="annotation1">1</span>:</p>
<pre><code>delta = (px+sprite.width) - width;
if (delta &gt; 0) // right side
{
  px = width-delta-sprite.width;
  dx = -dx;
}</code></pre>
<p>So <code>px+sprite.width</code> is the coordinate for the right side of the sprite. </p>
<p>The checks are symmetrical for the y-coordinate <span class="CodeAnnotation" aria-label="annotation3">3</span>.</p>
<aside epub:type="sidebar">
<div class="top hr"><hr/></div>
<section class="note">
<h2><span class="NoteHead">NOTE</span></h2>
<p>	Most games allow the player to move one or more of the sprites. The convention is to do this using key presses: <span class="KeyCaps">w</span> for up, <span class="KeyCaps">a</span> for left, <span class="KeyCaps">d</span> for right, and <span class="KeyCaps">s</span> for down. You’d put the code to move the sprite in the function <code>key</code><code>P</code><code>ressed(</code><code>)</code>:</p>
<pre><code>void keyPressed()
{
  if (key == 'w') py = py - 1;
  if (key == 's') py = py + 1;
  if (key == 'd') px = px + 1;
  if (key == 'a') px = px - 1;
}</code></pre><div class="bottom hr"><hr/></div>
</section>
</aside>
<aside epub:type="sidebar">
<div class="top hr"><hr/></div>
<section class="boxcustom1">

<pre><code>PImage img1, sprite;
color c=color(0,0,0);
int px=100, py=100, dx=2, dy=1;

void setup ()
{
  size(100,100);
  surface.setResizable(true);
  img1 = loadImage ("background.bmp");
  surface.setSize (img1.width, img1.height);
  sprite = loadImage("image.gif");
  sprite.resize (90, 50);
}

void draw ()
{
  background (255);
  image (img1, 0, 0);
  image (sprite, px, py);
  px = px + dx; py = py + dy;
  xbounce(); ybounce();
}

void xbounce ()
{
  int delta;
  delta = (px+sprite.width) - width;
  <span class="CodeAnnotationHang" aria-label="annotation1">1</span> if (delta &gt; 0)     // right side
  {
    px = width-delta-sprite.width;
    dx = -dx;
  <span class="CodeAnnotationHang" aria-label="annotation2">2</span> } else if (px &lt; 0) // left side
  {
    px = -px;
    dx = -dx;        // Reverse x-direction
  }
}
void ybounce ()
{
  int delta;
  delta = (py+sprite.height) - height;
  <span class="CodeAnnotationHang" aria-label="annotation3">3</span> if (py &lt; 0)           // top side
  {
    py = -py;
    dy = -dy;
  } else if (delta &gt; 0) // bottom side
  {
    py = height-delta-sprite.height;
    dy = -dy;           // Reverse y-direction
  }
}</code></pre>
<span epub:type="pagebreak" title="63" id="Page_63"/><figure class="graphic"><img src="Images/g29001.png" alt="g29001" width="205" height="1082"/></figure>
<div class="bottom hr"><hr/></div>
</section>
</aside>
<h2 id="h1-501645c03-0004" class="HeadProject"><span><span epub:type="pagebreak" title="64" id="Page_64"/>Sketch 30: Detecting Sprite-Sprite Collisions</span></h2>
<p class="BodyFirst">It is a relatively simple matter to decide whether a sprite is still within a window, because the size of the window remains fixed and the window doesn’t move. But what if there were many sprites moving at the same time? How would we determine if any two had collided when both were moving? The situation of circular objects is the simplest and is a general solution, so this sketch will handle an arbitrary number of circular objects (balls) that will bounce off the boundaries and each other.</p>
<p>The coordinates of each ball will be stored in the <code>xpos[]</code> and <code>ypos[]</code> arrays <span class="CodeAnnotation" aria-label="annotation1">1</span>. Drawing object <code>i</code> is simple <span class="CodeAnnotation" aria-label="annotation2">2</span>:</p>
<pre><code>ellipse (xpos[i], ypos[i], 10, 10);</code></pre>
<p>Any two objects collide if they get nearer to each other than twice the radius, or in this case 10 pixels. These are the steps in the sketch:</p>
<ol class="decimal">
<li value="1">Define positions and speeds (<code>dx</code>, <code>dy</code>) for each of <code>nballs</code> objects.</li>
<li value="2">Each step (frame) is defined by a call to <code>draw()</code>. First, draw a circle at each location <code>xpos[i]</code>, <code>ypos[i]</code> <span class="CodeAnnotation" aria-label="annotation2">2</span>.</li>
<li value="3">Change the position: <code>xpos[i] = xpos[i] + dx[i]</code>, and the same for <code>y</code> <span class="CodeAnnotation" aria-label="annotation3">3</span>.</li>
<li value="4">Check for a collision with the boundary (bounce), and if there is one, implement the reaction to the collision. A bounce? An explosion? <span class="CodeAnnotation" aria-label="annotation4">4</span>.
<p class="ListBody">For each ball, check the distance between it and every other ball. If the distance is less than twice the radius, then change the direction of both balls (implementing a collision as a bounce) <span class="CodeAnnotation" aria-label="annotation5">5</span>.</p></li>
</ol>
<p>And that’s it. The <code>bounce()</code> function <span class="CodeAnnotation" aria-label="annotation6">6</span> is a little different from the previous one, but it effectively does the same thing. The <code>distance()</code> function calculates the Euclidean distance between the two balls, as you saw in Sketch 24. If two balls overlap after bouncing, they could stick together until they collide with another ball.</p>
<aside epub:type="sidebar">
<div class="top hr"><hr/></div>
<section class="note">
<h2><span class="NoteHead">NOTE</span></h2>
<p>	A rectangular object <em>N</em>×<em>M</em> pixels in size (<em>N</em> &gt; <em>M</em>) has a circle that surrounds it that can be used to check collisions. The center is (<em>N</em>/2, <em>M</em>/2) and the width is <em>N</em>. Using a bounding circle is not precise, but it is quick. The enclosing circle for the spaceship in Sketch 29 is shown in <a href="#figure30-1" id="figureanchor30-1">Figure 30-1</a>.</p>
<div class="bottom hr"><hr/></div>
</section>
</aside>
<figure>
<img src="Images/f30001.png" alt="f30001" class="" width="465" height="400"/>
<figcaption><p><a id="figure30-1">Figure 30-1</a>: The enclosing circle for a rectangular object</p></figcaption>
</figure>
<aside epub:type="sidebar">
<div class="top hr"><hr/></div>
<section class="boxcustom1">

<pre><code>int MAXBALLS = 100;
  <span class="CodeAnnotationHang" aria-label="annotation1">1</span> int []xpos = new int[MAXBALLS];
int []ypos = new int[MAXBALLS];
int nballs = 30;
int []dx= new int[MAXBALLS];
int []dy = new int[MAXBALLS];
void setup ()
{
  size (400, 400);
  for (int i=0; i&lt;nballs; i=i+1)
  {
    xpos[i] = (int)random(width-10)+5;
    ypos[i] = (int)random(height-10)+5;
    dx[i] = (int)random(10)-5;
    dy[i] = (int)random(10)-5;
  }
}

void draw ()
{
  background (255);
  for (int i = 0; i&lt;nballs; i++)
  {
    <span class="CodeAnnotationHang" aria-label="annotation2">2</span> ellipse (xpos[i], ypos[i], 10, 10);    xpos[i] = xpos[i] + dx[i];
    <span class="CodeAnnotationHang" aria-label="annotation3">3</span> ypos[i] = ypos[i] + dy[i];
    <span class="CodeAnnotationHang" aria-label="annotation4">4</span> bounce(i);
  }
  for (int i=0; i&lt;nballs; i++)
    for (int j=i+1; j&lt;nballs; j++)
      <span class="CodeAnnotationHang" aria-label="annotation5">5</span> if (distance (xpos[i], ypos[i], xpos[j], ypos[j]) &lt; 10)
      {
        dx[i] = -dx[i]; dy[i] = -dy[i];
        dx[j] = -dx[j]; dy[j] = -dy[j];
      }
}

float distance (int x0, int y0, int x1, int y1)
{ return sqrt ( (x0-x1)*(x0-x1) + (y0-y1)*(y0-y1) ); }

  <span class="CodeAnnotationHang" aria-label="annotation6">6</span> void bounce (int i)
{
  if (xpos[i] &lt; 10) dx[i] = -dx[i];
  if (xpos[i] &gt; width-10) dx[i] = -dx[i];
  if (ypos[i] &lt; 10) dy[i] = -dy[i];
  if (ypos[i] &gt; height-10) dy[i] = -dy[i];
  xpos[i] = xpos[i] + dx[i]; ypos[i] = ypos[i] + dy[i];
}</code></pre>
<span epub:type="pagebreak" title="65" id="Page_65"/><figure class="graphic"><img src="Images/g30001.png" alt="g30001" width="484" height="484"/></figure>
<div class="bottom hr"><hr/></div>
</section>
</aside>
<h2 id="h1-501645c03-0005" class="HeadProject"><span><span epub:type="pagebreak" title="66" id="Page_66"/>Sketch 31: Animation—Generating TV Static</span></h2>
<p class="BodyFirst">We have used random numbers before, in Sketches 8 and 30. Random numbers serve a few important functions in games, simulations, and other software:</p>
<ul>
<li>Nature uses unpredictable forms and shapes. Placing trees in a forest in a two-dimensional grid is a giveaway that there was a mind at work in the planting. This does not happen in nature. Instead, trees in a forest have an average distance from each other and seem otherwise to form a random collection.</li>
<li>Intelligent creatures do not behave predictably. Cars on a freeway that all behave in the same manner look very odd. Cars have random distances from each other, random speeds, and random behaviors within a possible range.</li>
<li>When playing poker or craps, the cards and dice ought to display random values, or the game is simply no fun.</li>
</ul>
<p>This sketch draws a television set that looks as if it were tuned to a vacant channel. What is seen on the screen used to be called <em>snow</em>, and it is really pixels created by random voltages from signals received from space and various local electronic and electrical devices. We cannot predict what the TV will receive at any particular moment, so we draw a 2D set of random grey pixel values. This set of values changes every time the screen updates. There is an impression of random motion, rapid flashing of spots on the screen, but no organized images.</p>
<p>First, we display a background image of a TV set <span class="CodeAnnotation" aria-label="annotation1">1</span> and then set the pixels within the screen section to random black/white values each time <code>draw()</code> is called <span class="CodeAnnotation" aria-label="annotation3">3</span>:</p>
<pre><code>if (random(3)&lt;1) set (i, j, BLACK);
  else set (i, j, WHITE);</code></pre>
<p>To make it appear as though a channel were poorly tuned in, we could display an image faintly over the static by setting the alpha for the image to a low value, perhaps 30 or so. The static would be visible through the image. The <code>tint()</code> function changes the color and transparency of whatever is drawn from then on, so we could use it to change the transparency of the channel image, as follows:</p>
<pre><code>tint (255, 255, 255, 127);
image (back, 49, 49);</code></pre>
<p>The parameters to <code>tint()</code> are color coordinates, the first three being RGB and the fourth transparency (alpha). In the preceding example, the color is white (no actual tint) but the transparency is 127, which is half transparent.</p>
<p>In the code for this sketch, the tint and TV image are commented out. To see the image, remove the comment characters from those two lines <span class="CodeAnnotation" aria-label="annotation2">2</span>.</p>
<aside epub:type="sidebar">
<div class="top hr"><hr/></div>
<section class="boxcustom1">

<pre><code><span epub:type="pagebreak" title="67" id="Page_67"/>PImage tv;
PImage back;
int x0=250, y0=445; 
color WHITE = color (255, 255, 255, 90);
color BLACK = color (0,0,0, 90);

void setup ()
{
  size(350, 250);
  tv = loadImage("tv.jpg");  // Load TV set image
  back = loadImage ("screen.jpg");
}

void draw ()
{
  background (90, 90, 200);   // Blue background
  <span class="CodeAnnotationHang" aria-label="annotation1">1</span> image (tv, 20, 20);         // Display the TV
  snow (20, 20);              // Display random pixels on the screen
<span class="CodeAnnotationHang" aria-label="annotation2">2</span> //  tint (255, 60); 
//  image (back, 49, 49);
}

// Display random black/white pixels
void snow(int x, int y)
{
  for (int i=x+29; i&lt;x+160; i++)     // TV screen coordinate offsets fixed
    for (int j=y+29; j&lt;y+115; j++)   // at UL = 29,29 and LR = 152,115
      <span class="CodeAnnotationHang" aria-label="annotation3">3</span> if (random(3)&lt;1) set (i, j, color(0,0,0,4));
        else set (i,j, WHITE);
}</code></pre>
<figure class="graphic"><img src="Images/g31001.png" alt="g31001" width="481" height="481"/></figure>
<figure class="graphic"><img src="Images/g31002.png" alt="g31002" width="481" height="481"/></figure>
<div class="bottom hr"><hr/></div>
</section>
</aside>
<h2 id="h1-501645c03-0006" class="HeadProject"><span><span epub:type="pagebreak" title="68" id="Page_68"/>Sketch 32: Frame Animation</span></h2>
<p class="BodyFirst">Animation involves displaying a sequence of still images on the screen at such a rate that the human visual system interpolates changes in position in the images and perceives motion. It is an illusion, in much the same way that any motion picture is an illusion. The previous sketch animated a display in a very basic manner, creating the illusion of random TV images by generating them with code. Most animations require that an image sequence be created by an artist and then displayed as a sequence.</p>
<p>For a Processing sketch to display an animation, the program has to read in the images (<span class="KeyTerm">frames</span>) to be displayed and then display them one after the other. The set of frames can be stored in an array of <code>PImage</code> values, one per frame.</p>
<p>The two examples in this sketch use an image sequence that represents the gait of a human; the 11 images compose one entire cycle of a single step, and repeating them makes it appear as if the character is walking.</p>
<h3 id="h2-501645c03-0001">Example A</h3>
<p class="BodyFirst">Eleven images, named <em>a000.bmp</em> through <em>a010.bmp</em>, represent the animation. The program reads the images into consecutive elements of the <code>frames</code> array <span class="CodeAnnotation" aria-label="annotation1">1</span>. The <code>draw()</code> function displays the next image in sequence each time it’s called, increasing an index variable <code>n</code> from 0 to 10 and decreasing it to 0 again repeatedly <span class="CodeAnnotation" aria-label="annotation2">2</span>.</p>
<h3 id="h2-501645c03-0002">Example B</h3>
<p class="BodyFirst">In Example A we needed to know in advance how many images belonged to the animation. In Example B we only require that the names of the files begin with <em>a000.bmp</em> and that the number increases by one for consecutive images. When the program fails to read an image file, as indicated by the fact that <code>loadImage()</code> returns <code>null</code>, the program presumes that all of the images have been loaded <span class="CodeAnnotation" aria-label="annotation1">1</span>. The program counts the images as they are read and then displays them as before.</p>
<p>The loop within which the images are loaded has a <code>break</code> <span class="CodeAnnotation" aria-label="annotation2">2</span> statement in it to escape the loop when <code>null</code> is detected.</p>
<aside epub:type="sidebar">
<div class="top hr"><hr/></div>
<section class="boxcustom1">
<p class="BoxCodeLabel">Example A</p>
<pre><code>PImage []frames = new PImage[12];
int nFrames = 11, n=0;
void setup ()
{
  size(100,100);
  surface.setResizable(true);
  <span class="CodeAnnotationHang" aria-label="annotation1">1</span> frames[0] = loadImage("a000.bmp");
  frames[1] = loadImage("a001.bmp");
  frames[2] = loadImage("a002.bmp");
  frames[3] = loadImage("a003.bmp");
  frames[4] = loadImage("a004.bmp");
  frames[5] = loadImage("a005.bmp");
  frames[6] = loadImage("a006.bmp");
  frames[7] = loadImage("a007.bmp");
  frames[8] = loadImage("a008.bmp");
  frames[9] = loadImage("a009.bmp");
  frames[10] = loadImage("a010.bmp");
  surface.setSize(frames[0].width, frames[0].height);
}
void draw ()
{
  frameRate (10);
  <span class="CodeAnnotationHang" aria-label="annotation2">2</span> image (frames[n], 0, 0);      // Display the Frame
  n = (n + 1)%nFrames;
}</code></pre>
<span epub:type="pagebreak" title="69" id="Page_69"/><figure class="graphic"><img src="Images/g032001.png" alt="g032001" width="530" height="161"/></figure>
<p class="BoxCodeLabel">Example B</p>
<pre><code>int MAXFRAMES = 100;
PImage []frames = new PImage[MAXFRAMES];
int nFrames = 0, n=0;
void setup ()
{
  for (int i=0; i&lt;MAXFRAMES; i++)
  {
    if (i&lt;10)
      frames[i] = loadImage("a00"+i+".bmp");
    else
      frames[i] = loadImage("a0"+i+".bmp");
    <span class="CodeAnnotationHang" aria-label="annotation1">1</span> if (frames[i] == null)
    {
      nFrames = i;
      <span class="CodeAnnotationHang" aria-label="annotation2">2</span> break;
    }
  }
  size(100,100);
  surface.setResizable(true);
  surface.setSize(frames[0].width, frames[0].height);
}
void draw ()
{
  frameRate (10); 
  image (frames[n], 0, 0); // Display the Frame
  n = (n + 1)%nFrames;
}</code></pre>
<div class="bottom hr"><hr/></div>
</section>
</aside>
<h2 id="h1-501645c03-0007" class="HeadProject"><span><span epub:type="pagebreak" title="70" id="Page_70"/>Sketch 33: Flood Fill—Filling in Complex Shapes</span></h2>
<p class="BodyFirst">Drawing a rectangle or ellipse that is filled with a particular color is easy to do in Processing. You simply specify a fill color using the <code>fill()</code> function and then draw the shape. However, there’s no function for filling an arbitrary shape or region, so let’s make one. It has the advantage of showing you how filling is done in general.</p>
<p>This sketch reads an image with a white background that contains regions outlined with black (though you can use other colors). The regions do not have to be regular polygons, but they should be <span class="KeyTerm">closed</span>, in that there is an inside and an outside, with no gaps in the edges. When the user clicks on a pixel, the region surrounding that pixel will be filled with a random color.</p>
<p>The pixel that is clicked on has a color, the background color (<code>bgcolor</code> in the sketch). A random color will be selected for the fill color (variable <code>fillColor</code>). The goal is to set all of the pixels within the region that currently have the background color value to the fill color. The first step is to set the selected pixel to the fill color, followed by setting all neighboring pixels repeatedly, until no more candidates remain.</p>
<p>After the first pixel is changed, every background-colored pixel that is a neighbor of it is also set to the fill color <span class="CodeAnnotation" aria-label="annotation1">1</span>. A <span class="KeyTerm">neighbor</span> is defined as a pixel that is immediately adjacent either vertically or horizontally. Then all of the pixels are scanned again, and any background pixel that is a neighbor of a fill-colored pixel is set to the fill color. The process is shown in <a href="#figure33-1" id="figureanchor33-1">Figure 33-1</a>.</p>
<figure>
<img src="Images/f33001.png" alt="f33001" class="" width="811" height="326"/>
<figcaption><p><a id="figure33-1">Figure 33-1</a>: Filling in neighboring pixels</p></figcaption>
</figure>
<p>The process is repeated until no change is made. The process stops at the boundary because boundary pixels do not have the background color and are not changed. This is not the only method for implementing a fill, nor is it the fastest, but it is probably the easiest to comprehend.</p>
<p>The <code>mouseReleased()</code> function sets the values of the <code>bgColor</code> and <code>fillColor</code> variables and sets the first (<span class="KeyTerm">seed</span>) pixel to the fill color <span class="CodeAnnotation" aria-label="annotation3">3</span>. The <code>nay()</code> function returns true if the pixel indicated by the parameters is a neighbor to a fill-colored pixel <span class="CodeAnnotation" aria-label="annotation2">2</span>. Each time <code>draw()</code> is called (once per frame), it displays one iteration of the filling process, so the process appears animated.</p>
<aside epub:type="sidebar">
<div class="top hr"><hr/></div>
<section class="boxcustom1">
<pre><code>PImage inputImage;
color bgColor, fillColor;

void setup ()
{
  size(100,100);
  surface.setResizable(true);
  inputImage = loadImage ("image.bmp");
  surface.setSize (inputImage.width, inputImage.height);
  bgColor = inputImage.get(0,0);
  fillColor = color (40, 200, 30);
}

void draw ()
{
  image (inputImage, 0, 0);

  for (int i=0; i&lt;inputImage.width; i++)
    for (int j=0; j&lt;inputImage.height; j++)
      if ((inputImage.get(i,j)==bgColor) &amp;&amp; nay(i,j,fillColor))
      {
        <span class="CodeAnnotationHang" aria-label="annotation1">1</span> inputImage.set(i,j,fillColor);
      }
}

<span class="CodeAnnotationHang" aria-label="annotation2">2</span> boolean nay (int x, int y, int c)
{
  if (get(x-1, y) == c) return true;
  if (get(x+1, y) == c) return true;
  if (get(x, y-1) == c) return true;
  if (get(x, y+1) == c) return true;
  return false;
}

void mouseReleased ()
{
  <span class="CodeAnnotationHang" aria-label="annotation3">3</span> bgColor = get(mouseX, mouseY);
  fillColor = color (random(128,255),random(128,255),random(128,255));
  inputImage.set (mouseX, mouseY, fillColor);


}</code></pre>
<span epub:type="pagebreak" title="71" id="Page_71"/><figure class="graphic"><img src="Images/g033002.png" alt="g033002" width="380" height="265"/></figure>
<div class="bottom hr"><hr/></div>
</section>
</aside>
</section>
</div></body></html>