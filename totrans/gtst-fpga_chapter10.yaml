- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">10</samp> <samp class="SANS_Dogma_OT_Bold_B_11">NUMBERS
    AND MATH</samp>
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">10</samp> <samp class="SANS_Dogma_OT_Bold_B_11">数字与数学</samp>
- en: '![](../images/opener-img.png)'
  id: totrans-1
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/opener-img.png)'
- en: Throughout this book, I’ve been saying that FPGAs are good at performing mathematical
    computations quickly. I’ve also been saying that FPGAs are good at doing tasks
    in parallel, and that the combination of these two assets—fast math done in parallel—is
    one of their killer features. In low-level Verilog or VHDL code, however, working
    with numbers and math is full of pitfalls.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书中，我一直在说 FPGAs 擅长快速执行数学运算。我还说过，FPGAs 擅长并行执行任务，而这两项优势——快速数学运算和并行处理——是它们的杀手级特性。然而，在低级
    Verilog 或 VHDL 代码中，处理数字和数学是充满陷阱的。
- en: In this chapter, we’ll explore exactly how FPGAs manage mathematical calculations
    so you can avoid those pitfalls. To understand the details of how operations like
    addition, subtraction, multiplication, and division work, we also need to understand
    how to represent numbers, both positive and negative, with or without decimals,
    inside your FPGA. It’s time for a journey in the wonderful world of computer arithmetic.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨 FPGAs 如何管理数学运算，以便你可以避免那些陷阱。要了解加法、减法、乘法和除法等运算的细节，我们还需要了解如何在 FPGA 内部表示数字，不论是正数还是负数，是否带小数。现在是时候进入计算机算术的奇妙世界了。
- en: <samp class="SANS_Futura_Std_Bold_B_11">Numerical Data Types</samp>
  id: totrans-4
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">数值数据类型</samp>
- en: There are many ways to represent numbers in Verilog or VHDL, as is true with
    all programming languages. For example, if you want to store only whole numbers,
    you can use an integer data type, but if you need to store fractional numbers,
    you’ll need a data type that can represent decimals. Choosing the right type for
    the data you’re trying to represent is critical in any programming language. If
    you assign data to the wrong type, you’ll either get compiler errors or, worse,
    a design that behaves strangely. For example, trying to assign a decimal number
    to an integer data type could truncate the fractional component, causing an unintended
    rounding operation.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Verilog 或 VHDL 中表示数字有许多方法，这一点与所有编程语言一样。例如，如果你只需要存储整数，可以使用整数数据类型，但如果需要存储小数，则需要使用可以表示小数的数据类型。在任何编程语言中，为数据选择正确的类型至关重要。如果将数据分配给错误的数据类型，你可能会遇到编译错误，或者更糟糕的是，设计出现奇怪的行为。例如，试图将小数赋值给整数数据类型，可能会截断小数部分，导致意外的四舍五入操作。
- en: Additionally, you don’t want to use more resources than necessary. For example,
    you could create every signal with a 64-bit-wide data type, but that’s clearly
    overkill if all you need is a counter that goes from 0 to 7\. FPGAs provide even
    more granular control over data types than you get with most other programming
    languages. For example, C has the <samp class="SANS_TheSansMonoCd_W5Regular_11">uint8_t</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">uint16_t</samp>, and <samp class="SANS_TheSansMonoCd_W5Regular_11">uint32_t</samp>
    data types, which create data widths of 8, 16, and 32 bits, respectively, but
    there’s nothing in between. In Verilog and VHDL, by contrast, you can create a
    signal that’s 9 bits wide, 15 bits wide, 23 bits wide, or any other number. We’ll
    explore recommendations for sizing signals later in this chapter.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，你还不想使用超过必要的资源。例如，你可以使用 64 位宽的数据类型来创建每个信号，但如果你只需要一个从 0 到 7 的计数器，显然这是一种过度设计。与大多数其他编程语言相比，FPGAs
    对数据类型的控制更加精细。例如，C 语言有 <samp class="SANS_TheSansMonoCd_W5Regular_11">uint8_t</samp>、<samp
    class="SANS_TheSansMonoCd_W5Regular_11">uint16_t</samp> 和 <samp class="SANS_TheSansMonoCd_W5Regular_11">uint32_t</samp>
    数据类型，它们分别创建 8 位、16 位和 32 位的数据宽度，但没有中间值。相比之下，在 Verilog 和 VHDL 中，你可以创建 9 位、15 位、23
    位宽的信号，或者任何其他位宽。本章后面我们将探讨信号尺寸的建议。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Representing Signed
    vs. Unsigned Values</samp>
  id: totrans-7
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">表示有符号与无符号值</samp>
- en: 'When you’re working with numbers, you need to know if they’re positive or negative.
    Sometimes, such as if you’re counting clock cycles to keep track of time, you’ll
    know the values will all be positive. In this case, you can store the numbers
    using an *unsigned* data type; the sign (positive or negative) isn’t specified
    and is assumed to be positive. Other times, you’ll need to work with negative
    numbers: for example, when you’re reading temperature values, where the sign of
    the numbers might vary. In these cases you’ll need to use a *signed* data type,
    where the positive or negative sign is specified.'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 当你处理数字时，需要知道它们是正数还是负数。有时候，比如当你计数时钟周期以跟踪时间，你会知道这些值都是正数。在这种情况下，你可以使用 *无符号* 数据类型来存储数字；符号（正数或负数）没有指定，默认假设为正数。其他时候，你需要处理负数：例如，当你读取温度值时，数字的符号可能会变化。在这些情况下，你需要使用
    *有符号* 数据类型，其中符号（正数或负数）是明确指定的。
- en: 'By default, signals in Verilog and VHDL are unsigned. For example, if we need
    a counter that counts from 0 to 7, we can declare a signal like <samp class="SANS_TheSansMonoCd_W5Regular_11">reg
    [2:0] counter;</samp> in Verilog or <samp class="SANS_TheSansMonoCd_W5Regular_11">signal
    counter : std_logic_vector(2 downto 0);</samp> in VHDL. We’ve used code like this
    throughout the book. It will create a 3-bit register, and since it’s unsigned
    by default, the values on the register will all be interpreted as positive. If
    we want <samp class="SANS_TheSansMonoCd_W5Regular_11">counter</samp> to represent
    negative numbers as well as positive ones, we’d have to explicitly declare it
    to be signed using the <samp class="SANS_TheSansMonoCd_W5Regular_11">signed</samp>
    keyword. In Verilog we would write <samp class="SANS_TheSansMonoCd_W5Regular_11">reg
    signed [2:0] counter;</samp>, and in VHDL we would use <samp class="SANS_TheSansMonoCd_W5Regular_11">signal
    counter : signed(2 downto 0);</samp>.'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: '默认情况下，Verilog 和 VHDL 中的信号是无符号的。例如，如果我们需要一个从 0 到 7 的计数器，我们可以在 Verilog 中声明一个信号，如
    <samp class="SANS_TheSansMonoCd_W5Regular_11">reg [2:0] counter;</samp>，或者在 VHDL
    中声明为 <samp class="SANS_TheSansMonoCd_W5Regular_11">signal counter : std_logic_vector(2
    downto 0);</samp>。我们在整本书中都使用了这样的代码。它会创建一个 3 位寄存器，且由于默认是无符号的，寄存器中的值将全部解释为正数。如果我们希望
    <samp class="SANS_TheSansMonoCd_W5Regular_11">counter</samp> 能表示负数和正数，我们必须显式声明它为有符号，使用
    <samp class="SANS_TheSansMonoCd_W5Regular_11">signed</samp> 关键字。在 Verilog 中，我们会写成
    <samp class="SANS_TheSansMonoCd_W5Regular_11">reg signed [2:0] counter;</samp>，在
    VHDL 中，我们会使用 <samp class="SANS_TheSansMonoCd_W5Regular_11">signal counter : signed(2
    downto 0);</samp>。'
- en: <samp class="SANS_Dogma_OT_Bold_B_21">NOTE</samp>
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Dogma_OT_Bold_B_21">注意</samp>
- en: '*To access the signed keyword in VHDL, you need to use the numeric_std package,
    which you can do by adding the line use ieee.numeric_std.all; at the top of your
    file. You may see some code that uses the std_logic_arith package instead, but
    this isn’t an official IEEE-supported library and I don’t recommend using it.
    It’s easier to make mistakes with this package than with numeric_std.*'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: '*要在 VHDL 中访问 signed 关键字，你需要使用 numeric_std 包，可以通过在文件顶部添加一行 use ieee.numeric_std.all;
    来实现。你可能会看到一些代码使用了 std_logic_arith 包，但这不是一个官方的 IEEE 支持库，我不推荐使用它。使用这个包比使用 numeric_std
    容易出错。*'
- en: Using the <samp class="SANS_TheSansMonoCd_W5Regular_11">signed</samp> keyword
    explicitly tells the tools that this 3-bit-wide register can represent negative
    and positive values. But which values can we actually represent with it? [Table
    10-1](#tab10-1) compares the values represented by a 3-bit unsigned register and
    a 3-bit signed register. (We’ll discuss how to determine the signed values in
    the next section.)
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 <samp class="SANS_TheSansMonoCd_W5Regular_11">signed</samp> 关键字明确告诉工具，这个
    3 位宽的寄存器可以表示负数和正数。但是我们实际能用它表示哪些值呢？[表 10-1](#tab10-1) 比较了 3 位无符号寄存器和 3 位有符号寄存器表示的值。（我们将在下一节讨论如何确定有符号值。）
- en: <samp class="SANS_Futura_Std_Heavy_B_11">Table 10-1:</samp> <samp class="SANS_Futura_Std_Book_11">3-Bit
    Unsigned vs. Signed Decimal Values</samp>
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Heavy_B_11">表 10-1：</samp> <samp class="SANS_Futura_Std_Book_11">3
    位无符号与有符号十进制值</samp>
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">Bits</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">Unsigned
    decimal value</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">Signed decimal
    value</samp> |'
  id: totrans-14
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_Futura_Std_Heavy_B_11">位</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">无符号十进制值</samp>
    | <samp class="SANS_Futura_Std_Heavy_B_11">有符号十进制值</samp> |'
- en: '| --- | --- | --- |'
  id: totrans-15
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">000</samp> | <samp class="SANS_Futura_Std_Book_11">0</samp>
    | <samp class="SANS_Futura_Std_Book_11">0</samp> |'
  id: totrans-16
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">000</samp> | <samp class="SANS_Futura_Std_Book_11">0</samp>
    | <samp class="SANS_Futura_Std_Book_11">0</samp> |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">001</samp> | <samp class="SANS_Futura_Std_Book_11">1</samp>
    | <samp class="SANS_Futura_Std_Book_11">1</samp> |'
  id: totrans-17
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">001</samp> | <samp class="SANS_Futura_Std_Book_11">1</samp>
    | <samp class="SANS_Futura_Std_Book_11">1</samp> |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">010</samp> | <samp class="SANS_Futura_Std_Book_11">2</samp>
    | <samp class="SANS_Futura_Std_Book_11">2</samp> |'
  id: totrans-18
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">010</samp> | <samp class="SANS_Futura_Std_Book_11">2</samp>
    | <samp class="SANS_Futura_Std_Book_11">2</samp> |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">011</samp> | <samp class="SANS_Futura_Std_Book_11">3</samp>
    | <samp class="SANS_Futura_Std_Book_11">3</samp> |'
  id: totrans-19
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">011</samp> | <samp class="SANS_Futura_Std_Book_11">3</samp>
    | <samp class="SANS_Futura_Std_Book_11">3</samp> |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">100</samp> | <samp class="SANS_Futura_Std_Book_11">4</samp>
    | <samp class="SANS_Futura_Std_Book_11">–4</samp> |'
  id: totrans-20
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">100</samp> | <samp class="SANS_Futura_Std_Book_11">4</samp>
    | <samp class="SANS_Futura_Std_Book_11">–4</samp> |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">101</samp> | <samp class="SANS_Futura_Std_Book_11">5</samp>
    | <samp class="SANS_Futura_Std_Book_11">–3</samp> |'
  id: totrans-21
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">101</samp> | <samp class="SANS_Futura_Std_Book_11">5</samp>
    | <samp class="SANS_Futura_Std_Book_11">–3</samp> |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">110</samp> | <samp class="SANS_Futura_Std_Book_11">6</samp>
    | <samp class="SANS_Futura_Std_Book_11">–2</samp> |'
  id: totrans-22
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">110</samp> | <samp class="SANS_Futura_Std_Book_11">6</samp>
    | <samp class="SANS_Futura_Std_Book_11">–2</samp> |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">111</samp> | <samp class="SANS_Futura_Std_Book_11">7</samp>
    | <samp class="SANS_Futura_Std_Book_11">–1</samp> |'
  id: totrans-23
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">111</samp> | <samp class="SANS_Futura_Std_Book_11">7</samp>
    | <samp class="SANS_Futura_Std_Book_11">–1</samp> |'
- en: Notice that when a register is declared as signed, we lose some numbers on the
    positive end of the range (4, 5, 6, and 7 in this case) but gain some numbers
    on the negative end (–1, –2, –3, and –4). The range of numbers that can be represented
    by an unsigned register is 0 to 2*^N* − 1, where *N* is the number of bits available.
    For this 3-bit register, we can represent from 0 to 2³ − 1 = 7 if the register
    is unsigned. On the other hand, the range of numbers that can be represented by
    a signed register is –2^(*^N*^(–1)) to 2^(*^N*^(–1)) − 1\. In this case, that
    gives us –2^((3–1)) to 2^((3–1)) − 1, or = –4 to 3\. The data is still 3 bits
    of binary data, but *what that binary data represents* is different.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，当一个寄存器被声明为带符号时，我们会失去一些正数范围内的数字（在这个例子中是4, 5, 6和7），但会在负数范围内获得一些数字（–1, –2,
    –3和–4）。无符号寄存器能够表示的数字范围是0到2*^N* − 1，其中*N*是可用的位数。对于这个3位寄存器，如果寄存器是无符号的，我们可以表示从0到2³
    − 1 = 7。另一方面，带符号寄存器能够表示的数字范围是 –2^(*^N*^(–1)) 到 2^(*^N*^(–1)) − 1。在这种情况下，它给我们的范围是
    –2^((3–1)) 到 2^((3–1)) − 1，即 –4 到 3。数据仍然是3位的二进制数据，但*这些二进制数据表示的内容*是不同的。
- en: Another feature to notice in [Table 10-1](#tab10-1) is that the values that
    are negative all have a 1 in the most significant bit position. In fact, the most
    significant bit in a signed number is the *sign bit*, which indicates whether
    the number being represented is positive or negative. For signed binary numbers,
    a 0 in the sign bit tells you that the number is positive, while a 1 in the sign
    bit tells you that the number is negative.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个需要注意的特点是在[表10-1](#tab10-1)中，所有负值的最高有效位都为1。实际上，在带符号的数值中，最高有效位是*符号位*，它表示所表示的数字是正数还是负数。对于带符号的二进制数，符号位为0表示数字是正数，而符号位为1表示数字是负数。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Taking the Two’s
    Complement</samp>
  id: totrans-26
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">求二的补码</samp>
- en: How do you know what decimal value a negatively signed binary number is supposed
    to represent? You take its *two’s complement*, a mathematical operation where
    you invert the number’s bits and then add 1\. For example, take the binary number
    <samp class="SANS_TheSansMonoCd_W5Regular_11">101</samp>. If this were an unsigned
    number, we’d interpret it as 5 in decimal, but if it’s a signed number, the 1
    in the sign bit tells us that the represented value should be negative, so we
    have to take the two’s complement. First, we invert <samp class="SANS_TheSansMonoCd_W5Regular_11">101</samp>,
    which gives us <samp class="SANS_TheSansMonoCd_W5Regular_11">010</samp>. Then
    we add 1, giving us <samp class="SANS_TheSansMonoCd_W5Regular_11">011</samp>,
    which is 3 in decimal. Finally, we apply the negative sign to get –3\. Look back
    at [Table 10-1](#tab10-1) and you’ll see that’s what we have in the row for <samp
    class="SANS_TheSansMonoCd_W5Regular_11">101</samp>.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 如何知道一个带负号的二进制数应该表示什么十进制值呢？你需要进行*二补数*运算，这是一种数学操作，其中你将数值的位反转，然后加 1。例如，考虑二进制数<samp
    class="SANS_TheSansMonoCd_W5Regular_11">101</samp>。如果它是无符号数，我们会将其解释为十进制的 5，但如果它是有符号数，那么符号位上的
    1 告诉我们，表示的值应该是负数，因此我们必须进行二补数运算。首先，我们将<samp class="SANS_TheSansMonoCd_W5Regular_11">101</samp>的位反转，得到<samp
    class="SANS_TheSansMonoCd_W5Regular_11">010</samp>。然后加 1，得到<samp class="SANS_TheSansMonoCd_W5Regular_11">011</samp>，它在十进制中是
    3。最后，我们加上负号得到 –3。回到[表 10-1](#tab10-1)，你会看到在<samp class="SANS_TheSansMonoCd_W5Regular_11">101</samp>这一行就是这个结果。
- en: <samp class="SANS_Dogma_OT_Bold_B_21">NOTE</samp>
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Dogma_OT_Bold_B_21">注意</samp>
- en: '*An alternative to the invert-and-add-one method is to start at the right-most
    (least significant) bit, move left until you get to the first 1, then invert all
    the remaining bits to the left of that 1\. For example, 100010 100 becomes 011101
    100\. The three bolded bits, up to and including the first 1 from the right, remain
    the same, while the others are inverted. In decimal, 011101100 is 236; applying
    the negative sign, we know that 100010100 represents –236\. This method avoids
    the need for addition and can be simpler for long numbers.*'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '*反转加一法的替代方法是，从最右边（最低有效）位开始，向左移动，直到遇到第一个 1，然后将这个 1 左边的所有位反转。例如，100010 100 变成
    011101 100。三个加粗的位，直到并包括右边第一个 1，保持不变，而其他位则反转。十进制中，011101100 是 236；加上负号后，我们知道 100010100
    表示 –236。这个方法避免了加法操作，对于长数字可能更简单。*'
- en: We can also take a two’s complement to go in the other direction, converting
    a negative decimal number into its signed binary representation. For example,
    how would we represent –1 in binary using 3 bits? First, strip away the negative
    sign to get 1, which is <samp class="SANS_TheSansMonoCd_W5Regular_11">001</samp>
    in binary. Then invert the bits to get <samp class="SANS_TheSansMonoCd_W5Regular_11">110</samp>,
    and add 1 to get <samp class="SANS_TheSansMonoCd_W5Regular_11">111</samp>. Again,
    check [Table 10-1](#tab10-1) and you’ll see that this is the correct result.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以反向进行二补数运算，将一个负的十进制数转换为其带符号的二进制表示。例如，如何用 3 位二进制表示 –1 呢？首先，去掉负号得到 1，它的二进制表示是<samp
    class="SANS_TheSansMonoCd_W5Regular_11">001</samp>。然后反转位，得到<samp class="SANS_TheSansMonoCd_W5Regular_11">110</samp>，再加
    1，得到<samp class="SANS_TheSansMonoCd_W5Regular_11">111</samp>。同样，查看[表 10-1](#tab10-1)，你会发现这是正确的结果。
- en: Taking the two’s complement is a useful trick us humans can use to better understand
    how to interpret signed numbers, but this invert-and-add-one logic *isn’t something
    an FPGA actually does* when working with negative values. The data is binary 1s
    and 0s whether a number is signed or unsigned. It’s just the *representation*
    of those 1s and 0s that makes a difference. When you have a 3-bit unsigned signal
    set to <samp class="SANS_TheSansMonoCd_W5Regular_11">101</samp>, that represents
    the decimal value 5\. When you have a 3-bit signed signal set to <samp class="SANS_TheSansMonoCd_W5Regular_11">101</samp>,
    that represents the decimal value –3\. The FPGA doesn’t have to invert and add
    bits anywhere to know that. It just needs to know that the signal is of a signed
    data type. This is an important point and will become clearer as we explore mathematical
    operations in binary.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 取二进制补码是我们人类用来更好理解如何解释有符号数字的一个有用技巧，但这种“反转并加一”的逻辑*并不是FPGA在处理负值时实际执行的操作*。无论一个数字是有符号还是无符号，数据都是二进制的1和0。不同之处在于这些1和0的*表示方式*。当你有一个3位无符号信号，设置为<samp
    class="SANS_TheSansMonoCd_W5Regular_11">101</samp>时，它表示十进制值5。当你有一个3位有符号信号，设置为<samp
    class="SANS_TheSansMonoCd_W5Regular_11">101</samp>时，它表示十进制值-3。FPGA并不需要反转并加上位来知道这一点。它只需要知道该信号是有符号数据类型。这是一个重要的点，随着我们在二进制中探索数学运算，这一点会更加清晰。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Sizing Signals Appropriately</samp>
  id: totrans-32
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">正确地调整信号大小</samp>
- en: When you write Verilog or VHDL code working with signed and unsigned data types,
    you must ensure that you properly size the signals you’re creating. If you try
    to store too large of a number in too small of a signal, you’ll get data loss.
    As we just discussed, for example, the value of a 3-bit unsigned counter maxes
    out at 7\. If you try to increment it again from 7, it won’t go to 8; it’ll actually
    go back to 0\. This is sometimes called *wraparound*, and if you’re not expecting
    it, you’ll end up losing count. As you’ll see later in the chapter, ensuring your
    signals are large enough to handle your data is particularly important when the
    signals are for holding the results of mathematical operations.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 当你编写处理有符号和无符号数据类型的Verilog或VHDL代码时，必须确保你创建的信号大小正确。如果你试图将一个过大的数字存储到一个过小的信号中，你将会丢失数据。如我们刚才讨论的那样，例如，一个3位无符号计数器的最大值是7。如果你尝试从7开始递增，它不会变成8；实际上，它会回到0。这有时被称为*回绕*，如果你没有预料到这一点，你可能会丢失计数。如本章后面所述，确保信号足够大以容纳你的数据，在信号用来保存数学运算结果时尤其重要。
- en: 'To avoid data loss you might be tempted to make all your signals larger than
    they need to be, but there’s a downside to this, too: you’ll end up using more
    of your FPGA’s precious resources than are needed. This may be less of a problem
    than you think, though. If the synthesis tools are smart enough, they might detect
    that your possible range of values is smaller than the signal you’ve created and
    remove the upper bits that are unused to conserve resources. If the tools did
    this to our <samp class="SANS_TheSansMonoCd_W5Regular_11">counter</samp> register,
    for example, we’d see a warning saying something like <samp class="SANS_TheSansMonoCd_W5Regular_11">Pruning
    register counter</samp> in the synthesis report. Getting a warning like this isn’t
    usually a problem, but it might indicate code you could revisit and size differently.'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免数据丢失，你可能会倾向于将所有信号做得比实际需要的更大，但这样做也有一个弊端：你将使用更多FPGA宝贵的资源，这比实际需要的要多。然而，这个问题可能没有你想象的那么严重。如果综合工具足够智能，它们可能会检测到你的值的可能范围小于你创建的信号，并去除未使用的高位，以节省资源。例如，如果工具对我们的<samp
    class="SANS_TheSansMonoCd_W5Regular_11">counter</samp>寄存器进行优化，我们会在综合报告中看到类似<samp
    class="SANS_TheSansMonoCd_W5Regular_11">Pruning register counter</samp>的警告。通常，收到这样的警告不是问题，但它可能表明你可以重新检查代码，并调整信号的大小。
- en: As a rule of thumb, you should aim to size your signals to the values you expect
    them to store, but know that making them too large is a much better solution than
    making them too small. Of course, you have to remember that the maximum value
    you can represent with a given number of bits varies depending on whether the
    values are signed or unsigned. For comparison, [Table 10-2](#tab10-2) summarizes
    the ranges of possible unsigned and signed values you can represent using between
    2 and 8 bits.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 通常来说，你应该根据信号预期存储的值来选择大小，但要知道，设置信号大小过大比设置过小要更好。当然，你还需要记住，使用给定的位数表示的最大值会根据是否为有符号或无符号值而有所不同。为了进行对比，[表
    10-2](#tab10-2)总结了你可以使用 2 到 8 位表示的无符号和有符号值的范围。
- en: <samp class="SANS_Futura_Std_Heavy_B_11">Table 10-2:</samp> <samp class="SANS_Futura_Std_Book_11">N-bit
    Sizing for Unsigned and Signed Data Types</samp>
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Heavy_B_11">表 10-2:</samp> <samp class="SANS_Futura_Std_Book_11">无符号和有符号数据类型的
    N 位大小</samp>
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">Width</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">Type</samp>
    | <samp class="SANS_Futura_Std_Heavy_B_11">Min integer</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">Min
    binary</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">Max integer</samp> |
    <samp class="SANS_Futura_Std_Heavy_B_11">Max binary</samp> |'
  id: totrans-37
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_Futura_Std_Heavy_B_11">宽度</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">类型</samp>
    | <samp class="SANS_Futura_Std_Heavy_B_11">最小整数</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">最小二进制</samp>
    | <samp class="SANS_Futura_Std_Heavy_B_11">最大整数</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">最大二进制</samp>
    |'
- en: '| --- | --- | --- | --- | --- | --- |'
  id: totrans-38
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- | --- | --- |'
- en: '| <samp class="SANS_Futura_Std_Book_11">2</samp> | <samp class="SANS_Futura_Std_Book_11">Unsigned</samp>
    | <samp class="SANS_Futura_Std_Book_11">0</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">00</samp>
    | <samp class="SANS_Futura_Std_Book_11">3</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">11</samp>
    |'
  id: totrans-39
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_Futura_Std_Book_11">2</samp> | <samp class="SANS_Futura_Std_Book_11">无符号</samp>
    | <samp class="SANS_Futura_Std_Book_11">0</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">00</samp>
    | <samp class="SANS_Futura_Std_Book_11">3</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">11</samp>
    |'
- en: '| <samp class="SANS_Futura_Std_Book_11">2</samp> | <samp class="SANS_Futura_Std_Book_11">Signed</samp>
    | <samp class="SANS_Futura_Std_Book_11">–2</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">10</samp>
    | <samp class="SANS_Futura_Std_Book_11">1</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">01</samp>
    |'
  id: totrans-40
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_Futura_Std_Book_11">2</samp> | <samp class="SANS_Futura_Std_Book_11">有符号</samp>
    | <samp class="SANS_Futura_Std_Book_11">–2</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">10</samp>
    | <samp class="SANS_Futura_Std_Book_11">1</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">01</samp>
    |'
- en: '| <samp class="SANS_Futura_Std_Book_11">3</samp> | <samp class="SANS_Futura_Std_Book_11">Unsigned</samp>
    | <samp class="SANS_Futura_Std_Book_11">0</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">000</samp>
    | <samp class="SANS_Futura_Std_Book_11">7</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">111</samp>
    |'
  id: totrans-41
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_Futura_Std_Book_11">3</samp> | <samp class="SANS_Futura_Std_Book_11">无符号</samp>
    | <samp class="SANS_Futura_Std_Book_11">0</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">000</samp>
    | <samp class="SANS_Futura_Std_Book_11">7</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">111</samp>
    |'
- en: '| <samp class="SANS_Futura_Std_Book_11">3</samp> | <samp class="SANS_Futura_Std_Book_11">Signed</samp>
    | <samp class="SANS_Futura_Std_Book_11">–4</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">100</samp>
    | <samp class="SANS_Futura_Std_Book_11">3</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">011</samp>
    |'
  id: totrans-42
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_Futura_Std_Book_11">3</samp> | <samp class="SANS_Futura_Std_Book_11">有符号</samp>
    | <samp class="SANS_Futura_Std_Book_11">–4</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">100</samp>
    | <samp class="SANS_Futura_Std_Book_11">3</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">011</samp>
    |'
- en: '| <samp class="SANS_Futura_Std_Book_11">4</samp> | <samp class="SANS_Futura_Std_Book_11">Unsigned</samp>
    | <samp class="SANS_Futura_Std_Book_11">0</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">0000</samp>
    | <samp class="SANS_Futura_Std_Book_11">15</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">1111</samp>
    |'
  id: totrans-43
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_Futura_Std_Book_11">4</samp> | <samp class="SANS_Futura_Std_Book_11">无符号</samp>
    | <samp class="SANS_Futura_Std_Book_11">0</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">0000</samp>
    | <samp class="SANS_Futura_Std_Book_11">15</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">1111</samp>
    |'
- en: '| <samp class="SANS_Futura_Std_Book_11">4</samp> | <samp class="SANS_Futura_Std_Book_11">Signed</samp>
    | <samp class="SANS_Futura_Std_Book_11">–8</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">1000</samp>
    | <samp class="SANS_Futura_Std_Book_11">7</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">0111</samp>
    |'
  id: totrans-44
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_Futura_Std_Book_11">4</samp> | <samp class="SANS_Futura_Std_Book_11">有符号</samp>
    | <samp class="SANS_Futura_Std_Book_11">–8</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">1000</samp>
    | <samp class="SANS_Futura_Std_Book_11">7</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">0111</samp>
    |'
- en: '| <samp class="SANS_Futura_Std_Book_11">5</samp> | <samp class="SANS_Futura_Std_Book_11">Unsigned</samp>
    | <samp class="SANS_Futura_Std_Book_11">0</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">00000</samp>
    | <samp class="SANS_Futura_Std_Book_11">31</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">11111</samp>
    |'
  id: totrans-45
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_Futura_Std_Book_11">5</samp> | <samp class="SANS_Futura_Std_Book_11">无符号</samp>
    | <samp class="SANS_Futura_Std_Book_11">0</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">00000</samp>
    | <samp class="SANS_Futura_Std_Book_11">31</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">11111</samp>
    |'
- en: '| <samp class="SANS_Futura_Std_Book_11">5</samp> | <samp class="SANS_Futura_Std_Book_11">Signed</samp>
    | <samp class="SANS_Futura_Std_Book_11">–16</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">10000</samp>
    | <samp class="SANS_Futura_Std_Book_11">15</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">01111</samp>
    |'
  id: totrans-46
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_Futura_Std_Book_11">5</samp> | <samp class="SANS_Futura_Std_Book_11">有符号</samp>
    | <samp class="SANS_Futura_Std_Book_11">–16</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">10000</samp>
    | <samp class="SANS_Futura_Std_Book_11">15</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">01111</samp>
    |'
- en: '| <samp class="SANS_Futura_Std_Book_11">6</samp> | <samp class="SANS_Futura_Std_Book_11">Unsigned</samp>
    | <samp class="SANS_Futura_Std_Book_11">0</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">000000</samp>
    | <samp class="SANS_Futura_Std_Book_11">63</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">111111</samp>
    |'
  id: totrans-47
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_Futura_Std_Book_11">6</samp> | <samp class="SANS_Futura_Std_Book_11">无符号</samp>
    | <samp class="SANS_Futura_Std_Book_11">0</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">000000</samp>
    | <samp class="SANS_Futura_Std_Book_11">63</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">111111</samp>
    |'
- en: '| <samp class="SANS_Futura_Std_Book_11">6</samp> | <samp class="SANS_Futura_Std_Book_11">Signed</samp>
    | <samp class="SANS_Futura_Std_Book_11">–32</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">100000</samp>
    | <samp class="SANS_Futura_Std_Book_11">31</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">011111</samp>
    |'
  id: totrans-48
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_Futura_Std_Book_11">6</samp> | <samp class="SANS_Futura_Std_Book_11">有符号</samp>
    | <samp class="SANS_Futura_Std_Book_11">–32</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">100000</samp>
    | <samp class="SANS_Futura_Std_Book_11">31</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">011111</samp>
    |'
- en: '| <samp class="SANS_Futura_Std_Book_11">7</samp> | <samp class="SANS_Futura_Std_Book_11">Unsigned</samp>
    | <samp class="SANS_Futura_Std_Book_11">0</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">0000000</samp>
    | <samp class="SANS_Futura_Std_Book_11">127</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">1111111</samp>
    |'
  id: totrans-49
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_Futura_Std_Book_11">7</samp> | <samp class="SANS_Futura_Std_Book_11">无符号</samp>
    | <samp class="SANS_Futura_Std_Book_11">0</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">0000000</samp>
    | <samp class="SANS_Futura_Std_Book_11">127</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">1111111</samp>
    |'
- en: '| <samp class="SANS_Futura_Std_Book_11">7</samp> | <samp class="SANS_Futura_Std_Book_11">Signed</samp>
    | <samp class="SANS_Futura_Std_Book_11">–64</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">1000000</samp>
    | <samp class="SANS_Futura_Std_Book_11">63</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">0111111</samp>
    |'
  id: totrans-50
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_Futura_Std_Book_11">7</samp> | <samp class="SANS_Futura_Std_Book_11">有符号</samp>
    | <samp class="SANS_Futura_Std_Book_11">–64</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">1000000</samp>
    | <samp class="SANS_Futura_Std_Book_11">63</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">0111111</samp>
    |'
- en: '| <samp class="SANS_Futura_Std_Book_11">8</samp> | <samp class="SANS_Futura_Std_Book_11">Unsigned</samp>
    | <samp class="SANS_Futura_Std_Book_11">0</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">00000000</samp>
    | <samp class="SANS_Futura_Std_Book_11">255</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">11111111</samp>
    |'
  id: totrans-51
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_Futura_Std_Book_11">8</samp> | <samp class="SANS_Futura_Std_Book_11">无符号</samp>
    | <samp class="SANS_Futura_Std_Book_11">0</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">00000000</samp>
    | <samp class="SANS_Futura_Std_Book_11">255</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">11111111</samp>
    |'
- en: '| <samp class="SANS_Futura_Std_Book_11">8</samp> | <samp class="SANS_Futura_Std_Book_11">Signed</samp>
    | <samp class="SANS_Futura_Std_Book_11">–128</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">10000000</samp>
    | <samp class="SANS_Futura_Std_Book_11">127</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">01111111</samp>
    |'
  id: totrans-52
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_Futura_Std_Book_11">8</samp> | <samp class="SANS_Futura_Std_Book_11">有符号</samp>
    | <samp class="SANS_Futura_Std_Book_11">–128</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">10000000</samp>
    | <samp class="SANS_Futura_Std_Book_11">127</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">01111111</samp>
    |'
- en: Starting at a width of 2 bits, we can represent the numbers 0 to 3 unsigned,
    or –2 to 1 signed. At a width of 8 bits, we can represent 0 to 255 unsigned, or
    –128 to 127 signed.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 从 2 位宽开始，我们可以表示 0 到 3 的无符号数，或者 –2 到 1 的有符号数。在 8 位宽时，我们可以表示 0 到 255 的无符号数，或者
    –128 到 127 的有符号数。
- en: 'One way to bypass the sizing dilemma is to size your signals dynamically, instead
    of setting them to a fixed width. We’ve seen some examples of this throughout
    the book. For instance, if you need to index into something 32 words deep but
    that depth could change in the future, you could write something like <samp class="SANS_TheSansMonoCd_W5Regular_11">reg
    [$clog2(DEPTH)-1:0] index;</samp> instead of <samp class="SANS_TheSansMonoCd_W5Regular_11">reg
    [4:0] index;</samp> in Verilog, or <samp class="SANS_TheSansMonoCd_W5Regular_11">signal
    index : integer range 0 to DEPTH-1;</samp> instead of <samp class="SANS_TheSansMonoCd_W5Regular_11">signal
    index : std_logic_vector(4 downto 0);</samp> in VHDL. Here, <samp class="SANS_TheSansMonoCd_W5Regular_11">DEPTH</samp>
    is a parameter/generic that can be changed on the fly. Using it will generate
    a signal of the exact bit width you need, wide enough to index into all possible
    values from <samp class="SANS_TheSansMonoCd_W5Regular_11">0</samp> to <samp class="SANS_TheSansMonoCd_W5Regular_11">DEPTH-1</samp>,
    with no extra headroom. In this case, you would set <samp class="SANS_TheSansMonoCd_W5Regular_11">DEPTH</samp>
    to <samp class="SANS_TheSansMonoCd_W5Regular_11">32</samp>, but if your indexing
    requirement were to grow to some larger value (say 1,024), the code won’t break;
    all you’ll have to do is change <samp class="SANS_TheSansMonoCd_W5Regular_11">DEPTH</samp>.
    By contrast, if you arbitrarily say that <samp class="SANS_TheSansMonoCd_W5Regular_11">index</samp>
    will be fixed to 8 bits wide (which has a maximum value of 255, as you can see
    in [Table 10-2](#tab10-2)), then your code might break in the future if your requirements
    grow beyond that range.'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '绕过大小问题的一种方法是动态地调整信号的大小，而不是将其设置为固定宽度。我们在本书中已经看过一些这样的示例。例如，如果你需要索引到深度为 32 的某个东西，但该深度可能会在未来发生变化，你可以在
    Verilog 中编写类似 <samp class="SANS_TheSansMonoCd_W5Regular_11">reg [$clog2(DEPTH)-1:0]
    index;</samp>，而不是 <samp class="SANS_TheSansMonoCd_W5Regular_11">reg [4:0] index;</samp>，或者在
    VHDL 中编写 <samp class="SANS_TheSansMonoCd_W5Regular_11">signal index : integer
    range 0 to DEPTH-1;</samp>，而不是 <samp class="SANS_TheSansMonoCd_W5Regular_11">signal
    index : std_logic_vector(4 downto 0);</samp>。这里，<samp class="SANS_TheSansMonoCd_W5Regular_11">DEPTH</samp>
    是一个可以动态更改的参数/泛型。使用它将生成一个精确的比特宽度信号，足以索引从 <samp class="SANS_TheSansMonoCd_W5Regular_11">0</samp>
    到 <samp class="SANS_TheSansMonoCd_W5Regular_11">DEPTH-1</samp> 的所有可能值，不会有多余的空余空间。在这种情况下，你可以将
    <samp class="SANS_TheSansMonoCd_W5Regular_11">DEPTH</samp> 设置为 <samp class="SANS_TheSansMonoCd_W5Regular_11">32</samp>，但如果你的索引需求增长到更大的值（例如
    1,024），代码也不会崩溃；你只需要更改 <samp class="SANS_TheSansMonoCd_W5Regular_11">DEPTH</samp>。相比之下，如果你随意地说
    <samp class="SANS_TheSansMonoCd_W5Regular_11">index</samp> 会被固定为 8 位宽（最大值为 255，如你在
    [表 10-2](#tab10-2) 中看到的那样），那么如果你的需求超出该范围，代码可能会在未来崩溃。'
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Converting Between
    Types in VHDL</samp>
  id: totrans-55
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">VHDL 中类型转换</samp>
- en: VHDL has many numeric data types, including <samp class="SANS_TheSansMonoCd_W5Regular_11">signed</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">unsigned</samp>, where binary
    values are interpreted as positive or negative decimal numbers; <samp class="SANS_TheSansMonoCd_W5Regular_11">integer</samp>,
    where you can type numbers directly into the code; and <samp class="SANS_TheSansMonoCd_W5Regular_11">std_logic_vector</samp>,
    where by default binary values aren’t interpreted as anything other than binary
    values. Because VHDL is strongly typed, you’ll often need to convert between these
    different data types when you’re working with numbers. Before we do any math,
    let’s look at some examples of how to implement common VHDL type conversions using
    the <samp class="SANS_TheSansMonoCd_W5Regular_11">numeric_std</samp> package (not
    the unofficial <samp class="SANS_TheSansMonoCd_W5Regular_11">std_logic_arith</samp>).
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: VHDL 有许多数字数据类型，包括 <samp class="SANS_TheSansMonoCd_W5Regular_11">signed</samp>
    和 <samp class="SANS_TheSansMonoCd_W5Regular_11">unsigned</samp>，其中二进制值被解释为正数或负数的十进制数；<samp
    class="SANS_TheSansMonoCd_W5Regular_11">integer</samp>，可以直接在代码中输入数字；以及 <samp class="SANS_TheSansMonoCd_W5Regular_11">std_logic_vector</samp>，其中默认情况下二进制值不会被解释为除二进制值以外的任何内容。由于
    VHDL 是强类型语言，在处理数字时，通常需要在这些不同的数据类型之间进行转换。在进行任何数学运算之前，我们先看一些如何使用 <samp class="SANS_TheSansMonoCd_W5Regular_11">numeric_std</samp>
    包（而不是非官方的 <samp class="SANS_TheSansMonoCd_W5Regular_11">std_logic_arith</samp>）实现常见
    VHDL 类型转换的示例。
- en: <samp class="SANS_Dogma_OT_Bold_B_21">NOTE</samp>
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Dogma_OT_Bold_B_21">注意</samp>
- en: '*Verilog users don’t need to worry about performing these conversions, since
    Verilog is loosely typed. VHDL users should consult this section as needed for
    reference.*'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '*Verilog 用户无需担心执行这些转换，因为 Verilog 是弱类型语言。VHDL 用户应根据需要参考本节内容。*'
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">From Unsigned or Signed to
    Integer</samp>
  id: totrans-59
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">从无符号或有符号到整数</samp>
- en: 'This example illustrates how to convert from the <samp class="SANS_TheSansMonoCd_W5Regular_11">unsigned</samp>
    or <samp class="SANS_TheSansMonoCd_W5Regular_11">signed</samp> type to the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">integer</samp> type. For simplicity, we’re
    assuming the signals are all 4 bits wide, but the conversion will work for any
    bit width:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 这个示例说明了如何将无符号或有符号类型转换为 <samp class="SANS_TheSansMonoCd_W5Regular_11">integer</samp>
    类型。为了简化起见，我们假设所有信号都是 4 位宽，但这种转换适用于任何位宽：
- en: '[PRE0]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: For these conversions, all we need to do is call the <samp class="SANS_TheSansMonoCd_W5Regular_11">to_integer()</samp>
    function from the <samp class="SANS_TheSansMonoCd_W5Regular_11">numeric_std</samp>
    package. We already know the width and the sign of the input, so the output will
    be sized automatically. This works whether the input is unsigned (as with <samp
    class="SANS_TheSansMonoCd_W5Regular_11">in1</samp>) or signed (as with <samp class="SANS_TheSansMonoCd_W5Regular_11">in2</samp>).
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这些转换，我们只需要调用来自 <samp class="SANS_TheSansMonoCd_W5Regular_11">numeric_std</samp>
    包的 <samp class="SANS_TheSansMonoCd_W5Regular_11">to_integer()</samp> 函数。我们已经知道输入的宽度和符号，因此输出会自动调整大小。无论输入是无符号（如
    <samp class="SANS_TheSansMonoCd_W5Regular_11">in1</samp>）还是有符号（如 <samp class="SANS_TheSansMonoCd_W5Regular_11">in2</samp>），该方法都适用。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">From Integer to Unsigned,
    Signed, or std_logic_vector</samp>
  id: totrans-63
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">从整数到无符号、有符号或 std_logic_vector</samp>
- en: 'This example shows how to convert from the <samp class="SANS_TheSansMonoCd_W5Regular_11">integer</samp>
    type to one of the other types. Again, we’re assuming 4-bit signals:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 这个示例展示了如何将 <samp class="SANS_TheSansMonoCd_W5Regular_11">integer</samp> 类型转换为其他类型。再次说明，我们假设信号为
    4 位：
- en: '[PRE1]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Here we use the <samp class="SANS_TheSansMonoCd_W5Regular_11">to_unsigned()</samp>
    ❶ and <samp class="SANS_TheSansMonoCd_W5Regular_11">to_signed()</samp> ❷ functions
    from <samp class="SANS_TheSansMonoCd_W5Regular_11">numeric_std</samp> to convert
    from the <samp class="SANS_TheSansMonoCd_W5Regular_11">integer</samp> to the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">unsigned</samp> or <samp class="SANS_TheSansMonoCd_W5Regular_11">signed</samp>
    type. In addition to the value to be converted, these functions require the width
    of the output signal as an argument. Rather than entering the width manually,
    we get it by applying <samp class="SANS_TheSansMonoCd_W5Regular_11">'length</samp>,
    a VHDL attribute, to the output signal. This keeps the code flexible; if the width
    changes, the conversion code doesn’t have to.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用 <samp class="SANS_TheSansMonoCd_W5Regular_11">to_unsigned()</samp>
    ❶ 和 <samp class="SANS_TheSansMonoCd_W5Regular_11">to_signed()</samp> ❷ 函数，来自 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">numeric_std</samp>，将 <samp class="SANS_TheSansMonoCd_W5Regular_11">integer</samp>
    转换为 <samp class="SANS_TheSansMonoCd_W5Regular_11">unsigned</samp> 或 <samp class="SANS_TheSansMonoCd_W5Regular_11">signed</samp>
    类型。除了要转换的值外，这些函数还需要输出信号的宽度作为参数。我们通过应用 VHDL 属性 <samp class="SANS_TheSansMonoCd_W5Regular_11">'length</samp>
    获取宽度，而不是手动输入。这样可以保持代码的灵活性；如果宽度发生变化，转换代码不需要做任何更改。
- en: To get to <samp class="SANS_TheSansMonoCd_W5Regular_11">std_logic_vector</samp>,
    we have to convert from <samp class="SANS_TheSansMonoCd_W5Regular_11">integer</samp>
    to <samp class="SANS_TheSansMonoCd_W5Regular_11">unsigned</samp> if the integer
    is positive ❸, or to <samp class="SANS_TheSansMonoCd_W5Regular_11">signed</samp>
    if the integer is negative ❹. Then, once we have an unsigned or signed value of
    the proper width, we cast it using <samp class="SANS_TheSansMonoCd_W5Regular_11">std_logic_vector()</samp>.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 为了得到 <samp class="SANS_TheSansMonoCd_W5Regular_11">std_logic_vector</samp>，我们必须将
    <samp class="SANS_TheSansMonoCd_W5Regular_11">integer</samp> 转换为 <samp class="SANS_TheSansMonoCd_W5Regular_11">unsigned</samp>（如果整数是正数
    ❸），或者转为 <samp class="SANS_TheSansMonoCd_W5Regular_11">signed</samp>（如果整数是负数 ❹）。然后，一旦我们获得了具有适当宽度的无符号或有符号值，我们就可以使用
    <samp class="SANS_TheSansMonoCd_W5Regular_11">std_logic_vector()</samp> 进行类型转换。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">From std_logic_vector to Unsigned,
    Signed, or Integer</samp>
  id: totrans-68
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">从 std_logic_vector 到无符号、有符号或整数</samp>
- en: 'Finally, here’s how to convert from the <samp class="SANS_TheSansMonoCd_W5Regular_11">std_logic_vector</samp>
    type to one of the other numeric types:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，这是如何将 <samp class="SANS_TheSansMonoCd_W5Regular_11">std_logic_vector</samp>
    类型转换为其他数字类型的示例：
- en: '[PRE2]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: To get to <samp class="SANS_TheSansMonoCd_W5Regular_11">unsigned</samp> ❶ or
    <samp class="SANS_TheSansMonoCd_W5Regular_11">signed</samp> ❷, we use a simple
    cast. However, VHDL needs to know if the <samp class="SANS_TheSansMonoCd_W5Regular_11">std_logic_vector</samp>
    is unsigned or signed before converting to the <samp class="SANS_TheSansMonoCd_W5Regular_11">integer</samp>
    type. We perform the appropriate cast using <samp class="SANS_TheSansMonoCd_W5Regular_11">unsigned()</samp>
    ❸ or <samp class="SANS_TheSansMonoCd_W5Regular_11">signed()</samp> ❹, then call
    the <samp class="SANS_TheSansMonoCd_W5Regular_11">to_integer()</samp> function
    to do the final conversion.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 要获取 <samp class="SANS_TheSansMonoCd_W5Regular_11">unsigned</samp> ❶ 或 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">signed</samp> ❷，我们使用一个简单的类型转换。然而，VHDL
    需要知道 <samp class="SANS_TheSansMonoCd_W5Regular_11">std_logic_vector</samp> 是无符号的还是有符号的，才能转换为
    <samp class="SANS_TheSansMonoCd_W5Regular_11">integer</samp> 类型。我们通过使用 <samp class="SANS_TheSansMonoCd_W5Regular_11">unsigned()</samp>
    ❸ 或 <samp class="SANS_TheSansMonoCd_W5Regular_11">signed()</samp> ❹ 来执行适当的转换，然后调用
    <samp class="SANS_TheSansMonoCd_W5Regular_11">to_integer()</samp> 函数进行最终转换。
- en: <samp class="SANS_Futura_Std_Bold_B_11">Performing Mathematical Operations</samp>
  id: totrans-72
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">执行数学运算</samp>
- en: Now we’ll consider how basic addition, subtraction, multiplication, and division
    operations are performed within an FPGA, and how to implement them in Verilog
    and VHDL. I’ll suggest some rules that, if followed, will help you avoid many
    of the commit pitfalls when working with binary math. The best way to explore
    these concepts is through examples. To that end, we’ll create a large testbench
    that you can run in a simulator tool like EDA Playground. The testbench will execute
    dozens of different math equations, illustrating how binary math operations should
    be carried out and how they can go awry.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将考虑在 FPGA 中如何执行基本的加法、减法、乘法和除法操作，以及如何在 Verilog 和 VHDL 中实现它们。我将建议一些规则，如果遵循这些规则，将帮助你避免在进行二进制数学运算时出现许多常见的陷阱。探索这些概念的最佳方法是通过示例。为此，我们将创建一个大型测试平台，你可以在像
    EDA Playground 这样的仿真工具中运行它。该测试平台将执行数十个不同的数学方程，展示二进制数学运算应该如何进行，以及它们如何出错。
- en: In general, when working with numbers and manipulating them with algebraic operations,
    testbenches are a very powerful tool. Hidden math issues in your code can manifest
    themselves in strange ways. Testbenches allow you to stress your design by running
    through a large range of possible inputs, to see how the code works. I find it
    valuable to inject data into my testbenches that stress the math operations over
    a wide range of values, including minimum and maximum inputs. This helps ensure
    a design is robust.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 一般来说，在处理数字并进行代数运算时，测试平台是一个非常强大的工具。代码中隐藏的数学问题可能以奇怪的方式表现出来。测试平台通过运行大量不同的输入来加大设计的压力，从而查看代码的工作情况。我发现，在我的测试平台中注入数据，尤其是那些对数学运算施加压力的值，包括最小和最大输入，是非常有价值的。这有助于确保设计的稳健性。
- en: 'Before we do any math, let’s set up our testbench, called <samp class="SANS_TheSansMonoCd_W5Regular_11">Math_Examples</samp>,
    by declaring all the necessary inputs and outputs, as well as some helper functions
    in the VHDL version. This setup code provides the skeleton for the examples that
    follow throughout the rest of the chapter. The code for each example will go where
    the <samp class="SANS_TheSansMonoCd_W5Regular_11">--</samp> <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">snip</samp><samp
    class="SANS_TheSansMonoCd_W5Regular_11">--</samp> is shown in the setup code:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们进行任何数学运算之前，让我们通过在 VHDL 版本中声明所有必要的输入和输出，以及一些辅助函数，来设置我们的测试平台，名为 <samp class="SANS_TheSansMonoCd_W5Regular_11">Math_Examples</samp>。这段设置代码为接下来整个章节中的示例提供了框架。每个示例的代码将放置在设置代码中的
    <samp class="SANS_TheSansMonoCd_W5Regular_11">--</samp> <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">snip</samp><samp
    class="SANS_TheSansMonoCd_W5Regular_11">--</samp> 位置：
- en: <samp class="SANS_Futura_Std_Bold_Oblique_BI_11">Verilog</samp>
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Oblique_BI_11">Verilog</samp>
- en: '[PRE3]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: <samp class="SANS_Futura_Std_Bold_Oblique_BI_11">VHDL</samp>
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Oblique_BI_11">VHDL</samp>
- en: '[PRE4]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The skeleton for this testbench sets up a single <samp class="SANS_TheSansMonoCd_W5Regular_11">initial</samp>
    (in Verilog) or <samp class="SANS_TheSansMonoCd_W5Regular_11">process</samp> (in
    VHDL) block that runs once through. We’ll fill in this block with examples later
    in the chapter. Notice that we’ve declared a number of signals using <samp class="SANS_TheSansMonoCd_W5Regular_11">reg</samp>
    (in Verilog) and <samp class="SANS_TheSansMonoCd_W5Regular_11">variable</samp>
    (in VHDL). This is the first time we’ve seen the <samp class="SANS_TheSansMonoCd_W5Regular_11">variable</samp>
    keyword in VHDL: we need it so we can write blocking assignment statements in
    the testbench. See “Blocking vs. Non-Blocking Assignments” on page 214 for more
    information.'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 这个测试平台的骨架设置了一个单独的 <samp class="SANS_TheSansMonoCd_W5Regular_11">initial</samp>（在
    Verilog 中）或 <samp class="SANS_TheSansMonoCd_W5Regular_11">process</samp>（在 VHDL
    中）块，该块只运行一次。我们将在本章后面用示例填充这个块。请注意，我们已经使用 <samp class="SANS_TheSansMonoCd_W5Regular_11">reg</samp>（在
    Verilog 中）和 <samp class="SANS_TheSansMonoCd_W5Regular_11">variable</samp>（在 VHDL
    中）声明了一些信号。这是我们第一次在 VHDL 中看到 <samp class="SANS_TheSansMonoCd_W5Regular_11">variable</samp>
    关键字：我们需要它以便在测试平台中编写阻塞赋值语句。有关更多信息，请参见第 214 页的“阻塞与非阻塞赋值”。
- en: The examples in this chapter use a common naming scheme to quickly identify
    the data types and widths of the signals so you don’t have to keep looking back
    at the signal definitions. The prefix <samp class="SANS_TheSansMonoCd_W5Regular_11">i</samp>
    indicates an input to a math equation, while <samp class="SANS_TheSansMonoCd_W5Regular_11">o</samp>
    indicates an output, the result of the math equation. In addition, we have the
    suffixes <samp class="SANS_TheSansMonoCd_W5Regular_11">_u</samp><samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">N</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">_s</samp><samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">N</samp>,
    where <samp class="SANS_TheSansMonoCd_W5Regular_11">u</samp> represents unsigned,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">s</samp> represents signed, and
    <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">N</samp> represents the
    bit width of the signal. For example, <samp class="SANS_TheSansMonoCd_W5Regular_11">o_s4</samp>
    is a 4-bit-wide signed output. Establishing a scheme like this that makes it easier
    to remember data types and widths can be very helpful in your code, especially
    if there are many values in a single file.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中的示例使用了一种通用的命名规则，以便快速识别信号的数据类型和宽度，这样你就不必不断回头查看信号定义。前缀 <samp class="SANS_TheSansMonoCd_W5Regular_11">i</samp>
    表示数学方程的输入，而 <samp class="SANS_TheSansMonoCd_W5Regular_11">o</samp> 表示输出，即数学方程的结果。此外，我们有后缀
    <samp class="SANS_TheSansMonoCd_W5Regular_11">_u</samp><samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">N</samp>
    和 <samp class="SANS_TheSansMonoCd_W5Regular_11">_s</samp><samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">N</samp>，其中
    <samp class="SANS_TheSansMonoCd_W5Regular_11">u</samp> 代表无符号，<samp class="SANS_TheSansMonoCd_W5Regular_11">s</samp>
    代表有符号，<samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">N</samp> 代表信号的位宽。例如，<samp
    class="SANS_TheSansMonoCd_W5Regular_11">o_s4</samp> 是一个 4 位宽的有符号输出。建立像这样的命名方案，可以帮助你更容易地记住数据类型和宽度，尤其是当一个文件中有很多值时，这对你的代码非常有帮助。
- en: Notice in the VHDL that we declare a custom function, <samp class="SANS_TheSansMonoCd_W5Regular_11">str()</samp>,
    to help convert the outputs of our equations to strings for printing. This will
    save us a lot of typing in the examples later on. We actually define the function
    in three different ways, depending on the data type involved—because VHDL is strongly
    typed, we need to define all the supported function inputs so that the compiler
    knows which one to use. The first definition ❶ converts an <samp class="SANS_TheSansMonoCd_W5Regular_11">unsigned</samp>
    value, the second ❷ converts a <samp class="SANS_TheSansMonoCd_W5Regular_11">signed</samp>
    value, and the third ❸ converts a <samp class="SANS_TheSansMonoCd_W5Regular_11">real</samp>
    value. This is an example of function *overloading*, a programming technique where
    a single function can have multiple implementations. Overloading is a somewhat
    advanced VHDL concept, but it’s very useful. You can even overload normal VHDL
    operators like <samp class="SANS_TheSansMonoCd_W5Regular_11">+</samp> and <samp
    class="SANS_TheSansMonoCd_W5Regular_11">–</samp> with any implementation that
    you need, though I don’t recommend doing so.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，在 VHDL 中，我们声明了一个自定义函数 <samp class="SANS_TheSansMonoCd_W5Regular_11">str()</samp>，用于将我们方程的输出转换为字符串以便打印。这将大大减少我们在后续示例中输入的工作量。我们实际上根据数据类型定义了三种不同的函数，因为
    VHDL 是强类型语言，我们需要定义所有支持的函数输入，以便编译器知道使用哪个版本。第一个定义 ❶ 转换一个 <samp class="SANS_TheSansMonoCd_W5Regular_11">unsigned</samp>
    值，第二个 ❷ 转换一个 <samp class="SANS_TheSansMonoCd_W5Regular_11">signed</samp> 值，第三个
    ❸ 转换一个 <samp class="SANS_TheSansMonoCd_W5Regular_11">real</samp> 值。这是函数 *重载* 的一个例子，重载是一个编程技巧，允许一个函数有多个实现。重载是一个相对高级的
    VHDL 概念，但它非常有用。你甚至可以重载普通的 VHDL 运算符，如 <samp class="SANS_TheSansMonoCd_W5Regular_11">+</samp>
    和 <samp class="SANS_TheSansMonoCd_W5Regular_11">–</samp>，使用任何你需要的实现，尽管我并不建议这样做。
- en: Now that we have our testbench set up, we’re ready to start exploring math operations.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经设置好了测试平台，准备开始探索数学运算。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Addition</samp>
  id: totrans-84
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">加法</samp>
- en: 'Adding binary data works the same way you were taught to add numbers in elementary
    school: you add them one digit at a time, working from right to left. For example,
    here’s how to add the binary numbers <samp class="SANS_TheSansMonoCd_W5Regular_11">0010</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">1000</samp>:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 加法二进制数据的方式与小学时教你加法的方式相同：逐位相加，从右向左。例如，以下是如何加法两个二进制数<samp class="SANS_TheSansMonoCd_W5Regular_11">0010</samp>和<samp
    class="SANS_TheSansMonoCd_W5Regular_11">1000</samp>：
- en: '[PRE5]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: To arrive at the result, you simply go digit by digit, starting with the least
    significant bit, adding the digits in that column together. If you get 1 + 1 =
    10 in a column, then you write 0 at the bottom of the column and carry the 1 to
    the next digit to the left.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 要得出结果，你只需要逐位相加，从最低有效位开始，将该列的数字相加。如果在某一列中得到 1 + 1 = 10，那么你在该列的底部写下 0，并将 1 进位到左边的下一位。
- en: 'Notice that the result of adding two 4-bit numbers together is 5 bits wide.
    This is our first rule of FPGA math:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，将两个 4 位数相加后的结果是 5 位宽。这是 FPGA 数学的第一个规则：
- en: '**Rule #1** When adding, the result should be at least 1 bit bigger than the
    biggest input.'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '**规则 #1** 在加法时，结果的位数应至少比最大输入大 1 位。'
- en: 'The extra bit is needed in the case where adding the most significant bit requires
    a carry operation. Without the extra bit, we’d be truncating the result, which
    could produce an incorrect answer. In our first example, dropping the most significant
    bit wouldn’t make a difference, but consider this example where having that extra
    bit is critical:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 当加法的最高有效位需要进位操作时，额外的位是必要的。如果没有这个额外的位，我们就会截断结果，可能会得到错误的答案。在第一个例子中，丢弃最高有效位并不会产生问题，但考虑这个例子，拥有额外的位是至关重要的：
- en: '[PRE6]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Here, the most significant bit of the result is a 1\. Had we just assumed that
    the output width would be the same as the input widths, then we would have dropped
    this bit and gotten the wrong answer. Our result would have been <samp class="SANS_TheSansMonoCd_W5Regular_11">0100</samp>
    instead of <samp class="SANS_TheSansMonoCd_W5Regular_11">10100</samp>.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，结果的最高有效位是 1。如果我们假设输出宽度与输入宽度相同，那么我们就会丢掉这个位，得到错误的答案。我们的结果将是 <samp class="SANS_TheSansMonoCd_W5Regular_11">0100</samp>
    而不是 <samp class="SANS_TheSansMonoCd_W5Regular_11">10100</samp>。
- en: 'Perhaps you’ve noticed that I haven’t explicitly said what these binary numbers
    represent yet, and whether they’re positive or negative. For example, is <samp
    class="SANS_TheSansMonoCd_W5Regular_11">1001</samp> unsigned and equal to 9, or
    is it signed and equal to the two’s complement of 9, which is –7 (invert the bits
    to get <samp class="SANS_TheSansMonoCd_W5Regular_11">0110</samp>, then add 1 to
    get <samp class="SANS_TheSansMonoCd_W5Regular_11">0111</samp>)? The reason I haven’t
    specified this is because the representation of the binary data ultimately doesn’t
    affect how the math is performed, as long as the inputs and outputs are sized
    appropriately. Whether <samp class="SANS_TheSansMonoCd_W5Regular_11">1001</samp>
    represents +9 or –7, the addition operation will be performed the same way. Of
    course, we care if the result is positive or negative, but the implementation
    of the addition doesn’t change depending on whether the data types are signed
    or unsigned. Let’s revisit our first example and consider what happens when we
    assign it various signed and unsigned combinations. Here’s the example again:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 也许你注意到，我还没有明确说明这些二进制数字代表什么，也没有说明它们是正数还是负数。例如，<samp class="SANS_TheSansMonoCd_W5Regular_11">1001</samp>
    是无符号并等于 9，还是有符号并等于 9 的二进制补码，即 –7（反转位得到 <samp class="SANS_TheSansMonoCd_W5Regular_11">0110</samp>，然后加
    1 得到 <samp class="SANS_TheSansMonoCd_W5Regular_11">0111</samp>）？我之所以没有明确说明这一点，是因为二进制数据的表示方式最终不会影响数学运算的执行方式，只要输入和输出的位数合适。无论
    <samp class="SANS_TheSansMonoCd_W5Regular_11">1001</samp> 代表 +9 还是 –7，加法操作都会以相同的方式进行。当然，我们关心结果是正数还是负数，但加法的实现不会因为数据类型是有符号还是无符号而有所不同。让我们重新回到第一个例子，考虑一下当我们为其分配不同的有符号和无符号组合时会发生什么。以下是这个例子：
- en: '[PRE7]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: If both addition inputs are declared as unsigned types, then we have 2 + 8 =
    10\. Pretty simple. If both addition inputs are declared as signed, then the first
    input is still 2, but the second input is –8\. (Invert the bits to get <samp class="SANS_TheSansMonoCd_W5Regular_11">0111</samp>,
    add 1 to get <samp class="SANS_TheSansMonoCd_W5Regular_11">1000</samp>, and apply
    the negative sign to get –8.) So now we have 2 + –8, which should equal –6, but
    the result, <samp class="SANS_TheSansMonoCd_W5Regular_11">01010</samp>, is still
    10\. Something isn’t right here!
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 如果两个加法输入都声明为无符号类型，那么我们有 2 + 8 = 10。相当简单。如果两个加法输入都声明为有符号类型，那么第一个输入仍然是 2，但第二个输入是
    –8。 （反转位得到 <samp class="SANS_TheSansMonoCd_W5Regular_11">0111</samp>，加 1 得到 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">1000</samp>，然后应用负号得到 –8。）所以现在我们有 2 + –8，结果应该是
    –6，但结果 <samp class="SANS_TheSansMonoCd_W5Regular_11">01010</samp> 仍然是 10。这里出了点问题！
- en: 'The problem is that we’re not performing sign extension on the inputs. *Sign
    extension* is the operation of increasing the number of bits of a binary number
    while preserving the number’s sign and value. This operation is required when
    the inputs are signed. Without it, we’ll get an incorrect answer, as you’ve just
    seen. To perform sign extension on a signed value, simply replicate the most significant
    bit. For example, <samp class="SANS_TheSansMonoCd_W5Regular_11">1000</samp> becomes
    <samp class="SANS_TheSansMonoCd_W5Regular_11">11000</samp>, and <samp class="SANS_TheSansMonoCd_W5Regular_11">0010</samp>
    becomes <samp class="SANS_TheSansMonoCd_W5Regular_11">00010</samp>. Let’s try
    that math again, this time first applying sign extension to our inputs:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 问题是我们没有对输入进行符号扩展。*符号扩展*是将二进制数的位数增加，同时保持该数的符号和值的操作。输入为有符号时，需要进行此操作。如果没有，它会导致不正确的答案，就像你刚才看到的那样。要对有符号值执行符号扩展，只需复制最重要的位。例如，<samp
    class="SANS_TheSansMonoCd_W5Regular_11">1000</samp> 变成 <samp class="SANS_TheSansMonoCd_W5Regular_11">11000</samp>，而
    <samp class="SANS_TheSansMonoCd_W5Regular_11">0010</samp> 变成 <samp class="SANS_TheSansMonoCd_W5Regular_11">00010</samp>。让我们再次尝试这个运算，这次先对输入应用符号扩展：
- en: '[PRE8]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Our inputs are still 2 and –8\. (For the latter, invert the bits of <samp class="SANS_TheSansMonoCd_W5Regular_11">11000</samp>
    to get <samp class="SANS_TheSansMonoCd_W5Regular_11">00111</samp>, add 1 to get
    <samp class="SANS_TheSansMonoCd_W5Regular_11">01000</samp>, and apply the negative
    sign to get –8.) The answer, <samp class="SANS_TheSansMonoCd_W5Regular_11">11010</samp>,
    is the signed equivalent of –6, which is exactly what we want. Sign extension
    was the critical step to ensure we got the expected answer.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的输入仍然是 2 和 –8。 （对于后者，反转 <samp class="SANS_TheSansMonoCd_W5Regular_11">11000</samp>
    的位得到 <samp class="SANS_TheSansMonoCd_W5Regular_11">00111</samp>，加 1 得到 <samp class="SANS_TheSansMonoCd_W5Regular_11">01000</samp>，然后应用负号得到
    –8。）答案 <samp class="SANS_TheSansMonoCd_W5Regular_11">11010</samp> 是 –6 的有符号等效值，这正是我们想要的。符号扩展是确保我们得到预期答案的关键步骤。
- en: 'Sign extension is useful for unsigned values, too. In fact, since VHDL is strongly
    typed, the inputs and outputs to an addition operation must all have exactly the
    same width. You can’t, for example, add two 4-bit inputs to produce a 5-bit output;
    everything must be 5 bits. That means we should revisit Rule #1 and add a small
    modification:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '符号扩展对于无符号值也非常有用。事实上，由于 VHDL 是强类型的，所有参与加法运算的输入和输出必须具有完全相同的宽度。例如，你不能将两个 4 位输入相加得到一个
    5 位输出；所有的信号都必须是 5 位。这意味着我们应该重新审视规则 #1，并进行一个小的修改：'
- en: '**Rule #1 (modification #1)** When adding, the result should be at least 1
    bit bigger than the biggest input, *before sign extension*. Once sign extension
    is applied, the input and output widths should match exactly.'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '**规则 #1（修改 #1）** 在加法时，结果应至少比最大输入大 1 位，*在符号扩展之前*。一旦符号扩展应用，输入和输出的宽度应完全匹配。'
- en: For unsigned values, sign extension simply means adding a 0 as the new most
    significant bit. For example, unsigned <samp class="SANS_TheSansMonoCd_W5Regular_11">1000</samp>
    becomes <samp class="SANS_TheSansMonoCd_W5Regular_11">01000</samp>. The good news
    for those of you using Verilog is that the code performs sign extension automatically
    when you’re adding numbers. If you’re using VHDL, however, you’ll need to sign-extend
    your inputs manually using the <samp class="SANS_TheSansMonoCd_W5Regular_11">resize()</samp>
    function, as you’ll see in the coming examples. Both approaches have their pros
    and cons. Verilog is easier if you know what you’re doing, as there’s less to
    worry about, but it also leaves more room for mistakes (for example, trying to
    store data in too small a signal). VHDL’s extra steps can be more confusing for
    beginners, and it generates cryptic errors when the rules aren’t followed. On
    the other hand, VHDL ensures that you’ve matched widths and types every step along
    the way, so there’s less room for error in the end.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 对于无符号值，符号扩展意味着将0作为新的最高有效位。例如，无符号的 <samp class="SANS_TheSansMonoCd_W5Regular_11">1000</samp>
    变成 <samp class="SANS_TheSansMonoCd_W5Regular_11">01000</samp>。对于使用 Verilog 的用户来说，好消息是，当你加法运算时，代码会自动执行符号扩展。然而，如果你使用的是
    VHDL，你将需要通过 <samp class="SANS_TheSansMonoCd_W5Regular_11">resize()</samp> 函数手动进行符号扩展，正如接下来的示例中所展示的那样。这两种方法各有优缺点。如果你知道自己在做什么，Verilog
    更容易，因为你需要担心的东西较少，但也更容易出错（例如，试图将数据存储在一个过小的信号中）。VHDL 的额外步骤可能让初学者感到困惑，而且当规则没有遵循时，它会生成难以理解的错误。另一方面，VHDL
    确保每一步都匹配宽度和类型，因此最终出错的可能性较小。
- en: 'Let’s summarize what we’ve learned with a few code examples. Add this code
    to your testbench where you saw the <samp class="SANS_TheSansMonoCd_W5Regular_11">--</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">snip</samp><samp class="SANS_TheSansMonoCd_W5Regular_11">--</samp>
    earlier:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过一些代码示例来总结我们所学的内容。将以下代码添加到你的测试平台中，在你之前看到过的 <samp class="SANS_TheSansMonoCd_W5Regular_11">--</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">snip</samp><samp class="SANS_TheSansMonoCd_W5Regular_11">--</samp>
    位置：
- en: <samp class="SANS_Futura_Std_Bold_Oblique_BI_11">Verilog</samp>
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Oblique_BI_11">Verilog</samp>
- en: '[PRE9]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: <samp class="SANS_Futura_Std_Bold_Oblique_BI_11">VHDL</samp>
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Oblique_BI_11">VHDL</samp>
- en: '[PRE10]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Here’s the output:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是输出结果：
- en: <samp class="SANS_Futura_Std_Bold_Oblique_BI_11">Verilog</samp>
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Oblique_BI_11">Verilog</samp>
- en: '[PRE11]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: <samp class="SANS_Futura_Std_Bold_Oblique_BI_11">VHDL</samp>
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Oblique_BI_11">VHDL</samp>
- en: '[PRE12]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'First, we have two situations (<samp class="SANS_TheSansMonoCd_W5Regular_11">Ex01</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">Ex02</samp>) where Rule #1 isn’t
    followed. We’re using 4-bit inputs and storing the result in a 4-bit output, and
    we’re not performing any sign extension. In both of these examples, we get the
    wrong answer. In <samp class="SANS_TheSansMonoCd_W5Regular_11">Ex01</samp>, we
    add two unsigned numbers, 9 and 11, but get 4 as a result. The problem here is
    that we’re dropping the most significant bit, which would be worth 16\. (Indeed,
    4 + 16 = 20, which is the answer we should be getting.) In <samp class="SANS_TheSansMonoCd_W5Regular_11">Ex02</samp>,
    we add two signed numbers representing negative values, and again we get the wrong
    answer.'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '首先，我们有两个情况（<samp class="SANS_TheSansMonoCd_W5Regular_11">Ex01</samp> 和 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">Ex02</samp>），这两个例子没有遵循规则 #1。我们使用 4 位输入，并将结果存储在
    4 位输出中，而且没有执行符号扩展。在这两个例子中，我们得到了错误的结果。在 <samp class="SANS_TheSansMonoCd_W5Regular_11">Ex01</samp>
    中，我们加了两个无符号数，9 和 11，但得到了 4 作为结果。问题在于我们丢失了最高有效位，而这个位的值应该是 16。（事实上，4 + 16 = 20，这才是我们应该得到的答案。）在
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Ex02</samp> 中，我们加了两个表示负值的有符号数，结果依然是错误的。'
- en: 'The fix is to store the result in a 5-bit output, which we do in both <samp
    class="SANS_TheSansMonoCd_W5Regular_11">Ex03</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">Ex04</samp>.
    We’ve satisfied Rule #1, so the math works correctly. Notice that in the Verilog
    version, the sign extension happens automatically: we can simply assign 4-bit
    inputs to a 5-bit output, for example by writing <samp class="SANS_TheSansMonoCd_W5Regular_11">o_u5</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">=</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">i1_u4</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">+</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">i2_u4;</samp>.
    In VHDL, however, we must explicitly match input and output widths, while preserving
    the sign and value of each input. To do this, we call the <samp class="SANS_TheSansMonoCd_W5Regular_11">resize()</samp>
    function ❶. We use the VHDL tick attribute <samp class="SANS_TheSansMonoCd_W5Regular_11">''length</samp>
    to reference the length of the output signal, as we did when we were performing
    type conversions. Again, this is more flexible than hardcoding the desired width
    by writing something like <samp class="SANS_TheSansMonoCd_W5Regular_11">resize(i1_u4,
    5)</samp>.'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 解决方法是将结果存储在一个5位的输出中，我们在<samp class="SANS_TheSansMonoCd_W5Regular_11">Ex03</samp>和<samp
    class="SANS_TheSansMonoCd_W5Regular_11">Ex04</samp>中都这样做了。我们已经满足了规则#1，所以数学运算是正确的。注意，在Verilog版本中，符号扩展是自动进行的：我们可以简单地将4位输入赋值给5位输出，例如通过写<samp
    class="SANS_TheSansMonoCd_W5Regular_11">o_u5</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">=</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">i1_u4</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">+</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">i2_u4;</samp>。然而，在VHDL中，我们必须显式地匹配输入和输出的位宽，同时保留每个输入的符号和值。为此，我们调用<samp
    class="SANS_TheSansMonoCd_W5Regular_11">resize()</samp>函数❶。我们使用VHDL的tick属性<samp
    class="SANS_TheSansMonoCd_W5Regular_11">'length</samp>来引用输出信号的长度，正如我们在进行类型转换时所做的那样。再说一次，这比通过写类似<samp
    class="SANS_TheSansMonoCd_W5Regular_11">resize(i1_u4, 5)</samp>这样的硬编码宽度更灵活。
- en: 'Another tip for performing successful addition operations is to never mix signed
    and unsigned values. Your inputs and outputs should be of the same type; otherwise
    you might get an incorrect answer. This brings us to our second rule of FPGA math:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 进行成功的加法运算的另一个技巧是不要混合带符号和不带符号的值。输入和输出应该是相同类型的；否则，你可能会得到错误的结果。这引出了我们的第二条FPGA数学规则：
- en: '**Rule #2** Match types among inputs and outputs.'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '**规则#2** 输入和输出类型要匹配。'
- en: 'With VHDL, it’s easy to follow Rule #2 because it will throw an error if you
    try to do a math operation where one input is signed and the other is unsigned.
    For example, say you write this in your testbench to try to add a 4-bit unsigned
    value (<samp class="SANS_TheSansMonoCd_W5Regular_11">i1_u4</samp>) to a 4-bit
    signed value (<samp class="SANS_TheSansMonoCd_W5Regular_11">i2_s4</samp>):'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 对于VHDL来说，遵循规则#2很容易，因为如果你尝试进行一个输入为带符号、另一个输入为不带符号的数学运算，它会抛出错误。例如，假设你在测试平台中写下以下代码，尝试将一个4位的不带符号值（<samp
    class="SANS_TheSansMonoCd_W5Regular_11">i1_u4</samp>）与一个4位的带符号值（<samp class="SANS_TheSansMonoCd_W5Regular_11">i2_s4</samp>）相加：
- en: '[PRE13]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'You’ll end up with an error message indicating the tool doesn’t know how to
    interpret the <samp class="SANS_TheSansMonoCd_W5Regular_11">+</samp> operator
    given those inputs:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 你会看到一个错误消息，指出工具无法理解给定输入下的<samp class="SANS_TheSansMonoCd_W5Regular_11">+</samp>运算符：
- en: '[PRE14]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Verilog is much more lenient. It will happily let you perform that math operation,
    and it won’t tell you that it’s actually treating your signed input as unsigned.
    This can very possibly result in the wrong answer, so be careful to always match
    your data types in Verilog.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: Verilog的容错性更强。它会很高兴地让你执行该数学运算，而且不会告诉你它实际上是把带符号输入当作不带符号处理的。这很可能导致错误的结果，因此在Verilog中务必小心始终匹配数据类型。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Subtraction</samp>
  id: totrans-121
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">减法</samp>
- en: Subtraction isn’t that different from addition. After all, subtraction is just
    an addition operation where one of the inputs is negative. In this sense, we’ve
    been doing subtraction all along; 2 + –8 is the same as 2 – 8\. Likewise, you
    can think of something like 5 – 3 as 5 + –3 and approach it like an addition operation.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 减法与加法没什么不同。毕竟，减法只是将其中一个输入变为负数的加法运算。从这个角度看，我们一直在做减法；2 + –8 就等同于 2 – 8。同样，你可以把类似
    5 – 3 的运算看作 5 + –3，并以加法运算的方式进行处理。
- en: 'There’s one thing to be careful with when subtracting two numbers, though:
    while you *could* use subtraction with unsigned inputs and outputs, I wouldn’t
    recommend it. What happens if the result should be negative? For example, 3 –
    5 = –2, but if you try to store –2 into an unsigned data type, you won’t get the
    correct result. This brings us to our next rule:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，在进行两个数的减法时，有一件事需要特别注意：虽然你*可以*使用无符号输入和输出进行减法，但我不推荐这样做。如果结果应该是负数会怎样呢？例如，3 –
    5 = -2，但如果你尝试将 -2 存入无符号数据类型中，你将无法获得正确的结果。这引出了我们的下一个规则：
- en: '**Rule #3** When subtracting, use signed inputs and outputs.'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '**规则 #3** 在进行减法时，使用有符号的输入和输出。'
- en: Even if you don’t think the result of a subtraction will produce a negative
    number, you should use signed data types to be safe.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 即使你认为减法的结果不会产生负数，你也应该使用有符号数据类型，以确保安全。
- en: 'Because subtraction is really just negative addition, subtraction carries the
    same risk that you could truncate the result if the output isn’t sized appropriately.
    Again, it’s better to size up the output by 1 bit and to sign-extend your inputs
    before performing the math operation. This gives us a further modified Rule #1:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '因为减法实际上就是负数加法，所以减法存在相同的风险，即如果输出的大小不合适，可能会导致结果被截断。再次强调，最好在执行数学运算之前将输出大小增加1位，并对输入进行符号扩展。这给我们带来了进一步修改的规则
    #1：'
- en: '**Rule #1 (modification #2)** When adding *or subtracting*, the result should
    be at least 1 bit bigger than the biggest input, before sign extension. Once sign
    extension is applied, the input and output widths should match exactly.'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '**规则 #1（修改版 #2）** 在加法*或减法*时，结果应比最大输入大至少 1 位，符号扩展前如此。符号扩展应用后，输入和输出的位宽应该完全匹配。'
- en: 'With those two rules in place, let’s extend our <samp class="SANS_TheSansMonoCd_W5Regular_11">Math_Examples</samp>
    testbench to take a look at some subtraction operations in Verilog and VHDL:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这两条规则，我们扩展了 <samp class="SANS_TheSansMonoCd_W5Regular_11">Math_Examples</samp>
    测试平台，来观察 Verilog 和 VHDL 中的一些减法操作：
- en: <samp class="SANS_Futura_Std_Bold_Oblique_BI_11">Verilog</samp>
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Oblique_BI_11">Verilog</samp>
- en: '[PRE15]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: <samp class="SANS_Futura_Std_Bold_Oblique_BI_11">VHDL</samp>
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Oblique_BI_11">VHDL</samp>
- en: '[PRE16]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Here’s the output:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 这是输出：
- en: <samp class="SANS_Futura_Std_Bold_Oblique_BI_11">Verilog</samp>
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Oblique_BI_11">Verilog</samp>
- en: '[PRE17]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: <samp class="SANS_Futura_Std_Bold_Oblique_BI_11">VHDL</samp>
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Oblique_BI_11">VHDL</samp>
- en: '[PRE18]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'In <samp class="SANS_TheSansMonoCd_W5Regular_11">Ex05</samp>, we’re trying
    to calculate 9 – 11 but we get a result of 30, clearly the wrong answer. The problem
    here is that we’re using unsigned types for subtraction, which is a violation
    of Rule #3\. We fix this in <samp class="SANS_TheSansMonoCd_W5Regular_11">Ex06</samp>
    by converting the input values from unsigned to signed data types. We also perform
    sign extension in the process, going from 4-bit inputs to 5-bit inputs. In the
    Verilog code, we handle the conversion by simply assigning the 4-bit unsigned
    signals to 5-bit signed signals ❶. Verilog takes care of the details automatically.
    VHDL makes us jump through a few more hoops. We first resize the input, which
    will sign-extend it, but the result of the resize operation is still an unsigned
    type, so we then explicitly cast it to a signed data type using <samp class="SANS_TheSansMonoCd_W5Regular_11">signed()</samp>
    ❷. This is safe to do because we’ve already resized the signal, so the most significant
    bit will be 0\. Therefore, the value after converting to a signed type won’t be
    changed.'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '在 <samp class="SANS_TheSansMonoCd_W5Regular_11">Ex05</samp> 中，我们尝试计算 9 – 11，但结果却是
    30，显然是错误的答案。问题在于我们使用了无符号类型进行减法，这违反了规则 #3。我们在 <samp class="SANS_TheSansMonoCd_W5Regular_11">Ex06</samp>
    中通过将输入值从无符号转换为有符号数据类型来修复这一问题。在此过程中，我们还进行了符号扩展，将 4 位输入转换为 5 位输入。在 Verilog 代码中，我们通过将
    4 位无符号信号直接赋值给 5 位有符号信号来处理转换 ❶。Verilog 会自动处理细节。而 VHDL 需要我们多做一些工作。我们首先调整输入大小，这将进行符号扩展，但调整大小后的结果仍然是无符号类型，因此我们需要显式地使用
    <samp class="SANS_TheSansMonoCd_W5Regular_11">signed()</samp> 将其转换为有符号数据类型 ❷。这样做是安全的，因为我们已经调整了信号大小，所以最高位将是
    0。因此，转换为有符号类型后的值不会改变。'
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Multiplication</samp>
  id: totrans-139
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">乘法</samp>
- en: 'Multiplication also works similarly to addition; after all, a multiplication
    operation is just a series of repeated addition operations (4 × 3 = 4 + 4 + 4).
    The first thing to consider when multiplying two inputs together is how to properly
    size the output bit width. This brings us to our next rule:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
- en: '**Rule #4** When multiplying, the output bit width must be at least the sum
    of the input bit widths (before sign extension).'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
- en: 'This rule holds true for both signed and unsigned numbers. For example, say
    we’re trying to multiply the unsigned inputs <samp class="SANS_TheSansMonoCd_W5Regular_11">111</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">11</samp> (equivalent to 7 ×
    3). According to Rule #4, the output should be 3 + 2 = 5 bits wide. You can try
    out the multiplication yourself to confirm this, using the same technique you
    learned in school for multiplying multidigit numbers—multiply each digit individually
    and add the results together:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The output, <samp class="SANS_TheSansMonoCd_W5Regular_11">10101</samp> (equivalent
    to 21), is indeed 5 bits wide, which is what we expected. But what happens to
    this same multiplication if we treat our inputs and outputs as signed, rather
    than unsigned? In this case, we would have the equivalent of –1 × –1 in decimal,
    which should produce a result of +1, but signed <samp class="SANS_TheSansMonoCd_W5Regular_11">10101</samp>
    in binary is equal to –11 in decimal. What’s wrong here?
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
- en: 'The problem is that we didn’t sign-extend our inputs to match the width of
    our output (5 bits) before multiplying. If we do that, our inputs both become
    <samp class="SANS_TheSansMonoCd_W5Regular_11">11111</samp>, and the multiplication
    looks like this:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Now we’re getting <samp class="SANS_TheSansMonoCd_W5Regular_11">00000001</samp>,
    or really <samp class="SANS_TheSansMonoCd_W5Regular_11">00001</samp> once we truncate
    the result to be 5 bits wide, which is +1 in decimal. Sign extension gives us
    the result we expect. Unlike with addition and subtraction, however, you don’t
    actually need to perform this sign extension manually when multiplying numbers
    using Verilog or VHDL. The tools will handle this automatically; you simply need
    to size the output signal correctly.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
- en: 'VHDL helps with this too: it won’t even let you compile the code if you disobey
    Rule #4 and fail to size the output of a multiplication correctly. With Verilog,
    you’ll need to be more careful. It won’t warn you if the output is the wrong size,
    and you could get an unexpected result. Let’s add some examples of this to our
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Math_Examples</samp> testbench:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Oblique_BI_11">Verilog</samp>
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: <samp class="SANS_Futura_Std_Bold_Oblique_BI_11">VHDL</samp>
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Here’s the output:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Oblique_BI_11">Verilog</samp>
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: <samp class="SANS_Futura_Std_Bold_Oblique_BI_11">VHDL</samp>
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Verilog allows us to perform the math operation despite the fact that we’re
    disobeying Rule #4 by multiplying 4 bits by 4 bits and storing the result in a
    4-bit output. This produces incorrect results for both unsigned (<samp class="SANS_TheSansMonoCd_W5Regular_11">Ex07</samp>)
    and signed (<samp class="SANS_TheSansMonoCd_W5Regular_11">Ex08</samp>) input values.
    VHDL, on the other hand, won’t even build this code; we get a nice descriptive
    error telling us that the tool is trying to assign an 8-bit-wide result to a 4-bit-wide
    variable, which isn’t permitted. Let’s add a few more examples to our testbench
    that fix these issues:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Oblique_BI_11">Verilog</samp>
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: <samp class="SANS_Futura_Std_Bold_Oblique_BI_11">VHDL</samp>
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Here’s the output:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Oblique_BI_11">Verilog</samp>
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: <samp class="SANS_Futura_Std_Bold_Oblique_BI_11">VHDL</samp>
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: In <samp class="SANS_TheSansMonoCd_W5Regular_11">Ex09</samp>, we correct the
    problem in <samp class="SANS_TheSansMonoCd_W5Regular_11">Ex07</samp> by storing
    the output of multiplying two unsigned 4-bit values into an 8-bit signal. Similarly,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Ex10</samp> corrects the issue from
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Ex08</samp> with signed values.
    Notice that we never have to sign-extend the inputs, in either Verilog or VHDL.
    The tools handle this automatically.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Multiplication by
    Powers of 2</samp>
  id: totrans-169
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'There’s a trick that we can use when multiplying numbers by a power of 2 (for
    example, 2, 4, 8, 16, 32, …). Rather than instantiating a bunch of multiplication
    logic, we can simply instantiate a shift register and perform a shift left operation.
    Shifting left by *N* bits is equivalent to multiplying by 2*^N*. For example,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">0011</samp> (3 in binary) shifted
    left 2 bits gives us <samp class="SANS_TheSansMonoCd_W5Regular_11">1100</samp>
    (12 in binary). It’s the same as calculating 3 × 4, or 3 × 2². This trick works
    for both signed and unsigned numbers. Let’s try it out in our testbench:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Oblique_BI_11">Verilog</samp>
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: <samp class="SANS_Futura_Std_Bold_Oblique_BI_11">VHDL</samp>
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Here’s the output:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Oblique_BI_11">Verilog</samp>
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: <samp class="SANS_Futura_Std_Bold_Oblique_BI_11">VHDL</samp>
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: We start with the decimal value 3 and shift left by 1, 2, and 4 bits to multiply
    it by 2, 4, and 16, respectively. In Verilog we perform the shift using the <samp
    class="SANS_TheSansMonoCd_W5Regular_11"><<</samp> operator, and in VHDL we use
    the function <samp class="SANS_TheSansMonoCd_W5Regular_11">shift_left()</samp>.
    Both take as an argument the number of bit positions to shift.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
- en: Shifting left is a simple and quick trick to save FPGA resources, but you don’t
    necessarily need to write it out explicitly. It’s likely that if you hardcode
    a multiplication by a power of 2, the synthesis tools will be smart enough to
    figure out that a left shift would take fewer resources.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 左移是节省FPGA资源的一个简单快捷的技巧，但你不一定需要显式地写出来。如果你硬编码了一个2的幂乘法，综合工具可能会足够聪明，自动识别出左移操作会占用更少的资源。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Division</samp>
  id: totrans-182
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Division</samp>
- en: Unfortunately, division isn’t nearly as simple an operation as addition, subtraction,
    or multiplication. Division comes with all sorts of messy complications, like
    remainders and fractions. In general, it’s a good idea to avoid division inside
    your FPGA if you can. It’s a resource-intensive operation, especially if you need
    that operation to run at high clock rates.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，除法不像加法、减法或乘法那样简单。除法会带来各种复杂问题，比如余数和分数。一般来说，如果可以的话，最好避免在FPGA内部进行除法。除法是一个资源密集型的操作，尤其是在你需要让这个操作在高时钟频率下运行时。
- en: I once worked on a project that needed to add a division operation to an FPGA
    in the field. The FPGA was a very old part, and it simply couldn’t fit it within
    the available resources. To accommodate the division operation we ended up having
    to upgrade to a higher-resource FPGA of the same family, which increased the cost
    of the hardware by over $1 million. I always think of that one extra operation
    as the million-dollar divide!
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 我曾经参与一个项目，需要在现场为FPGA添加一个除法操作。那个FPGA是一个非常老旧的型号，根本无法在现有资源下完成这项操作。为了支持除法操作，我们最终不得不升级到同一家族的高资源FPGA，这使得硬件成本增加了超过100万美元。我一直把那一次额外的操作当作百万美元除法！
- en: If you *must* divide numbers, there are a few ways to make the operation less
    resource-intensive. These include restricting yourself to dividing by powers of
    2, using a precalculated table of answers, or breaking up the operation across
    multiple clock cycles.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你*必须*进行除法操作，有几种方法可以使这个操作更节省资源。这些方法包括限制自己只进行2的幂除法，使用预先计算好的答案表，或者将操作分解到多个时钟周期中进行。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Using Powers of 2</samp>
  id: totrans-186
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">使用2的幂</samp>
- en: 'My best suggestion for reducing the overhead of dividing numbers inside an
    FPGA is to make the divisor a power of 2\. Similar to how multiplication by a
    power of 2 can be efficiently performed with a shift left operation, division
    by a power of 2 can be performed efficiently with a shift right operation. Shifting
    right by *N* bits is equivalent to dividing by 2*^N*. Let’s look at a few examples
    of this:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 我对减少在FPGA内部进行除法操作开销的最佳建议是将除数设为2的幂。类似于如何使用左移操作高效地进行2的幂乘法，2的幂除法也可以通过右移操作高效地完成。右移*N*位相当于除以2*^N*。让我们来看看几个例子：
- en: <samp class="SANS_Futura_Std_Bold_Oblique_BI_11">Verilog</samp>
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Oblique_BI_11">Verilog</samp>
- en: '[PRE33]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: <samp class="SANS_Futura_Std_Bold_Oblique_BI_11">VHDL</samp>
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Oblique_BI_11">VHDL</samp>
- en: '[PRE34]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Here’s the output:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是输出结果：
- en: <samp class="SANS_Futura_Std_Bold_Oblique_BI_11">Verilog</samp>
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Oblique_BI_11">Verilog</samp>
- en: '[PRE35]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: <samp class="SANS_Futura_Std_Bold_Oblique_BI_11">VHDL</samp>
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Oblique_BI_11">VHDL</samp>
- en: '[PRE36]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">Ex14</samp> performs a shift right
    by 1, which in Verilog uses the <samp class="SANS_TheSansMonoCd_W5Regular_11">>></samp>
    operator and in VHDL uses the <samp class="SANS_TheSansMonoCd_W5Regular_11">shift_right()</samp>
    function. This accomplishes a single divide by 2\. To divide by 4, shift right
    by 2 bit positions, as in <samp class="SANS_TheSansMonoCd_W5Regular_11">Ex15</samp>.
    Likewise, a right shift by 4 divides by 16, as in <samp class="SANS_TheSansMonoCd_W5Regular_11">Ex16</samp>.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">Ex14</samp>执行了右移1位，在Verilog中使用的是
    <samp class="SANS_TheSansMonoCd_W5Regular_11">>></samp> 运算符，而在VHDL中使用的是 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">shift_right()</samp> 函数。这完成了一个除以2的操作。要除以4，可以右移2个位位置，如
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Ex15</samp> 所示。同样，右移4位相当于除以16，如
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Ex16</samp> 所示。
- en: 'What happens when we don’t have a number that’s cleanly divisible by the power
    of 2 serving as the divisor? In this case, shifting right effectively accomplishes
    a division that’s rounded down to the nearest integer. The next few examples illustrate
    how this works:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们没有一个能被2的幂整除的数字作为除数时会发生什么呢？在这种情况下，右移操作有效地完成了一个向下取整到最接近整数的除法。接下来的几个例子将说明这是如何工作的：
- en: <samp class="SANS_Futura_Std_Bold_Oblique_BI_11">Verilog</samp>
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Oblique_BI_11">Verilog</samp>
- en: '[PRE37]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: <samp class="SANS_Futura_Std_Bold_Oblique_BI_11">VHDL</samp>
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Oblique_BI_11">VHDL</samp>
- en: '[PRE38]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Here’s the output:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 这是输出结果：
- en: <samp class="SANS_Futura_Std_Bold_Oblique_BI_11">Verilog</samp>
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Oblique_BI_11">Verilog</samp>
- en: '[PRE39]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: <samp class="SANS_Futura_Std_Bold_Oblique_BI_11">VHDL</samp>
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Oblique_BI_11">VHDL</samp>
- en: '[PRE40]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: In <samp class="SANS_TheSansMonoCd_W5Regular_11">Ex17</samp>, we try to perform
    15 / 2\. This should give us 7.5, but we have no way to represent the .5 part,
    so we end up rounding down to 7 instead. Thinking of this as a shift right, we
    went from <samp class="SANS_TheSansMonoCd_W5Regular_11">00001111</samp> to <samp
    class="SANS_TheSansMonoCd_W5Regular_11">00000111</samp>. In <samp class="SANS_TheSansMonoCd_W5Regular_11">Ex18</samp>,
    we try to take 15 / 4, which should be 3.75, but we drop the decimal places and
    just get 3\. Finally, in <samp class="SANS_TheSansMonoCd_W5Regular_11">Ex19</samp>
    we get 15 / 8 = 1\. This rounding might cause a problem if you’re not expecting
    it, so be aware that this can happen when performing shift right operations.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 在 <samp class="SANS_TheSansMonoCd_W5Regular_11">Ex17</samp> 中，我们尝试执行 15 / 2\。这应该得到
    7.5，但我们无法表示 .5 部分，因此最终会向下取整为 7。将其视为右移操作，我们从 <samp class="SANS_TheSansMonoCd_W5Regular_11">00001111</samp>
    变为 <samp class="SANS_TheSansMonoCd_W5Regular_11">00000111</samp>。在 <samp class="SANS_TheSansMonoCd_W5Regular_11">Ex18</samp>
    中，我们尝试计算 15 / 4，这应该得到 3.75，但我们会去掉小数部分，只得到 3\。最后，在 <samp class="SANS_TheSansMonoCd_W5Regular_11">Ex19</samp>
    中，我们得到 15 / 8 = 1\。如果你没有预料到这种情况，这种舍入可能会引发问题，因此请注意在执行右移操作时可能会发生这种情况。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Using a Precalculated Table</samp>
  id: totrans-209
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">使用预计算表</samp>
- en: Another option for dividing two numbers is to precalculate the result for all
    possible input combinations. For example, if we’re trying to divide any number
    1 through 7 by any other number 1 through 7, we could create something like [Table
    10-3](#tab10-3) inside the FPGA.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种除法操作的选项是为所有可能的输入组合预先计算结果。例如，如果我们尝试将数字 1 到 7 中的任何数字除以 1 到 7 中的任何其他数字，我们可以在
    FPGA 中创建类似[表 10-3](#tab10-3)的内容。
- en: <samp class="SANS_Futura_Std_Heavy_B_11">Table 10-3:</samp> <samp class="SANS_Futura_Std_Book_11">Precalculated
    Table for Full Range of Division Inputs</samp>
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Heavy_B_11">表 10-3：</samp> <samp class="SANS_Futura_Std_Book_11">全范围除法输入的预计算表</samp>
- en: '|  | <samp class="SANS_Futura_Std_Heavy_B_11">1</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">2</samp>
    | <samp class="SANS_Futura_Std_Heavy_B_11">3</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">4</samp>
    | <samp class="SANS_Futura_Std_Heavy_B_11">5</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">6</samp>
    | <samp class="SANS_Futura_Std_Heavy_B_11">7</samp> |'
  id: totrans-212
  prefs: []
  type: TYPE_TB
  zh: '|  | <samp class="SANS_Futura_Std_Heavy_B_11">1</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">2</samp>
    | <samp class="SANS_Futura_Std_Heavy_B_11">3</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">4</samp>
    | <samp class="SANS_Futura_Std_Heavy_B_11">5</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">6</samp>
    | <samp class="SANS_Futura_Std_Heavy_B_11">7</samp> |'
- en: '| --- | --- | --- | --- | --- | --- | --- | --- |'
  id: totrans-213
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- | --- | --- | --- | --- |'
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">1</samp> | <samp class="SANS_Futura_Std_Book_11">1.00</samp>
    | <samp class="SANS_Futura_Std_Book_11">0.50</samp> | <samp class="SANS_Futura_Std_Book_11">0.33</samp>
    | <samp class="SANS_Futura_Std_Book_11">0.25</samp> | <samp class="SANS_Futura_Std_Book_11">0.20</samp>
    | <samp class="SANS_Futura_Std_Book_11">0.17</samp> | <samp class="SANS_Futura_Std_Book_11">0.14</samp>
    |'
  id: totrans-214
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_Futura_Std_Heavy_B_11">1</samp> | <samp class="SANS_Futura_Std_Book_11">1.00</samp>
    | <samp class="SANS_Futura_Std_Book_11">0.50</samp> | <samp class="SANS_Futura_Std_Book_11">0.33</samp>
    | <samp class="SANS_Futura_Std_Book_11">0.25</samp> | <samp class="SANS_Futura_Std_Book_11">0.20</samp>
    | <samp class="SANS_Futura_Std_Book_11">0.17</samp> | <samp class="SANS_Futura_Std_Book_11">0.14</samp>
    |'
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">2</samp> | <samp class="SANS_Futura_Std_Book_11">2.00</samp>
    | <samp class="SANS_Futura_Std_Book_11">1.00</samp> | <samp class="SANS_Futura_Std_Book_11">0.67</samp>
    | <samp class="SANS_Futura_Std_Book_11">0.50</samp> | <samp class="SANS_Futura_Std_Book_11">0.40</samp>
    | <samp class="SANS_Futura_Std_Book_11">0.33</samp> | <samp class="SANS_Futura_Std_Book_11">0.29</samp>
    |'
  id: totrans-215
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_Futura_Std_Heavy_B_11">2</samp> | <samp class="SANS_Futura_Std_Book_11">2.00</samp>
    | <samp class="SANS_Futura_Std_Book_11">1.00</samp> | <samp class="SANS_Futura_Std_Book_11">0.67</samp>
    | <samp class="SANS_Futura_Std_Book_11">0.50</samp> | <samp class="SANS_Futura_Std_Book_11">0.40</samp>
    | <samp class="SANS_Futura_Std_Book_11">0.33</samp> | <samp class="SANS_Futura_Std_Book_11">0.29</samp>
    |'
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">3</samp> | <samp class="SANS_Futura_Std_Book_11">3.00</samp>
    | <samp class="SANS_Futura_Std_Book_11">1.50</samp> | <samp class="SANS_Futura_Std_Book_11">1.00</samp>
    | <samp class="SANS_Futura_Std_Book_11">0.75</samp> | <samp class="SANS_Futura_Std_Book_11">0.60</samp>
    | <samp class="SANS_Futura_Std_Book_11">0.50</samp> | <samp class="SANS_Futura_Std_Book_11">0.43</samp>
    |'
  id: totrans-216
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">4</samp> | <samp class="SANS_Futura_Std_Book_11">4.00</samp>
    | <samp class="SANS_Futura_Std_Book_11">2.00</samp> | <samp class="SANS_Futura_Std_Book_11">1.33</samp>
    | <samp class="SANS_Futura_Std_Book_11">1.00</samp> | <samp class="SANS_Futura_Std_Book_11">0.80</samp>
    | <samp class="SANS_Futura_Std_Book_11">0.67</samp> | <samp class="SANS_Futura_Std_Book_11">0.57</samp>
    |'
  id: totrans-217
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">5</samp> | <samp class="SANS_Futura_Std_Book_11">5.00</samp>
    | <samp class="SANS_Futura_Std_Book_11">2.50</samp> | <samp class="SANS_Futura_Std_Book_11">1.67</samp>
    | <samp class="SANS_Futura_Std_Book_11">1.25</samp> | <samp class="SANS_Futura_Std_Book_11">1.00</samp>
    | <samp class="SANS_Futura_Std_Book_11">0.83</samp> | <samp class="SANS_Futura_Std_Book_11">0.71</samp>
    |'
  id: totrans-218
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">6</samp> | <samp class="SANS_Futura_Std_Book_11">6.00</samp>
    | <samp class="SANS_Futura_Std_Book_11">3.00</samp> | <samp class="SANS_Futura_Std_Book_11">2.00</samp>
    | <samp class="SANS_Futura_Std_Book_11">1.50</samp> | <samp class="SANS_Futura_Std_Book_11">1.20</samp>
    | <samp class="SANS_Futura_Std_Book_11">1.00</samp> | <samp class="SANS_Futura_Std_Book_11">0.86</samp>
    |'
  id: totrans-219
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">7</samp> | <samp class="SANS_Futura_Std_Book_11">7.00</samp>
    | <samp class="SANS_Futura_Std_Book_11">3.50</samp> | <samp class="SANS_Futura_Std_Book_11">2.33</samp>
    | <samp class="SANS_Futura_Std_Book_11">1.75</samp> | <samp class="SANS_Futura_Std_Book_11">1.40</samp>
    | <samp class="SANS_Futura_Std_Book_11">1.17</samp> | <samp class="SANS_Futura_Std_Book_11">1.00</samp>
    |'
  id: totrans-220
  prefs: []
  type: TYPE_TB
- en: For this example, let’s assume that each row represents a possible dividend,
    and each column represents a possible divisor. The value at the intersection of
    a given dividend and divisor is the corresponding quotient. As an example, to
    find the value in decimal for the fraction 5/6, go to row 5, then over to column
    6 to get the value 0.83\. To implement this in Verilog or VHDL, we could store
    this two-dimensional table in a 2D array. (You saw how 2D arrays work in the state
    machine project in [Chapter 8](chapter8.xhtml).) The row input values provide
    one index, the column input values provide the second index, and the quotient
    is the value at those two indices. We’re not actually performing any math here;
    we’re just indexing into the correct result, which has been precalculated and
    stored in memory.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Dogma_OT_Bold_B_21">NOTE</samp>
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
- en: '*If you’re wondering how to represent decimal values like 0.50 and 0.33 inside
    an FPGA, good question! We’ll explore this topic shortly.*'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
- en: As the range of possible inputs grows, of course, we’ll need a larger and larger
    table to store the possible outputs. Eventually, a single table could take up
    an entire block RAM, which are often 16Kb in size. Using a precalculated table
    in a block RAM guarantees that a single division calculation will take a single
    clock cycle, since we only need one clock cycle to read from the memory (as you
    learned when we discussed RAM back in [Chapter 6](chapter6.xhtml)). However, we
    can’t read from multiple locations in the memory on the same clock cycle, so if
    we needed to do two divisions simultaneously, on the exact same clock cycle, we
    would need to instantiate a second copy of the precalculated table in another
    block RAM.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
- en: Block RAMs are usually valuable resources, so taking up a bunch of them for
    concurrent divisions doesn’t scale very well. If the design will allow us to run
    the different divisions in consecutive clock cycles, rather than simultaneously,
    we could instead use a single table and time-share it. Time sharing a single resource
    would require arbitration of that resource, as we discussed in [Chapter 7](chapter7.xhtml).
    We would have to create some arbiter that would only allow access to the block
    RAM table by one module at a time.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
- en: The solutions discussed up to this point assume we have just one clock cycle
    to get the result of a division operation. However, if we can wait multiple clock
    cycles for the result of a division operation, that allows us to use another option.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Using Multiple Clock Cycles</samp>
  id: totrans-227
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Another way to ease the burden of the synthesis tools when it comes to division
    is to create an algorithm that performs division in more than a single clock cycle,
    using simpler math operations such as addition and subtraction. At its heart,
    division is about calculating how many times one number fits into another number.
    You can accomplish this, for example, by adding the divisor to itself over and
    over until you’ve passed the value of the dividend, while counting the number
    of times you had to run that loop. Then you subtract the dividend to get the remainder.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
- en: There are various other techniques for performing division using simpler math
    operations. (Specific implementations are beyond the scope of this book; search
    the web for *division algorithms on FPGAs* if you want to learn more.) But of
    course, these methods only work if you’re able to wait multiple clock cycles for
    the result. Using multiple clock cycles to produce a result is a bit different
    in this context than the pipelining example we discussed in [Chapter 7](chapter7.xhtml),
    where we broke up a complex math operation across multiple clock cycles to meet
    timing. In that case, we were still able to get a result every clock cycle, but
    the outputs were delayed a few clock cycles from the inputs.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
- en: In this case, we don’t know how many clock cycles the division algorithm will
    take to provide a result, so we can’t rely on a result each clock cycle. Ultimately,
    it’s a question of trading lower resource utilization for more clock cycles. If
    you really need to get the result of a division operation on every single clock
    cycle, you’ll have to use one of the previously discussed division techniques.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">How FPGAs Implement Math Operations</samp>
  id: totrans-231
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: With all the operations we’ve discussed so far, we’ve only looked at how the
    math works, without really considering how the operations are implemented inside
    an FPGA. There are various FPGA components that may be involved, depending on
    the specific operation performed. If you take an introductory digital electronics
    course, you might learn about *half adders* and *full adders*, digital circuits
    that combine various logic gates (like XOR and AND) to perform addition operations.
    It’s a fascinating subject, but in the end you might be frustrated to find that
    you don’t need to know how these circuits work to be able to do math with modern
    FPGA code. You’ll never need to instantiate a full adder component by manually
    typing out all the necessary logic operations if you’re just adding two numbers
    together. Instead, you just use the <samp class="SANS_TheSansMonoCd_W5Regular_11">+</samp>
    operator in Verilog or VHDL, like you would in any other programming language,
    and trust the synthesis tools to handle the implementation.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
- en: The tools will likely place addition and subtraction operations into basic LUTs.
    For multiplication, the tools will use flip-flops for the shift left approach,
    or LUTs or DSP blocks (if available) for more complicated calculations. As discussed
    in [Chapter 9](chapter9.xhtml), DSP blocks are useful for accelerating large multiply–accumulate
    operations without utilizing a lot of LUT logic. Finally, division will require
    registers for the shift right approach, block RAMs for the precalculated table
    approach, or LUTs.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
- en: 'There’s more to math than just addition, subtraction, multiplication, and division,
    however. Look at your calculator and consider all the operations we haven’t discussed:
    sine, cosine, square root, and more. It’s certainly possible to run these operations
    on an FPGA, but it gets complicated and is beyond the scope of this book. If you’re
    interested in learning more, there are dedicated algorithms that you can instantiate
    for these, such as a Coordinate Rotation Digital Computer (CORDIC). Search GitHub
    for *FPGA CORDIC* and you’ll find many examples.'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
- en: In addition to actually implementing more complicated math operations on your
    FPGA, if you have the option it might be worth sending the inputs to a dedicated
    processor to perform the calculations, and then returning the result back to the
    FPGA logic. We’ll discuss floating- versus fixed-point arithmetic in the next
    section, but processors are much more capable of performing floating-point arithmetic
    than FPGAs. This processor can be a dedicated component external to the FPGA,
    or it can be internal to the FPGA itself. If it’s internal, it’s referred to as
    either a hard-core processor or a soft-core processor, depending on if it’s a
    dedicated piece of silicon or not.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
- en: Many modern FPGAs have internal hard ARM cores. This type of component with
    FPGA logic and a dedicated processor is often referred to as a *system on a chip
    (SoC)*. You can send the operations from the FPGA LUT/flip-flop logic into the
    ARM core for processing, and it will perform whatever operation is required and
    return the result. This solution is more about handling data than performing math,
    since you’ll likely need to set up FIFOs for each of the inputs and outputs. Working
    with a separate processor is an advanced topic, but it can be very valuable in
    higher-end applications.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Working with Decimals</samp>
  id: totrans-237
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'So far we’ve been working with integers, but there are many applications where
    you’ll need your FPGA to operate on numbers with a decimal component. In this
    section, we’ll examine how to do math using non-integers. To begin with, we need
    to consider how fractional numbers are actually represented using binary digits.
    There are two possible systems to choose from: floating point and fixed point.'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
- en: The vast majority of mathematical operations within electronic devices use *floating-point*
    arithmetic, since most CPUs are designed to handle floating-point numbers. The
    key to floating point is that the *radix* (the decimal separator) “floats,” depending
    on how much precision is needed. We won’t go into detail about how exactly this
    works, but the bottom line is that with 32 bits you can represent an enormous
    range of values, with varying precision; you can represent very small numbers
    with high precision, or very large numbers with less precision. *Fixed-point*
    arithmetic, on the other hand, has a fixed radix, meaning there are a fixed number
    of integer places and a fixed number of decimal places.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
- en: FPGAs *can* perform floating-point operations, but they often require more resources
    than fixed-point operations. Most FPGA math is therefore done with fixed-point
    arithmetic, so that will be our focus for the rest of the chapter.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
- en: To illustrate how fixed-point representation works, let’s take an example. Say
    we have 3 bits allotted for representing a number inside our FPGA. We’ve been
    assuming up to this point that each bit change will be worth one integer value.
    For example, going from <samp class="SANS_TheSansMonoCd_W5Regular_11">001</samp>
    to <samp class="SANS_TheSansMonoCd_W5Regular_11">010</samp> means that we go from
    1 to 2\. But we’ve just arbitrarily decided that each bit is worth one integer.
    We could just as easily decide that a single bit is worth something else, for
    example 0.5\. In that case, <samp class="SANS_TheSansMonoCd_W5Regular_11">001</samp>
    would be equivalent to 0.5, <samp class="SANS_TheSansMonoCd_W5Regular_11">010</samp>
    would be 1.0, <samp class="SANS_TheSansMonoCd_W5Regular_11">011</samp> would be
    1.5, and so on. We now have a fixed-point system where the rightmost bit represents
    the decimal component of the number and the other two bits represent the integer
    component. We can also interpret the bits in other ways to give us different fixed-point
    representations. [Table 10-4](#tab10-4) shows the most common decimal interpretations
    of 3 unsigned bits.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Heavy_B_11">Table 10-4:</samp> <samp class="SANS_Futura_Std_Book_11">3-Bit
    Unsigned Fixed-Point Possibilities</samp>
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">Bits</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">U3.0</samp>
    | <samp class="SANS_Futura_Std_Heavy_B_11">U2.1</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">U1.2</samp>
    | <samp class="SANS_Futura_Std_Heavy_B_11">U0.3</samp> |'
  id: totrans-243
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- | --- |'
  id: totrans-244
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">000</samp> | <samp class="SANS_Futura_Std_Book_11">0</samp>
    | <samp class="SANS_Futura_Std_Book_11">0</samp> | <samp class="SANS_Futura_Std_Book_11">0</samp>
    | <samp class="SANS_Futura_Std_Book_11">0</samp> |'
  id: totrans-245
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">001</samp> | <samp class="SANS_Futura_Std_Book_11">1</samp>
    | <samp class="SANS_Futura_Std_Book_11">0.5</samp> | <samp class="SANS_Futura_Std_Book_11">0.25</samp>
    | <samp class="SANS_Futura_Std_Book_11">0.125</samp> |'
  id: totrans-246
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">010</samp> | <samp class="SANS_Futura_Std_Book_11">2</samp>
    | <samp class="SANS_Futura_Std_Book_11">1.0</samp> | <samp class="SANS_Futura_Std_Book_11">0.50</samp>
    | <samp class="SANS_Futura_Std_Book_11">0.250</samp> |'
  id: totrans-247
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">011</samp> | <samp class="SANS_Futura_Std_Book_11">3</samp>
    | <samp class="SANS_Futura_Std_Book_11">1.5</samp> | <samp class="SANS_Futura_Std_Book_11">0.75</samp>
    | <samp class="SANS_Futura_Std_Book_11">0.375</samp> |'
  id: totrans-248
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">100</samp> | <samp class="SANS_Futura_Std_Book_11">4</samp>
    | <samp class="SANS_Futura_Std_Book_11">2.0</samp> | <samp class="SANS_Futura_Std_Book_11">1.00</samp>
    | <samp class="SANS_Futura_Std_Book_11">0.500</samp> |'
  id: totrans-249
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">101</samp> | <samp class="SANS_Futura_Std_Book_11">5</samp>
    | <samp class="SANS_Futura_Std_Book_11">2.5</samp> | <samp class="SANS_Futura_Std_Book_11">1.25</samp>
    | <samp class="SANS_Futura_Std_Book_11">0.625</samp> |'
  id: totrans-250
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">110</samp> | <samp class="SANS_Futura_Std_Book_11">6</samp>
    | <samp class="SANS_Futura_Std_Book_11">3.0</samp> | <samp class="SANS_Futura_Std_Book_11">1.50</samp>
    | <samp class="SANS_Futura_Std_Book_11">0.750</samp> |'
  id: totrans-251
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">111</samp> | <samp class="SANS_Futura_Std_Book_11">7</samp>
    | <samp class="SANS_Futura_Std_Book_11">3.5</samp> | <samp class="SANS_Futura_Std_Book_11">1.75</samp>
    | <samp class="SANS_Futura_Std_Book_11">0.875</samp> |'
  id: totrans-252
  prefs: []
  type: TYPE_TB
- en: The headings in [Table 10-4](#tab10-4) use a modified version of *Q notation*,
    which is a way to specify the parameters of a binary fixed-point number format.
    In Q notation, for example, Q1.2 indicates that 1 bit is being used for the integer
    portion of a number and 2 bits are being used for the fractional portion. Standard
    Q notation assumes the values are signed; however, in FPGAs it’s very common to
    have unsigned and signed values. That’s why I prefer a notation that specifies
    if the values are signed (S) or unsigned (U) using the leading character. Thus,
    S3.1 indicates a signed value with 3 integer bits and 1 fractional bit, and U4.8
    indicates an unsigned value with 4 integer bits and 8 fractional bits.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
- en: In [Table 10-4](#tab10-4), the U3.0 column is what we’re used to; all 3 bits
    are allotted to the integer portion of the number, so we only have whole numbers.
    Let’s consider the next column, U2.1\. It’s unsigned, with 2 bits for the integer
    component and 1 bit for the decimal component. This means the integer part can
    be in the range <samp class="SANS_TheSansMonoCd_W5Regular_11">00</samp>, <samp
    class="SANS_TheSansMonoCd_W5Regular_11">01</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">10</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">11</samp>, and the decimal part
    can be in the range <samp class="SANS_TheSansMonoCd_W5Regular_11">0</samp> or
    <samp class="SANS_TheSansMonoCd_W5Regular_11">1</samp>. To figure out what possible
    values that represents, simply take the original U3.0 value and divide it by 2\.
    For example, <samp class="SANS_TheSansMonoCd_W5Regular_11">111</samp> is 7 in
    U3.0, but in U2.1 it’s 3.5 (7 / 2 = 3.5). In general, when there are *N* bits
    allotted to the fractional portion of the number, you divide the integer representation
    by 2*^N* to determine the fixed-point value. Thus, <samp class="SANS_TheSansMonoCd_W5Regular_11">111</samp>
    in U0.3 is 7 / 2³ = 7 / 8 = 0.875.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
- en: In [Table 10-4](#tab10-4) we treated all the values as unsigned. [Table 10-5](#tab10-5)
    shows the most common possibilities for interpreting the same 3 bits when we use
    signed data types.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Heavy_B_11">Table 10-5:</samp> <samp class="SANS_Futura_Std_Book_11">3-Bit
    Signed Fixed-Point Possibilities</samp>
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">Bits</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">S3.0</samp>
    | <samp class="SANS_Futura_Std_Heavy_B_11">S2.1</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">S1.2</samp>
    | <samp class="SANS_Futura_Std_Heavy_B_11">S0.3</samp> |'
  id: totrans-257
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- | --- |'
  id: totrans-258
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">000</samp> | <samp class="SANS_Futura_Std_Book_11">0</samp>
    | <samp class="SANS_Futura_Std_Book_11">0</samp> | <samp class="SANS_Futura_Std_Book_11">0</samp>
    | <samp class="SANS_Futura_Std_Book_11">0</samp> |'
  id: totrans-259
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">001</samp> | <samp class="SANS_Futura_Std_Book_11">1</samp>
    | <samp class="SANS_Futura_Std_Book_11">0.5</samp> | <samp class="SANS_Futura_Std_Book_11">0.25</samp>
    | <samp class="SANS_Futura_Std_Book_11">0.125</samp> |'
  id: totrans-260
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">010</samp> | <samp class="SANS_Futura_Std_Book_11">2</samp>
    | <samp class="SANS_Futura_Std_Book_11">1.0</samp> | <samp class="SANS_Futura_Std_Book_11">0.50</samp>
    | <samp class="SANS_Futura_Std_Book_11">0.250</samp> |'
  id: totrans-261
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">011</samp> | <samp class="SANS_Futura_Std_Book_11">3</samp>
    | <samp class="SANS_Futura_Std_Book_11">1.5</samp> | <samp class="SANS_Futura_Std_Book_11">0.75</samp>
    | <samp class="SANS_Futura_Std_Book_11">0.375</samp> |'
  id: totrans-262
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">100</samp> | <samp class="SANS_Futura_Std_Book_11">–4</samp>
    | <samp class="SANS_Futura_Std_Book_11">–2.0</samp> | <samp class="SANS_Futura_Std_Book_11">–1.00</samp>
    | <samp class="SANS_Futura_Std_Book_11">–0.500</samp> |'
  id: totrans-263
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">101</samp> | <samp class="SANS_Futura_Std_Book_11">–3</samp>
    | <samp class="SANS_Futura_Std_Book_11">–1.5</samp> | <samp class="SANS_Futura_Std_Book_11">–0.75</samp>
    | <samp class="SANS_Futura_Std_Book_11">–0.375</samp> |'
  id: totrans-264
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">110</samp> | <samp class="SANS_Futura_Std_Book_11">–2</samp>
    | <samp class="SANS_Futura_Std_Book_11">–1.0</samp> | <samp class="SANS_Futura_Std_Book_11">–0.50</samp>
    | <samp class="SANS_Futura_Std_Book_11">–0.250</samp> |'
  id: totrans-265
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">111</samp> | <samp class="SANS_Futura_Std_Book_11">–</samp><samp
    class="SANS_Futura_Std_Book_11">1</samp> | <samp class="SANS_Futura_Std_Book_11">–0.5</samp>
    | <samp class="SANS_Futura_Std_Book_11">–0.25</samp> | <samp class="SANS_Futura_Std_Book_11">–0.125</samp>
    |'
  id: totrans-266
  prefs: []
  type: TYPE_TB
- en: The S3.0 column shows the same signed whole number values we saw earlier in
    the chapter, in [Table 10-1](#tab10-1). We can generate the remaining columns
    by dividing the values in the S3.0 column by 2 for S2.1, by 4 for S1.2, and by
    8 for S0.3.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s the critical thing about working with fixed-point numbers: when you’re
    performing operations on binary data, the behavior of the binary operation doesn’t
    change based on its representation. Addition, subtraction, multiplication, and
    division all work exactly the same way as before, when we were treating the numbers
    as integers. However, there are a few more rules that need to be established to
    get the correct answer with fixed-point values.'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
- en: You’ll notice for the remainder of this chapter that I make an effort to keep
    track of the decimals in the code examples. I find it very helpful to add comments
    recording the width of the math operations in my Verilog or VHDL code. For example,
    when adding two 3-bit numbers together to get a 4-bit result, I’ll include a comment
    like <samp class="SANS_TheSansMonoCd_W5Regular_11">// U2.1</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">+</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">U2.1</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">=</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">U3.1</samp> so I know the decimal
    and integer widths. This is particularly useful when there are several math operations
    chained one after another, where the widths along the way might be changing.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Adding and Subtracting
    with Fixed Point</samp>
  id: totrans-270
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'When performing addition or subtraction with fixed-point decimals, the actual
    process doesn’t change. The data is still just binary. There’s another rule that
    we must apply when we have decimals involved, however:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
- en: '**Rule #5** When adding or subtracting, the decimal widths must match.'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
- en: 'The number of places to the right of the decimal point determines the value,
    or *weight*, of each bit, so if you try to add or subtract two inputs with different
    decimal bit widths—for example, a U3.1 input and a U4.0 input—you’ll get a wrong
    answer. We can see that in the following code:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Oblique_BI_11">Verilog</samp>
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: <samp class="SANS_Futura_Std_Bold_Oblique_BI_11">VHDL</samp>
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Here’s the output:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Oblique_BI_11">Verilog</samp>
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: <samp class="SANS_Futura_Std_Bold_Oblique_BI_11">VHDL</samp>
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: '<samp class="SANS_TheSansMonoCd_W5Regular_11">Ex20</samp> shows the effect
    of not obeying Rule #5\. Here we’re attempting to add a U3.1 to a U4.0\. This
    is going to cause a problem because the weight of the bits being added together
    isn’t matched. Indeed, the printout tells us that 1.5 + 3 = 3, so something has
    clearly gone wrong.'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
- en: Notice that we’ve divided the input U3.1 and the output U5.1 by 2.0 to print
    out these fixed-point values correctly ❶. For Verilog, we can simply do the division
    on the unsigned input and use <samp class="SANS_TheSansMonoCd_W5Regular_11">%f</samp>
    to format the result like a float. In VHDL, the conversion is a bit more complicated.
    First we need to switch to the <samp class="SANS_TheSansMonoCd_W5Regular_11">real</samp>
    data type, which is used for numbers with decimals, and then we can divide by
    2.0 for printing.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
- en: 'To fix this example, we need to adjust one of the inputs so it has the same
    number of decimal bits as the other input. We can either change the first input
    from U3.1 to U4.0 to match the second input, or change the second input from U4.0
    to U4.1\. In the following code, we try both options:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Oblique_BI_11">Verilog</samp>
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: <samp class="SANS_Futura_Std_Bold_Oblique_BI_11">VHDL</samp>
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Here’s the output:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Oblique_BI_11">Verilog</samp>
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: <samp class="SANS_Futura_Std_Bold_Oblique_BI_11">VHDL</samp>
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'In <samp class="SANS_TheSansMonoCd_W5Regular_11">Ex21</samp>, we convert the
    U3.1 to a U4.0, effectively dropping the decimal point. We do this using a 1-bit
    shift to the right ❶. But consider the effect of this: we’re eliminating the least
    significant bit, and if that bit has a 1 in it, then we’re dropping that data.
    Essentially, we’re performing a rounding operation to the next lowest integer.
    We can see that our first input was originally 1.5, but after dropping the decimal
    point it’s 1.0\. The math is correct, 1.0 + 3.0 = 4.0, but we’ve truncated our
    input.'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
- en: '<samp class="SANS_TheSansMonoCd_W5Regular_11">Ex22</samp> shows a better solution
    that retains the precision of all inputs. Rather than shifting the first input
    to the right, we shift the second input to the left ❷. This pads the least significant
    bit with a 0, converting our second input from U4.0 to U4.1\. Notice that this
    means the second input now occupies a total of 5 bits. We need to be sure to resize
    it, or we could end up losing the data in the most significant bit during the
    shift left. Additionally, our output now has to be 6 bits so we don’t violate
    Rule #1.'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
- en: Now that the decimal widths of the two inputs are matched with no loss of precision,
    we’re able to successfully calculate that 1.5 + 3.0 = 4.5\. Expanding your inputs
    to match is the best solution if you don’t want to round any of the decimal values.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Dogma_OT_Bold_B_21">NOTE</samp>
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
- en: '*Subtracting fixed-point numbers works with all the same rules as addition,
    so we won’t consider an example here. Follow the rules introduced in this chapter,
    and your subtraction operations will work as expected.*'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Multiplying with
    Fixed Point</samp>
  id: totrans-300
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Multiplication with fixed-point numbers doesn’t require any shifting to match
    the decimal widths. Instead, we can simply multiply the two inputs together as
    they are, provided we keep track of the input widths and size the output appropriately.
    We already have a rule for multiplication:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
- en: '**Rule #4** When multiplying, the output bit width must be at least the sum
    of the input bit widths (before sign extension).'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we need to add another rule to account for fixed-point numbers:'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
- en: '**Rule #6** When multiplying fixed-point numbers, add the integer component
    bit widths and the decimal component bit widths of your inputs separately to get
    the output format.'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, if you’re trying to multiply a U3.5 by a U1.7, the result is formatted
    as a U4.12\. We determine this by adding the integer components (3 + 1 = 4) and
    the decimal components (5 + 7 = 12), and putting them together to get the output
    width format. It works the same way for signed values, so S3.0 × S2.4 = S5.4\.
    Notice that we’re still obeying Rule #4 as well, since the output width will be
    the sum of the input widths. It’s just that the integer and decimal components
    are treated separately.'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s take a look at some examples in Verilog and VHDL:'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Oblique_BI_11">Verilog</samp>
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  id: totrans-308
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: <samp class="SANS_Futura_Std_Bold_Oblique_BI_11">VHDL</samp>
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  id: totrans-310
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Here’s the output:'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Oblique_BI_11">Verilog</samp>
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  id: totrans-313
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: <samp class="SANS_Futura_Std_Bold_Oblique_BI_11">VHDL</samp>
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  id: totrans-315
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'In <samp class="SANS_TheSansMonoCd_W5Regular_11">Ex23</samp>, we’re multiplying
    a U2.2 by a U3.1 to get a result that’s a U5.3\. We can see in the printout that
    the answer is correct: 1.25 × 5.5 = 6.875\. As with the addition examples, notice
    that we have to divide the values to print them out correctly. We divide the U2.2
    by 4, the U3.1 by 2, and the U5.3 by 8\. In <samp class="SANS_TheSansMonoCd_W5Regular_11">Ex24</samp>,
    we use the same technique to multiply signed values. We’re multiplying 1.5 by
    –6.0 to get –9.0, which is represented with S2.2 × S4.0 = S6.2.'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Summary</samp>
  id: totrans-317
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Since FPGAs are known for being able to perform many calculations at fast clock
    rates and in parallel, many common FPGA applications call for using addition,
    subtraction, multiplication, and division. Inside your FPGA, these operations
    may involve LUTs, shift registers, or DSP blocks. More important than knowing
    exactly how the operations are implemented, however, is understanding how the
    inputs and outputs are stored and what those binary digits represent when you’re
    writing your Verilog or VHDL code. Are they signed or unsigned? Integers or fixed
    point?
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
- en: 'Over the course of this chapter, we’ve developed a set of rules for successfully
    performing FPGA math operations and interpreting the results. They are:'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
- en: '**Rule #1** When adding or subtracting, the result should be at least 1 bit
    bigger than the biggest input, before sign extension. Once sign extension is applied,
    the input and output widths should match exactly.'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
- en: '**Rule #2** Match types among inputs and outputs.'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
- en: '**Rule #3** When subtracting, use signed inputs and outputs.'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
- en: '**Rule #4** When multiplying, the output bit width must be at least the sum
    of the input bit widths (before sign extension).'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
- en: '**Rule #5** When adding or subtracting, the decimal widths must match.'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
- en: '**Rule #6** When multiplying fixed-point numbers, add the integer component
    bit widths and the decimal component bit widths of your inputs separately to get
    the output format.'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
- en: These rules don’t capture every nuance of performing math in FPGAs, but they
    cover the major details that you need to get right. If you follow these six rules,
    it’s much more likely that you’ll get the correct answer from your calculations.
    Whenever you’re working with math, adding tests will help to ensure things are
    working as you expect.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
