- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">10</samp> <samp class="SANS_Dogma_OT_Bold_B_11">NUMBERS
    AND MATH</samp>
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '![](../images/opener-img.png)'
  prefs: []
  type: TYPE_IMG
- en: Throughout this book, I’ve been saying that FPGAs are good at performing mathematical
    computations quickly. I’ve also been saying that FPGAs are good at doing tasks
    in parallel, and that the combination of these two assets—fast math done in parallel—is
    one of their killer features. In low-level Verilog or VHDL code, however, working
    with numbers and math is full of pitfalls.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we’ll explore exactly how FPGAs manage mathematical calculations
    so you can avoid those pitfalls. To understand the details of how operations like
    addition, subtraction, multiplication, and division work, we also need to understand
    how to represent numbers, both positive and negative, with or without decimals,
    inside your FPGA. It’s time for a journey in the wonderful world of computer arithmetic.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Numerical Data Types</samp>
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are many ways to represent numbers in Verilog or VHDL, as is true with
    all programming languages. For example, if you want to store only whole numbers,
    you can use an integer data type, but if you need to store fractional numbers,
    you’ll need a data type that can represent decimals. Choosing the right type for
    the data you’re trying to represent is critical in any programming language. If
    you assign data to the wrong type, you’ll either get compiler errors or, worse,
    a design that behaves strangely. For example, trying to assign a decimal number
    to an integer data type could truncate the fractional component, causing an unintended
    rounding operation.
  prefs: []
  type: TYPE_NORMAL
- en: Additionally, you don’t want to use more resources than necessary. For example,
    you could create every signal with a 64-bit-wide data type, but that’s clearly
    overkill if all you need is a counter that goes from 0 to 7\. FPGAs provide even
    more granular control over data types than you get with most other programming
    languages. For example, C has the <samp class="SANS_TheSansMonoCd_W5Regular_11">uint8_t</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">uint16_t</samp>, and <samp class="SANS_TheSansMonoCd_W5Regular_11">uint32_t</samp>
    data types, which create data widths of 8, 16, and 32 bits, respectively, but
    there’s nothing in between. In Verilog and VHDL, by contrast, you can create a
    signal that’s 9 bits wide, 15 bits wide, 23 bits wide, or any other number. We’ll
    explore recommendations for sizing signals later in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Representing Signed
    vs. Unsigned Values</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'When you’re working with numbers, you need to know if they’re positive or negative.
    Sometimes, such as if you’re counting clock cycles to keep track of time, you’ll
    know the values will all be positive. In this case, you can store the numbers
    using an *unsigned* data type; the sign (positive or negative) isn’t specified
    and is assumed to be positive. Other times, you’ll need to work with negative
    numbers: for example, when you’re reading temperature values, where the sign of
    the numbers might vary. In these cases you’ll need to use a *signed* data type,
    where the positive or negative sign is specified.'
  prefs: []
  type: TYPE_NORMAL
- en: 'By default, signals in Verilog and VHDL are unsigned. For example, if we need
    a counter that counts from 0 to 7, we can declare a signal like <samp class="SANS_TheSansMonoCd_W5Regular_11">reg
    [2:0] counter;</samp> in Verilog or <samp class="SANS_TheSansMonoCd_W5Regular_11">signal
    counter : std_logic_vector(2 downto 0);</samp> in VHDL. We’ve used code like this
    throughout the book. It will create a 3-bit register, and since it’s unsigned
    by default, the values on the register will all be interpreted as positive. If
    we want <samp class="SANS_TheSansMonoCd_W5Regular_11">counter</samp> to represent
    negative numbers as well as positive ones, we’d have to explicitly declare it
    to be signed using the <samp class="SANS_TheSansMonoCd_W5Regular_11">signed</samp>
    keyword. In Verilog we would write <samp class="SANS_TheSansMonoCd_W5Regular_11">reg
    signed [2:0] counter;</samp>, and in VHDL we would use <samp class="SANS_TheSansMonoCd_W5Regular_11">signal
    counter : signed(2 downto 0);</samp>.'
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Dogma_OT_Bold_B_21">NOTE</samp>
  prefs: []
  type: TYPE_NORMAL
- en: '*To access the signed keyword in VHDL, you need to use the numeric_std package,
    which you can do by adding the line use ieee.numeric_std.all; at the top of your
    file. You may see some code that uses the std_logic_arith package instead, but
    this isn’t an official IEEE-supported library and I don’t recommend using it.
    It’s easier to make mistakes with this package than with numeric_std.*'
  prefs: []
  type: TYPE_NORMAL
- en: Using the <samp class="SANS_TheSansMonoCd_W5Regular_11">signed</samp> keyword
    explicitly tells the tools that this 3-bit-wide register can represent negative
    and positive values. But which values can we actually represent with it? [Table
    10-1](#tab10-1) compares the values represented by a 3-bit unsigned register and
    a 3-bit signed register. (We’ll discuss how to determine the signed values in
    the next section.)
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Heavy_B_11">Table 10-1:</samp> <samp class="SANS_Futura_Std_Book_11">3-Bit
    Unsigned vs. Signed Decimal Values</samp>
  prefs: []
  type: TYPE_NORMAL
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">Bits</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">Unsigned
    decimal value</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">Signed decimal
    value</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">000</samp> | <samp class="SANS_Futura_Std_Book_11">0</samp>
    | <samp class="SANS_Futura_Std_Book_11">0</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">001</samp> | <samp class="SANS_Futura_Std_Book_11">1</samp>
    | <samp class="SANS_Futura_Std_Book_11">1</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">010</samp> | <samp class="SANS_Futura_Std_Book_11">2</samp>
    | <samp class="SANS_Futura_Std_Book_11">2</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">011</samp> | <samp class="SANS_Futura_Std_Book_11">3</samp>
    | <samp class="SANS_Futura_Std_Book_11">3</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">100</samp> | <samp class="SANS_Futura_Std_Book_11">4</samp>
    | <samp class="SANS_Futura_Std_Book_11">–4</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">101</samp> | <samp class="SANS_Futura_Std_Book_11">5</samp>
    | <samp class="SANS_Futura_Std_Book_11">–3</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">110</samp> | <samp class="SANS_Futura_Std_Book_11">6</samp>
    | <samp class="SANS_Futura_Std_Book_11">–2</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">111</samp> | <samp class="SANS_Futura_Std_Book_11">7</samp>
    | <samp class="SANS_Futura_Std_Book_11">–1</samp> |'
  prefs: []
  type: TYPE_TB
- en: Notice that when a register is declared as signed, we lose some numbers on the
    positive end of the range (4, 5, 6, and 7 in this case) but gain some numbers
    on the negative end (–1, –2, –3, and –4). The range of numbers that can be represented
    by an unsigned register is 0 to 2*^N* − 1, where *N* is the number of bits available.
    For this 3-bit register, we can represent from 0 to 2³ − 1 = 7 if the register
    is unsigned. On the other hand, the range of numbers that can be represented by
    a signed register is –2^(*^N*^(–1)) to 2^(*^N*^(–1)) − 1\. In this case, that
    gives us –2^((3–1)) to 2^((3–1)) − 1, or = –4 to 3\. The data is still 3 bits
    of binary data, but *what that binary data represents* is different.
  prefs: []
  type: TYPE_NORMAL
- en: Another feature to notice in [Table 10-1](#tab10-1) is that the values that
    are negative all have a 1 in the most significant bit position. In fact, the most
    significant bit in a signed number is the *sign bit*, which indicates whether
    the number being represented is positive or negative. For signed binary numbers,
    a 0 in the sign bit tells you that the number is positive, while a 1 in the sign
    bit tells you that the number is negative.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Taking the Two’s
    Complement</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: How do you know what decimal value a negatively signed binary number is supposed
    to represent? You take its *two’s complement*, a mathematical operation where
    you invert the number’s bits and then add 1\. For example, take the binary number
    <samp class="SANS_TheSansMonoCd_W5Regular_11">101</samp>. If this were an unsigned
    number, we’d interpret it as 5 in decimal, but if it’s a signed number, the 1
    in the sign bit tells us that the represented value should be negative, so we
    have to take the two’s complement. First, we invert <samp class="SANS_TheSansMonoCd_W5Regular_11">101</samp>,
    which gives us <samp class="SANS_TheSansMonoCd_W5Regular_11">010</samp>. Then
    we add 1, giving us <samp class="SANS_TheSansMonoCd_W5Regular_11">011</samp>,
    which is 3 in decimal. Finally, we apply the negative sign to get –3\. Look back
    at [Table 10-1](#tab10-1) and you’ll see that’s what we have in the row for <samp
    class="SANS_TheSansMonoCd_W5Regular_11">101</samp>.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Dogma_OT_Bold_B_21">NOTE</samp>
  prefs: []
  type: TYPE_NORMAL
- en: '*An alternative to the invert-and-add-one method is to start at the right-most
    (least significant) bit, move left until you get to the first 1, then invert all
    the remaining bits to the left of that 1\. For example, 100010 100 becomes 011101
    100\. The three bolded bits, up to and including the first 1 from the right, remain
    the same, while the others are inverted. In decimal, 011101100 is 236; applying
    the negative sign, we know that 100010100 represents –236\. This method avoids
    the need for addition and can be simpler for long numbers.*'
  prefs: []
  type: TYPE_NORMAL
- en: We can also take a two’s complement to go in the other direction, converting
    a negative decimal number into its signed binary representation. For example,
    how would we represent –1 in binary using 3 bits? First, strip away the negative
    sign to get 1, which is <samp class="SANS_TheSansMonoCd_W5Regular_11">001</samp>
    in binary. Then invert the bits to get <samp class="SANS_TheSansMonoCd_W5Regular_11">110</samp>,
    and add 1 to get <samp class="SANS_TheSansMonoCd_W5Regular_11">111</samp>. Again,
    check [Table 10-1](#tab10-1) and you’ll see that this is the correct result.
  prefs: []
  type: TYPE_NORMAL
- en: Taking the two’s complement is a useful trick us humans can use to better understand
    how to interpret signed numbers, but this invert-and-add-one logic *isn’t something
    an FPGA actually does* when working with negative values. The data is binary 1s
    and 0s whether a number is signed or unsigned. It’s just the *representation*
    of those 1s and 0s that makes a difference. When you have a 3-bit unsigned signal
    set to <samp class="SANS_TheSansMonoCd_W5Regular_11">101</samp>, that represents
    the decimal value 5\. When you have a 3-bit signed signal set to <samp class="SANS_TheSansMonoCd_W5Regular_11">101</samp>,
    that represents the decimal value –3\. The FPGA doesn’t have to invert and add
    bits anywhere to know that. It just needs to know that the signal is of a signed
    data type. This is an important point and will become clearer as we explore mathematical
    operations in binary.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Sizing Signals Appropriately</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When you write Verilog or VHDL code working with signed and unsigned data types,
    you must ensure that you properly size the signals you’re creating. If you try
    to store too large of a number in too small of a signal, you’ll get data loss.
    As we just discussed, for example, the value of a 3-bit unsigned counter maxes
    out at 7\. If you try to increment it again from 7, it won’t go to 8; it’ll actually
    go back to 0\. This is sometimes called *wraparound*, and if you’re not expecting
    it, you’ll end up losing count. As you’ll see later in the chapter, ensuring your
    signals are large enough to handle your data is particularly important when the
    signals are for holding the results of mathematical operations.
  prefs: []
  type: TYPE_NORMAL
- en: 'To avoid data loss you might be tempted to make all your signals larger than
    they need to be, but there’s a downside to this, too: you’ll end up using more
    of your FPGA’s precious resources than are needed. This may be less of a problem
    than you think, though. If the synthesis tools are smart enough, they might detect
    that your possible range of values is smaller than the signal you’ve created and
    remove the upper bits that are unused to conserve resources. If the tools did
    this to our <samp class="SANS_TheSansMonoCd_W5Regular_11">counter</samp> register,
    for example, we’d see a warning saying something like <samp class="SANS_TheSansMonoCd_W5Regular_11">Pruning
    register counter</samp> in the synthesis report. Getting a warning like this isn’t
    usually a problem, but it might indicate code you could revisit and size differently.'
  prefs: []
  type: TYPE_NORMAL
- en: As a rule of thumb, you should aim to size your signals to the values you expect
    them to store, but know that making them too large is a much better solution than
    making them too small. Of course, you have to remember that the maximum value
    you can represent with a given number of bits varies depending on whether the
    values are signed or unsigned. For comparison, [Table 10-2](#tab10-2) summarizes
    the ranges of possible unsigned and signed values you can represent using between
    2 and 8 bits.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Heavy_B_11">Table 10-2:</samp> <samp class="SANS_Futura_Std_Book_11">N-bit
    Sizing for Unsigned and Signed Data Types</samp>
  prefs: []
  type: TYPE_NORMAL
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">Width</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">Type</samp>
    | <samp class="SANS_Futura_Std_Heavy_B_11">Min integer</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">Min
    binary</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">Max integer</samp> |
    <samp class="SANS_Futura_Std_Heavy_B_11">Max binary</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_Futura_Std_Book_11">2</samp> | <samp class="SANS_Futura_Std_Book_11">Unsigned</samp>
    | <samp class="SANS_Futura_Std_Book_11">0</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">00</samp>
    | <samp class="SANS_Futura_Std_Book_11">3</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">11</samp>
    |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_Futura_Std_Book_11">2</samp> | <samp class="SANS_Futura_Std_Book_11">Signed</samp>
    | <samp class="SANS_Futura_Std_Book_11">–2</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">10</samp>
    | <samp class="SANS_Futura_Std_Book_11">1</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">01</samp>
    |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_Futura_Std_Book_11">3</samp> | <samp class="SANS_Futura_Std_Book_11">Unsigned</samp>
    | <samp class="SANS_Futura_Std_Book_11">0</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">000</samp>
    | <samp class="SANS_Futura_Std_Book_11">7</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">111</samp>
    |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_Futura_Std_Book_11">3</samp> | <samp class="SANS_Futura_Std_Book_11">Signed</samp>
    | <samp class="SANS_Futura_Std_Book_11">–4</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">100</samp>
    | <samp class="SANS_Futura_Std_Book_11">3</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">011</samp>
    |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_Futura_Std_Book_11">4</samp> | <samp class="SANS_Futura_Std_Book_11">Unsigned</samp>
    | <samp class="SANS_Futura_Std_Book_11">0</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">0000</samp>
    | <samp class="SANS_Futura_Std_Book_11">15</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">1111</samp>
    |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_Futura_Std_Book_11">4</samp> | <samp class="SANS_Futura_Std_Book_11">Signed</samp>
    | <samp class="SANS_Futura_Std_Book_11">–8</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">1000</samp>
    | <samp class="SANS_Futura_Std_Book_11">7</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">0111</samp>
    |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_Futura_Std_Book_11">5</samp> | <samp class="SANS_Futura_Std_Book_11">Unsigned</samp>
    | <samp class="SANS_Futura_Std_Book_11">0</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">00000</samp>
    | <samp class="SANS_Futura_Std_Book_11">31</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">11111</samp>
    |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_Futura_Std_Book_11">5</samp> | <samp class="SANS_Futura_Std_Book_11">Signed</samp>
    | <samp class="SANS_Futura_Std_Book_11">–16</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">10000</samp>
    | <samp class="SANS_Futura_Std_Book_11">15</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">01111</samp>
    |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_Futura_Std_Book_11">6</samp> | <samp class="SANS_Futura_Std_Book_11">Unsigned</samp>
    | <samp class="SANS_Futura_Std_Book_11">0</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">000000</samp>
    | <samp class="SANS_Futura_Std_Book_11">63</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">111111</samp>
    |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_Futura_Std_Book_11">6</samp> | <samp class="SANS_Futura_Std_Book_11">Signed</samp>
    | <samp class="SANS_Futura_Std_Book_11">–32</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">100000</samp>
    | <samp class="SANS_Futura_Std_Book_11">31</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">011111</samp>
    |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_Futura_Std_Book_11">7</samp> | <samp class="SANS_Futura_Std_Book_11">Unsigned</samp>
    | <samp class="SANS_Futura_Std_Book_11">0</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">0000000</samp>
    | <samp class="SANS_Futura_Std_Book_11">127</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">1111111</samp>
    |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_Futura_Std_Book_11">7</samp> | <samp class="SANS_Futura_Std_Book_11">Signed</samp>
    | <samp class="SANS_Futura_Std_Book_11">–64</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">1000000</samp>
    | <samp class="SANS_Futura_Std_Book_11">63</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">0111111</samp>
    |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_Futura_Std_Book_11">8</samp> | <samp class="SANS_Futura_Std_Book_11">Unsigned</samp>
    | <samp class="SANS_Futura_Std_Book_11">0</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">00000000</samp>
    | <samp class="SANS_Futura_Std_Book_11">255</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">11111111</samp>
    |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_Futura_Std_Book_11">8</samp> | <samp class="SANS_Futura_Std_Book_11">Signed</samp>
    | <samp class="SANS_Futura_Std_Book_11">–128</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">10000000</samp>
    | <samp class="SANS_Futura_Std_Book_11">127</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">01111111</samp>
    |'
  prefs: []
  type: TYPE_TB
- en: Starting at a width of 2 bits, we can represent the numbers 0 to 3 unsigned,
    or –2 to 1 signed. At a width of 8 bits, we can represent 0 to 255 unsigned, or
    –128 to 127 signed.
  prefs: []
  type: TYPE_NORMAL
- en: 'One way to bypass the sizing dilemma is to size your signals dynamically, instead
    of setting them to a fixed width. We’ve seen some examples of this throughout
    the book. For instance, if you need to index into something 32 words deep but
    that depth could change in the future, you could write something like <samp class="SANS_TheSansMonoCd_W5Regular_11">reg
    [$clog2(DEPTH)-1:0] index;</samp> instead of <samp class="SANS_TheSansMonoCd_W5Regular_11">reg
    [4:0] index;</samp> in Verilog, or <samp class="SANS_TheSansMonoCd_W5Regular_11">signal
    index : integer range 0 to DEPTH-1;</samp> instead of <samp class="SANS_TheSansMonoCd_W5Regular_11">signal
    index : std_logic_vector(4 downto 0);</samp> in VHDL. Here, <samp class="SANS_TheSansMonoCd_W5Regular_11">DEPTH</samp>
    is a parameter/generic that can be changed on the fly. Using it will generate
    a signal of the exact bit width you need, wide enough to index into all possible
    values from <samp class="SANS_TheSansMonoCd_W5Regular_11">0</samp> to <samp class="SANS_TheSansMonoCd_W5Regular_11">DEPTH-1</samp>,
    with no extra headroom. In this case, you would set <samp class="SANS_TheSansMonoCd_W5Regular_11">DEPTH</samp>
    to <samp class="SANS_TheSansMonoCd_W5Regular_11">32</samp>, but if your indexing
    requirement were to grow to some larger value (say 1,024), the code won’t break;
    all you’ll have to do is change <samp class="SANS_TheSansMonoCd_W5Regular_11">DEPTH</samp>.
    By contrast, if you arbitrarily say that <samp class="SANS_TheSansMonoCd_W5Regular_11">index</samp>
    will be fixed to 8 bits wide (which has a maximum value of 255, as you can see
    in [Table 10-2](#tab10-2)), then your code might break in the future if your requirements
    grow beyond that range.'
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Converting Between
    Types in VHDL</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: VHDL has many numeric data types, including <samp class="SANS_TheSansMonoCd_W5Regular_11">signed</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">unsigned</samp>, where binary
    values are interpreted as positive or negative decimal numbers; <samp class="SANS_TheSansMonoCd_W5Regular_11">integer</samp>,
    where you can type numbers directly into the code; and <samp class="SANS_TheSansMonoCd_W5Regular_11">std_logic_vector</samp>,
    where by default binary values aren’t interpreted as anything other than binary
    values. Because VHDL is strongly typed, you’ll often need to convert between these
    different data types when you’re working with numbers. Before we do any math,
    let’s look at some examples of how to implement common VHDL type conversions using
    the <samp class="SANS_TheSansMonoCd_W5Regular_11">numeric_std</samp> package (not
    the unofficial <samp class="SANS_TheSansMonoCd_W5Regular_11">std_logic_arith</samp>).
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Dogma_OT_Bold_B_21">NOTE</samp>
  prefs: []
  type: TYPE_NORMAL
- en: '*Verilog users don’t need to worry about performing these conversions, since
    Verilog is loosely typed. VHDL users should consult this section as needed for
    reference.*'
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">From Unsigned or Signed to
    Integer</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'This example illustrates how to convert from the <samp class="SANS_TheSansMonoCd_W5Regular_11">unsigned</samp>
    or <samp class="SANS_TheSansMonoCd_W5Regular_11">signed</samp> type to the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">integer</samp> type. For simplicity, we’re
    assuming the signals are all 4 bits wide, but the conversion will work for any
    bit width:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: For these conversions, all we need to do is call the <samp class="SANS_TheSansMonoCd_W5Regular_11">to_integer()</samp>
    function from the <samp class="SANS_TheSansMonoCd_W5Regular_11">numeric_std</samp>
    package. We already know the width and the sign of the input, so the output will
    be sized automatically. This works whether the input is unsigned (as with <samp
    class="SANS_TheSansMonoCd_W5Regular_11">in1</samp>) or signed (as with <samp class="SANS_TheSansMonoCd_W5Regular_11">in2</samp>).
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">From Integer to Unsigned,
    Signed, or std_logic_vector</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'This example shows how to convert from the <samp class="SANS_TheSansMonoCd_W5Regular_11">integer</samp>
    type to one of the other types. Again, we’re assuming 4-bit signals:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Here we use the <samp class="SANS_TheSansMonoCd_W5Regular_11">to_unsigned()</samp>
    ❶ and <samp class="SANS_TheSansMonoCd_W5Regular_11">to_signed()</samp> ❷ functions
    from <samp class="SANS_TheSansMonoCd_W5Regular_11">numeric_std</samp> to convert
    from the <samp class="SANS_TheSansMonoCd_W5Regular_11">integer</samp> to the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">unsigned</samp> or <samp class="SANS_TheSansMonoCd_W5Regular_11">signed</samp>
    type. In addition to the value to be converted, these functions require the width
    of the output signal as an argument. Rather than entering the width manually,
    we get it by applying <samp class="SANS_TheSansMonoCd_W5Regular_11">'length</samp>,
    a VHDL attribute, to the output signal. This keeps the code flexible; if the width
    changes, the conversion code doesn’t have to.
  prefs: []
  type: TYPE_NORMAL
- en: To get to <samp class="SANS_TheSansMonoCd_W5Regular_11">std_logic_vector</samp>,
    we have to convert from <samp class="SANS_TheSansMonoCd_W5Regular_11">integer</samp>
    to <samp class="SANS_TheSansMonoCd_W5Regular_11">unsigned</samp> if the integer
    is positive ❸, or to <samp class="SANS_TheSansMonoCd_W5Regular_11">signed</samp>
    if the integer is negative ❹. Then, once we have an unsigned or signed value of
    the proper width, we cast it using <samp class="SANS_TheSansMonoCd_W5Regular_11">std_logic_vector()</samp>.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">From std_logic_vector to Unsigned,
    Signed, or Integer</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Finally, here’s how to convert from the <samp class="SANS_TheSansMonoCd_W5Regular_11">std_logic_vector</samp>
    type to one of the other numeric types:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: To get to <samp class="SANS_TheSansMonoCd_W5Regular_11">unsigned</samp> ❶ or
    <samp class="SANS_TheSansMonoCd_W5Regular_11">signed</samp> ❷, we use a simple
    cast. However, VHDL needs to know if the <samp class="SANS_TheSansMonoCd_W5Regular_11">std_logic_vector</samp>
    is unsigned or signed before converting to the <samp class="SANS_TheSansMonoCd_W5Regular_11">integer</samp>
    type. We perform the appropriate cast using <samp class="SANS_TheSansMonoCd_W5Regular_11">unsigned()</samp>
    ❸ or <samp class="SANS_TheSansMonoCd_W5Regular_11">signed()</samp> ❹, then call
    the <samp class="SANS_TheSansMonoCd_W5Regular_11">to_integer()</samp> function
    to do the final conversion.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Performing Mathematical Operations</samp>
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now we’ll consider how basic addition, subtraction, multiplication, and division
    operations are performed within an FPGA, and how to implement them in Verilog
    and VHDL. I’ll suggest some rules that, if followed, will help you avoid many
    of the commit pitfalls when working with binary math. The best way to explore
    these concepts is through examples. To that end, we’ll create a large testbench
    that you can run in a simulator tool like EDA Playground. The testbench will execute
    dozens of different math equations, illustrating how binary math operations should
    be carried out and how they can go awry.
  prefs: []
  type: TYPE_NORMAL
- en: In general, when working with numbers and manipulating them with algebraic operations,
    testbenches are a very powerful tool. Hidden math issues in your code can manifest
    themselves in strange ways. Testbenches allow you to stress your design by running
    through a large range of possible inputs, to see how the code works. I find it
    valuable to inject data into my testbenches that stress the math operations over
    a wide range of values, including minimum and maximum inputs. This helps ensure
    a design is robust.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we do any math, let’s set up our testbench, called <samp class="SANS_TheSansMonoCd_W5Regular_11">Math_Examples</samp>,
    by declaring all the necessary inputs and outputs, as well as some helper functions
    in the VHDL version. This setup code provides the skeleton for the examples that
    follow throughout the rest of the chapter. The code for each example will go where
    the <samp class="SANS_TheSansMonoCd_W5Regular_11">--</samp> <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">snip</samp><samp
    class="SANS_TheSansMonoCd_W5Regular_11">--</samp> is shown in the setup code:'
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Oblique_BI_11">Verilog</samp>
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: <samp class="SANS_Futura_Std_Bold_Oblique_BI_11">VHDL</samp>
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'The skeleton for this testbench sets up a single <samp class="SANS_TheSansMonoCd_W5Regular_11">initial</samp>
    (in Verilog) or <samp class="SANS_TheSansMonoCd_W5Regular_11">process</samp> (in
    VHDL) block that runs once through. We’ll fill in this block with examples later
    in the chapter. Notice that we’ve declared a number of signals using <samp class="SANS_TheSansMonoCd_W5Regular_11">reg</samp>
    (in Verilog) and <samp class="SANS_TheSansMonoCd_W5Regular_11">variable</samp>
    (in VHDL). This is the first time we’ve seen the <samp class="SANS_TheSansMonoCd_W5Regular_11">variable</samp>
    keyword in VHDL: we need it so we can write blocking assignment statements in
    the testbench. See “Blocking vs. Non-Blocking Assignments” on page 214 for more
    information.'
  prefs: []
  type: TYPE_NORMAL
- en: The examples in this chapter use a common naming scheme to quickly identify
    the data types and widths of the signals so you don’t have to keep looking back
    at the signal definitions. The prefix <samp class="SANS_TheSansMonoCd_W5Regular_11">i</samp>
    indicates an input to a math equation, while <samp class="SANS_TheSansMonoCd_W5Regular_11">o</samp>
    indicates an output, the result of the math equation. In addition, we have the
    suffixes <samp class="SANS_TheSansMonoCd_W5Regular_11">_u</samp><samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">N</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">_s</samp><samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">N</samp>,
    where <samp class="SANS_TheSansMonoCd_W5Regular_11">u</samp> represents unsigned,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">s</samp> represents signed, and
    <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">N</samp> represents the
    bit width of the signal. For example, <samp class="SANS_TheSansMonoCd_W5Regular_11">o_s4</samp>
    is a 4-bit-wide signed output. Establishing a scheme like this that makes it easier
    to remember data types and widths can be very helpful in your code, especially
    if there are many values in a single file.
  prefs: []
  type: TYPE_NORMAL
- en: Notice in the VHDL that we declare a custom function, <samp class="SANS_TheSansMonoCd_W5Regular_11">str()</samp>,
    to help convert the outputs of our equations to strings for printing. This will
    save us a lot of typing in the examples later on. We actually define the function
    in three different ways, depending on the data type involved—because VHDL is strongly
    typed, we need to define all the supported function inputs so that the compiler
    knows which one to use. The first definition ❶ converts an <samp class="SANS_TheSansMonoCd_W5Regular_11">unsigned</samp>
    value, the second ❷ converts a <samp class="SANS_TheSansMonoCd_W5Regular_11">signed</samp>
    value, and the third ❸ converts a <samp class="SANS_TheSansMonoCd_W5Regular_11">real</samp>
    value. This is an example of function *overloading*, a programming technique where
    a single function can have multiple implementations. Overloading is a somewhat
    advanced VHDL concept, but it’s very useful. You can even overload normal VHDL
    operators like <samp class="SANS_TheSansMonoCd_W5Regular_11">+</samp> and <samp
    class="SANS_TheSansMonoCd_W5Regular_11">–</samp> with any implementation that
    you need, though I don’t recommend doing so.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have our testbench set up, we’re ready to start exploring math operations.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Addition</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Adding binary data works the same way you were taught to add numbers in elementary
    school: you add them one digit at a time, working from right to left. For example,
    here’s how to add the binary numbers <samp class="SANS_TheSansMonoCd_W5Regular_11">0010</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">1000</samp>:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: To arrive at the result, you simply go digit by digit, starting with the least
    significant bit, adding the digits in that column together. If you get 1 + 1 =
    10 in a column, then you write 0 at the bottom of the column and carry the 1 to
    the next digit to the left.
  prefs: []
  type: TYPE_NORMAL
- en: 'Notice that the result of adding two 4-bit numbers together is 5 bits wide.
    This is our first rule of FPGA math:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Rule #1** When adding, the result should be at least 1 bit bigger than the
    biggest input.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The extra bit is needed in the case where adding the most significant bit requires
    a carry operation. Without the extra bit, we’d be truncating the result, which
    could produce an incorrect answer. In our first example, dropping the most significant
    bit wouldn’t make a difference, but consider this example where having that extra
    bit is critical:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Here, the most significant bit of the result is a 1\. Had we just assumed that
    the output width would be the same as the input widths, then we would have dropped
    this bit and gotten the wrong answer. Our result would have been <samp class="SANS_TheSansMonoCd_W5Regular_11">0100</samp>
    instead of <samp class="SANS_TheSansMonoCd_W5Regular_11">10100</samp>.
  prefs: []
  type: TYPE_NORMAL
- en: 'Perhaps you’ve noticed that I haven’t explicitly said what these binary numbers
    represent yet, and whether they’re positive or negative. For example, is <samp
    class="SANS_TheSansMonoCd_W5Regular_11">1001</samp> unsigned and equal to 9, or
    is it signed and equal to the two’s complement of 9, which is –7 (invert the bits
    to get <samp class="SANS_TheSansMonoCd_W5Regular_11">0110</samp>, then add 1 to
    get <samp class="SANS_TheSansMonoCd_W5Regular_11">0111</samp>)? The reason I haven’t
    specified this is because the representation of the binary data ultimately doesn’t
    affect how the math is performed, as long as the inputs and outputs are sized
    appropriately. Whether <samp class="SANS_TheSansMonoCd_W5Regular_11">1001</samp>
    represents +9 or –7, the addition operation will be performed the same way. Of
    course, we care if the result is positive or negative, but the implementation
    of the addition doesn’t change depending on whether the data types are signed
    or unsigned. Let’s revisit our first example and consider what happens when we
    assign it various signed and unsigned combinations. Here’s the example again:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: If both addition inputs are declared as unsigned types, then we have 2 + 8 =
    10\. Pretty simple. If both addition inputs are declared as signed, then the first
    input is still 2, but the second input is –8\. (Invert the bits to get <samp class="SANS_TheSansMonoCd_W5Regular_11">0111</samp>,
    add 1 to get <samp class="SANS_TheSansMonoCd_W5Regular_11">1000</samp>, and apply
    the negative sign to get –8.) So now we have 2 + –8, which should equal –6, but
    the result, <samp class="SANS_TheSansMonoCd_W5Regular_11">01010</samp>, is still
    10\. Something isn’t right here!
  prefs: []
  type: TYPE_NORMAL
- en: 'The problem is that we’re not performing sign extension on the inputs. *Sign
    extension* is the operation of increasing the number of bits of a binary number
    while preserving the number’s sign and value. This operation is required when
    the inputs are signed. Without it, we’ll get an incorrect answer, as you’ve just
    seen. To perform sign extension on a signed value, simply replicate the most significant
    bit. For example, <samp class="SANS_TheSansMonoCd_W5Regular_11">1000</samp> becomes
    <samp class="SANS_TheSansMonoCd_W5Regular_11">11000</samp>, and <samp class="SANS_TheSansMonoCd_W5Regular_11">0010</samp>
    becomes <samp class="SANS_TheSansMonoCd_W5Regular_11">00010</samp>. Let’s try
    that math again, this time first applying sign extension to our inputs:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Our inputs are still 2 and –8\. (For the latter, invert the bits of <samp class="SANS_TheSansMonoCd_W5Regular_11">11000</samp>
    to get <samp class="SANS_TheSansMonoCd_W5Regular_11">00111</samp>, add 1 to get
    <samp class="SANS_TheSansMonoCd_W5Regular_11">01000</samp>, and apply the negative
    sign to get –8.) The answer, <samp class="SANS_TheSansMonoCd_W5Regular_11">11010</samp>,
    is the signed equivalent of –6, which is exactly what we want. Sign extension
    was the critical step to ensure we got the expected answer.
  prefs: []
  type: TYPE_NORMAL
- en: 'Sign extension is useful for unsigned values, too. In fact, since VHDL is strongly
    typed, the inputs and outputs to an addition operation must all have exactly the
    same width. You can’t, for example, add two 4-bit inputs to produce a 5-bit output;
    everything must be 5 bits. That means we should revisit Rule #1 and add a small
    modification:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Rule #1 (modification #1)** When adding, the result should be at least 1
    bit bigger than the biggest input, *before sign extension*. Once sign extension
    is applied, the input and output widths should match exactly.'
  prefs: []
  type: TYPE_NORMAL
- en: For unsigned values, sign extension simply means adding a 0 as the new most
    significant bit. For example, unsigned <samp class="SANS_TheSansMonoCd_W5Regular_11">1000</samp>
    becomes <samp class="SANS_TheSansMonoCd_W5Regular_11">01000</samp>. The good news
    for those of you using Verilog is that the code performs sign extension automatically
    when you’re adding numbers. If you’re using VHDL, however, you’ll need to sign-extend
    your inputs manually using the <samp class="SANS_TheSansMonoCd_W5Regular_11">resize()</samp>
    function, as you’ll see in the coming examples. Both approaches have their pros
    and cons. Verilog is easier if you know what you’re doing, as there’s less to
    worry about, but it also leaves more room for mistakes (for example, trying to
    store data in too small a signal). VHDL’s extra steps can be more confusing for
    beginners, and it generates cryptic errors when the rules aren’t followed. On
    the other hand, VHDL ensures that you’ve matched widths and types every step along
    the way, so there’s less room for error in the end.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s summarize what we’ve learned with a few code examples. Add this code
    to your testbench where you saw the <samp class="SANS_TheSansMonoCd_W5Regular_11">--</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">snip</samp><samp class="SANS_TheSansMonoCd_W5Regular_11">--</samp>
    earlier:'
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Oblique_BI_11">Verilog</samp>
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: <samp class="SANS_Futura_Std_Bold_Oblique_BI_11">VHDL</samp>
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Here’s the output:'
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Oblique_BI_11">Verilog</samp>
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: <samp class="SANS_Futura_Std_Bold_Oblique_BI_11">VHDL</samp>
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'First, we have two situations (<samp class="SANS_TheSansMonoCd_W5Regular_11">Ex01</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">Ex02</samp>) where Rule #1 isn’t
    followed. We’re using 4-bit inputs and storing the result in a 4-bit output, and
    we’re not performing any sign extension. In both of these examples, we get the
    wrong answer. In <samp class="SANS_TheSansMonoCd_W5Regular_11">Ex01</samp>, we
    add two unsigned numbers, 9 and 11, but get 4 as a result. The problem here is
    that we’re dropping the most significant bit, which would be worth 16\. (Indeed,
    4 + 16 = 20, which is the answer we should be getting.) In <samp class="SANS_TheSansMonoCd_W5Regular_11">Ex02</samp>,
    we add two signed numbers representing negative values, and again we get the wrong
    answer.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The fix is to store the result in a 5-bit output, which we do in both <samp
    class="SANS_TheSansMonoCd_W5Regular_11">Ex03</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">Ex04</samp>.
    We’ve satisfied Rule #1, so the math works correctly. Notice that in the Verilog
    version, the sign extension happens automatically: we can simply assign 4-bit
    inputs to a 5-bit output, for example by writing <samp class="SANS_TheSansMonoCd_W5Regular_11">o_u5</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">=</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">i1_u4</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">+</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">i2_u4;</samp>.
    In VHDL, however, we must explicitly match input and output widths, while preserving
    the sign and value of each input. To do this, we call the <samp class="SANS_TheSansMonoCd_W5Regular_11">resize()</samp>
    function ❶. We use the VHDL tick attribute <samp class="SANS_TheSansMonoCd_W5Regular_11">''length</samp>
    to reference the length of the output signal, as we did when we were performing
    type conversions. Again, this is more flexible than hardcoding the desired width
    by writing something like <samp class="SANS_TheSansMonoCd_W5Regular_11">resize(i1_u4,
    5)</samp>.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Another tip for performing successful addition operations is to never mix signed
    and unsigned values. Your inputs and outputs should be of the same type; otherwise
    you might get an incorrect answer. This brings us to our second rule of FPGA math:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Rule #2** Match types among inputs and outputs.'
  prefs: []
  type: TYPE_NORMAL
- en: 'With VHDL, it’s easy to follow Rule #2 because it will throw an error if you
    try to do a math operation where one input is signed and the other is unsigned.
    For example, say you write this in your testbench to try to add a 4-bit unsigned
    value (<samp class="SANS_TheSansMonoCd_W5Regular_11">i1_u4</samp>) to a 4-bit
    signed value (<samp class="SANS_TheSansMonoCd_W5Regular_11">i2_s4</samp>):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'You’ll end up with an error message indicating the tool doesn’t know how to
    interpret the <samp class="SANS_TheSansMonoCd_W5Regular_11">+</samp> operator
    given those inputs:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Verilog is much more lenient. It will happily let you perform that math operation,
    and it won’t tell you that it’s actually treating your signed input as unsigned.
    This can very possibly result in the wrong answer, so be careful to always match
    your data types in Verilog.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Subtraction</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Subtraction isn’t that different from addition. After all, subtraction is just
    an addition operation where one of the inputs is negative. In this sense, we’ve
    been doing subtraction all along; 2 + –8 is the same as 2 – 8\. Likewise, you
    can think of something like 5 – 3 as 5 + –3 and approach it like an addition operation.
  prefs: []
  type: TYPE_NORMAL
- en: 'There’s one thing to be careful with when subtracting two numbers, though:
    while you *could* use subtraction with unsigned inputs and outputs, I wouldn’t
    recommend it. What happens if the result should be negative? For example, 3 –
    5 = –2, but if you try to store –2 into an unsigned data type, you won’t get the
    correct result. This brings us to our next rule:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Rule #3** When subtracting, use signed inputs and outputs.'
  prefs: []
  type: TYPE_NORMAL
- en: Even if you don’t think the result of a subtraction will produce a negative
    number, you should use signed data types to be safe.
  prefs: []
  type: TYPE_NORMAL
- en: 'Because subtraction is really just negative addition, subtraction carries the
    same risk that you could truncate the result if the output isn’t sized appropriately.
    Again, it’s better to size up the output by 1 bit and to sign-extend your inputs
    before performing the math operation. This gives us a further modified Rule #1:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Rule #1 (modification #2)** When adding *or subtracting*, the result should
    be at least 1 bit bigger than the biggest input, before sign extension. Once sign
    extension is applied, the input and output widths should match exactly.'
  prefs: []
  type: TYPE_NORMAL
- en: 'With those two rules in place, let’s extend our <samp class="SANS_TheSansMonoCd_W5Regular_11">Math_Examples</samp>
    testbench to take a look at some subtraction operations in Verilog and VHDL:'
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Oblique_BI_11">Verilog</samp>
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: <samp class="SANS_Futura_Std_Bold_Oblique_BI_11">VHDL</samp>
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Here’s the output:'
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Oblique_BI_11">Verilog</samp>
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: <samp class="SANS_Futura_Std_Bold_Oblique_BI_11">VHDL</samp>
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'In <samp class="SANS_TheSansMonoCd_W5Regular_11">Ex05</samp>, we’re trying
    to calculate 9 – 11 but we get a result of 30, clearly the wrong answer. The problem
    here is that we’re using unsigned types for subtraction, which is a violation
    of Rule #3\. We fix this in <samp class="SANS_TheSansMonoCd_W5Regular_11">Ex06</samp>
    by converting the input values from unsigned to signed data types. We also perform
    sign extension in the process, going from 4-bit inputs to 5-bit inputs. In the
    Verilog code, we handle the conversion by simply assigning the 4-bit unsigned
    signals to 5-bit signed signals ❶. Verilog takes care of the details automatically.
    VHDL makes us jump through a few more hoops. We first resize the input, which
    will sign-extend it, but the result of the resize operation is still an unsigned
    type, so we then explicitly cast it to a signed data type using <samp class="SANS_TheSansMonoCd_W5Regular_11">signed()</samp>
    ❷. This is safe to do because we’ve already resized the signal, so the most significant
    bit will be 0\. Therefore, the value after converting to a signed type won’t be
    changed.'
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Multiplication</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Multiplication also works similarly to addition; after all, a multiplication
    operation is just a series of repeated addition operations (4 × 3 = 4 + 4 + 4).
    The first thing to consider when multiplying two inputs together is how to properly
    size the output bit width. This brings us to our next rule:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Rule #4** When multiplying, the output bit width must be at least the sum
    of the input bit widths (before sign extension).'
  prefs: []
  type: TYPE_NORMAL
- en: 'This rule holds true for both signed and unsigned numbers. For example, say
    we’re trying to multiply the unsigned inputs <samp class="SANS_TheSansMonoCd_W5Regular_11">111</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">11</samp> (equivalent to 7 ×
    3). According to Rule #4, the output should be 3 + 2 = 5 bits wide. You can try
    out the multiplication yourself to confirm this, using the same technique you
    learned in school for multiplying multidigit numbers—multiply each digit individually
    and add the results together:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: The output, <samp class="SANS_TheSansMonoCd_W5Regular_11">10101</samp> (equivalent
    to 21), is indeed 5 bits wide, which is what we expected. But what happens to
    this same multiplication if we treat our inputs and outputs as signed, rather
    than unsigned? In this case, we would have the equivalent of –1 × –1 in decimal,
    which should produce a result of +1, but signed <samp class="SANS_TheSansMonoCd_W5Regular_11">10101</samp>
    in binary is equal to –11 in decimal. What’s wrong here?
  prefs: []
  type: TYPE_NORMAL
- en: 'The problem is that we didn’t sign-extend our inputs to match the width of
    our output (5 bits) before multiplying. If we do that, our inputs both become
    <samp class="SANS_TheSansMonoCd_W5Regular_11">11111</samp>, and the multiplication
    looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Now we’re getting <samp class="SANS_TheSansMonoCd_W5Regular_11">00000001</samp>,
    or really <samp class="SANS_TheSansMonoCd_W5Regular_11">00001</samp> once we truncate
    the result to be 5 bits wide, which is +1 in decimal. Sign extension gives us
    the result we expect. Unlike with addition and subtraction, however, you don’t
    actually need to perform this sign extension manually when multiplying numbers
    using Verilog or VHDL. The tools will handle this automatically; you simply need
    to size the output signal correctly.
  prefs: []
  type: TYPE_NORMAL
- en: 'VHDL helps with this too: it won’t even let you compile the code if you disobey
    Rule #4 and fail to size the output of a multiplication correctly. With Verilog,
    you’ll need to be more careful. It won’t warn you if the output is the wrong size,
    and you could get an unexpected result. Let’s add some examples of this to our
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Math_Examples</samp> testbench:'
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Oblique_BI_11">Verilog</samp>
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: <samp class="SANS_Futura_Std_Bold_Oblique_BI_11">VHDL</samp>
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Here’s the output:'
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Oblique_BI_11">Verilog</samp>
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: <samp class="SANS_Futura_Std_Bold_Oblique_BI_11">VHDL</samp>
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Verilog allows us to perform the math operation despite the fact that we’re
    disobeying Rule #4 by multiplying 4 bits by 4 bits and storing the result in a
    4-bit output. This produces incorrect results for both unsigned (<samp class="SANS_TheSansMonoCd_W5Regular_11">Ex07</samp>)
    and signed (<samp class="SANS_TheSansMonoCd_W5Regular_11">Ex08</samp>) input values.
    VHDL, on the other hand, won’t even build this code; we get a nice descriptive
    error telling us that the tool is trying to assign an 8-bit-wide result to a 4-bit-wide
    variable, which isn’t permitted. Let’s add a few more examples to our testbench
    that fix these issues:'
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Oblique_BI_11">Verilog</samp>
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: <samp class="SANS_Futura_Std_Bold_Oblique_BI_11">VHDL</samp>
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Here’s the output:'
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Oblique_BI_11">Verilog</samp>
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: <samp class="SANS_Futura_Std_Bold_Oblique_BI_11">VHDL</samp>
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: In <samp class="SANS_TheSansMonoCd_W5Regular_11">Ex09</samp>, we correct the
    problem in <samp class="SANS_TheSansMonoCd_W5Regular_11">Ex07</samp> by storing
    the output of multiplying two unsigned 4-bit values into an 8-bit signal. Similarly,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Ex10</samp> corrects the issue from
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Ex08</samp> with signed values.
    Notice that we never have to sign-extend the inputs, in either Verilog or VHDL.
    The tools handle this automatically.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Multiplication by
    Powers of 2</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'There’s a trick that we can use when multiplying numbers by a power of 2 (for
    example, 2, 4, 8, 16, 32, …). Rather than instantiating a bunch of multiplication
    logic, we can simply instantiate a shift register and perform a shift left operation.
    Shifting left by *N* bits is equivalent to multiplying by 2*^N*. For example,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">0011</samp> (3 in binary) shifted
    left 2 bits gives us <samp class="SANS_TheSansMonoCd_W5Regular_11">1100</samp>
    (12 in binary). It’s the same as calculating 3 × 4, or 3 × 2². This trick works
    for both signed and unsigned numbers. Let’s try it out in our testbench:'
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Oblique_BI_11">Verilog</samp>
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: <samp class="SANS_Futura_Std_Bold_Oblique_BI_11">VHDL</samp>
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Here’s the output:'
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Oblique_BI_11">Verilog</samp>
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: <samp class="SANS_Futura_Std_Bold_Oblique_BI_11">VHDL</samp>
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: We start with the decimal value 3 and shift left by 1, 2, and 4 bits to multiply
    it by 2, 4, and 16, respectively. In Verilog we perform the shift using the <samp
    class="SANS_TheSansMonoCd_W5Regular_11"><<</samp> operator, and in VHDL we use
    the function <samp class="SANS_TheSansMonoCd_W5Regular_11">shift_left()</samp>.
    Both take as an argument the number of bit positions to shift.
  prefs: []
  type: TYPE_NORMAL
- en: Shifting left is a simple and quick trick to save FPGA resources, but you don’t
    necessarily need to write it out explicitly. It’s likely that if you hardcode
    a multiplication by a power of 2, the synthesis tools will be smart enough to
    figure out that a left shift would take fewer resources.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Division</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Unfortunately, division isn’t nearly as simple an operation as addition, subtraction,
    or multiplication. Division comes with all sorts of messy complications, like
    remainders and fractions. In general, it’s a good idea to avoid division inside
    your FPGA if you can. It’s a resource-intensive operation, especially if you need
    that operation to run at high clock rates.
  prefs: []
  type: TYPE_NORMAL
- en: I once worked on a project that needed to add a division operation to an FPGA
    in the field. The FPGA was a very old part, and it simply couldn’t fit it within
    the available resources. To accommodate the division operation we ended up having
    to upgrade to a higher-resource FPGA of the same family, which increased the cost
    of the hardware by over $1 million. I always think of that one extra operation
    as the million-dollar divide!
  prefs: []
  type: TYPE_NORMAL
- en: If you *must* divide numbers, there are a few ways to make the operation less
    resource-intensive. These include restricting yourself to dividing by powers of
    2, using a precalculated table of answers, or breaking up the operation across
    multiple clock cycles.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Using Powers of 2</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'My best suggestion for reducing the overhead of dividing numbers inside an
    FPGA is to make the divisor a power of 2\. Similar to how multiplication by a
    power of 2 can be efficiently performed with a shift left operation, division
    by a power of 2 can be performed efficiently with a shift right operation. Shifting
    right by *N* bits is equivalent to dividing by 2*^N*. Let’s look at a few examples
    of this:'
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Oblique_BI_11">Verilog</samp>
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: <samp class="SANS_Futura_Std_Bold_Oblique_BI_11">VHDL</samp>
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Here’s the output:'
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Oblique_BI_11">Verilog</samp>
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: <samp class="SANS_Futura_Std_Bold_Oblique_BI_11">VHDL</samp>
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">Ex14</samp> performs a shift right
    by 1, which in Verilog uses the <samp class="SANS_TheSansMonoCd_W5Regular_11">>></samp>
    operator and in VHDL uses the <samp class="SANS_TheSansMonoCd_W5Regular_11">shift_right()</samp>
    function. This accomplishes a single divide by 2\. To divide by 4, shift right
    by 2 bit positions, as in <samp class="SANS_TheSansMonoCd_W5Regular_11">Ex15</samp>.
    Likewise, a right shift by 4 divides by 16, as in <samp class="SANS_TheSansMonoCd_W5Regular_11">Ex16</samp>.
  prefs: []
  type: TYPE_NORMAL
- en: 'What happens when we don’t have a number that’s cleanly divisible by the power
    of 2 serving as the divisor? In this case, shifting right effectively accomplishes
    a division that’s rounded down to the nearest integer. The next few examples illustrate
    how this works:'
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Oblique_BI_11">Verilog</samp>
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: <samp class="SANS_Futura_Std_Bold_Oblique_BI_11">VHDL</samp>
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'Here’s the output:'
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Oblique_BI_11">Verilog</samp>
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: <samp class="SANS_Futura_Std_Bold_Oblique_BI_11">VHDL</samp>
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: In <samp class="SANS_TheSansMonoCd_W5Regular_11">Ex17</samp>, we try to perform
    15 / 2\. This should give us 7.5, but we have no way to represent the .5 part,
    so we end up rounding down to 7 instead. Thinking of this as a shift right, we
    went from <samp class="SANS_TheSansMonoCd_W5Regular_11">00001111</samp> to <samp
    class="SANS_TheSansMonoCd_W5Regular_11">00000111</samp>. In <samp class="SANS_TheSansMonoCd_W5Regular_11">Ex18</samp>,
    we try to take 15 / 4, which should be 3.75, but we drop the decimal places and
    just get 3\. Finally, in <samp class="SANS_TheSansMonoCd_W5Regular_11">Ex19</samp>
    we get 15 / 8 = 1\. This rounding might cause a problem if you’re not expecting
    it, so be aware that this can happen when performing shift right operations.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Using a Precalculated Table</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Another option for dividing two numbers is to precalculate the result for all
    possible input combinations. For example, if we’re trying to divide any number
    1 through 7 by any other number 1 through 7, we could create something like [Table
    10-3](#tab10-3) inside the FPGA.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Heavy_B_11">Table 10-3:</samp> <samp class="SANS_Futura_Std_Book_11">Precalculated
    Table for Full Range of Division Inputs</samp>
  prefs: []
  type: TYPE_NORMAL
- en: '|  | <samp class="SANS_Futura_Std_Heavy_B_11">1</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">2</samp>
    | <samp class="SANS_Futura_Std_Heavy_B_11">3</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">4</samp>
    | <samp class="SANS_Futura_Std_Heavy_B_11">5</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">6</samp>
    | <samp class="SANS_Futura_Std_Heavy_B_11">7</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- | --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">1</samp> | <samp class="SANS_Futura_Std_Book_11">1.00</samp>
    | <samp class="SANS_Futura_Std_Book_11">0.50</samp> | <samp class="SANS_Futura_Std_Book_11">0.33</samp>
    | <samp class="SANS_Futura_Std_Book_11">0.25</samp> | <samp class="SANS_Futura_Std_Book_11">0.20</samp>
    | <samp class="SANS_Futura_Std_Book_11">0.17</samp> | <samp class="SANS_Futura_Std_Book_11">0.14</samp>
    |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">2</samp> | <samp class="SANS_Futura_Std_Book_11">2.00</samp>
    | <samp class="SANS_Futura_Std_Book_11">1.00</samp> | <samp class="SANS_Futura_Std_Book_11">0.67</samp>
    | <samp class="SANS_Futura_Std_Book_11">0.50</samp> | <samp class="SANS_Futura_Std_Book_11">0.40</samp>
    | <samp class="SANS_Futura_Std_Book_11">0.33</samp> | <samp class="SANS_Futura_Std_Book_11">0.29</samp>
    |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">3</samp> | <samp class="SANS_Futura_Std_Book_11">3.00</samp>
    | <samp class="SANS_Futura_Std_Book_11">1.50</samp> | <samp class="SANS_Futura_Std_Book_11">1.00</samp>
    | <samp class="SANS_Futura_Std_Book_11">0.75</samp> | <samp class="SANS_Futura_Std_Book_11">0.60</samp>
    | <samp class="SANS_Futura_Std_Book_11">0.50</samp> | <samp class="SANS_Futura_Std_Book_11">0.43</samp>
    |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">4</samp> | <samp class="SANS_Futura_Std_Book_11">4.00</samp>
    | <samp class="SANS_Futura_Std_Book_11">2.00</samp> | <samp class="SANS_Futura_Std_Book_11">1.33</samp>
    | <samp class="SANS_Futura_Std_Book_11">1.00</samp> | <samp class="SANS_Futura_Std_Book_11">0.80</samp>
    | <samp class="SANS_Futura_Std_Book_11">0.67</samp> | <samp class="SANS_Futura_Std_Book_11">0.57</samp>
    |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">5</samp> | <samp class="SANS_Futura_Std_Book_11">5.00</samp>
    | <samp class="SANS_Futura_Std_Book_11">2.50</samp> | <samp class="SANS_Futura_Std_Book_11">1.67</samp>
    | <samp class="SANS_Futura_Std_Book_11">1.25</samp> | <samp class="SANS_Futura_Std_Book_11">1.00</samp>
    | <samp class="SANS_Futura_Std_Book_11">0.83</samp> | <samp class="SANS_Futura_Std_Book_11">0.71</samp>
    |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">6</samp> | <samp class="SANS_Futura_Std_Book_11">6.00</samp>
    | <samp class="SANS_Futura_Std_Book_11">3.00</samp> | <samp class="SANS_Futura_Std_Book_11">2.00</samp>
    | <samp class="SANS_Futura_Std_Book_11">1.50</samp> | <samp class="SANS_Futura_Std_Book_11">1.20</samp>
    | <samp class="SANS_Futura_Std_Book_11">1.00</samp> | <samp class="SANS_Futura_Std_Book_11">0.86</samp>
    |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">7</samp> | <samp class="SANS_Futura_Std_Book_11">7.00</samp>
    | <samp class="SANS_Futura_Std_Book_11">3.50</samp> | <samp class="SANS_Futura_Std_Book_11">2.33</samp>
    | <samp class="SANS_Futura_Std_Book_11">1.75</samp> | <samp class="SANS_Futura_Std_Book_11">1.40</samp>
    | <samp class="SANS_Futura_Std_Book_11">1.17</samp> | <samp class="SANS_Futura_Std_Book_11">1.00</samp>
    |'
  prefs: []
  type: TYPE_TB
- en: For this example, let’s assume that each row represents a possible dividend,
    and each column represents a possible divisor. The value at the intersection of
    a given dividend and divisor is the corresponding quotient. As an example, to
    find the value in decimal for the fraction 5/6, go to row 5, then over to column
    6 to get the value 0.83\. To implement this in Verilog or VHDL, we could store
    this two-dimensional table in a 2D array. (You saw how 2D arrays work in the state
    machine project in [Chapter 8](chapter8.xhtml).) The row input values provide
    one index, the column input values provide the second index, and the quotient
    is the value at those two indices. We’re not actually performing any math here;
    we’re just indexing into the correct result, which has been precalculated and
    stored in memory.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Dogma_OT_Bold_B_21">NOTE</samp>
  prefs: []
  type: TYPE_NORMAL
- en: '*If you’re wondering how to represent decimal values like 0.50 and 0.33 inside
    an FPGA, good question! We’ll explore this topic shortly.*'
  prefs: []
  type: TYPE_NORMAL
- en: As the range of possible inputs grows, of course, we’ll need a larger and larger
    table to store the possible outputs. Eventually, a single table could take up
    an entire block RAM, which are often 16Kb in size. Using a precalculated table
    in a block RAM guarantees that a single division calculation will take a single
    clock cycle, since we only need one clock cycle to read from the memory (as you
    learned when we discussed RAM back in [Chapter 6](chapter6.xhtml)). However, we
    can’t read from multiple locations in the memory on the same clock cycle, so if
    we needed to do two divisions simultaneously, on the exact same clock cycle, we
    would need to instantiate a second copy of the precalculated table in another
    block RAM.
  prefs: []
  type: TYPE_NORMAL
- en: Block RAMs are usually valuable resources, so taking up a bunch of them for
    concurrent divisions doesn’t scale very well. If the design will allow us to run
    the different divisions in consecutive clock cycles, rather than simultaneously,
    we could instead use a single table and time-share it. Time sharing a single resource
    would require arbitration of that resource, as we discussed in [Chapter 7](chapter7.xhtml).
    We would have to create some arbiter that would only allow access to the block
    RAM table by one module at a time.
  prefs: []
  type: TYPE_NORMAL
- en: The solutions discussed up to this point assume we have just one clock cycle
    to get the result of a division operation. However, if we can wait multiple clock
    cycles for the result of a division operation, that allows us to use another option.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Using Multiple Clock Cycles</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Another way to ease the burden of the synthesis tools when it comes to division
    is to create an algorithm that performs division in more than a single clock cycle,
    using simpler math operations such as addition and subtraction. At its heart,
    division is about calculating how many times one number fits into another number.
    You can accomplish this, for example, by adding the divisor to itself over and
    over until you’ve passed the value of the dividend, while counting the number
    of times you had to run that loop. Then you subtract the dividend to get the remainder.
  prefs: []
  type: TYPE_NORMAL
- en: There are various other techniques for performing division using simpler math
    operations. (Specific implementations are beyond the scope of this book; search
    the web for *division algorithms on FPGAs* if you want to learn more.) But of
    course, these methods only work if you’re able to wait multiple clock cycles for
    the result. Using multiple clock cycles to produce a result is a bit different
    in this context than the pipelining example we discussed in [Chapter 7](chapter7.xhtml),
    where we broke up a complex math operation across multiple clock cycles to meet
    timing. In that case, we were still able to get a result every clock cycle, but
    the outputs were delayed a few clock cycles from the inputs.
  prefs: []
  type: TYPE_NORMAL
- en: In this case, we don’t know how many clock cycles the division algorithm will
    take to provide a result, so we can’t rely on a result each clock cycle. Ultimately,
    it’s a question of trading lower resource utilization for more clock cycles. If
    you really need to get the result of a division operation on every single clock
    cycle, you’ll have to use one of the previously discussed division techniques.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">How FPGAs Implement Math Operations</samp>
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: With all the operations we’ve discussed so far, we’ve only looked at how the
    math works, without really considering how the operations are implemented inside
    an FPGA. There are various FPGA components that may be involved, depending on
    the specific operation performed. If you take an introductory digital electronics
    course, you might learn about *half adders* and *full adders*, digital circuits
    that combine various logic gates (like XOR and AND) to perform addition operations.
    It’s a fascinating subject, but in the end you might be frustrated to find that
    you don’t need to know how these circuits work to be able to do math with modern
    FPGA code. You’ll never need to instantiate a full adder component by manually
    typing out all the necessary logic operations if you’re just adding two numbers
    together. Instead, you just use the <samp class="SANS_TheSansMonoCd_W5Regular_11">+</samp>
    operator in Verilog or VHDL, like you would in any other programming language,
    and trust the synthesis tools to handle the implementation.
  prefs: []
  type: TYPE_NORMAL
- en: The tools will likely place addition and subtraction operations into basic LUTs.
    For multiplication, the tools will use flip-flops for the shift left approach,
    or LUTs or DSP blocks (if available) for more complicated calculations. As discussed
    in [Chapter 9](chapter9.xhtml), DSP blocks are useful for accelerating large multiply–accumulate
    operations without utilizing a lot of LUT logic. Finally, division will require
    registers for the shift right approach, block RAMs for the precalculated table
    approach, or LUTs.
  prefs: []
  type: TYPE_NORMAL
- en: 'There’s more to math than just addition, subtraction, multiplication, and division,
    however. Look at your calculator and consider all the operations we haven’t discussed:
    sine, cosine, square root, and more. It’s certainly possible to run these operations
    on an FPGA, but it gets complicated and is beyond the scope of this book. If you’re
    interested in learning more, there are dedicated algorithms that you can instantiate
    for these, such as a Coordinate Rotation Digital Computer (CORDIC). Search GitHub
    for *FPGA CORDIC* and you’ll find many examples.'
  prefs: []
  type: TYPE_NORMAL
- en: In addition to actually implementing more complicated math operations on your
    FPGA, if you have the option it might be worth sending the inputs to a dedicated
    processor to perform the calculations, and then returning the result back to the
    FPGA logic. We’ll discuss floating- versus fixed-point arithmetic in the next
    section, but processors are much more capable of performing floating-point arithmetic
    than FPGAs. This processor can be a dedicated component external to the FPGA,
    or it can be internal to the FPGA itself. If it’s internal, it’s referred to as
    either a hard-core processor or a soft-core processor, depending on if it’s a
    dedicated piece of silicon or not.
  prefs: []
  type: TYPE_NORMAL
- en: Many modern FPGAs have internal hard ARM cores. This type of component with
    FPGA logic and a dedicated processor is often referred to as a *system on a chip
    (SoC)*. You can send the operations from the FPGA LUT/flip-flop logic into the
    ARM core for processing, and it will perform whatever operation is required and
    return the result. This solution is more about handling data than performing math,
    since you’ll likely need to set up FIFOs for each of the inputs and outputs. Working
    with a separate processor is an advanced topic, but it can be very valuable in
    higher-end applications.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Working with Decimals</samp>
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'So far we’ve been working with integers, but there are many applications where
    you’ll need your FPGA to operate on numbers with a decimal component. In this
    section, we’ll examine how to do math using non-integers. To begin with, we need
    to consider how fractional numbers are actually represented using binary digits.
    There are two possible systems to choose from: floating point and fixed point.'
  prefs: []
  type: TYPE_NORMAL
- en: The vast majority of mathematical operations within electronic devices use *floating-point*
    arithmetic, since most CPUs are designed to handle floating-point numbers. The
    key to floating point is that the *radix* (the decimal separator) “floats,” depending
    on how much precision is needed. We won’t go into detail about how exactly this
    works, but the bottom line is that with 32 bits you can represent an enormous
    range of values, with varying precision; you can represent very small numbers
    with high precision, or very large numbers with less precision. *Fixed-point*
    arithmetic, on the other hand, has a fixed radix, meaning there are a fixed number
    of integer places and a fixed number of decimal places.
  prefs: []
  type: TYPE_NORMAL
- en: FPGAs *can* perform floating-point operations, but they often require more resources
    than fixed-point operations. Most FPGA math is therefore done with fixed-point
    arithmetic, so that will be our focus for the rest of the chapter.
  prefs: []
  type: TYPE_NORMAL
- en: To illustrate how fixed-point representation works, let’s take an example. Say
    we have 3 bits allotted for representing a number inside our FPGA. We’ve been
    assuming up to this point that each bit change will be worth one integer value.
    For example, going from <samp class="SANS_TheSansMonoCd_W5Regular_11">001</samp>
    to <samp class="SANS_TheSansMonoCd_W5Regular_11">010</samp> means that we go from
    1 to 2\. But we’ve just arbitrarily decided that each bit is worth one integer.
    We could just as easily decide that a single bit is worth something else, for
    example 0.5\. In that case, <samp class="SANS_TheSansMonoCd_W5Regular_11">001</samp>
    would be equivalent to 0.5, <samp class="SANS_TheSansMonoCd_W5Regular_11">010</samp>
    would be 1.0, <samp class="SANS_TheSansMonoCd_W5Regular_11">011</samp> would be
    1.5, and so on. We now have a fixed-point system where the rightmost bit represents
    the decimal component of the number and the other two bits represent the integer
    component. We can also interpret the bits in other ways to give us different fixed-point
    representations. [Table 10-4](#tab10-4) shows the most common decimal interpretations
    of 3 unsigned bits.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Heavy_B_11">Table 10-4:</samp> <samp class="SANS_Futura_Std_Book_11">3-Bit
    Unsigned Fixed-Point Possibilities</samp>
  prefs: []
  type: TYPE_NORMAL
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">Bits</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">U3.0</samp>
    | <samp class="SANS_Futura_Std_Heavy_B_11">U2.1</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">U1.2</samp>
    | <samp class="SANS_Futura_Std_Heavy_B_11">U0.3</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">000</samp> | <samp class="SANS_Futura_Std_Book_11">0</samp>
    | <samp class="SANS_Futura_Std_Book_11">0</samp> | <samp class="SANS_Futura_Std_Book_11">0</samp>
    | <samp class="SANS_Futura_Std_Book_11">0</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">001</samp> | <samp class="SANS_Futura_Std_Book_11">1</samp>
    | <samp class="SANS_Futura_Std_Book_11">0.5</samp> | <samp class="SANS_Futura_Std_Book_11">0.25</samp>
    | <samp class="SANS_Futura_Std_Book_11">0.125</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">010</samp> | <samp class="SANS_Futura_Std_Book_11">2</samp>
    | <samp class="SANS_Futura_Std_Book_11">1.0</samp> | <samp class="SANS_Futura_Std_Book_11">0.50</samp>
    | <samp class="SANS_Futura_Std_Book_11">0.250</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">011</samp> | <samp class="SANS_Futura_Std_Book_11">3</samp>
    | <samp class="SANS_Futura_Std_Book_11">1.5</samp> | <samp class="SANS_Futura_Std_Book_11">0.75</samp>
    | <samp class="SANS_Futura_Std_Book_11">0.375</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">100</samp> | <samp class="SANS_Futura_Std_Book_11">4</samp>
    | <samp class="SANS_Futura_Std_Book_11">2.0</samp> | <samp class="SANS_Futura_Std_Book_11">1.00</samp>
    | <samp class="SANS_Futura_Std_Book_11">0.500</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">101</samp> | <samp class="SANS_Futura_Std_Book_11">5</samp>
    | <samp class="SANS_Futura_Std_Book_11">2.5</samp> | <samp class="SANS_Futura_Std_Book_11">1.25</samp>
    | <samp class="SANS_Futura_Std_Book_11">0.625</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">110</samp> | <samp class="SANS_Futura_Std_Book_11">6</samp>
    | <samp class="SANS_Futura_Std_Book_11">3.0</samp> | <samp class="SANS_Futura_Std_Book_11">1.50</samp>
    | <samp class="SANS_Futura_Std_Book_11">0.750</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">111</samp> | <samp class="SANS_Futura_Std_Book_11">7</samp>
    | <samp class="SANS_Futura_Std_Book_11">3.5</samp> | <samp class="SANS_Futura_Std_Book_11">1.75</samp>
    | <samp class="SANS_Futura_Std_Book_11">0.875</samp> |'
  prefs: []
  type: TYPE_TB
- en: The headings in [Table 10-4](#tab10-4) use a modified version of *Q notation*,
    which is a way to specify the parameters of a binary fixed-point number format.
    In Q notation, for example, Q1.2 indicates that 1 bit is being used for the integer
    portion of a number and 2 bits are being used for the fractional portion. Standard
    Q notation assumes the values are signed; however, in FPGAs it’s very common to
    have unsigned and signed values. That’s why I prefer a notation that specifies
    if the values are signed (S) or unsigned (U) using the leading character. Thus,
    S3.1 indicates a signed value with 3 integer bits and 1 fractional bit, and U4.8
    indicates an unsigned value with 4 integer bits and 8 fractional bits.
  prefs: []
  type: TYPE_NORMAL
- en: In [Table 10-4](#tab10-4), the U3.0 column is what we’re used to; all 3 bits
    are allotted to the integer portion of the number, so we only have whole numbers.
    Let’s consider the next column, U2.1\. It’s unsigned, with 2 bits for the integer
    component and 1 bit for the decimal component. This means the integer part can
    be in the range <samp class="SANS_TheSansMonoCd_W5Regular_11">00</samp>, <samp
    class="SANS_TheSansMonoCd_W5Regular_11">01</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">10</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">11</samp>, and the decimal part
    can be in the range <samp class="SANS_TheSansMonoCd_W5Regular_11">0</samp> or
    <samp class="SANS_TheSansMonoCd_W5Regular_11">1</samp>. To figure out what possible
    values that represents, simply take the original U3.0 value and divide it by 2\.
    For example, <samp class="SANS_TheSansMonoCd_W5Regular_11">111</samp> is 7 in
    U3.0, but in U2.1 it’s 3.5 (7 / 2 = 3.5). In general, when there are *N* bits
    allotted to the fractional portion of the number, you divide the integer representation
    by 2*^N* to determine the fixed-point value. Thus, <samp class="SANS_TheSansMonoCd_W5Regular_11">111</samp>
    in U0.3 is 7 / 2³ = 7 / 8 = 0.875.
  prefs: []
  type: TYPE_NORMAL
- en: In [Table 10-4](#tab10-4) we treated all the values as unsigned. [Table 10-5](#tab10-5)
    shows the most common possibilities for interpreting the same 3 bits when we use
    signed data types.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Heavy_B_11">Table 10-5:</samp> <samp class="SANS_Futura_Std_Book_11">3-Bit
    Signed Fixed-Point Possibilities</samp>
  prefs: []
  type: TYPE_NORMAL
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">Bits</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">S3.0</samp>
    | <samp class="SANS_Futura_Std_Heavy_B_11">S2.1</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">S1.2</samp>
    | <samp class="SANS_Futura_Std_Heavy_B_11">S0.3</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">000</samp> | <samp class="SANS_Futura_Std_Book_11">0</samp>
    | <samp class="SANS_Futura_Std_Book_11">0</samp> | <samp class="SANS_Futura_Std_Book_11">0</samp>
    | <samp class="SANS_Futura_Std_Book_11">0</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">001</samp> | <samp class="SANS_Futura_Std_Book_11">1</samp>
    | <samp class="SANS_Futura_Std_Book_11">0.5</samp> | <samp class="SANS_Futura_Std_Book_11">0.25</samp>
    | <samp class="SANS_Futura_Std_Book_11">0.125</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">010</samp> | <samp class="SANS_Futura_Std_Book_11">2</samp>
    | <samp class="SANS_Futura_Std_Book_11">1.0</samp> | <samp class="SANS_Futura_Std_Book_11">0.50</samp>
    | <samp class="SANS_Futura_Std_Book_11">0.250</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">011</samp> | <samp class="SANS_Futura_Std_Book_11">3</samp>
    | <samp class="SANS_Futura_Std_Book_11">1.5</samp> | <samp class="SANS_Futura_Std_Book_11">0.75</samp>
    | <samp class="SANS_Futura_Std_Book_11">0.375</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">100</samp> | <samp class="SANS_Futura_Std_Book_11">–4</samp>
    | <samp class="SANS_Futura_Std_Book_11">–2.0</samp> | <samp class="SANS_Futura_Std_Book_11">–1.00</samp>
    | <samp class="SANS_Futura_Std_Book_11">–0.500</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">101</samp> | <samp class="SANS_Futura_Std_Book_11">–3</samp>
    | <samp class="SANS_Futura_Std_Book_11">–1.5</samp> | <samp class="SANS_Futura_Std_Book_11">–0.75</samp>
    | <samp class="SANS_Futura_Std_Book_11">–0.375</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">110</samp> | <samp class="SANS_Futura_Std_Book_11">–2</samp>
    | <samp class="SANS_Futura_Std_Book_11">–1.0</samp> | <samp class="SANS_Futura_Std_Book_11">–0.50</samp>
    | <samp class="SANS_Futura_Std_Book_11">–0.250</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">111</samp> | <samp class="SANS_Futura_Std_Book_11">–</samp><samp
    class="SANS_Futura_Std_Book_11">1</samp> | <samp class="SANS_Futura_Std_Book_11">–0.5</samp>
    | <samp class="SANS_Futura_Std_Book_11">–0.25</samp> | <samp class="SANS_Futura_Std_Book_11">–0.125</samp>
    |'
  prefs: []
  type: TYPE_TB
- en: The S3.0 column shows the same signed whole number values we saw earlier in
    the chapter, in [Table 10-1](#tab10-1). We can generate the remaining columns
    by dividing the values in the S3.0 column by 2 for S2.1, by 4 for S1.2, and by
    8 for S0.3.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s the critical thing about working with fixed-point numbers: when you’re
    performing operations on binary data, the behavior of the binary operation doesn’t
    change based on its representation. Addition, subtraction, multiplication, and
    division all work exactly the same way as before, when we were treating the numbers
    as integers. However, there are a few more rules that need to be established to
    get the correct answer with fixed-point values.'
  prefs: []
  type: TYPE_NORMAL
- en: You’ll notice for the remainder of this chapter that I make an effort to keep
    track of the decimals in the code examples. I find it very helpful to add comments
    recording the width of the math operations in my Verilog or VHDL code. For example,
    when adding two 3-bit numbers together to get a 4-bit result, I’ll include a comment
    like <samp class="SANS_TheSansMonoCd_W5Regular_11">// U2.1</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">+</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">U2.1</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">=</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">U3.1</samp> so I know the decimal
    and integer widths. This is particularly useful when there are several math operations
    chained one after another, where the widths along the way might be changing.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Adding and Subtracting
    with Fixed Point</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'When performing addition or subtraction with fixed-point decimals, the actual
    process doesn’t change. The data is still just binary. There’s another rule that
    we must apply when we have decimals involved, however:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Rule #5** When adding or subtracting, the decimal widths must match.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The number of places to the right of the decimal point determines the value,
    or *weight*, of each bit, so if you try to add or subtract two inputs with different
    decimal bit widths—for example, a U3.1 input and a U4.0 input—you’ll get a wrong
    answer. We can see that in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Oblique_BI_11">Verilog</samp>
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: <samp class="SANS_Futura_Std_Bold_Oblique_BI_11">VHDL</samp>
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'Here’s the output:'
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Oblique_BI_11">Verilog</samp>
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: <samp class="SANS_Futura_Std_Bold_Oblique_BI_11">VHDL</samp>
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_TheSansMonoCd_W5Regular_11">Ex20</samp> shows the effect
    of not obeying Rule #5\. Here we’re attempting to add a U3.1 to a U4.0\. This
    is going to cause a problem because the weight of the bits being added together
    isn’t matched. Indeed, the printout tells us that 1.5 + 3 = 3, so something has
    clearly gone wrong.'
  prefs: []
  type: TYPE_NORMAL
- en: Notice that we’ve divided the input U3.1 and the output U5.1 by 2.0 to print
    out these fixed-point values correctly ❶. For Verilog, we can simply do the division
    on the unsigned input and use <samp class="SANS_TheSansMonoCd_W5Regular_11">%f</samp>
    to format the result like a float. In VHDL, the conversion is a bit more complicated.
    First we need to switch to the <samp class="SANS_TheSansMonoCd_W5Regular_11">real</samp>
    data type, which is used for numbers with decimals, and then we can divide by
    2.0 for printing.
  prefs: []
  type: TYPE_NORMAL
- en: 'To fix this example, we need to adjust one of the inputs so it has the same
    number of decimal bits as the other input. We can either change the first input
    from U3.1 to U4.0 to match the second input, or change the second input from U4.0
    to U4.1\. In the following code, we try both options:'
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Oblique_BI_11">Verilog</samp>
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: <samp class="SANS_Futura_Std_Bold_Oblique_BI_11">VHDL</samp>
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'Here’s the output:'
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Oblique_BI_11">Verilog</samp>
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: <samp class="SANS_Futura_Std_Bold_Oblique_BI_11">VHDL</samp>
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'In <samp class="SANS_TheSansMonoCd_W5Regular_11">Ex21</samp>, we convert the
    U3.1 to a U4.0, effectively dropping the decimal point. We do this using a 1-bit
    shift to the right ❶. But consider the effect of this: we’re eliminating the least
    significant bit, and if that bit has a 1 in it, then we’re dropping that data.
    Essentially, we’re performing a rounding operation to the next lowest integer.
    We can see that our first input was originally 1.5, but after dropping the decimal
    point it’s 1.0\. The math is correct, 1.0 + 3.0 = 4.0, but we’ve truncated our
    input.'
  prefs: []
  type: TYPE_NORMAL
- en: '<samp class="SANS_TheSansMonoCd_W5Regular_11">Ex22</samp> shows a better solution
    that retains the precision of all inputs. Rather than shifting the first input
    to the right, we shift the second input to the left ❷. This pads the least significant
    bit with a 0, converting our second input from U4.0 to U4.1\. Notice that this
    means the second input now occupies a total of 5 bits. We need to be sure to resize
    it, or we could end up losing the data in the most significant bit during the
    shift left. Additionally, our output now has to be 6 bits so we don’t violate
    Rule #1.'
  prefs: []
  type: TYPE_NORMAL
- en: Now that the decimal widths of the two inputs are matched with no loss of precision,
    we’re able to successfully calculate that 1.5 + 3.0 = 4.5\. Expanding your inputs
    to match is the best solution if you don’t want to round any of the decimal values.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Dogma_OT_Bold_B_21">NOTE</samp>
  prefs: []
  type: TYPE_NORMAL
- en: '*Subtracting fixed-point numbers works with all the same rules as addition,
    so we won’t consider an example here. Follow the rules introduced in this chapter,
    and your subtraction operations will work as expected.*'
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Multiplying with
    Fixed Point</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Multiplication with fixed-point numbers doesn’t require any shifting to match
    the decimal widths. Instead, we can simply multiply the two inputs together as
    they are, provided we keep track of the input widths and size the output appropriately.
    We already have a rule for multiplication:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Rule #4** When multiplying, the output bit width must be at least the sum
    of the input bit widths (before sign extension).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we need to add another rule to account for fixed-point numbers:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Rule #6** When multiplying fixed-point numbers, add the integer component
    bit widths and the decimal component bit widths of your inputs separately to get
    the output format.'
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, if you’re trying to multiply a U3.5 by a U1.7, the result is formatted
    as a U4.12\. We determine this by adding the integer components (3 + 1 = 4) and
    the decimal components (5 + 7 = 12), and putting them together to get the output
    width format. It works the same way for signed values, so S3.0 × S2.4 = S5.4\.
    Notice that we’re still obeying Rule #4 as well, since the output width will be
    the sum of the input widths. It’s just that the integer and decimal components
    are treated separately.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s take a look at some examples in Verilog and VHDL:'
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Oblique_BI_11">Verilog</samp>
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: <samp class="SANS_Futura_Std_Bold_Oblique_BI_11">VHDL</samp>
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'Here’s the output:'
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Oblique_BI_11">Verilog</samp>
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: <samp class="SANS_Futura_Std_Bold_Oblique_BI_11">VHDL</samp>
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'In <samp class="SANS_TheSansMonoCd_W5Regular_11">Ex23</samp>, we’re multiplying
    a U2.2 by a U3.1 to get a result that’s a U5.3\. We can see in the printout that
    the answer is correct: 1.25 × 5.5 = 6.875\. As with the addition examples, notice
    that we have to divide the values to print them out correctly. We divide the U2.2
    by 4, the U3.1 by 2, and the U5.3 by 8\. In <samp class="SANS_TheSansMonoCd_W5Regular_11">Ex24</samp>,
    we use the same technique to multiply signed values. We’re multiplying 1.5 by
    –6.0 to get –9.0, which is represented with S2.2 × S4.0 = S6.2.'
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Summary</samp>
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Since FPGAs are known for being able to perform many calculations at fast clock
    rates and in parallel, many common FPGA applications call for using addition,
    subtraction, multiplication, and division. Inside your FPGA, these operations
    may involve LUTs, shift registers, or DSP blocks. More important than knowing
    exactly how the operations are implemented, however, is understanding how the
    inputs and outputs are stored and what those binary digits represent when you’re
    writing your Verilog or VHDL code. Are they signed or unsigned? Integers or fixed
    point?
  prefs: []
  type: TYPE_NORMAL
- en: 'Over the course of this chapter, we’ve developed a set of rules for successfully
    performing FPGA math operations and interpreting the results. They are:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Rule #1** When adding or subtracting, the result should be at least 1 bit
    bigger than the biggest input, before sign extension. Once sign extension is applied,
    the input and output widths should match exactly.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Rule #2** Match types among inputs and outputs.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Rule #3** When subtracting, use signed inputs and outputs.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Rule #4** When multiplying, the output bit width must be at least the sum
    of the input bit widths (before sign extension).'
  prefs: []
  type: TYPE_NORMAL
- en: '**Rule #5** When adding or subtracting, the decimal widths must match.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Rule #6** When multiplying fixed-point numbers, add the integer component
    bit widths and the decimal component bit widths of your inputs separately to get
    the output format.'
  prefs: []
  type: TYPE_NORMAL
- en: These rules don’t capture every nuance of performing math in FPGAs, but they
    cover the major details that you need to get right. If you follow these six rules,
    it’s much more likely that you’ll get the correct answer from your calculations.
    Whenever you’re working with math, adding tests will help to ensure things are
    working as you expect.
  prefs: []
  type: TYPE_NORMAL
