- en: '**6'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: COMPILE-TIME POLYMORPHISM**
  prefs: []
  type: TYPE_NORMAL
- en: '*The more adapt, the more interesting you are.'
  prefs: []
  type: TYPE_NORMAL
- en: —Martha Stewart*
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/common.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In this chapter, you’ll learn how to achieve compile-time polymorphism with
    templates. You’ll learn how to declare and use templates, enforce type safety,
    and survey some of the templates’ more advanced usages. This chapter concludes
    with a comparison of runtime and compile-time polymorphism in C++.
  prefs: []
  type: TYPE_NORMAL
- en: '**Templates**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: C++ achieves compile-time polymorphism through *templates*. A template is a
    class or function with template parameters. These parameters can stand in for
    any type, including fundamental and user-defined types. When the compiler sees
    a template used with a type, it stamps out a bespoke template instantiation.
  prefs: []
  type: TYPE_NORMAL
- en: '*Template instantiation* is the process of creating a class or a function from
    a template. Somewhat confusingly, you can also refer to “a template instantiation”
    as the result of the template instantiation process. Template instantiations are
    sometimes called concrete classes and concrete types.'
  prefs: []
  type: TYPE_NORMAL
- en: The big idea is that, rather than copying and pasting common code all over the
    place, you write a single template; the compiler generates new template instances
    when it encounters a new combination of types in the template parameters.
  prefs: []
  type: TYPE_NORMAL
- en: '**Declaring Templates**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You declare templates with a *template prefix*, which consists of the keyword
    `template` followed by angle brackets `< >`. Within the angle brackets, you place
    the declarations of one or more template parameters. You can declare template
    parameters using either the `typename` or `class` keywords followed by an identifier.
    For example, the template prefix `template<typename T>` declares that the template
    takes a template parameter `T`.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*The coexistence of the `typename` and `class` keywords is unfortunate and
    confusing. They mean the same thing. (They’re both supported for historical reasons.)
    This chapter always uses `typename`.*'
  prefs: []
  type: TYPE_NORMAL
- en: '***Template Class Definitions***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Consider `MyTemplateClass` in [Listing 6-1](ch06.xhtml#ch06ex01), which takes
    three template parameters: `X, Y`, and `Z`.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 6-1: A template class with three template parameters*'
  prefs: []
  type: TYPE_NORMAL
- en: The `template` keyword ➊ begins the template prefix, which contains the template
    parameters ➋. This `template` preamble leads to something special about the remaining
    declaration of `MyTemplateClass` ➌. Within `MyTemplateClass`, you use `X, Y`,
    and `Z` as if they were any fully specified type, like an `int` or a user-defined
    class.
  prefs: []
  type: TYPE_NORMAL
- en: The `foo` method takes a `Y` reference and returns an `X` ➍. You can declare
    members with types that include template parameters, like a pointer to `Z` ➎.
    Besides the special prefix beginning ➊, this template class is essentially identical
    to a non-template class.
  prefs: []
  type: TYPE_NORMAL
- en: '***Template Function Definitions***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You can also specify template functions, like the `my_template_function` in
    [Listing 6-2](ch06.xhtml#ch06ex02) that also takes three template parameters:
    `X, Y`, and `Z`.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 6-2: A template function with three template parameters*'
  prefs: []
  type: TYPE_NORMAL
- en: Within the body of `my_template_function`, you can use `arg1` and `arg2` however
    you’d like, as long as you return an object of type `X`.
  prefs: []
  type: TYPE_NORMAL
- en: '***Instantiating Templates***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'To instantiate a template class, use the following syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'The tc_name ➊ is where you place the template class’s name. Next, you fill
    in your template parameters ➋. Finally, you treat this combination of template
    name and parameters as if it were a normal type: you use whatever initialization
    syntax you like ➌.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Instantiating a template function is similar:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The tf_name ➊ is where you put the template function’s name. You fill in the
    parameters just as you do for template classes ➋. You use the combination of template
    name and parameters as if it were a normal type. You invoke this template function
    instantiation with parentheses and function parameters ➌.
  prefs: []
  type: TYPE_NORMAL
- en: All this new notation might be daunting to a newcomer, but it’s not so bad once
    you get used to it. In fact, it’s used in a set of language features called named
    conversion functions.
  prefs: []
  type: TYPE_NORMAL
- en: '**Named Conversion Functions**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*Named conversions* are language features that explicitly convert one type
    into another type. You use named conversions sparingly in situations where you
    cannot use implicit conversions or constructors to get the types you need.'
  prefs: []
  type: TYPE_NORMAL
- en: 'All named conversions accept a single object parameter, which is the object
    you want to cast `object-to-cast`, and a single type parameter, which is the type
    you want to cast to `desired-type`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: For example, if you need to modify a `const` object, you would first need to
    cast away the `const` qualifier. The named conversion function `const_cast` allows
    you to perform this operation. Other named conversions help you to reverse implicit
    casts (`static_cast`) or reinterpret memory with a different type (`reinterpret_cast`).
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Although named conversion functions aren’t technically template functions,
    they are conceptually very close to templates—a relationship reflected in their
    syntactic similarity.*'
  prefs: []
  type: TYPE_NORMAL
- en: '***const_cast***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The `const_cast` function shucks away the `const` modifier, allowing the modification
    of `const` values. The `object-to-cast` is of some `const` type, and the desired-type
    is that type minus the `const` qualifier.
  prefs: []
  type: TYPE_NORMAL
- en: Consider the `carbon_thaw` function in [Listing 6-3](ch06.xhtml#ch06ex03), which
    takes a `const` reference to an `encased_solo` argument.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 6-3: A function using `const_cast`. Uncommenting yields a compiler
    error.*'
  prefs: []
  type: TYPE_NORMAL
- en: The `encased_solo` parameter is `const` ➊, so any attempt to modify it ➋ would
    result in a compiler error. You use `const_cast` ➌ to obtain the non-`const` reference
    `hibernation_sick_solo`. The `const_cast` takes a single template parameter, the
    type you want to cast into ➍. It also takes a function parameter, the object you
    want to remove `const` from ➎. You’re then free to modify the `int` pointed to
    by `encased_solo` via the new, non-`const` reference ➏.
  prefs: []
  type: TYPE_NORMAL
- en: Only use `const_cast` to obtain write access to `const` objects. Any other type
    conversion will result in a compiler error.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Trivially, you can use `const_cast` to add `const` to an object’s type, but
    you shouldn’t because it’s verbose and unnecessary. Use an implicit cast instead.
    In [Chapter 7](ch07.xhtml#ch07), you’ll learn what the `volatile` modifier is.
    You can also use `const_cast` to remove the `volatile` modifier from an object.*'
  prefs: []
  type: TYPE_NORMAL
- en: '***static_cast***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The `static_cast` reverses a well-defined implicit conversion, such as an integer
    type to another integer type. The `object-to-cast` is of some type that the `desired-type`
    implicitly converts to. The reason you might need `static_cast` is that, generally,
    implicit casts aren’t reversible.
  prefs: []
  type: TYPE_NORMAL
- en: The program in [Listing 6-4](ch06.xhtml#ch06ex04) defines an `increment_as_short`
    function that takes a `void` pointer argument. It employs a `static_cast` to create
    a `short` pointer from this argument, increment the pointed-to `short`, and return
    the result. In some low-level applications, such as network programming or handling
    binary file formats, you might need to interpret raw bytes as an integer type.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 6-4: A program using `static_cast`*'
  prefs: []
  type: TYPE_NORMAL
- en: The `target` parameter is a `void` pointer ➊. You employ `static_cast` to cast
    `target` into a `short*` ➋. The template parameter is the desired type ➌, and
    the function parameter is the object you want to cast into ➍.
  prefs: []
  type: TYPE_NORMAL
- en: 'Notice that the implicit conversion of `short*` to `void*` is well defined.
    Attempting ill-defined conversions with `static_cast`, such as converting a `char*`
    to a `float*`, will result in a compiler error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: To perform such chainsaw juggling, you need to use `reinterpret_cast`.
  prefs: []
  type: TYPE_NORMAL
- en: '***reinterpret_cast***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Sometimes in low-level programming, you must perform type conversions that are
    not well defined. In system programming and especially in embedded environments,
    you often need complete control over how to interpret memory. The `reinterpret_cast`
    gives you such control, but ensuring the correctness of these conversions is entirely
    your responsibility.
  prefs: []
  type: TYPE_NORMAL
- en: Suppose your embedded device keeps an `unsigned long` timer at memory address
    0x1000\. You could use `reinterpret_cast` to read from the timer, as demonstrated
    in [Listing 6-5](ch06.xhtml#ch06ex05).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 6-5: A program using `reinterpret_cast`. This program will compile,
    but you should expect a runtime crash unless 0x1000 is readable.*'
  prefs: []
  type: TYPE_NORMAL
- en: The `reinterpret_cast` ➊ takes a type parameter corresponding to the desired
    pointer type ➋ and the memory address the result should point to ➌.
  prefs: []
  type: TYPE_NORMAL
- en: 'Of course, the compiler has no idea whether the memory at address 0x1000 contains
    an `unsigned long`. It’s entirely up to you to ensure correctness. Because you’re
    taking full responsibility for this very dangerous construction, the compiler
    forces you to employ `reinterpret_cast`. You couldn’t, for example, replace the
    initialization of `timer` with the following line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The compiler will grumble about converting an `int` to a pointer.
  prefs: []
  type: TYPE_NORMAL
- en: '***narrow_cast***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '[Listing 6-6](ch06.xhtml#ch06ex06) illustrates a custom `static_cast` that
    performs a runtime check for *narrowing*. Narrowing is a loss in information.
    Think about converting from an `int` to a `short`. As long as the value of `int`
    fits into a `short`, the conversion is reversible and no narrowing occurs. If
    the value of `int` is too big for the `short`, the conversion isn’t reversible
    and results in narrowing.'
  prefs: []
  type: TYPE_NORMAL
- en: Let’s implement a named conversion called `narrow_cast` that checks for narrowing
    and throws a `runtime_error` if it’s detected.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 6-6: A `narrow_cast` definition*'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `narrow_cast` function template takes two template parameters: the type
    you’re casting `To` ➊ and the type you’re casting `From` ➋. You can see these
    template parameters in action as the return type of the function ➌ and the type
    of the parameter value ➍. First, you perform the requested conversion using `static_cast`
    to yield `converted` ➎. Next, you perform the conversion in the opposite direction
    (from `converted` to type `From`) to yield `backwards` ➏. If `value` doesn’t equal
    `backwards`, you’ve narrowed, so you throw an exception ➐. Otherwise, you return
    `converted` ➑.'
  prefs: []
  type: TYPE_NORMAL
- en: You can see `narrow_cast` in action in [Listing 6-7](ch06.xhtml#ch06ex07).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 6-7: A program using `narrow_cast`. (The output comes from an execution
    on Windows 10 x64.)*'
  prefs: []
  type: TYPE_NORMAL
- en: You first initialize `perfect` to 496 ➊ and then `narrow_cast` it to the short
    `perfect_short` ➋. This proceeds without exception because the value 496 fits
    easily into a 2-byte short on Windows 10 x64 (maximum value 32767). You see the
    output as expected ➌. Next, you initialize `cyclic` to 142857 ➍ and attempt to
    `narrow_cast` to the short `cyclic_short` ➎. This throws a `runtime_error` because
    142857 is greater than the short’s maximum value of 32767\. The check within `narrow_cast`
    will fail. You see the exception printed in the `output` ➏.
  prefs: []
  type: TYPE_NORMAL
- en: Notice that you need to provide only a single template parameter, the return
    type, upon instantiation ➋➎. The compiler can deduce the `From` parameter based
    on usage.
  prefs: []
  type: TYPE_NORMAL
- en: '**mean: A Template Function Example**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Consider the function in [Listing 6-8](ch06.xhtml#ch06ex08) that computes the
    mean of a `double` array using the sum-and-divide approach.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 6-8: A function for computing the mean of an array*'
  prefs: []
  type: TYPE_NORMAL
- en: You initialize a `result` variable to zero ➊. Next, you sum over `values` by
    iterating over each index `i`, adding the corresponding element to `result` ➋.
    Then you divide `result` by `length` and `return` ➌.
  prefs: []
  type: TYPE_NORMAL
- en: '***Genericizing mean***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Suppose you want to support `mean` calculations for other numeric types, such
    as `float` or `long`. You might be thinking, “That’s what function overloads are
    for!” Essentially, you would be correct.
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 6-9](ch06.xhtml#ch06ex09) overloads `mean` to accept a `long` array.
    The straightforward approach is to copy and paste the original, then replace instances
    of `double` with `long`.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 6-9: An overload of [Listing 6-8](ch06.xhtml#ch06ex08) accepting a
    `long` array*'
  prefs: []
  type: TYPE_NORMAL
- en: 'That sure is a lot of copying and pasting, and you’ve changed very little:
    the return type ➊, the function argument ➋, and `result` ➌.'
  prefs: []
  type: TYPE_NORMAL
- en: This approach doesn’t scale as you add more types. What if you want to support
    other integral types, such as `short` types or `uint_64` types? What about `float`
    types? What if, later on, you want to refactor some logic in `mean`? You’re in
    for a lot of tedious and error-prone maintenance.
  prefs: []
  type: TYPE_NORMAL
- en: There are three changes to `mean` in [Listing 6-9](ch06.xhtml#ch06ex09), and
    all of them involve finding and replacing `double` types with `long` types. Ideally,
    you could have the compiler automatically generate versions of the function for
    you whenever it encounters usage with a different type. The key is that none of
    the logic changes—only the types.
  prefs: []
  type: TYPE_NORMAL
- en: What you need to solve this copy-and-paste problem is *generic programming*,
    a programming style where you program with yet-to-be-specified types. You achieve
    generic programming using the support C++ has for templates. Templates allow the
    compiler to instantiate a custom class or function based on the types in use.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you know how to declare templates, consider the `mean` function again.
    You still want `mean` to accept a wide range of types—not just `double` types—but
    you don’t want to have to copy and paste the same code over and over again.
  prefs: []
  type: TYPE_NORMAL
- en: Consider how you can refactor [Listing 6-8](ch06.xhtml#ch06ex08) into a template
    function, as demonstrated in [Listing 6-10](ch06.xhtml#ch06ex10).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 6-10: Refactoring [Listing 6-8](ch06.xhtml#ch06ex08) into a template
    function*'
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 6-10](ch06.xhtml#ch06ex10) kicks off with a template prefix ➊. This
    prefix communicates a single template parameter `T`. Next, you update `mean` to
    use `T` instead of `double` ➋➌➍.'
  prefs: []
  type: TYPE_NORMAL
- en: Now you can use `mean` with many different types. Each time the compiler encounters
    a usage of `mean` with a new type, it performs template instantiation. It’s *as
    if* you had done the copy-paste-and-replace-types procedure, but the compiler
    is much better at doing detail-oriented, monotonous tasks than you are. Consider
    the example in [Listing 6-11](ch06.xhtml#ch06ex11), which computes means for `double,
    float`, and `size_t` types.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 6-11: A program using the template function `mean`*'
  prefs: []
  type: TYPE_NORMAL
- en: Three templates are instantiated ➊➋➌; it’s as if you generated the overloads
    isolated in [Listing 6-12](ch06.xhtml#ch06ex12) by hand. (Each template instantiation
    contains types, shown in bold, where the compiler substituted a type for a template
    parameter.)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 6-12: The template instantiations for [Listing 6-11](ch06.xhtml#ch06ex11)*'
  prefs: []
  type: TYPE_NORMAL
- en: 'The compiler has done a lot of work for you, but you might have noticed that
    you had to type the pointed-to array type twice: once to declare an array and
    again to specify a template parameter. This gets tedious and can cause errors.
    If the template parameter doesn’t match, you’ll likely get a compiler error or
    cause unintended casting.'
  prefs: []
  type: TYPE_NORMAL
- en: Fortunately, you can generally omit the template parameters when invoking a
    template function. The process that the compiler uses to determine the correct
    template parameters is called *template type deduction*.
  prefs: []
  type: TYPE_NORMAL
- en: '***Template Type Deduction***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Generally, you don’t have to provide template function parameters. The compiler
    can deduce them from usage, so a rewrite of [Listing 6-11](ch06.xhtml#ch06ex11)
    without them is shown in [Listing 6-13](ch06.xhtml#ch06ex13).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 6-13: A refactor of [Listing 6-11](ch06.xhtml#ch06ex11) without explicit
    template parameters*'
  prefs: []
  type: TYPE_NORMAL
- en: It’s clear from usage that the template parameters are `double` ➊, `float` ➋,
    and `size_t` ➌.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Template type deduction mostly works the way you might expect, but there is
    some nuance you’ll want to become familiar with if you’re writing a lot of generic
    code. For more information, see the ISO standard [temp]. Also, refer to Item 1
    of Effective Modern C++ by Scott Meyers and Section 23.5.1 of The C++ Programming
    Language, 4th Edition, by Bjarne Stroustrup.*'
  prefs: []
  type: TYPE_NORMAL
- en: Sometimes, template arguments cannot be deduced. For example, if a template
    function’s return type is a template argument that’s entirely independent of other
    function and template arguments, you must specify template arguments explicitly.
  prefs: []
  type: TYPE_NORMAL
- en: '**SimpleUniquePointer: A Template Class Example**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A *unique pointer* is an RAII wrapper around a free-store-allocated object.
    As its name suggests, the unique pointer has a single owner at a time, so when
    a unique pointer’s lifetime ends, the pointed-to object gets destructed.
  prefs: []
  type: TYPE_NORMAL
- en: The underlying object’s type in unique pointers doesn’t matter, making them
    a prime candidate for a template class. Consider the implementation in [Listing
    6-14](ch06.xhtml#ch06ex14).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 6-14: A simple unique pointer implementation*'
  prefs: []
  type: TYPE_NORMAL
- en: You announce the template class with a template prefix ➊, which establishes
    `T` as the wrapped object’s type. Next, you specify a default constructor using
    the `default` keyword ➋. (Recall from [Chapter 4](ch04.xhtml#ch04) that you need
    `default` when you want both a default constructor *and* a non-default constructor.)
    The generated default constructor will set the private member `T*` pointer to
    `nullptr` thanks to default initialization rules. You have a non-default constructor
    that takes a `T*` and sets the private member pointer ➌. Because the pointer is
    possibly `nullptr`, the destructor checks before deleting ➍.
  prefs: []
  type: TYPE_NORMAL
- en: Because you want to allow only a single owner of the pointed-to object, you
    `delete` the copy constructor and the copy-assignment operator ➎. This prevents
    double-free issues, which were discussed in [Chapter 4](ch04.xhtml#ch04). However,
    you can make your unique pointer moveable by adding a move constructor ➏. This
    steals the value of `pointer` from `other` and then sets the pointer of `other`
    to `nullptr`, handing responsibility of the pointed-to object to `this`. Once
    the move constructor returns, the moved-from object is destroyed. Because the
    moved-from object’s pointer is set to `nullptr`, the destructor will not delete
    the pointed-to object.
  prefs: []
  type: TYPE_NORMAL
- en: 'The possibility that `this` already owns an object complicates the move assignment
    ➐. You must check explicitly for prior ownership, because failure to delete a
    pointer leaks a resource. After this check, you perform the same operations as
    in the copy constructor: you set `pointer` to the value of `other.pointer` and
    then set `other.pointer` to `nullptr`. This ensures that the moved-from object
    doesn’t delete the pointed-to object.'
  prefs: []
  type: TYPE_NORMAL
- en: You can obtain direct access to the underlying pointer by calling the `get`
    method ➑.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s enlist our old friend `Tracer` from [Listing 4-5](ch04.xhtml#ch04ex05)
    to investigate `SimpleUniquePointer`. Consider the program in [Listing 6-15](ch06.xhtml#ch06ex15).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 6-15: A program investigating `SimpleUniquePointers` with the `Tracer`
    class*'
  prefs: []
  type: TYPE_NORMAL
- en: First, you dynamically allocate a `Tracer` with the message `ptr_a`. This prints
    the first message ➊. You use the resulting `Tracer` pointer to construct a `SimpleUniquePointer`
    called `ptr_a`. Next, you use the `get()` method of `ptr_a` to retrieve the address
    of its `Tracer`, which you print ➍. Then you use `std::move` to relinquish the
    `Tracer` of `ptr_a` to the `consumer` function, which moves `ptr_a` into the `consumer_ptr`
    argument.
  prefs: []
  type: TYPE_NORMAL
- en: Now, `consumer_ptr` owns the `Tracer`. You use the `get()` method of `consumer_ptr`
    to retrieve the address of `Tracer`, then print ➌. Notice this address matches
    the one printed at ➍. When `consumer` returns, `consumer_ptr` dies because its
    storage duration is the scope of `consumer`. As a result, `ptr_a` gets destructed
    ➋.
  prefs: []
  type: TYPE_NORMAL
- en: Recall that `ptr_a` is in a moved-from state—you moved its `Tracer` into `consumer`.
    You use the `get()` method of `ptr_a` to illustrate that it now holds a `nullptr`
    ➎.
  prefs: []
  type: TYPE_NORMAL
- en: Thanks to `SimpleUniquePointer`, you won’t leak a dynamically allocated object;
    also, because the `SimpleUniquePointer` is just carrying around a pointer under
    the hood, move semantics are efficient.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*The `SimpleUniquePointer` is a pedagogical implementation of the stdlib’s
    `std::unique_ptr`, which is a member of the family of RAII templates called smart
    pointers. You’ll learn about these in [Part II](part02.xhtml#part02).*'
  prefs: []
  type: TYPE_NORMAL
- en: '**Type Checking in Templates**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Templates are type safe. During template instantiation, the compiler pastes
    in the template parameters. If the resulting code is incorrect, the compiler will
    not generate the instantiation.
  prefs: []
  type: TYPE_NORMAL
- en: Consider the template function in [Listing 6-16](ch06.xhtml#ch06ex16), which
    squares an element and returns the result.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 6-16: A template function that squares a value*'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `T` has a silent requirement: it must support multiplication ➊.'
  prefs: []
  type: TYPE_NORMAL
- en: If you try to use `square` with, say, a `char*`, the compilation will fail,
    as shown in [Listing 6-17](ch06.xhtml#ch06ex17).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 6-17: A program with a failed template instantiation. (This program
    fails to compile.)*'
  prefs: []
  type: TYPE_NORMAL
- en: Pointers don’t support multiplication, so template initialization fails ➊.
  prefs: []
  type: TYPE_NORMAL
- en: 'The square function is trivially small, but the failed template initialization’s
    error message isn’t. On MSVC v141, you get this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'And on GCC 7.3, you get this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: These error messages exemplify the notoriously cryptic error messages emitted
    by template initialization failures.
  prefs: []
  type: TYPE_NORMAL
- en: Although template instantiation ensures type safety, the checking happens very
    late in the compilation process. When the compiler instantiates a template, it
    pastes the template parameter types into the template. After type insertion, the
    compiler attempts to compile the result. If instantiation fails, the compiler
    emits the dying words inside the template instantiation.
  prefs: []
  type: TYPE_NORMAL
- en: C++ template programming shares similarities with *duck-typed languages*. Duck-typed
    languages (like Python) defer type checking until runtime. The underlying philosophy
    is that if an object looks like a duck and quacks like a duck, then it must be
    type duck. Unfortunately, this means you can’t generally know whether an object
    supports a particular operation until you execute the program.
  prefs: []
  type: TYPE_NORMAL
- en: With templates, you cannot know whether an instantiation will succeed until
    you try to compile it. Although duck-typed languages might blow up at runtime,
    templates might blow up at compile time.
  prefs: []
  type: TYPE_NORMAL
- en: This situation is widely regarded as unacceptable by right-thinking people in
    the C++ community, so there is a splendid solution called *concepts*.
  prefs: []
  type: TYPE_NORMAL
- en: '**Concepts**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*Concepts* constrain template parameters, allowing for parameter checking at
    the point of instantiation rather than the point of first use. By catching usage
    issues at the point of instantiation, the compiler can give you a friendly, informative
    error code—for example, “You tried to instantiate this template with a `char*`,
    but this template requires a type that supports multiplication.”'
  prefs: []
  type: TYPE_NORMAL
- en: Concepts allow you to express requirements on template parameters directly in
    the language.
  prefs: []
  type: TYPE_NORMAL
- en: 'Unfortunately, concepts aren’t yet officially part of the C++ standard, although
    they’ve been voted into C++ 20\. At press time, GCC 6.0 and later support the
    Concepts Technical Specification, and Microsoft is actively working toward implementing
    concepts in its C++ compiler, MSVC. Regardless of its unofficial status, it’s
    worth exploring concepts in some detail for a few reasons:'
  prefs: []
  type: TYPE_NORMAL
- en: They’ll fundamentally change the way you achieve compile-time polymorphism.
    Familiarity with concepts will pay major dividends.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: They provide a conceptual framework for understanding some of the makeshift
    solutions that you can put in place to get better compiler errors when templates
    are misused.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: They provide an excellent conceptual bridge from compile-time templates to interfaces,
    the primary mechanism for runtime polymorphism (covered in [Chapter 5](ch05.xhtml#ch05)).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you can use GCC 6.0 or later, concepts *are* available by turning on the
    `-fconcepts` compiler flag.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**WARNING**'
  prefs: []
  type: TYPE_NORMAL
- en: '*C++ 20’s final concept specification will almost certainly deviate from the
    Concepts Technical Specification. This section presents concepts as specified
    in the Concepts Technical Specification so you can follow along.*'
  prefs: []
  type: TYPE_NORMAL
- en: '***Defining a Concept***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'A concept is a template. It’s a constant expression involving template arguments,
    evaluated at compile time. Think of a concept as one big *predicate*: a function
    that evaluates to `true` or `false`.'
  prefs: []
  type: TYPE_NORMAL
- en: If a set of template parameters meets the criteria for a given concept, that
    concept evaluates to `true` when instantiated with those parameters; otherwise,
    it will evaluate to `false`. When a concept evaluates to `false`, template instantiation
    fails.
  prefs: []
  type: TYPE_NORMAL
- en: 'You declare concepts using the keyword `concept` on an otherwise familiar template
    function definition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: '***Type Traits***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Concepts validate type parameters. Within concepts, you manipulate types to
    inspect their properties. You can hand roll these manipulations, or you can use
    the type support library built into the stdlib. The library contains utilities
    for inspecting type properties. These utilities are collectively called *type
    traits*. They’re available in the `<type_traits>` header and are part of the `std`
    namespace. [Table 6-1](ch06.xhtml#ch06tab01) lists some commonly used type traits.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*See Chapter 5.4 of The C++ Standard Library, 2nd Edition, by Nicolai M. Josuttis
    for an exhaustive listing of type traits available in the stdlib.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 6-1:** Selected Type Traits from the `<type_traits>` Header'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Type trait** | **Checks if template argument is …** |'
  prefs: []
  type: TYPE_TB
- en: '| `is_void` | `void` |'
  prefs: []
  type: TYPE_TB
- en: '| `is_null_pointer` | `nullptr` |'
  prefs: []
  type: TYPE_TB
- en: '| `is_integral` | `bool`, a `char` type, an `int` type, a `short` type, a `long`
    type, or a `long long` type |'
  prefs: []
  type: TYPE_TB
- en: '| `is_floating_point` | `float`, `double`, or `long double` |'
  prefs: []
  type: TYPE_TB
- en: '| `is_fundamental` | Any of `is_void`, `is_null_pointer`, `is_integral`, or
    `is_floating_point` |'
  prefs: []
  type: TYPE_TB
- en: '| `is_array` | An array; that is, a type containing square brackets `[]` |'
  prefs: []
  type: TYPE_TB
- en: '| `is_enum` | An enumeration type (`enum`) |'
  prefs: []
  type: TYPE_TB
- en: '| `is_class` | A class type (but not a union type) |'
  prefs: []
  type: TYPE_TB
- en: '| `is_function` | A function |'
  prefs: []
  type: TYPE_TB
- en: '| `is_pointer` | A pointer; function pointers count, but pointers to class
    members and `nullptr` do not |'
  prefs: []
  type: TYPE_TB
- en: '| `is_reference` | A reference (either lvalue or rvalue) |'
  prefs: []
  type: TYPE_TB
- en: '| `is_arithmetic` | `is_floating_point` or `is_integral` |'
  prefs: []
  type: TYPE_TB
- en: '|  `is_pod`  | A plain-old-data type; that is, a type that can be represented
    as a data type in plain C |'
  prefs: []
  type: TYPE_TB
- en: '| `is_default_constructible` | Default constructible; that is, it can be constructed
    without arguments or initialization values |'
  prefs: []
  type: TYPE_TB
- en: '| `is_constructible` | Constructible with the given template parameters: this
    type trait allows the user to provide additional template parameters beyond the
    type under consideration |'
  prefs: []
  type: TYPE_TB
- en: '| `is_copy_constructible` | Copy constructible |'
  prefs: []
  type: TYPE_TB
- en: '| `is_move_constructible` | Move constructible |'
  prefs: []
  type: TYPE_TB
- en: '| `is_destructible` | Destructible |'
  prefs: []
  type: TYPE_TB
- en: '| `is_same` | The same type as the additional template parameter type (including
    const and volatile modifiers) |'
  prefs: []
  type: TYPE_TB
- en: '| `is_invocable` | Invocable with the given template parameters: this type
    trait allows the user to provide additional template parameters beyond the type
    under consideration |'
  prefs: []
  type: TYPE_TB
- en: Each type trait is a template class that takes a single template parameter,
    the type you want to inspect. You extract the results using the template’s static
    member `value`. This member equals `true` if the type parameter meets the criteria;
    otherwise, it’s `false`.
  prefs: []
  type: TYPE_NORMAL
- en: Consider the type trait classes `is_integral` and `is_floating_point`. These
    are useful for checking if a type is (you guessed it) integral or floating point.
    Both of these templates take a single template parameter. The example in [Listing
    6-18](ch06.xhtml#ch06ex18) investigates type traits with several types.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 6-18: A program using type traits*'
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 6-18](ch06.xhtml#ch06ex18) defines the convenience function `as_str`
    ➊ to print Boolean values with the string `True` or `False`. Within `main`, you
    print the result of various type trait instantiations. The template parameters
    `int` ➋, const int ➌, char ➍, and `uint64_t` ➎ all return `true` when passed to
    `is_integral`. Reference types ➏➐ and floating-point types ➑ return `false`.'
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Recall that `printf` doesn’t have a format specifier for `bool`. Rather than
    using the integer format specifier `%d` as a stand-in, [Listing 6-18](ch06.xhtml#ch06ex18)
    employs the `as_str` function, which returns the string literal `True` or `False`
    depending on the value of the `bool`. Because these values are string literals,
    you can capitalize them however you like*.'
  prefs: []
  type: TYPE_NORMAL
- en: Type traits are often the building blocks for a concept, but sometimes you need
    more flexibility. Type traits tell you *what* types are, but sometimes you must
    also specify *how* the template will use them. For this, you use requirements.
  prefs: []
  type: TYPE_NORMAL
- en: '***Requirements***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '*Requirements* are ad hoc constraints on template parameters. Each concept
    can specify any number of requirements on its template parameters. Requirements
    are encoded into requires expressions denoted by the `requires` keyword followed
    by function arguments and a body.'
  prefs: []
  type: TYPE_NORMAL
- en: 'A sequence of syntactic requirements comprises the requirements expression’s
    body. Each syntactic requirement puts a constraint on the template parameters.
    Together, requires expressions have the following form:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Requires expressions take arguments that you place after the `requires` keyword
    ➊. These arguments have types derived from template parameters. The syntactic
    requirements follow, each denoted with `{ } ->`. You put an arbitrary expression
    within each of the braces ➋. This expression can involve any number of the arguments
    to the argument expression.
  prefs: []
  type: TYPE_NORMAL
- en: If an instantiation causes a syntactic expression not to compile, that syntactic
    requirement fails. Supposing the expression evaluates without error, the next
    check is whether the return type of that expression matches the type given after
    the arrow `->` ➌. If the expression result’s evaluated type can’t implicitly convert
    to the return type ➌, the syntactic requirement fails.
  prefs: []
  type: TYPE_NORMAL
- en: If any of the syntactic requirements fail, the requires expression evaluates
    to `false`. If all of the syntactic requirements pass, the requires expression
    evaluates to `true`.
  prefs: []
  type: TYPE_NORMAL
- en: Suppose you have two types, `T` and `U`, and you want to know whether you can
    compare objects of these types using the equality `==` and inequality `!=` operators.
    One way to encode this requirement is to use the following expression.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: The requires expression takes two arguments, one each of types `T` and `U`.
    Each of the syntactic requirements contained in the requires expression is an
    expression using `t` and `u` with either `==` or `!=`. All four syntactic requirements
    enforce a `bool` result. Any two types that satisfy this requires expression are
    guaranteed to support comparison with `==` and `!=`.
  prefs: []
  type: TYPE_NORMAL
- en: '***Building Concepts from Requires Expressions***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Because requires expressions are evaluated at compile time, concepts can contain
    any number of them. Try to construct a concept that guards against the misuse
    of `mean`. [Listing 6-19](ch06.xhtml#ch06ex19) annotates some of the implicit
    requirements used earlier in [Listing 6-10](ch06.xhtml#ch06ex10).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 6-19: A relisting of 6-10 with annotations for some implicit requirements
    on `T`*'
  prefs: []
  type: TYPE_NORMAL
- en: 'You can see three requirements implied by this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '`T` must be default constructible ➊.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`T` supports `operator+=` ➋.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Dividing a `T` by a `size_t` yields a `T` ➌.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: From these requirements, you could create a concept called `Averageable`, as
    demonstrated in [Listing 6-20](ch06.xhtml#ch06ex20).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 6-20: An `Averageable` concept. Annotations are consistent with the
    requirements and the body of `mean`.*'
  prefs: []
  type: TYPE_NORMAL
- en: You use the type trait `is_default_constructible` to ensure that `T` is default
    constructible ➊, that you can add two `T` types ➋, and that you can divide a `T`
    by a `size_t` ➌ and get a result of type `T`.
  prefs: []
  type: TYPE_NORMAL
- en: Recall that concepts are just predicates; you’re building a Boolean expression
    that evaluates to `true` when the template parameters are supported and `false`
    when they’re not. The concept is composed of a type trait ➊ and a requires containing
    two requirement expressions ➋➌. If any of the three returns `false`, the concept’s
    constraints are not met.
  prefs: []
  type: TYPE_NORMAL
- en: '***Using Concepts***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Declaring concepts is a lot more work than using them. To use a concept, just
    use the concept’s name in place of the `typename` keyword.
  prefs: []
  type: TYPE_NORMAL
- en: For example, you can refactor [Listing 6-13](ch06.xhtml#ch06ex13) with the `Averageable`
    concept, as shown in [Listing 6-21](ch06.xhtml#ch06ex21).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 6-21: A refactor of [Listing 6-13](ch06.xhtml#ch06ex13) using `Averageable`*'
  prefs: []
  type: TYPE_NORMAL
- en: After defining `Averageable` ➊, you just use it in place of `typename` ➋. No
    further modification is necessary. The code generated from compiling [Listing
    6-13](ch06.xhtml#ch06ex13) is identical to the code generated from compiling [Listing
    6-21](ch06.xhtml#ch06ex21).
  prefs: []
  type: TYPE_NORMAL
- en: 'The payoff is when you get to try to use `mean` with a type that is not `Averageable`:
    you get a compiler error at the point of instantiation. This produces much better
    compiler error messages than you would obtain from a raw template.'
  prefs: []
  type: TYPE_NORMAL
- en: Look at the instantiation of `mean` in [Listing 6-22](ch06.xhtml#ch06ex22) where
    you “accidentally” try to average an array of `double` pointers.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 6-22: A bad template instantiation using a non-`Averageable` argument*'
  prefs: []
  type: TYPE_NORMAL
- en: There are several problems with using `values` ➊. What can the compiler tell
    you about those problems?
  prefs: []
  type: TYPE_NORMAL
- en: Without concepts, GCC 6.3 produces the error message shown in [Listing 6-23](ch06.xhtml#ch06ex23).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 6-23: Error message from GCC 6.3 when compiling [Listing 6-22](ch06.xhtml#ch06ex22)*'
  prefs: []
  type: TYPE_NORMAL
- en: You might expect a casual user of `mean` to be extremely confused by this error
    message. What is `i` ➊? Why is a `const double*` involved in division ➋?
  prefs: []
  type: TYPE_NORMAL
- en: Concepts provide a far more illuminating error message, as [Listing 6-24](ch06.xhtml#ch06ex24)
    demonstrates.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 6-24: Error message from GCC 7.2 when compiling [Listing 6-22](ch06.xhtml#ch06ex22)
    with concepts enabled*'
  prefs: []
  type: TYPE_NORMAL
- en: This error message is fantastic. The compiler tells you which argument (`values`)
    didn’t meet a constraint ➊. Then it tells you that `values` is not `Averageable`
    because it doesn’t satisfy two required expressions ➋➌. You know immediately how
    to modify your arguments to make this template instantiation successful.
  prefs: []
  type: TYPE_NORMAL
- en: When concepts incorporate into the C++ standard, it’s likely that the stdlib
    will include many concepts. The design goal of concepts is that a programmer shouldn’t
    have to define very many concepts on their own; rather, they should be able to
    combine concepts and ad hoc requirements within a template prefix. [Table 6-2](ch06.xhtml#ch06tab02)
    provides a partial listing of some concepts you might expect to be included; these
    are borrowed from Andrew Sutton’s implementation of concepts in the Origins Library.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*See [https://github.com/asutton/origin/](https://github.com/asutton/origin/)
    for more information on the Origins Library. To compile the examples that follow,
    you can install Origins and use GCC version 6.0 or later with the `-fconcepts`
    flag.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 6-2:** The Concepts Contained in the Origins Library'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Concept** | **A type that …** |'
  prefs: []
  type: TYPE_TB
- en: '| `Conditional` | Can be explicitly converted to `bool` |'
  prefs: []
  type: TYPE_TB
- en: '| `Boolean` | Is `Conditional` and supports `!`, `&&`, and `&#124;&#124;` Boolean
    operations |'
  prefs: []
  type: TYPE_TB
- en: '| `Equality_comparable` | Supports `==` and `!=` operations returning a `Boolean`
    |'
  prefs: []
  type: TYPE_TB
- en: '| `Destructible` | Can be destroyed (compare `is_destructible`) |'
  prefs: []
  type: TYPE_TB
- en: '| `Default_constructible` | Is default constructible (compare `is_default_constructible`)
    |'
  prefs: []
  type: TYPE_TB
- en: '| `Movable` | Supports move semantics: it must be move assignable and move
    constructible (compare `is_move_assignable`, `is_move_constructible`) |'
  prefs: []
  type: TYPE_TB
- en: '| `Copyable` | Supports copy semantics: it must be copy assignable and copy
    constructible (compare `is_copy_assignable`, `is_copy_constructible`) |'
  prefs: []
  type: TYPE_TB
- en: '| `Regular` | Is default constructible, copyable, and `Equality_comparable`
    |'
  prefs: []
  type: TYPE_TB
- en: '| `Ordered` | Is `Regular` and is totally ordered (essentially, it can be sorted)
    |'
  prefs: []
  type: TYPE_TB
- en: '| `Number` | Is `Ordered` and supports math operations like `+`, `-`, `/`,
    and `*` |'
  prefs: []
  type: TYPE_TB
- en: '| `Function` | Supports invocation; that is, you can call it (compare `is_invocable`)
    |'
  prefs: []
  type: TYPE_TB
- en: '| `Predicate` | Is a `Function` and returns `bool` |'
  prefs: []
  type: TYPE_TB
- en: '| `Range` | Can be iterated over in a range-based `for` loop |'
  prefs: []
  type: TYPE_TB
- en: 'There are several ways to build constraints into a template prefix. If a template
    parameter is only used to declare the type of a function parameter, you can omit
    the template prefix entirely:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Because you use a concept rather than a `typename` to define an argument’s type
    ➊, the compiler knows that the associated function is a template. You are even
    free to mix concepts and concrete types in the argument list. In other words,
    whenever you use a concept as part of a function definition, that function becomes
    a template.
  prefs: []
  type: TYPE_NORMAL
- en: The template function in [Listing 6-25](ch06.xhtml#ch06ex25) takes an array
    of `Ordered` elements and finds the minimum.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 6-25: A template function using the `Ordered` concept*'
  prefs: []
  type: TYPE_NORMAL
- en: Even though there’s no template prefix, `index_of_minimum` is a template because
    `Ordered` ➊ is a concept. This template can be instantiated in the same way as
    any other template function, as demonstrated in [Listing 6-26](ch06.xhtml#ch06ex26).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 6-26: A listing employing `index_of_minimum` from [Listing 6-25](ch06.xhtml#ch06ex25).
    Uncommenting* ➌ *causes compilation to fail.*'
  prefs: []
  type: TYPE_NORMAL
- en: The instantiations for `int` ➊ and `unsigned short` ➋ arrays succeed because
    types are `Ordered` (see [Table 6-2](ch06.xhtml#ch06tab02)).
  prefs: []
  type: TYPE_NORMAL
- en: 'However, the `Goblin` class is not `Ordered`, and template instantiation would
    fail if you tried to compile ➌. Crucially, the error message would be informative:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: You know that the `index_of_minimum` instantiation failed and that the issue
    is with the `Ordered` concept.
  prefs: []
  type: TYPE_NORMAL
- en: '***Ad Hoc Requires Expressions***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Concepts are fairly heavyweight mechanisms for enforcing type safety. Sometimes,
    you just want to enforce some requirement directly in the template prefix. You
    can embed requires expressions directly into the template definition to accomplish
    this. Consider the `get_copy` function in [Listing 6-27](ch06.xhtml#ch06ex27)
    that takes a pointer and safely returns a copy of the pointed-to object.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 6-27: A template function with an ad hoc requires expression*'
  prefs: []
  type: TYPE_NORMAL
- en: The template prefix contains the `requires` keyword ➊, which begins the requires
    expression. In this case, the type trait `is_copy_constructible` ensures that
    `T` is copyable ➋. This way, if a user accidentally tries to `get_copy` with a
    pointer that points to an uncopyable object, they’ll be presented with a clear
    explanation of why template instantiation failed. Consider the example in [Listing
    6-28](ch06.xhtml#ch06ex28).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 6-28: Program using the `get_copy` template in [Listing 6-27](ch06.xhtml#ch06ex27).
    This code doesn’t compile.*'
  prefs: []
  type: TYPE_NORMAL
- en: The definition of `get_copy` ➊ is followed by a `Highlander` class definition,
    which contains a default constructor ➋ and a deleted copy constructor ➌. Within
    `main`, you’ve initialized a `Highlander` ➍, taken its reference ➎, and attempted
    to instantiate `get_copy` with the result ➏. Because there can be only one `Highlander`
    (it’s not copyable), [Listing 6-28](ch06.xhtml#ch06ex28) produces an exquisitely
    clear error message.
  prefs: []
  type: TYPE_NORMAL
- en: '**static_assert: The Preconcepts Stopgap**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'As of C++17, concepts aren’t part of the standard, so they’re not guaranteed
    to be available across compilers. There is a stopgap you can apply in the interim:
    the `static_assert` expression. These assertions evaluate at compile time. If
    an assertion fails, the compiler will issue an error and optionally provide a
    diagnostic message. A `static_assert` has the following form:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: In the absence of concepts, you can include one or more `static_assert` expressions
    in the bodies of templates to assist users in diagnosing usage errors.
  prefs: []
  type: TYPE_NORMAL
- en: Suppose you want to improve the error messages of `mean` without leaning on
    concepts. You can use type traits in combination with `static_assert` to achieve
    a similar result, as demonstrated in [Listing 6-29](ch06.xhtml#ch06ex29).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 6-29: Using `static_assert` expressions to improve compile time errors
    in `mean` in [Listing 6-10](ch06.xhtml#ch06ex10).*'
  prefs: []
  type: TYPE_NORMAL
- en: You see the familiar type traits for checking that `T` is default ➊ and copy
    constructible ➋, and you provide error methods to help users diagnose issues with
    template instantiation. You use `is_arithmetic` ➌, which evaluates to `true` if
    the type parameter supports arithmetic operations (`+, -, /`, and `*`), and `is_constructible`
    ➍, which determines whether you can construct a `T` from a `size_t`.
  prefs: []
  type: TYPE_NORMAL
- en: Using `static_assert` as a proxy for concepts is a hack, but it’s widely used.
    Using type traits, you can limp along until concepts are included in the standard.
    You’ll often see `static_assert` if you use modern third-party libraries; if you’re
    writing code for others (including future you), consider using `static_assert`
    and type traits.
  prefs: []
  type: TYPE_NORMAL
- en: Compilers, and often programmers, don’t read documentation. By baking requirements
    directly into the code, you can avoid stale documentation. In the absence of concepts,
    `static_assert` is a fine stopgap.
  prefs: []
  type: TYPE_NORMAL
- en: '**Non-Type Template Parameters**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'A template parameter declared with the `typename` (or `class`) keyword is called
    a *type template parameter*, which is a stand-in for some yet-to-be-specified
    *type*. Alternatively, you can use *non-type template parameters*, which are stand-ins
    for some yet-to-be-specified *value*. Non-type template parameters can be any
    of the following:'
  prefs: []
  type: TYPE_NORMAL
- en: An integral type
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An lvalue reference type
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A pointer (or pointer-to-member) type
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A `std::nullptr_t` (the type of `nullptr`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An `enum class`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using a non-type template parameter allows you to inject a value into the generic
    code at compile time. For example, you can construct a template function called
    `get` that checks for out-of-bounds array access at compile time by taking the
    index you want to access as a non-type template parameter.
  prefs: []
  type: TYPE_NORMAL
- en: 'Recall from [Chapter 3](ch03.xhtml#ch03) that if you pass an array to a function,
    it decays into a pointer. You can instead pass an array reference with a particularly
    off-putting syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: For example, [Listing 6-30](ch06.xhtml#ch06ex30) contains a `get` function that
    makes a first attempt at performing bounds-checked array access.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 6-30: A function for accessing array elements with bounds checking*'
  prefs: []
  type: TYPE_NORMAL
- en: The `get` function accepts a reference to an `int` array of length 10 ➊ and
    an `index` to extract ➋. If `index` is out of bounds, it throws an `out_of_bounds`
    exception ➌; otherwise, it returns a reference to the corresponding element ➍.
  prefs: []
  type: TYPE_NORMAL
- en: You can improve [Listing 6-30](ch06.xhtml#ch06ex30) in three ways, which are
    all enabled by non-type template parameters genericizing the values out of `get`.
  prefs: []
  type: TYPE_NORMAL
- en: First, you can relax the requirement that `arr` refer to an `int` array by making
    `get` a template function, as in [Listing 6-31](ch06.xhtml#ch06ex31).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 6-31: A refactor of [Listing 6-30](ch06.xhtml#ch06ex30) to accept
    an array of a generic type*'
  prefs: []
  type: TYPE_NORMAL
- en: As you’ve done throughout this chapter, you’ve genericized the function by replacing
    a concrete type (here, `int`) with a template parameter ➊➋➌.
  prefs: []
  type: TYPE_NORMAL
- en: 'Second, you can relax the requirement that `arr` refer to an array of length
    10 by introducing a non-type template parameter `Length`. [Listing 6-32](ch06.xhtml#ch06ex32)
    shows how: simply declare a `size_t Length` template parameter and use it in place
    of 10.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 6-32: A refactor of [Listing 6-31](ch06.xhtml#ch06ex31) to accept
    an array of a generic length*'
  prefs: []
  type: TYPE_NORMAL
- en: 'The idea is the same: rather than replacing a specific type (`int`), you’ve
    replaced a specific integral value (`10`) ➊➋➌. Now you can use the function with
    arrays of any size.'
  prefs: []
  type: TYPE_NORMAL
- en: Third, you can perform compile time bounds checking by taking `size_t index`
    as another non-type template parameter. This allows you to replace the `std::out_of_range`
    with a `static_assert`, as in [Listing 6-33](ch06.xhtml#ch06ex33).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 6-33: A program using compile time bounds-checked array accesses*'
  prefs: []
  type: TYPE_NORMAL
- en: You’ve moved the `size_t` index parameter into a non-type template parameter
    ➊ and updated the array access with the correct name `Index` ➌. Because `Index`
    is now a compile time constant, you also replace the `logic_error` with a `static_assert`,
    which prints the friendly message `Out-of-bounds access` whenever you accidentally
    try to access an out-of-bounds element ➋.
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 6-33](ch06.xhtml#ch06ex33) also contains example usage of get in `main`.
    You’ve first declared an `int` array `fib` of length 4 ➍. You then print the first
    three elements of the array using `get` ➎, set the fourth element ➏, and print
    it ➐. If you uncomment the out-of-bounds access ➑, the compiler will generate
    an error thanks to the `static_assert`.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Variadic Templates**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Sometimes, templates must take in an unknown number of arguments. The compiler
    knows these arguments at template instantiation, but you want to avoid having
    to write many different templates each for different numbers of arguments. This
    is the raison d’être of variadic templates. *Variadic templates* take a variable
    number of arguments.
  prefs: []
  type: TYPE_NORMAL
- en: You denote variadic templates using a final template parameter that has a special
    syntax, namely `typename... arguments`. The ellipsis indicates that `arguments`
    is a *parameter pack type*, meaning you can declare parameter packs within your
    template. A parameter pack is a template argument that accepts zero or more function
    arguments. These definitions can seem a bit abstruse, so consider the following
    sample variadic template that builds upon `SimpleUniquePointer`.
  prefs: []
  type: TYPE_NORMAL
- en: Recall from [Listing 6-14](ch06.xhtml#ch06ex14) that you pass a raw pointer
    into the constructor of `SimpleUniquePointer`. [Listing 6-34](ch06.xhtml#ch06ex34)
    implements a `make_simple_unique` function that handles construction of the underlying
    type.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 6-34: Implementing a `make_simple_unique` function to ease `SimpleUniquePointer`
    usage*'
  prefs: []
  type: TYPE_NORMAL
- en: You define the parameter pack type `Arguments` ➊, which declares `make_simple_unique`
    as a variadic template. This function passes arguments ➋ to the constructor of
    template parameter `T` ➌.
  prefs: []
  type: TYPE_NORMAL
- en: The upshot is you can now create `SimpleUniquePointers` very easily, even when
    the pointed-to object has a non-default constructor.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*There is a slightly more efficient implementation of [Listing 6-34](ch06.xhtml#ch06ex34).
    If `arguments` is an rvalue, you can move it directly into the constructor of
    `T`. The stdlib contains a function called `std::forward` in the `<utility>` header
    that will detect whether `arguments` is an lvalue or rvalue and perform a copy
    or move, respectively. See Item 23 in Effective Modern C++ by Scott Meyers.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**Advanced Template Topics**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: For everyday polymorphic programming, templates are your go-to tool. It turns
    out that templates are also used in a wide range of advanced settings, especially
    in implementing libraries, high-performance programs, and embedded system firmware.
    This section outlines some of the major terrain features of this vast space.
  prefs: []
  type: TYPE_NORMAL
- en: '***Template Specialization***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: To understand advanced template usage, you must first understand *template specialization*.
    Templates can actually take more than just `concept` and `typename` parameters
    (type parameters). They can also accept fundamental types, like `char` (value
    parameters), as well as other templates. Given the tremendous flexibility of template
    parameters, you can make a lot of compile-time decisions about their features.
    You could have different versions of templates depending on the characteristics
    of these parameters. For example, if a type parameter is `Ordered` instead of
    `Regular`, you might be able to make a generic program more efficient. Programming
    this way is called *template specialization*. Refer to the ISO standard [temp.spec]
    for more information about template specialization.
  prefs: []
  type: TYPE_NORMAL
- en: '***Name Binding***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Another critical component of how templates get instantiated is name binding.
    Name binding helps determine the rules for when the compiler matches a named element
    within a template to a concrete implementation. The named element could, for example,
    be part of the template definition, a local name, a global name, or from some
    named namespace. If you want to write heavily templated code, you need to understand
    how this binding occurs. If you’re in such a situation, refer to [Chapter 9](ch09.xhtml#ch09),
    “Names in Templates,” in *C++ Templates: The Complete Guide* by David Vandevoorde
    et al. and to [temp.res].'
  prefs: []
  type: TYPE_NORMAL
- en: '***Type Function***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: A *type function* takes types as arguments and returns a type. The type traits
    with which you build up concepts are closely related to type functions. You can
    combine type functions with compile time control structures to do general computation,
    such as programming control flow, at compile time. Generally, programming using
    these techniques is called *template metaprogramming*.
  prefs: []
  type: TYPE_NORMAL
- en: '***Template Metaprogramming***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Template metaprogramming has a deserved reputation for resulting in code that
    is exceedingly clever and absolutely inscrutable to all but the mightiest of wizards.
    Fortunately, once concepts are part of the C++ standard, template metaprogramming
    should become more approachable to us mere mortals. Until then, tread carefully.
    For those interested in further detail on this topic, refer to *Modern C++ Design:
    Generic Programming and Design Patterns Applied* by Andrei Alexandrescu and *C++
    Templates: The Complete Guide* by David Vandevoorde et al.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Template Source Code Organization**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Each time a template is instantiated, the compiler must be able to generate
    all the code necessary to use the template. This means all the information about
    how to instantiate a custom class or function must be available within the same
    translation unit as the template instantiation. By far, the most popular way to
    achieve this is to implement templates entirely within header files.
  prefs: []
  type: TYPE_NORMAL
- en: There are some modest inconveniences associated with this approach. Compile
    times can increase, because templates with the same parameters might get instantiated
    multiple times. It also decreases your ability to hide implementation details.
    Fortunately, the benefits of generic programming far outweigh these inconveniences.
    (Major compilers will probably minimize the problems of compile times and code
    duplication anyway.)
  prefs: []
  type: TYPE_NORMAL
- en: 'There are even a few advantages to having header-only templates:'
  prefs: []
  type: TYPE_NORMAL
- en: 'It’s very easy for others to use your code: it’s a matter of applying `#include`
    to some headers (rather than compiling the library, ensuring the resulting object
    files are visible to the linker, and so on).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It’s trivially easy for compilers to inline header-only templates, which can
    lead to faster code at runtime.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Compilers can generally do a better job of optimizing code when all of the source
    is available.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Polymorphism at Runtime vs. Compile Time**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When you want polymorphism, you should use templates. But sometimes you can’t
    use templates because you won’t know the types used with your code until runtime.
    Remember that template instantiation only occurs when you pair a template’s parameters
    with types. At this point, the compiler can instantiate a custom class for you.
    In some situations, you might not be able to perform such pairings until your
    program is executing (or, at least, performing such pairing at compile time would
    be tedious).
  prefs: []
  type: TYPE_NORMAL
- en: In such cases, you can use runtime polymorphism. Whereas the template is the
    mechanism for achieving compile-time polymorphism, the runtime mechanism is the
    interface.
  prefs: []
  type: TYPE_NORMAL
- en: '**Summary**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you explored polymorphism in C++. The chapter started with
    a discussion of what polymorphism is and why it’s so tremendously useful. You
    explored how to achieve polymorphism at compile time with templates. You learned
    about type checking with concepts and then explored some advanced topics, such
    as variadic templates and template metaprogramming.
  prefs: []
  type: TYPE_NORMAL
- en: '**EXERCISES**'
  prefs: []
  type: TYPE_NORMAL
- en: '**6-1.** The mode of a series of values is the value that appears most commonly.
    Implement a mode function using the following signature: `int mode(constint* values,
    size_t length)`. If you encounter an error condition, such as input having multiple
    modes and no values, return zero.'
  prefs: []
  type: TYPE_NORMAL
- en: '**6-2.** Implement `mode` as a template function.'
  prefs: []
  type: TYPE_NORMAL
- en: '**6-3.** Modify mode to accept an `Integer` concept. Verify that mode fails
    to instantiate with floating types like `double`.'
  prefs: []
  type: TYPE_NORMAL
- en: '**6-4.** Refactor `mean` in [Listing 6-13](ch06.xhtml#ch06ex13) to accept an
    array rather than pointer and length arguments. Use [Listing 6-33](ch06.xhtml#ch06ex33)
    as a guide.'
  prefs: []
  type: TYPE_NORMAL
- en: '**6-5.** Using the example from [Chapter 5](ch05.xhtml#ch05), make `Bank` a
    template class that accepts a template parameter. Use this type parameter as the
    type of an account rather than `long`. Verify that your code still works using
    a `Bank<long>` class.'
  prefs: []
  type: TYPE_NORMAL
- en: '**6-6.** Implement an `Account` class and instantiate a `Bank<Account>`. Implement
    functions in `Account` to keep track of balances.'
  prefs: []
  type: TYPE_NORMAL
- en: '**6-7.** Make `Account` an interface. Implement a `CheckingAccount` and `SavingsAccount`.
    Create a program with several checking and savings accounts. Use a `Bank<Account>`
    to make several transactions between the accounts.'
  prefs: []
  type: TYPE_NORMAL
- en: '**FURTHER READING**'
  prefs: []
  type: TYPE_NORMAL
- en: '*C++ Templates: The Complete Guide*, 2nd Edition, by David Vandevoorde, Nicolai
    M. Josuttis, and Douglas Gregor (Addison-Wesley, 2017)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Effective Modern C++: 42 Specific Ways to Improve Your Use of C++11 and C++14*
    by Scott Meyers (O’Reilly Media, 2015)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*The C++ Programming Language*, 4th Edition, by Bjarne Stroustrup (Pearson
    Education, 2013)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Modern C++ Design: Generic Programming and Design Patterns Applied* by Andrei
    Alexandrescu (Addison-Wesley, 2001)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
