- en: '**6'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '**6**'
- en: COMPILE-TIME POLYMORPHISM**
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '**编译时多态**'
- en: '*The more adapt, the more interesting you are.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: '*越灵活，越有趣。*'
- en: —Martha Stewart*
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: —玛莎·斯图尔特*
- en: '![Image](../images/common.jpg)'
  id: totrans-4
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/common.jpg)'
- en: In this chapter, you’ll learn how to achieve compile-time polymorphism with
    templates. You’ll learn how to declare and use templates, enforce type safety,
    and survey some of the templates’ more advanced usages. This chapter concludes
    with a comparison of runtime and compile-time polymorphism in C++.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将学习如何通过模板实现编译时多态。你将学习如何声明和使用模板，强制类型安全，并探讨模板的更多高级用法。本章最后会对 C++ 中的运行时多态和编译时多态进行比较。
- en: '**Templates**'
  id: totrans-6
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**模板**'
- en: C++ achieves compile-time polymorphism through *templates*. A template is a
    class or function with template parameters. These parameters can stand in for
    any type, including fundamental and user-defined types. When the compiler sees
    a template used with a type, it stamps out a bespoke template instantiation.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: C++ 通过*模板*实现编译时多态。模板是一个带有模板参数的类或函数。这些参数可以代表任何类型，包括基本类型和用户自定义类型。当编译器看到模板与某个类型一起使用时，它会生成一个专门的模板实例。
- en: '*Template instantiation* is the process of creating a class or a function from
    a template. Somewhat confusingly, you can also refer to “a template instantiation”
    as the result of the template instantiation process. Template instantiations are
    sometimes called concrete classes and concrete types.'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: '*模板实例化* 是从模板创建类或函数的过程。有些时候，令人困惑的是，你也可以将“模板实例化”称为模板实例化过程的结果。模板实例化有时被称为具体类和具体类型。'
- en: The big idea is that, rather than copying and pasting common code all over the
    place, you write a single template; the compiler generates new template instances
    when it encounters a new combination of types in the template parameters.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 这个大致的想法是，与其到处复制粘贴常见代码，不如编写一个模板；当编译器遇到模板参数的新类型组合时，它会生成新的模板实例。
- en: '**Declaring Templates**'
  id: totrans-10
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**声明模板**'
- en: You declare templates with a *template prefix*, which consists of the keyword
    `template` followed by angle brackets `< >`. Within the angle brackets, you place
    the declarations of one or more template parameters. You can declare template
    parameters using either the `typename` or `class` keywords followed by an identifier.
    For example, the template prefix `template<typename T>` declares that the template
    takes a template parameter `T`.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 你用一个*template前缀*来声明模板，前缀由关键字 `template` 和尖括号 `< >` 组成。在尖括号内，你放置一个或多个模板参数的声明。你可以使用
    `typename` 或 `class` 关键字后跟标识符来声明模板参数。例如，模板前缀 `template<typename T>` 表明该模板接受一个模板参数
    `T`。
- en: '**NOTE**'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*The coexistence of the `typename` and `class` keywords is unfortunate and
    confusing. They mean the same thing. (They’re both supported for historical reasons.)
    This chapter always uses `typename`.*'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '*`typename` 和 `class` 关键字的共存是不幸且令人困惑的。它们的意思相同。（由于历史原因，它们都被支持。）本章始终使用 `typename`。*'
- en: '***Template Class Definitions***'
  id: totrans-14
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***模板类定义***'
- en: 'Consider `MyTemplateClass` in [Listing 6-1](ch06.xhtml#ch06ex01), which takes
    three template parameters: `X, Y`, and `Z`.'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑 [列表 6-1](ch06.xhtml#ch06ex01) 中的 `MyTemplateClass`，它接受三个模板参数：`X`、`Y` 和 `Z`。
- en: '[PRE0]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '*Listing 6-1: A template class with three template parameters*'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 6-1：一个具有三个模板参数的模板类*'
- en: The `template` keyword ➊ begins the template prefix, which contains the template
    parameters ➋. This `template` preamble leads to something special about the remaining
    declaration of `MyTemplateClass` ➌. Within `MyTemplateClass`, you use `X, Y`,
    and `Z` as if they were any fully specified type, like an `int` or a user-defined
    class.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '`template` 关键字 ➊ 开始模板前缀，其中包含模板参数 ➋。这个 `template` 前言导致 `MyTemplateClass` ➌ 的剩余声明有些特别。在
    `MyTemplateClass` 中，你像使用任何完全指定的类型（如 `int` 或用户定义的类）一样使用 `X`、`Y` 和 `Z`。'
- en: The `foo` method takes a `Y` reference and returns an `X` ➍. You can declare
    members with types that include template parameters, like a pointer to `Z` ➎.
    Besides the special prefix beginning ➊, this template class is essentially identical
    to a non-template class.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '`foo` 方法接受一个 `Y` 引用并返回一个 `X` ➍。你可以声明包含模板参数的成员类型，比如指向 `Z` 的指针 ➎。除了特殊的前缀 ➊ 外，这个模板类与非模板类基本相同。'
- en: '***Template Function Definitions***'
  id: totrans-20
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***模板函数定义***'
- en: 'You can also specify template functions, like the `my_template_function` in
    [Listing 6-2](ch06.xhtml#ch06ex02) that also takes three template parameters:
    `X, Y`, and `Z`.'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以指定模板函数，比如在[列表 6-2](ch06.xhtml#ch06ex02)中也接受三个模板参数：`X`、`Y` 和 `Z` 的 `my_template_function`。
- en: '[PRE1]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '*Listing 6-2: A template function with three template parameters*'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 6-2：一个具有三个模板参数的模板函数*'
- en: Within the body of `my_template_function`, you can use `arg1` and `arg2` however
    you’d like, as long as you return an object of type `X`.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `my_template_function` 的函数体内，你可以根据需要使用 `arg1` 和 `arg2`，只要你返回一个类型为 `X` 的对象。
- en: '***Instantiating Templates***'
  id: totrans-25
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***实例化模板***'
- en: 'To instantiate a template class, use the following syntax:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 要实例化一个模板类，请使用以下语法：
- en: '[PRE2]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The tc_name ➊ is where you place the template class’s name. Next, you fill
    in your template parameters ➋. Finally, you treat this combination of template
    name and parameters as if it were a normal type: you use whatever initialization
    syntax you like ➌.'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: tc_name ➊ 是你放置模板类名称的地方。接下来，你填写你的模板参数 ➋。最后，你将模板名称和参数的组合视为普通类型：你可以使用任何初始化语法 ➌。
- en: 'Instantiating a template function is similar:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 实例化一个模板函数是类似的：
- en: '[PRE3]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The tf_name ➊ is where you put the template function’s name. You fill in the
    parameters just as you do for template classes ➋. You use the combination of template
    name and parameters as if it were a normal type. You invoke this template function
    instantiation with parentheses and function parameters ➌.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: tf_name ➊ 是你放置模板函数名称的地方。你按照模板类的方式填写参数 ➋。你将模板名称和参数的组合视为普通类型。你通过括号和函数参数来调用这个模板函数实例化
    ➌。
- en: All this new notation might be daunting to a newcomer, but it’s not so bad once
    you get used to it. In fact, it’s used in a set of language features called named
    conversion functions.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些新的符号对初学者来说可能很令人生畏，但一旦习惯了，就不会那么难。实际上，它们在一组语言特性中得到了应用，这些特性被称为命名转换函数。
- en: '**Named Conversion Functions**'
  id: totrans-33
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**命名转换函数**'
- en: '*Named conversions* are language features that explicitly convert one type
    into another type. You use named conversions sparingly in situations where you
    cannot use implicit conversions or constructors to get the types you need.'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '*命名转换* 是语言特性，用于显式地将一种类型转换为另一种类型。你在无法使用隐式转换或构造函数获取所需类型的情况下，谨慎使用命名转换。'
- en: 'All named conversions accept a single object parameter, which is the object
    you want to cast `object-to-cast`, and a single type parameter, which is the type
    you want to cast to `desired-type`:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 所有命名转换接受一个对象参数，即你希望转换的 `object-to-cast`，以及一个类型参数，即你希望转换成的目标类型 `desired-type`：
- en: '[PRE4]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: For example, if you need to modify a `const` object, you would first need to
    cast away the `const` qualifier. The named conversion function `const_cast` allows
    you to perform this operation. Other named conversions help you to reverse implicit
    casts (`static_cast`) or reinterpret memory with a different type (`reinterpret_cast`).
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果你需要修改一个 `const` 对象，你首先需要去掉 `const` 限定符。命名转换函数 `const_cast` 允许你执行此操作。其他命名转换帮助你逆转隐式转换（`static_cast`）或以不同类型重新解释内存（`reinterpret_cast`）。
- en: '**NOTE**'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*Although named conversion functions aren’t technically template functions,
    they are conceptually very close to templates—a relationship reflected in their
    syntactic similarity.*'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '*尽管命名转换函数在技术上不是模板函数，但它们在概念上与模板非常相似——这一关系体现在它们的语法相似性上。*'
- en: '***const_cast***'
  id: totrans-40
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***const_cast***'
- en: The `const_cast` function shucks away the `const` modifier, allowing the modification
    of `const` values. The `object-to-cast` is of some `const` type, and the desired-type
    is that type minus the `const` qualifier.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '`const_cast` 函数去掉了 `const` 修饰符，允许修改 `const` 值。`object-to-cast` 是某个 `const`
    类型的对象，所需的目标类型是去掉 `const` 限定符的该类型。'
- en: Consider the `carbon_thaw` function in [Listing 6-3](ch06.xhtml#ch06ex03), which
    takes a `const` reference to an `encased_solo` argument.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 请考虑[清单 6-3](ch06.xhtml#ch06ex03)中的 `carbon_thaw` 函数，它接受一个 `const` 引用的 `encased_solo`
    参数。
- en: '[PRE5]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '*Listing 6-3: A function using `const_cast`. Uncommenting yields a compiler
    error.*'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 6-3：使用 `const_cast` 的函数。取消注释会导致编译器错误。*'
- en: The `encased_solo` parameter is `const` ➊, so any attempt to modify it ➋ would
    result in a compiler error. You use `const_cast` ➌ to obtain the non-`const` reference
    `hibernation_sick_solo`. The `const_cast` takes a single template parameter, the
    type you want to cast into ➍. It also takes a function parameter, the object you
    want to remove `const` from ➎. You’re then free to modify the `int` pointed to
    by `encased_solo` via the new, non-`const` reference ➏.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '`encased_solo` 参数是 `const` ➊，因此任何试图修改它的行为 ➋ 都会导致编译器错误。你可以使用 `const_cast` ➌
    来获取非 `const` 引用 `hibernation_sick_solo`。`const_cast` 接受一个模板参数，即你希望转换为的类型 ➍。它还接受一个函数参数，即你希望去除
    `const` 的对象 ➎。然后，你就可以通过新的非 `const` 引用 ➏ 来修改 `encased_solo` 指向的 `int`。'
- en: Only use `const_cast` to obtain write access to `const` objects. Any other type
    conversion will result in a compiler error.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 只使用 `const_cast` 来获取对 `const` 对象的写访问权限。任何其他类型的转换都将导致编译错误。
- en: '**NOTE**'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*Trivially, you can use `const_cast` to add `const` to an object’s type, but
    you shouldn’t because it’s verbose and unnecessary. Use an implicit cast instead.
    In [Chapter 7](ch07.xhtml#ch07), you’ll learn what the `volatile` modifier is.
    You can also use `const_cast` to remove the `volatile` modifier from an object.*'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '*显然，你可以使用 `const_cast` 向对象的类型添加 `const`，但不应该这么做，因为它冗长且不必要。最好使用隐式转换。在 [第7章](ch07.xhtml#ch07)
    中，你将学习 `volatile` 修饰符是什么。你也可以使用 `const_cast` 从对象中移除 `volatile` 修饰符。*'
- en: '***static_cast***'
  id: totrans-49
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***static_cast***'
- en: The `static_cast` reverses a well-defined implicit conversion, such as an integer
    type to another integer type. The `object-to-cast` is of some type that the `desired-type`
    implicitly converts to. The reason you might need `static_cast` is that, generally,
    implicit casts aren’t reversible.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '`static_cast` 反转一个明确定义的隐式转换，例如整数类型到另一个整数类型。`object-to-cast` 是某种类型，`desired-type`
    可以隐式地转换成该类型。你可能需要使用 `static_cast` 的原因是，一般来说，隐式转换不可逆。'
- en: The program in [Listing 6-4](ch06.xhtml#ch06ex04) defines an `increment_as_short`
    function that takes a `void` pointer argument. It employs a `static_cast` to create
    a `short` pointer from this argument, increment the pointed-to `short`, and return
    the result. In some low-level applications, such as network programming or handling
    binary file formats, you might need to interpret raw bytes as an integer type.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 6-4](ch06.xhtml#ch06ex04) 中的程序定义了一个 `increment_as_short` 函数，该函数接受一个 `void`
    指针参数。它使用 `static_cast` 从这个参数创建一个 `short` 指针，递增指向的 `short`，并返回结果。在一些低级应用中，如网络编程或处理二进制文件格式，你可能需要将原始字节解释为整数类型。'
- en: '[PRE6]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '*Listing 6-4: A program using `static_cast`*'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '*示例 6-4：使用 `static_cast` 的程序*'
- en: The `target` parameter is a `void` pointer ➊. You employ `static_cast` to cast
    `target` into a `short*` ➋. The template parameter is the desired type ➌, and
    the function parameter is the object you want to cast into ➍.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '`target` 参数是一个 `void` 指针 ➊。你使用 `static_cast` 将 `target` 转换为 `short*` ➋。模板参数是所需的类型
    ➌，函数参数是你想要转换的对象 ➍。'
- en: 'Notice that the implicit conversion of `short*` to `void*` is well defined.
    Attempting ill-defined conversions with `static_cast`, such as converting a `char*`
    to a `float*`, will result in a compiler error:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`short*` 到 `void*` 的隐式转换是明确定义的。尝试使用 `static_cast` 进行未定义的转换，例如将 `char*` 转换为
    `float*`，将导致编译错误：
- en: '[PRE7]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: To perform such chainsaw juggling, you need to use `reinterpret_cast`.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 要执行这样的链锯杂技，你需要使用`reinterpret_cast`。
- en: '***reinterpret_cast***'
  id: totrans-58
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***reinterpret_cast***'
- en: Sometimes in low-level programming, you must perform type conversions that are
    not well defined. In system programming and especially in embedded environments,
    you often need complete control over how to interpret memory. The `reinterpret_cast`
    gives you such control, but ensuring the correctness of these conversions is entirely
    your responsibility.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 有时在低级编程中，你必须执行一些未定义类型转换。在系统编程中，尤其是在嵌入式环境下，你通常需要完全控制如何解释内存。`reinterpret_cast`
    给了你这种控制，但确保这些转换的正确性完全是你的责任。
- en: Suppose your embedded device keeps an `unsigned long` timer at memory address
    0x1000\. You could use `reinterpret_cast` to read from the timer, as demonstrated
    in [Listing 6-5](ch06.xhtml#ch06ex05).
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你的嵌入式设备在内存地址 0x1000 处保存了一个 `unsigned long` 类型的定时器。你可以使用 `reinterpret_cast`
    来读取定时器，正如 [示例 6-5](ch06.xhtml#ch06ex05) 中所示。
- en: '[PRE8]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '*Listing 6-5: A program using `reinterpret_cast`. This program will compile,
    but you should expect a runtime crash unless 0x1000 is readable.*'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '*示例 6-5：使用 `reinterpret_cast` 的程序。该程序将编译，但除非 0x1000 是可读的，否则你应预期程序在运行时崩溃。*'
- en: The `reinterpret_cast` ➊ takes a type parameter corresponding to the desired
    pointer type ➋ and the memory address the result should point to ➌.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '`reinterpret_cast` ➊ 需要一个类型参数，对应于所需的指针类型 ➋ 和结果应指向的内存地址 ➌。'
- en: 'Of course, the compiler has no idea whether the memory at address 0x1000 contains
    an `unsigned long`. It’s entirely up to you to ensure correctness. Because you’re
    taking full responsibility for this very dangerous construction, the compiler
    forces you to employ `reinterpret_cast`. You couldn’t, for example, replace the
    initialization of `timer` with the following line:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，编译器无法知道地址 0x1000 处的内存是否包含一个 `unsigned long`。完全由你负责确保正确性。因为你要为这个非常危险的构造承担全部责任，编译器强制你使用
    `reinterpret_cast`。例如，你不能将 `timer` 的初始化替换为以下行：
- en: '[PRE9]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The compiler will grumble about converting an `int` to a pointer.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 编译器会抱怨将`int`转换为指针。
- en: '***narrow_cast***'
  id: totrans-67
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***narrow_cast***'
- en: '[Listing 6-6](ch06.xhtml#ch06ex06) illustrates a custom `static_cast` that
    performs a runtime check for *narrowing*. Narrowing is a loss in information.
    Think about converting from an `int` to a `short`. As long as the value of `int`
    fits into a `short`, the conversion is reversible and no narrowing occurs. If
    the value of `int` is too big for the `short`, the conversion isn’t reversible
    and results in narrowing.'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 6-6](ch06.xhtml#ch06ex06)展示了一个自定义的`static_cast`，它执行运行时检查以检测*缩小*。缩小是信息丢失的过程。想象一下从`int`转换为`short`。只要`int`的值能适应`short`，转换就是可逆的，不会发生缩小。如果`int`的值太大，超出了`short`的最大值，那么转换就是不可逆的，会导致缩小。'
- en: Let’s implement a named conversion called `narrow_cast` that checks for narrowing
    and throws a `runtime_error` if it’s detected.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们实现一个名为`narrow_cast`的转换，它会检查缩小并在检测到时抛出`runtime_error`。
- en: '[PRE10]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '*Listing 6-6: A `narrow_cast` definition*'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 6-6：`narrow_cast`的定义*'
- en: 'The `narrow_cast` function template takes two template parameters: the type
    you’re casting `To` ➊ and the type you’re casting `From` ➋. You can see these
    template parameters in action as the return type of the function ➌ and the type
    of the parameter value ➍. First, you perform the requested conversion using `static_cast`
    to yield `converted` ➎. Next, you perform the conversion in the opposite direction
    (from `converted` to type `From`) to yield `backwards` ➏. If `value` doesn’t equal
    `backwards`, you’ve narrowed, so you throw an exception ➐. Otherwise, you return
    `converted` ➑.'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '`narrow_cast`函数模板有两个模板参数：您要转换的类型`To` ➊和您要转换的类型`From` ➋。您可以看到这些模板参数在函数的返回类型
    ➌ 和参数值的类型 ➍ 中的实际应用。首先，您使用`static_cast`执行请求的转换，得到`converted` ➎。接着，您将转换方向反转（从`converted`转换为类型`From`），得到`backwards`
    ➏。如果`value`不等于`backwards`，说明您进行了缩小，因此抛出一个异常 ➐。否则，返回`converted` ➑。'
- en: You can see `narrow_cast` in action in [Listing 6-7](ch06.xhtml#ch06ex07).
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在[列表 6-7](ch06.xhtml#ch06ex07)中看到`narrow_cast`的实际应用。
- en: '[PRE11]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '*Listing 6-7: A program using `narrow_cast`. (The output comes from an execution
    on Windows 10 x64.)*'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 6-7：使用`narrow_cast`的程序。（输出来自在Windows 10 x64上的执行。）*'
- en: You first initialize `perfect` to 496 ➊ and then `narrow_cast` it to the short
    `perfect_short` ➋. This proceeds without exception because the value 496 fits
    easily into a 2-byte short on Windows 10 x64 (maximum value 32767). You see the
    output as expected ➌. Next, you initialize `cyclic` to 142857 ➍ and attempt to
    `narrow_cast` to the short `cyclic_short` ➎. This throws a `runtime_error` because
    142857 is greater than the short’s maximum value of 32767\. The check within `narrow_cast`
    will fail. You see the exception printed in the `output` ➏.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，您将`perfect`初始化为496 ➊，然后将其`narrow_cast`为短整型`perfect_short` ➋。此操作不会出现异常，因为值496可以轻松适应Windows
    10 x64上的2字节`short`（最大值为32767）。您会看到预期的输出 ➌。接下来，您将`cyclic`初始化为142857 ➍，并尝试将其`narrow_cast`为短整型`cyclic_short`
    ➎。这会抛出一个`runtime_error`，因为142857大于`short`的最大值32767。`narrow_cast`中的检查会失败。您会在`output`中看到异常
    ➏。
- en: Notice that you need to provide only a single template parameter, the return
    type, upon instantiation ➋➎. The compiler can deduce the `From` parameter based
    on usage.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，在实例化时，您只需要提供一个模板参数，即返回类型 ➋➎。编译器可以根据使用情况推断出`From`参数。
- en: '**mean: A Template Function Example**'
  id: totrans-78
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**mean：模板函数示例**'
- en: Consider the function in [Listing 6-8](ch06.xhtml#ch06ex08) that computes the
    mean of a `double` array using the sum-and-divide approach.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 请参阅[列表 6-8](ch06.xhtml#ch06ex08)中计算`double`数组均值的函数，该函数使用求和除法方法。
- en: '[PRE12]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '*Listing 6-8: A function for computing the mean of an array*'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 6-8：计算数组均值的函数*'
- en: You initialize a `result` variable to zero ➊. Next, you sum over `values` by
    iterating over each index `i`, adding the corresponding element to `result` ➋.
    Then you divide `result` by `length` and `return` ➌.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 您将`result`变量初始化为零 ➊。接下来，通过遍历每个索引`i`，将对应的元素添加到`result`中 ➋。然后，您将`result`除以`length`并返回
    ➌。
- en: '***Genericizing mean***'
  id: totrans-83
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***泛型化均值***'
- en: Suppose you want to support `mean` calculations for other numeric types, such
    as `float` or `long`. You might be thinking, “That’s what function overloads are
    for!” Essentially, you would be correct.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 假设您想支持其他数值类型的`mean`计算，例如`float`或`long`。您可能会想，“这就是函数重载的作用！”从本质上来说，您是对的。
- en: '[Listing 6-9](ch06.xhtml#ch06ex09) overloads `mean` to accept a `long` array.
    The straightforward approach is to copy and paste the original, then replace instances
    of `double` with `long`.'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '[清单 6-9](ch06.xhtml#ch06ex09)重载了`mean`，使其接受一个`long`数组。最简单的方法是复制并粘贴原始代码，然后将`double`替换为`long`。'
- en: '[PRE13]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '*Listing 6-9: An overload of [Listing 6-8](ch06.xhtml#ch06ex08) accepting a
    `long` array*'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 6-9：[清单 6-8](ch06.xhtml#ch06ex08)的一个重载版本，接受`long`数组*'
- en: 'That sure is a lot of copying and pasting, and you’ve changed very little:
    the return type ➊, the function argument ➋, and `result` ➌.'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 这确实是大量的复制粘贴，而且你几乎没有做任何改变：返回类型➊，函数参数➋，以及`result` ➌。
- en: This approach doesn’t scale as you add more types. What if you want to support
    other integral types, such as `short` types or `uint_64` types? What about `float`
    types? What if, later on, you want to refactor some logic in `mean`? You’re in
    for a lot of tedious and error-prone maintenance.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 随着你添加更多类型，这种方法无法扩展。如果你想支持其他整型类型，比如`short`类型或`uint_64`类型怎么办？`float`类型呢？如果后来你想重构`mean`中的某些逻辑呢？你将面临大量繁琐且容易出错的维护工作。
- en: There are three changes to `mean` in [Listing 6-9](ch06.xhtml#ch06ex09), and
    all of them involve finding and replacing `double` types with `long` types. Ideally,
    you could have the compiler automatically generate versions of the function for
    you whenever it encounters usage with a different type. The key is that none of
    the logic changes—only the types.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在[清单 6-9](ch06.xhtml#ch06ex09)中，`mean`有三个更改，所有更改都涉及将`double`类型替换为`long`类型。理想情况下，每当编译器遇到不同类型的使用时，它可以自动为你生成该函数的版本。关键是逻辑没有变化——只是类型发生了变化。
- en: What you need to solve this copy-and-paste problem is *generic programming*,
    a programming style where you program with yet-to-be-specified types. You achieve
    generic programming using the support C++ has for templates. Templates allow the
    compiler to instantiate a custom class or function based on the types in use.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 解决这个复制粘贴问题所需要的是*泛型编程*，这是一种使用尚未指定的类型进行编程的编程风格。你可以利用C++对模板的支持实现泛型编程。模板允许编译器基于正在使用的类型实例化自定义类或函数。
- en: Now that you know how to declare templates, consider the `mean` function again.
    You still want `mean` to accept a wide range of types—not just `double` types—but
    you don’t want to have to copy and paste the same code over and over again.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你知道如何声明模板了，再看看`mean`函数。你仍然希望`mean`能够接受广泛的类型——不仅仅是`double`类型——但你不希望一遍又一遍地复制粘贴相同的代码。
- en: Consider how you can refactor [Listing 6-8](ch06.xhtml#ch06ex08) into a template
    function, as demonstrated in [Listing 6-10](ch06.xhtml#ch06ex10).
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑如何将[清单 6-8](ch06.xhtml#ch06ex08)重构为一个模板函数，正如[清单 6-10](ch06.xhtml#ch06ex10)中所演示的那样。
- en: '[PRE14]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '*Listing 6-10: Refactoring [Listing 6-8](ch06.xhtml#ch06ex08) into a template
    function*'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 6-10：将[清单 6-8](ch06.xhtml#ch06ex08)重构为模板函数*'
- en: '[Listing 6-10](ch06.xhtml#ch06ex10) kicks off with a template prefix ➊. This
    prefix communicates a single template parameter `T`. Next, you update `mean` to
    use `T` instead of `double` ➋➌➍.'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '[清单 6-10](ch06.xhtml#ch06ex10)以模板前缀➊开始。这个前缀传递了一个模板参数`T`。接下来，你更新`mean`，将`T`替换为`double`
    ➋➌➍。'
- en: Now you can use `mean` with many different types. Each time the compiler encounters
    a usage of `mean` with a new type, it performs template instantiation. It’s *as
    if* you had done the copy-paste-and-replace-types procedure, but the compiler
    is much better at doing detail-oriented, monotonous tasks than you are. Consider
    the example in [Listing 6-11](ch06.xhtml#ch06ex11), which computes means for `double,
    float`, and `size_t` types.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你可以用许多不同的类型来使用`mean`。每当编译器遇到使用新类型的`mean`时，它会执行模板实例化。这就*好像*你做了复制粘贴和替换类型的操作，但编译器在执行细节导向的、单调的任务上比你要强得多。考虑[清单
    6-11](ch06.xhtml#ch06ex11)中的示例，它计算`double`、`float`和`size_t`类型的均值。
- en: '[PRE15]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '*Listing 6-11: A program using the template function `mean`*'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 6-11：使用模板函数`mean`的程序*'
- en: Three templates are instantiated ➊➋➌; it’s as if you generated the overloads
    isolated in [Listing 6-12](ch06.xhtml#ch06ex12) by hand. (Each template instantiation
    contains types, shown in bold, where the compiler substituted a type for a template
    parameter.)
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 三个模板被实例化了➊➋➌；这就像你手动生成了[清单 6-12](ch06.xhtml#ch06ex12)中孤立的重载函数。（每个模板实例化包含了类型，类型以粗体显示，表示编译器为模板参数替换了类型。）
- en: '[PRE16]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '*Listing 6-12: The template instantiations for [Listing 6-11](ch06.xhtml#ch06ex11)*'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 6-12：为[清单 6-11](ch06.xhtml#ch06ex11)生成的模板实例化*'
- en: 'The compiler has done a lot of work for you, but you might have noticed that
    you had to type the pointed-to array type twice: once to declare an array and
    again to specify a template parameter. This gets tedious and can cause errors.
    If the template parameter doesn’t match, you’ll likely get a compiler error or
    cause unintended casting.'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 编译器为你做了很多工作，但你可能已经注意到，你必须两次输入指向数组的类型：一次是声明数组，另一次是指定模板参数。这变得很繁琐，并且可能导致错误。如果模板参数不匹配，通常会得到编译器错误或导致意外的类型转换。
- en: Fortunately, you can generally omit the template parameters when invoking a
    template function. The process that the compiler uses to determine the correct
    template parameters is called *template type deduction*.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，调用模板函数时通常可以省略模板参数。编译器用来确定正确模板参数的过程叫做*模板类型推导*。
- en: '***Template Type Deduction***'
  id: totrans-105
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***模板类型推导***'
- en: Generally, you don’t have to provide template function parameters. The compiler
    can deduce them from usage, so a rewrite of [Listing 6-11](ch06.xhtml#ch06ex11)
    without them is shown in [Listing 6-13](ch06.xhtml#ch06ex13).
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 通常情况下，你不需要提供模板函数的参数。编译器可以从使用情况中推导出这些参数，因此可以看到[清单6-11](ch06.xhtml#ch06ex11)在没有显式模板参数的情况下的重写版本，见[清单6-13](ch06.xhtml#ch06ex13)。
- en: '[PRE17]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '*Listing 6-13: A refactor of [Listing 6-11](ch06.xhtml#ch06ex11) without explicit
    template parameters*'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单6-13：一个没有显式模板参数的[清单6-11](ch06.xhtml#ch06ex11)重构版本*'
- en: It’s clear from usage that the template parameters are `double` ➊, `float` ➋,
    and `size_t` ➌.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 从使用情况来看，模板参数分别是`double` ➊、`float` ➋和`size_t` ➌。
- en: '**NOTE**'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*Template type deduction mostly works the way you might expect, but there is
    some nuance you’ll want to become familiar with if you’re writing a lot of generic
    code. For more information, see the ISO standard [temp]. Also, refer to Item 1
    of Effective Modern C++ by Scott Meyers and Section 23.5.1 of The C++ Programming
    Language, 4th Edition, by Bjarne Stroustrup.*'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '*模板类型推导通常按照你预期的方式工作，但如果你编写大量通用代码，你可能会遇到一些细节问题。有关更多信息，请参阅ISO标准[temp]。另外，参考Scott
    Meyers的《Effective Modern C++》中的第1条和Bjarne Stroustrup的《C++程序设计语言（第4版）》中的第23.5.1节。*'
- en: Sometimes, template arguments cannot be deduced. For example, if a template
    function’s return type is a template argument that’s entirely independent of other
    function and template arguments, you must specify template arguments explicitly.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，模板参数无法推导。例如，如果模板函数的返回类型是一个完全独立于其他函数和模板参数的模板参数，你必须显式指定模板参数。
- en: '**SimpleUniquePointer: A Template Class Example**'
  id: totrans-113
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**SimpleUniquePointer：一个模板类示例**'
- en: A *unique pointer* is an RAII wrapper around a free-store-allocated object.
    As its name suggests, the unique pointer has a single owner at a time, so when
    a unique pointer’s lifetime ends, the pointed-to object gets destructed.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '*唯一指针*是一个围绕自由存储分配对象的RAII封装器。正如其名称所示，唯一指针在任何时刻只有一个所有者，因此当唯一指针的生命周期结束时，所指向的对象会被销毁。'
- en: The underlying object’s type in unique pointers doesn’t matter, making them
    a prime candidate for a template class. Consider the implementation in [Listing
    6-14](ch06.xhtml#ch06ex14).
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 在唯一指针中，底层对象的类型并不重要，这使得它们成为模板类的理想候选。考虑[清单6-14](ch06.xhtml#ch06ex14)中的实现。
- en: '[PRE18]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '*Listing 6-14: A simple unique pointer implementation*'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单6-14：一个简单的唯一指针实现*'
- en: You announce the template class with a template prefix ➊, which establishes
    `T` as the wrapped object’s type. Next, you specify a default constructor using
    the `default` keyword ➋. (Recall from [Chapter 4](ch04.xhtml#ch04) that you need
    `default` when you want both a default constructor *and* a non-default constructor.)
    The generated default constructor will set the private member `T*` pointer to
    `nullptr` thanks to default initialization rules. You have a non-default constructor
    that takes a `T*` and sets the private member pointer ➌. Because the pointer is
    possibly `nullptr`, the destructor checks before deleting ➍.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 你通过一个模板前缀➊声明模板类，这样就确立了`T`作为封装对象的类型。接下来，使用`default`关键字➋指定默认构造函数。（回想一下[第4章](ch04.xhtml#ch04)，当你需要一个默认构造函数*和*一个非默认构造函数时，必须使用`default`。）生成的默认构造函数会根据默认初始化规则将私有成员`T*`指针初始化为`nullptr`。你还有一个非默认构造函数，它接受一个`T*`并将私有成员指针设置为➌。因为指针可能是`nullptr`，析构函数在删除之前会进行检查➍。
- en: Because you want to allow only a single owner of the pointed-to object, you
    `delete` the copy constructor and the copy-assignment operator ➎. This prevents
    double-free issues, which were discussed in [Chapter 4](ch04.xhtml#ch04). However,
    you can make your unique pointer moveable by adding a move constructor ➏. This
    steals the value of `pointer` from `other` and then sets the pointer of `other`
    to `nullptr`, handing responsibility of the pointed-to object to `this`. Once
    the move constructor returns, the moved-from object is destroyed. Because the
    moved-from object’s pointer is set to `nullptr`, the destructor will not delete
    the pointed-to object.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 因为你只想允许指向对象的唯一所有者，所以你删除了拷贝构造函数和拷贝赋值运算符 ➎。这样可以防止双重释放问题，正如在[第 4 章](ch04.xhtml#ch04)中讨论的那样。然而，你可以通过添加移动构造函数
    ➏ 来使你的唯一指针可移动。这会从 `other` 中窃取 `pointer` 的值，然后将 `other` 的指针设置为 `nullptr`，将指向对象的责任交给
    `this`。一旦移动构造函数返回，已移动的对象会被销毁。因为已移动对象的指针被设置为 `nullptr`，所以析构函数不会删除指向的对象。
- en: 'The possibility that `this` already owns an object complicates the move assignment
    ➐. You must check explicitly for prior ownership, because failure to delete a
    pointer leaks a resource. After this check, you perform the same operations as
    in the copy constructor: you set `pointer` to the value of `other.pointer` and
    then set `other.pointer` to `nullptr`. This ensures that the moved-from object
    doesn’t delete the pointed-to object.'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 `this` 可能已经拥有一个对象，这使得移动赋值变得复杂 ➐。你必须显式检查是否已经拥有该对象，因为如果未能删除指针，会导致资源泄漏。通过这次检查后，你执行与拷贝构造函数相同的操作：将
    `pointer` 设置为 `other.pointer` 的值，然后将 `other.pointer` 设置为 `nullptr`。这确保了被移动的对象不会删除指向的对象。
- en: You can obtain direct access to the underlying pointer by calling the `get`
    method ➑.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过调用 `get` 方法直接访问底层指针 ➑。
- en: Let’s enlist our old friend `Tracer` from [Listing 4-5](ch04.xhtml#ch04ex05)
    to investigate `SimpleUniquePointer`. Consider the program in [Listing 6-15](ch06.xhtml#ch06ex15).
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们请出老朋友 `Tracer`，它出现在[列表 4-5](ch04.xhtml#ch04ex05)中，来调查 `SimpleUniquePointer`。考虑一下[列表
    6-15](ch06.xhtml#ch06ex15)中的程序。
- en: '[PRE19]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '*Listing 6-15: A program investigating `SimpleUniquePointers` with the `Tracer`
    class*'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 6-15：一个使用 `Tracer` 类调查 `SimpleUniquePointers` 的程序*'
- en: First, you dynamically allocate a `Tracer` with the message `ptr_a`. This prints
    the first message ➊. You use the resulting `Tracer` pointer to construct a `SimpleUniquePointer`
    called `ptr_a`. Next, you use the `get()` method of `ptr_a` to retrieve the address
    of its `Tracer`, which you print ➍. Then you use `std::move` to relinquish the
    `Tracer` of `ptr_a` to the `consumer` function, which moves `ptr_a` into the `consumer_ptr`
    argument.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，你动态分配一个名为 `ptr_a` 的 `Tracer`。这会打印出第一条消息 ➊。然后，你使用得到的 `Tracer` 指针来构造一个名为 `ptr_a`
    的 `SimpleUniquePointer`。接下来，你使用 `ptr_a` 的 `get()` 方法来获取其 `Tracer` 的地址，并打印 ➍。然后你使用
    `std::move` 将 `ptr_a` 的 `Tracer` 转交给 `consumer` 函数，这会将 `ptr_a` 移动到 `consumer_ptr`
    参数中。
- en: Now, `consumer_ptr` owns the `Tracer`. You use the `get()` method of `consumer_ptr`
    to retrieve the address of `Tracer`, then print ➌. Notice this address matches
    the one printed at ➍. When `consumer` returns, `consumer_ptr` dies because its
    storage duration is the scope of `consumer`. As a result, `ptr_a` gets destructed
    ➋.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，`consumer_ptr` 拥有 `Tracer`。你使用 `consumer_ptr` 的 `get()` 方法来获取 `Tracer` 的地址，然后打印
    ➌。注意这个地址与 ➍ 打印的地址相同。当 `consumer` 返回时，`consumer_ptr` 被销毁，因为它的生命周期是 `consumer` 的作用域。因此，`ptr_a`
    会被析构 ➋。
- en: Recall that `ptr_a` is in a moved-from state—you moved its `Tracer` into `consumer`.
    You use the `get()` method of `ptr_a` to illustrate that it now holds a `nullptr`
    ➎.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，`ptr_a` 已经处于一个“已移动”状态——你已经将它的 `Tracer` 移动到 `consumer`。你使用 `ptr_a` 的 `get()`
    方法来说明它现在持有一个 `nullptr` ➎。
- en: Thanks to `SimpleUniquePointer`, you won’t leak a dynamically allocated object;
    also, because the `SimpleUniquePointer` is just carrying around a pointer under
    the hood, move semantics are efficient.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 由于有了 `SimpleUniquePointer`，你就不会泄漏一个动态分配的对象；此外，因为 `SimpleUniquePointer` 仅在背后携带一个指针，所以移动语义非常高效。
- en: '**NOTE**'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*The `SimpleUniquePointer` is a pedagogical implementation of the stdlib’s
    `std::unique_ptr`, which is a member of the family of RAII templates called smart
    pointers. You’ll learn about these in [Part II](part02.xhtml#part02).*'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '*`SimpleUniquePointer` 是对 stdlib 的 `std::unique_ptr` 的教学性实现，它是称为智能指针的 RAII
    模板家族的一员。你将在[第二部分](part02.xhtml#part02)中学习这些内容。*'
- en: '**Type Checking in Templates**'
  id: totrans-131
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**模板中的类型检查**'
- en: Templates are type safe. During template instantiation, the compiler pastes
    in the template parameters. If the resulting code is incorrect, the compiler will
    not generate the instantiation.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 模板是类型安全的。在模板实例化过程中，编译器将模板参数粘贴到模板中。如果生成的代码不正确，编译器将不会生成该实例化。
- en: Consider the template function in [Listing 6-16](ch06.xhtml#ch06ex16), which
    squares an element and returns the result.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑[列表 6-16](ch06.xhtml#ch06ex16)中的模板函数，它对一个元素进行平方并返回结果。
- en: '[PRE20]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '*Listing 6-16: A template function that squares a value*'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 6-16：一个对值进行平方的模板函数*'
- en: 'The `T` has a silent requirement: it must support multiplication ➊.'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '`T` 有一个隐式要求：它必须支持乘法 ➊。'
- en: If you try to use `square` with, say, a `char*`, the compilation will fail,
    as shown in [Listing 6-17](ch06.xhtml#ch06ex17).
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你尝试使用 `square`，例如使用 `char*`，编译将失败，如[列表 6-17](ch06.xhtml#ch06ex17)所示。
- en: '[PRE21]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '*Listing 6-17: A program with a failed template instantiation. (This program
    fails to compile.)*'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 6-17：一个模板实例化失败的程序。（这个程序无法编译。）*'
- en: Pointers don’t support multiplication, so template initialization fails ➊.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 指针不支持乘法，因此模板初始化失败 ➊。
- en: 'The square function is trivially small, but the failed template initialization’s
    error message isn’t. On MSVC v141, you get this:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '`square` 函数非常简单，但失败的模板初始化错误信息却不简单。在 MSVC v141 上，你会看到这个：'
- en: '[PRE22]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'And on GCC 7.3, you get this:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 在 GCC 7.3 上，你会看到这个：
- en: '[PRE23]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: These error messages exemplify the notoriously cryptic error messages emitted
    by template initialization failures.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 这些错误信息展示了模板初始化失败时 notoriously cryptic 的错误信息。
- en: Although template instantiation ensures type safety, the checking happens very
    late in the compilation process. When the compiler instantiates a template, it
    pastes the template parameter types into the template. After type insertion, the
    compiler attempts to compile the result. If instantiation fails, the compiler
    emits the dying words inside the template instantiation.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管模板实例化确保了类型安全，但检查发生在编译过程的非常晚阶段。当编译器实例化模板时，它将模板参数类型粘贴到模板中。类型插入之后，编译器尝试编译结果。如果实例化失败，编译器会在模板实例化内发出错误信息。
- en: C++ template programming shares similarities with *duck-typed languages*. Duck-typed
    languages (like Python) defer type checking until runtime. The underlying philosophy
    is that if an object looks like a duck and quacks like a duck, then it must be
    type duck. Unfortunately, this means you can’t generally know whether an object
    supports a particular operation until you execute the program.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: C++ 模板编程与*鸭子类型语言*有相似之处。鸭子类型语言（如 Python）会推迟类型检查，直到运行时。其基本哲学是，如果一个对象看起来像鸭子并且叫声像鸭子，那么它就应该是鸭子类型。不幸的是，这意味着你无法在程序执行之前判断一个对象是否支持某个特定操作。
- en: With templates, you cannot know whether an instantiation will succeed until
    you try to compile it. Although duck-typed languages might blow up at runtime,
    templates might blow up at compile time.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 使用模板时，直到你尝试编译它，你才知道实例化是否会成功。尽管鸭子类型语言可能会在运行时崩溃，但模板可能会在编译时崩溃。
- en: This situation is widely regarded as unacceptable by right-thinking people in
    the C++ community, so there is a splendid solution called *concepts*.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 这种情况在 C++ 社区中被认为是不可接受的，因此有一个精彩的解决方案，叫做*概念*。
- en: '**Concepts**'
  id: totrans-150
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**概念**'
- en: '*Concepts* constrain template parameters, allowing for parameter checking at
    the point of instantiation rather than the point of first use. By catching usage
    issues at the point of instantiation, the compiler can give you a friendly, informative
    error code—for example, “You tried to instantiate this template with a `char*`,
    but this template requires a type that supports multiplication.”'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: '*概念* 限制模板参数，允许在实例化时而不是首次使用时进行参数检查。通过在实例化时捕获使用问题，编译器可以为你提供友好的、有用的错误代码——例如，“你尝试使用
    `char*` 实例化这个模板，但该模板需要一个支持乘法的类型。”'
- en: Concepts allow you to express requirements on template parameters directly in
    the language.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 概念允许你直接在语言中表达模板参数的要求。
- en: 'Unfortunately, concepts aren’t yet officially part of the C++ standard, although
    they’ve been voted into C++ 20\. At press time, GCC 6.0 and later support the
    Concepts Technical Specification, and Microsoft is actively working toward implementing
    concepts in its C++ compiler, MSVC. Regardless of its unofficial status, it’s
    worth exploring concepts in some detail for a few reasons:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，概念尚未正式成为 C++ 标准的一部分，尽管它们已经被投票纳入 C++ 20。截止目前，GCC 6.0 及之后的版本支持概念技术规范，而微软正在积极努力在其
    C++ 编译器 MSVC 中实现概念。尽管它们还不是正式标准，但出于以下几个原因，深入了解概念是值得的：
- en: They’ll fundamentally change the way you achieve compile-time polymorphism.
    Familiarity with concepts will pay major dividends.
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们将从根本上改变你实现编译时多态性的方法。熟悉概念将带来巨大的回报。
- en: They provide a conceptual framework for understanding some of the makeshift
    solutions that you can put in place to get better compiler errors when templates
    are misused.
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们提供了一个概念框架，用于理解在模板被误用时，你可以采取的一些临时解决方案，以获得更好的编译器错误信息。
- en: They provide an excellent conceptual bridge from compile-time templates to interfaces,
    the primary mechanism for runtime polymorphism (covered in [Chapter 5](ch05.xhtml#ch05)).
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们提供了从编译时模板到接口的优秀概念桥梁，接口是实现运行时多态性的主要机制（详见[第5章](ch05.xhtml#ch05)）。
- en: If you can use GCC 6.0 or later, concepts *are* available by turning on the
    `-fconcepts` compiler flag.
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你可以使用GCC 6.0或更高版本，概念*是*可用的，只需启用`-fconcepts`编译器标志。
- en: '**WARNING**'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: '**警告**'
- en: '*C++ 20’s final concept specification will almost certainly deviate from the
    Concepts Technical Specification. This section presents concepts as specified
    in the Concepts Technical Specification so you can follow along.*'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: '*C++ 20的最终概念规范几乎肯定会与概念技术规范有所不同。本节介绍了根据概念技术规范指定的概念，以便你可以跟上。*'
- en: '***Defining a Concept***'
  id: totrans-160
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***定义一个概念***'
- en: 'A concept is a template. It’s a constant expression involving template arguments,
    evaluated at compile time. Think of a concept as one big *predicate*: a function
    that evaluates to `true` or `false`.'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 概念是一个模板。它是一个常量表达式，涉及模板参数，在编译时评估。把概念看作是一个大的*谓词*：一个评估为`true`或`false`的函数。
- en: If a set of template parameters meets the criteria for a given concept, that
    concept evaluates to `true` when instantiated with those parameters; otherwise,
    it will evaluate to `false`. When a concept evaluates to `false`, template instantiation
    fails.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一组模板参数符合给定概念的标准，那么在用这些参数实例化时，该概念会评估为`true`；否则，评估为`false`。当概念评估为`false`时，模板实例化将失败。
- en: 'You declare concepts using the keyword `concept` on an otherwise familiar template
    function definition:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用关键字`concept`声明概念，语法与常规模板函数定义类似：
- en: '[PRE24]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '***Type Traits***'
  id: totrans-165
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***类型特征***'
- en: Concepts validate type parameters. Within concepts, you manipulate types to
    inspect their properties. You can hand roll these manipulations, or you can use
    the type support library built into the stdlib. The library contains utilities
    for inspecting type properties. These utilities are collectively called *type
    traits*. They’re available in the `<type_traits>` header and are part of the `std`
    namespace. [Table 6-1](ch06.xhtml#ch06tab01) lists some commonly used type traits.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 概念验证类型参数。在概念中，你操作类型以检查其属性。你可以手动实现这些操作，也可以使用标准库中内建的类型支持库。该库包含检查类型属性的工具，这些工具统称为*类型特征*。它们可以在`<type_traits>`头文件中找到，并且属于`std`命名空间。[表6-1](ch06.xhtml#ch06tab01)列出了常用的类型特征。
- en: '**NOTE**'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: '**备注**'
- en: '*See Chapter 5.4 of The C++ Standard Library, 2nd Edition, by Nicolai M. Josuttis
    for an exhaustive listing of type traits available in the stdlib.*'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: '*有关标准库中可用的类型特征的详细列表，请参见Nicolai M. Josuttis的《C++标准库》第2版第5.4章。*'
- en: '**Table 6-1:** Selected Type Traits from the `<type_traits>` Header'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: '**表6-1：** 选自`<type_traits>`头文件的类型特征'
- en: '| **Type trait** | **Checks if template argument is …** |'
  id: totrans-170
  prefs: []
  type: TYPE_TB
  zh: '| **类型特征** | **检查模板参数是否是…** |'
- en: '| `is_void` | `void` |'
  id: totrans-171
  prefs: []
  type: TYPE_TB
  zh: '| `is_void` | `void` |'
- en: '| `is_null_pointer` | `nullptr` |'
  id: totrans-172
  prefs: []
  type: TYPE_TB
  zh: '| `is_null_pointer` | `nullptr` |'
- en: '| `is_integral` | `bool`, a `char` type, an `int` type, a `short` type, a `long`
    type, or a `long long` type |'
  id: totrans-173
  prefs: []
  type: TYPE_TB
  zh: '| `is_integral` | `bool`、`char`类型、`int`类型、`short`类型、`long`类型或`long long`类型
    |'
- en: '| `is_floating_point` | `float`, `double`, or `long double` |'
  id: totrans-174
  prefs: []
  type: TYPE_TB
  zh: '| `is_floating_point` | `float`、`double`或`long double` |'
- en: '| `is_fundamental` | Any of `is_void`, `is_null_pointer`, `is_integral`, or
    `is_floating_point` |'
  id: totrans-175
  prefs: []
  type: TYPE_TB
  zh: '| `is_fundamental` | 任何一个`is_void`、`is_null_pointer`、`is_integral`或`is_floating_point`
    |'
- en: '| `is_array` | An array; that is, a type containing square brackets `[]` |'
  id: totrans-176
  prefs: []
  type: TYPE_TB
  zh: '| `is_array` | 数组类型；即包含方括号`[]`的类型 |'
- en: '| `is_enum` | An enumeration type (`enum`) |'
  id: totrans-177
  prefs: []
  type: TYPE_TB
  zh: '| `is_enum` | 枚举类型（`enum`） |'
- en: '| `is_class` | A class type (but not a union type) |'
  id: totrans-178
  prefs: []
  type: TYPE_TB
  zh: '| `is_class` | 类类型（但不是联合类型） |'
- en: '| `is_function` | A function |'
  id: totrans-179
  prefs: []
  type: TYPE_TB
  zh: '| `is_function` | 函数类型 |'
- en: '| `is_pointer` | A pointer; function pointers count, but pointers to class
    members and `nullptr` do not |'
  id: totrans-180
  prefs: []
  type: TYPE_TB
  zh: '| `is_pointer` | 指针；包括函数指针，但不包括类成员指针和`nullptr` |'
- en: '| `is_reference` | A reference (either lvalue or rvalue) |'
  id: totrans-181
  prefs: []
  type: TYPE_TB
  zh: '| `is_reference` | 引用类型（包括左值和右值） |'
- en: '| `is_arithmetic` | `is_floating_point` or `is_integral` |'
  id: totrans-182
  prefs: []
  type: TYPE_TB
  zh: '| `is_arithmetic` | `is_floating_point`或`is_integral` |'
- en: '|  `is_pod`  | A plain-old-data type; that is, a type that can be represented
    as a data type in plain C |'
  id: totrans-183
  prefs: []
  type: TYPE_TB
  zh: '|  `is_pod`  | 一个简单的旧数据类型；即，可以作为普通C中的数据类型表示的类型 |'
- en: '| `is_default_constructible` | Default constructible; that is, it can be constructed
    without arguments or initialization values |'
  id: totrans-184
  prefs: []
  type: TYPE_TB
  zh: '| `is_default_constructible` | 可以默认构造；即，可以没有参数或初始化值地构造 |'
- en: '| `is_constructible` | Constructible with the given template parameters: this
    type trait allows the user to provide additional template parameters beyond the
    type under consideration |'
  id: totrans-185
  prefs: []
  type: TYPE_TB
  zh: '| `is_constructible` | 是否可以使用给定的模板参数构造：此类型特征允许用户提供超出当前考虑类型的其他模板参数 |'
- en: '| `is_copy_constructible` | Copy constructible |'
  id: totrans-186
  prefs: []
  type: TYPE_TB
  zh: '| `is_copy_constructible` | 可以通过复制构造 |'
- en: '| `is_move_constructible` | Move constructible |'
  id: totrans-187
  prefs: []
  type: TYPE_TB
  zh: '| `is_move_constructible` | 可以通过移动构造 |'
- en: '| `is_destructible` | Destructible |'
  id: totrans-188
  prefs: []
  type: TYPE_TB
  zh: '| `is_destructible` | 是否可以析构 |'
- en: '| `is_same` | The same type as the additional template parameter type (including
    const and volatile modifiers) |'
  id: totrans-189
  prefs: []
  type: TYPE_TB
  zh: '| `is_same` | 与附加模板参数类型相同（包括`const`和`volatile`修饰符） |'
- en: '| `is_invocable` | Invocable with the given template parameters: this type
    trait allows the user to provide additional template parameters beyond the type
    under consideration |'
  id: totrans-190
  prefs: []
  type: TYPE_TB
  zh: '| `is_invocable` | 可以使用给定的模板参数调用：此类型特征允许用户提供超出当前考虑类型的其他模板参数 |'
- en: Each type trait is a template class that takes a single template parameter,
    the type you want to inspect. You extract the results using the template’s static
    member `value`. This member equals `true` if the type parameter meets the criteria;
    otherwise, it’s `false`.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 每个类型特征都是一个模板类，接受一个模板参数，即你想要检查的类型。你可以通过模板的静态成员`value`提取结果。如果类型参数满足条件，该成员的值为`true`；否则为`false`。
- en: Consider the type trait classes `is_integral` and `is_floating_point`. These
    are useful for checking if a type is (you guessed it) integral or floating point.
    Both of these templates take a single template parameter. The example in [Listing
    6-18](ch06.xhtml#ch06ex18) investigates type traits with several types.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑类型特征类`is_integral`和`is_floating_point`。它们用于检查一个类型是否是（你猜对了）整数类型或浮点类型。这两个模板都接受一个模板参数。在[清单
    6-18](ch06.xhtml#ch06ex18)中的示例检查了多个类型的类型特征。
- en: '[PRE25]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '*Listing 6-18: A program using type traits*'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 6-18：使用类型特征的程序*'
- en: '[Listing 6-18](ch06.xhtml#ch06ex18) defines the convenience function `as_str`
    ➊ to print Boolean values with the string `True` or `False`. Within `main`, you
    print the result of various type trait instantiations. The template parameters
    `int` ➋, const int ➌, char ➍, and `uint64_t` ➎ all return `true` when passed to
    `is_integral`. Reference types ➏➐ and floating-point types ➑ return `false`.'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: '[清单 6-18](ch06.xhtml#ch06ex18)定义了便捷函数`as_str` ➊，用来打印布尔值，返回字符串`True`或`False`。在`main`函数中，你打印了各种类型特征实例化的结果。模板参数`int`
    ➋、`const int` ➌、`char` ➍和`uint64_t` ➎传递给`is_integral`时，都会返回`true`。引用类型 ➏➐ 和浮点类型
    ➑ 返回`false`。'
- en: '**NOTE**'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*Recall that `printf` doesn’t have a format specifier for `bool`. Rather than
    using the integer format specifier `%d` as a stand-in, [Listing 6-18](ch06.xhtml#ch06ex18)
    employs the `as_str` function, which returns the string literal `True` or `False`
    depending on the value of the `bool`. Because these values are string literals,
    you can capitalize them however you like*.'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: '*请记住，`printf`没有为`bool`类型提供格式说明符。与其使用整数格式说明符`%d`作为替代，[清单 6-18](ch06.xhtml#ch06ex18)使用了`as_str`函数，根据`bool`的值返回字符串字面量`True`或`False`。由于这些值是字符串字面量，你可以根据需要对它们进行大小写转换*。'
- en: Type traits are often the building blocks for a concept, but sometimes you need
    more flexibility. Type traits tell you *what* types are, but sometimes you must
    also specify *how* the template will use them. For this, you use requirements.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 类型特征通常是概念的构建块，但有时你需要更多的灵活性。类型特征告诉你*什么*类型是，但有时你还必须指定模板如何使用这些类型。为此，你需要使用要求（requirements）。
- en: '***Requirements***'
  id: totrans-199
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***要求***'
- en: '*Requirements* are ad hoc constraints on template parameters. Each concept
    can specify any number of requirements on its template parameters. Requirements
    are encoded into requires expressions denoted by the `requires` keyword followed
    by function arguments and a body.'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: '*要求*是对模板参数的临时约束。每个概念可以为其模板参数指定任意数量的要求。要求被编码为`requires`关键字后跟函数参数和主体的要求表达式。'
- en: 'A sequence of syntactic requirements comprises the requirements expression’s
    body. Each syntactic requirement puts a constraint on the template parameters.
    Together, requires expressions have the following form:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 一系列语法要求构成了要求表达式的主体。每个语法要求对模板参数施加约束。要求表达式的形式如下：
- en: '[PRE26]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Requires expressions take arguments that you place after the `requires` keyword
    ➊. These arguments have types derived from template parameters. The syntactic
    requirements follow, each denoted with `{ } ->`. You put an arbitrary expression
    within each of the braces ➋. This expression can involve any number of the arguments
    to the argument expression.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: '`requires`表达式接受你在`requires`关键字后面放置的参数 ➊。这些参数的类型来源于模板参数。接下来是语法要求，每个要求用`{ } ->`表示。你在每对大括号内放置一个任意表达式
    ➋。这个表达式可以涉及任何数量的参数表达式。'
- en: If an instantiation causes a syntactic expression not to compile, that syntactic
    requirement fails. Supposing the expression evaluates without error, the next
    check is whether the return type of that expression matches the type given after
    the arrow `->` ➌. If the expression result’s evaluated type can’t implicitly convert
    to the return type ➌, the syntactic requirement fails.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 如果实例化导致语法表达式无法编译，则该语法要求失败。假设表达式在没有错误的情况下计算，接下来的检查是该表达式的返回类型是否与箭头`->`后面的类型匹配
    ➌。如果表达式结果的计算类型不能隐式转换为返回类型 ➌，则语法要求失败。
- en: If any of the syntactic requirements fail, the requires expression evaluates
    to `false`. If all of the syntactic requirements pass, the requires expression
    evaluates to `true`.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 如果任何语法要求失败，`requires`表达式的求值结果为`false`。如果所有语法要求都通过，`requires`表达式的求值结果为`true`。
- en: Suppose you have two types, `T` and `U`, and you want to know whether you can
    compare objects of these types using the equality `==` and inequality `!=` operators.
    One way to encode this requirement is to use the following expression.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你有两种类型，`T`和`U`，你想知道是否可以使用相等`==`和不等`!=`运算符比较这两种类型的对象。编码此要求的一种方法是使用以下表达式。
- en: '[PRE27]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: The requires expression takes two arguments, one each of types `T` and `U`.
    Each of the syntactic requirements contained in the requires expression is an
    expression using `t` and `u` with either `==` or `!=`. All four syntactic requirements
    enforce a `bool` result. Any two types that satisfy this requires expression are
    guaranteed to support comparison with `==` and `!=`.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: '`requires`表达式接受两个参数，每个参数的类型分别为`T`和`U`。`requires`表达式中的每个语法要求都是使用`t`和`u`进行`==`或`!=`比较的表达式。所有四个语法要求都强制要求返回`bool`类型的结果。任何两个满足该`requires`表达式的类型，都能保证支持`==`和`!=`的比较。'
- en: '***Building Concepts from Requires Expressions***'
  id: totrans-209
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***从Requires表达式构建概念***'
- en: Because requires expressions are evaluated at compile time, concepts can contain
    any number of them. Try to construct a concept that guards against the misuse
    of `mean`. [Listing 6-19](ch06.xhtml#ch06ex19) annotates some of the implicit
    requirements used earlier in [Listing 6-10](ch06.xhtml#ch06ex10).
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 因为`requires`表达式在编译时求值，概念可以包含任意数量的它们。尝试构造一个防止误用`mean`的概念。[清单6-19](ch06.xhtml#ch06ex19)注释了一些之前在[清单6-10](ch06.xhtml#ch06ex10)中使用的隐式要求。
- en: '[PRE28]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '*Listing 6-19: A relisting of 6-10 with annotations for some implicit requirements
    on `T`*'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单6-19：带有对`T`隐式要求的注释的6-10重新列出*'
- en: 'You can see three requirements implied by this code:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到这段代码暗示了三个要求：
- en: '`T` must be default constructible ➊.'
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`T`必须是默认可构造的 ➊。'
- en: '`T` supports `operator+=` ➋.'
  id: totrans-215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`T`支持`operator+=` ➋。'
- en: Dividing a `T` by a `size_t` yields a `T` ➌.
  id: totrans-216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将一个`T`除以一个`size_t`得到一个`T` ➌。
- en: From these requirements, you could create a concept called `Averageable`, as
    demonstrated in [Listing 6-20](ch06.xhtml#ch06ex20).
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 从这些要求中，你可以创建一个名为`Averageable`的概念，正如[清单6-20](ch06.xhtml#ch06ex20)中演示的那样。
- en: '[PRE29]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '*Listing 6-20: An `Averageable` concept. Annotations are consistent with the
    requirements and the body of `mean`.*'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单6-20：一个`Averageable`概念。注释与要求和`mean`的主体一致。*'
- en: You use the type trait `is_default_constructible` to ensure that `T` is default
    constructible ➊, that you can add two `T` types ➋, and that you can divide a `T`
    by a `size_t` ➌ and get a result of type `T`.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 你使用类型特性`is_default_constructible`来确保`T`是默认可构造的 ➊，可以对两个`T`类型进行加法操作 ➋，并且能够将`T`除以`size_t`
    ➌并得到`T`类型的结果。
- en: Recall that concepts are just predicates; you’re building a Boolean expression
    that evaluates to `true` when the template parameters are supported and `false`
    when they’re not. The concept is composed of a type trait ➊ and a requires containing
    two requirement expressions ➋➌. If any of the three returns `false`, the concept’s
    constraints are not met.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，概念只是谓词；你正在构建一个布尔表达式，当模板参数被支持时，它返回`true`，而当不被支持时，它返回`false`。这个概念由一个类型特性 ➊
    和一个包含两个要求表达式 ➋➌ 的`requires`组成。如果三个要求中的任何一个返回`false`，那么该概念的约束未被满足。
- en: '***Using Concepts***'
  id: totrans-222
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***使用概念***'
- en: Declaring concepts is a lot more work than using them. To use a concept, just
    use the concept’s name in place of the `typename` keyword.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 声明概念比使用它们要麻烦得多。要使用一个概念，只需在`typename`关键字的位置使用该概念的名称。
- en: For example, you can refactor [Listing 6-13](ch06.xhtml#ch06ex13) with the `Averageable`
    concept, as shown in [Listing 6-21](ch06.xhtml#ch06ex21).
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，你可以通过`Averageable`概念重构[清单 6-13](ch06.xhtml#ch06ex13)，如[清单 6-21](ch06.xhtml#ch06ex21)所示。
- en: '[PRE30]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '*Listing 6-21: A refactor of [Listing 6-13](ch06.xhtml#ch06ex13) using `Averageable`*'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 6-21：使用`Averageable`重构[清单 6-13](ch06.xhtml#ch06ex13)*'
- en: After defining `Averageable` ➊, you just use it in place of `typename` ➋. No
    further modification is necessary. The code generated from compiling [Listing
    6-13](ch06.xhtml#ch06ex13) is identical to the code generated from compiling [Listing
    6-21](ch06.xhtml#ch06ex21).
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 定义`Averageable` ➊后，你只需将其替代`typename` ➋使用即可。无需进一步修改。从编译[清单 6-13](ch06.xhtml#ch06ex13)生成的代码与从编译[清单
    6-21](ch06.xhtml#ch06ex21)生成的代码是完全相同的。
- en: 'The payoff is when you get to try to use `mean` with a type that is not `Averageable`:
    you get a compiler error at the point of instantiation. This produces much better
    compiler error messages than you would obtain from a raw template.'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 其回报是在你尝试使用一个非`Averageable`类型的`mean`时：你会在实例化时收到编译器错误。这比你从原始模板中得到的编译器错误信息要清晰得多。
- en: Look at the instantiation of `mean` in [Listing 6-22](ch06.xhtml#ch06ex22) where
    you “accidentally” try to average an array of `double` pointers.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 看看在[清单 6-22](ch06.xhtml#ch06ex22)中`mean`的实例化，在那里你“意外”尝试对`double`指针数组求平均值。
- en: '[PRE31]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: '*Listing 6-22: A bad template instantiation using a non-`Averageable` argument*'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 6-22：使用非`Averageable`参数的错误模板实例化*'
- en: There are several problems with using `values` ➊. What can the compiler tell
    you about those problems?
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`values` ➊时存在几个问题。编译器能告诉你这些问题吗？
- en: Without concepts, GCC 6.3 produces the error message shown in [Listing 6-23](ch06.xhtml#ch06ex23).
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有概念，GCC 6.3会产生[清单 6-23](ch06.xhtml#ch06ex23)中显示的错误信息。
- en: '[PRE32]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: '*Listing 6-23: Error message from GCC 6.3 when compiling [Listing 6-22](ch06.xhtml#ch06ex22)*'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 6-23：使用GCC 6.3编译[清单 6-22](ch06.xhtml#ch06ex22)时的错误信息*'
- en: You might expect a casual user of `mean` to be extremely confused by this error
    message. What is `i` ➊? Why is a `const double*` involved in division ➋?
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会觉得`mean`的普通用户看到这个错误信息时会非常困惑。`i` ➊是什么？为什么`const double*`会参与到除法运算中 ➋？
- en: Concepts provide a far more illuminating error message, as [Listing 6-24](ch06.xhtml#ch06ex24)
    demonstrates.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 概念提供了更具启发性的错误信息，正如[清单 6-24](ch06.xhtml#ch06ex24)所展示的那样。
- en: '[PRE33]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: '*Listing 6-24: Error message from GCC 7.2 when compiling [Listing 6-22](ch06.xhtml#ch06ex22)
    with concepts enabled*'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 6-24：使用GCC 7.2编译启用概念的[清单 6-22](ch06.xhtml#ch06ex22)时的错误信息*'
- en: This error message is fantastic. The compiler tells you which argument (`values`)
    didn’t meet a constraint ➊. Then it tells you that `values` is not `Averageable`
    because it doesn’t satisfy two required expressions ➋➌. You know immediately how
    to modify your arguments to make this template instantiation successful.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 这个错误信息非常棒。编译器告诉你哪个参数（`values`）没有满足某个约束 ➊。然后它告诉你`values`不是`Averageable`，因为它没有满足两个必需的表达式
    ➋➌。你立刻知道如何修改你的参数，以便成功实例化这个模板。
- en: When concepts incorporate into the C++ standard, it’s likely that the stdlib
    will include many concepts. The design goal of concepts is that a programmer shouldn’t
    have to define very many concepts on their own; rather, they should be able to
    combine concepts and ad hoc requirements within a template prefix. [Table 6-2](ch06.xhtml#ch06tab02)
    provides a partial listing of some concepts you might expect to be included; these
    are borrowed from Andrew Sutton’s implementation of concepts in the Origins Library.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 当概念被纳入C++标准时，std库可能会包含许多概念。概念的设计目标是程序员不必自己定义太多的概念；相反，他们应该能够在模板前缀中组合概念和临时需求。[表
    6-2](ch06.xhtml#ch06tab02)提供了你可能期望包含的一些概念的部分列表，这些概念借用了Andrew Sutton在Origins库中实现的概念。
- en: '**NOTE**'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*See [https://github.com/asutton/origin/](https://github.com/asutton/origin/)
    for more information on the Origins Library. To compile the examples that follow,
    you can install Origins and use GCC version 6.0 or later with the `-fconcepts`
    flag.*'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: '*请参见[https://github.com/asutton/origin/](https://github.com/asutton/origin/)了解更多关于Origins库的信息。要编译接下来的示例，你可以安装Origins并使用GCC
    6.0或更高版本，并加上`-fconcepts`标志。*'
- en: '**Table 6-2:** The Concepts Contained in the Origins Library'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: '**表 6-2：**Origins库中包含的概念'
- en: '| **Concept** | **A type that …** |'
  id: totrans-245
  prefs: []
  type: TYPE_TB
  zh: '| **概念** | **一种类型，其…** |'
- en: '| `Conditional` | Can be explicitly converted to `bool` |'
  id: totrans-246
  prefs: []
  type: TYPE_TB
  zh: '| `Conditional` | 可以显式转换为 `bool` |'
- en: '| `Boolean` | Is `Conditional` and supports `!`, `&&`, and `&#124;&#124;` Boolean
    operations |'
  id: totrans-247
  prefs: []
  type: TYPE_TB
  zh: '| `Boolean` | 是 `Conditional` 并支持 `!`、`&&` 和 `&#124;&#124;` 布尔运算 |'
- en: '| `Equality_comparable` | Supports `==` and `!=` operations returning a `Boolean`
    |'
  id: totrans-248
  prefs: []
  type: TYPE_TB
  zh: '| `Equality_comparable` | 支持 `==` 和 `!=` 操作，返回一个 `Boolean` |'
- en: '| `Destructible` | Can be destroyed (compare `is_destructible`) |'
  id: totrans-249
  prefs: []
  type: TYPE_TB
  zh: '| `Destructible` | 可以被销毁（比较 `is_destructible`） |'
- en: '| `Default_constructible` | Is default constructible (compare `is_default_constructible`)
    |'
  id: totrans-250
  prefs: []
  type: TYPE_TB
  zh: '| `Default_constructible` | 可以默认构造（比较 `is_default_constructible`） |'
- en: '| `Movable` | Supports move semantics: it must be move assignable and move
    constructible (compare `is_move_assignable`, `is_move_constructible`) |'
  id: totrans-251
  prefs: []
  type: TYPE_TB
  zh: '| `Movable` | 支持移动语义：它必须是可移动赋值和可移动构造的（比较 `is_move_assignable`，`is_move_constructible`）
    |'
- en: '| `Copyable` | Supports copy semantics: it must be copy assignable and copy
    constructible (compare `is_copy_assignable`, `is_copy_constructible`) |'
  id: totrans-252
  prefs: []
  type: TYPE_TB
  zh: '| `Copyable` | 支持复制语义：它必须是可复制赋值和可复制构造的（比较 `is_copy_assignable`，`is_copy_constructible`）
    |'
- en: '| `Regular` | Is default constructible, copyable, and `Equality_comparable`
    |'
  id: totrans-253
  prefs: []
  type: TYPE_TB
  zh: '| `Regular` | 是默认可构造的，可复制的，并且是 `Equality_comparable` |'
- en: '| `Ordered` | Is `Regular` and is totally ordered (essentially, it can be sorted)
    |'
  id: totrans-254
  prefs: []
  type: TYPE_TB
  zh: '| `Ordered` | 是 `Regular` 且完全有序（本质上，它可以被排序） |'
- en: '| `Number` | Is `Ordered` and supports math operations like `+`, `-`, `/`,
    and `*` |'
  id: totrans-255
  prefs: []
  type: TYPE_TB
  zh: '| `Number` | 是 `Ordered` 并支持诸如 `+`、`-`、`/` 和 `*` 等数学运算 |'
- en: '| `Function` | Supports invocation; that is, you can call it (compare `is_invocable`)
    |'
  id: totrans-256
  prefs: []
  type: TYPE_TB
  zh: '| `Function` | 支持调用；也就是说，你可以调用它（比较 `is_invocable`） |'
- en: '| `Predicate` | Is a `Function` and returns `bool` |'
  id: totrans-257
  prefs: []
  type: TYPE_TB
  zh: '| `Predicate` | 是一个 `Function` 并返回 `bool` |'
- en: '| `Range` | Can be iterated over in a range-based `for` loop |'
  id: totrans-258
  prefs: []
  type: TYPE_TB
  zh: '| `Range` | 可以在基于范围的 `for` 循环中进行迭代 |'
- en: 'There are several ways to build constraints into a template prefix. If a template
    parameter is only used to declare the type of a function parameter, you can omit
    the template prefix entirely:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 有几种方法可以将约束构建到模板前缀中。如果模板参数仅用于声明函数参数的类型，你可以完全省略模板前缀：
- en: '[PRE34]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Because you use a concept rather than a `typename` to define an argument’s type
    ➊, the compiler knows that the associated function is a template. You are even
    free to mix concepts and concrete types in the argument list. In other words,
    whenever you use a concept as part of a function definition, that function becomes
    a template.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 因为你使用的是概念而不是 `typename` 来定义参数的类型 ➊，所以编译器知道相关的函数是一个模板。你甚至可以在参数列表中混合使用概念和具体类型。换句话说，每当你在函数定义中使用概念时，该函数就变成了一个模板。
- en: The template function in [Listing 6-25](ch06.xhtml#ch06ex25) takes an array
    of `Ordered` elements and finds the minimum.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 6-25](ch06.xhtml#ch06ex25) 中的模板函数接受一个 `Ordered` 元素的数组并找到最小值。'
- en: '[PRE35]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: '*Listing 6-25: A template function using the `Ordered` concept*'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 6-25：使用 `Ordered` 概念的模板函数*'
- en: Even though there’s no template prefix, `index_of_minimum` is a template because
    `Ordered` ➊ is a concept. This template can be instantiated in the same way as
    any other template function, as demonstrated in [Listing 6-26](ch06.xhtml#ch06ex26).
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 即使没有模板前缀，`index_of_minimum` 也是一个模板，因为 `Ordered` ➊ 是一个概念。这个模板可以像其他模板函数一样进行实例化，正如[列表
    6-26](ch06.xhtml#ch06ex26)中所示。
- en: '[PRE36]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: '*Listing 6-26: A listing employing `index_of_minimum` from [Listing 6-25](ch06.xhtml#ch06ex25).
    Uncommenting* ➌ *causes compilation to fail.*'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 6-26：一个使用[列表 6-25](ch06.xhtml#ch06ex25)中 `index_of_minimum` 的例子。取消注释* ➌
    *会导致编译失败。*'
- en: The instantiations for `int` ➊ and `unsigned short` ➋ arrays succeed because
    types are `Ordered` (see [Table 6-2](ch06.xhtml#ch06tab02)).
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: '`int` ➊ 和 `unsigned short` ➋ 数组的实例化成功，因为这些类型是 `Ordered`（见[表 6-2](ch06.xhtml#ch06tab02)）。'
- en: 'However, the `Goblin` class is not `Ordered`, and template instantiation would
    fail if you tried to compile ➌. Crucially, the error message would be informative:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，`Goblin` 类不是 `Ordered`，如果你尝试编译 ➌，模板实例化会失败。重要的是，错误信息会很有帮助：
- en: '[PRE37]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: You know that the `index_of_minimum` instantiation failed and that the issue
    is with the `Ordered` concept.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 你知道 `index_of_minimum` 的实例化失败了，问题出在 `Ordered` 概念上。
- en: '***Ad Hoc Requires Expressions***'
  id: totrans-272
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***特定需求表达式***'
- en: Concepts are fairly heavyweight mechanisms for enforcing type safety. Sometimes,
    you just want to enforce some requirement directly in the template prefix. You
    can embed requires expressions directly into the template definition to accomplish
    this. Consider the `get_copy` function in [Listing 6-27](ch06.xhtml#ch06ex27)
    that takes a pointer and safely returns a copy of the pointed-to object.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 概念是一种相对重量级的机制，用于强制执行类型安全性。有时，您只需要在模板前缀中直接强制执行某些要求。您可以将 requires 表达式直接嵌入到模板定义中，以实现这一点。请考虑
    [清单 6-27](ch06.xhtml#ch06ex27) 中的 `get_copy` 函数，它接受一个指针并安全地返回指向对象的副本。
- en: '[PRE38]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: '*Listing 6-27: A template function with an ad hoc requires expression*'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 6-27：一个具有特定要求表达式的模板函数*'
- en: The template prefix contains the `requires` keyword ➊, which begins the requires
    expression. In this case, the type trait `is_copy_constructible` ensures that
    `T` is copyable ➋. This way, if a user accidentally tries to `get_copy` with a
    pointer that points to an uncopyable object, they’ll be presented with a clear
    explanation of why template instantiation failed. Consider the example in [Listing
    6-28](ch06.xhtml#ch06ex28).
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 模板前缀包含 `requires` 关键字 ➊，它开始了要求表达式。在这种情况下，类型特征 `is_copy_constructible` 确保 `T`
    是可拷贝的 ➋。这样，如果用户错误地尝试使用指向不可拷贝对象的指针来 `get_copy`，他们会看到模板实例化失败的清晰解释。请参考 [清单 6-28](ch06.xhtml#ch06ex28)
    中的示例。
- en: '[PRE39]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: '*Listing 6-28: Program using the `get_copy` template in [Listing 6-27](ch06.xhtml#ch06ex27).
    This code doesn’t compile.*'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 6-28：使用 [清单 6-27](ch06.xhtml#ch06ex27) 中的 `get_copy` 模板的程序。此代码无法编译。*'
- en: The definition of `get_copy` ➊ is followed by a `Highlander` class definition,
    which contains a default constructor ➋ and a deleted copy constructor ➌. Within
    `main`, you’ve initialized a `Highlander` ➍, taken its reference ➎, and attempted
    to instantiate `get_copy` with the result ➏. Because there can be only one `Highlander`
    (it’s not copyable), [Listing 6-28](ch06.xhtml#ch06ex28) produces an exquisitely
    clear error message.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: '`get_copy` ➊ 的定义后跟着一个 `Highlander` 类的定义，该类包含一个默认构造函数 ➋ 和一个已删除的拷贝构造函数 ➌。在 `main`
    中，您初始化了一个 `Highlander` ➍，获取了它的引用 ➎，并尝试用结果实例化 `get_copy` ➏。由于 `Highlander` 只能有一个（它不可拷贝），[清单
    6-28](ch06.xhtml#ch06ex28) 会产生一个非常清晰的错误消息。'
- en: '**static_assert: The Preconcepts Stopgap**'
  id: totrans-280
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**static_assert：前提的临时解决方案**'
- en: 'As of C++17, concepts aren’t part of the standard, so they’re not guaranteed
    to be available across compilers. There is a stopgap you can apply in the interim:
    the `static_assert` expression. These assertions evaluate at compile time. If
    an assertion fails, the compiler will issue an error and optionally provide a
    diagnostic message. A `static_assert` has the following form:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 从 C++17 开始，概念不再是标准的一部分，因此它们在不同编译器之间不一定可用。在此期间，您可以应用一个临时的解决方案：`static_assert`
    表达式。这些断言在编译时进行评估。如果断言失败，编译器会发出错误，并可选地提供诊断消息。`static_assert` 的形式如下：
- en: '[PRE40]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: In the absence of concepts, you can include one or more `static_assert` expressions
    in the bodies of templates to assist users in diagnosing usage errors.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 在没有概念的情况下，您可以在模板的主体中包含一个或多个 `static_assert` 表达式，以帮助用户诊断使用错误。
- en: Suppose you want to improve the error messages of `mean` without leaning on
    concepts. You can use type traits in combination with `static_assert` to achieve
    a similar result, as demonstrated in [Listing 6-29](ch06.xhtml#ch06ex29).
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 假设您想在不依赖概念的情况下改进 `mean` 的错误消息。您可以结合使用类型特征和 `static_assert` 来实现类似的效果，如 [清单 6-29](ch06.xhtml#ch06ex29)
    所示。
- en: '[PRE41]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: '*Listing 6-29: Using `static_assert` expressions to improve compile time errors
    in `mean` in [Listing 6-10](ch06.xhtml#ch06ex10).*'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 6-29：使用 `static_assert` 表达式改善 [清单 6-10](ch06.xhtml#ch06ex10) 中 `mean` 的编译时错误。*'
- en: You see the familiar type traits for checking that `T` is default ➊ and copy
    constructible ➋, and you provide error methods to help users diagnose issues with
    template instantiation. You use `is_arithmetic` ➌, which evaluates to `true` if
    the type parameter supports arithmetic operations (`+, -, /`, and `*`), and `is_constructible`
    ➍, which determines whether you can construct a `T` from a `size_t`.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 您会看到常见的类型特征，用于检查 `T` 是否可以默认构造 ➊ 和拷贝构造 ➋，并且您提供了错误方法以帮助用户诊断模板实例化问题。您使用 `is_arithmetic`
    ➌，该方法如果类型参数支持算术操作（`+，-，/` 和 `*`）则返回 `true`，以及 `is_constructible` ➍，它确定是否可以从 `size_t`
    构造一个 `T`。
- en: Using `static_assert` as a proxy for concepts is a hack, but it’s widely used.
    Using type traits, you can limp along until concepts are included in the standard.
    You’ll often see `static_assert` if you use modern third-party libraries; if you’re
    writing code for others (including future you), consider using `static_assert`
    and type traits.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`static_assert`作为概念的代理是一种变通方法，但它被广泛使用。通过使用类型特征，你可以暂时解决问题，直到概念被纳入标准。如果你使用现代的第三方库，你会经常看到`static_assert`；如果你为他人（包括未来的自己）编写代码，考虑使用`static_assert`和类型特征。
- en: Compilers, and often programmers, don’t read documentation. By baking requirements
    directly into the code, you can avoid stale documentation. In the absence of concepts,
    `static_assert` is a fine stopgap.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 编译器，通常程序员，也不会阅读文档。通过将要求直接嵌入代码中，你可以避免过时的文档问题。在缺乏概念的情况下，`static_assert`是一个很好的临时替代方案。
- en: '**Non-Type Template Parameters**'
  id: totrans-290
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**非类型模板参数**'
- en: 'A template parameter declared with the `typename` (or `class`) keyword is called
    a *type template parameter*, which is a stand-in for some yet-to-be-specified
    *type*. Alternatively, you can use *non-type template parameters*, which are stand-ins
    for some yet-to-be-specified *value*. Non-type template parameters can be any
    of the following:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`typename`（或`class`）关键字声明的模板参数称为*类型模板参数*，它代表某种尚未指定的*类型*。另外，你可以使用*非类型模板参数*，它们代表某种尚未指定的*值*。非类型模板参数可以是以下任意类型：
- en: An integral type
  id: totrans-292
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个整数类型
- en: An lvalue reference type
  id: totrans-293
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个左值引用类型
- en: A pointer (or pointer-to-member) type
  id: totrans-294
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个指针（或指向成员的指针）类型
- en: A `std::nullptr_t` (the type of `nullptr`)
  id: totrans-295
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个`std::nullptr_t`（即`nullptr`的类型）
- en: An `enum class`
  id: totrans-296
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个`enum class`
- en: Using a non-type template parameter allows you to inject a value into the generic
    code at compile time. For example, you can construct a template function called
    `get` that checks for out-of-bounds array access at compile time by taking the
    index you want to access as a non-type template parameter.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 使用非类型模板参数允许你在编译时将一个值注入到通用代码中。例如，你可以构建一个名为`get`的模板函数，在编译时检查数组越界访问，通过将你想访问的索引作为非类型模板参数传入。
- en: 'Recall from [Chapter 3](ch03.xhtml#ch03) that if you pass an array to a function,
    it decays into a pointer. You can instead pass an array reference with a particularly
    off-putting syntax:'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 回想一下[第3章](ch03.xhtml#ch03)，如果你将一个数组传递给函数，它会衰变为指针。你可以改为传递数组引用，尽管它的语法比较难以接受：
- en: '[PRE42]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: For example, [Listing 6-30](ch06.xhtml#ch06ex30) contains a `get` function that
    makes a first attempt at performing bounds-checked array access.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，[示例 6-30](ch06.xhtml#ch06ex30)包含一个`get`函数，它首次尝试执行带边界检查的数组访问。
- en: '[PRE43]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: '*Listing 6-30: A function for accessing array elements with bounds checking*'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: '*示例 6-30：带有边界检查的数组元素访问函数*'
- en: The `get` function accepts a reference to an `int` array of length 10 ➊ and
    an `index` to extract ➋. If `index` is out of bounds, it throws an `out_of_bounds`
    exception ➌; otherwise, it returns a reference to the corresponding element ➍.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: '`get`函数接受一个长度为10的`int`数组引用 ➊ 和一个要提取的`index` ➋。如果`index`超出范围，它会抛出一个`out_of_bounds`异常
    ➌；否则，它会返回对应元素的引用 ➍。'
- en: You can improve [Listing 6-30](ch06.xhtml#ch06ex30) in three ways, which are
    all enabled by non-type template parameters genericizing the values out of `get`.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在三方面改进[示例 6-30](ch06.xhtml#ch06ex30)，这些都通过非类型模板参数实现，使得`get`函数中的值变得通用。
- en: First, you can relax the requirement that `arr` refer to an `int` array by making
    `get` a template function, as in [Listing 6-31](ch06.xhtml#ch06ex31).
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，你可以通过将`get`函数改为模板函数来放宽`arr`引用`int`数组的要求，如[示例 6-31](ch06.xhtml#ch06ex31)所示。
- en: '[PRE44]'
  id: totrans-306
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: '*Listing 6-31: A refactor of [Listing 6-30](ch06.xhtml#ch06ex30) to accept
    an array of a generic type*'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: '*示例 6-31：对[示例 6-30](ch06.xhtml#ch06ex30)的重构，以接受一个通用类型的数组*'
- en: As you’ve done throughout this chapter, you’ve genericized the function by replacing
    a concrete type (here, `int`) with a template parameter ➊➋➌.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你在本章中所做的，你已经通过将具体类型（此处为`int`）替换为模板参数来使函数通用化 ➊➋➌。
- en: 'Second, you can relax the requirement that `arr` refer to an array of length
    10 by introducing a non-type template parameter `Length`. [Listing 6-32](ch06.xhtml#ch06ex32)
    shows how: simply declare a `size_t Length` template parameter and use it in place
    of 10.'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 其次，你可以通过引入一个非类型模板参数`Length`来放宽`arr`引用长度为10的数组的要求。[示例 6-32](ch06.xhtml#ch06ex32)展示了如何做：只需声明一个`size_t
    Length`模板参数，并在代码中替代10。
- en: '[PRE45]'
  id: totrans-310
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: '*Listing 6-32: A refactor of [Listing 6-31](ch06.xhtml#ch06ex31) to accept
    an array of a generic length*'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: '*示例 6-32：对[示例 6-31](ch06.xhtml#ch06ex31)的重构，以接受一个长度为通用值的数组*'
- en: 'The idea is the same: rather than replacing a specific type (`int`), you’ve
    replaced a specific integral value (`10`) ➊➋➌. Now you can use the function with
    arrays of any size.'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 这个思想是一样的：你不是替换一个特定的类型（`int`），而是替换一个特定的整数值（`10`）➊➋➌。现在，你可以在任何大小的数组中使用这个函数。
- en: Third, you can perform compile time bounds checking by taking `size_t index`
    as another non-type template parameter. This allows you to replace the `std::out_of_range`
    with a `static_assert`, as in [Listing 6-33](ch06.xhtml#ch06ex33).
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 第三，你可以通过将`size_t index`作为另一个非类型模板参数来执行编译时边界检查。这允许你用`static_assert`替换`std::out_of_range`，如[示例
    6-33](ch06.xhtml#ch06ex33)所示。
- en: '[PRE46]'
  id: totrans-314
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: '*Listing 6-33: A program using compile time bounds-checked array accesses*'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: '*示例 6-33：一个使用编译时边界检查数组访问的程序*'
- en: You’ve moved the `size_t` index parameter into a non-type template parameter
    ➊ and updated the array access with the correct name `Index` ➌. Because `Index`
    is now a compile time constant, you also replace the `logic_error` with a `static_assert`,
    which prints the friendly message `Out-of-bounds access` whenever you accidentally
    try to access an out-of-bounds element ➋.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 你将`size_t`索引参数移到了一个非类型模板参数中 ➊，并用正确的名称`Index` ➌更新了数组访问。因为`Index`现在是一个编译时常量，你还将`logic_error`替换为`static_assert`，当你不小心尝试访问越界元素时，它会打印友好的信息`Out-of-bounds
    access` ➋。
- en: '[Listing 6-33](ch06.xhtml#ch06ex33) also contains example usage of get in `main`.
    You’ve first declared an `int` array `fib` of length 4 ➍. You then print the first
    three elements of the array using `get` ➎, set the fourth element ➏, and print
    it ➐. If you uncomment the out-of-bounds access ➑, the compiler will generate
    an error thanks to the `static_assert`.'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 6-33](ch06.xhtml#ch06ex33)还展示了在`main`中使用`get`的示例。你首先声明了一个长度为4的`int`数组`fib`
    ➍。然后，你使用`get` ➎打印数组的前三个元素，设置第四个元素 ➏，并打印它 ➐。如果你取消注释越界访问 ➑，编译器会因为`static_assert`而生成错误。'
- en: '**Variadic Templates**'
  id: totrans-318
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**变参模板**'
- en: Sometimes, templates must take in an unknown number of arguments. The compiler
    knows these arguments at template instantiation, but you want to avoid having
    to write many different templates each for different numbers of arguments. This
    is the raison d’être of variadic templates. *Variadic templates* take a variable
    number of arguments.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候，模板必须接受一个未知数量的参数。编译器在模板实例化时知道这些参数，但你希望避免为每种不同数量的参数编写许多不同的模板。这就是变参模板的存在意义。*变参模板*接受一个可变数量的参数。
- en: You denote variadic templates using a final template parameter that has a special
    syntax, namely `typename... arguments`. The ellipsis indicates that `arguments`
    is a *parameter pack type*, meaning you can declare parameter packs within your
    template. A parameter pack is a template argument that accepts zero or more function
    arguments. These definitions can seem a bit abstruse, so consider the following
    sample variadic template that builds upon `SimpleUniquePointer`.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 你通过一个具有特殊语法的最终模板参数来表示变参模板，即`typename... arguments`。省略号表示`arguments`是一个*参数包类型*，意味着你可以在模板中声明参数包。参数包是一个接受零个或多个函数参数的模板参数。这些定义可能看起来有些抽象，因此请考虑以下基于`SimpleUniquePointer`的变参模板示例。
- en: Recall from [Listing 6-14](ch06.xhtml#ch06ex14) that you pass a raw pointer
    into the constructor of `SimpleUniquePointer`. [Listing 6-34](ch06.xhtml#ch06ex34)
    implements a `make_simple_unique` function that handles construction of the underlying
    type.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 回想一下[示例 6-14](ch06.xhtml#ch06ex14)，你将一个原始指针传递给`SimpleUniquePointer`的构造函数。[示例
    6-34](ch06.xhtml#ch06ex34)实现了一个`make_simple_unique`函数，用于处理基础类型的构造。
- en: '[PRE47]'
  id: totrans-322
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: '*Listing 6-34: Implementing a `make_simple_unique` function to ease `SimpleUniquePointer`
    usage*'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: '*示例 6-34：实现一个`make_simple_unique`函数，以简化`SimpleUniquePointer`的使用*'
- en: You define the parameter pack type `Arguments` ➊, which declares `make_simple_unique`
    as a variadic template. This function passes arguments ➋ to the constructor of
    template parameter `T` ➌.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 你定义了参数包类型`Arguments` ➊，这声明了`make_simple_unique`为一个变参模板。这个函数将参数 ➋ 传递给模板参数`T`的构造函数
    ➌。
- en: The upshot is you can now create `SimpleUniquePointers` very easily, even when
    the pointed-to object has a non-default constructor.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 结果是，现在你可以非常轻松地创建`SimpleUniquePointer`，即使所指向的对象有一个非默认构造函数。
- en: '**NOTE**'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*There is a slightly more efficient implementation of [Listing 6-34](ch06.xhtml#ch06ex34).
    If `arguments` is an rvalue, you can move it directly into the constructor of
    `T`. The stdlib contains a function called `std::forward` in the `<utility>` header
    that will detect whether `arguments` is an lvalue or rvalue and perform a copy
    or move, respectively. See Item 23 in Effective Modern C++ by Scott Meyers.*'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: '*[示例 6-34](ch06.xhtml#ch06ex34)有一个略微更高效的实现。如果`arguments`是一个右值，你可以直接将其移动到`T`的构造函数中。标准库包含一个名为`std::forward`的函数，位于`<utility>`头文件中，它将检测`arguments`是左值还是右值，并分别执行复制或移动操作。有关更多信息，请参阅Scott
    Meyers的《Effective Modern C++》中的第23条。*'
- en: '**Advanced Template Topics**'
  id: totrans-328
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**高级模板话题**'
- en: For everyday polymorphic programming, templates are your go-to tool. It turns
    out that templates are also used in a wide range of advanced settings, especially
    in implementing libraries, high-performance programs, and embedded system firmware.
    This section outlines some of the major terrain features of this vast space.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 对于日常的多态编程，模板是你最常用的工具。事实证明，模板也被广泛应用于各种高级设置，特别是在实现库、高性能程序和嵌入式系统固件时。本节概述了这一广阔领域的一些主要特征。
- en: '***Template Specialization***'
  id: totrans-330
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***模板特化***'
- en: To understand advanced template usage, you must first understand *template specialization*.
    Templates can actually take more than just `concept` and `typename` parameters
    (type parameters). They can also accept fundamental types, like `char` (value
    parameters), as well as other templates. Given the tremendous flexibility of template
    parameters, you can make a lot of compile-time decisions about their features.
    You could have different versions of templates depending on the characteristics
    of these parameters. For example, if a type parameter is `Ordered` instead of
    `Regular`, you might be able to make a generic program more efficient. Programming
    this way is called *template specialization*. Refer to the ISO standard [temp.spec]
    for more information about template specialization.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 要理解高级模板用法，首先必须理解*模板特化*。模板实际上不仅可以接受`concept`和`typename`参数（类型参数）。它们还可以接受基本类型，如`char`（值参数），以及其他模板。由于模板参数具有极大的灵活性，你可以根据这些参数的特性做出许多编译时决定。你可以根据这些参数的不同特性拥有不同版本的模板。例如，如果类型参数是`Ordered`而不是`Regular`，你可能能够使一个通用程序更加高效。以这种方式编程被称为*模板特化*。有关模板特化的更多信息，请参阅ISO标准[temp.spec]。
- en: '***Name Binding***'
  id: totrans-332
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***名称绑定***'
- en: 'Another critical component of how templates get instantiated is name binding.
    Name binding helps determine the rules for when the compiler matches a named element
    within a template to a concrete implementation. The named element could, for example,
    be part of the template definition, a local name, a global name, or from some
    named namespace. If you want to write heavily templated code, you need to understand
    how this binding occurs. If you’re in such a situation, refer to [Chapter 9](ch09.xhtml#ch09),
    “Names in Templates,” in *C++ Templates: The Complete Guide* by David Vandevoorde
    et al. and to [temp.res].'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: '模板实例化的另一个关键组件是名称绑定。名称绑定有助于确定编译器在模板中匹配命名元素到具体实现的规则。例如，命名元素可以是模板定义的一部分、局部名称、全局名称，或者来自某个命名空间。如果你想编写大量模板代码，你需要了解绑定是如何发生的。如果你处于这种情况，请参考David
    Vandevoorde等人的《*C++ Templates: The Complete Guide*》中的[第9章](ch09.xhtml#ch09)，“模板中的名称”，以及[temp.res]。'
- en: '***Type Function***'
  id: totrans-334
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***类型函数***'
- en: A *type function* takes types as arguments and returns a type. The type traits
    with which you build up concepts are closely related to type functions. You can
    combine type functions with compile time control structures to do general computation,
    such as programming control flow, at compile time. Generally, programming using
    these techniques is called *template metaprogramming*.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: '*类型函数*接受类型作为参数并返回一个类型。构建概念的类型特征与类型函数密切相关。你可以将类型函数与编译时控制结构结合使用，以便在编译时进行一般计算，例如编程控制流。通常，使用这些技术进行编程被称为*模板元编程*。'
- en: '***Template Metaprogramming***'
  id: totrans-336
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***模板元编程***'
- en: 'Template metaprogramming has a deserved reputation for resulting in code that
    is exceedingly clever and absolutely inscrutable to all but the mightiest of wizards.
    Fortunately, once concepts are part of the C++ standard, template metaprogramming
    should become more approachable to us mere mortals. Until then, tread carefully.
    For those interested in further detail on this topic, refer to *Modern C++ Design:
    Generic Programming and Design Patterns Applied* by Andrei Alexandrescu and *C++
    Templates: The Complete Guide* by David Vandevoorde et al.'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: '模板元编程以生成极为巧妙且对除最强大的程序员外几乎无人能懂的代码而闻名。幸运的是，一旦概念成为C++标准的一部分，模板元编程应该会变得更容易为我们这些普通人所理解。在那之前，请小心谨慎。对于那些希望深入了解这一主题的人，可以参考*Modern
    C++ Design: Generic Programming and Design Patterns Applied*（安德烈·亚历山大斯库著）和*C++
    Templates: The Complete Guide*（大卫·范德沃尔德等著）。'
- en: '**Template Source Code Organization**'
  id: totrans-338
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**模板源代码组织**'
- en: Each time a template is instantiated, the compiler must be able to generate
    all the code necessary to use the template. This means all the information about
    how to instantiate a custom class or function must be available within the same
    translation unit as the template instantiation. By far, the most popular way to
    achieve this is to implement templates entirely within header files.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 每次实例化模板时，编译器必须能够生成使用该模板所需的所有代码。这意味着关于如何实例化自定义类或函数的所有信息必须在与模板实例化相同的翻译单元内可用。到目前为止，最流行的实现方法是在头文件中完全实现模板。
- en: There are some modest inconveniences associated with this approach. Compile
    times can increase, because templates with the same parameters might get instantiated
    multiple times. It also decreases your ability to hide implementation details.
    Fortunately, the benefits of generic programming far outweigh these inconveniences.
    (Major compilers will probably minimize the problems of compile times and code
    duplication anyway.)
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法有一些小的 inconveniences。编译时间可能会增加，因为具有相同参数的模板可能会被多次实例化。它还减少了隐藏实现细节的能力。幸运的是，泛型编程的好处远远超过这些不便。（主要的编译器可能会尽量减少编译时间和代码重复的问题。）
- en: 'There are even a few advantages to having header-only templates:'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 头文件模板也有一些优势：
- en: 'It’s very easy for others to use your code: it’s a matter of applying `#include`
    to some headers (rather than compiling the library, ensuring the resulting object
    files are visible to the linker, and so on).'
  id: totrans-342
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 让其他人使用你的代码非常容易：只需要对一些头文件应用`#include`（而不是编译库，确保结果对象文件对链接器可见，等等）。
- en: It’s trivially easy for compilers to inline header-only templates, which can
    lead to faster code at runtime.
  id: totrans-343
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于编译器来说，将仅包含头文件的模板内联是非常容易的，这可以在运行时提高代码的执行速度。
- en: Compilers can generally do a better job of optimizing code when all of the source
    is available.
  id: totrans-344
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编译器通常可以在所有源代码都可用时做得更好，从而优化代码。
- en: '**Polymorphism at Runtime vs. Compile Time**'
  id: totrans-345
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**运行时多态与编译时多态**'
- en: When you want polymorphism, you should use templates. But sometimes you can’t
    use templates because you won’t know the types used with your code until runtime.
    Remember that template instantiation only occurs when you pair a template’s parameters
    with types. At this point, the compiler can instantiate a custom class for you.
    In some situations, you might not be able to perform such pairings until your
    program is executing (or, at least, performing such pairing at compile time would
    be tedious).
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 当你需要多态时，应该使用模板。但有时你不能使用模板，因为你直到运行时才知道与你的代码一起使用的类型。记住，模板实例化仅在你将模板的参数与类型配对时才会发生。此时，编译器可以为你实例化一个自定义类。在某些情况下，你可能无法在编译时执行这种配对，或者至少，在编译时执行配对会非常繁琐，直到程序执行时才能进行。
- en: In such cases, you can use runtime polymorphism. Whereas the template is the
    mechanism for achieving compile-time polymorphism, the runtime mechanism is the
    interface.
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，你可以使用运行时多态。而模板是实现编译时多态的机制，运行时机制是接口。
- en: '**Summary**'
  id: totrans-348
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**总结**'
- en: In this chapter, you explored polymorphism in C++. The chapter started with
    a discussion of what polymorphism is and why it’s so tremendously useful. You
    explored how to achieve polymorphism at compile time with templates. You learned
    about type checking with concepts and then explored some advanced topics, such
    as variadic templates and template metaprogramming.
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你探讨了C++中的多态。本章开始时讨论了多态是什么，以及它为何如此有用。你探索了如何通过模板在编译时实现多态。你了解了使用概念进行类型检查，然后探讨了一些高级主题，如变参模板和模板元编程。
- en: '**EXERCISES**'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: '**练习**'
- en: '**6-1.** The mode of a series of values is the value that appears most commonly.
    Implement a mode function using the following signature: `int mode(constint* values,
    size_t length)`. If you encounter an error condition, such as input having multiple
    modes and no values, return zero.'
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: '**6-1.** 一系列值的众数是最常出现的值。使用以下签名实现一个众数函数：`int mode(const int* values, size_t
    length)`。如果遇到错误情况，如输入具有多个众数或没有值，则返回零。'
- en: '**6-2.** Implement `mode` as a template function.'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: '**6-2.** 将 `mode` 实现为模板函数。'
- en: '**6-3.** Modify mode to accept an `Integer` concept. Verify that mode fails
    to instantiate with floating types like `double`.'
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: '**6-3.** 修改 `mode` 函数以接受 `Integer` 类型概念。验证 `mode` 无法使用浮动类型（如 `double`）实例化。'
- en: '**6-4.** Refactor `mean` in [Listing 6-13](ch06.xhtml#ch06ex13) to accept an
    array rather than pointer and length arguments. Use [Listing 6-33](ch06.xhtml#ch06ex33)
    as a guide.'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: '**6-4.** 重构 [列表 6-13](ch06.xhtml#ch06ex13) 中的 `mean` 函数，使其接受数组，而不是指针和长度参数。使用
    [列表 6-33](ch06.xhtml#ch06ex33) 作为参考。'
- en: '**6-5.** Using the example from [Chapter 5](ch05.xhtml#ch05), make `Bank` a
    template class that accepts a template parameter. Use this type parameter as the
    type of an account rather than `long`. Verify that your code still works using
    a `Bank<long>` class.'
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: '**6-5.** 使用 [第5章](ch05.xhtml#ch05)的示例，将 `Bank` 改为接受模板参数的模板类。使用该类型参数作为账户类型，而不是
    `long`。验证使用 `Bank<long>` 类时代码是否仍然有效。'
- en: '**6-6.** Implement an `Account` class and instantiate a `Bank<Account>`. Implement
    functions in `Account` to keep track of balances.'
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: '**6-6.** 实现一个 `Account` 类并实例化一个 `Bank<Account>`。在 `Account` 类中实现函数以跟踪余额。'
- en: '**6-7.** Make `Account` an interface. Implement a `CheckingAccount` and `SavingsAccount`.
    Create a program with several checking and savings accounts. Use a `Bank<Account>`
    to make several transactions between the accounts.'
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: '**6-7.** 将 `Account` 变为接口。实现 `CheckingAccount` 和 `SavingsAccount`。创建一个程序，包含多个支票账户和储蓄账户。使用
    `Bank<Account>` 实现账户间的多个交易。'
- en: '**FURTHER READING**'
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: '**进一步阅读**'
- en: '*C++ Templates: The Complete Guide*, 2nd Edition, by David Vandevoorde, Nicolai
    M. Josuttis, and Douglas Gregor (Addison-Wesley, 2017)'
  id: totrans-359
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*C++ 模板：完全指南*（第2版），由 David Vandevoorde、Nicolai M. Josuttis 和 Douglas Gregor
    编写（Addison-Wesley，2017年）'
- en: '*Effective Modern C++: 42 Specific Ways to Improve Your Use of C++11 and C++14*
    by Scott Meyers (O’Reilly Media, 2015)'
  id: totrans-360
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*有效的现代 C++：42 种方法改进你对 C++11 和 C++14 的使用* 由 Scott Meyers 编写（O''Reilly Media，2015年）'
- en: '*The C++ Programming Language*, 4th Edition, by Bjarne Stroustrup (Pearson
    Education, 2013)'
  id: totrans-361
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*C++ 编程语言*（第4版），由 Bjarne Stroustrup 编写（Pearson Education，2013年）'
- en: '*Modern C++ Design: Generic Programming and Design Patterns Applied* by Andrei
    Alexandrescu (Addison-Wesley, 2001)'
  id: totrans-362
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*现代 C++ 设计：通用编程与设计模式应用* 由 Andrei Alexandrescu 编写（Addison-Wesley，2001年）'
