<html><head></head><body>
<div id="book-content">
<div id="sbo-rt-content"><h2 class="chn"><span epub:type="pagebreak" id="page_281"/><strong>12</strong></h2>&#13;
<h2 class="cht"><strong>EMBEDDED ARCHITECTURES</strong></h2>&#13;
<div class="image1"><img src="../images/f0281-01.jpg" alt="Image" width="252" height="252"/></div>&#13;
<p class="chq">Computers are now common inside cars, robots, factories, art galleries, and domestic appliances. These environments bring particular constraints and challenges to computation, and architectures designed for them are known as <em>embedded systems</em>. The vast majority of manufactured processors—about 98 percent of them—go to embedded systems. This is a huge market, with a value of around $250 billion in the early 2020s, so it’s worth your time to study these systems.</p>&#13;
<p class="indent">This chapter will give you the understanding of embedded systems needed to build your own robots, home automation hacks, electronic musical instruments, or art installations, as well as industrial applications. We’ll begin by examining key differences between general-purpose computers and embedded systems, including the structure of typical microcontrollers and their I/O features. We’ll then turn to Arduino, the most common embedded system used by computer scientists, and show how to program it in simulation and for real at the assembly language level, where its architecture is clearest to see. Finally, we’ll explore some alternatives to Arduino, including Arduinoless AVR, PIC, DSPs, and PLCs.</p>&#13;
<h3 class="h3" id="lev233"><span epub:type="pagebreak" id="page_282"/>Design Principles</h3>&#13;
<p class="noindent">There are several well-known design principles that distinguish embedded systems from other architectures. Let’s walk through them now.</p>&#13;
<h4 class="h4" id="lev234"><em>Single Purpose</em></h4>&#13;
<p class="noindent">Unlike PCs, embedded systems are usually purchased and used for a single purpose. An embedded system controls your robot or your washing machine by running a single program, meaning you don’t need an operating system to switch between programs, and you don’t often—or ever—need to change the program. As a result, embedded devices can be difficult to upgrade. You can occasionally try asking all your users to upgrade the firmware on their TV or music player, but it would be very expensive to promote and explain the concept widely enough for many users to actually do it. Instead, it’s common for most users to throw away such devices and buy new ones. Depending on your point of view, this can be a huge waste of Earth’s resources or a highly profitable business model.</p>&#13;
<h4 class="h4" id="lev235"><em>Reliability</em></h4>&#13;
<p class="noindent">Reliability is often much more of an issue for embedded systems than for general-purpose computing—it can literally be life or death. Consider a heart pacemaker and its embedded systems, which are put inside a human being during surgery. You have to be very sure that it works correctly, as you really don’t want to have to open the person up again to fix a bug or turn the device off and on again. Other embedded systems control heavy machinery in factories, signaling systems for public transportation, and nuclear missile launches, all of which have a similarly low tolerance for errors.</p>&#13;
<h4 class="h4" id="lev236"><em>Mobility and Power</em></h4>&#13;
<p class="noindent">Embedded systems are usually designed as the computational parts of physical machines, which constrain their physical shape more heavily than for general-purpose computers. It’s common for the physical machine to be designed first, and for the embedded system to be designed to fit into whatever space is left. Some embedded systems have mobility concerns, too: if the embedded system has to go on a person, for example, it has to be small and light enough to carry around (and it wouldn’t hurt to look good, too).</p>&#13;
<p class="indent">There are considerations of electricity, especially if the host machine runs on a battery instead of plugging into the wall. Designers have to consider how much power to draw and for how long, and how large the battery has to be. A lot of effort goes into designing embedded processors to use as little energy as possible.</p>&#13;
<h4 class="h4" id="lev237"><span epub:type="pagebreak" id="page_283"/><em>Encapsulation</em></h4>&#13;
<p class="noindent">Because they’re intended for a single purpose, embedded systems typically don’t need to expose the user to most or any of their functionality, a concept known as <em>encapsulation</em>. Instead, the user might get a simple interface, with just a few buttons and some LEDs, or none at all if the system is intended to work without human intervention. Often, the user won’t even realize that there’s a computer present in their machine.</p>&#13;
<h4 class="h4" id="lev238"><em>Careful Debugging</em></h4>&#13;
<p class="noindent">While finished embedded systems are often designed to be very robust, safety-critical, and fault-tolerant, you’ll find as a computer scientist that they can feel very brittle during development work. We’re used to working with systems that can be quickly and safely hacked around; if something doesn’t work, we fix it and run it again until it does. But when you work with embedded systems, a failure can physically destroy a component that may be difficult, expensive, or time-consuming to replace, so you often have to be more careful and organized about how to plan tests.</p>&#13;
<h3 class="h3" id="lev239">Microcontrollers</h3>&#13;
<p class="noindent">A <em>microcontroller</em> (aka a <em>microcontroller unit</em>, <em>MCU</em>, or <em>µC</em>) is a chip including a CPU that’s designed and marketed for embedded applications. A microcontroller may look like the one in <a href="ch12.xhtml#ch12fig1">Figure 12-1</a>.</p>&#13;
<div class="image"><img id="ch12fig1" src="../images/f0283-01.jpg" alt="Image" width="287" height="207"/></div>&#13;
<p class="figcap"><em>Figure 12-1: An Atmel ATmega328P microcontroller chip</em></p>&#13;
<p class="indent">In the next few sections, we’ll walk through some common features of microcontrollers.</p>&#13;
<h4 class="h4" id="lev240"><em>CPU</em></h4>&#13;
<p class="noindent">Microcontrollers are based around a CPU. The CPU is usually much lower power than a desktop’s, in terms of both computational power and energy consumption. They’re often 8-bit, behaving quite similarly to retro 8-bit architectures, and they often don’t have floating point—as with retro machines, you need to work in either integers or fixed point.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_284"/>Microcontrollers usually also include memory and I/O components on the same silicon as the CPU. This arrangement removes the need for external buses and reduces the number of pins on the microcontroller. It’s easier to build a physical system from a single MCU chip than to require separate chips and bus wiring.</p>&#13;
<h4 class="h4" id="lev241"><em>Memory</em></h4>&#13;
<p class="noindent">Because they’re intended to run a single, fixed program, microcontrollers typically use a Harvard architecture, with the program stored as firmware in ROM, and RAM used only as working memory for the program’s data. Using ROM in this way enables the program to remain in memory when the system is powered off, and to be immediately available when powered on again. Like all CPUs, microcontrollers are designed to fetch from a hardwired initial address on power-on, and the first instruction will be placed in ROM at that address.</p>&#13;
<p class="indent">Because it has to fit on the single chip, microcontroller memory is much smaller than in desktop PCs.</p>&#13;
<h4 class="h4" id="lev242"><em>Timers and Counters</em></h4>&#13;
<p class="noindent">As many real-world control tasks need to operate based on time and events in the real world, it’s common for timers and counters to be included in microcontrollers. They usually appear as extra simple machines, with their own dedicated registers and instructions, in the microcontroller’s CPU.</p>&#13;
<p class="indent">You saw how to make counters from digital logic in <a href="ch06.xhtml">Chapter 6</a>. If you connect a wire from the outside world to a counter, you can use the counter to count the number of occurrences of some physical event, such as the number of presses of a button.</p>&#13;
<p class="indent">A <em>timer</em> measures the amount of real time that has elapsed since it was initialized. Real-world time is often called “wall-clock” time in this context, as in the time difference that would be reported by a human looking at a physical clock on the wall. A timer can be made by connecting the electronic clock, as used to control the CPU’s cycle, to a counter.</p>&#13;
<p class="indent">A <em>watchdog</em> is a special timer that automatically resets the microcontroller in the case of failure. This is used in systems that have to be reliable in the real world. If something goes wrong, you need a way to reset the system without needing to touch the machine (think of the pacemaker example). The reset is done at the digital logic level and isn’t part of the CPU’s program.</p>&#13;
<h3 class="h3" id="lev243">Embedded I/O</h3>&#13;
<p class="noindent">Embedded systems exist to control physical devices, so I/O is particularly important. We often find I/O modules, ports, and some very basic, slow serial communication built into the chip itself. As microcontrollers don’t <span epub:type="pagebreak" id="page_285"/>expose their bus on their external pins, the scarce resource of pin real estate can instead be used to expose I/O connections. Some microcontrollers forgo I/O modules and use direct I/O instructions to talk to these pins—similar to what you saw for the Commodore 64 6510.</p>&#13;
<p class="indent">I/O isn’t only important for real-time execution; it also provides a way to upload programs to embedded systems. Unlike with PCs, it’s usually not possible to do the development work on an embedded device, as this would require graphics, a keyboard, an operating system, and a compiler to all run on the low-power device. Instead, we do development work on a desktop, and perhaps test our programs there too using simulation or emulation, before transferring the final binary executable to the embedded device. Microcontrollers have special modes for doing this: usually they can be connected to a desktop via USB, serial port, or other means, then put into “firmware upgrade” mode to copy the executable into their non-volatile program memory via this connection and a software device driver on the desktop machine.</p>&#13;
<h4 class="h4" id="lev244"><em>Analog-Digital Conversion</em></h4>&#13;
<p class="noindent">Many microcontrollers need to handle incoming and outgoing analog signals, but inside the controller signals must be digital; this requires conversion at both ends. The necessary converters may be found outside the microcontroller, connected to its pins, or in some cases on the microcontroller silicon itself.</p>&#13;
<p class="indent">The classic case of analog-digital conversion (ADC) is audio processing. An analog signal from a microphone is sent to a digital processor, which adds effects to the audio before sending the processed analog signal back out to the speakers. This is done by taking a continuous analog signal wave and quantizing it, turning it into a digital signal by sampling it at regular time intervals, as shown in <a href="ch12.xhtml#ch12fig2">Figure 12-2</a>. You can do this at different resolutions by taking samples more or less frequently.</p>&#13;
<div class="image"><img id="ch12fig2" src="../images/f0285-01.jpg" alt="Image" width="601" height="359"/></div>&#13;
<p class="figcap"><em>Figure 12-2: Quantizing an analog signal to digital</em></p>&#13;
<p class="indent">When converting the other way, digital-analog conversion (DAC), some devices (like the Arduino Due) do true conversion of digital integers to analog voltages. Cheaper ones (such as the Arduino Uno) approximate the conversion with pulse-width modulation (PWM). Here, the output is only ever <span epub:type="pagebreak" id="page_286"/>0 V or 5 V. If 3 V is asked for, the output oscillates rapidly between 0 V and 5 V, spending three-fifths of its time at 5 V and two-fifths at 0 V, to give a temporal average of 3 V. For some applications this creates no noticeable difference, but for others it can play havoc with the output.</p>&#13;
<h4 class="h4" id="lev245"><em>Embedded Serial Ports</em></h4>&#13;
<p class="noindent">The serial ports seen in the previous chapter continue to be used heavily today in embedded systems, due to their simplicity and stability. In the projects you do here, you’re more likely to see this convention in a virtualized form, as you don’t often see a physical serial port on a modern computer these days. Instead, you can use something like USB to emulate the old-fashioned serial port protocols. Similarly, the <em>Zigbee</em> wireless protocol acts as a virtual serial port running over a specific radio frequency; it’s used by embedded devices such as programmable light bulbs and transportation and agriculture sensor networks.</p>&#13;
<h4 class="h4" id="lev246"><em>Inter-Integrated Circuit Bus</em></h4>&#13;
<p class="noindent">The <em>Inter-Integrated Circuit bus</em>, pronounced “eye-two-see” (written as I<sup>2</sup>C and sometimes pronounced “eye-squared-see”), is a standard for connecting chips together. It’s very common in robotics. The standard is owned and licensed by NXP (formerly Phillips).</p>&#13;
<p class="indent">I<sup>2</sup>C communication is done on just two wires: data (SDA) and clock (SDL), as shown in <a href="ch12.xhtml#ch12fig3">Figure 12-3</a>.</p>&#13;
<div class="image"><img id="ch12fig3" src="../images/f0286-01.jpg" alt="Image" width="417" height="170"/></div>&#13;
<p class="figcap"><em>Figure 12-3: The I<sup>2</sup>C architecture</em></p>&#13;
<p class="indent">I<sup>2</sup>C can use 5 V or 3.3 V as its high voltage, and runs in various speed modes, from 100Kbps to 3Mbps. There may be multiple devices on the bus, each having a 7-bit licensed device address. One node must take on the role of manager by generating the clock and initiating communications. The other nodes are workers, which reply to the manager. Basic message collision avoidance is implemented by the rule “only talk if the bus is free.”</p>&#13;
<p class="indent">In practice, I<sup>2</sup>C devices can be accessed via a standard FTDI (Future Technology Devices International Ltd) chip, which provides a hardware and software interface to it, usually via a serial connection (which itself is usually via a USB port). Examples of an I<sup>2</sup>C device (an inertial measurement unit sensor) and an FTDI for interfacing to it are shown in <a href="ch12.xhtml#ch12fig4">Figure 12-4</a>.</p>&#13;
<div class="image"><span epub:type="pagebreak" id="page_287"/><img id="ch12fig4" src="../images/f0287-01.jpg" alt="Image" width="865" height="312"/></div>&#13;
<p class="figcap"><em>Figure 12-4: An I<sup>2</sup>C device (left) and FTDI interface (right)</em></p>&#13;
<p class="indent">No extra device drivers are needed for transport—the FTDI behaves as a serial port to the user.</p>&#13;
<h4 class="h4" id="lev247"><em>Controller Area Network Bus</em></h4>&#13;
<p class="noindent">A <em>vehicle bus</em> is a specialized internal communications network that interconnects components inside a vehicle such as an automobile, train, ship, aircraft, or robot. A <em>controller area network (CAN)</em> bus is a type of vehicle bus that has a single public serial channel shared by all devices. CAN has no standard connector, as it isn’t intended for use by consumers, but rather for the internals of vehicles. Usually its wires are soldered directly into the printed circuit boards (PCBs) of the many devices in the vehicle. If you remove the plastic covering in front of the passenger seat in a car, you’ll usually find a wiring loom, which will include accessible CAN wires. Check your vehicle’s service documents to locate and connect to them.</p>&#13;
<p class="indent">CAN usually has four internal wires, which use differential voltages to protect against the strong external electromagnetic fields expected in vehicles, especially around electric motors and engines.</p>&#13;
<p class="indent">CAN security is a current concern. Because it’s a bus, all devices can read and write to it. This may create problems when safety-critical devices, such as antilock brakes, are connected to the same bus as non-critical devices, such as media players. The concern is that security in media and similar devices is typically less rigorous than in the safety equipment. A hacker could take control of a non-critical device and use it to send malicious commands to critical devices, or deny service to them by filling the bus with junk messages. For autonomous vehicles where steering and acceleration are also managed via the CAN bus, the consequences could be particularly severe.</p>&#13;
<p class="indent">Now that you’ve seen the general concepts that go into an embedded system, let’s explore how they show up in practice in the best-known example, the Arduino.</p>&#13;
<h3 class="h3" id="lev248"><span epub:type="pagebreak" id="page_288"/>Arduino</h3>&#13;
<p class="noindent"><em>Arduino</em>, shown in <a href="ch12.xhtml#ch12fig5">Figure 12-5</a>, is the standard embedded system for hackers, makers, and robotics researchers because it packages a microcontroller onto a PCB together with all the power management and I/O that you need to program it from a PC—you can just connect it to your desktop via USB and start programming it, without having to worry about analog power supplies or setting up its USB I/O system by yourself.</p>&#13;
<div class="image"><img id="ch12fig5" src="../images/f0288-01.jpg" alt="Image" width="468" height="318"/></div>&#13;
<p class="figcap"><em>Figure 12-5: An Arduino board. The ATmega328P microcontroller is the large chip near the bottom right.</em></p>&#13;
<p class="indent">The Arduino PCB is an open source hardware design based around a microcontroller from the closed source Atmel AVR family, usually the ATmega328 model. The microcontroller is surrounded by additional hardware that makes powering and interfacing with it both easy and standard. These components were the traditional barrier to computer scientists programming microcontrollers, as they have to be made up on breadboards or PCBs for every project, requiring analog electronics skills. The cleverness of the Arduino design was to select and standardize a single set of these components that are generally useful for many applications, and to manufacture them cheaply in bulk so that end users don’t have to worry about them anymore. Arduino comes with open source software to easily assemble and transfer programs via USB into its firmware. (There’s also a C-like language and compiler, but as this book is about the architectural level, we’ll here study only Arduino’s assembly-level programming.)</p>&#13;
<p class="indent">You can program Arduino by itself—for example, to read numbers sent to it over USB from your desktop, do arithmetic on them, and send the results to your desktop. However, Arduino is usually used to interface with other electronic sensors and actuators, starting with LEDs and switches. Typically you lay these out on a breadboard, then connect wires from the breadboard to your Arduino, as in <a href="ch12.xhtml#ch12fig6">Figure 12-6</a>.</p>&#13;
<div class="image"><span epub:type="pagebreak" id="page_289"/><img id="ch12fig6" src="../images/f0289-01.jpg" alt="Image" width="552" height="292"/></div>&#13;
<p class="figcap"><em>Figure 12-6: An I/O circuit connecting an LED and button to an Arduino using a breadboard and wires</em></p>&#13;
<p class="indent">No soldering is required, as components and wires can be pushed into place in both the breadboard and the Arduino’s connectors.</p>&#13;
<h4 class="h4" id="lev249"><em>The ATmega328 Microcontroller</em></h4>&#13;
<p class="noindent">The classic Arduino microcontroller, the Atmel AVR ATmega328, shown in <a href="ch12.xhtml#ch12fig1">Figure 12-1</a>, behaves somewhat like an old-style 8-bit system such as a 6502. There are 32 8-bit user registers (more than the three of the 6502). There’s an arithmetic logic unit (ALU) that includes integer multiplication and division, but no floating point. Similar to the 6502, there’s an 8-bit status register, containing bits telling you the result of arithmetic calculations to allow branching. The instruction set architecture (ISA) includes indirect addressing and a hardware stack. It’s usually clocked around 20 MHz.</p>&#13;
<p class="indent">The pinout, shown in <a href="ch12.xhtml#ch12fig7">Figure 12-7</a>, is different from a typical CPU, as there’s no external bus.</p>&#13;
<div class="image"><img id="ch12fig7" src="../images/f0289-02.jpg" alt="Image" width="772" height="523"/></div>&#13;
<p class="figcap"><em>Figure 12-7: The pinout of the ATmega328 (note the lack of A and D bus pins)</em></p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_290"/>Instead of an external bus, 14 I/O pins are directly exposed. Pins increase the size of the chip’s package, so they’re a scarce resource. The I/O pins are each configurable to function as either input or output. Their configuration is set and stored using dedicated data direction registers (DDRs).</p>&#13;
<p class="indent">The die shot (<a href="ch12.xhtml#ch12fig8">Figure 12-8</a>) reveals that the microcontroller contains more than just a CPU.</p>&#13;
<div class="image"><img id="ch12fig8" src="../images/f0290-01.jpg" alt="Image" width="795" height="799"/></div>&#13;
<p class="figcap"><em>Figure 12-8: A die shot of the ATmega328</em></p>&#13;
<p class="indent">In addition to a CPU, the chip has 2 k<sub>2</sub>B of SRAM, 32 k<sub>2</sub>B of flash memory, and a 1 k<sub>2</sub>B EEPROM, all on the silicon. In this sense, the chip is really more comparable to an entire retro computer than to only a CPU.</p>&#13;
<p class="indent">The Arduino uses a Harvard architecture. The program you send to the board is programmed into the flash memory using software on your host PC, while the RAM is used for data. (The EEPROM is user-writable, and is provided for applications where small configuration-style data needs to be stored during power-off.) The Harvard architecture uses two separate buses: an 8-bit bus for data and a 16-bit bus for programs. There’s no external memory or bus; the memory is all on the chip.</p>&#13;
<p class="indent">The microcontroller contains serial port pins and I/O modules. On power-on, the microcontroller first runs a small internal ROM program that checks its serial port. If there’s data waiting on the serial port, it’s assumed to be a new user program, which is then loaded into flash. The program counter is set to start the user program.</p>&#13;
<h4 class="h4" id="lev250"><span epub:type="pagebreak" id="page_291"/><em>The Rest of the Arduino Board</em></h4>&#13;
<p class="noindent">While it’s possible to program the ATmega directly from its serial port pins, most desktop machines don’t have physical serial ports anymore, so it’s easier for users to use a virtual serial port running over USB. The Arduino board includes a USB connector and a dedicated chip (actually another, smaller microcontroller) that reads the USB wires and translates them into serial port signals to pass to the ATmega’s pins.</p>&#13;
<p class="indent">Most of the analog electronics on the board are used for power management. The microcontroller requires only a simple 5 V power supply. If a single, stable 5 V is provided, then no further electronics would be needed. However, Arduino is designed to work in several different use cases. In particular, it can be powered by a battery or can take power via a USB cable. The extra components regulate these supplies, protecting the board from peaks and dips, and enabling it to switch between them. (It could otherwise be very bad to allow current from elsewhere to travel back up the USB cable into the connected desktop computer.)</p>&#13;
<p class="indent">An I<sup>2</sup>C bus enables extra extensions to plug into the Arduino. You can get other physical boards (“shields”) that plug into ports on the I<sup>2</sup>C bus, in a nice, physically stackable way.</p>&#13;
<p class="indent">As it’s an open source platform, Arduino has been modified by many designers. For example, Ruggeduino is a hardened (and thus more expensive) version that includes extra safeguards to prevent you from blowing it up in stupid ways. There are also official variants from the Arduino team. The Due is a version with real DACs replacing PWM, the Mega and Giga have larger PCBs to enable more connections, and the Nano has a smaller footprint. Some variants use different microcontrollers, providing more computing power and different instruction sets for those who need or prefer them.</p>&#13;
<h4 class="h4" id="lev251"><em>Programming Arduino</em></h4>&#13;
<p class="noindent">Like all CPUs, Atmel AVRs execute machine code from an instruction set, which you can program by assembling from a human-readable assembly language. The Arduino assembler isn’t very different from the other assemblers we’ve seen so far. You can write, edit, and assemble this assembly code on your desktop PC. The classic “Hello, world!” program for Arduino is to turn on its built-in LED on pin 13:</p>&#13;
<pre>.global main&#13;
main:&#13;
  ldi r16,0b00100000   ; load bits describing eight AVR PB pins into r16&#13;
  out 0x04,r16         ; set AVR pin PB5 (Arduino pin 13) to output mode&#13;
  out 0x05,r16         ; set output on AVR pin PB5 (Arduino pin 13) to ON&#13;
.global loop&#13;
loop:&#13;
  jmp loop</pre>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_292"/>The global <code>main</code> label gets called automatically when the Arduino is powered on. The <code>ldi</code> instruction is “load immediate,” and it loads a constant into a register. This particular constant contains 8 bits, one for each of the AVR’s eight digital I/O pins (labeled PB0 through PB7 in <a href="ch12.xhtml#ch12fig7">Figure 12-7</a>). They’re all set to 0, except for pin PB5 (counting right to left, from PB0, along the binary digits), which is set to 1. The AVR’s PB5 pin is wired to the Arduino PCB’s pin 13 and thus to the LED. The first <code>out</code> instruction copies the bits from r16 to 0x04, the data direction register, to configure the pins for I/O. This sets PB5 to act as an output and the other seven pins to act as inputs. The second <code>out</code> writes the same bits from r16 to 0x05, the “PortB” register, which sets values to output on the eight PB pins. This writes the 1 to PB5 and thus sends a high voltage to turn on the LED on Arduino pin 13.</p>&#13;
<p class="indent">Unlike many CPU programs, the <code>loop</code> label and jump are important because they keep the program running forever. Without these, the LED would light only for a fraction of a second, then go off as the program ends. Embedded programs usually need to run forever like this.</p>&#13;
<p class="indent">A more complex version of the program makes the LED blink on and off:</p>&#13;
<pre>#define DDRB 0x04&#13;
#define PINB 0x03&#13;
.global main&#13;
main:&#13;
  sbi   DDRB, 5         ; set bit IO; port b 5th pin (make pin 13 an output)&#13;
blink:&#13;
  sbi   PINB, 5         ; set bit IO; to toggle PINB&#13;
  ldi   r25, hi8(1000)  ; 1,000 ms delay as argument, hi byte&#13;
  ldi   r24, lo8(1000)  ; 1,000 ms delay as argument, lo byte&#13;
  call  delay_ms&#13;
  jmp   blink&#13;
delay_ms:               ; delay about (r25:r24)*ms. Clobbers r30, and r31&#13;
  ldi   r31, hi8(4000)&#13;
  ldi   r30, lo8(4000)&#13;
innerloop:&#13;
  sbiw    r30, 1        ; subtract immediate value from word&#13;
  brne    innerloop     ; branch if not equal to zero status flag&#13;
  sbiw    r24, 1&#13;
  brne    delay_ms&#13;
  ret</pre>&#13;
<p class="indent">To make the code easier to read, I have here defined DDRB and PINB to represent the data direction register and PortB register. One millisecond is about 16,000 cycles at 16 MHz. The inner loop takes four cycles, so we repeat it 3,000 times.</p>&#13;
<p class="notes"><strong><span class="nt">NOTE</span></strong></p>&#13;
<p class="noindent"><em>The AVR also has some 16-bit instructions that operate on pairs of 8-bit registers together, as in the 6502.</em></p>&#13;
<h3 class="h3" id="lev252"><span epub:type="pagebreak" id="page_293"/>Other CPU-Based Embedded Systems</h3>&#13;
<p class="noindent">Arduino isn’t the only CPU-based embedded system in town. Let’s look at some alternatives that you might encounter.</p>&#13;
<h4 class="h4" id="lev253"><em>Atmel AVR Without the Arduino</em></h4>&#13;
<p class="noindent">Arduino is designed for computer scientists, not engineers. You wouldn’t normally sell a product based on a full Arduino board. Rather, you would create a custom PCB containing the AVR chip plus only the electronics that are needed, both from the Arduino board and from your own design.</p>&#13;
<p class="indent">As an intermediate step, you can use a breadboard without the Arduino to mount the AVR and other electronics, as in <a href="ch12.xhtml#ch12fig9">Figure 12-9</a>.</p>&#13;
<div class="image"><img id="ch12fig9" src="../images/f0293-01.jpg" alt="Image" width="552" height="366"/></div>&#13;
<p class="figcap"><em>Figure 12-9: A breadboard implementation using an AVR microcontroller</em></p>&#13;
<p class="indent">Once you’re happy that your design is working, you turn it into a PCB design using a program such as <em>KiCAD</em>, submit it to a PCB manufacturing company using their website, and receive your PCB in a few days through the mail. You don’t have to solder things yourself nowadays, the PCB manufacturing companies have robots that do it for you.</p>&#13;
<h4 class="h4" id="lev254"><em>PIC Microcontrollers</em></h4>&#13;
<p class="noindent"><em>PIC</em> is another series of microcontrollers, similar to but different from the AVR series. As with Arduinoless AVR, PICs require breadboards, PCB design, and serial ports.</p>&#13;
<p class="indent">PICs are designed by the American company Microchip, who bought out their competitor Atmel in 2016. PICs are found in many consumer and industrial embedded systems. There are a number of PICs to choose from; you decide which to buy based on your needs in terms of speed, power, cost, and physical size. Because of the wide range of options, PICs are more popular than Arduino/AVR in production engineering. The flexibility allows a selected PIC version to be closely matched to its application needs.</p>&#13;
<h4 class="h4" id="lev255"><span epub:type="pagebreak" id="page_294"/><em>Digital Signal Processors</em></h4>&#13;
<p class="noindent"><em>Digital signal processors (DSPs)</em> are a specialized class of microcontroller designed for handling real-time signals, such as audio. Embedded systems working with such signals have particular requirements, as they’re fundamentally working with long—effectively endless—real-time streams of identically formatted data that have to be processed repeatedly in identical ways. This means there isn’t much branching; instead, the data flows through a smooth pipeline from one stage to the next, always being processed in the same way.</p>&#13;
<p class="indent">For example, guitarists often buy and use digital effects boxes that connect between their guitar and amplifier to modify the sound (by adding compression, distortion, delay, or reverb, for example). These boxes are embedded systems containing one or more DSPs, such as the chip shown in <a href="ch12.xhtml#ch12fig10">Figure 12-10</a>.</p>&#13;
<div class="image"><img id="ch12fig10" src="../images/f0294-01.jpg" alt="Image" width="316" height="320"/></div>&#13;
<p class="figcap"><em>Figure 12-10: A DSP chip inside a guitar digital effects unit</em></p>&#13;
<p class="indent">DSPs aren’t only for audio signals, though. There are many other types of signals with similar properties, such as video, radar, and data streams from all kinds of medical and scientific monitoring instruments. With sound and sound-like data, you can often mostly get away with representing directly quantized sound waves from the ADC. With video, however, the data is usually so huge that it needs to be compressed during storage and transmission, which means many DSP units are used primarily to perform compression and decompression.</p>&#13;
<p class="indent">DSPs often use fixed-point number representation (as discussed in <a href="ch02.xhtml">Chapter 2</a>) rather than integers or floating point. This is because most signals have clear, fixed upper and lower bounds that can be rescaled to +1.0 and –1.0. For example, musical audio is usually recorded in this way, with any signal outside these bounds being clipped. Fixed point is cheaper and simpler to implement than floating point, but can give similar quality results for these kinds of signals.</p>&#13;
<p class="indent">DSPs use their available silicon to provide additional instructions dedicated to signal processing. (Recall from <a href="ch08.xhtml">Chapter 8</a> that adding extra domain-specific instructions like this is often considered to be the CISC philosophy.) <span epub:type="pagebreak" id="page_295"/>For example, special instructions for fast Fourier transforms and convolution are found in DSPs designed for embedded audio use, as these operations form the basis of many standard audio processing algorithms. These usually operate in fixed point. As DSPs are designed to process large streams of data, they sometimes include additional instructions that load and store chunks of data larger than single words. Such instructions may trigger a sequence of transfers over the bus from a series of neighboring memory locations to a group of registers. Similarly, I/O instructions may trigger a series of ADCs to and from these groups of registers.</p>&#13;
<p class="indent">As with standard microcontrollers, DSPs use a Harvard architecture, so that firmware can be placed in ROM during manufacture, then left alone to run forever.</p>&#13;
<h3 class="h3" id="lev256">Embedded Systems with No CPU</h3>&#13;
<p class="noindent">The embedded systems we’ve seen so far have been microcontroller-based, meaning they’re still based around a CPU that executes programs of machine code instructions. But there are also other, simpler styles of embedded systems where there’s no CPU, no program, and no instruction set. There’s only hardware that you lay out to compute what you want to be computed, using digital logic circuits. These systems include PLCs and FPGAs.</p>&#13;
<h4 class="h4" id="lev257"><em>Programmable Logic Controllers</em></h4>&#13;
<p class="noindent"><em>Programmable logic controllers (PLCs)</em> are a type of embedded system designed to perform simple computations to control machinery in industrial environments, with very high reliability. They’re usually found in factories with dust, chemicals, bits of food, high and low temperatures, and other extreme conditions that make life hard for normal chips. The idea is to install something durable that can operate continuously for 20 years, without ever going down. Systems have to be almost indestructible, utterly reliable, and as simple as possible to avoid any kind of bugs slipping in. In this context of industrial automation, embedded systems are sometimes known as <em>supervisory control and data acquisition (SCADA)</em> systems.</p>&#13;
<p class="indent">You’ll see PLCs in these kinds of environments, usually packaged in what are called DIN modules and mounted on standard DIN rails, as in <a href="ch12.xhtml#ch12fig11">Figure 12-11</a>.</p>&#13;
<p class="indent">In your house—often in a basement or under the stairs—you might have a DIN-style module that acts as a fuse box or circuit breaker (aka a residual current device, or RCD) for your whole house. Again, it’s robust engineering that’s designed not to fail under any normal operating circumstances. The DIN design was standardized in the 1970s and is still with us today.</p>&#13;
<div class="image"><span epub:type="pagebreak" id="page_296"/><img id="ch12fig11" src="../images/f0296-01.jpg" alt="Image" width="552" height="368"/></div>&#13;
<p class="figcap"><em>Figure 12-11: DIN modules mounted on a DIN rail</em></p>&#13;
<p class="indent">A PLC doesn’t run a program in the sense of a series of instructions; instead, its function is usually specified using a visual system called <em>ladder logic</em>, as shown in <a href="ch12.xhtml#ch12fig12">Figure 12-12</a>.</p>&#13;
<div class="image"><img id="ch12fig12" src="../images/f0296-02.jpg" alt="Image" width="551" height="746"/></div>&#13;
<p class="figcap"><em>Figure 12-12: An example of a ladder logic configuration for an embedded device</em></p>&#13;
<p class="indent">In essence, ladder logic is a set of if-then rules that say that if one input is high, then connect a wire to another wire. There’s no program starting at the top and working through a list of instructions; each unit follows the logic of the rules around it. It’s derived from the old days where you’d make computers from physical electromechanical relays.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_297"/>Ladder logic is so simple that even engineers can do it. But the simplicity also means that both formal methods and intuitive inspection can be used to verify that systems do exactly what they’re supposed to do. You wouldn’t want all the complexity of an operating system and modern programming languages and compilers when even tiny bugs in any of that could cause your nuclear fuel rods to move to the wrong place; everything has to be absolutely reliable and understandable.</p>&#13;
<p class="indent">PLCs are simple, completely transparent, and verifiable. It may surprise you to learn that the engineers programming this equipment often make more than most computer scientist programmers, but they’re also getting paid to take responsibility for safety. The program might exist as part of a nuclear power station where, even if the program is very simple, it has to be very correct. You don’t have to design PLCs by directly configuring the ladder logic anymore; there are now compilers and assemblers that will turn C code into these configurations for you. Doing this, of course, requires trusting the compiler and assembler programs, as well as your own code.</p>&#13;
<div class="sidebar">&#13;
<p class="stitle"><strong>EMBEDDED SECURITY</strong></p>&#13;
<p class="stext">SCADA systems should never be connected to the public internet. A famous leading question used in security audits asks SCADA managers, “How would you connect to the system in an emergency, when all the staff are away working at home and they need to take over control remotely before the nuclear fuel rod goes critical?” A worrying number of managers will then proudly explain that they do in fact have such a connection, which of course can be exploited by hackers.</p>&#13;
<p class="stext">Even when there’s no internet connection and the system is separated from the network by an “air gap,” it is possible to gain access. The 2010 Stuxnet worm was distributed on USB sticks left around international academic conferences. It replicated itself from USB stick to USB stick around the world until it reached the Iranian nuclear weapons fuel enrichment centrifuge embedded systems. Stuxnet then affected only their specific model and configuration of PLC, altering its behavior very subtly and almost undetectably to change the timing of the centrifuges, destroying them and preventing enrichment of the fuel.</p>&#13;
</div>&#13;
<h4 class="h4" id="lev258"><em>Embedded FPGAs</em></h4>&#13;
<p class="noindent">The FPGA (field programmable gate array) chips discussed in <a href="ch05.xhtml">Chapter 5</a> can be used to actualize any digital logic designs—not only those intended for use in or with CPUs. This can include PLC-like structures and many other digital logic network designs.</p>&#13;
<p class="indent">As embedded systems perform single functions, a CPU design capable of running arbitrary programs of instructions may be both overkill and inefficient. Instead, the particular sequence of arithmetic or other transformations can be implemented directly as a sequence of simple machines, pipelined together in an FPGA. This can include, for example, placing multiple adders and multipliers connected in the specific sequence needed to <span epub:type="pagebreak" id="page_298"/>implement your signal processing algorithm. In addition to reducing the CPU-style paraphernalia needed, this can also make systems run very fast, as all these arithmetic operations can happen in parallel.</p>&#13;
<p class="indent">Hardware description languages can be especially useful for creating such designs. For example, they enable the arithmetic steps to be expressed in a C-like language before being automatically compiled to the appropriate digital logic.</p>&#13;
<div class="sidebar">&#13;
<p class="stitle"><strong>UBIQUITOUS VS. MINDFUL COMPUTING</strong></p>&#13;
<p class="stext"><em>Ubicomp</em>, or Ubiquitous Computing, is an embedded design philosophy founded by Marc Wiser in the 1980s Xerox PARC (the same place where the mouse and graphical desktop were invented). Its core idea, as outlined by Marc Weiser, is that “the purpose of a computer is to help you do something else. The best computer is a quiet, invisible servant. The more you can do by intuition the smarter you are; the computer should extend your unconscious. Technology should create calm.”</p>&#13;
<p class="stext">Ubicomp shows up in products such as Amazon’s Alexa. It sits invisibly in your house, and when you want something, you say it out loud and it gets done for you. There’s no need for you to sit down at a computer and think about how to do it. Ubicomp ideas have also returned in recent fields such as “pervasive computing” and the Internet of Things.</p>&#13;
<p class="stext">There has recently been a counter-movement against Ubicomp, which we might call <em>mindful computing</em>. Its adherents have decided that users don’t want decisions made for them by an uncertain, non-understood corporate cloud. They’re freaked out about losing control to these machines. Mindful computing therefore does the opposite, deliberately drawing attention to the technology and forcing users to think about and understand the machines they’re using.</p>&#13;
<p class="stext">According to a Ubicomp philosophy, light switches might disappear as machines automatically predict when the lights should turn themselves on and off without your input. According to mindful computing, the light switches should remain, and the user should devote their full conscious attention to becoming at one with the light switch as they touch it.</p>&#13;
</div>&#13;
<h3 class="h3" id="lev259">Summary</h3>&#13;
<p class="noindent">Embedded architectures form the vast bulk of the world’s computers, yet by their nature they’re often invisible to most users. Their applications exist at the border between computing and engineering, but their architectures can be quite similar to those of retro computers, and they provide an interesting place for fans of that style of computing to work today. Most embedded systems are based on microcontrollers, which are chips that combine a low-power CPU with onboard memory, I/O, and other useful features. Arduino is a standard embedded platform that wraps most of the engineering needed for computer scientists to get started interfacing to hardware such as robots, factories, cars, and art installations.</p>&#13;
<h3 class="h3" id="lev260"><span epub:type="pagebreak" id="page_299"/>Exercises</h3>&#13;
<h4 class="h4a"><strong>Simulated Arduino Programming</strong></h4>&#13;
<ol class="number">&#13;
<li class="tm">Use the open source Wokwi Arduino emulator to run the example Arduino programs shown in this chapter. To use the assembler, go to the blink.S tab at <em><a href="https://wokwi.com/arduino/projects/290348681199092237">https://wokwi.com/arduino/projects/290348681199092237</a></em>, or find the offline version at <em><a href="https://github.com/arcostasi/avr8js-electron-playground">https://github.com/arcostasi/avr8js-electron-playground</a></em>.</li>&#13;
<li class="tm">Remember that Arduino’s I/O pins are each configurable to act as inputs or outputs. If a pin isn’t reading or writing as expected, check that you’ve put it into the right mode first.</li>&#13;
<li class="tm">Instead of the nested delay loops used in the LED blinking program, a prettier and more energy-efficient way to program blinking lights is to use the AVR’s built-in timer. Research what registers and commands are needed to do it this way, and implement this alternative version.</li>&#13;
</ol>&#13;
<h4 class="h4a"><strong>Challenging</strong></h4>&#13;
<ol class="number">&#13;
<li class="tm">There are many affordable Arduino starter kits available; obtain one and try to run the example programs on the real hardware. When working with real LEDs, remember that as diodes they’re directional and must be connected the right way around and always in parallel with a resistor; otherwise, they’ll explode!</li>&#13;
<li class="tm">Most kits come with some additional sample programs written in Arduino C; try to reproduce their functionality using your own handwritten AVR assembly. (If stuck, try compiling the Arduino C into assembly and inspecting that to get ideas.)</li>&#13;
<li class="tm">If you prefer command line tools to the Arduino IDE, AVRA is the AVR assembler, and AVRDUDE is the AVR downloader/uploader.</li>&#13;
</ol>&#13;
<h3 class="h3" id="lev261">Further Reading</h3>&#13;
<ul class="bullet">&#13;
<li class="tm">For a famous parable about engineers’ and computer scientists’ differing opinions on embedded design, see Do-While Jones, “The Breakfast Food Cooker.” Various versions can be found around the internet, dating from 1990.</li>&#13;
<li class="tm">For a full reference for the AVR instruction set, see Atmel, “AVR-Instruction-Set-Manual,” 2016, <em><a href="https://ww1.microchip.com/downloads/en/DeviceDoc/Atmel-0856-AVR-Instruction-Set-Manual.pdf">https://ww1.microchip.com/downloads/en/DeviceDoc/Atmel-0856-AVR-Instruction-Set-Manual.pdf</a></em>.</li>&#13;
<li class="tm">For an Arduino PCB design explanation and CAD files, see the “Arduino from Scratch” series, <em><a href="https://rheingoldheavy.com/arduino-from-scratch-series">https://rheingoldheavy.com/arduino-from-scratch-series</a></em>.</li>&#13;
<li class="tm">For information on programming PIC microcontrollers, see “PIC Programming in Assembly,” <em><a href="https://groups.csail.mit.edu/lbr/stack/pic/pic-prog-assembly.pdf">https://groups.csail.mit.edu/lbr/stack/pic/pic-prog-assembly.pdf</a></em>.</li>&#13;
<li class="tm"><span epub:type="pagebreak" id="page_300"/>To get your hands dirty with a CAN bus, see Jared Reabow, “How to Hack and Upgrade Your Car Using CAN Bus and Arduino,” <em><a href="https://www.instructables.com/How-to-Hack-and-Upgrade-Your-Car-Using-CAN-Bus/">https://www.instructables.com/How-to-Hack-and-Upgrade-Your-Car-Using-CAN-Bus/</a></em>. The tutorial includes instructions for making a <em>Back to the Future</em>–style date and time display.</li>&#13;
<li class="tm">Hackaday (<em><a href="https://www.hackaday.com">https://www.hackaday.com</a></em>) is a well-known website for embedded project ideas.</li>&#13;
</ul>&#13;
</div>
</div>
</body></html>