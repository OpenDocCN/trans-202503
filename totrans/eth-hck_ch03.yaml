- en: '**3'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: ANALYZING CAPTURED TRAFFIC**
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: '*The internet is just a world passing notes around a classroom.*'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: –Jon Stewart
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/common.jpg)'
  id: totrans-4
  prefs: []
  type: TYPE_IMG
- en: In [Chapter 2](ch02.xhtml#ch2), you learned how a hacker in a coffee shop could
    use an ARP spoofing attack to intercept a victim’s internet traffic. Now let’s
    actually view that traffic. In this chapter, we’ll use two tools, *Wireshark*
    and *TCPDump*, to steal private data from the unencrypted packets we intercepted.
    I’ll also introduce the concept of a protocol and discuss the general software
    architecture of the internet. We’ll conclude by analyzing the packets collected
    by your firewall so that you can detect attacks on your network.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
- en: '**Packets and the Internet Protocol Stack**'
  id: totrans-6
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A *protocol* is a set of rules that governs the communication between systems.
    For example, when humans communicate, we first exchange “Hello” messages and then
    exchange information before ending the conversation with “Goodbye.” Similarly,
    when a browser wants to learn the IP address of a website such as *[https://cs.virginia.edu/](https://cs.virginia.edu/)*,
    it uses the *Domain Name System (DNS)* protocol to communicate with a DNS server.
    It begins by sending a DNS query requesting the IP address for *[https://cs.virginia.edu/](https://cs.virginia.edu/)*.
    The DNS server will then respond with the IP address. [Figure 3-1](ch03.xhtml#ch3fig1)
    shows protocol sequence diagrams for both human communication and the DNS protocol.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/ch03fig01.jpg)'
  id: totrans-8
  prefs: []
  type: TYPE_IMG
- en: '*Figure 3-1: A protocol sequence diagram showing an example human communication
    protocol and the DNS communication protocol*'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
- en: In addition to governing communication rules, a protocol determines how information
    is laid out in a packet. In English, we often say “Hello, Alice” and rarely “Alice
    Hello,” because the English language dictates that the greeting should precede
    the name. The same is true for internet protocols. They usually require the packet
    header to contain specific information. Returning to the letter example from [Chapter
    2](ch02.xhtml#ch2), [Figure 3-2](ch03.xhtml#ch3fig2) shows how address fields
    on an envelope are analogous to packet headers.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/ch03fig02.jpg)'
  id: totrans-11
  prefs: []
  type: TYPE_IMG
- en: '*Figure 3-2: How header fields in a packet are like addresses on an envelope*'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
- en: In addition to IP addresses, this figure contains header fields for the source
    and destination *port numbers*, which are assigned by the operating system when
    it allows a process to communicate over the network. Port numbers are unique,
    meaning that no two processes on a machine can use the same port number. A *process*
    is an abstraction that represents a running program. For example, when you open
    your web browser, your computer’s operating system starts a process that is associated
    with that browser. When a process wants to send and receive information through
    the network, the operating system assigns that process a port number. You can
    think of this number as being like a shipping port. For example, packets intended
    for your web server will usually arrive at your IP address 192.168.1.100 on port
    443\. In other words, ports expose internal processes to the network.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
- en: Ports are necessary because they allow multiple processes on your computer to
    communicate with the internet simultaneously, as illustrated in [Figure 3-3](ch03.xhtml#ch3fig3).
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/ch03fig03.jpg)'
  id: totrans-15
  prefs: []
  type: TYPE_IMG
- en: '*Figure 3-3: How ports allow packets to flow in and out of a system*'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
- en: When your operating system receives a packet from the network, it examines the
    port number to decide whether the packet is intended for your browser or messenger.
    However, ports also create a security risk because they open your computer to
    outside attackers. Often, one of the first things an attacker will do is scan
    a machine to discover open ports. A port is open if it accepts a connection from
    an external process. If the attacker finds an open port, they will attempt to
    infect your machine by sending it malicious packets. We’ll discuss how to scan
    for open ports and exploit the associated vulnerable process in [Chapter 4](ch04.xhtml#ch4).
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
- en: '***The Five-Layer Internet Protocol Stack***'
  id: totrans-18
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: To address the complexity of designing software for the internet, engineers
    decided to abstract the architecture into five independent layers. Each layer
    is responsible for managing the communication between specific components in the
    network. For example, the network layer manages communication between routers
    on the internet, whereas the application layer manages communication between applications,
    such as BitTorrent clients.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
- en: Each layer is independent, meaning its actions aren’t affected by the actions
    performed at the other layers. The protocol stack achieves this through a process
    called *encapsulation*, in which each layer treats information from the layers
    above it as generic data and does not try to interpret it. [Figure 3-4](ch03.xhtml#ch3fig4)
    shows how information is encapsulated at each layer before it is finally transmitted
    at the physical layer.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/ch03fig04.jpg)'
  id: totrans-21
  prefs: []
  type: TYPE_IMG
- en: '*Figure 3-4: Five-layer internet protocol stack*'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
- en: Let’s say a user composes an email. This happens at the application layer. As
    you can see, the messages associated with the email are then placed in transport
    layer packets. The transport layer does not read or alter the email in any way.
    It simply labels the packet with the information needed to process it. These transport
    layer packets are then placed into network layer packets and then data link layer
    packets before they are finally transmitted. By encapsulating and labeling each
    packet with its own headers, each layer can make decisions without depending on
    information from another layer. [Figure 3-5](ch03.xhtml#ch3fig5) shows an overview
    of the five-layer internet protocol stack, along with its headers and components.
    This layered approach allows two components in the same layer to communicate as
    though they were the only components in the network. For example, when your web
    browser makes a request to *[https://google.com](https://google.com)*, it is completely
    unaware of the routers that handle the request. Thus, it appears as though the
    web browser were directly communicating with the Google server. Now let’s look
    more closely at each layer.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 假设用户正在编写电子邮件。这发生在应用层。如你所见，邮件相关的消息随后被放置在传输层的数据包中。传输层不会以任何方式读取或修改电子邮件内容。它只是将处理所需的信息标记在数据包上。这些传输层数据包随后被放入网络层数据包中，再经过数据链路层数据包，最终才会被传输。通过将每个数据包封装并用其自己的头部进行标记，每一层可以在不依赖于其他层的信息的情况下做出决策。[图
    3-5](ch03.xhtml#ch3fig5)展示了五层互联网协议栈的概览，以及其头部和组成部分。这种分层的方法允许同一层的两个组件像网络中唯一的组件一样进行通信。例如，当你的网页浏览器向
    *[https://google.com](https://google.com)* 发送请求时，它完全不知道处理该请求的路由器。因此，看起来就像是网页浏览器直接与
    Google 服务器进行通信。现在让我们更仔细地看看每一层。
- en: '![image](../images/ch03fig05.jpg)'
  id: totrans-24
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/ch03fig05.jpg)'
- en: '*Figure 3-5: The network components that are communicating at each layer of
    the five-layer internet protocol stack*'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 3-5：五层互联网协议栈中每一层的网络组件通信情况*'
- en: '**The Application Layer**'
  id: totrans-26
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**应用层**'
- en: The *application layer* is responsible for communications between applications;
    for example, between your Firefox browser and the University of Virginia web servers.
    There are several application layer protocols. The *hypertext transfer protocol
    (HTTP)* sends web pages to browsers, and the *file transfer protocol (FTP)* uploads
    files to a server. This is one of the easiest layers for which software developers
    can define their own protocols. DNS, FTP, and BitTorrent are a few examples of
    application layer protocols. Throughout this book, you’ll modify various application
    layer protocols. For example, in [Chapter 7](ch07.xhtml#ch7), you’ll write a Python
    program that sends a fake email using a modified version of the simple mail transfer
    protocol (SMTP). Some malicious programs define custom protocols to avoid detection,
    whereas others use existing protocols in unexpected ways, such as using DNS for
    *command and control*. Not to worry, I’ll discuss this in the next chapter, when
    you’ll implement your own simple custom application layer protocol.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '*应用层*负责应用程序之间的通信；例如，在你的 Firefox 浏览器和弗吉尼亚大学的网页服务器之间。应用层协议有多种。*超文本传输协议（HTTP）*将网页发送到浏览器，而*文件传输协议（FTP）*将文件上传到服务器。这是软件开发人员可以定义自己协议的最简单层之一。DNS、FTP
    和 BitTorrent 是一些应用层协议的例子。在本书中，你将修改各种应用层协议。例如，在[第七章](ch07.xhtml#ch7)中，你将编写一个使用修改版简单邮件传输协议（SMTP）发送假电子邮件的
    Python 程序。一些恶意程序定义了自定义协议来避免被检测，而其他程序则以意想不到的方式使用现有协议，例如使用 DNS 进行*命令与控制*。不用担心，我将在下一章讨论这个问题，届时你将实现自己的简单自定义应用层协议。'
- en: '**The Transport Layer**'
  id: totrans-28
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**传输层**'
- en: 'The *transport layer* is responsible for managing communication between processes
    communicating over the internet. Because of limitations in its design, the internet
    does not always reliably deliver packets. You may have noticed dropped packets
    while video chatting or playing a game. This layer has two main protocols: the
    *transmission control protocol (TCP)*, which provides a guarantee that packets
    have reached their destination, and the *user datagram protocol (UDP)*, which
    is less complex and provides no guarantees.'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '*传输层*负责管理通过互联网进行通信的进程之间的通信。由于其设计上的局限性，互联网并不总是可靠地传输数据包。你可能已经注意到，在视频聊天或玩游戏时，数据包丢失的情况。这一层有两个主要协议：*传输控制协议（TCP）*，它保证数据包已到达目的地，和*用户数据报协议（UDP）*，它较为简单，且不提供任何保证。'
- en: '**The Network Layer**'
  id: totrans-30
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**网络层**'
- en: 'The *network layer* is responsible for controlling how packets flow between
    routers in the network. IP addresses are implemented at this layer. You can see
    every router your packets pass through by using the `traceroute` tool. The `traceroute`
    tool uses a network layer protocol called the *internet control message protocol
    (ICMP)* to construct packets that probe the network to learn the path a packet
    takes. You can run `traceroute` using the following command:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The command probes each router with three packets and then records the time
    it takes for each packet to reach the router. As you can see, the first router
    we encounter is the pfSense router in our lab environment. The second router is
    the one in the coffee shop.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
- en: '**The Data Link Layer**'
  id: totrans-34
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: The *data link layer* is responsible for communication between NICs. It also
    detects errors that might have occurred during transmissions. For example, Wi-Fi
    signals may become corrupted during transmission due to interference from other
    radio signals. The data link layer also implements the MAC protocol, which is
    responsible for sharing the *transmission medium* (for example, radio spectrum
    or wires). Consider the laptops in the coffee shop. How is it possible for all
    of these machines to transmit Wi-Fi radio waves without interfering with one another?
    Well, Wi-Fi implements a MAC protocol called *carrier sense multiple access*,
    which listens to the Wi-Fi signals and then transmits only when no one else is
    transmitting. Essentially, the laptops in the coffee shop are waiting their turn
    by listening for an empty slot.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
- en: '**The Physical Layer**'
  id: totrans-36
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: The *physical layer* is responsible for converting the ones and zeros that represent
    data in a computer into a transmittable form. This could mean translating them
    into pulses of light, radio or electrical signals, or even sound. For example,
    communications at the physical layer might use a laser that emits pulses of light
    into a fiber-optic cable.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
- en: '**Viewing Packets in Wireshark**'
  id: totrans-38
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Now let’s examine some packets. Wireshark is a tool that allows you to capture
    and view the packets that flow through your NIC. It’s installed by default in
    most Kali Linux installations. To launch Wireshark, click **Applications** ▶**Sniffing
    and Snooping** ▶**Wireshark**, or open a terminal window and run the following
    command:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'If Wireshark is not installed, install it by running the following:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: It’s important to run Wireshark with root privileges so it has unrestricted
    access to your computer’s interfaces. After you start Wireshark, you should see
    a welcome screen similar to [Figure 3-6](ch03.xhtml#ch3fig6).
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/ch03fig06.jpg)'
  id: totrans-44
  prefs: []
  type: TYPE_IMG
- en: '*Figure 3-6: The Wireshark welcome screen*'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
- en: The welcome screen lists the interfaces your machine uses to communicate with
    the network. Because all of our virtual lab’s devices are attached to an Ethernet
    interface, we’ll monitor traffic on the `eth0` interface. Select this interface
    by clicking **eth0**. On the other hand, if you want to monitor Wi-Fi traffic,
    you should select the **wlan** interface. A third interface, labeled **lo**, represents
    a virtual network interface called the *loopback interface*, which redirects traffic
    back to the machine itself.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 欢迎屏幕列出了您的计算机用来与网络通信的接口。由于我们虚拟实验室的所有设备都连接到以太网接口，我们将监控 `eth0` 接口上的流量。通过点击**eth0**来选择此接口。另一方面，如果您想监控
    Wi-Fi 流量，应选择**wlan**接口。第三个接口，标记为**lo**，表示一个名为 *回环接口* 的虚拟网络接口，它将流量重定向回计算机本身。
- en: Let’s use Wireshark to view the packets we intercepted during the ARP spoofing
    attack in [Chapter 2](ch02.xhtml#ch2). Recall that an ARP spoofing attack tricks
    the network into routing the victim’s incoming and outgoing traffic through the
    hacker’s NIC. [Figure 3-7](ch03.xhtml#ch3fig7) shows an overview of how we use
    Wireshark to view the packets intercepted during an ARP spoofing attack. Packets
    are duplicated as they enter the NIC, and the copies are sent directly to Wireshark
    using operating system drivers in the NPCAP library. Simultaneously, the card
    forwards the original packets to the victim’s NIC, where they are sent to the
    victim’s browser. The browser displays the web page (*[http://facebook.com/](http://facebook.com/)*,
    in this example) and the victim remains completely unaware that their packets
    were intercepted.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用 Wireshark 查看我们在 [第 2 章](ch02.xhtml#ch2) 中进行 ARP 欺骗攻击时拦截到的数据包。回想一下，ARP
    欺骗攻击会欺骗网络，将受害者的进出流量通过黑客的网络接口卡（NIC）进行路由。[图 3-7](ch03.xhtml#ch3fig7) 显示了我们如何使用 Wireshark
    查看在 ARP 欺骗攻击中拦截的数据包的概览。数据包在进入网络接口卡时会被复制，并通过操作系统驱动程序在 NPCAP 库中直接发送到 Wireshark。同时，网卡将原始数据包转发到受害者的
    NIC，受害者的浏览器将显示网页（例如：*http://facebook.com/*），而受害者完全没有意识到他们的数据包已被拦截。
- en: '![image](../images/ch03fig07.jpg)'
  id: totrans-48
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/ch03fig07.jpg)'
- en: '*Figure 3-7: Interactions between Wireshark and the NIC*'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 3-7: Wireshark 与 NIC 之间的交互*'
- en: To avoid having to re-execute an ARP spoofing attack, we’ll examine packets
    we generate ourselves on the Kali Linux virtual machine. However, if you wanted
    to perform another ARP spoofing attack, you could still use the steps described
    here.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免重新执行 ARP 欺骗攻击，我们将检查在 Kali Linux 虚拟机上生成的数据包。但是，如果您想执行另一次 ARP 欺骗攻击，您仍然可以使用这里描述的步骤。
- en: 'First, we’ll pretend to be the victim and generate some web traffic by accessing
    the web server on the Metasploitable machine. Because we didn’t configure a DNS
    server in our setup, our victim can’t access the Metasploitable server by entering
    a URL like *[http://www.evil.corp/](http://www.evil.corp/)*. Instead, we’ll manually
    obtain the server’s IP address. Log in to the Metasploitable machine using the
    username **msfadmin** and password **msfadmin**. When you’ve logged in, run the
    following command to obtain its IP address:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将假装是受害者，并通过访问 Metasploitable 机器上的 web 服务器来生成一些网络流量。由于我们在设置中没有配置 DNS 服务器，受害者无法通过输入像
    *[http://www.evil.corp/](http://www.evil.corp/)* 这样的 URL 来访问 Metasploitable 服务器。相反，我们将手动获取服务器的
    IP 地址。使用用户名 **msfadmin** 和密码 **msfadmin** 登录 Metasploitable 机器。登录后，运行以下命令来获取其
    IP 地址：
- en: '[PRE3]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The value after `inet addr:` is the IP address.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '`inet addr:` 后面的值是 IP 地址。'
- en: 'Back in Kali Linux, start the packet capture process by clicking the shark
    fin icon (![image](../images/icon.jpg)) in the upper-left corner of the Wireshark
    screen. Next, we will pretend to be the victim and generate packets by opening
    the Firefox browser and entering the server’s IP address into the address bar;
    for example: *http://192.168.1.101/* (your machine might have a different address).
    [Figure 3-8](ch03.xhtml#ch3fig8) shows the three main sections of the Wireshark
    capture screen.'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 回到 Kali Linux，点击 Wireshark 屏幕左上角的鲨鱼鳍图标 (![image](../images/icon.jpg)) 开始数据包捕获过程。接下来，我们将假装是受害者，并通过打开
    Firefox 浏览器并在地址栏中输入服务器的 IP 地址来生成数据包，例如：*http://192.168.1.101/*（您的机器可能有不同的地址）。[图
    3-8](ch03.xhtml#ch3fig8) 显示了 Wireshark 捕获屏幕的三个主要部分。
- en: '![image](../images/ch03fig08.jpg)'
  id: totrans-55
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/ch03fig08.jpg)'
- en: '*Figure 3-8: The Wireshark window*'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 3-8: Wireshark 窗口*'
- en: If you choose to do this in the context of an ARP-spoofing attack you would
    generate the traffic from the victim machine instead of the Kali Linux machine.
    Once the page has loaded, click the red stop icon (![image](../images/icon1.jpg))
    to end the capture. Notice that the process of opening the browser and visiting
    a single web page generated more than 4,000 packets!
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你选择在 ARP 欺骗攻击的上下文中进行此操作，你需要从受害者机器而非 Kali Linux 机器生成流量。页面加载完成后，点击红色停止图标 (![image](../images/icon1.jpg))
    以结束抓包。注意，打开浏览器并访问单个网页的过程中生成了超过 4000 个数据包！
- en: 'How could an attacker possibly sift through all of this information to learn
    more about the victim? Not to worry: Wireshark contains a filter function that
    allows you to find the packets that interest you. Let’s assume that you’re interested
    in viewing only packets that have been sent to the Metasploitable server at the
    IP address 192.168.1.101 (remember, your IP address may be different). Enter the
    following command into the filter box so that Wireshark will display only the
    packets exchanged with the Metasploitable server.'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 攻击者如何可能从所有这些信息中筛选出与受害者相关的内容呢？不用担心：Wireshark 提供了一个过滤功能，可以帮助你找到感兴趣的数据包。假设你只想查看发送到
    IP 地址为 192.168.1.101（记住，你的 IP 地址可能不同）的 Metasploitable 服务器的数据包。将以下命令输入过滤框中，Wireshark
    就会只显示与 Metasploitable 服务器交换的数据包。
- en: '[PRE4]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Let’s examine this command closely. Here, we are limiting the packets to only
    those with a destination IP address (`ip.dst`) of 192.168.1.101\. [Figure 3-9](ch03.xhtml#ch3fig9)
    shows the result of running this filter query.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们仔细查看这个命令。在这里，我们将数据包限制为目标 IP 地址（`ip.dst`）为 192.168.1.101 的数据包。[图 3-9](ch03.xhtml#ch3fig9)
    显示了运行此过滤器查询的结果。
- en: '![image](../images/ch03fig09.jpg)'
  id: totrans-61
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/ch03fig09.jpg)'
- en: '*Figure 3-9: Filtering packets in Wireshark*'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 3-9：在 Wireshark 中筛选数据包*'
- en: 'Filtering packets to include only those that are sent to the server reduces
    the number of packets you need to examine. Once you understand the general syntax
    of Wireshark display filters, you can construct filters of your own. Here is the
    structure of a Wireshark filter:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 仅筛选发送到服务器的数据包可以减少你需要检查的数据包数量。一旦你了解了 Wireshark 显示过滤器的一般语法，你就可以构造自己的过滤器。以下是 Wireshark
    过滤器的结构：
- en: '[PRE5]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'First, specify the protocol (`[Protocol]`); for example, TCP or IP. Next, specify
    the packet field you’d like to filter on; for example, the source IP address (`src`)
    or destination IP address (`dst`). Lastly, specify an operator and value; for
    example, not equal to (`!=`) 192.168.1.10\. Using this structure, we will construct
    a filter that displays only packets with the server’s source IP address, as follows:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，指定协议（`[Protocol]`）；例如，TCP 或 IP。接下来，指定你希望过滤的数据包字段；例如，源 IP 地址（`src`）或目标 IP
    地址（`dst`）。最后，指定操作符和值；例如，不等于（`!=`）192.168.1.10。使用这个结构，我们将构造一个过滤器，只显示源 IP 地址为服务器的数据包，如下所示：
- en: '[PRE6]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Wireshark also allows you to filter packets based on their content. For example,
    an attacker might find packets that contain terms like *password*, *email*, or
    *@virginia*. You can search all TCP packets for the term *login* using the following
    filter:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: Wireshark 还允许你根据数据包的内容进行筛选。例如，攻击者可能会查找包含 *password*、*email* 或 *@virginia* 等词语的数据包。你可以使用以下过滤器搜索所有
    TCP 数据包中包含 *login* 的数据包：
- en: '[PRE7]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Armed with these filtering techniques, let’s identify the TCP packets transmitted
    between the server and the Kali Linux machine. Right-click one of the packets
    with the destination address of the Metasploitable server and select **Conversation
    Filter** ▶**TCP**, as shown in [Figure 3-10](ch03.xhtml#ch3fig10). This will display
    only the packets exchanged between the Kali Linux virtual machine and the Metasploitable
    server.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这些过滤技巧，我们来识别服务器与 Kali Linux 机器之间传输的 TCP 数据包。右键点击一个目标地址为 Metasploitable 服务器的数据包，并选择
    **会话过滤** ▶ **TCP**，如 [图 3-10](ch03.xhtml#ch3fig10) 所示。这将只显示 Kali Linux 虚拟机与 Metasploitable
    服务器之间交换的数据包。
- en: '![image](../images/ch03fig10.jpg)'
  id: totrans-70
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/ch03fig10.jpg)'
- en: '*Figure 3-10: TCP conversation filtering*'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 3-10：TCP 会话过滤*'
- en: 'This is equivalent to the following filter:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 这相当于以下过滤器：
- en: '[PRE8]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Now, why are there so many packets if all we did was load a single web page?
    This happens because the server breaks the web page into smaller pieces and then
    transmits them as separate packets if a file is too large to be transmitted in
    a single packet. The recipient will reassemble these packets to recover the original
    file.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，为什么会有这么多数据包呢？我们只加载了一个网页。发生这种情况是因为服务器将网页分成更小的部分，如果文件太大而无法在一个数据包中传输，它会将这些部分作为独立的数据包发送。接收方将重新组装这些数据包以恢复原始文件。
- en: Wireshark lets you reconstruct this data from a packet stream by clicking a
    packet and selecting **Follow** ▶**TCP Stream**, as shown in [Figure 3-11](ch03.xhtml#ch3fig11).
    If you do this, you should see the HTML corresponding to the page.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: Wireshark 允许你通过点击数据包并选择 **Follow** ▶**TCP Stream** 来重建数据流，如 [图 3-11](ch03.xhtml#ch3fig11)
    所示。如果你这样做，你应该能看到对应页面的 HTML 内容。
- en: '![image](../images/ch03fig11.jpg)'
  id: totrans-76
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/ch03fig11.jpg)'
- en: '*Figure 3-11: Following a TCP stream on Wireshark*'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 3-11：在 Wireshark 中跟踪 TCP 流*'
- en: The reassembled stream should look like [Figure 3-12](ch03.xhtml#ch3fig12).
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 重组后的数据流应该如下所示 [图 3-12](ch03.xhtml#ch3fig12)。
- en: '![image](../images/ch03fig12.jpg)'
  id: totrans-79
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/ch03fig12.jpg)'
- en: '*Figure 3-12: The reconstructed TCP stream*'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 3-12：重建的 TCP 流*'
- en: Now you know how an attacker can use Wireshark to steal private data from the
    unencrypted packets intercepted in an ARP spoofing attack. This is why it’s so
    important to ensure that your web traffic is encrypted using HTTPS.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你知道了攻击者是如何利用 Wireshark 从在 ARP 欺骗攻击中拦截到的未加密数据包中窃取私密数据的。这就是为什么确保你的 Web 流量通过
    HTTPS 加密如此重要的原因。
- en: '**Analyzing Packets Collected by Your Firewall**'
  id: totrans-82
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**分析防火墙收集的数据包**'
- en: Now that you’ve seen how a hacker uses Wireshark, let’s change tracks. This
    section discusses using Wireshark to determine if your network is being hacked.
    I’ll show you how to capture and analyze traffic collected by your pfSense firewall
    using Wireshark and `tcpdump`, a command line tool that allows you to save captured
    packets to a file.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经了解了黑客如何使用 Wireshark，让我们换个角度来看。此部分将讨论如何使用 Wireshark 判断你的网络是否遭到攻击。我将向你展示如何使用
    Wireshark 和 `tcpdump` 命令行工具捕获并分析由 pfSense 防火墙收集的流量，`tcpdump` 可以将捕获的数据包保存到文件中。
- en: An easy way to do this is to save all packets associated with port 80 that pass
    through the firewall. Port 80 is almost always used for HTTP communication, whereas
    port 443 is commonly used for encrypted HTTPS traffic. If you’re interested in
    viewing web traffic, start with these two ports. For simplicity, I’ll focus on
    unencrypted HTTP traffic here. In [Chapter 6](ch06.xhtml#ch6), you’ll learn how
    to decrypt encrypted traffic by obtaining the encryption key from the victim’s
    machine.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 一种简单的方法是保存所有通过防火墙的与端口 80 相关的数据包。端口 80 几乎总是用于 HTTP 通信，而端口 443 通常用于加密的 HTTPS 流量。如果你对查看
    Web 流量感兴趣，可以从这两个端口开始。为了简便起见，我这里将重点讨论未加密的 HTTP 流量。在 [第六章](ch06.xhtml#ch6)中，你将学习如何通过从受害者机器获取加密密钥来解密加密流量。
- en: '***Capturing Traffic on Port 80***'
  id: totrans-85
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***捕获端口 80 的流量***'
- en: 'Boot up the Kali Linux machine and navigate to *[http://cs.virginia.edu/](http://cs.virginia.edu/)*.
    Because all traffic on your network passes through the pfSense firewall, you can
    use the `tcpdump` command on the pfSense machine to capture the TCP packets from
    the Kali Linux machine. Now start pfSense. You should see a screen that looks
    like this:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 启动 Kali Linux 机器并访问 *[http://cs.virginia.edu/](http://cs.virginia.edu/)*。由于网络中的所有流量都经过
    pfSense 防火墙，你可以在 pfSense 机器上使用 `tcpdump` 命令来捕获来自 Kali Linux 机器的 TCP 数据包。现在启动 pfSense，你应该看到如下屏幕：
- en: '[PRE9]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Start the shell option by entering **8**:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 通过输入 **8** 启动 shell 选项：
- en: '[PRE10]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Next, enter `**tcpdump**` in the shell. The program will run without options
    and capture all packets going through all of the system’s interfaces, and will
    continue to run until you terminate it by pressing CTRL-C. Here’s a sample `tcpdump`
    output:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，在 shell 中输入 `**tcpdump**`。该程序将不带任何选项运行，并捕获经过系统所有接口的所有数据包，直到你按下 CTRL-C 停止它。以下是一个
    `tcpdump` 输出的示例：
- en: '[PRE11]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Notice that the traffic is organized into lines. Let’s analyze one of them to
    understand what’s being printed. `15:18:44.372924` is a timestamp indicating when
    the traffic was captured ➊. `IP` identifies the protocol of the packet, and `192.168.1.100.41193`
    indicates the source’s combined IP address and port number (the port number alone
    is `41193`). Next, `z.arin.net.domain.57745` represents the destination’s IP address
    and port. To make the trace more readable, `tcpdump` converts this IP address
    to its associated domain name. You can disable this by adding the `-n` flag to
    the command. Everything else is specific information pertaining to the packet.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，流量按行组织。让我们分析其中一行，以了解打印的内容。`15:18:44.372924` 是一个时间戳，表示流量被捕获的时间 ➊。`IP` 标识数据包的协议，`192.168.1.100.41193`
    表示源的 IP 地址和端口号的组合（仅端口号是 `41193`）。接下来，`z.arin.net.domain.57745` 表示目标的 IP 地址和端口号。为了使追踪更具可读性，`tcpdump`
    将该 IP 地址转换为其关联的域名。你可以通过添加 `-n` 标志来禁用此操作。其他信息则是与数据包相关的特定信息。
- en: 'As in Wireshark, you can capture packets from a specific protocol by passing
    that protocol as an argument to `tcpdump`. You can also listen to packets from
    a certain port by specifying the port number. For example, to capture only TCP
    packets on port 443, run this command in pfSense:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 与 Wireshark 类似，你可以通过将特定协议作为参数传递给 `tcpdump` 来捕获来自该协议的包。你还可以通过指定端口号来监听来自某个端口的包。例如，要仅捕获端口
    443 上的 TCP 包，请在 pfSense 中运行以下命令：
- en: '[PRE12]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'If you don’t see any packets, try refreshing your web browser in Kali Linux.
    Instead of displaying the packets in the terminal, you also can write them to
    a file that you then can analyze in Wireshark:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你没有看到任何数据包，尝试刷新 Kali Linux 中的网页浏览器。除了在终端中显示数据包外，你还可以将其写入文件，然后在 Wireshark 中进行分析：
- en: '[PRE13]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The `-i` option represents the interface on which you’d like to capture packets.
    (You captured packets on the `em0` interface ➊ in the previous example.) You can
    get a list of all interfaces on a device by selecting the shell option from the
    start screen and running the `ifconfig` command. The `-s` flag represents the
    number of packets to capture, and the `-w` flag specifies the name of the file
    where the data will be stored. Once you’ve collected the data, you can view the
    file in Wireshark. Analyzing these traces can often be very tedious. Online tools
    like *[https://packettotal.com](https://packettotal.com)* will analyze *.pcap*
    files for you and flag suspicious activity.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '`-i` 选项表示你希望捕获数据包的接口。（在前面的例子中，你在 `em0` 接口上捕获了数据包 ➊。）你可以通过选择启动屏幕上的 Shell 选项并运行
    `ifconfig` 命令来获取设备上所有接口的列表。`-s` 标志表示捕获的数据包数量，`-w` 标志指定存储数据的文件名。收集数据后，你可以在 Wireshark
    中查看该文件。分析这些数据包通常非常繁琐。像 *[https://packettotal.com](https://packettotal.com)* 这样的在线工具可以帮助你分析
    *.pcap* 文件，并标记可疑活动。'
- en: '**Exercises**'
  id: totrans-98
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**练习**'
- en: Try these exercises to deepen your understanding of Wireshark and pfSense. In
    the first exercise, you’ll log in to pfSense through the web interface and explore
    its features. In the second exercise, you’ll use Wireshark to analyze packets
    from an ARP spoofing attack.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试这些练习，以加深你对 Wireshark 和 pfSense 的理解。在第一个练习中，你将通过 Web 界面登录 pfSense 并探索其功能。在第二个练习中，你将使用
    Wireshark 分析来自 ARP 欺骗攻击的数据包。
- en: '***pfSense***'
  id: totrans-100
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***pfSense***'
- en: In the Kali Linux browser, log in to pfSense by entering the router’s IP address
    into the URL bar. You will see a security warning saying that the security certificate
    is not valid. Select the option to add an exception. The pfSense firewall uses
    a self-signed certificate. I’ll discuss these certificates in [Chapter 6](ch06.xhtml#ch6).
    Next, log in using the default username **admin** and password **pfsense**. Once
    you’re logged in, change the default password, as shown in [Figure 3-13](ch03.xhtml#ch3fig13).
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Kali Linux 浏览器中，通过在 URL 地址栏输入路由器的 IP 地址来登录 pfSense。你将看到一个安全警告，提示安全证书无效。选择添加例外的选项。pfSense
    防火墙使用的是自签名证书。关于这些证书，我将在[第六章](ch06.xhtml#ch6)中讨论。接下来，使用默认用户名 **admin** 和密码 **pfsense**
    登录。一旦登录后，按照[图 3-13](ch03.xhtml#ch3fig13)所示，更改默认密码。
- en: '![image](../images/ch03fig13.jpg)'
  id: totrans-102
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/ch03fig13.jpg)'
- en: '*Figure 3-13: Change the default password in the pfSense firewall/router*'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 3-13：在 pfSense 防火墙/路由器中更改默认密码*'
- en: Now you’ll view real-time statistics on packets flowing through the firewall.
    Click **Status** and select **Dashboard** from the drop-down menu. You can view
    a global snapshot of your system from the dashboard. You also can add and remove
    panels from your dashboard. For example, click the plus icon and select **Traffic
    graphs** to add a real-time traffic graph. [Figure 3-14](ch03.xhtml#ch3fig14)
    shows a screenshot of the dashboard.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你将查看通过防火墙流动的数据包的实时统计信息。点击 **状态** 并从下拉菜单中选择 **仪表板**。你可以从仪表板查看系统的全局快照。你还可以添加和移除仪表板上的面板。例如，点击加号图标并选择
    **流量图** 来添加实时流量图。[图 3-14](ch03.xhtml#ch3fig14) 显示了仪表板的截图。
- en: '![image](../images/ch03fig14.jpg)'
  id: totrans-105
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/ch03fig14.jpg)'
- en: '*Figure 3-14: The pfSense dashboard*'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 3-14：pfSense 仪表板*'
- en: Experiment by adding panels to the dashboard. Use this as an opportunity to
    familiarize yourself with the firewall.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 通过向仪表板添加面板进行实验。利用这个机会熟悉防火墙。
- en: '***Exploring Packets in Wireshark***'
  id: totrans-108
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***在 Wireshark 中探索数据包***'
- en: 'Download the Wireshark capture of our ARP spoofing attack (*arpspoof.pcap*)
    from this book’s GitHub page at *[https://github.com/The-Ethical-Hacking-Book/ARP-pcap-files](https://github.com/The-Ethical-Hacking-Book/ARP-pcap-files)*.
    Open the file in Wireshark and try answering the following questions: What are
    the MAC and IP addresses of the victim’s and attacker’s machines, and what is
    the MAC address of the local network’s router? Hint: the local router’s IP address
    is 192.168.1.1.'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 从本书的 GitHub 页面下载我们 ARP 欺骗攻击的 Wireshark 捕获文件（*arpspoof.pcap*），链接为 *[https://github.com/The-Ethical-Hacking-Book/ARP-pcap-files](https://github.com/The-Ethical-Hacking-Book/ARP-pcap-files)*。在
    Wireshark 中打开该文件并尝试回答以下问题：受害者和攻击者机器的 MAC 和 IP 地址分别是什么？本地网络路由器的 MAC 地址是什么？提示：本地路由器的
    IP 地址是 192.168.1.1。
- en: You can find other packet captures to analyze by visiting *[https://www.netresec.com/index.ashx?page=PcapFiles/](https://www.netresec.com/index.ashx?page=PcapFiles/)*.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过访问 *[https://www.netresec.com/index.ashx?page=PcapFiles/](https://www.netresec.com/index.ashx?page=PcapFiles/)*
    找到其他需要分析的数据包捕获。
