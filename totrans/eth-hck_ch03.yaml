- en: '**3'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: ANALYZING CAPTURED TRAFFIC**
  prefs: []
  type: TYPE_NORMAL
- en: '*The internet is just a world passing notes around a classroom.*'
  prefs: []
  type: TYPE_NORMAL
- en: –Jon Stewart
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/common.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In [Chapter 2](ch02.xhtml#ch2), you learned how a hacker in a coffee shop could
    use an ARP spoofing attack to intercept a victim’s internet traffic. Now let’s
    actually view that traffic. In this chapter, we’ll use two tools, *Wireshark*
    and *TCPDump*, to steal private data from the unencrypted packets we intercepted.
    I’ll also introduce the concept of a protocol and discuss the general software
    architecture of the internet. We’ll conclude by analyzing the packets collected
    by your firewall so that you can detect attacks on your network.
  prefs: []
  type: TYPE_NORMAL
- en: '**Packets and the Internet Protocol Stack**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A *protocol* is a set of rules that governs the communication between systems.
    For example, when humans communicate, we first exchange “Hello” messages and then
    exchange information before ending the conversation with “Goodbye.” Similarly,
    when a browser wants to learn the IP address of a website such as *[https://cs.virginia.edu/](https://cs.virginia.edu/)*,
    it uses the *Domain Name System (DNS)* protocol to communicate with a DNS server.
    It begins by sending a DNS query requesting the IP address for *[https://cs.virginia.edu/](https://cs.virginia.edu/)*.
    The DNS server will then respond with the IP address. [Figure 3-1](ch03.xhtml#ch3fig1)
    shows protocol sequence diagrams for both human communication and the DNS protocol.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/ch03fig01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 3-1: A protocol sequence diagram showing an example human communication
    protocol and the DNS communication protocol*'
  prefs: []
  type: TYPE_NORMAL
- en: In addition to governing communication rules, a protocol determines how information
    is laid out in a packet. In English, we often say “Hello, Alice” and rarely “Alice
    Hello,” because the English language dictates that the greeting should precede
    the name. The same is true for internet protocols. They usually require the packet
    header to contain specific information. Returning to the letter example from [Chapter
    2](ch02.xhtml#ch2), [Figure 3-2](ch03.xhtml#ch3fig2) shows how address fields
    on an envelope are analogous to packet headers.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/ch03fig02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 3-2: How header fields in a packet are like addresses on an envelope*'
  prefs: []
  type: TYPE_NORMAL
- en: In addition to IP addresses, this figure contains header fields for the source
    and destination *port numbers*, which are assigned by the operating system when
    it allows a process to communicate over the network. Port numbers are unique,
    meaning that no two processes on a machine can use the same port number. A *process*
    is an abstraction that represents a running program. For example, when you open
    your web browser, your computer’s operating system starts a process that is associated
    with that browser. When a process wants to send and receive information through
    the network, the operating system assigns that process a port number. You can
    think of this number as being like a shipping port. For example, packets intended
    for your web server will usually arrive at your IP address 192.168.1.100 on port
    443\. In other words, ports expose internal processes to the network.
  prefs: []
  type: TYPE_NORMAL
- en: Ports are necessary because they allow multiple processes on your computer to
    communicate with the internet simultaneously, as illustrated in [Figure 3-3](ch03.xhtml#ch3fig3).
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/ch03fig03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 3-3: How ports allow packets to flow in and out of a system*'
  prefs: []
  type: TYPE_NORMAL
- en: When your operating system receives a packet from the network, it examines the
    port number to decide whether the packet is intended for your browser or messenger.
    However, ports also create a security risk because they open your computer to
    outside attackers. Often, one of the first things an attacker will do is scan
    a machine to discover open ports. A port is open if it accepts a connection from
    an external process. If the attacker finds an open port, they will attempt to
    infect your machine by sending it malicious packets. We’ll discuss how to scan
    for open ports and exploit the associated vulnerable process in [Chapter 4](ch04.xhtml#ch4).
  prefs: []
  type: TYPE_NORMAL
- en: '***The Five-Layer Internet Protocol Stack***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: To address the complexity of designing software for the internet, engineers
    decided to abstract the architecture into five independent layers. Each layer
    is responsible for managing the communication between specific components in the
    network. For example, the network layer manages communication between routers
    on the internet, whereas the application layer manages communication between applications,
    such as BitTorrent clients.
  prefs: []
  type: TYPE_NORMAL
- en: Each layer is independent, meaning its actions aren’t affected by the actions
    performed at the other layers. The protocol stack achieves this through a process
    called *encapsulation*, in which each layer treats information from the layers
    above it as generic data and does not try to interpret it. [Figure 3-4](ch03.xhtml#ch3fig4)
    shows how information is encapsulated at each layer before it is finally transmitted
    at the physical layer.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/ch03fig04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 3-4: Five-layer internet protocol stack*'
  prefs: []
  type: TYPE_NORMAL
- en: Let’s say a user composes an email. This happens at the application layer. As
    you can see, the messages associated with the email are then placed in transport
    layer packets. The transport layer does not read or alter the email in any way.
    It simply labels the packet with the information needed to process it. These transport
    layer packets are then placed into network layer packets and then data link layer
    packets before they are finally transmitted. By encapsulating and labeling each
    packet with its own headers, each layer can make decisions without depending on
    information from another layer. [Figure 3-5](ch03.xhtml#ch3fig5) shows an overview
    of the five-layer internet protocol stack, along with its headers and components.
    This layered approach allows two components in the same layer to communicate as
    though they were the only components in the network. For example, when your web
    browser makes a request to *[https://google.com](https://google.com)*, it is completely
    unaware of the routers that handle the request. Thus, it appears as though the
    web browser were directly communicating with the Google server. Now let’s look
    more closely at each layer.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/ch03fig05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 3-5: The network components that are communicating at each layer of
    the five-layer internet protocol stack*'
  prefs: []
  type: TYPE_NORMAL
- en: '**The Application Layer**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: The *application layer* is responsible for communications between applications;
    for example, between your Firefox browser and the University of Virginia web servers.
    There are several application layer protocols. The *hypertext transfer protocol
    (HTTP)* sends web pages to browsers, and the *file transfer protocol (FTP)* uploads
    files to a server. This is one of the easiest layers for which software developers
    can define their own protocols. DNS, FTP, and BitTorrent are a few examples of
    application layer protocols. Throughout this book, you’ll modify various application
    layer protocols. For example, in [Chapter 7](ch07.xhtml#ch7), you’ll write a Python
    program that sends a fake email using a modified version of the simple mail transfer
    protocol (SMTP). Some malicious programs define custom protocols to avoid detection,
    whereas others use existing protocols in unexpected ways, such as using DNS for
    *command and control*. Not to worry, I’ll discuss this in the next chapter, when
    you’ll implement your own simple custom application layer protocol.
  prefs: []
  type: TYPE_NORMAL
- en: '**The Transport Layer**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'The *transport layer* is responsible for managing communication between processes
    communicating over the internet. Because of limitations in its design, the internet
    does not always reliably deliver packets. You may have noticed dropped packets
    while video chatting or playing a game. This layer has two main protocols: the
    *transmission control protocol (TCP)*, which provides a guarantee that packets
    have reached their destination, and the *user datagram protocol (UDP)*, which
    is less complex and provides no guarantees.'
  prefs: []
  type: TYPE_NORMAL
- en: '**The Network Layer**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'The *network layer* is responsible for controlling how packets flow between
    routers in the network. IP addresses are implemented at this layer. You can see
    every router your packets pass through by using the `traceroute` tool. The `traceroute`
    tool uses a network layer protocol called the *internet control message protocol
    (ICMP)* to construct packets that probe the network to learn the path a packet
    takes. You can run `traceroute` using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The command probes each router with three packets and then records the time
    it takes for each packet to reach the router. As you can see, the first router
    we encounter is the pfSense router in our lab environment. The second router is
    the one in the coffee shop.
  prefs: []
  type: TYPE_NORMAL
- en: '**The Data Link Layer**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: The *data link layer* is responsible for communication between NICs. It also
    detects errors that might have occurred during transmissions. For example, Wi-Fi
    signals may become corrupted during transmission due to interference from other
    radio signals. The data link layer also implements the MAC protocol, which is
    responsible for sharing the *transmission medium* (for example, radio spectrum
    or wires). Consider the laptops in the coffee shop. How is it possible for all
    of these machines to transmit Wi-Fi radio waves without interfering with one another?
    Well, Wi-Fi implements a MAC protocol called *carrier sense multiple access*,
    which listens to the Wi-Fi signals and then transmits only when no one else is
    transmitting. Essentially, the laptops in the coffee shop are waiting their turn
    by listening for an empty slot.
  prefs: []
  type: TYPE_NORMAL
- en: '**The Physical Layer**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: The *physical layer* is responsible for converting the ones and zeros that represent
    data in a computer into a transmittable form. This could mean translating them
    into pulses of light, radio or electrical signals, or even sound. For example,
    communications at the physical layer might use a laser that emits pulses of light
    into a fiber-optic cable.
  prefs: []
  type: TYPE_NORMAL
- en: '**Viewing Packets in Wireshark**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Now let’s examine some packets. Wireshark is a tool that allows you to capture
    and view the packets that flow through your NIC. It’s installed by default in
    most Kali Linux installations. To launch Wireshark, click **Applications** ▶**Sniffing
    and Snooping** ▶**Wireshark**, or open a terminal window and run the following
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'If Wireshark is not installed, install it by running the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: It’s important to run Wireshark with root privileges so it has unrestricted
    access to your computer’s interfaces. After you start Wireshark, you should see
    a welcome screen similar to [Figure 3-6](ch03.xhtml#ch3fig6).
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/ch03fig06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 3-6: The Wireshark welcome screen*'
  prefs: []
  type: TYPE_NORMAL
- en: The welcome screen lists the interfaces your machine uses to communicate with
    the network. Because all of our virtual lab’s devices are attached to an Ethernet
    interface, we’ll monitor traffic on the `eth0` interface. Select this interface
    by clicking **eth0**. On the other hand, if you want to monitor Wi-Fi traffic,
    you should select the **wlan** interface. A third interface, labeled **lo**, represents
    a virtual network interface called the *loopback interface*, which redirects traffic
    back to the machine itself.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s use Wireshark to view the packets we intercepted during the ARP spoofing
    attack in [Chapter 2](ch02.xhtml#ch2). Recall that an ARP spoofing attack tricks
    the network into routing the victim’s incoming and outgoing traffic through the
    hacker’s NIC. [Figure 3-7](ch03.xhtml#ch3fig7) shows an overview of how we use
    Wireshark to view the packets intercepted during an ARP spoofing attack. Packets
    are duplicated as they enter the NIC, and the copies are sent directly to Wireshark
    using operating system drivers in the NPCAP library. Simultaneously, the card
    forwards the original packets to the victim’s NIC, where they are sent to the
    victim’s browser. The browser displays the web page (*[http://facebook.com/](http://facebook.com/)*,
    in this example) and the victim remains completely unaware that their packets
    were intercepted.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/ch03fig07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 3-7: Interactions between Wireshark and the NIC*'
  prefs: []
  type: TYPE_NORMAL
- en: To avoid having to re-execute an ARP spoofing attack, we’ll examine packets
    we generate ourselves on the Kali Linux virtual machine. However, if you wanted
    to perform another ARP spoofing attack, you could still use the steps described
    here.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we’ll pretend to be the victim and generate some web traffic by accessing
    the web server on the Metasploitable machine. Because we didn’t configure a DNS
    server in our setup, our victim can’t access the Metasploitable server by entering
    a URL like *[http://www.evil.corp/](http://www.evil.corp/)*. Instead, we’ll manually
    obtain the server’s IP address. Log in to the Metasploitable machine using the
    username **msfadmin** and password **msfadmin**. When you’ve logged in, run the
    following command to obtain its IP address:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The value after `inet addr:` is the IP address.
  prefs: []
  type: TYPE_NORMAL
- en: 'Back in Kali Linux, start the packet capture process by clicking the shark
    fin icon (![image](../images/icon.jpg)) in the upper-left corner of the Wireshark
    screen. Next, we will pretend to be the victim and generate packets by opening
    the Firefox browser and entering the server’s IP address into the address bar;
    for example: *http://192.168.1.101/* (your machine might have a different address).
    [Figure 3-8](ch03.xhtml#ch3fig8) shows the three main sections of the Wireshark
    capture screen.'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/ch03fig08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 3-8: The Wireshark window*'
  prefs: []
  type: TYPE_NORMAL
- en: If you choose to do this in the context of an ARP-spoofing attack you would
    generate the traffic from the victim machine instead of the Kali Linux machine.
    Once the page has loaded, click the red stop icon (![image](../images/icon1.jpg))
    to end the capture. Notice that the process of opening the browser and visiting
    a single web page generated more than 4,000 packets!
  prefs: []
  type: TYPE_NORMAL
- en: 'How could an attacker possibly sift through all of this information to learn
    more about the victim? Not to worry: Wireshark contains a filter function that
    allows you to find the packets that interest you. Let’s assume that you’re interested
    in viewing only packets that have been sent to the Metasploitable server at the
    IP address 192.168.1.101 (remember, your IP address may be different). Enter the
    following command into the filter box so that Wireshark will display only the
    packets exchanged with the Metasploitable server.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Let’s examine this command closely. Here, we are limiting the packets to only
    those with a destination IP address (`ip.dst`) of 192.168.1.101\. [Figure 3-9](ch03.xhtml#ch3fig9)
    shows the result of running this filter query.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/ch03fig09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 3-9: Filtering packets in Wireshark*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Filtering packets to include only those that are sent to the server reduces
    the number of packets you need to examine. Once you understand the general syntax
    of Wireshark display filters, you can construct filters of your own. Here is the
    structure of a Wireshark filter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'First, specify the protocol (`[Protocol]`); for example, TCP or IP. Next, specify
    the packet field you’d like to filter on; for example, the source IP address (`src`)
    or destination IP address (`dst`). Lastly, specify an operator and value; for
    example, not equal to (`!=`) 192.168.1.10\. Using this structure, we will construct
    a filter that displays only packets with the server’s source IP address, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Wireshark also allows you to filter packets based on their content. For example,
    an attacker might find packets that contain terms like *password*, *email*, or
    *@virginia*. You can search all TCP packets for the term *login* using the following
    filter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Armed with these filtering techniques, let’s identify the TCP packets transmitted
    between the server and the Kali Linux machine. Right-click one of the packets
    with the destination address of the Metasploitable server and select **Conversation
    Filter** ▶**TCP**, as shown in [Figure 3-10](ch03.xhtml#ch3fig10). This will display
    only the packets exchanged between the Kali Linux virtual machine and the Metasploitable
    server.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/ch03fig10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 3-10: TCP conversation filtering*'
  prefs: []
  type: TYPE_NORMAL
- en: 'This is equivalent to the following filter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Now, why are there so many packets if all we did was load a single web page?
    This happens because the server breaks the web page into smaller pieces and then
    transmits them as separate packets if a file is too large to be transmitted in
    a single packet. The recipient will reassemble these packets to recover the original
    file.
  prefs: []
  type: TYPE_NORMAL
- en: Wireshark lets you reconstruct this data from a packet stream by clicking a
    packet and selecting **Follow** ▶**TCP Stream**, as shown in [Figure 3-11](ch03.xhtml#ch3fig11).
    If you do this, you should see the HTML corresponding to the page.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/ch03fig11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 3-11: Following a TCP stream on Wireshark*'
  prefs: []
  type: TYPE_NORMAL
- en: The reassembled stream should look like [Figure 3-12](ch03.xhtml#ch3fig12).
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/ch03fig12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 3-12: The reconstructed TCP stream*'
  prefs: []
  type: TYPE_NORMAL
- en: Now you know how an attacker can use Wireshark to steal private data from the
    unencrypted packets intercepted in an ARP spoofing attack. This is why it’s so
    important to ensure that your web traffic is encrypted using HTTPS.
  prefs: []
  type: TYPE_NORMAL
- en: '**Analyzing Packets Collected by Your Firewall**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Now that you’ve seen how a hacker uses Wireshark, let’s change tracks. This
    section discusses using Wireshark to determine if your network is being hacked.
    I’ll show you how to capture and analyze traffic collected by your pfSense firewall
    using Wireshark and `tcpdump`, a command line tool that allows you to save captured
    packets to a file.
  prefs: []
  type: TYPE_NORMAL
- en: An easy way to do this is to save all packets associated with port 80 that pass
    through the firewall. Port 80 is almost always used for HTTP communication, whereas
    port 443 is commonly used for encrypted HTTPS traffic. If you’re interested in
    viewing web traffic, start with these two ports. For simplicity, I’ll focus on
    unencrypted HTTP traffic here. In [Chapter 6](ch06.xhtml#ch6), you’ll learn how
    to decrypt encrypted traffic by obtaining the encryption key from the victim’s
    machine.
  prefs: []
  type: TYPE_NORMAL
- en: '***Capturing Traffic on Port 80***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Boot up the Kali Linux machine and navigate to *[http://cs.virginia.edu/](http://cs.virginia.edu/)*.
    Because all traffic on your network passes through the pfSense firewall, you can
    use the `tcpdump` command on the pfSense machine to capture the TCP packets from
    the Kali Linux machine. Now start pfSense. You should see a screen that looks
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Start the shell option by entering **8**:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, enter `**tcpdump**` in the shell. The program will run without options
    and capture all packets going through all of the system’s interfaces, and will
    continue to run until you terminate it by pressing CTRL-C. Here’s a sample `tcpdump`
    output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Notice that the traffic is organized into lines. Let’s analyze one of them to
    understand what’s being printed. `15:18:44.372924` is a timestamp indicating when
    the traffic was captured ➊. `IP` identifies the protocol of the packet, and `192.168.1.100.41193`
    indicates the source’s combined IP address and port number (the port number alone
    is `41193`). Next, `z.arin.net.domain.57745` represents the destination’s IP address
    and port. To make the trace more readable, `tcpdump` converts this IP address
    to its associated domain name. You can disable this by adding the `-n` flag to
    the command. Everything else is specific information pertaining to the packet.
  prefs: []
  type: TYPE_NORMAL
- en: 'As in Wireshark, you can capture packets from a specific protocol by passing
    that protocol as an argument to `tcpdump`. You can also listen to packets from
    a certain port by specifying the port number. For example, to capture only TCP
    packets on port 443, run this command in pfSense:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'If you don’t see any packets, try refreshing your web browser in Kali Linux.
    Instead of displaying the packets in the terminal, you also can write them to
    a file that you then can analyze in Wireshark:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: The `-i` option represents the interface on which you’d like to capture packets.
    (You captured packets on the `em0` interface ➊ in the previous example.) You can
    get a list of all interfaces on a device by selecting the shell option from the
    start screen and running the `ifconfig` command. The `-s` flag represents the
    number of packets to capture, and the `-w` flag specifies the name of the file
    where the data will be stored. Once you’ve collected the data, you can view the
    file in Wireshark. Analyzing these traces can often be very tedious. Online tools
    like *[https://packettotal.com](https://packettotal.com)* will analyze *.pcap*
    files for you and flag suspicious activity.
  prefs: []
  type: TYPE_NORMAL
- en: '**Exercises**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Try these exercises to deepen your understanding of Wireshark and pfSense. In
    the first exercise, you’ll log in to pfSense through the web interface and explore
    its features. In the second exercise, you’ll use Wireshark to analyze packets
    from an ARP spoofing attack.
  prefs: []
  type: TYPE_NORMAL
- en: '***pfSense***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In the Kali Linux browser, log in to pfSense by entering the router’s IP address
    into the URL bar. You will see a security warning saying that the security certificate
    is not valid. Select the option to add an exception. The pfSense firewall uses
    a self-signed certificate. I’ll discuss these certificates in [Chapter 6](ch06.xhtml#ch6).
    Next, log in using the default username **admin** and password **pfsense**. Once
    you’re logged in, change the default password, as shown in [Figure 3-13](ch03.xhtml#ch3fig13).
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/ch03fig13.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 3-13: Change the default password in the pfSense firewall/router*'
  prefs: []
  type: TYPE_NORMAL
- en: Now you’ll view real-time statistics on packets flowing through the firewall.
    Click **Status** and select **Dashboard** from the drop-down menu. You can view
    a global snapshot of your system from the dashboard. You also can add and remove
    panels from your dashboard. For example, click the plus icon and select **Traffic
    graphs** to add a real-time traffic graph. [Figure 3-14](ch03.xhtml#ch3fig14)
    shows a screenshot of the dashboard.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/ch03fig14.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 3-14: The pfSense dashboard*'
  prefs: []
  type: TYPE_NORMAL
- en: Experiment by adding panels to the dashboard. Use this as an opportunity to
    familiarize yourself with the firewall.
  prefs: []
  type: TYPE_NORMAL
- en: '***Exploring Packets in Wireshark***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Download the Wireshark capture of our ARP spoofing attack (*arpspoof.pcap*)
    from this book’s GitHub page at *[https://github.com/The-Ethical-Hacking-Book/ARP-pcap-files](https://github.com/The-Ethical-Hacking-Book/ARP-pcap-files)*.
    Open the file in Wireshark and try answering the following questions: What are
    the MAC and IP addresses of the victim’s and attacker’s machines, and what is
    the MAC address of the local network’s router? Hint: the local router’s IP address
    is 192.168.1.1.'
  prefs: []
  type: TYPE_NORMAL
- en: You can find other packet captures to analyze by visiting *[https://www.netresec.com/index.ashx?page=PcapFiles/](https://www.netresec.com/index.ashx?page=PcapFiles/)*.
  prefs: []
  type: TYPE_NORMAL
