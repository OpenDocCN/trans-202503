["```\n// Allocate an int array, store (2 * element number)\n// in each element, and print the array contents.\n\n#include \"twice_index.h\"\n#include \"display_array.h\"\n#define N 10\n\nint main(void)\n{\n    int my_array[N];\n\n    twice_index(my_array, N);\n    display_array(my_array, N);\n\n    return 0;\n}\n```", "```\n        .arch armv8-a\n        .file   \"fill_array.c\"\n        .text\n        .align  2\n        .global main\n        .type   main, %function\nmain:\n     ➊ stp     x29, x30, [sp, -64]!\n        mov     x29, sp\n     ➋ add     x0, sp, 24            /// Address of array\n        mov     w1, 10\n        bl      twice_index\n     ➌ add     x0, sp, 24\n        mov     w1, 10\n        bl      display_array\n        mov     w0, 0\n        ldp     x29, x30, [sp], 64\n        ret\n        .size   main, .-main\n        .ident  \"GCC: (Debian 12.2.0-14) 12.2.0\"\n        .section        .note.GNU-stack,\"\",@progbits\n```", "```\n// Store (2 * element number) in each array element.\n\n#ifndef TWICE_INDEX_H\n#define TWICE_INDEX_H\nvoid twice_index(int the_array[], int n_elements);\n#endif\n```", "```\n// Store (2 * element number) in each array element.\n\n#include \"twice_index.h\"\n\nvoid twice_index(int the_array[], int n_elements)\n{\n    int i;\n\n    for (i = 0; i < n_elements; i++) {\n        the_array[i] = 2 * i;\n    }\n}\n```", "```\n        .arch armv8-a\n        .file   \"twice_index.c\"\n        .text\n        .align  2\n        .global twice_index\n        .type   twice_index, %function\ntwice_index:\n        sub     sp, sp, #32\n        str     x0, [sp, 8]       /// Address of the_array\n        str     w1, [sp, 4]       /// n_elements\n        str     wzr, [sp, 28]     /// i = 0;\n        b       .L2\n.L3:\n        ldrsw   x0, [sp, 28]\n     ➊ lsl     x0, x0, 2         /// Each element is 4 bytes\n        ldr     x1, [sp, 8]\n     ➋ add     x0, x1, x0        /// Address of ith element\n        ldr     w1, [sp, 28]\n        lsl     w1, w1, 1         /// 2 * i;\n        str     w1, [x0]\n        ldr     w0, [sp, 28]\n        add     w0, w0, 1         /// i++\n        str     w0, [sp, 28]\n.L2:\n        ldr     w1, [sp, 28]\n        ldr     w0, [sp, 4]\n        cmp     w1, w0\n        blt     .L3\n        nop\n        nop\n        add     sp, sp, 32\n        ret\n        .size   twice_index, .-twice_index\n        .ident  \"GCC: (Debian 12.2.0-14) 12.2.0\"\n        .section        .note.GNU-stack,\"\",@progbits\n```", "```\n// Print the int array contents.\n\n#ifndef DISPLAY_ARRAY_H\n#define DISPLAY_ARRAY_H\nvoid display_array(int the_array[], int n_elements);\n#endif\n```", "```\n// Print the int array contents.\n\n#include \"display_array.h\"\n#include \"write_str.h\"\n#include \"write_char.h\"\n#include \"put_int.h\"\nvoid display_array(int the_array[], int n_elements)\n{\n    int i;\n    for (i = 0; i < n_elements; i++) {\n        write_str(\"my_array[\");\n        put_int(i);\n        write_str(\"] = \");\n        put_int(the_array[i]);\n        write_char('\\n');\n    }\n}\n```", "```\n        .arch armv8-a\n        .file   \"display_array.c\"\n        .text\n        .section        .rodata\n        .align  3\n        .LC0:\n        .string \"my_array[\"\n        .align  3\n.LC1:\n        .string \"] = \"\n        .text\n        .align  2\n        .global display_array\n        .type   display_array, %function\ndisplay_array:\n        stp     x29, x30, [sp, -48]!\n        mov     x29, sp\n     ➊ str     x0, [sp, 24]      /// Address of the_array\n        str     w1, [sp, 20]      /// n_elements\n        str     wzr, [sp, 44]     /// i = 0;\n        b       .L2\n.L3:\n        adrp    x0, .LC0\n        add     x0, x0, :lo12:.LC0\n        bl      write_str\n        ldr     w0, [sp, 44]\n        bl      put_int\n        adrp    x0, .LC1\n        add     x0, x0, :lo12:.LC1\n        bl      write_str\n        ldrsw   x0, [sp, 44]\n     ➋ lsl     x0, x0, 2         /// Each element is 4 bytes\n     ➌ ldr     x1, [sp, 24]      /// Address of array\n        add     x0, x1, x0        /// Address of ith element\n        ldr     w0, [x0]\n        bl      put_int\n        mov     w0, 10            /// '\\n' character\n        bl      write_char\n        ldr     w0, [sp, 44]\n        add     w0, w0, 1         /// i++\n        str     w0, [sp, 44]\n.L2:\n        ldr     w1, [sp, 44]\n        ldr     w0, [sp, 20]\n        cmp     w1, w0\n        blt     .L3\n        nop\n        nop\n        ldp     x29, x30, [sp], 48\n        ret\n        .size   display_array, .-display_array\n        .ident  \"GCC: (Debian 12.2.0-14) 12.2.0\"\n        .section        .note.GNU-stack,\"\",@progbits\n```", "```\n// Allocate an int array, store (2 * element number)\n// in each element, and print array contents.\n        .arch armv8-a\n// Useful constant\n        .equ    N, 10                   // Array length\n// Stack frame\n        .equ    my_array, 16\n        .equ    FRAME, 64\n// Code\n        .text\n        .align  2\n        .global main\n        .type   main, %function\nmain:\n        stp     fp, lr, [sp, -FRAME]!   // Create stack frame\n        mov     fp, sp                  // Set our frame pointer\n\n        mov     w1, N                   // Length of array\n        add     x0, sp, my_array        // Address of array\n        bl      twice_index             // Fill the array\n\n        mov     w1, N                   // Number of elements\n        add     x0, sp, my_array        // Address of array\n        bl      display_array           // Print array contents\n\n        mov     w0, wzr                 // Return 0\n        ldp     fp, lr, [sp], FRAME     // Delete stack frame\n        ret\n```", "```\n// Store (2 * element number) in each array element.\n// Calling sequence:\n//    x0 <- address of array\n//    w1 <- number of array elements\n//    Return 0.\n        .arch armv8-a\n// Code\n        .text\n        .align  2\n        .global twice_index\n        .type   twice_index, %function\ntwice_index:\n        mov     w2, wzr                // i = 0\nloop:\n        add     w3, w2, w2             // 2 * i\n     ➊ str     w3, [x0, w2, uxtw 2]   // Current element address\n        add     w2, w2, 1              // i++\n        cmp     w2, w1                 // At end?\n        b.lt    loop                   // No, continue filling\n\n        mov     w0, wzr                // Yes, return 0\n        ret\n```", "```\n// Display ints in an array.\n// Calling sequence:\n//    x0 <- address of array\n//    w1 <- number of array elements\n        .arch armv8-a\n// Stack frame\n        .equ    save1920, 16\n        .equ    save21, 32\n        .equ    FRAME, 48\n// Code\n        .section  .rodata\n        .align  3\nmsg1:\n        .string \"my_array[\"\nmsg2:\n        .string \"] = \"\n        .text\n        .align  2\n        .global display_array\n        .type   display_array, %function\ndisplay_array:\n     ➊ stp     fp, lr, [sp, -FRAME]!     // Create stack frame\n        mov     fp, sp                    // Set our frame pointer\n        stp     x19, x20,  [sp, save1920] // Save regs\n        str     x21, [sp, save21]\n\n        mov     x19, x0                   // Array address\n        mov     w20, w1                   // Array size\n        mov     w21, wzr                  // Array index\nloop:\n        adr     x0, msg1                  // Start line\n        bl      write_str\n        mov     w0, w21                   // Index\n        bl      put_int\n        adr     x0, msg2                  // More text on line\n        bl      write_str\n        ldr     w0, [x19, w21, uxtw 2]    // Current element\n        bl      put_int\n        mov     w0, '\\n'                  // Finish line\n        bl      write_char\n        add     w21, w21, 1               // Increment index\n        cmp     w21, w20                  // At end?\n        b.lt    loop                      // No, continue\n\n        mov     w0, wzr                   // Return 0\n        ldp     x19, x20,  [sp, save1920] // Restore regs\n        ldr     x21, [sp, save21]\n        ldp     fp, lr, [sp], FRAME       // Delete stack frame\n        ret\n```", "```\n// Allocate a record and assign a value to each field.\n\n#include <stdio.h>\n\nint main(void)\n{\n    struct {\n     ➊ char a;\n        int i;\n        char b;\n        int j;\n        char c;\n➋ } x;\n\n➌ x.a = 'a';\n    x.i = 12;\n    x.b = 'b';\n    x.j = 34;\n    x.c = 'c';\n\n    printf(\"x: %c, %i, %c, %i, %c\\n\", x.a, x.i,\n          x.b, x.j, x.c);\n    return 0;\n}\n```", "```\n        .arch armv8-a\n        .file   \"fill_record.c\"\n        .text\n        .section        .rodata\n        .align  3\n.LC0:\n        .string \"x: %c, %i, %c, %i, %c\\n\"\n        .text\n        .align  2\n        .global main\n        .type   main, %function\nmain:\n        stp     x29, x30, [sp, -48]!\n        mov     x29, sp\n        mov     w0, 97\n     ➊ strb    w0, [sp, 24]    /// x.a = 'a';\n        mov     w0, 12\n     ➋ str     w0, [sp, 28]    /// x.i = 12;\n        mov     w0, 98\n        strb    w0, [sp, 32]    /// x.b = 'b';\n        mov     w0, 34\n        str     w0, [sp, 36]    /// x.j = 34;\n        mov     w0, 99\n        strb    w0, [sp, 40]    /// x.c = 'c';\n        ldrb    w0, [sp, 24]\n        mov     w6, w0\n        ldr     w0, [sp, 28]\n        ldrb    w1, [sp, 32]\n        mov     w3, w1\n        ldr     w1, [sp, 36]\n        ldrb    w2, [sp, 40]\n        mov     w5, w2\n        mov     w4, w1\n        mov     w2, w0\n        mov     w1, w6\n        adrp    x0, .LC0\n        add     x0, x0, :lo12:.LC0\n        bl      printf\n        mov     w0, 0\n        ldp     x29, x30, [sp], 48\n        ret\n        .size   main, .-main\n        .ident  \"GCC: (Debian 12.2.0-14) 12.2.0\"\n        .section        .note.GNU-stack,\"\",@progbits\n```", "```\nstruct {\n    char a;\n    int i;\n    char b;\n    int j;\n    char c;\n} x;\n```", "```\nstruct chars_and_ints {\n    char a;\n    int i;\n    char b;\n    int j;\n    char c;\n};\n```", "```\nstruct chars_and_ints x;\n```", "```\n// Declare a record.\n\n#ifndef MY_RECORD_H\n#define MY_RECORD_H\nstruct chars_and_ints {\n    char a;\n    int i;\n    char b;\n    int j;\n    char c;\n};\n#endif\n```", "```\n// Allocate two records, assign a value to each field\n// in each record, and display the contents.\n\n#include \"my_record.h\"\n#include \"load_record.h\"\n#include \"display_record.h\"\n\nint main(void)\n{\n ➊ struct chars_and_ints x;\n    struct chars_and_ints y;\n\n ➋ load_record(&x, 'a', 12, 'b', 34, 'c');\n    load_record(&y, 'd', 56, 'e', 78, 'f');\n\n ➌ display_record(x);\n    display_record(y);\n\n    return 0;\n}\n```", "```\n        .arch armv8-a\n        .file   \"fill_records.c\"\n        .text\n        .align  2\n        .global main\n        .type   main, %function\nmain:\n     ➊ stp     x29, x30, [sp, -96]!\n        mov     x29, sp\n     ➋ add     x0, sp, 72        /// Pass by pointer\n        mov     w5, 99\n        mov     w4, 34\n        mov     w3, 98\n        mov     w2, 12\n        mov     w1, 97\n        bl      load_record\n        add     x0, sp, 48\n        mov     w5, 102\n        mov     w4, 78\n        mov     w3, 101\n        mov     w2, 56\n        mov     w1, 100\n        bl      load_record\n     ➌ add     x2, sp, 16        /// Point to temporary place\n        add     x3, sp, 72        ///   and copy record there\n        ldp     x0, x1, [x3]\n        stp     x0, x1, [x2]\n        ldr     w0, [x3, 16]\n        str     w0, [x2, 16]\n     ➍ add     x0, sp, 16\n        bl      display_record   /// Pass temp place by pointer\n        add     x2, sp, 16\n        add     x3, sp, 48\n        ldp     x0, x1, [x3]\n        stp     x0, x1, [x2]\n        ldr     w0, [x3, 16]\n        str     w0, [x2, 16]\n        add     x0, sp, 16\n        bl      display_record\n        mov     w0, 0\n        ldp     x29, x30, [sp], 96\n        ret\n        .size   main, .-main\n        .ident  \"GCC: (Debian 12.2.0-14) 12.2.0\"\n        .section        .note.GNU-stack,\"\",@progbits\n```", "```\n// Load a record with data.\n\n#ifndef LOAD_RECORD_H\n#define LOAD_RECORD_H\n#include \"my_record.h\"\nint load_record(struct chars_and_ints *a_record, char x, int y, char z);\n#endif\n```", "```\n// Load a record with data.\n\n#include \"load_record.h\"\n\nvoid load_record(struct chars_and_ints *a_record, char v, int w,\n                 char x, int y, char z)\n{\n ➊ (*a_record).a = v;\n ➋ a_record->b = x;     // Equivalent syntax\n    a_record->c = z;\n    a_record->i = w;\n    a_record->j = y;\n}\n```", "```\n        .arch armv8-a\n        .file   \"load_record.c\"\n        .text\n        .align  2\n        .global load_record\n        .type   load_record, %function\nload_record:\n     ➊ sub     sp, sp, #32\n        str     x0, [sp, 24]    /// a_record address\n        strb    w1, [sp, 23]    /// v\n        str     w2, [sp, 16]    /// w\n        strb    w3, [sp, 22]    /// x\n        str     w4, [sp, 12]    /// y\n        strb    w5, [sp, 21]    /// z\n        ldr     x0, [sp, 24]    /// Load a_record address\n        ldrb    w1, [sp, 23]    /// Load v\n        strb    w1, [x0]        /// Store in record field\n     ➋ ldr     x0, [sp, 24]    /// Load a_record address\n        ldrb    w1, [sp, 22]    /// Load X\n        strb    w1, [x0, 8]     /// Store in record field\n        ldr     x0, [sp, 24]\n        ldrb    w1, [sp, 21]\n        strb    w1, [x0, 16]\n        ldr     x0, [sp, 24]    /// Load a_record address\n        ldr     w1, [sp, 16]    /// Load w\n        str     w1, [x0, 4]     /// Store in record field\n        ldr     x0, [sp, 24]\n        ldr     w1, [sp, 12]\n        str     w1, [x0, 12]\n        nop\n        add     sp, sp, 32\n        ret\n        .size   load_record, .-load_record\n        .ident  \"GCC: (Debian 12.2.0-14) 12.2.0\"\n        .section        .note.GNU-stack,\"\",@progbits\n```", "```\n// Display the contents of a record.\n\n#ifndef DISPLAY_RECORD_H\n#define DISPLAY_RECORD_H\n#include \"a_record.h\"\nvoid display_record(struct chars_and_ints a_record);\n#endif\n```", "```\n// Display the contents of a record.\n\n#include <stdio.h>\n#include \"display_record.h\"\n\nvoid display_record(struct chars_and_ints a_record)\n{\n    printf(\"%c, %i, %c, %i, %c\\n\", a_record.a, a_record.i, a_record.b,\n          a_record.j, a_record.c);\n}\n```", "```\n        .arch armv8-a\n        .file   \"display_record.c\"\n        .text\n        .section        .rodata\n        .align  3\n        .LC0:\n        .string \"%c, %i, %c, %i, %c\\n\"\n        .text\n        .align  2\n        .global display_record\n        .type   display_record, %function\ndisplay_record:\n        stp     x29, x30, [sp, -32]!\n        mov     x29, sp\n        str     x19, [sp, 16]\n     ➊ mov     x19, x0         /// Pointer to caller's copy\n        ldrb    w0, [x19]\n        mov     w6, w0\n        ldr     w0, [x19, 4]\n        ldrb    w1, [x19, 8]\n        mov     w3, w1\n        ldr     w1, [x19, 12]\n        ldrb    w2, [x19, 16]\n     ➋ mov     w5, w2          /// Arguments to printf\n        mov     w4, w1\n        mov     w2, w0\n        mov     w1, w6\n        adrp    x0, .LC0\n        add     x0, x0, :lo12:.LC0\n        bl      printf\n        nop\n        ldr     x19, [sp, 16]\n        ldp     x29, x30, [sp], 32\n        ret\n        .size   display_record, .-display_record\n        .ident  \"GCC: (Debian 12.2.0-14) 12.2.0\"\n        .section        .note.GNU-stack,\"\",@progbits\n```", "```\n// Allocate two records, assign a value to each field\n// in each record, and display the contents.\n        .arch armv8-a\n// Stack frame\n        .equ    x, 16\n     ➊ .equ    y, 32\n        .equ    FRAME, 48\n// Code\n        .text\n        .align  2\n        .global main\n        .type   main, %function\nmain:\n        stp     fp, lr, [sp, -FRAME]!   // Create stack frame\n        mov     fp, sp                  // Set our frame pointer\n\n        mov     w5, 'c'                 // Data to load\n        mov     w4, 34\n        mov     w3, 'b'\n        mov     w2, 12\n        mov     w1, 'a'\n        add     x0, sp, x               // Address of first record\n        bl      load_record             // Load values\n\n        mov     w5, 'f'                 // Data to load\n        mov     w4, 78\n        mov     w3, 'e'\n        mov     w2, 56\n        mov     w1, 'd'\n        add     x0, sp, y               // Address of second record\n        bl      load_record             // Load values\n\n     ➋ ldr     x0, [sp, x]             // First 8 bytes of x\n        ldr     w1, [sp, x+8]           // Last 4 bytes of x\n        bl      display_record          // Display x\n\n     ➌ ldr     x0, [sp, y]             // First 8 bytes of y\n        ldr     w1, [sp, y+8]           // Last 4 bytes of y\n        bl      display_record          // Display y\n\n        mov     w0, wzr                 // Return 0\n        ldp     fp, lr, [sp], FRAME     // Delete stack frame\n        ret\n```", "```\n// Assembly language declaration of a record.\n// This record takes 12 bytes.\n        .equ    a, 0\n        .equ    b, 1\n        .equ    c, 2\n        .equ    i, 4\n        .equ    j, 8\n```", "```\n// Load the fields of my_record.s.\n// Calling sequence:\n//    x0 <- address of record\n//    w1 <- char a\n//    w2 <- int x\n//    w3 <- char b\n//    w4 <- int y\n//    w5 <- char c\n//    Returns 0\n        .arch armv8-a\n     ➊ .include  \"my_record.s\"   // Field offsets\n// Code\n        .text\n        .align  2\n        .global load_record\n        .type   load_record, %function\nload_record:\n        strb    w1, [x0, a]       // First char\n        str     w2, [x0, i]       // First int\n        strb    w3, [x0, b]       // Second char\n\n        str     w4, [x0, j]       // Second int\n        strb    w5, [x0, c]       // Third char\n\n        mov     w0, wzr           // Return 0\n        ret\n```", "```\n// Display the fields of my_record.s.\n//    x0 <- first 8 bytes of record contents\n//    w1 <- remaining 4 bytes of record contents\n        .arch armv8-a\n        .include  \"my_record.s\"      // Field offsets\n// Stack frame\n        .equ    save19, 16\n        .equ    record, 24\n        .equ    FRAME, 48\n// Code\n        .section  .rodata\n        .align  3\nseparator:\n        .string \", \"\n        .text\n        .align  2\n        .global display_record\n        .type   display_record, %function\ndisplay_record:\n        stp     fp, lr, [sp, -FRAME]! // Create stack frame\n        mov     fp, sp                // Set our frame pointer\n     ➊ str     x19, [sp, save19]     // Save reg\n\n        add     x19, sp, record       // Point to our copy\n     ➋ str     x0, [x19]             // Make a copy of record\n        str     w1, [x19, 8]\n\n        ldrb    w0, [x19, a]          // First char\n        bl      write_char            // Display\n        adr     x0, separator         // Field separation\n        bl      write_str\n        ldr     w0, [x19, i]          // First int\n        bl      put_int               // Display\n        adr     x0, separator         // Field separation\n        bl      write_str\n        ldrb    w0, [x19, b]          // Second char\n        bl      write_char            // Display\n        adr     x0, separator         // Field separation\n        bl      write_str\n        ldr     w0, [x19, j]          // Second int\n        bl      put_int               // Display\n        adr     x0, separator         // Field separation\n        bl      write_str\n        ldrb    w0, [x19, c]          // Third char\n        bl      write_char            // Display\n        mov     w0, '\\n'              // Newline\n        bl      write_char\n\n        mov     w0, wzr               // Return 0\n        ldr     x19, [sp, save19]     // Restore reg\n        ldp     fp, lr, [sp], FRAME   // Delete stack frame\n        ret\n```"]