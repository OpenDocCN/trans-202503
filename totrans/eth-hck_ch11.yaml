- en: '**11'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '**11'
- en: BUILDING AND INSTALLING LINUX ROOTKITS**
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '**构建和安装 Linux Rootkit**'
- en: '*Technology is nothing. What’s important is that you have a faith in people,
    that they’re basically good and smart, and if you give them tools, they’ll do
    wonderful things with them.*'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: '*技术无关紧要。重要的是你对人类的信任，相信他们本质上是善良和聪明的，如果你给他们工具，他们会用这些工具做出奇妙的事情。*'
- en: –Steve Jobs
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: –史蒂夫·乔布斯
- en: '![image](../images/common.jpg)'
  id: totrans-4
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/common.jpg)'
- en: Once hackers have gained access to a machine, they often want to remain undetected.
    One way to do this is to install a *rootkit*. A rootkit replaces parts of the
    operating system with the attacker’s code, which is sort of like pasting a photo
    of a room over a security camera. For example, a rootkit might replace the operating
    system function that lists all files with one that lists all files except those
    the hacker created. Thus, when an antivirus tool attempts to search for malicious
    files by reading the filesystem, it won’t find anything suspicious.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦黑客获取了对一台机器的访问，他们通常希望保持隐匿。一种方法是安装 *rootkit*。Rootkit 用攻击者的代码替换操作系统的部分功能，这有点像在监控摄像头上粘上一张房间的照片。例如，rootkit
    可能会将列出所有文件的操作系统功能替换为列出所有文件，除了黑客创建的文件。因此，当防病毒工具试图通过读取文件系统来搜索恶意文件时，它不会发现任何可疑的东西。
- en: In this chapter, you’ll modify the kernel on your Kali Linux machine by writing
    a Linux kernel module, a Linux operating system extension that can be used to
    create a rootkit. Then you’ll override the operating system’s functions using
    a technique called *hooking*. We’ll use this hooking technique to write a rootkit
    that stops the system from rebooting and hides malicious files. We’ll conclude
    by using a Metasploit graphical user interface (GUI) called Armitage to scan a
    machine, exploit a vulnerability, and install a rootkit on it.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将通过编写一个 Linux 内核模块来修改 Kali Linux 机器上的内核，Linux 内核模块是一个操作系统扩展，可用于创建 rootkit。然后你将使用一种叫做
    *钩子* 的技术来覆盖操作系统的功能。我们将使用这种钩子技术编写一个 rootkit，它可以阻止系统重启并隐藏恶意文件。最后，我们将使用一个叫做 Armitage
    的 Metasploit 图形用户界面 (GUI) 扫描机器，利用漏洞并安装一个 rootkit。
- en: '**Writing a Linux Kernel Module**'
  id: totrans-7
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**编写一个 Linux 内核模块**'
- en: A common way attackers create rootkits is by exploiting a feature of the Linux
    operating system called *kernel modules*. This feature allows users to extend
    the operating system without recompiling or rebooting it. For example, when you
    connect a web camera to your system, the webcam’s installer adds software called
    a *driver* to the kernel. This driver enables the kernel to interact with your
    new hardware. The ability to insert and run code directly in the kernel makes
    kernel modules a great candidate for developing rootkits, which work best when
    integrated into the kernel.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 攻击者创建 rootkit 的常见方法是通过利用 Linux 操作系统的一个功能，叫做 *内核模块*。这个功能允许用户在不重新编译或重启操作系统的情况下扩展操作系统。例如，当你将网络摄像头连接到系统时，摄像头的安装程序会将一个叫做
    *驱动程序* 的软件添加到内核中。这个驱动程序使内核能够与新硬件进行交互。能够直接在内核中插入和运行代码使得内核模块成为开发 rootkit 的理想选择，rootkit
    在集成到内核中时效果最佳。
- en: In this section, you’ll become familiar with how Linux kernel modules work by
    writing one yourself and running it on your Kali Linux virtual machine. The module
    you’ll create will log a message whenever you add or remove it.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，你将通过自己编写并在 Kali Linux 虚拟机上运行一个内核模块，了解 Linux 内核模块是如何工作的。你将创建的模块将在你添加或删除时记录一条信息。
- en: '***Backing Up Your Kali Linux Virtual Machine***'
  id: totrans-10
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***备份你的 Kali Linux 虚拟机***'
- en: Any coding errors you make in your kernel module could result in kernel crashes,
    so first create a backup snapshot of your Kali Linux virtual machine so you can
    restore it in the event of a crash. [Figure 11-1](ch11.xhtml#ch11fig1) provides
    instructions on how to do this.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 你在内核模块中所犯的任何编码错误都可能导致内核崩溃，所以首先创建 Kali Linux 虚拟机的备份快照，以便在崩溃时可以恢复它。[图 11-1](ch11.xhtml#ch11fig1)提供了如何执行此操作的说明。
- en: '![image](../images/ch11fig01.jpg)'
  id: totrans-12
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/ch11fig01.jpg)'
- en: '*Figure 11-1: How to create a snapshot*'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 11-1：如何创建快照*'
- en: Select the Kali Linux machine from your list of virtual machines ➊ and then
    click **Snapshots**. Then select **Take** ➋. Give your snapshot a name ➌ and then
    click **OK** ➍.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 从你的虚拟机列表中选择 Kali Linux 机器 ➊ 然后点击 **快照**。接着选择 **拍摄** ➋。给你的快照命名 ➌ 然后点击 **确定**
    ➍。
- en: '***Writing the Code***'
  id: totrans-15
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***编写代码***'
- en: The kernel module code differs from the other programs we’ve covered in this
    book so far. First, instead of using Python, we’ll write our first kernel module
    in C. That’s because the Linux kernel is written in C, so kernel modules must
    also be written in C. Secondly, we won’t be able to use the standard C libraries
    (such as `unistd`, `stdio`, and `stdlib`), because user space libraries are not
    available in kernel mode. (I’ll discuss these two modes in the “System Calls”
    section of this chapter.)
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 这个内核模块代码与我们在本书中讨论的其他程序有所不同。首先，我们将使用C语言编写第一个内核模块，而不是使用Python。这是因为Linux内核是用C语言编写的，所以内核模块也必须用C语言编写。其次，我们无法使用标准C库（例如`unistd`、`stdio`和`stdlib`），因为在内核模式下没有用户空间库可用。（我将在本章的“系统调用”部分讨论这两种模式。）
- en: Another difference between most programs you may have written and kernel modules
    is that kernel modules are event driven. This means that instead of running sequentially,
    the program executes in response to events such as mouse clicks or keyboard interrupts.
    Kernel modules run in a privileged state, which means that they can access and
    change anything in the system.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 你编写的多数程序和内核模块之间的另一个区别是，内核模块是事件驱动的。这意味着程序不是按顺序执行的，而是响应事件（例如鼠标点击或键盘中断）来执行。内核模块运行在特权状态下，这意味着它们可以访问并更改系统中的任何内容。
- en: 'Every kernel module must respond to two events: `module_init()` and `module_exit()`.
    The `module_init()` event occurs when you add the module to the kernel, and the
    `module_exit()` event occurs when you remove the module from the kernel.'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 每个内核模块必须响应两个事件：`module_init()`和`module_exit()`。`module_init()`事件在你将模块添加到内核时发生，`module_exit()`事件在你从内核中移除模块时发生。
- en: 'To get started, create a Desktop folder called *lkm_rootkit*, and create two
    empty files, *hello.c* and *Makefile*, by running the following command:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，创建一个名为*lkm_rootkit*的桌面文件夹，并通过运行以下命令创建两个空文件，*hello.c*和*Makefile*：
- en: '[PRE0]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Next, copy the following into *hello.c*:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，将以下内容复制到*hello.c*中：
- en: '[PRE1]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Notice that there is no `main` method in this program. Instead, we define the
    function that runs in response to the `module_int` event ➊, which calls the `printk()`
    function ➋. Unlike a traditional user-level `printf()` method that prints to the
    console (remember that we don’t have a console when running in the kernel), the
    `printk()` method logs the value. Each log entry is associated with a log-level
    flag (for example, `KERN_NOTICE` ➌). [Table 11-1](ch11.xhtml#ch11tab1) lists the
    various flags and their associated meanings. Next we define the function to run
    when the `module_exit` event is fired ➍. Lastly, we register the functions with
    the `module_init` ➎ and `module_exit` ➏ events, respectively. These are the functions
    that will be run when the kernel module is loaded and removed, respectively. The
    `MODULE_LICENSE` tag is required for all Linux kernel modules. In this case, we
    are using the GNU General Public License (GPL).
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，这个程序中没有`main`方法。相反，我们定义了一个在响应`module_int`事件时运行的函数 ➊，该函数调用`printk()`函数 ➋。与传统的用户级`printf()`方法不同，后者是输出到控制台（记住，在内核模式下我们没有控制台），`printk()`方法将日志记录下来。每条日志条目都与一个日志级别标志相关联（例如，`KERN_NOTICE`
    ➌）。[表11-1](ch11.xhtml#ch11tab1)列出了各种标志及其相关含义。接下来，我们定义了一个在触发`module_exit`事件时执行的函数
    ➍。最后，我们分别通过`module_init` ➎和`module_exit` ➏事件注册这些函数。这些函数将在内核模块加载和卸载时分别执行。所有Linux内核模块都必须包含`MODULE_LICENSE`标签。在本例中，我们使用的是GNU通用公共许可证（GPL）。
- en: '**Table 11-1:** Kernel Log Flags'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '**表11-1：** 内核日志标志'
- en: '| Flag | Description |'
  id: totrans-25
  prefs: []
  type: TYPE_TB
  zh: '| 标志 | 描述 |'
- en: '| --- | --- |'
  id: totrans-26
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `KERN_EMERG` | Emergency condition, system is probably dead |'
  id: totrans-27
  prefs: []
  type: TYPE_TB
  zh: '| `KERN_EMERG` | 紧急条件，系统可能已经崩溃 |'
- en: '| `KERN_ALERT` | Some problem has occurred, immediate attention is needed |'
  id: totrans-28
  prefs: []
  type: TYPE_TB
  zh: '| `KERN_ALERT` | 发生了一些问题，需要立即关注 |'
- en: '| `KERN_CRIT` | A critical condition |'
  id: totrans-29
  prefs: []
  type: TYPE_TB
  zh: '| `KERN_CRIT` | 严重条件 |'
- en: '| `KERN_ERR` | An error has occurred |'
  id: totrans-30
  prefs: []
  type: TYPE_TB
  zh: '| `KERN_ERR` | 发生了错误 |'
- en: '| `KERN_WARNING` | A warning |'
  id: totrans-31
  prefs: []
  type: TYPE_TB
  zh: '| `KERN_WARNING` | 警告 |'
- en: '| `KERN_NOTICE` | Normal message to take note of |'
  id: totrans-32
  prefs: []
  type: TYPE_TB
  zh: '| `KERN_NOTICE` | 正常信息，值得注意 |'
- en: '| `KERN_INFO` | Some information |'
  id: totrans-33
  prefs: []
  type: TYPE_TB
  zh: '| `KERN_INFO` | 一些信息 |'
- en: '| `KERN_DEBUG` | Debug information related to the program |'
  id: totrans-34
  prefs: []
  type: TYPE_TB
  zh: '| `KERN_DEBUG` | 与程序相关的调试信息 |'
- en: Now that you’ve written your kernel module, let’s compile it.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经编写了内核模块，接下来我们来编译它。
- en: '***Compiling and Running Your Kernel Module***'
  id: totrans-36
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***编译和运行你的内核模块***'
- en: 'The make file you’ll create (*Makefile*) will contain instructions the compiler
    will use to build the kernel module. Open *Makefile* in your favorite text editor,
    copy in the following, and then save the file:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 你将创建的Make文件（*Makefile*）将包含编译器用来构建内核模块的指令。在你喜欢的文本编辑器中打开*Makefile*，复制以下内容，然后保存文件：
- en: '[PRE2]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The first command ➊ tells the kernel’s build system to compile the file (*hello.c*)
    into an object file (*hello.o*). This build system passes the object file to software
    in the compiler’s pipeline called the *linker*, which fills in the addresses of
    the other libraries to which the module refers. Once the linking process has completed,
    the linker produces the final kernel module file, *hello.ko*. The make file asks
    the kernel build system to build all the modules in the current directory ➋.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个命令➊告诉内核的构建系统将文件(*hello.c*)编译成目标文件(*hello.o*)。这个构建系统将目标文件传递给编译器管道中的软件，即*链接器*，它填充模块引用的其他库的地址。一旦链接过程完成，链接器会生成最终的内核模块文件*hello.ko*。Make文件要求内核构建系统构建当前目录下的所有模块➋。
- en: 'Make sure that you have the Linux headers installed:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 确保你已经安装了Linux头文件：
- en: '[PRE3]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Then, run the `make` command in the *lkm_rootkit* directory to start the build
    process:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在*lkm_rootkit*目录中运行`make`命令以启动构建过程：
- en: '[PRE4]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Next, run the following command to insert your Linux kernel module into the
    kernel:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，运行以下命令将Linux内核模块插入到内核中：
- en: '[PRE5]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Each time you insert the module into the kernel, the Linux operating system
    will call the `__init` function. This module uses the `printk()` function to write
    the message `Hello, Kernel Reporting for Duty!` to the kernel logs */var/log/syslog*
    and */var/log/kern.log*. The kernel also includes these messages in the *kernel
    ring buffer*, which is a circular queue into which the kernel inserts messages
    it generates. Run the `**dmesg**` command to view the messages:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 每次将模块插入内核时，Linux操作系统都会调用`__init`函数。该模块使用`printk()`函数将消息`Hello, Kernel Reporting
    for Duty!`写入内核日志*/var/log/syslog*和*/var/log/kern.log*。内核还将这些消息包含在*内核环形缓冲区*中，这是一种环形队列，内核将生成的消息插入其中。运行`**dmesg**`命令查看这些消息：
- en: '[PRE6]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'As you can see, the kernel ring buffer contains a lot of debug information.
    Use the `grep` command to filter through the results:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，内核环形缓冲区包含大量的调试信息。使用`grep`命令过滤结果：
- en: '[PRE7]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'You can also view the last few messages logged by the kernel using the `tail`
    command:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以使用`tail`命令查看内核记录的最后几条消息：
- en: '[PRE8]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Use the `**lsmod**` command to view a list of all loaded kernel modules:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`**lsmod**`命令查看所有已加载的内核模块列表：
- en: '[PRE9]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'You should find the module you just installed ➊. You’ve now successfully inserted
    code directly into the kernel using a kernel module! This means that you can now
    modify the kernel, bringing you one step closer to transforming your kernel module
    into a rootkit. You might be thinking: Won’t a system administrator be able to
    discover my rootkit by just listing the kernel modules as we just did? Well, yes,
    but later in this chapter I’ll discuss how to keep our module from showing up
    in this list.'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该能找到你刚刚安装的模块➊。现在，你已经成功地通过内核模块将代码直接插入到内核中！这意味着你现在可以修改内核，使你的内核模块离根套件更近一步。你可能会想：系统管理员难道不会通过列出我们刚才做过的内核模块来发现我的根套件吗？嗯，是的，但稍后在本章中我会讨论如何让我们的模块不出现在这个列表中。
- en: 'Use the `rmmod` command to remove your Linux kernel module:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`rmmod`命令删除你的Linux内核模块：
- en: '[PRE10]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: When you remove your kernel module, the operating system will call the `__exit`
    function and the module will log the `Bye bye!` message.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 当你删除内核模块时，操作系统将调用`__exit`函数，模块将记录`Bye bye!`消息。
- en: '**NOTE**'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*You must be careful when implementing your module. Coding mistakes can cause
    your module to crash, and it will be difficult to remove the module. If this happens,
    reboot your virtual machine.*'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '*在实现你的模块时必须小心。编码错误可能会导致模块崩溃，并且将很难删除该模块。如果发生这种情况，请重启你的虚拟机。*'
- en: You can find further details about building Linux kernel modules at *[https://tldp.org/LDP/lkmpg/2.6/html/lkmpg.html](https://tldp.org/LDP/lkmpg/2.6/html/lkmpg.html)*.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在*[https://tldp.org/LDP/lkmpg/2.6/html/lkmpg.html](https://tldp.org/LDP/lkmpg/2.6/html/lkmpg.html)*中找到有关构建Linux内核模块的更多详细信息。
- en: '**Modifying System Calls**'
  id: totrans-61
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**修改系统调用**'
- en: In this section, we’ll look at how you can use kernel modules to create rootkits.
    In particular, you’ll learn how you can use them to hook into system calls. But
    first I must discuss what a system call is.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将讨论如何利用内核模块创建根套件。特别是，你将学习如何使用它们挂钩系统调用。但在此之前，我必须讨论一下什么是系统调用。
- en: '***How System Calls Work***'
  id: totrans-63
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***系统调用是如何工作的***'
- en: 'To prevent a malicious program from directly modifying the kernel, a computer’s
    processor divides the memory into two regions: *user space* and *kernel space*.'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 为了防止恶意程序直接修改内核，计算机的处理器将内存划分为两个区域：*用户空间*和*内核空间*。
- en: When a user program runs, it uses the user space region of the memory. In contrast,
    kernel space memory can be accessed only when the processor is running in privileged
    mode. Switching to privileged mode requires special permissions, or privilege
    levels, which are stored in the last two bits of a special register called the
    *code segment (CS) register*. The processor checks the CS register whenever it
    fetches data from protected memory.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户程序运行时，它使用的是内存中的用户空间区域。相比之下，只有在处理器处于特权模式时，才能访问内核空间内存。切换到特权模式需要特殊的权限或特权级别，这些权限存储在一个名为*代码段（CS）寄存器*的特殊寄存器的最后两位中。每当处理器从保护内存中取出数据时，它会检查CS寄存器。
- en: 'Intel processors have four privilege levels: 3, 2, 1, and 0\. Privilege level
    3 is used by user programs, privilege levels 2 and 1 are used by device drivers,
    and privilege level 0 is used by the kernel. However, in practice, modern systems
    use only level 0 (kernel mode) and level 3 (user mode). The processor will only
    fetch a memory section if the CS register’s privilege level allows it. [Figure
    11-2](ch11.xhtml#ch11fig2) shows how the CS register manages access to protected
    sections of memory and helps to enforce kernel space/user space segmentation.'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 英特尔处理器有四个特权级别：3、2、1 和 0。特权级别3由用户程序使用，特权级别2和1由设备驱动程序使用，而特权级别0则由内核使用。然而，在实践中，现代系统只使用级别0（内核模式）和级别3（用户模式）。只有当CS寄存器的特权级别允许时，处理器才会获取内存区域。[图
    11-2](ch11.xhtml#ch11fig2)展示了CS寄存器如何管理对受保护内存区域的访问，并帮助执行内核空间/用户空间的分隔。
- en: '![image](../images/ch11fig02.jpg)'
  id: totrans-67
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/ch11fig02.jpg)'
- en: '*Figure 11-2: Kernel space versus user space and code segment (CS) register*'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 11-2：内核空间与用户空间及代码段（CS）寄存器对比*'
- en: Activities such as reading a file or accessing the network are considered privileged;
    therefore, the code associated with these activities is stored in kernel space.
    But you might be wondering how user-level programs like your browser access the
    network.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 读取文件或访问网络等活动被视为特权操作，因此与这些活动相关的代码存储在内核空间中。但你可能会好奇，像浏览器这样的用户级程序是如何访问网络的。
- en: 'Well, the processor provides a special instruction called a *system call (syscall)*.
    This instruction transfers control to the kernel, which then runs the appropriate
    function. To understand how a program activates one of these syscalls, consider
    the following program, which opens a file, writes the value 7, and then closes
    the file:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 处理器提供了一条名为*系统调用（syscall）*的特殊指令。这条指令将控制权转交给内核，内核随后运行适当的函数。为了理解程序是如何激活这些系统调用之一的，可以参考以下程序，该程序打开一个文件，写入值7，然后关闭文件：
- en: '[PRE11]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'All three operations, `open`, `write`, and `close`, are privileged; therefore,
    they must invoke syscalls. To see these calls in action, let’s look at a snippet
    of the assembly code associated with the `fclose()` function:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '`open`、`write`和`close`这三种操作都是特权操作，因此它们必须调用系统调用。为了查看这些调用的实际情况，我们来看一段与`fclose()`函数相关的汇编代码片段：'
- en: '[PRE12]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: A program must follow these steps when using the syscall instruction. During
    the first step ➊, the compiler moves the syscall number into the `%eax` CPU register.
    In this case, the value 3 represents the `close` system call. In the second step,
    the processor executes the `syscall` instruction ➋ and transfers control to the
    kernel. The kernel will use the number stored in the `%eax` register to index
    into the *system call table*, which is an array in kernel memory that stores pointers
    to kernel functions. [Figure 11-3](ch11.xhtml#ch11fig3) shows an illustration
    of the system call table.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 程序在使用系统调用指令时必须遵循以下步骤。在第一步 ➊，编译器将系统调用号移动到`%eax` CPU寄存器中。在这种情况下，值3表示`close`系统调用。在第二步中，处理器执行`syscall`指令
    ➋，并将控制权转交给内核。内核将使用存储在`%eax`寄存器中的号码来索引*系统调用表*，这是内核内存中的一个数组，存储着指向内核函数的指针。[图 11-3](ch11.xhtml#ch11fig3)展示了系统调用表的示意图。
- en: '![image](../images/ch11fig03.jpg)'
  id: totrans-75
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/ch11fig03.jpg)'
- en: '*Figure 11-3: A visualisation of the system call table in memory*'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 11-3：内存中系统调用表的可视化展示*'
- en: When the function associated with the syscall completes, it places the return
    value in the `%rax` register and switches control back to the user program. During
    the third step ➌, the user program checks the value in `%rax`. This value tells
    the user program whether the kernel function returned an error. Errors are indicated
    by a value of –1\. If no errors occurred, the function completes and returns ➍.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 当与系统调用关联的函数完成时，它会将返回值放入`%rax`寄存器，并将控制权交还给用户程序。在第三步 ➌ 中，用户程序检查`%rax`中的值。这个值告诉用户程序内核函数是否返回了错误。错误由值
    -1 指示。如果没有错误发生，函数完成并返回 ➍。
- en: 'To see a list of syscalls and their corresponding system call numbers, look
    at the *unistd_64.h* or *unistd_32.h* file on your system. Use the `**find**`
    command to search the file’s root (`/`) directory, and the `**-iname**` option
    to perform a case-insensitive search:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看系统调用及其对应的系统调用编号，请查看你系统中的*unistd_64.h*或*unistd_32.h*文件。使用`**find**`命令搜索文件的根目录（`/`），并使用`**-iname**`选项执行不区分大小写的搜索：
- en: '[PRE13]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Select the last option ➊, which is the library used by the GNU compiler and
    use the `**cat**` command to list the file’s contents:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 选择最后一个选项 ➊，这是 GNU 编译器使用的库，并使用`**cat**`命令列出文件内容：
- en: '[PRE14]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Notice that this file defines several constants, which store the system call
    numbers. For example, the `__NR_close` constant ➊ stores syscall number `3`. These
    constants allow us to write more readable programs. Instead of using arbitrary
    integers to index into the system call array (for instance, by writing `sys_call_table[3]`),
    we can use the predefined constant `sys_call_table[__NR_close]`.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，这个文件定义了几个常量，这些常量存储了系统调用编号。例如，`__NR_close`常量 ➊ 存储系统调用编号`3`。这些常量使我们能够编写更具可读性的程序。我们可以使用预定义的常量`sys_call_table[__NR_close]`，而不是使用任意的整数来索引系统调用数组（例如，通过编写`sys_call_table[3]`）。
- en: '***Hooking Syscalls***'
  id: totrans-83
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***钩取系统调用***'
- en: Now that we’ve discussed syscalls and how they work, let’s discuss how we could
    design a rootkit that hooks one. *Hooking* is the process of overriding an entry
    in the system call table with a new pointer to the attacker’s function. [Figure
    11-4](ch11.xhtml#ch11fig4) shows a visual example of hooking the `read` syscall.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经讨论了系统调用及其工作原理，让我们讨论一下如何设计一个钩取系统调用的 rootkit。*钩取*是将系统调用表中的某个条目重写为指向攻击者函数的新指针的过程。[图
    11-4](ch11.xhtml#ch11fig4)展示了钩取`read`系统调用的视觉示例。
- en: '![image](../images/ch11fig04.jpg)'
  id: totrans-85
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/ch11fig04.jpg)'
- en: '*Figure 11-4: An overview of the hooking process*'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 11-4：钩取过程概述*'
- en: The kernel module replaces the `read` entry in the system call table with a
    pointer to the hacker’s `read` function. Because your kernel module is a part
    of the kernel, it has access to all of the kernel’s memory and its variables.
    This means that it can access the kernel’s system call table, which is just an
    array in memory. Because your kernel module can read and write memory, it can
    also modify entries in this table or any other part of the kernel you choose.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 内核模块将系统调用表中的`read`条目替换为指向黑客`read`函数的指针。由于你的内核模块是内核的一部分，它可以访问内核的所有内存和变量。这意味着它可以访问内核的系统调用表，系统调用表仅是内存中的一个数组。因为你的内核模块可以读写内存，它也可以修改此表中的条目或你选择的任何其他内核部分。
- en: Often, instead of reimplementing the entire `read` function, an attacker can
    selectively call the original `read` function from within their new `read` function.
    Doing this allows them to selectively respond to reads. For example, they might
    choose to modify some reads while allowing others to function normally. Or, they
    might block reads to their secret files while allowing other reads to function
    normally.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，攻击者可以选择性地从他们的新`read`函数中调用原始的`read`函数，而不是重新实现整个`read`函数。这样做允许他们选择性地响应读取操作。例如，他们可能选择修改一些读取操作，同时允许其他操作正常工作。或者，他们可能阻止对秘密文件的读取，同时允许其他读取操作正常进行。
- en: '**Hooking the Shutdown Syscall**'
  id: totrans-89
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**钩取关机系统调用**'
- en: Let’s write a kernel module that will prevent a user from performing a software-based
    system reboot. We’ll do this by modifying the kernel module you wrote earlier
    (*hello.c*) to hook the `__NR_reboot` syscall.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们编写一个内核模块，防止用户执行基于软件的系统重启。我们将通过修改你之前编写的内核模块（*hello.c*）来钩取`__NR_reboot`系统调用。
- en: Let’s begin by finding the address of the system call table in memory. You can
    usually get this address using the kernel’s `kallsyms_lookup_name` function; however,
    techniques for locating the system call table will vary depending on the kernel’s
    version. Here I discuss a method tested with Linux kernel version 5.7 running
    in a virtual machine.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始找到内存中系统调用表的地址。通常可以使用内核的 `kallsyms_lookup_name` 函数获取此地址；然而，根据内核版本不同，定位系统调用表的技术也会有所不同。这里我讨论的方法是在运行于虚拟机中的
    Linux 内核版本 5.7 上测试过的。
- en: 'Copy the following C code to below the `#include` statements in your *hello.c*
    module:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 将以下 C 代码复制到你的 *hello.c* 模块的 `#include` 语句下方：
- en: '[PRE15]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Once we have the system call table’s address, we can modify its entries. However,
    the system call table may be stored in a write-protected memory location that
    allows only reads. The processor will write these pages only if the `WP` (write
    protect) flag is 0 (false), so we must modify this flag, too.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们有了系统调用表的地址，就可以修改它的条目。然而，系统调用表可能存储在只允许读取的写保护内存位置。处理器只会在 `WP`（写保护）标志为 0（假）时写入这些页面，因此我们也必须修改此标志。
- en: 'The write-protect flag is stored in the 17th bit of the Intel x86_64 processor’s
    32-bit control register (cr0). The Linux kernel implements a function called `write_cr0`,
    which writes a value to the cr0 register. Instead of using this predefined Linux
    function, whose functionality varies depending on whether it is run in a virtual
    environment, we’ll write a function called `my_write_cr0` that explicitly executes
    assembly instructions to set the cr0 register:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 写保护标志存储在 Intel x86_64 处理器的 32 位控制寄存器（cr0）的第 17 位。Linux 内核实现了一个名为 `write_cr0`
    的函数，该函数将一个值写入 cr0 寄存器。我们将编写一个名为 `my_write_cr0` 的函数，该函数明确执行汇编指令以设置 cr0 寄存器，而不使用预定义的
    Linux 函数，其功能因运行在虚拟环境中而异。
- en: '[PRE16]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Now we can disable the `WP` flag by bitwise AND-ing (`&`) the register with
    a negation (`~`) of `0x10000`. This effectively sets the flag’s current value
    to 0:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以通过按位 AND 运算（`&`）寄存器与 `0x10000` 的取反（`~`）来禁用 `WP` 标志。这样可以将标志的当前值设置为 0：
- en: '[PRE17]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Then we can reenable write protection; that is, set the bit back to one, by
    computing the bitwise OR between the register and the value `0x10000`:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们可以通过计算寄存器与值 `0x10000` 之间的按位 OR 来重新启用写保护；这样可以将位设置回 1：
- en: '[PRE18]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Now let’s write the C function that will allow our kernel module to hook the
    system call table:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们编写一个 C 函数，使我们的内核模块能够钩住系统调用表：
- en: '[PRE19]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: First, we save a copy of the old reboot system call ➊. We’ll need this to replace
    the old function pointer after we unload the module because we want the system
    to function normally when we remove it. Next, we disable write protection by calling
    the function we just wrote and update the `__NR_reboot` entry ➋ in the system
    call table to point to our new reboot function, which we’ll define in the following
    code snippet. Lastly, we’ll reenable write protection.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们保存了旧的重启系统调用 ➊ 的副本。在卸载模块后，我们需要这样做，因为我们希望在移除模块时系统能够正常运行。接下来，我们通过调用刚刚编写的函数禁用写保护，并更新系统调用表中的
    `__NR_reboot` 条目 ➋，指向我们将在以下代码片段中定义的新重启函数。最后，我们将重新启用写保护。
- en: 'Now let’s pull this all together into a single file. Copy the following into
    a new file called *reboot_blocker.c* and save it to the *lkm_rootkit* folder:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们把这一切整合到一个单独的文件中。将以下内容复制到名为 *reboot_blocker.c* 的新文件中，并保存到 *lkm_rootkit*
    文件夹中：
- en: '[PRE20]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: In addition to the hook function ➊, we also include a function to restore the
    system call entry to its original value ➋. We’ll call this function when we remove
    the module. We also define the `hackers_reboot()` function that will replace the
    reboot function in the system call table. This function has the same parameters
    as the kernel’s original reboot function.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 除了钩子函数 ➊ 外，我们还包括一个函数来将系统调用入口恢复到其原始值 ➋。在移除模块时将调用此函数。我们还定义了 `hackers_reboot()`
    函数，该函数将替换系统调用表中的重启函数。此函数与内核的原始重启函数具有相同的参数。
- en: 'You might be wondering what the `magic1` and `magic2` parameters represent.
    Well, because Linux is open source, we can view the system call’s source code
    in the *reboot.c* file. I’ve included a snippet of the code here:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 或许你在想 `magic1` 和 `magic2` 参数代表什么。因为 Linux 是开源的，我们可以在 *reboot.c* 文件中查看系统调用的源代码。我在这里包含了代码片段：
- en: '[PRE21]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The additional checks ➊ reduce the likelihood that a memory corruption error
    will cause the machine to reboot spontaneously. That’s because the memory corruption
    would need to affect both the system call table and all the constants ➋ for this
    type of error to occur. So what value did Linus Torvalds, the developer of Linux,
    choose for these constants? Take a look:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 额外的检查➊减少了内存损坏错误导致机器自发重启的可能性。因为内存损坏需要同时影响系统调用表和所有常量➋，这种错误才会发生。那么Linux的开发者Linus
    Torvalds为这些常量选择了什么值呢？来看一下：
- en: '[PRE22]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Torvalds chose his birthday and those of his three kids. These constants get
    checked to ensure that a memory corruption didn’t cause the shutdown: a great
    Linux Easter egg. Every time you shut down a Linux machine, remember that you
    need a little bit of magic.'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 托瓦尔兹选择了自己的生日以及他三个孩子的生日。这些常量会被检查，以确保内存损坏没有导致关机：这是一个绝妙的Linux彩蛋。每次你关闭Linux机器时，请记住，你需要一点魔法。
- en: Returning to our code, the `cmd` parameter specifies the command shortcut CTRL-ALT-DELETE
    to trigger a shutdown. The final parameter is a pointer to the user. The Linux
    kernel uses this value to ensure that the user has proper privileges to shut down
    the machine.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 回到我们的代码中，`cmd`参数指定了命令快捷键CTRL-ALT-DELETE来触发关机。最后一个参数是指向用户的指针。Linux内核使用该值来确保用户具有正确的权限来关闭机器。
- en: You’ll also notice that the function signature includes the `asmlinkage` macro.
    This macro tells the compiler to check the stack (a region of a program’s memory
    used to store variables temporarily) instead of the registers for the function’s
    parameters. This is because the `syscall` instruction places these parameters
    on the stack.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 你还会注意到函数签名中包括了`asmlinkage`宏。这个宏告诉编译器检查栈（程序内存的一个区域，用于临时存储变量），而不是寄存器，来获取函数的参数。这是因为`syscall`指令将这些参数放置在栈上。
- en: We defined a constant called `enable_reboot`. Setting this constant to 1 allows
    the system to reboot, but setting it to 0 blocks the reboot call and returns the
    `EPERM` constant. This constant indicates that the user has insufficient permissions
    to reboot as we now control the system.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 我们定义了一个常量`enable_reboot`。将此常量设置为1允许系统重启，但将其设置为0会阻止重启调用并返回`EPERM`常量。这个常量表示用户没有足够的权限进行重启，因为现在我们已经控制了系统。
- en: 'It’s time to compile the kernel module. Edit the first line in *Makefile* so
    that it targets the *reboot_blocker.c* file:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候编译内核模块了。编辑*Makefile*中的第一行，使其指向*reboot_blocker.c*文件：
- en: '[PRE23]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Now install the kernel module:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 现在安装内核模块：
- en: '[PRE24]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Check the logs to make sure the kernel module is installed:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 检查日志以确保内核模块已安装：
- en: '[PRE25]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'To test it, do a software-based reboot of your Kali Linux system by running
    the following command in the terminal:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 要测试它，可以通过在终端运行以下命令来进行基于软件的重启Kali Linux系统：
- en: '[PRE26]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'This should cause the GUI of your Kali Linux machine to shut down and return
    you to the Kali logo. However, the kernel has not shut down and can still be detected.
    In pfSense, ping your Kali Linux machine:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该会导致你的Kali Linux机器的GUI关闭并返回到Kali的logo。然而，内核并未关闭，仍然可以被检测到。在pfSense中，ping你的Kali
    Linux机器：
- en: '[PRE27]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: If you installed the module correctly, you’ll notice that the Kali Linux kernel
    still responds to the pings, indicating that it is still up and running. When
    this module is running, a victim would have to hit the power switch or unplug
    the machine to completely shut it down.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你正确安装了模块，你会注意到Kali Linux内核仍然会响应ping，这表明它仍然在运行。当这个模块运行时，受害者必须按下电源开关或拔掉机器的电源才能完全关闭它。
- en: '**Hiding Files**'
  id: totrans-126
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**隐藏文件**'
- en: 'Rootkits can also hide files by hooking the “get directory entries” system
    call (`__NR_getdents64`), which runs the `getdents()` kernel function:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: Rootkit也可以通过挂钩“获取目录条目”系统调用（`__NR_getdents64`）来隐藏文件，这会运行`getdents()`内核函数：
- en: '[PRE28]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: As you can see, the `getdents()` function takes three parameters as input. The
    first parameter is the file ID returned by the `open` syscall, which is an integer
    that uniquely identifies a file or directory. The second parameter is a pointer
    to an array of Linux directory entries (`linux_dirent`). The third parameter is
    the number of entries in that array.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，`getdents()`函数接收三个参数作为输入。第一个参数是通过`open`系统调用返回的文件ID，它是一个唯一标识文件或目录的整数。第二个参数是指向Linux目录条目的数组（`linux_dirent`）的指针。第三个参数是该数组中条目的数量。
- en: '***The linux_dirent struct***'
  id: totrans-130
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***linux_dirent结构体***'
- en: 'Let’s take a look at the structure of entries in the `linux_dirent` array.
    These entries are important because they’re what is displayed in your file explorer
    or whenever you run the `ls` command. Removing an entry from this list will remove
    it from all programs that use the `dirent64` syscall to display files:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一下`linux_dirent`数组中条目的结构。这些条目很重要，因为它们是文件资源管理器中显示的内容，或者每当你运行`ls`命令时会看到的内容。将一个条目从这个列表中移除，会将其从所有使用`dirent64`系统调用来显示文件的程序中移除：
- en: '[PRE29]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: The `d_ino` field is an 8-byte field containing a unique number that identifies
    the *inode* associated with a file. Inodes are data structures the Linux filesystem
    uses to store metadata such as file size and timestamp. Inodes also include pointers
    to the place where the file is stored in memory. The second field is the 8-byte
    file offset, which specifies the number of bytes until the next entry in the array.
    The next field, `d_reclen`, represents the total length of the entry. The 1-byte
    `d_type` field is used to distinguish the entry’s type as both files and directories
    are valid entries in the `linux_dirent` array. The final field, `d_name[]`, contains
    the file or directory name.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '`d_ino`字段是一个8字节的字段，包含一个唯一的数字，标识与文件关联的*inode*。Inode是Linux文件系统用来存储文件元数据（如文件大小和时间戳）的数据结构。Inode还包含指向文件存储在内存中的位置的指针。第二个字段是8字节的文件偏移量，指定从当前位置到数组中下一个条目的字节数。接下来的字段`d_reclen`表示条目的总长度。1字节的`d_type`字段用于区分条目的类型，因为文件和目录都是`linux_dirent`数组中的有效条目。最后一个字段`d_name[]`包含文件或目录的名称。'
- en: '***Writing the Hooking Code***'
  id: totrans-134
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***编写钩子代码***'
- en: Hooking the syscall associated with the `getdents64()` function allows us to
    run our malicious function when that syscall is called. Our function will call
    the original `getdents64()` function; however, we’ll remove entries containing
    our malicious files’ names from the array of Linux directory entries before returning
    from the call. More specifically, any entries that start with the prefix `eh_hacker_`
    will be removed, making it seem as though they never existed.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 钩住与`getdents64()`函数相关的系统调用可以让我们在调用该系统调用时运行我们的恶意函数。我们的函数将调用原始的`getdents64()`函数；然而，在返回调用之前，我们会从Linux目录条目的数组中移除包含我们恶意文件名称的条目。更具体地说，任何以`eh_hacker_`为前缀的条目将被移除，这样看起来就像这些条目从未存在过。
- en: To visualize the work we’ll have to do, take a look at [Figure 11-5](ch11.xhtml#ch11fig5),
    which shows how we’ll modify the array containing directory entries. In this example,
    the shaded entry is a file containing the `eh_hacker_` prefix.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 为了可视化我们需要做的工作，查看[图11-5](ch11.xhtml#ch11fig5)，它展示了我们将如何修改包含目录项的数组。在这个例子中，阴影部分的条目是一个包含`eh_hacker_`前缀的文件。
- en: '![image](../images/ch11fig05.jpg)'
  id: totrans-137
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/ch11fig05.jpg)'
- en: '*Figure 11-5: How the directory entry array is modified*'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '*图11-5：目录项数组如何被修改*'
- en: 'As soon as we’ve discovered a file with the `eh_hacker_` prefix, we remove
    it from the array, overriding it by moving the subsequent value up. In this example,
    we overwrite 3 by moving 4 and 5 up next to 2\. Lastly, we update the length of
    the array from 5 to 4\. The following code implements the malicious `hacker_getdents64()`
    function:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们发现一个以`eh_hacker_`为前缀的文件，我们将其从数组中移除，通过将后续的值向上移动来覆盖它。在这个例子中，我们通过将4和5向上移动到2旁边来覆盖3。最后，我们将数组的长度从5更新为4。以下代码实现了恶意的`hacker_getdents64()`函数：
- en: '[PRE30]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: We call the kernel’s original `getdent64()` function ➊, which updates the pointer
    to point to the Linux directory entries array and set the count to the number
    of entries. It will also return the number of bytes in the array. Next, we loop
    through all the entries ➋ and increment the offset until we get to the last byte
    in the byte array. During each iteration of the loop, we calculate an entry’s
    address by adding the offset’s value to the directory entries pointer (`drip`).
    Then we cast the address to be a pointer to the `linux_direct` struct so that
    we can easily access its fields. Next, we check the filename entry to see whether
    it starts with our prefix (`eh_hacker_`) ➌. If it doesn’t match, we skip it by
    advancing the offset to the next entry. However, if it does contain our prefix,
    we calculate the number of remaining bytes ➍ and then override the entry by sliding
    the remaining bytes back, as shown in [Figure 11-5](ch11.xhtml#ch11fig5). Lastly,
    we decrement the count and the number of bytes.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 我们调用内核的原始 `getdent64()` 函数 ➊，它会更新指针，使其指向 Linux 目录项数组，并设置计数为目录项的数量。它还会返回数组的字节数。接下来，我们遍历所有目录项
    ➋，并递增偏移量，直到到达字节数组的最后一个字节。在每次循环迭代中，我们通过将偏移量的值加到目录项指针（`drip`）来计算目录项的地址。然后，我们将该地址强制转换为指向
    `linux_direct` 结构的指针，以便轻松访问其字段。接下来，我们检查文件名项，以查看它是否以我们的前缀（`eh_hacker_`） ➌ 开头。如果不匹配，我们通过将偏移量推进到下一个目录项来跳过它。然而，如果它包含我们的前缀，我们会计算剩余字节数
    ➍，然后通过将剩余字节向后滑动来覆盖该项，如 [图 11-5](ch11.xhtml#ch11fig5) 所示。最后，我们递减计数和字节数。
- en: In addition to hiding files, sophisticated rootkits, such as the one in the
    Drovorub malware, also hide processes, sockets, and packets. These activities
    help the malware avoid detection. For example, hiding packets enables the rootkit
    to avoid detection while communicating with an attacker’s server. It can hide
    packets by hooking into the Netfilter component, a part of the Linux kernel that
    allows firewalls to block and filter packets.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 除了隐藏文件之外，复杂的 rootkit（例如 Drovorub 恶意软件中的 rootkit）还会隐藏进程、套接字和数据包。这些活动有助于恶意软件避免被检测到。例如，隐藏数据包可以让
    rootkit 在与攻击者的服务器通信时避免被检测。它可以通过挂钩到 Netfilter 组件来隐藏数据包，而 Netfilter 是 Linux 内核的一部分，允许防火墙拦截和过滤数据包。
- en: '**Using Armitage to Exploit a Host and Install a Rootkit**'
  id: totrans-143
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**使用 Armitage 对主机进行攻击并安装 Rootkit**'
- en: Now that you’ve seen how kernel module base rootkits work, let’s use a tool
    called *Armitage* to execute an attack from start to finish. We’ll begin by scanning
    the Metasploitable virtual machine to identify a vulnerability. Then we’ll exploit
    that vulnerability to upload a reverse shell, which we’ll use to download and
    install a rootkit.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经了解了内核模块基础 rootkit 的工作原理，我们来使用一个名为 *Armitage* 的工具，从头到尾执行一次攻击。我们将从扫描 Metasploitable
    虚拟机开始，识别一个漏洞。然后，我们将利用这个漏洞上传一个反向 Shell，并用它来下载并安装 rootkit。
- en: 'Armitage is a GUI that simplifies interfacing with the Metasploit Framework.
    The commercial version of this software is called Cobalt Strike, and it costs
    approximately $3,500\. Luckily, Armitage is free, though it can be buggy. Install
    it by running the following:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: Armitage 是一个简化与 Metasploit 框架交互的 GUI。该软件的商业版叫做 Cobalt Strike，价格大约为 $3,500。幸运的是，Armitage
    是免费的，尽管它可能存在一些 Bug。您可以通过运行以下命令来安装它：
- en: '[PRE31]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Once the installation is complete, start the `postgresql` database service,
    which the Metasploit Framework uses to store information about client connections:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 安装完成后，启动 `postgresql` 数据库服务，这是 Metasploit 框架用来存储客户端连接信息的：
- en: '[PRE32]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Armitage is a GUI interface for the Metasploit Framework, so you must ensure
    that Metasploit is running before launching Armitage. After the database has been
    initialized, start Metasploit by running the following:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: Armitage 是一个用于 Metasploit 框架的 GUI 界面，因此在启动 Armitage 之前，您必须确保 Metasploit 正在运行。数据库初始化完成后，通过运行以下命令启动
    Metasploit：
- en: '[PRE33]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Now launch Armitage:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 现在启动 Armitage：
- en: '[PRE34]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: The first time you run this command, it should take a minute to load, so be
    patient. When it finishes, you should see a setup screen like that in [Figure
    11-6](ch11.xhtml#ch11fig6). Use all the default options and click **Connect**
    to use a local Metasploitable server.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 第一次运行此命令时，加载过程可能需要一分钟，因此请耐心等待。加载完成后，您应该会看到一个类似于 [图 11-6](ch11.xhtml#ch11fig6)
    的设置界面。选择所有默认选项，然后点击 **连接** 以使用本地 Metasploitable 服务器。
- en: '![image](../images/ch11fig06.jpg)'
  id: totrans-154
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/ch11fig06.jpg)'
- en: '*Figure 11-6: The Armitage setup screen*'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 11-6：Armitage 设置界面*'
- en: Click **Yes** to start Metasploit’s remote procedure call (RPC) server, which
    allows you to use Armitage to programmatically control the Metasploit Framework.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 点击**是**，以启动 Metasploit 的远程过程调用（RPC）服务器，这使你可以通过 Armitage 程序化地控制 Metasploit Framework。
- en: '***Scanning the Network***'
  id: totrans-157
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***扫描网络***'
- en: Let’s start by using the Armitage discovery tool to find the machines in your
    virtual environment. Click **Hosts** ▶ **Scan** ▶ **Quick Scan OS Detect**, as
    shown in [Figure 11-7](ch11.xhtml#ch11fig7). The **Quick Scan OS Detect** option
    will perform a quick `nmap` scan of the virtual environment.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们首先使用 Armitage 发现工具来查找虚拟环境中的机器。点击**主机** ▶ **扫描** ▶ **快速扫描操作系统检测**，如[图 11-7](ch11.xhtml#ch11fig7)所示。**快速扫描操作系统检测**选项会执行一次快速的`nmap`扫描，扫描虚拟环境。
- en: '![image](../images/ch11fig07.jpg)'
  id: totrans-159
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/ch11fig07.jpg)'
- en: '*Figure 11-7: An example of running the quick scan*'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 11-7：运行快速扫描的示例*'
- en: You should see a pop-up that asks you for the range of IP addresses you want
    to scan. This pop-up takes an address in CIDR notation (for example, 192.168.1.0/24;
    see [Chapter 2](ch02.xhtml#ch2) for a discussion of CIDR).
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该会看到一个弹出窗口，要求你输入要扫描的 IP 地址范围。这个弹出窗口接受 CIDR 表示法中的地址（例如，192.168.1.0/24；有关 CIDR
    的讨论，请参见[第 2 章](ch02.xhtml#ch2)）。
- en: Once you’ve discovered some hosts, scan them for vulnerabilities by clicking
    the host and selecting **Attacks** ▶ **Find Attacks** ([Figure 11-8](ch11.xhtml#ch11fig8)).
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你发现了一些主机，点击主机并选择**攻击** ▶ **查找攻击**来扫描它们的漏洞（见[图 11-8](ch11.xhtml#ch11fig8)）。
- en: '![image](../images/ch11fig08.jpg)'
  id: totrans-163
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/ch11fig08.jpg)'
- en: '*Figure 11-8: Using Armitage to quickly scan all addresses*'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 11-8：使用 Armitage 快速扫描所有地址*'
- en: When the vulnerability scan has completed, click the host and select **Attack**.
    You should see a list of available attacks. The Metasploit Framework has a built-in
    scanner, similar to those discussed in [Chapter 8](ch08.xhtml#ch8), that locates
    possible vulnerabilities. The vulnerability scanner will discover the FTP vulnerability
    we discussed in [Chapter 1](ch01.xhtml#ch1). [Figure 11-9](ch11.xhtml#ch11fig9)
    shows the FTP attack.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 漏洞扫描完成后，点击主机并选择**攻击**。你应该会看到一个可用攻击的列表。Metasploit Framework 中内置的扫描器，类似于[第 8 章](ch08.xhtml#ch8)中讨论的那些，会找到可能的漏洞。漏洞扫描器会发现我们在[第
    1 章](ch01.xhtml#ch1)中讨论的 FTP 漏洞。[图 11-9](ch11.xhtml#ch11fig9)显示了 FTP 攻击。
- en: '![image](../images/ch11fig09.jpg)'
  id: totrans-166
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/ch11fig09.jpg)'
- en: '*Figure 11-9: The vftpd vulnerability*'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 11-9：vftpd 漏洞*'
- en: Alternatively, you can use the search box on the left to search the hosts for
    a specific exploit.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 另外，你可以使用左侧的搜索框来搜索主机是否存在特定的漏洞。
- en: '***Exploiting a Host***'
  id: totrans-169
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***利用主机***'
- en: When Armitage attacks a host, it uploads a payload to the host. Thus, you must
    configure the payload so that it knows how to connect to your machine. [Figure
    11-10](ch11.xhtml#ch11fig10) shows the configuration screen.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 当 Armitage 攻击一个主机时，它会将有效负载上传到主机。因此，你必须配置有效负载，以便它知道如何连接到你的机器。[图 11-10](ch11.xhtml#ch11fig10)显示了配置屏幕。
- en: '![image](../images/ch11fig10.jpg)'
  id: totrans-171
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/ch11fig10.jpg)'
- en: '*Figure 11-10: Description of the attack*'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 11-10：攻击描述*'
- en: You may have noticed that these options look very similar to the Metasploit
    Framework options used in [Chapter 10](ch10.xhtml#ch10). This is because Armitage
    is a GUI wrapper for Metasploit. LHOST is the IP address of the controlling machine,
    and LPORT is the port on the controlling machine. Similarly, RHOST is the IP address
    of the host you’re attacking, and RPORT is the port used by the reverse shell
    included in the payload uploaded to the host. Click **Use a reverse connection**
    option to instruct Armitage to generate a reverse shell similar to the one we
    implemented in [Chapter 4](ch04.xhtml#ch4) and then click **Launch** to launch
    the attack.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经注意到，这些选项与在[第 10 章](ch10.xhtml#ch10)中使用的 Metasploit Framework 选项非常相似。这是因为
    Armitage 是 Metasploit 的图形用户界面封装程序。LHOST 是控制机器的 IP 地址，LPORT 是控制机器的端口。类似地，RHOST
    是你攻击的主机的 IP 地址，RPORT 是上传到主机的有效负载中包含的反向 shell 所使用的端口。点击**使用反向连接**选项，指示 Armitage
    生成一个类似于我们在[第 4 章](ch04.xhtml#ch4)中实现的反向 shell，然后点击**启动**以发起攻击。
- en: Once your host is compromised, the host’s icon in the Armitage GUI will change.
    To access the machine’s shell, right-click the host and then select **Shell**
    ▶ **Interact**, as shown in [Figure 11-11](ch11.xhtml#ch11fig11). A Linux shell
    should appear in the bottom of the window.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你的主机被攻陷，Armitage GUI 中的主机图标会发生变化。要访问该机器的 shell，右键点击主机，然后选择**Shell** ▶ **Interact**，如[图
    11-11](ch11.xhtml#ch11fig11)所示。Linux shell 应该会出现在窗口的底部。
- en: '![image](../images/ch11fig11.jpg)'
  id: totrans-175
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/ch11fig11.jpg)'
- en: '*Figure 11-11: Getting shell access in Armitage*'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 11-11：在 Armitage 中获取 shell 访问权限*'
- en: '***Installing a Rootkit***'
  id: totrans-177
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***安装Rootkit***'
- en: Now that you have access, use the shell associated with the payload to download
    and install a rootkit on the host. You can find a long list of open source rootkits
    that contains rootkits for Android, Linux, Windows, and macOS systems at *[https://github.com/rmusser01/Infosec_Reference/blob/master/Draft/Rootkits.md](https://github.com/rmusser01/Infosec_Reference/blob/master/Draft/Rootkits.md)*.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已获得访问权限，使用与负载关联的shell下载并安装rootkit到主机上。你可以在*[https://github.com/rmusser01/Infosec_Reference/blob/master/Draft/Rootkits.md](https://github.com/rmusser01/Infosec_Reference/blob/master/Draft/Rootkits.md)*找到一长串开源rootkit，包含适用于Android、Linux、Windows和macOS系统的rootkit。
- en: '**Exercises**'
  id: totrans-179
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**练习**'
- en: Complete these exercises to practice creating kernel modules. In the first exercise,
    you’ll write a kernel module called a *keylogger* that logs everything a user
    types, including usernames and passwords. In the second exercise, you’ll extend
    your module so that it hides from the `lsmod` command.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 完成这些练习来练习创建内核模块。在第一个练习中，你将编写一个名为*keylogger*的内核模块，记录用户输入的所有内容，包括用户名和密码。在第二个练习中，你将扩展模块，使其能够隐藏在`lsmod`命令中。
- en: '***The Keylogger***'
  id: totrans-181
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***键盘记录器***'
- en: 'Keyloggers are common hacking tools, and implementing one in the kernel offers
    an extra advantage: it allows you to stealthily intercept all of a user’s keystrokes,
    regardless of which application they’re using.'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 键盘记录器是常见的黑客工具，在内核中实现一个键盘记录器具有额外的优势：它使你能够悄悄地拦截所有用户的按键，无论他们使用的是哪个应用程序。
- en: 'As you did earlier in this chapter, create a new folder for your module named
    *keylogger_module* and create two files, *keylogger.c* and *Makefile*. In the
    module file, first define a mapping array, which maps numeric keycodes (unique
    numbers assigned to each key on the keyboard) to characters:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 如本章之前所做，创建一个名为*keylogger_module*的新文件夹，并创建两个文件，*keylogger.c*和*Makefile*。在模块文件中，首先定义一个映射数组，它将数字键码（分配给每个键的唯一数字）映射到字符：
- en: '[PRE35]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'A fun, interactive way to see the mapping is to open a terminal, run the `**showkey**`
    command, open another application like Mousepad, and start typing. The `showkey`
    command should display the key code of each key you press:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 一种有趣且互动的方式来查看映射是打开终端，运行`**showkey**`命令，打开另一个应用程序如Mousepad，然后开始输入。`showkey`命令应该会显示你按下的每个键的键码：
- en: '[PRE36]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: You may have already noticed that the values are roughly in the order of a “qwerty”
    keyboard layout. Because actual keyboard layouts vary by region and preference,
    the keymap translates keycodes to specific ASCII characters. Put this keymap definition
    at the top of your *keylogger.c* file.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经注意到，这些值大致按照“qwerty”键盘布局的顺序排列。由于实际键盘布局因地区和偏好而异，键盘映射将键码转换为特定的ASCII字符。将此键盘映射定义放在你的*keylogger.c*文件的顶部。
- en: 'The `__init` and `__exit` methods in this module are very short. They simply
    register and unregister, respectively, a keyboard `notifier_block` struct. You
    may have also noticed that the `__init` and `__exit` methods in this module have
    different names than the module we created in this chapter; that is, `start` and
    `end` rather than `startup` and `shutdown`—these names are arbitrary:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 该模块中的`__init`和`__exit`方法非常简短。它们分别仅注册和注销一个键盘`notifier_block`结构。你可能还注意到，在这个模块中，`__init`和`__exit`方法的名字与本章中我们创建的模块不同；即，使用的是`start`和`end`而不是`startup`和`shutdown`——这些名字是任意的：
- en: '[PRE37]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Next, to be notified when a user presses a key, we must specify a value for
    one of the attributes of the keyboard `notifier_block` struct. This struct is
    an API mechanism provided by the kernel that gives a module access to some keyboard
    functionality. We define it at the top of our module here:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，为了在用户按下一个键时得到通知，我们必须为键盘`notifier_block`结构的一个属性指定一个值。这个结构是内核提供的API机制，使模块可以访问一些键盘功能。我们在这里的模块顶部定义它：
- en: '[PRE38]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Specifying values for predefined structs, as we’ve done here, is a common pattern
    when programming in the Linux kernel. If you take a look at the complete `notifier_block`
    struct definition in the Linux *notifier.h* source file, you’ll notice that it
    specifies many more attributes than are shown in our definition of it. However,
    they’re all set to `NULL` until a module (like ours) sets their values. Here,
    we’ve specified a value for the `notifier_call` attribute ➊ by providing a function
    pointer `notify_keypress` ➋. Now our function will be called whenever a user presses
    a key.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 指定预定义结构体的值，如我们在这里所做的，是在Linux内核编程中常见的模式。如果你查看Linux *notifier.h*源文件中完整的`notifier_block`结构体定义，你会注意到它指定了比我们定义的更多的属性。然而，在模块（如我们的模块）设置这些值之前，它们都被设置为`NULL`。在这里，我们通过提供函数指针`notify_keypress`
    ➋，为`notifier_call`属性 ➊指定了一个值。现在，每当用户按下一个键时，我们的函数就会被调用。
- en: 'Complete the implementation of the `notify_keypress` function so that it logs
    user key presses:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 完成`notify_keypress`函数的实现，使其记录用户的按键操作：
- en: '[PRE39]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'The `keyboard_notifier_param` struct ➊ contains details on the key press events.
    The source code from the `keyboard_notifier_param` struct is available in the
    *keyboard.h* file in the Linux source code. I’ve included a snippet of the file
    for your convenience; you can see all values in the struct associated with a key
    press event:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: '`keyboard_notifier_param`结构体 ➊ 包含关于按键事件的详细信息。`keyboard_notifier_param`结构体的源代码可以在Linux源代码中的*keyboard.h*文件中找到。我为你提供了该文件的代码片段，便于你查看与按键事件相关的所有结构体值：'
- en: '[PRE40]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: We use these details to determine when a `keydown` event ➊ occurs and extract
    its `keycode` ➋. This keycode becomes an index for our keymap. You can read other
    details from this struct, as well, including the SHIFT key state and keyboard
    LED state. Try implementing functionality that adds the character a user types
    to the kernel ring buffer.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用这些细节来确定何时发生`keydown`事件 ➊，并提取其`keycode` ➋。这个keycode成为我们键盘映射的索引。你也可以从这个结构体中读取其他细节，包括SHIFT键的状态和键盘LED的状态。尝试实现功能，将用户输入的字符添加到内核环形缓冲区。
- en: This module dumps key presses to the kernel’s logs. However, a more sophisticated
    logger could transmit key presses to a hacker’s machine, where the hacker could
    extract credentials.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 该模块将按键操作转储到内核日志中。然而，更复杂的日志记录器可以将按键操作传输到黑客的机器上，黑客可以在上面提取凭证。
- en: '***Self-Hiding Module***'
  id: totrans-199
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***自隐藏模块***'
- en: Extend the kernel module so that it hides from the `lsmod` command as soon as
    you install it. I’ll leave this implementation completely up to you. A great place
    to start is by looking at kernel modules that other developers have created. For
    instance, Reptile is a well-documented Linux kernel module rootkit. Take a look
    at its *module.c* file at *[https://github.com/f0rb1dd3n/Reptile/blob/master/kernel/module.c](https://github.com/f0rb1dd3n/Reptile/blob/master/kernel/module.c)*.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 扩展内核模块，使其在安装后立即从`lsmod`命令中隐藏。我将完全交给你实现这一功能。一个很好的起点是查看其他开发者创建的内核模块。例如，Reptile是一个文档完善的Linux内核模块rootkit。你可以查看其*module.c*文件，链接地址是*[https://github.com/f0rb1dd3n/Reptile/blob/master/kernel/module.c](https://github.com/f0rb1dd3n/Reptile/blob/master/kernel/module.c)*。
