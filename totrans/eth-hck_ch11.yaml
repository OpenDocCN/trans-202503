- en: '**11'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: BUILDING AND INSTALLING LINUX ROOTKITS**
  prefs: []
  type: TYPE_NORMAL
- en: '*Technology is nothing. What’s important is that you have a faith in people,
    that they’re basically good and smart, and if you give them tools, they’ll do
    wonderful things with them.*'
  prefs: []
  type: TYPE_NORMAL
- en: –Steve Jobs
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/common.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Once hackers have gained access to a machine, they often want to remain undetected.
    One way to do this is to install a *rootkit*. A rootkit replaces parts of the
    operating system with the attacker’s code, which is sort of like pasting a photo
    of a room over a security camera. For example, a rootkit might replace the operating
    system function that lists all files with one that lists all files except those
    the hacker created. Thus, when an antivirus tool attempts to search for malicious
    files by reading the filesystem, it won’t find anything suspicious.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, you’ll modify the kernel on your Kali Linux machine by writing
    a Linux kernel module, a Linux operating system extension that can be used to
    create a rootkit. Then you’ll override the operating system’s functions using
    a technique called *hooking*. We’ll use this hooking technique to write a rootkit
    that stops the system from rebooting and hides malicious files. We’ll conclude
    by using a Metasploit graphical user interface (GUI) called Armitage to scan a
    machine, exploit a vulnerability, and install a rootkit on it.
  prefs: []
  type: TYPE_NORMAL
- en: '**Writing a Linux Kernel Module**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A common way attackers create rootkits is by exploiting a feature of the Linux
    operating system called *kernel modules*. This feature allows users to extend
    the operating system without recompiling or rebooting it. For example, when you
    connect a web camera to your system, the webcam’s installer adds software called
    a *driver* to the kernel. This driver enables the kernel to interact with your
    new hardware. The ability to insert and run code directly in the kernel makes
    kernel modules a great candidate for developing rootkits, which work best when
    integrated into the kernel.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, you’ll become familiar with how Linux kernel modules work by
    writing one yourself and running it on your Kali Linux virtual machine. The module
    you’ll create will log a message whenever you add or remove it.
  prefs: []
  type: TYPE_NORMAL
- en: '***Backing Up Your Kali Linux Virtual Machine***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Any coding errors you make in your kernel module could result in kernel crashes,
    so first create a backup snapshot of your Kali Linux virtual machine so you can
    restore it in the event of a crash. [Figure 11-1](ch11.xhtml#ch11fig1) provides
    instructions on how to do this.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/ch11fig01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 11-1: How to create a snapshot*'
  prefs: []
  type: TYPE_NORMAL
- en: Select the Kali Linux machine from your list of virtual machines ➊ and then
    click **Snapshots**. Then select **Take** ➋. Give your snapshot a name ➌ and then
    click **OK** ➍.
  prefs: []
  type: TYPE_NORMAL
- en: '***Writing the Code***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The kernel module code differs from the other programs we’ve covered in this
    book so far. First, instead of using Python, we’ll write our first kernel module
    in C. That’s because the Linux kernel is written in C, so kernel modules must
    also be written in C. Secondly, we won’t be able to use the standard C libraries
    (such as `unistd`, `stdio`, and `stdlib`), because user space libraries are not
    available in kernel mode. (I’ll discuss these two modes in the “System Calls”
    section of this chapter.)
  prefs: []
  type: TYPE_NORMAL
- en: Another difference between most programs you may have written and kernel modules
    is that kernel modules are event driven. This means that instead of running sequentially,
    the program executes in response to events such as mouse clicks or keyboard interrupts.
    Kernel modules run in a privileged state, which means that they can access and
    change anything in the system.
  prefs: []
  type: TYPE_NORMAL
- en: 'Every kernel module must respond to two events: `module_init()` and `module_exit()`.
    The `module_init()` event occurs when you add the module to the kernel, and the
    `module_exit()` event occurs when you remove the module from the kernel.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To get started, create a Desktop folder called *lkm_rootkit*, and create two
    empty files, *hello.c* and *Makefile*, by running the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, copy the following into *hello.c*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Notice that there is no `main` method in this program. Instead, we define the
    function that runs in response to the `module_int` event ➊, which calls the `printk()`
    function ➋. Unlike a traditional user-level `printf()` method that prints to the
    console (remember that we don’t have a console when running in the kernel), the
    `printk()` method logs the value. Each log entry is associated with a log-level
    flag (for example, `KERN_NOTICE` ➌). [Table 11-1](ch11.xhtml#ch11tab1) lists the
    various flags and their associated meanings. Next we define the function to run
    when the `module_exit` event is fired ➍. Lastly, we register the functions with
    the `module_init` ➎ and `module_exit` ➏ events, respectively. These are the functions
    that will be run when the kernel module is loaded and removed, respectively. The
    `MODULE_LICENSE` tag is required for all Linux kernel modules. In this case, we
    are using the GNU General Public License (GPL).
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 11-1:** Kernel Log Flags'
  prefs: []
  type: TYPE_NORMAL
- en: '| Flag | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `KERN_EMERG` | Emergency condition, system is probably dead |'
  prefs: []
  type: TYPE_TB
- en: '| `KERN_ALERT` | Some problem has occurred, immediate attention is needed |'
  prefs: []
  type: TYPE_TB
- en: '| `KERN_CRIT` | A critical condition |'
  prefs: []
  type: TYPE_TB
- en: '| `KERN_ERR` | An error has occurred |'
  prefs: []
  type: TYPE_TB
- en: '| `KERN_WARNING` | A warning |'
  prefs: []
  type: TYPE_TB
- en: '| `KERN_NOTICE` | Normal message to take note of |'
  prefs: []
  type: TYPE_TB
- en: '| `KERN_INFO` | Some information |'
  prefs: []
  type: TYPE_TB
- en: '| `KERN_DEBUG` | Debug information related to the program |'
  prefs: []
  type: TYPE_TB
- en: Now that you’ve written your kernel module, let’s compile it.
  prefs: []
  type: TYPE_NORMAL
- en: '***Compiling and Running Your Kernel Module***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The make file you’ll create (*Makefile*) will contain instructions the compiler
    will use to build the kernel module. Open *Makefile* in your favorite text editor,
    copy in the following, and then save the file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The first command ➊ tells the kernel’s build system to compile the file (*hello.c*)
    into an object file (*hello.o*). This build system passes the object file to software
    in the compiler’s pipeline called the *linker*, which fills in the addresses of
    the other libraries to which the module refers. Once the linking process has completed,
    the linker produces the final kernel module file, *hello.ko*. The make file asks
    the kernel build system to build all the modules in the current directory ➋.
  prefs: []
  type: TYPE_NORMAL
- en: 'Make sure that you have the Linux headers installed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, run the `make` command in the *lkm_rootkit* directory to start the build
    process:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, run the following command to insert your Linux kernel module into the
    kernel:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Each time you insert the module into the kernel, the Linux operating system
    will call the `__init` function. This module uses the `printk()` function to write
    the message `Hello, Kernel Reporting for Duty!` to the kernel logs */var/log/syslog*
    and */var/log/kern.log*. The kernel also includes these messages in the *kernel
    ring buffer*, which is a circular queue into which the kernel inserts messages
    it generates. Run the `**dmesg**` command to view the messages:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, the kernel ring buffer contains a lot of debug information.
    Use the `grep` command to filter through the results:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'You can also view the last few messages logged by the kernel using the `tail`
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Use the `**lsmod**` command to view a list of all loaded kernel modules:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'You should find the module you just installed ➊. You’ve now successfully inserted
    code directly into the kernel using a kernel module! This means that you can now
    modify the kernel, bringing you one step closer to transforming your kernel module
    into a rootkit. You might be thinking: Won’t a system administrator be able to
    discover my rootkit by just listing the kernel modules as we just did? Well, yes,
    but later in this chapter I’ll discuss how to keep our module from showing up
    in this list.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Use the `rmmod` command to remove your Linux kernel module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: When you remove your kernel module, the operating system will call the `__exit`
    function and the module will log the `Bye bye!` message.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*You must be careful when implementing your module. Coding mistakes can cause
    your module to crash, and it will be difficult to remove the module. If this happens,
    reboot your virtual machine.*'
  prefs: []
  type: TYPE_NORMAL
- en: You can find further details about building Linux kernel modules at *[https://tldp.org/LDP/lkmpg/2.6/html/lkmpg.html](https://tldp.org/LDP/lkmpg/2.6/html/lkmpg.html)*.
  prefs: []
  type: TYPE_NORMAL
- en: '**Modifying System Calls**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this section, we’ll look at how you can use kernel modules to create rootkits.
    In particular, you’ll learn how you can use them to hook into system calls. But
    first I must discuss what a system call is.
  prefs: []
  type: TYPE_NORMAL
- en: '***How System Calls Work***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'To prevent a malicious program from directly modifying the kernel, a computer’s
    processor divides the memory into two regions: *user space* and *kernel space*.'
  prefs: []
  type: TYPE_NORMAL
- en: When a user program runs, it uses the user space region of the memory. In contrast,
    kernel space memory can be accessed only when the processor is running in privileged
    mode. Switching to privileged mode requires special permissions, or privilege
    levels, which are stored in the last two bits of a special register called the
    *code segment (CS) register*. The processor checks the CS register whenever it
    fetches data from protected memory.
  prefs: []
  type: TYPE_NORMAL
- en: 'Intel processors have four privilege levels: 3, 2, 1, and 0\. Privilege level
    3 is used by user programs, privilege levels 2 and 1 are used by device drivers,
    and privilege level 0 is used by the kernel. However, in practice, modern systems
    use only level 0 (kernel mode) and level 3 (user mode). The processor will only
    fetch a memory section if the CS register’s privilege level allows it. [Figure
    11-2](ch11.xhtml#ch11fig2) shows how the CS register manages access to protected
    sections of memory and helps to enforce kernel space/user space segmentation.'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/ch11fig02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 11-2: Kernel space versus user space and code segment (CS) register*'
  prefs: []
  type: TYPE_NORMAL
- en: Activities such as reading a file or accessing the network are considered privileged;
    therefore, the code associated with these activities is stored in kernel space.
    But you might be wondering how user-level programs like your browser access the
    network.
  prefs: []
  type: TYPE_NORMAL
- en: 'Well, the processor provides a special instruction called a *system call (syscall)*.
    This instruction transfers control to the kernel, which then runs the appropriate
    function. To understand how a program activates one of these syscalls, consider
    the following program, which opens a file, writes the value 7, and then closes
    the file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'All three operations, `open`, `write`, and `close`, are privileged; therefore,
    they must invoke syscalls. To see these calls in action, let’s look at a snippet
    of the assembly code associated with the `fclose()` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: A program must follow these steps when using the syscall instruction. During
    the first step ➊, the compiler moves the syscall number into the `%eax` CPU register.
    In this case, the value 3 represents the `close` system call. In the second step,
    the processor executes the `syscall` instruction ➋ and transfers control to the
    kernel. The kernel will use the number stored in the `%eax` register to index
    into the *system call table*, which is an array in kernel memory that stores pointers
    to kernel functions. [Figure 11-3](ch11.xhtml#ch11fig3) shows an illustration
    of the system call table.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/ch11fig03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 11-3: A visualisation of the system call table in memory*'
  prefs: []
  type: TYPE_NORMAL
- en: When the function associated with the syscall completes, it places the return
    value in the `%rax` register and switches control back to the user program. During
    the third step ➌, the user program checks the value in `%rax`. This value tells
    the user program whether the kernel function returned an error. Errors are indicated
    by a value of –1\. If no errors occurred, the function completes and returns ➍.
  prefs: []
  type: TYPE_NORMAL
- en: 'To see a list of syscalls and their corresponding system call numbers, look
    at the *unistd_64.h* or *unistd_32.h* file on your system. Use the `**find**`
    command to search the file’s root (`/`) directory, and the `**-iname**` option
    to perform a case-insensitive search:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Select the last option ➊, which is the library used by the GNU compiler and
    use the `**cat**` command to list the file’s contents:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Notice that this file defines several constants, which store the system call
    numbers. For example, the `__NR_close` constant ➊ stores syscall number `3`. These
    constants allow us to write more readable programs. Instead of using arbitrary
    integers to index into the system call array (for instance, by writing `sys_call_table[3]`),
    we can use the predefined constant `sys_call_table[__NR_close]`.
  prefs: []
  type: TYPE_NORMAL
- en: '***Hooking Syscalls***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Now that we’ve discussed syscalls and how they work, let’s discuss how we could
    design a rootkit that hooks one. *Hooking* is the process of overriding an entry
    in the system call table with a new pointer to the attacker’s function. [Figure
    11-4](ch11.xhtml#ch11fig4) shows a visual example of hooking the `read` syscall.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/ch11fig04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 11-4: An overview of the hooking process*'
  prefs: []
  type: TYPE_NORMAL
- en: The kernel module replaces the `read` entry in the system call table with a
    pointer to the hacker’s `read` function. Because your kernel module is a part
    of the kernel, it has access to all of the kernel’s memory and its variables.
    This means that it can access the kernel’s system call table, which is just an
    array in memory. Because your kernel module can read and write memory, it can
    also modify entries in this table or any other part of the kernel you choose.
  prefs: []
  type: TYPE_NORMAL
- en: Often, instead of reimplementing the entire `read` function, an attacker can
    selectively call the original `read` function from within their new `read` function.
    Doing this allows them to selectively respond to reads. For example, they might
    choose to modify some reads while allowing others to function normally. Or, they
    might block reads to their secret files while allowing other reads to function
    normally.
  prefs: []
  type: TYPE_NORMAL
- en: '**Hooking the Shutdown Syscall**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Let’s write a kernel module that will prevent a user from performing a software-based
    system reboot. We’ll do this by modifying the kernel module you wrote earlier
    (*hello.c*) to hook the `__NR_reboot` syscall.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s begin by finding the address of the system call table in memory. You can
    usually get this address using the kernel’s `kallsyms_lookup_name` function; however,
    techniques for locating the system call table will vary depending on the kernel’s
    version. Here I discuss a method tested with Linux kernel version 5.7 running
    in a virtual machine.
  prefs: []
  type: TYPE_NORMAL
- en: 'Copy the following C code to below the `#include` statements in your *hello.c*
    module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Once we have the system call table’s address, we can modify its entries. However,
    the system call table may be stored in a write-protected memory location that
    allows only reads. The processor will write these pages only if the `WP` (write
    protect) flag is 0 (false), so we must modify this flag, too.
  prefs: []
  type: TYPE_NORMAL
- en: 'The write-protect flag is stored in the 17th bit of the Intel x86_64 processor’s
    32-bit control register (cr0). The Linux kernel implements a function called `write_cr0`,
    which writes a value to the cr0 register. Instead of using this predefined Linux
    function, whose functionality varies depending on whether it is run in a virtual
    environment, we’ll write a function called `my_write_cr0` that explicitly executes
    assembly instructions to set the cr0 register:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we can disable the `WP` flag by bitwise AND-ing (`&`) the register with
    a negation (`~`) of `0x10000`. This effectively sets the flag’s current value
    to 0:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Then we can reenable write protection; that is, set the bit back to one, by
    computing the bitwise OR between the register and the value `0x10000`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Now let’s write the C function that will allow our kernel module to hook the
    system call table:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: First, we save a copy of the old reboot system call ➊. We’ll need this to replace
    the old function pointer after we unload the module because we want the system
    to function normally when we remove it. Next, we disable write protection by calling
    the function we just wrote and update the `__NR_reboot` entry ➋ in the system
    call table to point to our new reboot function, which we’ll define in the following
    code snippet. Lastly, we’ll reenable write protection.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let’s pull this all together into a single file. Copy the following into
    a new file called *reboot_blocker.c* and save it to the *lkm_rootkit* folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: In addition to the hook function ➊, we also include a function to restore the
    system call entry to its original value ➋. We’ll call this function when we remove
    the module. We also define the `hackers_reboot()` function that will replace the
    reboot function in the system call table. This function has the same parameters
    as the kernel’s original reboot function.
  prefs: []
  type: TYPE_NORMAL
- en: 'You might be wondering what the `magic1` and `magic2` parameters represent.
    Well, because Linux is open source, we can view the system call’s source code
    in the *reboot.c* file. I’ve included a snippet of the code here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'The additional checks ➊ reduce the likelihood that a memory corruption error
    will cause the machine to reboot spontaneously. That’s because the memory corruption
    would need to affect both the system call table and all the constants ➋ for this
    type of error to occur. So what value did Linus Torvalds, the developer of Linux,
    choose for these constants? Take a look:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Torvalds chose his birthday and those of his three kids. These constants get
    checked to ensure that a memory corruption didn’t cause the shutdown: a great
    Linux Easter egg. Every time you shut down a Linux machine, remember that you
    need a little bit of magic.'
  prefs: []
  type: TYPE_NORMAL
- en: Returning to our code, the `cmd` parameter specifies the command shortcut CTRL-ALT-DELETE
    to trigger a shutdown. The final parameter is a pointer to the user. The Linux
    kernel uses this value to ensure that the user has proper privileges to shut down
    the machine.
  prefs: []
  type: TYPE_NORMAL
- en: You’ll also notice that the function signature includes the `asmlinkage` macro.
    This macro tells the compiler to check the stack (a region of a program’s memory
    used to store variables temporarily) instead of the registers for the function’s
    parameters. This is because the `syscall` instruction places these parameters
    on the stack.
  prefs: []
  type: TYPE_NORMAL
- en: We defined a constant called `enable_reboot`. Setting this constant to 1 allows
    the system to reboot, but setting it to 0 blocks the reboot call and returns the
    `EPERM` constant. This constant indicates that the user has insufficient permissions
    to reboot as we now control the system.
  prefs: []
  type: TYPE_NORMAL
- en: 'It’s time to compile the kernel module. Edit the first line in *Makefile* so
    that it targets the *reboot_blocker.c* file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Now install the kernel module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Check the logs to make sure the kernel module is installed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'To test it, do a software-based reboot of your Kali Linux system by running
    the following command in the terminal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'This should cause the GUI of your Kali Linux machine to shut down and return
    you to the Kali logo. However, the kernel has not shut down and can still be detected.
    In pfSense, ping your Kali Linux machine:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: If you installed the module correctly, you’ll notice that the Kali Linux kernel
    still responds to the pings, indicating that it is still up and running. When
    this module is running, a victim would have to hit the power switch or unplug
    the machine to completely shut it down.
  prefs: []
  type: TYPE_NORMAL
- en: '**Hiding Files**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Rootkits can also hide files by hooking the “get directory entries” system
    call (`__NR_getdents64`), which runs the `getdents()` kernel function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, the `getdents()` function takes three parameters as input. The
    first parameter is the file ID returned by the `open` syscall, which is an integer
    that uniquely identifies a file or directory. The second parameter is a pointer
    to an array of Linux directory entries (`linux_dirent`). The third parameter is
    the number of entries in that array.
  prefs: []
  type: TYPE_NORMAL
- en: '***The linux_dirent struct***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Let’s take a look at the structure of entries in the `linux_dirent` array.
    These entries are important because they’re what is displayed in your file explorer
    or whenever you run the `ls` command. Removing an entry from this list will remove
    it from all programs that use the `dirent64` syscall to display files:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: The `d_ino` field is an 8-byte field containing a unique number that identifies
    the *inode* associated with a file. Inodes are data structures the Linux filesystem
    uses to store metadata such as file size and timestamp. Inodes also include pointers
    to the place where the file is stored in memory. The second field is the 8-byte
    file offset, which specifies the number of bytes until the next entry in the array.
    The next field, `d_reclen`, represents the total length of the entry. The 1-byte
    `d_type` field is used to distinguish the entry’s type as both files and directories
    are valid entries in the `linux_dirent` array. The final field, `d_name[]`, contains
    the file or directory name.
  prefs: []
  type: TYPE_NORMAL
- en: '***Writing the Hooking Code***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Hooking the syscall associated with the `getdents64()` function allows us to
    run our malicious function when that syscall is called. Our function will call
    the original `getdents64()` function; however, we’ll remove entries containing
    our malicious files’ names from the array of Linux directory entries before returning
    from the call. More specifically, any entries that start with the prefix `eh_hacker_`
    will be removed, making it seem as though they never existed.
  prefs: []
  type: TYPE_NORMAL
- en: To visualize the work we’ll have to do, take a look at [Figure 11-5](ch11.xhtml#ch11fig5),
    which shows how we’ll modify the array containing directory entries. In this example,
    the shaded entry is a file containing the `eh_hacker_` prefix.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/ch11fig05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 11-5: How the directory entry array is modified*'
  prefs: []
  type: TYPE_NORMAL
- en: 'As soon as we’ve discovered a file with the `eh_hacker_` prefix, we remove
    it from the array, overriding it by moving the subsequent value up. In this example,
    we overwrite 3 by moving 4 and 5 up next to 2\. Lastly, we update the length of
    the array from 5 to 4\. The following code implements the malicious `hacker_getdents64()`
    function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: We call the kernel’s original `getdent64()` function ➊, which updates the pointer
    to point to the Linux directory entries array and set the count to the number
    of entries. It will also return the number of bytes in the array. Next, we loop
    through all the entries ➋ and increment the offset until we get to the last byte
    in the byte array. During each iteration of the loop, we calculate an entry’s
    address by adding the offset’s value to the directory entries pointer (`drip`).
    Then we cast the address to be a pointer to the `linux_direct` struct so that
    we can easily access its fields. Next, we check the filename entry to see whether
    it starts with our prefix (`eh_hacker_`) ➌. If it doesn’t match, we skip it by
    advancing the offset to the next entry. However, if it does contain our prefix,
    we calculate the number of remaining bytes ➍ and then override the entry by sliding
    the remaining bytes back, as shown in [Figure 11-5](ch11.xhtml#ch11fig5). Lastly,
    we decrement the count and the number of bytes.
  prefs: []
  type: TYPE_NORMAL
- en: In addition to hiding files, sophisticated rootkits, such as the one in the
    Drovorub malware, also hide processes, sockets, and packets. These activities
    help the malware avoid detection. For example, hiding packets enables the rootkit
    to avoid detection while communicating with an attacker’s server. It can hide
    packets by hooking into the Netfilter component, a part of the Linux kernel that
    allows firewalls to block and filter packets.
  prefs: []
  type: TYPE_NORMAL
- en: '**Using Armitage to Exploit a Host and Install a Rootkit**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Now that you’ve seen how kernel module base rootkits work, let’s use a tool
    called *Armitage* to execute an attack from start to finish. We’ll begin by scanning
    the Metasploitable virtual machine to identify a vulnerability. Then we’ll exploit
    that vulnerability to upload a reverse shell, which we’ll use to download and
    install a rootkit.
  prefs: []
  type: TYPE_NORMAL
- en: 'Armitage is a GUI that simplifies interfacing with the Metasploit Framework.
    The commercial version of this software is called Cobalt Strike, and it costs
    approximately $3,500\. Luckily, Armitage is free, though it can be buggy. Install
    it by running the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Once the installation is complete, start the `postgresql` database service,
    which the Metasploit Framework uses to store information about client connections:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Armitage is a GUI interface for the Metasploit Framework, so you must ensure
    that Metasploit is running before launching Armitage. After the database has been
    initialized, start Metasploit by running the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Now launch Armitage:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: The first time you run this command, it should take a minute to load, so be
    patient. When it finishes, you should see a setup screen like that in [Figure
    11-6](ch11.xhtml#ch11fig6). Use all the default options and click **Connect**
    to use a local Metasploitable server.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/ch11fig06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 11-6: The Armitage setup screen*'
  prefs: []
  type: TYPE_NORMAL
- en: Click **Yes** to start Metasploit’s remote procedure call (RPC) server, which
    allows you to use Armitage to programmatically control the Metasploit Framework.
  prefs: []
  type: TYPE_NORMAL
- en: '***Scanning the Network***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Let’s start by using the Armitage discovery tool to find the machines in your
    virtual environment. Click **Hosts** ▶ **Scan** ▶ **Quick Scan OS Detect**, as
    shown in [Figure 11-7](ch11.xhtml#ch11fig7). The **Quick Scan OS Detect** option
    will perform a quick `nmap` scan of the virtual environment.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/ch11fig07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 11-7: An example of running the quick scan*'
  prefs: []
  type: TYPE_NORMAL
- en: You should see a pop-up that asks you for the range of IP addresses you want
    to scan. This pop-up takes an address in CIDR notation (for example, 192.168.1.0/24;
    see [Chapter 2](ch02.xhtml#ch2) for a discussion of CIDR).
  prefs: []
  type: TYPE_NORMAL
- en: Once you’ve discovered some hosts, scan them for vulnerabilities by clicking
    the host and selecting **Attacks** ▶ **Find Attacks** ([Figure 11-8](ch11.xhtml#ch11fig8)).
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/ch11fig08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 11-8: Using Armitage to quickly scan all addresses*'
  prefs: []
  type: TYPE_NORMAL
- en: When the vulnerability scan has completed, click the host and select **Attack**.
    You should see a list of available attacks. The Metasploit Framework has a built-in
    scanner, similar to those discussed in [Chapter 8](ch08.xhtml#ch8), that locates
    possible vulnerabilities. The vulnerability scanner will discover the FTP vulnerability
    we discussed in [Chapter 1](ch01.xhtml#ch1). [Figure 11-9](ch11.xhtml#ch11fig9)
    shows the FTP attack.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/ch11fig09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 11-9: The vftpd vulnerability*'
  prefs: []
  type: TYPE_NORMAL
- en: Alternatively, you can use the search box on the left to search the hosts for
    a specific exploit.
  prefs: []
  type: TYPE_NORMAL
- en: '***Exploiting a Host***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: When Armitage attacks a host, it uploads a payload to the host. Thus, you must
    configure the payload so that it knows how to connect to your machine. [Figure
    11-10](ch11.xhtml#ch11fig10) shows the configuration screen.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/ch11fig10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 11-10: Description of the attack*'
  prefs: []
  type: TYPE_NORMAL
- en: You may have noticed that these options look very similar to the Metasploit
    Framework options used in [Chapter 10](ch10.xhtml#ch10). This is because Armitage
    is a GUI wrapper for Metasploit. LHOST is the IP address of the controlling machine,
    and LPORT is the port on the controlling machine. Similarly, RHOST is the IP address
    of the host you’re attacking, and RPORT is the port used by the reverse shell
    included in the payload uploaded to the host. Click **Use a reverse connection**
    option to instruct Armitage to generate a reverse shell similar to the one we
    implemented in [Chapter 4](ch04.xhtml#ch4) and then click **Launch** to launch
    the attack.
  prefs: []
  type: TYPE_NORMAL
- en: Once your host is compromised, the host’s icon in the Armitage GUI will change.
    To access the machine’s shell, right-click the host and then select **Shell**
    ▶ **Interact**, as shown in [Figure 11-11](ch11.xhtml#ch11fig11). A Linux shell
    should appear in the bottom of the window.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/ch11fig11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 11-11: Getting shell access in Armitage*'
  prefs: []
  type: TYPE_NORMAL
- en: '***Installing a Rootkit***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Now that you have access, use the shell associated with the payload to download
    and install a rootkit on the host. You can find a long list of open source rootkits
    that contains rootkits for Android, Linux, Windows, and macOS systems at *[https://github.com/rmusser01/Infosec_Reference/blob/master/Draft/Rootkits.md](https://github.com/rmusser01/Infosec_Reference/blob/master/Draft/Rootkits.md)*.
  prefs: []
  type: TYPE_NORMAL
- en: '**Exercises**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Complete these exercises to practice creating kernel modules. In the first exercise,
    you’ll write a kernel module called a *keylogger* that logs everything a user
    types, including usernames and passwords. In the second exercise, you’ll extend
    your module so that it hides from the `lsmod` command.
  prefs: []
  type: TYPE_NORMAL
- en: '***The Keylogger***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Keyloggers are common hacking tools, and implementing one in the kernel offers
    an extra advantage: it allows you to stealthily intercept all of a user’s keystrokes,
    regardless of which application they’re using.'
  prefs: []
  type: TYPE_NORMAL
- en: 'As you did earlier in this chapter, create a new folder for your module named
    *keylogger_module* and create two files, *keylogger.c* and *Makefile*. In the
    module file, first define a mapping array, which maps numeric keycodes (unique
    numbers assigned to each key on the keyboard) to characters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'A fun, interactive way to see the mapping is to open a terminal, run the `**showkey**`
    command, open another application like Mousepad, and start typing. The `showkey`
    command should display the key code of each key you press:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: You may have already noticed that the values are roughly in the order of a “qwerty”
    keyboard layout. Because actual keyboard layouts vary by region and preference,
    the keymap translates keycodes to specific ASCII characters. Put this keymap definition
    at the top of your *keylogger.c* file.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `__init` and `__exit` methods in this module are very short. They simply
    register and unregister, respectively, a keyboard `notifier_block` struct. You
    may have also noticed that the `__init` and `__exit` methods in this module have
    different names than the module we created in this chapter; that is, `start` and
    `end` rather than `startup` and `shutdown`—these names are arbitrary:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, to be notified when a user presses a key, we must specify a value for
    one of the attributes of the keyboard `notifier_block` struct. This struct is
    an API mechanism provided by the kernel that gives a module access to some keyboard
    functionality. We define it at the top of our module here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: Specifying values for predefined structs, as we’ve done here, is a common pattern
    when programming in the Linux kernel. If you take a look at the complete `notifier_block`
    struct definition in the Linux *notifier.h* source file, you’ll notice that it
    specifies many more attributes than are shown in our definition of it. However,
    they’re all set to `NULL` until a module (like ours) sets their values. Here,
    we’ve specified a value for the `notifier_call` attribute ➊ by providing a function
    pointer `notify_keypress` ➋. Now our function will be called whenever a user presses
    a key.
  prefs: []
  type: TYPE_NORMAL
- en: 'Complete the implementation of the `notify_keypress` function so that it logs
    user key presses:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'The `keyboard_notifier_param` struct ➊ contains details on the key press events.
    The source code from the `keyboard_notifier_param` struct is available in the
    *keyboard.h* file in the Linux source code. I’ve included a snippet of the file
    for your convenience; you can see all values in the struct associated with a key
    press event:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: We use these details to determine when a `keydown` event ➊ occurs and extract
    its `keycode` ➋. This keycode becomes an index for our keymap. You can read other
    details from this struct, as well, including the SHIFT key state and keyboard
    LED state. Try implementing functionality that adds the character a user types
    to the kernel ring buffer.
  prefs: []
  type: TYPE_NORMAL
- en: This module dumps key presses to the kernel’s logs. However, a more sophisticated
    logger could transmit key presses to a hacker’s machine, where the hacker could
    extract credentials.
  prefs: []
  type: TYPE_NORMAL
- en: '***Self-Hiding Module***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Extend the kernel module so that it hides from the `lsmod` command as soon as
    you install it. I’ll leave this implementation completely up to you. A great place
    to start is by looking at kernel modules that other developers have created. For
    instance, Reptile is a well-documented Linux kernel module rootkit. Take a look
    at its *module.c* file at *[https://github.com/f0rb1dd3n/Reptile/blob/master/kernel/module.c](https://github.com/f0rb1dd3n/Reptile/blob/master/kernel/module.c)*.
  prefs: []
  type: TYPE_NORMAL
