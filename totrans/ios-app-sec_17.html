<html><head></head><body>
<h2 class="h2" id="ch13"><a id="page_211"/><strong><span class="big">13</span></strong><br/><strong>ENCRYPTION AND AUTHENTICATION</strong></h2>
<p class="noindent">While Apple’s cryptographic APIs are fairly robust, many developers don’t know how to use them effectively. There are two major built-in encryption components that you have control over: the Keychain and the Data Protection API. These components share some of the same encryption keys and have similar protection attributes, and I’ll cover them in this chapter. I’ll also provide a look at lower-level crypto primitives and the (limited) circumstances in which you would want to use them.</p>
<h3 class="h3" id="ch13lev1sec01"><strong>Using the Keychain</strong></h3>
<p class="noindent">The Keychain is meant to be used when you have small snippets of sensitive data to store, including passwords, personal data, and so on. The Keychain itself is encrypted using the Device Key, combined with a user passcode if available. The Keychain’s API consists of four main operations: <code>SecItemAdd</code>, <code>SecItemUpdate</code>, <code>SecItemCopyMatching</code>, and <code>SecItemDelete</code>. These operations add items to the Keychain, update existing items, retrieve items, and delete them from the Keychain, respectively.</p>
<p class="indent"><a id="page_212"/>That said, I <em>really</em> wish I’d never see the GenericKeychain<sup><a href="footnote.html#fn109" id="fn_109">1</a></sup> sample code again. Everyone seems to base their Keychain code on it (which is reasonable), but this code predates any of the modern Keychain protections that actually prevent secret data from being stolen off your device by a physical attacker. In this section, you’ll learn about those protections and how to take advantage of them.</p>
<h4 class="h4" id="ch13lev2sec01"><em><strong>The Keychain in User Backups</strong></em></h4>
<p class="noindent">When users perform full backups of their devices, they have two security-related options: Unencrypted and Encrypted. <em>Unencrypted</em> backups can be restored only to the same device they were received from. <em>Encrypted</em> backups let the user select a passphrase to encrypt their backup data with. This allows the backup to be restored to any device (except for items marked with <code>ThisDeviceOnly</code>) and backs up the full contents of the Keychain as well. If you don’t want your Keychain item to be stored in backups, you can use the Keychain’s data protection attributes.</p>
<h4 class="h4" id="ch13lev2sec02"><em><strong>Keychain Protection Attributes</strong></em></h4>
<p class="noindent"><em>Keychain protection attributes</em> specify when Keychain data is allowed to be stored in memory and requested by the OS or an application. When adding items such as passwords or personal data to the Keychain, it’s important to specify a protection attribute because this explicitly states when the data should be available. Not specifying a protection attribute should be considered a bug.</p>
<p class="indent">Specify attributes when first storing an item in the Keychain by using the <code>SecItemAdd</code> method. You’ll need to pass in one of a predefined set of values (see <a href="ch13.html#ch13tab1">Table 13-1</a>) for <code>kSecAttrAccessible</code>.</p>
<p class="indentb">Three main types of access can be specified via this attribute:</p>
<p class="hanging"><strong>Always accessible</strong> The key is always available, regardless of whether the phone is locked.</p>
<p class="hanging"><strong>Accessible when unlocked</strong> The key is accessible when the device is unlocked; otherwise, attempts to access it will fail.</p>
<p class="hanging"><strong>Accessible after first unlocked</strong> The key is accessible after the device has booted and been unlocked for the first time.</p>
<p class="indentt">For each of the three main types of Keychain protection, there is an additional counterpart suffixed with <code>ThisDeviceOnly</code>. This means that the Key-chain item will not be backed up to iCloud, will be backed up to iTunes only if using encrypted backups, and cannot be restored onto another device.</p>
<p class="tablecap"><a id="page_213"/><a id="ch13tab1"/><strong>Table 13-1:</strong> Keychain Protection Attributes and Their Associated Meanings</p>
<table border="0" cellpadding="0" cellspacing="0" class="topbot" width="80%">
<thead>
<tr>
<td class="table_th" valign="top"><p class="table"><strong>Keychain protection attribute</strong></p></td>
<td class="table_th" valign="top"><p class="table"><strong>Meaning</strong></p></td>
</tr>
</thead>
<tbody>
<tr>
<td class="table" valign="top"><p class="table"><code>kSecAttrAccessibleAfterFirstUnlock</code></p></td>
<td class="table" valign="top"><p class="table">The key is inaccessible after boot, until the user enters a passcode for the first time.</p></td>
</tr>
<tr>
<td class="table" valign="top"><p class="table"><code>kSecAttrAccessibleAlways</code></p></td>
<td class="table" valign="top"><p class="table">The key is always accessible, as long as the device is booted. Note that this is deprecated in iOS 9 because it has no real advantage over <code>kSecAttrAccessibleAfterFirstUnlock</code>.</p></td>
</tr>
<tr>
<td class="table" valign="top"><p class="table"><code>kSecAttrAccessibleAlwaysThisDeviceOnly</code></p></td>
<td class="table" valign="top"><p class="table">The key is always accessible, but it cannot be ported to other iOS devices.</p></td>
</tr>
<tr>
<td class="table" valign="top"><p class="table"><code>kSecAttrAccessibleAfterFirstUnlockThisDeviceOnly</code></p></td>
<td class="table" valign="top"><p class="table">This is the same as the previous key, but this key remains on only this device.</p></td>
</tr>
<tr>
<td class="table" valign="top"><p class="table"><code>kSecAttrAccessibleWhenUnlocked</code></p></td>
<td class="table" valign="top"><p class="table">Whenever the device is unlocked (that is, after the user has entered a passcode), the key is accessible.</p></td>
</tr>
<tr>
<td class="table" valign="top"><p class="table"><code>kSecAttrAccessibleWhenUnlockedThisDeviceOnly</code></p></td>
<td class="table" valign="top"><p class="table">This is the same as the previous key, but this key remains only on this device (except for full, encrypted backups).</p></td>
</tr>
<tr>
<td class="table" valign="top"><p class="table"><code>kSecAttrAccessibleWhenPasscodeSetThisDeviceOnly</code></p></td>
<td class="table" valign="top"><p class="table">This is the same as the previous key, but this key will be available only to users who have a passcode set and will be removed from the device if that passcode is unset. It will not be included in any backups.</p></td>
</tr>
</tbody>
</table>
<p class="indent">When Keychain protections were first introduced, the default value was <code>kSecAttrAccessibleAlways</code>, creating an obvious security problem. <em>Accessible</em> in this case should be taken to mean “available to a physical attacker”: if someone steals your device, they’ll be able to read the contents of the Keychain. Generally, this is done by performing a temporary jailbreak and extracting the keys; using <code>kSecAttrAccessibleAfterFirstUnlock</code> instead will usually prevent this since a reboot is often required to perform the jailbreak. However, a code execution attack (such as someone exploiting a bug in a Wi-Fi driver) would give access to a device while it’s still running. In this case, <code>kSecAttrAccessibleWhenUnlocked</code> would be needed to prevent compromise of the keys, meaning that the attacker would need to determine the user’s passcode to extract secrets.</p>
<div class="note">
<p class="notet"><a id="page_214"/><strong>NOTE</strong></p>
<p class="notep"><em>Unfortunately, brute-forcing a four-digit PIN on iOS is ridiculously fast. Not only can this be done with a temporary jailbreak,</em><sup><a href="footnote.html#fn110" id="fn_110">2</a></sup> <em>but my colleagues have successfully built cute robots to physically brute-force PINs in less than a day.</em><sup><a href="footnote.html#fn111" id="fn_111">3</a></sup></p>
</div>
<p class="indent">Currently, the default attribute is <code>kSecAttrAccessibleWhenUnlocked</code>, which is a reasonably restrictive default. However, Apple’s public documentation disagrees about what the default attribute is supposed to be, so just in case, you should set this attribute explicitly on all Keychain items. For your own code, consider using <code>kSecAttrAccessibleWhenUnlockedThisDeviceOnly</code> if appropriate; when examining third-party source code, ensure that restrictive protection attributes are used.</p>
<p class="indent">In iOS 8, the <code>kSecAttrAccessibleWhenPasscodeSetThisDeviceOnly</code> protection attribute was added. Developers have long requested an API that requires a user to have a passcode set. This new attribute doesn’t directly accomplish that, but developers can use it to make decisions based on whether a passcode is set. When you attempt to add an item to the Keychain specifying the <code>kSecAttrAccessibleWhenPasscodeSetThisDeviceOnly</code> attribute, it will fail if the user does not have a passcode set. You can use this failure as a point at which to make a decision about whether to fall back to another Keychain protection attribute, alert the user, or just store less sensitive data locally.</p>
<p class="indent">If the user does have a passcode set, the addition will be successful; however, if the user ever decides to disable the passcode, the Class Keys used to decrypt the item will be discarded, preventing the item from being decrypted by the application.</p>
<h4 class="h4" id="ch13lev2sec03"><em><strong>Basic Keychain Usage</strong></em></h4>
<p class="noindent">There are several classes of Keychain items, as listed in <a href="ch13.html#ch13tab2">Table 13-2</a>. Unless you’re dealing with certificates, <code>kSecClassGenericPassword</code> can generally be used for most sensitive data, so let’s look at some useful methods on that class.</p>
<p class="tablecap"><a id="ch13tab2"/><strong>Table 13-2:</strong> Keychain Item Classes</p>
<table border="0" cellpadding="0" cellspacing="0" class="topbot" width="80%">
<thead>
<tr>
<td class="table_th" valign="top"><p class="table"><strong>Item class</strong></p></td>
<td class="table_th" valign="top"><p class="table"><strong>Meaning</strong></p></td>
</tr>
</thead>
<tbody>
<tr>
<td class="table" valign="top"><p class="table"><code>kSecClassGenericPassword</code></p></td>
<td class="table" valign="top"><p class="table">A plain-old password</p></td>
</tr>
<tr>
<td class="table" valign="top"><p class="table"><code>kSecClassInternetPassword</code></p></td>
<td class="table" valign="top"><p class="table">A password specifically used for an Internet service</p></td>
</tr>
<tr>
<td class="table" valign="top"><p class="table"><code>kSecClassCertificate</code></p></td>
<td class="table" valign="top"><p class="table">A cryptographic certificate</p></td>
</tr>
<tr>
<td class="table" valign="top"><p class="table"><code>kSecClassKey</code></p></td>
<td class="table" valign="top"><p class="table">A cryptographic key</p></td>
</tr>
<tr>
<td class="table" valign="top"><p class="table"><code>kSecClassIdentity</code></p></td>
<td class="table" valign="top"><p class="table">A key pair, comprising a public certificate and private key</p></td>
</tr>
</tbody>
</table>
<p class="indent"><a id="page_215"/><a href="ch13.html#ch13ex1">Listing 13-1</a> shows an example of how to use the Keychain to add a basic password item, using <code>SecItemAdd</code>. It sets up a dictionary to hold a Keychain <em>query</em>, which contains the appropriate key-value pairs to identify the password, sets a password policy, and specifies the password itself.</p>
<pre><span class="violet1">NSMutableDictionary</span> *dict = [<span class="violet1">NSMutableDictionary</span> dictionary];<br/><span class="violet1">NSData</span> *passwordData = [<span class="red">@"mypassword"</span> dataUsingEncoding:<span class="violet1">NSUTF8StringEncoding];</span><br/><br/>[<span class="violet1">dict</span> <span class="violet">setObject</span>:(__bridge <span class="rose">id</span>)kSecClassGenericPassword forKey:(__bridge <span class="rose">id</span>)<br/>     kSecClass];<br/>[dict <span class="violet">setObject</span>:<span class="red">@"Conglomco login"</span> forKey:(__bridge <span class="rose">id</span>)kSecAttrLabel];<br/>[dict <span class="violet">setObject</span>:<span class="red">@"This is your password for the Conglomco service."</span> forKey:<br/>     (__bridge <span class="rose">id</span>)kSecAttrDescription];<br/>[dict <span class="violet">setObject</span>:<span class="red">@"dthiel"</span> forKey:(__bridge <span class="rose">id</span>)kSecAttrAccount];<br/>[dict <span class="violet">setObject</span>:<span class="red">@"com.isecpartners.SampleKeychain"</span> forKey:(__bridge <span class="rose">id</span>)<br/>     kSecAttrService];<br/>[dict <span class="violet">setObject</span>:passwordData forKey:(__bridge <span class="rose">id</span>)kSecValueData];<br/>[dict <span class="violet">setObject</span>:(__bridge <span class="rose">id</span>)kSecAttrAccessibleWhenUnlocked forKey:(__bridge <span class="rose">id</span>)<br/>     kSecAttrAccessible];<br/><br/>OSStatus error = SecItemAdd((__bridge <span class="green">CFDictionaryRef</span>)dict, NULL);<br/><span class="rose">if</span> (error == errSecSuccess) {<br/>    <span class="violet1">NSLog(</span><span class="red">@"Yay"</span><span class="violet1">);</span><br/><span class="violet1">}</span></pre>
<p class="listcap"><a id="ch13ex1"/><em>Listing 13-1: Adding an item to the Keychain</em></p>
<p class="indent">Here, the <code>kSecClassGenericPassword</code> class is set for the Keychain item, along with a user-readable label, a long description, the account (username), and an identifier for the service (to prevent duplicates). The code also sets the password and an accessibility attribute.</p>
<p class="indent"><code>SecItemUpdate</code> works similarly. <a href="ch13.html#ch13ex2">Listing 13-2</a> shows <code>SecItemUpdate</code> in action with an example that updates the user’s password, which is stored in <code>kSecValueData</code>.</p>
<pre><span class="violet1">NSString</span> *newPassword = <span class="red">@""</span>;<br/><span class="violet1">NSMutableDictionary</span> *dict = [<span class="violet1">NSMutableDictionary</span> dictionary];<br/><br/>[dict <span class="violet">setObject</span>:(__bridge <span class="rose">id</span>)kSecClassGenericPassword forKey:(__bridge <span class="rose">id</span>)<br/>     kSecClass];<br/>[dict <span class="violet">setObject</span>:<span class="red">@"dthiel"</span> forKey:(__bridge <span class="rose">id</span>)kSecAttrAccount];<br/>[dict <span class="violet">setObject</span>:<span class="red">@"com.isecpartners.SampleKeychain"</span> forKey:(__bridge <span class="rose">id</span>)<br/>     kSecAttrService];<br/><br/><span class="violet1">NSDictionary</span> *updatedAttribute = [<span class="violet1">NSDictionary</span> dictionaryWithObject:[newPassword<br/>     dataUsingEncoding:<span class="violet1">NSUTF8StringEncoding]</span> forKey:(__bridge <span class="rose">id</span>)kSecValueData];<br/>OSStatus error = SecItemUpdate((__bridge <span class="green">CFDictionaryRef</span>)dict, (__bridge<br/>     <span class="green">CFDictionaryRef</span>)updatedAttribute);</pre>
<p class="listcap"><a id="ch13ex2"/><em>Listing 13-2: Updating a Keychain item with</em> <code>SecItemUpdate</code></p>
<p class="indent"><a id="page_216"/>When updating a Keychain item with <code>SecItemUpdate</code>, you have to set two dictionaries. One should specify the basic Keychain identification information (at least the class, account, and service information), and the other should contain the attribute to update.</p>
<p class="indent"><code>SecItemCopyMatching</code> can be used to query the Keychain to find one or more entries matching a given set of criteria. Typically, you’d construct a search dictionary using the class, account, and service attributes you use when creating or updating a Keychain item. Then, you’d instantiate an <code>NSDictionary</code> that will hold the search results and perform the actual <code>SecItemCopyMatching</code> call, passing in the search dictionary and a reference to the result dictionary. An example can be found in <a href="ch13.html#ch13ex3">Listing 13-3</a>.</p>
<pre>[dict <span class="violet">setObject</span>:(__bridge <span class="rose">id</span>)kSecClassGenericPassword forKey:(__bridge <span class="rose">id</span>)<br/>     kSecClass];<br/>[dict <span class="violet">setObject</span>:<span class="red">@"dthiel"</span> forKey:(__bridge <span class="rose">id</span>)kSecAttrAccount];<br/>[dict <span class="violet">setObject</span>:<span class="red">@"com.isecpartners.SampleKeychain"</span> forKey:(__bridge <span class="rose">id</span>)<br/>     kSecAttrService];<br/><br/>[dict <span class="violet">setObject</span>:(<span class="rose">id</span>)kCFBooleanTrue forKey:(__bridge <span class="rose">id</span>)kSecReturnAttributes];<br/><br/><span class="violet1">NSDictionary</span> *result = nil;<br/>OSStatus error = SecItemCopyMatching((__bridge <span class="green">CFDictionaryRef</span>)dict, (<span class="rose">void</span> *)&amp;<br/>     result);<br/><span class="violet1">NSLog(</span><span class="red">@"Yay %@"</span><span class="violet1">,</span> result);</pre>
<p class="listcap"><a id="ch13ex3"/><em>Listing 13-3: Querying the Keychain using</em> <code>SecItemCopyMatching</code></p>
<p class="indent">With the Keychain data in the <code>result</code> dictionary, you can then use this information to perform your security-sensitive tasks such as authenticating to a remote service or decrypting data. Note that if you construct a query based on attributes that don’t include the account and service (which uniquely identify Keychain items), you may get a return dictionary that contains more than one Keychain item. This dictionary can be limited with <code>kSecMatchLimit</code> (that is, by setting it to a value of 1), but this could lead to unpredictable behavior if you’re trying to search for a single piece of data like a password.</p>
<p class="indent">You can probably guess at this point what a <code>SecItemDelete</code> call will look like—see the example in <a href="ch13.html#ch13ex4">Listing 13-4</a> for the actual code.</p>
<pre><a id="page_217"/><span class="violet1">NSMutableDictionary</span> *searchDictionary = [<span class="violet1">NSMutableDictionary</span> dictionary];<br/><br/>[searchDictionary <span class="violet">setObject</span>:(__bridge <span class="rose">id</span>)kSecClassGenericPassword forKey:<br/>     (__bridge <span class="rose">id</span>)kSecClass];<br/>[searchDictionary <span class="violet">setObject</span>:<span class="red">@"dthiel"</span> forKey:(__bridge <span class="rose">id</span>)kSecAttrAccount];<br/>[searchDictionary <span class="violet">setObject</span>:<span class="red">@"com.isecpartners.SampleKeychain"</span> forKey:(__bridge <span class="rose">id</span>)<br/>     kSecAttrService];<br/><br/>OSStatus error = SecItemDelete((__bridge <span class="green">CFDictionaryRef</span>)searchDictionary);</pre>
<p class="listcap"><a id="ch13ex4"/><em>Listing 13-4: Deleting a Keychain item using</em> <code>SecItemDelete</code></p>
<p class="indent">Note that if you don’t uniquely identify your Keychain item, all matching items that your application has access to will be deleted.</p>
<h4 class="h4" id="ch13lev2sec04"><em><strong>Keychain Wrappers</strong></em></h4>
<p class="noindent">When working with the Keychain, you’ll probably end up writing a number of wrapper functions to make it more convenient since most applications use only a subset of the Keychain API’s functionality. There are actually a number of prewritten Keychain wrappers available from third parties; I tend to prefer Lockbox<sup><a href="footnote.html#fn112" id="fn_112">4</a></sup> for its simplicity and functionality. Lockbox provides a set of class methods for storing strings, dates, arrays, and sets. You can see the procedure for storing a secret string in <a href="ch13.html#ch13ex5">Listing 13-5</a>.</p>
<pre><span class="brown">#import "Lockbox.h"</span><br/><br/><span class="violet1">NSString</span> *keyname = <span class="red">@"KeyForMyApp"</span>;<br/><span class="violet1">NSString</span> *secret = <span class="red">@"secretstring"</span>;<br/><br/>[Lockbox setString:secret<br/>             forKey:keyname<br/>     accessibility:kSecAttrAccessibleWhenUnlocked];</pre>
<p class="listcap"><a id="ch13ex5"/><em>Listing 13-5: Setting a Keychain item with Lockbox</em></p>
<p class="indent">The key name will be prefixed with your application’s bundle ID automatically, and this value will be used as for both the account and service keys. Retrieving data from the Keychain works as shown in <a href="ch13.html#ch13ex6">Listing 13-6</a>.</p>
<pre><span class="violet1">NSString</span> *result = [Lockbox stringForKey:secret];</pre>
<p class="listcap"><a id="ch13ex6"/><em>Listing 13-6: Retrieving a string from the Keychain using Lockbox</em></p>
<p class="indent"><a id="page_218"/>Whichever wrapper you choose or write, ensure that it has the ability to set <code>kSecAttrAccessible</code> attributes because much available sample code neglects this feature.</p>
<h4 class="h4" id="ch13lev2sec05"><em><strong>Shared Keychains</strong></em></h4>
<p class="noindent">iOS has the capability to share Keychain data among multiple applications from the same developer by using Keychain access groups. For example, if you have a “buyer” app and a “seller” app for an online marketplace, you can let your users share the same username and password between the two applications. Unfortunately, this mechanism is widely misunderstood, which has led people to do horrifying things such as using named pasteboards to share items that should be specific to the Keychain.</p>
<div class="note">
<p class="notet"><strong>NOTE</strong></p>
<p class="notep"><em>To use Keychain access groups, your applications</em> must <em>share the same bundle seed ID. This can be specified only upon creation of a new App ID.</em><sup><a href="footnote.html#fn113" id="fn_113">5</a></sup></p>
</div>
<p class="indent">For your application to take advantage of access groups, you’ll need to create an Entitlements property list (see <a href="ch13.html#ch13fig1">Figure 13-1</a>) containing an array called <code>keychain-access-groups</code>, with a String entry for each shared Key-chain item.</p>
<div class="image"><img alt="image" src="graphics/f13-01.jpg"/></div>
<p class="figcap"><a id="ch13fig1"/><em>Figure 13-1: Define a Keychain access group consisting of your bundle seed ID and your company prefix, followed by a common name for the Keychain item.</em></p>
<p class="indent">The Keychain item will consist of the bundle seed ID, followed by your reverse-DNS notation developer identifier and a symbolic name that both applications can refer to the entitlement with (see <a href="ch13.html#ch13ex7">Listing 13-7</a>).</p>
<pre>[dict <span class="violet">setObject</span>:<span class="red">@"DTHIELISEC.securitySuite"</span> forKey:(<span class="rose">id</span>)kSecAttrAccessGroup];</pre>
<p class="listcap"><a id="ch13ex7"/><em>Listing 13-7: Setting the access group of a Keychain item</em></p>
<p class="indent"><a id="page_219"/>Here, <code>DTHIELISEC</code> is the bundle seed ID. Your bundle ID will also be a 10-character alphanumeric string. You’ll need to pass in the value of your new entitlement as the value of the <code>kSecAttrAccessGroup</code> key when creating a Keychain item via the <code>SecItemAdd</code> function. Note that you can have only one Keychain access group on a Keychain item.</p>
<div class="note">
<p class="notet"><strong>NOTE</strong></p>
<p class="notep"><em>Technically, if you create a Keychain access group and don’t specify it when creating a Keychain item, the first string in the</em> <code><em>keychain-access-groups</em></code> <em>array will be used as the default entitlement. So if you’re using only one access group, you don’t have to specify the group when doing a</em> <code><em>SecItemAdd</em></code><em>—but you should anyway.</em></p>
</div>
<h4 class="h4" id="ch13lev2sec06"><em><strong>iCloud Synchronization</strong></em></h4>
<p class="noindent">iOS 7 introduced a mechanism to allow Keychain items to be synchronized with iCloud, letting users share Keychain items across multiple devices. By default, this is not enabled on application-created Keychain items, but it can be enabled by setting <code>kSecAttrSynchronizable</code> to true.</p>
<pre>[query <span class="violet">setObject</span>:(<span class="rose">id</span>)kCFBooleanTrue forKey:(<span class="rose">id</span>)kSecAttrSynchronizable];</pre>
<p class="indent">Because this item is now potentially synchronized between multiple Keychains, updates to the item (including deletion) will propagate to all other locations as well. Ensure that your application can handle having Keychain items removed or changed by the system. Also note that you can’t specify an incompatible <code>kSecAttrAccessible</code> attribute when using this option. For instance, specifying <code>kSecAttrAccessibleWhenUnlockedThisDeviceOnly</code> doesn’t work because <code>ThisDeviceOnly</code> specifies that the item should never be backed up, either to iCloud, to a laptop or desktop, or to any other synchronization provider.</p>
<h3 class="h3" id="ch13lev1sec02"><strong>The Data Protection API</strong></h3>
<p class="noindent">As an extra layer of protection, Apple introduced the Data Protection API (not to be confused with Microsoft’s Data Protection API), which allows developers to specify when file decryption keys are available. This lets you control access to the file itself, similar to the <code>kSecAttrAccessible</code> attribute of Keychain items. The Data Protection API uses the user’s passcode in conjunction with a Class Key to encrypt keys specific to each protected file and discards the Class Key in memory when those files should not be accessible (that is, when the device is locked). When a PIN is enabled, the passcode settings screen will indicate that Data Protection is enabled, as in <a href="ch13.html#ch13fig2">Figure 13-2</a>.</p>
<div class="image"><a id="page_220"/><img alt="image" src="graphics/f13-02.jpg"/></div>
<p class="figcap"><a id="ch13fig2"/><em>Figure 13-2: Passcode settings with Data Protection enabled</em></p>
<h4 class="h4" id="ch13lev2sec07"><em><strong>Protection Levels</strong></em></h4>
<p class="noindent">There are several levels of protection that a developer can request with the Data Protection API, which are roughly analogous to the <code>kSecAttrAccessible</code> attributes one sets on Keychain items. Let’s explore those now.</p>
<h5 class="h5" id="ch13lev3sec01"><strong>The CompleteUntilFirstUserAuthentication Protection Level</strong></h5>
<p class="noindent"><code>CompleteUntilFirstUserAuthentication</code> is the default file protection attribute for iOS 5 and later. It will be applied to all applicable files unless another attribute has been explicitly specified. It’s functionally similar to <code>FileProtectionComplete</code>, except the file is always available after the user first unlocks the device after a reboot. This doesn’t offer a ton of protection if someone gains remote code execution on your running device or if there’s a Sandbox bypass, but it does protect you from some attacks that require a reboot.</p>
<h5 class="h5" id="ch13lev3sec02"><strong>The Complete Protection Level</strong></h5>
<p class="noindent"><code>Complete</code> is the safest file protection class available, if you can get away with using it. Complete protection ensures that after a short delay, locking the device discards the Class Key from memory and renders file contents unreadable.</p>
<p class="indent"><a id="page_221"/>This protection level is expressed with the <code>NSFileProtectionComplete</code> attribute of <code>NSFileManager</code> and the <code>NSDataWritingFileProtectionComplete</code> flag for <code>NSData</code> objects. For <code>NSData</code> objects, you can start by setting the <code>NSDataWritingFileProtectionComplete</code> flag, as shown in <a href="ch13.html#ch13ex8">Listing 13-8</a>.</p>
<pre><span class="violet1">NSData</span> *data = [request responseData];<br/><br/><span class="rose">if</span> (data) {<br/>    <span class="violet1">NSError</span> *error = nil;<br/>    <span class="violet1">NSString</span> *downloadFilePath = [<span class="violet1">NSString</span> stringWithFormat:<span class="red">@"%@mydoc.pdf"</span>, <span class="violet1">NS</span><br/>     <span class="violet1">TemporaryDirectory()];</span><br/>    [data writeToFile:downloadFilePath options<span class="violet1">:NSDataWritingFileProtectionComplete</span><br/>     error:&amp;error];</pre>
<p class="listcap"><a id="ch13ex8"/><em>Listing 13-8: Setting the</em> <code>NSDataWritingFileProtectionComplete</code> <em>flag on an</em> <code>NSData</code> <em>object</em></p>
<p class="indent">Once you’ve set <code>NSDataWritingFileProtectionComplete</code> on your <code>NSData</code> object, you can use <code>NNSFileManager</code> to set the <code>NSFileProtectionComplete</code> flag.</p>
<pre><span class="violet1">NSArray</span> *searchPaths = <span class="violet1">NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NS</span><br/>     <span class="violet1">UserDomainMask, YES);</span><br/><span class="violet1">NSString *applicationDocumentsDirectory</span> = [searchPaths lastObject];<br/><span class="violet1">NSString</span> *filePath = [applicationDocumentsDirectory stringByAppendingPathComponent:<br/>     <span class="red">@"mySensitivedata.txt"</span>];<br/><br/><span class="violet1">NSError</span> *error = nil;<br/><span class="violet1">NSDictionary</span> *attr =<br/>      [<span class="violet1">NSDictionary</span> dictionaryWithObject<span class="violet1">:NSFileProtectionComplete</span><br/>                                  forKey:<span class="violet1">NSFileProtectionKey];</span><br/><br/>[<span class="violet1">[NSFileManager</span> <span class="violet">defaultManage</span><span class="violet1">r]</span> setAttributes:attr<br/>                                 ofItemAtPath:filePath<br/>                                        error:&amp;error];</pre>
<p class="listcap"><a id="ch13ex9"/><em>Listing 13-9: Setting the</em> <code>NSFileProtectionComplete</code> <em>flag using</em> <code>NSFileManager</code></p>
<p class="indent">You can also add file protection attributes on SQLite databases that you create, using the weirdly long <code>SQLITE_OPEN_READWRITE_SQLITE_OPEN_FILEPROTECTION_COMPLETEUNLESSOPEN</code> argument, as shown in <a href="ch13.html#ch13ex10">Listing 13-10</a>.</p>
<pre><span class="violet1">NSString</span> *databasePath = [documentsDirectory stringByAppendingPathComponent:<span class="red">@"</span><br/>     <span class="red">MyNewDB.sqlite"</span>];<br/><br/>sqlite3_open_v2([databasePath UTF8String], &amp;handle, SQLITE_OPEN_CREATE|<br/>     SQLITE_OPEN_READWRITE_SQLITE_OPEN_FILEPROTECTION_COMPLETEUNLESSOPEN,NULL);</pre>
<p class="listcap"><a id="ch13ex10"/><em>Listing 13-10: Setting protection attributes on SQLite databases</em></p>
<p class="indent"><a id="page_222"/>Think about how your app works before trying to use complete protection. If you have a process that will need continuous read/write access to a file, this protection mode will not be appropriate.</p>
<h5 class="h5" id="ch13lev3sec03"><strong>The CompleteUnlessOpen Protection Level</strong></h5>
<p class="noindent">The <code>CompleteUnlessOpen</code> protection level is slightly more complicated. You’ll set it with the <code>NSFileProtectionCompleteUnlessOpen</code> flag when using <code>NSFileManager</code> and set it with <code>NSDataWritingFileProtectionCompleteUnlessOpen</code> when manipulating <code>NSData</code> stores. It is not, as its name might suggest, a mechanism that disables file protection if a file is currently held open by an application. <code>CompleteUnlessOpen</code> actually ensures that open files can still be written to after the device is locked and allows new files to be written to disk. Any existing files with this class cannot be opened when the device is locked unless they were already open beforehand.</p>
<p class="indent">The way this works is by generating a key pair and using it to calculate and derive a shared secret, which wraps the file key. <a href="ch13.html#ch13fig3">Figure 13-3</a> illustrates this process.</p>
<div class="image"><img alt="image" src="graphics/f13-03.jpg"/></div>
<p class="figcap"><a id="ch13fig3"/><em>Figure 13-3: Key generation and wrapping. Note that the file private key <span class="ent">➌</span> is transient and is discarded after the wrapped file key is stored in the file metadata.</em></p>
<p class="indent">Let’s walk through this file protection process step by step:</p>
<ol>
<li><p class="noindent">As with all files, a file key <span class="ent">➊</span> is generated to encrypt the file’s contents.</p></li>
<li><p class="noindent">An additional key pair is generated<sup><a href="footnote.html#fn114" id="fn_114">6</a></sup> to produce the file public key <span class="ent">➋</span> and the file private key <span class="ent">➌</span>.</p></li>
<li><p class="noindent">The file private key <span class="ent">➌</span> and the Protected Unless Open class public key <span class="ent">➍</span> are used to calculate a shared secret <span class="ent">➎</span>.</p></li>
<li><p class="noindent">An SHA-1 hash of this secret <span class="ent">➏</span> is used to encrypt the file key.</p></li>
<li><p class="noindent">This encrypted file key <span class="ent">➐</span> is stored in the file’s metadata, along with the file public key.</p></li>
<li><p class="noindent">The system throws away the file private key.</p></li>
<li><p class="noindent">Upon closing the file, the unencrypted file key is erased from memory.</p></li>
<li><p class="noindent"><a id="page_223"/>When the file needs to be opened again, the Protected Unless Open class private key and the file public key are used to calculate the shared secret.</p></li>
<li><p class="noindent">The SHA-1 hash of this key is then used to decrypt the file key.</p></li>
</ol>
<p class="indent">The upshot of this process is that you can still write data while the device is locked, without having to worry that an attacker will be able to read that data.</p>
<h4 class="h4" id="ch13lev2sec08"><em><strong>The DataProtectionClass Entitlement</strong></em></h4>
<p class="noindent">If your application is not going to need to read or write any files while in the background or when the device is locked, you can add an entitlement to the project with a value of <code>NSFileProtectionComplete</code>. This will ensure that all protectable data files written to disk will be accessible only when the device is unlocked, which is the equivalent of setting <code>kSecAttrAccessibleWhenUnlocked</code> on every applicable file.</p>
<div class="note">
<p class="notet"><strong>NOTE</strong></p>
<p class="notep"><em>While this will affect files managed with</em> <code><em>NSFileManager</em></code>, <code><em>NSData</em></code><em>, SQLite, and Core Data files, other types of files (for example, plists, caches, and so on) will not be protected.</em></p>
</div>
<p class="indent">In Xcode 5 and later, the Data Protection entitlement is enabled by default on new projects; however, old projects will not be automatically migrated. Enabling entitlement itself is fairly simple—just flip the switch as shown in <a href="ch13.html#ch13fig4">Figure 13-4</a>.</p>
<div class="image"><img alt="image" src="graphics/f13-04.jpg"/></div>
<p class="figcap"><a id="ch13fig4"/><em>Figure 13-4: Enable the Data Protection entitlement in Xcode 5.</em></p>
<p class="indent"><a id="page_224"/>Note that applications that were installed before iOS 7 do not automatically have Data Protection enabled. They either need to be updated or must have specifically requested a Data Protection attribute in the past.</p>
<h4 class="h4" id="ch13lev2sec09"><em><strong>Checking for Protected Data Availability</strong></em></h4>
<p class="noindent">For applications that do all their work in the foreground, Data Protection should work transparently. For applications that need to work in the background while the device is locked, your application will need to determine the availability of protected data before using it. This can be done via three different mechanisms.</p>
<h5 class="h5" id="ch13lev3sec04"><strong>Implementing Delegate Methods</strong></h5>
<p class="noindent">To be notified and take particular actions when data’s availability changes, your application should implement the <code>applicationProtectedDataWillBecomeUnavailable</code> and <code>applicationProtectedDataDidBecomeAvailable</code> delegate methods, as in <a href="ch13.html#ch13ex11">Listing 13-11</a>.</p>
<pre>- (<span class="rose">void</span>)applicationProtectedDataWillBecomeUnavailable:<br/>    (<span class="violet1">UIApplication *</span>)application {<br/><br/>    [<span class="rose">self</span> [<span class="green">theBodies</span> <span class="violet">hide</span>]];<br/>}<br/><br/>- (<span class="rose">void</span>)applicationProtectedDataDidBecomeAvailable:<br/>    (<span class="violet1">UIApplication *</span>)application {<br/><br/>    [<span class="rose">self</span> [<span class="green">theBodies</span> <span class="violet">exhume</span>]];<br/>}</pre>
<p class="listcap"><a id="ch13ex11"/><em>Listing 13-11: Delegate methods for detecting Data Protection availability changes</em></p>
<p class="indent">Use these delegate methods to ensure that tasks requiring protected data files clean up gracefully and to notify you when the files will be active again.</p>
<h5 class="h5" id="ch13lev3sec05"><strong>Using the Notification Center</strong></h5>
<p class="noindent">The <code>NSNotificationCenter</code> API essentially allows for an in-app broadcast mechanism, where one part of the app can listen for an event notification that can be called from other places in the code. To use the Notification Center to detect these state changes, you can register for the <code>UIApplicationProtectedDataWillBecomeUnavailable</code> and <code>UIApplicationProtectedDataDidBecomeAvailable</code> notifications, as shown in <a href="ch13.html#ch13ex12">Listing 13-12</a>.</p>
<pre>   - (<span class="rose">BOOL</span>)application:(<span class="violet1">UIApplication*</span>)application didFinishLaunchingWithOptions:<br/>       (<span class="violet1">NSDictionary*)launchOptions</span> {<br/><br/><span class="ent">➊</span> <span class="violet1">NSNotificationCenter</span> *nc = [<span class="violet1">NSNotificationCenter</span> defaultCenter];<br/><br/><span class="ent">➋</span> [nc addObserver:<span class="rose">self</span><br/>          selector:<span class="rose">@selector</span>(dataGoingAway:)<br/>              name:<span class="violet1">UIApplicationProtectedDataWillBecomeUnavailable</span><br/>            <span class="violet1">object:nil];</span><br/>   <span class="violet1">}</span><br/><br/><span class="ent">➌</span> <span class="violet1">-</span> (<span class="rose">void</span><span class="violet1">)dataGoingAway {</span><br/><br/>       <span class="violet1">[</span><span class="rose">self</span> <span class="violet1">[</span><span class="green">theBodies</span> <span class="violet">hide</span><span class="violet1">]];</span><br/><br/>   <span class="violet1">}</span></pre>
<p class="listcap"><a id="ch13ex12"/><em>Listing 13-12: Using the Notification Center to detect data availability changes</em></p>
<p class="indent"><a id="page_225"/>At <span class="ent">➊</span>, an instance of the default Notification Center is instantiated and then an observer <span class="ent">➋</span> is added that specifies the selector to call when the event specified by <code>name:</code> occurs. Then you can simply implement that selector as part of the same class <span class="ent">➌</span> and put any logic that you want to perform upon receipt of the event there.</p>
<h5 class="h5" id="ch13lev3sec06"><strong>Detecting Data Protection Using UIApplication</strong></h5>
<p class="noindent">You can also easily detect whether Data Protection is engaged at any given time, as shown in <a href="ch13.html#ch13ex13">Listing 13-13</a>.</p>
<pre><span class="rose">if</span> ([[<span class="violet1">UIApplication</span> <span class="violet">sharedApplication</span><span class="violet1">] isProtectedDataAvailable]) {</span><br/><br/>    <span class="violet1">[</span><span class="rose">self</span> <span class="violet1">[</span><span class="green">theBodies</span> <span class="violet">hide</span><span class="violet1">]];</span><br/><span class="violet1">}</span></pre>
<p class="listcap"><a id="ch13ex13"/><em>Listing 13-13: Using the</em> <code>protectedDataAvailable</code> <em>property</em></p>
<p class="indent">Just check the Boolean result of the <code>isProtectedDataAvailable</code> instance method of <code>UIApplication</code>.</p>
<h3 class="h3" id="ch13lev1sec03"><strong>Encryption with CommonCrypto</strong></h3>
<p class="noindent">First things first: you are (probably) not a cryptographer.<sup><a href="footnote.html#fn115" id="fn_115">7</a></sup> I’m not a cryptographer. It’s easy to think that you understand the subtleties of an encryption algorithm or to copy and paste crypto code from somewhere online, but you will generally mess up if you try to do crypto yourself.</p>
<p class="indent"><a id="page_226"/>That said, you should be aware of the CommonCrypto framework, if only so you can tell when other developers are trying to play cryptographer. There are some lower-level primitives for encryption and decryption operations, but the only one that you have any excuse for playing with is CCCrypt. <a href="ch13.html#ch13ex14">Listing 13-14</a> shows one example of how you might use it.</p>
<pre>CCCrypt(CCOperation op, CCAlgorithm alg, CCOptions options,<br/>   <span class="rose">const void</span> *key, size_t keyLength, <span class="rose">const void</span> *iv, <span class="rose">const void</span> *dataIn,<br/>   size_t dataInLength, <span class="rose">void</span> *dataOut, size_t dataOutAvailable,<br/>   size_t *dataOutMoved);</pre>
<p class="listcap"><a id="ch13ex14"/><em>Listing 13-14: Method signature for CCCrypt</em></p>
<p class="indent">The <code>CCCrypt</code> method takes 11 arguments: control over the algorithm, key length, initialization vector, operation mode, and so on. Each one is a potential place to make a cryptographic mistake. In my experience, there are several common pitfalls that developers run into with CCCrypt, which I’ll describe here. Don’t make the same mistakes!</p>
<h4 class="h4" id="ch13lev2sec10"><em><strong>Broken Algorithms to Avoid</strong></em></h4>
<p class="noindent">CCCrypt supports known bad encryption algorithms, such as DES, and if you use one, your app will almost certainly be susceptible to cryptographic attacks and brute-forcing. Even if you’re using the more modern AES, CCCrypt will let you switch from the default Cipher Block Chaining (CBC) mode to Electronic Code Book (ECB) using CCOptions, which is another bad idea. Using ECB mode causes identical blocks of plaintext to encrypt to identical blocks of ciphertext.<sup><a href="footnote.html#fn116" id="fn_116">8</a></sup> This is a problem because if attackers know one piece of encrypted data, they can infer the contents of other blocks. This can typically be solved with a salt or initialization vector, but they can have problems as well.</p>
<h4 class="h4" id="ch13lev2sec11"><em><strong>Broken Initialization Vectors</strong></em></h4>
<p class="noindent">The specification for AES’s CBC mode requires a nonsecret initialization vector (IV) to be supplied to the algorithm. The IV helps to randomize the encryption and produce distinct ciphertexts even if the same plaintext is encrypted multiple times. That way, you don’t need to generate a new key every time to prevent disclosure of identical blocks of data.</p>
<p class="indent">It’s important that you never reuse an IV under the same key, however, or two plaintext messages that begin with the same bytes will have ciphertext beginning with the same sequence of block values. This would reveal information about the encrypted messages to an attacker. As such, it’s important to use a random IV for each cryptographic operation.</p>
<p class="indent"><a id="page_227"/>You should also always make sure your call to AES CBC mode encryption functions don’t pass in a null initialization vector. If they do, then multiple sets of messages will be encrypted using the same key and IV, resulting in the situation I just described.</p>
<p class="indent">As you can see, using a static IV or a null IV has the same result: small blocks of ciphertext containing the same data will appear identical. An example of where this might be a problem would be a password manager, where encrypted keys are stored; if an attacker can read this data and determine that some of the ciphertexts are identical, they will know that the same password is used for multiple websites.</p>
<h4 class="h4" id="ch13lev2sec12"><em><strong>Broken Entropy</strong></em></h4>
<p class="noindent">In the worst case, you may come across code that uses <code>rand</code> to attempt to obtain random bytes (<code>rand</code> being cryptographically insecure and not meant for use in cryptographic operations). The official Cocoa way to obtain entropy is via <code>SecRandomCopyBytes</code>.</p>
<pre>uint8_t randomdata[16];<br/><span class="rose">int</span> result = <span class="green">SecRandomCopyBytes</span>(kSecRandomDefault, 16, (uint8_t*)randomdata);</pre>
<p class="indent">This code effectively acts as a wrapper of <em>/dev/random</em>, reading entropy from the kernel’s built-in entropy pool. Note that the <code>kSecRandomDefault</code> constant is not available on OS X, so if you’re writing code to be portable, simply specify <code>NULL</code> as the first argument. (Under iOS, this is equivalent to using <code>kSecRandomDefault</code>.)</p>
<h4 class="h4" id="ch13lev2sec13"><em><strong>Poor Quality Keys</strong></em></h4>
<p class="noindent">People often mistakenly use a user-supplied password as an encryption key. Especially on mobile devices, this results in a fairly weak, low-entropy encryption key. Sometimes, it’s as bad as a four-digit PIN. When using user-supplied input to determine an encryption key, a key derivation algorithm such as PBKDF2 should be used. The CommonCrypto framework provides this with <code>CCKeyDerivationPBKDF</code>.</p>
<p class="indentb">PBKDF2 is a key derivation function that uses a passphrase plus repeated iterations of a hashing algorithm to generate a suitable cryptographic key. The repeated iterations intentionally cause the routine to take longer to complete, making offline brute-force attacks against the passphrase far less feasible. <code>CCKeyDerivationPBKDF</code> supports the following algorithms for iterators:</p>
<p class="bull">• <code>kCCPRFHmacAlgSHA1</code></p>
<p class="bull">• <code>kCCPRFHmacAlgSHA224</code></p>
<p class="bull">• <code>kCCPRFHmacAlgSHA256</code></p>
<p class="bull">• <code>kCCPRFHmacAlgSHA384</code></p>
<p class="bull">• <code>kCCPRFHmacAlgSHA512</code></p>
<p class="indentt"><a id="page_228"/>If at all possible, you should be using at least SHA-256 or above. SHA-1 should be considered deprecated at this point because advances have been made to speed up cracking of SHA-1 hashes in recent years.</p>
<h3 class="h3" id="ch13lev1sec04"><strong>Performing Hashing Operations</strong></h3>
<p class="noindent">In some circumstances, you may need to perform a hashing operation to determine whether two blobs of data match, without comparing the entire contents. This is frequently used to verify a file against a “known good” version or to verify sensitive information without storing the information itself. To perform a simple hashing operation on a string, you can use the <code>CC_SHA</code> family of methods as follows:</p>
<pre>   <span class="rose">char</span> secret[] = <span class="red">"swordfish"</span>;<br/>   size_t length = <span class="rose">sizeof</span>(secret);<br/>   <span class="rose">unsigned char</span> hash[CC_SHA256_DIGEST_LENGTH];<br/><br/><span class="ent">➊</span> CC_SHA256(data, length, hash);</pre>
<p class="indent">This code simply defines a secret and its length and makes a char <code>hash</code> to contain the result of the hashing operation. At <span class="ent">➊</span>, the call to <code>CC_SHA_256</code> takes whatever has been put into <code>data</code>, calculates the hash, and stores the result in <code>hash</code>.</p>
<p class="indent">You may also be used to using OpenSSL for hashing functions. iOS does not include OpenSSL, but it does include some compatibility shims for using OpenSSL-dependent hashing code. These are defined in <em>CommonDigest.h</em>, shown in <a href="ch13.html#ch13ex15">Listing 13-15</a>.</p>
<pre><span class="rose">#ifdef</span> COMMON_DIGEST_FOR_OPENSSL<br/><br/>--<span class="codeitalic">snip</span>--<br/><br/><span class="rose">#define</span> SHA_DIGEST_LENGTH        CC_SHA1_DIGEST_LENGTH<br/><span class="rose">#define</span> SHA_CTX                    CC_SHA1_CTX<br/><span class="rose">#define</span> SHA1_Init                  CC_SHA1_Init<br/><span class="rose">#define</span> SHA1_Update                CC_SHA1_Update<br/><span class="rose">#define</span> SHA1_Final                 CC_SHA1_Final</pre>
<p class="listcap"><a id="ch13ex15"/><em>Listing 13-15: OpenSSL compatibility hooks for CommonCrypto hashing functions</em></p>
<p class="indent">So as long as you define <code>COMMON_DIGEST_FOR_OPENSSL</code>, OpenSSL-style hashing operations should work transparently. You can see an example in <a href="ch13.html#ch13ex16">Listing 13-16</a>.</p>
<pre><span class="rose">#define</span> COMMON_DIGEST_FOR_OPENSSL<br/><span class="rose">#include</span> &lt;CommonCrypto/CommonDigest.h&gt;<br/><br/>SHA_CTX ctx;<br/><span class="rose">unsigned char</span> hash[SHA_DIGEST_LENGTH];<br/><br/>SHA1_Init(&amp;ctx);<br/>memset(hash, 0, <span class="rose">sizeof</span>(hash));<br/>SHA1_Update(&amp;ctx, <span class="red">"Secret chunk"</span>, 12);<br/>SHA1_Update(&amp;ctx, <span class="red">"Other secret chunk"</span>, 18);<br/>SHA1_Final(hash, &amp;ctx);</pre>
<p class="listcap"><a id="ch13ex16"/><em>Listing 13-16: OpenSSL-style chunked SHA hashing</em></p>
<p class="indent"><a id="page_229"/><a href="ch13.html#ch13ex16">Listing 13-16</a> uses <code>SHA1_Update</code> and <code>SHA1_Final</code>, which is more appropriate for hashing a large file, where reading the file in chunks reduces overall memory usage.</p>
<h3 class="h3" id="ch13lev1sec05"><strong>Ensuring Message Authenticity with HMACs</strong></h3>
<p class="noindent">It’s important to make sure that encrypted message data hasn’t been tampered with or corrupted and that it was produced by a party in possession of a secret key. You can use a keyed <em>Hash Message Authentication Code (HMAC)</em> as a mechanism to guarantee the authenticity and integrity of a message. In an iOS application, you could use this to verify the authenticity of messages sent between applications or to have a remote server verify that requests were produced by the correct application. (Just take care that the key is generated and stored in such a way that it is unique to the device and well-protected.)</p>
<p class="indent">To calculate an HMAC, you just need a key and some data to pass to the <code>CCHmac</code> function, as shown in <a href="ch13.html#ch13ex17">Listing 13-17</a>.</p>
<pre>   <span class="brown">#include &lt;CommonCrypto/CommonDigest.h&gt;</span><br/>   <span class="brown">#include &lt;CommonCrypto/CommonHMAC.h&gt;</span><br/><br/><span class="ent">➊</span> <span class="violet1">NSData</span> *key = [<span class="red">@"key for the hash"</span> dataUsingEncoding:<span class="violet1">NSUTF8StringEncoding];</span><br/><span class="ent">➋</span> <span class="violet1">NSData *data</span> = [<span class="red">@"data to be hashed"</span> dataUsingEncoding<span class="violet1">:NSUTF8StringEncoding];</span><br/><span class="ent">➌</span> <span class="violet1">NSMutableData *hash</span> = [<span class="violet1">NSMutableData</span> dataWithLength:CC_SHA256_DIGEST_LENGTH];<br/><span class="ent">➍</span> CCHmac(kCCHmacAlgSHA256, [key bytes], [key length], [data bytes], [data length],<br/>         [hash mutableBytes]);</pre>
<p class="listcap"><a id="ch13ex17"/><em>Listing 13-17: Calculating an HMAC</em></p>
<p class="indent">Note that <a href="ch13.html#ch13ex17">Listing 13-17</a> is simplified to show the basic mechanism; embedding a static key in your source code is not a recommended practice. In most cases, this key should be dynamically generated and stored in the Keychain. The operation is fairly simple. At <span class="ent">➊</span>, the key for the hash is passed in as a UTF-8 encoded string (this is the part that should be stored in the Keychain). At <span class="ent">➋</span>, the data to be hashed is passed in, also as a UTF-8 <a id="page_230"/>string. Then an <code>NSMutableData</code> object is constructed <span class="ent">➌</span> to store the hash for later use and all three components are passed to the <code>CCHmac</code> function at <span class="ent">➍</span>.</p>
<h3 class="h3" id="ch13lev1sec06"><strong>Wrapping CommonCrypto with RNCryptor</strong></h3>
<p class="noindent">If you need to use the encryption functionality exposed by CommonCrypto, RNCryptor is a good framework.<sup><a href="footnote.html#fn117" id="fn_117">9</a></sup> This wraps CommonCrypto and helps perform the most common function needed from it: encrypting data via AES with a user-supplied key. RNCryptor also helps you by providing sane defaults. The basic examples given in the instructions should be sufficient for most usage. See <a href="ch13.html#ch13ex18">Listing 13-18</a> for basic usage.</p>
<pre><span class="violet1">NSData</span> *data = [<span class="red">@"Data"</span> dataUsingEncoding:<span class="violet1">NSUTF8StringEncoding];</span><br/><span class="violet1">NSError *error;</span><br/><span class="violet1">NSData *encryptedData</span> = [RNEncryptor encryptData:data<br/>                                    withSettings:kRNCryptorAES256Settings<br/>                                        password:aPassword<br/>                                           error:&amp;error];</pre>
<p class="listcap"><a id="ch13ex18"/><em>Listing 13-18: Encryption with RNCryptor</em></p>
<p class="indent">Simply pass in your data to the <code>encryptData</code> method, along with a constant specifying the encryption settings you want to use, a key (pulled from the Keychain or from user input), and an <code>NSError</code> object to store the result.</p>
<p class="indent">Decrypting data (<a href="ch13.html#ch13ex19">Listing 13-19</a>) is more or less the inverse of encrypting, except that you do not need to provide the <code>kRNCryptorAES256Settings</code> constant because this is read from the header of the encrypted data.</p>
<pre><span class="violet1">NSData</span> *decryptedData = [RNDecryptor <span class="violet">decryptData</span>:encryptedData<br/>                                    withPassword:aPassword<br/>                                           error:&amp;error];</pre>
<p class="listcap"><a id="ch13ex19"/><em>Listing 13-19: Decrypting RNCryptor-encrypted data</em></p>
<p class="indent">Encrypting streams or larger amounts of data while keeping memory usage sane is slightly more involved (see <em><a href="https://github.com/rnapier/RNCryptor">https://github.com/rnapier/RNCryptor</a></em> for current examples), but the examples shown here cover the most common use case you’ll likely encounter.</p>
<div class="note">
<p class="notet"><strong>NOTE</strong></p>
<p class="notep"><em>An older version of RNCryptor suffered from a vulnerability</em><sup><a href="footnote.html#fn118" id="fn_118">10</a></sup> <em>that could allow an attacker to manipulate a portion of the decrypted data by altering the ciphertext, so make sure that your code is using the most up-to-date version of RNCryptor.</em></p>
</div>
<h3 class="h3" id="ch13lev1sec07"><a id="page_231"/><strong>Local Authentication: Using the TouchID</strong></h3>
<p class="noindent">In iOS 8, Apple opened up the Local Authentication API so that third-party apps could use the fingerprint reader as an authenticator. The Local Authentication API is used by instantiating the <code>LAContext</code> class and passing it an authentication policy to evaluate; currently, only one policy is available, which is to identify the owner biometrically. <a href="ch13.html#ch13ex20">Listing 13-20</a> shows this process in detail. Note that using this API doesn’t give developers access to the fingerprint—it just gives a success or failure from the reader hardware.</p>
<pre><span class="ent">➊</span> LAContext *context = [[LAContext <span class="violet">alloc</span>] <span class="violet">init</span>];<br/><span class="ent">➋</span> <span class="violet1">NSError</span> *error = nil;<br/><span class="ent">➌</span> <span class="violet1">NSString</span> *reason = <span class="red">@"We use this to verify your identity"</span>;<br/><br/><span class="ent">➍</span> <span class="rose">if</span> ([context canEvaluatePolicy:LAPolicyDeviceOwnerAuthenticationWithBiometrics<br/>       error:&amp;error]) {<br/><span class="ent">➎</span>     [context evaluatePolicy:LAPolicyDeviceOwnerAuthenticationWithBiometrics<br/>              localizedReason:reason<br/>                        reply:^(<span class="rose">BOOL</span> success, <span class="violet1">NSError</span> *error) {<br/>                          <span class="rose">if</span> (success) {<br/><span class="ent">➏</span>                             <span class="violet1">NSLog</span>(<span class="red">@"Hooray, that's your finger!"</span><span class="violet1">);</span><br/>                          } <span class="rose">else</span> {<br/><span class="ent">➐</span>                 <span class="violet1">NSLog</span>(<span class="red">@"Couldn't read your fingerprint. Falling back to PIN or</span><br/>       <span class="red">something."</span><span class="violet1">);</span><br/>              }<br/>          }];<br/>   } <span class="rose">else</span> {<br/>       <span class="green1"><span class="codeitalic">// Something went wrong. Maybe the policy can't be evaluated because the</span></span><br/>       <span class="green1"><span class="codeitalic">// device doesn't have a fingerprint reader.</span></span><br/><span class="ent">➑</span>     <span class="violet1">NSLog(</span><span class="red">@"Error: %@ %@"</span><span class="violet1">,</span> error, [error userInfo]);<br/>   }</pre>
<p class="listcap"><a id="ch13ex20"/><em>Listing 13-20: Authenticating the user via a fingerprint</em></p>
<p class="indent">First, this code creates an <code>LAContext</code> object <span class="ent">➊</span> and an <code>NSError</code> object <span class="ent">➋</span> to contain the results of the operation. There also needs to be a reason to present to the user when the UI asks for their fingerprint <span class="ent">➌</span>. After creating these things, the code checks whether it can evaluate the <code>LAPolicyDeviceOwnerAuthenticationWithBiometrics</code> policy at <span class="ent">➍</span>.</p>
<p class="indent">If evaluation is possible, then the policy is evaluated <span class="ent">➎</span>; the reason and a block to handle the results of the evaluation are also passed to the <code>evaluatePolicy</code> method. If the fingerprint authenticates successfully, you can have the application allow whatever action it’s performing to continue <span class="ent">➏</span>. If the fingerprint is invalid, then depending on how you choose to write your application, it can fall back to a different method of authentication or authentication can fail entirely <span class="ent">➐</span>.</p>
<p class="indent"><a id="page_232"/>If the call to <code>canEvaluatePolicy</code> at <span class="ent">➍</span> fails, then the execution ends up at <span class="ent">➑</span>. This is most likely to happen if the user’s device doesn’t support the finger-print reader, fingerprint functionality has been disabled, or no fingerprints have been enrolled.</p>
<h4 class="h4" id="ch13lev2sec14"><em><strong>How Safe Are Fingerprints?</strong></em></h4>
<p class="noindent">As with most other forms of biometric authentication, fingerprint authentication is an imperfect approach. It’s convenient, but given that you leave your fingerprints all over the place, it’s not difficult to re-create a mold that would effectively simulate your finger. In the United States, law enforcement is legally allowed to use fingerprints to unlock devices, whereas they cannot compel someone to divulge their passcode.</p>
<p class="indent">There are a couple of things that developers can do to address these shortcomings. The most obvious is to provide the user with an option to use a PIN instead of using the TouchID, or perhaps in addition to the TouchID. Another thing that can help mitigate fingerprint cloning attacks is to implement a system similar to the one that Apple uses to handle the lock screen: after three unsuccessful attempts, revert to a PIN or require the user’s password. Because successfully getting a cloned fingerprint is an unreliable process, this may help prevent a successful fraudulent fingerprint authentication.</p>
<h3 class="h3" id="ch13lev1sec08"><strong>Closing Thoughts</strong></h3>
<p class="noindent">Encryption and authentication features aren’t always the most straightforward to use, but given the importance of user data privacy, both from a legal and reputational standpoint, correct deployment of these features is crucial. This chapter should have given you a reasonable idea of the strategies you might encounter or need to deploy. Protecting user privacy is a broader topic than just encryption, though—you’ll be turning your attention to that in the next chapter.</p>
</body></html>